ECMAScript® 2026 Language Specification
Toggle shortcuts help
?
Toggle "can call user code" annotations
u
Navigate to/from multipage
m
Jump to search box
/
Toggle pinning of the current clause
p
Jump to the
n
th
pin
1-9
Jump to the 10
th
pin
0
Jump to the most recent link target
`
Menu
Pins
clear
Table of Contents
Introduction
1
Scope
+
2
Conformance
2.1
Example Normative Optional Clause Heading
2.2
Example Legacy Clause Heading
2.3
Example Legacy Normative Optional Clause Heading
3
Normative References
+
4
Overview
4.1
Web Scripting
4.2
Hosts and Implementations
+
4.3
ECMAScript Overview
4.3.1
Objects
4.3.2
The Strict Variant of ECMAScript
+
4.4
Terms and Definitions
4.4.1
implementation-approximated
4.4.2
implementation-defined
4.4.3
host-defined
4.4.4
type
4.4.5
primitive value
4.4.6
object
4.4.7
constructor
4.4.8
prototype
4.4.9
ordinary object
4.4.10
exotic object
4.4.11
standard object
4.4.12
built-in object
4.4.13
undefined value
4.4.14
Undefined type
4.4.15
null value
4.4.16
Null type
4.4.17
Boolean value
4.4.18
Boolean type
4.4.19
Boolean object
4.4.20
String value
4.4.21
String type
4.4.22
String object
4.4.23
Number value
4.4.24
Number type
4.4.25
Number object
4.4.26
Infinity
4.4.27
NaN
4.4.28
BigInt value
4.4.29
BigInt type
4.4.30
BigInt object
4.4.31
Symbol value
4.4.32
Symbol type
4.4.33
Symbol object
4.4.34
function
4.4.35
built-in function
4.4.36
built-in constructor
4.4.37
property
4.4.38
method
4.4.39
built-in method
4.4.40
attribute
4.4.41
own property
4.4.42
inherited property
4.5
Organization of This Specification
+
5
Notational Conventions
+
5.1
Syntactic and Lexical Grammars
5.1.1
Context-Free Grammars
5.1.2
The Lexical and RegExp Grammars
5.1.3
The Numeric String Grammar
5.1.4
The Syntactic Grammar
+
5.1.5
Grammar Notation
5.1.5.1
Terminal Symbols
5.1.5.2
Nonterminal Symbols and Productions
5.1.5.3
Optional Symbols
5.1.5.4
Grammatical Parameters
5.1.5.5
one of
5.1.5.6
[empty]
5.1.5.7
Lookahead Restrictions
5.1.5.8
[no
LineTerminator
here]
5.1.5.9
but not
5.1.5.10
Descriptive Phrases
+
5.2
Algorithm Conventions
5.2.1
Evaluation Order
5.2.2
Abstract Operations
5.2.3
Syntax-Directed Operations
+
5.2.4
Runtime Semantics
5.2.4.1
Completion (
completionRecord
)
5.2.4.2
Throw an Exception
5.2.4.3
Shorthands for Unwrapping Completion Records
5.2.4.4
Implicit Normal Completion
5.2.5
Static Semantics
5.2.6
Mathematical Operations
5.2.7
Value Notation
5.2.8
Identity
+
6
ECMAScript Data Types and Values
+
6.1
ECMAScript Language Types
6.1.1
The Undefined Type
6.1.2
The Null Type
6.1.3
The Boolean Type
+
6.1.4
The String Type
6.1.4.1
StringIndexOf (
string
,
searchValue
,
fromIndex
)
6.1.4.2
StringLastIndexOf (
string
,
searchValue
,
fromIndex
)
+
6.1.5
The Symbol Type
6.1.5.1
Well-Known Symbols
+
6.1.6
Numeric Types
+
6.1.6.1
The Number Type
6.1.6.1.1
Number::unaryMinus (
x
)
6.1.6.1.2
Number::bitwiseNOT (
x
)
6.1.6.1.3
Number::exponentiate (
base
,
exponent
)
6.1.6.1.4
Number::multiply (
x
,
y
)
6.1.6.1.5
Number::divide (
x
,
y
)
6.1.6.1.6
Number::remainder (
n
,
d
)
6.1.6.1.7
Number::add (
x
,
y
)
6.1.6.1.8
Number::subtract (
x
,
y
)
6.1.6.1.9
Number::leftShift (
x
,
y
)
6.1.6.1.10
Number::signedRightShift (
x
,
y
)
6.1.6.1.11
Number::unsignedRightShift (
x
,
y
)
6.1.6.1.12
Number::lessThan (
x
,
y
)
6.1.6.1.13
Number::equal (
x
,
y
)
6.1.6.1.14
Number::sameValue (
x
,
y
)
6.1.6.1.15
Number::sameValueZero (
x
,
y
)
6.1.6.1.16
NumberBitwiseOp (
op
,
x
,
y
)
6.1.6.1.17
Number::bitwiseAND (
x
,
y
)
6.1.6.1.18
Number::bitwiseXOR (
x
,
y
)
6.1.6.1.19
Number::bitwiseOR (
x
,
y
)
6.1.6.1.20
Number::toString (
x
,
radix
)
+
6.1.6.2
The BigInt Type
6.1.6.2.1
BigInt::unaryMinus (
x
)
6.1.6.2.2
BigInt::bitwiseNOT (
x
)
6.1.6.2.3
BigInt::exponentiate (
base
,
exponent
)
6.1.6.2.4
BigInt::multiply (
x
,
y
)
6.1.6.2.5
BigInt::divide (
x
,
y
)
6.1.6.2.6
BigInt::remainder (
n
,
d
)
6.1.6.2.7
BigInt::add (
x
,
y
)
6.1.6.2.8
BigInt::subtract (
x
,
y
)
6.1.6.2.9
BigInt::leftShift (
x
,
y
)
6.1.6.2.10
BigInt::signedRightShift (
x
,
y
)
6.1.6.2.11
BigInt::unsignedRightShift (
x
,
y
)
6.1.6.2.12
BigInt::lessThan (
x
,
y
)
6.1.6.2.13
BigInt::equal (
x
,
y
)
6.1.6.2.14
BinaryAnd (
x
,
y
)
6.1.6.2.15
BinaryOr (
x
,
y
)
6.1.6.2.16
BinaryXor (
x
,
y
)
6.1.6.2.17
BigIntBitwiseOp (
op
,
x
,
y
)
6.1.6.2.18
BigInt::bitwiseAND (
x
,
y
)
6.1.6.2.19
BigInt::bitwiseXOR (
x
,
y
)
6.1.6.2.20
BigInt::bitwiseOR (
x
,
y
)
6.1.6.2.21
BigInt::toString (
x
,
radix
)
+
6.1.7
The Object Type
6.1.7.1
Property Attributes
6.1.7.2
Object Internal Methods and Internal Slots
6.1.7.3
Invariants of the Essential Internal Methods
6.1.7.4
Well-Known Intrinsic Objects
+
6.2
ECMAScript Specification Types
6.2.1
The Enum Specification Type
6.2.2
The List and Record Specification Types
6.2.3
The Set and Relation Specification Types
+
6.2.4
The Completion Record Specification Type
6.2.4.1
NormalCompletion (
value
)
6.2.4.2
ThrowCompletion (
value
)
6.2.4.3
ReturnCompletion (
value
)
6.2.4.4
UpdateEmpty (
completionRecord
,
value
)
+
6.2.5
The Reference Record Specification Type
6.2.5.1
IsPropertyReference (
V
)
6.2.5.2
IsUnresolvableReference (
V
)
6.2.5.3
IsSuperReference (
V
)
6.2.5.4
IsPrivateReference (
V
)
6.2.5.5
GetValue (
V
)
6.2.5.6
PutValue (
V
,
W
)
6.2.5.7
GetThisValue (
V
)
6.2.5.8
InitializeReferencedBinding (
V
,
W
)
6.2.5.9
MakePrivateReference (
baseValue
,
privateIdentifier
)
+
6.2.6
The Property Descriptor Specification Type
6.2.6.1
IsAccessorDescriptor (
Desc
)
6.2.6.2
IsDataDescriptor (
Desc
)
6.2.6.3
IsGenericDescriptor (
Desc
)
6.2.6.4
FromPropertyDescriptor (
Desc
)
6.2.6.5
ToPropertyDescriptor (
Obj
)
6.2.6.6
CompletePropertyDescriptor (
Desc
)
6.2.7
The Environment Record Specification Type
6.2.8
The Abstract Closure Specification Type
+
6.2.9
Data Blocks
6.2.9.1
CreateByteDataBlock (
size
)
6.2.9.2
CreateSharedByteDataBlock (
size
)
6.2.9.3
CopyDataBlockBytes (
toBlock
,
toIndex
,
fromBlock
,
fromIndex
,
count
)
6.2.10
The PrivateElement Specification Type
6.2.11
The ClassFieldDefinition Record Specification Type
6.2.12
Private Names
6.2.13
The ClassStaticBlockDefinition Record Specification Type
+
7
Abstract Operations
+
7.1
Type Conversion
+
7.1.1
ToPrimitive (
input
[ ,
preferredType
] )
7.1.1.1
OrdinaryToPrimitive (
O
,
hint
)
7.1.2
ToBoolean (
argument
)
7.1.3
ToNumeric (
value
)
+
7.1.4
ToNumber (
argument
)
+
7.1.4.1
ToNumber Applied to the String Type
7.1.4.1.1
StringToNumber (
str
)
7.1.4.1.2
RS: StringNumericValue
7.1.4.1.3
RoundMVResult (
n
)
7.1.5
ToIntegerOrInfinity (
argument
)
7.1.6
ToInt32 (
argument
)
7.1.7
ToUint32 (
argument
)
7.1.8
ToInt16 (
argument
)
7.1.9
ToUint16 (
argument
)
7.1.10
ToInt8 (
argument
)
7.1.11
ToUint8 (
argument
)
7.1.12
ToUint8Clamp (
argument
)
7.1.13
ToBigInt (
argument
)
+
7.1.14
StringToBigInt (
str
)
7.1.14.1
StringIntegerLiteral Grammar
7.1.14.2
RS: MV
7.1.15
ToBigInt64 (
argument
)
7.1.16
ToBigUint64 (
argument
)
7.1.17
ToString (
argument
)
7.1.18
ToObject (
argument
)
7.1.19
ToPropertyKey (
argument
)
7.1.20
ToLength (
argument
)
7.1.21
CanonicalNumericIndexString (
argument
)
7.1.22
ToIndex (
value
)
+
7.2
Testing and Comparison Operations
7.2.1
RequireObjectCoercible (
argument
)
7.2.2
IsArray (
argument
)
7.2.3
IsCallable (
argument
)
7.2.4
IsConstructor (
argument
)
7.2.5
IsExtensible (
O
)
7.2.6
IsRegExp (
argument
)
7.2.7
SS: IsStringWellFormedUnicode (
string
)
7.2.8
SameType (
x
,
y
)
7.2.9
SameValue (
x
,
y
)
7.2.10
SameValueZero (
x
,
y
)
7.2.11
SameValueNonNumber (
x
,
y
)
7.2.12
IsLessThan (
x
,
y
,
LeftFirst
)
7.2.13
IsLooselyEqual (
x
,
y
)
7.2.14
IsStrictlyEqual (
x
,
y
)
+
7.3
Operations on Objects
7.3.1
MakeBasicObject (
internalSlotsList
)
7.3.2
Get (
O
,
P
)
7.3.3
GetV (
V
,
P
)
7.3.4
Set (
O
,
P
,
V
,
Throw
)
7.3.5
CreateDataProperty (
O
,
P
,
V
)
7.3.6
CreateDataPropertyOrThrow (
O
,
P
,
V
)
7.3.7
CreateNonEnumerableDataPropertyOrThrow (
O
,
P
,
V
)
7.3.8
DefinePropertyOrThrow (
O
,
P
,
desc
)
7.3.9
DeletePropertyOrThrow (
O
,
P
)
7.3.10
GetMethod (
V
,
P
)
7.3.11
HasProperty (
O
,
P
)
7.3.12
HasOwnProperty (
O
,
P
)
7.3.13
Call (
F
,
V
[ ,
argumentsList
] )
7.3.14
Construct (
F
[ ,
argumentsList
[ ,
newTarget
] ] )
7.3.15
SetIntegrityLevel (
O
,
level
)
7.3.16
TestIntegrityLevel (
O
,
level
)
7.3.17
CreateArrayFromList (
elements
)
7.3.18
LengthOfArrayLike (
obj
)
7.3.19
CreateListFromArrayLike (
obj
[ ,
validElementTypes
] )
7.3.20
Invoke (
V
,
P
[ ,
argumentsList
] )
7.3.21
OrdinaryHasInstance (
C
,
O
)
7.3.22
SpeciesConstructor (
O
,
defaultConstructor
)
7.3.23
EnumerableOwnProperties (
O
,
kind
)
7.3.24
GetFunctionRealm (
obj
)
7.3.25
CopyDataProperties (
target
,
source
,
excludedItems
)
7.3.26
PrivateElementFind (
O
,
P
)
7.3.27
PrivateFieldAdd (
O
,
P
,
value
)
7.3.28
PrivateMethodOrAccessorAdd (
O
,
method
)
7.3.29
HostEnsureCanAddPrivateElement (
O
)
7.3.30
PrivateGet (
O
,
P
)
7.3.31
PrivateSet (
O
,
P
,
value
)
7.3.32
DefineField (
receiver
,
fieldRecord
)
7.3.33
InitializeInstanceElements (
O
,
constructor
)
7.3.34
AddValueToKeyedGroup (
groups
,
key
,
value
)
7.3.35
GroupBy (
items
,
callback
,
keyCoercion
)
7.3.36
GetOptionsObject (
options
)
7.3.37
SetterThatIgnoresPrototypeProperties (
thisValue
,
home
,
p
,
v
)
+
7.4
Operations on Iterator Objects
7.4.1
Iterator Records
7.4.2
GetIteratorDirect (
obj
)
7.4.3
GetIteratorFromMethod (
obj
,
method
)
7.4.4
GetIterator (
obj
,
kind
)
7.4.5
GetIteratorFlattenable (
obj
,
primitiveHandling
)
7.4.6
IteratorNext (
iteratorRecord
[ ,
value
] )
7.4.7
IteratorComplete (
iteratorResult
)
7.4.8
IteratorValue (
iteratorResult
)
7.4.9
IteratorStep (
iteratorRecord
)
7.4.10
IteratorStepValue (
iteratorRecord
)
7.4.11
IteratorClose (
iteratorRecord
,
completion
)
7.4.12
IteratorCloseAll (
iters
,
completion
)
7.4.13
IfAbruptCloseIterator (
value
,
iteratorRecord
)
7.4.14
AsyncIteratorClose (
iteratorRecord
,
completion
)
7.4.15
IfAbruptCloseAsyncIterator (
value
,
iteratorRecord
)
7.4.16
CreateIteratorResultObject (
value
,
done
)
7.4.17
CreateListIteratorRecord (
list
)
7.4.18
IteratorToList (
iteratorRecord
)
+
8
Syntax-Directed Operations
8.1
RS: Evaluation
+
8.2
Scope Analysis
8.2.1
SS: BoundNames
8.2.2
SS: DeclarationPart
8.2.3
SS: IsConstantDeclaration
8.2.4
SS: LexicallyDeclaredNames
8.2.5
SS: LexicallyScopedDeclarations
8.2.6
SS: VarDeclaredNames
8.2.7
SS: VarScopedDeclarations
8.2.8
SS: TopLevelLexicallyDeclaredNames
8.2.9
SS: TopLevelLexicallyScopedDeclarations
8.2.10
SS: TopLevelVarDeclaredNames
8.2.11
SS: TopLevelVarScopedDeclarations
+
8.3
Labels
8.3.1
SS: ContainsDuplicateLabels
8.3.2
SS: ContainsUndefinedBreakTarget
8.3.3
SS: ContainsUndefinedContinueTarget
+
8.4
Function Name Inference
8.4.1
SS: HasName
8.4.2
SS: IsFunctionDefinition
8.4.3
SS: IsAnonymousFunctionDefinition (
expr
)
8.4.4
SS: IsIdentifierRef
8.4.5
RS: NamedEvaluation
+
8.5
Contains
8.5.1
SS: Contains
8.5.2
SS: ComputedPropertyContains
+
8.6
Miscellaneous
8.6.1
RS: InstantiateFunctionObject
+
8.6.2
RS: BindingInitialization
8.6.2.1
InitializeBoundName (
name
,
value
,
environment
)
8.6.3
RS: IteratorBindingInitialization
8.6.4
SS: AssignmentTargetType
8.6.5
SS: PropName
+
9
Executable Code and Execution Contexts
+
9.1
Environment Records
+
9.1.1
The Environment Record Type Hierarchy
+
9.1.1.1
Declarative Environment Records
9.1.1.1.1
HasBinding (
N
)
9.1.1.1.2
CreateMutableBinding (
N
,
D
)
9.1.1.1.3
CreateImmutableBinding (
N
,
S
)
9.1.1.1.4
InitializeBinding (
N
,
V
)
9.1.1.1.5
SetMutableBinding (
N
,
V
,
S
)
9.1.1.1.6
GetBindingValue (
N
,
S
)
9.1.1.1.7
DeleteBinding (
N
)
9.1.1.1.8
HasThisBinding ( )
9.1.1.1.9
GetThisBinding ( )
9.1.1.1.10
HasSuperBinding ( )
9.1.1.1.11
WithBaseObject ( )
+
9.1.1.2
Object Environment Records
9.1.1.2.1
HasBinding (
N
)
9.1.1.2.2
CreateMutableBinding (
N
,
D
)
9.1.1.2.3
CreateImmutableBinding (
N
,
S
)
9.1.1.2.4
InitializeBinding (
N
,
V
)
9.1.1.2.5
SetMutableBinding (
N
,
V
,
S
)
9.1.1.2.6
GetBindingValue (
N
,
S
)
9.1.1.2.7
DeleteBinding (
N
)
9.1.1.2.8
HasThisBinding ( )
9.1.1.2.9
GetThisBinding ( )
9.1.1.2.10
HasSuperBinding ( )
9.1.1.2.11
WithBaseObject ( )
+
9.1.1.3
Function Environment Records
9.1.1.3.1
BindThisValue (
envRec
,
V
)
9.1.1.3.2
HasThisBinding ( )
9.1.1.3.3
GetThisBinding ( )
9.1.1.3.4
HasSuperBinding ( )
9.1.1.3.5
GetSuperBase (
envRec
)
+
9.1.1.4
Global Environment Records
9.1.1.4.1
HasBinding (
N
)
9.1.1.4.2
CreateMutableBinding (
N
,
D
)
9.1.1.4.3
CreateImmutableBinding (
N
,
S
)
9.1.1.4.4
InitializeBinding (
N
,
V
)
9.1.1.4.5
SetMutableBinding (
N
,
V
,
S
)
9.1.1.4.6
GetBindingValue (
N
,
S
)
9.1.1.4.7
DeleteBinding (
N
)
9.1.1.4.8
HasThisBinding ( )
9.1.1.4.9
GetThisBinding ( )
9.1.1.4.10
HasSuperBinding ( )
9.1.1.4.11
WithBaseObject ( )
9.1.1.4.12
HasLexicalDeclaration (
envRec
,
N
)
9.1.1.4.13
HasRestrictedGlobalProperty (
envRec
,
N
)
9.1.1.4.14
CanDeclareGlobalVar (
envRec
,
N
)
9.1.1.4.15
CanDeclareGlobalFunction (
envRec
,
N
)
9.1.1.4.16
CreateGlobalVarBinding (
envRec
,
N
,
D
)
9.1.1.4.17
CreateGlobalFunctionBinding (
envRec
,
N
,
V
,
D
)
+
9.1.1.5
Module Environment Records
9.1.1.5.1
GetBindingValue (
N
,
S
)
9.1.1.5.2
DeleteBinding (
N
)
9.1.1.5.3
HasThisBinding ( )
9.1.1.5.4
GetThisBinding ( )
9.1.1.5.5
CreateImportBinding (
envRec
,
N
,
M
,
N2
)
+
9.1.2
Environment Record Operations
9.1.2.1
GetIdentifierReference (
env
,
name
,
strict
)
9.1.2.2
NewDeclarativeEnvironment (
E
)
9.1.2.3
NewObjectEnvironment (
O
,
W
,
E
)
9.1.2.4
NewFunctionEnvironment (
F
,
newTarget
)
9.1.2.5
NewGlobalEnvironment (
G
,
thisValue
)
9.1.2.6
NewModuleEnvironment (
E
)
+
9.2
PrivateEnvironment Records
+
9.2.1
PrivateEnvironment Record Operations
9.2.1.1
NewPrivateEnvironment (
outerPrivateEnv
)
9.2.1.2
ResolvePrivateIdentifier (
privateEnv
,
identifier
)
+
9.3
Realms
9.3.1
InitializeHostDefinedRealm ( )
9.3.2
CreateIntrinsics (
realmRec
)
9.3.3
SetDefaultGlobalBindings (
realmRec
)
+
9.4
Execution Contexts
9.4.1
GetActiveScriptOrModule ( )
9.4.2
ResolveBinding (
name
[ ,
env
] )
9.4.3
GetThisEnvironment ( )
9.4.4
ResolveThisBinding ( )
9.4.5
GetNewTarget ( )
9.4.6
GetGlobalObject ( )
+
9.5
Jobs and Host Operations to Enqueue Jobs
9.5.1
JobCallback Records
9.5.2
HostMakeJobCallback (
callback
)
9.5.3
HostCallJobCallback (
jobCallback
,
V
,
argumentsList
)
9.5.4
HostEnqueueGenericJob (
job
,
realm
)
9.5.5
HostEnqueuePromiseJob (
job
,
realm
)
9.5.6
HostEnqueueTimeoutJob (
timeoutJob
,
realm
,
milliseconds
)
+
9.6
Agents
9.6.1
AgentSignifier ( )
9.6.2
AgentCanSuspend ( )
9.6.3
IncrementModuleAsyncEvaluationCount ( )
9.7
Agent Clusters
9.8
Forward Progress
+
9.9
Processing Model of WeakRef and FinalizationRegistry Targets
9.9.1
Objectives
9.9.2
Liveness
9.9.3
Execution
+
9.9.4
Host Hooks
9.9.4.1
HostEnqueueFinalizationRegistryCleanupJob (
finalizationRegistry
)
9.10
ClearKeptObjects ( )
9.11
AddToKeptObjects (
value
)
9.12
CleanupFinalizationRegistry (
finalizationRegistry
)
9.13
CanBeHeldWeakly (
v
)
+
10
Ordinary and Exotic Objects Behaviours
+
10.1
Ordinary Object Internal Methods and Internal Slots
+
10.1.1
[[GetPrototypeOf]]
( )
10.1.1.1
OrdinaryGetPrototypeOf (
O
)
+
10.1.2
[[SetPrototypeOf]]
(
V
)
10.1.2.1
OrdinarySetPrototypeOf (
O
,
V
)
+
10.1.3
[[IsExtensible]]
( )
10.1.3.1
OrdinaryIsExtensible (
O
)
+
10.1.4
[[PreventExtensions]]
( )
10.1.4.1
OrdinaryPreventExtensions (
O
)
+
10.1.5
[[GetOwnProperty]]
(
P
)
10.1.5.1
OrdinaryGetOwnProperty (
O
,
P
)
+
10.1.6
[[DefineOwnProperty]]
(
P
,
Desc
)
10.1.6.1
OrdinaryDefineOwnProperty (
O
,
P
,
Desc
)
10.1.6.2
IsCompatiblePropertyDescriptor (
Extensible
,
Desc
,
Current
)
10.1.6.3
ValidateAndApplyPropertyDescriptor (
O
,
P
,
extensible
,
Desc
,
current
)
+
10.1.7
[[HasProperty]]
(
P
)
10.1.7.1
OrdinaryHasProperty (
O
,
P
)
+
10.1.8
[[Get]]
(
P
,
Receiver
)
10.1.8.1
OrdinaryGet (
O
,
P
,
Receiver
)
+
10.1.9
[[Set]]
(
P
,
V
,
Receiver
)
10.1.9.1
OrdinarySet (
O
,
P
,
V
,
Receiver
)
10.1.9.2
OrdinarySetWithOwnDescriptor (
O
,
P
,
V
,
Receiver
,
ownDesc
)
+
10.1.10
[[Delete]]
(
P
)
10.1.10.1
OrdinaryDelete (
O
,
P
)
+
10.1.11
[[OwnPropertyKeys]]
( )
10.1.11.1
OrdinaryOwnPropertyKeys (
O
)
10.1.12
OrdinaryObjectCreate (
proto
[ ,
additionalInternalSlotsList
] )
10.1.13
OrdinaryCreateFromConstructor (
constructor
,
intrinsicDefaultProto
[ ,
internalSlotsList
] )
10.1.14
GetPrototypeFromConstructor (
constructor
,
intrinsicDefaultProto
)
10.1.15
RequireInternalSlot (
O
,
internalSlot
)
+
10.2
ECMAScript Function Objects
+
10.2.1
[[Call]]
(
thisArgument
,
argumentsList
)
10.2.1.1
PrepareForOrdinaryCall (
F
,
newTarget
)
10.2.1.2
OrdinaryCallBindThis (
F
,
calleeContext
,
thisArgument
)
10.2.1.3
RS: EvaluateBody
10.2.1.4
OrdinaryCallEvaluateBody (
F
,
argumentsList
)
10.2.2
[[Construct]]
(
argumentsList
,
newTarget
)
10.2.3
OrdinaryFunctionCreate (
functionPrototype
,
sourceText
,
ParameterList
,
Body
,
thisMode
,
env
,
privateEnv
)
+
10.2.4
AddRestrictedFunctionProperties (
F
,
realm
)
10.2.4.1
%ThrowTypeError% ( )
10.2.5
MakeConstructor (
F
[ ,
writablePrototype
[ ,
prototype
] ] )
10.2.6
MakeClassConstructor (
F
)
10.2.7
MakeMethod (
F
,
homeObject
)
10.2.8
DefineMethodProperty (
homeObject
,
key
,
closure
,
enumerable
)
10.2.9
SetFunctionName (
F
,
name
[ ,
prefix
] )
10.2.10
SetFunctionLength (
F
,
length
)
10.2.11
FunctionDeclarationInstantiation (
func
,
argumentsList
)
+
10.3
Built-in Function Objects
10.3.1
[[Call]]
(
thisArgument
,
argumentsList
)
10.3.2
[[Construct]]
(
argumentsList
,
newTarget
)
10.3.3
BuiltinCallOrConstruct (
F
,
thisArgument
,
argumentsList
,
newTarget
)
10.3.4
CreateBuiltinFunction (
behaviour
,
length
,
name
,
additionalInternalSlotsList
[ ,
realm
[ ,
prototype
[ ,
prefix
[ ,
async
] ] ] ] )
+
10.4
Built-in Exotic Object Internal Methods and Slots
+
10.4.1
Bound Function Exotic Objects
10.4.1.1
[[Call]]
(
thisArgument
,
argumentsList
)
10.4.1.2
[[Construct]]
(
argumentsList
,
newTarget
)
10.4.1.3
BoundFunctionCreate (
targetFunction
,
boundThis
,
boundArgs
)
+
10.4.2
Array Exotic Objects
10.4.2.1
[[DefineOwnProperty]]
(
P
,
Desc
)
10.4.2.2
ArrayCreate (
length
[ ,
proto
] )
10.4.2.3
ArraySpeciesCreate (
originalArray
,
length
)
10.4.2.4
ArraySetLength (
A
,
Desc
)
+
10.4.3
String Exotic Objects
10.4.3.1
[[GetOwnProperty]]
(
P
)
10.4.3.2
[[DefineOwnProperty]]
(
P
,
Desc
)
10.4.3.3
[[OwnPropertyKeys]]
( )
10.4.3.4
StringCreate (
value
,
prototype
)
10.4.3.5
StringGetOwnProperty (
S
,
P
)
+
10.4.4
Arguments Exotic Objects
10.4.4.1
[[GetOwnProperty]]
(
P
)
10.4.4.2
[[DefineOwnProperty]]
(
P
,
Desc
)
10.4.4.3
[[Get]]
(
P
,
Receiver
)
10.4.4.4
[[Set]]
(
P
,
V
,
Receiver
)
10.4.4.5
[[Delete]]
(
P
)
10.4.4.6
CreateUnmappedArgumentsObject (
argumentsList
)
+
10.4.4.7
CreateMappedArgumentsObject (
func
,
formals
,
argumentsList
,
env
)
10.4.4.7.1
MakeArgGetter (
name
,
env
)
10.4.4.7.2
MakeArgSetter (
name
,
env
)
+
10.4.5
TypedArray Exotic Objects
10.4.5.1
[[PreventExtensions]]
( )
10.4.5.2
[[GetOwnProperty]]
(
P
)
10.4.5.3
[[HasProperty]]
(
P
)
10.4.5.4
[[DefineOwnProperty]]
(
P
,
Desc
)
10.4.5.5
[[Get]]
(
P
,
Receiver
)
10.4.5.6
[[Set]]
(
P
,
V
,
Receiver
)
10.4.5.7
[[Delete]]
(
P
)
10.4.5.8
[[OwnPropertyKeys]]
( )
10.4.5.9
TypedArray With Buffer Witness Records
10.4.5.10
MakeTypedArrayWithBufferWitnessRecord (
obj
,
order
)
10.4.5.11
TypedArrayCreate (
prototype
)
10.4.5.12
TypedArrayByteLength (
taRecord
)
10.4.5.13
TypedArrayLength (
taRecord
)
10.4.5.14
IsTypedArrayOutOfBounds (
taRecord
)
10.4.5.15
IsTypedArrayFixedLength (
O
)
10.4.5.16
IsValidIntegerIndex (
O
,
index
)
10.4.5.17
TypedArrayGetElement (
O
,
index
)
10.4.5.18
TypedArraySetElement (
O
,
index
,
value
)
10.4.5.19
IsArrayBufferViewOutOfBounds (
O
)
+
10.4.6
Module Namespace Exotic Objects
10.4.6.1
[[GetPrototypeOf]]
( )
10.4.6.2
[[SetPrototypeOf]]
(
V
)
10.4.6.3
[[IsExtensible]]
( )
10.4.6.4
[[PreventExtensions]]
( )
10.4.6.5
[[GetOwnProperty]]
(
P
)
10.4.6.6
[[DefineOwnProperty]]
(
P
,
Desc
)
10.4.6.7
[[HasProperty]]
(
P
)
10.4.6.8
[[Get]]
(
P
,
Receiver
)
10.4.6.9
[[Set]]
(
P
,
V
,
Receiver
)
10.4.6.10
[[Delete]]
(
P
)
10.4.6.11
[[OwnPropertyKeys]]
( )
10.4.6.12
ModuleNamespaceCreate (
module
,
exports
)
+
10.4.7
Immutable Prototype Exotic Objects
10.4.7.1
[[SetPrototypeOf]]
(
V
)
10.4.7.2
SetImmutablePrototype (
O
,
V
)
+
10.5
Proxy Object Internal Methods and Internal Slots
10.5.1
[[GetPrototypeOf]]
( )
10.5.2
[[SetPrototypeOf]]
(
V
)
10.5.3
[[IsExtensible]]
( )
10.5.4
[[PreventExtensions]]
( )
10.5.5
[[GetOwnProperty]]
(
P
)
10.5.6
[[DefineOwnProperty]]
(
P
,
Desc
)
10.5.7
[[HasProperty]]
(
P
)
10.5.8
[[Get]]
(
P
,
Receiver
)
10.5.9
[[Set]]
(
P
,
V
,
Receiver
)
10.5.10
[[Delete]]
(
P
)
10.5.11
[[OwnPropertyKeys]]
( )
10.5.12
[[Call]]
(
thisArgument
,
argumentsList
)
10.5.13
[[Construct]]
(
argumentsList
,
newTarget
)
10.5.14
ValidateNonRevokedProxy (
proxy
)
10.5.15
ProxyCreate (
target
,
handler
)
+
11
ECMAScript Language: Source Text
+
11.1
Source Text
11.1.1
SS: UTF16EncodeCodePoint (
cp
)
11.1.2
SS: CodePointsToString (
text
)
11.1.3
SS: UTF16SurrogatePairToCodePoint (
lead
,
trail
)
11.1.4
SS: CodePointAt (
string
,
position
)
11.1.5
SS: StringToCodePoints (
string
)
11.1.6
SS: ParseText (
sourceText
,
goalSymbol
)
+
11.2
Types of Source Code
11.2.1
Directive Prologues and the Use Strict Directive
+
11.2.2
Strict Mode Code
11.2.2.1
SS: IsStrict (
node
)
11.2.3
Non-ECMAScript Functions
+
12
ECMAScript Language: Lexical Grammar
12.1
Unicode Format-Control Characters
12.2
White Space
12.3
Line Terminators
12.4
Comments
12.5
Hashbang Comments
12.6
Tokens
+
12.7
Names and Keywords
+
12.7.1
Identifier Names
12.7.1.1
SS: Early Errors
12.7.1.2
SS: IdentifierCodePoints
12.7.1.3
SS: IdentifierCodePoint
12.7.2
Keywords and Reserved Words
12.8
Punctuators
+
12.9
Literals
12.9.1
Null Literals
12.9.2
Boolean Literals
+
12.9.3
Numeric Literals
12.9.3.1
SS: Early Errors
12.9.3.2
SS: MV
12.9.3.3
SS: NumericValue
+
12.9.4
String Literals
12.9.4.1
SS: Early Errors
12.9.4.2
SS: SV
12.9.4.3
SS: MV
+
12.9.5
Regular Expression Literals
12.9.5.1
SS: BodyText
12.9.5.2
SS: FlagText
+
12.9.6
Template Literal Lexical Components
12.9.6.1
SS: TV
12.9.6.2
SS: TRV
+
12.10
Automatic Semicolon Insertion
12.10.1
Rules of Automatic Semicolon Insertion
12.10.2
Examples of Automatic Semicolon Insertion
+
12.10.3
Interesting Cases of Automatic Semicolon Insertion
12.10.3.1
Interesting Cases of Automatic Semicolon Insertion in Statement Lists
+
12.10.3.2
Cases of Automatic Semicolon Insertion and “[no
LineTerminator
here]”
12.10.3.2.1
List of Grammar Productions with Optional Operands and “[no
LineTerminator
here]”
+
13
ECMAScript Language: Expressions
+
13.1
Identifiers
13.1.1
SS: Early Errors
13.1.2
SS: StringValue
13.1.3
RS: Evaluation
+
13.2
Primary Expression
+
13.2.1
The
this
Keyword
13.2.1.1
RS: Evaluation
13.2.2
Identifier Reference
+
13.2.3
Literals
13.2.3.1
RS: Evaluation
+
13.2.4
Array Initializer
13.2.4.1
RS: ArrayAccumulation
13.2.4.2
RS: Evaluation
+
13.2.5
Object Initializer
13.2.5.1
SS: Early Errors
13.2.5.2
SS: IsComputedPropertyKey
13.2.5.3
SS: PropertyNameList
13.2.5.4
RS: Evaluation
13.2.5.5
RS: PropertyDefinitionEvaluation
13.2.6
Function Defining Expressions
+
13.2.7
Regular Expression Literals
13.2.7.1
SS: Early Errors
13.2.7.2
SS: IsValidRegularExpressionLiteral (
literal
)
13.2.7.3
RS: Evaluation
+
13.2.8
Template Literals
13.2.8.1
SS: Early Errors
13.2.8.2
SS: TemplateStrings
13.2.8.3
SS: TemplateString (
templateToken
,
raw
)
13.2.8.4
GetTemplateObject (
templateLiteral
)
13.2.8.5
RS: SubstitutionEvaluation
13.2.8.6
RS: Evaluation
+
13.2.9
The Grouping Operator
13.2.9.1
SS: Early Errors
13.2.9.2
RS: Evaluation
+
13.3
Left-Hand-Side Expressions
+
13.3.1
Static Semantics
13.3.1.1
SS: Early Errors
+
13.3.2
Property Accessors
13.3.2.1
RS: Evaluation
13.3.3
EvaluatePropertyAccessWithExpressionKey (
baseValue
,
expression
,
strict
)
13.3.4
EvaluatePropertyAccessWithIdentifierKey (
baseValue
,
identifierName
,
strict
)
+
13.3.5
The
new
Operator
+
13.3.5.1
RS: Evaluation
13.3.5.1.1
EvaluateNew (
constructExpr
,
arguments
)
+
13.3.6
Function Calls
13.3.6.1
RS: Evaluation
13.3.6.2
EvaluateCall (
func
,
ref
,
arguments
,
tailPosition
)
+
13.3.7
The
super
Keyword
13.3.7.1
RS: Evaluation
13.3.7.2
GetSuperConstructor ( )
13.3.7.3
MakeSuperPropertyReference (
actualThis
,
propertyKey
,
strict
)
+
13.3.8
Argument Lists
13.3.8.1
RS: ArgumentListEvaluation
+
13.3.9
Optional Chains
13.3.9.1
RS: Evaluation
13.3.9.2
RS: ChainEvaluation
+
13.3.10
Import Calls
13.3.10.1
RS: Evaluation
13.3.10.2
EvaluateImportCall (
specifierExpression
[ ,
optionsExpression
] )
13.3.10.3
ContinueDynamicImport (
promiseCapability
,
moduleCompletion
)
+
13.3.11
Tagged Templates
13.3.11.1
RS: Evaluation
+
13.3.12
Meta Properties
+
13.3.12.1
RS: Evaluation
13.3.12.1.1
HostGetImportMetaProperties (
moduleRecord
)
13.3.12.1.2
HostFinalizeImportMeta (
importMeta
,
moduleRecord
)
+
13.4
Update Expressions
13.4.1
SS: Early Errors
+
13.4.2
Postfix Increment Operator
13.4.2.1
RS: Evaluation
+
13.4.3
Postfix Decrement Operator
13.4.3.1
RS: Evaluation
+
13.4.4
Prefix Increment Operator
13.4.4.1
RS: Evaluation
+
13.4.5
Prefix Decrement Operator
13.4.5.1
RS: Evaluation
+
13.5
Unary Operators
+
13.5.1
The
delete
Operator
13.5.1.1
SS: Early Errors
13.5.1.2
RS: Evaluation
+
13.5.2
The
void
Operator
13.5.2.1
RS: Evaluation
+
13.5.3
The
typeof
Operator
13.5.3.1
RS: Evaluation
+
13.5.4
Unary
+
Operator
13.5.4.1
RS: Evaluation
+
13.5.5
Unary
-
Operator
13.5.5.1
RS: Evaluation
+
13.5.6
Bitwise NOT Operator (
~
)
13.5.6.1
RS: Evaluation
+
13.5.7
Logical NOT Operator (
!
)
13.5.7.1
RS: Evaluation
+
13.6
Exponentiation Operator
13.6.1
RS: Evaluation
+
13.7
Multiplicative Operators
13.7.1
RS: Evaluation
+
13.8
Additive Operators
+
13.8.1
The Addition Operator (
+
)
13.8.1.1
RS: Evaluation
+
13.8.2
The Subtraction Operator (
-
)
13.8.2.1
RS: Evaluation
+
13.9
Bitwise Shift Operators
+
13.9.1
The Left Shift Operator (
<<
)
13.9.1.1
RS: Evaluation
+
13.9.2
The Signed Right Shift Operator (
>>
)
13.9.2.1
RS: Evaluation
+
13.9.3
The Unsigned Right Shift Operator (
>>>
)
13.9.3.1
RS: Evaluation
+
13.10
Relational Operators
13.10.1
RS: Evaluation
13.10.2
InstanceofOperator (
V
,
target
)
+
13.11
Equality Operators
13.11.1
RS: Evaluation
+
13.12
Binary Bitwise Operators
13.12.1
RS: Evaluation
+
13.13
Binary Logical Operators
13.13.1
RS: Evaluation
+
13.14
Conditional Operator (
? :
)
13.14.1
RS: Evaluation
+
13.15
Assignment Operators
13.15.1
SS: Early Errors
13.15.2
RS: Evaluation
13.15.3
ApplyStringOrNumericBinaryOperator (
lVal
,
opText
,
rVal
)
13.15.4
EvaluateStringOrNumericBinaryExpression (
leftOperand
,
opText
,
rightOperand
)
+
13.15.5
Destructuring Assignment
13.15.5.1
SS: Early Errors
13.15.5.2
RS: DestructuringAssignmentEvaluation
13.15.5.3
RS: PropertyDestructuringAssignmentEvaluation
13.15.5.4
RS: RestDestructuringAssignmentEvaluation
13.15.5.5
RS: IteratorDestructuringAssignmentEvaluation
13.15.5.6
RS: KeyedDestructuringAssignmentEvaluation
+
13.16
Comma Operator (
,
)
13.16.1
RS: Evaluation
+
14
ECMAScript Language: Statements and Declarations
+
14.1
Statement Semantics
14.1.1
RS: Evaluation
+
14.2
Block
14.2.1
SS: Early Errors
14.2.2
RS: Evaluation
14.2.3
BlockDeclarationInstantiation (
code
,
env
)
+
14.3
Declarations and the Variable Statement
+
14.3.1
Let and Const Declarations
14.3.1.1
SS: Early Errors
14.3.1.2
RS: Evaluation
+
14.3.2
Variable Statement
14.3.2.1
RS: Evaluation
+
14.3.3
Destructuring Binding Patterns
14.3.3.1
RS: PropertyBindingInitialization
14.3.3.2
RS: RestBindingInitialization
14.3.3.3
RS: KeyedBindingInitialization
+
14.4
Empty Statement
14.4.1
RS: Evaluation
+
14.5
Expression Statement
14.5.1
RS: Evaluation
+
14.6
The
if
Statement
14.6.1
SS: Early Errors
14.6.2
RS: Evaluation
+
14.7
Iteration Statements
+
14.7.1
Semantics
14.7.1.1
LoopContinues (
completion
,
labelSet
)
14.7.1.2
RS: LoopEvaluation
+
14.7.2
The
do
-
while
Statement
14.7.2.1
SS: Early Errors
14.7.2.2
RS: DoWhileLoopEvaluation
+
14.7.3
The
while
Statement
14.7.3.1
SS: Early Errors
14.7.3.2
RS: WhileLoopEvaluation
+
14.7.4
The
for
Statement
14.7.4.1
SS: Early Errors
14.7.4.2
RS: ForLoopEvaluation
14.7.4.3
ForBodyEvaluation (
test
,
increment
,
stmt
,
perIterationBindings
,
labelSet
)
14.7.4.4
CreatePerIterationEnvironment (
perIterationBindings
)
+
14.7.5
The
for
-
in
,
for
-
of
, and
for
-
await
-
of
Statements
14.7.5.1
SS: Early Errors
14.7.5.2
SS: IsDestructuring
14.7.5.3
RS: ForDeclarationBindingInitialization
14.7.5.4
RS: ForDeclarationBindingInstantiation
14.7.5.5
RS: ForInOfLoopEvaluation
14.7.5.6
ForIn/OfHeadEvaluation (
uninitializedBoundNames
,
expr
,
iterationKind
)
14.7.5.7
ForIn/OfBodyEvaluation (
lhs
,
stmt
,
iteratorRecord
,
iterationKind
,
lhsKind
,
labelSet
[ ,
iteratorKind
] )
14.7.5.8
RS: Evaluation
14.7.5.9
EnumerateObjectProperties (
O
)
+
14.7.5.10
For-In Iterator Objects
14.7.5.10.1
CreateForInIterator (
object
)
+
14.7.5.10.2
The %ForInIteratorPrototype% Object
14.7.5.10.2.1
%ForInIteratorPrototype%.next ( )
14.7.5.10.3
Properties of For-In Iterator Instances
+
14.8
The
continue
Statement
14.8.1
SS: Early Errors
14.8.2
RS: Evaluation
+
14.9
The
break
Statement
14.9.1
SS: Early Errors
14.9.2
RS: Evaluation
+
14.10
The
return
Statement
14.10.1
RS: Evaluation
+
14.11
The
with
Statement
14.11.1
SS: Early Errors
14.11.2
RS: Evaluation
+
14.12
The
switch
Statement
14.12.1
SS: Early Errors
14.12.2
RS: CaseBlockEvaluation
14.12.3
CaseClauseIsSelected (
C
,
input
)
14.12.4
RS: Evaluation
+
14.13
Labelled Statements
14.13.1
SS: Early Errors
14.13.2
SS: IsLabelledFunction (
stmt
)
14.13.3
RS: Evaluation
14.13.4
RS: LabelledEvaluation
+
14.14
The
throw
Statement
14.14.1
RS: Evaluation
+
14.15
The
try
Statement
14.15.1
SS: Early Errors
14.15.2
RS: CatchClauseEvaluation
14.15.3
RS: Evaluation
+
14.16
The
debugger
Statement
14.16.1
RS: Evaluation
+
15
ECMAScript Language: Functions and Classes
+
15.1
Parameter Lists
15.1.1
SS: Early Errors
15.1.2
SS: ContainsExpression
15.1.3
SS: IsSimpleParameterList
15.1.4
SS: HasInitializer
15.1.5
SS: ExpectedArgumentCount
+
15.2
Function Definitions
15.2.1
SS: Early Errors
15.2.2
SS: FunctionBodyContainsUseStrict
15.2.3
RS: EvaluateFunctionBody
15.2.4
RS: InstantiateOrdinaryFunctionObject
15.2.5
RS: InstantiateOrdinaryFunctionExpression
15.2.6
RS: Evaluation
+
15.3
Arrow Function Definitions
15.3.1
SS: Early Errors
15.3.2
SS: ConciseBodyContainsUseStrict
15.3.3
RS: EvaluateConciseBody
15.3.4
RS: InstantiateArrowFunctionExpression
15.3.5
RS: Evaluation
+
15.4
Method Definitions
15.4.1
SS: Early Errors
15.4.2
SS: HasDirectSuper
15.4.3
SS: SpecialMethod
15.4.4
RS: DefineMethod
15.4.5
RS: MethodDefinitionEvaluation
+
15.5
Generator Function Definitions
15.5.1
SS: Early Errors
15.5.2
RS: EvaluateGeneratorBody
15.5.3
RS: InstantiateGeneratorFunctionObject
15.5.4
RS: InstantiateGeneratorFunctionExpression
15.5.5
RS: Evaluation
+
15.6
Async Generator Function Definitions
15.6.1
SS: Early Errors
15.6.2
RS: EvaluateAsyncGeneratorBody
15.6.3
RS: InstantiateAsyncGeneratorFunctionObject
15.6.4
RS: InstantiateAsyncGeneratorFunctionExpression
15.6.5
RS: Evaluation
+
15.7
Class Definitions
15.7.1
SS: Early Errors
15.7.2
SS: ClassElementKind
15.7.3
SS: ConstructorMethod
15.7.4
SS: IsStatic
15.7.5
SS: NonConstructorElements
15.7.6
SS: PrototypePropertyNameList
15.7.7
SS: AllPrivateIdentifiersValid
15.7.8
SS: PrivateBoundIdentifiers
15.7.9
SS: ContainsArguments
15.7.10
RS: ClassFieldDefinitionEvaluation
15.7.11
RS: ClassStaticBlockDefinitionEvaluation
15.7.12
RS: EvaluateClassStaticBlockBody
15.7.13
RS: ClassElementEvaluation
15.7.14
RS: ClassDefinitionEvaluation
15.7.15
RS: BindingClassDeclarationEvaluation
15.7.16
RS: Evaluation
+
15.8
Async Function Definitions
15.8.1
SS: Early Errors
15.8.2
RS: InstantiateAsyncFunctionObject
15.8.3
RS: InstantiateAsyncFunctionExpression
15.8.4
RS: EvaluateAsyncFunctionBody
15.8.5
RS: Evaluation
+
15.9
Async Arrow Function Definitions
15.9.1
SS: Early Errors
15.9.2
SS: AsyncConciseBodyContainsUseStrict
15.9.3
RS: EvaluateAsyncConciseBody
15.9.4
RS: InstantiateAsyncArrowFunctionExpression
15.9.5
RS: Evaluation
+
15.10
Tail Position Calls
15.10.1
SS: IsInTailPosition (
call
)
15.10.2
SS: HasCallInTailPosition
15.10.3
PrepareForTailCall ( )
+
16
ECMAScript Language: Scripts and Modules
+
16.1
Scripts
16.1.1
SS: Early Errors
16.1.2
SS: ScriptIsStrict
16.1.3
RS: Evaluation
16.1.4
Script Records
16.1.5
ParseScript (
sourceText
,
realm
,
hostDefined
)
16.1.6
ScriptEvaluation (
scriptRecord
)
16.1.7
GlobalDeclarationInstantiation (
script
,
env
)
+
16.2
Modules
+
16.2.1
Module Semantics
16.2.1.1
SS: Early Errors
16.2.1.2
SS: ImportedLocalNames (
importEntries
)
+
16.2.1.3
ModuleRequest Records
16.2.1.3.1
ModuleRequestsEqual (
left
,
right
)
16.2.1.4
SS: ModuleRequests
+
16.2.1.5
Abstract Module Records
16.2.1.5.1
EvaluateModuleSync (
module
)
+
16.2.1.6
Cyclic Module Records
+
16.2.1.6.1
Implementation of Module Record Abstract Methods
+
16.2.1.6.1.1
LoadRequestedModules ( [
hostDefined
] )
16.2.1.6.1.1.1
InnerModuleLoading (
state
,
module
)
16.2.1.6.1.1.2
ContinueModuleLoading (
state
,
moduleCompletion
)
+
16.2.1.6.1.2
Link ( )
16.2.1.6.1.2.1
InnerModuleLinking (
module
,
stack
,
index
)
+
16.2.1.6.1.3
Evaluate ( )
16.2.1.6.1.3.1
InnerModuleEvaluation (
module
,
stack
,
index
)
16.2.1.6.1.3.2
ExecuteAsyncModule (
module
)
16.2.1.6.1.3.3
GatherAvailableAncestors (
module
,
execList
)
16.2.1.6.1.3.4
AsyncModuleExecutionFulfilled (
module
)
16.2.1.6.1.3.5
AsyncModuleExecutionRejected (
module
,
error
)
16.2.1.6.2
Example Cyclic Module Record Graphs
+
16.2.1.7
Source Text Module Records
16.2.1.7.1
ParseModule (
sourceText
,
realm
,
hostDefined
)
+
16.2.1.7.2
Implementation of Module Record Abstract Methods
16.2.1.7.2.1
GetExportedNames ( [
exportStarSet
] )
16.2.1.7.2.2
ResolveExport (
exportName
[ ,
resolveSet
] )
+
16.2.1.7.3
Implementation of Cyclic Module Record Abstract Methods
16.2.1.7.3.1
InitializeEnvironment ( )
16.2.1.7.3.2
ExecuteModule ( [
capability
] )
+
16.2.1.8
Synthetic Module Records
16.2.1.8.1
CreateDefaultExportSyntheticModule (
defaultExport
)
16.2.1.8.2
ParseJSONModule (
source
)
16.2.1.8.3
SetSyntheticModuleExport (
module
,
exportName
,
exportValue
)
+
16.2.1.8.4
Implementation of Module Record Abstract Methods
16.2.1.8.4.1
LoadRequestedModules ( [
hostDefined
] )
16.2.1.8.4.2
GetExportedNames ( [
exportStarSet
] )
16.2.1.8.4.3
ResolveExport (
exportName
[ ,
resolveSet
] )
16.2.1.8.4.4
Link ( )
16.2.1.8.4.5
Evaluate ( )
16.2.1.9
GetImportedModule (
referrer
,
request
)
16.2.1.10
HostLoadImportedModule (
referrer
,
moduleRequest
,
hostDefined
,
payload
)
16.2.1.11
FinishLoadingImportedModule (
referrer
,
moduleRequest
,
payload
,
result
)
+
16.2.1.12
AllImportAttributesSupported (
attributes
)
16.2.1.12.1
HostGetSupportedImportAttributes ( )
16.2.1.13
GetModuleNamespace (
module
)
16.2.1.14
RS: Evaluation
+
16.2.2
Imports
16.2.2.1
SS: Early Errors
16.2.2.2
SS: ImportEntries
16.2.2.3
SS: ImportEntriesForModule
16.2.2.4
SS: WithClauseToAttributes
+
16.2.3
Exports
16.2.3.1
SS: Early Errors
16.2.3.2
SS: ExportedBindings
16.2.3.3
SS: ExportedNames
16.2.3.4
SS: ExportEntries
16.2.3.5
SS: ExportEntriesForModule
16.2.3.6
SS: ReferencedBindings
16.2.3.7
RS: Evaluation
+
17
Error Handling and Language Extensions
17.1
Forbidden Extensions
18
ECMAScript Standard Built-in Objects
+
19
The Global Object
+
19.1
Value Properties of the Global Object
19.1.1
globalThis
19.1.2
Infinity
19.1.3
NaN
19.1.4
undefined
+
19.2
Function Properties of the Global Object
+
19.2.1
eval (
x
)
19.2.1.1
PerformEval (
x
,
strictCaller
,
direct
)
19.2.1.2
HostEnsureCanCompileStrings (
calleeRealm
,
parameterStrings
,
bodyString
,
direct
)
19.2.1.3
EvalDeclarationInstantiation (
body
,
varEnv
,
lexEnv
,
privateEnv
,
strict
)
19.2.2
isFinite (
number
)
19.2.3
isNaN (
number
)
19.2.4
parseFloat (
string
)
19.2.5
parseInt (
string
,
radix
)
+
19.2.6
URI Handling Functions
19.2.6.1
decodeURI (
encodedURI
)
19.2.6.2
decodeURIComponent (
encodedURIComponent
)
19.2.6.3
encodeURI (
uri
)
19.2.6.4
encodeURIComponent (
uriComponent
)
19.2.6.5
Encode (
string
,
extraUnescaped
)
19.2.6.6
Decode (
string
,
preserveEscapeSet
)
19.2.6.7
ParseHexOctet (
string
,
position
)
+
19.3
Constructor Properties of the Global Object
19.3.1
AggregateError ( . . . )
19.3.2
Array ( . . . )
19.3.3
ArrayBuffer ( . . . )
19.3.4
BigInt ( . . . )
19.3.5
BigInt64Array ( . . . )
19.3.6
BigUint64Array ( . . . )
19.3.7
Boolean ( . . . )
19.3.8
DataView ( . . . )
19.3.9
Date ( . . . )
19.3.10
Error ( . . . )
19.3.11
EvalError ( . . . )
19.3.12
FinalizationRegistry ( . . . )
19.3.13
Float16Array ( . . . )
19.3.14
Float32Array ( . . . )
19.3.15
Float64Array ( . . . )
19.3.16
Function ( . . . )
19.3.17
Int8Array ( . . . )
19.3.18
Int16Array ( . . . )
19.3.19
Int32Array ( . . . )
19.3.20
Iterator ( . . . )
19.3.21
Map ( . . . )
19.3.22
Number ( . . . )
19.3.23
Object ( . . . )
19.3.24
Promise ( . . . )
19.3.25
Proxy ( . . . )
19.3.26
RangeError ( . . . )
19.3.27
ReferenceError ( . . . )
19.3.28
RegExp ( . . . )
19.3.29
Set ( . . . )
19.3.30
SharedArrayBuffer ( . . . )
19.3.31
String ( . . . )
19.3.32
Symbol ( . . . )
19.3.33
SyntaxError ( . . . )
19.3.34
TypeError ( . . . )
19.3.35
Uint8Array ( . . . )
19.3.36
Uint8ClampedArray ( . . . )
19.3.37
Uint16Array ( . . . )
19.3.38
Uint32Array ( . . . )
19.3.39
URIError ( . . . )
19.3.40
WeakMap ( . . . )
19.3.41
WeakRef ( . . . )
19.3.42
WeakSet ( . . . )
+
19.4
Other Properties of the Global Object
19.4.1
Atomics
19.4.2
JSON
19.4.3
Math
19.4.4
Reflect
+
20
Fundamental Objects
+
20.1
Object Objects
+
20.1.1
The Object Constructor
20.1.1.1
Object (
value
)
+
20.1.2
Properties of the Object Constructor
20.1.2.1
Object.assign (
target
, ...
sources
)
20.1.2.2
Object.create (
O
,
Properties
)
+
20.1.2.3
Object.defineProperties (
O
,
Properties
)
20.1.2.3.1
ObjectDefineProperties (
O
,
Properties
)
20.1.2.4
Object.defineProperty (
O
,
P
,
Attributes
)
20.1.2.5
Object.entries (
O
)
20.1.2.6
Object.freeze (
O
)
20.1.2.7
Object.fromEntries (
iterable
)
20.1.2.8
Object.getOwnPropertyDescriptor (
O
,
P
)
20.1.2.9
Object.getOwnPropertyDescriptors (
O
)
20.1.2.10
Object.getOwnPropertyNames (
O
)
+
20.1.2.11
Object.getOwnPropertySymbols (
O
)
20.1.2.11.1
GetOwnPropertyKeys (
O
,
type
)
20.1.2.12
Object.getPrototypeOf (
O
)
20.1.2.13
Object.groupBy (
items
,
callback
)
20.1.2.14
Object.hasOwn (
O
,
P
)
20.1.2.15
Object.is (
value1
,
value2
)
20.1.2.16
Object.isExtensible (
O
)
20.1.2.17
Object.isFrozen (
O
)
20.1.2.18
Object.isSealed (
O
)
20.1.2.19
Object.keys (
O
)
20.1.2.20
Object.preventExtensions (
O
)
20.1.2.21
Object.prototype
20.1.2.22
Object.seal (
O
)
20.1.2.23
Object.setPrototypeOf (
O
,
proto
)
20.1.2.24
Object.values (
O
)
+
20.1.3
Properties of the Object Prototype Object
20.1.3.1
Object.prototype.constructor
20.1.3.2
Object.prototype.hasOwnProperty (
V
)
20.1.3.3
Object.prototype.isPrototypeOf (
V
)
20.1.3.4
Object.prototype.propertyIsEnumerable (
V
)
20.1.3.5
Object.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
20.1.3.6
Object.prototype.toString ( )
20.1.3.7
Object.prototype.valueOf ( )
+
20.1.3.8
Object.prototype.__proto__
20.1.3.8.1
get Object.prototype.__proto__
20.1.3.8.2
set Object.prototype.__proto__
+
20.1.3.9
Legacy Object.prototype Accessor Methods
20.1.3.9.1
Object.prototype.__defineGetter__ (
P
,
getter
)
20.1.3.9.2
Object.prototype.__defineSetter__ (
P
,
setter
)
20.1.3.9.3
Object.prototype.__lookupGetter__ (
P
)
20.1.3.9.4
Object.prototype.__lookupSetter__ (
P
)
20.1.4
Properties of Object Instances
+
20.2
Function Objects
+
20.2.1
The Function Constructor
+
20.2.1.1
Function ( ...
parameterArgs
,
bodyArg
)
20.2.1.1.1
CreateDynamicFunction (
constructor
,
newTarget
,
kind
,
parameterArgs
,
bodyArg
)
+
20.2.2
Properties of the Function Constructor
20.2.2.1
Function.prototype
+
20.2.3
Properties of the Function Prototype Object
20.2.3.1
Function.prototype.apply (
thisArg
,
argArray
)
20.2.3.2
Function.prototype.bind (
thisArg
, ...
args
)
20.2.3.3
Function.prototype.call (
thisArg
, ...
args
)
20.2.3.4
Function.prototype.constructor
20.2.3.5
Function.prototype.toString ( )
20.2.3.6
Function.prototype [ %Symbol.hasInstance% ] (
V
)
+
20.2.4
Function Instances
20.2.4.1
length
20.2.4.2
name
20.2.4.3
prototype
20.2.5
HostHasSourceTextAvailable (
func
)
+
20.3
Boolean Objects
+
20.3.1
The Boolean Constructor
20.3.1.1
Boolean (
value
)
+
20.3.2
Properties of the Boolean Constructor
20.3.2.1
Boolean.prototype
+
20.3.3
Properties of the Boolean Prototype Object
20.3.3.1
Boolean.prototype.constructor
20.3.3.2
Boolean.prototype.toString ( )
+
20.3.3.3
Boolean.prototype.valueOf ( )
20.3.3.3.1
ThisBooleanValue (
value
)
20.3.4
Properties of Boolean Instances
+
20.4
Symbol Objects
+
20.4.1
The Symbol Constructor
20.4.1.1
Symbol ( [
description
] )
+
20.4.2
Properties of the Symbol Constructor
20.4.2.1
Symbol.asyncIterator
20.4.2.2
Symbol.for (
key
)
20.4.2.3
Symbol.hasInstance
20.4.2.4
Symbol.isConcatSpreadable
20.4.2.5
Symbol.iterator
20.4.2.6
Symbol.keyFor (
sym
)
20.4.2.7
Symbol.match
20.4.2.8
Symbol.matchAll
20.4.2.9
Symbol.prototype
20.4.2.10
Symbol.replace
20.4.2.11
Symbol.search
20.4.2.12
Symbol.species
20.4.2.13
Symbol.split
20.4.2.14
Symbol.toPrimitive
20.4.2.15
Symbol.toStringTag
20.4.2.16
Symbol.unscopables
+
20.4.3
Properties of the Symbol Prototype Object
20.4.3.1
Symbol.prototype.constructor
20.4.3.2
get Symbol.prototype.description
+
20.4.3.3
Symbol.prototype.toString ( )
20.4.3.3.1
SymbolDescriptiveString (
sym
)
+
20.4.3.4
Symbol.prototype.valueOf ( )
20.4.3.4.1
ThisSymbolValue (
value
)
20.4.3.5
Symbol.prototype [ %Symbol.toPrimitive% ] (
hint
)
20.4.3.6
Symbol.prototype [ %Symbol.toStringTag% ]
20.4.4
Properties of Symbol Instances
+
20.4.5
Abstract Operations for Symbols
20.4.5.1
KeyForSymbol (
sym
)
+
20.5
Error Objects
+
20.5.1
The Error Constructor
20.5.1.1
Error (
message
[ ,
options
] )
+
20.5.2
Properties of the Error Constructor
20.5.2.1
Error.isError (
arg
)
20.5.2.2
Error.prototype
+
20.5.3
Properties of the Error Prototype Object
20.5.3.1
Error.prototype.constructor
20.5.3.2
Error.prototype.message
20.5.3.3
Error.prototype.name
20.5.3.4
Error.prototype.toString ( )
20.5.4
Properties of Error Instances
+
20.5.5
Native Error Types Used in This Standard
20.5.5.1
EvalError
20.5.5.2
RangeError
20.5.5.3
ReferenceError
20.5.5.4
SyntaxError
20.5.5.5
TypeError
20.5.5.6
URIError
+
20.5.6
NativeError
Object Structure
+
20.5.6.1
The
NativeError
Constructors
20.5.6.1.1
NativeError
(
message
[ ,
options
] )
+
20.5.6.2
Properties of the
NativeError
Constructors
20.5.6.2.1
NativeError
.prototype
+
20.5.6.3
Properties of the
NativeError
Prototype Objects
20.5.6.3.1
NativeError
.prototype.constructor
20.5.6.3.2
NativeError
.prototype.message
20.5.6.3.3
NativeError
.prototype.name
20.5.6.4
Properties of
NativeError
Instances
+
20.5.7
AggregateError Objects
+
20.5.7.1
The AggregateError Constructor
20.5.7.1.1
AggregateError (
errors
,
message
[ ,
options
] )
+
20.5.7.2
Properties of the AggregateError Constructor
20.5.7.2.1
AggregateError.prototype
+
20.5.7.3
Properties of the AggregateError Prototype Object
20.5.7.3.1
AggregateError.prototype.constructor
20.5.7.3.2
AggregateError.prototype.message
20.5.7.3.3
AggregateError.prototype.name
20.5.7.4
Properties of AggregateError Instances
+
20.5.8
Abstract Operations for Error Objects
20.5.8.1
InstallErrorCause (
O
,
options
)
+
21
Numbers and Dates
+
21.1
Number Objects
+
21.1.1
The Number Constructor
21.1.1.1
Number (
value
)
+
21.1.2
Properties of the Number Constructor
21.1.2.1
Number.EPSILON
21.1.2.2
Number.isFinite (
number
)
21.1.2.3
Number.isInteger (
number
)
21.1.2.4
Number.isNaN (
number
)
21.1.2.5
Number.isSafeInteger (
number
)
21.1.2.6
Number.MAX_SAFE_INTEGER
21.1.2.7
Number.MAX_VALUE
21.1.2.8
Number.MIN_SAFE_INTEGER
21.1.2.9
Number.MIN_VALUE
21.1.2.10
Number.NaN
21.1.2.11
Number.NEGATIVE_INFINITY
21.1.2.12
Number.parseFloat (
string
)
21.1.2.13
Number.parseInt (
string
,
radix
)
21.1.2.14
Number.POSITIVE_INFINITY
21.1.2.15
Number.prototype
+
21.1.3
Properties of the Number Prototype Object
21.1.3.1
Number.prototype.constructor
21.1.3.2
Number.prototype.toExponential (
fractionDigits
)
21.1.3.3
Number.prototype.toFixed (
fractionDigits
)
21.1.3.4
Number.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
21.1.3.5
Number.prototype.toPrecision (
precision
)
21.1.3.6
Number.prototype.toString ( [
radix
] )
+
21.1.3.7
Number.prototype.valueOf ( )
21.1.3.7.1
ThisNumberValue (
value
)
21.1.4
Properties of Number Instances
+
21.2
BigInt Objects
+
21.2.1
The BigInt Constructor
+
21.2.1.1
BigInt (
value
)
21.2.1.1.1
NumberToBigInt (
number
)
+
21.2.2
Properties of the BigInt Constructor
21.2.2.1
BigInt.asIntN (
bits
,
bigint
)
21.2.2.2
BigInt.asUintN (
bits
,
bigint
)
21.2.2.3
BigInt.prototype
+
21.2.3
Properties of the BigInt Prototype Object
21.2.3.1
BigInt.prototype.constructor
21.2.3.2
BigInt.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
21.2.3.3
BigInt.prototype.toString ( [
radix
] )
+
21.2.3.4
BigInt.prototype.valueOf ( )
21.2.3.4.1
ThisBigIntValue (
value
)
21.2.3.5
BigInt.prototype [ %Symbol.toStringTag% ]
21.2.4
Properties of BigInt Instances
+
21.3
The Math Object
+
21.3.1
Value Properties of the Math Object
21.3.1.1
Math.E
21.3.1.2
Math.LN10
21.3.1.3
Math.LN2
21.3.1.4
Math.LOG10E
21.3.1.5
Math.LOG2E
21.3.1.6
Math.PI
21.3.1.7
Math.SQRT1_2
21.3.1.8
Math.SQRT2
21.3.1.9
Math [ %Symbol.toStringTag% ]
+
21.3.2
Function Properties of the Math Object
21.3.2.1
Math.abs (
x
)
21.3.2.2
Math.acos (
x
)
21.3.2.3
Math.acosh (
x
)
21.3.2.4
Math.asin (
x
)
21.3.2.5
Math.asinh (
x
)
21.3.2.6
Math.atan (
x
)
21.3.2.7
Math.atanh (
x
)
21.3.2.8
Math.atan2 (
y
,
x
)
21.3.2.9
Math.cbrt (
x
)
21.3.2.10
Math.ceil (
x
)
21.3.2.11
Math.clz32 (
x
)
21.3.2.12
Math.cos (
x
)
21.3.2.13
Math.cosh (
x
)
21.3.2.14
Math.exp (
x
)
21.3.2.15
Math.expm1 (
x
)
21.3.2.16
Math.floor (
x
)
21.3.2.17
Math.fround (
x
)
21.3.2.18
Math.f16round (
x
)
21.3.2.19
Math.hypot ( ...
args
)
21.3.2.20
Math.imul (
x
,
y
)
21.3.2.21
Math.log (
x
)
21.3.2.22
Math.log1p (
x
)
21.3.2.23
Math.log10 (
x
)
21.3.2.24
Math.log2 (
x
)
21.3.2.25
Math.max ( ...
args
)
21.3.2.26
Math.min ( ...
args
)
21.3.2.27
Math.pow (
base
,
exponent
)
21.3.2.28
Math.random ( )
21.3.2.29
Math.round (
x
)
21.3.2.30
Math.sign (
x
)
21.3.2.31
Math.sin (
x
)
21.3.2.32
Math.sinh (
x
)
21.3.2.33
Math.sqrt (
x
)
21.3.2.34
Math.sumPrecise (
items
)
21.3.2.35
Math.tan (
x
)
21.3.2.36
Math.tanh (
x
)
21.3.2.37
Math.trunc (
x
)
+
21.4
Date Objects
+
21.4.1
Overview of Date Objects and Definitions of Abstract Operations
21.4.1.1
Time Values and Time Range
21.4.1.2
Time-related Constants
21.4.1.3
Day (
t
)
21.4.1.4
TimeWithinDay (
t
)
21.4.1.5
DaysInYear (
y
)
21.4.1.6
DayFromYear (
y
)
21.4.1.7
TimeFromYear (
y
)
21.4.1.8
YearFromTime (
t
)
21.4.1.9
DayWithinYear (
t
)
21.4.1.10
InLeapYear (
t
)
21.4.1.11
MonthFromTime (
t
)
21.4.1.12
DateFromTime (
t
)
21.4.1.13
WeekDay (
t
)
21.4.1.14
HourFromTime (
t
)
21.4.1.15
MinFromTime (
t
)
21.4.1.16
SecFromTime (
t
)
21.4.1.17
msFromTime (
t
)
21.4.1.18
GetUTCEpochNanoseconds (
year
,
month
,
day
,
hour
,
minute
,
second
,
millisecond
,
microsecond
,
nanosecond
)
21.4.1.19
Time Zone Identifiers
21.4.1.20
GetNamedTimeZoneEpochNanoseconds (
timeZoneIdentifier
,
year
,
month
,
day
,
hour
,
minute
,
second
,
millisecond
,
microsecond
,
nanosecond
)
21.4.1.21
GetNamedTimeZoneOffsetNanoseconds (
timeZoneIdentifier
,
epochNanoseconds
)
21.4.1.22
Time Zone Identifier Record
21.4.1.23
AvailableNamedTimeZoneIdentifiers ( )
21.4.1.24
SystemTimeZoneIdentifier ( )
21.4.1.25
LocalTime (
t
)
21.4.1.26
UTC (
t
)
21.4.1.27
MakeTime (
hour
,
min
,
sec
,
ms
)
21.4.1.28
MakeDay (
year
,
month
,
date
)
21.4.1.29
MakeDate (
day
,
time
)
21.4.1.30
MakeFullYear (
year
)
21.4.1.31
TimeClip (
time
)
+
21.4.1.32
Date Time String Format
21.4.1.32.1
Expanded Years
+
21.4.1.33
Time Zone Offset String Format
21.4.1.33.1
IsTimeZoneOffsetString (
offsetString
)
21.4.1.33.2
ParseTimeZoneOffsetString (
offsetString
)
+
21.4.2
The Date Constructor
21.4.2.1
Date ( ...
values
)
+
21.4.3
Properties of the Date Constructor
21.4.3.1
Date.now ( )
21.4.3.2
Date.parse (
string
)
21.4.3.3
Date.prototype
21.4.3.4
Date.UTC (
year
[ ,
month
[ ,
date
[ ,
hours
[ ,
minutes
[ ,
seconds
[ ,
ms
] ] ] ] ] ] )
+
21.4.4
Properties of the Date Prototype Object
21.4.4.1
Date.prototype.constructor
21.4.4.2
Date.prototype.getDate ( )
21.4.4.3
Date.prototype.getDay ( )
21.4.4.4
Date.prototype.getFullYear ( )
21.4.4.5
Date.prototype.getHours ( )
21.4.4.6
Date.prototype.getMilliseconds ( )
21.4.4.7
Date.prototype.getMinutes ( )
21.4.4.8
Date.prototype.getMonth ( )
21.4.4.9
Date.prototype.getSeconds ( )
21.4.4.10
Date.prototype.getTime ( )
21.4.4.11
Date.prototype.getTimezoneOffset ( )
21.4.4.12
Date.prototype.getUTCDate ( )
21.4.4.13
Date.prototype.getUTCDay ( )
21.4.4.14
Date.prototype.getUTCFullYear ( )
21.4.4.15
Date.prototype.getUTCHours ( )
21.4.4.16
Date.prototype.getUTCMilliseconds ( )
21.4.4.17
Date.prototype.getUTCMinutes ( )
21.4.4.18
Date.prototype.getUTCMonth ( )
21.4.4.19
Date.prototype.getUTCSeconds ( )
21.4.4.20
Date.prototype.setDate (
date
)
21.4.4.21
Date.prototype.setFullYear (
year
[ ,
month
[ ,
date
] ] )
21.4.4.22
Date.prototype.setHours (
hour
[ ,
min
[ ,
sec
[ ,
ms
] ] ] )
21.4.4.23
Date.prototype.setMilliseconds (
ms
)
21.4.4.24
Date.prototype.setMinutes (
min
[ ,
sec
[ ,
ms
] ] )
21.4.4.25
Date.prototype.setMonth (
month
[ ,
date
] )
21.4.4.26
Date.prototype.setSeconds (
sec
[ ,
ms
] )
21.4.4.27
Date.prototype.setTime (
time
)
21.4.4.28
Date.prototype.setUTCDate (
date
)
21.4.4.29
Date.prototype.setUTCFullYear (
year
[ ,
month
[ ,
date
] ] )
21.4.4.30
Date.prototype.setUTCHours (
hour
[ ,
min
[ ,
sec
[ ,
ms
] ] ] )
21.4.4.31
Date.prototype.setUTCMilliseconds (
ms
)
21.4.4.32
Date.prototype.setUTCMinutes (
min
[ ,
sec
[ ,
ms
] ] )
21.4.4.33
Date.prototype.setUTCMonth (
month
[ ,
date
] )
21.4.4.34
Date.prototype.setUTCSeconds (
sec
[ ,
ms
] )
21.4.4.35
Date.prototype.toDateString ( )
21.4.4.36
Date.prototype.toISOString ( )
21.4.4.37
Date.prototype.toJSON (
key
)
21.4.4.38
Date.prototype.toLocaleDateString ( [
reserved1
[ ,
reserved2
] ] )
21.4.4.39
Date.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
21.4.4.40
Date.prototype.toLocaleTimeString ( [
reserved1
[ ,
reserved2
] ] )
+
21.4.4.41
Date.prototype.toString ( )
21.4.4.41.1
TimeString (
tv
)
21.4.4.41.2
DateString (
tv
)
21.4.4.41.3
TimeZoneString (
tv
)
21.4.4.41.4
ToDateString (
tv
)
21.4.4.42
Date.prototype.toTimeString ( )
21.4.4.43
Date.prototype.toUTCString ( )
21.4.4.44
Date.prototype.valueOf ( )
21.4.4.45
Date.prototype [ %Symbol.toPrimitive% ] (
hint
)
21.4.5
Properties of Date Instances
+
22
Text Processing
+
22.1
String Objects
+
22.1.1
The String Constructor
22.1.1.1
String (
value
)
+
22.1.2
Properties of the String Constructor
22.1.2.1
String.fromCharCode ( ...
codeUnits
)
22.1.2.2
String.fromCodePoint ( ...
codePoints
)
22.1.2.3
String.prototype
22.1.2.4
String.raw (
template
, ...
substitutions
)
+
22.1.3
Properties of the String Prototype Object
22.1.3.1
String.prototype.at (
index
)
22.1.3.2
String.prototype.charAt (
pos
)
22.1.3.3
String.prototype.charCodeAt (
pos
)
22.1.3.4
String.prototype.codePointAt (
pos
)
22.1.3.5
String.prototype.concat ( ...
args
)
22.1.3.6
String.prototype.constructor
22.1.3.7
String.prototype.endsWith (
searchString
[ ,
endPosition
] )
22.1.3.8
String.prototype.includes (
searchString
[ ,
position
] )
22.1.3.9
String.prototype.indexOf (
searchString
[ ,
position
] )
22.1.3.10
String.prototype.isWellFormed ( )
22.1.3.11
String.prototype.lastIndexOf (
searchString
[ ,
position
] )
22.1.3.12
String.prototype.localeCompare (
that
[ ,
reserved1
[ ,
reserved2
] ] )
22.1.3.13
String.prototype.match (
regexp
)
22.1.3.14
String.prototype.matchAll (
regexp
)
22.1.3.15
String.prototype.normalize ( [
form
] )
22.1.3.16
String.prototype.padEnd (
maxLength
[ ,
fillString
] )
+
22.1.3.17
String.prototype.padStart (
maxLength
[ ,
fillString
] )
22.1.3.17.1
StringPaddingBuiltinsImpl (
O
,
maxLength
,
fillString
,
placement
)
22.1.3.17.2
StringPad (
S
,
maxLength
,
fillString
,
placement
)
22.1.3.17.3
ToZeroPaddedDecimalString (
n
,
minLength
)
22.1.3.18
String.prototype.repeat (
count
)
+
22.1.3.19
String.prototype.replace (
searchValue
,
replaceValue
)
22.1.3.19.1
GetSubstitution (
matched
,
str
,
position
,
captures
,
namedCaptures
,
replacementTemplate
)
22.1.3.20
String.prototype.replaceAll (
searchValue
,
replaceValue
)
22.1.3.21
String.prototype.search (
regexp
)
22.1.3.22
String.prototype.slice (
start
,
end
)
22.1.3.23
String.prototype.split (
separator
,
limit
)
22.1.3.24
String.prototype.startsWith (
searchString
[ ,
position
] )
22.1.3.25
String.prototype.substring (
start
,
end
)
22.1.3.26
String.prototype.toLocaleLowerCase ( [
reserved1
[ ,
reserved2
] ] )
22.1.3.27
String.prototype.toLocaleUpperCase ( [
reserved1
[ ,
reserved2
] ] )
22.1.3.28
String.prototype.toLowerCase ( )
22.1.3.29
String.prototype.toString ( )
22.1.3.30
String.prototype.toUpperCase ( )
22.1.3.31
String.prototype.toWellFormed ( )
+
22.1.3.32
String.prototype.trim ( )
22.1.3.32.1
TrimString (
string
,
where
)
22.1.3.33
String.prototype.trimEnd ( )
22.1.3.34
String.prototype.trimStart ( )
+
22.1.3.35
String.prototype.valueOf ( )
22.1.3.35.1
ThisStringValue (
value
)
22.1.3.36
String.prototype [ %Symbol.iterator% ] ( )
+
22.1.4
Properties of String Instances
22.1.4.1
length
+
22.1.5
String Iterator Objects
+
22.1.5.1
The %StringIteratorPrototype% Object
22.1.5.1.1
%StringIteratorPrototype%.next ( )
22.1.5.1.2
%StringIteratorPrototype% [ %Symbol.toStringTag% ]
+
22.2
RegExp (Regular Expression) Objects
+
22.2.1
Patterns
22.2.1.1
SS: Early Errors
22.2.1.2
SS: CountLeftCapturingParensWithin (
node
)
22.2.1.3
SS: CountLeftCapturingParensBefore (
node
)
22.2.1.4
SS: MightBothParticipate (
x
,
y
)
22.2.1.5
SS: CapturingGroupNumber
22.2.1.6
SS: IsCharacterClass
22.2.1.7
SS: CharacterValue
22.2.1.8
SS: MayContainStrings
22.2.1.9
SS: GroupSpecifiersThatMatch (
thisGroupName
)
22.2.1.10
SS: CapturingGroupName
22.2.1.11
SS: RegExpIdentifierCodePoints
22.2.1.12
SS: RegExpIdentifierCodePoint
+
22.2.2
Pattern Semantics
+
22.2.2.1
Notation
22.2.2.1.1
RegExp Records
22.2.2.2
RS: CompilePattern
+
22.2.2.3
RS: CompileSubpattern
22.2.2.3.1
RepeatMatcher (
m
,
min
,
max
,
greedy
,
x
,
c
,
parenIndex
,
parenCount
)
22.2.2.3.2
EmptyMatcher ( )
22.2.2.3.3
MatchTwoAlternatives (
m1
,
m2
)
22.2.2.3.4
MatchSequence (
m1
,
m2
,
direction
)
+
22.2.2.4
RS: CompileAssertion
22.2.2.4.1
IsWordChar (
rer
,
Input
,
e
)
22.2.2.5
RS: CompileQuantifier
22.2.2.6
RS: CompileQuantifierPrefix
+
22.2.2.7
RS: CompileAtom
22.2.2.7.1
CharacterSetMatcher (
rer
,
A
,
invert
,
direction
)
22.2.2.7.2
BackreferenceMatcher (
rer
,
ns
,
direction
)
22.2.2.7.3
Canonicalize (
rer
,
ch
)
22.2.2.7.4
UpdateModifiers (
rer
,
add
,
remove
)
22.2.2.8
RS: CompileCharacterClass
+
22.2.2.9
RS: CompileToCharSet
22.2.2.9.1
CharacterRange (
A
,
B
)
22.2.2.9.2
HasEitherUnicodeFlag (
rer
)
22.2.2.9.3
WordCharacters (
rer
)
22.2.2.9.4
AllCharacters (
rer
)
22.2.2.9.5
MaybeSimpleCaseFolding (
rer
,
A
)
22.2.2.9.6
CharacterComplement (
rer
,
S
)
22.2.2.9.7
UnicodeMatchProperty (
rer
,
p
)
22.2.2.9.8
UnicodeMatchPropertyValue (
p
,
v
)
22.2.2.10
RS: CompileClassSetString
+
22.2.3
Abstract Operations for RegExp Creation
22.2.3.1
RegExpCreate (
P
,
F
)
22.2.3.2
RegExpAlloc (
newTarget
)
22.2.3.3
RegExpInitialize (
obj
,
pattern
,
flags
)
22.2.3.4
SS: ParsePattern (
patternText
,
u
,
v
)
+
22.2.4
The RegExp Constructor
22.2.4.1
RegExp (
pattern
,
flags
)
+
22.2.5
Properties of the RegExp Constructor
+
22.2.5.1
RegExp.escape (
S
)
22.2.5.1.1
EncodeForRegExpEscape (
cp
)
22.2.5.2
RegExp.prototype
22.2.5.3
get RegExp [ %Symbol.species% ]
+
22.2.6
Properties of the RegExp Prototype Object
22.2.6.1
RegExp.prototype.constructor
22.2.6.2
RegExp.prototype.exec (
string
)
22.2.6.3
get RegExp.prototype.dotAll
+
22.2.6.4
get RegExp.prototype.flags
22.2.6.4.1
RegExpHasFlag (
R
,
codeUnit
)
22.2.6.5
get RegExp.prototype.global
22.2.6.6
get RegExp.prototype.hasIndices
22.2.6.7
get RegExp.prototype.ignoreCase
22.2.6.8
RegExp.prototype [ %Symbol.match% ] (
string
)
22.2.6.9
RegExp.prototype [ %Symbol.matchAll% ] (
string
)
22.2.6.10
get RegExp.prototype.multiline
22.2.6.11
RegExp.prototype [ %Symbol.replace% ] (
string
,
replaceValue
)
22.2.6.12
RegExp.prototype [ %Symbol.search% ] (
string
)
+
22.2.6.13
get RegExp.prototype.source
22.2.6.13.1
EscapeRegExpPattern (
P
,
F
)
22.2.6.14
RegExp.prototype [ %Symbol.split% ] (
string
,
limit
)
22.2.6.15
get RegExp.prototype.sticky
22.2.6.16
RegExp.prototype.test (
S
)
22.2.6.17
RegExp.prototype.toString ( )
22.2.6.18
get RegExp.prototype.unicode
22.2.6.19
get RegExp.prototype.unicodeSets
+
22.2.7
Abstract Operations for RegExp Matching
22.2.7.1
RegExpExec (
R
,
S
)
22.2.7.2
RegExpBuiltinExec (
R
,
S
)
22.2.7.3
AdvanceStringIndex (
S
,
index
,
unicode
)
22.2.7.4
GetStringIndex (
S
,
codePointIndex
)
22.2.7.5
Match Records
22.2.7.6
GetMatchString (
S
,
match
)
22.2.7.7
GetMatchIndexPair (
S
,
match
)
22.2.7.8
MakeMatchIndicesIndexPairArray (
S
,
indices
,
groupNames
,
hasGroups
)
+
22.2.8
Properties of RegExp Instances
22.2.8.1
lastIndex
+
22.2.9
RegExp String Iterator Objects
22.2.9.1
CreateRegExpStringIterator (
R
,
S
,
global
,
fullUnicode
)
+
22.2.9.2
The %RegExpStringIteratorPrototype% Object
22.2.9.2.1
%RegExpStringIteratorPrototype%.next ( )
22.2.9.2.2
%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]
22.2.9.3
Properties of RegExp String Iterator Instances
+
23
Indexed Collections
+
23.1
Array Objects
+
23.1.1
The Array Constructor
23.1.1.1
Array ( ...
values
)
+
23.1.2
Properties of the Array Constructor
23.1.2.1
Array.from (
items
[ ,
mapper
[ ,
thisArg
] ] )
23.1.2.2
Array.fromAsync (
items
[ ,
mapper
[ ,
thisArg
] ] )
23.1.2.3
Array.isArray (
arg
)
23.1.2.4
Array.of ( ...
items
)
23.1.2.5
Array.prototype
23.1.2.6
get Array [ %Symbol.species% ]
+
23.1.3
Properties of the Array Prototype Object
23.1.3.1
Array.prototype.at (
index
)
+
23.1.3.2
Array.prototype.concat ( ...
items
)
23.1.3.2.1
IsConcatSpreadable (
O
)
23.1.3.3
Array.prototype.constructor
23.1.3.4
Array.prototype.copyWithin (
target
,
start
[ ,
end
] )
23.1.3.5
Array.prototype.entries ( )
23.1.3.6
Array.prototype.every (
callback
[ ,
thisArg
] )
23.1.3.7
Array.prototype.fill (
value
[ ,
start
[ ,
end
] ] )
23.1.3.8
Array.prototype.filter (
callback
[ ,
thisArg
] )
23.1.3.9
Array.prototype.find (
predicate
[ ,
thisArg
] )
23.1.3.10
Array.prototype.findIndex (
predicate
[ ,
thisArg
] )
23.1.3.11
Array.prototype.findLast (
predicate
[ ,
thisArg
] )
+
23.1.3.12
Array.prototype.findLastIndex (
predicate
[ ,
thisArg
] )
23.1.3.12.1
FindViaPredicate (
O
,
len
,
direction
,
predicate
,
thisArg
)
+
23.1.3.13
Array.prototype.flat ( [
depth
] )
23.1.3.13.1
FlattenIntoArray (
target
,
source
,
sourceLen
,
start
,
depth
[ ,
mapperFunction
[ ,
thisArg
] ] )
23.1.3.14
Array.prototype.flatMap (
mapperFunction
[ ,
thisArg
] )
23.1.3.15
Array.prototype.forEach (
callback
[ ,
thisArg
] )
23.1.3.16
Array.prototype.includes (
searchElement
[ ,
fromIndex
] )
23.1.3.17
Array.prototype.indexOf (
searchElement
[ ,
fromIndex
] )
23.1.3.18
Array.prototype.join (
separator
)
23.1.3.19
Array.prototype.keys ( )
23.1.3.20
Array.prototype.lastIndexOf (
searchElement
[ ,
fromIndex
] )
23.1.3.21
Array.prototype.map (
callback
[ ,
thisArg
] )
23.1.3.22
Array.prototype.pop ( )
23.1.3.23
Array.prototype.push ( ...
items
)
23.1.3.24
Array.prototype.reduce (
callback
[ ,
initialValue
] )
23.1.3.25
Array.prototype.reduceRight (
callback
[ ,
initialValue
] )
23.1.3.26
Array.prototype.reverse ( )
23.1.3.27
Array.prototype.shift ( )
23.1.3.28
Array.prototype.slice (
start
,
end
)
23.1.3.29
Array.prototype.some (
callback
[ ,
thisArg
] )
+
23.1.3.30
Array.prototype.sort (
comparator
)
23.1.3.30.1
SortIndexedProperties (
obj
,
len
,
SortCompare
,
holes
)
23.1.3.30.2
CompareArrayElements (
x
,
y
,
comparator
)
23.1.3.31
Array.prototype.splice (
start
,
deleteCount
, ...
items
)
23.1.3.32
Array.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
23.1.3.33
Array.prototype.toReversed ( )
23.1.3.34
Array.prototype.toSorted (
comparator
)
23.1.3.35
Array.prototype.toSpliced (
start
,
skipCount
, ...
items
)
23.1.3.36
Array.prototype.toString ( )
23.1.3.37
Array.prototype.unshift ( ...
items
)
23.1.3.38
Array.prototype.values ( )
23.1.3.39
Array.prototype.with (
index
,
value
)
23.1.3.40
Array.prototype [ %Symbol.iterator% ] ( )
23.1.3.41
Array.prototype [ %Symbol.unscopables% ]
+
23.1.4
Properties of Array Instances
23.1.4.1
length
+
23.1.5
Array Iterator Objects
23.1.5.1
CreateArrayIterator (
array
,
kind
)
+
23.1.5.2
The %ArrayIteratorPrototype% Object
23.1.5.2.1
%ArrayIteratorPrototype%.next ( )
23.1.5.2.2
%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]
23.1.5.3
Properties of Array Iterator Instances
+
23.2
TypedArray Objects
+
23.2.1
The %TypedArray% Intrinsic Object
23.2.1.1
%TypedArray% ( )
+
23.2.2
Properties of the %TypedArray% Intrinsic Object
23.2.2.1
%TypedArray%.from (
source
[ ,
mapper
[ ,
thisArg
] ] )
23.2.2.2
%TypedArray%.of ( ...
items
)
23.2.2.3
%TypedArray%.prototype
23.2.2.4
get %TypedArray% [ %Symbol.species% ]
+
23.2.3
Properties of the %TypedArray% Prototype Object
23.2.3.1
%TypedArray%.prototype.at (
index
)
23.2.3.2
get %TypedArray%.prototype.buffer
23.2.3.3
get %TypedArray%.prototype.byteLength
23.2.3.4
get %TypedArray%.prototype.byteOffset
23.2.3.5
%TypedArray%.prototype.constructor
23.2.3.6
%TypedArray%.prototype.copyWithin (
target
,
start
[ ,
end
] )
23.2.3.7
%TypedArray%.prototype.entries ( )
23.2.3.8
%TypedArray%.prototype.every (
callback
[ ,
thisArg
] )
23.2.3.9
%TypedArray%.prototype.fill (
value
[ ,
start
[ ,
end
] ] )
23.2.3.10
%TypedArray%.prototype.filter (
callback
[ ,
thisArg
] )
23.2.3.11
%TypedArray%.prototype.find (
predicate
[ ,
thisArg
] )
23.2.3.12
%TypedArray%.prototype.findIndex (
predicate
[ ,
thisArg
] )
23.2.3.13
%TypedArray%.prototype.findLast (
predicate
[ ,
thisArg
] )
23.2.3.14
%TypedArray%.prototype.findLastIndex (
predicate
[ ,
thisArg
] )
23.2.3.15
%TypedArray%.prototype.forEach (
callback
[ ,
thisArg
] )
23.2.3.16
%TypedArray%.prototype.includes (
searchElement
[ ,
fromIndex
] )
23.2.3.17
%TypedArray%.prototype.indexOf (
searchElement
[ ,
fromIndex
] )
23.2.3.18
%TypedArray%.prototype.join (
separator
)
23.2.3.19
%TypedArray%.prototype.keys ( )
23.2.3.20
%TypedArray%.prototype.lastIndexOf (
searchElement
[ ,
fromIndex
] )
23.2.3.21
get %TypedArray%.prototype.length
23.2.3.22
%TypedArray%.prototype.map (
callback
[ ,
thisArg
] )
23.2.3.23
%TypedArray%.prototype.reduce (
callback
[ ,
initialValue
] )
23.2.3.24
%TypedArray%.prototype.reduceRight (
callback
[ ,
initialValue
] )
23.2.3.25
%TypedArray%.prototype.reverse ( )
+
23.2.3.26
%TypedArray%.prototype.set (
source
[ ,
offset
] )
23.2.3.26.1
SetTypedArrayFromArrayLike (
target
,
targetOffset
,
source
)
23.2.3.26.2
SetTypedArrayFromTypedArray (
target
,
targetOffset
,
source
)
23.2.3.27
%TypedArray%.prototype.slice (
start
,
end
)
23.2.3.28
%TypedArray%.prototype.some (
callback
[ ,
thisArg
] )
23.2.3.29
%TypedArray%.prototype.sort (
comparator
)
23.2.3.30
%TypedArray%.prototype.subarray (
start
,
end
)
23.2.3.31
%TypedArray%.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
23.2.3.32
%TypedArray%.prototype.toReversed ( )
23.2.3.33
%TypedArray%.prototype.toSorted (
comparator
)
23.2.3.34
%TypedArray%.prototype.toString ( )
23.2.3.35
%TypedArray%.prototype.values ( )
23.2.3.36
%TypedArray%.prototype.with (
index
,
value
)
23.2.3.37
%TypedArray%.prototype [ %Symbol.iterator% ] ( )
23.2.3.38
get %TypedArray%.prototype [ %Symbol.toStringTag% ]
+
23.2.4
Abstract Operations for TypedArray Objects
23.2.4.1
TypedArrayCreateFromConstructor (
constructor
,
argumentList
)
23.2.4.2
TypedArrayCreateSameType (
exemplar
,
length
)
23.2.4.3
TypedArraySpeciesCreate (
exemplar
,
argumentList
)
23.2.4.4
ValidateTypedArray (
O
,
order
)
23.2.4.5
TypedArrayElementSize (
O
)
23.2.4.6
TypedArrayElementType (
O
)
23.2.4.7
CompareTypedArrayElements (
x
,
y
,
comparator
)
+
23.2.5
The
TypedArray
Constructors
+
23.2.5.1
TypedArray
( ...
args
)
23.2.5.1.1
AllocateTypedArray (
constructorName
,
newTarget
,
defaultProto
[ ,
length
] )
23.2.5.1.2
InitializeTypedArrayFromTypedArray (
O
,
srcArray
)
23.2.5.1.3
InitializeTypedArrayFromArrayBuffer (
O
,
buffer
,
byteOffset
,
length
)
23.2.5.1.4
InitializeTypedArrayFromList (
O
,
values
)
23.2.5.1.5
InitializeTypedArrayFromArrayLike (
O
,
arrayLike
)
23.2.5.1.6
AllocateTypedArrayBuffer (
O
,
length
)
+
23.2.6
Properties of the
TypedArray
Constructors
23.2.6.1
TypedArray
.BYTES_PER_ELEMENT
23.2.6.2
TypedArray
.prototype
+
23.2.7
Properties of the
TypedArray
Prototype Objects
23.2.7.1
TypedArray
.prototype.BYTES_PER_ELEMENT
23.2.7.2
TypedArray
.prototype.constructor
23.2.8
Properties of
TypedArray
Instances
+
23.3
Uint8Array Objects
+
23.3.1
Additional Properties of the Uint8Array Constructor
23.3.1.1
Uint8Array.fromBase64 (
string
[ ,
options
] )
23.3.1.2
Uint8Array.fromHex (
string
)
+
23.3.2
Additional Properties of the Uint8Array Prototype Object
23.3.2.1
Uint8Array.prototype.setFromBase64 (
string
[ ,
options
] )
23.3.2.2
Uint8Array.prototype.setFromHex (
string
)
23.3.2.3
Uint8Array.prototype.toBase64 ( [
options
] )
23.3.2.4
Uint8Array.prototype.toHex ( )
+
23.3.3
Abstract Operations for Uint8Array Objects
23.3.3.1
ValidateUint8Array (
ta
)
23.3.3.2
GetUint8ArrayBytes (
ta
)
23.3.3.3
SetUint8ArrayBytes (
into
,
bytes
)
23.3.3.4
SkipAsciiWhitespace (
string
,
index
)
23.3.3.5
DecodeFinalBase64Chunk (
chunk
,
throwOnExtraBits
)
23.3.3.6
DecodeFullLengthBase64Chunk (
chunk
)
23.3.3.7
FromBase64 (
string
,
alphabet
,
lastChunkHandling
[ ,
maxLength
] )
23.3.3.8
FromHex (
string
[ ,
maxLength
] )
+
24
Keyed Collections
+
24.1
Map Objects
+
24.1.1
The Map Constructor
24.1.1.1
Map ( [
iterable
] )
24.1.1.2
AddEntriesFromIterable (
target
,
iterable
,
adder
)
+
24.1.2
Properties of the Map Constructor
24.1.2.1
Map.groupBy (
items
,
callback
)
24.1.2.2
Map.prototype
24.1.2.3
get Map [ %Symbol.species% ]
+
24.1.3
Properties of the Map Prototype Object
24.1.3.1
Map.prototype.clear ( )
24.1.3.2
Map.prototype.constructor
24.1.3.3
Map.prototype.delete (
key
)
24.1.3.4
Map.prototype.entries ( )
24.1.3.5
Map.prototype.forEach (
callback
[ ,
thisArg
] )
24.1.3.6
Map.prototype.get (
key
)
24.1.3.7
Map.prototype.getOrInsert (
key
,
value
)
24.1.3.8
Map.prototype.getOrInsertComputed (
key
,
callback
)
24.1.3.9
Map.prototype.has (
key
)
24.1.3.10
Map.prototype.keys ( )
24.1.3.11
Map.prototype.set (
key
,
value
)
24.1.3.12
get Map.prototype.size
24.1.3.13
Map.prototype.values ( )
24.1.3.14
Map.prototype [ %Symbol.iterator% ] ( )
24.1.3.15
Map.prototype [ %Symbol.toStringTag% ]
24.1.4
Properties of Map Instances
+
24.1.5
Map Iterator Objects
24.1.5.1
CreateMapIterator (
map
,
kind
)
+
24.1.5.2
The %MapIteratorPrototype% Object
24.1.5.2.1
%MapIteratorPrototype%.next ( )
24.1.5.2.2
%MapIteratorPrototype% [ %Symbol.toStringTag% ]
+
24.2
Set Objects
+
24.2.1
Abstract Operations For Set Objects
24.2.1.1
Set Records
24.2.1.2
GetSetRecord (
obj
)
24.2.1.3
SetDataHas (
setData
,
value
)
24.2.1.4
SetDataIndex (
setData
,
value
)
24.2.1.5
SetDataSize (
setData
)
+
24.2.2
The Set Constructor
24.2.2.1
Set ( [
iterable
] )
+
24.2.3
Properties of the Set Constructor
24.2.3.1
Set.prototype
24.2.3.2
get Set [ %Symbol.species% ]
+
24.2.4
Properties of the Set Prototype Object
24.2.4.1
Set.prototype.add (
value
)
24.2.4.2
Set.prototype.clear ( )
24.2.4.3
Set.prototype.constructor
24.2.4.4
Set.prototype.delete (
value
)
24.2.4.5
Set.prototype.difference (
other
)
24.2.4.6
Set.prototype.entries ( )
24.2.4.7
Set.prototype.forEach (
callback
[ ,
thisArg
] )
24.2.4.8
Set.prototype.has (
value
)
24.2.4.9
Set.prototype.intersection (
other
)
24.2.4.10
Set.prototype.isDisjointFrom (
other
)
24.2.4.11
Set.prototype.isSubsetOf (
other
)
24.2.4.12
Set.prototype.isSupersetOf (
other
)
24.2.4.13
Set.prototype.keys ( )
24.2.4.14
get Set.prototype.size
24.2.4.15
Set.prototype.symmetricDifference (
other
)
24.2.4.16
Set.prototype.union (
other
)
24.2.4.17
Set.prototype.values ( )
24.2.4.18
Set.prototype [ %Symbol.iterator% ] ( )
24.2.4.19
Set.prototype [ %Symbol.toStringTag% ]
24.2.5
Properties of Set Instances
+
24.2.6
Set Iterator Objects
24.2.6.1
CreateSetIterator (
set
,
kind
)
+
24.2.6.2
The %SetIteratorPrototype% Object
24.2.6.2.1
%SetIteratorPrototype%.next ( )
24.2.6.2.2
%SetIteratorPrototype% [ %Symbol.toStringTag% ]
+
24.3
WeakMap Objects
+
24.3.1
The WeakMap Constructor
24.3.1.1
WeakMap ( [
iterable
] )
+
24.3.2
Properties of the WeakMap Constructor
24.3.2.1
WeakMap.prototype
+
24.3.3
Properties of the WeakMap Prototype Object
24.3.3.1
WeakMap.prototype.constructor
24.3.3.2
WeakMap.prototype.delete (
key
)
24.3.3.3
WeakMap.prototype.get (
key
)
24.3.3.4
WeakMap.prototype.getOrInsert (
key
,
value
)
24.3.3.5
WeakMap.prototype.getOrInsertComputed (
key
,
callback
)
24.3.3.6
WeakMap.prototype.has (
key
)
24.3.3.7
WeakMap.prototype.set (
key
,
value
)
24.3.3.8
WeakMap.prototype [ %Symbol.toStringTag% ]
24.3.4
Properties of WeakMap Instances
+
24.4
WeakSet Objects
+
24.4.1
The WeakSet Constructor
24.4.1.1
WeakSet ( [
iterable
] )
+
24.4.2
Properties of the WeakSet Constructor
24.4.2.1
WeakSet.prototype
+
24.4.3
Properties of the WeakSet Prototype Object
24.4.3.1
WeakSet.prototype.add (
value
)
24.4.3.2
WeakSet.prototype.constructor
24.4.3.3
WeakSet.prototype.delete (
value
)
24.4.3.4
WeakSet.prototype.has (
value
)
24.4.3.5
WeakSet.prototype [ %Symbol.toStringTag% ]
24.4.4
Properties of WeakSet Instances
+
24.5
Abstract Operations for Keyed Collections
24.5.1
CanonicalizeKeyedCollectionKey (
key
)
+
25
Structured Data
+
25.1
ArrayBuffer Objects
25.1.1
Notation
25.1.2
Fixed-length and Resizable ArrayBuffer Objects
+
25.1.3
Abstract Operations For ArrayBuffer Objects
25.1.3.1
AllocateArrayBuffer (
constructor
,
byteLength
[ ,
maxByteLength
] )
25.1.3.2
ArrayBufferByteLength (
arrayBuffer
,
order
)
25.1.3.3
ArrayBufferCopyAndDetach (
arrayBuffer
,
newLength
,
preserveResizability
)
25.1.3.4
IsDetachedBuffer (
arrayBuffer
)
25.1.3.5
DetachArrayBuffer (
arrayBuffer
[ ,
key
] )
25.1.3.6
CloneArrayBuffer (
srcBuffer
,
srcByteOffset
,
srcLength
)
25.1.3.7
GetArrayBufferMaxByteLengthOption (
options
)
25.1.3.8
HostResizeArrayBuffer (
buffer
,
newByteLength
)
25.1.3.9
IsFixedLengthArrayBuffer (
arrayBuffer
)
25.1.3.10
IsUnsignedElementType (
type
)
25.1.3.11
IsUnclampedIntegerElementType (
type
)
25.1.3.12
IsBigIntElementType (
type
)
25.1.3.13
IsNoTearConfiguration (
type
,
order
)
25.1.3.14
RawBytesToNumeric (
type
,
rawBytes
,
isLittleEndian
)
25.1.3.15
GetRawBytesFromSharedBlock (
block
,
byteIndex
,
type
,
isTypedArray
,
order
)
25.1.3.16
GetValueFromBuffer (
arrayBuffer
,
byteIndex
,
type
,
isTypedArray
,
order
[ ,
isLittleEndian
] )
25.1.3.17
NumericToRawBytes (
type
,
value
,
isLittleEndian
)
25.1.3.18
SetValueInBuffer (
arrayBuffer
,
byteIndex
,
type
,
value
,
isTypedArray
,
order
[ ,
isLittleEndian
] )
25.1.3.19
GetModifySetValueInBuffer (
arrayBuffer
,
byteIndex
,
type
,
value
,
op
)
+
25.1.4
The ArrayBuffer Constructor
25.1.4.1
ArrayBuffer (
length
[ ,
options
] )
+
25.1.5
Properties of the ArrayBuffer Constructor
25.1.5.1
ArrayBuffer.isView (
arg
)
25.1.5.2
ArrayBuffer.prototype
25.1.5.3
get ArrayBuffer [ %Symbol.species% ]
+
25.1.6
Properties of the ArrayBuffer Prototype Object
25.1.6.1
get ArrayBuffer.prototype.byteLength
25.1.6.2
ArrayBuffer.prototype.constructor
25.1.6.3
get ArrayBuffer.prototype.detached
25.1.6.4
get ArrayBuffer.prototype.maxByteLength
25.1.6.5
get ArrayBuffer.prototype.resizable
25.1.6.6
ArrayBuffer.prototype.resize (
newLength
)
25.1.6.7
ArrayBuffer.prototype.slice (
start
,
end
)
25.1.6.8
ArrayBuffer.prototype.transfer ( [
newLength
] )
25.1.6.9
ArrayBuffer.prototype.transferToFixedLength ( [
newLength
] )
25.1.6.10
ArrayBuffer.prototype [ %Symbol.toStringTag% ]
25.1.7
Properties of ArrayBuffer Instances
25.1.8
Resizable ArrayBuffer Guidelines
+
25.2
SharedArrayBuffer Objects
25.2.1
Fixed-length and Growable SharedArrayBuffer Objects
+
25.2.2
Abstract Operations for SharedArrayBuffer Objects
25.2.2.1
AllocateSharedArrayBuffer (
constructor
,
byteLength
[ ,
maxByteLength
] )
25.2.2.2
IsSharedArrayBuffer (
obj
)
25.2.2.3
IsGrowableSharedArrayBuffer (
obj
)
25.2.2.4
HostGrowSharedArrayBuffer (
buffer
,
newByteLength
)
+
25.2.3
The SharedArrayBuffer Constructor
25.2.3.1
SharedArrayBuffer (
length
[ ,
options
] )
+
25.2.4
Properties of the SharedArrayBuffer Constructor
25.2.4.1
SharedArrayBuffer.prototype
25.2.4.2
get SharedArrayBuffer [ %Symbol.species% ]
+
25.2.5
Properties of the SharedArrayBuffer Prototype Object
25.2.5.1
get SharedArrayBuffer.prototype.byteLength
25.2.5.2
SharedArrayBuffer.prototype.constructor
25.2.5.3
SharedArrayBuffer.prototype.grow (
newLength
)
25.2.5.4
get SharedArrayBuffer.prototype.growable
25.2.5.5
get SharedArrayBuffer.prototype.maxByteLength
25.2.5.6
SharedArrayBuffer.prototype.slice (
start
,
end
)
25.2.5.7
SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]
25.2.6
Properties of SharedArrayBuffer Instances
25.2.7
Growable SharedArrayBuffer Guidelines
+
25.3
DataView Objects
+
25.3.1
Abstract Operations For DataView Objects
25.3.1.1
DataView With Buffer Witness Records
25.3.1.2
MakeDataViewWithBufferWitnessRecord (
obj
,
order
)
25.3.1.3
GetViewByteLength (
viewRecord
)
25.3.1.4
IsViewOutOfBounds (
viewRecord
)
25.3.1.5
GetViewValue (
view
,
requestIndex
,
isLittleEndian
,
type
)
25.3.1.6
SetViewValue (
view
,
requestIndex
,
isLittleEndian
,
type
,
value
)
+
25.3.2
The DataView Constructor
25.3.2.1
DataView (
buffer
[ ,
byteOffset
[ ,
byteLength
] ] )
+
25.3.3
Properties of the DataView Constructor
25.3.3.1
DataView.prototype
+
25.3.4
Properties of the DataView Prototype Object
25.3.4.1
get DataView.prototype.buffer
25.3.4.2
get DataView.prototype.byteLength
25.3.4.3
get DataView.prototype.byteOffset
25.3.4.4
DataView.prototype.constructor
25.3.4.5
DataView.prototype.getBigInt64 (
byteOffset
[ ,
littleEndian
] )
25.3.4.6
DataView.prototype.getBigUint64 (
byteOffset
[ ,
littleEndian
] )
25.3.4.7
DataView.prototype.getFloat16 (
byteOffset
[ ,
littleEndian
] )
25.3.4.8
DataView.prototype.getFloat32 (
byteOffset
[ ,
littleEndian
] )
25.3.4.9
DataView.prototype.getFloat64 (
byteOffset
[ ,
littleEndian
] )
25.3.4.10
DataView.prototype.getInt8 (
byteOffset
)
25.3.4.11
DataView.prototype.getInt16 (
byteOffset
[ ,
littleEndian
] )
25.3.4.12
DataView.prototype.getInt32 (
byteOffset
[ ,
littleEndian
] )
25.3.4.13
DataView.prototype.getUint8 (
byteOffset
)
25.3.4.14
DataView.prototype.getUint16 (
byteOffset
[ ,
littleEndian
] )
25.3.4.15
DataView.prototype.getUint32 (
byteOffset
[ ,
littleEndian
] )
25.3.4.16
DataView.prototype.setBigInt64 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.17
DataView.prototype.setBigUint64 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.18
DataView.prototype.setFloat16 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.19
DataView.prototype.setFloat32 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.20
DataView.prototype.setFloat64 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.21
DataView.prototype.setInt8 (
byteOffset
,
value
)
25.3.4.22
DataView.prototype.setInt16 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.23
DataView.prototype.setInt32 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.24
DataView.prototype.setUint8 (
byteOffset
,
value
)
25.3.4.25
DataView.prototype.setUint16 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.26
DataView.prototype.setUint32 (
byteOffset
,
value
[ ,
littleEndian
] )
25.3.4.27
DataView.prototype [ %Symbol.toStringTag% ]
25.3.5
Properties of DataView Instances
+
25.4
The Atomics Object
25.4.1
Waiter Record
25.4.2
WaiterList Records
+
25.4.3
Abstract Operations for Atomics
25.4.3.1
ValidateIntegerTypedArray (
typedArray
,
waitable
)
25.4.3.2
ValidateAtomicAccess (
taRecord
,
requestIndex
)
25.4.3.3
ValidateAtomicAccessOnIntegerTypedArray (
typedArray
,
requestIndex
)
25.4.3.4
RevalidateAtomicAccess (
typedArray
,
byteIndexInBuffer
)
25.4.3.5
GetWaiterList (
block
,
i
)
25.4.3.6
EnterCriticalSection (
WL
)
25.4.3.7
LeaveCriticalSection (
WL
)
25.4.3.8
AddWaiter (
WL
,
waiterRecord
)
25.4.3.9
RemoveWaiter (
WL
,
waiterRecord
)
25.4.3.10
RemoveWaiters (
WL
,
c
)
25.4.3.11
SuspendThisAgent (
WL
,
waiterRecord
)
25.4.3.12
NotifyWaiter (
WL
,
waiterRecord
)
25.4.3.13
EnqueueResolveInAgentJob (
agentSignifier
,
promiseCapability
,
resolution
)
25.4.3.14
DoWait (
mode
,
typedArray
,
index
,
value
,
timeout
)
25.4.3.15
EnqueueAtomicsWaitAsyncTimeoutJob (
WL
,
waiterRecord
)
25.4.3.16
AtomicCompareExchangeInSharedBlock (
block
,
byteIndexInBuffer
,
elementSize
,
expectedBytes
,
replacementBytes
)
25.4.3.17
AtomicReadModifyWrite (
typedArray
,
index
,
value
,
op
)
25.4.3.18
ByteListBitwiseOp (
op
,
xBytes
,
yBytes
)
25.4.3.19
ByteListEqual (
xBytes
,
yBytes
)
25.4.4
Atomics.add (
typedArray
,
index
,
value
)
25.4.5
Atomics.and (
typedArray
,
index
,
value
)
25.4.6
Atomics.compareExchange (
typedArray
,
index
,
expectedValue
,
replacementValue
)
25.4.7
Atomics.exchange (
typedArray
,
index
,
value
)
25.4.8
Atomics.isLockFree (
size
)
25.4.9
Atomics.load (
typedArray
,
index
)
25.4.10
Atomics.or (
typedArray
,
index
,
value
)
25.4.11
Atomics.store (
typedArray
,
index
,
value
)
25.4.12
Atomics.sub (
typedArray
,
index
,
value
)
25.4.13
Atomics.wait (
typedArray
,
index
,
value
,
timeout
)
25.4.14
Atomics.waitAsync (
typedArray
,
index
,
value
,
timeout
)
25.4.15
Atomics.notify (
typedArray
,
index
,
count
)
25.4.16
Atomics.xor (
typedArray
,
index
,
value
)
25.4.17
Atomics [ %Symbol.toStringTag% ]
+
25.5
The JSON Object
+
25.5.1
JSON.parse (
text
[ ,
reviver
] )
25.5.1.1
ParseJSON (
text
)
25.5.1.2
InternalizeJSONProperty (
holder
,
name
,
reviver
)
+
25.5.2
JSON.stringify (
value
[ ,
replacer
[ ,
space
] ] )
25.5.2.1
JSON Serialization Record
25.5.2.2
SerializeJSONProperty (
state
,
key
,
holder
)
25.5.2.3
QuoteJSONString (
value
)
25.5.2.4
UnicodeEscape (
C
)
25.5.2.5
SerializeJSONObject (
state
,
value
)
25.5.2.6
SerializeJSONArray (
state
,
value
)
25.5.3
JSON [ %Symbol.toStringTag% ]
+
26
Managing Memory
+
26.1
WeakRef Objects
+
26.1.1
The WeakRef Constructor
26.1.1.1
WeakRef (
target
)
+
26.1.2
Properties of the WeakRef Constructor
26.1.2.1
WeakRef.prototype
+
26.1.3
Properties of the WeakRef Prototype Object
26.1.3.1
WeakRef.prototype.constructor
26.1.3.2
WeakRef.prototype.deref ( )
26.1.3.3
WeakRef.prototype [ %Symbol.toStringTag% ]
+
26.1.4
WeakRef Abstract Operations
26.1.4.1
WeakRefDeref (
weakRef
)
26.1.5
Properties of WeakRef Instances
+
26.2
FinalizationRegistry Objects
+
26.2.1
The FinalizationRegistry Constructor
26.2.1.1
FinalizationRegistry (
cleanupCallback
)
+
26.2.2
Properties of the FinalizationRegistry Constructor
26.2.2.1
FinalizationRegistry.prototype
+
26.2.3
Properties of the FinalizationRegistry Prototype Object
26.2.3.1
FinalizationRegistry.prototype.constructor
26.2.3.2
FinalizationRegistry.prototype.register (
target
,
heldValue
[ ,
unregisterToken
] )
26.2.3.3
FinalizationRegistry.prototype.unregister (
unregisterToken
)
26.2.3.4
FinalizationRegistry.prototype [ %Symbol.toStringTag% ]
26.2.4
Properties of FinalizationRegistry Instances
+
27
Control Abstraction Objects
+
27.1
Iteration
+
27.1.1
Common Iteration Interfaces
27.1.1.1
The Iterable Interface
27.1.1.2
The Iterator Interface
27.1.1.3
The Async Iterable Interface
27.1.1.4
The Async Iterator Interface
27.1.1.5
The IteratorResult Interface
+
27.1.2
Iterator Helper Objects
+
27.1.2.1
The %IteratorHelperPrototype% Object
27.1.2.1.1
%IteratorHelperPrototype%.next ( )
27.1.2.1.2
%IteratorHelperPrototype%.return ( )
27.1.2.1.3
%IteratorHelperPrototype% [ %Symbol.toStringTag% ]
+
27.1.3
Iterator Objects
+
27.1.3.1
The Iterator Constructor
27.1.3.1.1
Iterator ( )
+
27.1.3.2
Properties of the Iterator Constructor
27.1.3.2.1
Iterator.concat ( ...
items
)
+
27.1.3.2.2
Iterator.from (
O
)
+
27.1.3.2.2.1
The %WrapForValidIteratorPrototype% Object
27.1.3.2.2.1.1
%WrapForValidIteratorPrototype%.next ( )
27.1.3.2.2.1.2
%WrapForValidIteratorPrototype%.return ( )
27.1.3.2.3
Iterator.prototype
+
27.1.3.3
Properties of the Iterator Prototype Object
+
27.1.3.3.1
Iterator.prototype.constructor
27.1.3.3.1.1
get Iterator.prototype.constructor
27.1.3.3.1.2
set Iterator.prototype.constructor
27.1.3.3.2
Iterator.prototype.drop (
limit
)
27.1.3.3.3
Iterator.prototype.every (
predicate
)
27.1.3.3.4
Iterator.prototype.filter (
predicate
)
27.1.3.3.5
Iterator.prototype.find (
predicate
)
27.1.3.3.6
Iterator.prototype.flatMap (
mapper
)
27.1.3.3.7
Iterator.prototype.forEach (
procedure
)
27.1.3.3.8
Iterator.prototype.map (
mapper
)
27.1.3.3.9
Iterator.prototype.reduce (
reducer
[ ,
initialValue
] )
27.1.3.3.10
Iterator.prototype.some (
predicate
)
27.1.3.3.11
Iterator.prototype.take (
limit
)
27.1.3.3.12
Iterator.prototype.toArray ( )
27.1.3.3.13
Iterator.prototype [ %Symbol.iterator% ] ( )
+
27.1.3.3.14
Iterator.prototype [ %Symbol.toStringTag% ]
27.1.3.3.14.1
get Iterator.prototype [ %Symbol.toStringTag% ]
27.1.3.3.14.2
set Iterator.prototype [ %Symbol.toStringTag% ]
+
27.1.4
The %AsyncIteratorPrototype% Object
27.1.4.1
%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )
+
27.1.5
Async-from-Sync Iterator Objects
27.1.5.1
CreateAsyncFromSyncIterator (
syncIteratorRecord
)
+
27.1.5.2
The %AsyncFromSyncIteratorPrototype% Object
27.1.5.2.1
%AsyncFromSyncIteratorPrototype%.next ( [
value
] )
27.1.5.2.2
%AsyncFromSyncIteratorPrototype%.return ( [
value
] )
27.1.5.2.3
%AsyncFromSyncIteratorPrototype%.throw ( [
value
] )
27.1.5.3
Properties of Async-from-Sync Iterator Instances
27.1.5.4
AsyncFromSyncIteratorContinuation (
result
,
promiseCapability
,
syncIteratorRecord
,
closeOnRejection
)
+
27.2
Promise Objects
+
27.2.1
Promise Abstract Operations
+
27.2.1.1
PromiseCapability Records
27.2.1.1.1
IfAbruptRejectPromise (
value
,
capability
)
27.2.1.2
PromiseReaction Records
27.2.1.3
CreateResolvingFunctions (
promise
)
27.2.1.4
FulfillPromise (
promise
,
value
)
27.2.1.5
NewPromiseCapability (
C
)
27.2.1.6
IsPromise (
x
)
27.2.1.7
RejectPromise (
promise
,
reason
)
27.2.1.8
TriggerPromiseReactions (
reactions
,
argument
)
27.2.1.9
HostPromiseRejectionTracker (
promise
,
operation
)
+
27.2.2
Promise Jobs
27.2.2.1
NewPromiseReactionJob (
reaction
,
argument
)
27.2.2.2
NewPromiseResolveThenableJob (
promiseToResolve
,
thenable
,
then
)
+
27.2.3
The Promise Constructor
27.2.3.1
Promise (
executor
)
+
27.2.4
Properties of the Promise Constructor
+
27.2.4.1
Promise.all (
iterable
)
27.2.4.1.1
GetPromiseResolve (
promiseConstructor
)
27.2.4.1.2
PerformPromiseAll (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
+
27.2.4.2
Promise.allSettled (
iterable
)
27.2.4.2.1
PerformPromiseAllSettled (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
+
27.2.4.3
Promise.any (
iterable
)
27.2.4.3.1
PerformPromiseAny (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
27.2.4.4
Promise.prototype
+
27.2.4.5
Promise.race (
iterable
)
27.2.4.5.1
PerformPromiseRace (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
27.2.4.6
Promise.reject (
r
)
+
27.2.4.7
Promise.resolve (
x
)
27.2.4.7.1
PromiseResolve (
C
,
x
)
27.2.4.8
Promise.try (
callback
, ...
args
)
27.2.4.9
Promise.withResolvers ( )
27.2.4.10
get Promise [ %Symbol.species% ]
+
27.2.5
Properties of the Promise Prototype Object
27.2.5.1
Promise.prototype.catch (
onRejected
)
27.2.5.2
Promise.prototype.constructor
27.2.5.3
Promise.prototype.finally (
onFinally
)
+
27.2.5.4
Promise.prototype.then (
onFulfilled
,
onRejected
)
27.2.5.4.1
PerformPromiseThen (
promise
,
onFulfilled
,
onRejected
[ ,
resultCapability
] )
27.2.5.5
Promise.prototype [ %Symbol.toStringTag% ]
27.2.6
Properties of Promise Instances
+
27.3
GeneratorFunction Objects
+
27.3.1
The GeneratorFunction Constructor
27.3.1.1
GeneratorFunction ( ...
parameterArgs
,
bodyArg
)
+
27.3.2
Properties of the GeneratorFunction Constructor
27.3.2.1
GeneratorFunction.prototype
+
27.3.3
Properties of the GeneratorFunction Prototype Object
27.3.3.1
GeneratorFunction.prototype.constructor
27.3.3.2
GeneratorFunction.prototype.prototype
27.3.3.3
GeneratorFunction.prototype [ %Symbol.toStringTag% ]
+
27.3.4
GeneratorFunction Instances
27.3.4.1
length
27.3.4.2
name
27.3.4.3
prototype
+
27.4
AsyncGeneratorFunction Objects
+
27.4.1
The AsyncGeneratorFunction Constructor
27.4.1.1
AsyncGeneratorFunction ( ...
parameterArgs
,
bodyArg
)
+
27.4.2
Properties of the AsyncGeneratorFunction Constructor
27.4.2.1
AsyncGeneratorFunction.prototype
+
27.4.3
Properties of the AsyncGeneratorFunction Prototype Object
27.4.3.1
AsyncGeneratorFunction.prototype.constructor
27.4.3.2
AsyncGeneratorFunction.prototype.prototype
27.4.3.3
AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]
+
27.4.4
AsyncGeneratorFunction Instances
27.4.4.1
length
27.4.4.2
name
27.4.4.3
prototype
+
27.5
Generator Objects
+
27.5.1
The %GeneratorPrototype% Object
27.5.1.1
%GeneratorPrototype%.constructor
27.5.1.2
%GeneratorPrototype%.next (
value
)
27.5.1.3
%GeneratorPrototype%.return (
value
)
27.5.1.4
%GeneratorPrototype%.throw (
exception
)
27.5.1.5
%GeneratorPrototype% [ %Symbol.toStringTag% ]
27.5.2
Properties of Generator Instances
+
27.5.3
Generator Abstract Operations
27.5.3.1
GeneratorStart (
generator
,
generatorBody
)
27.5.3.2
GeneratorValidate (
generator
,
generatorBrand
)
27.5.3.3
GeneratorResume (
generator
,
value
,
generatorBrand
)
27.5.3.4
GeneratorResumeAbrupt (
generator
,
abruptCompletion
,
generatorBrand
)
27.5.3.5
GetGeneratorKind ( )
27.5.3.6
GeneratorYield (
iteratorResult
)
27.5.3.7
Yield (
value
)
27.5.3.8
CreateIteratorFromClosure (
closure
,
generatorBrand
,
generatorPrototype
[ ,
extraSlots
] )
+
27.6
AsyncGenerator Objects
+
27.6.1
The %AsyncGeneratorPrototype% Object
27.6.1.1
%AsyncGeneratorPrototype%.constructor
27.6.1.2
%AsyncGeneratorPrototype%.next (
value
)
27.6.1.3
%AsyncGeneratorPrototype%.return (
value
)
27.6.1.4
%AsyncGeneratorPrototype%.throw (
exception
)
27.6.1.5
%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]
27.6.2
Properties of AsyncGenerator Instances
+
27.6.3
AsyncGenerator Abstract Operations
27.6.3.1
AsyncGeneratorRequest Records
27.6.3.2
AsyncGeneratorStart (
generator
,
generatorBody
)
27.6.3.3
AsyncGeneratorValidate (
generator
,
generatorBrand
)
27.6.3.4
AsyncGeneratorEnqueue (
generator
,
completion
,
promiseCapability
)
27.6.3.5
AsyncGeneratorCompleteStep (
generator
,
completion
,
done
[ ,
realm
] )
27.6.3.6
AsyncGeneratorResume (
generator
,
completion
)
27.6.3.7
AsyncGeneratorUnwrapYieldResumption (
resumptionValue
)
27.6.3.8
AsyncGeneratorYield (
value
)
27.6.3.9
AsyncGeneratorAwaitReturn (
generator
)
27.6.3.10
AsyncGeneratorDrainQueue (
generator
)
+
27.7
AsyncFunction Objects
+
27.7.1
The AsyncFunction Constructor
27.7.1.1
AsyncFunction ( ...
parameterArgs
,
bodyArg
)
+
27.7.2
Properties of the AsyncFunction Constructor
27.7.2.1
AsyncFunction.prototype
+
27.7.3
Properties of the AsyncFunction Prototype Object
27.7.3.1
AsyncFunction.prototype.constructor
27.7.3.2
AsyncFunction.prototype [ %Symbol.toStringTag% ]
+
27.7.4
AsyncFunction Instances
27.7.4.1
length
27.7.4.2
name
+
27.7.5
Async Functions Abstract Operations
27.7.5.1
AsyncFunctionStart (
promiseCapability
,
asyncFunctionBody
)
27.7.5.2
AsyncBlockStart (
promiseCapability
,
asyncBody
,
asyncContext
)
27.7.5.3
Await (
value
)
+
28
Reflection
+
28.1
The Reflect Object
28.1.1
Reflect.apply (
target
,
thisArgument
,
argumentsList
)
28.1.2
Reflect.construct (
target
,
argumentsList
[ ,
newTarget
] )
28.1.3
Reflect.defineProperty (
target
,
propertyKey
,
attributes
)
28.1.4
Reflect.deleteProperty (
target
,
propertyKey
)
28.1.5
Reflect.get (
target
,
propertyKey
[ ,
receiver
] )
28.1.6
Reflect.getOwnPropertyDescriptor (
target
,
propertyKey
)
28.1.7
Reflect.getPrototypeOf (
target
)
28.1.8
Reflect.has (
target
,
propertyKey
)
28.1.9
Reflect.isExtensible (
target
)
28.1.10
Reflect.ownKeys (
target
)
28.1.11
Reflect.preventExtensions (
target
)
28.1.12
Reflect.set (
target
,
propertyKey
,
V
[ ,
receiver
] )
28.1.13
Reflect.setPrototypeOf (
target
,
proto
)
28.1.14
Reflect [ %Symbol.toStringTag% ]
+
28.2
Proxy Objects
+
28.2.1
The Proxy Constructor
28.2.1.1
Proxy (
target
,
handler
)
+
28.2.2
Properties of the Proxy Constructor
28.2.2.1
Proxy.revocable (
target
,
handler
)
+
28.3
Module Namespace Objects
28.3.1
%Symbol.toStringTag%
+
29
Memory Model
29.1
Memory Model Fundamentals
29.2
Agent Events Records
29.3
Chosen Value Records
29.4
Candidate Executions
+
29.5
Abstract Operations for the Memory Model
29.5.1
EventSet (
execution
)
29.5.2
SharedDataBlockEventSet (
execution
)
29.5.3
HostEventSet (
execution
)
29.5.4
ComposeWriteEventBytes (
execution
,
byteIndex
,
Ws
)
29.5.5
ValueOfReadEvent (
execution
,
R
)
+
29.6
Relations of Candidate Executions
29.6.1
is-agent-order-before
29.6.2
reads-bytes-from
29.6.3
reads-from
29.6.4
host-synchronizes-with
29.6.5
synchronizes-with
29.6.6
happens-before
+
29.7
Properties of Valid Executions
29.7.1
Valid Chosen Reads
29.7.2
Coherent Reads
29.7.3
Tear Free Reads
29.7.4
Sequentially Consistent Atomics
29.7.5
Valid Executions
29.8
Races
29.9
Data Races
29.10
Data Race Freedom
29.11
Shared Memory Guidelines
+
Annex A
(informative)
Grammar Summary
A.1
Lexical Grammar
A.2
Expressions
A.3
Statements
A.4
Functions and Classes
A.5
Scripts and Modules
A.6
Number Conversions
A.7
Time Zone Offset String Format
A.8
Regular Expressions
+
Annex B
(normative)
Additional ECMAScript Features for Web Browsers
+
B.1
Additional Syntax
B.1.1
HTML-like Comments
+
B.1.2
Regular Expressions Patterns
B.1.2.1
SS: Early Errors
B.1.2.2
SS: CountLeftCapturingParensWithin and CountLeftCapturingParensBefore
B.1.2.3
SS: IsCharacterClass
B.1.2.4
SS: CharacterValue
B.1.2.5
RS: CompileSubpattern
B.1.2.6
RS: CompileAssertion
B.1.2.7
RS: CompileAtom
+
B.1.2.8
RS: CompileToCharSet
B.1.2.8.1
CharacterRangeOrUnion (
rer
,
A
,
B
)
B.1.2.9
SS: ParsePattern (
patternText
,
u
,
v
)
+
B.2
Additional Built-in Properties
+
B.2.1
Additional Properties of the Global Object
B.2.1.1
escape (
string
)
B.2.1.2
unescape (
string
)
+
B.2.2
Additional Properties of the String.prototype Object
B.2.2.1
String.prototype.substr (
start
,
length
)
+
B.2.2.2
String.prototype.anchor (
name
)
B.2.2.2.1
CreateHTML (
string
,
tag
,
attribute
,
value
)
B.2.2.3
String.prototype.big ( )
B.2.2.4
String.prototype.blink ( )
B.2.2.5
String.prototype.bold ( )
B.2.2.6
String.prototype.fixed ( )
B.2.2.7
String.prototype.fontcolor (
colour
)
B.2.2.8
String.prototype.fontsize (
size
)
B.2.2.9
String.prototype.italics ( )
B.2.2.10
String.prototype.link (
url
)
B.2.2.11
String.prototype.small ( )
B.2.2.12
String.prototype.strike ( )
B.2.2.13
String.prototype.sub ( )
B.2.2.14
String.prototype.sup ( )
B.2.2.15
String.prototype.trimLeft ( )
B.2.2.16
String.prototype.trimRight ( )
+
B.2.3
Additional Properties of the Date.prototype Object
B.2.3.1
Date.prototype.getYear ( )
B.2.3.2
Date.prototype.setYear (
year
)
B.2.3.3
Date.prototype.toGMTString ( )
+
B.2.4
Additional Properties of the RegExp.prototype Object
B.2.4.1
RegExp.prototype.compile (
pattern
,
flags
)
+
B.3
Other Additional Features
B.3.1
Labelled Function Declarations
B.3.2
Block-Level Function Declarations Web Legacy Compatibility Semantics
B.3.3
FunctionDeclarations in IfStatement Statement Clauses
B.3.4
VariableStatements in Catch Blocks
B.3.5
Initializers in ForIn Statement Heads
B.3.6
The
[[IsHTMLDDA]]
Internal Slot
B.3.7
Non-default behaviour in HostMakeJobCallback
B.3.8
Non-default behaviour in HostEnsureCanAddPrivateElement
B.3.9
Runtime Errors for Function Call Assignment Targets
Annex C
(informative)
The Strict Mode of ECMAScript
+
Annex D
(informative)
Host Layering Points
D.1
Host Hooks
D.2
Host-defined Fields
D.3
Host-defined Objects
D.4
Running Jobs
D.5
Internal Methods of Exotic Objects
D.6
Built-in Objects and Methods
Annex E
(informative)
Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact
Annex F
(informative)
Additions and Changes That Introduce Incompatibilities with Prior Editions
Bibliography
Colophon
Copyright & Software License
Draft ECMA-262 / February 17, 2026
ECMAScript® 2026 Language Specification
About this Specification
The document at
https://tc39.es/ecma262/
is the most accurate and up-to-date ECMAScript specification. It contains the content of the most recent yearly snapshot plus any
finished proposals
— those that have reached Stage 4 in the
proposal process
and thus are implemented in several implementations and will be included in the next yearly snapshot. Historical snapshots are available at
https://ecma-international.org/publications-and-standards/standards/ecma-262/
.
This document is available as
a single page
and as
multiple pages
.
Contributing to this Specification
This specification is developed on GitHub with the help of the ECMAScript community. There are a number of ways to contribute to the development of this specification:
GitHub Repository:
https://github.com/tc39/ecma262
Issues:
All Issues
,
File a New Issue
Pull Requests:
All Pull Requests
,
Create a New Pull Request
Test Suite:
Test262
Editors:
Shu-yu Guo
Michael Ficarra
(
@michael.ficarra.me
)
Kevin Gibbons
Community:
Discourse:
https://es.discourse.group/
Chat:
Matrix
Mailing
List
Archives:
https://esdiscuss.org/
Refer to the
colophon
for more information on how this document is created.
Introduction
This Ecma Standard defines the ECMAScript 2026 Language. It is the seventeenth edition of the ECMAScript Language Specification. ECMAScript is based on several originating technologies, the most well-known being JavaScript (Netscape) and JScript (Microsoft). The language was invented by Brendan Eich at Netscape and first appeared in that company's Navigator 2.0 browser. Though best known as the language embedded in web browsers, it has also been widely adopted for use outside the browser, including server and embedded applications, and has grown to be one of the world's most widely used general-purpose programming languages.
The development of the ECMAScript Language Specification started in November 1996. The first edition of this Ecma Standard was adopted by the Ecma General Assembly of June 1997.
That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the fast-track procedure, and approved as international standard ISO/IEC 16262, in April 1998. The Ecma General Assembly of June 1998 approved the second edition of ECMA-262 to keep it fully aligned with ISO/IEC 16262. Changes between the first and the second edition are editorial in nature.
The third edition of the Standard introduced powerful regular expressions, better string handling, new control statements, try/catch exception handling, tighter definition of errors, formatting for numeric output and minor changes in anticipation of future language growth. The third edition of the ECMAScript standard was adopted by the Ecma General Assembly of December 1999 and published as ISO/IEC 16262:2002 in June 2002.
After publication of the third edition, ECMAScript achieved massive adoption in conjunction with the World Wide Web where it has become the programming language that is supported by essentially all web browsers. Significant work was done to develop a fourth edition of ECMAScript. However, that work was not completed and not published as the fourth edition of ECMAScript but some of it was incorporated into the development of the sixth edition.
The fifth edition of ECMAScript (published as ECMA-262 5
th
edition) codified de facto interpretations of the language specification that have become common among browser implementations and added support for new features that had emerged since the publication of the third edition. Such features include
accessor properties
, reflective creation and inspection of objects, program control of property attributes, additional array manipulation functions, support for the JSON object encoding format, and a strict mode that provides enhanced error checking and program security. The fifth edition was adopted by the Ecma General Assembly of December 2009.
The fifth edition was submitted to ISO/IEC JTC 1 for adoption under the fast-track procedure, and approved as international standard ISO/IEC 16262:2011. Edition 5.1 of the ECMAScript Standard incorporated minor corrections and is the same text as ISO/IEC 16262:2011. The 5.1 Edition was adopted by the Ecma General Assembly of June 2011.
Focused development of the sixth edition started in 2009, as the fifth edition was being prepared for publication. However, this was preceded by significant experimentation and language enhancement design efforts dating to the publication of the third edition in 1999. In a very real sense, the completion of the sixth edition is the culmination of a fifteen year effort. The goals for this edition included providing better support for large applications, library creation, and for use of ECMAScript as a compilation target for other languages. Some of its major enhancements included modules, class declarations, lexical block scoping,
iterators
and generators, promises for asynchronous programming, destructuring patterns, and proper tail calls. The ECMAScript library of built-ins was expanded to support additional data abstractions including maps, sets, and arrays of binary numeric values as well as additional support for Unicode supplementary characters in strings and regular expressions. The built-ins were also made extensible via subclassing. The sixth edition provides the foundation for regular, incremental language and library enhancements. The sixth edition was adopted by the General Assembly of June 2015.
ECMAScript 2016 was the first ECMAScript edition released under Ecma TC39's new yearly release cadence and open development process. A plain-text source document was built from the ECMAScript 2015 source document to serve as the base for further development entirely on GitHub. Over the year of this standard's development, hundreds of pull requests and issues were filed representing thousands of bug fixes, editorial fixes and other improvements. Additionally, numerous software tools were developed to aid in this effort including Ecmarkup, Ecmarkdown, and Grammarkdown. ES2016 also included support for a new exponentiation operator and adds a new method to
Array.prototype
called
includes
.
ECMAScript 2017 introduced Async Functions, Shared Memory, and Atomics along with smaller language and library enhancements, bug fixes, and editorial updates. Async functions improve the asynchronous programming experience by providing syntax for promise-returning functions. Shared Memory and Atomics introduce a new
memory model
that allows multi-
agent
programs to communicate using atomic operations that ensure a well-defined execution order even on parallel CPUs. It also included new static methods on Object:
Object.values
,
Object.entries
, and
Object.getOwnPropertyDescriptors
.
ECMAScript 2018 introduced support for asynchronous iteration via the
async iterator
protocol and async generators. It also included four new regular expression features: the
dotAll
flag, named capture groups, Unicode property escapes, and look-behind assertions. Lastly it included object rest and spread properties.
ECMAScript 2019 introduced a few new built-in functions:
flat
and
flatMap
on
Array.prototype
for flattening arrays,
Object.fromEntries
for directly turning the return value of
Object.entries
into a new Object, and
trimStart
and
trimEnd
on
String.prototype
as better-named alternatives to the widely implemented but non-standard
String.prototype.trimLeft
and
trimRight
built-ins. In addition, it included a few minor updates to syntax and semantics. Updated syntax included optional catch binding parameters and allowing U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) in string literals to align with JSON. Other updates included requiring that
Array.prototype.sort
be a stable sort, requiring that
JSON.stringify
return well-formed UTF-8 regardless of input, and clarifying
Function.prototype.toString
by requiring that it either return the corresponding original source text or a standard placeholder.
ECMAScript 2020, the 11
th
edition, introduced the
matchAll
method for Strings, to produce an
iterator
for all match objects generated by a global regular expression;
import()
, a syntax to asynchronously import Modules with a dynamic specifier;
BigInt
, a new number primitive for working with arbitrary precision
integers
;
Promise.allSettled
, a new Promise combinator that does not short-circuit;
globalThis
, a universal way to access the global
this
value; dedicated
export * as ns from 'module'
syntax for use within modules; increased standardization of
for-in
enumeration order;
import.meta
, a
host
-populated object available in Modules that may contain contextual information about the Module; as well as adding two new syntax features to improve working with “nullish” values (
undefined
or
null
): nullish coalescing, a value selection operator; and optional chaining, a property access and function invocation operator that short-circuits if the value to access/invoke is nullish.
ECMAScript 2021, the 12
th
edition, introduced the
replaceAll
method for Strings;
Promise.any
, a Promise combinator that short-circuits when an input value is fulfilled;
AggregateError
, a new Error type to represent multiple errors at once; logical assignment operators (
??=
,
&&=
,
||=
);
WeakRef
, for referring to a target object without preserving it from garbage collection, and
FinalizationRegistry
, to manage registration and unregistration of cleanup operations performed when target objects are garbage collected; separators for numeric literals (
1_000
); and
Array.prototype.sort
was made more precise, reducing the amount of cases that result in an
implementation-defined
sort order
.
ECMAScript 2022, the 13
th
edition, introduced top-level
await
, allowing the
keyword
to be used at the top level of modules; new class elements: public and private instance fields, public and private static fields, private instance methods and accessors, and private static methods and accessors; static blocks inside classes, to perform per-class evaluation initialization; the
#x in obj
syntax, to test for presence of private fields on objects; regular expression match indices via the
/d
flag, which provides start and end indices for matched substrings; the
cause
property on
Error
objects, which can be used to record a causation chain in errors; the
at
method for Strings, Arrays, and
TypedArrays
, which allows relative indexing; and
Object.hasOwn
, a convenient alternative to
Object.prototype.hasOwnProperty
.
ECMAScript 2023, the 14
th
edition, introduced the
toSorted
,
toReversed
,
with
,
findLast
, and
findLastIndex
methods on
Array.prototype
and
TypedArray.prototype
, as well as the
toSpliced
method on
Array.prototype
; added support for
#!
comments at the beginning of files to better facilitate executable ECMAScript files; and allowed the use of most Symbols as keys in weak collections.
ECMAScript 2024, the 15
th
edition, added facilities for resizing and transferring ArrayBuffers and SharedArrayBuffers; added a new RegExp
/v
flag for creating RegExps with more advanced features for working with sets of strings; and introduced the
Promise.withResolvers
convenience method for constructing Promises, the
Object.groupBy
and
Map.groupBy
methods for aggregating data, the
Atomics.waitAsync
method for asynchronously waiting for a change to shared memory, and the
String.prototype.isWellFormed
and
String.prototype.toWellFormed
methods for checking and ensuring that strings contain only well-formed Unicode.
ECMAScript 2025, the 16
th
edition, added a new
Iterator
global with associated static and prototype methods for working with
iterators
; added methods to
Set.prototype
for performing common operations on Sets; added support for importing JSON modules as well as syntax for declaring attributes of imported modules; added the
RegExp.escape
method for escaping a string to be safely used in a regular expression; added syntax for enabling and disabling modifier flags inline within regular expressions; added the
Promise.try
method for calling functions which may or may not return a
Promise
and ensuring the result is always a
Promise
; and added a new
Float16Array
TypedArray
kind as well as the related
DataView.prototype.getFloat16
,
DataView.prototype.setFloat16
, and
Math.f16round
methods.
Dozens of individuals representing many organizations have made very significant contributions within Ecma TC39 to the development of this edition and to the prior editions. In addition, a vibrant community has emerged supporting TC39's ECMAScript efforts. This community has reviewed numerous drafts, filed thousands of bug reports, performed implementation experiments, contributed test suites, and educated the world-wide developer community about ECMAScript. Unfortunately, it is impossible to identify and acknowledge every person and organization who has contributed to this effort.
Allen Wirfs-Brock
ECMA-262, Project Editor, 6
th
Edition
Brian Terlson
ECMA-262, Project Editor, 7
th
through 10
th
Editions
Jordan Harband
ECMA-262, Project Editor, 10
th
through 12
th
Editions
Shu-yu Guo
ECMA-262, Project Editor, 12
th
through 16
th
Editions
Michael Ficarra
ECMA-262, Project Editor, 12
th
through 16
th
Editions
Kevin Gibbons
ECMA-262, Project Editor, 12
th
through 16
th
Editions
1
Scope
This Standard defines the ECMAScript 2026 general-purpose programming language.
2
Conformance
A conforming implementation of ECMAScript must provide and support all the types, values, objects, properties, functions, and program syntax and semantics described in this specification.
A conforming implementation of ECMAScript must interpret source text input in conformance with the latest version of the Unicode Standard and ISO/IEC 10646.
A conforming implementation of ECMAScript that provides an application programming interface (API) that supports programs that need to adapt to the linguistic and cultural conventions used by different human languages and countries must implement the interface defined by the most recent edition of ECMA-402 that is compatible with this specification.
A conforming implementation of ECMAScript may provide additional types, values, objects, properties, and functions beyond those described in this specification. In particular, a conforming implementation of ECMAScript may provide properties not described in this specification, and values for those properties, for objects that are described in this specification.
A conforming implementation of ECMAScript may support program and regular expression syntax not described in this specification. In particular, a conforming implementation of ECMAScript may support program syntax that makes use of any “future
reserved words
” noted in subclause
12.7.2
of this specification.
A conforming implementation of ECMAScript must not implement any extension that is listed as a Forbidden Extension in subclause
17.1
.
A conforming implementation of ECMAScript must not redefine any facilities that are not
implementation-defined
,
implementation-approximated
, or
host-defined
.
A conforming implementation of ECMAScript may choose to implement or not implement
Normative Optional
subclauses, unless otherwise indicated. Web browsers are generally required to implement all normative optional subclauses. (See Annex
B
.) If any Normative Optional behaviour is implemented, all of the behaviour in the containing Normative Optional clause must be implemented. A Normative Optional clause is denoted in this specification with the words "Normative Optional" in a coloured box, as shown below.
Normative Optional
2.1
Example Normative Optional Clause Heading
Example clause contents.
A conforming implementation of ECMAScript must implement
Legacy
subclauses, unless they are also marked as Normative Optional. All of the language features and behaviours specified within Legacy subclauses have one or more undesirable characteristics. However, their continued usage in existing applications prevents their removal from this specification. These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code.
Legacy
2.2
Example Legacy Clause Heading
Example clause contents.
Normative Optional
,
Legacy
2.3
Example Legacy Normative Optional Clause Heading
Example clause contents.
3
Normative References
The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.
IEEE 754-2019
,
IEEE Standard for Floating-Point Arithmetic
.
The Unicode Standard.
https://unicode.org/versions/latest
ISO/IEC 10646,
Information Technology — Universal Multiple-Octet Coded Character Set (UCS)
plus Amendment 1:2005, Amendment 2:2006, Amendment 3:2008, Amendment 4:2008, and additional amendments and corrigenda, or successor.
ECMA-402,
ECMAScript Internationalization API Specification
, specifically the annual edition corresponding to this edition of this specification.
https://www.ecma-international.org/publications-and-standards/standards/ecma-402/
ECMA-404,
The JSON Data Interchange Format
.
https://www.ecma-international.org/publications-and-standards/standards/ecma-404/
4
Overview
This section contains a non-normative overview of the ECMAScript language.
ECMAScript is an object-oriented programming language for performing computations and manipulating computational objects within a
host environment
. ECMAScript as defined here is not intended to be computationally self-sufficient; indeed, there are no provisions in this specification for input of external data or output of computed results. Instead, it is expected that the computational environment of an ECMAScript program will provide not only the objects and other facilities described in this specification but also certain environment-specific objects, whose description and behaviour are beyond the scope of this specification except to indicate that they may provide certain properties that can be accessed and certain functions that can be called from an ECMAScript program.
ECMAScript was originally designed to be used as a scripting language, but has become widely used as a general-purpose programming language. A
scripting language
is a programming language that is used to manipulate, customize, and automate the facilities of an existing system. In such systems, useful functionality is already available through a user interface, and the scripting language is a mechanism for exposing that functionality to program control. In this way, the existing system is said to provide a
host environment
of objects and facilities, which completes the capabilities of the scripting language. A scripting language is intended for use by both professional and non-professional programmers.
ECMAScript was originally designed to be a
Web scripting language
, providing a mechanism to enliven Web pages in browsers and to perform server computation as part of a Web-based client-server architecture. ECMAScript is now used to provide core scripting capabilities for a variety of
host environments
. Therefore the core language is specified in this document apart from any particular
host environment
.
ECMAScript usage has moved beyond simple scripting and it is now used for the full spectrum of programming tasks in many different environments and scales. As the usage of ECMAScript has expanded, so have the features and facilities it provides. ECMAScript is now a fully featured general-purpose programming language.
4.1
Web Scripting
A web browser provides an ECMAScript
host environment
for client-side computation including, for instance, objects that represent windows, menus, pop-ups, dialog boxes, text areas, anchors, frames, history, cookies, and input/output. Further, the
host environment
provides a means to attach scripting code to events such as change of focus, page and image loading, unloading, error and abort, selection, form submission, and mouse actions. Scripting code appears within the HTML and the displayed page is a combination of user interface elements and fixed and computed text and images. The scripting code is reactive to user interaction, and there is no need for a main program.
A web server provides a different
host environment
for server-side computation including objects representing requests, clients, and files; and mechanisms to lock and share data. By using browser-side and server-side scripting together, it is possible to distribute computation between the client and server while providing a customized user interface for a Web-based application.
Each Web browser and server that supports ECMAScript supplies its own
host environment
, completing the ECMAScript execution environment.
4.2
Hosts and Implementations
To aid integrating ECMAScript into
host environments
, this specification defers the definition of certain facilities (e.g.,
abstract operations
), either in whole or in part, to a source outside of this specification. Editorially, this specification distinguishes the following kinds of deferrals.
An
implementation
is an external source that further defines facilities enumerated in Annex
D
or those that are marked as
implementation-defined
or
implementation-approximated
. In informal use, an implementation refers to a concrete artefact, such as a particular web browser.
An
implementation-defined
facility is one that defers its definition to an external source without further qualification. This specification does not make any recommendations for particular behaviours, and conforming implementations are free to choose any behaviour within the constraints put forth by this specification.
An
implementation-approximated
facility is one that defers its definition to an external source while recommending an ideal behaviour. While conforming implementations are free to choose any behaviour within the constraints put forth by this specification, they are encouraged to strive to approximate the ideal. Some mathematical operations, such as
Math.exp
, are
implementation-approximated
.
A
host
is an external source that further defines facilities listed in Annex
D
but does not further define other
implementation-defined
or
implementation-approximated
facilities. In informal use, a
host
refers to the set of all implementations, such as the set of all web browsers, that interface with this specification in the same way via Annex
D
. A
host
is often an external specification, such as WHATWG HTML (
https://html.spec.whatwg.org/
). In other words, facilities that are
host-defined
are often further defined in external specifications.
A
host hook
is an abstract operation that is defined in whole or in part by an external source. All
host hooks
must be listed in Annex
D
. A
host hook
must conform to at least the following requirements:
It must return either a
normal completion
or a
throw completion
.
A
host-defined
facility is one that defers its definition to an external source without further qualification and is listed in Annex
D
. Implementations that are not
hosts
may also provide definitions for
host-defined
facilities.
A
host environment
is a particular choice of definition for all
host-defined
facilities. A
host environment
typically includes objects or functions which allow obtaining input and providing output as
host-defined
properties of the
global object
.
This specification follows the editorial convention of always using the most specific term. For example, if a facility is
host-defined
, it should not be referred to as
implementation-defined
.
Both
hosts
and implementations may interface with this specification via the language types, specification types,
abstract operations
, grammar productions, intrinsic objects, and intrinsic symbols defined herein.
4.3
ECMAScript Overview
The following is an informal overview of ECMAScript—not all parts of the language are described. This overview is not part of the standard proper.
ECMAScript is object-based: basic language and
host
facilities are provided by objects, and an ECMAScript program is a cluster of communicating objects. In ECMAScript, an
object
is a collection of zero or more
properties
each with
attributes
that determine how each property can be used—for example, when the Writable attribute for a property is set to
false
, any attempt by executed ECMAScript code to assign a different value to the property fails. Properties are containers that hold other objects,
primitive values
, or
functions
. A primitive value is a member of one of the following built-in types:
Undefined
,
Null
,
Boolean
,
Number
,
BigInt
,
String
, and
Symbol;
an object is a member of the built-in type
Object
; and a function is a callable object. A function that is associated with an object via a property is called a
method
.
ECMAScript defines a collection of
built-in objects
that round out the definition of ECMAScript entities. These built-in objects include the
global object
; objects that are fundamental to the
runtime semantics
of the language including
Object
,
Function
,
Boolean
,
Symbol
, and various
Error
objects; objects that represent and manipulate numeric values including
Math
,
Number
, and
Date
; the text processing objects
String
and
RegExp
; objects that are indexed collections of values including
Array
and nine different kinds of Typed Arrays whose elements all have a specific numeric data representation; keyed collections including
Map
and
Set
objects; objects supporting structured data including the
JSON
object,
ArrayBuffer
,
SharedArrayBuffer
, and
DataView
; objects supporting control abstractions including generator functions and
Promise
objects; and reflection objects including
Proxy
and
Reflect
.
ECMAScript also defines a set of built-in
operators
. ECMAScript operators include various unary operations, multiplicative operators, additive operators, bitwise shift operators, relational operators, equality operators, binary bitwise operators, binary logical operators, assignment operators, and the comma operator.
Large ECMAScript programs are supported by
modules
which allow a program to be divided into multiple sequences of statements and declarations. Each module explicitly identifies declarations it uses that need to be provided by other modules and which of its declarations are available for use by other modules.
ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax is relaxed to enable it to serve as an easy-to-use scripting language. For example, a variable is not required to have its type declared nor are types associated with properties, and defined functions are not required to have their declarations appear textually before calls to them.
4.3.1
Objects
Even though ECMAScript includes syntax for class definitions, ECMAScript objects are not fundamentally class-based such as those in C++, Smalltalk, or Java. Instead objects may be created in various ways including via a literal notation or via
constructors
which create objects and then execute code that initializes all or part of them by assigning initial values to their properties. Each
constructor
is a function that has a property named
"prototype"
that is used to implement
prototype-based inheritance
and
shared properties
. Objects are created by using
constructors
in
new
expressions; for example,
new Date(2009, 11)
creates a new Date object. Invoking a
constructor
without using
new
has consequences that depend on the
constructor
. For example,
Date()
produces a string representation of the current date and time rather than an object.
Every object created by a
constructor
has an implicit reference (called the object's
prototype
) to the value of its
constructor
's
"prototype"
property. Furthermore, a prototype may have a non-
null
implicit reference to its prototype, and so on; this is called the
prototype chain
. When a reference is made to a property in an object, that reference is to the property of that name in the first object in the prototype chain that contains a property of that name. In other words, first the object mentioned directly is examined for such a property; if that object contains the named property, that is the property to which the reference refers; if that object does not contain the named property, the prototype for that object is examined next; and so on.
Figure 1: Object/Prototype Relationships
In a class-based object-oriented language, in general, state is carried by instances, methods are carried by classes, and inheritance is only of structure and behaviour. In ECMAScript, the state and methods are carried by objects, while structure, behaviour, and state are all inherited.
All objects that do not directly contain a particular property that their prototype contains share that property and its value. Figure 1 illustrates this:
CF
is a
constructor
(and also an object). Five objects have been created by using
new
expressions:
cf
1
,
cf
2
,
cf
3
,
cf
4
, and
cf
5
. Each of these objects contains properties named
"q1"
and
"q2"
. The dashed lines represent the implicit prototype relationship; so, for example,
cf
3
's prototype is
CF
p
. The
constructor
,
CF
, has two properties itself, named
"P1"
and
"P2"
, which are not visible to
CF
p
,
cf
1
,
cf
2
,
cf
3
,
cf
4
, or
cf
5
. The property named
"CFP1"
in
CF
p
is shared by
cf
1
,
cf
2
,
cf
3
,
cf
4
, and
cf
5
(but not by
CF
), as are any properties found in
CF
p
's implicit prototype chain that are not named
"q1"
,
"q2"
, or
"CFP1"
. Notice that there is no implicit prototype link between
CF
and
CF
p
.
Unlike most class-based object languages, properties can be added to objects dynamically by assigning values to them. That is,
constructors
are not required to name or assign values to all or any of the constructed object's properties. In the above diagram, one could add a new shared property for
cf
1
,
cf
2
,
cf
3
,
cf
4
, and
cf
5
by assigning a new value to the property in
CF
p
.
Although ECMAScript objects are not inherently class-based, it is often convenient to define class-like abstractions based upon a common pattern of
constructor
functions, prototype objects, and methods. The ECMAScript built-in objects themselves follow such a class-like pattern. Beginning with ECMAScript 2015, the ECMAScript language includes syntactic class definitions that permit programmers to concisely define objects that conform to the same class-like abstraction pattern used by the built-in objects.
4.3.2
The Strict Variant of ECMAScript
The ECMAScript Language recognizes the possibility that some users of the language may wish to restrict their usage of some features available in the language. They might do so in the interests of security, to avoid what they consider to be error-prone features, to get enhanced error checking, or for other reasons of their choosing. In support of this possibility, ECMAScript defines a strict variant of the language. The strict variant of the language excludes some specific syntactic and semantic features of the regular ECMAScript language and modifies the detailed semantics of some features. The strict variant also specifies additional error conditions that must be reported by throwing error exceptions in situations that are not specified as errors by the non-strict form of the language.
The strict variant of ECMAScript is commonly referred to as the
strict mode
of the language. Strict mode selection and use of the strict mode syntax and semantics of ECMAScript is explicitly made at the level of individual
ECMAScript source text
units as described in
11.2.2
. Because strict mode is selected at the level of a syntactic source text unit, strict mode only imposes restrictions that have local effect within such a source text unit. Strict mode does not restrict or modify any aspect of the ECMAScript semantics that must operate consistently across multiple source text units. A complete ECMAScript program may be composed of both strict mode and non-strict mode
ECMAScript source text
units. In this case, strict mode only applies when actually executing code that is defined within a strict mode source text unit.
In order to conform to this specification, an ECMAScript implementation must implement both the full unrestricted ECMAScript language and the strict variant of the ECMAScript language as defined by this specification. In addition, an implementation must support the combination of unrestricted and strict mode source text units into a single composite program.
4.4
Terms and Definitions
For the purposes of this document, the following terms and definitions apply.
4.4.1
implementation-approximated
an
implementation-approximated
facility is defined in whole or in part by an external source but has a recommended, ideal behaviour in this specification
4.4.2
implementation-defined
an
implementation-defined
facility is defined in whole or in part by an external source to this specification
4.4.3
host-defined
same as
implementation-defined
Note
Editorially, see clause
4.2
.
4.4.4
type
set of data values as defined in clause
6
4.4.5
primitive value
member of one of the types Undefined, Null, Boolean, Number, BigInt, Symbol, or String as defined in clause
6
Note
A primitive value is a datum that is represented directly at the lowest level of the language implementation.
4.4.6
object
member of the type Object
Note
An object is a collection of properties and has a single prototype object. The prototype may be
null
.
4.4.7
constructor
function object
that creates and initializes objects
Note
The value of a
constructor
's
"prototype"
property is a prototype object that is used to implement inheritance and shared properties.
4.4.8
prototype
object that provides shared properties for other objects
Note
When a
constructor
creates an object, that object implicitly references the
constructor
's
"prototype"
property for the purpose of resolving property references. The
constructor
's
"prototype"
property can be referenced by the program expression
constructor
.prototype
, and properties added to an object's prototype are shared, through inheritance, by all objects sharing the prototype. Alternatively, a new object may be created with an explicitly specified prototype by using the
Object.create
built-in function.
4.4.9
ordinary object
object that has the default behaviour for the essential internal methods that must be supported by all objects
4.4.10
exotic object
object that does not have the default behaviour for one or more of the essential internal methods
Note
Any object that is not an
ordinary object
is an
exotic object
.
4.4.11
standard object
object whose semantics are defined by this specification
4.4.12
built-in object
object specified and supplied by an ECMAScript implementation
Note
Standard built-in objects are defined in this specification. An ECMAScript implementation may specify and supply additional kinds of built-in objects.
4.4.13
undefined value
primitive value used when a variable has not been assigned a value
4.4.14
Undefined type
type whose sole value is the
undefined
value
4.4.15
null value
primitive value that represents the intentional absence of any object value
4.4.16
Null type
type whose sole value is the
null
value
4.4.17
Boolean value
member of the
Boolean type
Note
There are only two Boolean values,
true
and
false
.
4.4.18
Boolean type
type consisting of the primitive values
true
and
false
4.4.19
Boolean object
member of the
Object type
that is an instance of the standard built-in Boolean
constructor
Note
A Boolean object is created by using the Boolean
constructor
in a
new
expression, supplying a Boolean value as an argument. The resulting object has an internal slot whose value is the Boolean value. A Boolean object can be coerced to a Boolean value.
4.4.20
String value
primitive value that is a
finite
ordered sequence of zero or more 16-bit unsigned
integer
values
Note
A String value is a member of the
String type
. Each
integer
value in the sequence usually represents a single 16-bit unit of UTF-16 text. However, ECMAScript does not place any restrictions or requirements on the values except that they must be 16-bit unsigned
integers
.
4.4.21
String type
set of all possible String values
4.4.22
String object
member of the
Object type
that is an instance of the standard built-in String
constructor
Note
A String object is created by using the String
constructor
in a
new
expression, supplying a String value as an argument. The resulting object has an internal slot whose value is the String value. A String object can be coerced to a String value by calling the String
constructor
as a function (
22.1.1.1
).
4.4.23
Number value
primitive value corresponding to a double-precision 64-bit binary format
IEEE 754-2019
value
Note
A Number value is a member of the
Number type
and is a direct representation of a number.
4.4.24
Number type
set of all possible Number values including
NaN
(“not a number”),
+∞
𝔽
(positive infinity), and
-∞
𝔽
(negative infinity)
4.4.25
Number object
member of the
Object type
that is an instance of the standard built-in Number
constructor
Note
A Number object is created by using the Number
constructor
in a
new
expression, supplying a Number value as an argument. The resulting object has an internal slot whose value is the Number value. A Number object can be coerced to a Number value by calling the Number
constructor
as a function (
21.1.1.1
).
4.4.26
Infinity
Number value that is the positive infinite Number value
4.4.27
NaN
Number value that is an
IEEE 754-2019
NaN (“not a number”) value
4.4.28
BigInt value
primitive value corresponding to an arbitrary-precision
integer
value
4.4.29
BigInt type
set of all possible BigInt values
4.4.30
BigInt object
member of the
Object type
that is an instance of the standard built-in BigInt
constructor
4.4.31
Symbol value
primitive value that represents a unique, non-String Object
property key
4.4.32
Symbol type
set of all possible Symbol values
4.4.33
Symbol object
member of the
Object type
that is an instance of the standard built-in Symbol
constructor
4.4.34
function
member of the
Object type
that may be invoked as a subroutine
Note
In addition to its properties, a function contains executable code and state that determine how it behaves when invoked. A function's code may or may not be written in ECMAScript.
4.4.35
built-in function
built-in object that is a function
Note
Examples of built-in functions include
parseInt
and
Math.exp
. A
host
or implementation may provide additional built-in functions that are not described in this specification.
4.4.36
built-in constructor
built-in function that is a
constructor
Note
Examples of built-in
constructors
include
Object
and
Function
. A
host
or implementation may provide additional built-in
constructors
that are not described in this specification.
4.4.37
property
part of an object that associates a key (either a String value or a Symbol value) and a value
Note
Depending upon the form of the property the value may be represented either directly as a data value (a primitive value, an object, or a
function object
) or indirectly by a pair of accessor functions.
4.4.38
method
function that is the value of a property
Note
When a function is called as a method of an object, the object is passed to the function as its
this
value.
4.4.39
built-in method
method that is a built-in function
Note
Standard built-in methods are defined in this specification. A
host
or implementation may provide additional built-in methods that are not described in this specification.
4.4.40
attribute
internal value that defines some characteristic of a property
4.4.41
own property
property that is directly contained by its object
4.4.42
inherited property
property of an object that is not an own property but is a property (either own or inherited) of the object's prototype
4.5
Organization of This Specification
The remainder of this specification is organized as follows:
Clause
5
defines the notational conventions used throughout the specification.
Clauses
6
through
10
define the execution environment within which ECMAScript programs operate.
Clauses
11
through
17
define the actual ECMAScript programming language including its syntactic encoding and the execution semantics of all language features.
Clauses
18
through
28
define the ECMAScript standard library. They include the definitions of all of the standard objects that are available for use by ECMAScript programs as they execute.
Clause
29
describes the memory consistency model of accesses on SharedArrayBuffer-backed memory and methods of the Atomics object.
5
Notational Conventions
5.1
Syntactic and Lexical Grammars
5.1.1
Context-Free Grammars
A
context-free grammar
consists of a number of
productions
. Each production has an abstract symbol called a
nonterminal
as its
left-hand side
, and a sequence of zero or more nonterminal and
terminal
symbols as its
right-hand side
. For each grammar, the terminal symbols are drawn from a specified alphabet.
A
chain production
is a production that has exactly one nonterminal symbol on its right-hand side along with zero or more terminal symbols.
Starting from a sentence consisting of a single distinguished nonterminal, called the
goal symbol
, a given context-free grammar specifies a
language
, namely, the (perhaps infinite) set of possible sequences of terminal symbols that can result from repeatedly replacing any nonterminal in the sequence with a right-hand side of a production for which the nonterminal is the left-hand side.
5.1.2
The Lexical and RegExp Grammars
A
lexical grammar
for ECMAScript is given in clause
12
. This grammar has as its terminal symbols Unicode code points that conform to the rules for
SourceCharacter
defined in
11.1
. It defines a set of productions, starting from the
goal symbol
InputElementDiv
,
InputElementTemplateTail
,
InputElementRegExp
,
InputElementRegExpOrTemplateTail
, or
InputElementHashbangOrRegExp
, that describe how sequences of such code points are translated into a sequence of input elements.
Input elements other than white space and comments form the terminal symbols for the syntactic grammar for ECMAScript and are called ECMAScript
tokens
. These tokens are the
reserved words
, identifiers, literals, and punctuators of the ECMAScript language. Moreover, line terminators, although not considered to be tokens, also become part of the stream of input elements and guide the process of automatic semicolon insertion (
12.10
). Simple white space and single-line comments are discarded and do not appear in the stream of input elements for the syntactic grammar. A
MultiLineComment
(that is, a comment of the form
/*
…
*/
regardless of whether it spans more than one line) is likewise simply discarded if it contains no line terminator; but if a
MultiLineComment
contains one or more line terminators, then it is replaced by a single line terminator, which becomes part of the stream of input elements for the syntactic grammar.
A
RegExp grammar
for ECMAScript is given in
22.2.1
. This grammar also has as its terminal symbols the code points as defined by
SourceCharacter
. It defines a set of productions, starting from the
goal symbol
Pattern
, that describe how sequences of code points are translated into regular expression patterns.
Productions of the lexical and RegExp grammars are distinguished by having two colons “
::
” as separating punctuation. The lexical and RegExp grammars share some productions.
5.1.3
The Numeric String Grammar
A
numeric string grammar
appears in
7.1.4.1
. It has as its terminal symbols
SourceCharacter
, and is used for translating Strings into numeric values starting from the
goal symbol
StringNumericLiteral
(which is similar to but distinct from the
lexical grammar for numeric literals
).
Productions of the numeric string grammar are distinguished by having three colons “
:::
” as punctuation, and are never used for parsing source text.
5.1.4
The Syntactic Grammar
The
syntactic grammar
for ECMAScript is given in clauses
13
through
16
. This grammar has ECMAScript tokens defined by the lexical grammar as its terminal symbols (
5.1.2
). It defines a set of productions, starting from two alternative
goal symbols
Script
and
Module
, that describe how sequences of tokens form syntactically correct independent components of ECMAScript programs.
When a stream of code points is to be parsed as an ECMAScript
Script
or
Module
, it is first converted to a stream of input elements by repeated application of the lexical grammar; this stream of input elements is then parsed by a single application of the syntactic grammar. The input stream is syntactically in error if the tokens in the stream of input elements cannot be parsed as a single instance of the goal nonterminal (
Script
or
Module
), with no tokens left over.
When a parse is successful, it constructs a
parse tree
, a rooted tree structure in which each node is a
Parse Node
. Each Parse Node is an
instance
of a symbol in the grammar; it represents a span of the source text that can be derived from that symbol. The root node of the parse tree, representing the whole of the source text, is an instance of the parse's
goal symbol
. When a Parse Node is an instance of a nonterminal, it is also an instance of some production that has that nonterminal as its left-hand side. Moreover, it has zero or more
children
, one for each symbol on the production's right-hand side: each child is a Parse Node that is an instance of the corresponding symbol.
New Parse Nodes are instantiated for each invocation of the parser and never reused between parses even of identical source text. Parse Nodes are considered
the same Parse Node
if and only if they represent the same span of source text, are instances of the same grammar symbol, and resulted from the same parser invocation.
Note 1
Parsing the same String multiple times will lead to different Parse Nodes. For example, consider:
let
str =
"1 + 1;"
;
eval
(str);
eval
(str);
Each call to
eval
converts the value of
str
into
ECMAScript source text
and performs an independent parse that creates its own separate tree of Parse Nodes. The trees are distinct even though each parse operates upon a source text that was derived from the same String value.
Note 2
Parse Nodes are specification artefacts, and implementations are not required to use an analogous data structure.
Productions of the syntactic grammar are distinguished by having just one colon “
:
” as punctuation.
The syntactic grammar as presented in clauses
13
through
16
is not a complete account of which token sequences are accepted as a correct ECMAScript
Script
or
Module
. Certain additional token sequences are also accepted, namely, those that would be described by the grammar if only semicolons were added to the sequence in certain places (such as before line terminator characters). Furthermore, certain token sequences that are described by the grammar are not considered acceptable if a line terminator character appears in certain “awkward” places.
In certain cases, in order to avoid ambiguities, the syntactic grammar uses generalized productions that permit token sequences that do not form a valid ECMAScript
Script
or
Module
. For example, this technique is used for object literals and object destructuring patterns. In such cases a more restrictive
supplemental grammar
is provided that further restricts the acceptable token sequences. Typically, an
early error
rule will then state that, in certain contexts, "
P
must cover
an
N
", where
P
is a Parse Node (an instance of the generalized production) and
N
is a nonterminal from the supplemental grammar. This means:
The sequence of tokens originally matched by
P
is parsed again using
N
as the
goal symbol
. If
N
takes grammatical parameters, then they are set to the same values used when
P
was originally parsed.
If the sequence of tokens can be parsed as a single instance of
N
, with no tokens left over, then:
We refer to that instance of
N
(a Parse Node, unique for a given
P
) as "the
N
that is
covered
by
P
".
All Early Error rules for
N
and its derived productions also apply to the
N
that is covered by
P
.
Otherwise (if the parse fails), it is an early Syntax Error.
5.1.5
Grammar Notation
5.1.5.1
Terminal Symbols
In the ECMAScript grammars, some terminal symbols are shown in
fixed-width
font. These are to appear in a source text exactly as written. All terminal symbol code points specified in this way are to be understood as the appropriate Unicode code points from the Basic Latin block, as opposed to any similar-looking code points from other Unicode ranges. A code point in a terminal symbol cannot be expressed by a
\
UnicodeEscapeSequence
.
In grammars whose terminal symbols are individual Unicode code points (i.e., the lexical, RegExp, and numeric string grammars), a contiguous run of multiple fixed-width code points appearing in a production is a simple shorthand for the same sequence of code points, written as standalone terminal symbols.
For example, the production:
HexIntegerLiteral
::
0x
HexDigits
is a shorthand for:
HexIntegerLiteral
::
0
x
HexDigits
In contrast, in the syntactic grammar, a contiguous run of fixed-width code points is a single terminal symbol.
Terminal symbols come in two other forms:
In the lexical and RegExp grammars, Unicode code points without a conventional printed representation are instead shown in the form "<ABBREV>" where "ABBREV" is a mnemonic for the code point or set of code points. These forms are defined in
Unicode Format-Control Characters
,
White Space
, and
Line Terminators
.
In the syntactic grammar, certain terminal symbols (e.g.
IdentifierName
and
RegularExpressionLiteral
) are shown in italics, as they refer to the nonterminals of the same name in the lexical grammar.
5.1.5.2
Nonterminal Symbols and Productions
Nonterminal symbols are shown in
italic
type. The definition of a nonterminal (also called a “production”) is introduced by the name of the nonterminal being defined followed by one or more colons. (The number of colons indicates to which grammar the production belongs.) One or more alternative right-hand sides for the nonterminal then follow on succeeding lines. For example, the syntactic definition:
WhileStatement
:
while
(
Expression
)
Statement
states that the nonterminal
WhileStatement
represents the token
while
, followed by a left parenthesis token, followed by an
Expression
, followed by a right parenthesis token, followed by a
Statement
. The occurrences of
Expression
and
Statement
are themselves nonterminals. As another example, the syntactic definition:
ArgumentList
:
AssignmentExpression
ArgumentList
,
AssignmentExpression
states that an
ArgumentList
may represent either a single
AssignmentExpression
or an
ArgumentList
, followed by a comma, followed by an
AssignmentExpression
. This definition of
ArgumentList
is recursive, that is, it is defined in terms of itself. The result is that an
ArgumentList
may contain any positive number of arguments, separated by commas, where each argument expression is an
AssignmentExpression
. Such recursive definitions of nonterminals are common.
5.1.5.3
Optional Symbols
The subscripted suffix “
opt
”, which may appear after a terminal or nonterminal, indicates an optional symbol. The alternative containing the optional symbol actually specifies two right-hand sides, one that omits the optional element and one that includes it. This means that:
VariableDeclaration
:
BindingIdentifier
Initializer
opt
is a convenient abbreviation for:
VariableDeclaration
:
BindingIdentifier
BindingIdentifier
Initializer
and that:
ForStatement
:
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
is a convenient abbreviation for:
ForStatement
:
for
(
LexicalDeclaration
;
Expression
opt
)
Statement
for
(
LexicalDeclaration
Expression
;
Expression
opt
)
Statement
which in turn is an abbreviation for:
ForStatement
:
for
(
LexicalDeclaration
;
)
Statement
for
(
LexicalDeclaration
;
Expression
)
Statement
for
(
LexicalDeclaration
Expression
;
)
Statement
for
(
LexicalDeclaration
Expression
;
Expression
)
Statement
so, in this example, the nonterminal
ForStatement
actually has four alternative right-hand sides.
5.1.5.4
Grammatical Parameters
A production may be parameterized by a subscripted annotation of the form “
[parameters]
”, which may appear as a suffix to the nonterminal symbol defined by the production. “
parameters
” may be either a single name or a comma separated list of names. A parameterized production is shorthand for a set of productions defining all combinations of the parameter names, preceded by an underscore, appended to the parameterized nonterminal symbol. This means that:
StatementList
[Return]
:
ReturnStatement
ExpressionStatement
is a convenient abbreviation for:
StatementList
:
ReturnStatement
ExpressionStatement
StatementList_Return
:
ReturnStatement
ExpressionStatement
and that:
StatementList
[Return, In]
:
ReturnStatement
ExpressionStatement
is an abbreviation for:
StatementList
:
ReturnStatement
ExpressionStatement
StatementList_Return
:
ReturnStatement
ExpressionStatement
StatementList_In
:
ReturnStatement
ExpressionStatement
StatementList_Return_In
:
ReturnStatement
ExpressionStatement
Multiple parameters produce a combinatoric number of productions, not all of which are necessarily referenced in a complete grammar.
References to nonterminals on the right-hand side of a production can also be parameterized. For example:
StatementList
:
ReturnStatement
ExpressionStatement
[+In]
is equivalent to saying:
StatementList
:
ReturnStatement
ExpressionStatement_In
and:
StatementList
:
ReturnStatement
ExpressionStatement
[~In]
is equivalent to:
StatementList
:
ReturnStatement
ExpressionStatement
A nonterminal reference may have both a parameter list and an “
opt
” suffix. For example:
VariableDeclaration
:
BindingIdentifier
Initializer
[+In]
opt
is an abbreviation for:
VariableDeclaration
:
BindingIdentifier
BindingIdentifier
Initializer_In
Prefixing a parameter name with “
?
” on a right-hand side nonterminal reference makes that parameter value dependent upon the occurrence of the parameter name on the reference to the current production's left-hand side symbol. For example:
VariableDeclaration
[In]
:
BindingIdentifier
Initializer
[?In]
is an abbreviation for:
VariableDeclaration
:
BindingIdentifier
Initializer
VariableDeclaration_In
:
BindingIdentifier
Initializer_In
If a right-hand side alternative is prefixed with “[+parameter]” that alternative is only available if the named parameter was used in referencing the production's nonterminal symbol. If a right-hand side alternative is prefixed with “[~parameter]” that alternative is only available if the named parameter was
not
used in referencing the production's nonterminal symbol. This means that:
StatementList
[Return]
:
[+Return]
ReturnStatement
ExpressionStatement
is an abbreviation for:
StatementList
:
ExpressionStatement
StatementList_Return
:
ReturnStatement
ExpressionStatement
and that:
StatementList
[Return]
:
[~Return]
ReturnStatement
ExpressionStatement
is an abbreviation for:
StatementList
:
ReturnStatement
ExpressionStatement
StatementList_Return
:
ExpressionStatement
5.1.5.5
one of
When the words “
one of
” follow the colon(s) in a grammar definition, they signify that each of the terminal symbols on the following line or lines is an alternative definition. For example, the lexical grammar for ECMAScript contains the production:
NonZeroDigit
::
one of
1
2
3
4
5
6
7
8
9
which is merely a convenient abbreviation for:
NonZeroDigit
::
1
2
3
4
5
6
7
8
9
5.1.5.6
[empty]
If the phrase “[empty]” appears as the right-hand side of a production, it indicates that the production's right-hand side contains no terminals or nonterminals.
5.1.5.7
Lookahead Restrictions
If the phrase “[lookahead =
seq
]” appears in the right-hand side of a production, it indicates that the production may only be used if the token sequence
seq
is a prefix of the immediately following input token sequence. Similarly, “[lookahead ∈
set
]”, where
set
is a
finite
non-empty set of token sequences, indicates that the production may only be used if some element of
set
is a prefix of the immediately following token sequence. For convenience, the set can also be written as a nonterminal, in which case it represents the set of all token sequences to which that nonterminal could expand. It is considered an editorial error if the nonterminal could expand to infinitely many distinct token sequences.
These conditions may be negated. “[lookahead ≠
seq
]” indicates that the containing production may only be used if
seq
is
not
a prefix of the immediately following input token sequence, and “[lookahead ∉
set
]” indicates that the production may only be used if
no
element of
set
is a prefix of the immediately following token sequence.
As an example, given the definitions:
DecimalDigit
::
one of
0
1
2
3
4
5
6
7
8
9
DecimalDigits
::
DecimalDigit
DecimalDigits
DecimalDigit
the definition:
LookaheadExample
::
n
[lookahead ∉ {
1
,
3
,
5
,
7
,
9
}]
DecimalDigits
DecimalDigit
[lookahead ∉
DecimalDigit
]
matches either the letter
n
followed by one or more decimal digits the first of which is even, or a decimal digit not followed by another decimal digit.
Note that when these phrases are used in the syntactic grammar, it may not be possible to unambiguously identify the immediately following token sequence because determining later tokens requires knowing which lexical
goal symbol
to use at later positions. As such, when these are used in the syntactic grammar, it is considered an editorial error for a token sequence
seq
to appear in a lookahead restriction (including as part of a set of sequences) if the choices of lexical
goal symbols
to use could change whether or not
seq
would be a prefix of the resulting token sequence.
5.1.5.8
[no
LineTerminator
here]
If the phrase “[no
LineTerminator
here]” appears in the right-hand side of a production of the syntactic grammar, it indicates that the production is
a restricted production
: it may not be used if a
LineTerminator
occurs in the input stream at the indicated position. For example, the production:
ThrowStatement
:
throw
[no
LineTerminator
here]
Expression
;
indicates that the production may not be used if a
LineTerminator
occurs in the script between the
throw
token and the
Expression
.
Unless the presence of a
LineTerminator
is forbidden by a restricted production, any number of occurrences of
LineTerminator
may appear between any two consecutive tokens in the stream of input elements without affecting the syntactic acceptability of the script.
5.1.5.9
but not
The right-hand side of a production may specify that certain expansions are not permitted by using the phrase “
but not
” and then indicating the expansions to be excluded. For example, the production:
Identifier
::
IdentifierName
but not
ReservedWord
means that the nonterminal
Identifier
may be replaced by any sequence of code points that could replace
IdentifierName
provided that the same sequence of code points could not replace
ReservedWord
.
5.1.5.10
Descriptive Phrases
Finally, a few nonterminal symbols are described by a descriptive phrase in sans-serif type in cases where it would be impractical to list all the alternatives:
SourceCharacter
::
any Unicode code point
5.2
Algorithm Conventions
The specification often uses a numbered list to specify steps in an algorithm. These algorithms are used to precisely specify the required semantics of ECMAScript language constructs. The algorithms are not intended to imply the use of any specific implementation technique. In practice, there may be more efficient algorithms available to implement a given feature.
Algorithms may be explicitly parameterized with an ordered, comma-separated sequence of alias names which may be used within the algorithm steps to reference the argument passed in that position. Optional parameters are denoted with surrounding brackets ([ ,
name
]) and are no different from required parameters within algorithm steps. A rest parameter may appear at the end of a parameter list, denoted with leading ellipsis (, ...
name
). The rest parameter captures all of the arguments provided following the required and optional parameters into a
List
. If there are no such additional arguments, that
List
is empty.
Algorithm steps may be subdivided into sequential substeps. Substeps are indented and may themselves be further divided into indented substeps. Outline numbering conventions are used to identify substeps with the first level of substeps labelled with lowercase alphabetic characters and the second level of substeps labelled with lowercase roman numerals. If more than three levels are required these rules repeat with the fourth level using numeric labels. For example:
Top-level step
Substep.
Substep.
Subsubstep.
Subsubsubstep
Subsubsubsubstep
Subsubsubsubsubstep
A step or substep may be written as an “if” predicate that conditions its substeps. In this case, the substeps are only applied if the predicate is true. If a step or substep begins with the word “else”, it is a predicate that is the negation of the preceding “if” predicate step at the same level.
A step may specify the iterative application of its substeps.
A step that begins with “
Assert
:” asserts an invariant condition of its algorithm. Such assertions are used to make explicit algorithmic invariants that would otherwise be implicit. Such assertions add no additional semantic requirements and hence need not be checked by an implementation. They are used simply to clarify algorithms.
Algorithm steps may declare named aliases for any value using the form “Let
x
be
someValue
”. These aliases are reference-like in that both
x
and
someValue
refer to the same underlying data and modifications to either are visible to both. Algorithm steps that want to avoid this reference-like behaviour should explicitly make a copy of the right-hand side: “Let
x
be a copy of
someValue
” creates a shallow copy of
someValue
.
Once declared, an alias may be referenced in any subsequent steps and must not be referenced from steps prior to the alias's declaration. Aliases may be modified using the form “Set
x
to
someOtherValue
”.
5.2.1
Evaluation Order
When complex expressions appear in algorithm steps, these are to be understood as being evaluated in a left-to-right, inside-to-outside order. For example, the step
Return A(B(), C.
[[D]]
) + E(F()).
is equivalent to
Let
tmp1
be B().
Let
tmp2
be C.
[[D]]
.
Let
tmp3
be A(
tmp1
,
tmp2
).
Let
tmp4
be F().
Let
tmp5
be E(
tmp4
).
Let
tmp6
be
tmp3
+
tmp5
.
Return
tmp6
.
where the various
tmpN
aliases are ephemeral and visible only in these steps.
5.2.2
Abstract Operations
In order to facilitate their use in multiple parts of this specification, some algorithms, called
abstract operations
, are named and written in parameterized functional form so that they may be referenced by name from within other algorithms. Abstract operations are typically referenced using a functional application style such as OperationName(
arg1
,
arg2
). Some abstract operations are treated as polymorphically dispatched methods of class-like specification abstractions. Such method-like abstract operations are typically referenced using a method application style such as
someValue
.OperationName(
arg1
,
arg2
).
5.2.3
Syntax-Directed Operations
A
syntax-directed operation
is a named operation whose definition consists of algorithms, each of which is associated with one or more productions from one of the ECMAScript grammars. A production that has multiple alternative definitions will typically have a distinct algorithm for each alternative. When an algorithm is associated with a grammar production, it may reference the terminal and nonterminal symbols of the production alternative as if they were parameters of the algorithm. When used in this manner, nonterminal symbols refer to the actual alternative definition that is matched when parsing the source text. The
source text matched by
a grammar production or
Parse Node
derived from it is the portion of the source text that starts at the beginning of the first terminal that participated in the match and ends at the end of the last terminal that participated in the match.
When an algorithm is associated with a production alternative, the alternative is typically shown without any “[ ]” grammar annotations. Such annotations should only affect the syntactic recognition of the alternative and have no effect on the associated semantics for the alternative.
Syntax-directed operations are invoked with a parse node and, optionally, other parameters by using the conventions on steps
1
,
3
, and
4
in the following algorithm:
Let
status
be SyntaxDirectedOperation of
SomeNonTerminal
.
Let
someParseNode
be the parse of some source text.
Perform SyntaxDirectedOperation of
someParseNode
.
Perform SyntaxDirectedOperation of
someParseNode
with argument
"value"
.
Unless explicitly specified otherwise, all
chain productions
have an implicit definition for every operation that might be applied to that production's left-hand side nonterminal. The implicit definition simply reapplies the same operation with the same parameters, if any, to the
chain production
's sole right-hand side nonterminal and then returns the result. For example, assume that some algorithm has a step of the form: “Return
Evaluation
of
Block
” and that there is a production:
Block
:
{
StatementList
}
but the
Evaluation
operation does not associate an algorithm with that production. In that case, the
Evaluation
operation implicitly includes an association of the form:
Runtime Semantics:
Evaluation
Block
:
{
StatementList
}
Return
Evaluation
of
StatementList
.
5.2.4
Runtime Semantics
Algorithms which specify semantics that must be called at runtime are called
runtime semantics
. Runtime semantics are defined by
abstract operations
or
syntax-directed operations
.
5.2.4.1
Completion (
completionRecord
)
The abstract operation Completion takes argument
completionRecord
(a
Completion Record
) and returns a
Completion Record
. It is used to emphasize that a
Completion Record
is being returned. It performs the following steps when called:
Assert
:
completionRecord
is a
Completion Record
.
Return
completionRecord
.
5.2.4.2
Throw an Exception
Algorithms steps that say to throw an exception, such as
Throw a
TypeError
exception.
mean the same things as:
Return
ThrowCompletion
(a newly created
TypeError
object).
5.2.4.3
Shorthands for Unwrapping Completion Records
Prefix
?
and
!
are used as shorthands which unwrap
Completion Records
.
?
is used to propagate an
abrupt completion
to the caller, or otherwise to unwrap a
normal completion
.
!
is used to assert that a
Completion Record
is normal and unwrap it. Formally, the step
Let
result
be ?
record
.
is equivalent to
Assert
:
record
is a
Completion Record
.
If
record
is an
abrupt completion
, return
record
.
Let
result
be
record
.
[[Value]]
.
Likewise, the step
Let
result
be !
record
.
is equivalent to
Assert
:
record
is a
normal completion
.
Let
result
be
record
.
[[Value]]
.
When
?
or
!
is used in any other context, first apply the rewrite given in
Evaluation Order
until this rule can be applied, then apply this rule. For example, the step
Perform AO(? Other()).
can be rewritten to
Let
tmp1
be Other().
Let
tmp2
be ?
tmp1
.
Perform AO(
tmp2
).
which in turn expands to
Let
tmp1
be Other().
Assert
:
tmp1
is a
Completion Record
.
If
tmp1
is an
abrupt completion
, return
tmp1
.
Let
tmp2
be
tmp1
.
[[Value]]
.
Perform AO(
tmp2
).
5.2.4.4
Implicit Normal Completion
In algorithms within
abstract operations
which are declared to return a
Completion Record
, and within all built-in functions, the returned value is first passed to
NormalCompletion
, and the result is used instead. This rule does not apply within the
Completion
algorithm or when the value being returned is clearly marked as a
Completion Record
in that step; these cases are:
when the result of applying
Completion
,
NormalCompletion
,
ThrowCompletion
, or
ReturnCompletion
is directly returned
when the result of constructing a
Completion Record
is directly returned
It is an editorial error if a
Completion Record
is returned from such an abstract operation through any other means. For example, within these
abstract operations
,
Return
true
.
means the same things as any of
Return
NormalCompletion
(
true
).
or
Let
completion
be
NormalCompletion
(
true
).
Return
Completion
(
completion
).
or
Return
Completion Record
{
[[Type]]
:
normal
,
[[Value]]
:
true
,
[[Target]]
:
empty
}.
Note that, through the ReturnIfAbrupt expansion, the following example is allowed, as within the expanded steps, the result of applying
Completion
is returned directly in the abrupt case and the implicit
NormalCompletion
application occurs after unwrapping in the normal case.
Return ?
completion
.
The following example would be an editorial error because a
Completion Record
is being returned without being annotated in that step.
Let
completion
be
NormalCompletion
(
true
).
Return
completion
.
5.2.5
Static Semantics
Context-free grammars are not sufficiently powerful to express all the rules that define whether a stream of input elements form a valid ECMAScript
Script
or
Module
that may be evaluated. In some situations additional rules are needed that may be expressed using either ECMAScript algorithm conventions or prose requirements. Such rules are always associated with a production of a grammar and are called the
static semantics
of the production.
Static Semantic Rules have names and typically are defined using an algorithm. Named Static Semantic Rules are associated with grammar productions and a production that has multiple alternative definitions will typically have for each alternative a distinct algorithm for each applicable named static semantic rule.
A special kind of static semantic rule is an
Early Error Rule
.
Early error
rules define
early error
conditions (see clause
17
) that are associated with specific grammar productions.
Evaluation
of most
early error
rules are not explicitly invoked within the algorithms of this specification. A conforming implementation must, prior to the first evaluation of a
Script
or
Module
, validate all of the
early error
rules of the productions used to parse that
Script
or
Module
. If any of the
early error
rules are violated the
Script
or
Module
is invalid and cannot be evaluated.
5.2.6
Mathematical Operations
This specification makes reference to these kinds of numeric values:
Mathematical values
: Arbitrary real numbers, used as the default numeric type.
Extended mathematical values
:
Mathematical values
together with +∞ and -∞.
Numbers
:
IEEE 754-2019
binary64 (double-precision floating point) values.
BigInts
:
ECMAScript language values
representing arbitrary
integers
in a one-to-one correspondence.
In the language of this specification, numerical values are distinguished among different numeric kinds using subscript suffixes. The subscript
𝔽
refers to Numbers, and the subscript
ℤ
refers to BigInts. Numeric values without a subscript suffix refer to
mathematical values
. This specification denotes most numeric values in base 10; it also uses numeric values of the form 0x followed by digits 0-9 or A-F as base-16 values.
In general, when this specification refers to a numerical value, such as in the phrase, "the length of
y
" or "the
integer
represented by the four hexadecimal digits ...", without explicitly specifying a numeric kind, the phrase refers to a
mathematical value
. Phrases which refer to a Number or a BigInt value are explicitly annotated as such; for example, "the
Number value for
the number of code points in …" or "the
BigInt value for
…".
When the term
integer
is used in this specification, it refers to a
mathematical value
which is in the set of
integers
, unless otherwise stated. When the term
integral Number
is used in this specification, it refers to a
finite
Number value whose
mathematical value
is in the set of
integers
.
Numeric operators such as +, ×, =, and ≥ refer to those operations as determined by the type of the operands. When applied to
mathematical values
, the operators refer to the usual mathematical operations. When applied to
extended mathematical values
, the operators refer to the usual mathematical operations over the extended real numbers; indeterminate forms are not defined and their use in this specification should be considered an editorial error. When applied to Numbers, the operators refer to the relevant operations within
IEEE 754-2019
. When applied to BigInts, the operators refer to the usual mathematical operations applied to the
mathematical value of
the BigInt. Numeric operators applied to mixed-type operands (such as a Number and a
mathematical value
) are not defined and should be considered an editorial error in this specification.
Conversions between
mathematical values
and Numbers or BigInts are always explicit in this document. A conversion from a
mathematical value
or
extended mathematical value
x
to a Number is denoted as "the
Number value for
x
" or
𝔽(
x
)
, and is defined in
6.1.6.1
. A conversion from an
integer
x
to a BigInt is denoted as "the
BigInt value for
x
" or
ℤ(
x
)
. A conversion from a Number or BigInt
x
to a
mathematical value
is denoted as "the
mathematical value of
x
", or
ℝ(
x
)
. The
mathematical value of
+0
𝔽
and
-0
𝔽
is the
mathematical value
0. The
mathematical value of
non-
finite
values is not defined. The
extended mathematical value of
x
is the
mathematical value of
x
for
finite
values, and is +∞ and -∞ for
+∞
𝔽
and
-∞
𝔽
respectively; it is not defined for
NaN
.
The mathematical function
abs(
x
)
produces the absolute value of
x
, which is
-
x
if
x
< 0 and otherwise is
x
itself.
The mathematical function
ln(
x
)
produces the natural logarithm of
x
. The mathematical function
log10(
x
)
produces the base 10 logarithm of
x
. The mathematical function
log2(
x
)
produces the base 2 logarithm of
x
.
The mathematical function
min(
x1
,
x2
, … ,
xN
)
produces the mathematically smallest of
x1
through
xN
. The mathematical function
max(
x1
,
x2
, ...,
xN
)
produces the mathematically largest of
x1
through
xN
. The domain and range of these mathematical functions are the
extended mathematical values
.
The notation “
x
modulo
y
” (
y
must be
finite
and non-zero) computes a value
k
of the same sign as
y
(or zero) such that
abs
(
k
) <
abs
(
y
) and
x
-
k
=
q
×
y
for some
integer
q
.
The phrase "the result of
clamping
x
between
lower
and
upper
" (where
x
is an
extended mathematical value
and
lower
and
upper
are
mathematical values
such that
lower
≤
upper
) produces
lower
if
x
<
lower
, produces
upper
if
x
>
upper
, and otherwise produces
x
.
The mathematical function
floor(
x
)
produces the largest
integer
(closest to +∞) that is not larger than
x
.
Note
floor
(
x
) =
x
- (
x
modulo
1)
.
The mathematical function
truncate(
x
)
removes the fractional part of
x
by rounding towards zero, producing
-
floor
(-
x
)
if
x
< 0 and otherwise producing
floor
(
x
)
.
Mathematical functions
min
,
max
,
abs
,
floor
, and
truncate
are not defined for Numbers and BigInts, and any usage of those methods that have non-
mathematical value
arguments would be an editorial error in this specification.
An
interval
from lower bound
a
to upper bound
b
is a possibly-infinite, possibly-empty set of numeric values of the same numeric type. Each bound will be described as either inclusive or exclusive, but not both. There are four kinds of intervals, as follows:
An
interval
from
a
(inclusive) to
b
(inclusive), also called an
inclusive interval
from
a
to
b
, includes all values
x
of the same numeric type such that
a
≤
x
≤
b
, and no others.
An
interval
from
a
(inclusive) to
b
(exclusive) includes all values
x
of the same numeric type such that
a
≤
x
<
b
, and no others.
An
interval
from
a
(exclusive) to
b
(inclusive) includes all values
x
of the same numeric type such that
a
<
x
≤
b
, and no others.
An
interval
from
a
(exclusive) to
b
(exclusive) includes all values
x
of the same numeric type such that
a
<
x
<
b
, and no others.
For example, the
interval
from 1 (inclusive) to 2 (exclusive) consists of all
mathematical values
between 1 and 2, including 1 and not including 2. For the purpose of defining intervals,
-0
𝔽
<
+0
𝔽
, so, for example, an
inclusive interval
with a lower bound of
+0
𝔽
includes
+0
𝔽
but not
-0
𝔽
.
NaN
is never included in an
interval
.
5.2.7
Value Notation
In this specification,
ECMAScript language values
are displayed in
bold
. Examples include
null
,
true
, or
"hello"
. These are distinguished from
ECMAScript source text
such as
Function.prototype.apply
or
let n = 42;
.
5.2.8
Identity
In this specification, both specification values and
ECMAScript language values
are compared for equality. When comparing for equality, values fall into one of two categories.
Values without identity
are equal to other values without identity if all of their innate characteristics are the same — characteristics such as the magnitude of an
integer
or the length of a sequence. Values without identity may be manifest without prior reference by fully describing their characteristics. In contrast, each
value with identity
is unique and therefore only equal to itself. Values with identity are like values without identity but with an additional unguessable, unchangeable, universally-unique characteristic called
identity
. References to existing values with identity cannot be manifest simply by describing them, as the identity itself is indescribable; instead, references to these values must be explicitly passed from one place to another. Some values with identity are mutable and therefore can have their characteristics (except their identity) changed in-place, causing all holders of the value to observe the new characteristics. A value without identity is never equal to a value with identity.
From the perspective of this specification, the word “is” is used to compare two values for equality, as in “If
bool
is
true
, then ...”, and the word “contains” is used to search for a value inside lists using equality comparisons, as in "If
list
contains a
Record
r
such that
r
.
[[Foo]]
is
true
, then ...". The
specification identity
of values determines the result of these comparisons and is axiomatic in this specification.
From the perspective of the ECMAScript language, language values are compared for equality using the
SameValue
abstract operation and the
abstract operations
it transitively calls. The algorithms of these comparison
abstract operations
determine
language identity
of
ECMAScript language values
.
For specification values, examples of values without specification identity include, but are not limited to:
mathematical values
and
extended mathematical values
;
ECMAScript source text
,
surrogate pairs
,
Directive Prologues
, etc; UTF-16 code units; Unicode code points;
enums
;
abstract operations
, including
syntax-directed operations
,
host hooks
, etc; and ordered pairs. Examples of specification values with specification identity include, but are not limited to: any kind of
Records
, including
Property Descriptors
,
PrivateElements
, etc;
Parse Nodes
;
Lists
;
Sets
and
Relations
;
Abstract Closures
;
Data Blocks
;
Private Names
;
execution contexts
and
execution context stacks
;
agent signifiers
; and
WaiterList Records
.
Specification identity agrees with language identity for all
ECMAScript language values
except Symbol values produced by
Symbol.for
. The
ECMAScript language values
without specification identity and without language identity are
undefined
,
null
,
Booleans
,
Strings
,
Numbers
, and
BigInts
. The
ECMAScript language values
with specification identity and language identity are
Symbols
not produced by
Symbol.for
and
Objects
. Symbol values produced by
Symbol.for
have specification identity, but not language identity.
6
ECMAScript Data Types and Values
Algorithms within this specification manipulate values each of which has an associated type. The possible value types are exactly those defined in this clause. Types are further classified into
ECMAScript language types
and specification types.
6.1
ECMAScript Language Types
An
ECMAScript language type
corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Symbol, Number, BigInt, and Object. An
ECMAScript language value
is a value that is characterized by an ECMAScript language type.
6.1.1
The Undefined Type
The Undefined type has exactly one value, called
undefined
. Any variable that has not been assigned a value has the value
undefined
.
6.1.2
The Null Type
The Null type has exactly one value, called
null
.
6.1.3
The Boolean Type
The
Boolean type
represents a logical entity having two values, called
true
and
false
.
6.1.4
The String Type
The
String type
is the set of all ordered sequences of zero or more 16-bit unsigned
integer
values (“elements”) up to a maximum length of 2
53
- 1 elements. The String type is generally used to represent textual data in a running ECMAScript program, in which case each element in the String is treated as a UTF-16 code unit value. Each element is regarded as occupying a position within the sequence. These positions are indexed with non-negative
integers
. The first element (if any) is at index 0, the next element (if any) at index 1, and so on. The length of a String is the number of elements (i.e., 16-bit values) within it. The empty String has length zero and therefore contains no elements.
ECMAScript operations that do not interpret String contents apply no further semantics. Operations that do interpret String values treat each element as a single UTF-16 code unit. However, ECMAScript does not restrict the value of or relationships between these code units, so operations that further interpret String contents as sequences of Unicode code points encoded in UTF-16 must account for ill-formed subsequences. Such operations apply special treatment to every code unit with a numeric value in the
inclusive interval
from 0xD800 to 0xDBFF (defined by the Unicode Standard as a
leading surrogate
, or more formally as a
high-surrogate code unit
) and every code unit with a numeric value in the
inclusive interval
from 0xDC00 to 0xDFFF (defined as a
trailing surrogate
, or more formally as a
low-surrogate code unit
) using the following rules:
A code unit that is not a
leading surrogate
and not a
trailing surrogate
is interpreted as a code point with the same value.
A sequence of two code units, where the first code unit
c1
is a
leading surrogate
and the second code unit
c2
a
trailing surrogate
, is a
surrogate pair
and is interpreted as a code point with the value (
c1
- 0xD800) × 0x400 + (
c2
- 0xDC00) + 0x10000. (See
11.1.3
)
A code unit that is a
leading surrogate
or
trailing surrogate
, but is not part of a
surrogate pair
, is interpreted as a code point with the same value.
The function
String.prototype.normalize
(see
22.1.3.15
) can be used to explicitly normalize a String value.
String.prototype.localeCompare
(see
22.1.3.12
) internally normalizes String values, but no other operations implicitly normalize the strings upon which they operate. Operation results are not language- and/or locale-sensitive unless stated otherwise.
Note
The rationale behind this design was to keep the implementation of Strings as simple and high-performing as possible. If
ECMAScript source text
is in Normalized Form C, string literals are guaranteed to also be normalized, as long as they do not contain any Unicode escape sequences.
In this specification, the phrase "the
string-concatenation
of
A
,
B
, ..." (where each argument is a String value, a code unit, or a sequence of code units) denotes the String value whose sequence of code units is the concatenation of the code units (in order) of each of the arguments (in order).
The phrase "the
substring
of
S
from
inclusiveStart
to
exclusiveEnd
" (where
S
is a String value or a sequence of code units and
inclusiveStart
and
exclusiveEnd
are
integers
) denotes the String value consisting of the consecutive code units of
S
beginning at index
inclusiveStart
and ending immediately before index
exclusiveEnd
(which is the empty String when
inclusiveStart
=
exclusiveEnd
). If the "to" suffix is omitted, the length of
S
is used as the value of
exclusiveEnd
.
The phrase "
the ASCII word characters
" denotes the following String value, which consists solely of every letter and number in the Unicode Basic Latin block along with U+005F (LOW LINE):
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"
.
For historical reasons, it has significance to various algorithms.
6.1.4.1
StringIndexOf (
string
,
searchValue
,
fromIndex
)
The abstract operation StringIndexOf takes arguments
string
(a String),
searchValue
(a String), and
fromIndex
(a non-negative
integer
) and returns a non-negative
integer
or
not-found
. It performs the following steps when called:
Let
len
be the length of
string
.
If
searchValue
is the empty String and
fromIndex
≤
len
, return
fromIndex
.
Let
searchLen
be the length of
searchValue
.
For each
integer
i
such that
fromIndex
≤
i
≤
len
-
searchLen
, in ascending order, do
Let
candidate
be the
substring
of
string
from
i
to
i
+
searchLen
.
If
candidate
is
searchValue
, return
i
.
Return
not-found
.
Note 1
If
searchValue
is the empty String and
fromIndex
≤ the length of
string
, this algorithm returns
fromIndex
. The empty String is effectively found at every position within a string, including after the last code unit.
Note 2
This algorithm always returns
not-found
if
fromIndex
+ the length of
searchValue
> the length of
string
.
6.1.4.2
StringLastIndexOf (
string
,
searchValue
,
fromIndex
)
The abstract operation StringLastIndexOf takes arguments
string
(a String),
searchValue
(a String), and
fromIndex
(a non-negative
integer
) and returns a non-negative
integer
or
not-found
. It performs the following steps when called:
Let
len
be the length of
string
.
Let
searchLen
be the length of
searchValue
.
Assert
:
fromIndex
+
searchLen
≤
len
.
For each
integer
i
such that 0 ≤
i
≤
fromIndex
, in descending order, do
Let
candidate
be the
substring
of
string
from
i
to
i
+
searchLen
.
If
candidate
is
searchValue
, return
i
.
Return
not-found
.
Note
If
searchValue
is the empty String, this algorithm returns
fromIndex
. The empty String is effectively found at every position within a string, including after the last code unit.
6.1.5
The Symbol Type
The
Symbol type
is the set of all non-String values that may be used as the key of an Object property (
6.1.7
).
Each Symbol is unique and immutable.
Each Symbol has an immutable
[[Description]]
internal slot whose value is either a String or
undefined
.
6.1.5.1
Well-Known Symbols
Well-known symbols are built-in Symbol values that are explicitly referenced by algorithms of this specification. They are typically used as the keys of properties whose values serve as extension points of a specification algorithm. Unless otherwise specified, well-known symbols values are shared by all
realms
(
9.3
).
Within this specification a well-known symbol is referred to using the standard
intrinsic notation
where the intrinsic is one of the values listed in
Table 1
.
Note
Previous editions of this specification used a notation of the form @@name, where the current edition would use
%Symbol.name%
. In particular, the following names were used: @@asyncIterator, @@hasInstance, @@isConcatSpreadable, @@
iterator
, @@match, @@matchAll, @@replace, @@search, @@species, @@split, @@toPrimitive, @@toStringTag, and @@unscopables.
Table 1: Well-known Symbols
Specification Name
[[Description]]
Value and Purpose
%Symbol.asyncIterator%
"Symbol.asyncIterator"
A method that returns the default
async iterator
for an object. Called by the semantics of the
for
-
await
-
of
statement.
%Symbol.hasInstance%
"Symbol.hasInstance"
A method that determines if a
constructor
object recognizes an object as one of the
constructor
's instances. Called by the semantics of the
instanceof
operator.
%Symbol.isConcatSpreadable%
"Symbol.isConcatSpreadable"
A Boolean valued property that if true indicates that an object should be flattened to its array elements by
Array.prototype.concat
.
%Symbol.iterator%
"Symbol.iterator"
A method that returns the default
iterator
for an object. Called by the semantics of the for-of statement.
%Symbol.match%
"Symbol.match"
A regular expression method that matches the regular expression against a string. Called by the
String.prototype.match
method.
%Symbol.matchAll%
"Symbol.matchAll"
A regular expression method that returns an
iterator
that yields matches of the regular expression against a string. Called by the
String.prototype.matchAll
method.
%Symbol.replace%
"Symbol.replace"
A regular expression method that replaces matched substrings of a string. Called by the
String.prototype.replace
method.
%Symbol.search%
"Symbol.search"
A regular expression method that returns the index within a string that matches the regular expression. Called by the
String.prototype.search
method.
%Symbol.species%
"Symbol.species"
A function valued property that is the
constructor
function that is used to create derived objects.
%Symbol.split%
"Symbol.split"
A regular expression method that splits a string at the indices that match the regular expression. Called by the
String.prototype.split
method.
%Symbol.toPrimitive%
"Symbol.toPrimitive"
A method that converts an object to a corresponding primitive value. Called by the
ToPrimitive
abstract operation.
%Symbol.toStringTag%
"Symbol.toStringTag"
A String valued property that is used in the creation of the default string description of an object. Accessed by the built-in method
Object.prototype.toString
.
%Symbol.unscopables%
"Symbol.unscopables"
An object valued property whose own and inherited
property names
are
property names
that are excluded from the
with
environment bindings of the associated object.
6.1.6
Numeric Types
ECMAScript has two built-in numeric types: Number and BigInt. The following
abstract operations
are defined over these numeric types. The "Result" column shows the return type, along with an indication if it is possible for some invocations of the operation to return an
abrupt completion
.
Table 2: Numeric Type Operations
Operation
Example source
Invoked by the
Evaluation
semantics of ...
Result
Number::unaryMinus
-x
Unary
-
Operator
Number
BigInt::unaryMinus
BigInt
Number::bitwiseNOT
~x
Bitwise NOT Operator (
~
)
Number
BigInt::bitwiseNOT
BigInt
Number::exponentiate
x ** y
Exponentiation Operator
and
Math.pow (
base
,
exponent
)
Number
BigInt::exponentiate
either a
normal completion containing
a BigInt or a
throw completion
Number::multiply
x * y
Multiplicative Operators
Number
BigInt::multiply
BigInt
Number::divide
x / y
Multiplicative Operators
Number
BigInt::divide
either a
normal completion containing
a BigInt or a
throw completion
Number::remainder
x % y
Multiplicative Operators
Number
BigInt::remainder
either a
normal completion containing
a BigInt or a
throw completion
Number::add
x ++
++ x
x + y
Postfix Increment Operator
,
Prefix Increment Operator
, and
The Addition Operator (
+
)
Number
BigInt::add
BigInt
Number::subtract
x --
-- x
x - y
Postfix Decrement Operator
,
Prefix Decrement Operator
, and
The Subtraction Operator (
-
)
Number
BigInt::subtract
BigInt
Number::leftShift
x << y
The Left Shift Operator (
<<
)
Number
BigInt::leftShift
BigInt
Number::signedRightShift
x >> y
The Signed Right Shift Operator (
>>
)
Number
BigInt::signedRightShift
BigInt
Number::unsignedRightShift
x >>> y
The Unsigned Right Shift Operator (
>>>
)
Number
BigInt::unsignedRightShift
a
throw completion
Number::lessThan
x < y
x > y
x <= y
x >= y
Relational Operators
, via
IsLessThan (
x
,
y
,
LeftFirst
)
Boolean or
undefined
(for unordered inputs)
BigInt::lessThan
Boolean
Number::equal
x == y
x != y
x === y
x !== y
Equality Operators
, via
IsStrictlyEqual (
x
,
y
)
Boolean
BigInt::equal
Number::sameValue
Object.is(x, y)
Object internal methods, via
SameValue (
x
,
y
)
, to test exact value equality
Boolean
Number::sameValueZero
[x].includes(y)
via
SameValueZero (
x
,
y
)
, to test value equality, ignoring the difference between
+0
𝔽
and
-0
𝔽
, as in Array, Map, and Set methods
Boolean
Number::bitwiseAND
x & y
Binary Bitwise Operators
Number
BigInt::bitwiseAND
BigInt
Number::bitwiseXOR
x ^ y
Number
BigInt::bitwiseXOR
BigInt
Number::bitwiseOR
x | y
Number
BigInt::bitwiseOR
BigInt
Number::toString
String(x)
Many expressions and built-in functions, via
ToString (
argument
)
String
BigInt::toString
Because the numeric types are in general not convertible without loss of precision or truncation, the ECMAScript language provides no implicit conversion among these types. Programmers must explicitly call
Number
and
BigInt
functions to convert among types when calling a function which requires another type.
Note
The first and subsequent editions of ECMAScript have provided, for certain operators, implicit numeric conversions that could lose precision or
truncate
. These legacy implicit conversions are maintained for backward compatibility, but not provided for BigInt in order to minimize opportunity for programmer error, and to leave open the option of generalized
value types
in a future edition.
6.1.6.1
The Number Type
The
Number type
has exactly 18,437,736,874,454,810,627 (that is,
2
64
- 2
53
+ 3
) values, representing the double-precision floating point
IEEE 754-2019
binary64 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9,007,199,254,740,990 (that is,
2
53
- 2
) distinct NaN values of the IEEE Standard are represented in ECMAScript as a single special
NaN
value. (Note that the
NaN
value is produced by the program expression
NaN
.) In some implementations, external code might be able to detect a difference between various NaN values, but such behaviour is
implementation-defined
; to ECMAScript code, all
NaN
values are indistinguishable from each other.
Note
The bit pattern that might be observed in an ArrayBuffer (see
25.1
) or a SharedArrayBuffer (see
25.2
) after a Number value has been stored into it is not necessarily the same as the internal representation of that Number value used by the ECMAScript implementation.
There are two other special values, called
positive Infinity
and
negative Infinity
. For brevity, these values are also referred to for expository purposes by the symbols
+∞
𝔽
and
-∞
𝔽
, respectively. (Note that these two infinite Number values are produced by the program expressions
+Infinity
(or simply
Infinity
) and
-Infinity
.)
The other 18,437,736,874,454,810,624 (that is,
2
64
- 2
53
) values are called the
finite
numbers. Half of these are positive numbers and half are negative numbers; for every
finite
positive Number value there is a corresponding negative value having the same magnitude.
Note that there is both a
positive zero
and a
negative zero
. For brevity, these values are also referred to for expository purposes by the symbols
+0
𝔽
and
-0
𝔽
, respectively. (Note that these two different zero Number values are produced by the program expressions
+0
(or simply
0
) and
-0
.)
The 18,437,736,874,454,810,622 (that is,
2
64
- 2
53
- 2
)
finite
non-zero values are of two kinds:
18,428,729,675,200,069,632 (that is,
2
64
- 2
54
) of them are normalized, having the form
s
×
m
× 2
e
where
s
is 1 or -1,
m
is an
integer
in the
interval
from 2
52
(inclusive) to 2
53
(exclusive), and
e
is an
integer
in the
inclusive interval
from -1074 to 971.
The remaining 9,007,199,254,740,990 (that is,
2
53
- 2
) values are denormalized, having the form
s
×
m
× 2
e
where
s
is 1 or -1,
m
is an
integer
in the
interval
from 0 (exclusive) to 2
52
(exclusive), and
e
is -1074.
Note that all the positive and negative
integers
whose magnitude is no greater than 2
53
are representable in the Number type. The
integer
0 has two representations in the Number type:
+0
𝔽
and
-0
𝔽
.
A
finite
number has an
odd significand
if it is non-zero and the
integer
m
used to express it (in one of the two forms shown above) is odd. Otherwise, it has an
even significand
.
In this specification, the phrase “the
Number value for
x
” where
x
represents an exact real mathematical quantity (which might even be an irrational number such as π) means a Number value chosen in the following manner. Consider the set of all
finite
values of the Number type, with
-0
𝔽
removed and with two additional values added to it that are not representable in the Number type, namely 2
1024
(which is
+1 × 2
53
× 2
971
) and
-2
1024
(which is
-1 × 2
53
× 2
971
). Choose the member of this set that is closest in value to
x
. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 2
1024
and
-2
1024
are considered to have even significands. Finally, if 2
1024
was chosen, replace it with
+∞
𝔽
; if
-2
1024
was chosen, replace it with
-∞
𝔽
; if
+0
𝔽
was chosen, replace it with
-0
𝔽
if and only if
x
< 0; any other chosen value is used unchanged. The result is the
Number value for
x
. (This procedure corresponds exactly to the behaviour of the
IEEE 754-2019
roundTiesToEven mode.)
The
Number value for
+∞ is
+∞
𝔽
, and the
Number value for
-∞ is
-∞
𝔽
.
Some ECMAScript operators deal only with
integers
in specific ranges such as the
inclusive interval
from
-2
31
to
2
31
- 1
or the
inclusive interval
from 0 to
2
16
- 1
. These operators accept any value of the Number type but first convert each such value to an
integer
value in the expected range. See the descriptions of the numeric conversion operations in
7.1
.
6.1.6.1.1
Number::unaryMinus (
x
)
The abstract operation Number::unaryMinus takes argument
x
(a Number) and returns a Number. It performs the following steps when called:
If
x
is
NaN
, return
NaN
.
Return the negation of
x
; that is, compute a Number with the same magnitude but opposite sign.
6.1.6.1.2
Number::bitwiseNOT (
x
)
The abstract operation Number::bitwiseNOT takes argument
x
(a Number) and returns an
integral Number
. It performs the following steps when called:
Let
oldValue
be !
ToInt32
(
x
).
Return the bitwise complement of
oldValue
. The
mathematical value of
the result is exactly representable as a 32-bit two's complement bit string.
6.1.6.1.3
Number::exponentiate (
base
,
exponent
)
The abstract operation Number::exponentiate takes arguments
base
(a Number) and
exponent
(a Number) and returns a Number. It returns an
implementation-approximated
value representing the result of raising
base
to the
exponent
power. It performs the following steps when called:
If
exponent
is
NaN
, return
NaN
.
If
exponent
is either
+0
𝔽
or
-0
𝔽
, return
1
𝔽
.
If
base
is
NaN
, return
NaN
.
If
base
is
+∞
𝔽
, then
If
exponent
>
+0
𝔽
, return
+∞
𝔽
; otherwise return
+0
𝔽
.
If
base
is
-∞
𝔽
, then
If
exponent
>
+0
𝔽
, then
If
exponent
is an odd
integral Number
, return
-∞
𝔽
; otherwise return
+∞
𝔽
.
Else,
If
exponent
is an odd
integral Number
, return
-0
𝔽
; otherwise return
+0
𝔽
.
If
base
is
+0
𝔽
, then
If
exponent
>
+0
𝔽
, return
+0
𝔽
; otherwise return
+∞
𝔽
.
If
base
is
-0
𝔽
, then
If
exponent
>
+0
𝔽
, then
If
exponent
is an odd
integral Number
, return
-0
𝔽
; otherwise return
+0
𝔽
.
Else,
If
exponent
is an odd
integral Number
, return
-∞
𝔽
; otherwise return
+∞
𝔽
.
Assert
:
base
is
finite
and is neither
+0
𝔽
nor
-0
𝔽
.
If
exponent
is
+∞
𝔽
, then
If
abs
(
ℝ
(
base
)) > 1, return
+∞
𝔽
.
If
abs
(
ℝ
(
base
)) = 1, return
NaN
.
If
abs
(
ℝ
(
base
)) < 1, return
+0
𝔽
.
If
exponent
is
-∞
𝔽
, then
If
abs
(
ℝ
(
base
)) > 1, return
+0
𝔽
.
If
abs
(
ℝ
(
base
)) = 1, return
NaN
.
If
abs
(
ℝ
(
base
)) < 1, return
+∞
𝔽
.
Assert
:
exponent
is
finite
and is neither
+0
𝔽
nor
-0
𝔽
.
If
base
<
-0
𝔽
and
exponent
is not an
integral Number
, return
NaN
.
Return an
implementation-approximated
Number value representing the result of raising
ℝ
(
base
) to the
ℝ
(
exponent
) power.
Note
The result of
base
**
exponent
when
base
is
1
𝔽
or
-1
𝔽
and
exponent
is
+∞
𝔽
or
-∞
𝔽
, or when
base
is
1
𝔽
and
exponent
is
NaN
, differs from
IEEE 754-2019
. The first edition of ECMAScript specified a result of
NaN
for this operation, whereas later revisions of IEEE 754 specified
1
𝔽
. The historical ECMAScript behaviour is preserved for compatibility reasons.
6.1.6.1.4
Number::multiply (
x
,
y
)
The abstract operation Number::multiply takes arguments
x
(a Number) and
y
(a Number) and returns a Number. It performs multiplication according to the rules of
IEEE 754-2019
binary double-precision arithmetic, producing the product of
x
and
y
. It performs the following steps when called:
If
x
is
NaN
or
y
is
NaN
, return
NaN
.
If
x
is either
+∞
𝔽
or
-∞
𝔽
, then
If
y
is either
+0
𝔽
or
-0
𝔽
, return
NaN
.
If
y
>
+0
𝔽
, return
x
.
Return -
x
.
If
y
is either
+∞
𝔽
or
-∞
𝔽
, then
If
x
is either
+0
𝔽
or
-0
𝔽
, return
NaN
.
If
x
>
+0
𝔽
, return
y
.
Return -
y
.
If
x
is
-0
𝔽
, then
If
y
is
-0
𝔽
or
y
<
-0
𝔽
, return
+0
𝔽
.
Else, return
-0
𝔽
.
If
y
is
-0
𝔽
, then
If
x
<
-0
𝔽
, return
+0
𝔽
.
Else, return
-0
𝔽
.
Return
𝔽
(
ℝ
(
x
) ×
ℝ
(
y
)).
Note
Finite
-precision multiplication is commutative, but not always associative.
6.1.6.1.5
Number::divide (
x
,
y
)
The abstract operation Number::divide takes arguments
x
(a Number) and
y
(a Number) and returns a Number. It performs division according to the rules of
IEEE 754-2019
binary double-precision arithmetic, producing the quotient of
x
and
y
where
x
is the dividend and
y
is the divisor. It performs the following steps when called:
If
x
is
NaN
or
y
is
NaN
, return
NaN
.
If
x
is either
+∞
𝔽
or
-∞
𝔽
, then
If
y
is either
+∞
𝔽
or
-∞
𝔽
, return
NaN
.
If
y
is
+0
𝔽
or
y
>
+0
𝔽
, return
x
.
Return -
x
.
If
y
is
+∞
𝔽
, then
If
x
is
+0
𝔽
or
x
>
+0
𝔽
, return
+0
𝔽
; otherwise return
-0
𝔽
.
If
y
is
-∞
𝔽
, then
If
x
is
+0
𝔽
or
x
>
+0
𝔽
, return
-0
𝔽
; otherwise return
+0
𝔽
.
If
x
is either
+0
𝔽
or
-0
𝔽
, then
If
y
is either
+0
𝔽
or
-0
𝔽
, return
NaN
.
If
y
>
+0
𝔽
, return
x
.
Return -
x
.
If
y
is
+0
𝔽
, then
If
x
>
+0
𝔽
, return
+∞
𝔽
; otherwise return
-∞
𝔽
.
If
y
is
-0
𝔽
, then
If
x
>
+0
𝔽
, return
-∞
𝔽
; otherwise return
+∞
𝔽
.
Return
𝔽
(
ℝ
(
x
) /
ℝ
(
y
)).
6.1.6.1.6
Number::remainder (
n
,
d
)
The abstract operation Number::remainder takes arguments
n
(a Number) and
d
(a Number) and returns a Number. It yields the remainder from an implied division of its operands where
n
is the dividend and
d
is the divisor. It performs the following steps when called:
If
n
is
NaN
or
d
is
NaN
, return
NaN
.
If
n
is either
+∞
𝔽
or
-∞
𝔽
, return
NaN
.
If
d
is either
+∞
𝔽
or
-∞
𝔽
, return
n
.
If
d
is either
+0
𝔽
or
-0
𝔽
, return
NaN
.
If
n
is either
+0
𝔽
or
-0
𝔽
, return
n
.
Assert
:
n
and
d
are
finite
and non-zero.
Let
quotient
be
ℝ
(
n
) /
ℝ
(
d
).
Let
q
be
truncate
(
quotient
).
Let
r
be
ℝ
(
n
) - (
ℝ
(
d
) ×
q
).
If
r
= 0 and
n
<
-0
𝔽
, return
-0
𝔽
.
Return
𝔽
(
r
).
Note 1
In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.
Note 2
The result of a floating-point remainder operation as computed by the
%
operator is not the same as the “remainder” operation defined by
IEEE 754-2019
. The
IEEE 754-2019
“remainder” operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual
integer
remainder operator. Instead the ECMAScript language defines
%
on floating-point operations to behave in a manner analogous to that of the Java
integer
remainder operator; this may be compared with the C library function fmod.
6.1.6.1.7
Number::add (
x
,
y
)
The abstract operation Number::add takes arguments
x
(a Number) and
y
(a Number) and returns a Number. It performs addition according to the rules of
IEEE 754-2019
binary double-precision arithmetic, producing the sum of its arguments. It performs the following steps when called:
If
x
is
NaN
or
y
is
NaN
, return
NaN
.
If
x
is
+∞
𝔽
and
y
is
-∞
𝔽
, return
NaN
.
If
x
is
-∞
𝔽
and
y
is
+∞
𝔽
, return
NaN
.
If
x
is either
+∞
𝔽
or
-∞
𝔽
, return
x
.
If
y
is either
+∞
𝔽
or
-∞
𝔽
, return
y
.
Assert
:
x
and
y
are both
finite
.
If
x
is
-0
𝔽
and
y
is
-0
𝔽
, return
-0
𝔽
.
Return
𝔽
(
ℝ
(
x
) +
ℝ
(
y
)).
Note
Finite
-precision addition is commutative, but not always associative.
6.1.6.1.8
Number::subtract (
x
,
y
)
The abstract operation Number::subtract takes arguments
x
(a Number) and
y
(a Number) and returns a Number. It performs subtraction, producing the difference of its operands;
x
is the minuend and
y
is the subtrahend. It performs the following steps when called:
Return
Number::add
(
x
,
Number::unaryMinus
(
y
)).
Note
It is always the case that
x - y
produces the same result as
x + (-y)
.
6.1.6.1.9
Number::leftShift (
x
,
y
)
The abstract operation Number::leftShift takes arguments
x
(a Number) and
y
(a Number) and returns an
integral Number
. It performs the following steps when called:
Let
lNum
be !
ToInt32
(
x
).
Let
rNum
be !
ToUint32
(
y
).
Let
shiftCount
be
ℝ
(
rNum
)
modulo
32.
Return the result of left shifting
lNum
by
shiftCount
bits. The
mathematical value of
the result is exactly representable as a 32-bit two's complement bit string.
6.1.6.1.10
Number::signedRightShift (
x
,
y
)
The abstract operation Number::signedRightShift takes arguments
x
(a Number) and
y
(a Number) and returns an
integral Number
. It performs the following steps when called:
Let
lNum
be !
ToInt32
(
x
).
Let
rNum
be !
ToUint32
(
y
).
Let
shiftCount
be
ℝ
(
rNum
)
modulo
32.
Return the result of performing a sign-extending right shift of
lNum
by
shiftCount
bits. The most significant bit is propagated. The
mathematical value of
the result is exactly representable as a 32-bit two's complement bit string.
6.1.6.1.11
Number::unsignedRightShift (
x
,
y
)
The abstract operation Number::unsignedRightShift takes arguments
x
(a Number) and
y
(a Number) and returns an
integral Number
. It performs the following steps when called:
Let
lNum
be !
ToUint32
(
x
).
Let
rNum
be !
ToUint32
(
y
).
Let
shiftCount
be
ℝ
(
rNum
)
modulo
32.
Return the result of performing a zero-filling right shift of
lNum
by
shiftCount
bits. Vacated bits are filled with zero. The
mathematical value of
the result is exactly representable as a 32-bit unsigned bit string.
6.1.6.1.12
Number::lessThan (
x
,
y
)
The abstract operation Number::lessThan takes arguments
x
(a Number) and
y
(a Number) and returns a Boolean or
undefined
. It performs the following steps when called:
If
x
is
NaN
, return
undefined
.
If
y
is
NaN
, return
undefined
.
If
x
is
y
, return
false
.
If
x
is
+0
𝔽
and
y
is
-0
𝔽
, return
false
.
If
x
is
-0
𝔽
and
y
is
+0
𝔽
, return
false
.
If
x
is
+∞
𝔽
, return
false
.
If
y
is
+∞
𝔽
, return
true
.
If
y
is
-∞
𝔽
, return
false
.
If
x
is
-∞
𝔽
, return
true
.
Assert
:
x
and
y
are
finite
.
If
ℝ
(
x
) <
ℝ
(
y
), return
true
; otherwise return
false
.
6.1.6.1.13
Number::equal (
x
,
y
)
The abstract operation Number::equal takes arguments
x
(a Number) and
y
(a Number) and returns a Boolean. It performs the following steps when called:
If
x
is
NaN
, return
false
.
If
y
is
NaN
, return
false
.
If
x
is
y
, return
true
.
If
x
is
+0
𝔽
and
y
is
-0
𝔽
, return
true
.
If
x
is
-0
𝔽
and
y
is
+0
𝔽
, return
true
.
Return
false
.
6.1.6.1.14
Number::sameValue (
x
,
y
)
The abstract operation Number::sameValue takes arguments
x
(a Number) and
y
(a Number) and returns a Boolean. It performs the following steps when called:
If
x
is
NaN
and
y
is
NaN
, return
true
.
If
x
is
+0
𝔽
and
y
is
-0
𝔽
, return
false
.
If
x
is
-0
𝔽
and
y
is
+0
𝔽
, return
false
.
If
x
is
y
, return
true
.
Return
false
.
6.1.6.1.15
Number::sameValueZero (
x
,
y
)
The abstract operation Number::sameValueZero takes arguments
x
(a Number) and
y
(a Number) and returns a Boolean. It performs the following steps when called:
If
x
is
NaN
and
y
is
NaN
, return
true
.
If
x
is
+0
𝔽
and
y
is
-0
𝔽
, return
true
.
If
x
is
-0
𝔽
and
y
is
+0
𝔽
, return
true
.
If
x
is
y
, return
true
.
Return
false
.
6.1.6.1.16
NumberBitwiseOp (
op
,
x
,
y
)
The abstract operation NumberBitwiseOp takes arguments
op
(
&
,
^
, or
|
),
x
(a Number), and
y
(a Number) and returns an
integral Number
. It performs the following steps when called:
Let
lNum
be !
ToInt32
(
x
).
Let
rNum
be !
ToInt32
(
y
).
Let
lBits
be the 32-bit two's complement bit string representing
ℝ
(
lNum
).
Let
rBits
be the 32-bit two's complement bit string representing
ℝ
(
rNum
).
If
op
is
&
, then
Let
result
be the result of applying the bitwise AND operation to
lBits
and
rBits
.
Else if
op
is
^
, then
Let
result
be the result of applying the bitwise exclusive OR (XOR) operation to
lBits
and
rBits
.
Else,
Assert
:
op
is
|
.
Let
result
be the result of applying the bitwise inclusive OR operation to
lBits
and
rBits
.
Return the
Number value for
the
integer
represented by the 32-bit two's complement bit string
result
.
6.1.6.1.17
Number::bitwiseAND (
x
,
y
)
The abstract operation Number::bitwiseAND takes arguments
x
(a Number) and
y
(a Number) and returns an
integral Number
. It performs the following steps when called:
Return
NumberBitwiseOp
(
&
,
x
,
y
).
6.1.6.1.18
Number::bitwiseXOR (
x
,
y
)
The abstract operation Number::bitwiseXOR takes arguments
x
(a Number) and
y
(a Number) and returns an
integral Number
. It performs the following steps when called:
Return
NumberBitwiseOp
(
^
,
x
,
y
).
6.1.6.1.19
Number::bitwiseOR (
x
,
y
)
The abstract operation Number::bitwiseOR takes arguments
x
(a Number) and
y
(a Number) and returns an
integral Number
. It performs the following steps when called:
Return
NumberBitwiseOp
(
|
,
x
,
y
).
6.1.6.1.20
Number::toString (
x
,
radix
)
The abstract operation Number::toString takes arguments
x
(a Number) and
radix
(an
integer
in the
inclusive interval
from 2 to 36) and returns a String. It represents
x
as a String using a positional numeral system with radix
radix
. The digits used in the representation of a number using radix
r
are taken from the first
r
code units of
"0123456789abcdefghijklmnopqrstuvwxyz"
in order. The representation of numbers with magnitude greater than or equal to
1
𝔽
never includes leading zeroes. It performs the following steps when called:
If
x
is
NaN
, return
"NaN"
.
If
x
is either
+0
𝔽
or
-0
𝔽
, return
"0"
.
If
x
<
-0
𝔽
, return the
string-concatenation
of
"-"
and
Number::toString
(-
x
,
radix
).
If
x
is
+∞
𝔽
, return
"Infinity"
.
Let
n
,
k
, and
s
be
integers
such that
k
≥ 1,
radix
k
- 1
≤
s
<
radix
k
,
𝔽
(
s
×
radix
n
-
k
) is
x
, and
k
is as small as possible. Note that
k
is the number of digits in the representation of
s
using radix
radix
, that
s
is not divisible by
radix
, and that the least significant digit of
s
is not necessarily uniquely determined by these criteria.
If
radix
≠ 10 or
n
is in the
inclusive interval
from -5 to 21, then
If
n
≥
k
, then
Return the
string-concatenation
of:
the code units of the
k
digits of the representation of
s
using radix
radix
n
-
k
occurrences of the code unit 0x0030 (DIGIT ZERO)
Else if
n
> 0, then
Return the
string-concatenation
of:
the code units of the most significant
n
digits of the representation of
s
using radix
radix
the code unit 0x002E (FULL STOP)
the code units of the remaining
k
-
n
digits of the representation of
s
using radix
radix
Else,
Assert
:
n
≤ 0.
Return the
string-concatenation
of:
the code unit 0x0030 (DIGIT ZERO)
the code unit 0x002E (FULL STOP)
-
n
occurrences of the code unit 0x0030 (DIGIT ZERO)
the code units of the
k
digits of the representation of
s
using radix
radix
NOTE: In this case, the input will be represented using scientific E notation, such as
1.2e+3
.
Assert
:
radix
is 10.
If
n
< 0, then
Let
exponentSign
be the code unit 0x002D (HYPHEN-MINUS).
Else,
Let
exponentSign
be the code unit 0x002B (PLUS SIGN).
If
k
= 1, then
Return the
string-concatenation
of:
the code unit of the single digit of
s
the code unit 0x0065 (LATIN SMALL LETTER E)
exponentSign
the code units of the decimal representation of
abs
(
n
- 1)
Return the
string-concatenation
of:
the code unit of the most significant digit of the decimal representation of
s
the code unit 0x002E (FULL STOP)
the code units of the remaining
k
- 1 digits of the decimal representation of
s
the code unit 0x0065 (LATIN SMALL LETTER E)
exponentSign
the code units of the decimal representation of
abs
(
n
- 1)
Note 1
The following observations may be useful as guidelines for implementations, but are not part of the normative requirements of this Standard:
If x is any Number value other than
-0
𝔽
, then
ToNumber
(
ToString
(x)) is x.
The least significant digit of s is not always uniquely determined by the requirements listed in step
5
.
Note 2
For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step
5
be used as a guideline:
Let
n
,
k
, and
s
be
integers
such that
k
≥ 1,
radix
k
- 1
≤
s
<
radix
k
,
𝔽
(
s
×
radix
n
-
k
) is
x
, and
k
is as small as possible. If there are multiple possibilities for
s
, choose the value of
s
for which
s
×
radix
n
-
k
is closest in value to
ℝ
(
x
). If there are two such possible values of
s
, choose the one that is even. Note that
k
is the number of digits in the representation of
s
using radix
radix
and that
s
is not divisible by
radix
.
Note 3
Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:
Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell Laboratories (Murray Hill, New Jersey). 30 November 1990. Available as
https://ampl.com/_archive/first-website/REFS/rounding.pdf
. Associated code available as
http://netlib.sandia.gov/fp/dtoa.c
and as
http://netlib.sandia.gov/fp/g_fmt.c
and may also be found at the various
netlib
mirror sites.
6.1.6.2
The BigInt Type
The
BigInt type
represents an
integer
value. The value may be any size and is not limited to a particular bit-width. Generally, where not otherwise noted, operations are designed to return exact mathematically-based answers. For binary operations, BigInts act as two's complement binary strings, with negative numbers treated as having bits set infinitely to the left.
6.1.6.2.1
BigInt::unaryMinus (
x
)
The abstract operation BigInt::unaryMinus takes argument
x
(a BigInt) and returns a BigInt. It performs the following steps when called:
If
x
=
0
ℤ
, return
0
ℤ
.
Return -
x
.
6.1.6.2.2
BigInt::bitwiseNOT (
x
)
The abstract operation BigInt::bitwiseNOT takes argument
x
(a BigInt) and returns a BigInt. It returns the one's complement of
x
. It performs the following steps when called:
Return -
x
-
1
ℤ
.
6.1.6.2.3
BigInt::exponentiate (
base
,
exponent
)
The abstract operation BigInt::exponentiate takes arguments
base
(a BigInt) and
exponent
(a BigInt) and returns either a
normal completion containing
a BigInt or a
throw completion
. It performs the following steps when called:
If
exponent
<
0
ℤ
, throw a
RangeError
exception.
If
base
=
0
ℤ
and
exponent
=
0
ℤ
, return
1
ℤ
.
Return
base
raised to the power
exponent
.
6.1.6.2.4
BigInt::multiply (
x
,
y
)
The abstract operation BigInt::multiply takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Return
x
×
y
.
Note
Even if the result has a much larger bit width than the input, the exact mathematical answer is given.
6.1.6.2.5
BigInt::divide (
x
,
y
)
The abstract operation BigInt::divide takes arguments
x
(a BigInt) and
y
(a BigInt) and returns either a
normal completion containing
a BigInt or a
throw completion
. It performs the following steps when called:
If
y
=
0
ℤ
, throw a
RangeError
exception.
Let
quotient
be
ℝ
(
x
) /
ℝ
(
y
).
Return
ℤ
(
truncate
(
quotient
)).
6.1.6.2.6
BigInt::remainder (
n
,
d
)
The abstract operation BigInt::remainder takes arguments
n
(a BigInt) and
d
(a BigInt) and returns either a
normal completion containing
a BigInt or a
throw completion
. It performs the following steps when called:
If
d
=
0
ℤ
, throw a
RangeError
exception.
If
n
=
0
ℤ
, return
0
ℤ
.
Let
quotient
be
ℝ
(
n
) /
ℝ
(
d
).
Let
q
be
ℤ
(
truncate
(
quotient
)).
Return
n
- (
d
×
q
).
Note
The sign of the result is the sign of the dividend.
6.1.6.2.7
BigInt::add (
x
,
y
)
The abstract operation BigInt::add takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Return
x
+
y
.
6.1.6.2.8
BigInt::subtract (
x
,
y
)
The abstract operation BigInt::subtract takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Return
x
-
y
.
6.1.6.2.9
BigInt::leftShift (
x
,
y
)
The abstract operation BigInt::leftShift takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
If
y
<
0
ℤ
, then
Return
ℤ
(
floor
(
ℝ
(
x
) / 2
-
ℝ
(
y
)
)).
Return
x
×
2
ℤ
y
.
Note
Semantics here should be equivalent to a bitwise shift, treating the BigInt as an infinite length string of binary two's complement digits.
6.1.6.2.10
BigInt::signedRightShift (
x
,
y
)
The abstract operation BigInt::signedRightShift takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Return
BigInt::leftShift
(
x
, -
y
).
6.1.6.2.11
BigInt::unsignedRightShift (
x
,
y
)
The abstract operation BigInt::unsignedRightShift takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a
throw completion
. It performs the following steps when called:
Throw a
TypeError
exception.
6.1.6.2.12
BigInt::lessThan (
x
,
y
)
The abstract operation BigInt::lessThan takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a Boolean. It performs the following steps when called:
If
ℝ
(
x
) <
ℝ
(
y
), return
true
; otherwise return
false
.
6.1.6.2.13
BigInt::equal (
x
,
y
)
The abstract operation BigInt::equal takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a Boolean. It performs the following steps when called:
If
ℝ
(
x
) =
ℝ
(
y
), return
true
; otherwise return
false
.
6.1.6.2.14
BinaryAnd (
x
,
y
)
The abstract operation BinaryAnd takes arguments
x
(0 or 1) and
y
(0 or 1) and returns 0 or 1. It performs the following steps when called:
If
x
= 1 and
y
= 1, return 1.
Else, return 0.
6.1.6.2.15
BinaryOr (
x
,
y
)
The abstract operation BinaryOr takes arguments
x
(0 or 1) and
y
(0 or 1) and returns 0 or 1. It performs the following steps when called:
If
x
= 1 or
y
= 1, return 1.
Else, return 0.
6.1.6.2.16
BinaryXor (
x
,
y
)
The abstract operation BinaryXor takes arguments
x
(0 or 1) and
y
(0 or 1) and returns 0 or 1. It performs the following steps when called:
If
x
= 1 and
y
= 0, return 1.
Else if
x
= 0 and
y
= 1, return 1.
Else, return 0.
6.1.6.2.17
BigIntBitwiseOp (
op
,
x
,
y
)
The abstract operation BigIntBitwiseOp takes arguments
op
(
&
,
^
, or
|
),
x
(a BigInt), and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Set
x
to
ℝ
(
x
).
Set
y
to
ℝ
(
y
).
Let
result
be 0.
Let
shift
be 0.
Repeat, until (
x
= 0 or
x
= -1) and (
y
= 0 or
y
= -1),
Let
xDigit
be
x
modulo
2.
Let
yDigit
be
y
modulo
2.
If
op
is
&
, then
Set
result
to
result
+ 2
shift
×
BinaryAnd
(
xDigit
,
yDigit
).
Else if
op
is
|
, then
Set
result
to
result
+ 2
shift
×
BinaryOr
(
xDigit
,
yDigit
).
Else,
Assert
:
op
is
^
.
Set
result
to
result
+ 2
shift
×
BinaryXor
(
xDigit
,
yDigit
).
Set
shift
to
shift
+ 1.
Set
x
to (
x
-
xDigit
) / 2.
Set
y
to (
y
-
yDigit
) / 2.
If
op
is
&
, then
Let
tmp
be
BinaryAnd
(
x
modulo
2,
y
modulo
2).
Else if
op
is
|
, then
Let
tmp
be
BinaryOr
(
x
modulo
2,
y
modulo
2).
Else,
Assert
:
op
is
^
.
Let
tmp
be
BinaryXor
(
x
modulo
2,
y
modulo
2).
If
tmp
≠ 0, then
Set
result
to
result
- 2
shift
.
NOTE: This extends the sign.
Return the
BigInt value for
result
.
6.1.6.2.18
BigInt::bitwiseAND (
x
,
y
)
The abstract operation BigInt::bitwiseAND takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Return
BigIntBitwiseOp
(
&
,
x
,
y
).
6.1.6.2.19
BigInt::bitwiseXOR (
x
,
y
)
The abstract operation BigInt::bitwiseXOR takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Return
BigIntBitwiseOp
(
^
,
x
,
y
).
6.1.6.2.20
BigInt::bitwiseOR (
x
,
y
)
The abstract operation BigInt::bitwiseOR takes arguments
x
(a BigInt) and
y
(a BigInt) and returns a BigInt. It performs the following steps when called:
Return
BigIntBitwiseOp
(
|
,
x
,
y
).
6.1.6.2.21
BigInt::toString (
x
,
radix
)
The abstract operation BigInt::toString takes arguments
x
(a BigInt) and
radix
(an
integer
in the
inclusive interval
from 2 to 36) and returns a String. It represents
x
as a String using a positional numeral system with radix
radix
. The digits used in the representation of a BigInt using radix
r
are taken from the first
r
code units of
"0123456789abcdefghijklmnopqrstuvwxyz"
in order. The representation of BigInts other than
0
ℤ
never includes leading zeroes. It performs the following steps when called:
If
x
<
0
ℤ
, return the
string-concatenation
of
"-"
and
BigInt::toString
(-
x
,
radix
).
Return the String value consisting of the representation of
x
using radix
radix
.
6.1.7
The Object Type
Each instance of the
Object type
, also referred to simply as “an Object”, represents a collection of properties. Each property is either a data property, or an accessor property:
A
data property
associates a key value with an
ECMAScript language value
and a set of Boolean attributes.
An
accessor property
associates a key value with one or two accessor functions, and a set of Boolean attributes. The accessor functions are used to store or retrieve an
ECMAScript language value
that is associated with the property.
The properties of an object are uniquely identified using
property keys
. A
property key
is either a String or a Symbol. All Strings and Symbols, including the empty String, are valid as
property keys
. A
property name
is a
property key
that
is a String
.
An
integer index
is a
property name
n
such that
CanonicalNumericIndexString
(
n
) returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
𝔽
(2
53
- 1). An
array index
is an
integer index
n
such that
CanonicalNumericIndexString
(
n
) returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
𝔽
(2
32
- 2).
Note
Every non-negative
safe integer
has a corresponding
integer index
. Every 32-bit unsigned
integer
except
2
32
- 1
has a corresponding
array index
.
"-0"
is neither an
integer index
nor an
array index
.
Property keys
are used to access properties and their values. There are two kinds of access for properties:
get
and
set
, corresponding to value retrieval and assignment, respectively. The properties accessible via get and set access includes both
own properties
that are a direct part of an object and
inherited properties
which are provided by another associated object via a property inheritance relationship. Inherited properties may be either own or inherited properties of the associated object. Each own property of an object must each have a key value that is distinct from the key values of the other own properties of that object.
All objects are logically collections of properties, but there are multiple forms of objects that differ in their semantics for accessing and manipulating their properties. Please see
6.1.7.2
for definitions of the multiple forms of objects.
In addition, some objects are callable; these are referred to as functions or
function objects
and are described further below. All functions in ECMAScript are members of the Object type.
6.1.7.1
Property Attributes
Attributes are used in this specification to define and explain the state of Object properties as described in
Table 3
. Unless specified explicitly, the initial value of each attribute is its Default Value.
Table 3: Attributes of an Object property
Attribute Name
Types of property for which it is present
Value Domain
Default Value
Description
[[Value]]
data property
an
ECMAScript language value
undefined
The value retrieved by a get access of the property.
[[Writable]]
data property
a Boolean
false
If
false
, attempts by ECMAScript code to change the property's
[[Value]]
attribute using
[[Set]]
will not succeed.
[[Get]]
accessor property
an Object or
undefined
undefined
If the value
is an Object
it must be a
function object
. The function's
[[Call]]
internal method (
Table 5
) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.
[[Set]]
accessor property
an Object or
undefined
undefined
If the value
is an Object
it must be a
function object
. The function's
[[Call]]
internal method (
Table 5
) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's
[[Set]]
internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's
[[Get]]
internal method.
[[Enumerable]]
data property
or
accessor property
a Boolean
false
If
true
, the property will be enumerated by a for-in enumeration (see
14.7.5
). Otherwise, the property is said to be non-enumerable.
[[Configurable]]
data property
or
accessor property
a Boolean
false
If
false
, attempts to delete the property, change it from a
data property
to an
accessor property
or from an
accessor property
to a
data property
, or make any changes to its attributes (other than replacing an existing
[[Value]]
or setting
[[Writable]]
to
false
) will fail.
6.1.7.2
Object Internal Methods and Internal Slots
The actual semantics of objects, in ECMAScript, are specified via algorithms called
internal methods
. Each object in an ECMAScript engine is associated with a set of internal methods that defines its runtime behaviour. These internal methods are not part of the ECMAScript language. They are defined by this specification purely for expository purposes. However, each object within an implementation of ECMAScript must behave as specified by the internal methods associated with it. The exact manner in which this is accomplished is determined by the implementation.
Internal method names are polymorphic. This means that different object values may perform different algorithms when a common internal method name is invoked upon them. That actual object upon which an internal method is invoked is the “target” of the invocation. If, at runtime, the implementation of an algorithm attempts to use an internal method of an object that the object does not support, a
TypeError
exception is thrown.
Internal slots correspond to internal state that is associated with objects, Symbols, or
Private Names
and used by various ECMAScript specification algorithms. Internal slots are not object properties and they are not inherited. Depending upon the specific internal slot specification, such state may consist of values of any
ECMAScript language type
or of specific ECMAScript specification type values. Unless explicitly specified otherwise, internal slots are allocated as part of the process of creating an object, Symbol, or
Private Name
and may not be dynamically added. Unless specified otherwise, the initial value of an internal slot is the value
undefined
. Various algorithms within this specification create values that have internal slots. However, the ECMAScript language provides no direct way to manipulate internal slots.
All objects have an internal slot named
[[PrivateElements]]
, which is a
List
of
PrivateElements
. This
List
represents the values of the private fields, methods, and accessors for the object. Initially, it is an empty
List
.
Internal methods and internal slots are identified within this specification using names enclosed in double square brackets [[ ]].
Table 4
summarizes the
essential internal methods
used by this specification that are applicable to all objects created or manipulated by ECMAScript code. Every object must have algorithms for all of the essential internal methods. However, all objects do not necessarily use the same algorithms for those methods.
An
ordinary object
is an object that satisfies all of the following criteria:
For the internal methods listed in
Table 4
, the object uses those defined in
10.1
.
If the object has a
[[Call]]
internal method, it uses either the one defined in
10.2.1
or the one defined in
10.3.1
.
If the object has a
[[Construct]]
internal method, it uses either the one defined in
10.2.2
or the one defined in
10.3.2
.
An
exotic object
is an object that is not an
ordinary object
.
This specification recognizes different kinds of
exotic objects
by those objects' internal methods. An object that is behaviourally equivalent to a particular kind of
exotic object
(such as an
Array exotic object
or a
bound function exotic object
), but does not have the same collection of internal methods specified for that kind, is not recognized as that kind of
exotic object
.
The “Signature” column of
Table 4
and other similar tables describes the invocation pattern for each internal method. The invocation pattern always includes a parenthesized list of descriptive parameter names. If a parameter name is the same as an ECMAScript type name then the name describes the required type of the parameter value. If an internal method explicitly returns a value, its parameter list is followed by the symbol “→” and the type name of the returned value. The type names used in signatures refer to the types defined in clause
6
augmented by the following additional names. “
any
” means the value may be any
ECMAScript language type
.
In addition to its parameters, an internal method always has access to the object that is the target of the method invocation.
An internal method implicitly returns a
Completion Record
, either a
normal completion
that wraps a value of the return type shown in its invocation pattern, or a
throw completion
.
Table 4: Essential Internal Methods
Internal Method
Signature
Description
[[GetPrototypeOf]]
( )
→
Object | Null
Determine the object that provides inherited properties for this object. A
null
value indicates that there are no inherited properties.
[[SetPrototypeOf]]
(Object | Null)
→
Boolean
Associate this object with another object that provides inherited properties. Passing
null
indicates that there are no inherited properties. Returns
true
indicating that the operation was completed successfully or
false
indicating that the operation was not successful.
[[IsExtensible]]
( )
→
Boolean
Determine whether it is permitted to add additional properties to this object.
[[PreventExtensions]]
( )
→
Boolean
Control whether new properties may be added to this object. Returns
true
if the operation was successful or
false
if the operation was unsuccessful.
[[GetOwnProperty]]
(
propertyKey
)
→
Undefined |
Property Descriptor
Return a
Property Descriptor
for the own property of this object whose key is
propertyKey
, or
undefined
if no such property exists.
[[DefineOwnProperty]]
(
propertyKey
,
PropertyDescriptor
)
→
Boolean
Create or alter the own property, whose key is
propertyKey
, to have the state described by
PropertyDescriptor
. Return
true
if that property was successfully created/updated or
false
if the property could not be created or updated.
[[HasProperty]]
(
propertyKey
)
→
Boolean
Return a Boolean value indicating whether this object already has either an own or inherited property whose key is
propertyKey
.
[[Get]]
(
propertyKey
,
Receiver
)
→
any
Return the value of the property whose key is
propertyKey
from this object. If any ECMAScript code must be executed to retrieve the property value,
Receiver
is used as the
this
value when evaluating the code.
[[Set]]
(
propertyKey
,
value
,
Receiver
)
→
Boolean
Set the value of the property whose key is
propertyKey
to
value
. If any ECMAScript code must be executed to set the property value,
Receiver
is used as the
this
value when evaluating the code. Returns
true
if the property value was set or
false
if it could not be set.
[[Delete]]
(
propertyKey
)
→
Boolean
Remove the own property whose key is
propertyKey
from this object. Return
false
if the property was not deleted and is still present. Return
true
if the property was deleted or is not present.
[[OwnPropertyKeys]]
( )
→
List
of
property keys
Return a
List
whose elements are all of the own
property keys
for the object.
Table 5
summarizes additional essential internal methods that are supported by objects that may be called as functions. A
function object
is an object that supports the
[[Call]]
internal method. A
constructor
is an object that supports the
[[Construct]]
internal method. Every object that supports
[[Construct]]
must support
[[Call]]
; that is, every
constructor
must be a
function object
. Therefore, a
constructor
may also be referred to as a
constructor
function
or
constructor
function object
.
Table 5: Additional Essential Internal Methods of Function Objects
Internal Method
Signature
Description
[[Call]]
(
any
, a
List
of
any
)
→
any
Executes code associated with this object. Invoked via a function call expression. The arguments to the internal method are a
this
value and a
List
whose elements are the arguments passed to the function by a call expression. Objects that implement this internal method are
callable
.
[[Construct]]
(a
List
of
any
, Object)
→
Object
Creates an object. Invoked via the
new
operator or a
super
call. The first argument to the internal method is a
List
whose elements are the arguments of the
constructor
invocation or the
super
call. The second argument is the object to which the
new
operator was initially applied. Objects that implement this internal method are called
constructors
. A
function object
is not necessarily a
constructor
and such non-
constructor
function objects
do not have a
[[Construct]]
internal method.
The semantics of the essential internal methods for
ordinary objects
and standard
exotic objects
are specified in clause
10
. If any specified use of an internal method of an
exotic object
is not supported by an implementation, that usage must throw a
TypeError
exception when attempted.
6.1.7.3
Invariants of the Essential Internal Methods
The Internal Methods of Objects of an ECMAScript engine must conform to the list of invariants specified below. Ordinary ECMAScript Objects as well as all standard
exotic objects
in this specification maintain these invariants. ECMAScript Proxy objects maintain these invariants by means of runtime checks on the result of traps invoked on the
[[ProxyHandler]]
object.
Any implementation provided
exotic objects
must also maintain these invariants for those objects. Violation of these invariants may cause ECMAScript code to have unpredictable behaviour and create security issues. However, violation of these invariants must never compromise the memory safety of an implementation.
An implementation must not allow these invariants to be circumvented in any manner such as by providing alternative interfaces that implement the functionality of the essential internal methods without enforcing their invariants.
Definitions:
The
target
of an internal method is the object upon which the internal method is called.
A target is
non-extensible
if it has been observed to return
false
from its
[[IsExtensible]]
internal method, or
true
from its
[[PreventExtensions]]
internal method.
A
non-existent
property is a property that does not exist as an own property on a non-extensible target.
All references to
SameValue
are according to the definition of the
SameValue
algorithm.
Return value:
The value returned by any internal method must be a
Completion Record
with either:
[[Type]]
=
normal
,
[[Target]]
=
empty
, and
[[Value]]
= a value of the "normal return type" shown below for that internal method, or
[[Type]]
=
throw
,
[[Target]]
=
empty
, and
[[Value]]
= any
ECMAScript language value
.
Note 1
An internal method must not return a
continue completion
, a
break completion
, or a
return completion
.
[[GetPrototypeOf]]
( )
The normal return type is either Object or Null.
If target is non-extensible, and
[[GetPrototypeOf]]
returns a value
V
, then any future calls to
[[GetPrototypeOf]]
should return the
SameValue
as
V
.
Note 2
An object's prototype chain should have
finite
length (that is, starting from any object, recursively applying the
[[GetPrototypeOf]]
internal method to its result should eventually lead to the value
null
). However, this requirement is not enforceable as an object level invariant if the prototype chain includes any
exotic objects
that do not use the
ordinary object
definition of
[[GetPrototypeOf]]
. Such a circular prototype chain may result in infinite loops when accessing object properties.
[[SetPrototypeOf]]
(
V
)
The normal return type is Boolean.
If target is non-extensible,
[[SetPrototypeOf]]
must return
false
, unless
V
is the
SameValue
as the target's observed
[[GetPrototypeOf]]
value.
[[IsExtensible]]
( )
The normal return type is Boolean.
If
[[IsExtensible]]
returns
false
, all future calls to
[[IsExtensible]]
on the target must return
false
.
[[PreventExtensions]]
( )
The normal return type is Boolean.
If
[[PreventExtensions]]
returns
true
, all future calls to
[[IsExtensible]]
on the target must return
false
and the target is now considered non-extensible.
[[GetOwnProperty]]
(
P
)
The normal return type is either
Property Descriptor
or Undefined.
If the return value is a
Property Descriptor
, it must be a
fully populated Property Descriptor
.
If
P
is described as a non-configurable, non-writable own
data property
, all future calls to
[[GetOwnProperty]]
(
P
) must return
Property Descriptor
whose
[[Value]]
is
SameValue
as
P
's
[[Value]]
attribute.
If
P
's attributes other than
[[Writable]]
and
[[Value]]
may change over time, or if the property might be deleted, then
P
's
[[Configurable]]
attribute must be
true
.
If the
[[Writable]]
attribute may change from
false
to
true
, then the
[[Configurable]]
attribute must be
true
.
If the target is non-extensible and
P
is non-existent, then all future calls to
[[GetOwnProperty]]
(
P
) on the target must describe
P
as non-existent (i.e.
[[GetOwnProperty]]
(
P
) must return
undefined
).
Note 3
As a consequence of the third invariant, if a property is described as a
data property
and it may return different values over time, then either or both of the
[[Writable]]
and
[[Configurable]]
attributes must be
true
even if no mechanism to change the value is exposed via the other essential internal methods.
[[DefineOwnProperty]]
(
P
,
Desc
)
The normal return type is Boolean.
[[DefineOwnProperty]]
must return
false
if
P
has previously been observed as a non-configurable own property of the target, unless either:
P
is a writable
data property
. A non-configurable writable
data property
can be changed into a non-configurable non-writable
data property
.
All attributes of
Desc
are the
SameValue
as
P
's attributes.
[[DefineOwnProperty]]
(
P
,
Desc
) must return
false
if target is non-extensible and
P
is a non-existent own property. That is, a non-extensible target object cannot be extended with new properties.
[[HasProperty]]
(
P
)
The normal return type is Boolean.
If
P
was previously observed as a non-configurable own data or
accessor property
of the target,
[[HasProperty]]
must return
true
.
[[Get]]
(
P
,
Receiver
)
The normal return type is any
ECMAScript language type
.
If
P
was previously observed as a non-configurable, non-writable own
data property
of the target with value
V
, then
[[Get]]
must return the
SameValue
as
V
.
If
P
was previously observed as a non-configurable own
accessor property
of the target whose
[[Get]]
attribute is
undefined
, the
[[Get]]
operation must return
undefined
.
[[Set]]
(
P
,
V
,
Receiver
)
The normal return type is Boolean.
If
P
was previously observed as a non-configurable, non-writable own
data property
of the target, then
[[Set]]
must return
false
unless
V
is the
SameValue
as
P
's
[[Value]]
attribute.
If
P
was previously observed as a non-configurable own
accessor property
of the target whose
[[Set]]
attribute is
undefined
, the
[[Set]]
operation must return
false
.
[[Delete]]
(
P
)
The normal return type is Boolean.
If
P
was previously observed as a non-configurable own data or
accessor property
of the target,
[[Delete]]
must return
false
.
[[OwnPropertyKeys]]
( )
The normal return type is
List
.
The returned
List
must not contain any duplicate entries.
Each element of the returned
List
must be a
property key
.
The returned
List
must contain at least the keys of all non-configurable own properties that have previously been observed.
If the target is non-extensible, the returned
List
must contain only the keys of all own properties of the target that are observable using
[[GetOwnProperty]]
.
[[Call]]
( )
The normal return type is any
ECMAScript language type
.
[[Construct]]
( )
The normal return type is Object.
The target must also have a
[[Call]]
internal method.
6.1.7.4
Well-Known Intrinsic Objects
Well-known intrinsics are built-in objects that are explicitly referenced by the algorithms of this specification and which usually have
realm
-specific identities. Unless otherwise specified each intrinsic object actually corresponds to a set of similar objects, one per
realm
.
Within this specification a reference such as %name% means the intrinsic object, associated with the current
realm
, corresponding to the name. A reference such as %name.a.b% means, as if the
"b"
property of the value of the
"a"
property of the intrinsic object %name% was accessed prior to any ECMAScript code being evaluated. Determination of the current
realm
and its intrinsics is described in
9.4
. The well-known intrinsics are listed in
Table 6
.
Table 6: Well-Known Intrinsic Objects
Intrinsic Name
Global Name
ECMAScript Language Association
%AggregateError%
AggregateError
The
AggregateError
constructor
(
20.5.7.1
)
%Array%
Array
The Array
constructor
(
23.1.1
)
%ArrayBuffer%
ArrayBuffer
The ArrayBuffer
constructor
(
25.1.4
)
%ArrayIteratorPrototype%
The prototype of
Array Iterator objects
(
23.1.5
)
%AsyncFromSyncIteratorPrototype%
The prototype of
Async-from-Sync Iterator objects
(
27.1.5
)
%AsyncFunction%
The
constructor
of async
function objects
(
27.7.1
)
%AsyncGeneratorFunction%
The
constructor
of async generator
function objects
(
27.4.1
)
%AsyncGeneratorPrototype%
The prototype of async generator objects (
27.6
)
%AsyncIteratorPrototype%
An object that all standard built-in
async iterator objects
indirectly inherit from
%Atomics%
Atomics
The
Atomics
object (
25.4
)
%BigInt%
BigInt
The BigInt
constructor
(
21.2.1
)
%BigInt64Array%
BigInt64Array
The BigInt64Array
constructor
(
23.2
)
%BigUint64Array%
BigUint64Array
The BigUint64Array
constructor
(
23.2
)
%Boolean%
Boolean
The Boolean
constructor
(
20.3.1
)
%DataView%
DataView
The DataView
constructor
(
25.3.2
)
%Date%
Date
The Date
constructor
(
21.4.2
)
%decodeURI%
decodeURI
The
decodeURI
function (
19.2.6.1
)
%decodeURIComponent%
decodeURIComponent
The
decodeURIComponent
function (
19.2.6.2
)
%encodeURI%
encodeURI
The
encodeURI
function (
19.2.6.3
)
%encodeURIComponent%
encodeURIComponent
The
encodeURIComponent
function (
19.2.6.4
)
%Error%
Error
The Error
constructor
(
20.5.1
)
%eval%
eval
The
eval
function (
19.2.1
)
%EvalError%
EvalError
The EvalError
constructor
(
20.5.5.1
)
%FinalizationRegistry%
FinalizationRegistry
The
FinalizationRegistry
constructor
(
26.2.1
)
%Float16Array%
Float16Array
The Float16Array
constructor
(
23.2
)
%Float32Array%
Float32Array
The Float32Array
constructor
(
23.2
)
%Float64Array%
Float64Array
The Float64Array
constructor
(
23.2
)
%ForInIteratorPrototype%
The prototype of
For-In Iterator objects
(
14.7.5.10
)
%Function%
Function
The Function
constructor
(
20.2.1
)
%GeneratorFunction%
The
constructor
of generator
function objects
(
27.3.1
)
%GeneratorPrototype%
The prototype of generator objects (
27.5
)
%Int8Array%
Int8Array
The Int8Array
constructor
(
23.2
)
%Int16Array%
Int16Array
The Int16Array
constructor
(
23.2
)
%Int32Array%
Int32Array
The Int32Array
constructor
(
23.2
)
%isFinite%
isFinite
The
isFinite
function (
19.2.2
)
%isNaN%
isNaN
The
isNaN
function (
19.2.3
)
%Iterator%
Iterator
The
Iterator
constructor
(
27.1.3.1
)
%IteratorHelperPrototype%
The prototype of
Iterator Helper objects
(
27.1.2.1
)
%JSON%
JSON
The
JSON
object (
25.5
)
%Map%
Map
The Map
constructor
(
24.1.1
)
%MapIteratorPrototype%
The prototype of
Map Iterator objects
(
24.1.5
)
%Math%
Math
The
Math
object (
21.3
)
%Number%
Number
The Number
constructor
(
21.1.1
)
%Object%
Object
The Object
constructor
(
20.1.1
)
%parseFloat%
parseFloat
The
parseFloat
function (
19.2.4
)
%parseInt%
parseInt
The
parseInt
function (
19.2.5
)
%Promise%
Promise
The Promise
constructor
(
27.2.3
)
%Proxy%
Proxy
The Proxy
constructor
(
28.2.1
)
%RangeError%
RangeError
The RangeError
constructor
(
20.5.5.2
)
%ReferenceError%
ReferenceError
The ReferenceError
constructor
(
20.5.5.3
)
%Reflect%
Reflect
The
Reflect
object (
28.1
)
%RegExp%
RegExp
The RegExp
constructor
(
22.2.4
)
%RegExpStringIteratorPrototype%
The prototype of
RegExp String Iterator objects
(
22.2.9
)
%Set%
Set
The Set
constructor
(
24.2.2
)
%SetIteratorPrototype%
The prototype of
Set Iterator objects
(
24.2.6
)
%SharedArrayBuffer%
SharedArrayBuffer
The SharedArrayBuffer
constructor
(
25.2.3
)
%String%
String
The String
constructor
(
22.1.1
)
%StringIteratorPrototype%
The prototype of
String Iterator objects
(
22.1.5
)
%Symbol%
Symbol
The Symbol
constructor
(
20.4.1
)
%SyntaxError%
SyntaxError
The SyntaxError
constructor
(
20.5.5.4
)
%ThrowTypeError%
A
function object
that unconditionally throws a new instance of
%TypeError%
%TypedArray%
The super class of all typed Array
constructors
(
23.2.1
)
%TypeError%
TypeError
The TypeError
constructor
(
20.5.5.5
)
%Uint8Array%
Uint8Array
The Uint8Array
constructor
(
23.2
)
%Uint8ClampedArray%
Uint8ClampedArray
The Uint8ClampedArray
constructor
(
23.2
)
%Uint16Array%
Uint16Array
The Uint16Array
constructor
(
23.2
)
%Uint32Array%
Uint32Array
The Uint32Array
constructor
(
23.2
)
%URIError%
URIError
The URIError
constructor
(
20.5.5.6
)
%WeakMap%
WeakMap
The WeakMap
constructor
(
24.3.1
)
%WeakRef%
WeakRef
The
WeakRef
constructor
(
26.1.1
)
%WeakSet%
WeakSet
The WeakSet
constructor
(
24.4.1
)
%WrapForValidIteratorPrototype%
The prototype of wrapped
iterator objects
returned by Iterator.from (
27.1.3.2.2.1
)
Note
Additional entries in
Table 97
.
6.2
ECMAScript Specification Types
A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and
ECMAScript language types
. The specification types include
Reference Record
,
List
,
Completion Record
,
Property Descriptor
,
Environment Record
,
Abstract Closure
, and
Data Block
. Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.
6.2.1
The Enum Specification Type
Enums
are values which are internal to the specification and not directly observable from ECMAScript code. Enums are denoted using a
sans-serif
typeface. For instance, a
Completion Record
's
[[Type]]
field takes on values like
normal
,
return
, or
throw
. Enums have no characteristics other than their name. The name of an enum serves no purpose other than to distinguish it from other enums, and implies nothing about its usage or meaning in context.
6.2.2
The List and Record Specification Types
The
List
type is used to explain the evaluation of argument lists (see
13.3.8
) in
new
expressions, in function calls, and in other algorithms where a simple ordered list of values is needed. Values of the List type are simply ordered sequences of list elements containing the individual values. These sequences may be of any length. The elements of a list may be randomly accessed using 0-origin indices. For notational convenience an array-like syntax can be used to access List elements. For example,
arguments
[2] is shorthand for saying the 3
rd
element of the List
arguments
.
When an algorithm iterates over the elements of a List without specifying an order, the order used is the order of the elements in the List.
For notational convenience within this specification, a literal syntax can be used to express a new List value. For example, « 1, 2 » defines a List value that has two elements each of which is initialized to a specific value. A new empty List can be expressed as « ».
In this specification, the phrase "the
list-concatenation
of
A
,
B
, ..." (where each argument is a possibly empty List) denotes a new List value whose elements are the concatenation of the elements (in order) of each of the arguments (in order).
As applied to a List of Strings, the phrase "sorted according to
lexicographic code unit order
" means sorting by the numeric value of each code unit up to the length of the shorter string, and sorting the shorter string before the longer string if all are equal, as described in the abstract operation
IsLessThan
.
The
Record
type is used to describe data aggregations within the algorithms of this specification. A Record type value consists of one or more named fields. The value of each field is an
ECMAScript language value
or specification value. Field names are always enclosed in double brackets, for example
[[Value]]
.
For notational convenience within this specification, an object literal-like syntax can be used to express a Record value. For example, {
[[Field1]]
: 42,
[[Field2]]
:
false
,
[[Field3]]
:
empty
} defines a Record value that has three fields, each of which is initialized to a specific value. Field name order is not significant. Any fields that are not explicitly listed are considered to be absent.
In specification text and algorithms, dot notation may be used to refer to a specific field of a Record value. For example, if R is the record shown in the previous paragraph then R.
[[Field2]]
is shorthand for “the field of R named
[[Field2]]
”.
Schema for commonly used Record field combinations may be named, and that name may be used as a prefix to a literal Record value to identify the specific kind of aggregations that is being described. For example: PropertyDescriptor {
[[Value]]
: 42,
[[Writable]]
:
false
,
[[Configurable]]
:
true
}.
6.2.3
The Set and Relation Specification Types
The
Set
type is used to explain a collection of unordered elements for use in the
memory model
. It is distinct from the ECMAScript collection type of the same name. To disambiguate, instances of the ECMAScript collection are consistently referred to as "
Set objects
" within this specification. Values of the Set type are simple collections of elements, where no element appears more than once. Elements may be added to and removed from Sets. Sets may be unioned, intersected, or subtracted from each other.
The
Relation
type is used to explain constraints on Sets. Values of the Relation type are Sets of ordered pairs of values from its value domain. For example, a Relation on
Memory events
is a set of ordered pairs of
Memory events
. For a Relation
R
and two values
a
and
b
in the value domain of
R
,
a
R
b
is shorthand for saying the ordered pair (
a
,
b
) is a member of
R
. A Relation is the
least Relation
with respect to some conditions when it is the smallest Relation that satisfies those conditions.
A
strict partial order
is a Relation value
R
that satisfies the following.
For all
a
,
b
, and
c
in
R
's domain:
It is not the case that
a
R
a
, and
If
a
R
b
and
b
R
c
, then
a
R
c
.
Note 1
The two properties above are called irreflexivity and transitivity, respectively.
A
strict total order
is a Relation value
R
that satisfies the following.
For all
a
,
b
, and
c
in
R
's domain:
a
is
b
or
a
R
b
or
b
R
a
, and
It is not the case that
a
R
a
, and
If
a
R
b
and
b
R
c
, then
a
R
c
.
Note 2
The three properties above are called totality, irreflexivity, and transitivity, respectively.
6.2.4
The Completion Record Specification Type
The
Completion Record
specification type is used to explain the runtime propagation of values and control flow such as the behaviour of statements (
break
,
continue
,
return
and
throw
) that perform nonlocal transfers of control.
Completion Records have the fields defined in
Table 7
.
Table 7:
Completion Record
Fields
Field Name
Value
Meaning
[[Type]]
normal
,
break
,
continue
,
return
, or
throw
The type of completion that occurred.
[[Value]]
any value except a
Completion Record
The value that was produced.
[[Target]]
a String or
empty
The target label for directed control transfers.
The following shorthand terms are sometimes used to refer to Completion Records.
normal completion
refers to any Completion Record with a
[[Type]]
value of
normal
.
break completion
refers to any Completion Record with a
[[Type]]
value of
break
.
continue completion
refers to any Completion Record with a
[[Type]]
value of
continue
.
return completion
refers to any Completion Record with a
[[Type]]
value of
return
.
throw completion
refers to any Completion Record with a
[[Type]]
value of
throw
.
abrupt completion
refers to any Completion Record with a
[[Type]]
value other than
normal
.
a
normal completion containing
some type of value refers to a normal completion that has a value of that type in its
[[Value]]
field.
Callable objects that are defined in this specification only return a normal completion or a throw completion. Returning any other kind of Completion Record is considered an editorial error.
Implementation-defined
callable objects must return either a normal completion or a throw completion.
6.2.4.1
NormalCompletion (
value
)
The abstract operation NormalCompletion takes argument
value
(any value except a
Completion Record
) and returns a
normal completion
. It performs the following steps when called:
Return
Completion Record
{
[[Type]]
:
normal
,
[[Value]]
:
value
,
[[Target]]
:
empty
}.
6.2.4.2
ThrowCompletion (
value
)
The abstract operation ThrowCompletion takes argument
value
(an
ECMAScript language value
) and returns a
throw completion
. It performs the following steps when called:
Return
Completion Record
{
[[Type]]
:
throw
,
[[Value]]
:
value
,
[[Target]]
:
empty
}.
6.2.4.3
ReturnCompletion (
value
)
The abstract operation ReturnCompletion takes argument
value
(an
ECMAScript language value
) and returns a
return completion
. It performs the following steps when called:
Return
Completion Record
{
[[Type]]
:
return
,
[[Value]]
:
value
,
[[Target]]
:
empty
}.
6.2.4.4
UpdateEmpty (
completionRecord
,
value
)
The abstract operation UpdateEmpty takes arguments
completionRecord
(a
Completion Record
) and
value
(any value except a
Completion Record
) and returns a
Completion Record
. It performs the following steps when called:
Assert
: If
completionRecord
is either a
return completion
or a
throw completion
, then
completionRecord
.
[[Value]]
is not
empty
.
If
completionRecord
.
[[Value]]
is not
empty
, return ?
completionRecord
.
Return
Completion Record
{
[[Type]]
:
completionRecord
.
[[Type]]
,
[[Value]]
:
value
,
[[Target]]
:
completionRecord
.
[[Target]]
}.
6.2.5
The Reference Record Specification Type
The
Reference Record
type is used to explain the behaviour of such operators as
delete
,
typeof
, the assignment operators, the
super
keyword
and other language features. For example, the left-hand operand of an assignment is expected to produce a Reference Record.
A Reference Record is a resolved name or (possibly not-yet-resolved) property binding; its fields are defined by
Table 8
.
Table 8:
Reference Record
Fields
Field Name
Value
Meaning
[[Base]]
an
ECMAScript language value
, an
Environment Record
, or
unresolvable
The value or
Environment Record
which holds the binding. A
[[Base]]
of
unresolvable
indicates that the binding could not be resolved.
[[ReferencedName]]
an
ECMAScript language value
or a
Private Name
The name of the binding. Always a String if
[[Base]]
value is an
Environment Record
. Otherwise, may be an
ECMAScript language value
other than a String or a Symbol until
ToPropertyKey
is performed.
[[Strict]]
a Boolean
true
if the
Reference Record
originated in
strict mode code
,
false
otherwise.
[[ThisValue]]
an
ECMAScript language value
or
empty
If not
empty
, the
Reference Record
represents a property binding that was expressed using the
super
keyword
; it is called a
Super Reference Record
and its
[[Base]]
value will never be an
Environment Record
. In that case, the
[[ThisValue]]
field holds the
this
value at the time the
Reference Record
was created.
The following
abstract operations
are used in this specification to operate upon Reference Records:
6.2.5.1
IsPropertyReference (
V
)
The abstract operation IsPropertyReference takes argument
V
(a
Reference Record
) and returns a Boolean. It performs the following steps when called:
If
V
.
[[Base]]
is
unresolvable
, return
false
.
If
V
.
[[Base]]
is an
Environment Record
, return
false
; otherwise return
true
.
6.2.5.2
IsUnresolvableReference (
V
)
The abstract operation IsUnresolvableReference takes argument
V
(a
Reference Record
) and returns a Boolean. It performs the following steps when called:
If
V
.
[[Base]]
is
unresolvable
, return
true
; otherwise return
false
.
6.2.5.3
IsSuperReference (
V
)
The abstract operation IsSuperReference takes argument
V
(a
Reference Record
) and returns a Boolean. It performs the following steps when called:
If
V
.
[[ThisValue]]
is not
empty
, return
true
; otherwise return
false
.
6.2.5.4
IsPrivateReference (
V
)
The abstract operation IsPrivateReference takes argument
V
(a
Reference Record
) and returns a Boolean. It performs the following steps when called:
If
V
.
[[ReferencedName]]
is a
Private Name
, return
true
; otherwise return
false
.
6.2.5.5
GetValue (
V
)
The abstract operation GetValue takes argument
V
(a
Reference Record
or an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
If
V
is not a
Reference Record
, return
V
.
If
IsUnresolvableReference
(
V
) is
true
, throw a
ReferenceError
exception.
If
IsPropertyReference
(
V
) is
true
, then
Let
baseObj
be ?
ToObject
(
V
.
[[Base]]
).
If
IsPrivateReference
(
V
) is
true
, then
Return ?
PrivateGet
(
baseObj
,
V
.
[[ReferencedName]]
).
If
V
.
[[ReferencedName]]
is not a
property key
, then
Set
V
.
[[ReferencedName]]
to ?
ToPropertyKey
(
V
.
[[ReferencedName]]
).
Return ?
baseObj
.
[[Get]]
(
V
.
[[ReferencedName]]
,
GetThisValue
(
V
))
.
Else,
Let
base
be
V
.
[[Base]]
.
Assert
:
base
is an
Environment Record
.
Return ?
base
.
GetBindingValue
(
V
.
[[ReferencedName]]
,
V
.
[[Strict]]
)
(see
9.1
).
Note
The object that may be created in step
3.a
is not accessible outside of the above abstract operation and the
ordinary object
[[Get]]
internal method. An implementation might choose to avoid the actual creation of the object.
6.2.5.6
PutValue (
V
,
W
)
The abstract operation PutValue takes arguments
V
(a
Reference Record
or an
ECMAScript language value
) and
W
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It performs the following steps when called:
If
V
is not a
Reference Record
, throw a
ReferenceError
exception.
If
IsUnresolvableReference
(
V
) is
true
, then
If
V
.
[[Strict]]
is
true
, throw a
ReferenceError
exception.
Let
globalObj
be
GetGlobalObject
().
Perform ?
Set
(
globalObj
,
V
.
[[ReferencedName]]
,
W
,
false
).
Return
unused
.
If
IsPropertyReference
(
V
) is
true
, then
Let
baseObj
be ?
ToObject
(
V
.
[[Base]]
).
If
IsPrivateReference
(
V
) is
true
, then
Return ?
PrivateSet
(
baseObj
,
V
.
[[ReferencedName]]
,
W
).
If
V
.
[[ReferencedName]]
is not a
property key
, then
Set
V
.
[[ReferencedName]]
to ?
ToPropertyKey
(
V
.
[[ReferencedName]]
).
Let
succeeded
be ?
baseObj
.
[[Set]]
(
V
.
[[ReferencedName]]
,
W
,
GetThisValue
(
V
))
.
If
succeeded
is
false
and
V
.
[[Strict]]
is
true
, throw a
TypeError
exception.
Return
unused
.
Else,
Let
base
be
V
.
[[Base]]
.
Assert
:
base
is an
Environment Record
.
Return ?
base
.
SetMutableBinding
(
V
.
[[ReferencedName]]
,
W
,
V
.
[[Strict]]
)
(see
9.1
).
Note
The object that may be created in step
3.a
is not accessible outside of the above abstract operation and the
ordinary object
[[Set]]
internal method. An implementation might choose to avoid the actual creation of that object.
6.2.5.7
GetThisValue (
V
)
The abstract operation GetThisValue takes argument
V
(a
Reference Record
) and returns an
ECMAScript language value
. It performs the following steps when called:
Assert
:
IsPropertyReference
(
V
) is
true
.
If
IsSuperReference
(
V
) is
true
, return
V
.
[[ThisValue]]
; otherwise return
V
.
[[Base]]
.
6.2.5.8
InitializeReferencedBinding (
V
,
W
)
The abstract operation InitializeReferencedBinding takes arguments
V
(a
Reference Record
) and
W
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It performs the following steps when called:
Assert
:
IsUnresolvableReference
(
V
) is
false
.
Let
base
be
V
.
[[Base]]
.
Assert
:
base
is an
Environment Record
.
Return ?
base
.
InitializeBinding
(
V
.
[[ReferencedName]]
,
W
).
6.2.5.9
MakePrivateReference (
baseValue
,
privateIdentifier
)
The abstract operation MakePrivateReference takes arguments
baseValue
(an
ECMAScript language value
) and
privateIdentifier
(a String) and returns a
Reference Record
. It performs the following steps when called:
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Assert
:
privateEnv
is not
null
.
Let
privateName
be
ResolvePrivateIdentifier
(
privateEnv
,
privateIdentifier
).
Return the
Reference Record
{
[[Base]]
:
baseValue
,
[[ReferencedName]]
:
privateName
,
[[Strict]]
:
true
,
[[ThisValue]]
:
empty
}.
6.2.6
The Property Descriptor Specification Type
The
Property Descriptor
type is used to explain the manipulation and reification of Object property attributes. A Property Descriptor is a
Record
with zero or more fields, where each field's name is an attribute name and its value is a corresponding attribute value as specified in
6.1.7.1
. The schema name used within this specification to tag literal descriptions of Property Descriptor records is “PropertyDescriptor”.
Property Descriptor values may be further classified as data Property Descriptors and accessor Property Descriptors based upon the existence or use of certain fields. A data Property Descriptor is one that includes any fields named either
[[Value]]
or
[[Writable]]
. An accessor Property Descriptor is one that includes any fields named either
[[Get]]
or
[[Set]]
. Any Property Descriptor may have fields named
[[Enumerable]]
and
[[Configurable]]
. A Property Descriptor value may not be both a data Property Descriptor and an accessor Property Descriptor; however, it may be neither (in which case it is a generic Property Descriptor). A
fully populated Property Descriptor
is one that is either an accessor Property Descriptor or a data Property Descriptor and that has all of the corresponding fields defined in
Table 3
.
The following
abstract operations
are used in this specification to operate upon Property Descriptor values:
6.2.6.1
IsAccessorDescriptor (
Desc
)
The abstract operation IsAccessorDescriptor takes argument
Desc
(a
Property Descriptor
) and returns a Boolean. It performs the following steps when called:
If
Desc
has a
[[Get]]
field, return
true
.
If
Desc
has a
[[Set]]
field, return
true
.
Return
false
.
6.2.6.2
IsDataDescriptor (
Desc
)
The abstract operation IsDataDescriptor takes argument
Desc
(a
Property Descriptor
) and returns a Boolean. It performs the following steps when called:
If
Desc
has a
[[Value]]
field, return
true
.
If
Desc
has a
[[Writable]]
field, return
true
.
Return
false
.
6.2.6.3
IsGenericDescriptor (
Desc
)
The abstract operation IsGenericDescriptor takes argument
Desc
(a
Property Descriptor
) and returns a Boolean. It performs the following steps when called:
If
IsAccessorDescriptor
(
Desc
) is
true
, return
false
.
If
IsDataDescriptor
(
Desc
) is
true
, return
false
.
Return
true
.
6.2.6.4
FromPropertyDescriptor (
Desc
)
The abstract operation FromPropertyDescriptor takes argument
Desc
(a
Property Descriptor
or
undefined
) and returns an Object or
undefined
. It performs the following steps when called:
If
Desc
is
undefined
, return
undefined
.
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Assert
:
obj
is an extensible
ordinary object
with no own properties.
If
Desc
has a
[[Value]]
field, then
Perform !
CreateDataPropertyOrThrow
(
obj
,
"value"
,
Desc
.
[[Value]]
).
If
Desc
has a
[[Writable]]
field, then
Perform !
CreateDataPropertyOrThrow
(
obj
,
"writable"
,
Desc
.
[[Writable]]
).
If
Desc
has a
[[Get]]
field, then
Perform !
CreateDataPropertyOrThrow
(
obj
,
"get"
,
Desc
.
[[Get]]
).
If
Desc
has a
[[Set]]
field, then
Perform !
CreateDataPropertyOrThrow
(
obj
,
"set"
,
Desc
.
[[Set]]
).
If
Desc
has an
[[Enumerable]]
field, then
Perform !
CreateDataPropertyOrThrow
(
obj
,
"enumerable"
,
Desc
.
[[Enumerable]]
).
If
Desc
has a
[[Configurable]]
field, then
Perform !
CreateDataPropertyOrThrow
(
obj
,
"configurable"
,
Desc
.
[[Configurable]]
).
Return
obj
.
6.2.6.5
ToPropertyDescriptor (
Obj
)
The abstract operation ToPropertyDescriptor takes argument
Obj
(an
ECMAScript language value
) and returns either a
normal completion containing
a
Property Descriptor
or a
throw completion
. It performs the following steps when called:
If
Obj
is not an Object
, throw a
TypeError
exception.
Let
desc
be a new
Property Descriptor
that initially has no fields.
Let
hasEnumerable
be ?
HasProperty
(
Obj
,
"enumerable"
).
If
hasEnumerable
is
true
, then
Let
enumerable
be
ToBoolean
(?
Get
(
Obj
,
"enumerable"
)).
Set
desc
.
[[Enumerable]]
to
enumerable
.
Let
hasConfigurable
be ?
HasProperty
(
Obj
,
"configurable"
).
If
hasConfigurable
is
true
, then
Let
configurable
be
ToBoolean
(?
Get
(
Obj
,
"configurable"
)).
Set
desc
.
[[Configurable]]
to
configurable
.
Let
hasValue
be ?
HasProperty
(
Obj
,
"value"
).
If
hasValue
is
true
, then
Let
value
be ?
Get
(
Obj
,
"value"
).
Set
desc
.
[[Value]]
to
value
.
Let
hasWritable
be ?
HasProperty
(
Obj
,
"writable"
).
If
hasWritable
is
true
, then
Let
writable
be
ToBoolean
(?
Get
(
Obj
,
"writable"
)).
Set
desc
.
[[Writable]]
to
writable
.
Let
hasGet
be ?
HasProperty
(
Obj
,
"get"
).
If
hasGet
is
true
, then
Let
getter
be ?
Get
(
Obj
,
"get"
).
If
IsCallable
(
getter
) is
false
and
getter
is not
undefined
, throw a
TypeError
exception.
Set
desc
.
[[Get]]
to
getter
.
Let
hasSet
be ?
HasProperty
(
Obj
,
"set"
).
If
hasSet
is
true
, then
Let
setter
be ?
Get
(
Obj
,
"set"
).
If
IsCallable
(
setter
) is
false
and
setter
is not
undefined
, throw a
TypeError
exception.
Set
desc
.
[[Set]]
to
setter
.
If
desc
has a
[[Get]]
field or
desc
has a
[[Set]]
field, then
If
desc
has a
[[Value]]
field or
desc
has a
[[Writable]]
field, throw a
TypeError
exception.
Return
desc
.
6.2.6.6
CompletePropertyDescriptor (
Desc
)
The abstract operation CompletePropertyDescriptor takes argument
Desc
(a
Property Descriptor
) and returns
unused
. It performs the following steps when called:
Let
like
be the
Record
{
[[Value]]
:
undefined
,
[[Writable]]
:
false
,
[[Get]]
:
undefined
,
[[Set]]
:
undefined
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
If
IsGenericDescriptor
(
Desc
) is
true
or
IsDataDescriptor
(
Desc
) is
true
, then
If
Desc
does not have a
[[Value]]
field, set
Desc
.
[[Value]]
to
like
.
[[Value]]
.
If
Desc
does not have a
[[Writable]]
field, set
Desc
.
[[Writable]]
to
like
.
[[Writable]]
.
Else,
If
Desc
does not have a
[[Get]]
field, set
Desc
.
[[Get]]
to
like
.
[[Get]]
.
If
Desc
does not have a
[[Set]]
field, set
Desc
.
[[Set]]
to
like
.
[[Set]]
.
If
Desc
does not have an
[[Enumerable]]
field, set
Desc
.
[[Enumerable]]
to
like
.
[[Enumerable]]
.
If
Desc
does not have a
[[Configurable]]
field, set
Desc
.
[[Configurable]]
to
like
.
[[Configurable]]
.
Return
unused
.
6.2.7
The Environment Record Specification Type
The
Environment Record
type is used to explain the behaviour of name resolution in nested functions and blocks. This type and the operations upon it are defined in
9.1
.
6.2.8
The Abstract Closure Specification Type
The
Abstract Closure
specification type is used to refer to algorithm steps together with a collection of values. Abstract Closures are meta-values and are invoked using function application style such as
closure
(
arg1
,
arg2
). Like
abstract operations
, invocations perform the algorithm steps described by the Abstract Closure.
In algorithm steps that create an Abstract Closure, values are captured with the verb "capture" followed by a list of aliases. When an Abstract Closure is created, it captures the value that is associated with each alias at that time. In steps that specify the algorithm to be performed when an Abstract Closure is called, each captured value is referred to by the alias that was used to capture the value.
If an Abstract Closure returns a
Completion Record
, that
Completion Record
must be either a
normal completion
or a
throw completion
.
Abstract Closures are created inline as part of other algorithms, shown in the following example.
Let
addend
be 41.
Let
closure
be a new
Abstract Closure
with parameters (
x
) that captures
addend
and performs the following steps when called:
Return
x
+
addend
.
Let
val
be
closure
(1).
Assert
:
val
is 42.
6.2.9
Data Blocks
The
Data Block
specification type is used to describe a distinct and mutable sequence of byte-sized (8 bit) numeric values. A
byte value
is an
integer
in the
inclusive interval
from 0 to 255. A Data Block value is created with a fixed number of bytes that each have the initial value 0.
For notational convenience within this specification, an array-like syntax can be used to access the individual bytes of a Data Block value. This notation presents a Data Block value as a 0-based
integer-indexed
sequence of bytes. For example, if
db
is a 5 byte Data Block value then
db
[2] can be used to access its 3
rd
byte.
A data block that resides in memory that can be referenced from multiple
agents
concurrently is designated a
Shared Data Block
. A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is
address-free
: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents. Two data blocks are equal only if the sets of the locations they contain are equal; otherwise, they are not equal and the intersection of the sets of locations they contain is empty. Finally, Shared Data Blocks can be distinguished from Data Blocks.
The semantics of Shared Data Blocks is defined using
Shared Data Block events
by the
memory model
.
Abstract operations
below introduce
Shared Data Block events
and act as the interface between evaluation semantics and the event semantics of the
memory model
. The events form a
candidate execution
, on which the
memory model
acts as a filter. Please consult the
memory model
for full semantics.
Shared Data Block events
are modelled by
Records
, defined in the
memory model
.
The following
abstract operations
are used in this specification to operate upon Data Block values:
6.2.9.1
CreateByteDataBlock (
size
)
The abstract operation CreateByteDataBlock takes argument
size
(a non-negative
integer
) and returns either a
normal completion containing
a
Data Block
or a
throw completion
. It performs the following steps when called:
If
size
> 2
53
- 1, throw a
RangeError
exception.
Let
db
be a new
Data Block
value consisting of
size
bytes. If it is impossible to create such a
Data Block
, throw a
RangeError
exception.
Set all of the bytes of
db
to 0.
Return
db
.
6.2.9.2
CreateSharedByteDataBlock (
size
)
The abstract operation CreateSharedByteDataBlock takes argument
size
(a non-negative
integer
) and returns either a
normal completion containing
a
Shared Data Block
or a
throw completion
. It performs the following steps when called:
Let
db
be a new
Shared Data Block
value consisting of
size
bytes. If it is impossible to create such a
Shared Data Block
, throw a
RangeError
exception.
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
Let
zero
be « 0 ».
For each index
i
of
db
, do
Append
WriteSharedMemory
{
[[Order]]
:
init
,
[[NoTear]]
:
true
,
[[Block]]
:
db
,
[[ByteIndex]]
:
i
,
[[ElementSize]]
: 1,
[[Payload]]
:
zero
} to
eventsRecord
.
[[EventList]]
.
Return
db
.
6.2.9.3
CopyDataBlockBytes (
toBlock
,
toIndex
,
fromBlock
,
fromIndex
,
count
)
The abstract operation CopyDataBlockBytes takes arguments
toBlock
(a
Data Block
or a
Shared Data Block
),
toIndex
(a non-negative
integer
),
fromBlock
(a
Data Block
or a
Shared Data Block
),
fromIndex
(a non-negative
integer
), and
count
(a non-negative
integer
) and returns
unused
. It performs the following steps when called:
Assert
:
fromBlock
and
toBlock
are distinct values.
Let
fromSize
be the number of bytes in
fromBlock
.
Assert
:
fromIndex
+
count
≤
fromSize
.
Let
toSize
be the number of bytes in
toBlock
.
Assert
:
toIndex
+
count
≤
toSize
.
Repeat, while
count
> 0,
If
fromBlock
is a
Shared Data Block
, then
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
Let
bytes
be a
List
whose sole element is a nondeterministically chosen
byte value
.
NOTE: In implementations,
bytes
is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the
memory model
to describe observable behaviour of hardware with weak consistency.
Let
readEvent
be
ReadSharedMemory
{
[[Order]]
:
unordered
,
[[NoTear]]
:
true
,
[[Block]]
:
fromBlock
,
[[ByteIndex]]
:
fromIndex
,
[[ElementSize]]
: 1 }.
Append
readEvent
to
eventsRecord
.
[[EventList]]
.
Append
Chosen Value Record
{
[[Event]]
:
readEvent
,
[[ChosenValue]]
:
bytes
} to
execution
.
[[ChosenValues]]
.
If
toBlock
is a
Shared Data Block
, then
Append
WriteSharedMemory
{
[[Order]]
:
unordered
,
[[NoTear]]
:
true
,
[[Block]]
:
toBlock
,
[[ByteIndex]]
:
toIndex
,
[[ElementSize]]
: 1,
[[Payload]]
:
bytes
} to
eventsRecord
.
[[EventList]]
.
Else,
Set
toBlock
[
toIndex
] to
bytes
[0].
Else,
Assert
:
toBlock
is not a
Shared Data Block
.
Set
toBlock
[
toIndex
] to
fromBlock
[
fromIndex
].
Set
toIndex
to
toIndex
+ 1.
Set
fromIndex
to
fromIndex
+ 1.
Set
count
to
count
- 1.
Return
unused
.
6.2.10
The PrivateElement Specification Type
The PrivateElement type is a
Record
used in the specification of private class fields, methods, and accessors. Although
Property Descriptors
are not used for private elements, private fields behave similarly to non-configurable, non-enumerable, writable
data properties
, private methods behave similarly to non-configurable, non-enumerable, non-writable
data properties
, and private accessors behave similarly to non-configurable, non-enumerable
accessor properties
.
Values of the PrivateElement type are
Record
values whose fields are defined by
Table 9
. Such values are referred to as
PrivateElements
.
Table 9:
PrivateElement
Fields
Field Name
Values of the
[[Kind]]
field for which it is present
Value
Meaning
[[Key]]
All
a
Private Name
The name of the field, method, or accessor.
[[Kind]]
All
field
,
method
, or
accessor
The kind of the element.
[[Value]]
field
and
method
an
ECMAScript language value
The value of the field.
[[Get]]
accessor
a
function object
or
undefined
The getter for a private accessor.
[[Set]]
accessor
a
function object
or
undefined
The setter for a private accessor.
6.2.11
The ClassFieldDefinition Record Specification Type
The ClassFieldDefinition type is a
Record
used in the specification of class fields.
Values of the ClassFieldDefinition type are
Record
values whose fields are defined by
Table 10
. Such values are referred to as
ClassFieldDefinition Records
.
Table 10:
ClassFieldDefinition Record
Fields
Field Name
Value
Meaning
[[Name]]
a
Private Name
, a String, or a Symbol
The name of the field.
[[Initializer]]
an ECMAScript
function object
or
empty
The initializer of the field, if any.
6.2.12
Private Names
The
Private Name
specification type is used to describe a globally unique value (one which differs from any other Private Name, even if they are otherwise indistinguishable) which represents the key of a private class element (field, method, or accessor). Each Private Name has an immutable
[[Description]]
internal slot which
is a String
. A Private Name may be installed on any ECMAScript object with
PrivateFieldAdd
or
PrivateMethodOrAccessorAdd
, and then read or written using
PrivateGet
and
PrivateSet
.
6.2.13
The ClassStaticBlockDefinition Record Specification Type
A
ClassStaticBlockDefinition Record
is a
Record
value used to encapsulate the executable code for a class static initialization block.
ClassStaticBlockDefinition Records have the fields listed in
Table 11
.
Table 11:
ClassStaticBlockDefinition Record
Fields
Field Name
Value
Meaning
[[BodyFunction]]
an ECMAScript
function object
The
function object
to be called during static initialization of a class.
7
Abstract Operations
These operations are not a part of the ECMAScript language; they are defined here solely to aid the specification of the semantics of the ECMAScript language. Other, more specialized
abstract operations
are defined throughout this specification.
7.1
Type Conversion
The ECMAScript language implicitly performs automatic type conversion as needed. To clarify the semantics of certain constructs it is useful to define a set of conversion
abstract operations
. The conversion
abstract operations
are polymorphic; they can accept a value of any
ECMAScript language type
. But no other specification types are used with these operations.
The
BigInt type
has no implicit conversions in the ECMAScript language; programmers must call BigInt explicitly to convert values from other types.
7.1.1
ToPrimitive (
input
[ ,
preferredType
] )
The abstract operation ToPrimitive takes argument
input
(an
ECMAScript language value
) and optional argument
preferredType
(
string
or
number
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It converts its
input
argument to a non-
Object type
. If an object is capable of converting to more than one primitive type, it may use the optional hint
preferredType
to favour that type. It performs the following steps when called:
If
input
is an Object
, then
Let
exoticToPrim
be ?
GetMethod
(
input
,
%Symbol.toPrimitive%
).
If
exoticToPrim
is not
undefined
, then
If
preferredType
is not present, then
Let
hint
be
"default"
.
Else if
preferredType
is
string
, then
Let
hint
be
"string"
.
Else,
Assert
:
preferredType
is
number
.
Let
hint
be
"number"
.
Let
result
be ?
Call
(
exoticToPrim
,
input
, «
hint
»).
If
result
is not an Object
, return
result
.
Throw a
TypeError
exception.
If
preferredType
is not present, let
preferredType
be
number
.
Return ?
OrdinaryToPrimitive
(
input
,
preferredType
).
Return
input
.
Note
When ToPrimitive is called without a hint, then it generally behaves as if the hint were
number
. However, objects may over-ride this behaviour by defining a
%Symbol.toPrimitive%
method. Of the objects defined in this specification only Dates (see
21.4.4.45
) and Symbol objects (see
20.4.3.5
) over-ride the default ToPrimitive behaviour. Dates treat the absence of a hint as if the hint were
string
.
7.1.1.1
OrdinaryToPrimitive (
O
,
hint
)
The abstract operation OrdinaryToPrimitive takes arguments
O
(an Object) and
hint
(
string
or
number
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
If
hint
is
string
, then
Let
methodNames
be «
"toString"
,
"valueOf"
».
Else,
Let
methodNames
be «
"valueOf"
,
"toString"
».
For each element
name
of
methodNames
, do
Let
method
be ?
Get
(
O
,
name
).
If
IsCallable
(
method
) is
true
, then
Let
result
be ?
Call
(
method
,
O
).
If
result
is not an Object
, return
result
.
Throw a
TypeError
exception.
7.1.2
ToBoolean (
argument
)
The abstract operation ToBoolean takes argument
argument
(an
ECMAScript language value
) and returns a Boolean. It converts
argument
to a value of type Boolean. It performs the following steps when called:
If
argument
is a Boolean
, return
argument
.
If
argument
is one of
undefined
,
null
,
+0
𝔽
,
-0
𝔽
,
NaN
,
0
ℤ
, or the empty String, return
false
.
Normative Optional
If the
host
is a web browser or otherwise supports
The
[[IsHTMLDDA]]
Internal Slot
, then
If
argument
is an Object
and
argument
has an
[[IsHTMLDDA]]
internal slot, return
false
.
Return
true
.
7.1.3
ToNumeric (
value
)
The abstract operation ToNumeric takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
either a Number or a BigInt, or a
throw completion
. It returns
value
converted to a Number or a BigInt. It performs the following steps when called:
Let
primValue
be ?
ToPrimitive
(
value
,
number
).
If
primValue
is a BigInt
, return
primValue
.
Return ?
ToNumber
(
primValue
).
7.1.4
ToNumber (
argument
)
The abstract operation ToNumber takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a Number or a
throw completion
. It converts
argument
to a value of type Number. It performs the following steps when called:
If
argument
is a Number
, return
argument
.
If
argument
is either a Symbol or a BigInt, throw a
TypeError
exception.
If
argument
is
undefined
, return
NaN
.
If
argument
is either
null
or
false
, return
+0
𝔽
.
If
argument
is
true
, return
1
𝔽
.
If
argument
is a String
, return
StringToNumber
(
argument
).
Assert
:
argument
is an Object
.
Let
primValue
be ?
ToPrimitive
(
argument
,
number
).
Assert
:
primValue
is not an Object
.
Return ?
ToNumber
(
primValue
).
7.1.4.1
ToNumber Applied to the String Type
The abstract operation
StringToNumber
specifies how to convert a String value to a Number value, using the following grammar.
Syntax
StringNumericLiteral
:::
StrWhiteSpace
opt
StrWhiteSpace
opt
StrNumericLiteral
StrWhiteSpace
opt
StrWhiteSpace
:::
StrWhiteSpaceChar
StrWhiteSpace
opt
StrWhiteSpaceChar
:::
WhiteSpace
LineTerminator
StrNumericLiteral
:::
StrDecimalLiteral
NonDecimalIntegerLiteral
[~Sep]
StrDecimalLiteral
:::
StrUnsignedDecimalLiteral
+
StrUnsignedDecimalLiteral
-
StrUnsignedDecimalLiteral
StrUnsignedDecimalLiteral
:::
Infinity
DecimalDigits
[~Sep]
.
DecimalDigits
[~Sep]
opt
ExponentPart
[~Sep]
opt
.
DecimalDigits
[~Sep]
ExponentPart
[~Sep]
opt
DecimalDigits
[~Sep]
ExponentPart
[~Sep]
opt
All grammar symbols not explicitly defined above have the definitions used in the Lexical Grammar for numeric literals (
12.9.3
)
Note
Some differences should be noted between the syntax of a
StringNumericLiteral
and a
NumericLiteral
:
A
StringNumericLiteral
may include leading and/or trailing white space and/or line terminators.
A
StringNumericLiteral
that is decimal may have any number of leading
0
digits.
A
StringNumericLiteral
that is decimal may include a
+
or
-
to indicate its sign.
A
StringNumericLiteral
that is empty or contains only white space is converted to
+0
𝔽
.
Infinity
and
-Infinity
are recognized as a
StringNumericLiteral
but not as a
NumericLiteral
.
A
StringNumericLiteral
cannot include a
BigIntLiteralSuffix
.
A
StringNumericLiteral
cannot include a
NumericLiteralSeparator
.
7.1.4.1.1
StringToNumber (
str
)
The abstract operation StringToNumber takes argument
str
(a String) and returns a Number. It performs the following steps when called:
Let
literal
be
ParseText
(
str
,
StringNumericLiteral
).
If
literal
is a
List
of errors, return
NaN
.
Return the
StringNumericValue
of
literal
.
7.1.4.1.2
Runtime Semantics: StringNumericValue
The
syntax-directed operation
StringNumericValue takes no arguments and returns a Number.
Note
The conversion of a
StringNumericLiteral
to a Number value is similar overall to the determination of the
NumericValue
of a
NumericLiteral
(see
12.9.3
), but some of the details are different.
It is defined piecewise over the following productions:
StringNumericLiteral
:::
StrWhiteSpace
opt
Return
+0
𝔽
.
StringNumericLiteral
:::
StrWhiteSpace
opt
StrNumericLiteral
StrWhiteSpace
opt
Return the
StringNumericValue
of
StrNumericLiteral
.
StrNumericLiteral
:::
NonDecimalIntegerLiteral
Return
𝔽
(MV of
NonDecimalIntegerLiteral
).
StrDecimalLiteral
:::
-
StrUnsignedDecimalLiteral
Let
a
be the
StringNumericValue
of
StrUnsignedDecimalLiteral
.
If
a
is
+0
𝔽
, return
-0
𝔽
.
Return -
a
.
StrUnsignedDecimalLiteral
:::
Infinity
Return
+∞
𝔽
.
StrUnsignedDecimalLiteral
:::
DecimalDigits
.
DecimalDigits
opt
ExponentPart
opt
Let
a
be the MV of the first
DecimalDigits
.
If the second
DecimalDigits
is present, then
Let
b
be the MV of the second
DecimalDigits
.
Let
n
be the number of code points in the second
DecimalDigits
.
Else,
Let
b
be 0.
Let
n
be 0.
If
ExponentPart
is present, let
e
be the MV of
ExponentPart
; otherwise let
e
be 0.
Return
RoundMVResult
((
a
+ (
b
× 10
-
n
)) × 10
e
).
StrUnsignedDecimalLiteral
:::
.
DecimalDigits
ExponentPart
opt
Let
b
be the MV of
DecimalDigits
.
If
ExponentPart
is present, let
e
be the MV of
ExponentPart
; otherwise let
e
be 0.
Let
n
be the number of code points in
DecimalDigits
.
Return
RoundMVResult
(
b
× 10
e
-
n
).
StrUnsignedDecimalLiteral
:::
DecimalDigits
ExponentPart
opt
Let
a
be the MV of
DecimalDigits
.
If
ExponentPart
is present, let
e
be the MV of
ExponentPart
; otherwise let
e
be 0.
Return
RoundMVResult
(
a
× 10
e
).
7.1.4.1.3
RoundMVResult (
n
)
The abstract operation RoundMVResult takes argument
n
(a
mathematical value
) and returns a Number. It converts
n
to a Number in an
implementation-defined
manner. For the purposes of this abstract operation, a digit is significant if it is not zero or there is a non-zero digit to its left and there is a non-zero digit to its right. For the purposes of this abstract operation, "the
mathematical value
denoted by" a representation of a
mathematical value
is the inverse of "the decimal representation of" a
mathematical value
. It performs the following steps when called:
If the decimal representation of
n
has 20 or fewer significant digits, return
𝔽
(
n
).
Let
option1
be the
mathematical value
denoted by the result of replacing each significant digit in the decimal representation of
n
after the 20th with a 0 digit.
Let
option2
be the
mathematical value
denoted by the result of replacing each significant digit in the decimal representation of
n
after the 20th with a 0 digit and then incrementing it at the 20th position (with carrying as necessary).
Let
chosen
be an
implementation-defined
choice of either
option1
or
option2
.
Return
𝔽
(
chosen
).
7.1.5
ToIntegerOrInfinity (
argument
)
The abstract operation ToIntegerOrInfinity takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
either an
integer
, +∞, or -∞, or a
throw completion
. It converts
argument
to an
integer
representing its Number value with fractional part truncated, or to +∞ or -∞ when that Number value is infinite. It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return 0.
If
number
is
+∞
𝔽
, return +∞.
If
number
is
-∞
𝔽
, return -∞.
Return
truncate
(
ℝ
(
number
)).
Note
𝔽
(ToIntegerOrInfinity(
x
)) never returns
-0
𝔽
for any value of
x
. The truncation of the fractional part is performed after converting
x
to a
mathematical value
.
7.1.6
ToInt32 (
argument
)
The abstract operation ToInt32 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integral Number
or a
throw completion
. It converts
argument
to one of 2
32
integral Number
values in the
inclusive interval
from
𝔽
(-2
31
) to
𝔽
(2
31
- 1). It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is not
finite
or
number
is either
+0
𝔽
or
-0
𝔽
, return
+0
𝔽
.
Let
int
be
truncate
(
ℝ
(
number
)).
Let
int32bit
be
int
modulo
2
32
.
If
int32bit
≥ 2
31
, return
𝔽
(
int32bit
- 2
32
); otherwise return
𝔽
(
int32bit
).
Note
Given the above definition of ToInt32:
The ToInt32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.
ToInt32(
ToUint32
(
x
)) is the same value as ToInt32(
x
) for all values of
x
. (It is to preserve this latter property that
+∞
𝔽
and
-∞
𝔽
are mapped to
+0
𝔽
.)
ToInt32 maps
-0
𝔽
to
+0
𝔽
.
7.1.7
ToUint32 (
argument
)
The abstract operation ToUint32 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integral Number
or a
throw completion
. It converts
argument
to one of 2
32
integral Number
values in the
inclusive interval
from
+0
𝔽
to
𝔽
(2
32
- 1). It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is not
finite
or
number
is either
+0
𝔽
or
-0
𝔽
, return
+0
𝔽
.
Let
int
be
truncate
(
ℝ
(
number
)).
Let
int32bit
be
int
modulo
2
32
.
Return
𝔽
(
int32bit
).
Note
Given the above definition of ToUint32:
Step
5
is the only difference between ToUint32 and
ToInt32
.
The ToUint32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.
ToUint32(
ToInt32
(
x
)) is the same value as ToUint32(
x
) for all values of
x
. (It is to preserve this latter property that
+∞
𝔽
and
-∞
𝔽
are mapped to
+0
𝔽
.)
ToUint32 maps
-0
𝔽
to
+0
𝔽
.
7.1.8
ToInt16 (
argument
)
The abstract operation ToInt16 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integral Number
or a
throw completion
. It converts
argument
to one of 2
16
integral Number
values in the
inclusive interval
from
𝔽
(-2
15
) to
𝔽
(2
15
- 1). It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is not
finite
or
number
is either
+0
𝔽
or
-0
𝔽
, return
+0
𝔽
.
Let
int
be
truncate
(
ℝ
(
number
)).
Let
int16bit
be
int
modulo
2
16
.
If
int16bit
≥ 2
15
, return
𝔽
(
int16bit
- 2
16
); otherwise return
𝔽
(
int16bit
).
7.1.9
ToUint16 (
argument
)
The abstract operation ToUint16 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integral Number
or a
throw completion
. It converts
argument
to one of 2
16
integral Number
values in the
inclusive interval
from
+0
𝔽
to
𝔽
(2
16
- 1). It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is not
finite
or
number
is either
+0
𝔽
or
-0
𝔽
, return
+0
𝔽
.
Let
int
be
truncate
(
ℝ
(
number
)).
Let
int16bit
be
int
modulo
2
16
.
Return
𝔽
(
int16bit
).
Note
Given the above definition of ToUint16:
The substitution of 2
16
for 2
32
in step
4
is the only difference between
ToUint32
and ToUint16.
ToUint16 maps
-0
𝔽
to
+0
𝔽
.
7.1.10
ToInt8 (
argument
)
The abstract operation ToInt8 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integral Number
or a
throw completion
. It converts
argument
to one of 2
8
integral Number
values in the
inclusive interval
from
-128
𝔽
to
127
𝔽
. It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is not
finite
or
number
is either
+0
𝔽
or
-0
𝔽
, return
+0
𝔽
.
Let
int
be
truncate
(
ℝ
(
number
)).
Let
int8bit
be
int
modulo
2
8
.
If
int8bit
≥ 2
7
, return
𝔽
(
int8bit
- 2
8
); otherwise return
𝔽
(
int8bit
).
7.1.11
ToUint8 (
argument
)
The abstract operation ToUint8 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integral Number
or a
throw completion
. It converts
argument
to one of 2
8
integral Number
values in the
inclusive interval
from
+0
𝔽
to
255
𝔽
. It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is not
finite
or
number
is either
+0
𝔽
or
-0
𝔽
, return
+0
𝔽
.
Let
int
be
truncate
(
ℝ
(
number
)).
Let
int8bit
be
int
modulo
2
8
.
Return
𝔽
(
int8bit
).
7.1.12
ToUint8Clamp (
argument
)
The abstract operation ToUint8Clamp takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integral Number
or a
throw completion
. It clamps and rounds
argument
to one of 2
8
integral Number
values in the
inclusive interval
from
+0
𝔽
to
255
𝔽
. It performs the following steps when called:
Let
number
be ?
ToNumber
(
argument
).
If
number
is
NaN
, return
+0
𝔽
.
Let
mv
be the
extended mathematical value of
number
.
Let
clamped
be the result of
clamping
mv
between 0 and 255.
Let
f
be
floor
(
clamped
).
If
clamped
<
f
+ 0.5, return
𝔽
(
f
).
If
clamped
>
f
+ 0.5, return
𝔽
(
f
+ 1).
If
f
is even, return
𝔽
(
f
); otherwise return
𝔽
(
f
+ 1).
Note
Unlike most other ECMAScript
integer
conversion operations, ToUint8Clamp rounds rather than truncates non-integral values. It also uses “round half to even” tie-breaking, which differs from the “round half up” tie-breaking of
Math.round
.
7.1.13
ToBigInt (
argument
)
The abstract operation ToBigInt takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a BigInt or a
throw completion
. It converts
argument
to a BigInt value, or throws if an implicit conversion from Number would be required. It performs the following steps when called:
Let
prim
be ?
ToPrimitive
(
argument
,
number
).
Return the value that
prim
corresponds to in
Table 12
.
Table 12: BigInt Conversions
Argument Type
Result
Undefined
Throw a
TypeError
exception.
Null
Throw a
TypeError
exception.
Boolean
Return
1n
if
prim
is
true
and
0n
if
prim
is
false
.
BigInt
Return
prim
.
Number
Throw a
TypeError
exception.
String
Let
n
be
StringToBigInt
(
prim
).
If
n
is
undefined
, throw a
SyntaxError
exception.
Return
n
.
Symbol
Throw a
TypeError
exception.
7.1.14
StringToBigInt (
str
)
The abstract operation StringToBigInt takes argument
str
(a String) and returns a BigInt or
undefined
. It performs the following steps when called:
Let
literal
be
ParseText
(
str
,
StringIntegerLiteral
).
If
literal
is a
List
of errors, return
undefined
.
Let
mv
be the MV of
literal
.
Assert
:
mv
is an
integer
.
Return
ℤ
(
mv
).
7.1.14.1
StringIntegerLiteral Grammar
StringToBigInt
uses the following grammar.
Syntax
StringIntegerLiteral
:::
StrWhiteSpace
opt
StrWhiteSpace
opt
StrIntegerLiteral
StrWhiteSpace
opt
StrIntegerLiteral
:::
SignedInteger
[~Sep]
NonDecimalIntegerLiteral
[~Sep]
7.1.14.2
Runtime Semantics: MV
The MV of
StringIntegerLiteral
:::
StrWhiteSpace
opt
is 0.
The MV of
StringIntegerLiteral
:::
StrWhiteSpace
opt
StrIntegerLiteral
StrWhiteSpace
opt
is the MV of
StrIntegerLiteral
.
7.1.15
ToBigInt64 (
argument
)
The abstract operation ToBigInt64 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a BigInt or a
throw completion
. It converts
argument
to one of 2
64
BigInt values in the
inclusive interval
from
ℤ
(-2
63
) to
ℤ
(2
63
- 1). It performs the following steps when called:
Let
n
be ?
ToBigInt
(
argument
).
Let
int64bit
be
ℝ
(
n
)
modulo
2
64
.
If
int64bit
≥ 2
63
, return
ℤ
(
int64bit
- 2
64
); otherwise return
ℤ
(
int64bit
).
7.1.16
ToBigUint64 (
argument
)
The abstract operation ToBigUint64 takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a BigInt or a
throw completion
. It converts
argument
to one of 2
64
BigInt values in the
inclusive interval
from
0
ℤ
to
ℤ
(2
64
- 1). It performs the following steps when called:
Let
n
be ?
ToBigInt
(
argument
).
Let
int64bit
be
ℝ
(
n
)
modulo
2
64
.
Return
ℤ
(
int64bit
).
7.1.17
ToString (
argument
)
The abstract operation ToString takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a String or a
throw completion
. It converts
argument
to a value of type String. It performs the following steps when called:
If
argument
is a String
, return
argument
.
If
argument
is a Symbol
, throw a
TypeError
exception.
If
argument
is
undefined
, return
"undefined"
.
If
argument
is
null
, return
"null"
.
If
argument
is
true
, return
"true"
.
If
argument
is
false
, return
"false"
.
If
argument
is a Number
, return
Number::toString
(
argument
, 10).
If
argument
is a BigInt
, return
BigInt::toString
(
argument
, 10).
Assert
:
argument
is an Object
.
Let
primValue
be ?
ToPrimitive
(
argument
,
string
).
Assert
:
primValue
is not an Object
.
Return ?
ToString
(
primValue
).
7.1.18
ToObject (
argument
)
The abstract operation ToObject takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
an Object or a
throw completion
. It converts
argument
to a value of type Object. It performs the following steps when called:
If
argument
is either
undefined
or
null
, throw a
TypeError
exception.
If
argument
is a Boolean
, return a new Boolean object whose
[[BooleanData]]
internal slot is set to
argument
. See
20.3
for a description of Boolean objects.
If
argument
is a Number
, return a new Number object whose
[[NumberData]]
internal slot is set to
argument
. See
21.1
for a description of Number objects.
If
argument
is a String
, return a new String object whose
[[StringData]]
internal slot is set to
argument
. See
22.1
for a description of String objects.
If
argument
is a Symbol
, return a new Symbol object whose
[[SymbolData]]
internal slot is set to
argument
. See
20.4
for a description of Symbol objects.
If
argument
is a BigInt
, return a new BigInt object whose
[[BigIntData]]
internal slot is set to
argument
. See
21.2
for a description of BigInt objects.
Assert
:
argument
is an Object
.
Return
argument
.
7.1.19
ToPropertyKey (
argument
)
The abstract operation ToPropertyKey takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a
property key
or a
throw completion
. It converts
argument
to a value that can be used as a
property key
. It performs the following steps when called:
Let
key
be ?
ToPrimitive
(
argument
,
string
).
If
key
is a Symbol
, then
Return
key
.
Return !
ToString
(
key
).
7.1.20
ToLength (
argument
)
The abstract operation ToLength takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a non-negative
integral Number
or a
throw completion
. It clamps and truncates
argument
to a non-negative
integral Number
suitable for use as the length of an
array-like object
. It performs the following steps when called:
Let
len
be ?
ToIntegerOrInfinity
(
argument
).
If
len
≤ 0, return
+0
𝔽
.
Return
𝔽
(
min
(
len
, 2
53
- 1)).
7.1.21
CanonicalNumericIndexString (
argument
)
The abstract operation CanonicalNumericIndexString takes argument
argument
(a String) and returns a Number or
undefined
. If
argument
is either
"-0"
or exactly matches
ToString
(
n
) for some Number value
n
, it returns the respective Number value. Otherwise, it returns
undefined
. It performs the following steps when called:
If
argument
is
"-0"
, return
-0
𝔽
.
Let
n
be !
ToNumber
(
argument
).
If !
ToString
(
n
) is
argument
, return
n
.
Return
undefined
.
A
canonical numeric string
is any String for which the CanonicalNumericIndexString abstract operation does not return
undefined
.
7.1.22
ToIndex (
value
)
The abstract operation ToIndex takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a non-negative
integer
or a
throw completion
. It converts
value
to an
integer
and returns that
integer
if it is non-negative and corresponds with an
integer index
. Otherwise, it throws an exception. It performs the following steps when called:
Let
integer
be ?
ToIntegerOrInfinity
(
value
).
If
integer
is not in the
inclusive interval
from 0 to 2
53
- 1, throw a
RangeError
exception.
Return
integer
.
7.2
Testing and Comparison Operations
7.2.1
RequireObjectCoercible (
argument
)
The abstract operation RequireObjectCoercible takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It throws an error if
argument
is a value that cannot be converted to an Object using
ToObject
. It performs the following steps when called:
If
argument
is either
undefined
or
null
, throw a
TypeError
exception.
Return
unused
.
7.2.2
IsArray (
argument
)
The abstract operation IsArray takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
argument
is not an Object
, return
false
.
If
argument
is an
Array exotic object
, return
true
.
If
argument
is a
Proxy exotic object
, then
Perform ?
ValidateNonRevokedProxy
(
argument
).
Let
proxyTarget
be
argument
.
[[ProxyTarget]]
.
Return ?
IsArray
(
proxyTarget
).
Return
false
.
7.2.3
IsCallable (
argument
)
The abstract operation IsCallable takes argument
argument
(an
ECMAScript language value
) and returns a Boolean. It determines if
argument
is a callable function with a
[[Call]]
internal method. It performs the following steps when called:
If
argument
is not an Object
, return
false
.
If
argument
has a
[[Call]]
internal method, return
true
.
Return
false
.
7.2.4
IsConstructor (
argument
)
The abstract operation IsConstructor takes argument
argument
(an
ECMAScript language value
) and returns a Boolean. It determines if
argument
is a
function object
with a
[[Construct]]
internal method. It performs the following steps when called:
If
argument
is not an Object
, return
false
.
If
argument
has a
[[Construct]]
internal method, return
true
.
Return
false
.
7.2.5
IsExtensible (
O
)
The abstract operation IsExtensible takes argument
O
(an Object) and returns either a
normal completion containing
a Boolean or a
throw completion
. It is used to determine whether additional properties can be added to
O
. It performs the following steps when called:
Return ?
O
.
[[IsExtensible]]
()
.
7.2.6
IsRegExp (
argument
)
The abstract operation IsRegExp takes argument
argument
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
argument
is not an Object
, return
false
.
Let
matcher
be ?
Get
(
argument
,
%Symbol.match%
).
If
matcher
is not
undefined
, return
ToBoolean
(
matcher
).
If
argument
has a
[[RegExpMatcher]]
internal slot, return
true
.
Return
false
.
7.2.7
Static Semantics: IsStringWellFormedUnicode (
string
)
The abstract operation IsStringWellFormedUnicode takes argument
string
(a String) and returns a Boolean. It interprets
string
as a sequence of UTF-16 encoded code points, as described in
6.1.4
, and determines whether it is a
well formed
UTF-16 sequence. It performs the following steps when called:
Let
len
be the length of
string
.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
cp
be
CodePointAt
(
string
,
k
).
If
cp
.
[[IsUnpairedSurrogate]]
is
true
, return
false
.
Set
k
to
k
+
cp
.
[[CodeUnitCount]]
.
Return
true
.
7.2.8
SameType (
x
,
y
)
The abstract operation SameType takes arguments
x
(an
ECMAScript language value
) and
y
(an
ECMAScript language value
) and returns a Boolean. It determines whether or not the two arguments are the same type. It performs the following steps when called:
If
x
is
undefined
and
y
is
undefined
, return
true
.
If
x
is
null
and
y
is
null
, return
true
.
If
x
is a Boolean
and
y
is a Boolean
, return
true
.
If
x
is a Number
and
y
is a Number
, return
true
.
If
x
is a BigInt
and
y
is a BigInt
, return
true
.
If
x
is a Symbol
and
y
is a Symbol
, return
true
.
If
x
is a String
and
y
is a String
, return
true
.
If
x
is an Object
and
y
is an Object
, return
true
.
Return
false
.
7.2.9
SameValue (
x
,
y
)
The abstract operation SameValue takes arguments
x
(an
ECMAScript language value
) and
y
(an
ECMAScript language value
) and returns a Boolean. It determines whether or not the two arguments are the same value. It performs the following steps when called:
If
SameType
(
x
,
y
) is
false
, return
false
.
If
x
is a Number
, then
Return
Number::sameValue
(
x
,
y
).
Return
SameValueNonNumber
(
x
,
y
).
Note
This algorithm differs from the
IsStrictlyEqual
Algorithm by treating all
NaN
values as equivalent and by differentiating
+0
𝔽
from
-0
𝔽
.
7.2.10
SameValueZero (
x
,
y
)
The abstract operation SameValueZero takes arguments
x
(an
ECMAScript language value
) and
y
(an
ECMAScript language value
) and returns a Boolean. It determines whether or not the two arguments are the same value (ignoring the difference between
+0
𝔽
and
-0
𝔽
). It performs the following steps when called:
If
SameType
(
x
,
y
) is
false
, return
false
.
If
x
is a Number
, then
Return
Number::sameValueZero
(
x
,
y
).
Return
SameValueNonNumber
(
x
,
y
).
Note
SameValueZero differs from
SameValue
only in that it treats
+0
𝔽
and
-0
𝔽
as equivalent.
7.2.11
SameValueNonNumber (
x
,
y
)
The abstract operation SameValueNonNumber takes arguments
x
(an
ECMAScript language value
, but not a Number) and
y
(an
ECMAScript language value
, but not a Number) and returns a Boolean. It performs the following steps when called:
Assert
:
SameType
(
x
,
y
) is
true
.
If
x
is either
undefined
or
null
, return
true
.
If
x
is a BigInt
, then
Return
BigInt::equal
(
x
,
y
).
If
x
is a String
, then
If
x
and
y
have the same length and the same code units in the same positions, return
true
; otherwise return
false
.
If
x
is a Boolean
, then
If
x
and
y
are both
true
or both
false
, return
true
; otherwise return
false
.
NOTE: All other
ECMAScript language values
are compared by identity.
If
x
is
y
, return
true
; otherwise return
false
.
Note 1
For expository purposes, some cases are handled separately within this algorithm even if it is unnecessary to do so.
Note 2
The specifics of what "
x
is
y
" means are detailed in
5.2.8
.
7.2.12
IsLessThan (
x
,
y
,
LeftFirst
)
The abstract operation IsLessThan takes arguments
x
(an
ECMAScript language value
),
y
(an
ECMAScript language value
), and
LeftFirst
(a Boolean) and returns either a
normal completion containing
either a Boolean or
undefined
, or a
throw completion
. It provides the semantics for the comparison
x
<
y
, returning
true
,
false
, or
undefined
(which indicates that at least one operand is
NaN
). The
LeftFirst
flag is used to control the order in which operations with potentially visible side-effects are performed upon
x
and
y
. It is necessary because ECMAScript specifies left to right evaluation of expressions. If
LeftFirst
is
true
, the
x
parameter corresponds to an expression that occurs to the left of the
y
parameter's corresponding expression. If
LeftFirst
is
false
, the reverse is the case and operations must be performed upon
y
before
x
. It performs the following steps when called:
If
LeftFirst
is
true
, then
Let
px
be ?
ToPrimitive
(
x
,
number
).
Let
py
be ?
ToPrimitive
(
y
,
number
).
Else,
NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.
Let
py
be ?
ToPrimitive
(
y
,
number
).
Let
px
be ?
ToPrimitive
(
x
,
number
).
If
px
is a String
and
py
is a String
, then
Let
lx
be the length of
px
.
Let
ly
be the length of
py
.
For each
integer
i
such that 0 ≤
i
<
min
(
lx
,
ly
), in ascending order, do
Let
cx
be the numeric value of the code unit at index
i
within
px
.
Let
cy
be the numeric value of the code unit at index
i
within
py
.
If
cx
<
cy
, return
true
.
If
cx
>
cy
, return
false
.
If
lx
<
ly
, return
true
; otherwise return
false
.
Else,
If
px
is a BigInt
and
py
is a String
, then
Let
ny
be
StringToBigInt
(
py
).
If
ny
is
undefined
, return
undefined
.
Return
BigInt::lessThan
(
px
,
ny
).
If
px
is a String
and
py
is a BigInt
, then
Let
nx
be
StringToBigInt
(
px
).
If
nx
is
undefined
, return
undefined
.
Return
BigInt::lessThan
(
nx
,
py
).
NOTE: Because
px
and
py
are primitive values, evaluation order is not important.
Let
nx
be ?
ToNumeric
(
px
).
Let
ny
be ?
ToNumeric
(
py
).
If
SameType
(
nx
,
ny
) is
true
, then
If
nx
is a Number
, then
Return
Number::lessThan
(
nx
,
ny
).
Else,
Assert
:
nx
is a BigInt
.
Return
BigInt::lessThan
(
nx
,
ny
).
Assert
:
nx
is a BigInt
and
ny
is a Number
, or
nx
is a Number
and
ny
is a BigInt
.
If
nx
or
ny
is
NaN
, return
undefined
.
If
nx
is
-∞
𝔽
or
ny
is
+∞
𝔽
, return
true
.
If
nx
is
+∞
𝔽
or
ny
is
-∞
𝔽
, return
false
.
If
ℝ
(
nx
) <
ℝ
(
ny
), return
true
; otherwise return
false
.
Note 1
Step
3
differs from step
1.c
in the algorithm that handles the addition operator
+
(
13.15.3
) by using the logical-and operation instead of the logical-or operation.
Note 2
The comparison of Strings uses a simple lexicographic ordering on sequences of UTF-16 code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode Standard but not in the same normalization form could test as unequal. Also note that lexicographic ordering by
code unit
differs from ordering by
code point
for Strings containing
surrogate pairs
.
7.2.13
IsLooselyEqual (
x
,
y
)
The abstract operation IsLooselyEqual takes arguments
x
(an
ECMAScript language value
) and
y
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It provides the semantics for the
==
operator. It performs the following steps when called:
If
SameType
(
x
,
y
) is
true
, then
Return
IsStrictlyEqual
(
x
,
y
).
If
x
is
null
and
y
is
undefined
, return
true
.
If
x
is
undefined
and
y
is
null
, return
true
.
Normative Optional
If the
host
is a web browser or otherwise supports
The
[[IsHTMLDDA]]
Internal Slot
, then
If
x
is an Object
,
x
has an
[[IsHTMLDDA]]
internal slot, and
y
is either
undefined
or
null
, return
true
.
If
x
is either
undefined
or
null
,
y
is an Object
, and
y
has an
[[IsHTMLDDA]]
internal slot, return
true
.
If
x
is a Number
and
y
is a String
, return !
IsLooselyEqual
(
x
, !
ToNumber
(
y
)).
If
x
is a String
and
y
is a Number
, return !
IsLooselyEqual
(!
ToNumber
(
x
),
y
).
If
x
is a BigInt
and
y
is a String
, then
Let
n
be
StringToBigInt
(
y
).
If
n
is
undefined
, return
false
.
Return !
IsLooselyEqual
(
x
,
n
).
If
x
is a String
and
y
is a BigInt
, return !
IsLooselyEqual
(
y
,
x
).
If
x
is a Boolean
, return !
IsLooselyEqual
(!
ToNumber
(
x
),
y
).
If
y
is a Boolean
, return !
IsLooselyEqual
(
x
, !
ToNumber
(
y
)).
If
x
is either a String, a Number, a BigInt, or a Symbol and
y
is an Object
, return !
IsLooselyEqual
(
x
, ?
ToPrimitive
(
y
)).
If
x
is an Object
and
y
is either a String, a Number, a BigInt, or a Symbol, return !
IsLooselyEqual
(?
ToPrimitive
(
x
),
y
).
If
x
is a BigInt
and
y
is a Number
, or if
x
is a Number
and
y
is a BigInt
, then
If
x
is not
finite
or
y
is not
finite
, return
false
.
If
ℝ
(
x
) =
ℝ
(
y
), return
true
; otherwise return
false
.
Return
false
.
7.2.14
IsStrictlyEqual (
x
,
y
)
The abstract operation IsStrictlyEqual takes arguments
x
(an
ECMAScript language value
) and
y
(an
ECMAScript language value
) and returns a Boolean. It provides the semantics for the
===
operator. It performs the following steps when called:
If
SameType
(
x
,
y
) is
false
, return
false
.
If
x
is a Number
, then
Return
Number::equal
(
x
,
y
).
Return
SameValueNonNumber
(
x
,
y
).
Note
This algorithm differs from the
SameValue
Algorithm in its treatment of signed zeroes and NaNs.
7.3
Operations on Objects
7.3.1
MakeBasicObject (
internalSlotsList
)
The abstract operation MakeBasicObject takes argument
internalSlotsList
(a
List
of internal slot names) and returns an Object. It is the source of all ECMAScript objects that are created algorithmically, including both
ordinary objects
and
exotic objects
. It factors out common steps used in creating all objects, and centralizes object creation. It performs the following steps when called:
Set
internalSlotsList
to the
list-concatenation
of
internalSlotsList
and «
[[PrivateElements]]
».
Let
obj
be a newly created object with an internal slot for each name in
internalSlotsList
.
NOTE: As described in
Object Internal Methods and Internal Slots
, the initial value of each such internal slot is
undefined
unless specified otherwise.
Set
obj
.
[[PrivateElements]]
to a new empty
List
.
Set
obj
's essential internal methods to the default
ordinary object
definitions specified in
10.1
.
Assert
: If the caller will not be overriding both
obj
's
[[GetPrototypeOf]]
and
[[SetPrototypeOf]]
essential internal methods, then
internalSlotsList
contains
[[Prototype]]
.
Assert
: If the caller will not be overriding all of
obj
's
[[SetPrototypeOf]]
,
[[IsExtensible]]
, and
[[PreventExtensions]]
essential internal methods, then
internalSlotsList
contains
[[Extensible]]
.
If
internalSlotsList
contains
[[Extensible]]
, set
obj
.
[[Extensible]]
to
true
.
Return
obj
.
Note
Within this specification,
exotic objects
are created in
abstract operations
such as
ArrayCreate
and
BoundFunctionCreate
by first calling MakeBasicObject to obtain a basic, foundational object, and then overriding some or all of that object's internal methods. In order to encapsulate
exotic object
creation, the object's essential internal methods are never modified outside those operations.
7.3.2
Get (
O
,
P
)
The abstract operation Get takes arguments
O
(an Object) and
P
(a
property key
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It is used to retrieve the value of a specific property of an object. It performs the following steps when called:
Return ?
O
.
[[Get]]
(
P
,
O
)
.
7.3.3
GetV (
V
,
P
)
The abstract operation GetV takes arguments
V
(an
ECMAScript language value
) and
P
(a
property key
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It is used to retrieve the value of a specific property of an
ECMAScript language value
. If the value is not an object, the property lookup is performed using a wrapper object appropriate for the type of the value. It performs the following steps when called:
Let
O
be ?
ToObject
(
V
).
Return ?
O
.
[[Get]]
(
P
,
V
)
.
7.3.4
Set (
O
,
P
,
V
,
Throw
)
The abstract operation Set takes arguments
O
(an Object),
P
(a
property key
),
V
(an
ECMAScript language value
), and
Throw
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It is used to set the value of a specific property of an object.
V
is the new value for the property. It performs the following steps when called:
Let
success
be ?
O
.
[[Set]]
(
P
,
V
,
O
)
.
If
success
is
false
and
Throw
is
true
, throw a
TypeError
exception.
Return
unused
.
7.3.5
CreateDataProperty (
O
,
P
,
V
)
The abstract operation CreateDataProperty takes arguments
O
(an Object),
P
(a
property key
), and
V
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It is used to create a new own property of an object. It performs the following steps when called:
Let
newDesc
be the PropertyDescriptor {
[[Value]]
:
V
,
[[Writable]]
:
true
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
true
}.
Return ?
O
.
[[DefineOwnProperty]]
(
P
,
newDesc
)
.
Note
This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator. Normally, the property will not already exist. If it does exist and is not configurable or if
O
is not extensible,
[[DefineOwnProperty]]
will return
false
.
7.3.6
CreateDataPropertyOrThrow (
O
,
P
,
V
)
The abstract operation CreateDataPropertyOrThrow takes arguments
O
(an Object),
P
(a
property key
), and
V
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It is used to create a new own property of an object. It throws a
TypeError
exception if the requested property update cannot be performed. It performs the following steps when called:
Let
success
be ?
CreateDataProperty
(
O
,
P
,
V
).
If
success
is
false
, throw a
TypeError
exception.
Return
unused
.
Note
This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator. Normally, the property will not already exist. If it does exist and is not configurable or if
O
is not extensible,
[[DefineOwnProperty]]
will return
false
causing this operation to throw a
TypeError
exception.
7.3.7
CreateNonEnumerableDataPropertyOrThrow (
O
,
P
,
V
)
The abstract operation CreateNonEnumerableDataPropertyOrThrow takes arguments
O
(an Object),
P
(a
property key
), and
V
(an
ECMAScript language value
) and returns
unused
. It is used to create a new non-enumerable own property of an
ordinary object
. It performs the following steps when called:
Assert
:
O
is an ordinary, extensible object with no non-configurable properties.
Let
newDesc
be the PropertyDescriptor {
[[Value]]
:
V
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
Perform !
DefinePropertyOrThrow
(
O
,
P
,
newDesc
).
Return
unused
.
Note
This abstract operation creates a property whose attributes are set to the same defaults used for properties created by the ECMAScript language assignment operator except it is not enumerable. Normally, the property will not already exist. If it does exist,
DefinePropertyOrThrow
is guaranteed to complete normally.
7.3.8
DefinePropertyOrThrow (
O
,
P
,
desc
)
The abstract operation DefinePropertyOrThrow takes arguments
O
(an Object),
P
(a
property key
), and
desc
(a
Property Descriptor
) and returns either a
normal completion containing
unused
or a
throw completion
. It is used to call the
[[DefineOwnProperty]]
internal method of an object in a manner that will throw a
TypeError
exception if the requested property update cannot be performed. It performs the following steps when called:
Let
success
be ?
O
.
[[DefineOwnProperty]]
(
P
,
desc
)
.
If
success
is
false
, throw a
TypeError
exception.
Return
unused
.
7.3.9
DeletePropertyOrThrow (
O
,
P
)
The abstract operation DeletePropertyOrThrow takes arguments
O
(an Object) and
P
(a
property key
) and returns either a
normal completion containing
unused
or a
throw completion
. It is used to remove a specific own property of an object. It throws an exception if the property is not configurable. It performs the following steps when called:
Let
success
be ?
O
.
[[Delete]]
(
P
)
.
If
success
is
false
, throw a
TypeError
exception.
Return
unused
.
7.3.10
GetMethod (
V
,
P
)
The abstract operation GetMethod takes arguments
V
(an
ECMAScript language value
) and
P
(a
property key
) and returns either a
normal completion containing
either a
function object
or
undefined
, or a
throw completion
. It is used to get the value of a specific property of an
ECMAScript language value
when the value of the property is expected to be a function. It performs the following steps when called:
Let
func
be ?
GetV
(
V
,
P
).
If
func
is either
undefined
or
null
, return
undefined
.
If
IsCallable
(
func
) is
false
, throw a
TypeError
exception.
Return
func
.
7.3.11
HasProperty (
O
,
P
)
The abstract operation HasProperty takes arguments
O
(an Object) and
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It is used to determine whether an object has a property with the specified
property key
. The property may be either own or inherited. It performs the following steps when called:
Return ?
O
.
[[HasProperty]]
(
P
)
.
7.3.12
HasOwnProperty (
O
,
P
)
The abstract operation HasOwnProperty takes arguments
O
(an Object) and
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It is used to determine whether an object has an own property with the specified
property key
. It performs the following steps when called:
Let
desc
be ?
O
.
[[GetOwnProperty]]
(
P
)
.
If
desc
is
undefined
, return
false
.
Return
true
.
7.3.13
Call (
F
,
V
[ ,
argumentsList
] )
The abstract operation Call takes arguments
F
(an
ECMAScript language value
) and
V
(an
ECMAScript language value
) and optional argument
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It is used to call the
[[Call]]
internal method of a
function object
.
F
is the
function object
,
V
is an
ECMAScript language value
that is the
this
value of the
[[Call]]
, and
argumentsList
is the value passed to the corresponding argument of the internal method. If
argumentsList
is not present, a new empty
List
is used as its value. It performs the following steps when called:
If
argumentsList
is not present, set
argumentsList
to a new empty
List
.
If
IsCallable
(
F
) is
false
, throw a
TypeError
exception.
Return ?
F
.
[[Call]]
(
V
,
argumentsList
)
.
7.3.14
Construct (
F
[ ,
argumentsList
[ ,
newTarget
] ] )
The abstract operation Construct takes argument
F
(a
constructor
) and optional arguments
argumentsList
(a
List
of
ECMAScript language values
) and
newTarget
(a
constructor
) and returns either a
normal completion containing
an Object or a
throw completion
. It is used to call the
[[Construct]]
internal method of a
function object
.
argumentsList
and
newTarget
are the values to be passed as the corresponding arguments of the internal method. If
argumentsList
is not present, a new empty
List
is used as its value. If
newTarget
is not present,
F
is used as its value. It performs the following steps when called:
If
newTarget
is not present, set
newTarget
to
F
.
If
argumentsList
is not present, set
argumentsList
to a new empty
List
.
Return ?
F
.
[[Construct]]
(
argumentsList
,
newTarget
)
.
Note
If
newTarget
is not present, this operation is equivalent to:
new F(...argumentsList)
7.3.15
SetIntegrityLevel (
O
,
level
)
The abstract operation SetIntegrityLevel takes arguments
O
(an Object) and
level
(
sealed
or
frozen
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It is used to fix the set of own properties of an object. It performs the following steps when called:
Let
status
be ?
O
.
[[PreventExtensions]]
().
If
status
is
false
, return
false
.
Let
keys
be ?
O
.
[[OwnPropertyKeys]]
().
If
level
is
sealed
, then
For each element
k
of
keys
, do
Perform ?
DefinePropertyOrThrow
(
O
,
k
, PropertyDescriptor {
[[Configurable]]
:
false
}).
Else,
Assert
:
level
is
frozen
.
For each element
k
of
keys
, do
Let
currentDesc
be ?
O
.
[[GetOwnProperty]]
(
k
)
.
If
currentDesc
is not
undefined
, then
If
IsAccessorDescriptor
(
currentDesc
) is
true
, then
Let
desc
be the PropertyDescriptor {
[[Configurable]]
:
false
}.
Else,
Let
desc
be the PropertyDescriptor {
[[Configurable]]
:
false
,
[[Writable]]
:
false
}.
Perform ?
DefinePropertyOrThrow
(
O
,
k
,
desc
).
Return
true
.
7.3.16
TestIntegrityLevel (
O
,
level
)
The abstract operation TestIntegrityLevel takes arguments
O
(an Object) and
level
(
sealed
or
frozen
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It is used to determine if the set of own properties of an object are fixed. It performs the following steps when called:
Let
extensible
be ?
IsExtensible
(
O
).
If
extensible
is
true
, return
false
.
NOTE: If the object is extensible, none of its properties are examined.
Let
keys
be ?
O
.
[[OwnPropertyKeys]]
().
For each element
k
of
keys
, do
Let
currentDesc
be ?
O
.
[[GetOwnProperty]]
(
k
)
.
If
currentDesc
is not
undefined
, then
If
currentDesc
.
[[Configurable]]
is
true
, return
false
.
If
level
is
frozen
and
IsDataDescriptor
(
currentDesc
) is
true
, then
If
currentDesc
.
[[Writable]]
is
true
, return
false
.
Return
true
.
7.3.17
CreateArrayFromList (
elements
)
The abstract operation CreateArrayFromList takes argument
elements
(a
List
of
ECMAScript language values
) and returns an Array. It is used to create an Array whose elements are provided by
elements
. It performs the following steps when called:
Let
array
be !
ArrayCreate
(0).
Let
n
be 0.
For each element
e
of
elements
, do
Perform !
CreateDataPropertyOrThrow
(
array
, !
ToString
(
𝔽
(
n
)),
e
).
Set
n
to
n
+ 1.
Return
array
.
7.3.18
LengthOfArrayLike (
obj
)
The abstract operation LengthOfArrayLike takes argument
obj
(an Object) and returns either a
normal completion containing
a non-negative
integer
or a
throw completion
. It returns the value of the
"length"
property of an array-like object. It performs the following steps when called:
Return
ℝ
(?
ToLength
(?
Get
(
obj
,
"length"
))).
An
array-like object
is any object for which this operation returns a
normal completion
.
Note 1
Typically, an array-like object would also have some properties with
integer index
names. However, that is not a requirement of this definition.
Note 2
Arrays and String objects are examples of array-like objects.
7.3.19
CreateListFromArrayLike (
obj
[ ,
validElementTypes
] )
The abstract operation CreateListFromArrayLike takes argument
obj
(an
ECMAScript language value
) and optional argument
validElementTypes
(
all
or
property-key
) and returns either a
normal completion containing
a
List
of
ECMAScript language values
or a
throw completion
. It is used to create a
List
value whose elements are provided by the indexed properties of
obj
.
validElementTypes
indicates the types of values that are allowed as elements. It performs the following steps when called:
If
validElementTypes
is not present, set
validElementTypes
to
all
.
If
obj
is not an Object
, throw a
TypeError
exception.
Let
len
be ?
LengthOfArrayLike
(
obj
).
Let
list
be a new empty
List
.
Let
index
be 0.
Repeat, while
index
<
len
,
Let
indexName
be !
ToString
(
𝔽
(
index
)).
Let
next
be ?
Get
(
obj
,
indexName
).
If
validElementTypes
is
property-key
and
next
is not a
property key
, throw a
TypeError
exception.
Append
next
to
list
.
Set
index
to
index
+ 1.
Return
list
.
7.3.20
Invoke (
V
,
P
[ ,
argumentsList
] )
The abstract operation Invoke takes arguments
V
(an
ECMAScript language value
) and
P
(a
property key
) and optional argument
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It is used to call a method property of an
ECMAScript language value
.
V
serves as both the lookup point for the property and the
this
value of the call.
argumentsList
is the list of arguments values passed to the method. If
argumentsList
is not present, a new empty
List
is used as its value. It performs the following steps when called:
If
argumentsList
is not present, set
argumentsList
to a new empty
List
.
Let
func
be ?
GetV
(
V
,
P
).
Return ?
Call
(
func
,
V
,
argumentsList
).
7.3.21
OrdinaryHasInstance (
C
,
O
)
The abstract operation OrdinaryHasInstance takes arguments
C
(an
ECMAScript language value
) and
O
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It implements the default algorithm for determining if
O
inherits from the instance object inheritance path provided by
C
. It performs the following steps when called:
If
IsCallable
(
C
) is
false
, return
false
.
If
C
has a
[[BoundTargetFunction]]
internal slot, then
Let
BC
be
C
.
[[BoundTargetFunction]]
.
Return ?
InstanceofOperator
(
O
,
BC
).
If
O
is not an Object
, return
false
.
Let
P
be ?
Get
(
C
,
"prototype"
).
If
P
is not an Object
, throw a
TypeError
exception.
Repeat,
Set
O
to ?
O
.
[[GetPrototypeOf]]
()
.
If
O
is
null
, return
false
.
If
SameValue
(
P
,
O
) is
true
, return
true
.
7.3.22
SpeciesConstructor (
O
,
defaultConstructor
)
The abstract operation SpeciesConstructor takes arguments
O
(an Object) and
defaultConstructor
(a
constructor
) and returns either a
normal completion containing
a
constructor
or a
throw completion
. It is used to retrieve the
constructor
that should be used to create new objects that are derived from
O
.
defaultConstructor
is the
constructor
to use if a
constructor
%Symbol.species%
property cannot be found starting from
O
. It performs the following steps when called:
Let
C
be ?
Get
(
O
,
"constructor"
).
If
C
is
undefined
, return
defaultConstructor
.
If
C
is not an Object
, throw a
TypeError
exception.
Let
S
be ?
Get
(
C
,
%Symbol.species%
).
If
S
is either
undefined
or
null
, return
defaultConstructor
.
If
IsConstructor
(
S
) is
true
, return
S
.
Throw a
TypeError
exception.
7.3.23
EnumerableOwnProperties (
O
,
kind
)
The abstract operation EnumerableOwnProperties takes arguments
O
(an Object) and
kind
(
key
,
value
, or
key+value
) and returns either a
normal completion containing
a
List
of
ECMAScript language values
or a
throw completion
. It performs the following steps when called:
Let
ownKeys
be ?
O
.
[[OwnPropertyKeys]]
()
.
Let
results
be a new empty
List
.
For each element
key
of
ownKeys
, do
If
key
is a String
, then
Let
desc
be ?
O
.
[[GetOwnProperty]]
(
key
)
.
If
desc
is not
undefined
and
desc
.
[[Enumerable]]
is
true
, then
If
kind
is
key
, then
Append
key
to
results
.
Else,
Let
value
be ?
Get
(
O
,
key
).
If
kind
is
value
, then
Append
value
to
results
.
Else,
Assert
:
kind
is
key+value
.
Let
entry
be
CreateArrayFromList
(«
key
,
value
»).
Append
entry
to
results
.
Return
results
.
7.3.24
GetFunctionRealm (
obj
)
The abstract operation GetFunctionRealm takes argument
obj
(a
function object
) and returns either a
normal completion containing
a
Realm Record
or a
throw completion
. It performs the following steps when called:
If
obj
has a
[[Realm]]
internal slot, then
Return
obj
.
[[Realm]]
.
If
obj
is a
bound function exotic object
, then
Let
boundTargetFunction
be
obj
.
[[BoundTargetFunction]]
.
Return ?
GetFunctionRealm
(
boundTargetFunction
).
If
obj
is a
Proxy exotic object
, then
Perform ?
ValidateNonRevokedProxy
(
obj
).
Let
proxyTarget
be
obj
.
[[ProxyTarget]]
.
Assert
:
proxyTarget
is a
function object
.
Return ?
GetFunctionRealm
(
proxyTarget
).
Return
the current Realm Record
.
Note
Step
4
will only be reached if
obj
is a non-standard function
exotic object
that does not have a
[[Realm]]
internal slot.
7.3.25
CopyDataProperties (
target
,
source
,
excludedItems
)
The abstract operation CopyDataProperties takes arguments
target
(an Object),
source
(an
ECMAScript language value
), and
excludedItems
(a
List
of
property keys
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
If
source
is either
undefined
or
null
, return
unused
.
Let
from
be !
ToObject
(
source
).
Let
keys
be ?
from
.
[[OwnPropertyKeys]]
()
.
For each element
nextKey
of
keys
, do
Let
excluded
be
false
.
For each element
e
of
excludedItems
, do
If
SameValue
(
e
,
nextKey
) is
true
, then
Set
excluded
to
true
.
If
excluded
is
false
, then
Let
desc
be ?
from
.
[[GetOwnProperty]]
(
nextKey
)
.
If
desc
is not
undefined
and
desc
.
[[Enumerable]]
is
true
, then
Let
propValue
be ?
Get
(
from
,
nextKey
).
Perform !
CreateDataPropertyOrThrow
(
target
,
nextKey
,
propValue
).
Return
unused
.
Note
The target passed in here is always a newly created object which is not directly accessible in case of an error being thrown.
7.3.26
PrivateElementFind (
O
,
P
)
The abstract operation PrivateElementFind takes arguments
O
(an Object) and
P
(a
Private Name
) and returns a
PrivateElement
or
empty
. It performs the following steps when called:
If
O
.
[[PrivateElements]]
contains a
PrivateElement
pe
such that
pe
.
[[Key]]
is
P
, then
Return
pe
.
Return
empty
.
7.3.27
PrivateFieldAdd (
O
,
P
,
value
)
The abstract operation PrivateFieldAdd takes arguments
O
(an Object),
P
(a
Private Name
), and
value
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
If the
host
is a web browser, then
Perform ?
HostEnsureCanAddPrivateElement
(
O
).
Let
entry
be
PrivateElementFind
(
O
,
P
).
If
entry
is not
empty
, throw a
TypeError
exception.
Append
PrivateElement
{
[[Key]]
:
P
,
[[Kind]]
:
field
,
[[Value]]
:
value
} to
O
.
[[PrivateElements]]
.
Return
unused
.
7.3.28
PrivateMethodOrAccessorAdd (
O
,
method
)
The abstract operation PrivateMethodOrAccessorAdd takes arguments
O
(an Object) and
method
(a
PrivateElement
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Assert
:
method
.
[[Kind]]
is either
method
or
accessor
.
If the
host
is a web browser, then
Perform ?
HostEnsureCanAddPrivateElement
(
O
).
Let
entry
be
PrivateElementFind
(
O
,
method
.
[[Key]]
).
If
entry
is not
empty
, throw a
TypeError
exception.
Append
method
to
O
.
[[PrivateElements]]
.
Return
unused
.
Note
The values for private methods and accessors are shared across instances. This operation does not create a new copy of the method or accessor.
7.3.29
HostEnsureCanAddPrivateElement (
O
)
The
host-defined
abstract operation HostEnsureCanAddPrivateElement takes argument
O
(an Object) and returns either a
normal completion containing
unused
or a
throw completion
. It allows
host environments
to prevent the addition of private elements to particular
host-defined
exotic objects
.
An implementation of HostEnsureCanAddPrivateElement must conform to the following requirements:
If
O
is not a
host-defined
exotic object
, this abstract operation must return
NormalCompletion
(
unused
) and perform no other steps.
Any two calls of this abstract operation with the same argument must return the same kind of
Completion Record
.
The default implementation of HostEnsureCanAddPrivateElement is to return
NormalCompletion
(
unused
).
This abstract operation is only invoked by ECMAScript
hosts
that are web browsers.
7.3.30
PrivateGet (
O
,
P
)
The abstract operation PrivateGet takes arguments
O
(an Object) and
P
(a
Private Name
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
entry
be
PrivateElementFind
(
O
,
P
).
If
entry
is
empty
, throw a
TypeError
exception.
If
entry
.
[[Kind]]
is either
field
or
method
, then
Return
entry
.
[[Value]]
.
Assert
:
entry
.
[[Kind]]
is
accessor
.
If
entry
.
[[Get]]
is
undefined
, throw a
TypeError
exception.
Let
getter
be
entry
.
[[Get]]
.
Return ?
Call
(
getter
,
O
).
7.3.31
PrivateSet (
O
,
P
,
value
)
The abstract operation PrivateSet takes arguments
O
(an Object),
P
(a
Private Name
), and
value
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
entry
be
PrivateElementFind
(
O
,
P
).
If
entry
is
empty
, throw a
TypeError
exception.
If
entry
.
[[Kind]]
is
field
, then
Set
entry
.
[[Value]]
to
value
.
Else if
entry
.
[[Kind]]
is
method
, then
Throw a
TypeError
exception.
Else,
Assert
:
entry
.
[[Kind]]
is
accessor
.
If
entry
.
[[Set]]
is
undefined
, throw a
TypeError
exception.
Let
setter
be
entry
.
[[Set]]
.
Perform ?
Call
(
setter
,
O
, «
value
»).
Return
unused
.
7.3.32
DefineField (
receiver
,
fieldRecord
)
The abstract operation DefineField takes arguments
receiver
(an Object) and
fieldRecord
(a
ClassFieldDefinition Record
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
fieldName
be
fieldRecord
.
[[Name]]
.
Let
initializer
be
fieldRecord
.
[[Initializer]]
.
If
initializer
is not
empty
, then
Let
initValue
be ?
Call
(
initializer
,
receiver
).
Else,
Let
initValue
be
undefined
.
If
fieldName
is a
Private Name
, then
Perform ?
PrivateFieldAdd
(
receiver
,
fieldName
,
initValue
).
Else,
Assert
:
fieldName
is a
property key
.
Perform ?
CreateDataPropertyOrThrow
(
receiver
,
fieldName
,
initValue
).
Return
unused
.
7.3.33
InitializeInstanceElements (
O
,
constructor
)
The abstract operation InitializeInstanceElements takes arguments
O
(an Object) and
constructor
(an ECMAScript
function object
or a built-in
function object
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
methods
be
constructor
.
[[PrivateMethods]]
.
For each
PrivateElement
method
of
methods
, do
Perform ?
PrivateMethodOrAccessorAdd
(
O
,
method
).
Let
fields
be
constructor
.
[[Fields]]
.
For each element
fieldRecord
of
fields
, do
Perform ?
DefineField
(
O
,
fieldRecord
).
Return
unused
.
7.3.34
AddValueToKeyedGroup (
groups
,
key
,
value
)
The abstract operation AddValueToKeyedGroup takes arguments
groups
(a
List
of
Records
with fields
[[Key]]
(an
ECMAScript language value
) and
[[Elements]]
(a
List
of
ECMAScript language values
)),
key
(an
ECMAScript language value
), and
value
(an
ECMAScript language value
) and returns
unused
. It performs the following steps when called:
For each
Record
{
[[Key]]
,
[[Elements]]
}
g
of
groups
, do
If
SameValue
(
g
.
[[Key]]
,
key
) is
true
, then
Assert
: Exactly one element of
groups
meets this criterion.
Append
value
to
g
.
[[Elements]]
.
Return
unused
.
Let
group
be the
Record
{
[[Key]]
:
key
,
[[Elements]]
: «
value
» }.
Append
group
to
groups
.
Return
unused
.
7.3.35
GroupBy (
items
,
callback
,
keyCoercion
)
The abstract operation GroupBy takes arguments
items
(an
ECMAScript language value
),
callback
(an
ECMAScript language value
), and
keyCoercion
(
property
or
collection
) and returns either a
normal completion containing
a
List
of
Records
with fields
[[Key]]
(an
ECMAScript language value
) and
[[Elements]]
(a
List
of
ECMAScript language values
), or a
throw completion
. It performs the following steps when called:
Perform ?
RequireObjectCoercible
(
items
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
groups
be a new empty
List
.
Let
iteratorRecord
be ?
GetIterator
(
items
,
sync
).
Let
k
be 0.
Repeat,
If
k
≥ 2
53
- 1, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iteratorRecord
,
error
).
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Return
groups
.
Let
value
be
next
.
Let
key
be
Completion
(
Call
(
callback
,
undefined
, «
value
,
𝔽
(
k
) »)).
IfAbruptCloseIterator
(
key
,
iteratorRecord
).
If
keyCoercion
is
property
, then
Set
key
to
Completion
(
ToPropertyKey
(
key
)).
IfAbruptCloseIterator
(
key
,
iteratorRecord
).
Else,
Assert
:
keyCoercion
is
collection
.
Set
key
to
CanonicalizeKeyedCollectionKey
(
key
).
Perform
AddValueToKeyedGroup
(
groups
,
key
,
value
).
Set
k
to
k
+ 1.
7.3.36
GetOptionsObject (
options
)
The abstract operation GetOptionsObject takes argument
options
(an
ECMAScript language value
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
If
options
is
undefined
, then
Return
OrdinaryObjectCreate
(
null
).
If
options
is an Object
, then
Return
options
.
Throw a
TypeError
exception.
7.3.37
SetterThatIgnoresPrototypeProperties (
thisValue
,
home
,
p
,
v
)
The abstract operation SetterThatIgnoresPrototypeProperties takes arguments
thisValue
(an
ECMAScript language value
),
home
(an Object),
p
(a
property key
), and
v
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
If
thisValue
is not an Object
, then
Throw a
TypeError
exception.
If
SameValue
(
thisValue
,
home
) is
true
, then
NOTE: Throwing here emulates assignment to a non-writable
data property
on the
home
object in
strict mode code
.
Throw a
TypeError
exception.
Let
desc
be ?
thisValue
.
[[GetOwnProperty]]
(
p
).
If
desc
is
undefined
, then
Perform ?
CreateDataPropertyOrThrow
(
thisValue
,
p
,
v
).
Else,
Perform ?
Set
(
thisValue
,
p
,
v
,
true
).
Return
unused
.
7.4
Operations on Iterator Objects
See Common Iteration Interfaces (
27.1
).
7.4.1
Iterator Records
An
Iterator Record
is a
Record
value used to encapsulate an
iterator
or
async iterator
along with the
next
method.
Iterator Records have the fields listed in
Table 13
.
Table 13:
Iterator Record
Fields
Field Name
Value
Meaning
[[Iterator]]
an Object
An object that conforms to the
iterator interface
or the
async iterator interface
.
[[NextMethod]]
an
ECMAScript language value
The
next
method of the
[[Iterator]]
object.
[[Done]]
a Boolean
Whether the
iterator
has completed or been closed.
7.4.2
GetIteratorDirect (
obj
)
The abstract operation GetIteratorDirect takes argument
obj
(an Object) and returns either a
normal completion containing
an
Iterator Record
or a
throw completion
. It performs the following steps when called:
Let
nextMethod
be ?
Get
(
obj
,
"next"
).
Let
iteratorRecord
be the
Iterator Record
{
[[Iterator]]
:
obj
,
[[NextMethod]]
:
nextMethod
,
[[Done]]
:
false
}.
Return
iteratorRecord
.
7.4.3
GetIteratorFromMethod (
obj
,
method
)
The abstract operation GetIteratorFromMethod takes arguments
obj
(an
ECMAScript language value
) and
method
(a
function object
) and returns either a
normal completion containing
an
Iterator Record
or a
throw completion
. It performs the following steps when called:
Let
iterator
be ?
Call
(
method
,
obj
).
If
iterator
is not an Object
, throw a
TypeError
exception.
Return ?
GetIteratorDirect
(
iterator
).
7.4.4
GetIterator (
obj
,
kind
)
The abstract operation GetIterator takes arguments
obj
(an
ECMAScript language value
) and
kind
(
sync
or
async
) and returns either a
normal completion containing
an
Iterator Record
or a
throw completion
. It performs the following steps when called:
If
kind
is
async
, then
Let
method
be ?
GetMethod
(
obj
,
%Symbol.asyncIterator%
).
If
method
is
undefined
, then
Let
syncMethod
be ?
GetMethod
(
obj
,
%Symbol.iterator%
).
If
syncMethod
is
undefined
, throw a
TypeError
exception.
Let
syncIteratorRecord
be ?
GetIteratorFromMethod
(
obj
,
syncMethod
).
Return
CreateAsyncFromSyncIterator
(
syncIteratorRecord
).
Else,
Let
method
be ?
GetMethod
(
obj
,
%Symbol.iterator%
).
If
method
is
undefined
, throw a
TypeError
exception.
Return ?
GetIteratorFromMethod
(
obj
,
method
).
7.4.5
GetIteratorFlattenable (
obj
,
primitiveHandling
)
The abstract operation GetIteratorFlattenable takes arguments
obj
(an
ECMAScript language value
) and
primitiveHandling
(
iterate-string-primitives
or
reject-primitives
) and returns either a
normal completion containing
an
Iterator Record
or a
throw completion
. It performs the following steps when called:
If
obj
is not an Object
, then
If
primitiveHandling
is
reject-primitives
, throw a
TypeError
exception.
Assert
:
primitiveHandling
is
iterate-string-primitives
.
If
obj
is not a String
, throw a
TypeError
exception.
Let
method
be ?
GetMethod
(
obj
,
%Symbol.iterator%
).
If
method
is
undefined
, then
Let
iterator
be
obj
.
Else,
Let
iterator
be ?
Call
(
method
,
obj
).
If
iterator
is not an Object
, throw a
TypeError
exception.
Return ?
GetIteratorDirect
(
iterator
).
7.4.6
IteratorNext (
iteratorRecord
[ ,
value
] )
The abstract operation IteratorNext takes argument
iteratorRecord
(an
Iterator Record
) and optional argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
If
value
is not present, then
Let
result
be
Completion
(
Call
(
iteratorRecord
.
[[NextMethod]]
,
iteratorRecord
.
[[Iterator]]
)).
Else,
Let
result
be
Completion
(
Call
(
iteratorRecord
.
[[NextMethod]]
,
iteratorRecord
.
[[Iterator]]
, «
value
»)).
If
result
is a
throw completion
, then
Set
iteratorRecord
.
[[Done]]
to
true
.
Return ?
result
.
Set
result
to !
result
.
If
result
is not an Object
, then
Set
iteratorRecord
.
[[Done]]
to
true
.
Throw a
TypeError
exception.
Return
result
.
7.4.7
IteratorComplete (
iteratorResult
)
The abstract operation IteratorComplete takes argument
iteratorResult
(an Object) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Return
ToBoolean
(?
Get
(
iteratorResult
,
"done"
)).
7.4.8
IteratorValue (
iteratorResult
)
The abstract operation IteratorValue takes argument
iteratorResult
(an Object) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Return ?
Get
(
iteratorResult
,
"value"
).
7.4.9
IteratorStep (
iteratorRecord
)
The abstract operation IteratorStep takes argument
iteratorRecord
(an
Iterator Record
) and returns either a
normal completion containing
either an Object or
done
, or a
throw completion
. It requests the next value from
iteratorRecord
.
[[Iterator]]
by calling
iteratorRecord
.
[[NextMethod]]
and returns either
done
indicating that the
iterator
has reached its end or the
IteratorResult object
if a next value is available. It performs the following steps when called:
Let
result
be ?
IteratorNext
(
iteratorRecord
).
Let
done
be
Completion
(
IteratorComplete
(
result
)).
If
done
is a
throw completion
, then
Set
iteratorRecord
.
[[Done]]
to
true
.
Return ?
done
.
Set
done
to !
done
.
If
done
is
true
, then
Set
iteratorRecord
.
[[Done]]
to
true
.
Return
done
.
Return
result
.
7.4.10
IteratorStepValue (
iteratorRecord
)
The abstract operation IteratorStepValue takes argument
iteratorRecord
(an
Iterator Record
) and returns either a
normal completion containing
either an
ECMAScript language value
or
done
, or a
throw completion
. It requests the next value from
iteratorRecord
.
[[Iterator]]
by calling
iteratorRecord
.
[[NextMethod]]
and returns either
done
indicating that the
iterator
has reached its end or the value from the
IteratorResult object
if a next value is available. It performs the following steps when called:
Let
result
be ?
IteratorStep
(
iteratorRecord
).
If
result
is
done
, then
Return
done
.
Let
value
be
Completion
(
IteratorValue
(
result
)).
If
value
is a
throw completion
, then
Set
iteratorRecord
.
[[Done]]
to
true
.
Return ?
value
.
7.4.11
IteratorClose (
iteratorRecord
,
completion
)
The abstract operation IteratorClose takes arguments
iteratorRecord
(an
Iterator Record
) and
completion
(a
Completion Record
) and returns a
Completion Record
. It is used to notify an
iterator
that it should perform any actions it would normally perform when it has reached its completed state. It performs the following steps when called:
Assert
:
iteratorRecord
.
[[Iterator]]
is an Object
.
Let
iterator
be
iteratorRecord
.
[[Iterator]]
.
Let
innerResult
be
Completion
(
GetMethod
(
iterator
,
"return"
)).
If
innerResult
is a
normal completion
, then
Let
return
be
innerResult
.
[[Value]]
.
If
return
is
undefined
, return ?
completion
.
Set
innerResult
to
Completion
(
Call
(
return
,
iterator
)).
If
completion
is a
throw completion
, return ?
completion
.
If
innerResult
is a
throw completion
, return ?
innerResult
.
If
innerResult
.
[[Value]]
is not an Object
, throw a
TypeError
exception.
Return ?
completion
.
7.4.12
IteratorCloseAll (
iters
,
completion
)
The abstract operation IteratorCloseAll takes arguments
iters
(a
List
of
Iterator Records
) and
completion
(a
Completion Record
) and returns a
Completion Record
. It performs the following steps when called:
For each element
iter
of
iters
, in reverse
List
order, do
Set
completion
to
Completion
(
IteratorClose
(
iter
,
completion
)).
Return ?
completion
.
7.4.13
IfAbruptCloseIterator (
value
,
iteratorRecord
)
IfAbruptCloseIterator is a shorthand for a sequence of algorithm steps that use an
Iterator Record
. An algorithm step of the form:
IfAbruptCloseIterator
(
value
,
iteratorRecord
).
means the same thing as:
Assert
:
value
is a
Completion Record
.
If
value
is an
abrupt completion
, return ?
IteratorClose
(
iteratorRecord
,
value
).
Else, set
value
to !
value
.
7.4.14
AsyncIteratorClose (
iteratorRecord
,
completion
)
The abstract operation AsyncIteratorClose takes arguments
iteratorRecord
(an
Iterator Record
) and
completion
(a
Completion Record
) and returns a
Completion Record
. It is used to notify an
async iterator
that it should perform any actions it would normally perform when it has reached its completed state. It performs the following steps when called:
Assert
:
iteratorRecord
.
[[Iterator]]
is an Object
.
Let
iterator
be
iteratorRecord
.
[[Iterator]]
.
Let
innerResult
be
Completion
(
GetMethod
(
iterator
,
"return"
)).
If
innerResult
is a
normal completion
, then
Let
return
be
innerResult
.
[[Value]]
.
If
return
is
undefined
, return ?
completion
.
Set
innerResult
to
Completion
(
Call
(
return
,
iterator
)).
If
innerResult
is a
normal completion
, set
innerResult
to
Completion
(
Await
(
innerResult
.
[[Value]]
)).
If
completion
is a
throw completion
, return ?
completion
.
If
innerResult
is a
throw completion
, return ?
innerResult
.
If
innerResult
.
[[Value]]
is not an Object
, throw a
TypeError
exception.
Return ?
completion
.
7.4.15
IfAbruptCloseAsyncIterator (
value
,
iteratorRecord
)
IfAbruptCloseAsyncIterator is a shorthand for a sequence of algorithm steps that use an
Iterator Record
. An algorithm step of the form:
IfAbruptCloseAsyncIterator
(
value
,
iteratorRecord
).
means the same thing as:
Assert
:
value
is a
Completion Record
.
If
value
is an
abrupt completion
, return ?
AsyncIteratorClose
(
iteratorRecord
,
value
).
Else, set
value
to !
value
.
7.4.16
CreateIteratorResultObject (
value
,
done
)
The abstract operation CreateIteratorResultObject takes arguments
value
(an
ECMAScript language value
) and
done
(a Boolean) and returns an Object that conforms to the
IteratorResult interface
. It creates an object that conforms to the
IteratorResult interface
. It performs the following steps when called:
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"value"
,
value
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"done"
,
done
).
Return
obj
.
7.4.17
CreateListIteratorRecord (
list
)
The abstract operation CreateListIteratorRecord takes argument
list
(a
List
of
ECMAScript language values
) and returns an
Iterator Record
. It creates an
Iterator Record
whose
[[NextMethod]]
returns the successive elements of
list
. It performs the following steps when called:
Let
closure
be a new
Abstract Closure
with no parameters that captures
list
and performs the following steps when called:
For each element
E
of
list
, do
Perform ?
GeneratorYield
(
CreateIteratorResultObject
(
E
,
false
)).
Return
NormalCompletion
(
undefined
).
Let
iterator
be
CreateIteratorFromClosure
(
closure
,
empty
,
%Iterator.prototype%
).
Return the
Iterator Record
{
[[Iterator]]
:
iterator
,
[[NextMethod]]
: %GeneratorPrototype.next%,
[[Done]]
:
false
}.
Note
The list
iterator object
is never directly accessible to ECMAScript code.
7.4.18
IteratorToList (
iteratorRecord
)
The abstract operation IteratorToList takes argument
iteratorRecord
(an
Iterator Record
) and returns either a
normal completion containing
a
List
of
ECMAScript language values
or a
throw completion
. It performs the following steps when called:
Let
values
be a new empty
List
.
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Return
values
.
Append
next
to
values
.
8
Syntax-Directed Operations
In addition to those defined in this section, specialized
syntax-directed operations
are defined throughout this specification.
8.1
Runtime Semantics: Evaluation
The
syntax-directed operation
Evaluation takes no arguments and returns a
Completion Record
.
Note
The definitions for this operation are distributed over the "ECMAScript Language" sections of this specification. Each definition appears after the defining occurrence of the relevant productions.
8.2
Scope Analysis
8.2.1
Static Semantics: BoundNames
The
syntax-directed operation
BoundNames takes no arguments and returns a
List
of Strings.
Note
"*default*"
is used within this specification as a synthetic name for a module's default export when it does not have another name. An entry in the module's
[[Environment]]
is created with that name and holds the corresponding value, and resolving the export named
"default"
by calling
ResolveExport (
exportName
[ ,
resolveSet
] )
for the module will return a
ResolvedBinding Record
whose
[[BindingName]]
is
"*default*"
, which will then resolve in the module's
[[Environment]]
to the above-mentioned value. This is done only for ease of specification, so that anonymous default exports can be resolved like any other export. This
"*default*"
string is never accessible to ECMAScript code or to the module linking algorithm.
It is defined piecewise over the following productions:
BindingIdentifier
:
Identifier
Return a
List
whose sole element is the
StringValue
of
Identifier
.
BindingIdentifier
:
yield
Return «
"yield"
».
BindingIdentifier
:
await
Return «
"await"
».
LexicalDeclaration
:
LetOrConst
BindingList
;
Return the
BoundNames
of
BindingList
.
BindingList
:
BindingList
,
LexicalBinding
Let
names1
be the
BoundNames
of
BindingList
.
Let
names2
be the
BoundNames
of
LexicalBinding
.
Return the
list-concatenation
of
names1
and
names2
.
LexicalBinding
:
BindingIdentifier
Initializer
opt
Return the
BoundNames
of
BindingIdentifier
.
LexicalBinding
:
BindingPattern
Initializer
Return the
BoundNames
of
BindingPattern
.
VariableDeclarationList
:
VariableDeclarationList
,
VariableDeclaration
Let
names1
be the
BoundNames
of
VariableDeclarationList
.
Let
names2
be the
BoundNames
of
VariableDeclaration
.
Return the
list-concatenation
of
names1
and
names2
.
VariableDeclaration
:
BindingIdentifier
Initializer
opt
Return the
BoundNames
of
BindingIdentifier
.
VariableDeclaration
:
BindingPattern
Initializer
Return the
BoundNames
of
BindingPattern
.
ObjectBindingPattern
:
{
}
Return a new empty
List
.
ObjectBindingPattern
:
{
BindingPropertyList
,
BindingRestProperty
}
Let
names1
be the
BoundNames
of
BindingPropertyList
.
Let
names2
be the
BoundNames
of
BindingRestProperty
.
Return the
list-concatenation
of
names1
and
names2
.
ArrayBindingPattern
:
[
Elision
opt
]
Return a new empty
List
.
ArrayBindingPattern
:
[
Elision
opt
BindingRestElement
]
Return the
BoundNames
of
BindingRestElement
.
ArrayBindingPattern
:
[
BindingElementList
,
Elision
opt
]
Return the
BoundNames
of
BindingElementList
.
ArrayBindingPattern
:
[
BindingElementList
,
Elision
opt
BindingRestElement
]
Let
names1
be the
BoundNames
of
BindingElementList
.
Let
names2
be the
BoundNames
of
BindingRestElement
.
Return the
list-concatenation
of
names1
and
names2
.
BindingPropertyList
:
BindingPropertyList
,
BindingProperty
Let
names1
be the
BoundNames
of
BindingPropertyList
.
Let
names2
be the
BoundNames
of
BindingProperty
.
Return the
list-concatenation
of
names1
and
names2
.
BindingElementList
:
BindingElementList
,
BindingElisionElement
Let
names1
be the
BoundNames
of
BindingElementList
.
Let
names2
be the
BoundNames
of
BindingElisionElement
.
Return the
list-concatenation
of
names1
and
names2
.
BindingElisionElement
:
Elision
opt
BindingElement
Return the
BoundNames
of
BindingElement
.
BindingProperty
:
PropertyName
:
BindingElement
Return the
BoundNames
of
BindingElement
.
SingleNameBinding
:
BindingIdentifier
Initializer
opt
Return the
BoundNames
of
BindingIdentifier
.
BindingElement
:
BindingPattern
Initializer
opt
Return the
BoundNames
of
BindingPattern
.
ForDeclaration
:
LetOrConst
ForBinding
Return the
BoundNames
of
ForBinding
.
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
Return the
BoundNames
of
BindingIdentifier
.
FunctionDeclaration
:
function
(
FormalParameters
)
{
FunctionBody
}
Return «
"*default*"
».
FormalParameters
:
[empty]
Return a new empty
List
.
FormalParameters
:
FormalParameterList
,
FunctionRestParameter
Let
names1
be the
BoundNames
of
FormalParameterList
.
Let
names2
be the
BoundNames
of
FunctionRestParameter
.
Return the
list-concatenation
of
names1
and
names2
.
FormalParameterList
:
FormalParameterList
,
FormalParameter
Let
names1
be the
BoundNames
of
FormalParameterList
.
Let
names2
be the
BoundNames
of
FormalParameter
.
Return the
list-concatenation
of
names1
and
names2
.
ArrowParameters
:
CoverParenthesizedExpressionAndArrowParameterList
Let
formals
be the
ArrowFormalParameters
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return the
BoundNames
of
formals
.
GeneratorDeclaration
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
Return the
BoundNames
of
BindingIdentifier
.
GeneratorDeclaration
:
function
*
(
FormalParameters
)
{
GeneratorBody
}
Return «
"*default*"
».
AsyncGeneratorDeclaration
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
Return the
BoundNames
of
BindingIdentifier
.
AsyncGeneratorDeclaration
:
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
Return «
"*default*"
».
ClassDeclaration
:
class
BindingIdentifier
ClassTail
Return the
BoundNames
of
BindingIdentifier
.
ClassDeclaration
:
class
ClassTail
Return «
"*default*"
».
AsyncFunctionDeclaration
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
Return the
BoundNames
of
BindingIdentifier
.
AsyncFunctionDeclaration
:
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
Return «
"*default*"
».
CoverCallExpressionAndAsyncArrowHead
:
MemberExpression
Arguments
Let
head
be the
AsyncArrowHead
that is
covered
by
CoverCallExpressionAndAsyncArrowHead
.
Return the
BoundNames
of
head
.
ImportDeclaration
:
import
ImportClause
FromClause
WithClause
opt
;
Return the
BoundNames
of
ImportClause
.
ImportDeclaration
:
import
ModuleSpecifier
WithClause
opt
;
Return a new empty
List
.
ImportClause
:
ImportedDefaultBinding
,
NameSpaceImport
Let
names1
be the
BoundNames
of
ImportedDefaultBinding
.
Let
names2
be the
BoundNames
of
NameSpaceImport
.
Return the
list-concatenation
of
names1
and
names2
.
ImportClause
:
ImportedDefaultBinding
,
NamedImports
Let
names1
be the
BoundNames
of
ImportedDefaultBinding
.
Let
names2
be the
BoundNames
of
NamedImports
.
Return the
list-concatenation
of
names1
and
names2
.
NamedImports
:
{
}
Return a new empty
List
.
ImportsList
:
ImportsList
,
ImportSpecifier
Let
names1
be the
BoundNames
of
ImportsList
.
Let
names2
be the
BoundNames
of
ImportSpecifier
.
Return the
list-concatenation
of
names1
and
names2
.
ImportSpecifier
:
ModuleExportName
as
ImportedBinding
Return the
BoundNames
of
ImportedBinding
.
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
export
NamedExports
;
Return a new empty
List
.
ExportDeclaration
:
export
VariableStatement
Return the
BoundNames
of
VariableStatement
.
ExportDeclaration
:
export
Declaration
Return the
BoundNames
of
Declaration
.
ExportDeclaration
:
export
default
HoistableDeclaration
Let
declarationNames
be the
BoundNames
of
HoistableDeclaration
.
If
declarationNames
does not include the element
"*default*"
, append
"*default*"
to
declarationNames
.
Return
declarationNames
.
ExportDeclaration
:
export
default
ClassDeclaration
Let
declarationNames
be the
BoundNames
of
ClassDeclaration
.
If
declarationNames
does not include the element
"*default*"
, append
"*default*"
to
declarationNames
.
Return
declarationNames
.
ExportDeclaration
:
export
default
AssignmentExpression
;
Return «
"*default*"
».
8.2.2
Static Semantics: DeclarationPart
The
syntax-directed operation
DeclarationPart takes no arguments and returns a
Parse Node
. It is defined piecewise over the following productions:
HoistableDeclaration
:
FunctionDeclaration
Return
FunctionDeclaration
.
HoistableDeclaration
:
GeneratorDeclaration
Return
GeneratorDeclaration
.
HoistableDeclaration
:
AsyncFunctionDeclaration
Return
AsyncFunctionDeclaration
.
HoistableDeclaration
:
AsyncGeneratorDeclaration
Return
AsyncGeneratorDeclaration
.
Declaration
:
ClassDeclaration
Return
ClassDeclaration
.
Declaration
:
LexicalDeclaration
Return
LexicalDeclaration
.
8.2.3
Static Semantics: IsConstantDeclaration
The
syntax-directed operation
IsConstantDeclaration takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
LexicalDeclaration
:
LetOrConst
BindingList
;
Return
IsConstantDeclaration
of
LetOrConst
.
LetOrConst
:
let
Return
false
.
LetOrConst
:
const
Return
true
.
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
function
(
FormalParameters
)
{
FunctionBody
}
GeneratorDeclaration
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
function
*
(
FormalParameters
)
{
GeneratorBody
}
AsyncGeneratorDeclaration
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncFunctionDeclaration
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
Return
false
.
ClassDeclaration
:
class
BindingIdentifier
ClassTail
class
ClassTail
Return
false
.
ExportDeclaration
:
export
ExportFromClause
FromClause
;
export
NamedExports
;
export
default
AssignmentExpression
;
Return
false
.
Note
It is not necessary to treat
export default
AssignmentExpression
as a constant declaration because there is no syntax that permits assignment to the internal bound name used to reference a module's default object.
8.2.4
Static Semantics: LexicallyDeclaredNames
The
syntax-directed operation
LexicallyDeclaredNames takes no arguments and returns a
List
of Strings. It is defined piecewise over the following productions:
Block
:
{
}
Return a new empty
List
.
StatementList
:
StatementList
StatementListItem
Let
names1
be the
LexicallyDeclaredNames
of
StatementList
.
Let
names2
be the
LexicallyDeclaredNames
of
StatementListItem
.
Return the
list-concatenation
of
names1
and
names2
.
StatementListItem
:
Statement
If
Statement
is
Statement
:
LabelledStatement
, return the
LexicallyDeclaredNames
of
LabelledStatement
.
Return a new empty
List
.
StatementListItem
:
Declaration
Return the
BoundNames
of
Declaration
.
CaseBlock
:
{
}
Return a new empty
List
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
If the first
CaseClauses
is present, let
names1
be the
LexicallyDeclaredNames
of the first
CaseClauses
.
Else, let
names1
be a new empty
List
.
Let
names2
be the
LexicallyDeclaredNames
of
DefaultClause
.
If the second
CaseClauses
is present, let
names3
be the
LexicallyDeclaredNames
of the second
CaseClauses
.
Else, let
names3
be a new empty
List
.
Return the
list-concatenation
of
names1
,
names2
, and
names3
.
CaseClauses
:
CaseClauses
CaseClause
Let
names1
be the
LexicallyDeclaredNames
of
CaseClauses
.
Let
names2
be the
LexicallyDeclaredNames
of
CaseClause
.
Return the
list-concatenation
of
names1
and
names2
.
CaseClause
:
case
Expression
:
StatementList
opt
If the
StatementList
is present, return the
LexicallyDeclaredNames
of
StatementList
.
Return a new empty
List
.
DefaultClause
:
default
:
StatementList
opt
If the
StatementList
is present, return the
LexicallyDeclaredNames
of
StatementList
.
Return a new empty
List
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return the
LexicallyDeclaredNames
of
LabelledItem
.
LabelledItem
:
Statement
Return a new empty
List
.
LabelledItem
:
FunctionDeclaration
Return the
BoundNames
of
FunctionDeclaration
.
FunctionStatementList
:
[empty]
Return a new empty
List
.
FunctionStatementList
:
StatementList
Return the
TopLevelLexicallyDeclaredNames
of
StatementList
.
ClassStaticBlockStatementList
:
[empty]
Return a new empty
List
.
ClassStaticBlockStatementList
:
StatementList
Return the
TopLevelLexicallyDeclaredNames
of
StatementList
.
ConciseBody
:
ExpressionBody
Return a new empty
List
.
AsyncConciseBody
:
ExpressionBody
Return a new empty
List
.
Script
:
[empty]
Return a new empty
List
.
ScriptBody
:
StatementList
Return the
TopLevelLexicallyDeclaredNames
of
StatementList
.
Note 1
At the top level of a
Script
, function declarations are treated like var declarations rather than like lexical declarations.
Note 2
The LexicallyDeclaredNames of a
Module
includes the names of all of its imported bindings.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
names1
be the
LexicallyDeclaredNames
of
ModuleItemList
.
Let
names2
be the
LexicallyDeclaredNames
of
ModuleItem
.
Return the
list-concatenation
of
names1
and
names2
.
ModuleItem
:
ImportDeclaration
Return the
BoundNames
of
ImportDeclaration
.
ModuleItem
:
ExportDeclaration
If
ExportDeclaration
is
export
VariableStatement
, return a new empty
List
.
Return the
BoundNames
of
ExportDeclaration
.
ModuleItem
:
StatementListItem
Return the
LexicallyDeclaredNames
of
StatementListItem
.
Note 3
At the top level of a
Module
, function declarations are treated like lexical declarations rather than like var declarations.
8.2.5
Static Semantics: LexicallyScopedDeclarations
The
syntax-directed operation
LexicallyScopedDeclarations takes no arguments and returns a
List
of
Parse Nodes
. It is defined piecewise over the following productions:
StatementList
:
StatementList
StatementListItem
Let
declarations1
be the
LexicallyScopedDeclarations
of
StatementList
.
Let
declarations2
be the
LexicallyScopedDeclarations
of
StatementListItem
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
StatementListItem
:
Statement
If
Statement
is
Statement
:
LabelledStatement
, return the
LexicallyScopedDeclarations
of
LabelledStatement
.
Return a new empty
List
.
StatementListItem
:
Declaration
Return a
List
whose sole element is the
DeclarationPart
of
Declaration
.
CaseBlock
:
{
}
Return a new empty
List
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
If the first
CaseClauses
is present, let
declarations1
be the
LexicallyScopedDeclarations
of the first
CaseClauses
.
Else, let
declarations1
be a new empty
List
.
Let
declarations2
be the
LexicallyScopedDeclarations
of
DefaultClause
.
If the second
CaseClauses
is present, let
declarations3
be the
LexicallyScopedDeclarations
of the second
CaseClauses
.
Else, let
declarations3
be a new empty
List
.
Return the
list-concatenation
of
declarations1
,
declarations2
, and
declarations3
.
CaseClauses
:
CaseClauses
CaseClause
Let
declarations1
be the
LexicallyScopedDeclarations
of
CaseClauses
.
Let
declarations2
be the
LexicallyScopedDeclarations
of
CaseClause
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
CaseClause
:
case
Expression
:
StatementList
opt
If the
StatementList
is present, return the
LexicallyScopedDeclarations
of
StatementList
.
Return a new empty
List
.
DefaultClause
:
default
:
StatementList
opt
If the
StatementList
is present, return the
LexicallyScopedDeclarations
of
StatementList
.
Return a new empty
List
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return the
LexicallyScopedDeclarations
of
LabelledItem
.
LabelledItem
:
Statement
Return a new empty
List
.
LabelledItem
:
FunctionDeclaration
Return «
FunctionDeclaration
».
FunctionStatementList
:
[empty]
Return a new empty
List
.
FunctionStatementList
:
StatementList
Return the
TopLevelLexicallyScopedDeclarations
of
StatementList
.
ClassStaticBlockStatementList
:
[empty]
Return a new empty
List
.
ClassStaticBlockStatementList
:
StatementList
Return the
TopLevelLexicallyScopedDeclarations
of
StatementList
.
ConciseBody
:
ExpressionBody
Return a new empty
List
.
AsyncConciseBody
:
ExpressionBody
Return a new empty
List
.
Script
:
[empty]
Return a new empty
List
.
ScriptBody
:
StatementList
Return the
TopLevelLexicallyScopedDeclarations
of
StatementList
.
Module
:
[empty]
Return a new empty
List
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
declarations1
be the
LexicallyScopedDeclarations
of
ModuleItemList
.
Let
declarations2
be the
LexicallyScopedDeclarations
of
ModuleItem
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
ModuleItem
:
ImportDeclaration
Return a new empty
List
.
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
export
NamedExports
;
export
VariableStatement
Return a new empty
List
.
ExportDeclaration
:
export
Declaration
Return a
List
whose sole element is the
DeclarationPart
of
Declaration
.
ExportDeclaration
:
export
default
HoistableDeclaration
Return a
List
whose sole element is the
DeclarationPart
of
HoistableDeclaration
.
ExportDeclaration
:
export
default
ClassDeclaration
Return a
List
whose sole element is
ClassDeclaration
.
ExportDeclaration
:
export
default
AssignmentExpression
;
Return a
List
whose sole element is this
ExportDeclaration
.
8.2.6
Static Semantics: VarDeclaredNames
The
syntax-directed operation
VarDeclaredNames takes no arguments and returns a
List
of Strings. It is defined piecewise over the following productions:
Statement
:
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Return a new empty
List
.
Block
:
{
}
Return a new empty
List
.
StatementList
:
StatementList
StatementListItem
Let
names1
be the
VarDeclaredNames
of
StatementList
.
Let
names2
be the
VarDeclaredNames
of
StatementListItem
.
Return the
list-concatenation
of
names1
and
names2
.
StatementListItem
:
Declaration
Return a new empty
List
.
VariableStatement
:
var
VariableDeclarationList
;
Return the
BoundNames
of
VariableDeclarationList
.
IfStatement
:
if
(
Expression
)
Statement
else
Statement
Let
names1
be the
VarDeclaredNames
of the first
Statement
.
Let
names2
be the
VarDeclaredNames
of the second
Statement
.
Return the
list-concatenation
of
names1
and
names2
.
IfStatement
:
if
(
Expression
)
Statement
Return the
VarDeclaredNames
of
Statement
.
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
Return the
VarDeclaredNames
of
Statement
.
WhileStatement
:
while
(
Expression
)
Statement
Return the
VarDeclaredNames
of
Statement
.
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
Return the
VarDeclaredNames
of
Statement
.
ForStatement
:
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
Let
names1
be the
BoundNames
of
VariableDeclarationList
.
Let
names2
be the
VarDeclaredNames
of
Statement
.
Return the
list-concatenation
of
names1
and
names2
.
ForStatement
:
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
Return the
VarDeclaredNames
of
Statement
.
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
ForDeclaration
in
Expression
)
Statement
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
Return the
VarDeclaredNames
of
Statement
.
ForInOfStatement
:
for
(
var
ForBinding
in
Expression
)
Statement
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
await
(
var
ForBinding
of
AssignmentExpression
)
Statement
Let
names1
be the
BoundNames
of
ForBinding
.
Let
names2
be the
VarDeclaredNames
of
Statement
.
Return the
list-concatenation
of
names1
and
names2
.
Note
This section is extended by Annex
B.3.5
.
WithStatement
:
with
(
Expression
)
Statement
Return the
VarDeclaredNames
of
Statement
.
SwitchStatement
:
switch
(
Expression
)
CaseBlock
Return the
VarDeclaredNames
of
CaseBlock
.
CaseBlock
:
{
}
Return a new empty
List
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
If the first
CaseClauses
is present, let
names1
be the
VarDeclaredNames
of the first
CaseClauses
.
Else, let
names1
be a new empty
List
.
Let
names2
be the
VarDeclaredNames
of
DefaultClause
.
If the second
CaseClauses
is present, let
names3
be the
VarDeclaredNames
of the second
CaseClauses
.
Else, let
names3
be a new empty
List
.
Return the
list-concatenation
of
names1
,
names2
, and
names3
.
CaseClauses
:
CaseClauses
CaseClause
Let
names1
be the
VarDeclaredNames
of
CaseClauses
.
Let
names2
be the
VarDeclaredNames
of
CaseClause
.
Return the
list-concatenation
of
names1
and
names2
.
CaseClause
:
case
Expression
:
StatementList
opt
If the
StatementList
is present, return the
VarDeclaredNames
of
StatementList
.
Return a new empty
List
.
DefaultClause
:
default
:
StatementList
opt
If the
StatementList
is present, return the
VarDeclaredNames
of
StatementList
.
Return a new empty
List
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return the
VarDeclaredNames
of
LabelledItem
.
LabelledItem
:
FunctionDeclaration
Return a new empty
List
.
TryStatement
:
try
Block
Catch
Let
names1
be the
VarDeclaredNames
of
Block
.
Let
names2
be the
VarDeclaredNames
of
Catch
.
Return the
list-concatenation
of
names1
and
names2
.
TryStatement
:
try
Block
Finally
Let
names1
be the
VarDeclaredNames
of
Block
.
Let
names2
be the
VarDeclaredNames
of
Finally
.
Return the
list-concatenation
of
names1
and
names2
.
TryStatement
:
try
Block
Catch
Finally
Let
names1
be the
VarDeclaredNames
of
Block
.
Let
names2
be the
VarDeclaredNames
of
Catch
.
Let
names3
be the
VarDeclaredNames
of
Finally
.
Return the
list-concatenation
of
names1
,
names2
, and
names3
.
Catch
:
catch
(
CatchParameter
)
Block
Return the
VarDeclaredNames
of
Block
.
FunctionStatementList
:
[empty]
Return a new empty
List
.
FunctionStatementList
:
StatementList
Return the
TopLevelVarDeclaredNames
of
StatementList
.
ClassStaticBlockStatementList
:
[empty]
Return a new empty
List
.
ClassStaticBlockStatementList
:
StatementList
Return the
TopLevelVarDeclaredNames
of
StatementList
.
ConciseBody
:
ExpressionBody
Return a new empty
List
.
AsyncConciseBody
:
ExpressionBody
Return a new empty
List
.
Script
:
[empty]
Return a new empty
List
.
ScriptBody
:
StatementList
Return the
TopLevelVarDeclaredNames
of
StatementList
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
names1
be the
VarDeclaredNames
of
ModuleItemList
.
Let
names2
be the
VarDeclaredNames
of
ModuleItem
.
Return the
list-concatenation
of
names1
and
names2
.
ModuleItem
:
ImportDeclaration
Return a new empty
List
.
ModuleItem
:
ExportDeclaration
If
ExportDeclaration
is
export
VariableStatement
, return the
BoundNames
of
ExportDeclaration
.
Return a new empty
List
.
8.2.7
Static Semantics: VarScopedDeclarations
The
syntax-directed operation
VarScopedDeclarations takes no arguments and returns a
List
of
Parse Nodes
. It is defined piecewise over the following productions:
Statement
:
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Return a new empty
List
.
Block
:
{
}
Return a new empty
List
.
StatementList
:
StatementList
StatementListItem
Let
declarations1
be the
VarScopedDeclarations
of
StatementList
.
Let
declarations2
be the
VarScopedDeclarations
of
StatementListItem
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
StatementListItem
:
Declaration
Return a new empty
List
.
VariableDeclarationList
:
VariableDeclaration
Return «
VariableDeclaration
».
VariableDeclarationList
:
VariableDeclarationList
,
VariableDeclaration
Let
declarations1
be the
VarScopedDeclarations
of
VariableDeclarationList
.
Return the
list-concatenation
of
declarations1
and «
VariableDeclaration
».
IfStatement
:
if
(
Expression
)
Statement
else
Statement
Let
declarations1
be the
VarScopedDeclarations
of the first
Statement
.
Let
declarations2
be the
VarScopedDeclarations
of the second
Statement
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
IfStatement
:
if
(
Expression
)
Statement
Return the
VarScopedDeclarations
of
Statement
.
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
Return the
VarScopedDeclarations
of
Statement
.
WhileStatement
:
while
(
Expression
)
Statement
Return the
VarScopedDeclarations
of
Statement
.
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
Return the
VarScopedDeclarations
of
Statement
.
ForStatement
:
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
Let
declarations1
be the
VarScopedDeclarations
of
VariableDeclarationList
.
Let
declarations2
be the
VarScopedDeclarations
of
Statement
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
ForStatement
:
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
Return the
VarScopedDeclarations
of
Statement
.
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
ForDeclaration
in
Expression
)
Statement
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
Return the
VarScopedDeclarations
of
Statement
.
ForInOfStatement
:
for
(
var
ForBinding
in
Expression
)
Statement
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
await
(
var
ForBinding
of
AssignmentExpression
)
Statement
Let
declarations1
be «
ForBinding
».
Let
declarations2
be the
VarScopedDeclarations
of
Statement
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
Note
This section is extended by Annex
B.3.5
.
WithStatement
:
with
(
Expression
)
Statement
Return the
VarScopedDeclarations
of
Statement
.
SwitchStatement
:
switch
(
Expression
)
CaseBlock
Return the
VarScopedDeclarations
of
CaseBlock
.
CaseBlock
:
{
}
Return a new empty
List
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
If the first
CaseClauses
is present, let
declarations1
be the
VarScopedDeclarations
of the first
CaseClauses
.
Else, let
declarations1
be a new empty
List
.
Let
declarations2
be the
VarScopedDeclarations
of
DefaultClause
.
If the second
CaseClauses
is present, let
declarations3
be the
VarScopedDeclarations
of the second
CaseClauses
.
Else, let
declarations3
be a new empty
List
.
Return the
list-concatenation
of
declarations1
,
declarations2
, and
declarations3
.
CaseClauses
:
CaseClauses
CaseClause
Let
declarations1
be the
VarScopedDeclarations
of
CaseClauses
.
Let
declarations2
be the
VarScopedDeclarations
of
CaseClause
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
CaseClause
:
case
Expression
:
StatementList
opt
If the
StatementList
is present, return the
VarScopedDeclarations
of
StatementList
.
Return a new empty
List
.
DefaultClause
:
default
:
StatementList
opt
If the
StatementList
is present, return the
VarScopedDeclarations
of
StatementList
.
Return a new empty
List
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return the
VarScopedDeclarations
of
LabelledItem
.
LabelledItem
:
FunctionDeclaration
Return a new empty
List
.
TryStatement
:
try
Block
Catch
Let
declarations1
be the
VarScopedDeclarations
of
Block
.
Let
declarations2
be the
VarScopedDeclarations
of
Catch
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
TryStatement
:
try
Block
Finally
Let
declarations1
be the
VarScopedDeclarations
of
Block
.
Let
declarations2
be the
VarScopedDeclarations
of
Finally
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
TryStatement
:
try
Block
Catch
Finally
Let
declarations1
be the
VarScopedDeclarations
of
Block
.
Let
declarations2
be the
VarScopedDeclarations
of
Catch
.
Let
declarations3
be the
VarScopedDeclarations
of
Finally
.
Return the
list-concatenation
of
declarations1
,
declarations2
, and
declarations3
.
Catch
:
catch
(
CatchParameter
)
Block
Return the
VarScopedDeclarations
of
Block
.
FunctionStatementList
:
[empty]
Return a new empty
List
.
FunctionStatementList
:
StatementList
Return the
TopLevelVarScopedDeclarations
of
StatementList
.
ClassStaticBlockStatementList
:
[empty]
Return a new empty
List
.
ClassStaticBlockStatementList
:
StatementList
Return the
TopLevelVarScopedDeclarations
of
StatementList
.
ConciseBody
:
ExpressionBody
Return a new empty
List
.
AsyncConciseBody
:
ExpressionBody
Return a new empty
List
.
Script
:
[empty]
Return a new empty
List
.
ScriptBody
:
StatementList
Return the
TopLevelVarScopedDeclarations
of
StatementList
.
Module
:
[empty]
Return a new empty
List
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
declarations1
be the
VarScopedDeclarations
of
ModuleItemList
.
Let
declarations2
be the
VarScopedDeclarations
of
ModuleItem
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
ModuleItem
:
ImportDeclaration
Return a new empty
List
.
ModuleItem
:
ExportDeclaration
If
ExportDeclaration
is
export
VariableStatement
, return the
VarScopedDeclarations
of
VariableStatement
.
Return a new empty
List
.
8.2.8
Static Semantics: TopLevelLexicallyDeclaredNames
The
syntax-directed operation
TopLevelLexicallyDeclaredNames takes no arguments and returns a
List
of Strings. It is defined piecewise over the following productions:
StatementList
:
StatementList
StatementListItem
Let
names1
be the
TopLevelLexicallyDeclaredNames
of
StatementList
.
Let
names2
be the
TopLevelLexicallyDeclaredNames
of
StatementListItem
.
Return the
list-concatenation
of
names1
and
names2
.
StatementListItem
:
Statement
Return a new empty
List
.
StatementListItem
:
Declaration
If
Declaration
is
Declaration
:
HoistableDeclaration
, then
Return a new empty
List
.
Return the
BoundNames
of
Declaration
.
Note
At the top level of a function, or script, function declarations are treated like var declarations rather than like lexical declarations.
8.2.9
Static Semantics: TopLevelLexicallyScopedDeclarations
The
syntax-directed operation
TopLevelLexicallyScopedDeclarations takes no arguments and returns a
List
of
Parse Nodes
. It is defined piecewise over the following productions:
StatementList
:
StatementList
StatementListItem
Let
declarations1
be the
TopLevelLexicallyScopedDeclarations
of
StatementList
.
Let
declarations2
be the
TopLevelLexicallyScopedDeclarations
of
StatementListItem
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
StatementListItem
:
Statement
Return a new empty
List
.
StatementListItem
:
Declaration
If
Declaration
is
Declaration
:
HoistableDeclaration
, then
Return a new empty
List
.
Return «
Declaration
».
8.2.10
Static Semantics: TopLevelVarDeclaredNames
The
syntax-directed operation
TopLevelVarDeclaredNames takes no arguments and returns a
List
of Strings. It is defined piecewise over the following productions:
StatementList
:
StatementList
StatementListItem
Let
names1
be the
TopLevelVarDeclaredNames
of
StatementList
.
Let
names2
be the
TopLevelVarDeclaredNames
of
StatementListItem
.
Return the
list-concatenation
of
names1
and
names2
.
StatementListItem
:
Declaration
If
Declaration
is
Declaration
:
HoistableDeclaration
, then
Return the
BoundNames
of
HoistableDeclaration
.
Return a new empty
List
.
StatementListItem
:
Statement
If
Statement
is
Statement
:
LabelledStatement
, return the
TopLevelVarDeclaredNames
of
Statement
.
Return the
VarDeclaredNames
of
Statement
.
Note
At the top level of a function or script, inner function declarations are treated like var declarations.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return the
TopLevelVarDeclaredNames
of
LabelledItem
.
LabelledItem
:
Statement
If
Statement
is
Statement
:
LabelledStatement
, return the
TopLevelVarDeclaredNames
of
Statement
.
Return the
VarDeclaredNames
of
Statement
.
LabelledItem
:
FunctionDeclaration
Return the
BoundNames
of
FunctionDeclaration
.
8.2.11
Static Semantics: TopLevelVarScopedDeclarations
The
syntax-directed operation
TopLevelVarScopedDeclarations takes no arguments and returns a
List
of
Parse Nodes
. It is defined piecewise over the following productions:
StatementList
:
StatementList
StatementListItem
Let
declarations1
be the
TopLevelVarScopedDeclarations
of
StatementList
.
Let
declarations2
be the
TopLevelVarScopedDeclarations
of
StatementListItem
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
StatementListItem
:
Statement
If
Statement
is
Statement
:
LabelledStatement
, return the
TopLevelVarScopedDeclarations
of
Statement
.
Return the
VarScopedDeclarations
of
Statement
.
StatementListItem
:
Declaration
If
Declaration
is
Declaration
:
HoistableDeclaration
, then
Let
declaration
be the
DeclarationPart
of
HoistableDeclaration
.
Return «
declaration
».
Return a new empty
List
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return the
TopLevelVarScopedDeclarations
of
LabelledItem
.
LabelledItem
:
Statement
If
Statement
is
Statement
:
LabelledStatement
, return the
TopLevelVarScopedDeclarations
of
Statement
.
Return the
VarScopedDeclarations
of
Statement
.
LabelledItem
:
FunctionDeclaration
Return «
FunctionDeclaration
».
8.3
Labels
8.3.1
Static Semantics: ContainsDuplicateLabels
The
syntax-directed operation
ContainsDuplicateLabels takes argument
labelSet
(a
List
of Strings) and returns a Boolean. It is defined piecewise over the following productions:
Statement
:
VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block
:
{
}
StatementListItem
:
Declaration
Return
false
.
StatementList
:
StatementList
StatementListItem
Let
hasDuplicates
be
ContainsDuplicateLabels
of
StatementList
with argument
labelSet
.
If
hasDuplicates
is
true
, return
true
.
Return
ContainsDuplicateLabels
of
StatementListItem
with argument
labelSet
.
IfStatement
:
if
(
Expression
)
Statement
else
Statement
Let
hasDuplicate
be
ContainsDuplicateLabels
of the first
Statement
with argument
labelSet
.
If
hasDuplicate
is
true
, return
true
.
Return
ContainsDuplicateLabels
of the second
Statement
with argument
labelSet
.
IfStatement
:
if
(
Expression
)
Statement
Return
ContainsDuplicateLabels
of
Statement
with argument
labelSet
.
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
Return
ContainsDuplicateLabels
of
Statement
with argument
labelSet
.
WhileStatement
:
while
(
Expression
)
Statement
Return
ContainsDuplicateLabels
of
Statement
with argument
labelSet
.
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
Return
ContainsDuplicateLabels
of
Statement
with argument
labelSet
.
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
var
ForBinding
in
Expression
)
Statement
for
(
ForDeclaration
in
Expression
)
Statement
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
await
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
Return
ContainsDuplicateLabels
of
Statement
with argument
labelSet
.
Note
This section is extended by Annex
B.3.5
.
WithStatement
:
with
(
Expression
)
Statement
Return
ContainsDuplicateLabels
of
Statement
with argument
labelSet
.
SwitchStatement
:
switch
(
Expression
)
CaseBlock
Return
ContainsDuplicateLabels
of
CaseBlock
with argument
labelSet
.
CaseBlock
:
{
}
Return
false
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
If the first
CaseClauses
is present, then
If
ContainsDuplicateLabels
of the first
CaseClauses
with argument
labelSet
is
true
, return
true
.
If
ContainsDuplicateLabels
of
DefaultClause
with argument
labelSet
is
true
, return
true
.
If the second
CaseClauses
is not present, return
false
.
Return
ContainsDuplicateLabels
of the second
CaseClauses
with argument
labelSet
.
CaseClauses
:
CaseClauses
CaseClause
Let
hasDuplicates
be
ContainsDuplicateLabels
of
CaseClauses
with argument
labelSet
.
If
hasDuplicates
is
true
, return
true
.
Return
ContainsDuplicateLabels
of
CaseClause
with argument
labelSet
.
CaseClause
:
case
Expression
:
StatementList
opt
If the
StatementList
is present, return
ContainsDuplicateLabels
of
StatementList
with argument
labelSet
.
Return
false
.
DefaultClause
:
default
:
StatementList
opt
If the
StatementList
is present, return
ContainsDuplicateLabels
of
StatementList
with argument
labelSet
.
Return
false
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Let
label
be the
StringValue
of
LabelIdentifier
.
If
labelSet
contains
label
, return
true
.
Let
newLabelSet
be the
list-concatenation
of
labelSet
and «
label
».
Return
ContainsDuplicateLabels
of
LabelledItem
with argument
newLabelSet
.
LabelledItem
:
FunctionDeclaration
Return
false
.
TryStatement
:
try
Block
Catch
Let
hasDuplicates
be
ContainsDuplicateLabels
of
Block
with argument
labelSet
.
If
hasDuplicates
is
true
, return
true
.
Return
ContainsDuplicateLabels
of
Catch
with argument
labelSet
.
TryStatement
:
try
Block
Finally
Let
hasDuplicates
be
ContainsDuplicateLabels
of
Block
with argument
labelSet
.
If
hasDuplicates
is
true
, return
true
.
Return
ContainsDuplicateLabels
of
Finally
with argument
labelSet
.
TryStatement
:
try
Block
Catch
Finally
If
ContainsDuplicateLabels
of
Block
with argument
labelSet
is
true
, return
true
.
If
ContainsDuplicateLabels
of
Catch
with argument
labelSet
is
true
, return
true
.
Return
ContainsDuplicateLabels
of
Finally
with argument
labelSet
.
Catch
:
catch
(
CatchParameter
)
Block
Return
ContainsDuplicateLabels
of
Block
with argument
labelSet
.
FunctionStatementList
:
[empty]
Return
false
.
ClassStaticBlockStatementList
:
[empty]
Return
false
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
hasDuplicates
be
ContainsDuplicateLabels
of
ModuleItemList
with argument
labelSet
.
If
hasDuplicates
is
true
, return
true
.
Return
ContainsDuplicateLabels
of
ModuleItem
with argument
labelSet
.
ModuleItem
:
ImportDeclaration
ExportDeclaration
Return
false
.
8.3.2
Static Semantics: ContainsUndefinedBreakTarget
The
syntax-directed operation
ContainsUndefinedBreakTarget takes argument
labelSet
(a
List
of Strings) and returns a Boolean. It is defined piecewise over the following productions:
Statement
:
VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block
:
{
}
StatementListItem
:
Declaration
Return
false
.
StatementList
:
StatementList
StatementListItem
Let
hasUndefinedLabels
be
ContainsUndefinedBreakTarget
of
StatementList
with argument
labelSet
.
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedBreakTarget
of
StatementListItem
with argument
labelSet
.
IfStatement
:
if
(
Expression
)
Statement
else
Statement
Let
hasUndefinedLabels
be
ContainsUndefinedBreakTarget
of the first
Statement
with argument
labelSet
.
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedBreakTarget
of the second
Statement
with argument
labelSet
.
IfStatement
:
if
(
Expression
)
Statement
Return
ContainsUndefinedBreakTarget
of
Statement
with argument
labelSet
.
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
Return
ContainsUndefinedBreakTarget
of
Statement
with argument
labelSet
.
WhileStatement
:
while
(
Expression
)
Statement
Return
ContainsUndefinedBreakTarget
of
Statement
with argument
labelSet
.
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
Return
ContainsUndefinedBreakTarget
of
Statement
with argument
labelSet
.
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
var
ForBinding
in
Expression
)
Statement
for
(
ForDeclaration
in
Expression
)
Statement
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
await
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
Return
ContainsUndefinedBreakTarget
of
Statement
with argument
labelSet
.
Note
This section is extended by Annex
B.3.5
.
BreakStatement
:
break
;
Return
false
.
BreakStatement
:
break
LabelIdentifier
;
If
labelSet
does not contain the
StringValue
of
LabelIdentifier
, return
true
.
Return
false
.
WithStatement
:
with
(
Expression
)
Statement
Return
ContainsUndefinedBreakTarget
of
Statement
with argument
labelSet
.
SwitchStatement
:
switch
(
Expression
)
CaseBlock
Return
ContainsUndefinedBreakTarget
of
CaseBlock
with argument
labelSet
.
CaseBlock
:
{
}
Return
false
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
If the first
CaseClauses
is present, then
If
ContainsUndefinedBreakTarget
of the first
CaseClauses
with argument
labelSet
is
true
, return
true
.
If
ContainsUndefinedBreakTarget
of
DefaultClause
with argument
labelSet
is
true
, return
true
.
If the second
CaseClauses
is not present, return
false
.
Return
ContainsUndefinedBreakTarget
of the second
CaseClauses
with argument
labelSet
.
CaseClauses
:
CaseClauses
CaseClause
Let
hasUndefinedLabels
be
ContainsUndefinedBreakTarget
of
CaseClauses
with argument
labelSet
.
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedBreakTarget
of
CaseClause
with argument
labelSet
.
CaseClause
:
case
Expression
:
StatementList
opt
If the
StatementList
is present, return
ContainsUndefinedBreakTarget
of
StatementList
with argument
labelSet
.
Return
false
.
DefaultClause
:
default
:
StatementList
opt
If the
StatementList
is present, return
ContainsUndefinedBreakTarget
of
StatementList
with argument
labelSet
.
Return
false
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Let
label
be the
StringValue
of
LabelIdentifier
.
Let
newLabelSet
be the
list-concatenation
of
labelSet
and «
label
».
Return
ContainsUndefinedBreakTarget
of
LabelledItem
with argument
newLabelSet
.
LabelledItem
:
FunctionDeclaration
Return
false
.
TryStatement
:
try
Block
Catch
Let
hasUndefinedLabels
be
ContainsUndefinedBreakTarget
of
Block
with argument
labelSet
.
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedBreakTarget
of
Catch
with argument
labelSet
.
TryStatement
:
try
Block
Finally
Let
hasUndefinedLabels
be
ContainsUndefinedBreakTarget
of
Block
with argument
labelSet
.
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedBreakTarget
of
Finally
with argument
labelSet
.
TryStatement
:
try
Block
Catch
Finally
If
ContainsUndefinedBreakTarget
of
Block
with argument
labelSet
is
true
, return
true
.
If
ContainsUndefinedBreakTarget
of
Catch
with argument
labelSet
is
true
, return
true
.
Return
ContainsUndefinedBreakTarget
of
Finally
with argument
labelSet
.
Catch
:
catch
(
CatchParameter
)
Block
Return
ContainsUndefinedBreakTarget
of
Block
with argument
labelSet
.
FunctionStatementList
:
[empty]
Return
false
.
ClassStaticBlockStatementList
:
[empty]
Return
false
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
hasUndefinedLabels
be
ContainsUndefinedBreakTarget
of
ModuleItemList
with argument
labelSet
.
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedBreakTarget
of
ModuleItem
with argument
labelSet
.
ModuleItem
:
ImportDeclaration
ExportDeclaration
Return
false
.
8.3.3
Static Semantics: ContainsUndefinedContinueTarget
The
syntax-directed operation
ContainsUndefinedContinueTarget takes arguments
iterationSet
(a
List
of Strings) and
labelSet
(a
List
of Strings) and returns a Boolean. It is defined piecewise over the following productions:
Statement
:
VariableStatement
EmptyStatement
ExpressionStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block
:
{
}
StatementListItem
:
Declaration
Return
false
.
Statement
:
BlockStatement
Return
ContainsUndefinedContinueTarget
of
BlockStatement
with arguments
iterationSet
and « ».
BreakableStatement
:
IterationStatement
Let
newIterationSet
be the
list-concatenation
of
iterationSet
and
labelSet
.
Return
ContainsUndefinedContinueTarget
of
IterationStatement
with arguments
newIterationSet
and « ».
StatementList
:
StatementList
StatementListItem
Let
hasUndefinedLabels
be
ContainsUndefinedContinueTarget
of
StatementList
with arguments
iterationSet
and « ».
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedContinueTarget
of
StatementListItem
with arguments
iterationSet
and « ».
IfStatement
:
if
(
Expression
)
Statement
else
Statement
Let
hasUndefinedLabels
be
ContainsUndefinedContinueTarget
of the first
Statement
with arguments
iterationSet
and « ».
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedContinueTarget
of the second
Statement
with arguments
iterationSet
and « ».
IfStatement
:
if
(
Expression
)
Statement
Return
ContainsUndefinedContinueTarget
of
Statement
with arguments
iterationSet
and « ».
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
Return
ContainsUndefinedContinueTarget
of
Statement
with arguments
iterationSet
and « ».
WhileStatement
:
while
(
Expression
)
Statement
Return
ContainsUndefinedContinueTarget
of
Statement
with arguments
iterationSet
and « ».
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
Return
ContainsUndefinedContinueTarget
of
Statement
with arguments
iterationSet
and « ».
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
var
ForBinding
in
Expression
)
Statement
for
(
ForDeclaration
in
Expression
)
Statement
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
await
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
Return
ContainsUndefinedContinueTarget
of
Statement
with arguments
iterationSet
and « ».
Note
This section is extended by Annex
B.3.5
.
ContinueStatement
:
continue
;
Return
false
.
ContinueStatement
:
continue
LabelIdentifier
;
If
iterationSet
does not contain the
StringValue
of
LabelIdentifier
, return
true
.
Return
false
.
WithStatement
:
with
(
Expression
)
Statement
Return
ContainsUndefinedContinueTarget
of
Statement
with arguments
iterationSet
and « ».
SwitchStatement
:
switch
(
Expression
)
CaseBlock
Return
ContainsUndefinedContinueTarget
of
CaseBlock
with arguments
iterationSet
and « ».
CaseBlock
:
{
}
Return
false
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
If the first
CaseClauses
is present, then
If
ContainsUndefinedContinueTarget
of the first
CaseClauses
with arguments
iterationSet
and « » is
true
, return
true
.
If
ContainsUndefinedContinueTarget
of
DefaultClause
with arguments
iterationSet
and « » is
true
, return
true
.
If the second
CaseClauses
is not present, return
false
.
Return
ContainsUndefinedContinueTarget
of the second
CaseClauses
with arguments
iterationSet
and « ».
CaseClauses
:
CaseClauses
CaseClause
Let
hasUndefinedLabels
be
ContainsUndefinedContinueTarget
of
CaseClauses
with arguments
iterationSet
and « ».
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedContinueTarget
of
CaseClause
with arguments
iterationSet
and « ».
CaseClause
:
case
Expression
:
StatementList
opt
If the
StatementList
is present, return
ContainsUndefinedContinueTarget
of
StatementList
with arguments
iterationSet
and « ».
Return
false
.
DefaultClause
:
default
:
StatementList
opt
If the
StatementList
is present, return
ContainsUndefinedContinueTarget
of
StatementList
with arguments
iterationSet
and « ».
Return
false
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Let
label
be the
StringValue
of
LabelIdentifier
.
Let
newLabelSet
be the
list-concatenation
of
labelSet
and «
label
».
Return
ContainsUndefinedContinueTarget
of
LabelledItem
with arguments
iterationSet
and
newLabelSet
.
LabelledItem
:
FunctionDeclaration
Return
false
.
TryStatement
:
try
Block
Catch
Let
hasUndefinedLabels
be
ContainsUndefinedContinueTarget
of
Block
with arguments
iterationSet
and « ».
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedContinueTarget
of
Catch
with arguments
iterationSet
and « ».
TryStatement
:
try
Block
Finally
Let
hasUndefinedLabels
be
ContainsUndefinedContinueTarget
of
Block
with arguments
iterationSet
and « ».
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedContinueTarget
of
Finally
with arguments
iterationSet
and « ».
TryStatement
:
try
Block
Catch
Finally
If
ContainsUndefinedContinueTarget
of
Block
with arguments
iterationSet
and « » is
true
, return
true
.
If
ContainsUndefinedContinueTarget
of
Catch
with arguments
iterationSet
and « » is
true
, return
true
.
Return
ContainsUndefinedContinueTarget
of
Finally
with arguments
iterationSet
and « ».
Catch
:
catch
(
CatchParameter
)
Block
Return
ContainsUndefinedContinueTarget
of
Block
with arguments
iterationSet
and « ».
FunctionStatementList
:
[empty]
Return
false
.
ClassStaticBlockStatementList
:
[empty]
Return
false
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
hasUndefinedLabels
be
ContainsUndefinedContinueTarget
of
ModuleItemList
with arguments
iterationSet
and « ».
If
hasUndefinedLabels
is
true
, return
true
.
Return
ContainsUndefinedContinueTarget
of
ModuleItem
with arguments
iterationSet
and « ».
ModuleItem
:
ImportDeclaration
ExportDeclaration
Return
false
.
8.4
Function Name Inference
8.4.1
Static Semantics: HasName
The
syntax-directed operation
HasName takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
Let
expr
be the
ParenthesizedExpression
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
If
IsFunctionDefinition
of
expr
is
false
, return
false
.
Return
HasName
of
expr
.
FunctionExpression
:
function
(
FormalParameters
)
{
FunctionBody
}
GeneratorExpression
:
function
*
(
FormalParameters
)
{
GeneratorBody
}
AsyncGeneratorExpression
:
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncFunctionExpression
:
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
ArrowFunction
:
ArrowParameters
=>
ConciseBody
AsyncArrowFunction
:
async
AsyncArrowBindingIdentifier
=>
AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead
=>
AsyncConciseBody
ClassExpression
:
class
ClassTail
Return
false
.
FunctionExpression
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
GeneratorExpression
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
AsyncGeneratorExpression
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncFunctionExpression
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
ClassExpression
:
class
BindingIdentifier
ClassTail
Return
true
.
8.4.2
Static Semantics: IsFunctionDefinition
The
syntax-directed operation
IsFunctionDefinition takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
Let
expr
be the
ParenthesizedExpression
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return
IsFunctionDefinition
of
expr
.
PrimaryExpression
:
this
IdentifierReference
Literal
ArrayLiteral
ObjectLiteral
RegularExpressionLiteral
TemplateLiteral
MemberExpression
:
MemberExpression
[
Expression
]
MemberExpression
.
IdentifierName
MemberExpression
TemplateLiteral
SuperProperty
MetaProperty
new
MemberExpression
Arguments
MemberExpression
.
PrivateIdentifier
NewExpression
:
new
NewExpression
LeftHandSideExpression
:
CallExpression
OptionalExpression
UpdateExpression
:
LeftHandSideExpression
++
LeftHandSideExpression
--
++
UnaryExpression
--
UnaryExpression
UnaryExpression
:
delete
UnaryExpression
void
UnaryExpression
typeof
UnaryExpression
+
UnaryExpression
-
UnaryExpression
~
UnaryExpression
!
UnaryExpression
AwaitExpression
ExponentiationExpression
:
UpdateExpression
**
ExponentiationExpression
MultiplicativeExpression
:
MultiplicativeExpression
MultiplicativeOperator
ExponentiationExpression
AdditiveExpression
:
AdditiveExpression
+
MultiplicativeExpression
AdditiveExpression
-
MultiplicativeExpression
ShiftExpression
:
ShiftExpression
<<
AdditiveExpression
ShiftExpression
>>
AdditiveExpression
ShiftExpression
>>>
AdditiveExpression
RelationalExpression
:
RelationalExpression
<
ShiftExpression
RelationalExpression
>
ShiftExpression
RelationalExpression
<=
ShiftExpression
RelationalExpression
>=
ShiftExpression
RelationalExpression
instanceof
ShiftExpression
RelationalExpression
in
ShiftExpression
PrivateIdentifier
in
ShiftExpression
EqualityExpression
:
EqualityExpression
==
RelationalExpression
EqualityExpression
!=
RelationalExpression
EqualityExpression
===
RelationalExpression
EqualityExpression
!==
RelationalExpression
BitwiseANDExpression
:
BitwiseANDExpression
&
EqualityExpression
BitwiseXORExpression
:
BitwiseXORExpression
^
BitwiseANDExpression
BitwiseORExpression
:
BitwiseORExpression
|
BitwiseXORExpression
LogicalANDExpression
:
LogicalANDExpression
&&
BitwiseORExpression
LogicalORExpression
:
LogicalORExpression
||
LogicalANDExpression
CoalesceExpression
:
CoalesceExpressionHead
??
BitwiseORExpression
ConditionalExpression
:
ShortCircuitExpression
?
AssignmentExpression
:
AssignmentExpression
AssignmentExpression
:
YieldExpression
LeftHandSideExpression
=
AssignmentExpression
LeftHandSideExpression
AssignmentOperator
AssignmentExpression
LeftHandSideExpression
&&=
AssignmentExpression
LeftHandSideExpression
||=
AssignmentExpression
LeftHandSideExpression
??=
AssignmentExpression
Expression
:
Expression
,
AssignmentExpression
Return
false
.
AssignmentExpression
:
ArrowFunction
AsyncArrowFunction
FunctionExpression
:
function
BindingIdentifier
opt
(
FormalParameters
)
{
FunctionBody
}
GeneratorExpression
:
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
GeneratorBody
}
AsyncGeneratorExpression
:
async
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncFunctionExpression
:
async
function
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncFunctionBody
}
ClassExpression
:
class
BindingIdentifier
opt
ClassTail
Return
true
.
8.4.3
Static Semantics: IsAnonymousFunctionDefinition (
expr
)
The abstract operation IsAnonymousFunctionDefinition takes argument
expr
(an
AssignmentExpression
Parse Node
, an
Initializer
Parse Node
, or an
Expression
Parse Node
) and returns a Boolean. It determines if its argument is a function definition that does not bind a name. It performs the following steps when called:
If
IsFunctionDefinition
of
expr
is
false
, return
false
.
Let
hasName
be
HasName
of
expr
.
If
hasName
is
true
, return
false
.
Return
true
.
8.4.4
Static Semantics: IsIdentifierRef
The
syntax-directed operation
IsIdentifierRef takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
PrimaryExpression
:
IdentifierReference
Return
true
.
PrimaryExpression
:
this
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
CoverParenthesizedExpressionAndArrowParameterList
MemberExpression
:
MemberExpression
[
Expression
]
MemberExpression
.
IdentifierName
MemberExpression
TemplateLiteral
SuperProperty
MetaProperty
new
MemberExpression
Arguments
MemberExpression
.
PrivateIdentifier
NewExpression
:
new
NewExpression
LeftHandSideExpression
:
CallExpression
OptionalExpression
Return
false
.
8.4.5
Runtime Semantics: NamedEvaluation
The
syntax-directed operation
NamedEvaluation takes argument
name
(a
property key
or a
Private Name
) and returns either a
normal completion containing
a
function object
or an
abrupt completion
. It is defined piecewise over the following productions:
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
Let
expr
be the
ParenthesizedExpression
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return ?
NamedEvaluation
of
expr
with argument
name
.
ParenthesizedExpression
:
(
Expression
)
Assert
:
IsAnonymousFunctionDefinition
(
Expression
) is
true
.
Return ?
NamedEvaluation
of
Expression
with argument
name
.
FunctionExpression
:
function
(
FormalParameters
)
{
FunctionBody
}
Return
InstantiateOrdinaryFunctionExpression
of
FunctionExpression
with argument
name
.
GeneratorExpression
:
function
*
(
FormalParameters
)
{
GeneratorBody
}
Return
InstantiateGeneratorFunctionExpression
of
GeneratorExpression
with argument
name
.
AsyncGeneratorExpression
:
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
Return
InstantiateAsyncGeneratorFunctionExpression
of
AsyncGeneratorExpression
with argument
name
.
AsyncFunctionExpression
:
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
Return
InstantiateAsyncFunctionExpression
of
AsyncFunctionExpression
with argument
name
.
ArrowFunction
:
ArrowParameters
=>
ConciseBody
Return
InstantiateArrowFunctionExpression
of
ArrowFunction
with argument
name
.
AsyncArrowFunction
:
async
AsyncArrowBindingIdentifier
=>
AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead
=>
AsyncConciseBody
Return
InstantiateAsyncArrowFunctionExpression
of
AsyncArrowFunction
with argument
name
.
ClassExpression
:
class
ClassTail
Let
sourceText
be the
source text matched by
ClassExpression
.
Return ?
ClassDefinitionEvaluation
of
ClassTail
with arguments
undefined
,
name
, and
sourceText
.
8.5
Contains
8.5.1
Static Semantics: Contains
The
syntax-directed operation
Contains takes argument
symbol
(a grammar symbol) and returns a Boolean.
Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of Contains:
For each child node
child
of this
Parse Node
, do
If
child
is an instance of
symbol
, return
true
.
If
child
is an instance of a nonterminal, then
Let
contained
be the result of
child
Contains
symbol
.
If
contained
is
true
, return
true
.
Return
false
.
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
function
(
FormalParameters
)
{
FunctionBody
}
FunctionExpression
:
function
BindingIdentifier
opt
(
FormalParameters
)
{
FunctionBody
}
GeneratorDeclaration
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
function
*
(
FormalParameters
)
{
GeneratorBody
}
GeneratorExpression
:
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
GeneratorBody
}
AsyncGeneratorDeclaration
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncGeneratorExpression
:
async
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncFunctionDeclaration
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
AsyncFunctionExpression
:
async
function
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncFunctionBody
}
Return
false
.
Note 1
Static semantic rules that depend upon substructure generally do not look into function definitions.
ClassTail
:
ClassHeritage
opt
{
ClassBody
}
If
symbol
is
ClassBody
, return
true
.
If
symbol
is
ClassHeritage
, then
If
ClassHeritage
is present, return
true
; otherwise return
false
.
If
ClassHeritage
is present, then
If
ClassHeritage
Contains
symbol
is
true
, return
true
.
Return the result of
ComputedPropertyContains
of
ClassBody
with argument
symbol
.
Note 2
Static semantic rules that depend upon substructure generally do not look into class bodies except for
PropertyName
s.
ClassStaticBlock
:
static
{
ClassStaticBlockBody
}
Return
false
.
Note 3
Static semantic rules that depend upon substructure generally do not look into
static
initialization blocks.
ArrowFunction
:
ArrowParameters
=>
ConciseBody
If
symbol
is not one of
NewTarget
,
SuperProperty
,
SuperCall
,
super
, or
this
, return
false
.
If
ArrowParameters
Contains
symbol
is
true
, return
true
.
Return
ConciseBody
Contains
symbol
.
ArrowParameters
:
CoverParenthesizedExpressionAndArrowParameterList
Let
formals
be the
ArrowFormalParameters
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return
formals
Contains
symbol
.
AsyncArrowFunction
:
async
AsyncArrowBindingIdentifier
=>
AsyncConciseBody
If
symbol
is not one of
NewTarget
,
SuperProperty
,
SuperCall
,
super
, or
this
, return
false
.
Return
AsyncConciseBody
Contains
symbol
.
AsyncArrowFunction
:
CoverCallExpressionAndAsyncArrowHead
=>
AsyncConciseBody
If
symbol
is not one of
NewTarget
,
SuperProperty
,
SuperCall
,
super
, or
this
, return
false
.
Let
head
be the
AsyncArrowHead
that is
covered
by
CoverCallExpressionAndAsyncArrowHead
.
If
head
Contains
symbol
is
true
, return
true
.
Return
AsyncConciseBody
Contains
symbol
.
Note 4
Contains is used to detect
new.target
,
this
, and
super
usage within an
ArrowFunction
or
AsyncArrowFunction
.
PropertyDefinition
:
MethodDefinition
If
symbol
is
MethodDefinition
, return
true
.
Return the result of
ComputedPropertyContains
of
MethodDefinition
with argument
symbol
.
LiteralPropertyName
:
IdentifierName
Return
false
.
MemberExpression
:
MemberExpression
.
IdentifierName
If
MemberExpression
Contains
symbol
is
true
, return
true
.
Return
false
.
SuperProperty
:
super
.
IdentifierName
If
symbol
is the
ReservedWord
super
, return
true
.
Return
false
.
CallExpression
:
CallExpression
.
IdentifierName
If
CallExpression
Contains
symbol
is
true
, return
true
.
Return
false
.
OptionalChain
:
?.
IdentifierName
Return
false
.
OptionalChain
:
OptionalChain
.
IdentifierName
If
OptionalChain
Contains
symbol
is
true
, return
true
.
Return
false
.
8.5.2
Static Semantics: ComputedPropertyContains
The
syntax-directed operation
ComputedPropertyContains takes argument
symbol
(a grammar symbol) and returns a Boolean. It is defined piecewise over the following productions:
ClassElementName
:
PrivateIdentifier
PropertyName
:
LiteralPropertyName
Return
false
.
PropertyName
:
ComputedPropertyName
Return the result of
ComputedPropertyName
Contains
symbol
.
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
get
ClassElementName
(
)
{
FunctionBody
}
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
Return the result of
ComputedPropertyContains
of
ClassElementName
with argument
symbol
.
GeneratorMethod
:
*
ClassElementName
(
UniqueFormalParameters
)
{
GeneratorBody
}
Return the result of
ComputedPropertyContains
of
ClassElementName
with argument
symbol
.
AsyncGeneratorMethod
:
async
*
ClassElementName
(
UniqueFormalParameters
)
{
AsyncGeneratorBody
}
Return the result of
ComputedPropertyContains
of
ClassElementName
with argument
symbol
.
ClassElementList
:
ClassElementList
ClassElement
Let
inList
be
ComputedPropertyContains
of
ClassElementList
with argument
symbol
.
If
inList
is
true
, return
true
.
Return the result of
ComputedPropertyContains
of
ClassElement
with argument
symbol
.
ClassElement
:
ClassStaticBlock
Return
false
.
ClassElement
:
;
Return
false
.
AsyncMethod
:
async
ClassElementName
(
UniqueFormalParameters
)
{
AsyncFunctionBody
}
Return the result of
ComputedPropertyContains
of
ClassElementName
with argument
symbol
.
FieldDefinition
:
ClassElementName
Initializer
opt
Return the result of
ComputedPropertyContains
of
ClassElementName
with argument
symbol
.
8.6
Miscellaneous
These operations are used in multiple places throughout the specification.
8.6.1
Runtime Semantics: InstantiateFunctionObject
The
syntax-directed operation
InstantiateFunctionObject takes arguments
env
(an
Environment Record
) and
privateEnv
(a
PrivateEnvironment Record
or
null
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
function
(
FormalParameters
)
{
FunctionBody
}
Return
InstantiateOrdinaryFunctionObject
of
FunctionDeclaration
with arguments
env
and
privateEnv
.
GeneratorDeclaration
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
function
*
(
FormalParameters
)
{
GeneratorBody
}
Return
InstantiateGeneratorFunctionObject
of
GeneratorDeclaration
with arguments
env
and
privateEnv
.
AsyncGeneratorDeclaration
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
Return
InstantiateAsyncGeneratorFunctionObject
of
AsyncGeneratorDeclaration
with arguments
env
and
privateEnv
.
AsyncFunctionDeclaration
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
Return
InstantiateAsyncFunctionObject
of
AsyncFunctionDeclaration
with arguments
env
and
privateEnv
.
8.6.2
Runtime Semantics: BindingInitialization
The
syntax-directed operation
BindingInitialization takes arguments
value
(an
ECMAScript language value
) and
environment
(an
Environment Record
or
undefined
) and returns either a
normal completion containing
unused
or an
abrupt completion
.
Note
undefined
is passed for
environment
to indicate that a
PutValue
operation should be used to assign the initialization value. This is the case for
var
statements and formal parameter lists of some
non-strict functions
(See
10.2.11
). In those cases a lexical binding is hoisted and preinitialized prior to evaluation of its initializer.
It is defined piecewise over the following productions:
BindingIdentifier
:
Identifier
Let
name
be the
StringValue
of
Identifier
.
Return ?
InitializeBoundName
(
name
,
value
,
environment
).
BindingIdentifier
:
yield
Return ?
InitializeBoundName
(
"yield"
,
value
,
environment
).
BindingIdentifier
:
await
Return ?
InitializeBoundName
(
"await"
,
value
,
environment
).
BindingPattern
:
ObjectBindingPattern
Perform ?
RequireObjectCoercible
(
value
).
Return ?
BindingInitialization
of
ObjectBindingPattern
with arguments
value
and
environment
.
BindingPattern
:
ArrayBindingPattern
Let
iteratorRecord
be ?
GetIterator
(
value
,
sync
).
Let
result
be
Completion
(
IteratorBindingInitialization
of
ArrayBindingPattern
with arguments
iteratorRecord
and
environment
).
If
iteratorRecord
.
[[Done]]
is
false
, return ?
IteratorClose
(
iteratorRecord
,
result
).
Return ?
result
.
ObjectBindingPattern
:
{
}
Return
unused
.
ObjectBindingPattern
:
{
BindingPropertyList
}
{
BindingPropertyList
,
}
Perform ?
PropertyBindingInitialization
of
BindingPropertyList
with arguments
value
and
environment
.
Return
unused
.
ObjectBindingPattern
:
{
BindingRestProperty
}
Let
excludedNames
be a new empty
List
.
Return ?
RestBindingInitialization
of
BindingRestProperty
with arguments
value
,
environment
, and
excludedNames
.
ObjectBindingPattern
:
{
BindingPropertyList
,
BindingRestProperty
}
Let
excludedNames
be ?
PropertyBindingInitialization
of
BindingPropertyList
with arguments
value
and
environment
.
Return ?
RestBindingInitialization
of
BindingRestProperty
with arguments
value
,
environment
, and
excludedNames
.
8.6.2.1
InitializeBoundName (
name
,
value
,
environment
)
The abstract operation InitializeBoundName takes arguments
name
(a String),
value
(an
ECMAScript language value
), and
environment
(an
Environment Record
or
undefined
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It performs the following steps when called:
If
environment
is not
undefined
, then
Perform !
environment
.
InitializeBinding
(
name
,
value
).
Return
unused
.
Else,
Let
lhs
be ?
ResolveBinding
(
name
).
Return ?
PutValue
(
lhs
,
value
).
8.6.3
Runtime Semantics: IteratorBindingInitialization
The
syntax-directed operation
IteratorBindingInitialization takes arguments
iteratorRecord
(an
Iterator Record
) and
environment
(an
Environment Record
or
undefined
) and returns either a
normal completion containing
unused
or an
abrupt completion
.
Note
When
undefined
is passed for
environment
it indicates that a
PutValue
operation should be used to assign the initialization value. This is the case for formal parameter lists of
non-strict functions
. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.
It is defined piecewise over the following productions:
ArrayBindingPattern
:
[
]
Return
unused
.
ArrayBindingPattern
:
[
Elision
]
Return ?
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
.
ArrayBindingPattern
:
[
Elision
opt
BindingRestElement
]
If
Elision
is present, then
Perform ?
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
.
Return ?
IteratorBindingInitialization
of
BindingRestElement
with arguments
iteratorRecord
and
environment
.
ArrayBindingPattern
:
[
BindingElementList
,
Elision
]
Perform ?
IteratorBindingInitialization
of
BindingElementList
with arguments
iteratorRecord
and
environment
.
Return ?
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
.
ArrayBindingPattern
:
[
BindingElementList
,
Elision
opt
BindingRestElement
]
Perform ?
IteratorBindingInitialization
of
BindingElementList
with arguments
iteratorRecord
and
environment
.
If
Elision
is present, then
Perform ?
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
.
Return ?
IteratorBindingInitialization
of
BindingRestElement
with arguments
iteratorRecord
and
environment
.
BindingElementList
:
BindingElementList
,
BindingElisionElement
Perform ?
IteratorBindingInitialization
of
BindingElementList
with arguments
iteratorRecord
and
environment
.
Return ?
IteratorBindingInitialization
of
BindingElisionElement
with arguments
iteratorRecord
and
environment
.
BindingElisionElement
:
Elision
BindingElement
Perform ?
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
.
Return ?
IteratorBindingInitialization
of
BindingElement
with arguments
iteratorRecord
and
environment
.
SingleNameBinding
:
BindingIdentifier
Initializer
opt
Let
bindingId
be the
StringValue
of
BindingIdentifier
.
Let
lhs
be ?
ResolveBinding
(
bindingId
,
environment
).
Let
v
be
undefined
.
If
iteratorRecord
.
[[Done]]
is
false
, then
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is not
done
, then
Set
v
to
next
.
If
Initializer
is present and
v
is
undefined
, then
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
, then
Set
v
to ?
NamedEvaluation
of
Initializer
with argument
bindingId
.
Else,
Let
defaultValue
be ?
Evaluation
of
Initializer
.
Set
v
to ?
GetValue
(
defaultValue
).
If
environment
is
undefined
, return ?
PutValue
(
lhs
,
v
).
Return ?
InitializeReferencedBinding
(
lhs
,
v
).
BindingElement
:
BindingPattern
Initializer
opt
Let
v
be
undefined
.
If
iteratorRecord
.
[[Done]]
is
false
, then
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is not
done
, then
Set
v
to
next
.
If
Initializer
is present and
v
is
undefined
, then
Let
defaultValue
be ?
Evaluation
of
Initializer
.
Set
v
to ?
GetValue
(
defaultValue
).
Return ?
BindingInitialization
of
BindingPattern
with arguments
v
and
environment
.
BindingRestElement
:
...
BindingIdentifier
Let
lhs
be ?
ResolveBinding
(
StringValue
of
BindingIdentifier
,
environment
).
Let
A
be !
ArrayCreate
(0).
Let
n
be 0.
Repeat,
Let
next
be
done
.
If
iteratorRecord
.
[[Done]]
is
false
, then
Set
next
to ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
If
environment
is
undefined
, return ?
PutValue
(
lhs
,
A
).
Return ?
InitializeReferencedBinding
(
lhs
,
A
).
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
n
)),
next
).
Set
n
to
n
+ 1.
BindingRestElement
:
...
BindingPattern
Let
A
be !
ArrayCreate
(0).
Let
n
be 0.
Repeat,
Let
next
be
done
.
If
iteratorRecord
.
[[Done]]
is
false
, then
Set
next
to ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Return ?
BindingInitialization
of
BindingPattern
with arguments
A
and
environment
.
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
n
)),
next
).
Set
n
to
n
+ 1.
FormalParameters
:
[empty]
Return
unused
.
FormalParameters
:
FormalParameterList
,
FunctionRestParameter
Perform ?
IteratorBindingInitialization
of
FormalParameterList
with arguments
iteratorRecord
and
environment
.
Return ?
IteratorBindingInitialization
of
FunctionRestParameter
with arguments
iteratorRecord
and
environment
.
FormalParameterList
:
FormalParameterList
,
FormalParameter
Perform ?
IteratorBindingInitialization
of
FormalParameterList
with arguments
iteratorRecord
and
environment
.
Return ?
IteratorBindingInitialization
of
FormalParameter
with arguments
iteratorRecord
and
environment
.
ArrowParameters
:
BindingIdentifier
Let
v
be
undefined
.
Assert
:
iteratorRecord
.
[[Done]]
is
false
.
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is not
done
, then
Set
v
to
next
.
Return ?
BindingInitialization
of
BindingIdentifier
with arguments
v
and
environment
.
ArrowParameters
:
CoverParenthesizedExpressionAndArrowParameterList
Let
formals
be the
ArrowFormalParameters
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return ?
IteratorBindingInitialization
of
formals
with arguments
iteratorRecord
and
environment
.
AsyncArrowBindingIdentifier
:
BindingIdentifier
Let
v
be
undefined
.
Assert
:
iteratorRecord
.
[[Done]]
is
false
.
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is not
done
, then
Set
v
to
next
.
Return ?
BindingInitialization
of
BindingIdentifier
with arguments
v
and
environment
.
8.6.4
Static Semantics: AssignmentTargetType
The
syntax-directed operation
AssignmentTargetType takes no arguments and returns
simple
,
web-compat
, or
invalid
. It is defined piecewise over the following productions:
IdentifierReference
:
Identifier
If
IsStrict
(this
IdentifierReference
) is
true
and the
StringValue
of
Identifier
is either
"eval"
or
"arguments"
, return
invalid
.
Return
simple
.
IdentifierReference
:
yield
await
CallExpression
:
CallExpression
[
Expression
]
CallExpression
.
IdentifierName
CallExpression
.
PrivateIdentifier
MemberExpression
:
MemberExpression
[
Expression
]
MemberExpression
.
IdentifierName
SuperProperty
MemberExpression
.
PrivateIdentifier
Return
simple
.
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
Let
expr
be the
ParenthesizedExpression
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return the
AssignmentTargetType
of
expr
.
CallExpression
:
CoverCallExpressionAndAsyncArrowHead
CallExpression
Arguments
Normative Optional
If the
host
is a web browser or otherwise supports
Runtime Errors for Function Call Assignment Targets
and
IsStrict
(this
CallExpression
) is
false
, then
Return
web-compat
.
Return
invalid
.
PrimaryExpression
:
this
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
CallExpression
:
SuperCall
ImportCall
CallExpression
TemplateLiteral
NewExpression
:
new
NewExpression
MemberExpression
:
MemberExpression
TemplateLiteral
new
MemberExpression
Arguments
NewTarget
:
new
.
target
ImportMeta
:
import
.
meta
LeftHandSideExpression
:
OptionalExpression
UpdateExpression
:
LeftHandSideExpression
++
LeftHandSideExpression
--
++
UnaryExpression
--
UnaryExpression
UnaryExpression
:
delete
UnaryExpression
void
UnaryExpression
typeof
UnaryExpression
+
UnaryExpression
-
UnaryExpression
~
UnaryExpression
!
UnaryExpression
AwaitExpression
ExponentiationExpression
:
UpdateExpression
**
ExponentiationExpression
MultiplicativeExpression
:
MultiplicativeExpression
MultiplicativeOperator
ExponentiationExpression
AdditiveExpression
:
AdditiveExpression
+
MultiplicativeExpression
AdditiveExpression
-
MultiplicativeExpression
ShiftExpression
:
ShiftExpression
<<
AdditiveExpression
ShiftExpression
>>
AdditiveExpression
ShiftExpression
>>>
AdditiveExpression
RelationalExpression
:
RelationalExpression
<
ShiftExpression
RelationalExpression
>
ShiftExpression
RelationalExpression
<=
ShiftExpression
RelationalExpression
>=
ShiftExpression
RelationalExpression
instanceof
ShiftExpression
RelationalExpression
in
ShiftExpression
PrivateIdentifier
in
ShiftExpression
EqualityExpression
:
EqualityExpression
==
RelationalExpression
EqualityExpression
!=
RelationalExpression
EqualityExpression
===
RelationalExpression
EqualityExpression
!==
RelationalExpression
BitwiseANDExpression
:
BitwiseANDExpression
&
EqualityExpression
BitwiseXORExpression
:
BitwiseXORExpression
^
BitwiseANDExpression
BitwiseORExpression
:
BitwiseORExpression
|
BitwiseXORExpression
LogicalANDExpression
:
LogicalANDExpression
&&
BitwiseORExpression
LogicalORExpression
:
LogicalORExpression
||
LogicalANDExpression
CoalesceExpression
:
CoalesceExpressionHead
??
BitwiseORExpression
ConditionalExpression
:
ShortCircuitExpression
?
AssignmentExpression
:
AssignmentExpression
AssignmentExpression
:
YieldExpression
ArrowFunction
AsyncArrowFunction
LeftHandSideExpression
=
AssignmentExpression
LeftHandSideExpression
AssignmentOperator
AssignmentExpression
LeftHandSideExpression
&&=
AssignmentExpression
LeftHandSideExpression
||=
AssignmentExpression
LeftHandSideExpression
??=
AssignmentExpression
Expression
:
Expression
,
AssignmentExpression
Return
invalid
.
8.6.5
Static Semantics: PropName
The
syntax-directed operation
PropName takes no arguments and returns a String or
empty
. It is defined piecewise over the following productions:
PropertyDefinition
:
IdentifierReference
Return the
StringValue
of
IdentifierReference
.
PropertyDefinition
:
...
AssignmentExpression
Return
empty
.
PropertyDefinition
:
PropertyName
:
AssignmentExpression
Return the
PropName
of
PropertyName
.
LiteralPropertyName
:
IdentifierName
AttributeKey
:
IdentifierName
Return the
StringValue
of
IdentifierName
.
LiteralPropertyName
:
StringLiteral
AttributeKey
:
StringLiteral
Return the
SV
of
StringLiteral
.
LiteralPropertyName
:
NumericLiteral
Let
nbr
be the
NumericValue
of
NumericLiteral
.
Return !
ToString
(
nbr
).
ComputedPropertyName
:
[
AssignmentExpression
]
Return
empty
.
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
get
ClassElementName
(
)
{
FunctionBody
}
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
Return the
PropName
of
ClassElementName
.
GeneratorMethod
:
*
ClassElementName
(
UniqueFormalParameters
)
{
GeneratorBody
}
Return the
PropName
of
ClassElementName
.
AsyncGeneratorMethod
:
async
*
ClassElementName
(
UniqueFormalParameters
)
{
AsyncGeneratorBody
}
Return the
PropName
of
ClassElementName
.
ClassElement
:
ClassStaticBlock
Return
empty
.
ClassElement
:
;
Return
empty
.
AsyncMethod
:
async
ClassElementName
(
UniqueFormalParameters
)
{
AsyncFunctionBody
}
Return the
PropName
of
ClassElementName
.
FieldDefinition
:
ClassElementName
Initializer
opt
Return the
PropName
of
ClassElementName
.
ClassElementName
:
PrivateIdentifier
Return
empty
.
9
Executable Code and Execution Contexts
9.1
Environment Records
Environment Record
is a specification type used to define the association of
Identifier
s to specific variables and functions, based upon the lexical nesting structure of ECMAScript code. Usually an Environment Record is associated with some specific syntactic structure of ECMAScript code such as a
FunctionDeclaration
, a
BlockStatement
, or a
Catch
clause of a
TryStatement
. Each time such code is evaluated, a new Environment Record is created to record the identifier bindings that are created by that code.
Every Environment Record has an
[[OuterEnv]]
field, which is either
null
or a reference to an outer Environment Record. This is used to model the logical nesting of Environment Record values. The outer reference of an (inner) Environment Record is a reference to the Environment Record that logically surrounds the inner Environment Record. An outer Environment Record may, of course, have its own outer Environment Record. An Environment Record may serve as the outer environment for multiple inner Environment Records. For example, if a
FunctionDeclaration
contains two nested
FunctionDeclaration
s then the Environment Records of each of the nested functions will have as their outer Environment Record the Environment Record of the current evaluation of the surrounding function.
Environment Records are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.
9.1.1
The Environment Record Type Hierarchy
Environment Records
can be thought of as existing in a simple object-oriented hierarchy where
Environment Record
is an abstract class with three concrete subclasses:
Declarative Environment Record
,
Object Environment Record
, and
Global Environment Record
.
Function Environment Records
and
Module Environment Records
are subclasses of
Declarative Environment Record
.
Environment Record
(abstract)
A
Declarative Environment Record
is used to define the effect of ECMAScript language syntactic elements such as
FunctionDeclaration
s,
VariableDeclaration
s, and
Catch
clauses that directly associate identifier bindings with
ECMAScript language values
.
A
Function Environment Record
corresponds to the invocation of an ECMAScript
function object
, and contains bindings for the top-level declarations within that function. It may establish a new
this
binding. It also captures the state necessary to support
super
method invocations.
A
Module Environment Record
contains the bindings for the top-level declarations of a
Module
. It also contains the bindings that are explicitly imported by the
Module
. Its
[[OuterEnv]]
is a
Global Environment Record
.
An
Object Environment Record
is used to define the effect of ECMAScript elements such as
WithStatement
that associate identifier bindings with the properties of some object.
A
Global Environment Record
is used for
Script
global declarations. It does not have an outer environment; its
[[OuterEnv]]
is
null
. It may be prepopulated with identifier bindings and it includes an associated
global object
whose properties provide some of the global environment's identifier bindings. As ECMAScript code is executed, additional properties may be added to the
global object
and the initial properties may be modified.
The
Environment Record
abstract class includes the abstract specification methods defined in
Table 14
. These abstract methods have distinct concrete algorithms for each of the concrete subclasses.
Table 14: Abstract Methods of
Environment Records
Method
Purpose
Definitions
HasBinding (
N
)
The abstract method HasBinding takes argument
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
.
It determines if an
Environment Record
has a binding for
N
.
It has concrete definitions in the following types:
9.1.1.1.1 Declarative Environment Record
9.1.1.2.1 Object Environment Record
9.1.1.4.1 Global Environment Record
CreateMutableBinding (
N
,
D
)
The abstract method CreateMutableBinding takes arguments
N
(a String) and
D
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
.
It creates a new but uninitialized mutable binding in an
Environment Record
.
N
is the text of the bound name. If
D
is
true
the binding may be subsequently deleted.
It has concrete definitions in the following types:
9.1.1.1.2 Declarative Environment Record
9.1.1.2.2 Object Environment Record
9.1.1.4.2 Global Environment Record
CreateImmutableBinding (
N
,
S
)
The abstract method CreateImmutableBinding takes arguments
N
(a String) and
S
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
.
It creates a new but uninitialized immutable binding in an
Environment Record
.
N
is the text of the bound name. If
S
is
true
then attempts to set it after it has been initialized will always throw an exception, regardless of the strict mode setting of operations that reference that binding.
It has concrete definitions in the following types:
9.1.1.1.3 Declarative Environment Record
9.1.1.4.3 Global Environment Record
InitializeBinding (
N
,
V
)
The abstract method InitializeBinding takes arguments
N
(a String) and
V
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
.
It sets the value of an already existing but uninitialized binding in an
Environment Record
.
N
is the text of the bound name.
V
is the value for the binding.
It has concrete definitions in the following types:
9.1.1.1.4 Declarative Environment Record
9.1.1.2.4 Object Environment Record
9.1.1.4.4 Global Environment Record
SetMutableBinding (
N
,
V
,
S
)
The abstract method SetMutableBinding takes arguments
N
(a String),
V
(an
ECMAScript language value
), and
S
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
.
It sets the value of an already existing mutable binding in an
Environment Record
.
N
is the text of the bound name.
V
is the value for the binding. If
S
is
true
and the binding cannot be set, this will throw a
TypeError
exception.
It has concrete definitions in the following types:
9.1.1.1.5 Declarative Environment Record
9.1.1.2.5 Object Environment Record
9.1.1.4.5 Global Environment Record
GetBindingValue (
N
,
S
)
The abstract method GetBindingValue takes arguments
N
(a String) and
S
(a Boolean) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
.
It returns the value of an already existing binding from an
Environment Record
.
N
is the text of the bound name.
S
is used to identify references originating in
strict mode code
or that otherwise require strict mode reference semantics. If
S
is
true
and the binding does not exist, this will throw a
ReferenceError
exception. If the binding exists but is uninitialized a
ReferenceError
is thrown, regardless of the value of
S
.
It has concrete definitions in the following types:
9.1.1.1.6 Declarative Environment Record
9.1.1.2.6 Object Environment Record
9.1.1.4.6 Global Environment Record
9.1.1.5.1 Module Environment Record
DeleteBinding (
N
)
The abstract method DeleteBinding takes argument
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
.
It deletes a binding from an
Environment Record
.
N
is the text of the bound name. If a binding for
N
exists, this removes the binding and returns
true
. If the binding exists but cannot be removed, this returns
false
. If the binding does not exist, this returns
true
.
It has concrete definitions in the following types:
9.1.1.1.7 Declarative Environment Record
9.1.1.2.7 Object Environment Record
9.1.1.4.7 Global Environment Record
HasThisBinding ( )
The abstract method HasThisBinding takes no arguments and returns a Boolean.
It determines if an
Environment Record
establishes a
this
binding. This returns
true
if it does and
false
if it does not.
It has concrete definitions in the following types:
9.1.1.1.8 Declarative Environment Record
9.1.1.2.8 Object Environment Record
9.1.1.3.2 Function Environment Record
9.1.1.4.8 Global Environment Record
9.1.1.5.3 Module Environment Record
GetThisBinding ( )
The abstract method GetThisBinding takes no arguments and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
.
It returns the value of this
Environment Record
's
this
binding. It throws a
ReferenceError
if the
this
binding has not been initialized.
It has concrete definitions in the following types:
9.1.1.3.3 Function Environment Record
9.1.1.4.9 Global Environment Record
9.1.1.5.4 Module Environment Record
HasSuperBinding ( )
The abstract method HasSuperBinding takes no arguments and returns a Boolean.
It determines if an
Environment Record
establishes a
super
method binding. This returns
true
if it does and
false
if it does not. If it returns
true
it implies that the
Environment Record
is a
Function Environment Record
, although the reverse implication does not hold.
It has concrete definitions in the following types:
9.1.1.1.10 Declarative Environment Record
9.1.1.2.10 Object Environment Record
9.1.1.3.4 Function Environment Record
9.1.1.4.10 Global Environment Record
WithBaseObject ( )
The abstract method WithBaseObject takes no arguments and returns an Object or
undefined
.
If this
Environment Record
is associated with a
with
statement, it returns the with object. Otherwise, it returns
undefined
.
It has concrete definitions in the following types:
9.1.1.1.11 Declarative Environment Record
9.1.1.2.11 Object Environment Record
9.1.1.4.11 Global Environment Record
9.1.1.1
Declarative Environment Records
Each
Declarative Environment Record
is associated with an ECMAScript program scope containing variable, constant, let, class, module, import, and/or function declarations. A Declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.
9.1.1.1.1
HasBinding (
N
)
The
HasBinding
concrete method of a
Declarative Environment Record
envRec
takes argument
N
(a String) and returns a
normal completion containing
a Boolean. It determines if the argument identifier is one of the identifiers bound by the record. It performs the following steps when called:
If
envRec
has a binding for
N
, return
true
.
Return
false
.
9.1.1.1.2
CreateMutableBinding (
N
,
D
)
The
CreateMutableBinding
concrete method of a
Declarative Environment Record
envRec
takes arguments
N
(a String) and
D
(a Boolean) and returns a
normal completion containing
unused
. It creates a new mutable binding for the name
N
that is uninitialized. A binding must not already exist in this
Environment Record
for
N
. If
D
is
true
, the new binding is marked as being subject to deletion. It performs the following steps when called:
Assert
:
envRec
does not already have a binding for
N
.
Create a mutable binding in
envRec
for
N
and record that it is uninitialized. If
D
is
true
, record that the newly created binding may be deleted by a subsequent
DeleteBinding
call.
Return
unused
.
9.1.1.1.3
CreateImmutableBinding (
N
,
S
)
The
CreateImmutableBinding
concrete method of a
Declarative Environment Record
envRec
takes arguments
N
(a String) and
S
(a Boolean) and returns a
normal completion containing
unused
. It creates a new immutable binding for the name
N
that is uninitialized. A binding must not already exist in this
Environment Record
for
N
. If
S
is
true
, the new binding is marked as a strict binding. It performs the following steps when called:
Assert
:
envRec
does not already have a binding for
N
.
Create an immutable binding in
envRec
for
N
and record that it is uninitialized. If
S
is
true
, record that the newly created binding is a strict binding.
Return
unused
.
9.1.1.1.4
InitializeBinding (
N
,
V
)
The
InitializeBinding
concrete method of a
Declarative Environment Record
envRec
takes arguments
N
(a String) and
V
(an
ECMAScript language value
) and returns a
normal completion containing
unused
. It is used to set the bound value of the current binding of the identifier whose name is
N
to the value
V
. An uninitialized binding for
N
must already exist. It performs the following steps when called:
Assert
:
envRec
must have an uninitialized binding for
N
.
Set the bound value for
N
in
envRec
to
V
.
Record
that the binding for
N
in
envRec
has been initialized.
Return
unused
.
9.1.1.1.5
SetMutableBinding (
N
,
V
,
S
)
The
SetMutableBinding
concrete method of a
Declarative Environment Record
envRec
takes arguments
N
(a String),
V
(an
ECMAScript language value
), and
S
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It attempts to change the bound value of the current binding of the identifier whose name is
N
to the value
V
. A binding for
N
normally already exists, but in rare cases it may not. If the binding is an immutable binding, a
TypeError
is thrown if
S
is
true
. It performs the following steps when called:
If
envRec
does not have a binding for
N
, then
If
S
is
true
, throw a
ReferenceError
exception.
Perform !
envRec
.
CreateMutableBinding
(
N
,
true
).
Perform !
envRec
.
InitializeBinding
(
N
,
V
).
Return
unused
.
If the binding for
N
in
envRec
is a strict binding, set
S
to
true
.
If the binding for
N
in
envRec
has not yet been initialized, then
Throw a
ReferenceError
exception.
Else if the binding for
N
in
envRec
is a mutable binding, then
Change its bound value to
V
.
Else,
Assert
: This is an attempt to change the value of an immutable binding.
If
S
is
true
, throw a
TypeError
exception.
Return
unused
.
Note
An example of ECMAScript code that results in a missing binding at step
1
is:
function
f
(
) {
eval
(
"var x; x = (delete x, 0);"
); }
9.1.1.1.6
GetBindingValue (
N
,
S
)
The
GetBindingValue
concrete method of a
Declarative Environment Record
envRec
takes arguments
N
(a String) and
S
(a Boolean) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It returns the value of its bound identifier whose name is
N
. If the binding exists but is uninitialized a
ReferenceError
is thrown, regardless of the value of
S
. It performs the following steps when called:
Assert
:
envRec
has a binding for
N
.
If the binding for
N
in
envRec
is an uninitialized binding, throw a
ReferenceError
exception.
Return the value currently bound to
N
in
envRec
.
9.1.1.1.7
DeleteBinding (
N
)
The
DeleteBinding
concrete method of a
Declarative Environment Record
envRec
takes argument
N
(a String) and returns a
normal completion containing
a Boolean. It can only delete bindings that have been explicitly designated as being subject to deletion. It performs the following steps when called:
Assert
:
envRec
has a binding for
N
.
If the binding for
N
in
envRec
cannot be deleted, return
false
.
Remove the binding for
N
from
envRec
.
Return
true
.
9.1.1.1.8
HasThisBinding ( )
The
HasThisBinding
concrete method of a
Declarative Environment Record
envRec
takes no arguments and returns
false
. It performs the following steps when called:
Return
false
.
Note
A regular
Declarative Environment Record
(i.e., one that is neither a
Function Environment Record
nor a
Module Environment Record
) does not provide a
this
binding.
9.1.1.1.9
GetThisBinding ( )
The
GetThisBinding
concrete method of a
Declarative Environment Record
is never used within this specification.
9.1.1.1.10
HasSuperBinding ( )
The
HasSuperBinding
concrete method of a
Declarative Environment Record
envRec
takes no arguments and returns
false
. It performs the following steps when called:
Return
false
.
Note
A regular
Declarative Environment Record
(i.e., one that is neither a
Function Environment Record
nor a
Module Environment Record
) does not provide a
super
binding.
9.1.1.1.11
WithBaseObject ( )
The
WithBaseObject
concrete method of a
Declarative Environment Record
envRec
takes no arguments and returns
undefined
. It performs the following steps when called:
Return
undefined
.
9.1.1.2
Object Environment Records
Each
Object Environment Record
is associated with an object called its
binding object
. An Object Environment Record binds the set of string identifier names that directly correspond to the
property names
of its binding object.
Property keys
that are not strings in the form of an
IdentifierName
are not included in the set of bound identifiers. Both own and inherited properties are included in the set regardless of the setting of their
[[Enumerable]]
attribute. Because properties can be dynamically added and deleted from objects, the set of identifiers bound by an Object Environment Record may potentially change as a side-effect of any operation that adds or deletes properties. Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the Writable attribute of the corresponding property is
false
. Immutable bindings do not exist for Object Environment Records.
Object Environment Records created for
with
statements (
14.11
) can provide their binding object as an implicit
this
value for use in function calls. The capability is controlled by a Boolean
[[IsWithEnvironment]]
field.
Object Environment Records have the additional state fields listed in
Table 15
.
Table 15: Additional Fields of
Object Environment Records
Field Name
Value
Meaning
[[BindingObject]]
an Object
The binding object of this
Environment Record
.
[[IsWithEnvironment]]
a Boolean
Indicates whether this
Environment Record
is created for a
with
statement.
9.1.1.2.1
HasBinding (
N
)
The
HasBinding
concrete method of an
Object Environment Record
envRec
takes argument
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
. It determines if its associated binding object has a property whose name is
N
. It performs the following steps when called:
Let
bindingObject
be
envRec
.
[[BindingObject]]
.
Let
foundBinding
be ?
HasProperty
(
bindingObject
,
N
).
If
foundBinding
is
false
, return
false
.
If
envRec
.
[[IsWithEnvironment]]
is
false
, return
true
.
Let
unscopables
be ?
Get
(
bindingObject
,
%Symbol.unscopables%
).
If
unscopables
is an Object
, then
Let
blocked
be
ToBoolean
(?
Get
(
unscopables
,
N
)).
If
blocked
is
true
, return
false
.
Return
true
.
9.1.1.2.2
CreateMutableBinding (
N
,
D
)
The
CreateMutableBinding
concrete method of an
Object Environment Record
envRec
takes arguments
N
(a String) and
D
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It creates in an
Environment Record
's associated binding object a property whose name is
N
and initializes it to the value
undefined
. If
D
is
true
, the new property's
[[Configurable]]
attribute is set to
true
; otherwise it is set to
false
. It performs the following steps when called:
Let
bindingObject
be
envRec
.
[[BindingObject]]
.
Perform ?
DefinePropertyOrThrow
(
bindingObject
,
N
, PropertyDescriptor {
[[Value]]
:
undefined
,
[[Writable]]
:
true
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
D
}).
Return
unused
.
Note
Normally
envRec
will not have a binding for
N
but if it does, the semantics of
DefinePropertyOrThrow
may result in an existing binding being replaced or shadowed or cause an
abrupt completion
to be returned.
9.1.1.2.3
CreateImmutableBinding (
N
,
S
)
The
CreateImmutableBinding
concrete method of an
Object Environment Record
is never used within this specification.
9.1.1.2.4
InitializeBinding (
N
,
V
)
The
InitializeBinding
concrete method of an
Object Environment Record
envRec
takes arguments
N
(a String) and
V
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It is used to set the bound value of the current binding of the identifier whose name is
N
to the value
V
. It performs the following steps when called:
Perform ?
envRec
.
SetMutableBinding
(
N
,
V
,
false
)
.
Return
unused
.
Note
In this specification, all uses of
CreateMutableBinding
for
Object Environment Records
are immediately followed by a call to
InitializeBinding
for the same name. Hence, this specification does not explicitly track the initialization state of bindings in
Object Environment Records
.
9.1.1.2.5
SetMutableBinding (
N
,
V
,
S
)
The
SetMutableBinding
concrete method of an
Object Environment Record
envRec
takes arguments
N
(a String),
V
(an
ECMAScript language value
), and
S
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It attempts to set the value of the
Environment Record
's associated binding object's property whose name is
N
to the value
V
. A property named
N
normally already exists but if it does not or is not currently writable, error handling is determined by
S
. It performs the following steps when called:
Let
bindingObject
be
envRec
.
[[BindingObject]]
.
Let
stillExists
be ?
HasProperty
(
bindingObject
,
N
).
If
stillExists
is
false
and
S
is
true
, throw a
ReferenceError
exception.
Perform ?
Set
(
bindingObject
,
N
,
V
,
S
).
Return
unused
.
9.1.1.2.6
GetBindingValue (
N
,
S
)
The
GetBindingValue
concrete method of an
Object Environment Record
envRec
takes arguments
N
(a String) and
S
(a Boolean) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It returns the value of its associated binding object's property whose name is
N
. The property should already exist but if it does not the result depends upon
S
. It performs the following steps when called:
Let
bindingObject
be
envRec
.
[[BindingObject]]
.
Let
value
be ?
HasProperty
(
bindingObject
,
N
).
If
value
is
false
, then
If
S
is
false
, return
undefined
; otherwise throw a
ReferenceError
exception.
Return ?
Get
(
bindingObject
,
N
).
9.1.1.2.7
DeleteBinding (
N
)
The
DeleteBinding
concrete method of an
Object Environment Record
envRec
takes argument
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
. It can only delete bindings that correspond to properties of the environment object whose
[[Configurable]]
attribute have the value
true
. It performs the following steps when called:
Let
bindingObject
be
envRec
.
[[BindingObject]]
.
Return ?
bindingObject
.
[[Delete]]
(
N
)
.
9.1.1.2.8
HasThisBinding ( )
The
HasThisBinding
concrete method of an
Object Environment Record
envRec
takes no arguments and returns
false
. It performs the following steps when called:
Return
false
.
Note
Object Environment Records
do not provide a
this
binding.
9.1.1.2.9
GetThisBinding ( )
The
GetThisBinding
concrete method of an
Object Environment Record
is never used within this specification.
9.1.1.2.10
HasSuperBinding ( )
The
HasSuperBinding
concrete method of an
Object Environment Record
envRec
takes no arguments and returns
false
. It performs the following steps when called:
Return
false
.
Note
Object Environment Records
do not provide a
super
binding.
9.1.1.2.11
WithBaseObject ( )
The
WithBaseObject
concrete method of an
Object Environment Record
envRec
takes no arguments and returns an Object or
undefined
. It performs the following steps when called:
If
envRec
.
[[IsWithEnvironment]]
is
true
, return
envRec
.
[[BindingObject]]
.
Otherwise, return
undefined
.
9.1.1.3
Function Environment Records
A
Function Environment Record
is a
Declarative Environment Record
that is used to represent the top-level scope of a function and, if the function is not an
ArrowFunction
, provides a
this
binding. If a function is not an
ArrowFunction
function and references
super
, its Function Environment Record also contains the state that is used to perform
super
method invocations from within the function.
Function Environment Records have the additional state fields listed in
Table 16
.
Table 16: Additional Fields of
Function Environment Records
Field Name
Value
Meaning
[[ThisValue]]
an
ECMAScript language value
This is the
this
value used for this invocation of the function.
[[ThisBindingStatus]]
lexical
,
initialized
, or
uninitialized
If the value is
lexical
, this is an
ArrowFunction
and does not have a local
this
value.
[[FunctionObject]]
an ECMAScript
function object
The
function object
whose invocation caused this
Environment Record
to be created.
[[NewTarget]]
a
constructor
or
undefined
If this
Environment Record
was created by the
[[Construct]]
internal method,
[[NewTarget]]
is the value of the
[[Construct]]
newTarget
parameter. Otherwise, its value is
undefined
.
Function Environment Records support all of the
Declarative Environment Record
methods listed in
Table 14
and share the same specifications for all of those methods except for
HasThisBinding
,
GetThisBinding
, and
HasSuperBinding
.
9.1.1.3.1
BindThisValue (
envRec
,
V
)
The abstract operation BindThisValue takes arguments
envRec
(a
Function Environment Record
) and
V
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It sets the
envRec
.
[[ThisValue]]
and records that it has been initialized. It performs the following steps when called:
Assert
:
envRec
.
[[ThisBindingStatus]]
is not
lexical
.
If
envRec
.
[[ThisBindingStatus]]
is
initialized
, throw a
ReferenceError
exception.
Set
envRec
.
[[ThisValue]]
to
V
.
Set
envRec
.
[[ThisBindingStatus]]
to
initialized
.
Return
unused
.
9.1.1.3.2
HasThisBinding ( )
The
HasThisBinding
concrete method of a
Function Environment Record
envRec
takes no arguments and returns a Boolean. It performs the following steps when called:
If
envRec
.
[[ThisBindingStatus]]
is
lexical
, return
false
; otherwise return
true
.
9.1.1.3.3
GetThisBinding ( )
The
GetThisBinding
concrete method of a
Function Environment Record
envRec
takes no arguments and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Assert
:
envRec
.
[[ThisBindingStatus]]
is not
lexical
.
If
envRec
.
[[ThisBindingStatus]]
is
uninitialized
, throw a
ReferenceError
exception.
Return
envRec
.
[[ThisValue]]
.
9.1.1.3.4
HasSuperBinding ( )
The
HasSuperBinding
concrete method of a
Function Environment Record
envRec
takes no arguments and returns a Boolean. It performs the following steps when called:
If
envRec
.
[[ThisBindingStatus]]
is
lexical
, return
false
.
If
envRec
.
[[FunctionObject]]
.
[[HomeObject]]
is
undefined
, return
false
; otherwise return
true
.
9.1.1.3.5
GetSuperBase (
envRec
)
The abstract operation GetSuperBase takes argument
envRec
(a
Function Environment Record
) and returns an Object,
null
, or
undefined
. It returns the object that is the base for
super
property accesses bound in
envRec
. The value
undefined
indicates that such accesses will produce runtime errors. It performs the following steps when called:
Let
home
be
envRec
.
[[FunctionObject]]
.
[[HomeObject]]
.
If
home
is
undefined
, return
undefined
.
Assert
:
home
is an
ordinary object
.
Return !
home
.
[[GetPrototypeOf]]
().
9.1.1.4
Global Environment Records
A
Global Environment Record
is used to represent the outer most scope that is shared by all of the ECMAScript
Script
elements that are processed in a common
realm
. A Global Environment Record provides the bindings for built-in globals (clause
19
), properties of the
global object
, and for all top-level declarations (
8.2.9
,
8.2.11
) that occur within a
Script
.
A Global Environment Record is logically a single record but it is specified as a composite encapsulating an
Object Environment Record
and a
Declarative Environment Record
. The
Object Environment Record
has as its base object the
global object
of the associated
Realm Record
. This
global object
is the value returned by the Global Environment Record's
GetThisBinding
concrete method. The
Object Environment Record
component of a Global Environment Record contains the bindings for all built-in globals (clause
19
) and all bindings introduced by a
FunctionDeclaration
,
GeneratorDeclaration
,
AsyncFunctionDeclaration
,
AsyncGeneratorDeclaration
, or
VariableStatement
contained in global code. The bindings for all other ECMAScript declarations in global code are contained in the
Declarative Environment Record
component of the Global Environment Record.
Properties may be created directly on a
global object
. Hence, the
Object Environment Record
component of a Global Environment Record may contain both bindings created explicitly by
FunctionDeclaration
,
GeneratorDeclaration
,
AsyncFunctionDeclaration
,
AsyncGeneratorDeclaration
, or
VariableDeclaration
declarations and bindings created implicitly as properties of the
global object
. In order to identify which bindings were explicitly created using declarations, a Global Environment Record maintains a list of the names bound using the
CreateGlobalVarBinding
and
CreateGlobalFunctionBinding
abstract operations
.
Global Environment Records have the additional fields listed in
Table 17
.
Table 17: Additional Fields of
Global Environment Records
Field Name
Value
Meaning
[[ObjectRecord]]
an
Object Environment Record
Binding object is the
global object
. It contains global built-in bindings as well as
FunctionDeclaration
,
GeneratorDeclaration
,
AsyncFunctionDeclaration
,
AsyncGeneratorDeclaration
, and
VariableDeclaration
bindings in global code for the associated
realm
.
[[GlobalThisValue]]
an Object
The value returned by
this
in global scope.
Hosts
may provide any ECMAScript Object value.
[[DeclarativeRecord]]
a
Declarative Environment Record
Contains
bindings for all declarations in global code for the associated
realm
code except for
FunctionDeclaration
,
GeneratorDeclaration
,
AsyncFunctionDeclaration
,
AsyncGeneratorDeclaration
, and
VariableDeclaration
bindings.
9.1.1.4.1
HasBinding (
N
)
The
HasBinding
concrete method of a
Global Environment Record
envRec
takes argument
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
. It determines if the argument identifier is one of the identifiers bound by the record. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
If !
DclRec
.
HasBinding
(
N
) is
true
, return
true
.
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Return ?
ObjRec
.
HasBinding
(
N
)
.
9.1.1.4.2
CreateMutableBinding (
N
,
D
)
The
CreateMutableBinding
concrete method of a
Global Environment Record
envRec
takes arguments
N
(a String) and
D
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It creates a new mutable binding for the name
N
that is uninitialized. The binding is created in the associated DeclarativeRecord. A binding for
N
must not already exist in the DeclarativeRecord. If
D
is
true
, the new binding is marked as being subject to deletion. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
If !
DclRec
.
HasBinding
(
N
) is
true
, throw a
TypeError
exception.
Return !
DclRec
.
CreateMutableBinding
(
N
,
D
).
9.1.1.4.3
CreateImmutableBinding (
N
,
S
)
The
CreateImmutableBinding
concrete method of a
Global Environment Record
envRec
takes arguments
N
(a String) and
S
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It creates a new immutable binding for the name
N
that is uninitialized. A binding must not already exist in this
Environment Record
for
N
. If
S
is
true
, the new binding is marked as a strict binding. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
If !
DclRec
.
HasBinding
(
N
) is
true
, throw a
TypeError
exception.
Return !
DclRec
.
CreateImmutableBinding
(
N
,
S
).
9.1.1.4.4
InitializeBinding (
N
,
V
)
The
InitializeBinding
concrete method of a
Global Environment Record
envRec
takes arguments
N
(a String) and
V
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It is used to set the bound value of the current binding of the identifier whose name is
N
to the value
V
. An uninitialized binding for
N
must already exist. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
If !
DclRec
.
HasBinding
(
N
) is
true
, then
Return !
DclRec
.
InitializeBinding
(
N
,
V
).
Assert
: If the binding exists, it must be in the
Object Environment Record
.
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Return ?
ObjRec
.
InitializeBinding
(
N
,
V
)
.
9.1.1.4.5
SetMutableBinding (
N
,
V
,
S
)
The
SetMutableBinding
concrete method of a
Global Environment Record
envRec
takes arguments
N
(a String),
V
(an
ECMAScript language value
), and
S
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It attempts to change the bound value of the current binding of the identifier whose name is
N
to the value
V
. If the binding is an immutable binding and
S
is
true
, a
TypeError
is thrown. A property named
N
normally already exists but if it does not or is not currently writable, error handling is determined by
S
. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
If !
DclRec
.
HasBinding
(
N
) is
true
, then
Return ?
DclRec
.
SetMutableBinding
(
N
,
V
,
S
).
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Return ?
ObjRec
.
SetMutableBinding
(
N
,
V
,
S
)
.
9.1.1.4.6
GetBindingValue (
N
,
S
)
The
GetBindingValue
concrete method of a
Global Environment Record
envRec
takes arguments
N
(a String) and
S
(a Boolean) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It returns the value of its bound identifier whose name is
N
. If the binding is an uninitialized binding throw a
ReferenceError
exception. A property named
N
normally already exists but if it does not or is not currently writable, error handling is determined by
S
. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
If !
DclRec
.
HasBinding
(
N
) is
true
, then
Return ?
DclRec
.
GetBindingValue
(
N
,
S
).
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Return ?
ObjRec
.
GetBindingValue
(
N
,
S
)
.
9.1.1.4.7
DeleteBinding (
N
)
The
DeleteBinding
concrete method of a
Global Environment Record
envRec
takes argument
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
. It can only delete bindings that have been explicitly designated as being subject to deletion. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
If !
DclRec
.
HasBinding
(
N
) is
true
, then
Return !
DclRec
.
DeleteBinding
(
N
).
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Let
globalObject
be
ObjRec
.
[[BindingObject]]
.
Let
existingProp
be ?
HasOwnProperty
(
globalObject
,
N
).
If
existingProp
is
true
, then
Return ?
ObjRec
.
DeleteBinding
(
N
)
.
Return
true
.
9.1.1.4.8
HasThisBinding ( )
The
HasThisBinding
concrete method of a
Global Environment Record
envRec
takes no arguments and returns
true
. It performs the following steps when called:
Return
true
.
Note
Global Environment Records
always provide a
this
binding.
9.1.1.4.9
GetThisBinding ( )
The
GetThisBinding
concrete method of a
Global Environment Record
envRec
takes no arguments and returns a
normal completion containing
an Object. It performs the following steps when called:
Return
envRec
.
[[GlobalThisValue]]
.
9.1.1.4.10
HasSuperBinding ( )
The
HasSuperBinding
concrete method of a
Global Environment Record
envRec
takes no arguments and returns
false
. It performs the following steps when called:
Return
false
.
Note
Global Environment Records
do not provide a
super
binding.
9.1.1.4.11
WithBaseObject ( )
The
WithBaseObject
concrete method of a
Global Environment Record
envRec
takes no arguments and returns
undefined
. It performs the following steps when called:
Return
undefined
.
9.1.1.4.12
HasLexicalDeclaration (
envRec
,
N
)
The abstract operation HasLexicalDeclaration takes arguments
envRec
(a
Global Environment Record
) and
N
(a String) and returns a Boolean. It determines if the argument identifier has a binding in
envRec
that was created using a lexical declaration such as a
LexicalDeclaration
or a
ClassDeclaration
. It performs the following steps when called:
Let
DclRec
be
envRec
.
[[DeclarativeRecord]]
.
Return !
DclRec
.
HasBinding
(
N
).
9.1.1.4.13
HasRestrictedGlobalProperty (
envRec
,
N
)
The abstract operation HasRestrictedGlobalProperty takes arguments
envRec
(a
Global Environment Record
) and
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
. It determines if the argument identifier is the name of a property of the
global object
that must not be shadowed by a global lexical binding. It performs the following steps when called:
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Let
globalObject
be
ObjRec
.
[[BindingObject]]
.
Let
existingProp
be ?
globalObject
.
[[GetOwnProperty]]
(
N
)
.
If
existingProp
is
undefined
, return
false
.
If
existingProp
.
[[Configurable]]
is
true
, return
false
.
Return
true
.
Note
Properties may exist upon a
global object
that were directly created rather than being declared using a var or function declaration. A global lexical binding may not be created that has the same name as a non-configurable property of the
global object
. The global property
"undefined"
is an example of such a property.
9.1.1.4.14
CanDeclareGlobalVar (
envRec
,
N
)
The abstract operation CanDeclareGlobalVar takes arguments
envRec
(a
Global Environment Record
) and
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
. It determines if a corresponding
CreateGlobalVarBinding
call would succeed if called for the same argument
N
. Redundant var declarations and var declarations for pre-existing
global object
properties are allowed. It performs the following steps when called:
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Let
globalObject
be
ObjRec
.
[[BindingObject]]
.
Let
hasProperty
be ?
HasOwnProperty
(
globalObject
,
N
).
If
hasProperty
is
true
, return
true
.
Return ?
IsExtensible
(
globalObject
).
9.1.1.4.15
CanDeclareGlobalFunction (
envRec
,
N
)
The abstract operation CanDeclareGlobalFunction takes arguments
envRec
(a
Global Environment Record
) and
N
(a String) and returns either a
normal completion containing
a Boolean or a
throw completion
. It determines if a corresponding
CreateGlobalFunctionBinding
call would succeed if called for the same argument
N
. It performs the following steps when called:
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Let
globalObject
be
ObjRec
.
[[BindingObject]]
.
Let
existingProp
be ?
globalObject
.
[[GetOwnProperty]]
(
N
)
.
If
existingProp
is
undefined
, return ?
IsExtensible
(
globalObject
).
If
existingProp
.
[[Configurable]]
is
true
, return
true
.
If
IsDataDescriptor
(
existingProp
) is
true
and
existingProp
has attribute values {
[[Writable]]
:
true
,
[[Enumerable]]
:
true
}, return
true
.
Return
false
.
9.1.1.4.16
CreateGlobalVarBinding (
envRec
,
N
,
D
)
The abstract operation CreateGlobalVarBinding takes arguments
envRec
(a
Global Environment Record
),
N
(a String), and
D
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It creates and initializes a mutable binding in the associated
Object Environment Record
. If a binding already exists, it is reused and assumed to be initialized. It performs the following steps when called:
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Let
globalObject
be
ObjRec
.
[[BindingObject]]
.
Let
hasProperty
be ?
HasOwnProperty
(
globalObject
,
N
).
Let
extensible
be ?
IsExtensible
(
globalObject
).
If
hasProperty
is
false
and
extensible
is
true
, then
Perform ?
ObjRec
.
CreateMutableBinding
(
N
,
D
)
.
Perform ?
ObjRec
.
InitializeBinding
(
N
,
undefined
)
.
Return
unused
.
9.1.1.4.17
CreateGlobalFunctionBinding (
envRec
,
N
,
V
,
D
)
The abstract operation CreateGlobalFunctionBinding takes arguments
envRec
(a
Global Environment Record
),
N
(a String),
V
(an
ECMAScript language value
), and
D
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It creates and initializes a mutable binding in the associated
Object Environment Record
. If a binding already exists, it is replaced. It performs the following steps when called:
Let
ObjRec
be
envRec
.
[[ObjectRecord]]
.
Let
globalObject
be
ObjRec
.
[[BindingObject]]
.
Let
existingProp
be ?
globalObject
.
[[GetOwnProperty]]
(
N
)
.
If
existingProp
is
undefined
or
existingProp
.
[[Configurable]]
is
true
, then
Let
desc
be the PropertyDescriptor {
[[Value]]
:
V
,
[[Writable]]
:
true
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
D
}.
Else,
Let
desc
be the PropertyDescriptor {
[[Value]]
:
V
}.
Perform ?
DefinePropertyOrThrow
(
globalObject
,
N
,
desc
).
Perform ?
Set
(
globalObject
,
N
,
V
,
false
).
Return
unused
.
Note
Global function declarations are always represented as own properties of the
global object
. If possible, an existing own property is reconfigured to have a standard set of attribute values. Step
7
is equivalent to what calling the
InitializeBinding
concrete method would do and if
globalObject
is a Proxy will produce the same sequence of Proxy trap calls.
9.1.1.5
Module Environment Records
A
Module Environment Record
is a
Declarative Environment Record
that is used to represent the outer scope of an ECMAScript
Module
. In additional to normal mutable and immutable bindings, Module Environment Records also provide immutable import bindings which are bindings that provide indirect access to a target binding that exists in another
Environment Record
.
Module Environment Records support all of the
Declarative Environment Record
methods listed in
Table 14
and share the same specifications for all of those methods except for
GetBindingValue
,
DeleteBinding
,
HasThisBinding
, and
GetThisBinding
.
9.1.1.5.1
GetBindingValue (
N
,
S
)
The
GetBindingValue
concrete method of a
Module Environment Record
envRec
takes arguments
N
(a String) and
S
(a Boolean) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It returns the value of its bound identifier whose name is
N
. However, if the binding is an indirect binding the value of the target binding is returned. If the binding exists but is uninitialized a
ReferenceError
is thrown. It performs the following steps when called:
Assert
:
S
is
true
.
Assert
:
envRec
has a binding for
N
.
If the binding for
N
is an indirect binding, then
Let
M
and
N2
be the indirection values provided when this binding for
N
was created.
Let
targetEnv
be
M
.
[[Environment]]
.
If
targetEnv
is
empty
, throw a
ReferenceError
exception.
Return ?
targetEnv
.
GetBindingValue
(
N2
,
true
)
.
If the binding for
N
in
envRec
is an uninitialized binding, throw a
ReferenceError
exception.
Return the value currently bound to
N
in
envRec
.
Note
S
will always be
true
because a
Module
is always
strict mode code
.
9.1.1.5.2
DeleteBinding (
N
)
The
DeleteBinding
concrete method of a
Module Environment Record
is never used within this specification.
Note
Module Environment Records
are only used within strict code and an
early error
rule prevents the delete operator, in strict code, from being applied to a
Reference Record
that would resolve to a
Module Environment Record
binding. See
13.5.1.1
.
9.1.1.5.3
HasThisBinding ( )
The
HasThisBinding
concrete method of a
Module Environment Record
envRec
takes no arguments and returns
true
. It performs the following steps when called:
Return
true
.
Note
Module Environment Records
always provide a
this
binding.
9.1.1.5.4
GetThisBinding ( )
The
GetThisBinding
concrete method of a
Module Environment Record
envRec
takes no arguments and returns a
normal completion containing
undefined
. It performs the following steps when called:
Return
undefined
.
9.1.1.5.5
CreateImportBinding (
envRec
,
N
,
M
,
N2
)
The abstract operation CreateImportBinding takes arguments
envRec
(a
Module Environment Record
),
N
(a String),
M
(a
Module Record
), and
N2
(a String) and returns
unused
. It creates a new initialized immutable indirect binding for the name
N
. A binding must not already exist in
envRec
for
N
.
N2
is the name of a binding that exists in
M
's
Module Environment Record
. Accesses to the value of the new binding will indirectly access the bound value of the target binding. It performs the following steps when called:
Assert
:
envRec
does not already have a binding for
N
.
Assert
: When
M
.
[[Environment]]
is instantiated, it will have a direct binding for
N2
.
Create an immutable indirect binding in
envRec
for
N
that references
M
and
N2
as its target binding and record that the binding is initialized.
Return
unused
.
9.1.2
Environment Record Operations
The following
abstract operations
are used in this specification to operate upon
Environment Records
:
9.1.2.1
GetIdentifierReference (
env
,
name
,
strict
)
The abstract operation GetIdentifierReference takes arguments
env
(an
Environment Record
or
null
),
name
(a String), and
strict
(a Boolean) and returns either a
normal completion containing
a
Reference Record
or a
throw completion
. It performs the following steps when called:
If
env
is
null
, then
Return the
Reference Record
{
[[Base]]
:
unresolvable
,
[[ReferencedName]]
:
name
,
[[Strict]]
:
strict
,
[[ThisValue]]
:
empty
}.
Let
exists
be ?
env
.
HasBinding
(
name
)
.
If
exists
is
true
, then
Return the
Reference Record
{
[[Base]]
:
env
,
[[ReferencedName]]
:
name
,
[[Strict]]
:
strict
,
[[ThisValue]]
:
empty
}.
Else,
Let
outer
be
env
.
[[OuterEnv]]
.
Return ?
GetIdentifierReference
(
outer
,
name
,
strict
).
9.1.2.2
NewDeclarativeEnvironment (
E
)
The abstract operation NewDeclarativeEnvironment takes argument
E
(an
Environment Record
or
null
) and returns a
Declarative Environment Record
. It performs the following steps when called:
Let
env
be a new
Declarative Environment Record
containing no bindings.
Set
env
.
[[OuterEnv]]
to
E
.
Return
env
.
9.1.2.3
NewObjectEnvironment (
O
,
W
,
E
)
The abstract operation NewObjectEnvironment takes arguments
O
(an Object),
W
(a Boolean), and
E
(an
Environment Record
or
null
) and returns an
Object Environment Record
. It performs the following steps when called:
Let
env
be a new
Object Environment Record
.
Set
env
.
[[BindingObject]]
to
O
.
Set
env
.
[[IsWithEnvironment]]
to
W
.
Set
env
.
[[OuterEnv]]
to
E
.
Return
env
.
9.1.2.4
NewFunctionEnvironment (
F
,
newTarget
)
The abstract operation NewFunctionEnvironment takes arguments
F
(an ECMAScript
function object
) and
newTarget
(an Object or
undefined
) and returns a
Function Environment Record
. It performs the following steps when called:
Let
env
be a new
Function Environment Record
containing no bindings.
Set
env
.
[[FunctionObject]]
to
F
.
If
F
.
[[ThisMode]]
is
lexical
, set
env
.
[[ThisBindingStatus]]
to
lexical
.
Else, set
env
.
[[ThisBindingStatus]]
to
uninitialized
.
Set
env
.
[[NewTarget]]
to
newTarget
.
Set
env
.
[[OuterEnv]]
to
F
.
[[Environment]]
.
Return
env
.
9.1.2.5
NewGlobalEnvironment (
G
,
thisValue
)
The abstract operation NewGlobalEnvironment takes arguments
G
(an Object) and
thisValue
(an Object) and returns a
Global Environment Record
. It performs the following steps when called:
Let
objRec
be
NewObjectEnvironment
(
G
,
false
,
null
).
Let
dclRec
be
NewDeclarativeEnvironment
(
null
).
Let
env
be a new
Global Environment Record
.
Set
env
.
[[ObjectRecord]]
to
objRec
.
Set
env
.
[[GlobalThisValue]]
to
thisValue
.
Set
env
.
[[DeclarativeRecord]]
to
dclRec
.
Set
env
.
[[OuterEnv]]
to
null
.
Return
env
.
9.1.2.6
NewModuleEnvironment (
E
)
The abstract operation NewModuleEnvironment takes argument
E
(an
Environment Record
) and returns a
Module Environment Record
. It performs the following steps when called:
Let
env
be a new
Module Environment Record
containing no bindings.
Set
env
.
[[OuterEnv]]
to
E
.
Return
env
.
9.2
PrivateEnvironment Records
A
PrivateEnvironment Record
is a specification mechanism used to track
Private Names
based upon the lexical nesting structure of
ClassDeclaration
s and
ClassExpression
s in ECMAScript code. They are similar to, but distinct from,
Environment Records
. Each
PrivateEnvironment Record
is associated with a
ClassDeclaration
or
ClassExpression
. Each time such a class is evaluated, a new
PrivateEnvironment Record
is created to record the
Private Names
declared by that class.
Each
PrivateEnvironment Record
has the fields defined in
Table 18
.
Table 18:
PrivateEnvironment Record
Fields
Field Name
Value Type
Meaning
[[OuterPrivateEnvironment]]
a
PrivateEnvironment Record
or
null
The
PrivateEnvironment Record
of the nearest containing class.
null
if the class with which this
PrivateEnvironment Record
is associated is not contained in any other class.
[[Names]]
a
List
of
Private Names
The
Private Names
declared by this class.
9.2.1
PrivateEnvironment Record Operations
The following
abstract operations
are used in this specification to operate upon
PrivateEnvironment Records
:
9.2.1.1
NewPrivateEnvironment (
outerPrivateEnv
)
The abstract operation NewPrivateEnvironment takes argument
outerPrivateEnv
(a
PrivateEnvironment Record
or
null
) and returns a
PrivateEnvironment Record
. It performs the following steps when called:
Let
names
be a new empty
List
.
Return the
PrivateEnvironment Record
{
[[OuterPrivateEnvironment]]
:
outerPrivateEnv
,
[[Names]]
:
names
}.
9.2.1.2
ResolvePrivateIdentifier (
privateEnv
,
identifier
)
The abstract operation ResolvePrivateIdentifier takes arguments
privateEnv
(a
PrivateEnvironment Record
) and
identifier
(a String) and returns a
Private Name
. It performs the following steps when called:
Let
names
be
privateEnv
.
[[Names]]
.
For each
Private Name
pn
of
names
, do
If
pn
.
[[Description]]
is
identifier
, then
Return
pn
.
Let
outerPrivateEnv
be
privateEnv
.
[[OuterPrivateEnvironment]]
.
Assert
:
outerPrivateEnv
is not
null
.
Return
ResolvePrivateIdentifier
(
outerPrivateEnv
,
identifier
).
9.3
Realms
Before it is evaluated, all ECMAScript code must be associated with a
realm
. Conceptually, a
realm
consists of a set of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of that global environment, and other associated state and resources.
A
realm
is represented in this specification as a
Realm Record
with the fields specified in
Table 19
:
Table 19:
Realm Record
Fields
Field Name
Value
Meaning
[[AgentSignifier]]
an
agent signifier
The
agent
that owns this
realm
[[Intrinsics]]
a
Record
whose field names are intrinsic keys and whose values are objects
The intrinsic values used by code associated with this
realm
[[GlobalObject]]
an Object
The
global object
for this
realm
[[GlobalEnv]]
a
Global Environment Record
The global environment for this
realm
[[TemplateMap]]
a
List
of
Records
with fields
[[Site]]
(a
TemplateLiteral
Parse Node
) and
[[Array]]
(an Array)
Template objects are canonicalized separately for each
realm
using its
Realm Record
's
[[TemplateMap]]
. Each
[[Site]]
value is a
Parse Node
that is a
TemplateLiteral
. The associated
[[Array]]
value is the corresponding template object that is passed to a tag function.
Note 1
Once a
Parse Node
becomes unreachable, the corresponding
[[Array]]
is also unreachable, and it would be unobservable if an implementation removed the pair from the
[[TemplateMap]]
list.
[[LoadedModules]]
a
List
of
LoadedModuleRequest Records
A map from the specifier strings imported by this
realm
to the resolved
Module Record
. The list does not contain two different
Records
r1
and
r2
such that
ModuleRequestsEqual
(
r1
,
r2
) is
true
.
Note 2
As mentioned in
HostLoadImportedModule
(
16.2.1.10 Note 1
),
[[LoadedModules]]
in
Realm Records
is only used when running an
import()
expression in a context where there is no
active script or module
.
[[HostDefined]]
anything (default value is
undefined
)
Field reserved for use by
hosts
that need to associate additional information with a
Realm Record
.
9.3.1
InitializeHostDefinedRealm ( )
The abstract operation InitializeHostDefinedRealm takes no arguments and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
realm
be a new
Realm Record
.
Perform
CreateIntrinsics
(
realm
).
Set
realm
.
[[AgentSignifier]]
to
AgentSignifier
().
Set
realm
.
[[TemplateMap]]
to a new empty
List
.
Let
newContext
be a new
execution context
.
Set the Function of
newContext
to
null
.
Set the
Realm
of
newContext
to
realm
.
Set the ScriptOrModule of
newContext
to
null
.
Push
newContext
onto the
execution context stack
;
newContext
is now the
running execution context
.
If the
host
requires use of a specific object to serve as
realm
's
global object
, then
Let
global
be such an object created in a
host-defined
manner.
Else,
Let
global
be
OrdinaryObjectCreate
(
realm
.
[[Intrinsics]]
.[[
%Object.prototype%
]]).
If the
host
requires that the
this
binding in
realm
's global scope return an object other than the
global object
, then
Let
thisValue
be such an object created in a
host-defined
manner.
Else,
Let
thisValue
be
global
.
Set
realm
.
[[GlobalObject]]
to
global
.
Set
realm
.
[[GlobalEnv]]
to
NewGlobalEnvironment
(
global
,
thisValue
).
Perform ?
SetDefaultGlobalBindings
(
realm
).
Create any
host-defined
global object
properties on
global
.
Return
unused
.
9.3.2
CreateIntrinsics (
realmRec
)
The abstract operation CreateIntrinsics takes argument
realmRec
(a
Realm Record
) and returns
unused
. It performs the following steps when called:
Set
realmRec
.
[[Intrinsics]]
to a new
Record
.
Set fields of
realmRec
.
[[Intrinsics]]
with the values listed in
Table 6
. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses
19
through
28
. All object property values are newly created object values. All values that are built-in
function objects
are created by performing
CreateBuiltinFunction
(
steps
,
length
,
name
,
slots
,
realmRec
,
prototype
,
async
) where
steps
is the definition of that function provided by this specification,
name
is the initial value of the function's
"name"
property,
length
is the initial value of the function's
"length"
property,
slots
is a list of the names, if any, of the function's specified internal slots,
prototype
is the specified value of the function's
[[Prototype]]
internal slot, and
async
is
true
if the function is described as “async” and
false
otherwise. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.
Perform
AddRestrictedFunctionProperties
(
realmRec
.
[[Intrinsics]]
.[[
%Function.prototype%
]],
realmRec
).
Return
unused
.
9.3.3
SetDefaultGlobalBindings (
realmRec
)
The abstract operation SetDefaultGlobalBindings takes argument
realmRec
(a
Realm Record
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
global
be
realmRec
.
[[GlobalObject]]
.
For each property of the Global Object specified in clause
19
, do
Let
name
be the String value of the
property name
.
Let
desc
be the fully populated data
Property Descriptor
for the property, containing the specified attributes for the property. For properties listed in
19.2
,
19.3
, or
19.4
the value of the
[[Value]]
attribute is the corresponding intrinsic object from
realmRec
.
Perform ?
DefinePropertyOrThrow
(
global
,
name
,
desc
).
Return
unused
.
9.4
Execution Contexts
An
execution context
is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation. At any point in time, there is at most one execution context per
agent
that is actually executing code. This is known as the
agent
's
running execution context
. All references to the
running execution context
in this specification denote the
running execution context
of the
surrounding agent
.
The
execution context stack
is used to track execution contexts. The
running execution context
is always the top element of this stack. A new execution context is created whenever control is transferred from the executable code associated with the currently
running execution context
to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the
running execution context
.
An execution context contains whatever implementation specific state is necessary to track the execution progress of its associated code. Each execution context has at least the state components listed in
Table 20
.
Table 20: State Components for All Execution Contexts
Component
Purpose
code evaluation state
Any state needed to perform, suspend, and resume evaluation of the code associated with this
execution context
.
Function
If this
execution context
is evaluating the code of a
function object
, then the value of this component is that
function object
. If the context is evaluating the code of a
Script
or
Module
, the value is
null
.
Realm
The
Realm Record
from which associated code accesses ECMAScript resources.
ScriptOrModule
The
Module Record
or
Script Record
from which associated code originates. If there is no originating script or module, as is the case for the original
execution context
created in
InitializeHostDefinedRealm
, the value is
null
.
Evaluation
of code by the
running execution context
may be suspended at various points defined within this specification. Once the
running execution context
has been suspended a different execution context may become the
running execution context
and commence evaluating its code. At some later time a suspended execution context may again become the
running execution context
and continue evaluating its code at the point where it had previously been suspended. Transition of the
running execution context
status among execution contexts usually occurs in stack-like last-in/first-out manner. However, some ECMAScript features require non-LIFO transitions of the
running execution context
.
The value of the
Realm
component of the
running execution context
is also called
the current Realm Record
. The value of the Function component of the
running execution context
is also called the
active function object
.
ECMAScript code execution contexts
have the additional state components listed in
Table 21
.
Table 21: Additional State Components for ECMAScript Code Execution Contexts
Component
Purpose
LexicalEnvironment
Identifies the
Environment Record
used to resolve identifier references made by code within this
execution context
.
VariableEnvironment
Identifies the
Environment Record
that holds bindings created by
VariableStatement
s within this
execution context
.
PrivateEnvironment
Identifies the
PrivateEnvironment Record
that holds
Private Names
created by
ClassElement
s in the nearest containing class.
null
if there is no containing class.
The LexicalEnvironment and VariableEnvironment components of an execution context are always
Environment Records
.
Execution contexts representing the evaluation of Generators have the additional state components listed in
Table 22
.
Table 22: Additional State Components for Generator Execution Contexts
Component
Purpose
Generator
The Generator that this
execution context
is evaluating.
In most situations only the
running execution context
(the top of the
execution context stack
) is directly manipulated by algorithms within this specification. Hence when the terms “LexicalEnvironment”, and “VariableEnvironment” are used without qualification they are in reference to those components of the
running execution context
.
An execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for ECMAScript code to directly access or observe an execution context.
9.4.1
GetActiveScriptOrModule ( )
The abstract operation GetActiveScriptOrModule takes no arguments and returns a
Script Record
, a
Module Record
, or
null
. It is used to determine the running script or module, based on the
running execution context
. It performs the following steps when called:
If the
execution context stack
is empty, return
null
.
Let
ec
be the topmost
execution context
on the
execution context stack
whose ScriptOrModule component is not
null
.
If no such
execution context
exists, return
null
; otherwise return
ec
's ScriptOrModule.
9.4.2
ResolveBinding (
name
[ ,
env
] )
The abstract operation ResolveBinding takes argument
name
(a String) and optional argument
env
(an
Environment Record
or
undefined
) and returns either a
normal completion containing
a
Reference Record
or a
throw completion
. It is used to determine the binding of
name
.
env
can be used to explicitly provide the
Environment Record
that is to be searched for the binding. It performs the following steps when called:
If
env
is not present or
env
is
undefined
, then
Set
env
to the
running execution context
's LexicalEnvironment.
Assert
:
env
is an
Environment Record
.
Let
strict
be
IsStrict
(the syntactic production that is being evaluated).
Return ?
GetIdentifierReference
(
env
,
name
,
strict
).
Note
The result of ResolveBinding is always a
Reference Record
whose
[[ReferencedName]]
field is
name
.
9.4.3
GetThisEnvironment ( )
The abstract operation GetThisEnvironment takes no arguments and returns an
Environment Record
. It finds the
Environment Record
that currently supplies the binding of the
keyword
this
. It performs the following steps when called:
Let
env
be the
running execution context
's LexicalEnvironment.
Repeat,
Let
exists
be
env
.
HasThisBinding
().
If
exists
is
true
, return
env
.
Let
outer
be
env
.
[[OuterEnv]]
.
Assert
:
outer
is not
null
.
Set
env
to
outer
.
Note
The loop in step
2
will always terminate because the list of environments always ends with the global environment which has a
this
binding.
9.4.4
ResolveThisBinding ( )
The abstract operation ResolveThisBinding takes no arguments and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It determines the binding of the
keyword
this
using the LexicalEnvironment of the
running execution context
. It performs the following steps when called:
Let
envRec
be
GetThisEnvironment
().
Return ?
envRec
.
GetThisBinding
().
9.4.5
GetNewTarget ( )
The abstract operation GetNewTarget takes no arguments and returns an Object or
undefined
. It determines the NewTarget value using the LexicalEnvironment of the
running execution context
. It performs the following steps when called:
Let
envRec
be
GetThisEnvironment
().
Assert
:
envRec
has a
[[NewTarget]]
field.
Return
envRec
.
[[NewTarget]]
.
9.4.6
GetGlobalObject ( )
The abstract operation GetGlobalObject takes no arguments and returns an Object. It returns the
global object
used by the currently
running execution context
. It performs the following steps when called:
Let
currentRealm
be
the current Realm Record
.
Return
currentRealm
.
[[GlobalObject]]
.
9.5
Jobs and Host Operations to Enqueue Jobs
A
Job
is an
Abstract Closure
with no parameters that initiates an ECMAScript computation when no other ECMAScript computation is currently in progress.
Jobs
are scheduled for execution by ECMAScript
host environments
in a particular
agent
. This specification describes the
host hooks
HostEnqueueGenericJob
,
HostEnqueueFinalizationRegistryCleanupJob
,
HostEnqueuePromiseJob
, and
HostEnqueueTimeoutJob
to schedule jobs. The
host hooks
in this specification are organized by the additional constraints imposed on the scheduling of jobs.
Hosts
may define additional
abstract operations
which schedule jobs. Such operations accept a
Job
Abstract Closure
and a
realm
(a
Realm Record
or
null
) as parameters. If a
Realm Record
is provided, these operations schedule the job to be performed at some future time in the provided
realm
, in the
agent
that owns the
realm
. If
null
is provided instead for the
realm
, then the job does not evaluate ECMAScript code. Their implementations must conform to the following requirements:
At some future point in time, when there is no running context in the
agent
for which the job is scheduled and that
agent
's
execution context stack
is empty, the implementation must:
Perform any
host-defined
preparation steps.
Invoke
the
Job
Abstract Closure
.
Perform any
host-defined
cleanup steps, after which the
execution context stack
must be empty.
Only one
Job
may be actively undergoing evaluation at any point in time in an
agent
.
Once evaluation of a
Job
starts, it must run to completion before evaluation of any other
Job
starts in an
agent
.
The
Abstract Closure
must return a
normal completion
, implementing its own handling of errors.
Note 1
Host environments
are not required to treat
Jobs
uniformly with respect to scheduling. For example, web browsers and Node.js treat Promise-handling
Jobs
as a higher priority than other work; future features may add
Jobs
that are not treated at such a high priority.
At any particular time,
scriptOrModule
(a
Script Record
, a
Module Record
, or
null
) is the
active script or module
if all of the following conditions are true:
GetActiveScriptOrModule
() is
scriptOrModule
.
If
scriptOrModule
is a
Script Record
or
Module Record
, let
ec
be the topmost
execution context
on the
execution context stack
whose ScriptOrModule component is
scriptOrModule
. The
Realm
component of
ec
is
scriptOrModule
.
[[Realm]]
.
At any particular time, an execution is
prepared to evaluate ECMAScript code
if all of the following conditions are true:
The
execution context stack
is not empty.
The
Realm
component of the topmost
execution context
on the
execution context stack
is a
Realm Record
.
Note 2
Host environments
may prepare an execution to evaluate code by pushing
execution contexts
onto the
execution context stack
. The specific steps are
implementation-defined
.
The specific choice of
Realm
is up to the
host environment
. This initial
execution context
and
Realm
is only in use before any callback function is invoked. When a callback function related to a
Job
, like a Promise handler, is invoked, the invocation pushes its own
execution context
and
Realm
.
Particular kinds of
Jobs
have additional conformance requirements.
9.5.1
JobCallback Records
A
JobCallback Record
is a
Record
value used to store a
function object
and a
host-defined
value.
Function objects
that are invoked via a
Job
enqueued by the
host
may have additional
host-defined
context. To propagate the state,
Job
Abstract Closures
should not capture and call
function objects
directly. Instead, use
HostMakeJobCallback
and
HostCallJobCallback
.
Note
The WHATWG HTML specification (
https://html.spec.whatwg.org/
), for example, uses the
host-defined
value to propagate the incumbent settings object for Promise callbacks.
JobCallback Records have the fields listed in
Table 23
.
Table 23:
JobCallback Record
Fields
Field Name
Value
Meaning
[[Callback]]
a
function object
The function to invoke when the
Job
is invoked.
[[HostDefined]]
anything (default value is
empty
)
Field reserved for use by
hosts
.
9.5.2
HostMakeJobCallback (
callback
)
The
host-defined
abstract operation HostMakeJobCallback takes argument
callback
(a
function object
) and returns a
JobCallback Record
.
An implementation of HostMakeJobCallback must conform to the following requirements:
It must return a
JobCallback Record
whose
[[Callback]]
field is
callback
.
The default implementation of HostMakeJobCallback performs the following steps when called:
Return the
JobCallback Record
{
[[Callback]]
:
callback
,
[[HostDefined]]
:
empty
}.
ECMAScript
hosts
that are not web browsers must use the default implementation of HostMakeJobCallback.
Note
This is called at the time that the callback is passed to the function that is responsible for its being eventually scheduled and run. For example,
promise.then(thenAction)
calls MakeJobCallback on
thenAction
at the time of invoking
Promise.prototype.then
, not at the time of scheduling the reaction
Job
.
9.5.3
HostCallJobCallback (
jobCallback
,
V
,
argumentsList
)
The
host-defined
abstract operation HostCallJobCallback takes arguments
jobCallback
(a
JobCallback Record
),
V
(an
ECMAScript language value
), and
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
.
An implementation of HostCallJobCallback must conform to the following requirements:
It must perform and return the result of
Call
(
jobCallback
.
[[Callback]]
,
V
,
argumentsList
).
Note
This requirement means that
hosts
cannot change the
[[Call]]
behaviour of
function objects
defined in this specification.
The default implementation of HostCallJobCallback performs the following steps when called:
Assert
:
IsCallable
(
jobCallback
.
[[Callback]]
) is
true
.
Return ?
Call
(
jobCallback
.
[[Callback]]
,
V
,
argumentsList
).
ECMAScript
hosts
that are not web browsers must use the default implementation of HostCallJobCallback.
9.5.4
HostEnqueueGenericJob (
job
,
realm
)
The
host-defined
abstract operation HostEnqueueGenericJob takes arguments
job
(a
Job
Abstract Closure
) and
realm
(a
Realm Record
) and returns
unused
. It schedules
job
in the
realm
realm
in the
agent
signified by
realm
.
[[AgentSignifier]]
to be performed at some future time. The
Abstract Closures
used with this algorithm are intended to be scheduled without additional constraints, such as priority and ordering.
An implementation of HostEnqueueGenericJob must conform to the requirements in
9.5
.
9.5.5
HostEnqueuePromiseJob (
job
,
realm
)
The
host-defined
abstract operation HostEnqueuePromiseJob takes arguments
job
(a
Job
Abstract Closure
) and
realm
(a
Realm Record
or
null
) and returns
unused
. It schedules
job
to be performed at some future time. The
Abstract Closures
used with this algorithm are intended to be related to the handling of Promises, or otherwise, to be scheduled with equal priority to Promise handling operations.
An implementation of HostEnqueuePromiseJob must conform to the requirements in
9.5
as well as the following:
If
realm
is not
null
, each time
job
is invoked the implementation must perform
implementation-defined
steps such that execution is
prepared to evaluate ECMAScript code
at the time of
job
's invocation.
Let
scriptOrModule
be
GetActiveScriptOrModule
() at the time HostEnqueuePromiseJob is invoked. If
realm
is not
null
, each time
job
is invoked the implementation must perform
implementation-defined
steps such that
scriptOrModule
is the
active script or module
at the time of
job
's invocation.
Jobs
must run in the same order as the HostEnqueuePromiseJob invocations that scheduled them.
Note
The
realm
for
Jobs
returned by
NewPromiseResolveThenableJob
is usually the result of calling
GetFunctionRealm
on the
then
function object
. The
realm
for
Jobs
returned by
NewPromiseReactionJob
is usually the result of calling
GetFunctionRealm
on the handler if the handler is not
undefined
. If the handler is
undefined
,
realm
is
null
. For both kinds of
Jobs
, when
GetFunctionRealm
completes abnormally (i.e. called on a revoked Proxy),
realm
is
the current Realm Record
at the time of the
GetFunctionRealm
call. When the
realm
is
null
, no user ECMAScript code will be evaluated and no new ECMAScript objects (e.g. Error objects) will be created. The WHATWG HTML specification (
https://html.spec.whatwg.org/
), for example, uses
realm
to check for the ability to run script and for the
entry
concept.
9.5.6
HostEnqueueTimeoutJob (
timeoutJob
,
realm
,
milliseconds
)
The
host-defined
abstract operation HostEnqueueTimeoutJob takes arguments
timeoutJob
(a
Job
Abstract Closure
),
realm
(a
Realm Record
), and
milliseconds
(a non-negative
finite
Number) and returns
unused
. It schedules
timeoutJob
in the
realm
realm
in the
agent
signified by
realm
.
[[AgentSignifier]]
to be performed after at least
milliseconds
milliseconds.
An implementation of HostEnqueueTimeoutJob must conform to the requirements in
9.5
.
9.6
Agents
An
agent
comprises a set of ECMAScript
execution contexts
, an
execution context stack
, a
running execution context
, an
Agent Record
, and an
executing thread
. Except for the
executing thread
, the constituents of an
agent
belong exclusively to that
agent
.
An
agent
's
executing thread
executes algorithmic steps on the
agent
's
execution contexts
independently of other
agents
, except that an
executing thread
may be used as the
executing thread
by multiple
agents
, provided none of the
agents
sharing the thread have an
Agent Record
whose
[[CanBlock]]
field is
true
.
Note 1
Some web browsers share a single
executing thread
across multiple unrelated tabs of a browser window, for example.
While an
agent
's
executing thread
is executing algorithmic steps, the
agent
is the
surrounding agent
for those steps. The steps use the
surrounding agent
to access the specification-level execution objects held within the
agent
: the
running execution context
, the
execution context stack
, and the
Agent Record
's fields.
An
agent signifier
is a globally-unique opaque value used to identify an
Agent
.
Table 24:
Agent Record
Fields
Field Name
Value
Meaning
[[LittleEndian]]
a Boolean
The default value computed for the
isLittleEndian
parameter when it is needed by the algorithms
GetValueFromBuffer
and
SetValueInBuffer
. The choice is
implementation-defined
and should be the alternative that is most efficient for the implementation.
[[CanBlock]]
a Boolean
Determines whether the
agent
can block or not.
[[Signifier]]
an
agent signifier
Uniquely identifies the
agent
within its
agent cluster
.
[[IsLockFree1]]
a Boolean
true
if atomic operations on one-
byte values
are lock-free,
false
otherwise.
[[IsLockFree2]]
a Boolean
true
if atomic operations on two-
byte values
are lock-free,
false
otherwise.
[[IsLockFree8]]
a Boolean
true
if atomic operations on eight-
byte values
are lock-free,
false
otherwise.
[[CandidateExecution]]
a
candidate execution
Record
See the
memory model
.
[[KeptAlive]]
a
List
of either Objects or Symbols
Initially a new empty
List
, representing the list of objects and/or symbols to be kept alive until the end of the current
Job
[[ModuleAsyncEvaluationCount]]
an
integer
Initially 0, used to assign unique incrementing values to the
[[AsyncEvaluationOrder]]
field of modules that are asynchronous or have asynchronous dependencies.
The values of
[[LittleEndian]]
,
[[Signifier]]
,
[[IsLockFree1]]
,
[[IsLockFree2]]
, and
[[IsLockFree8]]
cannot change.
Note 2
The values of
[[IsLockFree1]]
,
[[IsLockFree2]]
, and
[[IsLockFree8]]
are not necessarily determined by the hardware, but may also reflect implementation choices that can vary over time and between ECMAScript implementations.
There is no
[[IsLockFree4]]
field: 4-byte atomic operations are always lock-free.
In practice, if an atomic operation is implemented with any type of lock the operation is not lock-free. Lock-free does not imply wait-free: there is no upper bound on how many machine steps may be required to complete a lock-free atomic operation.
That an atomic access of size
n
is lock-free does not imply anything about the (perceived) atomicity of non-atomic accesses of size
n
, specifically, non-atomic accesses may still be performed as a sequence of several separate memory accesses. See
ReadSharedMemory
and
WriteSharedMemory
for details.
Note 3
An
agent
is a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation.
9.6.1
AgentSignifier ( )
The abstract operation AgentSignifier takes no arguments and returns an
agent signifier
. It performs the following steps when called:
Let
AR
be the
Agent Record
of the
surrounding agent
.
Return
AR
.
[[Signifier]]
.
9.6.2
AgentCanSuspend ( )
The abstract operation AgentCanSuspend takes no arguments and returns a Boolean. It performs the following steps when called:
Let
AR
be the
Agent Record
of the
surrounding agent
.
Return
AR
.
[[CanBlock]]
.
Note
In some environments it may not be reasonable for a given
agent
to suspend. For example, in a web browser environment, it may be reasonable to disallow suspending a document's main event handling thread, while still allowing workers' event handling threads to suspend.
9.6.3
IncrementModuleAsyncEvaluationCount ( )
The abstract operation IncrementModuleAsyncEvaluationCount takes no arguments and returns an
integer
. It performs the following steps when called:
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
count
be
AR
.
[[ModuleAsyncEvaluationCount]]
.
Set
AR
.
[[ModuleAsyncEvaluationCount]]
to
count
+ 1.
Return
count
.
Note
This value is only used to keep track of the relative evaluation order between pending modules. An implementation may unobservably reset
[[ModuleAsyncEvaluationCount]]
to 0 whenever there are no pending modules.
9.7
Agent Clusters
An
agent cluster
is a maximal set of
agents
that can communicate by operating on shared memory.
Note 1
Programs within different
agents
may share memory by unspecified means. At a minimum, the backing memory for SharedArrayBuffers can be shared among the
agents
in the cluster.
There may be
agents
that can communicate by message passing that cannot share memory; they are never in the same agent cluster.
Every
agent
belongs to exactly one agent cluster.
Note 2
The
agents
in a cluster need not all be alive at some particular point in time. If
agent
A
creates another
agent
B
, after which
A
terminates and
B
creates
agent
C
, the three
agents
are in the same cluster if
A
could share some memory with
B
and
B
could share some memory with
C
.
All
agents
within a cluster must have the same value for the
[[LittleEndian]]
field in their respective
Agent Records
.
Note 3
If different
agents
within an agent cluster have different values of
[[LittleEndian]]
it becomes hard to use shared memory for multi-byte data.
All
agents
within a cluster must have the same values for the
[[IsLockFree1]]
field in their respective
Agent Records
; similarly for the
[[IsLockFree2]]
and
[[IsLockFree8]]
fields.
All
agents
within a cluster must have different values for the
[[Signifier]]
field in their respective
Agent Records
.
An embedding may deactivate (stop forward progress) or activate (resume forward progress) an
agent
without the
agent
's knowledge or cooperation. If the embedding does so, it must not leave some
agents
in the cluster active while other
agents
in the cluster are deactivated indefinitely.
Note 4
The purpose of the preceding restriction is to avoid a situation where an
agent
deadlocks or starves because another
agent
has been deactivated. For example, if an HTML shared worker that has a lifetime independent of documents in any windows were allowed to share memory with the dedicated worker of such an independent document, and the document and its dedicated worker were to be deactivated while the dedicated worker holds a lock (say, the document is pushed into its window's history), and the shared worker then tries to acquire the lock, then the shared worker will be blocked until the dedicated worker is activated again, if ever. Meanwhile other workers trying to access the shared worker from other windows will starve.
The implication of the restriction is that it will not be possible to share memory between
agents
that don't belong to the same suspend/wake collective within the embedding.
An embedding may terminate an
agent
without any of the
agent
's cluster's other
agents
' prior knowledge or cooperation. If an
agent
is terminated not by programmatic action of its own or of another
agent
in the cluster but by forces external to the cluster, then the embedding must choose one of two strategies: Either terminate all the
agents
in the cluster, or provide reliable APIs that allow the
agents
in the cluster to coordinate so that at least one remaining member of the cluster will be able to detect the termination, with the termination data containing enough information to identify the
agent
that was terminated.
Note 5
Examples of that type of termination are: operating systems or users terminating
agents
that are running in separate processes; the embedding itself terminating an
agent
that is running in-process with the other
agents
when per-
agent
resource accounting indicates that the
agent
is runaway.
Each of the following specification values, and values transitively reachable from them, belong to exactly one agent cluster.
candidate execution
Record
Shared Data Block
WaiterList Record
Prior to any evaluation of any ECMAScript code by any
agent
in a cluster, the
[[CandidateExecution]]
field of the
Agent Record
for all
agents
in the cluster is set to the initial
candidate execution
. The initial
candidate execution
is an
empty candidate execution
whose
[[EventsRecords]]
field is a
List
containing, for each
agent
, an
Agent Events Record
whose
[[AgentSignifier]]
field is that
agent
's
agent signifier
, and whose
[[EventList]]
and
[[AgentSynchronizesWith]]
fields are empty
Lists
.
Note 6
All
agents
in an agent cluster share the same
candidate execution
in its
Agent Record
's
[[CandidateExecution]]
field. The
candidate execution
is a specification mechanism used by the
memory model
.
Note 7
An agent cluster is a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation.
9.8
Forward Progress
For an
agent
to
make forward progress
is for it to perform an evaluation step according to this specification.
An
agent
becomes
blocked
when its
running execution context
waits synchronously and indefinitely for an external event. Only
agents
whose
Agent Record
's
[[CanBlock]]
field is
true
can become blocked in this sense. An
unblocked
agent
is one that is not blocked.
Implementations must ensure that:
every unblocked
agent
with a dedicated
executing thread
eventually makes forward progress
in a set of
agents
that share an
executing thread
, one
agent
eventually makes forward progress
an
agent
does not cause another
agent
to become blocked except via explicit APIs that provide blocking.
Note
This, along with the liveness guarantee in the
memory model
, ensures that all
seq-cst
writes eventually become observable to all
agents
.
9.9
Processing Model of WeakRef and FinalizationRegistry Targets
9.9.1
Objectives
This specification does not make any guarantees that any object or symbol will be garbage collected. Objects or symbols which are not
live
may be released after long periods of time, or never at all. For this reason, this specification uses the term "may" when describing behaviour triggered by garbage collection.
The semantics of
WeakRefs
and
FinalizationRegistrys
is based on two operations which happen at particular points in time:
When
WeakRef.prototype.deref
is called, the referent (if
undefined
is not returned) is kept alive so that subsequent, synchronous accesses also return the same value. This list is reset when synchronous work is done using the
ClearKeptObjects
abstract operation.
When an object or symbol which is registered with a
FinalizationRegistry
becomes unreachable, a call of the
FinalizationRegistry
's cleanup callback may eventually be made, after synchronous ECMAScript execution completes. The
FinalizationRegistry
cleanup is performed with the
CleanupFinalizationRegistry
abstract operation.
Neither of these actions (
ClearKeptObjects
or
CleanupFinalizationRegistry
) may interrupt synchronous ECMAScript execution. Because
hosts
may assemble longer, synchronous ECMAScript execution runs, this specification defers the scheduling of
ClearKeptObjects
and
CleanupFinalizationRegistry
to the
host environment
.
Some ECMAScript implementations include garbage collector implementations which run in the background, including when ECMAScript is idle. Letting the
host environment
schedule
CleanupFinalizationRegistry
allows it to resume ECMAScript execution in order to run finalizer work, which may free up held values, reducing overall memory usage.
9.9.2
Liveness
For some set of objects and/or symbols
S
a
hypothetical WeakRef-oblivious
execution with respect to
S
is an execution whereby the abstract operation
WeakRefDeref
of a
WeakRef
whose referent is an element of
S
always returns
undefined
.
Note 1
WeakRef
-obliviousness, together with liveness, capture two notions. One, that a
WeakRef
itself does not keep its referent alive. Two, that cycles in liveness does not imply that a value is live. To be concrete, if determining
v
's liveness depends on determining the liveness of a
WeakRef
referent,
r
,
r
's liveness cannot assume
v
's liveness, which would be circular reasoning.
Note 2
WeakRef
-obliviousness is defined on sets of objects or symbols instead of individual values to account for cycles. If it were defined on individual values, then a
WeakRef
referent in a cycle will be considered live even though its identity is only observed via other
WeakRef
referents in the cycle.
Note 3
Colloquially, we say that an individual object or symbol is live if every set containing it is live.
At any point during evaluation, a set of objects and/or symbols
S
is considered
live
if either of the following conditions is met:
Any element in
S
is included in any
agent
's
[[KeptAlive]]
List
.
There exists a valid future hypothetical WeakRef-oblivious execution with respect to
S
that observes the identity of any value in
S
.
Note 4
The second condition above intends to capture the intuition that a value is live if its identity is observable via non-
WeakRef
means. A value's identity may be observed by observing a strict equality comparison or observing the value being used as key in a Map.
Note 5
Presence of an object or a symbol in a field, an internal slot, or a property does not imply that the value is live. For example if the value in question is never passed back to the program, then it cannot be observed.
This is the case for keys in a WeakMap, members of a WeakSet, as well as the
[[WeakRefTarget]]
and
[[UnregisterToken]]
fields of a
FinalizationRegistry
Cell record.
The above definition implies that, if a key in a WeakMap is not live, then its corresponding value is not necessarily live either.
Note 6
Liveness is the lower bound for guaranteeing which
WeakRefs
engines must not empty. Liveness as defined here is undecidable. In practice, engines use conservative approximations such as reachability. There is expected to be significant implementation leeway.
9.9.3
Execution
At any time, if a set of objects and/or symbols
S
is not
live
, an ECMAScript implementation may perform the following steps atomically:
For each element
value
of
S
, do
For each
WeakRef
ref
such that
ref
.
[[WeakRefTarget]]
is
value
, do
Set
ref
.
[[WeakRefTarget]]
to
empty
.
For each
FinalizationRegistry
fg
such that
fg
.
[[Cells]]
contains a
Record
cell
such that
cell
.
[[WeakRefTarget]]
is
value
, do
Set
cell
.
[[WeakRefTarget]]
to
empty
.
Optionally, perform
HostEnqueueFinalizationRegistryCleanupJob
(
fg
).
For each WeakMap
map
such that
map
.
[[WeakMapData]]
contains a
Record
r
such that
r
.
[[Key]]
is
value
, do
Set
r
.
[[Key]]
to
empty
.
Set
r
.
[[Value]]
to
empty
.
For each WeakSet
set
such that
set
.
[[WeakSetData]]
contains
value
, do
Replace the element of
set
.
[[WeakSetData]]
whose value is
value
with an element whose value is
empty
.
Note 1
Together with the definition of liveness, this clause prescribes optimizations that an implementation may apply regarding
WeakRefs
.
It is possible to access an object without observing its identity. Optimizations such as dead variable elimination and scalar replacement on properties of non-escaping objects whose identity is not observed are allowed. These optimizations are thus allowed to observably empty
WeakRefs
that point to such objects.
On the other hand, if an object's identity is observable, and that object is in the
[[WeakRefTarget]]
internal slot of a
WeakRef
, optimizations such as rematerialization that observably empty the
WeakRef
are prohibited.
Because calling
HostEnqueueFinalizationRegistryCleanupJob
is optional, registered objects in a
FinalizationRegistry
do not necessarily hold that
FinalizationRegistry
live
. Implementations may omit
FinalizationRegistry
callbacks for any reason, e.g., if the
FinalizationRegistry
itself becomes dead, or if the application is shutting down.
Note 2
Implementations are not obligated to empty
WeakRefs
for maximal sets of non-
live
objects or symbols.
If an implementation chooses a non-
live
set
S
in which to empty
WeakRefs
, this definition requires that it empties
WeakRefs
for all values in
S
simultaneously. In other words, it is not conformant for an implementation to empty a
WeakRef
pointing to a value
v
without emptying out other
WeakRefs
that, if not emptied, could result in an execution that observes the value of
v
.
9.9.4
Host Hooks
9.9.4.1
HostEnqueueFinalizationRegistryCleanupJob (
finalizationRegistry
)
The
host-defined
abstract operation HostEnqueueFinalizationRegistryCleanupJob takes argument
finalizationRegistry
(a
FinalizationRegistry
) and returns
unused
.
Let
cleanupJob
be a new
Job
Abstract Closure
with no parameters that captures
finalizationRegistry
and performs the following steps when called:
Let
cleanupResult
be
Completion
(
CleanupFinalizationRegistry
(
finalizationRegistry
)).
If
cleanupResult
is an
abrupt completion
, perform any
host-defined
steps for reporting the error.
Return
unused
.
An implementation of HostEnqueueFinalizationRegistryCleanupJob schedules
cleanupJob
to be performed at some future time, if possible. It must also conform to the requirements in
9.5
.
9.10
ClearKeptObjects ( )
The abstract operation ClearKeptObjects takes no arguments and returns
unused
. ECMAScript implementations are expected to call ClearKeptObjects when a synchronous sequence of ECMAScript executions completes. It performs the following steps when called:
Let
agentRecord
be the
surrounding agent
's
Agent Record
.
Set
agentRecord
.
[[KeptAlive]]
to a new empty
List
.
Return
unused
.
9.11
AddToKeptObjects (
value
)
The abstract operation AddToKeptObjects takes argument
value
(an Object or a Symbol) and returns
unused
. It performs the following steps when called:
Let
agentRecord
be the
surrounding agent
's
Agent Record
.
Append
value
to
agentRecord
.
[[KeptAlive]]
.
Return
unused
.
Note
When the abstract operation AddToKeptObjects is called with a target object or symbol, it adds the target to a list that will point strongly at the target until
ClearKeptObjects
is called.
9.12
CleanupFinalizationRegistry (
finalizationRegistry
)
The abstract operation CleanupFinalizationRegistry takes argument
finalizationRegistry
(a
FinalizationRegistry
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Assert
:
finalizationRegistry
has
[[Cells]]
and
[[CleanupCallback]]
internal slots.
Let
callback
be
finalizationRegistry
.
[[CleanupCallback]]
.
While
finalizationRegistry
.
[[Cells]]
contains a
Record
cell
such that
cell
.
[[WeakRefTarget]]
is
empty
, an implementation may perform the following steps:
Choose any such
cell
.
Remove
cell
from
finalizationRegistry
.
[[Cells]]
.
Perform ?
HostCallJobCallback
(
callback
,
undefined
, «
cell
.
[[HeldValue]]
»).
Return
unused
.
9.13
CanBeHeldWeakly (
v
)
The abstract operation CanBeHeldWeakly takes argument
v
(an
ECMAScript language value
) and returns a Boolean. It returns
true
if and only if
v
is suitable for use as a weak reference. Only values that are suitable for use as a weak reference may be a key of a WeakMap, an element of a WeakSet, the target of a
WeakRef
, or one of the targets of a
FinalizationRegistry
. It performs the following steps when called:
If
v
is an Object
, return
true
.
If
v
is a Symbol
and
KeyForSymbol
(
v
) is
undefined
, return
true
.
Return
false
.
Note
A language value without
language identity
can be manifested without prior reference and is unsuitable for use as a weak reference. A Symbol value produced by
Symbol.for
, unlike other Symbol values, does not have language identity and is unsuitable for use as a weak reference.
Well-known symbols
are likely to never be collected, but are nonetheless treated as suitable for use as a weak reference because they are limited in number and therefore manageable by a variety of implementation approaches. However, any value associated to a well-known symbol in a
live
WeakMap is unlikely to be collected and could “leak” memory resources in implementations.
10
Ordinary and Exotic Objects Behaviours
10.1
Ordinary Object Internal Methods and Internal Slots
All
ordinary objects
have an internal slot called
[[Prototype]]
. The value of this internal slot is either
null
or an object and is used for implementing inheritance. Assume a property named
P
is missing from an
ordinary object
O
but exists on its
[[Prototype]]
object. If
P
refers to a
data property
on the
[[Prototype]]
object,
O
inherits it for get access, making it behave as if
P
was a property of
O
. If
P
refers to a writable
data property
on the
[[Prototype]]
object, set access of
P
on
O
creates a new
data property
named
P
on
O
. If
P
refers to a non-writable
data property
on the
[[Prototype]]
object, set access of
P
on
O
fails. If
P
refers to an
accessor property
on the
[[Prototype]]
object, the accessor is inherited by
O
for both get access and set access.
Every
ordinary object
has a Boolean-valued
[[Extensible]]
internal slot which is used to fulfill the extensibility-related internal method invariants specified in
6.1.7.3
. Namely, once the value of an object's
[[Extensible]]
internal slot has been set to
false
, it is no longer possible to add properties to the object, to modify the value of the object's
[[Prototype]]
internal slot, or to subsequently change the value of
[[Extensible]]
to
true
.
In the following algorithm descriptions, assume
O
is an
ordinary object
,
P
is a
property key
value,
V
is any
ECMAScript language value
, and
Desc
is a
Property Descriptor
record.
Each
ordinary object
internal method delegates to a similarly-named abstract operation. If such an abstract operation depends on another internal method, then the internal method is invoked on
O
rather than calling the similarly-named abstract operation directly. These semantics ensure that
exotic objects
have their overridden internal methods invoked when
ordinary object
internal methods are applied to them.
10.1.1
[[GetPrototypeOf]]
( )
The
[[GetPrototypeOf]]
internal method of an
ordinary object
O
takes no arguments and returns a
normal completion containing
either an Object or
null
. It performs the following steps when called:
Return
OrdinaryGetPrototypeOf
(
O
).
10.1.1.1
OrdinaryGetPrototypeOf (
O
)
The abstract operation OrdinaryGetPrototypeOf takes argument
O
(an Object) and returns an Object or
null
. It performs the following steps when called:
Return
O
.
[[Prototype]]
.
10.1.2
[[SetPrototypeOf]]
(
V
)
The
[[SetPrototypeOf]]
internal method of an
ordinary object
O
takes argument
V
(an Object or
null
) and returns a
normal completion containing
a Boolean. It performs the following steps when called:
Return
OrdinarySetPrototypeOf
(
O
,
V
).
10.1.2.1
OrdinarySetPrototypeOf (
O
,
V
)
The abstract operation OrdinarySetPrototypeOf takes arguments
O
(an Object) and
V
(an Object or
null
) and returns a Boolean. It performs the following steps when called:
Let
current
be
O
.
[[Prototype]]
.
If
SameValue
(
V
,
current
) is
true
, return
true
.
Let
extensible
be
O
.
[[Extensible]]
.
If
extensible
is
false
, return
false
.
Let
p
be
V
.
Let
done
be
false
.
Repeat, while
done
is
false
,
If
p
is
null
, then
Set
done
to
true
.
Else if
SameValue
(
p
,
O
) is
true
, then
Return
false
.
Else,
If
p
.
[[GetPrototypeOf]]
is not the
ordinary object
internal method defined in
10.1.1
, set
done
to
true
.
Else, set
p
to
p
.
[[Prototype]]
.
Set
O
.
[[Prototype]]
to
V
.
Return
true
.
Note
The loop in step
7
guarantees that there will be no cycles in any prototype chain that only includes objects that use the
ordinary object
definitions for
[[GetPrototypeOf]]
and
[[SetPrototypeOf]]
.
10.1.3
[[IsExtensible]]
( )
The
[[IsExtensible]]
internal method of an
ordinary object
O
takes no arguments and returns a
normal completion containing
a Boolean. It performs the following steps when called:
Return
OrdinaryIsExtensible
(
O
).
10.1.3.1
OrdinaryIsExtensible (
O
)
The abstract operation OrdinaryIsExtensible takes argument
O
(an Object) and returns a Boolean. It performs the following steps when called:
Return
O
.
[[Extensible]]
.
10.1.4
[[PreventExtensions]]
( )
The
[[PreventExtensions]]
internal method of an
ordinary object
O
takes no arguments and returns a
normal completion containing
true
. It performs the following steps when called:
Return
OrdinaryPreventExtensions
(
O
).
10.1.4.1
OrdinaryPreventExtensions (
O
)
The abstract operation OrdinaryPreventExtensions takes argument
O
(an Object) and returns
true
. It performs the following steps when called:
Set
O
.
[[Extensible]]
to
false
.
Return
true
.
10.1.5
[[GetOwnProperty]]
(
P
)
The
[[GetOwnProperty]]
internal method of an
ordinary object
O
takes argument
P
(a
property key
) and returns a
normal completion containing
either a
Property Descriptor
or
undefined
. It performs the following steps when called:
Return
OrdinaryGetOwnProperty
(
O
,
P
).
10.1.5.1
OrdinaryGetOwnProperty (
O
,
P
)
The abstract operation OrdinaryGetOwnProperty takes arguments
O
(an Object) and
P
(a
property key
) and returns a
Property Descriptor
or
undefined
. It performs the following steps when called:
If
O
does not have an own property with key
P
, return
undefined
.
Let
D
be a newly created
Property Descriptor
with no fields.
Let
X
be
O
's own property whose key is
P
.
If
X
is a
data property
, then
Set
D
.
[[Value]]
to the value of
X
's
[[Value]]
attribute.
Set
D
.
[[Writable]]
to the value of
X
's
[[Writable]]
attribute.
Else,
Assert
:
X
is an
accessor property
.
Set
D
.
[[Get]]
to the value of
X
's
[[Get]]
attribute.
Set
D
.
[[Set]]
to the value of
X
's
[[Set]]
attribute.
Set
D
.
[[Enumerable]]
to the value of
X
's
[[Enumerable]]
attribute.
Set
D
.
[[Configurable]]
to the value of
X
's
[[Configurable]]
attribute.
Return
D
.
10.1.6
[[DefineOwnProperty]]
(
P
,
Desc
)
The
[[DefineOwnProperty]]
internal method of an
ordinary object
O
takes arguments
P
(a
property key
) and
Desc
(a
Property Descriptor
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Return ?
OrdinaryDefineOwnProperty
(
O
,
P
,
Desc
).
10.1.6.1
OrdinaryDefineOwnProperty (
O
,
P
,
Desc
)
The abstract operation OrdinaryDefineOwnProperty takes arguments
O
(an Object),
P
(a
property key
), and
Desc
(a
Property Descriptor
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Let
current
be ?
O
.
[[GetOwnProperty]]
(
P
)
.
Let
extensible
be ?
IsExtensible
(
O
).
Return
ValidateAndApplyPropertyDescriptor
(
O
,
P
,
extensible
,
Desc
,
current
).
10.1.6.2
IsCompatiblePropertyDescriptor (
Extensible
,
Desc
,
Current
)
The abstract operation IsCompatiblePropertyDescriptor takes arguments
Extensible
(a Boolean),
Desc
(a
Property Descriptor
), and
Current
(a
Property Descriptor
or
undefined
) and returns a Boolean. It performs the following steps when called:
Return
ValidateAndApplyPropertyDescriptor
(
undefined
,
""
,
Extensible
,
Desc
,
Current
).
10.1.6.3
ValidateAndApplyPropertyDescriptor (
O
,
P
,
extensible
,
Desc
,
current
)
The abstract operation ValidateAndApplyPropertyDescriptor takes arguments
O
(an Object or
undefined
),
P
(a
property key
),
extensible
(a Boolean),
Desc
(a
Property Descriptor
), and
current
(a
Property Descriptor
or
undefined
) and returns a Boolean. It returns
true
if and only if
Desc
can be applied as the property of an object with specified
extensibility
and current property
current
while upholding
invariants
. When such application is possible and
O
is not
undefined
, it is performed for the property named
P
(which is created if necessary). It performs the following steps when called:
Assert
:
P
is a
property key
.
If
current
is
undefined
, then
If
extensible
is
false
, return
false
.
If
O
is
undefined
, return
true
.
If
IsAccessorDescriptor
(
Desc
) is
true
, then
Create an own
accessor property
named
P
of object
O
whose
[[Get]]
,
[[Set]]
,
[[Enumerable]]
, and
[[Configurable]]
attributes are set to the value of the corresponding field in
Desc
if
Desc
has that field, or to the attribute's
default value
otherwise.
Else,
Create an own
data property
named
P
of object
O
whose
[[Value]]
,
[[Writable]]
,
[[Enumerable]]
, and
[[Configurable]]
attributes are set to the value of the corresponding field in
Desc
if
Desc
has that field, or to the attribute's
default value
otherwise.
Return
true
.
Assert
:
current
is a
fully populated Property Descriptor
.
If
Desc
does not have any fields, return
true
.
If
current
.
[[Configurable]]
is
false
, then
If
Desc
has a
[[Configurable]]
field and
Desc
.
[[Configurable]]
is
true
, return
false
.
If
Desc
has an
[[Enumerable]]
field and
Desc
.
[[Enumerable]]
is not
current
.
[[Enumerable]]
, return
false
.
If
IsGenericDescriptor
(
Desc
) is
false
and
IsAccessorDescriptor
(
Desc
) is not
IsAccessorDescriptor
(
current
), return
false
.
If
IsAccessorDescriptor
(
current
) is
true
, then
If
Desc
has a
[[Get]]
field and
SameValue
(
Desc
.
[[Get]]
,
current
.
[[Get]]
) is
false
, return
false
.
If
Desc
has a
[[Set]]
field and
SameValue
(
Desc
.
[[Set]]
,
current
.
[[Set]]
) is
false
, return
false
.
Else if
current
.
[[Writable]]
is
false
, then
If
Desc
has a
[[Writable]]
field and
Desc
.
[[Writable]]
is
true
, return
false
.
NOTE:
SameValue
returns
true
for
NaN
values which may be distinguishable by other means. Returning here ensures that any existing property of
O
remains unmodified.
If
Desc
has a
[[Value]]
field, return
SameValue
(
Desc
.
[[Value]]
,
current
.
[[Value]]
).
If
O
is not
undefined
, then
If
IsDataDescriptor
(
current
) is
true
and
IsAccessorDescriptor
(
Desc
) is
true
, then
If
Desc
has a
[[Configurable]]
field, let
configurable
be
Desc
.
[[Configurable]]
; else let
configurable
be
current
.
[[Configurable]]
.
If
Desc
has an
[[Enumerable]]
field, let
enumerable
be
Desc
.
[[Enumerable]]
; else let
enumerable
be
current
.
[[Enumerable]]
.
Replace the property named
P
of object
O
with an
accessor property
whose
[[Configurable]]
and
[[Enumerable]]
attributes are set to
configurable
and
enumerable
, respectively, and whose
[[Get]]
and
[[Set]]
attributes are set to the value of the corresponding field in
Desc
if
Desc
has that field, or to the attribute's
default value
otherwise.
Else if
IsAccessorDescriptor
(
current
) is
true
and
IsDataDescriptor
(
Desc
) is
true
, then
If
Desc
has a
[[Configurable]]
field, let
configurable
be
Desc
.
[[Configurable]]
; else let
configurable
be
current
.
[[Configurable]]
.
If
Desc
has an
[[Enumerable]]
field, let
enumerable
be
Desc
.
[[Enumerable]]
; else let
enumerable
be
current
.
[[Enumerable]]
.
Replace the property named
P
of object
O
with a
data property
whose
[[Configurable]]
and
[[Enumerable]]
attributes are set to
configurable
and
enumerable
, respectively, and whose
[[Value]]
and
[[Writable]]
attributes are set to the value of the corresponding field in
Desc
if
Desc
has that field, or to the attribute's
default value
otherwise.
Else,
For each field of
Desc
, set the corresponding attribute of the property named
P
of object
O
to the value of the field.
Return
true
.
10.1.7
[[HasProperty]]
(
P
)
The
[[HasProperty]]
internal method of an
ordinary object
O
takes argument
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Return ?
OrdinaryHasProperty
(
O
,
P
).
10.1.7.1
OrdinaryHasProperty (
O
,
P
)
The abstract operation OrdinaryHasProperty takes arguments
O
(an Object) and
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Let
hasOwn
be ?
O
.
[[GetOwnProperty]]
(
P
)
.
If
hasOwn
is not
undefined
, return
true
.
Let
parent
be ?
O
.
[[GetPrototypeOf]]
()
.
If
parent
is not
null
, then
Return ?
parent
.
[[HasProperty]]
(
P
)
.
Return
false
.
10.1.8
[[Get]]
(
P
,
Receiver
)
The
[[Get]]
internal method of an
ordinary object
O
takes arguments
P
(a
property key
) and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Return ?
OrdinaryGet
(
O
,
P
,
Receiver
).
10.1.8.1
OrdinaryGet (
O
,
P
,
Receiver
)
The abstract operation OrdinaryGet takes arguments
O
(an Object),
P
(a
property key
), and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
desc
be ?
O
.
[[GetOwnProperty]]
(
P
)
.
If
desc
is
undefined
, then
Let
parent
be ?
O
.
[[GetPrototypeOf]]
()
.
If
parent
is
null
, return
undefined
.
Return ?
parent
.
[[Get]]
(
P
,
Receiver
)
.
If
IsDataDescriptor
(
desc
) is
true
, return
desc
.
[[Value]]
.
Assert
:
IsAccessorDescriptor
(
desc
) is
true
.
Let
getter
be
desc
.
[[Get]]
.
If
getter
is
undefined
, return
undefined
.
Return ?
Call
(
getter
,
Receiver
).
10.1.9
[[Set]]
(
P
,
V
,
Receiver
)
The
[[Set]]
internal method of an
ordinary object
O
takes arguments
P
(a
property key
),
V
(an
ECMAScript language value
), and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Return ?
OrdinarySet
(
O
,
P
,
V
,
Receiver
).
10.1.9.1
OrdinarySet (
O
,
P
,
V
,
Receiver
)
The abstract operation OrdinarySet takes arguments
O
(an Object),
P
(a
property key
),
V
(an
ECMAScript language value
), and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Let
ownDesc
be ?
O
.
[[GetOwnProperty]]
(
P
)
.
Return ?
OrdinarySetWithOwnDescriptor
(
O
,
P
,
V
,
Receiver
,
ownDesc
).
10.1.9.2
OrdinarySetWithOwnDescriptor (
O
,
P
,
V
,
Receiver
,
ownDesc
)
The abstract operation OrdinarySetWithOwnDescriptor takes arguments
O
(an Object),
P
(a
property key
),
V
(an
ECMAScript language value
),
Receiver
(an
ECMAScript language value
), and
ownDesc
(a
Property Descriptor
or
undefined
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
ownDesc
is
undefined
, then
Let
parent
be ?
O
.
[[GetPrototypeOf]]
()
.
If
parent
is not
null
, then
Return ?
parent
.
[[Set]]
(
P
,
V
,
Receiver
)
.
Else,
Set
ownDesc
to the PropertyDescriptor {
[[Value]]
:
undefined
,
[[Writable]]
:
true
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
true
}.
If
IsDataDescriptor
(
ownDesc
) is
true
, then
If
ownDesc
.
[[Writable]]
is
false
, return
false
.
If
Receiver
is not an Object
, return
false
.
Let
existingDescriptor
be ?
Receiver
.
[[GetOwnProperty]]
(
P
)
.
If
existingDescriptor
is not
undefined
, then
If
IsAccessorDescriptor
(
existingDescriptor
) is
true
, return
false
.
If
existingDescriptor
.
[[Writable]]
is
false
, return
false
.
Let
valueDesc
be the PropertyDescriptor {
[[Value]]
:
V
}.
Return ?
Receiver
.
[[DefineOwnProperty]]
(
P
,
valueDesc
)
.
Else,
Assert
:
Receiver
does not currently have a property
P
.
Return ?
CreateDataProperty
(
Receiver
,
P
,
V
).
Assert
:
IsAccessorDescriptor
(
ownDesc
) is
true
.
Let
setter
be
ownDesc
.
[[Set]]
.
If
setter
is
undefined
, return
false
.
Perform ?
Call
(
setter
,
Receiver
, «
V
»).
Return
true
.
10.1.10
[[Delete]]
(
P
)
The
[[Delete]]
internal method of an
ordinary object
O
takes argument
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Return ?
OrdinaryDelete
(
O
,
P
).
10.1.10.1
OrdinaryDelete (
O
,
P
)
The abstract operation OrdinaryDelete takes arguments
O
(an Object) and
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Let
desc
be ?
O
.
[[GetOwnProperty]]
(
P
)
.
If
desc
is
undefined
, return
true
.
If
desc
.
[[Configurable]]
is
true
, then
Remove the own property with name
P
from
O
.
Return
true
.
Return
false
.
10.1.11
[[OwnPropertyKeys]]
( )
The
[[OwnPropertyKeys]]
internal method of an
ordinary object
O
takes no arguments and returns a
normal completion containing
a
List
of
property keys
. It performs the following steps when called:
Return
OrdinaryOwnPropertyKeys
(
O
).
10.1.11.1
OrdinaryOwnPropertyKeys (
O
)
The abstract operation OrdinaryOwnPropertyKeys takes argument
O
(an Object) and returns a
List
of
property keys
. It performs the following steps when called:
Let
keys
be a new empty
List
.
For each own
property key
P
of
O
such that
P
is an
array index
, in ascending numeric index order, do
Append
P
to
keys
.
For each own
property key
P
of
O
such that
P
is a String
and
P
is not an
array index
, in ascending chronological order of property creation, do
Append
P
to
keys
.
For each own
property key
P
of
O
such that
P
is a Symbol
, in ascending chronological order of property creation, do
Append
P
to
keys
.
Return
keys
.
10.1.12
OrdinaryObjectCreate (
proto
[ ,
additionalInternalSlotsList
] )
The abstract operation OrdinaryObjectCreate takes argument
proto
(an Object or
null
) and optional argument
additionalInternalSlotsList
(a
List
of names of internal slots) and returns an Object. It is used to specify the runtime creation of new
ordinary objects
.
additionalInternalSlotsList
contains the names of additional internal slots that must be defined as part of the object, beyond
[[Prototype]]
and
[[Extensible]]
. If
additionalInternalSlotsList
is not provided, a new empty
List
is used. It performs the following steps when called:
Let
internalSlotsList
be «
[[Prototype]]
,
[[Extensible]]
».
If
additionalInternalSlotsList
is present, set
internalSlotsList
to the
list-concatenation
of
internalSlotsList
and
additionalInternalSlotsList
.
Let
O
be
MakeBasicObject
(
internalSlotsList
).
Set
O
.
[[Prototype]]
to
proto
.
Return
O
.
Note
Although OrdinaryObjectCreate does little more than call
MakeBasicObject
, its use communicates the intention to create an
ordinary object
, and not an exotic one. Thus, within this specification, it is not called by any algorithm that subsequently modifies the internal methods of the object in ways that would make the result non-ordinary. Operations that create
exotic objects
invoke
MakeBasicObject
directly.
10.1.13
OrdinaryCreateFromConstructor (
constructor
,
intrinsicDefaultProto
[ ,
internalSlotsList
] )
The abstract operation OrdinaryCreateFromConstructor takes arguments
constructor
(a
function object
) and
intrinsicDefaultProto
(a String) and optional argument
internalSlotsList
(a
List
of names of internal slots) and returns either a
normal completion containing
an Object or a
throw completion
. It creates an
ordinary object
whose
[[Prototype]]
value is retrieved from a
constructor
's
"prototype"
property, if it exists. Otherwise the intrinsic named by
intrinsicDefaultProto
is used for
[[Prototype]]
.
internalSlotsList
contains the names of additional internal slots that must be defined as part of the object. If
internalSlotsList
is not provided, a new empty
List
is used. It performs the following steps when called:
Assert
:
intrinsicDefaultProto
is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the
[[Prototype]]
value of an object.
Let
proto
be ?
GetPrototypeFromConstructor
(
constructor
,
intrinsicDefaultProto
).
If
internalSlotsList
is present, let
slotsList
be
internalSlotsList
.
Else, let
slotsList
be a new empty
List
.
Return
OrdinaryObjectCreate
(
proto
,
slotsList
).
10.1.14
GetPrototypeFromConstructor (
constructor
,
intrinsicDefaultProto
)
The abstract operation GetPrototypeFromConstructor takes arguments
constructor
(a
function object
) and
intrinsicDefaultProto
(a String) and returns either a
normal completion containing
an Object or a
throw completion
. It determines the
[[Prototype]]
value that should be used to create an object corresponding to a specific
constructor
. The value is retrieved from the
constructor
's
"prototype"
property, if it exists. Otherwise the intrinsic named by
intrinsicDefaultProto
is used for
[[Prototype]]
. It performs the following steps when called:
Assert
:
intrinsicDefaultProto
is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the
[[Prototype]]
value of an object.
Let
proto
be ?
Get
(
constructor
,
"prototype"
).
If
proto
is not an Object
, then
Let
realm
be ?
GetFunctionRealm
(
constructor
).
Set
proto
to
realm
's intrinsic object named
intrinsicDefaultProto
.
Return
proto
.
Note
If
constructor
does not supply a
[[Prototype]]
value, the default value that is used is obtained from the
realm
of the
constructor
function rather than from the
running execution context
.
10.1.15
RequireInternalSlot (
O
,
internalSlot
)
The abstract operation RequireInternalSlot takes arguments
O
(an
ECMAScript language value
) and
internalSlot
(an internal slot name) and returns either a
normal completion containing
unused
or a
throw completion
. It throws an exception unless
O
is an Object
and has the given internal slot. It performs the following steps when called:
If
O
is not an Object
, throw a
TypeError
exception.
If
O
does not have an
internalSlot
internal slot, throw a
TypeError
exception.
Return
unused
.
10.2
ECMAScript Function Objects
ECMAScript
function objects
encapsulate parameterized ECMAScript code closed over a lexical environment and support the dynamic evaluation of that code. An ECMAScript
function object
is an
ordinary object
and has the same internal slots and the same internal methods as other
ordinary objects
. The code of an ECMAScript
function object
may be either
strict mode code
(
11.2.2
) or
non-strict code
. An ECMAScript
function object
whose code is
strict mode code
is called a
strict function
. One whose code is not
strict mode code
is called a
non-strict function
.
In addition to
[[Extensible]]
and
[[Prototype]]
, ECMAScript
function objects
also have the internal slots listed in
Table 25
.
Table 25: Internal Slots of ECMAScript Function Objects
Internal Slot
Type
Description
[[Environment]]
an
Environment Record
The
Environment Record
that the function was closed over. Used as the outer environment when evaluating the code of the function.
[[PrivateEnvironment]]
a
PrivateEnvironment Record
or
null
The
PrivateEnvironment Record
for
Private Names
that the function was closed over.
null
if this function is not syntactically contained within a class. Used as the outer PrivateEnvironment for inner classes when evaluating the code of the function.
[[FormalParameters]]
a
Parse Node
The root parse node of the source text that defines the function's formal parameter list.
[[ECMAScriptCode]]
a
Parse Node
The root parse node of the source text that defines the function's body.
[[ConstructorKind]]
base
or
derived
Whether or not the function is a derived class
constructor
.
[[Realm]]
a
Realm Record
The
realm
in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
[[ScriptOrModule]]
a
Script Record
or a
Module Record
The script or module in which the function was created.
[[ThisMode]]
lexical
,
strict
, or
global
Defines how
this
references are interpreted within the formal parameters and code body of the function.
lexical
means that
this
refers to the
this
value of a lexically enclosing function.
strict
means that the
this
value is used exactly as provided by an invocation of the function.
global
means that a
this
value of
undefined
or
null
is interpreted as a reference to the
global object
, and any other
this
value is first passed to
ToObject
.
[[Strict]]
a Boolean
true
if this is a
strict function
,
false
if this is a
non-strict function
.
[[HomeObject]]
an Object
If the function uses
super
, this is the object whose
[[GetPrototypeOf]]
provides the object where
super
property lookups begin.
[[SourceText]]
a sequence of Unicode code points
The
source text
that defines the function.
[[Fields]]
a
List
of
ClassFieldDefinition Records
If the function is a class, this is a list of
Records
representing the non-static fields and corresponding initializers of the class.
[[PrivateMethods]]
a
List
of
PrivateElements
If the function is a class, this is a list representing the non-static private methods and accessors of the class.
[[ClassFieldInitializerName]]
a String, a Symbol, a
Private Name
, or
empty
If the function is created as the initializer of a class field, the name to use for
NamedEvaluation
of the field;
empty
otherwise.
[[IsClassConstructor]]
a Boolean
Indicates whether the function is a class
constructor
. (If
true
, invoking the function's
[[Call]]
will immediately throw a
TypeError
exception.)
All ECMAScript
function objects
have the
[[Call]]
internal method defined here. ECMAScript functions that are also
constructors
in addition have the
[[Construct]]
internal method.
10.2.1
[[Call]]
(
thisArgument
,
argumentsList
)
The
[[Call]]
internal method of an ECMAScript
function object
F
takes arguments
thisArgument
(an
ECMAScript language value
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
callerContext
be the
running execution context
.
Let
calleeContext
be
PrepareForOrdinaryCall
(
F
,
undefined
).
Assert
:
calleeContext
is now the
running execution context
.
If
F
.
[[IsClassConstructor]]
is
true
, then
Let
error
be a newly created
TypeError
object.
NOTE:
error
is created in
calleeContext
with
F
's associated
Realm Record
.
Remove
calleeContext
from the
execution context stack
and restore
callerContext
as the
running execution context
.
Return
ThrowCompletion
(
error
).
Perform
OrdinaryCallBindThis
(
F
,
calleeContext
,
thisArgument
).
Let
result
be
Completion
(
OrdinaryCallEvaluateBody
(
F
,
argumentsList
)).
Remove
calleeContext
from the
execution context stack
and restore
callerContext
as the
running execution context
.
If
result
is a
return completion
, return
result
.
[[Value]]
.
Assert
:
result
is a
throw completion
.
Return ?
result
.
Note
When
calleeContext
is removed from the
execution context stack
in step
7
it must not be destroyed if it is suspended and retained for later resumption by an accessible Generator.
10.2.1.1
PrepareForOrdinaryCall (
F
,
newTarget
)
The abstract operation PrepareForOrdinaryCall takes arguments
F
(an ECMAScript
function object
) and
newTarget
(an Object or
undefined
) and returns an
execution context
. It performs the following steps when called:
Let
callerContext
be the
running execution context
.
Let
calleeContext
be a new
ECMAScript code execution context
.
Set the Function of
calleeContext
to
F
.
Let
calleeRealm
be
F
.
[[Realm]]
.
Set the
Realm
of
calleeContext
to
calleeRealm
.
Set the ScriptOrModule of
calleeContext
to
F
.
[[ScriptOrModule]]
.
Let
localEnv
be
NewFunctionEnvironment
(
F
,
newTarget
).
Set the LexicalEnvironment of
calleeContext
to
localEnv
.
Set the VariableEnvironment of
calleeContext
to
localEnv
.
Set the PrivateEnvironment of
calleeContext
to
F
.
[[PrivateEnvironment]]
.
If
callerContext
is not already suspended, suspend
callerContext
.
Push
calleeContext
onto the
execution context stack
;
calleeContext
is now the
running execution context
.
NOTE: Any exception objects produced after this point are associated with
calleeRealm
.
Return
calleeContext
.
10.2.1.2
OrdinaryCallBindThis (
F
,
calleeContext
,
thisArgument
)
The abstract operation OrdinaryCallBindThis takes arguments
F
(an ECMAScript
function object
),
calleeContext
(an
execution context
), and
thisArgument
(an
ECMAScript language value
) and returns
unused
. It performs the following steps when called:
Let
thisMode
be
F
.
[[ThisMode]]
.
If
thisMode
is
lexical
, return
unused
.
Let
calleeRealm
be
F
.
[[Realm]]
.
Let
localEnv
be the LexicalEnvironment of
calleeContext
.
If
thisMode
is
strict
, then
Let
thisValue
be
thisArgument
.
Else,
If
thisArgument
is either
undefined
or
null
, then
Let
globalEnv
be
calleeRealm
.
[[GlobalEnv]]
.
Assert
:
globalEnv
is a
Global Environment Record
.
Let
thisValue
be
globalEnv
.
[[GlobalThisValue]]
.
Else,
Let
thisValue
be !
ToObject
(
thisArgument
).
NOTE:
ToObject
produces wrapper objects using
calleeRealm
.
Assert
:
localEnv
is a
Function Environment Record
.
Assert
: The next step never returns an
abrupt completion
because
localEnv
.
[[ThisBindingStatus]]
is not
initialized
.
Perform !
BindThisValue
(
localEnv
,
thisValue
).
Return
unused
.
10.2.1.3
Runtime Semantics: EvaluateBody
The
syntax-directed operation
EvaluateBody takes arguments
functionObject
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
return completion
or a
throw completion
. It is defined piecewise over the following productions:
FunctionBody
:
FunctionStatementList
Return ?
EvaluateFunctionBody
of
FunctionBody
with arguments
functionObject
and
argumentsList
.
ConciseBody
:
ExpressionBody
Return ?
EvaluateConciseBody
of
ConciseBody
with arguments
functionObject
and
argumentsList
.
GeneratorBody
:
FunctionBody
Return ?
EvaluateGeneratorBody
of
GeneratorBody
with arguments
functionObject
and
argumentsList
.
AsyncGeneratorBody
:
FunctionBody
Return ?
EvaluateAsyncGeneratorBody
of
AsyncGeneratorBody
with arguments
functionObject
and
argumentsList
.
AsyncFunctionBody
:
FunctionBody
Return ?
EvaluateAsyncFunctionBody
of
AsyncFunctionBody
with arguments
functionObject
and
argumentsList
.
AsyncConciseBody
:
ExpressionBody
Return ?
EvaluateAsyncConciseBody
of
AsyncConciseBody
with arguments
functionObject
and
argumentsList
.
Initializer
:
=
AssignmentExpression
Assert
:
argumentsList
is empty.
Assert
:
functionObject
.
[[ClassFieldInitializerName]]
is not
empty
.
If
IsAnonymousFunctionDefinition
(
AssignmentExpression
) is
true
, then
Let
value
be ?
NamedEvaluation
of
Initializer
with argument
functionObject
.
[[ClassFieldInitializerName]]
.
Else,
Let
rhs
be ?
Evaluation
of
AssignmentExpression
.
Let
value
be ?
GetValue
(
rhs
).
Return
ReturnCompletion
(
value
).
Note
Even though field initializers constitute a function boundary, calling
FunctionDeclarationInstantiation
does not have any observable effect and so is omitted.
ClassStaticBlockBody
:
ClassStaticBlockStatementList
Assert
:
argumentsList
is empty.
Return ?
EvaluateClassStaticBlockBody
of
ClassStaticBlockBody
with argument
functionObject
.
10.2.1.4
OrdinaryCallEvaluateBody (
F
,
argumentsList
)
The abstract operation OrdinaryCallEvaluateBody takes arguments
F
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
return completion
or a
throw completion
. It performs the following steps when called:
Return ?
EvaluateBody
of
F
.
[[ECMAScriptCode]]
with arguments
F
and
argumentsList
.
10.2.2
[[Construct]]
(
argumentsList
,
newTarget
)
The
[[Construct]]
internal method of an ECMAScript
function object
F
takes arguments
argumentsList
(a
List
of
ECMAScript language values
) and
newTarget
(a
constructor
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
Let
callerContext
be the
running execution context
.
Let
kind
be
F
.
[[ConstructorKind]]
.
If
kind
is
base
, then
Let
thisArgument
be ?
OrdinaryCreateFromConstructor
(
newTarget
,
"%Object.prototype%"
).
Let
calleeContext
be
PrepareForOrdinaryCall
(
F
,
newTarget
).
Assert
:
calleeContext
is now the
running execution context
.
If
kind
is
base
, then
Perform
OrdinaryCallBindThis
(
F
,
calleeContext
,
thisArgument
).
Let
initializeResult
be
Completion
(
InitializeInstanceElements
(
thisArgument
,
F
)).
If
initializeResult
is an
abrupt completion
, then
Remove
calleeContext
from the
execution context stack
and restore
callerContext
as the
running execution context
.
Return ?
initializeResult
.
Let
constructorEnv
be the LexicalEnvironment of
calleeContext
.
Let
result
be
Completion
(
OrdinaryCallEvaluateBody
(
F
,
argumentsList
)).
Remove
calleeContext
from the
execution context stack
and restore
callerContext
as the
running execution context
.
If
result
is a
throw completion
, then
Return ?
result
.
Assert
:
result
is a
return completion
.
If
result
.
[[Value]]
is an Object
, return
result
.
[[Value]]
.
If
kind
is
base
, return
thisArgument
.
If
result
.
[[Value]]
is not
undefined
, throw a
TypeError
exception.
Let
thisBinding
be ?
constructorEnv
.
GetThisBinding
().
Assert
:
thisBinding
is an Object
.
Return
thisBinding
.
10.2.3
OrdinaryFunctionCreate (
functionPrototype
,
sourceText
,
ParameterList
,
Body
,
thisMode
,
env
,
privateEnv
)
The abstract operation OrdinaryFunctionCreate takes arguments
functionPrototype
(an Object),
sourceText
(a sequence of Unicode code points),
ParameterList
(a
Parse Node
),
Body
(a
Parse Node
),
thisMode
(
lexical-this
or
non-lexical-this
),
env
(an
Environment Record
), and
privateEnv
(a
PrivateEnvironment Record
or
null
) and returns an ECMAScript
function object
. It is used to specify the runtime creation of a new function with a default
[[Call]]
internal method and no
[[Construct]]
internal method (although one may be subsequently added by an operation such as
MakeConstructor
).
sourceText
is the source text of the syntactic definition of the function to be created. It performs the following steps when called:
Let
internalSlotsList
be the internal slots listed in
Table 25
.
Let
F
be
OrdinaryObjectCreate
(
functionPrototype
,
internalSlotsList
).
Set
F
.
[[Call]]
to the definition specified in
10.2.1
.
Set
F
.
[[SourceText]]
to
sourceText
.
Set
F
.
[[FormalParameters]]
to
ParameterList
.
Set
F
.
[[ECMAScriptCode]]
to
Body
.
Let
Strict
be
IsStrict
(
Body
).
Set
F
.
[[Strict]]
to
Strict
.
If
thisMode
is
lexical-this
, set
F
.
[[ThisMode]]
to
lexical
.
Else if
Strict
is
true
, set
F
.
[[ThisMode]]
to
strict
.
Else, set
F
.
[[ThisMode]]
to
global
.
Set
F
.
[[IsClassConstructor]]
to
false
.
Set
F
.
[[Environment]]
to
env
.
Set
F
.
[[PrivateEnvironment]]
to
privateEnv
.
Set
F
.
[[ScriptOrModule]]
to
GetActiveScriptOrModule
().
Set
F
.
[[Realm]]
to
the current Realm Record
.
Set
F
.
[[HomeObject]]
to
undefined
.
Set
F
.
[[Fields]]
to a new empty
List
.
Set
F
.
[[PrivateMethods]]
to a new empty
List
.
Set
F
.
[[ClassFieldInitializerName]]
to
empty
.
Let
len
be the
ExpectedArgumentCount
of
ParameterList
.
Perform
SetFunctionLength
(
F
,
len
).
Return
F
.
10.2.4
AddRestrictedFunctionProperties (
F
,
realm
)
The abstract operation AddRestrictedFunctionProperties takes arguments
F
(a
function object
) and
realm
(a
Realm Record
) and returns
unused
. It performs the following steps when called:
Assert
:
realm
.
[[Intrinsics]]
.[[
%ThrowTypeError%
]] exists and has been initialized.
Let
thrower
be
realm
.
[[Intrinsics]]
.[[
%ThrowTypeError%
]].
Perform !
DefinePropertyOrThrow
(
F
,
"caller"
, PropertyDescriptor {
[[Get]]
:
thrower
,
[[Set]]
:
thrower
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Perform !
DefinePropertyOrThrow
(
F
,
"arguments"
, PropertyDescriptor {
[[Get]]
:
thrower
,
[[Set]]
:
thrower
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Return
unused
.
10.2.4.1
%ThrowTypeError% ( )
This function is the
%ThrowTypeError%
intrinsic object.
It is an anonymous built-in
function object
that is defined once for each
realm
.
It performs the following steps when called:
Throw a
TypeError
exception.
The value of the
[[Extensible]]
internal slot of this function is
false
.
The
"length"
property of this function has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
The
"name"
property of this function has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
10.2.5
MakeConstructor (
F
[ ,
writablePrototype
[ ,
prototype
] ] )
The abstract operation MakeConstructor takes argument
F
(an ECMAScript
function object
or a built-in
function object
) and optional arguments
writablePrototype
(a Boolean) and
prototype
(an Object) and returns
unused
. It converts
F
into a
constructor
. It performs the following steps when called:
If
F
is an ECMAScript
function object
, then
Assert
:
IsConstructor
(
F
) is
false
.
Assert
:
F
is an extensible object that does not have a
"prototype"
own property.
Set
F
.
[[Construct]]
to the definition specified in
10.2.2
.
Else,
Set
F
.
[[Construct]]
to the definition specified in
10.3.2
.
Set
F
.
[[ConstructorKind]]
to
base
.
If
writablePrototype
is not present, set
writablePrototype
to
true
.
If
prototype
is not present, then
Set
prototype
to
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
DefinePropertyOrThrow
(
prototype
,
"constructor"
, PropertyDescriptor {
[[Value]]
:
F
,
[[Writable]]
:
writablePrototype
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Perform !
DefinePropertyOrThrow
(
F
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
writablePrototype
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
unused
.
10.2.6
MakeClassConstructor (
F
)
The abstract operation MakeClassConstructor takes argument
F
(an ECMAScript
function object
) and returns
unused
. It performs the following steps when called:
Assert
:
F
.
[[IsClassConstructor]]
is
false
.
Set
F
.
[[IsClassConstructor]]
to
true
.
Return
unused
.
10.2.7
MakeMethod (
F
,
homeObject
)
The abstract operation MakeMethod takes arguments
F
(an ECMAScript
function object
) and
homeObject
(an Object) and returns
unused
. It configures
F
as a method. It performs the following steps when called:
Assert
:
homeObject
is an
ordinary object
.
Set
F
.
[[HomeObject]]
to
homeObject
.
Return
unused
.
10.2.8
DefineMethodProperty (
homeObject
,
key
,
closure
,
enumerable
)
The abstract operation DefineMethodProperty takes arguments
homeObject
(an Object),
key
(a
property key
or
Private Name
),
closure
(a
function object
), and
enumerable
(a Boolean) and returns either a
normal completion containing
either a
PrivateElement
or
unused
, or an
abrupt completion
. It performs the following steps when called:
Assert
:
homeObject
is an ordinary, extensible object.
If
key
is a
Private Name
, then
Return
PrivateElement
{
[[Key]]
:
key
,
[[Kind]]
:
method
,
[[Value]]
:
closure
}.
Else,
Let
desc
be the PropertyDescriptor {
[[Value]]
:
closure
,
[[Writable]]
:
true
,
[[Enumerable]]
:
enumerable
,
[[Configurable]]
:
true
}.
Perform ?
DefinePropertyOrThrow
(
homeObject
,
key
,
desc
).
NOTE:
DefinePropertyOrThrow
only returns an
abrupt completion
when attempting to define a class static method whose
key
is
"prototype"
.
Return
unused
.
10.2.9
SetFunctionName (
F
,
name
[ ,
prefix
] )
The abstract operation SetFunctionName takes arguments
F
(a
function object
) and
name
(a
property key
or
Private Name
) and optional argument
prefix
(a String) and returns
unused
. It adds a
"name"
property to
F
. It performs the following steps when called:
Assert
:
F
is an extensible object that does not have a
"name"
own property.
If
name
is a Symbol
, then
Let
description
be
name
.
[[Description]]
.
If
description
is
undefined
, set
name
to the empty String.
Else, set
name
to the
string-concatenation
of
"["
,
description
, and
"]"
.
Else if
name
is a
Private Name
, then
Set
name
to
name
.
[[Description]]
.
If
F
has an
[[InitialName]]
internal slot, then
Set
F
.
[[InitialName]]
to
name
.
If
prefix
is present, then
Set
name
to the
string-concatenation
of
prefix
, the code unit 0x0020 (SPACE), and
name
.
If
F
has an
[[InitialName]]
internal slot, then
NOTE: The choice in the following step is made independently each time this Abstract Operation is invoked.
Optionally, set
F
.
[[InitialName]]
to
name
.
Perform !
DefinePropertyOrThrow
(
F
,
"name"
, PropertyDescriptor {
[[Value]]
:
name
,
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Return
unused
.
10.2.10
SetFunctionLength (
F
,
length
)
The abstract operation SetFunctionLength takes arguments
F
(a
function object
) and
length
(a non-negative
integer
or +∞) and returns
unused
. It adds a
"length"
property to
F
. It performs the following steps when called:
Assert
:
F
is an extensible object that does not have a
"length"
own property.
Perform !
DefinePropertyOrThrow
(
F
,
"length"
, PropertyDescriptor {
[[Value]]
:
𝔽
(
length
),
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Return
unused
.
10.2.11
FunctionDeclarationInstantiation (
func
,
argumentsList
)
The abstract operation FunctionDeclarationInstantiation takes arguments
func
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
unused
or a
throw completion
.
func
is the
function object
for which the
execution context
is being established.
Note
When an
execution context
is established for evaluating an ECMAScript function a new
Function Environment Record
is created and bindings for each formal parameter are instantiated in that
Environment Record
. Each declaration in the function body is also instantiated. If the function's formal parameters do not include any default value initializers then the body declarations are instantiated in the same
Environment Record
as the parameters. If default value parameter initializers exist, a second
Environment Record
is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.
It performs the following steps when called:
Let
calleeContext
be the
running execution context
.
Let
code
be
func
.
[[ECMAScriptCode]]
.
Let
strict
be
func
.
[[Strict]]
.
Let
formals
be
func
.
[[FormalParameters]]
.
Let
parameterNames
be the
BoundNames
of
formals
.
If
parameterNames
has any duplicate entries, let
hasDuplicates
be
true
; otherwise let
hasDuplicates
be
false
.
Let
simpleParameterList
be
IsSimpleParameterList
of
formals
.
Let
hasParameterExpressions
be
ContainsExpression
of
formals
.
Let
varNames
be the
VarDeclaredNames
of
code
.
Let
varDeclarations
be the
VarScopedDeclarations
of
code
.
Let
lexicalNames
be the
LexicallyDeclaredNames
of
code
.
Let
functionNames
be a new empty
List
.
Let
functionsToInitialize
be a new empty
List
.
For each element
d
of
varDeclarations
, in reverse
List
order, do
If
d
is neither a
VariableDeclaration
nor a
ForBinding
nor a
BindingIdentifier
, then
Assert
:
d
is either a
FunctionDeclaration
, a
GeneratorDeclaration
, an
AsyncFunctionDeclaration
, or an
AsyncGeneratorDeclaration
.
Let
fn
be the sole element of the
BoundNames
of
d
.
If
functionNames
does not contain
fn
, then
Insert
fn
as the first element of
functionNames
.
NOTE: If there are multiple function declarations for the same name, the last declaration is used.
Insert
d
as the first element of
functionsToInitialize
.
Let
argumentsObjectNeeded
be
true
.
If
func
.
[[ThisMode]]
is
lexical
, then
NOTE: Arrow functions never have an arguments object.
Set
argumentsObjectNeeded
to
false
.
Else if
parameterNames
contains
"arguments"
, then
Set
argumentsObjectNeeded
to
false
.
Else if
hasParameterExpressions
is
false
, then
If
functionNames
contains
"arguments"
or
lexicalNames
contains
"arguments"
, then
Set
argumentsObjectNeeded
to
false
.
If
strict
is
true
or
hasParameterExpressions
is
false
, then
NOTE: Only a single
Environment Record
is needed for the parameters, since calls to
eval
in
strict mode code
cannot create new bindings which are visible outside of the
eval
.
Let
env
be the LexicalEnvironment of
calleeContext
.
Else,
NOTE: A separate
Environment Record
is needed to ensure that bindings created by
direct eval
calls in the formal parameter list are outside the environment where parameters are declared.
Let
calleeEnv
be the LexicalEnvironment of
calleeContext
.
Let
env
be
NewDeclarativeEnvironment
(
calleeEnv
).
Assert
: The VariableEnvironment of
calleeContext
and
calleeEnv
are the same
Environment Record
.
Set the LexicalEnvironment of
calleeContext
to
env
.
For each String
paramName
of
parameterNames
, do
Let
alreadyDeclared
be !
env
.
HasBinding
(
paramName
).
NOTE:
Early errors
ensure that duplicate parameter names can only occur in
non-strict functions
that do not have parameter default values or rest parameters.
If
alreadyDeclared
is
false
, then
Perform !
env
.
CreateMutableBinding
(
paramName
,
false
).
If
hasDuplicates
is
true
, then
Perform !
env
.
InitializeBinding
(
paramName
,
undefined
).
If
argumentsObjectNeeded
is
true
, then
If
strict
is
true
or
simpleParameterList
is
false
, then
Let
ao
be
CreateUnmappedArgumentsObject
(
argumentsList
).
Else,
NOTE: A mapped argument object is only provided for
non-strict functions
that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
Let
ao
be
CreateMappedArgumentsObject
(
func
,
formals
,
argumentsList
,
env
).
If
strict
is
true
, then
Perform !
env
.
CreateImmutableBinding
(
"arguments"
,
false
).
NOTE: In
strict mode code
early errors
prevent attempting to assign to this binding, so its mutability is not observable.
Else,
Perform !
env
.
CreateMutableBinding
(
"arguments"
,
false
).
Perform !
env
.
InitializeBinding
(
"arguments"
,
ao
).
Let
parameterBindings
be the
list-concatenation
of
parameterNames
and «
"arguments"
».
Else,
Let
parameterBindings
be
parameterNames
.
Let
iteratorRecord
be
CreateListIteratorRecord
(
argumentsList
).
If
hasDuplicates
is
true
, then
Let
usedEnv
be
undefined
.
Else,
Let
usedEnv
be
env
.
NOTE: The following step cannot return a
ReturnCompletion
because the only way such a completion can arise in expression position is by use of
YieldExpression
, which is forbidden in parameter lists by Early Error rules in
15.5.1
and
15.6.1
.
Perform ?
IteratorBindingInitialization
of
formals
with arguments
iteratorRecord
and
usedEnv
.
If
hasParameterExpressions
is
false
, then
NOTE: Only a single
Environment Record
is needed for the parameters and top-level vars.
Let
instantiatedVarNames
be a copy of the
List
parameterBindings
.
For each element
n
of
varNames
, do
If
instantiatedVarNames
does not contain
n
, then
Append
n
to
instantiatedVarNames
.
Perform !
env
.
CreateMutableBinding
(
n
,
false
).
Perform !
env
.
InitializeBinding
(
n
,
undefined
).
Let
varEnv
be
env
.
Else,
NOTE: A separate
Environment Record
is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
Let
varEnv
be
NewDeclarativeEnvironment
(
env
).
Set the VariableEnvironment of
calleeContext
to
varEnv
.
Let
instantiatedVarNames
be a new empty
List
.
For each element
n
of
varNames
, do
If
instantiatedVarNames
does not contain
n
, then
Append
n
to
instantiatedVarNames
.
Perform !
varEnv
.
CreateMutableBinding
(
n
,
false
).
If
parameterBindings
does not contain
n
, or if
functionNames
contains
n
, then
Let
initialValue
be
undefined
.
Else,
Let
initialValue
be !
env
.
GetBindingValue
(
n
,
false
).
Perform !
varEnv
.
InitializeBinding
(
n
,
initialValue
).
NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.
If
strict
is
true
, then
Let
lexEnv
be
varEnv
.
Else,
Normative Optional
If the
host
is a web browser or otherwise supports
Block-Level Function Declarations Web Legacy Compatibility Semantics
, then
For each
FunctionDeclaration
f
that is directly contained in the
StatementList
of any
Block
,
CaseClause
, or
DefaultClause
x
such that
code
Contains
x
is
true
, do
Let
F
be the
StringValue
of the
BindingIdentifier
of
f
.
If replacing the
FunctionDeclaration
f
with a
VariableStatement
that has
F
as a
BindingIdentifier
would not produce any Early Errors for
func
and
parameterNames
does not contain
F
, then
NOTE: A var binding for
F
is only instantiated here if it is neither a VarDeclaredName, the name of a formal parameter, or another
FunctionDeclaration
.
If
instantiatedVarNames
does not contain
F
and
F
is not
"arguments"
, then
Perform !
varEnv
.
CreateMutableBinding
(
F
,
false
).
Perform !
varEnv
.
InitializeBinding
(
F
,
undefined
).
Append
F
to
instantiatedVarNames
.
When the
FunctionDeclaration
f
is evaluated, perform the following steps in place of the
FunctionDeclaration
Evaluation
algorithm provided in
15.2.6
:
Let
fEnv
be the
running execution context
's VariableEnvironment.
Let
bEnv
be the
running execution context
's LexicalEnvironment.
Let
fObj
be !
bEnv
.
GetBindingValue
(
F
,
false
).
Perform !
fEnv
.
SetMutableBinding
(
F
,
fObj
,
false
).
Return
unused
.
Let
lexEnv
be
NewDeclarativeEnvironment
(
varEnv
).
NOTE:
Non-strict functions
use a separate
Environment Record
for top-level lexical declarations so that a
direct eval
can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for
strict functions
because a strict
direct eval
always places all declarations into a new
Environment Record
.
Set the LexicalEnvironment of
calleeContext
to
lexEnv
.
Let
lexDeclarations
be the
LexicallyScopedDeclarations
of
code
.
For each element
d
of
lexDeclarations
, do
NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
For each element
dn
of the
BoundNames
of
d
, do
If
IsConstantDeclaration
of
d
is
true
, then
Perform !
lexEnv
.
CreateImmutableBinding
(
dn
,
true
).
Else,
Perform !
lexEnv
.
CreateMutableBinding
(
dn
,
false
).
Let
privateEnv
be the PrivateEnvironment of
calleeContext
.
For each
Parse Node
f
of
functionsToInitialize
, do
Let
fn
be the sole element of the
BoundNames
of
f
.
Let
fo
be
InstantiateFunctionObject
of
f
with arguments
lexEnv
and
privateEnv
.
Perform !
varEnv
.
SetMutableBinding
(
fn
,
fo
,
false
).
Return
unused
.
10.3
Built-in Function Objects
A built-in
function object
is an
ordinary object
; it must satisfy the requirements for
ordinary objects
set out in
10.1
.
In addition to the internal slots required of every
ordinary object
(see
10.1
), a built-in
function object
must also have the following internal slots:
[[Realm]]
, a
Realm Record
that represents the
realm
in which the function was created.
[[InitialName]]
, a String that is the initial name of the function. It is used by
20.2.3.5
.
[[Async]]
, a Boolean that indicates whether the function has async function call and construct behaviour in
BuiltinCallOrConstruct
.
The initial value of a built-in
function object
's
[[Prototype]]
internal slot is
%Function.prototype%
, unless otherwise specified.
A built-in
function object
must have a
[[Call]]
internal method that conforms to the definition in
10.3.1
.
A built-in
function object
has a
[[Construct]]
internal method if and only if it is described as a “
constructor
”, or some algorithm in this specification explicitly sets its
[[Construct]]
internal method. Such a
[[Construct]]
internal method must conform to the definition in
10.3.2
.
An implementation may provide additional built-in
function objects
that are not defined in this specification.
10.3.1
[[Call]]
(
thisArgument
,
argumentsList
)
The
[[Call]]
internal method of a built-in
function object
F
takes arguments
thisArgument
(an
ECMAScript language value
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Return ?
BuiltinCallOrConstruct
(
F
,
thisArgument
,
argumentsList
,
undefined
).
10.3.2
[[Construct]]
(
argumentsList
,
newTarget
)
The
[[Construct]]
internal method of a built-in
function object
F
(when the method is present) takes arguments
argumentsList
(a
List
of
ECMAScript language values
) and
newTarget
(a
constructor
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
Let
result
be ?
BuiltinCallOrConstruct
(
F
,
uninitialized
,
argumentsList
,
newTarget
).
Assert
:
result
is an Object
.
Return
result
.
10.3.3
BuiltinCallOrConstruct (
F
,
thisArgument
,
argumentsList
,
newTarget
)
The abstract operation BuiltinCallOrConstruct takes arguments
F
(a built-in
function object
),
thisArgument
(an
ECMAScript language value
or
uninitialized
),
argumentsList
(a
List
of
ECMAScript language values
), and
newTarget
(a
constructor
or
undefined
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
callerContext
be the
running execution context
.
If
callerContext
is not already suspended, suspend
callerContext
.
Let
calleeContext
be a new
execution context
.
Set the Function of
calleeContext
to
F
.
Let
calleeRealm
be
F
.
[[Realm]]
.
Set the
Realm
of
calleeContext
to
calleeRealm
.
Set the ScriptOrModule of
calleeContext
to
null
.
Perform any necessary
implementation-defined
initialization of
calleeContext
.
Push
calleeContext
onto the
execution context stack
;
calleeContext
is now the
running execution context
.
If
F
.
[[Async]]
is
true
, then
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
resultsClosure
be a new
Abstract Closure
with no parameters that captures
F
,
thisArgument
,
argumentsList
, and
newTarget
and performs the following steps when called:
Let
result
be the
Completion Record
that is
the result of evaluating
F
in a manner that conforms to the specification of
F
. If
thisArgument
is
uninitialized
, the
this
value is uninitialized; otherwise
thisArgument
provides the
this
value.
argumentsList
provides the named parameters.
newTarget
provides the NewTarget value.
NOTE: If
F
is defined in this document, “the specification of
F
” is the behaviour specified for it via algorithm steps or other means.
Return
Completion
(
result
).
Perform
AsyncFunctionStart
(
promiseCapability
,
resultsClosure
).
Remove
calleeContext
from the
execution context stack
and restore
callerContext
as the
running execution context
.
Return
promiseCapability
.
[[Promise]]
.
Else,
Let
result
be the
Completion Record
that is
the result of evaluating
F
in a manner that conforms to the specification of
F
. If
thisArgument
is
uninitialized
, the
this
value is uninitialized; otherwise
thisArgument
provides the
this
value.
argumentsList
provides the named parameters.
newTarget
provides the NewTarget value.
NOTE: If
F
is defined in this document, “the specification of
F
” is the behaviour specified for it via algorithm steps or other means.
Remove
calleeContext
from the
execution context stack
and restore
callerContext
as the
running execution context
.
Return ?
result
.
Note
When
calleeContext
is removed from the
execution context stack
it must not be destroyed if it has been suspended and retained by an accessible Generator for later resumption.
10.3.4
CreateBuiltinFunction (
behaviour
,
length
,
name
,
additionalInternalSlotsList
[ ,
realm
[ ,
prototype
[ ,
prefix
[ ,
async
] ] ] ] )
The abstract operation CreateBuiltinFunction takes arguments
behaviour
(an
Abstract Closure
, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification),
length
(a non-negative
integer
or +∞),
name
(a
property key
or a
Private Name
), and
additionalInternalSlotsList
(a
List
of names of internal slots) and optional arguments
realm
(a
Realm Record
),
prototype
(an Object or
null
),
prefix
(a String), and
async
(a Boolean) and returns a built-in
function object
.
additionalInternalSlotsList
contains the names of additional internal slots that must be defined as part of the object. This operation creates a built-in
function object
. It performs the following steps when called:
If
realm
is not present, set
realm
to
the current Realm Record
.
If
prototype
is not present, set
prototype
to
realm
.
[[Intrinsics]]
.[[
%Function.prototype%
]].
If
async
is not present, set
async
to
false
.
Let
internalSlotsList
be a
List
containing the names of all the internal slots that
10.3
requires for the built-in
function object
that is about to be created.
Append to
internalSlotsList
the elements of
additionalInternalSlotsList
.
Let
func
be a new built-in
function object
that, when called, performs the action described by
behaviour
using the provided arguments as the values of the corresponding parameters specified by
behaviour
. The new
function object
has internal slots whose names are the elements of
internalSlotsList
, and an
[[InitialName]]
internal slot.
Set
func
.
[[Async]]
to
async
.
Set
func
.
[[Prototype]]
to
prototype
.
Set
func
.
[[Extensible]]
to
true
.
Set
func
.
[[Realm]]
to
realm
.
Set
func
.
[[InitialName]]
to
null
.
Perform
SetFunctionLength
(
func
,
length
).
If
prefix
is not present, then
Perform
SetFunctionName
(
func
,
name
).
Else,
Perform
SetFunctionName
(
func
,
name
,
prefix
).
Return
func
.
Each built-in function defined in this specification is created by calling the CreateBuiltinFunction abstract operation.
10.4
Built-in Exotic Object Internal Methods and Slots
This specification defines several kinds of built-in
exotic objects
. These objects generally behave similar to
ordinary objects
except for a few specific situations. The following
exotic objects
use the
ordinary object
internal methods except where it is explicitly specified otherwise below:
10.4.1
Bound Function Exotic Objects
A
bound function exotic object
is an
exotic object
that wraps another
function object
. A
bound function exotic object
is callable (it has a
[[Call]]
internal method and may have a
[[Construct]]
internal method). Calling a
bound function exotic object
generally results in a call of its wrapped function.
An object is a
bound function exotic object
if its
[[Call]]
and (if applicable)
[[Construct]]
internal methods use the following implementations, and its other essential internal methods use the definitions found in
10.1
. These methods are installed in
BoundFunctionCreate
.
Bound function exotic objects
do not have the internal slots of ECMAScript
function objects
listed in
Table 25
. Instead they have the internal slots listed in
Table 26
, in addition to
[[Prototype]]
and
[[Extensible]]
.
Table 26: Internal Slots of Bound Function Exotic Objects
Internal Slot
Type
Description
[[BoundTargetFunction]]
a callable Object
The wrapped
function object
.
[[BoundThis]]
an
ECMAScript language value
The value that is always passed as the
this
value when calling the wrapped function.
[[BoundArguments]]
a
List
of
ECMAScript language values
A list of values whose elements are used as the first arguments to any call to the wrapped function.
10.4.1.1
[[Call]]
(
thisArgument
,
argumentsList
)
The
[[Call]]
internal method of a
bound function exotic object
F
takes arguments
thisArgument
(an
ECMAScript language value
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
target
be
F
.
[[BoundTargetFunction]]
.
Let
boundThis
be
F
.
[[BoundThis]]
.
Let
boundArgs
be
F
.
[[BoundArguments]]
.
Let
args
be the
list-concatenation
of
boundArgs
and
argumentsList
.
Return ?
Call
(
target
,
boundThis
,
args
).
10.4.1.2
[[Construct]]
(
argumentsList
,
newTarget
)
The
[[Construct]]
internal method of a
bound function exotic object
F
takes arguments
argumentsList
(a
List
of
ECMAScript language values
) and
newTarget
(a
constructor
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
Let
target
be
F
.
[[BoundTargetFunction]]
.
Assert
:
IsConstructor
(
target
) is
true
.
Let
boundArgs
be
F
.
[[BoundArguments]]
.
Let
args
be the
list-concatenation
of
boundArgs
and
argumentsList
.
If
SameValue
(
F
,
newTarget
) is
true
, set
newTarget
to
target
.
Return ?
Construct
(
target
,
args
,
newTarget
).
10.4.1.3
BoundFunctionCreate (
targetFunction
,
boundThis
,
boundArgs
)
The abstract operation BoundFunctionCreate takes arguments
targetFunction
(a
function object
),
boundThis
(an
ECMAScript language value
), and
boundArgs
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
a
function object
or a
throw completion
. It is used to specify the creation of new
bound function exotic objects
. It performs the following steps when called:
Let
proto
be ?
targetFunction
.
[[GetPrototypeOf]]
()
.
Let
internalSlotsList
be the
list-concatenation
of «
[[Prototype]]
,
[[Extensible]]
» and the internal slots listed in
Table 26
.
Let
obj
be
MakeBasicObject
(
internalSlotsList
).
Set
obj
.
[[Prototype]]
to
proto
.
Set
obj
.
[[Call]]
as specified in
10.4.1.1
.
If
IsConstructor
(
targetFunction
) is
true
, then
Set
obj
.
[[Construct]]
as specified in
10.4.1.2
.
Set
obj
.
[[BoundTargetFunction]]
to
targetFunction
.
Set
obj
.
[[BoundThis]]
to
boundThis
.
Set
obj
.
[[BoundArguments]]
to
boundArgs
.
Return
obj
.
10.4.2
Array Exotic Objects
An Array is an
exotic object
that gives special treatment to
array index
property keys
(see
6.1.7
). A property whose
property name
is an
array index
is also called an
element
. Every Array has a non-configurable
"length"
property whose value is always a non-negative
integral Number
whose
mathematical value
is strictly less than 2
32
. The value of the
"length"
property is numerically greater than the name of every own property whose name is an
array index
; whenever an own property of an Array is created or changed, other properties are adjusted as necessary to maintain this invariant. Specifically, whenever an own property is added whose name is an
array index
, the value of the
"length"
property is changed, if necessary, to be one more than the numeric value of that
array index
; and whenever the value of the
"length"
property is changed, every own property whose name is an
array index
whose value is not smaller than the new length is deleted. This constraint applies only to own properties of an Array and is unaffected by
"length"
or
array index
properties that may be inherited from its prototypes.
An object is an
Array exotic object
(or simply, an Array) if its
[[DefineOwnProperty]]
internal method uses the following implementation, and its other essential internal methods use the definitions found in
10.1
. These methods are installed in
ArrayCreate
.
10.4.2.1
[[DefineOwnProperty]]
(
P
,
Desc
)
The
[[DefineOwnProperty]]
internal method of an
Array exotic object
A
takes arguments
P
(a
property key
) and
Desc
(a
Property Descriptor
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
P
is
"length"
, then
Return ?
ArraySetLength
(
A
,
Desc
).
Else if
P
is an
array index
, then
Let
lengthDesc
be
OrdinaryGetOwnProperty
(
A
,
"length"
).
Assert
:
lengthDesc
is not
undefined
.
Assert
:
IsDataDescriptor
(
lengthDesc
) is
true
.
Assert
:
lengthDesc
.
[[Configurable]]
is
false
.
Let
length
be
lengthDesc
.
[[Value]]
.
Assert
:
length
is a non-negative
integral Number
.
Let
index
be !
ToUint32
(
P
).
If
index
≥
length
and
lengthDesc
.
[[Writable]]
is
false
, return
false
.
Let
succeeded
be !
OrdinaryDefineOwnProperty
(
A
,
P
,
Desc
).
If
succeeded
is
false
, return
false
.
If
index
≥
length
, then
Set
lengthDesc
.
[[Value]]
to
index
+
1
𝔽
.
Set
succeeded
to !
OrdinaryDefineOwnProperty
(
A
,
"length"
,
lengthDesc
).
Assert
:
succeeded
is
true
.
Return
true
.
Return ?
OrdinaryDefineOwnProperty
(
A
,
P
,
Desc
).
10.4.2.2
ArrayCreate (
length
[ ,
proto
] )
The abstract operation ArrayCreate takes argument
length
(a non-negative
integer
) and optional argument
proto
(an Object) and returns either a
normal completion containing
an
Array exotic object
or a
throw completion
. It is used to specify the creation of new Arrays. It performs the following steps when called:
If
length
> 2
32
- 1, throw a
RangeError
exception.
If
proto
is not present, set
proto
to
%Array.prototype%
.
Let
A
be
MakeBasicObject
(«
[[Prototype]]
,
[[Extensible]]
»).
Set
A
.
[[Prototype]]
to
proto
.
Set
A
.
[[DefineOwnProperty]]
as specified in
10.4.2.1
.
Perform !
OrdinaryDefineOwnProperty
(
A
,
"length"
, PropertyDescriptor {
[[Value]]
:
𝔽
(
length
),
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
A
.
10.4.2.3
ArraySpeciesCreate (
originalArray
,
length
)
The abstract operation ArraySpeciesCreate takes arguments
originalArray
(an Object) and
length
(a non-negative
integer
) and returns either a
normal completion containing
an Object or a
throw completion
. It is used to specify the creation of a new Array or similar object using a
constructor
function that is derived from
originalArray
. It does not enforce that the
constructor
function returns an Array. It performs the following steps when called:
Let
isArray
be ?
IsArray
(
originalArray
).
If
isArray
is
false
, return ?
ArrayCreate
(
length
).
Let
C
be ?
Get
(
originalArray
,
"constructor"
).
If
IsConstructor
(
C
) is
true
, then
Let
thisRealm
be
the current Realm Record
.
Let
realmC
be ?
GetFunctionRealm
(
C
).
If
thisRealm
and
realmC
are not the same
Realm Record
, then
If
SameValue
(
C
,
realmC
.
[[Intrinsics]]
.[[
%Array%
]]) is
true
, set
C
to
undefined
.
If
C
is an Object
, then
Set
C
to ?
Get
(
C
,
%Symbol.species%
).
If
C
is
null
, set
C
to
undefined
.
If
C
is
undefined
, return ?
ArrayCreate
(
length
).
If
IsConstructor
(
C
) is
false
, throw a
TypeError
exception.
Return ?
Construct
(
C
, «
𝔽
(
length
) »).
Note
If
originalArray
was created using the standard built-in Array
constructor
for a
realm
that is not the
realm
of the
running execution context
, then a new Array is created using the
realm
of the
running execution context
. This maintains compatibility with Web browsers that have historically had that behaviour for the
Array.prototype
methods that now are defined using ArraySpeciesCreate.
10.4.2.4
ArraySetLength (
A
,
Desc
)
The abstract operation ArraySetLength takes arguments
A
(an Array) and
Desc
(a
Property Descriptor
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
Desc
does not have a
[[Value]]
field, then
Return !
OrdinaryDefineOwnProperty
(
A
,
"length"
,
Desc
).
Let
newLenDesc
be a copy of
Desc
.
Let
newLen
be ?
ToUint32
(
Desc
.
[[Value]]
).
Let
numberLen
be ?
ToNumber
(
Desc
.
[[Value]]
).
If
SameValueZero
(
newLen
,
numberLen
) is
false
, throw a
RangeError
exception.
Set
newLenDesc
.
[[Value]]
to
newLen
.
Let
oldLenDesc
be
OrdinaryGetOwnProperty
(
A
,
"length"
).
Assert
:
oldLenDesc
is not
undefined
.
Assert
:
IsDataDescriptor
(
oldLenDesc
) is
true
.
Assert
:
oldLenDesc
.
[[Configurable]]
is
false
.
Let
oldLen
be
oldLenDesc
.
[[Value]]
.
If
newLen
≥
oldLen
, then
Return !
OrdinaryDefineOwnProperty
(
A
,
"length"
,
newLenDesc
).
If
oldLenDesc
.
[[Writable]]
is
false
, return
false
.
If
newLenDesc
does not have a
[[Writable]]
field or
newLenDesc
.
[[Writable]]
is
true
, then
Let
newWritable
be
true
.
Else,
NOTE: Setting the
[[Writable]]
attribute to
false
is deferred in case any elements cannot be deleted.
Let
newWritable
be
false
.
Set
newLenDesc
.
[[Writable]]
to
true
.
Let
succeeded
be !
OrdinaryDefineOwnProperty
(
A
,
"length"
,
newLenDesc
).
If
succeeded
is
false
, return
false
.
For each own
property key
P
of
A
such that
P
is an
array index
and !
ToUint32
(
P
) ≥
newLen
, in descending numeric index order, do
Let
deleteSucceeded
be !
A
.
[[Delete]]
(
P
).
If
deleteSucceeded
is
false
, then
Set
newLenDesc
.
[[Value]]
to !
ToUint32
(
P
) +
1
𝔽
.
If
newWritable
is
false
, set
newLenDesc
.
[[Writable]]
to
false
.
Perform !
OrdinaryDefineOwnProperty
(
A
,
"length"
,
newLenDesc
).
Return
false
.
If
newWritable
is
false
, then
Set
succeeded
to !
OrdinaryDefineOwnProperty
(
A
,
"length"
, PropertyDescriptor {
[[Writable]]
:
false
}).
Assert
:
succeeded
is
true
.
Return
true
.
Note
In steps
3
and
4
, if
Desc
.
[[Value]]
is an object then its
valueOf
method is called twice. This is legacy behaviour that was specified with this effect starting with the 2
nd
Edition of this specification.
10.4.3
String Exotic Objects
A String object is an
exotic object
that encapsulates a String value and exposes virtual
integer-indexed
data properties
corresponding to the individual code unit elements of the String value.
String exotic objects
always have a
data property
named
"length"
whose value is the length of the encapsulated String value. Both the code unit
data properties
and the
"length"
property are non-writable and non-configurable.
An object is a
String exotic object
(or simply, a String object) if its
[[GetOwnProperty]]
,
[[DefineOwnProperty]]
, and
[[OwnPropertyKeys]]
internal methods use the following implementations, and its other essential internal methods use the definitions found in
10.1
. These methods are installed in
StringCreate
.
String exotic objects
have the same internal slots as
ordinary objects
. They also have a
[[StringData]]
internal slot.
10.4.3.1
[[GetOwnProperty]]
(
P
)
The
[[GetOwnProperty]]
internal method of a
String exotic object
S
takes argument
P
(a
property key
) and returns a
normal completion containing
either a
Property Descriptor
or
undefined
. It performs the following steps when called:
Let
desc
be
OrdinaryGetOwnProperty
(
S
,
P
).
If
desc
is not
undefined
, return
desc
.
Return
StringGetOwnProperty
(
S
,
P
).
10.4.3.2
[[DefineOwnProperty]]
(
P
,
Desc
)
The
[[DefineOwnProperty]]
internal method of a
String exotic object
S
takes arguments
P
(a
property key
) and
Desc
(a
Property Descriptor
) and returns a
normal completion containing
a Boolean. It performs the following steps when called:
Let
stringDesc
be
StringGetOwnProperty
(
S
,
P
).
If
stringDesc
is not
undefined
, then
Let
extensible
be
S
.
[[Extensible]]
.
Return
IsCompatiblePropertyDescriptor
(
extensible
,
Desc
,
stringDesc
).
Return !
OrdinaryDefineOwnProperty
(
S
,
P
,
Desc
).
10.4.3.3
[[OwnPropertyKeys]]
( )
The
[[OwnPropertyKeys]]
internal method of a
String exotic object
O
takes no arguments and returns a
normal completion containing
a
List
of
property keys
. It performs the following steps when called:
Let
keys
be a new empty
List
.
Let
str
be
O
.
[[StringData]]
.
Assert
:
str
is a String
.
Let
len
be the length of
str
.
For each
integer
i
such that 0 ≤
i
<
len
, in ascending order, do
Append !
ToString
(
𝔽
(
i
)) to
keys
.
For each own
property key
P
of
O
such that
P
is an
array index
and !
ToIntegerOrInfinity
(
P
) ≥
len
, in ascending numeric index order, do
Append
P
to
keys
.
For each own
property key
P
of
O
such that
P
is a String
and
P
is not an
array index
, in ascending chronological order of property creation, do
Append
P
to
keys
.
For each own
property key
P
of
O
such that
P
is a Symbol
, in ascending chronological order of property creation, do
Append
P
to
keys
.
Return
keys
.
10.4.3.4
StringCreate (
value
,
prototype
)
The abstract operation StringCreate takes arguments
value
(a String) and
prototype
(an Object) and returns a
String exotic object
. It is used to specify the creation of new
String exotic objects
. It performs the following steps when called:
Let
S
be
MakeBasicObject
(«
[[Prototype]]
,
[[Extensible]]
,
[[StringData]]
»).
Set
S
.
[[Prototype]]
to
prototype
.
Set
S
.
[[StringData]]
to
value
.
Set
S
.
[[GetOwnProperty]]
as specified in
10.4.3.1
.
Set
S
.
[[DefineOwnProperty]]
as specified in
10.4.3.2
.
Set
S
.
[[OwnPropertyKeys]]
as specified in
10.4.3.3
.
Let
length
be the length of
value
.
Perform !
DefinePropertyOrThrow
(
S
,
"length"
, PropertyDescriptor {
[[Value]]
:
𝔽
(
length
),
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
S
.
10.4.3.5
StringGetOwnProperty (
S
,
P
)
The abstract operation StringGetOwnProperty takes arguments
S
(an Object that has a
[[StringData]]
internal slot) and
P
(a
property key
) and returns a
Property Descriptor
or
undefined
. It performs the following steps when called:
If
P
is not a String
, return
undefined
.
Let
index
be
CanonicalNumericIndexString
(
P
).
If
index
is not an
integral Number
, return
undefined
.
If
index
is
-0
𝔽
or
index
<
-0
𝔽
, return
undefined
.
Let
str
be
S
.
[[StringData]]
.
Assert
:
str
is a String
.
Let
len
be the length of
str
.
If
ℝ
(
index
) ≥
len
, return
undefined
.
Let
resultStr
be the
substring
of
str
from
ℝ
(
index
) to
ℝ
(
index
) + 1.
Return the PropertyDescriptor {
[[Value]]
:
resultStr
,
[[Writable]]
:
false
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
false
}.
10.4.4
Arguments Exotic Objects
Most ECMAScript functions make an arguments object available to their code. Depending upon the characteristics of the function definition, its arguments object is either an
ordinary object
or an
arguments exotic object
. An
arguments exotic object
is an
exotic object
whose
array index
properties map to the formal parameters bindings of an invocation of its associated ECMAScript function.
An object is an
arguments exotic object
if its internal methods use the following implementations, with the ones not specified here using those found in
10.1
. These methods are installed in
CreateMappedArgumentsObject
.
Note 1
While
CreateUnmappedArgumentsObject
is grouped into this clause, it creates an
ordinary object
, not an
arguments exotic object
.
Arguments exotic objects
have the same internal slots as
ordinary objects
. They also have a
[[ParameterMap]]
internal slot. Ordinary arguments objects also have a
[[ParameterMap]]
internal slot whose value is always
undefined
. For ordinary argument objects the
[[ParameterMap]]
internal slot is only used by
Object.prototype.toString
(
20.1.3.6
) to identify them as such.
Note 2
The
integer-indexed
data properties
of an
arguments exotic object
whose numeric name values are less than the number of formal parameters of the corresponding
function object
initially share their values with the corresponding argument bindings in the function's
execution context
. This means that changing the property changes the corresponding value of the argument binding and vice-versa. This correspondence is broken if such a property is deleted and then redefined or if the property is changed into an
accessor property
. If the arguments object is an
ordinary object
, the values of its properties are simply a copy of the arguments passed to the function and there is no dynamic linkage between the property values and the formal parameter values.
Note 3
The ParameterMap object and its property values are used as a device for specifying the arguments object correspondence to argument bindings. The ParameterMap object and the objects that are the values of its properties are not directly observable from ECMAScript code. An ECMAScript implementation does not need to actually create or use such objects to implement the specified semantics.
Note 4
Ordinary arguments objects define a non-configurable
accessor property
named
"callee"
which throws a
TypeError
exception on access. The
"callee"
property has a more specific meaning for
arguments exotic objects
, which are created only for some class of
non-strict functions
. The definition of this property in the ordinary variant exists to ensure that it is not defined in any other manner by conforming ECMAScript implementations.
Note 5
ECMAScript implementations of
arguments exotic objects
have historically contained an
accessor property
named
"caller"
. Prior to ECMAScript 2017, this specification included the definition of a throwing
"caller"
property on ordinary arguments objects. Since implementations do not contain this extension any longer, ECMAScript 2017 dropped the requirement for a throwing
"caller"
accessor.
10.4.4.1
[[GetOwnProperty]]
(
P
)
The
[[GetOwnProperty]]
internal method of an
arguments exotic object
args
takes argument
P
(a
property key
) and returns a
normal completion containing
either a
Property Descriptor
or
undefined
. It performs the following steps when called:
Let
desc
be
OrdinaryGetOwnProperty
(
args
,
P
).
If
desc
is
undefined
, return
undefined
.
Let
map
be
args
.
[[ParameterMap]]
.
Let
isMapped
be !
HasOwnProperty
(
map
,
P
).
If
isMapped
is
true
, then
Set
desc
.
[[Value]]
to !
Get
(
map
,
P
).
Return
desc
.
10.4.4.2
[[DefineOwnProperty]]
(
P
,
Desc
)
The
[[DefineOwnProperty]]
internal method of an
arguments exotic object
args
takes arguments
P
(a
property key
) and
Desc
(a
Property Descriptor
) and returns a
normal completion containing
a Boolean. It performs the following steps when called:
Let
map
be
args
.
[[ParameterMap]]
.
Let
isMapped
be !
HasOwnProperty
(
map
,
P
).
Let
newArgDesc
be
Desc
.
If
isMapped
is
true
and
IsDataDescriptor
(
Desc
) is
true
, then
If
Desc
does not have a
[[Value]]
field,
Desc
has a
[[Writable]]
field, and
Desc
.
[[Writable]]
is
false
, then
Set
newArgDesc
to a copy of
Desc
.
Set
newArgDesc
.
[[Value]]
to !
Get
(
map
,
P
).
Let
allowed
be !
OrdinaryDefineOwnProperty
(
args
,
P
,
newArgDesc
).
If
allowed
is
false
, return
false
.
If
isMapped
is
true
, then
If
IsAccessorDescriptor
(
Desc
) is
true
, then
Perform !
map
.
[[Delete]]
(
P
).
Else,
If
Desc
has a
[[Value]]
field, then
Assert
: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.
Perform !
Set
(
map
,
P
,
Desc
.
[[Value]]
,
false
).
If
Desc
has a
[[Writable]]
field and
Desc
.
[[Writable]]
is
false
, then
Perform !
map
.
[[Delete]]
(
P
).
Return
true
.
10.4.4.3
[[Get]]
(
P
,
Receiver
)
The
[[Get]]
internal method of an
arguments exotic object
args
takes arguments
P
(a
property key
) and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
map
be
args
.
[[ParameterMap]]
.
Let
isMapped
be !
HasOwnProperty
(
map
,
P
).
If
isMapped
is
false
, then
Return ?
OrdinaryGet
(
args
,
P
,
Receiver
).
Else,
Assert
:
map
contains a formal parameter mapping for
P
.
Return !
Get
(
map
,
P
).
10.4.4.4
[[Set]]
(
P
,
V
,
Receiver
)
The
[[Set]]
internal method of an
arguments exotic object
args
takes arguments
P
(a
property key
),
V
(an
ECMAScript language value
), and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
SameValue
(
args
,
Receiver
) is
false
, then
Let
isMapped
be
false
.
Else,
Let
map
be
args
.
[[ParameterMap]]
.
Let
isMapped
be !
HasOwnProperty
(
map
,
P
).
If
isMapped
is
true
, then
Assert
: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.
Perform !
Set
(
map
,
P
,
V
,
false
).
Return ?
OrdinarySet
(
args
,
P
,
V
,
Receiver
).
10.4.4.5
[[Delete]]
(
P
)
The
[[Delete]]
internal method of an
arguments exotic object
args
takes argument
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Let
map
be
args
.
[[ParameterMap]]
.
Let
isMapped
be !
HasOwnProperty
(
map
,
P
).
Let
result
be ?
OrdinaryDelete
(
args
,
P
).
If
result
is
true
and
isMapped
is
true
, then
Perform !
map
.
[[Delete]]
(
P
).
Return
result
.
10.4.4.6
CreateUnmappedArgumentsObject (
argumentsList
)
The abstract operation CreateUnmappedArgumentsObject takes argument
argumentsList
(a
List
of
ECMAScript language values
) and returns an
ordinary object
. It performs the following steps when called:
Let
len
be the number of elements in
argumentsList
.
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
, «
[[ParameterMap]]
»).
Set
obj
.
[[ParameterMap]]
to
undefined
.
Perform !
DefinePropertyOrThrow
(
obj
,
"length"
, PropertyDescriptor {
[[Value]]
:
𝔽
(
len
),
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Let
index
be 0.
Repeat, while
index
<
len
,
Let
val
be
argumentsList
[
index
].
Perform !
CreateDataPropertyOrThrow
(
obj
, !
ToString
(
𝔽
(
index
)),
val
).
Set
index
to
index
+ 1.
Perform !
DefinePropertyOrThrow
(
obj
,
%Symbol.iterator%
, PropertyDescriptor {
[[Value]]
: %Array.prototype.values%,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Perform !
DefinePropertyOrThrow
(
obj
,
"callee"
, PropertyDescriptor {
[[Get]]
:
%ThrowTypeError%
,
[[Set]]
:
%ThrowTypeError%
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
obj
.
10.4.4.7
CreateMappedArgumentsObject (
func
,
formals
,
argumentsList
,
env
)
The abstract operation CreateMappedArgumentsObject takes arguments
func
(an Object),
formals
(a
Parse Node
),
argumentsList
(a
List
of
ECMAScript language values
), and
env
(an
Environment Record
) and returns an
arguments exotic object
. It performs the following steps when called:
Assert
:
formals
does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.
Let
len
be the number of elements in
argumentsList
.
Let
obj
be
MakeBasicObject
(«
[[Prototype]]
,
[[Extensible]]
,
[[ParameterMap]]
»).
Set
obj
.
[[GetOwnProperty]]
as specified in
10.4.4.1
.
Set
obj
.
[[DefineOwnProperty]]
as specified in
10.4.4.2
.
Set
obj
.
[[Get]]
as specified in
10.4.4.3
.
Set
obj
.
[[Set]]
as specified in
10.4.4.4
.
Set
obj
.
[[Delete]]
as specified in
10.4.4.5
.
Set
obj
.
[[Prototype]]
to
%Object.prototype%
.
Let
map
be
OrdinaryObjectCreate
(
null
).
Set
obj
.
[[ParameterMap]]
to
map
.
Let
parameterNames
be the
BoundNames
of
formals
.
Let
numberOfParameters
be the number of elements in
parameterNames
.
Let
index
be 0.
Repeat, while
index
<
len
,
Let
val
be
argumentsList
[
index
].
Perform !
CreateDataPropertyOrThrow
(
obj
, !
ToString
(
𝔽
(
index
)),
val
).
Set
index
to
index
+ 1.
Perform !
DefinePropertyOrThrow
(
obj
,
"length"
, PropertyDescriptor {
[[Value]]
:
𝔽
(
len
),
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Let
mappedNames
be a new empty
List
.
Set
index
to
numberOfParameters
- 1.
Repeat, while
index
≥ 0,
Let
name
be
parameterNames
[
index
].
If
mappedNames
does not contain
name
, then
Append
name
to
mappedNames
.
If
index
<
len
, then
Let
g
be
MakeArgGetter
(
name
,
env
).
Let
p
be
MakeArgSetter
(
name
,
env
).
Perform !
map
.
[[DefineOwnProperty]]
(!
ToString
(
𝔽
(
index
)), PropertyDescriptor {
[[Set]]
:
p
,
[[Get]]
:
g
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Set
index
to
index
- 1.
Perform !
DefinePropertyOrThrow
(
obj
,
%Symbol.iterator%
, PropertyDescriptor {
[[Value]]
: %Array.prototype.values%,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Perform !
DefinePropertyOrThrow
(
obj
,
"callee"
, PropertyDescriptor {
[[Value]]
:
func
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}).
Return
obj
.
10.4.4.7.1
MakeArgGetter (
name
,
env
)
The abstract operation MakeArgGetter takes arguments
name
(a String) and
env
(an
Environment Record
) and returns a
function object
. It creates a built-in
function object
that when executed returns the value bound for
name
in
env
. It performs the following steps when called:
Let
getterClosure
be a new
Abstract Closure
with no parameters that captures
name
and
env
and performs the following steps when called:
Return
NormalCompletion
(!
env
.
GetBindingValue
(
name
,
false
)).
Let
getter
be
CreateBuiltinFunction
(
getterClosure
, 0,
""
, « »).
NOTE:
getter
is never directly accessible to ECMAScript code.
Return
getter
.
10.4.4.7.2
MakeArgSetter (
name
,
env
)
The abstract operation MakeArgSetter takes arguments
name
(a String) and
env
(an
Environment Record
) and returns a
function object
. It creates a built-in
function object
that when executed sets the value bound for
name
in
env
. It performs the following steps when called:
Let
setterClosure
be a new
Abstract Closure
with parameters (
value
) that captures
name
and
env
and performs the following steps when called:
Return
NormalCompletion
(!
env
.
SetMutableBinding
(
name
,
value
,
false
)).
Let
setter
be
CreateBuiltinFunction
(
setterClosure
, 1,
""
, « »).
NOTE:
setter
is never directly accessible to ECMAScript code.
Return
setter
.
10.4.5
TypedArray Exotic Objects
A
TypedArray
is an
exotic object
that performs special handling of
property keys
that are
canonical numeric strings
, using the subset that are in-bounds
integer indices
to index elements of uniform type and enforcing the invariant that the remainder are absent without incurring prototype chain traversal.
Note
Because
ToString
(
n
) for any Number
n
is a
canonical numeric string
, an implementation may treat Numbers as
property keys
for
TypedArrays
without actually performing the string conversion.
TypedArrays
have the same internal slots as
ordinary objects
and additionally
[[ViewedArrayBuffer]]
,
[[TypedArrayName]]
,
[[ContentType]]
,
[[ByteLength]]
,
[[ByteOffset]]
, and
[[ArrayLength]]
internal slots.
An object is a
TypedArray
if its
[[PreventExtensions]]
,
[[GetOwnProperty]]
,
[[HasProperty]]
,
[[DefineOwnProperty]]
,
[[Get]]
,
[[Set]]
,
[[Delete]]
, and
[[OwnPropertyKeys]]
, internal methods use the definitions in this section, and its other essential internal methods use the definitions found in
10.1
. These methods are installed by
TypedArrayCreate
.
10.4.5.1
[[PreventExtensions]]
( )
The
[[PreventExtensions]]
internal method of a
TypedArray
O
takes no arguments and returns a
normal completion containing
a Boolean. It performs the following steps when called:
NOTE: The extensibility-related invariants specified in
6.1.7.3
do not allow this method to return
true
when
O
can gain (or lose and then regain) properties, which might occur for properties with
integer index
names when its underlying buffer is resized.
If
IsTypedArrayFixedLength
(
O
) is
false
, return
false
.
Return
OrdinaryPreventExtensions
(
O
).
10.4.5.2
[[GetOwnProperty]]
(
P
)
The
[[GetOwnProperty]]
internal method of a
TypedArray
O
takes argument
P
(a
property key
) and returns a
normal completion containing
either a
Property Descriptor
or
undefined
. It performs the following steps when called:
If
P
is a String
, then
Let
numericIndex
be
CanonicalNumericIndexString
(
P
).
If
numericIndex
is not
undefined
, then
Let
value
be
TypedArrayGetElement
(
O
,
numericIndex
).
If
value
is
undefined
, return
undefined
.
Return the PropertyDescriptor {
[[Value]]
:
value
,
[[Writable]]
:
true
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
true
}.
Return
OrdinaryGetOwnProperty
(
O
,
P
).
10.4.5.3
[[HasProperty]]
(
P
)
The
[[HasProperty]]
internal method of a
TypedArray
O
takes argument
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
P
is a String
, then
Let
numericIndex
be
CanonicalNumericIndexString
(
P
).
If
numericIndex
is not
undefined
, return
IsValidIntegerIndex
(
O
,
numericIndex
).
Return ?
OrdinaryHasProperty
(
O
,
P
).
10.4.5.4
[[DefineOwnProperty]]
(
P
,
Desc
)
The
[[DefineOwnProperty]]
internal method of a
TypedArray
O
takes arguments
P
(a
property key
) and
Desc
(a
Property Descriptor
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
P
is a String
, then
Let
numericIndex
be
CanonicalNumericIndexString
(
P
).
If
numericIndex
is not
undefined
, then
If
IsValidIntegerIndex
(
O
,
numericIndex
) is
false
, return
false
.
If
Desc
has a
[[Configurable]]
field and
Desc
.
[[Configurable]]
is
false
, return
false
.
If
Desc
has an
[[Enumerable]]
field and
Desc
.
[[Enumerable]]
is
false
, return
false
.
If
IsAccessorDescriptor
(
Desc
) is
true
, return
false
.
If
Desc
has a
[[Writable]]
field and
Desc
.
[[Writable]]
is
false
, return
false
.
If
Desc
has a
[[Value]]
field, perform ?
TypedArraySetElement
(
O
,
numericIndex
,
Desc
.
[[Value]]
).
Return
true
.
Return !
OrdinaryDefineOwnProperty
(
O
,
P
,
Desc
).
10.4.5.5
[[Get]]
(
P
,
Receiver
)
The
[[Get]]
internal method of a
TypedArray
O
takes arguments
P
(a
property key
) and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
If
P
is a String
, then
Let
numericIndex
be
CanonicalNumericIndexString
(
P
).
If
numericIndex
is not
undefined
, then
Return
TypedArrayGetElement
(
O
,
numericIndex
).
Return ?
OrdinaryGet
(
O
,
P
,
Receiver
).
10.4.5.6
[[Set]]
(
P
,
V
,
Receiver
)
The
[[Set]]
internal method of a
TypedArray
O
takes arguments
P
(a
property key
),
V
(an
ECMAScript language value
), and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
P
is a String
, then
Let
numericIndex
be
CanonicalNumericIndexString
(
P
).
If
numericIndex
is not
undefined
, then
If
SameValue
(
O
,
Receiver
) is
true
, then
Perform ?
TypedArraySetElement
(
O
,
numericIndex
,
V
).
Return
true
.
If
IsValidIntegerIndex
(
O
,
numericIndex
) is
false
, return
true
.
Return ?
OrdinarySet
(
O
,
P
,
V
,
Receiver
).
10.4.5.7
[[Delete]]
(
P
)
The
[[Delete]]
internal method of a
TypedArray
O
takes argument
P
(a
property key
) and returns a
normal completion containing
a Boolean. It performs the following steps when called:
If
P
is a String
, then
Let
numericIndex
be
CanonicalNumericIndexString
(
P
).
If
numericIndex
is not
undefined
, then
If
IsValidIntegerIndex
(
O
,
numericIndex
) is
false
, return
true
; else return
false
.
Return !
OrdinaryDelete
(
O
,
P
).
10.4.5.8
[[OwnPropertyKeys]]
( )
The
[[OwnPropertyKeys]]
internal method of a
TypedArray
O
takes no arguments and returns a
normal completion containing
a
List
of
property keys
. It performs the following steps when called:
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
Let
keys
be a new empty
List
.
If
IsTypedArrayOutOfBounds
(
taRecord
) is
false
, then
Let
length
be
TypedArrayLength
(
taRecord
).
For each
integer
i
such that 0 ≤
i
<
length
, in ascending order, do
Append !
ToString
(
𝔽
(
i
)) to
keys
.
For each own
property key
P
of
O
such that
P
is a String
and
P
is not an
integer index
, in ascending chronological order of property creation, do
Append
P
to
keys
.
For each own
property key
P
of
O
such that
P
is a Symbol
, in ascending chronological order of property creation, do
Append
P
to
keys
.
Return
keys
.
10.4.5.9
TypedArray With Buffer Witness Records
An
TypedArray With Buffer Witness Record
is a
Record
value used to encapsulate a
TypedArray
along with a cached byte length of the viewed buffer. It is used to help ensure there is a single
ReadSharedMemory
event of the byte length data block when the viewed buffer is a
growable SharedArrayBuffer
.
TypedArray With Buffer Witness Records have the fields listed in
Table 27
.
Table 27:
TypedArray With Buffer Witness Record
Fields
Field Name
Value
Meaning
[[Object]]
a
TypedArray
The
TypedArray
whose buffer's byte length is loaded.
[[CachedBufferByteLength]]
a non-negative
integer
or
detached
The byte length of the object's
[[ViewedArrayBuffer]]
when the
Record
was created.
10.4.5.10
MakeTypedArrayWithBufferWitnessRecord (
obj
,
order
)
The abstract operation MakeTypedArrayWithBufferWitnessRecord takes arguments
obj
(a
TypedArray
) and
order
(
seq-cst
or
unordered
) and returns a
TypedArray With Buffer Witness Record
. It performs the following steps when called:
Let
buffer
be
obj
.
[[ViewedArrayBuffer]]
.
If
IsDetachedBuffer
(
buffer
) is
true
, then
Let
byteLength
be
detached
.
Else,
Let
byteLength
be
ArrayBufferByteLength
(
buffer
,
order
).
Return the
TypedArray With Buffer Witness Record
{
[[Object]]
:
obj
,
[[CachedBufferByteLength]]
:
byteLength
}.
10.4.5.11
TypedArrayCreate (
prototype
)
The abstract operation TypedArrayCreate takes argument
prototype
(an Object) and returns a
TypedArray
. It is used to specify the creation of new
TypedArrays
. It performs the following steps when called:
Let
internalSlotsList
be «
[[Prototype]]
,
[[Extensible]]
,
[[ViewedArrayBuffer]]
,
[[TypedArrayName]]
,
[[ContentType]]
,
[[ByteLength]]
,
[[ByteOffset]]
,
[[ArrayLength]]
».
Let
A
be
MakeBasicObject
(
internalSlotsList
).
Set
A
.
[[PreventExtensions]]
as specified in
10.4.5.1
.
Set
A
.
[[GetOwnProperty]]
as specified in
10.4.5.2
.
Set
A
.
[[HasProperty]]
as specified in
10.4.5.3
.
Set
A
.
[[DefineOwnProperty]]
as specified in
10.4.5.4
.
Set
A
.
[[Get]]
as specified in
10.4.5.5
.
Set
A
.
[[Set]]
as specified in
10.4.5.6
.
Set
A
.
[[Delete]]
as specified in
10.4.5.7
.
Set
A
.
[[OwnPropertyKeys]]
as specified in
10.4.5.8
.
Set
A
.
[[Prototype]]
to
prototype
.
Return
A
.
10.4.5.12
TypedArrayByteLength (
taRecord
)
The abstract operation TypedArrayByteLength takes argument
taRecord
(a
TypedArray With Buffer Witness Record
) and returns a non-negative
integer
. It performs the following steps when called:
Assert
:
IsTypedArrayOutOfBounds
(
taRecord
) is
false
.
Let
O
be
taRecord
.
[[Object]]
.
If
O
.
[[ByteLength]]
is not
auto
, return
O
.
[[ByteLength]]
.
Let
length
be
TypedArrayLength
(
taRecord
).
Let
elementSize
be
TypedArrayElementSize
(
O
).
NOTE: The returned byte length is always an
integer
multiple of
elementSize
, even when the underlying buffer has been resized to a non-
integer
multiple.
Return
length
×
elementSize
.
10.4.5.13
TypedArrayLength (
taRecord
)
The abstract operation TypedArrayLength takes argument
taRecord
(a
TypedArray With Buffer Witness Record
) and returns a non-negative
integer
. It performs the following steps when called:
Assert
:
IsTypedArrayOutOfBounds
(
taRecord
) is
false
.
Let
O
be
taRecord
.
[[Object]]
.
If
O
.
[[ArrayLength]]
is not
auto
, return
O
.
[[ArrayLength]]
.
Assert
:
IsFixedLengthArrayBuffer
(
O
.
[[ViewedArrayBuffer]]
) is
false
.
Let
byteOffset
be
O
.
[[ByteOffset]]
.
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
byteLength
be
taRecord
.
[[CachedBufferByteLength]]
.
Assert
:
byteLength
is not
detached
.
Return
floor
((
byteLength
-
byteOffset
) /
elementSize
).
10.4.5.14
IsTypedArrayOutOfBounds (
taRecord
)
The abstract operation IsTypedArrayOutOfBounds takes argument
taRecord
(a
TypedArray With Buffer Witness Record
) and returns a Boolean. It checks if any of the object's numeric properties reference a value at an index not contained within the underlying buffer's bounds. It performs the following steps when called:
Let
O
be
taRecord
.
[[Object]]
.
Let
bufferByteLength
be
taRecord
.
[[CachedBufferByteLength]]
.
If
IsDetachedBuffer
(
O
.
[[ViewedArrayBuffer]]
) is
true
, then
Assert
:
bufferByteLength
is
detached
.
Return
true
.
Assert
:
bufferByteLength
is a non-negative
integer
.
Let
byteOffsetStart
be
O
.
[[ByteOffset]]
.
If
O
.
[[ArrayLength]]
is
auto
, then
Let
byteOffsetEnd
be
bufferByteLength
.
Else,
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
arrayByteLength
be
O
.
[[ArrayLength]]
×
elementSize
.
Let
byteOffsetEnd
be
byteOffsetStart
+
arrayByteLength
.
NOTE: A 0-length
TypedArray
whose
[[ByteOffset]]
is
bufferByteLength
is not considered out-of-bounds.
If
byteOffsetStart
>
bufferByteLength
or
byteOffsetEnd
>
bufferByteLength
, return
true
.
Return
false
.
10.4.5.15
IsTypedArrayFixedLength (
O
)
The abstract operation IsTypedArrayFixedLength takes argument
O
(a
TypedArray
) and returns a Boolean. It performs the following steps when called:
If
O
.
[[ArrayLength]]
is
auto
, return
false
.
Let
buffer
be
O
.
[[ViewedArrayBuffer]]
.
If
IsFixedLengthArrayBuffer
(
buffer
) is
false
and
IsSharedArrayBuffer
(
buffer
) is
false
, return
false
.
Return
true
.
10.4.5.16
IsValidIntegerIndex (
O
,
index
)
The abstract operation IsValidIntegerIndex takes arguments
O
(a
TypedArray
) and
index
(a Number) and returns a Boolean. It performs the following steps when called:
If
IsDetachedBuffer
(
O
.
[[ViewedArrayBuffer]]
) is
true
, return
false
.
If
index
is not an
integral Number
, return
false
.
If
index
is
-0
𝔽
or
index
<
-0
𝔽
, return
false
.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
unordered
).
NOTE: Bounds checking is not a synchronizing operation when
O
's backing buffer is a
growable SharedArrayBuffer
.
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, return
false
.
Let
length
be
TypedArrayLength
(
taRecord
).
If
ℝ
(
index
) ≥
length
, return
false
.
Return
true
.
10.4.5.17
TypedArrayGetElement (
O
,
index
)
The abstract operation TypedArrayGetElement takes arguments
O
(a
TypedArray
) and
index
(a Number) and returns a Number, a BigInt, or
undefined
. It performs the following steps when called:
If
IsValidIntegerIndex
(
O
,
index
) is
false
, return
undefined
.
Let
offset
be
O
.
[[ByteOffset]]
.
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
byteIndexInBuffer
be (
ℝ
(
index
) ×
elementSize
) +
offset
.
Let
elementType
be
TypedArrayElementType
(
O
).
Return
GetValueFromBuffer
(
O
.
[[ViewedArrayBuffer]]
,
byteIndexInBuffer
,
elementType
,
true
,
unordered
).
10.4.5.18
TypedArraySetElement (
O
,
index
,
value
)
The abstract operation TypedArraySetElement takes arguments
O
(a
TypedArray
),
index
(a Number), and
value
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
If
O
.
[[ContentType]]
is
bigint
, let
numValue
be ?
ToBigInt
(
value
).
Otherwise, let
numValue
be ?
ToNumber
(
value
).
If
IsValidIntegerIndex
(
O
,
index
) is
true
, then
Let
offset
be
O
.
[[ByteOffset]]
.
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
byteIndexInBuffer
be (
ℝ
(
index
) ×
elementSize
) +
offset
.
Let
elementType
be
TypedArrayElementType
(
O
).
Perform
SetValueInBuffer
(
O
.
[[ViewedArrayBuffer]]
,
byteIndexInBuffer
,
elementType
,
numValue
,
true
,
unordered
).
Return
unused
.
Note
This operation always appears to succeed, but it has no effect when attempting to write past the end of a
TypedArray
or to a
TypedArray
which is backed by a detached ArrayBuffer.
10.4.5.19
IsArrayBufferViewOutOfBounds (
O
)
The abstract operation IsArrayBufferViewOutOfBounds takes argument
O
(a
TypedArray
or a DataView) and returns a Boolean. It checks if either any of a
TypedArray
's numeric properties or a DataView object's methods can reference a value at an index not contained within the underlying data block's bounds. This abstract operation exists as a convenience for upstream specifications. It performs the following steps when called:
If
O
has a
[[DataView]]
internal slot, then
Let
viewRecord
be
MakeDataViewWithBufferWitnessRecord
(
O
,
seq-cst
).
Return
IsViewOutOfBounds
(
viewRecord
).
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
Return
IsTypedArrayOutOfBounds
(
taRecord
).
10.4.6
Module Namespace Exotic Objects
A
module namespace exotic object
is an
exotic object
that exposes the bindings exported from an ECMAScript
Module
(See
16.2.3
). There is a one-to-one correspondence between the String-keyed own properties of a
module namespace exotic object
and the binding names exported by the
Module
. The exported bindings include any bindings that are indirectly exported using
export *
export items. Each String-valued own
property key
is the
StringValue
of the corresponding exported binding name. These are the only String-keyed properties of a
module namespace exotic object
. Each such property has the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
false
}.
Module namespace exotic objects
are not extensible.
An object is a
module namespace exotic object
if its
[[GetPrototypeOf]]
,
[[SetPrototypeOf]]
,
[[IsExtensible]]
,
[[PreventExtensions]]
,
[[GetOwnProperty]]
,
[[DefineOwnProperty]]
,
[[HasProperty]]
,
[[Get]]
,
[[Set]]
,
[[Delete]]
, and
[[OwnPropertyKeys]]
internal methods use the definitions in this section, and its other essential internal methods use the definitions found in
10.1
. These methods are installed by
ModuleNamespaceCreate
.
Module namespace exotic objects
have the internal slots defined in
Table 28
.
Table 28: Internal Slots of Module Namespace Exotic Objects
Internal Slot
Type
Description
[[Module]]
a
Module Record
The
Module Record
whose exports this namespace exposes.
[[Exports]]
a
List
of Strings
A
List
whose elements are the String values of the exported names exposed as own properties of this object. The list is sorted according to
lexicographic code unit order
.
10.4.6.1
[[GetPrototypeOf]]
( )
The
[[GetPrototypeOf]]
internal method of a
module namespace exotic object
takes no arguments and returns a
normal completion containing
null
. It performs the following steps when called:
Return
null
.
10.4.6.2
[[SetPrototypeOf]]
(
V
)
The
[[SetPrototypeOf]]
internal method of a
module namespace exotic object
O
takes argument
V
(an Object or
null
) and returns a
normal completion containing
a Boolean. It performs the following steps when called:
Return !
SetImmutablePrototype
(
O
,
V
).
10.4.6.3
[[IsExtensible]]
( )
The
[[IsExtensible]]
internal method of a
module namespace exotic object
takes no arguments and returns a
normal completion containing
false
. It performs the following steps when called:
Return
false
.
10.4.6.4
[[PreventExtensions]]
( )
The
[[PreventExtensions]]
internal method of a
module namespace exotic object
takes no arguments and returns a
normal completion containing
true
. It performs the following steps when called:
Return
true
.
10.4.6.5
[[GetOwnProperty]]
(
P
)
The
[[GetOwnProperty]]
internal method of a
module namespace exotic object
O
takes argument
P
(a
property key
) and returns either a
normal completion containing
either a
Property Descriptor
or
undefined
, or a
throw completion
. It performs the following steps when called:
If
P
is a Symbol
, return
OrdinaryGetOwnProperty
(
O
,
P
).
Let
exports
be
O
.
[[Exports]]
.
If
exports
does not contain
P
, return
undefined
.
Let
value
be ?
O
.
[[Get]]
(
P
,
O
).
Return PropertyDescriptor {
[[Value]]
:
value
,
[[Writable]]
:
true
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
false
}.
10.4.6.6
[[DefineOwnProperty]]
(
P
,
Desc
)
The
[[DefineOwnProperty]]
internal method of a
module namespace exotic object
O
takes arguments
P
(a
property key
) and
Desc
(a
Property Descriptor
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
P
is a Symbol
, return !
OrdinaryDefineOwnProperty
(
O
,
P
,
Desc
).
Let
current
be ?
O
.
[[GetOwnProperty]]
(
P
).
If
current
is
undefined
, return
false
.
If
Desc
has a
[[Configurable]]
field and
Desc
.
[[Configurable]]
is
true
, return
false
.
If
Desc
has an
[[Enumerable]]
field and
Desc
.
[[Enumerable]]
is
false
, return
false
.
If
IsAccessorDescriptor
(
Desc
) is
true
, return
false
.
If
Desc
has a
[[Writable]]
field and
Desc
.
[[Writable]]
is
false
, return
false
.
If
Desc
has a
[[Value]]
field, return
SameValue
(
Desc
.
[[Value]]
,
current
.
[[Value]]
).
Return
true
.
10.4.6.7
[[HasProperty]]
(
P
)
The
[[HasProperty]]
internal method of a
module namespace exotic object
O
takes argument
P
(a
property key
) and returns a
normal completion containing
a Boolean. It performs the following steps when called:
If
P
is a Symbol
, return !
OrdinaryHasProperty
(
O
,
P
).
Let
exports
be
O
.
[[Exports]]
.
If
exports
contains
P
, return
true
.
Return
false
.
10.4.6.8
[[Get]]
(
P
,
Receiver
)
The
[[Get]]
internal method of a
module namespace exotic object
O
takes arguments
P
(a
property key
) and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
If
P
is a Symbol
, then
Return !
OrdinaryGet
(
O
,
P
,
Receiver
).
Let
exports
be
O
.
[[Exports]]
.
If
exports
does not contain
P
, return
undefined
.
Let
m
be
O
.
[[Module]]
.
Let
binding
be
m
.
ResolveExport
(
P
).
Assert
:
binding
is a
ResolvedBinding Record
.
Let
targetModule
be
binding
.
[[Module]]
.
Assert
:
targetModule
is not
undefined
.
If
binding
.
[[BindingName]]
is
namespace
, then
Return
GetModuleNamespace
(
targetModule
).
Let
targetEnv
be
targetModule
.
[[Environment]]
.
If
targetEnv
is
empty
, throw a
ReferenceError
exception.
Return ?
targetEnv
.
GetBindingValue
(
binding
.
[[BindingName]]
,
true
).
Note
ResolveExport
is side-effect free. Each time this operation is called with a specific
exportName
,
resolveSet
pair as arguments it must return the same result. An implementation might choose to pre-compute or cache the
ResolveExport
results for the
[[Exports]]
of each
module namespace exotic object
.
10.4.6.9
[[Set]]
(
P
,
V
,
Receiver
)
The
[[Set]]
internal method of a
module namespace exotic object
takes arguments
P
(a
property key
),
V
(an
ECMAScript language value
), and
Receiver
(an
ECMAScript language value
) and returns a
normal completion containing
false
. It performs the following steps when called:
Return
false
.
10.4.6.10
[[Delete]]
(
P
)
The
[[Delete]]
internal method of a
module namespace exotic object
O
takes argument
P
(a
property key
) and returns a
normal completion containing
a Boolean. It performs the following steps when called:
If
P
is a Symbol
, then
Return !
OrdinaryDelete
(
O
,
P
).
Let
exports
be
O
.
[[Exports]]
.
If
exports
contains
P
, return
false
.
Return
true
.
10.4.6.11
[[OwnPropertyKeys]]
( )
The
[[OwnPropertyKeys]]
internal method of a
module namespace exotic object
O
takes no arguments and returns a
normal completion containing
a
List
of
property keys
. It performs the following steps when called:
Let
exports
be
O
.
[[Exports]]
.
Let
symbolKeys
be
OrdinaryOwnPropertyKeys
(
O
).
Return the
list-concatenation
of
exports
and
symbolKeys
.
10.4.6.12
ModuleNamespaceCreate (
module
,
exports
)
The abstract operation ModuleNamespaceCreate takes arguments
module
(a
Module Record
) and
exports
(a
List
of Strings) and returns a
module namespace exotic object
. It is used to specify the creation of new
module namespace exotic objects
. It performs the following steps when called:
Assert
:
module
.
[[Namespace]]
is
empty
.
Let
internalSlotsList
be the internal slots listed in
Table 28
.
Let
M
be
MakeBasicObject
(
internalSlotsList
).
Set
M
's essential internal methods to the definitions specified in
10.4.6
.
Set
M
.
[[Module]]
to
module
.
Let
sortedExports
be a
List
whose elements are the elements of
exports
, sorted according to
lexicographic code unit order
.
Set
M
.
[[Exports]]
to
sortedExports
.
Create own properties of
M
corresponding to the definitions in
28.3
.
Set
module
.
[[Namespace]]
to
M
.
Return
M
.
10.4.7
Immutable Prototype Exotic Objects
An
immutable prototype exotic object
is an
exotic object
that has a
[[Prototype]]
internal slot that will not change once it is initialized.
An object is an
immutable prototype exotic object
if its
[[SetPrototypeOf]]
internal method uses the following implementation. (Its other essential internal methods may use any implementation, depending on the specific
immutable prototype exotic object
in question.)
Note
Unlike other
exotic objects
, there is not a dedicated creation abstract operation provided for
immutable prototype exotic objects
. This is because they are only used by
%Object.prototype%
and by
host environments
, and in
host environments
, the relevant objects are potentially exotic in other ways and thus need their own dedicated creation operation.
10.4.7.1
[[SetPrototypeOf]]
(
V
)
The
[[SetPrototypeOf]]
internal method of an
immutable prototype exotic object
O
takes argument
V
(an Object or
null
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Return ?
SetImmutablePrototype
(
O
,
V
).
10.4.7.2
SetImmutablePrototype (
O
,
V
)
The abstract operation SetImmutablePrototype takes arguments
O
(an Object) and
V
(an Object or
null
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Let
current
be ?
O
.
[[GetPrototypeOf]]
()
.
If
SameValue
(
V
,
current
) is
true
, return
true
.
Return
false
.
10.5
Proxy Object Internal Methods and Internal Slots
A Proxy object is an
exotic object
whose essential internal methods are partially implemented using ECMAScript code. Every Proxy object has an internal slot called
[[ProxyHandler]]
. The value of
[[ProxyHandler]]
is an object, called the proxy's
handler object
, or
null
. Methods (see
Table 29
) of a handler object may be used to augment the implementation for one or more of the Proxy object's internal methods. Every Proxy object also has an internal slot called
[[ProxyTarget]]
whose value is either an object or
null
. This object is called the proxy's
target object
.
An object is a
Proxy exotic object
if its essential internal methods (including
[[Call]]
and
[[Construct]]
, if applicable) use the definitions in this section. These internal methods are installed in
ProxyCreate
.
Table 29: Proxy Handler Methods
Internal Method
Handler Method
[[GetPrototypeOf]]
getPrototypeOf
[[SetPrototypeOf]]
setPrototypeOf
[[IsExtensible]]
isExtensible
[[PreventExtensions]]
preventExtensions
[[GetOwnProperty]]
getOwnPropertyDescriptor
[[DefineOwnProperty]]
defineProperty
[[HasProperty]]
has
[[Get]]
get
[[Set]]
set
[[Delete]]
deleteProperty
[[OwnPropertyKeys]]
ownKeys
[[Call]]
apply
[[Construct]]
construct
When a handler method is called to provide the implementation of a Proxy object internal method, the handler method is passed the proxy's target object as a parameter. A proxy's handler object does not necessarily have a method corresponding to every essential internal method. Invoking an internal method on the proxy results in the invocation of the corresponding internal method on the proxy's target object if the handler object does not have a method corresponding to the internal trap.
The
[[ProxyHandler]]
and
[[ProxyTarget]]
internal slots of a Proxy object are always initialized when the object is created and typically may not be modified. Some Proxy objects are created in a manner that permits them to be subsequently
revoked
. When a proxy is revoked, its
[[ProxyHandler]]
and
[[ProxyTarget]]
internal slots are set to
null
causing subsequent invocations of internal methods on that Proxy object to throw a
TypeError
exception.
Because Proxy objects permit the implementation of internal methods to be provided by arbitrary ECMAScript code, it is possible to define a Proxy object whose handler methods violates the invariants defined in
6.1.7.3
. Some of the internal method invariants defined in
6.1.7.3
are essential integrity invariants. These invariants are explicitly enforced by the Proxy object internal methods specified in this section. An ECMAScript implementation must be robust in the presence of all possible invariant violations.
In the following algorithm descriptions, assume
O
is an ECMAScript Proxy object,
P
is a
property key
value,
V
is any
ECMAScript language value
and
Desc
is a
Property Descriptor
record.
10.5.1
[[GetPrototypeOf]]
( )
The
[[GetPrototypeOf]]
internal method of a
Proxy exotic object
O
takes no arguments and returns either a
normal completion containing
either an Object or
null
, or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"getPrototypeOf"
).
If
trap
is
undefined
, then
Return ?
target
.
[[GetPrototypeOf]]
()
.
Let
handlerProto
be ?
Call
(
trap
,
handler
, «
target
»).
If
handlerProto
is not an Object
and
handlerProto
is not
null
, throw a
TypeError
exception.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
If
extensibleTarget
is
true
, return
handlerProto
.
Let
targetProto
be ?
target
.
[[GetPrototypeOf]]
()
.
If
SameValue
(
handlerProto
,
targetProto
) is
false
, throw a
TypeError
exception.
Return
handlerProto
.
Note
[[GetPrototypeOf]]
for Proxy objects enforces the following invariants:
The result of
[[GetPrototypeOf]]
must be either an Object or
null
.
If the target object is not extensible,
[[GetPrototypeOf]]
applied to the Proxy object must return the same value as
[[GetPrototypeOf]]
applied to the Proxy object's target object.
10.5.2
[[SetPrototypeOf]]
(
V
)
The
[[SetPrototypeOf]]
internal method of a
Proxy exotic object
O
takes argument
V
(an Object or
null
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"setPrototypeOf"
).
If
trap
is
undefined
, then
Return ?
target
.
[[SetPrototypeOf]]
(
V
)
.
Let
booleanTrapResult
be
ToBoolean
(?
Call
(
trap
,
handler
, «
target
,
V
»)).
If
booleanTrapResult
is
false
, return
false
.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
If
extensibleTarget
is
true
, return
true
.
Let
targetProto
be ?
target
.
[[GetPrototypeOf]]
()
.
If
SameValue
(
V
,
targetProto
) is
false
, throw a
TypeError
exception.
Return
true
.
Note
[[SetPrototypeOf]]
for Proxy objects enforces the following invariants:
The result of
[[SetPrototypeOf]]
is a Boolean
value.
If the target object is not extensible, the argument value must be the same as the result of
[[GetPrototypeOf]]
applied to target object.
10.5.3
[[IsExtensible]]
( )
The
[[IsExtensible]]
internal method of a
Proxy exotic object
O
takes no arguments and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"isExtensible"
).
If
trap
is
undefined
, then
Return ?
IsExtensible
(
target
).
Let
booleanTrapResult
be
ToBoolean
(?
Call
(
trap
,
handler
, «
target
»)).
Let
targetResult
be ?
IsExtensible
(
target
).
If
booleanTrapResult
is not
targetResult
, throw a
TypeError
exception.
Return
booleanTrapResult
.
Note
[[IsExtensible]]
for Proxy objects enforces the following invariants:
The result of
[[IsExtensible]]
is a Boolean
value.
[[IsExtensible]]
applied to the Proxy object must return the same value as
[[IsExtensible]]
applied to the Proxy object's target object with the same argument.
10.5.4
[[PreventExtensions]]
( )
The
[[PreventExtensions]]
internal method of a
Proxy exotic object
O
takes no arguments and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"preventExtensions"
).
If
trap
is
undefined
, then
Return ?
target
.
[[PreventExtensions]]
()
.
Let
booleanTrapResult
be
ToBoolean
(?
Call
(
trap
,
handler
, «
target
»)).
If
booleanTrapResult
is
true
, then
Let
extensibleTarget
be ?
IsExtensible
(
target
).
If
extensibleTarget
is
true
, throw a
TypeError
exception.
Return
booleanTrapResult
.
Note
[[PreventExtensions]]
for Proxy objects enforces the following invariants:
The result of
[[PreventExtensions]]
is a Boolean
value.
[[PreventExtensions]]
applied to the Proxy object only returns
true
if
[[IsExtensible]]
applied to the Proxy object's target object is
false
.
10.5.5
[[GetOwnProperty]]
(
P
)
The
[[GetOwnProperty]]
internal method of a
Proxy exotic object
O
takes argument
P
(a
property key
) and returns either a
normal completion containing
either a
Property Descriptor
or
undefined
, or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"getOwnPropertyDescriptor"
).
If
trap
is
undefined
, then
Return ?
target
.
[[GetOwnProperty]]
(
P
)
.
Let
trapResultObj
be ?
Call
(
trap
,
handler
, «
target
,
P
»).
If
trapResultObj
is not an Object
and
trapResultObj
is not
undefined
, throw a
TypeError
exception.
Let
targetDesc
be ?
target
.
[[GetOwnProperty]]
(
P
)
.
If
trapResultObj
is
undefined
, then
If
targetDesc
is
undefined
, return
undefined
.
If
targetDesc
.
[[Configurable]]
is
false
, throw a
TypeError
exception.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
If
extensibleTarget
is
false
, throw a
TypeError
exception.
Return
undefined
.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
Let
resultDesc
be ?
ToPropertyDescriptor
(
trapResultObj
).
Perform
CompletePropertyDescriptor
(
resultDesc
).
Let
valid
be
IsCompatiblePropertyDescriptor
(
extensibleTarget
,
resultDesc
,
targetDesc
).
If
valid
is
false
, throw a
TypeError
exception.
If
resultDesc
.
[[Configurable]]
is
false
, then
If
targetDesc
is
undefined
or
targetDesc
.
[[Configurable]]
is
true
, then
Throw a
TypeError
exception.
If
resultDesc
has a
[[Writable]]
field and
resultDesc
.
[[Writable]]
is
false
, then
Assert
:
targetDesc
has a
[[Writable]]
field.
If
targetDesc
.
[[Writable]]
is
true
, throw a
TypeError
exception.
Return
resultDesc
.
Note
[[GetOwnProperty]]
for Proxy objects enforces the following invariants:
The result of
[[GetOwnProperty]]
must be either an Object or
undefined
.
A property cannot be reported as non-existent, if it exists as a non-configurable own property of the target object.
A property cannot be reported as non-existent, if it exists as an own property of a non-extensible target object.
A property cannot be reported as existent, if it does not exist as an own property of the target object and the target object is not extensible.
A property cannot be reported as non-configurable, unless it exists as a non-configurable own property of the target object.
A property cannot be reported as both non-configurable and non-writable, unless it exists as a non-configurable, non-writable own property of the target object.
10.5.6
[[DefineOwnProperty]]
(
P
,
Desc
)
The
[[DefineOwnProperty]]
internal method of a
Proxy exotic object
O
takes arguments
P
(a
property key
) and
Desc
(a
Property Descriptor
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"defineProperty"
).
If
trap
is
undefined
, then
Return ?
target
.
[[DefineOwnProperty]]
(
P
,
Desc
)
.
Let
descObj
be
FromPropertyDescriptor
(
Desc
).
Let
booleanTrapResult
be
ToBoolean
(?
Call
(
trap
,
handler
, «
target
,
P
,
descObj
»)).
If
booleanTrapResult
is
false
, return
false
.
Let
targetDesc
be ?
target
.
[[GetOwnProperty]]
(
P
)
.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
If
Desc
has a
[[Configurable]]
field and
Desc
.
[[Configurable]]
is
false
, then
Let
settingConfigFalse
be
true
.
Else,
Let
settingConfigFalse
be
false
.
If
targetDesc
is
undefined
, then
If
extensibleTarget
is
false
, throw a
TypeError
exception.
If
settingConfigFalse
is
true
, throw a
TypeError
exception.
Else,
If
IsCompatiblePropertyDescriptor
(
extensibleTarget
,
Desc
,
targetDesc
) is
false
, throw a
TypeError
exception.
If
settingConfigFalse
is
true
and
targetDesc
.
[[Configurable]]
is
true
, throw a
TypeError
exception.
If
IsDataDescriptor
(
targetDesc
) is
true
,
targetDesc
.
[[Configurable]]
is
false
, and
targetDesc
.
[[Writable]]
is
true
, then
If
Desc
has a
[[Writable]]
field and
Desc
.
[[Writable]]
is
false
, throw a
TypeError
exception.
Return
true
.
Note
[[DefineOwnProperty]]
for Proxy objects enforces the following invariants:
The result of
[[DefineOwnProperty]]
is a Boolean
value.
A property cannot be added, if the target object is not extensible.
A property cannot be non-configurable, unless there exists a corresponding non-configurable own property of the target object.
A non-configurable property cannot be non-writable, unless there exists a corresponding non-configurable, non-writable own property of the target object.
If a property has a corresponding target object property then applying the
Property Descriptor
of the property to the target object using
[[DefineOwnProperty]]
will not throw an exception.
10.5.7
[[HasProperty]]
(
P
)
The
[[HasProperty]]
internal method of a
Proxy exotic object
O
takes argument
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"has"
).
If
trap
is
undefined
, then
Return ?
target
.
[[HasProperty]]
(
P
)
.
Let
booleanTrapResult
be
ToBoolean
(?
Call
(
trap
,
handler
, «
target
,
P
»)).
If
booleanTrapResult
is
false
, then
Let
targetDesc
be ?
target
.
[[GetOwnProperty]]
(
P
)
.
If
targetDesc
is not
undefined
, then
If
targetDesc
.
[[Configurable]]
is
false
, throw a
TypeError
exception.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
If
extensibleTarget
is
false
, throw a
TypeError
exception.
Return
booleanTrapResult
.
Note
[[HasProperty]]
for Proxy objects enforces the following invariants:
The result of
[[HasProperty]]
is a Boolean
value.
A property cannot be reported as non-existent, if it exists as a non-configurable own property of the target object.
A property cannot be reported as non-existent, if it exists as an own property of the target object and the target object is not extensible.
10.5.8
[[Get]]
(
P
,
Receiver
)
The
[[Get]]
internal method of a
Proxy exotic object
O
takes arguments
P
(a
property key
) and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"get"
).
If
trap
is
undefined
, then
Return ?
target
.
[[Get]]
(
P
,
Receiver
)
.
Let
trapResult
be ?
Call
(
trap
,
handler
, «
target
,
P
,
Receiver
»).
Let
targetDesc
be ?
target
.
[[GetOwnProperty]]
(
P
)
.
If
targetDesc
is not
undefined
and
targetDesc
.
[[Configurable]]
is
false
, then
If
IsDataDescriptor
(
targetDesc
) is
true
and
targetDesc
.
[[Writable]]
is
false
, then
If
SameValue
(
trapResult
,
targetDesc
.
[[Value]]
) is
false
, throw a
TypeError
exception.
If
IsAccessorDescriptor
(
targetDesc
) is
true
and
targetDesc
.
[[Get]]
is
undefined
, then
If
trapResult
is not
undefined
, throw a
TypeError
exception.
Return
trapResult
.
Note
[[Get]]
for Proxy objects enforces the following invariants:
The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable own
data property
.
The value reported for a property must be
undefined
if the corresponding target object property is a non-configurable own
accessor property
that has
undefined
as its
[[Get]]
attribute.
10.5.9
[[Set]]
(
P
,
V
,
Receiver
)
The
[[Set]]
internal method of a
Proxy exotic object
O
takes arguments
P
(a
property key
),
V
(an
ECMAScript language value
), and
Receiver
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"set"
).
If
trap
is
undefined
, then
Return ?
target
.
[[Set]]
(
P
,
V
,
Receiver
)
.
Let
booleanTrapResult
be
ToBoolean
(?
Call
(
trap
,
handler
, «
target
,
P
,
V
,
Receiver
»)).
If
booleanTrapResult
is
false
, return
false
.
Let
targetDesc
be ?
target
.
[[GetOwnProperty]]
(
P
)
.
If
targetDesc
is not
undefined
and
targetDesc
.
[[Configurable]]
is
false
, then
If
IsDataDescriptor
(
targetDesc
) is
true
and
targetDesc
.
[[Writable]]
is
false
, then
If
SameValue
(
V
,
targetDesc
.
[[Value]]
) is
false
, throw a
TypeError
exception.
If
IsAccessorDescriptor
(
targetDesc
) is
true
, then
If
targetDesc
.
[[Set]]
is
undefined
, throw a
TypeError
exception.
Return
true
.
Note
[[Set]]
for Proxy objects enforces the following invariants:
The result of
[[Set]]
is a Boolean
value.
Cannot change the value of a property to be different from the value of the corresponding target object property if the corresponding target object property is a non-writable, non-configurable own
data property
.
Cannot set the value of a property if the corresponding target object property is a non-configurable own
accessor property
that has
undefined
as its
[[Set]]
attribute.
10.5.10
[[Delete]]
(
P
)
The
[[Delete]]
internal method of a
Proxy exotic object
O
takes argument
P
(a
property key
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"deleteProperty"
).
If
trap
is
undefined
, then
Return ?
target
.
[[Delete]]
(
P
)
.
Let
booleanTrapResult
be
ToBoolean
(?
Call
(
trap
,
handler
, «
target
,
P
»)).
If
booleanTrapResult
is
false
, return
false
.
Let
targetDesc
be ?
target
.
[[GetOwnProperty]]
(
P
)
.
If
targetDesc
is
undefined
, return
true
.
If
targetDesc
.
[[Configurable]]
is
false
, throw a
TypeError
exception.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
If
extensibleTarget
is
false
, throw a
TypeError
exception.
Return
true
.
Note
[[Delete]]
for Proxy objects enforces the following invariants:
The result of
[[Delete]]
is a Boolean
value.
A property cannot be reported as deleted, if it exists as a non-configurable own property of the target object.
A property cannot be reported as deleted, if it exists as an own property of the target object and the target object is non-extensible.
10.5.11
[[OwnPropertyKeys]]
( )
The
[[OwnPropertyKeys]]
internal method of a
Proxy exotic object
O
takes no arguments and returns either a
normal completion containing
a
List
of
property keys
or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"ownKeys"
).
If
trap
is
undefined
, then
Return ?
target
.
[[OwnPropertyKeys]]
()
.
Let
trapResultArray
be ?
Call
(
trap
,
handler
, «
target
»).
Let
trapResult
be ?
CreateListFromArrayLike
(
trapResultArray
,
property-key
).
If
trapResult
contains any duplicate entries, throw a
TypeError
exception.
Let
extensibleTarget
be ?
IsExtensible
(
target
).
Let
targetKeys
be ?
target
.
[[OwnPropertyKeys]]
()
.
Assert
:
targetKeys
is a
List
of
property keys
.
Assert
:
targetKeys
contains no duplicate entries.
Let
targetConfigurableKeys
be a new empty
List
.
Let
targetNonconfigurableKeys
be a new empty
List
.
For each element
key
of
targetKeys
, do
Let
desc
be ?
target
.
[[GetOwnProperty]]
(
key
)
.
If
desc
is not
undefined
and
desc
.
[[Configurable]]
is
false
, then
Append
key
to
targetNonconfigurableKeys
.
Else,
Append
key
to
targetConfigurableKeys
.
If
extensibleTarget
is
true
and
targetNonconfigurableKeys
is empty, then
Return
trapResult
.
Let
uncheckedResultKeys
be a
List
whose elements are the elements of
trapResult
.
For each element
key
of
targetNonconfigurableKeys
, do
If
uncheckedResultKeys
does not contain
key
, throw a
TypeError
exception.
Remove
key
from
uncheckedResultKeys
.
If
extensibleTarget
is
true
, return
trapResult
.
For each element
key
of
targetConfigurableKeys
, do
If
uncheckedResultKeys
does not contain
key
, throw a
TypeError
exception.
Remove
key
from
uncheckedResultKeys
.
If
uncheckedResultKeys
is not empty, throw a
TypeError
exception.
Return
trapResult
.
Note
[[OwnPropertyKeys]]
for Proxy objects enforces the following invariants:
The result of
[[OwnPropertyKeys]]
is a
List
.
The returned
List
contains no duplicate entries.
Each element of the returned
List
is a
property key
.
The result
List
must contain the keys of all non-configurable own properties of the target object.
If the target object is not extensible, then the result
List
must contain all the keys of the own properties of the target object and no other values.
10.5.12
[[Call]]
(
thisArgument
,
argumentsList
)
The
[[Call]]
internal method of a
Proxy exotic object
O
takes arguments
thisArgument
(an
ECMAScript language value
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"apply"
).
If
trap
is
undefined
, then
Return ?
Call
(
target
,
thisArgument
,
argumentsList
).
Let
argArray
be
CreateArrayFromList
(
argumentsList
).
Return ?
Call
(
trap
,
handler
, «
target
,
thisArgument
,
argArray
»).
Note
A
Proxy exotic object
only has a
[[Call]]
internal method if the initial value of its
[[ProxyTarget]]
internal slot is an object that has a
[[Call]]
internal method.
10.5.13
[[Construct]]
(
argumentsList
,
newTarget
)
The
[[Construct]]
internal method of a
Proxy exotic object
O
takes arguments
argumentsList
(a
List
of
ECMAScript language values
) and
newTarget
(a
constructor
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
Perform ?
ValidateNonRevokedProxy
(
O
).
Let
target
be
O
.
[[ProxyTarget]]
.
Assert
:
IsConstructor
(
target
) is
true
.
Let
handler
be
O
.
[[ProxyHandler]]
.
Assert
:
handler
is an Object
.
Let
trap
be ?
GetMethod
(
handler
,
"construct"
).
If
trap
is
undefined
, then
Return ?
Construct
(
target
,
argumentsList
,
newTarget
).
Let
argArray
be
CreateArrayFromList
(
argumentsList
).
Let
newObj
be ?
Call
(
trap
,
handler
, «
target
,
argArray
,
newTarget
»).
If
newObj
is not an Object
, throw a
TypeError
exception.
Return
newObj
.
Note 1
A
Proxy exotic object
only has a
[[Construct]]
internal method if the initial value of its
[[ProxyTarget]]
internal slot is an object that has a
[[Construct]]
internal method.
Note 2
[[Construct]]
for Proxy objects enforces the following invariants:
The result of
[[Construct]]
must be an Object.
10.5.14
ValidateNonRevokedProxy (
proxy
)
The abstract operation ValidateNonRevokedProxy takes argument
proxy
(a
Proxy exotic object
) and returns either a
normal completion containing
unused
or a
throw completion
. It throws a
TypeError
exception if
proxy
has been revoked. It performs the following steps when called:
If
proxy
.
[[ProxyTarget]]
is
null
, throw a
TypeError
exception.
Assert
:
proxy
.
[[ProxyHandler]]
is not
null
.
Return
unused
.
10.5.15
ProxyCreate (
target
,
handler
)
The abstract operation ProxyCreate takes arguments
target
(an
ECMAScript language value
) and
handler
(an
ECMAScript language value
) and returns either a
normal completion containing
a
Proxy exotic object
or a
throw completion
. It is used to specify the creation of new Proxy objects. It performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
If
handler
is not an Object
, throw a
TypeError
exception.
Let
P
be
MakeBasicObject
(«
[[ProxyHandler]]
,
[[ProxyTarget]]
»).
Set
P
's essential internal methods, except for
[[Call]]
and
[[Construct]]
, to the definitions specified in
10.5
.
If
IsCallable
(
target
) is
true
, then
Set
P
.
[[Call]]
as specified in
10.5.12
.
If
IsConstructor
(
target
) is
true
, then
Set
P
.
[[Construct]]
as specified in
10.5.13
.
Set
P
.
[[ProxyTarget]]
to
target
.
Set
P
.
[[ProxyHandler]]
to
handler
.
Return
P
.
11
ECMAScript Language: Source Text
11.1
Source Text
Syntax
SourceCharacter
::
any Unicode code point
ECMAScript source text
is a sequence of Unicode code points. All Unicode code point values from U+0000 to U+10FFFF, including surrogate code points, may occur in ECMAScript source text where permitted by the ECMAScript grammars. The actual encodings used to store and interchange ECMAScript source text is not relevant to this specification. Regardless of the external source text encoding, a conforming ECMAScript implementation processes the source text as if it was an equivalent sequence of
SourceCharacter
values, each
SourceCharacter
being a Unicode code point. Conforming ECMAScript implementations are not required to perform any normalization of source text, or behave as though they were performing normalization of source text.
The components of a combining character sequence are treated as individual Unicode code points even though a user might think of the whole sequence as a single character.
Note
In string literals, regular expression literals, template literals and identifiers, any Unicode code point may also be expressed using Unicode escape sequences that explicitly express a code point's numeric value. Within a comment, such an escape sequence is effectively ignored as part of the comment.
ECMAScript differs from the Java programming language in the behaviour of Unicode escape sequences. In a Java program, if the Unicode escape sequence
\u000A
, for example, occurs within a single-line comment, it is interpreted as a line terminator (Unicode code point U+000A is LINE FEED (LF)) and therefore the next code point is not part of the comment. Similarly, if the Unicode escape sequence
\u000A
occurs within a string literal in a Java program, it is likewise interpreted as a line terminator, which is not allowed within a string literal—one must write
\n
instead of
\u000A
to cause a LINE FEED (LF) to be part of the value of a string literal. In an ECMAScript program, a Unicode escape sequence occurring within a comment is never interpreted and therefore cannot contribute to termination of the comment. Similarly, a Unicode escape sequence occurring within a string literal in an ECMAScript program always contributes to the literal and is never interpreted as a line terminator or as a code point that might terminate the string literal.
11.1.1
Static Semantics: UTF16EncodeCodePoint (
cp
)
The abstract operation UTF16EncodeCodePoint takes argument
cp
(a Unicode code point) and returns a String. It performs the following steps when called:
Assert
: 0 ≤
cp
≤ 0x10FFFF.
If
cp
≤ 0xFFFF, return the String value consisting of the code unit whose numeric value is
cp
.
Let
cu1
be the code unit whose numeric value is
floor
((
cp
- 0x10000) / 0x400) + 0xD800.
Let
cu2
be the code unit whose numeric value is ((
cp
- 0x10000)
modulo
0x400) + 0xDC00.
Return the
string-concatenation
of
cu1
and
cu2
.
11.1.2
Static Semantics: CodePointsToString (
text
)
The abstract operation CodePointsToString takes argument
text
(a sequence of Unicode code points) and returns a String. It converts
text
into a String value, as described in
6.1.4
. It performs the following steps when called:
Let
result
be the empty String.
For each code point
cp
of
text
, do
Set
result
to the
string-concatenation
of
result
and
UTF16EncodeCodePoint
(
cp
).
Return
result
.
11.1.3
Static Semantics: UTF16SurrogatePairToCodePoint (
lead
,
trail
)
The abstract operation UTF16SurrogatePairToCodePoint takes arguments
lead
(a code unit) and
trail
(a code unit) and returns a code point. Two code units that form a UTF-16
surrogate pair
are converted to a code point. It performs the following steps when called:
Assert
:
lead
is a
leading surrogate
and
trail
is a
trailing surrogate
.
Let
cp
be (
lead
- 0xD800) × 0x400 + (
trail
- 0xDC00) + 0x10000.
Return the code point
cp
.
11.1.4
Static Semantics: CodePointAt (
string
,
position
)
The abstract operation CodePointAt takes arguments
string
(a String) and
position
(a non-negative
integer
) and returns a
Record
with fields
[[CodePoint]]
(a code point),
[[CodeUnitCount]]
(a positive
integer
), and
[[IsUnpairedSurrogate]]
(a Boolean). It interprets
string
as a sequence of UTF-16 encoded code points, as described in
6.1.4
, and reads from it a single code point starting with the code unit at index
position
. It performs the following steps when called:
Let
size
be the length of
string
.
Assert
:
position
≥ 0 and
position
<
size
.
Let
first
be the code unit at index
position
within
string
.
Let
cp
be the code point whose numeric value is the numeric value of
first
.
If
first
is neither a
leading surrogate
nor a
trailing surrogate
, then
Return the
Record
{
[[CodePoint]]
:
cp
,
[[CodeUnitCount]]
: 1,
[[IsUnpairedSurrogate]]
:
false
}.
If
first
is a
trailing surrogate
or
position
+ 1 =
size
, then
Return the
Record
{
[[CodePoint]]
:
cp
,
[[CodeUnitCount]]
: 1,
[[IsUnpairedSurrogate]]
:
true
}.
Let
second
be the code unit at index
position
+ 1 within
string
.
If
second
is not a
trailing surrogate
, then
Return the
Record
{
[[CodePoint]]
:
cp
,
[[CodeUnitCount]]
: 1,
[[IsUnpairedSurrogate]]
:
true
}.
Set
cp
to
UTF16SurrogatePairToCodePoint
(
first
,
second
).
Return the
Record
{
[[CodePoint]]
:
cp
,
[[CodeUnitCount]]
: 2,
[[IsUnpairedSurrogate]]
:
false
}.
11.1.5
Static Semantics: StringToCodePoints (
string
)
The abstract operation StringToCodePoints takes argument
string
(a String) and returns a
List
of code points. It returns the sequence of Unicode code points that results from interpreting
string
as UTF-16 encoded Unicode text as described in
6.1.4
. It performs the following steps when called:
Let
codePoints
be a new empty
List
.
Let
size
be the length of
string
.
Let
position
be 0.
Repeat, while
position
<
size
,
Let
cp
be
CodePointAt
(
string
,
position
).
Append
cp
.
[[CodePoint]]
to
codePoints
.
Set
position
to
position
+
cp
.
[[CodeUnitCount]]
.
Return
codePoints
.
11.1.6
Static Semantics: ParseText (
sourceText
,
goalSymbol
)
The abstract operation ParseText takes arguments
sourceText
(a String or a sequence of Unicode code points) and
goalSymbol
(a nonterminal in one of the ECMAScript grammars) and returns a
Parse Node
or a non-empty
List
of
SyntaxError
objects. It performs the following steps when called:
If
sourceText
is a String
, set
sourceText
to
StringToCodePoints
(
sourceText
).
Attempt to parse
sourceText
using
goalSymbol
as the
goal symbol
, and analyse the parse result for any
early error
conditions. Parsing and
early error
detection may be interleaved in an
implementation-defined
manner.
If the parse succeeded and no
early errors
were found, return the
Parse Node
(an instance of
goalSymbol
) at the root of the parse tree resulting from the parse.
Otherwise, return a
List
of one or more
SyntaxError
objects representing the parsing errors and/or
early errors
. If more than one parsing error or
early error
is present, the number and ordering of error objects in the list is
implementation-defined
, but at least one must be present.
Note 1
Consider a text that has an
early error
at a particular point, and also a syntax error at a later point. An implementation that does a parse pass followed by an
early errors
pass might report the syntax error and not proceed to the
early errors
pass. An implementation that interleaves the two activities might report the
early error
and not proceed to find the syntax error. A third implementation might report both errors. All of these behaviours are conformant.
Note 2
See also clause
17
.
11.2
Types of Source Code
There are four types of ECMAScript code:
Global code
is source text that is treated as an ECMAScript
Script
. The global code of a particular
Script
does not include any source text that is parsed as part of a
FunctionDeclaration
,
FunctionExpression
,
GeneratorDeclaration
,
GeneratorExpression
,
AsyncFunctionDeclaration
,
AsyncFunctionExpression
,
AsyncGeneratorDeclaration
,
AsyncGeneratorExpression
,
MethodDefinition
,
ArrowFunction
,
AsyncArrowFunction
,
ClassDeclaration
, or
ClassExpression
.
Eval code
is the source text supplied to the built-in
eval
function. More precisely, if the parameter to the built-in
eval
function
is a String
, it is treated as an ECMAScript
Script
. The eval code for a particular invocation of
eval
is the global code portion of that
Script
.
Function code
is source text that is parsed to supply the value of the
[[ECMAScriptCode]]
and
[[FormalParameters]]
internal slots (see
10.2
) of an ECMAScript
function object
. The function code of a particular ECMAScript function does not include any source text that is parsed as the function code of a nested
FunctionDeclaration
,
FunctionExpression
,
GeneratorDeclaration
,
GeneratorExpression
,
AsyncFunctionDeclaration
,
AsyncFunctionExpression
,
AsyncGeneratorDeclaration
,
AsyncGeneratorExpression
,
MethodDefinition
,
ArrowFunction
,
AsyncArrowFunction
,
ClassDeclaration
, or
ClassExpression
.
In addition, if the source text referred to above is parsed as:
the
FormalParameters
and
FunctionBody
of a
FunctionDeclaration
or
FunctionExpression
,
the
FormalParameters
and
GeneratorBody
of a
GeneratorDeclaration
or
GeneratorExpression
,
the
FormalParameters
and
AsyncFunctionBody
of an
AsyncFunctionDeclaration
or
AsyncFunctionExpression
, or
the
FormalParameters
and
AsyncGeneratorBody
of an
AsyncGeneratorDeclaration
or
AsyncGeneratorExpression
,
then the
source text matched by
the
BindingIdentifier
(if any) of that declaration or expression is also included in the function code of the corresponding function.
Module code
is source text that is code that is provided as a
ModuleBody
. It is the code that is directly evaluated when a module is initialized. The module code of a particular module does not include any source text that is parsed as part of a nested
FunctionDeclaration
,
FunctionExpression
,
GeneratorDeclaration
,
GeneratorExpression
,
AsyncFunctionDeclaration
,
AsyncFunctionExpression
,
AsyncGeneratorDeclaration
,
AsyncGeneratorExpression
,
MethodDefinition
,
ArrowFunction
,
AsyncArrowFunction
,
ClassDeclaration
, or
ClassExpression
.
Note 1
Function code is generally provided as the bodies of Function Definitions (
15.2
), Arrow Function Definitions (
15.3
), Method Definitions (
15.4
), Generator Function Definitions (
15.5
), Async Function Definitions (
15.8
), Async Generator Function Definitions (
15.6
), and Async Arrow Functions (
15.9
). Function code is also derived from the arguments to the Function
constructor
(
20.2.1.1
), the GeneratorFunction
constructor
(
27.3.1.1
), the AsyncFunction
constructor
(
27.7.1.1
), and the AsyncGeneratorFunction
constructor
(
27.4.1.1
).
Note 2
The practical effect of including the
BindingIdentifier
in function code is that the Early Errors for
strict mode code
are applied to a
BindingIdentifier
that is the name of a function whose body contains a "use strict" directive, even if the surrounding code is not
strict mode code
.
11.2.1
Directive Prologues and the Use Strict Directive
A
Directive Prologue
is the longest sequence of
ExpressionStatement
s occurring as the initial
StatementListItem
s or
ModuleItem
s of a
FunctionBody
, a
ScriptBody
, or a
ModuleBody
and where each
ExpressionStatement
in the sequence consists entirely of a
StringLiteral
token followed by a semicolon. The semicolon may appear explicitly or may be inserted by automatic semicolon insertion (
12.10
). A
Directive Prologue
may be an empty sequence.
A
Use Strict Directive
is an
ExpressionStatement
in a
Directive Prologue
whose
StringLiteral
is either of the exact code point sequences
"use strict"
or
'use strict'
. A
Use Strict Directive
may not contain an
EscapeSequence
or
LineContinuation
.
A
Directive Prologue
may contain more than one
Use Strict Directive
. However, an implementation may issue a warning if this occurs.
Note
The
ExpressionStatement
s of a
Directive Prologue
are evaluated normally during evaluation of the containing production. Implementations may define implementation specific meanings for
ExpressionStatement
s which are not a
Use Strict Directive
and which occur in a
Directive Prologue
. If an appropriate notification mechanism exists, an implementation should issue a warning if it encounters in a
Directive Prologue
an
ExpressionStatement
that is not a
Use Strict Directive
and which does not have a meaning defined by the implementation.
11.2.2
Strict Mode Code
An ECMAScript syntactic unit may be processed using either unrestricted or strict mode syntax and semantics (
4.3.2
). Code is interpreted as
strict mode code
in the following situations:
Global code
is strict mode code if it begins with a
Directive Prologue
that contains a
Use Strict Directive
.
Module code
is always strict mode code.
All parts of a
ClassDeclaration
or a
ClassExpression
are strict mode code.
Eval code
is strict mode code if it begins with a
Directive Prologue
that contains a
Use Strict Directive
or if the call to
eval
is a
direct eval
that is contained in strict mode code.
Function code
is strict mode code if the associated
FunctionDeclaration
,
FunctionExpression
,
GeneratorDeclaration
,
GeneratorExpression
,
AsyncFunctionDeclaration
,
AsyncFunctionExpression
,
AsyncGeneratorDeclaration
,
AsyncGeneratorExpression
,
MethodDefinition
,
ArrowFunction
, or
AsyncArrowFunction
is contained in strict mode code or if the code that produces the value of the function's
[[ECMAScriptCode]]
internal slot begins with a
Directive Prologue
that contains a
Use Strict Directive
.
Function code
that is supplied as the arguments to the built-in Function, Generator, AsyncFunction, and AsyncGenerator
constructors
is strict mode code if the last argument
is a String
that when processed is a
FunctionBody
that begins with a
Directive Prologue
that contains a
Use Strict Directive
.
ECMAScript code that is not strict mode code is called
non-strict code
.
11.2.2.1
Static Semantics: IsStrict (
node
)
The abstract operation IsStrict takes argument
node
(a
Parse Node
) and returns a Boolean. It performs the following steps when called:
If the
source text matched by
node
is
strict mode code
, return
true
; else return
false
.
11.2.3
Non-ECMAScript Functions
An ECMAScript implementation may support the evaluation of function
exotic objects
whose evaluative behaviour is expressed in some
host-defined
form of executable code other than
ECMAScript source text
. Whether a
function object
is defined within ECMAScript code or is a built-in function is not observable from the perspective of ECMAScript code that calls or is called by such a
function object
.
12
ECMAScript Language: Lexical Grammar
The source text of an ECMAScript
Script
or
Module
is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of code points as the next input element.
There are several situations where the identification of lexical input elements is sensitive to the syntactic grammar context that is consuming the input elements. This requires multiple
goal symbols
for the lexical grammar. The
InputElementHashbangOrRegExp
goal is used at the start of a
Script
or
Module
. The
InputElementRegExpOrTemplateTail
goal is used in syntactic grammar contexts where a
RegularExpressionLiteral
, a
TemplateMiddle
, or a
TemplateTail
is permitted. The
InputElementRegExp
goal symbol
is used in all syntactic grammar contexts where a
RegularExpressionLiteral
is permitted but neither a
TemplateMiddle
, nor a
TemplateTail
is permitted. The
InputElementTemplateTail
goal is used in all syntactic grammar contexts where a
TemplateMiddle
or a
TemplateTail
is permitted but a
RegularExpressionLiteral
is not permitted. In all other contexts,
InputElementDiv
is used as the lexical
goal symbol
.
Note
The use of multiple lexical goals ensures that there are no lexical ambiguities that would affect automatic semicolon insertion. For example, there are no syntactic grammar contexts where both a leading division or division-assignment, and a leading
RegularExpressionLiteral
are permitted. This is not affected by semicolon insertion (see
12.10
); in examples such as the following:
a = b /hi/g.
exec
(c).
map
(d);
where the first non-whitespace, non-comment code point after a
LineTerminator
is U+002F (SOLIDUS) and the syntactic context allows division or division-assignment, no semicolon is inserted at the
LineTerminator
. That is, the above example is interpreted in the same way as:
a = b / hi / g.
exec
(c).
map
(d);
Syntax
InputElementDiv
::
WhiteSpace
LineTerminator
Comment
CommonToken
DivPunctuator
RightBracePunctuator
InputElementRegExp
::
WhiteSpace
LineTerminator
Comment
CommonToken
RightBracePunctuator
RegularExpressionLiteral
InputElementRegExpOrTemplateTail
::
WhiteSpace
LineTerminator
Comment
CommonToken
RegularExpressionLiteral
TemplateSubstitutionTail
InputElementTemplateTail
::
WhiteSpace
LineTerminator
Comment
CommonToken
DivPunctuator
TemplateSubstitutionTail
InputElementHashbangOrRegExp
::
WhiteSpace
LineTerminator
Comment
CommonToken
HashbangComment
RegularExpressionLiteral
12.1
Unicode Format-Control Characters
The Unicode format-control characters (i.e., the characters in category “Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK or RIGHT-TO-LEFT MARK) are control codes used to control the formatting of a range of text in the absence of higher-level protocols for this (such as mark-up languages).
It is useful to allow format-control characters in source text to facilitate editing and display. All format control characters may be used within comments, and within string literals, template literals, and regular expression literals.
U+FEFF (ZERO WIDTH NO-BREAK SPACE) is a format-control character used primarily at the start of a text to mark it as Unicode and to allow detection of the text's encoding and byte order. <ZWNBSP> characters intended for this purpose can sometimes also appear after the start of a text, for example as a result of concatenating files. In
ECMAScript source text
<ZWNBSP> code points are treated as white space characters (see
12.2
) outside of comments, string literals, template literals, and regular expression literals.
12.2
White Space
White space code points are used to improve source text readability and to separate tokens (indivisible lexical units) from each other, but are otherwise insignificant. White space code points may occur between any two tokens and at the start or end of input. White space code points may occur within a
StringLiteral
, a
RegularExpressionLiteral
, a
Template
, or a
TemplateSubstitutionTail
where they are considered significant code points forming part of a literal value. They may also occur within a
Comment
, but cannot appear within any other kind of token.
The ECMAScript white space code points are listed in
Table 30
.
Table 30: White Space Code Points
Code Points
Name
Abbreviation
U+0009
CHARACTER TABULATION
<TAB>
U+000B
LINE TABULATION
<VT>
U+000C
FORM FEED (FF)
<FF>
U+FEFF
ZERO WIDTH NO-BREAK SPACE
<ZWNBSP>
any code point in general category “Space_Separator”
<USP>
Note 1
U+0020 (SPACE) and U+00A0 (NO-BREAK SPACE) code points are part of <USP>.
Note 2
Other than for the code points listed in
Table 30
, ECMAScript
WhiteSpace
intentionally excludes all code points that have the Unicode “White_Space” property but which are not classified in general category “Space_Separator” (“Zs”).
Syntax
WhiteSpace
::
<TAB>
<VT>
<FF>
<ZWNBSP>
<USP>
12.3
Line Terminators
Like white space code points, line terminator code points are used to improve source text readability and to separate tokens (indivisible lexical units) from each other. However, unlike white space code points, line terminators have some influence over the behaviour of the syntactic grammar. In general, line terminators may occur between any two tokens, but there are a few places where they are forbidden by the syntactic grammar. Line terminators also affect the process of automatic semicolon insertion (
12.10
). A line terminator cannot occur within any token except a
StringLiteral
,
Template
, or
TemplateSubstitutionTail
. <LF> and <CR> line terminators cannot occur within a
StringLiteral
token except as part of a
LineContinuation
.
A line terminator can occur within a
MultiLineComment
but cannot occur within a
SingleLineComment
.
Line terminators are included in the set of white space code points that are matched by the
\s
class in regular expressions.
The ECMAScript line terminator code points are listed in
Table 31
.
Table 31: Line Terminator Code Points
Code Point
Unicode Name
Abbreviation
U+000A
LINE FEED (LF)
<LF>
U+000D
CARRIAGE RETURN (CR)
<CR>
U+2028
LINE SEPARATOR
<LS>
U+2029
PARAGRAPH SEPARATOR
<PS>
Only the Unicode code points in
Table 31
are treated as line terminators. Other new line or line breaking Unicode code points are not treated as line terminators but are treated as white space if they meet the requirements listed in
Table 30
. The sequence <CR><LF> is commonly used as a line terminator. It should be considered a single
SourceCharacter
for the purpose of reporting line numbers.
Syntax
LineTerminator
::
<LF>
<CR>
<LS>
<PS>
LineTerminatorSequence
::
<LF>
<CR>
[lookahead ≠
<LF>
]
<LS>
<PS>
<CR>
<LF>
12.4
Comments
Comments can be either single or multi-line. Multi-line comments cannot nest.
Because a single-line comment can contain any Unicode code point except a
LineTerminator
code point, and because of the general rule that a token is always as long as possible, a single-line comment always consists of all code points from the
//
marker to the end of the line. However, the
LineTerminator
at the end of the line is not considered to be part of the single-line comment; it is recognized separately by the lexical grammar and becomes part of the stream of input elements for the syntactic grammar. This point is very important, because it implies that the presence or absence of single-line comments does not affect the process of automatic semicolon insertion (see
12.10
).
Comments behave like white space and are discarded except that, if a
MultiLineComment
contains a line terminator code point, then the entire comment is considered to be a
LineTerminator
for purposes of parsing by the syntactic grammar.
Syntax
Comment
::
MultiLineComment
SingleLineComment
MultiLineComment
::
/*
MultiLineCommentChars
opt
*/
MultiLineCommentChars
::
MultiLineNotAsteriskChar
MultiLineCommentChars
opt
*
PostAsteriskCommentChars
opt
PostAsteriskCommentChars
::
MultiLineNotForwardSlashOrAsteriskChar
MultiLineCommentChars
opt
*
PostAsteriskCommentChars
opt
MultiLineNotAsteriskChar
::
SourceCharacter
but not
*
MultiLineNotForwardSlashOrAsteriskChar
::
SourceCharacter
but not one of
/
or
*
SingleLineComment
::
//
SingleLineCommentChars
opt
SingleLineCommentChars
::
SingleLineCommentChar
SingleLineCommentChars
opt
SingleLineCommentChar
::
SourceCharacter
but not
LineTerminator
A number of productions in this section are given alternative definitions in section
B.1.1
12.5
Hashbang Comments
Hashbang Comments are location-sensitive and like other types of comments are discarded from the stream of input elements for the syntactic grammar.
Syntax
HashbangComment
::
#!
SingleLineCommentChars
opt
12.6
Tokens
Syntax
CommonToken
::
IdentifierName
PrivateIdentifier
Punctuator
NumericLiteral
StringLiteral
Template
Note
The
DivPunctuator
,
RegularExpressionLiteral
,
RightBracePunctuator
, and
TemplateSubstitutionTail
productions derive additional tokens that are not included in the
CommonToken
production.
12.7
Names and Keywords
IdentifierName
and
ReservedWord
are tokens that are interpreted according to the Default Identifier Syntax given in Unicode Standard Annex #31, Identifier and Pattern Syntax, with some small modifications.
ReservedWord
is an enumerated subset of
IdentifierName
. The syntactic grammar defines
Identifier
as an
IdentifierName
that is not a
ReservedWord
. The Unicode identifier grammar is based on character properties specified by the Unicode Standard. The Unicode code points in the specified categories in the latest version of the Unicode Standard must be treated as in those categories by all conforming ECMAScript implementations. ECMAScript implementations may recognize identifier code points defined in later editions of the Unicode Standard.
Note 1
This standard specifies specific code point additions: U+0024 (DOLLAR SIGN) and U+005F (LOW LINE) are permitted anywhere in an
IdentifierName
.
Syntax
PrivateIdentifier
::
#
IdentifierName
IdentifierName
::
IdentifierStart
IdentifierName
IdentifierPart
IdentifierStart
::
IdentifierStartChar
\
UnicodeEscapeSequence
IdentifierPart
::
IdentifierPartChar
\
UnicodeEscapeSequence
IdentifierStartChar
::
UnicodeIDStart
$
_
IdentifierPartChar
::
UnicodeIDContinue
$
AsciiLetter
::
one of
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
UnicodeIDStart
::
any Unicode code point with the Unicode property “ID_Start”
UnicodeIDContinue
::
any Unicode code point with the Unicode property “ID_Continue”
The definitions of the nonterminal
UnicodeEscapeSequence
is given in
12.9.4
.
Note 2
The nonterminal
IdentifierPart
derives
_
via
UnicodeIDContinue
.
Note 3
The sets of code points with Unicode properties “ID_Start” and “ID_Continue” include, respectively, the code points with Unicode properties “Other_ID_Start” and “Other_ID_Continue”.
12.7.1
Identifier Names
Unicode escape sequences are permitted in an
IdentifierName
, where they contribute a single Unicode code point equal to the
IdentifierCodePoint
of the
UnicodeEscapeSequence
. The
\
preceding the
UnicodeEscapeSequence
does not contribute any code points. A
UnicodeEscapeSequence
cannot be used to contribute a code point to an
IdentifierName
that would otherwise be invalid. In other words, if a
\
UnicodeEscapeSequence
sequence were replaced by the
SourceCharacter
it contributes, the result must still be a valid
IdentifierName
that has the exact same sequence of
SourceCharacter
elements as the original
IdentifierName
. All interpretations of
IdentifierName
within this specification are based upon their actual code points regardless of whether or not an escape sequence was used to contribute any particular code point.
Two
IdentifierName
s that are canonically equivalent according to the Unicode Standard are
not
equal unless, after replacement of each
UnicodeEscapeSequence
, they are represented by the exact same sequence of code points.
12.7.1.1
Static Semantics: Early Errors
IdentifierStart
::
\
UnicodeEscapeSequence
It is a Syntax Error if the
IdentifierCodePoint
of
UnicodeEscapeSequence
is not some Unicode code point matched by the
IdentifierStartChar
lexical grammar production.
IdentifierPart
::
\
UnicodeEscapeSequence
It is a Syntax Error if the
IdentifierCodePoint
of
UnicodeEscapeSequence
is not some Unicode code point matched by the
IdentifierPartChar
lexical grammar production.
12.7.1.2
Static Semantics: IdentifierCodePoints
The
syntax-directed operation
IdentifierCodePoints takes no arguments and returns a
List
of code points. It is defined piecewise over the following productions:
IdentifierName
::
IdentifierStart
Let
cp
be the
IdentifierCodePoint
of
IdentifierStart
.
Return «
cp
».
IdentifierName
::
IdentifierName
IdentifierPart
Let
cps
be the
IdentifierCodePoints
of the derived
IdentifierName
.
Let
cp
be the
IdentifierCodePoint
of
IdentifierPart
.
Return the
list-concatenation
of
cps
and «
cp
».
12.7.1.3
Static Semantics: IdentifierCodePoint
The
syntax-directed operation
IdentifierCodePoint takes no arguments and returns a code point. It is defined piecewise over the following productions:
IdentifierStart
::
IdentifierStartChar
Return the code point matched by
IdentifierStartChar
.
IdentifierPart
::
IdentifierPartChar
Return the code point matched by
IdentifierPartChar
.
UnicodeEscapeSequence
::
u
Hex4Digits
Return the code point whose numeric value is the MV of
Hex4Digits
.
UnicodeEscapeSequence
::
u{
CodePoint
}
Return the code point whose numeric value is the MV of
CodePoint
.
12.7.2
Keywords and Reserved Words
A
keyword
is a token that matches
IdentifierName
, but also has a syntactic use; that is, it appears literally, in a
fixed width
font, in some syntactic production. The keywords of ECMAScript include
if
,
while
,
async
,
await
, and many others.
A
reserved word
is an
IdentifierName
that cannot be used as an identifier. Many keywords are reserved words, but some are not, and some are reserved only in certain contexts.
if
and
while
are reserved words.
await
is reserved only inside async functions and modules.
async
is not reserved; it can be used as a variable name or statement label without restriction.
This specification uses a combination of grammatical productions and
early error
rules to specify which names are valid identifiers and which are reserved words. All tokens in the
ReservedWord
list below, except for
await
and
yield
, are unconditionally reserved. Exceptions for
await
and
yield
are specified in
13.1
, using parameterized syntactic productions. Lastly, several
early error
rules restrict the set of valid identifiers. See
13.1.1
,
14.3.1.1
,
14.7.5.1
, and
15.7.1
. In summary, there are five categories of identifier names:
Those that are always allowed as identifiers, and are not keywords, such as
Math
,
window
,
toString
, and
_
;
Those that are never allowed as identifiers, namely the
ReservedWord
s listed below except
await
and
yield
;
Those that are contextually allowed as identifiers, namely
await
and
yield
;
Those that are contextually disallowed as identifiers, in
strict mode code
:
let
,
static
,
implements
,
interface
,
package
,
private
,
protected
, and
public
;
Those that are always allowed as identifiers, but also appear as keywords within certain syntactic productions, at places where
Identifier
is not allowed:
as
,
async
,
from
,
get
,
meta
,
of
,
set
, and
target
.
The term
conditional keyword
, or
contextual keyword
, is sometimes used to refer to the keywords that fall in the last three categories, and thus can be used as identifiers in some contexts and as keywords in others.
Syntax
ReservedWord
::
one of
await
break
case
catch
class
const
continue
debugger
default
delete
do
else
enum
export
extends
false
finally
for
function
if
import
in
instanceof
new
null
return
super
switch
this
throw
true
try
typeof
var
void
while
with
yield
Note 1
Per
5.1.5
, keywords in the grammar match literal sequences of specific
SourceCharacter
elements. A code point in a keyword cannot be expressed by a
\
UnicodeEscapeSequence
.
An
IdentifierName
can contain
\
UnicodeEscapeSequence
s, but it is not possible to declare a variable named "else" by spelling it
els\u{65}
. The
early error
rules in
13.1.1
rule out identifiers with the same
StringValue
as a reserved word.
Note 2
enum
is not currently used as a keyword in this specification. It is a
future reserved word
, set aside for use as a keyword in future language extensions.
Similarly,
implements
,
interface
,
package
,
private
,
protected
, and
public
are future reserved words in
strict mode code
.
Note 3
The names
arguments
and
eval
are not keywords, but they are subject to some restrictions in
strict mode code
. See
13.1.1
,
8.6.4
,
15.2.1
,
15.5.1
,
15.6.1
, and
15.8.1
.
12.8
Punctuators
Syntax
Punctuator
::
OptionalChainingPunctuator
OtherPunctuator
OptionalChainingPunctuator
::
?.
[lookahead ∉
DecimalDigit
]
OtherPunctuator
::
one of
{
(
)
[
]
.
...
;
,
<
>
<=
>=
==
!=
===
!==
+
-
*
%
**
++
--
<<
>>
>>>
&
|
^
!
~
&&
||
??
?
:
=
+=
-=
*=
%=
**=
<<=
>>=
>>>=
&=
|=
^=
&&=
||=
??=
=>
DivPunctuator
::
/
/=
RightBracePunctuator
::
}
12.9
Literals
12.9.1
Null Literals
Syntax
NullLiteral
::
null
12.9.2
Boolean Literals
Syntax
BooleanLiteral
::
true
false
12.9.3
Numeric Literals
Syntax
NumericLiteralSeparator
::
_
NumericLiteral
::
DecimalLiteral
DecimalBigIntegerLiteral
NonDecimalIntegerLiteral
[+Sep]
NonDecimalIntegerLiteral
[+Sep]
BigIntLiteralSuffix
LegacyOctalIntegerLiteral
DecimalBigIntegerLiteral
::
0
BigIntLiteralSuffix
NonZeroDigit
DecimalDigits
[+Sep]
opt
BigIntLiteralSuffix
NonZeroDigit
NumericLiteralSeparator
DecimalDigits
[+Sep]
BigIntLiteralSuffix
NonDecimalIntegerLiteral
[Sep]
::
BinaryIntegerLiteral
[?Sep]
OctalIntegerLiteral
[?Sep]
HexIntegerLiteral
[?Sep]
BigIntLiteralSuffix
::
n
DecimalLiteral
::
DecimalIntegerLiteral
.
DecimalDigits
[+Sep]
opt
ExponentPart
[+Sep]
opt
.
DecimalDigits
[+Sep]
ExponentPart
[+Sep]
opt
DecimalIntegerLiteral
ExponentPart
[+Sep]
opt
DecimalIntegerLiteral
::
0
NonZeroDigit
NonZeroDigit
NumericLiteralSeparator
opt
DecimalDigits
[+Sep]
NonOctalDecimalIntegerLiteral
DecimalDigits
[Sep]
::
DecimalDigit
DecimalDigits
[?Sep]
DecimalDigit
[+Sep]
DecimalDigits
[+Sep]
NumericLiteralSeparator
DecimalDigit
DecimalDigit
::
one of
0
1
2
3
4
5
6
7
8
9
NonZeroDigit
::
one of
1
2
3
4
5
6
7
8
9
ExponentPart
[Sep]
::
ExponentIndicator
SignedInteger
[?Sep]
ExponentIndicator
::
one of
e
E
SignedInteger
[Sep]
::
DecimalDigits
[?Sep]
+
DecimalDigits
[?Sep]
-
DecimalDigits
[?Sep]
BinaryIntegerLiteral
[Sep]
::
0b
BinaryDigits
[?Sep]
0B
BinaryDigits
[?Sep]
BinaryDigits
[Sep]
::
BinaryDigit
BinaryDigits
[?Sep]
BinaryDigit
[+Sep]
BinaryDigits
[+Sep]
NumericLiteralSeparator
BinaryDigit
BinaryDigit
::
one of
0
1
OctalIntegerLiteral
[Sep]
::
0o
OctalDigits
[?Sep]
0O
OctalDigits
[?Sep]
OctalDigits
[Sep]
::
OctalDigit
OctalDigits
[?Sep]
OctalDigit
[+Sep]
OctalDigits
[+Sep]
NumericLiteralSeparator
OctalDigit
LegacyOctalIntegerLiteral
::
0
OctalDigit
LegacyOctalIntegerLiteral
OctalDigit
NonOctalDecimalIntegerLiteral
::
0
NonOctalDigit
LegacyOctalLikeDecimalIntegerLiteral
NonOctalDigit
NonOctalDecimalIntegerLiteral
DecimalDigit
LegacyOctalLikeDecimalIntegerLiteral
::
0
OctalDigit
LegacyOctalLikeDecimalIntegerLiteral
OctalDigit
OctalDigit
::
one of
0
1
2
3
4
5
6
7
NonOctalDigit
::
one of
8
9
HexIntegerLiteral
[Sep]
::
0x
HexDigits
[?Sep]
0X
HexDigits
[?Sep]
HexDigits
[Sep]
::
HexDigit
HexDigits
[?Sep]
HexDigit
[+Sep]
HexDigits
[+Sep]
NumericLiteralSeparator
HexDigit
HexDigit
::
one of
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
A
B
C
D
E
F
The
SourceCharacter
immediately following a
NumericLiteral
must not be an
IdentifierStart
or
DecimalDigit
.
Note
For example:
3in
is an error and not the two input elements
3
and
in
.
12.9.3.1
Static Semantics: Early Errors
NumericLiteral
::
LegacyOctalIntegerLiteral
DecimalIntegerLiteral
::
NonOctalDecimalIntegerLiteral
It is a Syntax Error if
IsStrict
(this production) is
true
.
Note
In
non-strict code
, this syntax is
Legacy
.
12.9.3.2
Static Semantics: MV
A numeric literal stands for a value of the
Number type
or the
BigInt type
.
The MV of
DecimalLiteral
::
DecimalIntegerLiteral
.
DecimalDigits
is the MV of
DecimalIntegerLiteral
plus (the MV of
DecimalDigits
× 10
-
n
), where
n
is the number of code points in
DecimalDigits
, excluding all occurrences of
NumericLiteralSeparator
.
The MV of
DecimalLiteral
::
DecimalIntegerLiteral
.
ExponentPart
is the MV of
DecimalIntegerLiteral
× 10
e
, where
e
is the MV of
ExponentPart
.
The MV of
DecimalLiteral
::
DecimalIntegerLiteral
.
DecimalDigits
ExponentPart
is (the MV of
DecimalIntegerLiteral
plus (the MV of
DecimalDigits
× 10
-
n
)) × 10
e
, where
n
is the number of code points in
DecimalDigits
, excluding all occurrences of
NumericLiteralSeparator
and
e
is the MV of
ExponentPart
.
The MV of
DecimalLiteral
::
.
DecimalDigits
is the MV of
DecimalDigits
× 10
-
n
, where
n
is the number of code points in
DecimalDigits
, excluding all occurrences of
NumericLiteralSeparator
.
The MV of
DecimalLiteral
::
.
DecimalDigits
ExponentPart
is the MV of
DecimalDigits
× 10
e
-
n
, where
n
is the number of code points in
DecimalDigits
, excluding all occurrences of
NumericLiteralSeparator
, and
e
is the MV of
ExponentPart
.
The MV of
DecimalLiteral
::
DecimalIntegerLiteral
ExponentPart
is the MV of
DecimalIntegerLiteral
× 10
e
, where
e
is the MV of
ExponentPart
.
The MV of
DecimalIntegerLiteral
::
0
is 0.
The MV of
DecimalIntegerLiteral
::
NonZeroDigit
NumericLiteralSeparator
opt
DecimalDigits
is (the MV of
NonZeroDigit
× 10
n
) plus the MV of
DecimalDigits
, where
n
is the number of code points in
DecimalDigits
, excluding all occurrences of
NumericLiteralSeparator
.
The MV of
DecimalDigits
::
DecimalDigits
DecimalDigit
is (the MV of
DecimalDigits
× 10) plus the MV of
DecimalDigit
.
The MV of
DecimalDigits
::
DecimalDigits
NumericLiteralSeparator
DecimalDigit
is (the MV of
DecimalDigits
× 10) plus the MV of
DecimalDigit
.
The MV of
ExponentPart
::
ExponentIndicator
SignedInteger
is the MV of
SignedInteger
.
The MV of
SignedInteger
::
-
DecimalDigits
is the negative of the MV of
DecimalDigits
.
The MV of
DecimalDigit
::
0
or of
HexDigit
::
0
or of
OctalDigit
::
0
or of
LegacyOctalEscapeSequence
::
0
or of
BinaryDigit
::
0
is 0.
The MV of
DecimalDigit
::
1
or of
NonZeroDigit
::
1
or of
HexDigit
::
1
or of
OctalDigit
::
1
or of
BinaryDigit
::
1
is 1.
The MV of
DecimalDigit
::
2
or of
NonZeroDigit
::
2
or of
HexDigit
::
2
or of
OctalDigit
::
2
is 2.
The MV of
DecimalDigit
::
3
or of
NonZeroDigit
::
3
or of
HexDigit
::
3
or of
OctalDigit
::
3
is 3.
The MV of
DecimalDigit
::
4
or of
NonZeroDigit
::
4
or of
HexDigit
::
4
or of
OctalDigit
::
4
is 4.
The MV of
DecimalDigit
::
5
or of
NonZeroDigit
::
5
or of
HexDigit
::
5
or of
OctalDigit
::
5
is 5.
The MV of
DecimalDigit
::
6
or of
NonZeroDigit
::
6
or of
HexDigit
::
6
or of
OctalDigit
::
6
is 6.
The MV of
DecimalDigit
::
7
or of
NonZeroDigit
::
7
or of
HexDigit
::
7
or of
OctalDigit
::
7
is 7.
The MV of
DecimalDigit
::
8
or of
NonZeroDigit
::
8
or of
NonOctalDigit
::
8
or of
HexDigit
::
8
is 8.
The MV of
DecimalDigit
::
9
or of
NonZeroDigit
::
9
or of
NonOctalDigit
::
9
or of
HexDigit
::
9
is 9.
The MV of
HexDigit
::
a
or of
HexDigit
::
A
is 10.
The MV of
HexDigit
::
b
or of
HexDigit
::
B
is 11.
The MV of
HexDigit
::
c
or of
HexDigit
::
C
is 12.
The MV of
HexDigit
::
d
or of
HexDigit
::
D
is 13.
The MV of
HexDigit
::
e
or of
HexDigit
::
E
is 14.
The MV of
HexDigit
::
f
or of
HexDigit
::
F
is 15.
The MV of
BinaryDigits
::
BinaryDigits
BinaryDigit
is (the MV of
BinaryDigits
× 2) plus the MV of
BinaryDigit
.
The MV of
BinaryDigits
::
BinaryDigits
NumericLiteralSeparator
BinaryDigit
is (the MV of
BinaryDigits
× 2) plus the MV of
BinaryDigit
.
The MV of
OctalDigits
::
OctalDigits
OctalDigit
is (the MV of
OctalDigits
× 8) plus the MV of
OctalDigit
.
The MV of
OctalDigits
::
OctalDigits
NumericLiteralSeparator
OctalDigit
is (the MV of
OctalDigits
× 8) plus the MV of
OctalDigit
.
The MV of
LegacyOctalIntegerLiteral
::
LegacyOctalIntegerLiteral
OctalDigit
is (the MV of
LegacyOctalIntegerLiteral
times 8) plus the MV of
OctalDigit
.
The MV of
NonOctalDecimalIntegerLiteral
::
LegacyOctalLikeDecimalIntegerLiteral
NonOctalDigit
is (the MV of
LegacyOctalLikeDecimalIntegerLiteral
times 10) plus the MV of
NonOctalDigit
.
The MV of
NonOctalDecimalIntegerLiteral
::
NonOctalDecimalIntegerLiteral
DecimalDigit
is (the MV of
NonOctalDecimalIntegerLiteral
times 10) plus the MV of
DecimalDigit
.
The MV of
LegacyOctalLikeDecimalIntegerLiteral
::
LegacyOctalLikeDecimalIntegerLiteral
OctalDigit
is (the MV of
LegacyOctalLikeDecimalIntegerLiteral
times 10) plus the MV of
OctalDigit
.
The MV of
HexDigits
::
HexDigits
HexDigit
is (the MV of
HexDigits
× 16) plus the MV of
HexDigit
.
The MV of
HexDigits
::
HexDigits
NumericLiteralSeparator
HexDigit
is (the MV of
HexDigits
× 16) plus the MV of
HexDigit
.
12.9.3.3
Static Semantics: NumericValue
The
syntax-directed operation
NumericValue takes no arguments and returns a Number or a BigInt. It is defined piecewise over the following productions:
NumericLiteral
::
DecimalLiteral
Return
RoundMVResult
(MV of
DecimalLiteral
).
NumericLiteral
::
NonDecimalIntegerLiteral
Return
𝔽
(MV of
NonDecimalIntegerLiteral
).
NumericLiteral
::
LegacyOctalIntegerLiteral
Return
𝔽
(MV of
LegacyOctalIntegerLiteral
).
NumericLiteral
::
NonDecimalIntegerLiteral
BigIntLiteralSuffix
Return the
BigInt value for
the MV of
NonDecimalIntegerLiteral
.
DecimalBigIntegerLiteral
::
0
BigIntLiteralSuffix
Return
0
ℤ
.
DecimalBigIntegerLiteral
::
NonZeroDigit
BigIntLiteralSuffix
Return the
BigInt value for
the MV of
NonZeroDigit
.
DecimalBigIntegerLiteral
::
NonZeroDigit
DecimalDigits
BigIntLiteralSuffix
NonZeroDigit
NumericLiteralSeparator
DecimalDigits
BigIntLiteralSuffix
Let
n
be the number of code points in
DecimalDigits
, excluding all occurrences of
NumericLiteralSeparator
.
Let
mv
be (the MV of
NonZeroDigit
× 10
n
) plus the MV of
DecimalDigits
.
Return
ℤ
(
mv
).
12.9.4
String Literals
Note 1
A string literal is 0 or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for the closing quote code points, U+005C (REVERSE SOLIDUS), U+000D (CARRIAGE RETURN), and U+000A (LINE FEED). Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded as defined in
11.1.1
. Code points belonging to the Basic Multilingual Plane are encoded as a single code unit element of the string. All other code points are encoded as two code unit elements of the string.
Syntax
StringLiteral
::
"
DoubleStringCharacters
opt
"
'
SingleStringCharacters
opt
'
DoubleStringCharacters
::
DoubleStringCharacter
DoubleStringCharacters
opt
SingleStringCharacters
::
SingleStringCharacter
SingleStringCharacters
opt
DoubleStringCharacter
::
SourceCharacter
but not one of
"
or
\
or
LineTerminator
<LS>
<PS>
\
EscapeSequence
LineContinuation
SingleStringCharacter
::
SourceCharacter
but not one of
'
or
\
or
LineTerminator
<LS>
<PS>
\
EscapeSequence
LineContinuation
LineContinuation
::
\
LineTerminatorSequence
EscapeSequence
::
CharacterEscapeSequence
0
[lookahead ∉
DecimalDigit
]
LegacyOctalEscapeSequence
NonOctalDecimalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence
CharacterEscapeSequence
::
SingleEscapeCharacter
NonEscapeCharacter
SingleEscapeCharacter
::
one of
'
"
\
b
f
n
r
t
v
NonEscapeCharacter
::
SourceCharacter
but not one of
EscapeCharacter
or
LineTerminator
EscapeCharacter
::
SingleEscapeCharacter
DecimalDigit
x
u
LegacyOctalEscapeSequence
::
0
[lookahead ∈ {
8
,
9
}]
NonZeroOctalDigit
[lookahead ∉
OctalDigit
]
ZeroToThree
OctalDigit
[lookahead ∉
OctalDigit
]
FourToSeven
OctalDigit
ZeroToThree
OctalDigit
OctalDigit
NonZeroOctalDigit
::
OctalDigit
but not
0
ZeroToThree
::
one of
0
1
2
3
FourToSeven
::
one of
4
5
6
7
NonOctalDecimalEscapeSequence
::
one of
8
9
HexEscapeSequence
::
x
HexDigit
HexDigit
UnicodeEscapeSequence
::
u
Hex4Digits
u{
CodePoint
}
Hex4Digits
::
HexDigit
HexDigit
HexDigit
HexDigit
The definition of the nonterminal
HexDigit
is given in
12.9.3
.
SourceCharacter
is defined in
11.1
.
Note 2
<LF> and <CR> cannot appear in a string literal, except as part of a
LineContinuation
to produce the empty code points sequence. The proper way to include either in the String value of a string literal is to use an escape sequence such as
\n
or
\u000A
.
12.9.4.1
Static Semantics: Early Errors
EscapeSequence
::
LegacyOctalEscapeSequence
NonOctalDecimalEscapeSequence
It is a Syntax Error if
IsStrict
(this production) is
true
.
Note 1
In
non-strict code
, this syntax is
Legacy
.
Note 2
It is possible for string literals to precede a
Use Strict Directive
that places the enclosing code in
strict mode
, and implementations must take care to enforce the above rules for such literals. For example, the following source text contains a Syntax Error:
function
invalid
(
) {
"\7"
;
"use strict"
; }
12.9.4.2
Static Semantics: SV
The
syntax-directed operation
SV takes no arguments and returns a String.
A string literal stands for a value of the
String type
. SV produces String values for string literals through recursive application on the various parts of the string literal. As part of this process, some Unicode code points within the string literal are interpreted as having a
mathematical value
, as described below or in
12.9.3
.
The SV of
StringLiteral
::
"
"
is the empty String.
The SV of
StringLiteral
::
'
'
is the empty String.
The SV of
DoubleStringCharacters
::
DoubleStringCharacter
DoubleStringCharacters
is the
string-concatenation
of the SV of
DoubleStringCharacter
and the SV of
DoubleStringCharacters
.
The SV of
SingleStringCharacters
::
SingleStringCharacter
SingleStringCharacters
is the
string-concatenation
of the SV of
SingleStringCharacter
and the SV of
SingleStringCharacters
.
The SV of
DoubleStringCharacter
::
SourceCharacter
but not one of
"
or
\
or
LineTerminator
is the result of performing
UTF16EncodeCodePoint
on the code point matched by
SourceCharacter
.
The SV of
DoubleStringCharacter
::
<LS>
is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
The SV of
DoubleStringCharacter
::
<PS>
is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
The SV of
DoubleStringCharacter
::
LineContinuation
is the empty String.
The SV of
SingleStringCharacter
::
SourceCharacter
but not one of
'
or
\
or
LineTerminator
is the result of performing
UTF16EncodeCodePoint
on the code point matched by
SourceCharacter
.
The SV of
SingleStringCharacter
::
<LS>
is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
The SV of
SingleStringCharacter
::
<PS>
is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
The SV of
SingleStringCharacter
::
LineContinuation
is the empty String.
The SV of
EscapeSequence
::
0
is the String value consisting of the code unit 0x0000 (NULL).
The SV of
CharacterEscapeSequence
::
SingleEscapeCharacter
is the String value consisting of the code unit whose numeric value is determined by the
SingleEscapeCharacter
according to
Table 32
.
Table 32: String Single Character Escape Sequences
Escape Sequence
Code Unit Value
Unicode Character Name
Symbol
\b
0x0008
BACKSPACE
<BS>
\t
0x0009
CHARACTER TABULATION
<HT>
\n
0x000A
LINE FEED (LF)
<LF>
\v
0x000B
LINE TABULATION
<VT>
\f
0x000C
FORM FEED (FF)
<FF>
\r
0x000D
CARRIAGE RETURN (CR)
<CR>
\"
0x0022
QUOTATION MARK
"
\'
0x0027
APOSTROPHE
'
\\
0x005C
REVERSE SOLIDUS
\
The SV of
NonEscapeCharacter
::
SourceCharacter
but not one of
EscapeCharacter
or
LineTerminator
is the result of performing
UTF16EncodeCodePoint
on the code point matched by
SourceCharacter
.
The SV of
EscapeSequence
::
LegacyOctalEscapeSequence
is the String value consisting of the code unit whose numeric value is the MV of
LegacyOctalEscapeSequence
.
The SV of
NonOctalDecimalEscapeSequence
::
8
is the String value consisting of the code unit 0x0038 (DIGIT EIGHT).
The SV of
NonOctalDecimalEscapeSequence
::
9
is the String value consisting of the code unit 0x0039 (DIGIT NINE).
The SV of
HexEscapeSequence
::
x
HexDigit
HexDigit
is the String value consisting of the code unit whose numeric value is the MV of
HexEscapeSequence
.
The SV of
Hex4Digits
::
HexDigit
HexDigit
HexDigit
HexDigit
is the String value consisting of the code unit whose numeric value is the MV of
Hex4Digits
.
The SV of
UnicodeEscapeSequence
::
u{
CodePoint
}
is the result of performing
UTF16EncodeCodePoint
on the MV of
CodePoint
.
The SV of
TemplateEscapeSequence
::
0
is the String value consisting of the code unit 0x0000 (NULL).
12.9.4.3
Static Semantics: MV
The MV of
LegacyOctalEscapeSequence
::
ZeroToThree
OctalDigit
is (8 times the MV of
ZeroToThree
) plus the MV of
OctalDigit
.
The MV of
LegacyOctalEscapeSequence
::
FourToSeven
OctalDigit
is (8 times the MV of
FourToSeven
) plus the MV of
OctalDigit
.
The MV of
LegacyOctalEscapeSequence
::
ZeroToThree
OctalDigit
OctalDigit
is (64 (that is, 8
2
) times the MV of
ZeroToThree
) plus (8 times the MV of the first
OctalDigit
) plus the MV of the second
OctalDigit
.
The MV of
ZeroToThree
::
0
is 0.
The MV of
ZeroToThree
::
1
is 1.
The MV of
ZeroToThree
::
2
is 2.
The MV of
ZeroToThree
::
3
is 3.
The MV of
FourToSeven
::
4
is 4.
The MV of
FourToSeven
::
5
is 5.
The MV of
FourToSeven
::
6
is 6.
The MV of
FourToSeven
::
7
is 7.
The MV of
HexEscapeSequence
::
x
HexDigit
HexDigit
is (16 times the MV of the first
HexDigit
) plus the MV of the second
HexDigit
.
The MV of
Hex4Digits
::
HexDigit
HexDigit
HexDigit
HexDigit
is (0x1000 × the MV of the first
HexDigit
) plus (0x100 × the MV of the second
HexDigit
) plus (0x10 × the MV of the third
HexDigit
) plus the MV of the fourth
HexDigit
.
12.9.5
Regular Expression Literals
Note 1
A regular expression literal is an input element that is converted to a RegExp object (see
22.2
) each time the literal is evaluated. Two regular expression literals in a program evaluate to regular expression objects that never compare as
===
to each other even if the two literals' contents are identical. A RegExp object may also be created at runtime by
new RegExp
or calling the RegExp
constructor
as a function (see
22.2.4
).
The productions below describe the syntax for a regular expression literal and are used by the input element scanner to find the end of the regular expression literal. The source text comprising the
RegularExpressionBody
and the
RegularExpressionFlags
are subsequently parsed again using the more stringent ECMAScript Regular Expression grammar (
22.2.1
).
An implementation may extend the ECMAScript Regular Expression grammar defined in
22.2.1
, but it must not extend the
RegularExpressionBody
and
RegularExpressionFlags
productions defined below or the productions used by these productions.
Syntax
RegularExpressionLiteral
::
/
RegularExpressionBody
/
RegularExpressionFlags
RegularExpressionBody
::
RegularExpressionFirstChar
RegularExpressionChars
RegularExpressionChars
::
[empty]
RegularExpressionChars
RegularExpressionChar
RegularExpressionFirstChar
::
RegularExpressionNonTerminator
but not one of
*
or
\
or
/
or
[
RegularExpressionBackslashSequence
RegularExpressionClass
RegularExpressionChar
::
RegularExpressionNonTerminator
but not one of
\
or
/
or
[
RegularExpressionBackslashSequence
RegularExpressionClass
RegularExpressionBackslashSequence
::
\
RegularExpressionNonTerminator
RegularExpressionNonTerminator
::
SourceCharacter
but not
LineTerminator
RegularExpressionClass
::
[
RegularExpressionClassChars
]
RegularExpressionClassChars
::
[empty]
RegularExpressionClassChars
RegularExpressionClassChar
RegularExpressionClassChar
::
RegularExpressionNonTerminator
but not one of
]
or
\
RegularExpressionBackslashSequence
RegularExpressionFlags
::
[empty]
RegularExpressionFlags
IdentifierPartChar
Note 2
Regular expression literals may not be empty; instead of representing an empty regular expression literal, the code unit sequence
//
starts a single-line comment. To specify an empty regular expression, use:
/(?:)/
.
12.9.5.1
Static Semantics: BodyText
The
syntax-directed operation
BodyText takes no arguments and returns source text. It is defined piecewise over the following productions:
RegularExpressionLiteral
::
/
RegularExpressionBody
/
RegularExpressionFlags
Return the source text that was recognized as
RegularExpressionBody
.
12.9.5.2
Static Semantics: FlagText
The
syntax-directed operation
FlagText takes no arguments and returns source text. It is defined piecewise over the following productions:
RegularExpressionLiteral
::
/
RegularExpressionBody
/
RegularExpressionFlags
Return the source text that was recognized as
RegularExpressionFlags
.
12.9.6
Template Literal Lexical Components
Syntax
Template
::
NoSubstitutionTemplate
TemplateHead
NoSubstitutionTemplate
::
`
TemplateCharacters
opt
`
TemplateHead
::
`
TemplateCharacters
opt
${
TemplateSubstitutionTail
::
TemplateMiddle
TemplateTail
TemplateMiddle
::
}
TemplateCharacters
opt
${
TemplateTail
::
}
TemplateCharacters
opt
`
TemplateCharacters
::
TemplateCharacter
TemplateCharacters
opt
TemplateCharacter
::
$
[lookahead ≠
{
]
\
TemplateEscapeSequence
\
NotEscapeSequence
LineContinuation
LineTerminatorSequence
SourceCharacter
but not one of
`
or
\
or
$
or
LineTerminator
TemplateEscapeSequence
::
CharacterEscapeSequence
0
[lookahead ∉
DecimalDigit
]
HexEscapeSequence
UnicodeEscapeSequence
NotEscapeSequence
::
0
DecimalDigit
DecimalDigit
but not
0
x
[lookahead ∉
HexDigit
]
x
HexDigit
[lookahead ∉
HexDigit
]
u
[lookahead ∉
HexDigit
]
[lookahead ≠
{
]
u
HexDigit
[lookahead ∉
HexDigit
]
u
HexDigit
HexDigit
[lookahead ∉
HexDigit
]
u
HexDigit
HexDigit
HexDigit
[lookahead ∉
HexDigit
]
u
{
[lookahead ∉
HexDigit
]
u
{
NotCodePoint
[lookahead ∉
HexDigit
]
u
{
CodePoint
[lookahead ∉
HexDigit
]
[lookahead ≠
}
]
NotCodePoint
::
HexDigits
[~Sep]
but only if the MV of
HexDigits
> 0x10FFFF
CodePoint
::
HexDigits
[~Sep]
but only if the MV of
HexDigits
≤ 0x10FFFF
Note
TemplateSubstitutionTail
is used by the
InputElementTemplateTail
alternative lexical goal.
12.9.6.1
Static Semantics: TV
The
syntax-directed operation
TV takes no arguments and returns a String or
undefined
. A template literal component is interpreted by TV as a value of the
String type
. TV is used to construct the indexed components of a template object (colloquially, the template values). In TV, escape sequences are replaced by the UTF-16 code unit(s) of the Unicode code point represented by the escape sequence.
The TV of
NoSubstitutionTemplate
::
`
`
is the empty String.
The TV of
TemplateHead
::
`
${
is the empty String.
The TV of
TemplateMiddle
::
}
${
is the empty String.
The TV of
TemplateTail
::
}
`
is the empty String.
The TV of
TemplateCharacters
::
TemplateCharacter
TemplateCharacters
is
undefined
if the TV of
TemplateCharacter
is
undefined
or the TV of
TemplateCharacters
is
undefined
. Otherwise, it is the
string-concatenation
of the TV of
TemplateCharacter
and the TV of
TemplateCharacters
.
The TV of
TemplateCharacter
::
SourceCharacter
but not one of
`
or
\
or
$
or
LineTerminator
is the result of performing
UTF16EncodeCodePoint
on the code point matched by
SourceCharacter
.
The TV of
TemplateCharacter
::
$
is the String value consisting of the code unit 0x0024 (DOLLAR SIGN).
The TV of
TemplateCharacter
::
\
TemplateEscapeSequence
is the
SV
of
TemplateEscapeSequence
.
The TV of
TemplateCharacter
::
\
NotEscapeSequence
is
undefined
.
The TV of
TemplateCharacter
::
LineTerminatorSequence
is the
TRV
of
LineTerminatorSequence
.
The TV of
LineContinuation
::
\
LineTerminatorSequence
is the empty String.
12.9.6.2
Static Semantics: TRV
The
syntax-directed operation
TRV takes no arguments and returns a String. A template literal component is interpreted by TRV as a value of the
String type
. TRV is used to construct the raw components of a template object (colloquially, the template raw values). TRV is similar to
TV
with the difference being that in TRV, escape sequences are interpreted as they appear in the literal.
The TRV of
NoSubstitutionTemplate
::
`
`
is the empty String.
The TRV of
TemplateHead
::
`
${
is the empty String.
The TRV of
TemplateMiddle
::
}
${
is the empty String.
The TRV of
TemplateTail
::
}
`
is the empty String.
The TRV of
TemplateCharacters
::
TemplateCharacter
TemplateCharacters
is the
string-concatenation
of the TRV of
TemplateCharacter
and the TRV of
TemplateCharacters
.
The TRV of
TemplateCharacter
::
SourceCharacter
but not one of
`
or
\
or
$
or
LineTerminator
is the result of performing
UTF16EncodeCodePoint
on the code point matched by
SourceCharacter
.
The TRV of
TemplateCharacter
::
$
is the String value consisting of the code unit 0x0024 (DOLLAR SIGN).
The TRV of
TemplateCharacter
::
\
TemplateEscapeSequence
is the
string-concatenation
of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of
TemplateEscapeSequence
.
The TRV of
TemplateCharacter
::
\
NotEscapeSequence
is the
string-concatenation
of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of
NotEscapeSequence
.
The TRV of
TemplateEscapeSequence
::
0
is the String value consisting of the code unit 0x0030 (DIGIT ZERO).
The TRV of
NotEscapeSequence
::
0
DecimalDigit
is the
string-concatenation
of the code unit 0x0030 (DIGIT ZERO) and the TRV of
DecimalDigit
.
The TRV of
NotEscapeSequence
::
x
[lookahead ∉
HexDigit
]
is the String value consisting of the code unit 0x0078 (LATIN SMALL LETTER X).
The TRV of
NotEscapeSequence
::
x
HexDigit
[lookahead ∉
HexDigit
]
is the
string-concatenation
of the code unit 0x0078 (LATIN SMALL LETTER X) and the TRV of
HexDigit
.
The TRV of
NotEscapeSequence
::
u
[lookahead ∉
HexDigit
]
[lookahead ≠
{
]
is the String value consisting of the code unit 0x0075 (LATIN SMALL LETTER U).
The TRV of
NotEscapeSequence
::
u
HexDigit
[lookahead ∉
HexDigit
]
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of
HexDigit
.
The TRV of
NotEscapeSequence
::
u
HexDigit
HexDigit
[lookahead ∉
HexDigit
]
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first
HexDigit
, and the TRV of the second
HexDigit
.
The TRV of
NotEscapeSequence
::
u
HexDigit
HexDigit
HexDigit
[lookahead ∉
HexDigit
]
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first
HexDigit
, the TRV of the second
HexDigit
, and the TRV of the third
HexDigit
.
The TRV of
NotEscapeSequence
::
u
{
[lookahead ∉
HexDigit
]
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U) and the code unit 0x007B (LEFT CURLY BRACKET).
The TRV of
NotEscapeSequence
::
u
{
NotCodePoint
[lookahead ∉
HexDigit
]
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of
NotCodePoint
.
The TRV of
NotEscapeSequence
::
u
{
CodePoint
[lookahead ∉
HexDigit
]
[lookahead ≠
}
]
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of
CodePoint
.
The TRV of
DecimalDigit
::
one of
0
1
2
3
4
5
6
7
8
9
is the result of performing
UTF16EncodeCodePoint
on the single code point matched by this production.
The TRV of
CharacterEscapeSequence
::
NonEscapeCharacter
is the
SV
of
NonEscapeCharacter
.
The TRV of
SingleEscapeCharacter
::
one of
'
"
\
b
f
n
r
t
v
is the result of performing
UTF16EncodeCodePoint
on the single code point matched by this production.
The TRV of
HexEscapeSequence
::
x
HexDigit
HexDigit
is the
string-concatenation
of the code unit 0x0078 (LATIN SMALL LETTER X), the TRV of the first
HexDigit
, and the TRV of the second
HexDigit
.
The TRV of
UnicodeEscapeSequence
::
u
Hex4Digits
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of
Hex4Digits
.
The TRV of
UnicodeEscapeSequence
::
u{
CodePoint
}
is the
string-concatenation
of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), the TRV of
CodePoint
, and the code unit 0x007D (RIGHT CURLY BRACKET).
The TRV of
Hex4Digits
::
HexDigit
HexDigit
HexDigit
HexDigit
is the
string-concatenation
of the TRV of the first
HexDigit
, the TRV of the second
HexDigit
, the TRV of the third
HexDigit
, and the TRV of the fourth
HexDigit
.
The TRV of
HexDigits
::
HexDigits
HexDigit
is the
string-concatenation
of the TRV of
HexDigits
and the TRV of
HexDigit
.
The TRV of
HexDigit
::
one of
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
A
B
C
D
E
F
is the result of performing
UTF16EncodeCodePoint
on the single code point matched by this production.
The TRV of
LineContinuation
::
\
LineTerminatorSequence
is the
string-concatenation
of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of
LineTerminatorSequence
.
The TRV of
LineTerminatorSequence
::
<LF>
is the String value consisting of the code unit 0x000A (LINE FEED).
The TRV of
LineTerminatorSequence
::
<CR>
is the String value consisting of the code unit 0x000A (LINE FEED).
The TRV of
LineTerminatorSequence
::
<LS>
is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
The TRV of
LineTerminatorSequence
::
<PS>
is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
The TRV of
LineTerminatorSequence
::
<CR>
<LF>
is the String value consisting of the code unit 0x000A (LINE FEED).
Note
TV
excludes the code units of
LineContinuation
while TRV includes them. <CR><LF> and <CR>
LineTerminatorSequence
s are normalized to <LF> for both
TV
and TRV. An explicit
TemplateEscapeSequence
is needed to include a <CR> or <CR><LF> sequence.
12.10
Automatic Semicolon Insertion
Most ECMAScript statements and declarations must be terminated with a semicolon. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.
12.10.1
Rules of Automatic Semicolon Insertion
In the following rules, “token” means the actual recognized lexical token determined using the current lexical
goal symbol
as described in clause
12
.
There are three basic rules of semicolon insertion:
When, as the source text is parsed from left to right, a token (called the
offending token
) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:
The offending token is separated from the previous token by at least one
LineTerminator
.
The offending token is
}
.
The previous token is
)
and the inserted semicolon would then be parsed as the terminating semicolon of a do-while statement (
14.7.2
).
When, as the source text is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single instance of the goal nonterminal, then a semicolon is automatically inserted at the end of the input stream.
When, as the source text is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a
restricted production
and the token would be the first token for a terminal or nonterminal immediately following the annotation “[no
LineTerminator
here]” within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one
LineTerminator
, then a semicolon is automatically inserted before the restricted token.
However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a
for
statement (see
14.7.4
).
Note
The following are the only restricted productions in the grammar:
UpdateExpression
[Yield, Await]
:
LeftHandSideExpression
[?Yield, ?Await]
[no
LineTerminator
here]
++
LeftHandSideExpression
[?Yield, ?Await]
[no
LineTerminator
here]
--
ContinueStatement
[Yield, Await]
:
continue
;
continue
[no
LineTerminator
here]
LabelIdentifier
[?Yield, ?Await]
;
BreakStatement
[Yield, Await]
:
break
;
break
[no
LineTerminator
here]
LabelIdentifier
[?Yield, ?Await]
;
ReturnStatement
[Yield, Await]
:
return
;
return
[no
LineTerminator
here]
Expression
[+In, ?Yield, ?Await]
;
ThrowStatement
[Yield, Await]
:
throw
[no
LineTerminator
here]
Expression
[+In, ?Yield, ?Await]
;
YieldExpression
[In, Await]
:
yield
yield
[no
LineTerminator
here]
AssignmentExpression
[?In, +Yield, ?Await]
yield
[no
LineTerminator
here]
*
AssignmentExpression
[?In, +Yield, ?Await]
ArrowFunction
[In, Yield, Await]
:
ArrowParameters
[?Yield, ?Await]
[no
LineTerminator
here]
=>
ConciseBody
[?In]
AsyncFunctionDeclaration
[Yield, Await, Default]
:
async
[no
LineTerminator
here]
function
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
[+Default]
async
[no
LineTerminator
here]
function
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncFunctionExpression
:
async
[no
LineTerminator
here]
function
BindingIdentifier
[~Yield, +Await]
opt
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncMethod
[Yield, Await]
:
async
[no
LineTerminator
here]
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncGeneratorDeclaration
[Yield, Await, Default]
:
async
[no
LineTerminator
here]
function
*
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
[+Default]
async
[no
LineTerminator
here]
function
*
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorExpression
:
async
[no
LineTerminator
here]
function
*
BindingIdentifier
[+Yield, +Await]
opt
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorMethod
[Yield, Await]
:
async
[no
LineTerminator
here]
*
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncArrowFunction
[In, Yield, Await]
:
async
[no
LineTerminator
here]
AsyncArrowBindingIdentifier
[?Yield]
[no
LineTerminator
here]
=>
AsyncConciseBody
[?In]
CoverCallExpressionAndAsyncArrowHead
[?Yield, ?Await]
[no
LineTerminator
here]
=>
AsyncConciseBody
[?In]
AsyncArrowHead
:
async
[no
LineTerminator
here]
ArrowFormalParameters
[~Yield, +Await]
The practical effect of these restricted productions is as follows:
When a
++
or
--
token is encountered where the parser would treat it as a postfix operator, and at least one
LineTerminator
occurred between the preceding token and the
++
or
--
token, then a semicolon is automatically inserted before the
++
or
--
token.
When a
continue
,
break
,
return
,
throw
, or
yield
token is encountered and a
LineTerminator
is encountered before the next token, a semicolon is automatically inserted after the
continue
,
break
,
return
,
throw
, or
yield
token.
When arrow function parameter(s) are followed by a
LineTerminator
before a
=>
token, a semicolon is automatically inserted and the punctuator causes a syntax error.
When an
async
token is followed by a
LineTerminator
before a
function
or
IdentifierName
or
(
token, a semicolon is automatically inserted and the
async
token is not treated as part of the same expression or class element as the following tokens.
When an
async
token is followed by a
LineTerminator
before a
*
token, a semicolon is automatically inserted and the punctuator causes a syntax error.
The resulting practical advice to ECMAScript programmers is:
A postfix
++
or
--
operator should be on the same line as its operand.
An
Expression
in a
return
or
throw
statement or an
AssignmentExpression
in a
yield
expression should start on the same line as the
return
,
throw
, or
yield
token.
A
LabelIdentifier
in a
break
or
continue
statement should be on the same line as the
break
or
continue
token.
The end of an arrow function's parameter(s) and its
=>
should be on the same line.
The
async
token preceding an asynchronous function or method should be on the same line as the immediately following token.
12.10.2
Examples of Automatic Semicolon Insertion
This section is non-normative.
The source
{
1
2
}
3
is not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source
{
1
2
}
3
is also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following:
{
1
;
2
;}
3
;
which is a valid ECMAScript sentence.
The source
for
(a; b )
is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a
for
statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a
for
statement.
The source
return
a + b
is transformed by automatic semicolon insertion into the following:
return
; a + b;
Note 1
The expression
a + b
is not treated as a value to be returned by the
return
statement, because a
LineTerminator
separates it from the token
return
.
The source
a = b ++c
is transformed by automatic semicolon insertion into the following:
a = b; ++c;
Note 2
The token
++
is not treated as a postfix operator applying to the variable
b
, because a
LineTerminator
occurs between
b
and
++
.
The source
if
(a > b)
else
c = d
is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the
else
token, even though no production of the grammar applies at that point, because an automatically inserted semicolon would then be parsed as an empty statement.
The source
a = b + c (d + e).
print
()
is
not
transformed by automatic semicolon insertion, because the parenthesized expression that begins the second line can be interpreted as an argument list for a function call:
a = b +
c
(d + e).
print
()
In the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.
12.10.3
Interesting Cases of Automatic Semicolon Insertion
This section is non-normative.
ECMAScript programs can be written in a style with very few semicolons by relying on automatic semicolon insertion. As described above, semicolons are not inserted at every newline, and automatic semicolon insertion can depend on multiple tokens across line terminators.
As new syntactic features are added to ECMAScript, additional grammar productions could be added that cause lines relying on automatic semicolon insertion preceding them to change grammar productions when parsed.
For the purposes of this section, a case of automatic semicolon insertion is considered interesting if it is a place where a semicolon may or may not be inserted, depending on the source text which precedes it. The rest of this section describes a number of interesting cases of automatic semicolon insertion in this version of ECMAScript.
12.10.3.1
Interesting Cases of Automatic Semicolon Insertion in Statement Lists
In a
StatementList
, many
StatementListItem
s end in semicolons, which may be omitted using automatic semicolon insertion. As a consequence of the rules above, at the end of a line ending an expression, a semicolon is required if the following line begins with any of the following:
An opening parenthesis (
(
)
. Without a semicolon, the two lines together are treated as a
CallExpression
.
An opening square bracket (
[
)
. Without a semicolon, the two lines together are treated as property access, rather than an
ArrayLiteral
or
ArrayAssignmentPattern
.
A template literal (
`
)
. Without a semicolon, the two lines together are interpreted as a tagged Template (
13.3.11
), with the previous expression as the
MemberExpression
.
Unary
+
or
-
. Without a semicolon, the two lines together are interpreted as a usage of the corresponding binary operator.
A RegExp literal
. Without a semicolon, the two lines together may be parsed instead as the
/
MultiplicativeOperator
, for example if the RegExp has flags.
12.10.3.2
Cases of Automatic Semicolon Insertion and “[no
LineTerminator
here]”
This section is non-normative.
ECMAScript contains grammar productions which include “[no
LineTerminator
here]”. These productions are sometimes a means to have optional operands in the grammar. Introducing a
LineTerminator
in these locations would change the grammar production of a source text by using the grammar production without the optional operand.
The rest of this section describes a number of productions using “[no
LineTerminator
here]” in this version of ECMAScript.
12.10.3.2.1
List of Grammar Productions with Optional Operands and “[no
LineTerminator
here]”
UpdateExpression
.
ContinueStatement
.
BreakStatement
.
ReturnStatement
.
YieldExpression
.
Async Function Definitions (
15.8
) with relation to Function Definitions (
15.2
)
13
ECMAScript Language: Expressions
13.1
Identifiers
Syntax
IdentifierReference
[Yield, Await]
:
Identifier
[~Yield]
yield
[~Await]
await
BindingIdentifier
[Yield, Await]
:
Identifier
yield
await
LabelIdentifier
[Yield, Await]
:
Identifier
[~Yield]
yield
[~Await]
await
Identifier
:
IdentifierName
but not
ReservedWord
Note
yield
and
await
are permitted as
BindingIdentifier
in the grammar, and prohibited with
static semantics
below, to prohibit automatic semicolon insertion in cases such as
let
await
0
;
13.1.1
Static Semantics: Early Errors
BindingIdentifier
:
Identifier
It is a Syntax Error if
IsStrict
(this production) is
true
and the
StringValue
of
Identifier
is either
"arguments"
or
"eval"
.
IdentifierReference
:
yield
BindingIdentifier
:
yield
LabelIdentifier
:
yield
It is a Syntax Error if
IsStrict
(this production) is
true
.
IdentifierReference
:
await
BindingIdentifier
:
await
LabelIdentifier
:
await
It is a Syntax Error if the
goal symbol
of the syntactic grammar is
Module
.
BindingIdentifier
[Yield, Await]
:
yield
It is a Syntax Error if this production has a
[Yield]
parameter.
BindingIdentifier
[Yield, Await]
:
await
It is a Syntax Error if this production has an
[Await]
parameter.
IdentifierReference
[Yield, Await]
:
Identifier
BindingIdentifier
[Yield, Await]
:
Identifier
LabelIdentifier
[Yield, Await]
:
Identifier
It is a Syntax Error if this production has a
[Yield]
parameter and the
StringValue
of
Identifier
is
"yield"
.
It is a Syntax Error if this production has an
[Await]
parameter and the
StringValue
of
Identifier
is
"await"
.
Identifier
:
IdentifierName
but not
ReservedWord
It is a Syntax Error if
IsStrict
(this phrase) is
true
and the
StringValue
of
IdentifierName
is one of
"implements"
,
"interface"
,
"let"
,
"package"
,
"private"
,
"protected"
,
"public"
,
"static"
, or
"yield"
.
It is a Syntax Error if the
goal symbol
of the syntactic grammar is
Module
and the
StringValue
of
IdentifierName
is
"await"
.
It is a Syntax Error if the
StringValue
of
IdentifierName
is the
StringValue
of any
ReservedWord
except for
yield
or
await
.
Note
The
StringValue
of
IdentifierName
normalizes any Unicode escape sequences in
IdentifierName
hence such escapes cannot be used to write an
Identifier
whose code point sequence is the same as a
ReservedWord
.
13.1.2
Static Semantics: StringValue
The
syntax-directed operation
StringValue takes no arguments and returns a String. It is defined piecewise over the following productions:
IdentifierName
::
IdentifierStart
IdentifierName
IdentifierPart
Let
idTextUnescaped
be the
IdentifierCodePoints
of
IdentifierName
.
Return
CodePointsToString
(
idTextUnescaped
).
IdentifierReference
:
yield
BindingIdentifier
:
yield
LabelIdentifier
:
yield
Return
"yield"
.
IdentifierReference
:
await
BindingIdentifier
:
await
LabelIdentifier
:
await
Return
"await"
.
Identifier
:
IdentifierName
but not
ReservedWord
Return the
StringValue
of
IdentifierName
.
PrivateIdentifier
::
#
IdentifierName
Return the
string-concatenation
of 0x0023 (NUMBER SIGN) and the
StringValue
of
IdentifierName
.
ModuleExportName
:
StringLiteral
Return the
SV
of
StringLiteral
.
13.1.3
Runtime Semantics: Evaluation
IdentifierReference
:
Identifier
Return ?
ResolveBinding
(
StringValue
of
Identifier
).
IdentifierReference
:
yield
Return ?
ResolveBinding
(
"yield"
).
IdentifierReference
:
await
Return ?
ResolveBinding
(
"await"
).
Note 1
The result of evaluating an
IdentifierReference
is always a value of type Reference.
Note 2
In
non-strict code
, the
keyword
yield
may be used as an identifier. Evaluating the
IdentifierReference
resolves the binding of
yield
as if it was an
Identifier
. Early Error restriction ensures that such an evaluation only can occur for
non-strict code
.
13.2
Primary Expression
Syntax
PrimaryExpression
[Yield, Await]
:
this
IdentifierReference
[?Yield, ?Await]
Literal
ArrayLiteral
[?Yield, ?Await]
ObjectLiteral
[?Yield, ?Await]
FunctionExpression
ClassExpression
[?Yield, ?Await]
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
[?Yield, ?Await, ~Tagged]
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
CoverParenthesizedExpressionAndArrowParameterList
[Yield, Await]
:
(
Expression
[+In, ?Yield, ?Await]
)
(
Expression
[+In, ?Yield, ?Await]
,
)
(
)
(
...
BindingIdentifier
[?Yield, ?Await]
)
(
...
BindingPattern
[?Yield, ?Await]
)
(
Expression
[+In, ?Yield, ?Await]
,
...
BindingIdentifier
[?Yield, ?Await]
)
(
Expression
[+In, ?Yield, ?Await]
,
...
BindingPattern
[?Yield, ?Await]
)
Supplemental Syntax
When processing an instance of the production
PrimaryExpression
[Yield, Await]
:
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
the interpretation of
CoverParenthesizedExpressionAndArrowParameterList
is refined using the following grammar:
ParenthesizedExpression
[Yield, Await]
:
(
Expression
[+In, ?Yield, ?Await]
)
13.2.1
The
this
Keyword
13.2.1.1
Runtime Semantics: Evaluation
PrimaryExpression
:
this
Return ?
ResolveThisBinding
().
13.2.2
Identifier Reference
See
13.1
for
IdentifierReference
.
13.2.3
Literals
Syntax
Literal
:
NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
13.2.3.1
Runtime Semantics: Evaluation
Literal
:
NullLiteral
Return
null
.
Literal
:
BooleanLiteral
If
BooleanLiteral
is the token
false
, return
false
.
If
BooleanLiteral
is the token
true
, return
true
.
Literal
:
NumericLiteral
Return the
NumericValue
of
NumericLiteral
as defined in
12.9.3
.
Literal
:
StringLiteral
Return the
SV
of
StringLiteral
as defined in
12.9.4.2
.
13.2.4
Array Initializer
Note
An
ArrayLiteral
is an expression describing the initialization of an Array, using a list, of zero or more expressions each of which represents an array element, enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initializer is evaluated.
Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an
AssignmentExpression
(i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.
Syntax
ArrayLiteral
[Yield, Await]
:
[
Elision
opt
]
[
ElementList
[?Yield, ?Await]
]
[
ElementList
[?Yield, ?Await]
,
Elision
opt
]
ElementList
[Yield, Await]
:
Elision
opt
AssignmentExpression
[+In, ?Yield, ?Await]
Elision
opt
SpreadElement
[?Yield, ?Await]
ElementList
[?Yield, ?Await]
,
Elision
opt
AssignmentExpression
[+In, ?Yield, ?Await]
ElementList
[?Yield, ?Await]
,
Elision
opt
SpreadElement
[?Yield, ?Await]
Elision
:
,
Elision
,
SpreadElement
[Yield, Await]
:
...
AssignmentExpression
[+In, ?Yield, ?Await]
13.2.4.1
Runtime Semantics: ArrayAccumulation
The
syntax-directed operation
ArrayAccumulation takes arguments
array
(an Array) and
nextIndex
(an
integer
) and returns either a
normal completion containing
an
integer
or an
abrupt completion
. It is defined piecewise over the following productions:
Elision
:
,
Let
len
be
nextIndex
+ 1.
Perform ?
Set
(
array
,
"length"
,
𝔽
(
len
),
true
).
NOTE: The above step throws if
len
exceeds 2
32
- 1.
Return
len
.
Elision
:
Elision
,
Return ?
ArrayAccumulation
of
Elision
with arguments
array
and (
nextIndex
+ 1).
ElementList
:
Elision
opt
AssignmentExpression
If
Elision
is present, then
Set
nextIndex
to ?
ArrayAccumulation
of
Elision
with arguments
array
and
nextIndex
.
Let
initResult
be ?
Evaluation
of
AssignmentExpression
.
Let
initValue
be ?
GetValue
(
initResult
).
Perform !
CreateDataPropertyOrThrow
(
array
, !
ToString
(
𝔽
(
nextIndex
)),
initValue
).
Return
nextIndex
+ 1.
ElementList
:
Elision
opt
SpreadElement
If
Elision
is present, then
Set
nextIndex
to ?
ArrayAccumulation
of
Elision
with arguments
array
and
nextIndex
.
Return ?
ArrayAccumulation
of
SpreadElement
with arguments
array
and
nextIndex
.
ElementList
:
ElementList
,
Elision
opt
AssignmentExpression
Set
nextIndex
to ?
ArrayAccumulation
of
ElementList
with arguments
array
and
nextIndex
.
If
Elision
is present, then
Set
nextIndex
to ?
ArrayAccumulation
of
Elision
with arguments
array
and
nextIndex
.
Let
initResult
be ?
Evaluation
of
AssignmentExpression
.
Let
initValue
be ?
GetValue
(
initResult
).
Perform !
CreateDataPropertyOrThrow
(
array
, !
ToString
(
𝔽
(
nextIndex
)),
initValue
).
Return
nextIndex
+ 1.
ElementList
:
ElementList
,
Elision
opt
SpreadElement
Set
nextIndex
to ?
ArrayAccumulation
of
ElementList
with arguments
array
and
nextIndex
.
If
Elision
is present, then
Set
nextIndex
to ?
ArrayAccumulation
of
Elision
with arguments
array
and
nextIndex
.
Return ?
ArrayAccumulation
of
SpreadElement
with arguments
array
and
nextIndex
.
SpreadElement
:
...
AssignmentExpression
Let
spreadRef
be ?
Evaluation
of
AssignmentExpression
.
Let
spreadObj
be ?
GetValue
(
spreadRef
).
Let
iteratorRecord
be ?
GetIterator
(
spreadObj
,
sync
).
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, return
nextIndex
.
Perform !
CreateDataPropertyOrThrow
(
array
, !
ToString
(
𝔽
(
nextIndex
)),
next
).
Set
nextIndex
to
nextIndex
+ 1.
Note
CreateDataPropertyOrThrow
is used to ensure that own properties are defined for the array even if the standard built-in
Array prototype object
has been modified in a manner that would preclude the creation of new own properties using
[[Set]]
.
13.2.4.2
Runtime Semantics: Evaluation
ArrayLiteral
:
[
Elision
opt
]
Let
array
be !
ArrayCreate
(0).
If
Elision
is present, then
Perform ?
ArrayAccumulation
of
Elision
with arguments
array
and 0.
Return
array
.
ArrayLiteral
:
[
ElementList
]
Let
array
be !
ArrayCreate
(0).
Perform ?
ArrayAccumulation
of
ElementList
with arguments
array
and 0.
Return
array
.
ArrayLiteral
:
[
ElementList
,
Elision
opt
]
Let
array
be !
ArrayCreate
(0).
Let
nextIndex
be ?
ArrayAccumulation
of
ElementList
with arguments
array
and 0.
If
Elision
is present, then
Perform ?
ArrayAccumulation
of
Elision
with arguments
array
and
nextIndex
.
Return
array
.
13.2.5
Object Initializer
Note 1
An object initializer is an expression describing the initialization of an Object, written in a form resembling a literal. It is a list of zero or more pairs of
property keys
and associated values, enclosed in curly brackets. The values need not be literals; they are evaluated each time the object initializer is evaluated.
Syntax
ObjectLiteral
[Yield, Await]
:
{
}
{
PropertyDefinitionList
[?Yield, ?Await]
}
{
PropertyDefinitionList
[?Yield, ?Await]
,
}
PropertyDefinitionList
[Yield, Await]
:
PropertyDefinition
[?Yield, ?Await]
PropertyDefinitionList
[?Yield, ?Await]
,
PropertyDefinition
[?Yield, ?Await]
PropertyDefinition
[Yield, Await]
:
IdentifierReference
[?Yield, ?Await]
CoverInitializedName
[?Yield, ?Await]
PropertyName
[?Yield, ?Await]
:
AssignmentExpression
[+In, ?Yield, ?Await]
MethodDefinition
[?Yield, ?Await]
...
AssignmentExpression
[+In, ?Yield, ?Await]
PropertyName
[Yield, Await]
:
LiteralPropertyName
ComputedPropertyName
[?Yield, ?Await]
LiteralPropertyName
:
IdentifierName
StringLiteral
NumericLiteral
ComputedPropertyName
[Yield, Await]
:
[
AssignmentExpression
[+In, ?Yield, ?Await]
]
CoverInitializedName
[Yield, Await]
:
IdentifierReference
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
Initializer
[In, Yield, Await]
:
=
AssignmentExpression
[?In, ?Yield, ?Await]
Note 2
MethodDefinition
is defined in
15.4
.
Note 3
In certain contexts,
ObjectLiteral
is used as a cover grammar for a more restricted secondary grammar. The
CoverInitializedName
production is necessary to fully cover these secondary grammars. However, use of this production results in an early Syntax Error in normal contexts where an actual
ObjectLiteral
is expected.
13.2.5.1
Static Semantics: Early Errors
PropertyDefinition
:
MethodDefinition
It is a Syntax Error if
HasDirectSuper
of
MethodDefinition
is
true
.
It is a Syntax Error if the
PrivateBoundIdentifiers
of
MethodDefinition
is not empty.
In addition to describing an actual object initializer the
ObjectLiteral
productions are also used as a cover grammar for
ObjectAssignmentPattern
and may be recognized as part of a
CoverParenthesizedExpressionAndArrowParameterList
. When
ObjectLiteral
appears in a context where
ObjectAssignmentPattern
is required the following Early Error rules are
not
applied. In addition, they are not applied when initially parsing a
CoverParenthesizedExpressionAndArrowParameterList
or
CoverCallExpressionAndAsyncArrowHead
.
PropertyDefinition
:
CoverInitializedName
It is a Syntax Error if any source text is matched by this production.
Note 1
This production exists so that
ObjectLiteral
can serve as a cover grammar for
ObjectAssignmentPattern
. It cannot occur in an actual object initializer.
ObjectLiteral
:
{
PropertyDefinitionList
}
{
PropertyDefinitionList
,
}
It is a Syntax Error if the
PropertyNameList
of
PropertyDefinitionList
contains any duplicate entries for
"__proto__"
and at least two of those entries were obtained from productions of the form
PropertyDefinition
:
PropertyName
:
AssignmentExpression
. This rule is not applied if this
ObjectLiteral
is contained within a
Script
that is being parsed for
ParseJSON
(see step
3
of
ParseJSON
).
Note 2
The
List
returned by
PropertyNameList
does not include
property names
defined using a
ComputedPropertyName
.
13.2.5.2
Static Semantics: IsComputedPropertyKey
The
syntax-directed operation
IsComputedPropertyKey takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
PropertyName
:
LiteralPropertyName
Return
false
.
PropertyName
:
ComputedPropertyName
Return
true
.
13.2.5.3
Static Semantics: PropertyNameList
The
syntax-directed operation
PropertyNameList takes no arguments and returns a
List
of Strings. It is defined piecewise over the following productions:
PropertyDefinitionList
:
PropertyDefinition
Let
propName
be the
PropName
of
PropertyDefinition
.
If
propName
is
empty
, return a new empty
List
.
Return «
propName
».
PropertyDefinitionList
:
PropertyDefinitionList
,
PropertyDefinition
Let
list
be the
PropertyNameList
of
PropertyDefinitionList
.
Let
propName
be the
PropName
of
PropertyDefinition
.
If
propName
is
empty
, return
list
.
Return the
list-concatenation
of
list
and «
propName
».
13.2.5.4
Runtime Semantics: Evaluation
ObjectLiteral
:
{
}
Return
OrdinaryObjectCreate
(
%Object.prototype%
).
ObjectLiteral
:
{
PropertyDefinitionList
}
{
PropertyDefinitionList
,
}
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform ?
PropertyDefinitionEvaluation
of
PropertyDefinitionList
with argument
obj
.
Return
obj
.
LiteralPropertyName
:
IdentifierName
Return the
StringValue
of
IdentifierName
.
LiteralPropertyName
:
StringLiteral
Return the
SV
of
StringLiteral
.
LiteralPropertyName
:
NumericLiteral
Let
nbr
be the
NumericValue
of
NumericLiteral
.
Return !
ToString
(
nbr
).
ComputedPropertyName
:
[
AssignmentExpression
]
Let
exprValue
be ?
Evaluation
of
AssignmentExpression
.
Let
propName
be ?
GetValue
(
exprValue
).
Return ?
ToPropertyKey
(
propName
).
13.2.5.5
Runtime Semantics: PropertyDefinitionEvaluation
The
syntax-directed operation
PropertyDefinitionEvaluation takes argument
object
(an Object) and returns either a
normal completion containing
unused
or an
abrupt completion
. It is defined piecewise over the following productions:
PropertyDefinitionList
:
PropertyDefinitionList
,
PropertyDefinition
Perform ?
PropertyDefinitionEvaluation
of
PropertyDefinitionList
with argument
object
.
Perform ?
PropertyDefinitionEvaluation
of
PropertyDefinition
with argument
object
.
Return
unused
.
PropertyDefinition
:
...
AssignmentExpression
Let
exprValue
be ?
Evaluation
of
AssignmentExpression
.
Let
fromValue
be ?
GetValue
(
exprValue
).
Let
excludedNames
be a new empty
List
.
Perform ?
CopyDataProperties
(
object
,
fromValue
,
excludedNames
).
Return
unused
.
PropertyDefinition
:
IdentifierReference
Let
propName
be the
StringValue
of
IdentifierReference
.
Let
exprValue
be ?
Evaluation
of
IdentifierReference
.
Let
propValue
be ?
GetValue
(
exprValue
).
Assert
:
object
is an ordinary, extensible object with no non-configurable properties.
Perform !
CreateDataPropertyOrThrow
(
object
,
propName
,
propValue
).
Return
unused
.
PropertyDefinition
:
PropertyName
:
AssignmentExpression
Let
propKey
be ?
Evaluation
of
PropertyName
.
If this
PropertyDefinition
is contained within a
Script
that is being evaluated for
ParseJSON
(see step
6
of
ParseJSON
), then
Let
isProtoSetter
be
false
.
Else if
propKey
is
"__proto__"
and
IsComputedPropertyKey
of
PropertyName
is
false
, then
Let
isProtoSetter
be
true
.
Else,
Let
isProtoSetter
be
false
.
If
IsAnonymousFunctionDefinition
(
AssignmentExpression
) is
true
and
isProtoSetter
is
false
, then
Let
propValue
be ?
NamedEvaluation
of
AssignmentExpression
with argument
propKey
.
Else,
Let
exprValueRef
be ?
Evaluation
of
AssignmentExpression
.
Let
propValue
be ?
GetValue
(
exprValueRef
).
If
isProtoSetter
is
true
, then
If
propValue
is an Object
or
propValue
is
null
, then
Perform !
object
.
[[SetPrototypeOf]]
(
propValue
)
.
Return
unused
.
Assert
:
object
is an ordinary, extensible object with no non-configurable properties.
Perform !
CreateDataPropertyOrThrow
(
object
,
propKey
,
propValue
).
Return
unused
.
PropertyDefinition
:
MethodDefinition
Perform ?
MethodDefinitionEvaluation
of
MethodDefinition
with arguments
object
and
true
.
Return
unused
.
13.2.6
Function Defining Expressions
See
15.2
for
PrimaryExpression
:
FunctionExpression
.
See
15.5
for
PrimaryExpression
:
GeneratorExpression
.
See
15.7
for
PrimaryExpression
:
ClassExpression
.
See
15.8
for
PrimaryExpression
:
AsyncFunctionExpression
.
See
15.6
for
PrimaryExpression
:
AsyncGeneratorExpression
.
13.2.7
Regular Expression Literals
Syntax
See
12.9.5
.
13.2.7.1
Static Semantics: Early Errors
PrimaryExpression
:
RegularExpressionLiteral
It is a Syntax Error if
IsValidRegularExpressionLiteral
(
RegularExpressionLiteral
) is
false
.
13.2.7.2
Static Semantics: IsValidRegularExpressionLiteral (
literal
)
The abstract operation IsValidRegularExpressionLiteral takes argument
literal
(a
RegularExpressionLiteral
Parse Node
) and returns a Boolean. It determines if its argument is a valid regular expression literal. It performs the following steps when called:
Let
flags
be the
FlagText
of
literal
.
If
flags
contains any code points other than
d
,
g
,
i
,
m
,
s
,
u
,
v
, or
y
, or if
flags
contains any code point more than once, return
false
.
If
flags
contains
u
, let
u
be
true
; else let
u
be
false
.
If
flags
contains
v
, let
v
be
true
; else let
v
be
false
.
Let
patternText
be the
BodyText
of
literal
.
If
u
is
false
and
v
is
false
, then
Let
stringValue
be
CodePointsToString
(
patternText
).
Set
patternText
to the sequence of code points resulting from interpreting each of the 16-bit elements of
stringValue
as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.
Let
parseResult
be
ParsePattern
(
patternText
,
u
,
v
).
If
parseResult
is a
Parse Node
, return
true
; else return
false
.
13.2.7.3
Runtime Semantics: Evaluation
PrimaryExpression
:
RegularExpressionLiteral
Let
pattern
be
CodePointsToString
(
BodyText
of
RegularExpressionLiteral
).
Let
flags
be
CodePointsToString
(
FlagText
of
RegularExpressionLiteral
).
Return !
RegExpCreate
(
pattern
,
flags
).
13.2.8
Template Literals
Syntax
TemplateLiteral
[Yield, Await, Tagged]
:
NoSubstitutionTemplate
SubstitutionTemplate
[?Yield, ?Await, ?Tagged]
SubstitutionTemplate
[Yield, Await, Tagged]
:
TemplateHead
Expression
[+In, ?Yield, ?Await]
TemplateSpans
[?Yield, ?Await, ?Tagged]
TemplateSpans
[Yield, Await, Tagged]
:
TemplateTail
TemplateMiddleList
[?Yield, ?Await, ?Tagged]
TemplateTail
TemplateMiddleList
[Yield, Await, Tagged]
:
TemplateMiddle
Expression
[+In, ?Yield, ?Await]
TemplateMiddleList
[?Yield, ?Await, ?Tagged]
TemplateMiddle
Expression
[+In, ?Yield, ?Await]
13.2.8.1
Static Semantics: Early Errors
TemplateLiteral
[Yield, Await, Tagged]
:
NoSubstitutionTemplate
It is a Syntax Error if the
[Tagged]
parameter was not set and
NoSubstitutionTemplate
Contains
NotEscapeSequence
.
TemplateLiteral
[Yield, Await, Tagged]
:
SubstitutionTemplate
[?Yield, ?Await, ?Tagged]
It is a Syntax Error if the number of elements in the
TemplateStrings
of
TemplateLiteral
with argument
false
is greater than or equal to 2
32
.
SubstitutionTemplate
[Yield, Await, Tagged]
:
TemplateHead
Expression
[+In, ?Yield, ?Await]
TemplateSpans
[?Yield, ?Await, ?Tagged]
It is a Syntax Error if the
[Tagged]
parameter was not set and
TemplateHead
Contains
NotEscapeSequence
.
TemplateSpans
[Yield, Await, Tagged]
:
TemplateTail
It is a Syntax Error if the
[Tagged]
parameter was not set and
TemplateTail
Contains
NotEscapeSequence
.
TemplateMiddleList
[Yield, Await, Tagged]
:
TemplateMiddle
Expression
[+In, ?Yield, ?Await]
TemplateMiddleList
[?Yield, ?Await, ?Tagged]
TemplateMiddle
Expression
[+In, ?Yield, ?Await]
It is a Syntax Error if the
[Tagged]
parameter was not set and
TemplateMiddle
Contains
NotEscapeSequence
.
13.2.8.2
Static Semantics: TemplateStrings
The
syntax-directed operation
TemplateStrings takes argument
raw
(a Boolean) and returns a
List
of either Strings or
undefined
. It is defined piecewise over the following productions:
TemplateLiteral
:
NoSubstitutionTemplate
Return «
TemplateString
(
NoSubstitutionTemplate
,
raw
) ».
SubstitutionTemplate
:
TemplateHead
Expression
TemplateSpans
Let
head
be «
TemplateString
(
TemplateHead
,
raw
) ».
Let
tail
be the
TemplateStrings
of
TemplateSpans
with argument
raw
.
Return the
list-concatenation
of
head
and
tail
.
TemplateSpans
:
TemplateTail
Return «
TemplateString
(
TemplateTail
,
raw
) ».
TemplateSpans
:
TemplateMiddleList
TemplateTail
Let
middle
be the
TemplateStrings
of
TemplateMiddleList
with argument
raw
.
Let
tail
be «
TemplateString
(
TemplateTail
,
raw
) ».
Return the
list-concatenation
of
middle
and
tail
.
TemplateMiddleList
:
TemplateMiddle
Expression
Return «
TemplateString
(
TemplateMiddle
,
raw
) ».
TemplateMiddleList
:
TemplateMiddleList
TemplateMiddle
Expression
Let
front
be the
TemplateStrings
of
TemplateMiddleList
with argument
raw
.
Let
last
be «
TemplateString
(
TemplateMiddle
,
raw
) ».
Return the
list-concatenation
of
front
and
last
.
13.2.8.3
Static Semantics: TemplateString (
templateToken
,
raw
)
The abstract operation TemplateString takes arguments
templateToken
(a
NoSubstitutionTemplate
Parse Node
, a
TemplateHead
Parse Node
, a
TemplateMiddle
Parse Node
, or a
TemplateTail
Parse Node
) and
raw
(a Boolean) and returns a String or
undefined
. It performs the following steps when called:
If
raw
is
true
, then
Let
string
be the
TRV
of
templateToken
.
Else,
Let
string
be the
TV
of
templateToken
.
Return
string
.
Note
This operation returns
undefined
if
raw
is
false
and
templateToken
contains a
NotEscapeSequence
. In all other cases, it returns a String.
13.2.8.4
GetTemplateObject (
templateLiteral
)
The abstract operation GetTemplateObject takes argument
templateLiteral
(a
Parse Node
) and returns an Array. It performs the following steps when called:
Let
realm
be
the current Realm Record
.
Let
templateRegistry
be
realm
.
[[TemplateMap]]
.
For each element
e
of
templateRegistry
, do
If
e
.
[[Site]]
is
the same Parse Node
as
templateLiteral
, then
Return
e
.
[[Array]]
.
Let
rawStrings
be the
TemplateStrings
of
templateLiteral
with argument
true
.
Assert
:
rawStrings
is a
List
of Strings.
Let
cookedStrings
be the
TemplateStrings
of
templateLiteral
with argument
false
.
Let
count
be the number of elements in the
List
cookedStrings
.
Assert
:
count
≤ 2
32
- 1.
Let
template
be !
ArrayCreate
(
count
).
Let
rawObj
be !
ArrayCreate
(
count
).
Let
index
be 0.
Repeat, while
index
<
count
,
Let
prop
be !
ToString
(
𝔽
(
index
)).
Let
cookedValue
be
cookedStrings
[
index
].
Perform !
DefinePropertyOrThrow
(
template
,
prop
, PropertyDescriptor {
[[Value]]
:
cookedValue
,
[[Writable]]
:
false
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
false
}).
Let
rawValue
be the String value
rawStrings
[
index
].
Perform !
DefinePropertyOrThrow
(
rawObj
,
prop
, PropertyDescriptor {
[[Value]]
:
rawValue
,
[[Writable]]
:
false
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
false
}).
Set
index
to
index
+ 1.
Perform !
SetIntegrityLevel
(
rawObj
,
frozen
).
Perform !
DefinePropertyOrThrow
(
template
,
"raw"
, PropertyDescriptor {
[[Value]]
:
rawObj
,
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Perform !
SetIntegrityLevel
(
template
,
frozen
).
Append the
Record
{
[[Site]]
:
templateLiteral
,
[[Array]]
:
template
} to
realm
.
[[TemplateMap]]
.
Return
template
.
Note 1
The creation of a template object cannot result in an
abrupt completion
.
Note 2
Each
TemplateLiteral
in the program code of a
realm
is associated with a unique template object that is used in the evaluation of tagged Templates (
13.2.8.6
). The template objects are frozen and the same template object is used each time a specific tagged Template is evaluated. Whether template objects are created lazily upon first evaluation of the
TemplateLiteral
or eagerly prior to first evaluation is an implementation choice that is not observable to ECMAScript code.
Note 3
Future editions of this specification may define additional non-enumerable properties of template objects.
13.2.8.5
Runtime Semantics: SubstitutionEvaluation
The
syntax-directed operation
SubstitutionEvaluation takes no arguments and returns either a
normal completion containing
a
List
of
ECMAScript language values
or an
abrupt completion
. It is defined piecewise over the following productions:
TemplateSpans
:
TemplateTail
Return a new empty
List
.
TemplateSpans
:
TemplateMiddleList
TemplateTail
Return ?
SubstitutionEvaluation
of
TemplateMiddleList
.
TemplateMiddleList
:
TemplateMiddle
Expression
Let
subRef
be ?
Evaluation
of
Expression
.
Let
sub
be ?
GetValue
(
subRef
).
Return «
sub
».
TemplateMiddleList
:
TemplateMiddleList
TemplateMiddle
Expression
Let
preceding
be ?
SubstitutionEvaluation
of
TemplateMiddleList
.
Let
nextRef
be ?
Evaluation
of
Expression
.
Let
next
be ?
GetValue
(
nextRef
).
Return the
list-concatenation
of
preceding
and «
next
».
13.2.8.6
Runtime Semantics: Evaluation
TemplateLiteral
:
NoSubstitutionTemplate
Return the
TV
of
NoSubstitutionTemplate
as defined in
12.9.6
.
SubstitutionTemplate
:
TemplateHead
Expression
TemplateSpans
Let
head
be the
TV
of
TemplateHead
as defined in
12.9.6
.
Let
subRef
be ?
Evaluation
of
Expression
.
Let
sub
be ?
GetValue
(
subRef
).
Let
middle
be ?
ToString
(
sub
).
Let
tail
be ?
Evaluation
of
TemplateSpans
.
Return the
string-concatenation
of
head
,
middle
, and
tail
.
Note 1
The string conversion semantics applied to the
Expression
value are like
String.prototype.concat
rather than the
+
operator.
TemplateSpans
:
TemplateTail
Return the
TV
of
TemplateTail
as defined in
12.9.6
.
TemplateSpans
:
TemplateMiddleList
TemplateTail
Let
head
be ?
Evaluation
of
TemplateMiddleList
.
Let
tail
be the
TV
of
TemplateTail
as defined in
12.9.6
.
Return the
string-concatenation
of
head
and
tail
.
TemplateMiddleList
:
TemplateMiddle
Expression
Let
head
be the
TV
of
TemplateMiddle
as defined in
12.9.6
.
Let
subRef
be ?
Evaluation
of
Expression
.
Let
sub
be ?
GetValue
(
subRef
).
Let
middle
be ?
ToString
(
sub
).
Return the
string-concatenation
of
head
and
middle
.
Note 2
The string conversion semantics applied to the
Expression
value are like
String.prototype.concat
rather than the
+
operator.
TemplateMiddleList
:
TemplateMiddleList
TemplateMiddle
Expression
Let
rest
be ?
Evaluation
of
TemplateMiddleList
.
Let
middle
be the
TV
of
TemplateMiddle
as defined in
12.9.6
.
Let
subRef
be ?
Evaluation
of
Expression
.
Let
sub
be ?
GetValue
(
subRef
).
Let
last
be ?
ToString
(
sub
).
Return the
string-concatenation
of
rest
,
middle
, and
last
.
Note 3
The string conversion semantics applied to the
Expression
value are like
String.prototype.concat
rather than the
+
operator.
13.2.9
The Grouping Operator
13.2.9.1
Static Semantics: Early Errors
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
CoverParenthesizedExpressionAndArrowParameterList
must cover
a
ParenthesizedExpression
.
13.2.9.2
Runtime Semantics: Evaluation
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
Let
expr
be the
ParenthesizedExpression
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return ?
Evaluation
of
expr
.
ParenthesizedExpression
:
(
Expression
)
Return ?
Evaluation
of
Expression
. This may be of type Reference.
Note
This algorithm does not apply
GetValue
to
Evaluation
of
Expression
. The principal motivation for this is so that operators such as
delete
and
typeof
may be applied to parenthesized expressions.
13.3
Left-Hand-Side Expressions
Syntax
MemberExpression
[Yield, Await]
:
PrimaryExpression
[?Yield, ?Await]
MemberExpression
[?Yield, ?Await]
[
Expression
[+In, ?Yield, ?Await]
]
MemberExpression
[?Yield, ?Await]
.
IdentifierName
MemberExpression
[?Yield, ?Await]
TemplateLiteral
[?Yield, ?Await, +Tagged]
SuperProperty
[?Yield, ?Await]
MetaProperty
new
MemberExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
MemberExpression
[?Yield, ?Await]
.
PrivateIdentifier
SuperProperty
[Yield, Await]
:
super
[
Expression
[+In, ?Yield, ?Await]
]
super
.
IdentifierName
MetaProperty
:
NewTarget
ImportMeta
NewTarget
:
new
.
target
ImportMeta
:
import
.
meta
NewExpression
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
new
NewExpression
[?Yield, ?Await]
CallExpression
[Yield, Await]
:
CoverCallExpressionAndAsyncArrowHead
[?Yield, ?Await]
SuperCall
[?Yield, ?Await]
ImportCall
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
[
Expression
[+In, ?Yield, ?Await]
]
CallExpression
[?Yield, ?Await]
.
IdentifierName
CallExpression
[?Yield, ?Await]
TemplateLiteral
[?Yield, ?Await, +Tagged]
CallExpression
[?Yield, ?Await]
.
PrivateIdentifier
SuperCall
[Yield, Await]
:
super
Arguments
[?Yield, ?Await]
ImportCall
[Yield, Await]
:
import
(
AssignmentExpression
[+In, ?Yield, ?Await]
,
opt
)
import
(
AssignmentExpression
[+In, ?Yield, ?Await]
,
AssignmentExpression
[+In, ?Yield, ?Await]
,
opt
)
Arguments
[Yield, Await]
:
(
)
(
ArgumentList
[?Yield, ?Await]
)
(
ArgumentList
[?Yield, ?Await]
,
)
ArgumentList
[Yield, Await]
:
AssignmentExpression
[+In, ?Yield, ?Await]
...
AssignmentExpression
[+In, ?Yield, ?Await]
ArgumentList
[?Yield, ?Await]
,
AssignmentExpression
[+In, ?Yield, ?Await]
ArgumentList
[?Yield, ?Await]
,
...
AssignmentExpression
[+In, ?Yield, ?Await]
OptionalExpression
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
OptionalExpression
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
OptionalChain
[Yield, Await]
:
?.
Arguments
[?Yield, ?Await]
?.
[
Expression
[+In, ?Yield, ?Await]
]
?.
IdentifierName
?.
TemplateLiteral
[?Yield, ?Await, +Tagged]
?.
PrivateIdentifier
OptionalChain
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
[
Expression
[+In, ?Yield, ?Await]
]
OptionalChain
[?Yield, ?Await]
.
IdentifierName
OptionalChain
[?Yield, ?Await]
TemplateLiteral
[?Yield, ?Await, +Tagged]
OptionalChain
[?Yield, ?Await]
.
PrivateIdentifier
LeftHandSideExpression
[Yield, Await]
:
NewExpression
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
OptionalExpression
[?Yield, ?Await]
Supplemental Syntax
When processing an instance of the production
CallExpression
:
CoverCallExpressionAndAsyncArrowHead
the interpretation of
CoverCallExpressionAndAsyncArrowHead
is refined using the following grammar:
CallMemberExpression
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
13.3.1
Static Semantics
13.3.1.1
Static Semantics: Early Errors
OptionalChain
:
?.
TemplateLiteral
OptionalChain
TemplateLiteral
It is a Syntax Error if any source text is matched by this production.
Note
This production exists in order to prevent automatic semicolon insertion rules (
12.10
) from being applied to the following code:
a?.
b
`c`
so that it would be interpreted as two valid statements. The purpose is to maintain consistency with similar code without optional chaining:
a.
b
`c`
which is a valid statement and where automatic semicolon insertion does not apply.
ImportMeta
:
import
.
meta
It is a Syntax Error if the syntactic
goal symbol
is not
Module
.
13.3.2
Property Accessors
Note
Properties are accessed by name, using either the dot notation:
MemberExpression
.
IdentifierName
CallExpression
.
IdentifierName
or the bracket notation:
MemberExpression
[
Expression
]
CallExpression
[
Expression
]
The dot notation is explained by the following syntactic conversion:
MemberExpression
.
IdentifierName
is identical in its behaviour to
MemberExpression
[
<
identifier-name-string
>
]
and similarly
CallExpression
.
IdentifierName
is identical in its behaviour to
CallExpression
[
<
identifier-name-string
>
]
where <
identifier-name-string
> is the
StringValue
of
IdentifierName
.
13.3.2.1
Runtime Semantics: Evaluation
MemberExpression
:
MemberExpression
[
Expression
]
Let
baseReference
be ?
Evaluation
of
MemberExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
Let
strict
be
IsStrict
(this
MemberExpression
).
Return ?
EvaluatePropertyAccessWithExpressionKey
(
baseValue
,
Expression
,
strict
).
MemberExpression
:
MemberExpression
.
IdentifierName
Let
baseReference
be ?
Evaluation
of
MemberExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
Let
strict
be
IsStrict
(this
MemberExpression
).
Return
EvaluatePropertyAccessWithIdentifierKey
(
baseValue
,
IdentifierName
,
strict
).
MemberExpression
:
MemberExpression
.
PrivateIdentifier
Let
baseReference
be ?
Evaluation
of
MemberExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
Let
fieldNameString
be the
StringValue
of
PrivateIdentifier
.
Return
MakePrivateReference
(
baseValue
,
fieldNameString
).
CallExpression
:
CallExpression
[
Expression
]
Let
baseReference
be ?
Evaluation
of
CallExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
Let
strict
be
IsStrict
(this
CallExpression
).
Return ?
EvaluatePropertyAccessWithExpressionKey
(
baseValue
,
Expression
,
strict
).
CallExpression
:
CallExpression
.
IdentifierName
Let
baseReference
be ?
Evaluation
of
CallExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
Let
strict
be
IsStrict
(this
CallExpression
).
Return
EvaluatePropertyAccessWithIdentifierKey
(
baseValue
,
IdentifierName
,
strict
).
CallExpression
:
CallExpression
.
PrivateIdentifier
Let
baseReference
be ?
Evaluation
of
CallExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
Let
fieldNameString
be the
StringValue
of
PrivateIdentifier
.
Return
MakePrivateReference
(
baseValue
,
fieldNameString
).
13.3.3
EvaluatePropertyAccessWithExpressionKey (
baseValue
,
expression
,
strict
)
The abstract operation EvaluatePropertyAccessWithExpressionKey takes arguments
baseValue
(an
ECMAScript language value
),
expression
(an
Expression
Parse Node
), and
strict
(a Boolean) and returns either a
normal completion containing
a
Reference Record
or an
abrupt completion
. It performs the following steps when called:
Let
propertyNameReference
be ?
Evaluation
of
expression
.
Let
propertyNameValue
be ?
GetValue
(
propertyNameReference
).
NOTE: In most cases,
ToPropertyKey
will be performed on
propertyNameValue
immediately after this step. However, in the case of
a[b] = c
, it will not be performed until after evaluation of
c
.
Return the
Reference Record
{
[[Base]]
:
baseValue
,
[[ReferencedName]]
:
propertyNameValue
,
[[Strict]]
:
strict
,
[[ThisValue]]
:
empty
}.
13.3.4
EvaluatePropertyAccessWithIdentifierKey (
baseValue
,
identifierName
,
strict
)
The abstract operation EvaluatePropertyAccessWithIdentifierKey takes arguments
baseValue
(an
ECMAScript language value
),
identifierName
(an
IdentifierName
Parse Node
), and
strict
(a Boolean) and returns a
Reference Record
. It performs the following steps when called:
Let
propertyNameString
be the
StringValue
of
identifierName
.
Return the
Reference Record
{
[[Base]]
:
baseValue
,
[[ReferencedName]]
:
propertyNameString
,
[[Strict]]
:
strict
,
[[ThisValue]]
:
empty
}.
13.3.5
The
new
Operator
13.3.5.1
Runtime Semantics: Evaluation
NewExpression
:
new
NewExpression
Return ?
EvaluateNew
(
NewExpression
,
empty
).
MemberExpression
:
new
MemberExpression
Arguments
Return ?
EvaluateNew
(
MemberExpression
,
Arguments
).
13.3.5.1.1
EvaluateNew (
constructExpr
,
arguments
)
The abstract operation EvaluateNew takes arguments
constructExpr
(a
NewExpression
Parse Node
or a
MemberExpression
Parse Node
) and
arguments
(
empty
or an
Arguments
Parse Node
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
Let
ref
be ?
Evaluation
of
constructExpr
.
Let
constructor
be ?
GetValue
(
ref
).
If
arguments
is
empty
, then
Let
argList
be a new empty
List
.
Else,
Let
argList
be ?
ArgumentListEvaluation
of
arguments
.
If
IsConstructor
(
constructor
) is
false
, throw a
TypeError
exception.
Return ?
Construct
(
constructor
,
argList
).
13.3.6
Function Calls
13.3.6.1
Runtime Semantics: Evaluation
CallExpression
:
CoverCallExpressionAndAsyncArrowHead
Let
expr
be the
CallMemberExpression
that is
covered
by
CoverCallExpressionAndAsyncArrowHead
.
Let
memberExpr
be the
MemberExpression
of
expr
.
Let
arguments
be the
Arguments
of
expr
.
Let
ref
be ?
Evaluation
of
memberExpr
.
Let
func
be ?
GetValue
(
ref
).
If
ref
is a
Reference Record
,
IsPropertyReference
(
ref
) is
false
, and
ref
.
[[ReferencedName]]
is
"eval"
, then
If
SameValue
(
func
,
%eval%
) is
true
, then
Let
argList
be ?
ArgumentListEvaluation
of
arguments
.
If
argList
has no elements, return
undefined
.
Let
evalArg
be the first element of
argList
.
If
IsStrict
(this
CallExpression
) is
true
, let
strictCaller
be
true
; otherwise let
strictCaller
be
false
.
Return ?
PerformEval
(
evalArg
,
strictCaller
,
true
).
Let
thisCall
be this
CallExpression
.
Let
tailCall
be
IsInTailPosition
(
thisCall
).
Return ?
EvaluateCall
(
func
,
ref
,
arguments
,
tailCall
).
A
CallExpression
evaluation that executes step
6.a.v
is a
direct eval
.
CallExpression
:
CallExpression
Arguments
Let
ref
be ?
Evaluation
of
CallExpression
.
Let
func
be ?
GetValue
(
ref
).
Let
thisCall
be this
CallExpression
.
Let
tailCall
be
IsInTailPosition
(
thisCall
).
Return ?
EvaluateCall
(
func
,
ref
,
Arguments
,
tailCall
).
13.3.6.2
EvaluateCall (
func
,
ref
,
arguments
,
tailPosition
)
The abstract operation EvaluateCall takes arguments
func
(an
ECMAScript language value
),
ref
(an
ECMAScript language value
or a
Reference Record
),
arguments
(a
Parse Node
), and
tailPosition
(a Boolean) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
If
ref
is a
Reference Record
, then
If
IsPropertyReference
(
ref
) is
true
, then
Let
thisValue
be
GetThisValue
(
ref
).
Else,
Let
refEnv
be
ref
.
[[Base]]
.
Assert
:
refEnv
is an
Environment Record
.
Let
thisValue
be
refEnv
.
WithBaseObject
().
Else,
Let
thisValue
be
undefined
.
Let
argList
be ?
ArgumentListEvaluation
of
arguments
.
If
func
is not an Object
, throw a
TypeError
exception.
If
IsCallable
(
func
) is
false
, throw a
TypeError
exception.
If
tailPosition
is
true
, perform
PrepareForTailCall
().
Return ?
Call
(
func
,
thisValue
,
argList
).
13.3.7
The
super
Keyword
13.3.7.1
Runtime Semantics: Evaluation
SuperProperty
:
super
[
Expression
]
Let
env
be
GetThisEnvironment
().
Let
actualThis
be ?
env
.
GetThisBinding
().
Let
propertyNameReference
be ?
Evaluation
of
Expression
.
Let
propertyNameValue
be ?
GetValue
(
propertyNameReference
).
Let
strict
be
IsStrict
(this
SuperProperty
).
NOTE: In most cases,
ToPropertyKey
will be performed on
propertyNameValue
immediately after this step. However, in the case of
super[b] = c
, it will not be performed until after evaluation of
c
.
Return
MakeSuperPropertyReference
(
actualThis
,
propertyNameValue
,
strict
).
SuperProperty
:
super
.
IdentifierName
Let
env
be
GetThisEnvironment
().
Let
actualThis
be ?
env
.
GetThisBinding
().
Let
propertyKey
be the
StringValue
of
IdentifierName
.
Let
strict
be
IsStrict
(this
SuperProperty
).
Return
MakeSuperPropertyReference
(
actualThis
,
propertyKey
,
strict
).
SuperCall
:
super
Arguments
Let
newTarget
be
GetNewTarget
().
Assert
:
newTarget
is a
constructor
.
Let
func
be
GetSuperConstructor
().
Let
argList
be ?
ArgumentListEvaluation
of
Arguments
.
If
IsConstructor
(
func
) is
false
, throw a
TypeError
exception.
Let
result
be ?
Construct
(
func
,
argList
,
newTarget
).
Let
thisER
be
GetThisEnvironment
().
Assert
:
thisER
is a
Function Environment Record
.
Perform ?
BindThisValue
(
thisER
,
result
).
Let
F
be
thisER
.
[[FunctionObject]]
.
Assert
:
F
is an ECMAScript
function object
.
Perform ?
InitializeInstanceElements
(
result
,
F
).
Return
result
.
13.3.7.2
GetSuperConstructor ( )
The abstract operation GetSuperConstructor takes no arguments and returns an
ECMAScript language value
. It performs the following steps when called:
Let
envRec
be
GetThisEnvironment
().
Assert
:
envRec
is a
Function Environment Record
.
Let
activeFunction
be
envRec
.
[[FunctionObject]]
.
Assert
:
activeFunction
is an ECMAScript
function object
.
Let
superConstructor
be !
activeFunction
.
[[GetPrototypeOf]]
().
Return
superConstructor
.
13.3.7.3
MakeSuperPropertyReference (
actualThis
,
propertyKey
,
strict
)
The abstract operation MakeSuperPropertyReference takes arguments
actualThis
(an
ECMAScript language value
),
propertyKey
(an
ECMAScript language value
), and
strict
(a Boolean) and returns a
Super Reference Record
. It performs the following steps when called:
Let
env
be
GetThisEnvironment
().
Assert
:
env
.
HasSuperBinding
() is
true
.
Assert
:
env
is a
Function Environment Record
.
Let
baseValue
be
GetSuperBase
(
env
).
Return the
Reference Record
{
[[Base]]
:
baseValue
,
[[ReferencedName]]
:
propertyKey
,
[[Strict]]
:
strict
,
[[ThisValue]]
:
actualThis
}.
13.3.8
Argument Lists
Note
The evaluation of an argument list produces a
List
of values.
13.3.8.1
Runtime Semantics: ArgumentListEvaluation
The
syntax-directed operation
ArgumentListEvaluation takes no arguments and returns either a
normal completion containing
a
List
of
ECMAScript language values
or an
abrupt completion
. It is defined piecewise over the following productions:
Arguments
:
(
)
Return a new empty
List
.
ArgumentList
:
AssignmentExpression
Let
ref
be ?
Evaluation
of
AssignmentExpression
.
Let
arg
be ?
GetValue
(
ref
).
Return «
arg
».
ArgumentList
:
...
AssignmentExpression
Let
list
be a new empty
List
.
Let
spreadRef
be ?
Evaluation
of
AssignmentExpression
.
Let
spreadObj
be ?
GetValue
(
spreadRef
).
Let
iteratorRecord
be ?
GetIterator
(
spreadObj
,
sync
).
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, return
list
.
Append
next
to
list
.
ArgumentList
:
ArgumentList
,
AssignmentExpression
Let
precedingArgs
be ?
ArgumentListEvaluation
of
ArgumentList
.
Let
ref
be ?
Evaluation
of
AssignmentExpression
.
Let
arg
be ?
GetValue
(
ref
).
Return the
list-concatenation
of
precedingArgs
and «
arg
».
ArgumentList
:
ArgumentList
,
...
AssignmentExpression
Let
precedingArgs
be ?
ArgumentListEvaluation
of
ArgumentList
.
Let
spreadRef
be ?
Evaluation
of
AssignmentExpression
.
Let
iteratorRecord
be ?
GetIterator
(?
GetValue
(
spreadRef
),
sync
).
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, return
precedingArgs
.
Append
next
to
precedingArgs
.
TemplateLiteral
:
NoSubstitutionTemplate
Let
templateLiteral
be this
TemplateLiteral
.
Let
siteObj
be
GetTemplateObject
(
templateLiteral
).
Return «
siteObj
».
TemplateLiteral
:
SubstitutionTemplate
Let
templateLiteral
be this
TemplateLiteral
.
Let
siteObj
be
GetTemplateObject
(
templateLiteral
).
Let
remaining
be ?
ArgumentListEvaluation
of
SubstitutionTemplate
.
Return the
list-concatenation
of «
siteObj
» and
remaining
.
SubstitutionTemplate
:
TemplateHead
Expression
TemplateSpans
Let
firstSubRef
be ?
Evaluation
of
Expression
.
Let
firstSub
be ?
GetValue
(
firstSubRef
).
Let
restSub
be ?
SubstitutionEvaluation
of
TemplateSpans
.
Assert
:
restSub
is a possibly empty
List
.
Return the
list-concatenation
of «
firstSub
» and
restSub
.
13.3.9
Optional Chains
Note
An optional chain is a chain of one or more property accesses and function calls, the first of which begins with the token
?.
.
13.3.9.1
Runtime Semantics: Evaluation
OptionalExpression
:
MemberExpression
OptionalChain
Let
baseReference
be ?
Evaluation
of
MemberExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
If
baseValue
is either
undefined
or
null
, then
Return
undefined
.
Return ?
ChainEvaluation
of
OptionalChain
with arguments
baseValue
and
baseReference
.
OptionalExpression
:
CallExpression
OptionalChain
Let
baseReference
be ?
Evaluation
of
CallExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
If
baseValue
is either
undefined
or
null
, then
Return
undefined
.
Return ?
ChainEvaluation
of
OptionalChain
with arguments
baseValue
and
baseReference
.
OptionalExpression
:
OptionalExpression
OptionalChain
Let
baseReference
be ?
Evaluation
of
OptionalExpression
.
Let
baseValue
be ?
GetValue
(
baseReference
).
If
baseValue
is either
undefined
or
null
, then
Return
undefined
.
Return ?
ChainEvaluation
of
OptionalChain
with arguments
baseValue
and
baseReference
.
13.3.9.2
Runtime Semantics: ChainEvaluation
The
syntax-directed operation
ChainEvaluation takes arguments
baseValue
(an
ECMAScript language value
) and
baseReference
(an
ECMAScript language value
or a
Reference Record
) and returns either a
normal completion containing
either an
ECMAScript language value
or a
Reference Record
, or an
abrupt completion
. It is defined piecewise over the following productions:
OptionalChain
:
?.
Arguments
Let
thisChain
be this
OptionalChain
.
Let
tailCall
be
IsInTailPosition
(
thisChain
).
Return ?
EvaluateCall
(
baseValue
,
baseReference
,
Arguments
,
tailCall
).
OptionalChain
:
?.
[
Expression
]
Let
strict
be
IsStrict
(this
OptionalChain
).
Return ?
EvaluatePropertyAccessWithExpressionKey
(
baseValue
,
Expression
,
strict
).
OptionalChain
:
?.
IdentifierName
Let
strict
be
IsStrict
(this
OptionalChain
).
Return
EvaluatePropertyAccessWithIdentifierKey
(
baseValue
,
IdentifierName
,
strict
).
OptionalChain
:
?.
PrivateIdentifier
Let
fieldNameString
be the
StringValue
of
PrivateIdentifier
.
Return
MakePrivateReference
(
baseValue
,
fieldNameString
).
OptionalChain
:
OptionalChain
Arguments
Let
optionalChain
be
OptionalChain
.
Let
newReference
be ?
ChainEvaluation
of
optionalChain
with arguments
baseValue
and
baseReference
.
Let
newValue
be ?
GetValue
(
newReference
).
Let
thisChain
be this
OptionalChain
.
Let
tailCall
be
IsInTailPosition
(
thisChain
).
Return ?
EvaluateCall
(
newValue
,
newReference
,
Arguments
,
tailCall
).
OptionalChain
:
OptionalChain
[
Expression
]
Let
optionalChain
be
OptionalChain
.
Let
newReference
be ?
ChainEvaluation
of
optionalChain
with arguments
baseValue
and
baseReference
.
Let
newValue
be ?
GetValue
(
newReference
).
Let
strict
be
IsStrict
(this
OptionalChain
).
Return ?
EvaluatePropertyAccessWithExpressionKey
(
newValue
,
Expression
,
strict
).
OptionalChain
:
OptionalChain
.
IdentifierName
Let
optionalChain
be
OptionalChain
.
Let
newReference
be ?
ChainEvaluation
of
optionalChain
with arguments
baseValue
and
baseReference
.
Let
newValue
be ?
GetValue
(
newReference
).
Let
strict
be
IsStrict
(this
OptionalChain
).
Return
EvaluatePropertyAccessWithIdentifierKey
(
newValue
,
IdentifierName
,
strict
).
OptionalChain
:
OptionalChain
.
PrivateIdentifier
Let
optionalChain
be
OptionalChain
.
Let
newReference
be ?
ChainEvaluation
of
optionalChain
with arguments
baseValue
and
baseReference
.
Let
newValue
be ?
GetValue
(
newReference
).
Let
fieldNameString
be the
StringValue
of
PrivateIdentifier
.
Return
MakePrivateReference
(
newValue
,
fieldNameString
).
13.3.10
Import Calls
13.3.10.1
Runtime Semantics: Evaluation
ImportCall
:
import
(
AssignmentExpression
,
opt
)
Return ?
EvaluateImportCall
(
AssignmentExpression
).
ImportCall
:
import
(
AssignmentExpression
,
AssignmentExpression
,
opt
)
Return ?
EvaluateImportCall
(the first
AssignmentExpression
, the second
AssignmentExpression
).
13.3.10.2
EvaluateImportCall (
specifierExpression
[ ,
optionsExpression
] )
The abstract operation EvaluateImportCall takes argument
specifierExpression
(a
Parse Node
) and optional argument
optionsExpression
(a
Parse Node
) and returns either a
normal completion containing
a Promise or an
abrupt completion
. It performs the following steps when called:
Let
referrer
be
GetActiveScriptOrModule
().
If
referrer
is
null
, set
referrer
to
the current Realm Record
.
Let
specifierRef
be ?
Evaluation
of
specifierExpression
.
Let
specifier
be ?
GetValue
(
specifierRef
).
If
optionsExpression
is present, then
Let
optionsRef
be ?
Evaluation
of
optionsExpression
.
Let
options
be ?
GetValue
(
optionsRef
).
Else,
Let
options
be
undefined
.
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
specifierString
be
Completion
(
ToString
(
specifier
)).
IfAbruptRejectPromise
(
specifierString
,
promiseCapability
).
Let
attributes
be a new empty
List
.
If
options
is not
undefined
, then
If
options
is not an Object
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, « a newly created
TypeError
object »).
Return
promiseCapability
.
[[Promise]]
.
Let
attributesObj
be
Completion
(
Get
(
options
,
"with"
)).
IfAbruptRejectPromise
(
attributesObj
,
promiseCapability
).
If
attributesObj
is not
undefined
, then
If
attributesObj
is not an Object
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, « a newly created
TypeError
object »).
Return
promiseCapability
.
[[Promise]]
.
Let
entries
be
Completion
(
EnumerableOwnProperties
(
attributesObj
,
key+value
)).
IfAbruptRejectPromise
(
entries
,
promiseCapability
).
For each element
entry
of
entries
, do
Let
key
be !
Get
(
entry
,
"0"
).
Let
value
be !
Get
(
entry
,
"1"
).
If
key
is a String
, then
If
value
is not a String
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, « a newly created
TypeError
object »).
Return
promiseCapability
.
[[Promise]]
.
Append the
ImportAttribute Record
{
[[Key]]
:
key
,
[[Value]]
:
value
} to
attributes
.
If
AllImportAttributesSupported
(
attributes
) is
false
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, « a newly created
TypeError
object »).
Return
promiseCapability
.
[[Promise]]
.
Sort
attributes
according to the lexicographic order of their
[[Key]]
field, treating the value of each such field as a sequence of UTF-16 code unit values. NOTE: This sorting is observable only in that
hosts
are prohibited from changing behaviour based on the order in which attributes are enumerated.
Let
moduleRequest
be a new
ModuleRequest Record
{
[[Specifier]]
:
specifierString
,
[[Attributes]]
:
attributes
}.
Perform
HostLoadImportedModule
(
referrer
,
moduleRequest
,
empty
,
promiseCapability
).
Return
promiseCapability
.
[[Promise]]
.
13.3.10.3
ContinueDynamicImport (
promiseCapability
,
moduleCompletion
)
The abstract operation ContinueDynamicImport takes arguments
promiseCapability
(a
PromiseCapability Record
) and
moduleCompletion
(either a
normal completion containing
a
Module Record
or a
throw completion
) and returns
unused
. It completes the process of a dynamic import originally started by an
import()
call, resolving or rejecting the promise returned by that call as appropriate. It performs the following steps when called:
If
moduleCompletion
is an
abrupt completion
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
moduleCompletion
.
[[Value]]
»).
Return
unused
.
Let
module
be
moduleCompletion
.
[[Value]]
.
Let
loadPromise
be
module
.
LoadRequestedModules
().
Let
rejectedClosure
be a new
Abstract Closure
with parameters (
reason
) that captures
promiseCapability
and performs the following steps when called:
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
reason
»).
Return
NormalCompletion
(
undefined
).
Let
onRejected
be
CreateBuiltinFunction
(
rejectedClosure
, 1,
""
, « »).
Let
linkAndEvaluateClosure
be a new
Abstract Closure
with no parameters that captures
module
,
promiseCapability
, and
onRejected
and performs the following steps when called:
Let
link
be
Completion
(
module
.
Link
()).
If
link
is an
abrupt completion
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
link
.
[[Value]]
»).
Return
NormalCompletion
(
undefined
).
Let
evaluatePromise
be
module
.
Evaluate
().
Let
fulfilledClosure
be a new
Abstract Closure
with no parameters that captures
module
and
promiseCapability
and performs the following steps when called:
Let
namespace
be
GetModuleNamespace
(
module
).
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
namespace
»).
Return
NormalCompletion
(
undefined
).
Let
onFulfilled
be
CreateBuiltinFunction
(
fulfilledClosure
, 0,
""
, « »).
Perform
PerformPromiseThen
(
evaluatePromise
,
onFulfilled
,
onRejected
).
Return
unused
.
Let
linkAndEvaluate
be
CreateBuiltinFunction
(
linkAndEvaluateClosure
, 0,
""
, « »).
Perform
PerformPromiseThen
(
loadPromise
,
linkAndEvaluate
,
onRejected
).
Return
unused
.
13.3.11
Tagged Templates
Note
A tagged template is a function call where the arguments of the call are derived from a
TemplateLiteral
(
13.2.8
). The actual arguments include a template object (
13.2.8.4
) and the values produced by evaluating the expressions embedded within the
TemplateLiteral
.
13.3.11.1
Runtime Semantics: Evaluation
MemberExpression
:
MemberExpression
TemplateLiteral
Let
tagRef
be ?
Evaluation
of
MemberExpression
.
Let
tagFunc
be ?
GetValue
(
tagRef
).
Let
thisCall
be this
MemberExpression
.
Let
tailCall
be
IsInTailPosition
(
thisCall
).
Return ?
EvaluateCall
(
tagFunc
,
tagRef
,
TemplateLiteral
,
tailCall
).
CallExpression
:
CallExpression
TemplateLiteral
Let
tagRef
be ?
Evaluation
of
CallExpression
.
Let
tagFunc
be ?
GetValue
(
tagRef
).
Let
thisCall
be this
CallExpression
.
Let
tailCall
be
IsInTailPosition
(
thisCall
).
Return ?
EvaluateCall
(
tagFunc
,
tagRef
,
TemplateLiteral
,
tailCall
).
13.3.12
Meta Properties
13.3.12.1
Runtime Semantics: Evaluation
NewTarget
:
new
.
target
Return
GetNewTarget
().
ImportMeta
:
import
.
meta
Let
module
be
GetActiveScriptOrModule
().
Assert
:
module
is a
Source Text Module Record
.
Let
importMeta
be
module
.
[[ImportMeta]]
.
If
importMeta
is
empty
, then
Set
importMeta
to
OrdinaryObjectCreate
(
null
).
Let
importMetaValues
be
HostGetImportMetaProperties
(
module
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
importMetaValues
, do
Perform !
CreateDataPropertyOrThrow
(
importMeta
,
p
.
[[Key]]
,
p
.
[[Value]]
).
Perform
HostFinalizeImportMeta
(
importMeta
,
module
).
Set
module
.
[[ImportMeta]]
to
importMeta
.
Return
importMeta
.
Else,
Assert
:
importMeta
is an Object
.
Return
importMeta
.
13.3.12.1.1
HostGetImportMetaProperties (
moduleRecord
)
The
host-defined
abstract operation HostGetImportMetaProperties takes argument
moduleRecord
(a
Module Record
) and returns a
List
of
Records
with fields
[[Key]]
(a
property key
) and
[[Value]]
(an
ECMAScript language value
). It allows
hosts
to provide
property keys
and values for the object returned from
import.meta
.
The default implementation of HostGetImportMetaProperties is to return a new empty
List
.
13.3.12.1.2
HostFinalizeImportMeta (
importMeta
,
moduleRecord
)
The
host-defined
abstract operation HostFinalizeImportMeta takes arguments
importMeta
(an Object) and
moduleRecord
(a
Module Record
) and returns
unused
. It allows
hosts
to perform any extraordinary operations to prepare the object returned from
import.meta
.
Most
hosts
will be able to simply define
HostGetImportMetaProperties
, and leave HostFinalizeImportMeta with its default behaviour. However, HostFinalizeImportMeta provides an "escape hatch" for
hosts
which need to directly manipulate the object before it is exposed to ECMAScript code.
The default implementation of HostFinalizeImportMeta is to return
unused
.
13.4
Update Expressions
Syntax
UpdateExpression
[Yield, Await]
:
LeftHandSideExpression
[?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
[no
LineTerminator
here]
++
LeftHandSideExpression
[?Yield, ?Await]
[no
LineTerminator
here]
--
++
UnaryExpression
[?Yield, ?Await]
--
UnaryExpression
[?Yield, ?Await]
13.4.1
Static Semantics: Early Errors
UpdateExpression
:
LeftHandSideExpression
++
LeftHandSideExpression
--
It is an early Syntax Error if the
AssignmentTargetType
of
LeftHandSideExpression
is
invalid
.
UpdateExpression
:
++
UnaryExpression
--
UnaryExpression
It is an early Syntax Error if the
AssignmentTargetType
of
UnaryExpression
is
invalid
.
13.4.2
Postfix Increment Operator
13.4.2.1
Runtime Semantics: Evaluation
UpdateExpression
:
LeftHandSideExpression
++
Let
lhs
be ?
Evaluation
of
LeftHandSideExpression
.
If the
AssignmentTargetType
of
LeftHandSideExpression
is
web-compat
, throw a
ReferenceError
exception.
Let
oldValue
be ?
ToNumeric
(?
GetValue
(
lhs
)).
If
oldValue
is a Number
, then
Let
newValue
be
Number::add
(
oldValue
,
1
𝔽
).
Else,
Assert
:
oldValue
is a BigInt
.
Let
newValue
be
BigInt::add
(
oldValue
,
1
ℤ
).
Perform ?
PutValue
(
lhs
,
newValue
).
Return
oldValue
.
13.4.3
Postfix Decrement Operator
13.4.3.1
Runtime Semantics: Evaluation
UpdateExpression
:
LeftHandSideExpression
--
Let
lhs
be ?
Evaluation
of
LeftHandSideExpression
.
If the
AssignmentTargetType
of
LeftHandSideExpression
is
web-compat
, throw a
ReferenceError
exception.
Let
oldValue
be ?
ToNumeric
(?
GetValue
(
lhs
)).
If
oldValue
is a Number
, then
Let
newValue
be
Number::subtract
(
oldValue
,
1
𝔽
).
Else,
Assert
:
oldValue
is a BigInt
.
Let
newValue
be
BigInt::subtract
(
oldValue
,
1
ℤ
).
Perform ?
PutValue
(
lhs
,
newValue
).
Return
oldValue
.
13.4.4
Prefix Increment Operator
13.4.4.1
Runtime Semantics: Evaluation
UpdateExpression
:
++
UnaryExpression
Let
expr
be ?
Evaluation
of
UnaryExpression
.
If the
AssignmentTargetType
of
UnaryExpression
is
web-compat
, throw a
ReferenceError
exception.
Let
oldValue
be ?
ToNumeric
(?
GetValue
(
expr
)).
If
oldValue
is a Number
, then
Let
newValue
be
Number::add
(
oldValue
,
1
𝔽
).
Else,
Assert
:
oldValue
is a BigInt
.
Let
newValue
be
BigInt::add
(
oldValue
,
1
ℤ
).
Perform ?
PutValue
(
expr
,
newValue
).
Return
newValue
.
13.4.5
Prefix Decrement Operator
13.4.5.1
Runtime Semantics: Evaluation
UpdateExpression
:
--
UnaryExpression
Let
expr
be ?
Evaluation
of
UnaryExpression
.
If the
AssignmentTargetType
of
UnaryExpression
is
web-compat
, throw a
ReferenceError
exception.
Let
oldValue
be ?
ToNumeric
(?
GetValue
(
expr
)).
If
oldValue
is a Number
, then
Let
newValue
be
Number::subtract
(
oldValue
,
1
𝔽
).
Else,
Assert
:
oldValue
is a BigInt
.
Let
newValue
be
BigInt::subtract
(
oldValue
,
1
ℤ
).
Perform ?
PutValue
(
expr
,
newValue
).
Return
newValue
.
13.5
Unary Operators
Syntax
UnaryExpression
[Yield, Await]
:
UpdateExpression
[?Yield, ?Await]
delete
UnaryExpression
[?Yield, ?Await]
void
UnaryExpression
[?Yield, ?Await]
typeof
UnaryExpression
[?Yield, ?Await]
+
UnaryExpression
[?Yield, ?Await]
-
UnaryExpression
[?Yield, ?Await]
~
UnaryExpression
[?Yield, ?Await]
!
UnaryExpression
[?Yield, ?Await]
[+Await]
AwaitExpression
[?Yield]
13.5.1
The
delete
Operator
13.5.1.1
Static Semantics: Early Errors
UnaryExpression
:
delete
UnaryExpression
It is a Syntax Error if
IsStrict
(the
UnaryExpression
) is
true
and the derived
UnaryExpression
is
PrimaryExpression
:
IdentifierReference
,
MemberExpression
:
MemberExpression
.
PrivateIdentifier
,
CallExpression
:
CallExpression
.
PrivateIdentifier
,
OptionalChain
:
?.
PrivateIdentifier
, or
OptionalChain
:
OptionalChain
.
PrivateIdentifier
.
It is a Syntax Error if the derived
UnaryExpression
is
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
and
CoverParenthesizedExpressionAndArrowParameterList
ultimately derives a phrase that, if used in place of
UnaryExpression
, would produce a Syntax Error according to these rules. This rule is recursively applied.
Note
The last rule means that expressions such as
delete (((foo)))
produce
early errors
because of recursive application of the first rule.
13.5.1.2
Runtime Semantics: Evaluation
UnaryExpression
:
delete
UnaryExpression
Let
ref
be ?
Evaluation
of
UnaryExpression
.
If
ref
is not a
Reference Record
, return
true
.
If
IsUnresolvableReference
(
ref
) is
true
, then
Assert
:
ref
.
[[Strict]]
is
false
.
Return
true
.
If
IsPropertyReference
(
ref
) is
true
, then
Assert
:
IsPrivateReference
(
ref
) is
false
.
If
IsSuperReference
(
ref
) is
true
, throw a
ReferenceError
exception.
Let
baseObj
be ?
ToObject
(
ref
.
[[Base]]
).
If
ref
.
[[ReferencedName]]
is not a
property key
, then
Set
ref
.
[[ReferencedName]]
to ?
ToPropertyKey
(
ref
.
[[ReferencedName]]
).
Let
deleteStatus
be ?
baseObj
.
[[Delete]]
(
ref
.
[[ReferencedName]]
)
.
If
deleteStatus
is
false
and
ref
.
[[Strict]]
is
true
, throw a
TypeError
exception.
Return
deleteStatus
.
Else,
Let
base
be
ref
.
[[Base]]
.
Assert
:
base
is an
Environment Record
.
Return ?
base
.
DeleteBinding
(
ref
.
[[ReferencedName]]
)
.
Note 1
When a
delete
operator occurs within
strict mode code
, a
SyntaxError
exception is thrown if its
UnaryExpression
is a direct reference to a variable, function argument, or function name. In addition, if a
delete
operator occurs within
strict mode code
and the property to be deleted has the attribute {
[[Configurable]]
:
false
} (or otherwise cannot be deleted), a
TypeError
exception is thrown.
Note 2
The object that may be created in step
4.c
is not accessible outside of the above abstract operation and the
ordinary object
[[Delete]]
internal method. An implementation might choose to avoid the actual creation of that object.
13.5.2
The
void
Operator
13.5.2.1
Runtime Semantics: Evaluation
UnaryExpression
:
void
UnaryExpression
Let
expr
be ?
Evaluation
of
UnaryExpression
.
Perform ?
GetValue
(
expr
).
Return
undefined
.
Note
GetValue
must be called even though its value is not used because it may have observable side-effects.
13.5.3
The
typeof
Operator
13.5.3.1
Runtime Semantics: Evaluation
UnaryExpression
:
typeof
UnaryExpression
Let
val
be ?
Evaluation
of
UnaryExpression
.
If
val
is a
Reference Record
, then
If
IsUnresolvableReference
(
val
) is
true
, return
"undefined"
.
Set
val
to ?
GetValue
(
val
).
If
val
is
undefined
, return
"undefined"
.
If
val
is
null
, return
"object"
.
If
val
is a String
, return
"string"
.
If
val
is a Symbol
, return
"symbol"
.
If
val
is a Boolean
, return
"boolean"
.
If
val
is a Number
, return
"number"
.
If
val
is a BigInt
, return
"bigint"
.
Assert
:
val
is an Object
.
Normative Optional
If the
host
is a web browser or otherwise supports
The
[[IsHTMLDDA]]
Internal Slot
, then
If
val
has an
[[IsHTMLDDA]]
internal slot, return
"undefined"
.
If
val
has a
[[Call]]
internal method, return
"function"
.
Return
"object"
.
13.5.4
Unary
+
Operator
Note
The unary + operator converts its operand to
Number type
.
13.5.4.1
Runtime Semantics: Evaluation
UnaryExpression
:
+
UnaryExpression
Let
expr
be ?
Evaluation
of
UnaryExpression
.
Return ?
ToNumber
(?
GetValue
(
expr
)).
13.5.5
Unary
-
Operator
Note
The unary
-
operator converts its operand to a numeric value and then negates it. Negating
+0
𝔽
produces
-0
𝔽
, and negating
-0
𝔽
produces
+0
𝔽
.
13.5.5.1
Runtime Semantics: Evaluation
UnaryExpression
:
-
UnaryExpression
Let
expr
be ?
Evaluation
of
UnaryExpression
.
Let
oldValue
be ?
ToNumeric
(?
GetValue
(
expr
)).
If
oldValue
is a Number
, then
Return
Number::unaryMinus
(
oldValue
).
Else,
Assert
:
oldValue
is a BigInt
.
Return
BigInt::unaryMinus
(
oldValue
).
13.5.6
Bitwise NOT Operator (
~
)
13.5.6.1
Runtime Semantics: Evaluation
UnaryExpression
:
~
UnaryExpression
Let
expr
be ?
Evaluation
of
UnaryExpression
.
Let
oldValue
be ?
ToNumeric
(?
GetValue
(
expr
)).
If
oldValue
is a Number
, then
Return
Number::bitwiseNOT
(
oldValue
).
Else,
Assert
:
oldValue
is a BigInt
.
Return
BigInt::bitwiseNOT
(
oldValue
).
13.5.7
Logical NOT Operator (
!
)
13.5.7.1
Runtime Semantics: Evaluation
UnaryExpression
:
!
UnaryExpression
Let
expr
be ?
Evaluation
of
UnaryExpression
.
Let
oldValue
be
ToBoolean
(?
GetValue
(
expr
)).
If
oldValue
is
true
, return
false
.
Return
true
.
13.6
Exponentiation Operator
Syntax
ExponentiationExpression
[Yield, Await]
:
UnaryExpression
[?Yield, ?Await]
UpdateExpression
[?Yield, ?Await]
**
ExponentiationExpression
[?Yield, ?Await]
13.6.1
Runtime Semantics: Evaluation
ExponentiationExpression
:
UpdateExpression
**
ExponentiationExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
UpdateExpression
,
**
,
ExponentiationExpression
).
13.7
Multiplicative Operators
Syntax
MultiplicativeExpression
[Yield, Await]
:
ExponentiationExpression
[?Yield, ?Await]
MultiplicativeExpression
[?Yield, ?Await]
MultiplicativeOperator
ExponentiationExpression
[?Yield, ?Await]
MultiplicativeOperator
:
one of
*
/
%
Note
The
*
operator performs multiplication, producing the product of its operands.
The
/
operator performs division, producing the quotient of its operands.
The
%
operator yields the remainder of its operands from an implied division.
13.7.1
Runtime Semantics: Evaluation
MultiplicativeExpression
:
MultiplicativeExpression
MultiplicativeOperator
ExponentiationExpression
Let
opText
be the
source text matched by
MultiplicativeOperator
.
Return ?
EvaluateStringOrNumericBinaryExpression
(
MultiplicativeExpression
,
opText
,
ExponentiationExpression
).
13.8
Additive Operators
Syntax
AdditiveExpression
[Yield, Await]
:
MultiplicativeExpression
[?Yield, ?Await]
AdditiveExpression
[?Yield, ?Await]
+
MultiplicativeExpression
[?Yield, ?Await]
AdditiveExpression
[?Yield, ?Await]
-
MultiplicativeExpression
[?Yield, ?Await]
13.8.1
The Addition Operator (
+
)
Note
The addition operator either performs string concatenation or numeric addition.
13.8.1.1
Runtime Semantics: Evaluation
AdditiveExpression
:
AdditiveExpression
+
MultiplicativeExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
AdditiveExpression
,
+
,
MultiplicativeExpression
).
13.8.2
The Subtraction Operator (
-
)
Note
The
-
operator performs subtraction, producing the difference of its operands.
13.8.2.1
Runtime Semantics: Evaluation
AdditiveExpression
:
AdditiveExpression
-
MultiplicativeExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
AdditiveExpression
,
-
,
MultiplicativeExpression
).
13.9
Bitwise Shift Operators
Syntax
ShiftExpression
[Yield, Await]
:
AdditiveExpression
[?Yield, ?Await]
ShiftExpression
[?Yield, ?Await]
<<
AdditiveExpression
[?Yield, ?Await]
ShiftExpression
[?Yield, ?Await]
>>
AdditiveExpression
[?Yield, ?Await]
ShiftExpression
[?Yield, ?Await]
>>>
AdditiveExpression
[?Yield, ?Await]
13.9.1
The Left Shift Operator (
<<
)
Note
Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.
13.9.1.1
Runtime Semantics: Evaluation
ShiftExpression
:
ShiftExpression
<<
AdditiveExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
ShiftExpression
,
<<
,
AdditiveExpression
).
13.9.2
The Signed Right Shift Operator (
>>
)
Note
Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.
13.9.2.1
Runtime Semantics: Evaluation
ShiftExpression
:
ShiftExpression
>>
AdditiveExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
ShiftExpression
,
>>
,
AdditiveExpression
).
13.9.3
The Unsigned Right Shift Operator (
>>>
)
Note
Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.
13.9.3.1
Runtime Semantics: Evaluation
ShiftExpression
:
ShiftExpression
>>>
AdditiveExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
ShiftExpression
,
>>>
,
AdditiveExpression
).
13.10
Relational Operators
Note 1
The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.
Syntax
RelationalExpression
[In, Yield, Await]
:
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
<
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
>
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
<=
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
>=
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
instanceof
ShiftExpression
[?Yield, ?Await]
[+In]
RelationalExpression
[+In, ?Yield, ?Await]
in
ShiftExpression
[?Yield, ?Await]
[+In]
PrivateIdentifier
in
ShiftExpression
[?Yield, ?Await]
Note 2
The
[In]
grammar parameter is needed to avoid confusing the
in
operator in a relational expression with the
in
operator in a
for
statement.
13.10.1
Runtime Semantics: Evaluation
RelationalExpression
:
RelationalExpression
<
ShiftExpression
Let
lRef
be ?
Evaluation
of
RelationalExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
ShiftExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Let
r
be ?
IsLessThan
(
lVal
,
rVal
,
true
).
If
r
is
undefined
, return
false
; otherwise return
r
.
RelationalExpression
:
RelationalExpression
>
ShiftExpression
Let
lRef
be ?
Evaluation
of
RelationalExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
ShiftExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Let
r
be ?
IsLessThan
(
rVal
,
lVal
,
false
).
If
r
is
undefined
, return
false
; otherwise return
r
.
RelationalExpression
:
RelationalExpression
<=
ShiftExpression
Let
lRef
be ?
Evaluation
of
RelationalExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
ShiftExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Let
r
be ?
IsLessThan
(
rVal
,
lVal
,
false
).
If
r
is either
true
or
undefined
, return
false
; otherwise return
true
.
RelationalExpression
:
RelationalExpression
>=
ShiftExpression
Let
lRef
be ?
Evaluation
of
RelationalExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
ShiftExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Let
r
be ?
IsLessThan
(
lVal
,
rVal
,
true
).
If
r
is either
true
or
undefined
, return
false
; otherwise return
true
.
RelationalExpression
:
RelationalExpression
instanceof
ShiftExpression
Let
lRef
be ?
Evaluation
of
RelationalExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
ShiftExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Return ?
InstanceofOperator
(
lVal
,
rVal
).
RelationalExpression
:
RelationalExpression
in
ShiftExpression
Let
lRef
be ?
Evaluation
of
RelationalExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
ShiftExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
If
rVal
is not an Object
, throw a
TypeError
exception.
Return ?
HasProperty
(
rVal
, ?
ToPropertyKey
(
lVal
)).
RelationalExpression
:
PrivateIdentifier
in
ShiftExpression
Let
privateIdentifier
be the
StringValue
of
PrivateIdentifier
.
Let
rRef
be ?
Evaluation
of
ShiftExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
If
rVal
is not an Object
, throw a
TypeError
exception.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Assert
:
privateEnv
is not
null
.
Let
privateName
be
ResolvePrivateIdentifier
(
privateEnv
,
privateIdentifier
).
If
PrivateElementFind
(
rVal
,
privateName
) is not
empty
, return
true
.
Return
false
.
13.10.2
InstanceofOperator (
V
,
target
)
The abstract operation InstanceofOperator takes arguments
V
(an
ECMAScript language value
) and
target
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It implements the generic algorithm for determining if
V
is an instance of
target
either by consulting
target
's
%Symbol.hasInstance%
method or, if absent, determining whether the value of
target
's
"prototype"
property is present in
V
's prototype chain. It performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
instOfHandler
be ?
GetMethod
(
target
,
%Symbol.hasInstance%
).
If
instOfHandler
is not
undefined
, then
Return
ToBoolean
(?
Call
(
instOfHandler
,
target
, «
V
»)).
If
IsCallable
(
target
) is
false
, throw a
TypeError
exception.
Return ?
OrdinaryHasInstance
(
target
,
V
).
Note
Steps
4
and
5
provide compatibility with previous editions of ECMAScript that did not use a
%Symbol.hasInstance%
method to define the
instanceof
operator semantics. If an object does not define or inherit
%Symbol.hasInstance%
it uses the default
instanceof
semantics.
13.11
Equality Operators
Note
The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.
Syntax
EqualityExpression
[In, Yield, Await]
:
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
==
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
!=
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
===
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
!==
RelationalExpression
[?In, ?Yield, ?Await]
13.11.1
Runtime Semantics: Evaluation
EqualityExpression
:
EqualityExpression
==
RelationalExpression
Let
lRef
be ?
Evaluation
of
EqualityExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
RelationalExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Return ?
IsLooselyEqual
(
rVal
,
lVal
).
EqualityExpression
:
EqualityExpression
!=
RelationalExpression
Let
lRef
be ?
Evaluation
of
EqualityExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
RelationalExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Let
r
be ?
IsLooselyEqual
(
rVal
,
lVal
).
If
r
is
true
, return
false
; otherwise return
true
.
EqualityExpression
:
EqualityExpression
===
RelationalExpression
Let
lRef
be ?
Evaluation
of
EqualityExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
RelationalExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Return
IsStrictlyEqual
(
rVal
,
lVal
).
EqualityExpression
:
EqualityExpression
!==
RelationalExpression
Let
lRef
be ?
Evaluation
of
EqualityExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
RelationalExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Let
r
be
IsStrictlyEqual
(
rVal
,
lVal
).
If
r
is
true
, return
false
; otherwise return
true
.
Note 1
The equality operators maintain the following invariants:
A != B
is equivalent to
!(A == B)
.
A == B
is equivalent to
B == A
, except in the order of evaluation of
A
and
B
.
Note 2
The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the
==
operator, but the two String objects would not be equal to each other. For example:
new String("a") == "a"
and
"a" == new String("a")
are both
true
.
new String("a") == new String("a")
is
false
.
Note 3
Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode Standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form.
13.12
Binary Bitwise Operators
Syntax
BitwiseANDExpression
[In, Yield, Await]
:
EqualityExpression
[?In, ?Yield, ?Await]
BitwiseANDExpression
[?In, ?Yield, ?Await]
&
EqualityExpression
[?In, ?Yield, ?Await]
BitwiseXORExpression
[In, Yield, Await]
:
BitwiseANDExpression
[?In, ?Yield, ?Await]
BitwiseXORExpression
[?In, ?Yield, ?Await]
^
BitwiseANDExpression
[?In, ?Yield, ?Await]
BitwiseORExpression
[In, Yield, Await]
:
BitwiseXORExpression
[?In, ?Yield, ?Await]
BitwiseORExpression
[?In, ?Yield, ?Await]
|
BitwiseXORExpression
[?In, ?Yield, ?Await]
13.12.1
Runtime Semantics: Evaluation
BitwiseANDExpression
:
BitwiseANDExpression
&
EqualityExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
BitwiseANDExpression
,
&
,
EqualityExpression
).
BitwiseXORExpression
:
BitwiseXORExpression
^
BitwiseANDExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
BitwiseXORExpression
,
^
,
BitwiseANDExpression
).
BitwiseORExpression
:
BitwiseORExpression
|
BitwiseXORExpression
Return ?
EvaluateStringOrNumericBinaryExpression
(
BitwiseORExpression
,
|
,
BitwiseXORExpression
).
13.13
Binary Logical Operators
Syntax
LogicalANDExpression
[In, Yield, Await]
:
BitwiseORExpression
[?In, ?Yield, ?Await]
LogicalANDExpression
[?In, ?Yield, ?Await]
&&
BitwiseORExpression
[?In, ?Yield, ?Await]
LogicalORExpression
[In, Yield, Await]
:
LogicalANDExpression
[?In, ?Yield, ?Await]
LogicalORExpression
[?In, ?Yield, ?Await]
||
LogicalANDExpression
[?In, ?Yield, ?Await]
CoalesceExpression
[In, Yield, Await]
:
CoalesceExpressionHead
[?In, ?Yield, ?Await]
??
BitwiseORExpression
[?In, ?Yield, ?Await]
CoalesceExpressionHead
[In, Yield, Await]
:
CoalesceExpression
[?In, ?Yield, ?Await]
BitwiseORExpression
[?In, ?Yield, ?Await]
ShortCircuitExpression
[In, Yield, Await]
:
LogicalORExpression
[?In, ?Yield, ?Await]
CoalesceExpression
[?In, ?Yield, ?Await]
Note
The value produced by a
&&
or
||
operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.
13.13.1
Runtime Semantics: Evaluation
LogicalANDExpression
:
LogicalANDExpression
&&
BitwiseORExpression
Let
lRef
be ?
Evaluation
of
LogicalANDExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
If
ToBoolean
(
lVal
) is
false
, return
lVal
.
Let
rRef
be ?
Evaluation
of
BitwiseORExpression
.
Return ?
GetValue
(
rRef
).
LogicalORExpression
:
LogicalORExpression
||
LogicalANDExpression
Let
lRef
be ?
Evaluation
of
LogicalORExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
If
ToBoolean
(
lVal
) is
true
, return
lVal
.
Let
rRef
be ?
Evaluation
of
LogicalANDExpression
.
Return ?
GetValue
(
rRef
).
CoalesceExpression
:
CoalesceExpressionHead
??
BitwiseORExpression
Let
lRef
be ?
Evaluation
of
CoalesceExpressionHead
.
Let
lVal
be ?
GetValue
(
lRef
).
If
lVal
is either
undefined
or
null
, then
Let
rRef
be ?
Evaluation
of
BitwiseORExpression
.
Return ?
GetValue
(
rRef
).
Else,
Return
lVal
.
13.14
Conditional Operator (
? :
)
Syntax
ConditionalExpression
[In, Yield, Await]
:
ShortCircuitExpression
[?In, ?Yield, ?Await]
ShortCircuitExpression
[?In, ?Yield, ?Await]
?
AssignmentExpression
[+In, ?Yield, ?Await]
:
AssignmentExpression
[?In, ?Yield, ?Await]
Note
The grammar for a
ConditionalExpression
in ECMAScript is slightly different from that in C and Java, which each allow the second subexpression to be an
Expression
but restrict the third expression to be a
ConditionalExpression
. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.
13.14.1
Runtime Semantics: Evaluation
ConditionalExpression
:
ShortCircuitExpression
?
AssignmentExpression
:
AssignmentExpression
Let
lRef
be ?
Evaluation
of
ShortCircuitExpression
.
Let
lVal
be
ToBoolean
(?
GetValue
(
lRef
)).
If
lVal
is
true
, then
Let
trueRef
be ?
Evaluation
of the first
AssignmentExpression
.
Return ?
GetValue
(
trueRef
).
Else,
Let
falseRef
be ?
Evaluation
of the second
AssignmentExpression
.
Return ?
GetValue
(
falseRef
).
13.15
Assignment Operators
Syntax
AssignmentExpression
[In, Yield, Await]
:
ConditionalExpression
[?In, ?Yield, ?Await]
[+Yield]
YieldExpression
[?In, ?Await]
ArrowFunction
[?In, ?Yield, ?Await]
AsyncArrowFunction
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
=
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
AssignmentOperator
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
&&=
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
||=
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
??=
AssignmentExpression
[?In, ?Yield, ?Await]
AssignmentOperator
:
one of
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
13.15.1
Static Semantics: Early Errors
AssignmentExpression
:
LeftHandSideExpression
=
AssignmentExpression
If
LeftHandSideExpression
is either an
ObjectLiteral
or an
ArrayLiteral
,
LeftHandSideExpression
must cover
an
AssignmentPattern
.
If
LeftHandSideExpression
is neither an
ObjectLiteral
nor an
ArrayLiteral
, it is a Syntax Error if the
AssignmentTargetType
of
LeftHandSideExpression
is
invalid
.
AssignmentExpression
:
LeftHandSideExpression
AssignmentOperator
AssignmentExpression
It is a Syntax Error if the
AssignmentTargetType
of
LeftHandSideExpression
is
invalid
.
AssignmentExpression
:
LeftHandSideExpression
&&=
AssignmentExpression
LeftHandSideExpression
||=
AssignmentExpression
LeftHandSideExpression
??=
AssignmentExpression
It is a Syntax Error if the
AssignmentTargetType
of
LeftHandSideExpression
is not
simple
.
13.15.2
Runtime Semantics: Evaluation
AssignmentExpression
:
LeftHandSideExpression
=
AssignmentExpression
If
LeftHandSideExpression
is neither an
ObjectLiteral
nor an
ArrayLiteral
, then
Let
lRef
be ?
Evaluation
of
LeftHandSideExpression
.
If the
AssignmentTargetType
of
LeftHandSideExpression
is
web-compat
, throw a
ReferenceError
exception.
If
IsAnonymousFunctionDefinition
(
AssignmentExpression
) is
true
and
IsIdentifierRef
of
LeftHandSideExpression
is
true
, then
Let
lhs
be the
StringValue
of
LeftHandSideExpression
.
Let
rVal
be ?
NamedEvaluation
of
AssignmentExpression
with argument
lhs
.
Else,
Let
rRef
be ?
Evaluation
of
AssignmentExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Perform ?
PutValue
(
lRef
,
rVal
).
Return
rVal
.
Let
assignmentPattern
be the
AssignmentPattern
that is
covered
by
LeftHandSideExpression
.
Let
rRef
be ?
Evaluation
of
AssignmentExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Perform ?
DestructuringAssignmentEvaluation
of
assignmentPattern
with argument
rVal
.
Return
rVal
.
AssignmentExpression
:
LeftHandSideExpression
AssignmentOperator
AssignmentExpression
Let
lRef
be ?
Evaluation
of
LeftHandSideExpression
.
If the
AssignmentTargetType
of
LeftHandSideExpression
is
web-compat
, throw a
ReferenceError
exception.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
AssignmentExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Let
assignmentOpText
be the
source text matched by
AssignmentOperator
.
Let
opText
be the sequence of Unicode code points associated with
assignmentOpText
in the following table:
assignmentOpText
opText
**=
**
*=
*
/=
/
%=
%
+=
+
-=
-
<<=
<<
>>=
>>
>>>=
>>>
&=
&
^=
^
|=
|
Let
r
be ?
ApplyStringOrNumericBinaryOperator
(
lVal
,
opText
,
rVal
).
Perform ?
PutValue
(
lRef
,
r
).
Return
r
.
AssignmentExpression
:
LeftHandSideExpression
&&=
AssignmentExpression
Let
lRef
be ?
Evaluation
of
LeftHandSideExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
If
ToBoolean
(
lVal
) is
false
, return
lVal
.
If
IsAnonymousFunctionDefinition
(
AssignmentExpression
) is
true
and
IsIdentifierRef
of
LeftHandSideExpression
is
true
, then
Let
lhs
be the
StringValue
of
LeftHandSideExpression
.
Let
rVal
be ?
NamedEvaluation
of
AssignmentExpression
with argument
lhs
.
Else,
Let
rRef
be ?
Evaluation
of
AssignmentExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Perform ?
PutValue
(
lRef
,
rVal
).
Return
rVal
.
AssignmentExpression
:
LeftHandSideExpression
||=
AssignmentExpression
Let
lRef
be ?
Evaluation
of
LeftHandSideExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
If
ToBoolean
(
lVal
) is
true
, return
lVal
.
If
IsAnonymousFunctionDefinition
(
AssignmentExpression
) is
true
and
IsIdentifierRef
of
LeftHandSideExpression
is
true
, then
Let
lhs
be the
StringValue
of
LeftHandSideExpression
.
Let
rVal
be ?
NamedEvaluation
of
AssignmentExpression
with argument
lhs
.
Else,
Let
rRef
be ?
Evaluation
of
AssignmentExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Perform ?
PutValue
(
lRef
,
rVal
).
Return
rVal
.
AssignmentExpression
:
LeftHandSideExpression
??=
AssignmentExpression
Let
lRef
be ?
Evaluation
of
LeftHandSideExpression
.
Let
lVal
be ?
GetValue
(
lRef
).
If
lVal
is neither
undefined
nor
null
, return
lVal
.
If
IsAnonymousFunctionDefinition
(
AssignmentExpression
) is
true
and
IsIdentifierRef
of
LeftHandSideExpression
is
true
, then
Let
lhs
be the
StringValue
of
LeftHandSideExpression
.
Let
rVal
be ?
NamedEvaluation
of
AssignmentExpression
with argument
lhs
.
Else,
Let
rRef
be ?
Evaluation
of
AssignmentExpression
.
Let
rVal
be ?
GetValue
(
rRef
).
Perform ?
PutValue
(
lRef
,
rVal
).
Return
rVal
.
Note
When this expression occurs within
strict mode code
, it is a runtime error if
lRef
in step
1.e
,
3
,
2
,
2
,
2
is an unresolvable reference. If it is, a
ReferenceError
exception is thrown. Additionally, it is a runtime error if the
lRef
in step
9
,
6
,
6
,
6
is a reference to a
data property
with the attribute value {
[[Writable]]
:
false
}, to an
accessor property
with the attribute value {
[[Set]]
:
undefined
}, or to a non-existent property of an object for which the
IsExtensible
predicate returns the value
false
. In these cases a
TypeError
exception is thrown.
13.15.3
ApplyStringOrNumericBinaryOperator (
lVal
,
opText
,
rVal
)
The abstract operation ApplyStringOrNumericBinaryOperator takes arguments
lVal
(an
ECMAScript language value
),
opText
(
**
,
*
,
/
,
%
,
+
,
-
,
<<
,
>>
,
>>>
,
&
,
^
, or
|
), and
rVal
(an
ECMAScript language value
) and returns either a
normal completion containing
either a String, a BigInt, or a Number, or a
throw completion
. It performs the following steps when called:
If
opText
is
+
, then
Let
lPrim
be ?
ToPrimitive
(
lVal
).
Let
rPrim
be ?
ToPrimitive
(
rVal
).
If
lPrim
is a String
or
rPrim
is a String
, then
Let
lStr
be ?
ToString
(
lPrim
).
Let
rStr
be ?
ToString
(
rPrim
).
Return the
string-concatenation
of
lStr
and
rStr
.
Set
lVal
to
lPrim
.
Set
rVal
to
rPrim
.
NOTE: At this point, it must be a numeric operation.
Let
lNum
be ?
ToNumeric
(
lVal
).
Let
rNum
be ?
ToNumeric
(
rVal
).
If
SameType
(
lNum
,
rNum
) is
false
, throw a
TypeError
exception.
If
lNum
is a BigInt
, then
If
opText
is
**
, return ?
BigInt::exponentiate
(
lNum
,
rNum
).
If
opText
is
/
, return ?
BigInt::divide
(
lNum
,
rNum
).
If
opText
is
%
, return ?
BigInt::remainder
(
lNum
,
rNum
).
If
opText
is
>>>
, return ?
BigInt::unsignedRightShift
(
lNum
,
rNum
).
Let
operation
be the abstract operation associated with
opText
in the following table:
opText
operation
*
BigInt::multiply
+
BigInt::add
-
BigInt::subtract
<<
BigInt::leftShift
>>
BigInt::signedRightShift
&
BigInt::bitwiseAND
^
BigInt::bitwiseXOR
|
BigInt::bitwiseOR
Else,
Assert
:
lNum
is a Number
.
Let
operation
be the abstract operation associated with
opText
in the following table:
opText
operation
**
Number::exponentiate
*
Number::multiply
/
Number::divide
%
Number::remainder
+
Number::add
-
Number::subtract
<<
Number::leftShift
>>
Number::signedRightShift
>>>
Number::unsignedRightShift
&
Number::bitwiseAND
^
Number::bitwiseXOR
|
Number::bitwiseOR
Return
operation
(
lNum
,
rNum
).
Note 1
No hint is provided in the calls to
ToPrimitive
in steps
1.a
and
1.b
. All standard objects except Dates handle the absence of a hint as if
number
were given; Dates handle the absence of a hint as if
string
were given.
Exotic objects
may handle the absence of a hint in some other manner.
Note 2
Step
1.c
differs from step
3
of the
IsLessThan
algorithm, by using the logical-or operation instead of the logical-and operation.
13.15.4
EvaluateStringOrNumericBinaryExpression (
leftOperand
,
opText
,
rightOperand
)
The abstract operation EvaluateStringOrNumericBinaryExpression takes arguments
leftOperand
(a
Parse Node
),
opText
(a sequence of Unicode code points), and
rightOperand
(a
Parse Node
) and returns either a
normal completion containing
either a String, a BigInt, or a Number, or an
abrupt completion
. It performs the following steps when called:
Let
lRef
be ?
Evaluation
of
leftOperand
.
Let
lVal
be ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
rightOperand
.
Let
rVal
be ?
GetValue
(
rRef
).
Return ?
ApplyStringOrNumericBinaryOperator
(
lVal
,
opText
,
rVal
).
13.15.5
Destructuring Assignment
Supplemental Syntax
In certain circumstances when processing an instance of the production
AssignmentExpression
:
LeftHandSideExpression
=
AssignmentExpression
the interpretation of
LeftHandSideExpression
is refined using the following grammar:
AssignmentPattern
[Yield, Await]
:
ObjectAssignmentPattern
[?Yield, ?Await]
ArrayAssignmentPattern
[?Yield, ?Await]
ObjectAssignmentPattern
[Yield, Await]
:
{
}
{
AssignmentRestProperty
[?Yield, ?Await]
}
{
AssignmentPropertyList
[?Yield, ?Await]
}
{
AssignmentPropertyList
[?Yield, ?Await]
,
AssignmentRestProperty
[?Yield, ?Await]
opt
}
ArrayAssignmentPattern
[Yield, Await]
:
[
Elision
opt
AssignmentRestElement
[?Yield, ?Await]
opt
]
[
AssignmentElementList
[?Yield, ?Await]
]
[
AssignmentElementList
[?Yield, ?Await]
,
Elision
opt
AssignmentRestElement
[?Yield, ?Await]
opt
]
AssignmentRestProperty
[Yield, Await]
:
...
DestructuringAssignmentTarget
[?Yield, ?Await]
AssignmentPropertyList
[Yield, Await]
:
AssignmentProperty
[?Yield, ?Await]
AssignmentPropertyList
[?Yield, ?Await]
,
AssignmentProperty
[?Yield, ?Await]
AssignmentElementList
[Yield, Await]
:
AssignmentElisionElement
[?Yield, ?Await]
AssignmentElementList
[?Yield, ?Await]
,
AssignmentElisionElement
[?Yield, ?Await]
AssignmentElisionElement
[Yield, Await]
:
Elision
opt
AssignmentElement
[?Yield, ?Await]
AssignmentProperty
[Yield, Await]
:
IdentifierReference
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
PropertyName
[?Yield, ?Await]
:
AssignmentElement
[?Yield, ?Await]
AssignmentElement
[Yield, Await]
:
DestructuringAssignmentTarget
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
AssignmentRestElement
[Yield, Await]
:
...
DestructuringAssignmentTarget
[?Yield, ?Await]
DestructuringAssignmentTarget
[Yield, Await]
:
LeftHandSideExpression
[?Yield, ?Await]
13.15.5.1
Static Semantics: Early Errors
AssignmentProperty
:
IdentifierReference
Initializer
opt
It is a Syntax Error if the
AssignmentTargetType
of
IdentifierReference
is not
simple
.
AssignmentRestProperty
:
...
DestructuringAssignmentTarget
It is a Syntax Error if
DestructuringAssignmentTarget
is either an
ArrayLiteral
or an
ObjectLiteral
.
DestructuringAssignmentTarget
:
LeftHandSideExpression
If
LeftHandSideExpression
is either an
ObjectLiteral
or an
ArrayLiteral
,
LeftHandSideExpression
must cover
an
AssignmentPattern
.
If
LeftHandSideExpression
is neither an
ObjectLiteral
nor an
ArrayLiteral
, it is a Syntax Error if the
AssignmentTargetType
of
LeftHandSideExpression
is not
simple
.
13.15.5.2
Runtime Semantics: DestructuringAssignmentEvaluation
The
syntax-directed operation
DestructuringAssignmentEvaluation takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It is defined piecewise over the following productions:
ObjectAssignmentPattern
:
{
}
Perform ?
RequireObjectCoercible
(
value
).
Return
unused
.
ObjectAssignmentPattern
:
{
AssignmentPropertyList
}
{
AssignmentPropertyList
,
}
Perform ?
RequireObjectCoercible
(
value
).
Perform ?
PropertyDestructuringAssignmentEvaluation
of
AssignmentPropertyList
with argument
value
.
Return
unused
.
ObjectAssignmentPattern
:
{
AssignmentRestProperty
}
Perform ?
RequireObjectCoercible
(
value
).
Let
excludedNames
be a new empty
List
.
Return ?
RestDestructuringAssignmentEvaluation
of
AssignmentRestProperty
with arguments
value
and
excludedNames
.
ObjectAssignmentPattern
:
{
AssignmentPropertyList
,
AssignmentRestProperty
}
Perform ?
RequireObjectCoercible
(
value
).
Let
excludedNames
be ?
PropertyDestructuringAssignmentEvaluation
of
AssignmentPropertyList
with argument
value
.
Return ?
RestDestructuringAssignmentEvaluation
of
AssignmentRestProperty
with arguments
value
and
excludedNames
.
ArrayAssignmentPattern
:
[
]
Let
iteratorRecord
be ?
GetIterator
(
value
,
sync
).
Return ?
IteratorClose
(
iteratorRecord
,
NormalCompletion
(
unused
)).
ArrayAssignmentPattern
:
[
Elision
]
Let
iteratorRecord
be ?
GetIterator
(
value
,
sync
).
Let
result
be
Completion
(
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
).
If
iteratorRecord
.
[[Done]]
is
false
, return ?
IteratorClose
(
iteratorRecord
,
result
).
Return
result
.
ArrayAssignmentPattern
:
[
Elision
opt
AssignmentRestElement
]
Let
iteratorRecord
be ?
GetIterator
(
value
,
sync
).
If
Elision
is present, then
Let
status
be
Completion
(
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
).
If
status
is an
abrupt completion
, then
Assert
:
iteratorRecord
.
[[Done]]
is
true
.
Return ?
status
.
Let
result
be
Completion
(
IteratorDestructuringAssignmentEvaluation
of
AssignmentRestElement
with argument
iteratorRecord
).
If
iteratorRecord
.
[[Done]]
is
false
, return ?
IteratorClose
(
iteratorRecord
,
result
).
Return
result
.
ArrayAssignmentPattern
:
[
AssignmentElementList
]
Let
iteratorRecord
be ?
GetIterator
(
value
,
sync
).
Let
result
be
Completion
(
IteratorDestructuringAssignmentEvaluation
of
AssignmentElementList
with argument
iteratorRecord
).
If
iteratorRecord
.
[[Done]]
is
false
, return ?
IteratorClose
(
iteratorRecord
,
result
).
Return
result
.
ArrayAssignmentPattern
:
[
AssignmentElementList
,
Elision
opt
AssignmentRestElement
opt
]
Let
iteratorRecord
be ?
GetIterator
(
value
,
sync
).
Let
status
be
Completion
(
IteratorDestructuringAssignmentEvaluation
of
AssignmentElementList
with argument
iteratorRecord
).
If
status
is an
abrupt completion
, then
If
iteratorRecord
.
[[Done]]
is
false
, return ?
IteratorClose
(
iteratorRecord
,
status
).
Return ?
status
.
If
Elision
is present, then
Set
status
to
Completion
(
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
).
If
status
is an
abrupt completion
, then
Assert
:
iteratorRecord
.
[[Done]]
is
true
.
Return ?
status
.
If
AssignmentRestElement
is present, then
Set
status
to
Completion
(
IteratorDestructuringAssignmentEvaluation
of
AssignmentRestElement
with argument
iteratorRecord
).
If
iteratorRecord
.
[[Done]]
is
false
, return ?
IteratorClose
(
iteratorRecord
,
status
).
Return ?
status
.
13.15.5.3
Runtime Semantics: PropertyDestructuringAssignmentEvaluation
The
syntax-directed operation
PropertyDestructuringAssignmentEvaluation takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a
List
of
property keys
or an
abrupt completion
. It collects a list of all destructured
property keys
. It is defined piecewise over the following productions:
AssignmentPropertyList
:
AssignmentPropertyList
,
AssignmentProperty
Let
propertyNames
be ?
PropertyDestructuringAssignmentEvaluation
of
AssignmentPropertyList
with argument
value
.
Let
nextNames
be ?
PropertyDestructuringAssignmentEvaluation
of
AssignmentProperty
with argument
value
.
Return the
list-concatenation
of
propertyNames
and
nextNames
.
AssignmentProperty
:
IdentifierReference
Initializer
opt
Let
P
be the
StringValue
of
IdentifierReference
.
Let
lRef
be ?
ResolveBinding
(
P
).
Let
v
be ?
GetV
(
value
,
P
).
If
Initializer
is present and
v
is
undefined
, then
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
, then
Set
v
to ?
NamedEvaluation
of
Initializer
with argument
P
.
Else,
Let
defaultValue
be ?
Evaluation
of
Initializer
.
Set
v
to ?
GetValue
(
defaultValue
).
Perform ?
PutValue
(
lRef
,
v
).
Return «
P
».
AssignmentProperty
:
PropertyName
:
AssignmentElement
Let
name
be ?
Evaluation
of
PropertyName
.
Perform ?
KeyedDestructuringAssignmentEvaluation
of
AssignmentElement
with arguments
value
and
name
.
Return «
name
».
13.15.5.4
Runtime Semantics: RestDestructuringAssignmentEvaluation
The
syntax-directed operation
RestDestructuringAssignmentEvaluation takes arguments
value
(an
ECMAScript language value
) and
excludedNames
(a
List
of
property keys
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It is defined piecewise over the following productions:
AssignmentRestProperty
:
...
DestructuringAssignmentTarget
Let
lRef
be ?
Evaluation
of
DestructuringAssignmentTarget
.
Let
restObj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform ?
CopyDataProperties
(
restObj
,
value
,
excludedNames
).
Return ?
PutValue
(
lRef
,
restObj
).
13.15.5.5
Runtime Semantics: IteratorDestructuringAssignmentEvaluation
The
syntax-directed operation
IteratorDestructuringAssignmentEvaluation takes argument
iteratorRecord
(an
Iterator Record
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It is defined piecewise over the following productions:
AssignmentElementList
:
AssignmentElisionElement
Return ?
IteratorDestructuringAssignmentEvaluation
of
AssignmentElisionElement
with argument
iteratorRecord
.
AssignmentElementList
:
AssignmentElementList
,
AssignmentElisionElement
Perform ?
IteratorDestructuringAssignmentEvaluation
of
AssignmentElementList
with argument
iteratorRecord
.
Return ?
IteratorDestructuringAssignmentEvaluation
of
AssignmentElisionElement
with argument
iteratorRecord
.
AssignmentElisionElement
:
AssignmentElement
Return ?
IteratorDestructuringAssignmentEvaluation
of
AssignmentElement
with argument
iteratorRecord
.
AssignmentElisionElement
:
Elision
AssignmentElement
Perform ?
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
.
Return ?
IteratorDestructuringAssignmentEvaluation
of
AssignmentElement
with argument
iteratorRecord
.
Elision
:
,
If
iteratorRecord
.
[[Done]]
is
false
, then
Perform ?
IteratorStep
(
iteratorRecord
).
Return
unused
.
Elision
:
Elision
,
Perform ?
IteratorDestructuringAssignmentEvaluation
of
Elision
with argument
iteratorRecord
.
If
iteratorRecord
.
[[Done]]
is
false
, then
Perform ?
IteratorStep
(
iteratorRecord
).
Return
unused
.
AssignmentElement
:
DestructuringAssignmentTarget
Initializer
opt
If
DestructuringAssignmentTarget
is neither an
ObjectLiteral
nor an
ArrayLiteral
, then
Let
lRef
be ?
Evaluation
of
DestructuringAssignmentTarget
.
Let
value
be
undefined
.
If
iteratorRecord
.
[[Done]]
is
false
, then
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is not
done
, then
Set
value
to
next
.
If
Initializer
is present and
value
is
undefined
, then
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
and
IsIdentifierRef
of
DestructuringAssignmentTarget
is
true
, then
Let
target
be the
StringValue
of
DestructuringAssignmentTarget
.
Let
v
be ?
NamedEvaluation
of
Initializer
with argument
target
.
Else,
Let
defaultValue
be ?
Evaluation
of
Initializer
.
Let
v
be ?
GetValue
(
defaultValue
).
Else,
Let
v
be
value
.
If
DestructuringAssignmentTarget
is either an
ObjectLiteral
or an
ArrayLiteral
, then
Let
nestedAssignmentPattern
be the
AssignmentPattern
that is
covered
by
DestructuringAssignmentTarget
.
Return ?
DestructuringAssignmentEvaluation
of
nestedAssignmentPattern
with argument
v
.
Return ?
PutValue
(
lRef
,
v
).
Note
Left to right evaluation order is maintained by evaluating a
DestructuringAssignmentTarget
that is not a destructuring pattern prior to accessing the
iterator
or evaluating the
Initializer
.
AssignmentRestElement
:
...
DestructuringAssignmentTarget
If
DestructuringAssignmentTarget
is neither an
ObjectLiteral
nor an
ArrayLiteral
, then
Let
lRef
be ?
Evaluation
of
DestructuringAssignmentTarget
.
Let
A
be !
ArrayCreate
(0).
Let
n
be 0.
Repeat, while
iteratorRecord
.
[[Done]]
is
false
,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is not
done
, then
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
n
)),
next
).
Set
n
to
n
+ 1.
If
DestructuringAssignmentTarget
is neither an
ObjectLiteral
nor an
ArrayLiteral
, then
Return ?
PutValue
(
lRef
,
A
).
Let
nestedAssignmentPattern
be the
AssignmentPattern
that is
covered
by
DestructuringAssignmentTarget
.
Return ?
DestructuringAssignmentEvaluation
of
nestedAssignmentPattern
with argument
A
.
13.15.5.6
Runtime Semantics: KeyedDestructuringAssignmentEvaluation
The
syntax-directed operation
KeyedDestructuringAssignmentEvaluation takes arguments
value
(an
ECMAScript language value
) and
propertyName
(a
property key
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It is defined piecewise over the following productions:
AssignmentElement
:
DestructuringAssignmentTarget
Initializer
opt
If
DestructuringAssignmentTarget
is neither an
ObjectLiteral
nor an
ArrayLiteral
, then
Let
lRef
be ?
Evaluation
of
DestructuringAssignmentTarget
.
Let
v
be ?
GetV
(
value
,
propertyName
).
If
Initializer
is present and
v
is
undefined
, then
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
and
IsIdentifierRef
of
DestructuringAssignmentTarget
is
true
, then
Let
target
be the
StringValue
of
DestructuringAssignmentTarget
.
Let
rhsValue
be ?
NamedEvaluation
of
Initializer
with argument
target
.
Else,
Let
defaultValue
be ?
Evaluation
of
Initializer
.
Let
rhsValue
be ?
GetValue
(
defaultValue
).
Else,
Let
rhsValue
be
v
.
If
DestructuringAssignmentTarget
is either an
ObjectLiteral
or an
ArrayLiteral
, then
Let
assignmentPattern
be the
AssignmentPattern
that is
covered
by
DestructuringAssignmentTarget
.
Return ?
DestructuringAssignmentEvaluation
of
assignmentPattern
with argument
rhsValue
.
Return ?
PutValue
(
lRef
,
rhsValue
).
13.16
Comma Operator (
,
)
Syntax
Expression
[In, Yield, Await]
:
AssignmentExpression
[?In, ?Yield, ?Await]
Expression
[?In, ?Yield, ?Await]
,
AssignmentExpression
[?In, ?Yield, ?Await]
13.16.1
Runtime Semantics: Evaluation
Expression
:
Expression
,
AssignmentExpression
Let
lRef
be ?
Evaluation
of
Expression
.
Perform ?
GetValue
(
lRef
).
Let
rRef
be ?
Evaluation
of
AssignmentExpression
.
Return ?
GetValue
(
rRef
).
Note
GetValue
must be called even though its value is not used because it may have observable side-effects.
14
ECMAScript Language: Statements and Declarations
Syntax
Statement
[Yield, Await, Return]
:
BlockStatement
[?Yield, ?Await, ?Return]
VariableStatement
[?Yield, ?Await]
EmptyStatement
ExpressionStatement
[?Yield, ?Await]
IfStatement
[?Yield, ?Await, ?Return]
BreakableStatement
[?Yield, ?Await, ?Return]
ContinueStatement
[?Yield, ?Await]
BreakStatement
[?Yield, ?Await]
[+Return]
ReturnStatement
[?Yield, ?Await]
WithStatement
[?Yield, ?Await, ?Return]
LabelledStatement
[?Yield, ?Await, ?Return]
ThrowStatement
[?Yield, ?Await]
TryStatement
[?Yield, ?Await, ?Return]
DebuggerStatement
Declaration
[Yield, Await]
:
HoistableDeclaration
[?Yield, ?Await, ~Default]
ClassDeclaration
[?Yield, ?Await, ~Default]
LexicalDeclaration
[+In, ?Yield, ?Await]
HoistableDeclaration
[Yield, Await, Default]
:
FunctionDeclaration
[?Yield, ?Await, ?Default]
GeneratorDeclaration
[?Yield, ?Await, ?Default]
AsyncFunctionDeclaration
[?Yield, ?Await, ?Default]
AsyncGeneratorDeclaration
[?Yield, ?Await, ?Default]
BreakableStatement
[Yield, Await, Return]
:
IterationStatement
[?Yield, ?Await, ?Return]
SwitchStatement
[?Yield, ?Await, ?Return]
14.1
Statement Semantics
14.1.1
Runtime Semantics: Evaluation
HoistableDeclaration
:
GeneratorDeclaration
AsyncFunctionDeclaration
AsyncGeneratorDeclaration
Return
empty
.
HoistableDeclaration
:
FunctionDeclaration
Return ?
Evaluation
of
FunctionDeclaration
.
BreakableStatement
:
IterationStatement
SwitchStatement
Let
newLabelSet
be a new empty
List
.
Return ?
LabelledEvaluation
of this
BreakableStatement
with argument
newLabelSet
.
14.2
Block
Syntax
BlockStatement
[Yield, Await, Return]
:
Block
[?Yield, ?Await, ?Return]
Block
[Yield, Await, Return]
:
{
StatementList
[?Yield, ?Await, ?Return]
opt
}
StatementList
[Yield, Await, Return]
:
StatementListItem
[?Yield, ?Await, ?Return]
StatementList
[?Yield, ?Await, ?Return]
StatementListItem
[?Yield, ?Await, ?Return]
StatementListItem
[Yield, Await, Return]
:
Statement
[?Yield, ?Await, ?Return]
Declaration
[?Yield, ?Await]
14.2.1
Static Semantics: Early Errors
Block
:
{
StatementList
}
It is a Syntax Error if the
LexicallyDeclaredNames
of
StatementList
contains any duplicate entries
, unless the
host
is a web browser or otherwise supports
Block-Level Function Declarations Web Legacy Compatibility Semantics
, and both of the following conditions are true:
IsStrict
(this production) is
false
.
The duplicate entries are only bound by FunctionDeclarations.
It is a Syntax Error if any element of the
LexicallyDeclaredNames
of
StatementList
also occurs in the
VarDeclaredNames
of
StatementList
.
14.2.2
Runtime Semantics: Evaluation
Block
:
{
}
Return
empty
.
Block
:
{
StatementList
}
Let
oldEnv
be the
running execution context
's LexicalEnvironment.
Let
blockEnv
be
NewDeclarativeEnvironment
(
oldEnv
).
Perform
BlockDeclarationInstantiation
(
StatementList
,
blockEnv
).
Set the
running execution context
's LexicalEnvironment to
blockEnv
.
Let
blockValue
be
Completion
(
Evaluation
of
StatementList
).
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Return ?
blockValue
.
Note 1
No matter how control leaves the
Block
the LexicalEnvironment is always restored to its former state.
StatementList
:
StatementList
StatementListItem
Let
sl
be ?
Evaluation
of
StatementList
.
Let
s
be
Completion
(
Evaluation
of
StatementListItem
).
Return ?
UpdateEmpty
(
s
,
sl
).
Note 2
The value of a
StatementList
is the value of the last value-producing item in the
StatementList
. For example, the following calls to the
eval
function all return the value 1:
eval
(
"1;;;;;"
)
eval
(
"1;{}"
)
eval
(
"1;var a;"
)
14.2.3
BlockDeclarationInstantiation (
code
,
env
)
The abstract operation BlockDeclarationInstantiation takes arguments
code
(a
Parse Node
) and
env
(a
Declarative Environment Record
) and returns
unused
.
code
is the
Parse Node
corresponding to the body of the block.
env
is the
Environment Record
in which bindings are to be created.
Note
When a
Block
or
CaseBlock
is evaluated a new
Declarative Environment Record
is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the
Environment Record
.
It performs the following steps when called:
Let
declarations
be the
LexicallyScopedDeclarations
of
code
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
For each element
d
of
declarations
, do
For each element
dn
of the
BoundNames
of
d
, do
If
IsConstantDeclaration
of
d
is
true
, then
Perform !
env
.
CreateImmutableBinding
(
dn
,
true
).
Else,
Normative Optional
If the
host
is a web browser or otherwise supports
Block-Level Function Declarations Web Legacy Compatibility Semantics
, then
If !
env
.
HasBinding
(
dn
) is
false
, then
Perform !
env
.
CreateMutableBinding
(
dn
,
false
).
Else,
Perform !
env
.
CreateMutableBinding
(
dn
,
false
).
If
d
is either a
FunctionDeclaration
, a
GeneratorDeclaration
, an
AsyncFunctionDeclaration
, or an
AsyncGeneratorDeclaration
, then
Let
fn
be the sole element of the
BoundNames
of
d
.
Let
fo
be
InstantiateFunctionObject
of
d
with arguments
env
and
privateEnv
.
Normative Optional
If the
host
is a web browser or otherwise supports
Block-Level Function Declarations Web Legacy Compatibility Semantics
, then
If the binding for
fn
in
env
is an uninitialized binding, then
Perform !
env
.
InitializeBinding
(
fn
,
fo
).
Else,
Assert
:
d
is a
FunctionDeclaration
.
Perform !
env
.
SetMutableBinding
(
fn
,
fo
,
false
).
Else,
Perform !
env
.
InitializeBinding
(
fn
,
fo
).
Return
unused
.
14.3
Declarations and the Variable Statement
14.3.1
Let and Const Declarations
Note
let
and
const
declarations define variables that are scoped to the
running execution context
's LexicalEnvironment. The variables are created when their containing
Environment Record
is instantiated but may not be accessed in any way until the variable's
LexicalBinding
is evaluated. A variable defined by a
LexicalBinding
with an
Initializer
is assigned the value of its
Initializer
's
AssignmentExpression
when the
LexicalBinding
is evaluated, not when the variable is created. If a
LexicalBinding
in a
let
declaration does not have an
Initializer
the variable is assigned the value
undefined
when the
LexicalBinding
is evaluated.
Syntax
LexicalDeclaration
[In, Yield, Await]
:
LetOrConst
BindingList
[?In, ?Yield, ?Await]
;
LetOrConst
:
let
const
BindingList
[In, Yield, Await]
:
LexicalBinding
[?In, ?Yield, ?Await]
BindingList
[?In, ?Yield, ?Await]
,
LexicalBinding
[?In, ?Yield, ?Await]
LexicalBinding
[In, Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
opt
BindingPattern
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
14.3.1.1
Static Semantics: Early Errors
LexicalDeclaration
:
LetOrConst
BindingList
;
It is a Syntax Error if the
BoundNames
of
BindingList
contains
"let"
.
It is a Syntax Error if the
BoundNames
of
BindingList
contains any duplicate entries.
LexicalBinding
:
BindingIdentifier
Initializer
opt
It is a Syntax Error if
Initializer
is not present and
IsConstantDeclaration
of the
LexicalDeclaration
containing this
LexicalBinding
is
true
.
14.3.1.2
Runtime Semantics: Evaluation
LexicalDeclaration
:
LetOrConst
BindingList
;
Perform ?
Evaluation
of
BindingList
.
Return
empty
.
BindingList
:
BindingList
,
LexicalBinding
Perform ?
Evaluation
of
BindingList
.
Return ?
Evaluation
of
LexicalBinding
.
LexicalBinding
:
BindingIdentifier
Let
lhs
be !
ResolveBinding
(
StringValue
of
BindingIdentifier
).
Perform !
InitializeReferencedBinding
(
lhs
,
undefined
).
Return
empty
.
Note
A
static semantics
rule ensures that this form of
LexicalBinding
never occurs in a
const
declaration.
LexicalBinding
:
BindingIdentifier
Initializer
Let
bindingId
be the
StringValue
of
BindingIdentifier
.
Let
lhs
be !
ResolveBinding
(
bindingId
).
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
, then
Let
value
be ?
NamedEvaluation
of
Initializer
with argument
bindingId
.
Else,
Let
rhs
be ?
Evaluation
of
Initializer
.
Let
value
be ?
GetValue
(
rhs
).
Perform !
InitializeReferencedBinding
(
lhs
,
value
).
Return
empty
.
LexicalBinding
:
BindingPattern
Initializer
Let
rhs
be ?
Evaluation
of
Initializer
.
Let
value
be ?
GetValue
(
rhs
).
Let
env
be the
running execution context
's LexicalEnvironment.
Return ?
BindingInitialization
of
BindingPattern
with arguments
value
and
env
.
14.3.2
Variable Statement
Note
A
var
statement declares variables that are scoped to the
running execution context
's VariableEnvironment. Var variables are created when their containing
Environment Record
is instantiated and are initialized to
undefined
when created. Within the scope of any VariableEnvironment a common
BindingIdentifier
may appear in more than one
VariableDeclaration
but those declarations collectively define only one variable. A variable defined by a
VariableDeclaration
with an
Initializer
is assigned the value of its
Initializer
's
AssignmentExpression
when the
VariableDeclaration
is executed, not when the variable is created.
Syntax
VariableStatement
[Yield, Await]
:
var
VariableDeclarationList
[+In, ?Yield, ?Await]
;
VariableDeclarationList
[In, Yield, Await]
:
VariableDeclaration
[?In, ?Yield, ?Await]
VariableDeclarationList
[?In, ?Yield, ?Await]
,
VariableDeclaration
[?In, ?Yield, ?Await]
VariableDeclaration
[In, Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
opt
BindingPattern
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
14.3.2.1
Runtime Semantics: Evaluation
VariableStatement
:
var
VariableDeclarationList
;
Perform ?
Evaluation
of
VariableDeclarationList
.
Return
empty
.
VariableDeclarationList
:
VariableDeclarationList
,
VariableDeclaration
Perform ?
Evaluation
of
VariableDeclarationList
.
Return ?
Evaluation
of
VariableDeclaration
.
VariableDeclaration
:
BindingIdentifier
Return
empty
.
VariableDeclaration
:
BindingIdentifier
Initializer
Let
bindingId
be the
StringValue
of
BindingIdentifier
.
Let
lhs
be ?
ResolveBinding
(
bindingId
).
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
, then
Let
value
be ?
NamedEvaluation
of
Initializer
with argument
bindingId
.
Else,
Let
rhs
be ?
Evaluation
of
Initializer
.
Let
value
be ?
GetValue
(
rhs
).
Perform ?
PutValue
(
lhs
,
value
).
Return
empty
.
Note
If a
VariableDeclaration
is nested within a with statement and the
BindingIdentifier
in the
VariableDeclaration
is the same as a
property name
of the binding object of the with statement's
Object Environment Record
, then step
5
will assign
value
to the property instead of assigning to the VariableEnvironment binding of the
Identifier
.
VariableDeclaration
:
BindingPattern
Initializer
Let
rhs
be ?
Evaluation
of
Initializer
.
Let
rVal
be ?
GetValue
(
rhs
).
Return ?
BindingInitialization
of
BindingPattern
with arguments
rVal
and
undefined
.
14.3.3
Destructuring Binding Patterns
Syntax
BindingPattern
[Yield, Await]
:
ObjectBindingPattern
[?Yield, ?Await]
ArrayBindingPattern
[?Yield, ?Await]
ObjectBindingPattern
[Yield, Await]
:
{
}
{
BindingRestProperty
[?Yield, ?Await]
}
{
BindingPropertyList
[?Yield, ?Await]
}
{
BindingPropertyList
[?Yield, ?Await]
,
BindingRestProperty
[?Yield, ?Await]
opt
}
ArrayBindingPattern
[Yield, Await]
:
[
Elision
opt
BindingRestElement
[?Yield, ?Await]
opt
]
[
BindingElementList
[?Yield, ?Await]
]
[
BindingElementList
[?Yield, ?Await]
,
Elision
opt
BindingRestElement
[?Yield, ?Await]
opt
]
BindingRestProperty
[Yield, Await]
:
...
BindingIdentifier
[?Yield, ?Await]
BindingPropertyList
[Yield, Await]
:
BindingProperty
[?Yield, ?Await]
BindingPropertyList
[?Yield, ?Await]
,
BindingProperty
[?Yield, ?Await]
BindingElementList
[Yield, Await]
:
BindingElisionElement
[?Yield, ?Await]
BindingElementList
[?Yield, ?Await]
,
BindingElisionElement
[?Yield, ?Await]
BindingElisionElement
[Yield, Await]
:
Elision
opt
BindingElement
[?Yield, ?Await]
BindingProperty
[Yield, Await]
:
SingleNameBinding
[?Yield, ?Await]
PropertyName
[?Yield, ?Await]
:
BindingElement
[?Yield, ?Await]
BindingElement
[Yield, Await]
:
SingleNameBinding
[?Yield, ?Await]
BindingPattern
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
SingleNameBinding
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
BindingRestElement
[Yield, Await]
:
...
BindingIdentifier
[?Yield, ?Await]
...
BindingPattern
[?Yield, ?Await]
14.3.3.1
Runtime Semantics: PropertyBindingInitialization
The
syntax-directed operation
PropertyBindingInitialization takes arguments
value
(an
ECMAScript language value
) and
environment
(an
Environment Record
or
undefined
) and returns either a
normal completion containing
a
List
of
property keys
or an
abrupt completion
. It collects a list of all bound
property names
. It is defined piecewise over the following productions:
BindingPropertyList
:
BindingPropertyList
,
BindingProperty
Let
boundNames
be ?
PropertyBindingInitialization
of
BindingPropertyList
with arguments
value
and
environment
.
Let
nextNames
be ?
PropertyBindingInitialization
of
BindingProperty
with arguments
value
and
environment
.
Return the
list-concatenation
of
boundNames
and
nextNames
.
BindingProperty
:
SingleNameBinding
Let
name
be the sole element of the
BoundNames
of
SingleNameBinding
.
Perform ?
KeyedBindingInitialization
of
SingleNameBinding
with arguments
value
,
environment
, and
name
.
Return «
name
».
BindingProperty
:
PropertyName
:
BindingElement
Let
P
be ?
Evaluation
of
PropertyName
.
Perform ?
KeyedBindingInitialization
of
BindingElement
with arguments
value
,
environment
, and
P
.
Return «
P
».
14.3.3.2
Runtime Semantics: RestBindingInitialization
The
syntax-directed operation
RestBindingInitialization takes arguments
value
(an
ECMAScript language value
),
environment
(an
Environment Record
or
undefined
), and
excludedNames
(a
List
of
property keys
) and returns either a
normal completion containing
unused
or an
abrupt completion
. It is defined piecewise over the following productions:
BindingRestProperty
:
...
BindingIdentifier
Let
lhs
be ?
ResolveBinding
(
StringValue
of
BindingIdentifier
,
environment
).
Let
restObj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform ?
CopyDataProperties
(
restObj
,
value
,
excludedNames
).
If
environment
is
undefined
, return ?
PutValue
(
lhs
,
restObj
).
Return ?
InitializeReferencedBinding
(
lhs
,
restObj
).
14.3.3.3
Runtime Semantics: KeyedBindingInitialization
The
syntax-directed operation
KeyedBindingInitialization takes arguments
value
(an
ECMAScript language value
),
environment
(an
Environment Record
or
undefined
), and
propertyName
(a
property key
) and returns either a
normal completion containing
unused
or an
abrupt completion
.
Note
When
undefined
is passed for
environment
it indicates that a
PutValue
operation should be used to assign the initialization value. This is the case for formal parameter lists of
non-strict functions
. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.
It is defined piecewise over the following productions:
BindingElement
:
BindingPattern
Initializer
opt
Let
v
be ?
GetV
(
value
,
propertyName
).
If
Initializer
is present and
v
is
undefined
, then
Let
defaultValue
be ?
Evaluation
of
Initializer
.
Set
v
to ?
GetValue
(
defaultValue
).
Return ?
BindingInitialization
of
BindingPattern
with arguments
v
and
environment
.
SingleNameBinding
:
BindingIdentifier
Initializer
opt
Let
bindingId
be the
StringValue
of
BindingIdentifier
.
Let
lhs
be ?
ResolveBinding
(
bindingId
,
environment
).
Let
v
be ?
GetV
(
value
,
propertyName
).
If
Initializer
is present and
v
is
undefined
, then
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
, then
Set
v
to ?
NamedEvaluation
of
Initializer
with argument
bindingId
.
Else,
Let
defaultValue
be ?
Evaluation
of
Initializer
.
Set
v
to ?
GetValue
(
defaultValue
).
If
environment
is
undefined
, return ?
PutValue
(
lhs
,
v
).
Return ?
InitializeReferencedBinding
(
lhs
,
v
).
14.4
Empty Statement
Syntax
EmptyStatement
:
;
14.4.1
Runtime Semantics: Evaluation
EmptyStatement
:
;
Return
empty
.
14.5
Expression Statement
Syntax
ExpressionStatement
[Yield, Await]
:
[lookahead ∉ {
{
,
function
,
async
[no
LineTerminator
here]
function
,
class
,
let
[
}]
Expression
[+In, ?Yield, ?Await]
;
Note
An
ExpressionStatement
cannot start with a U+007B (LEFT CURLY BRACKET) because that might make it ambiguous with a
Block
. An
ExpressionStatement
cannot start with the
function
or
class
keywords
because that would make it ambiguous with a
FunctionDeclaration
, a
GeneratorDeclaration
, or a
ClassDeclaration
. An
ExpressionStatement
cannot start with
async function
because that would make it ambiguous with an
AsyncFunctionDeclaration
or a
AsyncGeneratorDeclaration
. An
ExpressionStatement
cannot start with the two token sequence
let [
because that would make it ambiguous with a
let
LexicalDeclaration
whose first
LexicalBinding
was an
ArrayBindingPattern
.
14.5.1
Runtime Semantics: Evaluation
ExpressionStatement
:
Expression
;
Let
exprRef
be ?
Evaluation
of
Expression
.
Return ?
GetValue
(
exprRef
).
14.6
The
if
Statement
Syntax
IfStatement
[Yield, Await, Return]
:
if
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
else
Statement
[?Yield, ?Await, ?Return]
if
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[lookahead ≠
else
]
Note
The lookahead-restriction [lookahead ≠
else
] resolves the classic "dangling else" problem in the usual way. That is, when the choice of associated
if
is otherwise ambiguous, the
else
is associated with the nearest (innermost) of the candidate
if
s
14.6.1
Static Semantics: Early Errors
IfStatement
:
if
(
Expression
)
Statement
else
Statement
It is a Syntax Error if
IsLabelledFunction
(the first
Statement
) is
true
.
It is a Syntax Error if
IsLabelledFunction
(the second
Statement
) is
true
.
IfStatement
:
if
(
Expression
)
Statement
It is a Syntax Error if
IsLabelledFunction
(
Statement
) is
true
.
Note
It is only necessary to apply this rule if the extension specified in
B.3.1
is implemented.
14.6.2
Runtime Semantics: Evaluation
IfStatement
:
if
(
Expression
)
Statement
else
Statement
Let
exprRef
be ?
Evaluation
of
Expression
.
Let
exprValue
be
ToBoolean
(?
GetValue
(
exprRef
)).
If
exprValue
is
true
, then
Let
stmtCompletion
be
Completion
(
Evaluation
of the first
Statement
).
Else,
Let
stmtCompletion
be
Completion
(
Evaluation
of the second
Statement
).
Return ?
UpdateEmpty
(
stmtCompletion
,
undefined
).
IfStatement
:
if
(
Expression
)
Statement
Let
exprRef
be ?
Evaluation
of
Expression
.
Let
exprValue
be
ToBoolean
(?
GetValue
(
exprRef
)).
If
exprValue
is
false
, then
Return
undefined
.
Else,
Let
stmtCompletion
be
Completion
(
Evaluation
of
Statement
).
Return ?
UpdateEmpty
(
stmtCompletion
,
undefined
).
14.7
Iteration Statements
Syntax
IterationStatement
[Yield, Await, Return]
:
DoWhileStatement
[?Yield, ?Await, ?Return]
WhileStatement
[?Yield, ?Await, ?Return]
ForStatement
[?Yield, ?Await, ?Return]
ForInOfStatement
[?Yield, ?Await, ?Return]
14.7.1
Semantics
14.7.1.1
LoopContinues (
completion
,
labelSet
)
The abstract operation LoopContinues takes arguments
completion
(a
Completion Record
) and
labelSet
(a
List
of Strings) and returns a Boolean. It performs the following steps when called:
If
completion
is a
normal completion
, return
true
.
If
completion
is not a
continue completion
, return
false
.
If
completion
.
[[Target]]
is
empty
, return
true
.
If
labelSet
contains
completion
.
[[Target]]
, return
true
.
Return
false
.
Note
Within the
Statement
part of an
IterationStatement
a
ContinueStatement
may be used to begin a new iteration.
14.7.1.2
Runtime Semantics: LoopEvaluation
The
syntax-directed operation
LoopEvaluation takes argument
labelSet
(a
List
of Strings) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It is defined piecewise over the following productions:
IterationStatement
:
DoWhileStatement
Return ?
DoWhileLoopEvaluation
of
DoWhileStatement
with argument
labelSet
.
IterationStatement
:
WhileStatement
Return ?
WhileLoopEvaluation
of
WhileStatement
with argument
labelSet
.
IterationStatement
:
ForStatement
Return ?
ForLoopEvaluation
of
ForStatement
with argument
labelSet
.
IterationStatement
:
ForInOfStatement
Return ?
ForInOfLoopEvaluation
of
ForInOfStatement
with argument
labelSet
.
14.7.2
The
do
-
while
Statement
Syntax
DoWhileStatement
[Yield, Await, Return]
:
do
Statement
[?Yield, ?Await, ?Return]
while
(
Expression
[+In, ?Yield, ?Await]
)
;
14.7.2.1
Static Semantics: Early Errors
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
It is a Syntax Error if
IsLabelledFunction
(
Statement
) is
true
.
Note
It is only necessary to apply this rule if the extension specified in
B.3.1
is implemented.
14.7.2.2
Runtime Semantics: DoWhileLoopEvaluation
The
syntax-directed operation
DoWhileLoopEvaluation takes argument
labelSet
(a
List
of Strings) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It is defined piecewise over the following productions:
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
Let
V
be
undefined
.
Repeat,
Let
stmtResult
be
Completion
(
Evaluation
of
Statement
).
If
LoopContinues
(
stmtResult
,
labelSet
) is
false
, return ?
UpdateEmpty
(
stmtResult
,
V
).
If
stmtResult
.
[[Value]]
is not
empty
, set
V
to
stmtResult
.
[[Value]]
.
Let
exprRef
be ?
Evaluation
of
Expression
.
Let
exprValue
be ?
GetValue
(
exprRef
).
If
ToBoolean
(
exprValue
) is
false
, return
V
.
14.7.3
The
while
Statement
Syntax
WhileStatement
[Yield, Await, Return]
:
while
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
14.7.3.1
Static Semantics: Early Errors
WhileStatement
:
while
(
Expression
)
Statement
It is a Syntax Error if
IsLabelledFunction
(
Statement
) is
true
.
Note
It is only necessary to apply this rule if the extension specified in
B.3.1
is implemented.
14.7.3.2
Runtime Semantics: WhileLoopEvaluation
The
syntax-directed operation
WhileLoopEvaluation takes argument
labelSet
(a
List
of Strings) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It is defined piecewise over the following productions:
WhileStatement
:
while
(
Expression
)
Statement
Let
V
be
undefined
.
Repeat,
Let
exprRef
be ?
Evaluation
of
Expression
.
Let
exprValue
be ?
GetValue
(
exprRef
).
If
ToBoolean
(
exprValue
) is
false
, return
V
.
Let
stmtResult
be
Completion
(
Evaluation
of
Statement
).
If
LoopContinues
(
stmtResult
,
labelSet
) is
false
, return ?
UpdateEmpty
(
stmtResult
,
V
).
If
stmtResult
.
[[Value]]
is not
empty
, set
V
to
stmtResult
.
[[Value]]
.
14.7.4
The
for
Statement
Syntax
ForStatement
[Yield, Await, Return]
:
for
(
[lookahead ≠
let
[
]
Expression
[~In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
)
Statement
[?Yield, ?Await, ?Return]
for
(
var
VariableDeclarationList
[~In, ?Yield, ?Await]
;
Expression
[+In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
)
Statement
[?Yield, ?Await, ?Return]
for
(
LexicalDeclaration
[~In, ?Yield, ?Await]
Expression
[+In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
)
Statement
[?Yield, ?Await, ?Return]
14.7.4.1
Static Semantics: Early Errors
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
It is a Syntax Error if
IsLabelledFunction
(
Statement
) is
true
.
Note
It is only necessary to apply this rule if the extension specified in
B.3.1
is implemented.
ForStatement
:
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
It is a Syntax Error if any element of the
BoundNames
of
LexicalDeclaration
also occurs in the
VarDeclaredNames
of
Statement
.
14.7.4.2
Runtime Semantics: ForLoopEvaluation
The
syntax-directed operation
ForLoopEvaluation takes argument
labelSet
(a
List
of Strings) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It is defined piecewise over the following productions:
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
If the first
Expression
is present, then
Let
exprRef
be ?
Evaluation
of the first
Expression
.
Perform ?
GetValue
(
exprRef
).
If the second
Expression
is present, let
test
be the second
Expression
; otherwise let
test
be
empty
.
If the third
Expression
is present, let
increment
be the third
Expression
; otherwise let
increment
be
empty
.
Return ?
ForBodyEvaluation
(
test
,
increment
,
Statement
, « »,
labelSet
).
ForStatement
:
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
Perform ?
Evaluation
of
VariableDeclarationList
.
If the first
Expression
is present, let
test
be the first
Expression
; otherwise let
test
be
empty
.
If the second
Expression
is present, let
increment
be the second
Expression
; otherwise let
increment
be
empty
.
Return ?
ForBodyEvaluation
(
test
,
increment
,
Statement
, « »,
labelSet
).
ForStatement
:
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
Let
oldEnv
be the
running execution context
's LexicalEnvironment.
Let
loopEnv
be
NewDeclarativeEnvironment
(
oldEnv
).
Let
isConst
be
IsConstantDeclaration
of
LexicalDeclaration
.
Let
boundNames
be the
BoundNames
of
LexicalDeclaration
.
For each element
dn
of
boundNames
, do
If
isConst
is
true
, then
Perform !
loopEnv
.
CreateImmutableBinding
(
dn
,
true
).
Else,
Perform !
loopEnv
.
CreateMutableBinding
(
dn
,
false
).
Set the
running execution context
's LexicalEnvironment to
loopEnv
.
Let
forDcl
be
Completion
(
Evaluation
of
LexicalDeclaration
).
If
forDcl
is an
abrupt completion
, then
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Return ?
forDcl
.
If
isConst
is
false
, let
perIterationLets
be
boundNames
; otherwise let
perIterationLets
be a new empty
List
.
If the first
Expression
is present, let
test
be the first
Expression
; otherwise let
test
be
empty
.
If the second
Expression
is present, let
increment
be the second
Expression
; otherwise let
increment
be
empty
.
Let
bodyResult
be
Completion
(
ForBodyEvaluation
(
test
,
increment
,
Statement
,
perIterationLets
,
labelSet
)).
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Return ?
bodyResult
.
14.7.4.3
ForBodyEvaluation (
test
,
increment
,
stmt
,
perIterationBindings
,
labelSet
)
The abstract operation ForBodyEvaluation takes arguments
test
(an
Expression
Parse Node
or
empty
),
increment
(an
Expression
Parse Node
or
empty
),
stmt
(a
Statement
Parse Node
),
perIterationBindings
(a
List
of Strings), and
labelSet
(a
List
of Strings) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
Let
V
be
undefined
.
Perform ?
CreatePerIterationEnvironment
(
perIterationBindings
).
Repeat,
If
test
is not
empty
, then
Let
testRef
be ?
Evaluation
of
test
.
Let
testValue
be ?
GetValue
(
testRef
).
If
ToBoolean
(
testValue
) is
false
, return
V
.
Let
result
be
Completion
(
Evaluation
of
stmt
).
If
LoopContinues
(
result
,
labelSet
) is
false
, return ?
UpdateEmpty
(
result
,
V
).
If
result
.
[[Value]]
is not
empty
, set
V
to
result
.
[[Value]]
.
Perform ?
CreatePerIterationEnvironment
(
perIterationBindings
).
If
increment
is not
empty
, then
Let
incRef
be ?
Evaluation
of
increment
.
Perform ?
GetValue
(
incRef
).
14.7.4.4
CreatePerIterationEnvironment (
perIterationBindings
)
The abstract operation CreatePerIterationEnvironment takes argument
perIterationBindings
(a
List
of Strings) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
If
perIterationBindings
has any elements, then
Let
lastIterationEnv
be the
running execution context
's LexicalEnvironment.
Let
outer
be
lastIterationEnv
.
[[OuterEnv]]
.
Assert
:
outer
is not
null
.
Let
thisIterationEnv
be
NewDeclarativeEnvironment
(
outer
).
For each element
bn
of
perIterationBindings
, do
Perform !
thisIterationEnv
.
CreateMutableBinding
(
bn
,
false
).
Let
lastValue
be ?
lastIterationEnv
.
GetBindingValue
(
bn
,
true
).
Perform !
thisIterationEnv
.
InitializeBinding
(
bn
,
lastValue
).
Set the
running execution context
's LexicalEnvironment to
thisIterationEnv
.
Return
unused
.
14.7.5
The
for
-
in
,
for
-
of
, and
for
-
await
-
of
Statements
Syntax
ForInOfStatement
[Yield, Await, Return]
:
for
(
[lookahead ≠
let
[
]
LeftHandSideExpression
[?Yield, ?Await]
in
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
var
ForBinding
[?Yield, ?Await]
in
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
ForDeclaration
[?Yield, ?Await]
in
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
[lookahead ∉ {
let
,
async
of
}]
LeftHandSideExpression
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
var
ForBinding
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
ForDeclaration
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[+Await]
for
await
(
[lookahead ≠
let
]
LeftHandSideExpression
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[+Await]
for
await
(
var
ForBinding
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[+Await]
for
await
(
ForDeclaration
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
ForDeclaration
[Yield, Await]
:
LetOrConst
ForBinding
[?Yield, ?Await]
ForBinding
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
BindingPattern
[?Yield, ?Await]
Note
This section is extended by Annex
B.3.5
.
14.7.5.1
Static Semantics: Early Errors
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
var
ForBinding
in
Expression
)
Statement
for
(
ForDeclaration
in
Expression
)
Statement
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
await
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
It is a Syntax Error if
IsLabelledFunction
(
Statement
) is
true
.
Note
It is only necessary to apply this rule if the extension specified in
B.3.1
is implemented.
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
If
LeftHandSideExpression
is either an
ObjectLiteral
or an
ArrayLiteral
,
LeftHandSideExpression
must cover
an
AssignmentPattern
.
If
LeftHandSideExpression
is neither an
ObjectLiteral
nor an
ArrayLiteral
, it is a Syntax Error if the
AssignmentTargetType
of
LeftHandSideExpression
is
invalid
.
ForInOfStatement
:
for
(
ForDeclaration
in
Expression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
It is a Syntax Error if the
BoundNames
of
ForDeclaration
contains
"let"
.
It is a Syntax Error if any element of the
BoundNames
of
ForDeclaration
also occurs in the
VarDeclaredNames
of
Statement
.
It is a Syntax Error if the
BoundNames
of
ForDeclaration
contains any duplicate entries.
14.7.5.2
Static Semantics: IsDestructuring
The
syntax-directed operation
IsDestructuring takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
MemberExpression
:
PrimaryExpression
If
PrimaryExpression
is either an
ObjectLiteral
or an
ArrayLiteral
, return
true
.
Return
false
.
MemberExpression
:
MemberExpression
[
Expression
]
MemberExpression
.
IdentifierName
MemberExpression
TemplateLiteral
SuperProperty
MetaProperty
new
MemberExpression
Arguments
MemberExpression
.
PrivateIdentifier
NewExpression
:
new
NewExpression
LeftHandSideExpression
:
CallExpression
OptionalExpression
Return
false
.
ForDeclaration
:
LetOrConst
ForBinding
Return
IsDestructuring
of
ForBinding
.
ForBinding
:
BindingIdentifier
Return
false
.
ForBinding
:
BindingPattern
Return
true
.
Note
This section is extended by Annex
B.3.5
.
14.7.5.3
Runtime Semantics: ForDeclarationBindingInitialization
The
syntax-directed operation
ForDeclarationBindingInitialization takes arguments
value
(an
ECMAScript language value
) and
environment
(an
Environment Record
or
undefined
) and returns either a
normal completion containing
unused
or an
abrupt completion
.
Note
undefined
is passed for
environment
to indicate that a
PutValue
operation should be used to assign the initialization value. This is the case for
var
statements and the formal parameter lists of some
non-strict functions
(see
10.2.11
). In those cases a lexical binding is hoisted and preinitialized prior to evaluation of its initializer.
It is defined piecewise over the following productions:
ForDeclaration
:
LetOrConst
ForBinding
Return ?
BindingInitialization
of
ForBinding
with arguments
value
and
environment
.
14.7.5.4
Runtime Semantics: ForDeclarationBindingInstantiation
The
syntax-directed operation
ForDeclarationBindingInstantiation takes argument
environment
(a
Declarative Environment Record
) and returns
unused
. It is defined piecewise over the following productions:
ForDeclaration
:
LetOrConst
ForBinding
For each element
name
of the
BoundNames
of
ForBinding
, do
If
IsConstantDeclaration
of
LetOrConst
is
true
, then
Perform !
environment
.
CreateImmutableBinding
(
name
,
true
).
Else,
Perform !
environment
.
CreateMutableBinding
(
name
,
false
).
Return
unused
.
14.7.5.5
Runtime Semantics: ForInOfLoopEvaluation
The
syntax-directed operation
ForInOfLoopEvaluation takes argument
labelSet
(a
List
of Strings) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It is defined piecewise over the following productions:
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(« »,
Expression
,
enumerate
).
Return ?
ForIn/OfBodyEvaluation
(
LeftHandSideExpression
,
Statement
,
keyResult
,
enumerate
,
assignment
,
labelSet
).
ForInOfStatement
:
for
(
var
ForBinding
in
Expression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(« »,
Expression
,
enumerate
).
Return ?
ForIn/OfBodyEvaluation
(
ForBinding
,
Statement
,
keyResult
,
enumerate
,
var-binding
,
labelSet
).
ForInOfStatement
:
for
(
ForDeclaration
in
Expression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(
BoundNames
of
ForDeclaration
,
Expression
,
enumerate
).
Return ?
ForIn/OfBodyEvaluation
(
ForDeclaration
,
Statement
,
keyResult
,
enumerate
,
lexical-binding
,
labelSet
).
ForInOfStatement
:
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(« »,
AssignmentExpression
,
iterate
).
Return ?
ForIn/OfBodyEvaluation
(
LeftHandSideExpression
,
Statement
,
keyResult
,
iterate
,
assignment
,
labelSet
).
ForInOfStatement
:
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(« »,
AssignmentExpression
,
iterate
).
Return ?
ForIn/OfBodyEvaluation
(
ForBinding
,
Statement
,
keyResult
,
iterate
,
var-binding
,
labelSet
).
ForInOfStatement
:
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(
BoundNames
of
ForDeclaration
,
AssignmentExpression
,
iterate
).
Return ?
ForIn/OfBodyEvaluation
(
ForDeclaration
,
Statement
,
keyResult
,
iterate
,
lexical-binding
,
labelSet
).
ForInOfStatement
:
for
await
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(« »,
AssignmentExpression
,
async-iterate
).
Return ?
ForIn/OfBodyEvaluation
(
LeftHandSideExpression
,
Statement
,
keyResult
,
iterate
,
assignment
,
labelSet
,
async
).
ForInOfStatement
:
for
await
(
var
ForBinding
of
AssignmentExpression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(« »,
AssignmentExpression
,
async-iterate
).
Return ?
ForIn/OfBodyEvaluation
(
ForBinding
,
Statement
,
keyResult
,
iterate
,
var-binding
,
labelSet
,
async
).
ForInOfStatement
:
for
await
(
ForDeclaration
of
AssignmentExpression
)
Statement
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(
BoundNames
of
ForDeclaration
,
AssignmentExpression
,
async-iterate
).
Return ?
ForIn/OfBodyEvaluation
(
ForDeclaration
,
Statement
,
keyResult
,
iterate
,
lexical-binding
,
labelSet
,
async
).
Note
This section is extended by Annex
B.3.5
.
14.7.5.6
ForIn/OfHeadEvaluation (
uninitializedBoundNames
,
expr
,
iterationKind
)
The abstract operation ForIn/OfHeadEvaluation takes arguments
uninitializedBoundNames
(a
List
of Strings),
expr
(an
Expression
Parse Node
or an
AssignmentExpression
Parse Node
), and
iterationKind
(
enumerate
,
iterate
, or
async-iterate
) and returns either a
normal completion containing
an
Iterator Record
or an
abrupt completion
. It performs the following steps when called:
Let
oldEnv
be the
running execution context
's LexicalEnvironment.
If
uninitializedBoundNames
is not empty, then
Assert
:
uninitializedBoundNames
has no duplicate entries.
Let
newEnv
be
NewDeclarativeEnvironment
(
oldEnv
).
For each String
name
of
uninitializedBoundNames
, do
Perform !
newEnv
.
CreateMutableBinding
(
name
,
false
).
Set the
running execution context
's LexicalEnvironment to
newEnv
.
Let
exprRef
be
Completion
(
Evaluation
of
expr
).
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Let
exprValue
be ?
GetValue
(?
exprRef
).
If
iterationKind
is
enumerate
, then
If
exprValue
is either
undefined
or
null
, then
Return
Completion Record
{
[[Type]]
:
break
,
[[Value]]
:
empty
,
[[Target]]
:
empty
}.
Let
obj
be !
ToObject
(
exprValue
).
Let
iterator
be
EnumerateObjectProperties
(
obj
).
Let
nextMethod
be !
GetV
(
iterator
,
"next"
).
Return the
Iterator Record
{
[[Iterator]]
:
iterator
,
[[NextMethod]]
:
nextMethod
,
[[Done]]
:
false
}.
Else,
Assert
:
iterationKind
is either
iterate
or
async-iterate
.
If
iterationKind
is
async-iterate
, let
iteratorKind
be
async
.
Else, let
iteratorKind
be
sync
.
Return ?
GetIterator
(
exprValue
,
iteratorKind
).
14.7.5.7
ForIn/OfBodyEvaluation (
lhs
,
stmt
,
iteratorRecord
,
iterationKind
,
lhsKind
,
labelSet
[ ,
iteratorKind
] )
The abstract operation ForIn/OfBodyEvaluation takes arguments
lhs
(a
Parse Node
),
stmt
(a
Statement
Parse Node
),
iteratorRecord
(an
Iterator Record
),
iterationKind
(
enumerate
or
iterate
),
lhsKind
(
assignment
,
var-binding
, or
lexical-binding
), and
labelSet
(a
List
of Strings) and optional argument
iteratorKind
(
sync
or
async
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
If
iteratorKind
is not present, set
iteratorKind
to
sync
.
Let
oldEnv
be the
running execution context
's LexicalEnvironment.
Let
V
be
undefined
.
Let
destructuring
be
IsDestructuring
of
lhs
.
If
destructuring
is
true
and
lhsKind
is
assignment
, then
Assert
:
lhs
is a
LeftHandSideExpression
.
Let
assignmentPattern
be the
AssignmentPattern
that is
covered
by
lhs
.
Repeat,
Let
nextResult
be ?
Call
(
iteratorRecord
.
[[NextMethod]]
,
iteratorRecord
.
[[Iterator]]
).
If
iteratorKind
is
async
, set
nextResult
to ?
Await
(
nextResult
).
If
nextResult
is not an Object
, throw a
TypeError
exception.
Let
done
be ?
IteratorComplete
(
nextResult
).
If
done
is
true
, return
V
.
Let
nextValue
be ?
IteratorValue
(
nextResult
).
If
lhsKind
is either
assignment
or
var-binding
, then
If
destructuring
is
true
, then
If
lhsKind
is
assignment
, then
Let
status
be
Completion
(
DestructuringAssignmentEvaluation
of
assignmentPattern
with argument
nextValue
).
Else,
Assert
:
lhsKind
is
var-binding
.
Assert
:
lhs
is a
ForBinding
.
Let
status
be
Completion
(
BindingInitialization
of
lhs
with arguments
nextValue
and
undefined
).
Else,
Let
lhsRef
be
Completion
(
Evaluation
of
lhs
). (It may be evaluated repeatedly.)
If
lhsKind
is
assignment
and the
AssignmentTargetType
of
lhs
is
web-compat
, throw a
ReferenceError
exception.
If
lhsRef
is an
abrupt completion
, then
Let
status
be
lhsRef
.
Else,
Let
status
be
Completion
(
PutValue
(
lhsRef
.
[[Value]]
,
nextValue
)).
Else,
Assert
:
lhsKind
is
lexical-binding
.
Assert
:
lhs
is a
ForDeclaration
.
Let
iterationEnv
be
NewDeclarativeEnvironment
(
oldEnv
).
Perform
ForDeclarationBindingInstantiation
of
lhs
with argument
iterationEnv
.
Set the
running execution context
's LexicalEnvironment to
iterationEnv
.
If
destructuring
is
true
, then
Let
status
be
Completion
(
ForDeclarationBindingInitialization
of
lhs
with arguments
nextValue
and
iterationEnv
).
Else,
Assert
:
lhs
binds a single name.
Let
lhsName
be the sole element of the
BoundNames
of
lhs
.
Let
lhsRef
be !
ResolveBinding
(
lhsName
).
Let
status
be
Completion
(
InitializeReferencedBinding
(
lhsRef
,
nextValue
)).
If
status
is an
abrupt completion
, then
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
If
iterationKind
is
enumerate
, then
Return ?
status
.
Else,
Assert
:
iterationKind
is
iterate
.
If
iteratorKind
is
async
, return ?
AsyncIteratorClose
(
iteratorRecord
,
status
).
Return ?
IteratorClose
(
iteratorRecord
,
status
).
Let
result
be
Completion
(
Evaluation
of
stmt
).
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
If
LoopContinues
(
result
,
labelSet
) is
false
, then
Set
status
to
Completion
(
UpdateEmpty
(
result
,
V
)).
If
iterationKind
is
enumerate
, then
Return ?
status
.
Else,
Assert
:
iterationKind
is
iterate
.
If
iteratorKind
is
async
, return ?
AsyncIteratorClose
(
iteratorRecord
,
status
).
Return ?
IteratorClose
(
iteratorRecord
,
status
).
If
result
.
[[Value]]
is not
empty
, set
V
to
result
.
[[Value]]
.
14.7.5.8
Runtime Semantics: Evaluation
BindingIdentifier
:
Identifier
yield
await
Let
bindingId
be the
StringValue
of
BindingIdentifier
.
Return ?
ResolveBinding
(
bindingId
).
14.7.5.9
EnumerateObjectProperties (
O
)
The abstract operation EnumerateObjectProperties takes argument
O
(an Object) and returns an
iterator object
. It performs the following steps when called:
Return an
iterator object
whose
next
method iterates over all the String-valued keys of enumerable properties of
O
. The
iterator object
is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.
The
iterator
's
throw
and
return
methods are
null
and are never invoked. The
iterator
's
next
method processes object properties to determine whether the
property key
should be returned as an
iterator
value. Returned
property keys
do not include keys that are Symbols. Properties of the target object may be deleted during enumeration. A property that is deleted before it is processed by the
iterator
's
next
method is ignored. If new properties are added to the target object during enumeration, the newly added properties are not guaranteed to be processed in the active enumeration. A
property name
will be returned by the
iterator
's
next
method at most once in any enumeration.
Enumerating the properties of the target object includes enumerating properties of its prototype, and the prototype of the prototype, and so on, recursively; but a property of a prototype is not processed if it has the same name as a property that has already been processed by the
iterator
's
next
method. The values of
[[Enumerable]]
attributes are not considered when determining if a property of a prototype object has already been processed. The enumerable
property names
of prototype objects must be obtained by invoking EnumerateObjectProperties passing the prototype object as the argument. EnumerateObjectProperties must obtain the own
property keys
of the target object by calling its
[[OwnPropertyKeys]]
internal method. Property attributes of the target object must be obtained by calling its
[[GetOwnProperty]]
internal method.
In addition, if neither
O
nor any object in its prototype chain is a
Proxy exotic object
,
TypedArray
,
module namespace exotic object
, or implementation provided
exotic object
, then the
iterator
must behave as would the
iterator
given by
CreateForInIterator
(
O
) until one of the following occurs:
the value of the
[[Prototype]]
internal slot of
O
or an object in its prototype chain changes,
a property is removed from
O
or an object in its prototype chain,
a property is added to an object in
O
's prototype chain, or
the value of the
[[Enumerable]]
attribute of a property of
O
or an object in its prototype chain changes.
Note 1
ECMAScript implementations are not required to implement the algorithm in
14.7.5.10.2.1
directly. They may choose any implementation whose behaviour will not deviate from that algorithm unless one of the constraints in the previous paragraph is violated.
The following is an informative definition of an ECMAScript generator function that conforms to these rules:
function
*
EnumerateObjectProperties
(obj) {
const
visited =
new
Set
();
for
(
const
key
of
Reflect
.
ownKeys
(obj)) {
if
(
typeof
key ===
"symbol"
)
continue
;
const
desc =
Reflect
.
getOwnPropertyDescriptor
(obj, key);
if
(desc) { visited.
add
(key);
if
(desc.
enumerable
)
yield
key; } }
const
proto =
Reflect
.
getPrototypeOf
(obj);
if
(proto ===
null
)
return
;
for
(
const
protoKey
of
EnumerateObjectProperties
(proto)) {
if
(!visited.
has
(protoKey))
yield
protoKey; } }
Note 2
The list of
exotic objects
for which implementations are not required to match
CreateForInIterator
was chosen because implementations historically differed in behaviour for those cases, and agreed in all others.
14.7.5.10
For-In Iterator Objects
A
For-In Iterator
is an object that represents a specific iteration over some specific object. For-In Iterator objects are never directly accessible to ECMAScript code; they exist solely to illustrate the behaviour of
EnumerateObjectProperties
.
14.7.5.10.1
CreateForInIterator (
object
)
The abstract operation CreateForInIterator takes argument
object
(an Object) and returns a
For-In Iterator
. It is used to create a
For-In Iterator object
which iterates over the own and inherited enumerable string properties of
object
in a specific order. It performs the following steps when called:
Let
iterator
be
OrdinaryObjectCreate
(
%ForInIteratorPrototype%
, «
[[Object]]
,
[[ObjectWasVisited]]
,
[[VisitedKeys]]
,
[[RemainingKeys]]
»).
Set
iterator
.
[[Object]]
to
object
.
Set
iterator
.
[[ObjectWasVisited]]
to
false
.
Set
iterator
.
[[VisitedKeys]]
to a new empty
List
.
Set
iterator
.
[[RemainingKeys]]
to a new empty
List
.
Return
iterator
.
14.7.5.10.2
The %ForInIteratorPrototype% Object
The
%ForInIteratorPrototype%
object:
has properties that are inherited by all
For-In Iterator objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
is never directly accessible to ECMAScript code.
has the following properties:
14.7.5.10.2.1
%ForInIteratorPrototype%.next ( )
Let
O
be the
this
value.
Assert
:
O
is an Object
.
Assert
:
O
has all of the internal slots of a
For-In Iterator
instance (
14.7.5.10.3
).
Let
object
be
O
.
[[Object]]
.
Repeat,
If
O
.
[[ObjectWasVisited]]
is
false
, then
Let
keys
be ?
object
.
[[OwnPropertyKeys]]
()
.
For each element
key
of
keys
, do
If
key
is a String
, then
Append
key
to
O
.
[[RemainingKeys]]
.
Set
O
.
[[ObjectWasVisited]]
to
true
.
Repeat, while
O
.
[[RemainingKeys]]
is not empty,
Let
r
be the first element of
O
.
[[RemainingKeys]]
.
Remove the first element from
O
.
[[RemainingKeys]]
.
If
O
.
[[VisitedKeys]]
does not contain
r
, then
Let
desc
be ?
object
.
[[GetOwnProperty]]
(
r
)
.
If
desc
is not
undefined
, then
Append
r
to
O
.
[[VisitedKeys]]
.
If
desc
.
[[Enumerable]]
is
true
, return
CreateIteratorResultObject
(
r
,
false
).
Set
object
to ?
object
.
[[GetPrototypeOf]]
()
.
Set
O
.
[[Object]]
to
object
.
Set
O
.
[[ObjectWasVisited]]
to
false
.
If
object
is
null
, return
CreateIteratorResultObject
(
undefined
,
true
).
14.7.5.10.3
Properties of For-In Iterator Instances
For-In Iterator
instances are
ordinary objects
that inherit properties from the
%ForInIteratorPrototype%
intrinsic object.
For-In Iterator
instances are initially created with the internal slots listed in
Table 33
.
Table 33: Internal Slots of
For-In Iterator
Instances
Internal Slot
Type
Description
[[Object]]
an Object
The Object value whose properties are being iterated.
[[ObjectWasVisited]]
a Boolean
true
if the
iterator
has invoked
[[OwnPropertyKeys]]
on
[[Object]]
,
false
otherwise.
[[VisitedKeys]]
a
List
of Strings
The values that have been emitted by this
iterator
thus far.
[[RemainingKeys]]
a
List
of Strings
The values remaining to be emitted for the current object, before iterating the properties of its prototype (if its prototype is not
null
).
14.8
The
continue
Statement
Syntax
ContinueStatement
[Yield, Await]
:
continue
;
continue
[no
LineTerminator
here]
LabelIdentifier
[?Yield, ?Await]
;
14.8.1
Static Semantics: Early Errors
ContinueStatement
:
continue
;
continue
LabelIdentifier
;
It is a Syntax Error if this
ContinueStatement
is not nested, directly or indirectly (but not crossing function or
static
initialization block boundaries), within an
IterationStatement
.
14.8.2
Runtime Semantics: Evaluation
ContinueStatement
:
continue
;
Return
Completion Record
{
[[Type]]
:
continue
,
[[Value]]
:
empty
,
[[Target]]
:
empty
}.
ContinueStatement
:
continue
LabelIdentifier
;
Let
label
be the
StringValue
of
LabelIdentifier
.
Return
Completion Record
{
[[Type]]
:
continue
,
[[Value]]
:
empty
,
[[Target]]
:
label
}.
14.9
The
break
Statement
Syntax
BreakStatement
[Yield, Await]
:
break
;
break
[no
LineTerminator
here]
LabelIdentifier
[?Yield, ?Await]
;
14.9.1
Static Semantics: Early Errors
BreakStatement
:
break
;
It is a Syntax Error if this
BreakStatement
is not nested, directly or indirectly (but not crossing function or
static
initialization block boundaries), within an
IterationStatement
or a
SwitchStatement
.
14.9.2
Runtime Semantics: Evaluation
BreakStatement
:
break
;
Return
Completion Record
{
[[Type]]
:
break
,
[[Value]]
:
empty
,
[[Target]]
:
empty
}.
BreakStatement
:
break
LabelIdentifier
;
Let
label
be the
StringValue
of
LabelIdentifier
.
Return
Completion Record
{
[[Type]]
:
break
,
[[Value]]
:
empty
,
[[Target]]
:
label
}.
14.10
The
return
Statement
Syntax
ReturnStatement
[Yield, Await]
:
return
;
return
[no
LineTerminator
here]
Expression
[+In, ?Yield, ?Await]
;
Note
A
return
statement causes a function to cease execution and, in most cases, returns a value to the caller. If
Expression
is omitted, the return value is
undefined
. Otherwise, the return value is the value of
Expression
. A
return
statement may not actually return a value to the caller depending on surrounding context. For example, in a
try
block, a
return
statement's
Completion Record
may be replaced with another
Completion Record
during evaluation of the
finally
block.
14.10.1
Runtime Semantics: Evaluation
ReturnStatement
:
return
;
Return
ReturnCompletion
(
undefined
).
ReturnStatement
:
return
Expression
;
Let
exprRef
be ?
Evaluation
of
Expression
.
Let
exprValue
be ?
GetValue
(
exprRef
).
If
GetGeneratorKind
() is
async
, set
exprValue
to ?
Await
(
exprValue
).
Return
ReturnCompletion
(
exprValue
).
Legacy
14.11
The
with
Statement
Note 1
Use of the
Legacy
with
statement is discouraged in new ECMAScript code. Consider alternatives that are permitted in both
strict mode code
and
non-strict code
, such as
destructuring assignment
.
Syntax
WithStatement
[Yield, Await, Return]
:
with
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
Note 2
The
with
statement adds an
Object Environment Record
for a computed object to the lexical environment of the
running execution context
. It then executes a statement using this augmented lexical environment. Finally, it restores the original lexical environment.
14.11.1
Static Semantics: Early Errors
WithStatement
:
with
(
Expression
)
Statement
It is a Syntax Error if
IsStrict
(this production) is
true
.
It is a Syntax Error if
IsLabelledFunction
(
Statement
) is
true
.
Note
It is only necessary to apply the second rule if the extension specified in
B.3.1
is implemented.
14.11.2
Runtime Semantics: Evaluation
WithStatement
:
with
(
Expression
)
Statement
Let
val
be ?
Evaluation
of
Expression
.
Let
obj
be ?
ToObject
(?
GetValue
(
val
)).
Let
oldEnv
be the
running execution context
's LexicalEnvironment.
Let
newEnv
be
NewObjectEnvironment
(
obj
,
true
,
oldEnv
).
Set the
running execution context
's LexicalEnvironment to
newEnv
.
Let
C
be
Completion
(
Evaluation
of
Statement
).
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Return ?
UpdateEmpty
(
C
,
undefined
).
Note
No matter how control leaves the embedded
Statement
, whether normally or by some form of
abrupt completion
or exception, the LexicalEnvironment is always restored to its former state.
14.12
The
switch
Statement
Syntax
SwitchStatement
[Yield, Await, Return]
:
switch
(
Expression
[+In, ?Yield, ?Await]
)
CaseBlock
[?Yield, ?Await, ?Return]
CaseBlock
[Yield, Await, Return]
:
{
CaseClauses
[?Yield, ?Await, ?Return]
opt
}
{
CaseClauses
[?Yield, ?Await, ?Return]
opt
DefaultClause
[?Yield, ?Await, ?Return]
CaseClauses
[?Yield, ?Await, ?Return]
opt
}
CaseClauses
[Yield, Await, Return]
:
CaseClause
[?Yield, ?Await, ?Return]
CaseClauses
[?Yield, ?Await, ?Return]
CaseClause
[?Yield, ?Await, ?Return]
CaseClause
[Yield, Await, Return]
:
case
Expression
[+In, ?Yield, ?Await]
:
StatementList
[?Yield, ?Await, ?Return]
opt
DefaultClause
[Yield, Await, Return]
:
default
:
StatementList
[?Yield, ?Await, ?Return]
opt
14.12.1
Static Semantics: Early Errors
SwitchStatement
:
switch
(
Expression
)
CaseBlock
It is a Syntax Error if the
LexicallyDeclaredNames
of
CaseBlock
contains any duplicate entries
, unless the
host
is a web browser or otherwise supports
Block-Level Function Declarations Web Legacy Compatibility Semantics
, and both of the following conditions are true:
IsStrict
(this production) is
false
.
The duplicate entries are only bound by FunctionDeclarations.
It is a Syntax Error if any element of the
LexicallyDeclaredNames
of
CaseBlock
also occurs in the
VarDeclaredNames
of
CaseBlock
.
14.12.2
Runtime Semantics: CaseBlockEvaluation
The
syntax-directed operation
CaseBlockEvaluation takes argument
input
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It is defined piecewise over the following productions:
CaseBlock
:
{
}
Return
undefined
.
CaseBlock
:
{
CaseClauses
}
Let
V
be
undefined
.
Let
A
be the
List
of
CaseClause
items in
CaseClauses
, in source text order.
Let
found
be
false
.
For each
CaseClause
C
of
A
, do
If
found
is
false
, then
Set
found
to ?
CaseClauseIsSelected
(
C
,
input
).
If
found
is
true
, then
Let
R
be
Completion
(
Evaluation
of
C
).
If
R
.
[[Value]]
is not
empty
, set
V
to
R
.
[[Value]]
.
If
R
is an
abrupt completion
, return ?
UpdateEmpty
(
R
,
V
).
Return
V
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
Let
V
be
undefined
.
If the first
CaseClauses
is present, then
Let
A
be the
List
of
CaseClause
items in the first
CaseClauses
, in source text order.
Else,
Let
A
be a new empty
List
.
Let
found
be
false
.
For each
CaseClause
C
of
A
, do
If
found
is
false
, then
Set
found
to ?
CaseClauseIsSelected
(
C
,
input
).
If
found
is
true
, then
Let
R
be
Completion
(
Evaluation
of
C
).
If
R
.
[[Value]]
is not
empty
, set
V
to
R
.
[[Value]]
.
If
R
is an
abrupt completion
, return ?
UpdateEmpty
(
R
,
V
).
Let
foundInB
be
false
.
If the second
CaseClauses
is present, then
Let
B
be the
List
of
CaseClause
items in the second
CaseClauses
, in source text order.
Else,
Let
B
be a new empty
List
.
If
found
is
false
, then
For each
CaseClause
C
of
B
, do
If
foundInB
is
false
, then
Set
foundInB
to ?
CaseClauseIsSelected
(
C
,
input
).
If
foundInB
is
true
, then
Let
R
be
Completion
(
Evaluation
of
CaseClause
C
).
If
R
.
[[Value]]
is not
empty
, set
V
to
R
.
[[Value]]
.
If
R
is an
abrupt completion
, return ?
UpdateEmpty
(
R
,
V
).
If
foundInB
is
true
, return
V
.
Let
defaultR
be
Completion
(
Evaluation
of
DefaultClause
).
If
defaultR
.
[[Value]]
is not
empty
, set
V
to
defaultR
.
[[Value]]
.
If
defaultR
is an
abrupt completion
, return ?
UpdateEmpty
(
defaultR
,
V
).
NOTE: The following is another complete iteration of the second
CaseClauses
.
For each
CaseClause
C
of
B
, do
Let
R
be
Completion
(
Evaluation
of
CaseClause
C
).
If
R
.
[[Value]]
is not
empty
, set
V
to
R
.
[[Value]]
.
If
R
is an
abrupt completion
, return ?
UpdateEmpty
(
R
,
V
).
Return
V
.
14.12.3
CaseClauseIsSelected (
C
,
input
)
The abstract operation CaseClauseIsSelected takes arguments
C
(a
CaseClause
Parse Node
) and
input
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or an
abrupt completion
. It determines whether
C
matches
input
. It performs the following steps when called:
Assert
:
C
is an instance of the production
CaseClause
:
case
Expression
:
StatementList
opt
.
Let
exprRef
be ?
Evaluation
of the
Expression
of
C
.
Let
clauseSelector
be ?
GetValue
(
exprRef
).
Return
IsStrictlyEqual
(
input
,
clauseSelector
).
Note
This operation does not execute
C
's
StatementList
(if any). The
CaseBlock
algorithm uses its return value to determine which
StatementList
to start executing.
14.12.4
Runtime Semantics: Evaluation
SwitchStatement
:
switch
(
Expression
)
CaseBlock
Let
exprRef
be ?
Evaluation
of
Expression
.
Let
switchValue
be ?
GetValue
(
exprRef
).
Let
oldEnv
be the
running execution context
's LexicalEnvironment.
Let
blockEnv
be
NewDeclarativeEnvironment
(
oldEnv
).
Perform
BlockDeclarationInstantiation
(
CaseBlock
,
blockEnv
).
Set the
running execution context
's LexicalEnvironment to
blockEnv
.
Let
R
be
Completion
(
CaseBlockEvaluation
of
CaseBlock
with argument
switchValue
).
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Return
R
.
Note
No matter how control leaves the
SwitchStatement
the LexicalEnvironment is always restored to its former state.
CaseClause
:
case
Expression
:
Return
empty
.
CaseClause
:
case
Expression
:
StatementList
Return ?
Evaluation
of
StatementList
.
DefaultClause
:
default
:
Return
empty
.
DefaultClause
:
default
:
StatementList
Return ?
Evaluation
of
StatementList
.
14.13
Labelled Statements
Syntax
LabelledStatement
[Yield, Await, Return]
:
LabelIdentifier
[?Yield, ?Await]
:
LabelledItem
[?Yield, ?Await, ?Return]
LabelledItem
[Yield, Await, Return]
:
Statement
[?Yield, ?Await, ?Return]
FunctionDeclaration
[?Yield, ?Await, ~Default]
Note
A
Statement
may be prefixed by a label. Labelled statements are only used in conjunction with labelled
break
and
continue
statements. ECMAScript has no
goto
statement. A
Statement
can be part of a
LabelledStatement
, which itself can be part of a
LabelledStatement
, and so on. The labels introduced this way are collectively referred to as the “current label set” when describing the semantics of individual statements.
14.13.1
Static Semantics: Early Errors
LabelledItem
:
FunctionDeclaration
It is a Syntax Error if any source text is matched by this production
, unless that source text is
non-strict code
and the
host
is a web browser or otherwise supports
Labelled Function Declarations
.
14.13.2
Static Semantics: IsLabelledFunction (
stmt
)
The abstract operation IsLabelledFunction takes argument
stmt
(a
Statement
Parse Node
) and returns a Boolean. It performs the following steps when called:
If
stmt
is not a
LabelledStatement
, return
false
.
Let
item
be the
LabelledItem
of
stmt
.
If
item
is
LabelledItem
:
FunctionDeclaration
, return
true
.
Let
subStmt
be the
Statement
of
item
.
Return
IsLabelledFunction
(
subStmt
).
14.13.3
Runtime Semantics: Evaluation
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return ?
LabelledEvaluation
of this
LabelledStatement
with argument « ».
14.13.4
Runtime Semantics: LabelledEvaluation
The
syntax-directed operation
LabelledEvaluation takes argument
labelSet
(a
List
of Strings) and returns either a
normal completion containing
either an
ECMAScript language value
or
empty
, or an
abrupt completion
. It is defined piecewise over the following productions:
BreakableStatement
:
IterationStatement
Let
stmtResult
be
Completion
(
LoopEvaluation
of
IterationStatement
with argument
labelSet
).
If
stmtResult
is a
break completion
, then
If
stmtResult
.
[[Target]]
is
empty
, then
If
stmtResult
.
[[Value]]
is
empty
, set
stmtResult
to
NormalCompletion
(
undefined
).
Else, set
stmtResult
to
NormalCompletion
(
stmtResult
.
[[Value]]
).
Return ?
stmtResult
.
BreakableStatement
:
SwitchStatement
Let
stmtResult
be
Completion
(
Evaluation
of
SwitchStatement
).
If
stmtResult
is a
break completion
, then
If
stmtResult
.
[[Target]]
is
empty
, then
If
stmtResult
.
[[Value]]
is
empty
, set
stmtResult
to
NormalCompletion
(
undefined
).
Else, set
stmtResult
to
NormalCompletion
(
stmtResult
.
[[Value]]
).
Return ?
stmtResult
.
Note 1
A
BreakableStatement
is one that can be exited via an unlabelled
BreakStatement
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Let
label
be the
StringValue
of
LabelIdentifier
.
Let
newLabelSet
be the
list-concatenation
of
labelSet
and «
label
».
Let
stmtResult
be
Completion
(
LabelledEvaluation
of
LabelledItem
with argument
newLabelSet
).
If
stmtResult
is a
break completion
and
stmtResult
.
[[Target]]
is
label
, then
Set
stmtResult
to
NormalCompletion
(
stmtResult
.
[[Value]]
).
Return ?
stmtResult
.
LabelledItem
:
FunctionDeclaration
Return ?
Evaluation
of
FunctionDeclaration
.
Statement
:
BlockStatement
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
ThrowStatement
TryStatement
DebuggerStatement
Return ?
Evaluation
of
Statement
.
Note 2
The only two productions of
Statement
which have special semantics for LabelledEvaluation are
BreakableStatement
and
LabelledStatement
.
14.14
The
throw
Statement
Syntax
ThrowStatement
[Yield, Await]
:
throw
[no
LineTerminator
here]
Expression
[+In, ?Yield, ?Await]
;
14.14.1
Runtime Semantics: Evaluation
ThrowStatement
:
throw
Expression
;
Let
exprRef
be ?
Evaluation
of
Expression
.
Let
exprValue
be ?
GetValue
(
exprRef
).
Return
ThrowCompletion
(
exprValue
).
14.15
The
try
Statement
Syntax
TryStatement
[Yield, Await, Return]
:
try
Block
[?Yield, ?Await, ?Return]
Catch
[?Yield, ?Await, ?Return]
try
Block
[?Yield, ?Await, ?Return]
Finally
[?Yield, ?Await, ?Return]
try
Block
[?Yield, ?Await, ?Return]
Catch
[?Yield, ?Await, ?Return]
Finally
[?Yield, ?Await, ?Return]
Catch
[Yield, Await, Return]
:
catch
(
CatchParameter
[?Yield, ?Await]
)
Block
[?Yield, ?Await, ?Return]
catch
Block
[?Yield, ?Await, ?Return]
Finally
[Yield, Await, Return]
:
finally
Block
[?Yield, ?Await, ?Return]
CatchParameter
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
BindingPattern
[?Yield, ?Await]
Note
The
try
statement encloses a block of code in which an exceptional condition can occur, such as a runtime error or a
throw
statement. The
catch
clause provides the exception-handling code. When a catch clause catches an exception, its
CatchParameter
is bound to that exception.
14.15.1
Static Semantics: Early Errors
Catch
:
catch
(
CatchParameter
)
Block
It is a Syntax Error if the
BoundNames
of
CatchParameter
contains any duplicate elements.
It is a Syntax Error if any element of the
BoundNames
of
CatchParameter
also occurs in the
LexicallyDeclaredNames
of
Block
.
It is a Syntax Error if any element of the
BoundNames
of
CatchParameter
also occurs in the
VarDeclaredNames
of
Block
, unless
CatchParameter
is
CatchParameter
:
BindingIdentifier
and the
host
is a web browser or otherwise supports
VariableStatements in Catch Blocks
.
14.15.2
Runtime Semantics: CatchClauseEvaluation
The
syntax-directed operation
CatchClauseEvaluation takes argument
thrownValue
(an
ECMAScript language value
) and returns either a
normal completion containing
either an
ECMAScript language value
or
empty
, or an
abrupt completion
. It is defined piecewise over the following productions:
Catch
:
catch
(
CatchParameter
)
Block
Let
oldEnv
be the
running execution context
's LexicalEnvironment.
Let
catchEnv
be
NewDeclarativeEnvironment
(
oldEnv
).
For each element
argName
of the
BoundNames
of
CatchParameter
, do
Perform !
catchEnv
.
CreateMutableBinding
(
argName
,
false
).
Set the
running execution context
's LexicalEnvironment to
catchEnv
.
Let
status
be
Completion
(
BindingInitialization
of
CatchParameter
with arguments
thrownValue
and
catchEnv
).
If
status
is an
abrupt completion
, then
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Return ?
status
.
Let
B
be
Completion
(
Evaluation
of
Block
).
Set the
running execution context
's LexicalEnvironment to
oldEnv
.
Return ?
B
.
Catch
:
catch
Block
Return ?
Evaluation
of
Block
.
Note
No matter how control leaves the
Block
the LexicalEnvironment is always restored to its former state.
14.15.3
Runtime Semantics: Evaluation
TryStatement
:
try
Block
Catch
Let
B
be
Completion
(
Evaluation
of
Block
).
If
B
is a
throw completion
, let
C
be
Completion
(
CatchClauseEvaluation
of
Catch
with argument
B
.
[[Value]]
).
Else, let
C
be
B
.
Return ?
UpdateEmpty
(
C
,
undefined
).
TryStatement
:
try
Block
Finally
Let
B
be
Completion
(
Evaluation
of
Block
).
Let
F
be
Completion
(
Evaluation
of
Finally
).
If
F
is a
normal completion
, set
F
to
B
.
Return ?
UpdateEmpty
(
F
,
undefined
).
TryStatement
:
try
Block
Catch
Finally
Let
B
be
Completion
(
Evaluation
of
Block
).
If
B
is a
throw completion
, let
C
be
Completion
(
CatchClauseEvaluation
of
Catch
with argument
B
.
[[Value]]
).
Else, let
C
be
B
.
Let
F
be
Completion
(
Evaluation
of
Finally
).
If
F
is a
normal completion
, set
F
to
C
.
Return ?
UpdateEmpty
(
F
,
undefined
).
14.16
The
debugger
Statement
Syntax
DebuggerStatement
:
debugger
;
14.16.1
Runtime Semantics: Evaluation
Note
Evaluating a
DebuggerStatement
may allow an implementation to cause a breakpoint when run under a debugger. If a debugger is not present or active this statement has no observable effect.
DebuggerStatement
:
debugger
;
If an
implementation-defined
debugging facility is available and enabled, then
Perform an
implementation-defined
debugging action.
Return a new
implementation-defined
Completion Record
.
Else,
Return
empty
.
15
ECMAScript Language: Functions and Classes
Note
Various ECMAScript language elements cause the creation of ECMAScript
function objects
(
10.2
).
Evaluation
of such functions starts with the execution of their
[[Call]]
internal method (
10.2.1
).
15.1
Parameter Lists
Syntax
UniqueFormalParameters
[Yield, Await]
:
FormalParameters
[?Yield, ?Await]
FormalParameters
[Yield, Await]
:
[empty]
FunctionRestParameter
[?Yield, ?Await]
FormalParameterList
[?Yield, ?Await]
FormalParameterList
[?Yield, ?Await]
,
FormalParameterList
[?Yield, ?Await]
,
FunctionRestParameter
[?Yield, ?Await]
FormalParameterList
[Yield, Await]
:
FormalParameter
[?Yield, ?Await]
FormalParameterList
[?Yield, ?Await]
,
FormalParameter
[?Yield, ?Await]
FunctionRestParameter
[Yield, Await]
:
BindingRestElement
[?Yield, ?Await]
FormalParameter
[Yield, Await]
:
BindingElement
[?Yield, ?Await]
15.1.1
Static Semantics: Early Errors
UniqueFormalParameters
:
FormalParameters
It is a Syntax Error if the
BoundNames
of
FormalParameters
contains any duplicate elements.
FormalParameters
:
FormalParameterList
It is a Syntax Error if
IsSimpleParameterList
of
FormalParameterList
is
false
and the
BoundNames
of
FormalParameterList
contains any duplicate elements.
Note
Multiple occurrences of the same
BindingIdentifier
in a
FormalParameterList
is only allowed for functions which have simple parameter lists and which are not defined in
strict mode code
.
15.1.2
Static Semantics: ContainsExpression
The
syntax-directed operation
ContainsExpression takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
ObjectBindingPattern
:
{
}
{
BindingRestProperty
}
Return
false
.
ObjectBindingPattern
:
{
BindingPropertyList
,
BindingRestProperty
}
Return
ContainsExpression
of
BindingPropertyList
.
ArrayBindingPattern
:
[
Elision
opt
]
Return
false
.
ArrayBindingPattern
:
[
Elision
opt
BindingRestElement
]
Return
ContainsExpression
of
BindingRestElement
.
ArrayBindingPattern
:
[
BindingElementList
,
Elision
opt
]
Return
ContainsExpression
of
BindingElementList
.
ArrayBindingPattern
:
[
BindingElementList
,
Elision
opt
BindingRestElement
]
Let
has
be
ContainsExpression
of
BindingElementList
.
If
has
is
true
, return
true
.
Return
ContainsExpression
of
BindingRestElement
.
BindingPropertyList
:
BindingPropertyList
,
BindingProperty
Let
has
be
ContainsExpression
of
BindingPropertyList
.
If
has
is
true
, return
true
.
Return
ContainsExpression
of
BindingProperty
.
BindingElementList
:
BindingElementList
,
BindingElisionElement
Let
has
be
ContainsExpression
of
BindingElementList
.
If
has
is
true
, return
true
.
Return
ContainsExpression
of
BindingElisionElement
.
BindingElisionElement
:
Elision
opt
BindingElement
Return
ContainsExpression
of
BindingElement
.
BindingProperty
:
PropertyName
:
BindingElement
Let
has
be
IsComputedPropertyKey
of
PropertyName
.
If
has
is
true
, return
true
.
Return
ContainsExpression
of
BindingElement
.
BindingElement
:
BindingPattern
Initializer
Return
true
.
SingleNameBinding
:
BindingIdentifier
Return
false
.
SingleNameBinding
:
BindingIdentifier
Initializer
Return
true
.
BindingRestElement
:
...
BindingIdentifier
Return
false
.
BindingRestElement
:
...
BindingPattern
Return
ContainsExpression
of
BindingPattern
.
FormalParameters
:
[empty]
Return
false
.
FormalParameters
:
FormalParameterList
,
FunctionRestParameter
If
ContainsExpression
of
FormalParameterList
is
true
, return
true
.
Return
ContainsExpression
of
FunctionRestParameter
.
FormalParameterList
:
FormalParameterList
,
FormalParameter
If
ContainsExpression
of
FormalParameterList
is
true
, return
true
.
Return
ContainsExpression
of
FormalParameter
.
ArrowParameters
:
BindingIdentifier
Return
false
.
ArrowParameters
:
CoverParenthesizedExpressionAndArrowParameterList
Let
formals
be the
ArrowFormalParameters
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return
ContainsExpression
of
formals
.
AsyncArrowBindingIdentifier
:
BindingIdentifier
Return
false
.
15.1.3
Static Semantics: IsSimpleParameterList
The
syntax-directed operation
IsSimpleParameterList takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
BindingElement
:
BindingPattern
Return
false
.
BindingElement
:
BindingPattern
Initializer
Return
false
.
SingleNameBinding
:
BindingIdentifier
Return
true
.
SingleNameBinding
:
BindingIdentifier
Initializer
Return
false
.
FormalParameters
:
[empty]
Return
true
.
FormalParameters
:
FunctionRestParameter
Return
false
.
FormalParameters
:
FormalParameterList
,
FunctionRestParameter
Return
false
.
FormalParameterList
:
FormalParameterList
,
FormalParameter
If
IsSimpleParameterList
of
FormalParameterList
is
false
, return
false
.
Return
IsSimpleParameterList
of
FormalParameter
.
FormalParameter
:
BindingElement
Return
IsSimpleParameterList
of
BindingElement
.
ArrowParameters
:
BindingIdentifier
Return
true
.
ArrowParameters
:
CoverParenthesizedExpressionAndArrowParameterList
Let
formals
be the
ArrowFormalParameters
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return
IsSimpleParameterList
of
formals
.
AsyncArrowBindingIdentifier
:
BindingIdentifier
Return
true
.
CoverCallExpressionAndAsyncArrowHead
:
MemberExpression
Arguments
Let
head
be the
AsyncArrowHead
that is
covered
by
CoverCallExpressionAndAsyncArrowHead
.
Return
IsSimpleParameterList
of
head
.
15.1.4
Static Semantics: HasInitializer
The
syntax-directed operation
HasInitializer takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
BindingElement
:
BindingPattern
Return
false
.
BindingElement
:
BindingPattern
Initializer
Return
true
.
SingleNameBinding
:
BindingIdentifier
Return
false
.
SingleNameBinding
:
BindingIdentifier
Initializer
Return
true
.
FormalParameterList
:
FormalParameterList
,
FormalParameter
If
HasInitializer
of
FormalParameterList
is
true
, return
true
.
Return
HasInitializer
of
FormalParameter
.
15.1.5
Static Semantics: ExpectedArgumentCount
The
syntax-directed operation
ExpectedArgumentCount takes no arguments and returns a non-negative
integer
. It is defined piecewise over the following productions:
FormalParameters
:
[empty]
FunctionRestParameter
Return 0.
FormalParameters
:
FormalParameterList
,
FunctionRestParameter
Return the
ExpectedArgumentCount
of
FormalParameterList
.
Note
The ExpectedArgumentCount of a
FormalParameterList
is the number of
FormalParameters
to the left of either the rest parameter or the first
FormalParameter
with an Initializer. A
FormalParameter
without an initializer is allowed after the first parameter with an initializer but such parameters are considered to be optional with
undefined
as their default value.
FormalParameterList
:
FormalParameter
If
HasInitializer
of
FormalParameter
is
true
, return 0.
Return 1.
FormalParameterList
:
FormalParameterList
,
FormalParameter
Let
count
be the
ExpectedArgumentCount
of
FormalParameterList
.
If
HasInitializer
of
FormalParameterList
is
true
or
HasInitializer
of
FormalParameter
is
true
, return
count
.
Return
count
+ 1.
ArrowParameters
:
BindingIdentifier
Return 1.
ArrowParameters
:
CoverParenthesizedExpressionAndArrowParameterList
Let
formals
be the
ArrowFormalParameters
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return the
ExpectedArgumentCount
of
formals
.
PropertySetParameterList
:
FormalParameter
If
HasInitializer
of
FormalParameter
is
true
, return 0.
Return 1.
AsyncArrowBindingIdentifier
:
BindingIdentifier
Return 1.
15.2
Function Definitions
Syntax
FunctionDeclaration
[Yield, Await, Default]
:
function
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
[+Default]
function
(
FormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
FunctionExpression
:
function
BindingIdentifier
[~Yield, ~Await]
opt
(
FormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
FunctionBody
[Yield, Await]
:
FunctionStatementList
[?Yield, ?Await]
FunctionStatementList
[Yield, Await]
:
StatementList
[?Yield, ?Await, +Return]
opt
15.2.1
Static Semantics: Early Errors
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
function
(
FormalParameters
)
{
FunctionBody
}
FunctionExpression
:
function
BindingIdentifier
opt
(
FormalParameters
)
{
FunctionBody
}
If
IsStrict
(
FormalParameters
) is
true
, the Early Error rules for
UniqueFormalParameters
:
FormalParameters
are applied.
If
BindingIdentifier
is present and
IsStrict
(
BindingIdentifier
) is
true
, it is a Syntax Error if the
StringValue
of
BindingIdentifier
is either
"eval"
or
"arguments"
.
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
FunctionBody
is
true
and
IsSimpleParameterList
of
FormalParameters
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
FormalParameters
also occurs in the
LexicallyDeclaredNames
of
FunctionBody
.
It is a Syntax Error if
FormalParameters
Contains
SuperProperty
is
true
.
It is a Syntax Error if
FunctionBody
Contains
SuperProperty
is
true
.
It is a Syntax Error if
FormalParameters
Contains
SuperCall
is
true
.
It is a Syntax Error if
FunctionBody
Contains
SuperCall
is
true
.
Note
The
LexicallyDeclaredNames
of a
FunctionBody
does not include identifiers bound using var or function declarations.
FunctionBody
:
FunctionStatementList
It is a Syntax Error if the
LexicallyDeclaredNames
of
FunctionStatementList
contains any duplicate entries.
It is a Syntax Error if any element of the
LexicallyDeclaredNames
of
FunctionStatementList
also occurs in the
VarDeclaredNames
of
FunctionStatementList
.
It is a Syntax Error if
ContainsDuplicateLabels
of
FunctionStatementList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedBreakTarget
of
FunctionStatementList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedContinueTarget
of
FunctionStatementList
with arguments « » and « » is
true
.
15.2.2
Static Semantics: FunctionBodyContainsUseStrict
The
syntax-directed operation
FunctionBodyContainsUseStrict takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
FunctionBody
:
FunctionStatementList
If the
Directive Prologue
of
FunctionBody
contains a
Use Strict Directive
, return
true
; otherwise return
false
.
15.2.3
Runtime Semantics: EvaluateFunctionBody
The
syntax-directed operation
EvaluateFunctionBody takes arguments
functionObject
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
return completion
or a
throw completion
. It is defined piecewise over the following productions:
FunctionBody
:
FunctionStatementList
Perform ?
FunctionDeclarationInstantiation
(
functionObject
,
argumentsList
).
Perform ?
Evaluation
of
FunctionStatementList
.
NOTE: If the previous step resulted in a
normal completion
, then evaluation finished by proceeding past the end of the
FunctionStatementList
.
Return
ReturnCompletion
(
undefined
).
15.2.4
Runtime Semantics: InstantiateOrdinaryFunctionObject
The
syntax-directed operation
InstantiateOrdinaryFunctionObject takes arguments
env
(an
Environment Record
) and
privateEnv
(a
PrivateEnvironment Record
or
null
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
Let
name
be the
StringValue
of
BindingIdentifier
.
Let
sourceText
be the
source text matched by
FunctionDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
FormalParameters
,
FunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
name
).
Perform
MakeConstructor
(
F
).
Return
F
.
FunctionDeclaration
:
function
(
FormalParameters
)
{
FunctionBody
}
Let
sourceText
be the
source text matched by
FunctionDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
FormalParameters
,
FunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
"default"
).
Perform
MakeConstructor
(
F
).
Return
F
.
Note
An anonymous
FunctionDeclaration
can only occur as part of an
export default
declaration, and its function code is therefore always
strict mode code
.
15.2.5
Runtime Semantics: InstantiateOrdinaryFunctionExpression
The
syntax-directed operation
InstantiateOrdinaryFunctionExpression takes optional argument
name
(a
property key
or a
Private Name
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
FunctionExpression
:
function
(
FormalParameters
)
{
FunctionBody
}
If
name
is not present, set
name
to
""
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
FunctionExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
FormalParameters
,
FunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Perform
MakeConstructor
(
closure
).
Return
closure
.
FunctionExpression
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
Assert
:
name
is not present.
Set
name
to the
StringValue
of
BindingIdentifier
.
Let
outerEnv
be the
running execution context
's LexicalEnvironment.
Let
funcEnv
be
NewDeclarativeEnvironment
(
outerEnv
).
Perform !
funcEnv
.
CreateImmutableBinding
(
name
,
false
).
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
FunctionExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
FormalParameters
,
FunctionBody
,
non-lexical-this
,
funcEnv
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Perform
MakeConstructor
(
closure
).
Perform !
funcEnv
.
InitializeBinding
(
name
,
closure
).
Return
closure
.
Note
The
BindingIdentifier
in a
FunctionExpression
can be referenced from inside the
FunctionExpression
's
FunctionBody
to allow the function to call itself recursively. However, unlike in a
FunctionDeclaration
, the
BindingIdentifier
in a
FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
FunctionExpression
.
15.2.6
Runtime Semantics: Evaluation
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
Return
empty
.
Note 1
An alternative semantics is provided by
Block-Level Function Declarations Web Legacy Compatibility Semantics
at step
32.a.i.2.c
of
FunctionDeclarationInstantiation
, step
12.b.ii.2.a.ii.iii
of
GlobalDeclarationInstantiation
, and step
13.b.ii.7.b
of
EvalDeclarationInstantiation
.
FunctionDeclaration
:
function
(
FormalParameters
)
{
FunctionBody
}
Return
empty
.
FunctionExpression
:
function
BindingIdentifier
opt
(
FormalParameters
)
{
FunctionBody
}
Return
InstantiateOrdinaryFunctionExpression
of
FunctionExpression
.
Note 2
A
"prototype"
property is automatically created for every function defined using a
FunctionDeclaration
or
FunctionExpression
, to allow for the possibility that the function will be used as a
constructor
.
FunctionStatementList
:
[empty]
Return
undefined
.
15.3
Arrow Function Definitions
Syntax
ArrowFunction
[In, Yield, Await]
:
ArrowParameters
[?Yield, ?Await]
[no
LineTerminator
here]
=>
ConciseBody
[?In]
ArrowParameters
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
ConciseBody
[In]
:
[lookahead ≠
{
]
ExpressionBody
[?In, ~Await]
{
FunctionBody
[~Yield, ~Await]
}
ExpressionBody
[In, Await]
:
AssignmentExpression
[?In, ~Yield, ?Await]
Supplemental Syntax
When processing an instance of the production
ArrowParameters
[Yield, Await]
:
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
the interpretation of
CoverParenthesizedExpressionAndArrowParameterList
is refined using the following grammar:
ArrowFormalParameters
[Yield, Await]
:
(
UniqueFormalParameters
[?Yield, ?Await]
)
15.3.1
Static Semantics: Early Errors
ArrowFunction
:
ArrowParameters
=>
ConciseBody
It is a Syntax Error if
ArrowParameters
Contains
YieldExpression
is
true
.
It is a Syntax Error if
ArrowParameters
Contains
AwaitExpression
is
true
.
It is a Syntax Error if
ConciseBodyContainsUseStrict
of
ConciseBody
is
true
and
IsSimpleParameterList
of
ArrowParameters
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
ArrowParameters
also occurs in the
LexicallyDeclaredNames
of
ConciseBody
.
ArrowParameters
:
CoverParenthesizedExpressionAndArrowParameterList
CoverParenthesizedExpressionAndArrowParameterList
must cover
an
ArrowFormalParameters
.
15.3.2
Static Semantics: ConciseBodyContainsUseStrict
The
syntax-directed operation
ConciseBodyContainsUseStrict takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
ConciseBody
:
ExpressionBody
Return
false
.
ConciseBody
:
{
FunctionBody
}
Return
FunctionBodyContainsUseStrict
of
FunctionBody
.
15.3.3
Runtime Semantics: EvaluateConciseBody
The
syntax-directed operation
EvaluateConciseBody takes arguments
functionObject
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
return completion
or a
throw completion
. It is defined piecewise over the following productions:
ConciseBody
:
ExpressionBody
Perform ?
FunctionDeclarationInstantiation
(
functionObject
,
argumentsList
).
Return ?
Evaluation
of
ExpressionBody
.
15.3.4
Runtime Semantics: InstantiateArrowFunctionExpression
The
syntax-directed operation
InstantiateArrowFunctionExpression takes optional argument
name
(a
property key
or a
Private Name
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
ArrowFunction
:
ArrowParameters
=>
ConciseBody
If
name
is not present, set
name
to
""
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
ArrowFunction
.
Let
closure
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
ArrowParameters
,
ConciseBody
,
lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Return
closure
.
Note
An
ArrowFunction
does not define local bindings for
arguments
,
super
,
this
, or
new.target
. Any reference to
arguments
,
super
,
this
, or
new.target
within an
ArrowFunction
must resolve to a binding in a lexically enclosing environment. Typically this will be the Function Environment of an immediately enclosing function. Even though an
ArrowFunction
may contain references to
super
, the
function object
created in step
5
is not made into a method by performing
MakeMethod
. An
ArrowFunction
that references
super
is always contained within a non-
ArrowFunction
and the necessary state to implement
super
is accessible via the
env
that is captured by the
function object
of the
ArrowFunction
.
15.3.5
Runtime Semantics: Evaluation
ArrowFunction
:
ArrowParameters
=>
ConciseBody
Return
InstantiateArrowFunctionExpression
of
ArrowFunction
.
ExpressionBody
:
AssignmentExpression
Let
exprRef
be ?
Evaluation
of
AssignmentExpression
.
Let
exprValue
be ?
GetValue
(
exprRef
).
Return
ReturnCompletion
(
exprValue
).
15.4
Method Definitions
Syntax
MethodDefinition
[Yield, Await]
:
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
GeneratorMethod
[?Yield, ?Await]
AsyncMethod
[?Yield, ?Await]
AsyncGeneratorMethod
[?Yield, ?Await]
get
ClassElementName
[?Yield, ?Await]
(
)
{
FunctionBody
[~Yield, ~Await]
}
set
ClassElementName
[?Yield, ?Await]
(
PropertySetParameterList
)
{
FunctionBody
[~Yield, ~Await]
}
PropertySetParameterList
:
FormalParameter
[~Yield, ~Await]
15.4.1
Static Semantics: Early Errors
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
FunctionBody
is
true
and
IsSimpleParameterList
of
UniqueFormalParameters
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
UniqueFormalParameters
also occurs in the
LexicallyDeclaredNames
of
FunctionBody
.
MethodDefinition
:
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
It is a Syntax Error if the
BoundNames
of
PropertySetParameterList
contains any duplicate elements.
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
FunctionBody
is
true
and
IsSimpleParameterList
of
PropertySetParameterList
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
PropertySetParameterList
also occurs in the
LexicallyDeclaredNames
of
FunctionBody
.
15.4.2
Static Semantics: HasDirectSuper
The
syntax-directed operation
HasDirectSuper takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
If
UniqueFormalParameters
Contains
SuperCall
is
true
, return
true
.
Return
FunctionBody
Contains
SuperCall
.
MethodDefinition
:
get
ClassElementName
(
)
{
FunctionBody
}
Return
FunctionBody
Contains
SuperCall
.
MethodDefinition
:
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
If
PropertySetParameterList
Contains
SuperCall
is
true
, return
true
.
Return
FunctionBody
Contains
SuperCall
.
GeneratorMethod
:
*
ClassElementName
(
UniqueFormalParameters
)
{
GeneratorBody
}
If
UniqueFormalParameters
Contains
SuperCall
is
true
, return
true
.
Return
GeneratorBody
Contains
SuperCall
.
AsyncGeneratorMethod
:
async
*
ClassElementName
(
UniqueFormalParameters
)
{
AsyncGeneratorBody
}
If
UniqueFormalParameters
Contains
SuperCall
is
true
, return
true
.
Return
AsyncGeneratorBody
Contains
SuperCall
.
AsyncMethod
:
async
ClassElementName
(
UniqueFormalParameters
)
{
AsyncFunctionBody
}
If
UniqueFormalParameters
Contains
SuperCall
is
true
, return
true
.
Return
AsyncFunctionBody
Contains
SuperCall
.
15.4.3
Static Semantics: SpecialMethod
The
syntax-directed operation
SpecialMethod takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
Return
false
.
MethodDefinition
:
GeneratorMethod
AsyncMethod
AsyncGeneratorMethod
get
ClassElementName
(
)
{
FunctionBody
}
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
Return
true
.
15.4.4
Runtime Semantics: DefineMethod
The
syntax-directed operation
DefineMethod takes argument
object
(an Object) and optional argument
functionPrototype
(an Object) and returns either a
normal completion containing
a
Record
with fields
[[Key]]
(a
property key
) and
[[Closure]]
(an ECMAScript
function object
) or an
abrupt completion
. It is defined piecewise over the following productions:
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
Let
propKey
be ?
Evaluation
of
ClassElementName
.
Let
env
be the
running execution context
's LexicalEnvironment.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
If
functionPrototype
is present, then
Let
prototype
be
functionPrototype
.
Else,
Let
prototype
be
%Function.prototype%
.
Let
sourceText
be the
source text matched by
MethodDefinition
.
Let
closure
be
OrdinaryFunctionCreate
(
prototype
,
sourceText
,
UniqueFormalParameters
,
FunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
MakeMethod
(
closure
,
object
).
Return the
Record
{
[[Key]]
:
propKey
,
[[Closure]]
:
closure
}.
15.4.5
Runtime Semantics: MethodDefinitionEvaluation
The
syntax-directed operation
MethodDefinitionEvaluation takes arguments
object
(an Object) and
enumerable
(a Boolean) and returns either a
normal completion containing
either a
PrivateElement
or
unused
, or an
abrupt completion
. It is defined piecewise over the following productions:
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
Let
methodDef
be ?
DefineMethod
of
MethodDefinition
with argument
object
.
Perform
SetFunctionName
(
methodDef
.
[[Closure]]
,
methodDef
.
[[Key]]
).
Return ?
DefineMethodProperty
(
object
,
methodDef
.
[[Key]]
,
methodDef
.
[[Closure]]
,
enumerable
).
MethodDefinition
:
get
ClassElementName
(
)
{
FunctionBody
}
Let
propKey
be ?
Evaluation
of
ClassElementName
.
Let
env
be the
running execution context
's LexicalEnvironment.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
MethodDefinition
.
Let
formalParameterList
be an instance of the production
FormalParameters
:
[empty]
.
Let
closure
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
formalParameterList
,
FunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
MakeMethod
(
closure
,
object
).
Perform
SetFunctionName
(
closure
,
propKey
,
"get"
).
If
propKey
is a
Private Name
, then
Return
PrivateElement
{
[[Key]]
:
propKey
,
[[Kind]]
:
accessor
,
[[Get]]
:
closure
,
[[Set]]
:
undefined
}.
Else,
Let
desc
be the PropertyDescriptor {
[[Get]]
:
closure
,
[[Enumerable]]
:
enumerable
,
[[Configurable]]
:
true
}.
Perform ?
DefinePropertyOrThrow
(
object
,
propKey
,
desc
).
Return
unused
.
MethodDefinition
:
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
Let
propKey
be ?
Evaluation
of
ClassElementName
.
Let
env
be the
running execution context
's LexicalEnvironment.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
MethodDefinition
.
Let
closure
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
PropertySetParameterList
,
FunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
MakeMethod
(
closure
,
object
).
Perform
SetFunctionName
(
closure
,
propKey
,
"set"
).
If
propKey
is a
Private Name
, then
Return
PrivateElement
{
[[Key]]
:
propKey
,
[[Kind]]
:
accessor
,
[[Get]]
:
undefined
,
[[Set]]
:
closure
}.
Else,
Let
desc
be the PropertyDescriptor {
[[Set]]
:
closure
,
[[Enumerable]]
:
enumerable
,
[[Configurable]]
:
true
}.
Perform ?
DefinePropertyOrThrow
(
object
,
propKey
,
desc
).
Return
unused
.
GeneratorMethod
:
*
ClassElementName
(
UniqueFormalParameters
)
{
GeneratorBody
}
Let
propKey
be ?
Evaluation
of
ClassElementName
.
Let
env
be the
running execution context
's LexicalEnvironment.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
GeneratorMethod
.
Let
closure
be
OrdinaryFunctionCreate
(
%GeneratorFunction.prototype%
,
sourceText
,
UniqueFormalParameters
,
GeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
MakeMethod
(
closure
,
object
).
Perform
SetFunctionName
(
closure
,
propKey
).
Let
prototype
be
OrdinaryObjectCreate
(
%GeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
closure
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return ?
DefineMethodProperty
(
object
,
propKey
,
closure
,
enumerable
).
AsyncGeneratorMethod
:
async
*
ClassElementName
(
UniqueFormalParameters
)
{
AsyncGeneratorBody
}
Let
propKey
be ?
Evaluation
of
ClassElementName
.
Let
env
be the
running execution context
's LexicalEnvironment.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncGeneratorMethod
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncGeneratorFunction.prototype%
,
sourceText
,
UniqueFormalParameters
,
AsyncGeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
MakeMethod
(
closure
,
object
).
Perform
SetFunctionName
(
closure
,
propKey
).
Let
prototype
be
OrdinaryObjectCreate
(
%AsyncGeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
closure
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return ?
DefineMethodProperty
(
object
,
propKey
,
closure
,
enumerable
).
AsyncMethod
:
async
ClassElementName
(
UniqueFormalParameters
)
{
AsyncFunctionBody
}
Let
propKey
be ?
Evaluation
of
ClassElementName
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncMethod
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncFunction.prototype%
,
sourceText
,
UniqueFormalParameters
,
AsyncFunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
MakeMethod
(
closure
,
object
).
Perform
SetFunctionName
(
closure
,
propKey
).
Return ?
DefineMethodProperty
(
object
,
propKey
,
closure
,
enumerable
).
15.5
Generator Function Definitions
Syntax
GeneratorDeclaration
[Yield, Await, Default]
:
function
*
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
[+Default]
function
*
(
FormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
GeneratorExpression
:
function
*
BindingIdentifier
[+Yield, ~Await]
opt
(
FormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
GeneratorMethod
[Yield, Await]
:
*
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
GeneratorBody
:
FunctionBody
[+Yield, ~Await]
YieldExpression
[In, Await]
:
yield
yield
[no
LineTerminator
here]
AssignmentExpression
[?In, +Yield, ?Await]
yield
[no
LineTerminator
here]
*
AssignmentExpression
[?In, +Yield, ?Await]
Note 1
The syntactic context immediately following
yield
requires use of the
InputElementRegExpOrTemplateTail
lexical goal.
Note 2
YieldExpression
cannot be used within the
FormalParameters
of a generator function because any expressions that are part of
FormalParameters
are evaluated before the resulting Generator is in a resumable state.
Note 3
Abstract operations
relating to Generators are defined in
27.5.3
.
15.5.1
Static Semantics: Early Errors
GeneratorMethod
:
*
ClassElementName
(
UniqueFormalParameters
)
{
GeneratorBody
}
It is a Syntax Error if
HasDirectSuper
of
GeneratorMethod
is
true
.
It is a Syntax Error if
UniqueFormalParameters
Contains
YieldExpression
is
true
.
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
GeneratorBody
is
true
and
IsSimpleParameterList
of
UniqueFormalParameters
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
UniqueFormalParameters
also occurs in the
LexicallyDeclaredNames
of
GeneratorBody
.
GeneratorDeclaration
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
function
*
(
FormalParameters
)
{
GeneratorBody
}
GeneratorExpression
:
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
GeneratorBody
}
If
IsStrict
(
FormalParameters
) is
true
, the Early Error rules for
UniqueFormalParameters
:
FormalParameters
are applied.
If
BindingIdentifier
is present and
IsStrict
(
BindingIdentifier
) is
true
, it is a Syntax Error if the
StringValue
of
BindingIdentifier
is either
"eval"
or
"arguments"
.
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
GeneratorBody
is
true
and
IsSimpleParameterList
of
FormalParameters
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
FormalParameters
also occurs in the
LexicallyDeclaredNames
of
GeneratorBody
.
It is a Syntax Error if
FormalParameters
Contains
YieldExpression
is
true
.
It is a Syntax Error if
FormalParameters
Contains
SuperProperty
is
true
.
It is a Syntax Error if
GeneratorBody
Contains
SuperProperty
is
true
.
It is a Syntax Error if
FormalParameters
Contains
SuperCall
is
true
.
It is a Syntax Error if
GeneratorBody
Contains
SuperCall
is
true
.
15.5.2
Runtime Semantics: EvaluateGeneratorBody
The
syntax-directed operation
EvaluateGeneratorBody takes arguments
functionObject
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
throw completion
or a
return completion
. It is defined piecewise over the following productions:
GeneratorBody
:
FunctionBody
Perform ?
FunctionDeclarationInstantiation
(
functionObject
,
argumentsList
).
Let
G
be ?
OrdinaryCreateFromConstructor
(
functionObject
,
"%GeneratorPrototype%"
, «
[[GeneratorState]]
,
[[GeneratorContext]]
,
[[GeneratorBrand]]
»).
Set
G
.
[[GeneratorBrand]]
to
empty
.
Set
G
.
[[GeneratorState]]
to
suspended-start
.
Perform
GeneratorStart
(
G
,
FunctionBody
).
Return
ReturnCompletion
(
G
).
15.5.3
Runtime Semantics: InstantiateGeneratorFunctionObject
The
syntax-directed operation
InstantiateGeneratorFunctionObject takes arguments
env
(an
Environment Record
) and
privateEnv
(a
PrivateEnvironment Record
or
null
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
GeneratorDeclaration
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
Let
name
be the
StringValue
of
BindingIdentifier
.
Let
sourceText
be the
source text matched by
GeneratorDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%GeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
GeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
name
).
Let
prototype
be
OrdinaryObjectCreate
(
%GeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
F
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
F
.
GeneratorDeclaration
:
function
*
(
FormalParameters
)
{
GeneratorBody
}
Let
sourceText
be the
source text matched by
GeneratorDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%GeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
GeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
"default"
).
Let
prototype
be
OrdinaryObjectCreate
(
%GeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
F
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
F
.
Note
An anonymous
GeneratorDeclaration
can only occur as part of an
export default
declaration, and its function code is therefore always
strict mode code
.
15.5.4
Runtime Semantics: InstantiateGeneratorFunctionExpression
The
syntax-directed operation
InstantiateGeneratorFunctionExpression takes optional argument
name
(a
property key
or a
Private Name
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
GeneratorExpression
:
function
*
(
FormalParameters
)
{
GeneratorBody
}
If
name
is not present, set
name
to
""
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
GeneratorExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%GeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
GeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Let
prototype
be
OrdinaryObjectCreate
(
%GeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
closure
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
closure
.
GeneratorExpression
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
Assert
:
name
is not present.
Set
name
to the
StringValue
of
BindingIdentifier
.
Let
outerEnv
be the
running execution context
's LexicalEnvironment.
Let
funcEnv
be
NewDeclarativeEnvironment
(
outerEnv
).
Perform !
funcEnv
.
CreateImmutableBinding
(
name
,
false
).
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
GeneratorExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%GeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
GeneratorBody
,
non-lexical-this
,
funcEnv
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Let
prototype
be
OrdinaryObjectCreate
(
%GeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
closure
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Perform !
funcEnv
.
InitializeBinding
(
name
,
closure
).
Return
closure
.
Note
The
BindingIdentifier
in a
GeneratorExpression
can be referenced from inside the
GeneratorExpression
's
FunctionBody
to allow the generator code to call itself recursively. However, unlike in a
GeneratorDeclaration
, the
BindingIdentifier
in a
GeneratorExpression
cannot be referenced from and does not affect the scope enclosing the
GeneratorExpression
.
15.5.5
Runtime Semantics: Evaluation
GeneratorExpression
:
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
GeneratorBody
}
Return
InstantiateGeneratorFunctionExpression
of
GeneratorExpression
.
YieldExpression
:
yield
Return ?
Yield
(
undefined
).
YieldExpression
:
yield
AssignmentExpression
Let
exprRef
be ?
Evaluation
of
AssignmentExpression
.
Let
value
be ?
GetValue
(
exprRef
).
Return ?
Yield
(
value
).
YieldExpression
:
yield
*
AssignmentExpression
Let
generatorKind
be
GetGeneratorKind
().
Assert
:
generatorKind
is either
sync
or
async
.
Let
exprRef
be ?
Evaluation
of
AssignmentExpression
.
Let
value
be ?
GetValue
(
exprRef
).
Let
iteratorRecord
be ?
GetIterator
(
value
,
generatorKind
).
Let
iterator
be
iteratorRecord
.
[[Iterator]]
.
Let
received
be
NormalCompletion
(
undefined
).
Repeat,
If
received
is a
normal completion
, then
Let
innerResult
be ?
Call
(
iteratorRecord
.
[[NextMethod]]
,
iteratorRecord
.
[[Iterator]]
, «
received
.
[[Value]]
»).
If
generatorKind
is
async
, set
innerResult
to ?
Await
(
innerResult
).
If
innerResult
is not an Object
, throw a
TypeError
exception.
Let
done
be ?
IteratorComplete
(
innerResult
).
If
done
is
true
, then
Return ?
IteratorValue
(
innerResult
).
If
generatorKind
is
async
, set
received
to
Completion
(
AsyncGeneratorYield
(?
IteratorValue
(
innerResult
))).
Else, set
received
to
Completion
(
GeneratorYield
(
innerResult
)).
Else if
received
is a
throw completion
, then
Let
throw
be ?
GetMethod
(
iterator
,
"throw"
).
If
throw
is not
undefined
, then
Let
innerResult
be ?
Call
(
throw
,
iterator
, «
received
.
[[Value]]
»).
If
generatorKind
is
async
, set
innerResult
to ?
Await
(
innerResult
).
NOTE: Exceptions from the inner
iterator
throw
method are propagated.
Normal completions
from an inner
throw
method are processed similarly to an inner
next
.
If
innerResult
is not an Object
, throw a
TypeError
exception.
Let
done
be ?
IteratorComplete
(
innerResult
).
If
done
is
true
, then
Return ?
IteratorValue
(
innerResult
).
If
generatorKind
is
async
, set
received
to
Completion
(
AsyncGeneratorYield
(?
IteratorValue
(
innerResult
))).
Else, set
received
to
Completion
(
GeneratorYield
(
innerResult
)).
Else,
NOTE: If
iterator
does not have a
throw
method, this throw is going to terminate the
yield*
loop. But first we need to give
iterator
a chance to clean up.
Let
closeCompletion
be
NormalCompletion
(
empty
).
If
generatorKind
is
async
, perform ?
AsyncIteratorClose
(
iteratorRecord
,
closeCompletion
).
Else, perform ?
IteratorClose
(
iteratorRecord
,
closeCompletion
).
NOTE: The next step throws a
TypeError
to indicate that there was a
yield*
protocol violation:
iterator
does not have a
throw
method.
Throw a
TypeError
exception.
Else,
Assert
:
received
is a
return completion
.
Let
return
be ?
GetMethod
(
iterator
,
"return"
).
If
return
is
undefined
, then
Let
receivedValue
be
received
.
[[Value]]
.
If
generatorKind
is
async
, then
Set
receivedValue
to ?
Await
(
receivedValue
).
Return
ReturnCompletion
(
receivedValue
).
Let
innerReturnResult
be ?
Call
(
return
,
iterator
, «
received
.
[[Value]]
»).
If
generatorKind
is
async
, set
innerReturnResult
to ?
Await
(
innerReturnResult
).
If
innerReturnResult
is not an Object
, throw a
TypeError
exception.
Let
done
be ?
IteratorComplete
(
innerReturnResult
).
If
done
is
true
, then
Let
returnedValue
be ?
IteratorValue
(
innerReturnResult
).
Return
ReturnCompletion
(
returnedValue
).
If
generatorKind
is
async
, set
received
to
Completion
(
AsyncGeneratorYield
(?
IteratorValue
(
innerReturnResult
))).
Else, set
received
to
Completion
(
GeneratorYield
(
innerReturnResult
)).
15.6
Async Generator Function Definitions
Syntax
AsyncGeneratorDeclaration
[Yield, Await, Default]
:
async
[no
LineTerminator
here]
function
*
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
[+Default]
async
[no
LineTerminator
here]
function
*
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorExpression
:
async
[no
LineTerminator
here]
function
*
BindingIdentifier
[+Yield, +Await]
opt
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorMethod
[Yield, Await]
:
async
[no
LineTerminator
here]
*
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorBody
:
FunctionBody
[+Yield, +Await]
Note 1
YieldExpression
and
AwaitExpression
cannot be used within the
FormalParameters
of an async generator function because any expressions that are part of
FormalParameters
are evaluated before the resulting AsyncGenerator is in a resumable state.
Note 2
Abstract operations
relating to AsyncGenerators are defined in
27.6.3
.
15.6.1
Static Semantics: Early Errors
AsyncGeneratorMethod
:
async
*
ClassElementName
(
UniqueFormalParameters
)
{
AsyncGeneratorBody
}
It is a Syntax Error if
HasDirectSuper
of
AsyncGeneratorMethod
is
true
.
It is a Syntax Error if
UniqueFormalParameters
Contains
YieldExpression
is
true
.
It is a Syntax Error if
UniqueFormalParameters
Contains
AwaitExpression
is
true
.
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
AsyncGeneratorBody
is
true
and
IsSimpleParameterList
of
UniqueFormalParameters
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
UniqueFormalParameters
also occurs in the
LexicallyDeclaredNames
of
AsyncGeneratorBody
.
AsyncGeneratorDeclaration
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncGeneratorExpression
:
async
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncGeneratorBody
}
If
IsStrict
(
FormalParameters
) is
true
, the Early Error rules for
UniqueFormalParameters
:
FormalParameters
are applied.
If
BindingIdentifier
is present and
IsStrict
(
BindingIdentifier
) is
true
, it is a Syntax Error if the
StringValue
of
BindingIdentifier
is either
"eval"
or
"arguments"
.
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
AsyncGeneratorBody
is
true
and
IsSimpleParameterList
of
FormalParameters
is
false
.
It is a Syntax Error if any element of the
BoundNames
of
FormalParameters
also occurs in the
LexicallyDeclaredNames
of
AsyncGeneratorBody
.
It is a Syntax Error if
FormalParameters
Contains
YieldExpression
is
true
.
It is a Syntax Error if
FormalParameters
Contains
AwaitExpression
is
true
.
It is a Syntax Error if
FormalParameters
Contains
SuperProperty
is
true
.
It is a Syntax Error if
AsyncGeneratorBody
Contains
SuperProperty
is
true
.
It is a Syntax Error if
FormalParameters
Contains
SuperCall
is
true
.
It is a Syntax Error if
AsyncGeneratorBody
Contains
SuperCall
is
true
.
15.6.2
Runtime Semantics: EvaluateAsyncGeneratorBody
The
syntax-directed operation
EvaluateAsyncGeneratorBody takes arguments
functionObject
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
throw completion
or a
return completion
. It is defined piecewise over the following productions:
AsyncGeneratorBody
:
FunctionBody
Perform ?
FunctionDeclarationInstantiation
(
functionObject
,
argumentsList
).
Let
generator
be ?
OrdinaryCreateFromConstructor
(
functionObject
,
"%AsyncGeneratorPrototype%"
, «
[[AsyncGeneratorState]]
,
[[AsyncGeneratorContext]]
,
[[AsyncGeneratorQueue]]
,
[[GeneratorBrand]]
»).
Set
generator
.
[[GeneratorBrand]]
to
empty
.
Set
generator
.
[[AsyncGeneratorState]]
to
suspended-start
.
Perform
AsyncGeneratorStart
(
generator
,
FunctionBody
).
Return
ReturnCompletion
(
generator
).
15.6.3
Runtime Semantics: InstantiateAsyncGeneratorFunctionObject
The
syntax-directed operation
InstantiateAsyncGeneratorFunctionObject takes arguments
env
(an
Environment Record
) and
privateEnv
(a
PrivateEnvironment Record
or
null
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
AsyncGeneratorDeclaration
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
Let
name
be the
StringValue
of
BindingIdentifier
.
Let
sourceText
be the
source text matched by
AsyncGeneratorDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%AsyncGeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncGeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
name
).
Let
prototype
be
OrdinaryObjectCreate
(
%AsyncGeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
F
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
F
.
AsyncGeneratorDeclaration
:
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
Let
sourceText
be the
source text matched by
AsyncGeneratorDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%AsyncGeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncGeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
"default"
).
Let
prototype
be
OrdinaryObjectCreate
(
%AsyncGeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
F
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
F
.
Note
An anonymous
AsyncGeneratorDeclaration
can only occur as part of an
export default
declaration.
15.6.4
Runtime Semantics: InstantiateAsyncGeneratorFunctionExpression
The
syntax-directed operation
InstantiateAsyncGeneratorFunctionExpression takes optional argument
name
(a
property key
or a
Private Name
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
AsyncGeneratorExpression
:
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
If
name
is not present, set
name
to
""
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncGeneratorExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncGeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncGeneratorBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Let
prototype
be
OrdinaryObjectCreate
(
%AsyncGeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
closure
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
closure
.
AsyncGeneratorExpression
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
Assert
:
name
is not present.
Set
name
to the
StringValue
of
BindingIdentifier
.
Let
outerEnv
be the
running execution context
's LexicalEnvironment.
Let
funcEnv
be
NewDeclarativeEnvironment
(
outerEnv
).
Perform !
funcEnv
.
CreateImmutableBinding
(
name
,
false
).
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncGeneratorExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncGeneratorFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncGeneratorBody
,
non-lexical-this
,
funcEnv
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Let
prototype
be
OrdinaryObjectCreate
(
%AsyncGeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
closure
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Perform !
funcEnv
.
InitializeBinding
(
name
,
closure
).
Return
closure
.
Note
The
BindingIdentifier
in an
AsyncGeneratorExpression
can be referenced from inside the
AsyncGeneratorExpression
's
AsyncGeneratorBody
to allow the generator code to call itself recursively. However, unlike in an
AsyncGeneratorDeclaration
, the
BindingIdentifier
in an
AsyncGeneratorExpression
cannot be referenced from and does not affect the scope enclosing the
AsyncGeneratorExpression
.
15.6.5
Runtime Semantics: Evaluation
AsyncGeneratorExpression
:
async
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncGeneratorBody
}
Return
InstantiateAsyncGeneratorFunctionExpression
of
AsyncGeneratorExpression
.
15.7
Class Definitions
Syntax
ClassDeclaration
[Yield, Await, Default]
:
class
BindingIdentifier
[?Yield, ?Await]
ClassTail
[?Yield, ?Await]
[+Default]
class
ClassTail
[?Yield, ?Await]
ClassExpression
[Yield, Await]
:
class
BindingIdentifier
[?Yield, ?Await]
opt
ClassTail
[?Yield, ?Await]
ClassTail
[Yield, Await]
:
ClassHeritage
[?Yield, ?Await]
opt
{
ClassBody
[?Yield, ?Await]
opt
}
ClassHeritage
[Yield, Await]
:
extends
LeftHandSideExpression
[?Yield, ?Await]
ClassBody
[Yield, Await]
:
ClassElementList
[?Yield, ?Await]
ClassElementList
[Yield, Await]
:
ClassElement
[?Yield, ?Await]
ClassElementList
[?Yield, ?Await]
ClassElement
[?Yield, ?Await]
ClassElement
[Yield, Await]
:
MethodDefinition
[?Yield, ?Await]
static
MethodDefinition
[?Yield, ?Await]
FieldDefinition
[?Yield, ?Await]
;
static
FieldDefinition
[?Yield, ?Await]
;
ClassStaticBlock
;
FieldDefinition
[Yield, Await]
:
ClassElementName
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
ClassElementName
[Yield, Await]
:
PropertyName
[?Yield, ?Await]
PrivateIdentifier
ClassStaticBlock
:
static
{
ClassStaticBlockBody
}
ClassStaticBlockBody
:
ClassStaticBlockStatementList
ClassStaticBlockStatementList
:
StatementList
[~Yield, +Await, ~Return]
opt
Note
A class definition is always
strict mode code
.
15.7.1
Static Semantics: Early Errors
ClassTail
:
ClassHeritage
opt
{
ClassBody
}
It is a Syntax Error if
ClassHeritage
is not present and the following algorithm returns
true
:
Let
constructor
be the
ConstructorMethod
of
ClassBody
.
If
constructor
is
empty
, return
false
.
Return
HasDirectSuper
of
constructor
.
ClassBody
:
ClassElementList
It is a Syntax Error if the
PrototypePropertyNameList
of
ClassElementList
contains more than one occurrence of
"constructor"
.
It is a Syntax Error if the
PrivateBoundIdentifiers
of
ClassElementList
contains any duplicate entries, unless the name is used once for a getter and once for a setter and in no other entries, and the getter and setter are either both static or both non-static.
ClassElement
:
MethodDefinition
It is a Syntax Error if the
PropName
of
MethodDefinition
is not
"constructor"
and
HasDirectSuper
of
MethodDefinition
is
true
.
It is a Syntax Error if the
PropName
of
MethodDefinition
is
"constructor"
and
SpecialMethod
of
MethodDefinition
is
true
.
ClassElement
:
static
MethodDefinition
It is a Syntax Error if
HasDirectSuper
of
MethodDefinition
is
true
.
It is a Syntax Error if the
PropName
of
MethodDefinition
is
"prototype"
.
ClassElement
:
FieldDefinition
;
It is a Syntax Error if the
PropName
of
FieldDefinition
is
"constructor"
.
ClassElement
:
static
FieldDefinition
;
It is a Syntax Error if the
PropName
of
FieldDefinition
is either
"prototype"
or
"constructor"
.
FieldDefinition
:
ClassElementName
Initializer
opt
It is a Syntax Error if
Initializer
is present and
ContainsArguments
of
Initializer
is
true
.
It is a Syntax Error if
Initializer
is present and
Initializer
Contains
SuperCall
is
true
.
ClassElementName
:
PrivateIdentifier
It is a Syntax Error if the
StringValue
of
PrivateIdentifier
is
"#constructor"
.
ClassStaticBlockBody
:
ClassStaticBlockStatementList
It is a Syntax Error if the
LexicallyDeclaredNames
of
ClassStaticBlockStatementList
contains any duplicate entries.
It is a Syntax Error if any element of the
LexicallyDeclaredNames
of
ClassStaticBlockStatementList
also occurs in the
VarDeclaredNames
of
ClassStaticBlockStatementList
.
It is a Syntax Error if
ContainsDuplicateLabels
of
ClassStaticBlockStatementList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedBreakTarget
of
ClassStaticBlockStatementList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedContinueTarget
of
ClassStaticBlockStatementList
with arguments « » and « » is
true
.
It is a Syntax Error if
ContainsArguments
of
ClassStaticBlockStatementList
is
true
.
It is a Syntax Error if
ClassStaticBlockStatementList
Contains
SuperCall
is
true
.
It is a Syntax Error if
ClassStaticBlockStatementList
Contains
await
is
true
.
15.7.2
Static Semantics: ClassElementKind
The
syntax-directed operation
ClassElementKind takes no arguments and returns
constructor-method
,
non-constructor-method
, or
empty
. It is defined piecewise over the following productions:
ClassElement
:
MethodDefinition
If the
PropName
of
MethodDefinition
is
"constructor"
, return
constructor-method
.
Return
non-constructor-method
.
ClassElement
:
static
MethodDefinition
FieldDefinition
;
static
FieldDefinition
;
Return
non-constructor-method
.
ClassElement
:
ClassStaticBlock
Return
non-constructor-method
.
ClassElement
:
;
Return
empty
.
15.7.3
Static Semantics: ConstructorMethod
The
syntax-directed operation
ConstructorMethod takes no arguments and returns a
ClassElement
Parse Node
or
empty
. It is defined piecewise over the following productions:
ClassElementList
:
ClassElement
If the
ClassElementKind
of
ClassElement
is
constructor-method
, return
ClassElement
.
Return
empty
.
ClassElementList
:
ClassElementList
ClassElement
Let
head
be the
ConstructorMethod
of
ClassElementList
.
If
head
is not
empty
, return
head
.
If the
ClassElementKind
of
ClassElement
is
constructor-method
, return
ClassElement
.
Return
empty
.
Note
Early Error rules ensure that there is only one method definition named
"constructor"
and that it is not an
accessor property
or generator definition.
15.7.4
Static Semantics: IsStatic
The
syntax-directed operation
IsStatic takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
ClassElement
:
MethodDefinition
Return
false
.
ClassElement
:
static
MethodDefinition
Return
true
.
ClassElement
:
FieldDefinition
;
Return
false
.
ClassElement
:
static
FieldDefinition
;
Return
true
.
ClassElement
:
ClassStaticBlock
Return
true
.
ClassElement
:
;
Return
false
.
15.7.5
Static Semantics: NonConstructorElements
The
syntax-directed operation
NonConstructorElements takes no arguments and returns a
List
of
ClassElement
Parse Nodes
. It is defined piecewise over the following productions:
ClassElementList
:
ClassElement
If the
ClassElementKind
of
ClassElement
is
non-constructor-method
, then
Return «
ClassElement
».
Return a new empty
List
.
ClassElementList
:
ClassElementList
ClassElement
Let
list
be the
NonConstructorElements
of
ClassElementList
.
If the
ClassElementKind
of
ClassElement
is
non-constructor-method
, then
Append
ClassElement
to
list
.
Return
list
.
15.7.6
Static Semantics: PrototypePropertyNameList
The
syntax-directed operation
PrototypePropertyNameList takes no arguments and returns a
List
of
property keys
. It is defined piecewise over the following productions:
ClassElementList
:
ClassElement
Let
propName
be the
PropName
of
ClassElement
.
If
propName
is
empty
, return a new empty
List
.
If
IsStatic
of
ClassElement
is
true
, return a new empty
List
.
Return «
propName
».
ClassElementList
:
ClassElementList
ClassElement
Let
list
be the
PrototypePropertyNameList
of
ClassElementList
.
Let
propName
be the
PropName
of
ClassElement
.
If
propName
is
empty
, return
list
.
If
IsStatic
of
ClassElement
is
true
, return
list
.
Return the
list-concatenation
of
list
and «
propName
».
15.7.7
Static Semantics: AllPrivateIdentifiersValid
The
syntax-directed operation
AllPrivateIdentifiersValid takes argument
names
(a
List
of Strings) and returns a Boolean.
Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of AllPrivateIdentifiersValid:
For each child node
child
of this
Parse Node
, do
If
child
is an instance of a nonterminal, then
If
AllPrivateIdentifiersValid
of
child
with argument
names
is
false
, return
false
.
Return
true
.
MemberExpression
:
MemberExpression
.
PrivateIdentifier
If
names
contains the
StringValue
of
PrivateIdentifier
, then
Return
AllPrivateIdentifiersValid
of
MemberExpression
with argument
names
.
Return
false
.
CallExpression
:
CallExpression
.
PrivateIdentifier
If
names
contains the
StringValue
of
PrivateIdentifier
, then
Return
AllPrivateIdentifiersValid
of
CallExpression
with argument
names
.
Return
false
.
OptionalChain
:
?.
PrivateIdentifier
If
names
contains the
StringValue
of
PrivateIdentifier
, return
true
.
Return
false
.
OptionalChain
:
OptionalChain
.
PrivateIdentifier
If
names
contains the
StringValue
of
PrivateIdentifier
, then
Return
AllPrivateIdentifiersValid
of
OptionalChain
with argument
names
.
Return
false
.
ClassBody
:
ClassElementList
Let
newNames
be the
list-concatenation
of
names
and the
PrivateBoundIdentifiers
of
ClassBody
.
Return
AllPrivateIdentifiersValid
of
ClassElementList
with argument
newNames
.
RelationalExpression
:
PrivateIdentifier
in
ShiftExpression
If
names
contains the
StringValue
of
PrivateIdentifier
, then
Return
AllPrivateIdentifiersValid
of
ShiftExpression
with argument
names
.
Return
false
.
15.7.8
Static Semantics: PrivateBoundIdentifiers
The
syntax-directed operation
PrivateBoundIdentifiers takes no arguments and returns a
List
of Strings. It is defined piecewise over the following productions:
FieldDefinition
:
ClassElementName
Initializer
opt
Return the
PrivateBoundIdentifiers
of
ClassElementName
.
ClassElementName
:
PrivateIdentifier
Return a
List
whose sole element is the
StringValue
of
PrivateIdentifier
.
ClassElementName
:
PropertyName
ClassElement
:
ClassStaticBlock
;
Return a new empty
List
.
ClassElementList
:
ClassElementList
ClassElement
Let
names1
be the
PrivateBoundIdentifiers
of
ClassElementList
.
Let
names2
be the
PrivateBoundIdentifiers
of
ClassElement
.
Return the
list-concatenation
of
names1
and
names2
.
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
get
ClassElementName
(
)
{
FunctionBody
}
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
GeneratorMethod
:
*
ClassElementName
(
UniqueFormalParameters
)
{
GeneratorBody
}
AsyncMethod
:
async
ClassElementName
(
UniqueFormalParameters
)
{
AsyncFunctionBody
}
AsyncGeneratorMethod
:
async
*
ClassElementName
(
UniqueFormalParameters
)
{
AsyncGeneratorBody
}
Return the
PrivateBoundIdentifiers
of
ClassElementName
.
15.7.9
Static Semantics: ContainsArguments
The
syntax-directed operation
ContainsArguments takes no arguments and returns a Boolean.
Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of ContainsArguments:
For each child node
child
of this
Parse Node
, do
If
child
is an instance of a nonterminal, then
If
ContainsArguments
of
child
is
true
, return
true
.
Return
false
.
IdentifierReference
:
Identifier
If the
StringValue
of
Identifier
is
"arguments"
, return
true
.
Return
false
.
FunctionDeclaration
:
function
BindingIdentifier
(
FormalParameters
)
{
FunctionBody
}
function
(
FormalParameters
)
{
FunctionBody
}
FunctionExpression
:
function
BindingIdentifier
opt
(
FormalParameters
)
{
FunctionBody
}
GeneratorDeclaration
:
function
*
BindingIdentifier
(
FormalParameters
)
{
GeneratorBody
}
function
*
(
FormalParameters
)
{
GeneratorBody
}
GeneratorExpression
:
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
GeneratorBody
}
AsyncGeneratorDeclaration
:
async
function
*
BindingIdentifier
(
FormalParameters
)
{
AsyncGeneratorBody
}
async
function
*
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncGeneratorExpression
:
async
function
*
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncGeneratorBody
}
AsyncFunctionDeclaration
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
AsyncFunctionExpression
:
async
function
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncFunctionBody
}
Return
false
.
MethodDefinition
:
ClassElementName
(
UniqueFormalParameters
)
{
FunctionBody
}
get
ClassElementName
(
)
{
FunctionBody
}
set
ClassElementName
(
PropertySetParameterList
)
{
FunctionBody
}
GeneratorMethod
:
*
ClassElementName
(
UniqueFormalParameters
)
{
GeneratorBody
}
AsyncGeneratorMethod
:
async
*
ClassElementName
(
UniqueFormalParameters
)
{
AsyncGeneratorBody
}
AsyncMethod
:
async
ClassElementName
(
UniqueFormalParameters
)
{
AsyncFunctionBody
}
Return
ContainsArguments
of
ClassElementName
.
15.7.10
Runtime Semantics: ClassFieldDefinitionEvaluation
The
syntax-directed operation
ClassFieldDefinitionEvaluation takes argument
homeObject
(an Object) and returns either a
normal completion containing
a
ClassFieldDefinition Record
or an
abrupt completion
. It is defined piecewise over the following productions:
FieldDefinition
:
ClassElementName
Initializer
opt
Let
name
be ?
Evaluation
of
ClassElementName
.
If
Initializer
is present, then
Let
formalParameterList
be an instance of the production
FormalParameters
:
[empty]
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the empty sequence of Unicode code points.
Let
initializer
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
formalParameterList
,
Initializer
,
non-lexical-this
,
env
,
privateEnv
).
Perform
MakeMethod
(
initializer
,
homeObject
).
Set
initializer
.
[[ClassFieldInitializerName]]
to
name
.
Else,
Let
initializer
be
empty
.
Return the
ClassFieldDefinition Record
{
[[Name]]
:
name
,
[[Initializer]]
:
initializer
}.
Note
The function created for
initializer
is never directly accessible to ECMAScript code.
15.7.11
Runtime Semantics: ClassStaticBlockDefinitionEvaluation
The
syntax-directed operation
ClassStaticBlockDefinitionEvaluation takes argument
homeObject
(an Object) and returns a
ClassStaticBlockDefinition Record
. It is defined piecewise over the following productions:
ClassStaticBlock
:
static
{
ClassStaticBlockBody
}
Let
lex
be the
running execution context
's LexicalEnvironment.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the empty sequence of Unicode code points.
Let
formalParameters
be an instance of the production
FormalParameters
:
[empty]
.
Let
bodyFunction
be
OrdinaryFunctionCreate
(
%Function.prototype%
,
sourceText
,
formalParameters
,
ClassStaticBlockBody
,
non-lexical-this
,
lex
,
privateEnv
).
Perform
MakeMethod
(
bodyFunction
,
homeObject
).
Return the
ClassStaticBlockDefinition Record
{
[[BodyFunction]]
:
bodyFunction
}.
Note
The function
bodyFunction
is never directly accessible to ECMAScript code.
15.7.12
Runtime Semantics: EvaluateClassStaticBlockBody
The
syntax-directed operation
EvaluateClassStaticBlockBody takes argument
functionObject
(an ECMAScript
function object
) and returns a
return completion
or a
throw completion
. It is defined piecewise over the following productions:
ClassStaticBlockBody
:
ClassStaticBlockStatementList
Assert
:
functionObject
is a synthetic function created by
ClassStaticBlockDefinitionEvaluation
step
5
.
Perform !
FunctionDeclarationInstantiation
(
functionObject
, « »).
Perform ?
Evaluation
of
ClassStaticBlockStatementList
.
Return
ReturnCompletion
(
undefined
).
15.7.13
Runtime Semantics: ClassElementEvaluation
The
syntax-directed operation
ClassElementEvaluation takes argument
object
(an Object) and returns either a
normal completion containing
either a
ClassFieldDefinition Record
, a
ClassStaticBlockDefinition Record
, a
PrivateElement
, or
unused
, or an
abrupt completion
. It is defined piecewise over the following productions:
ClassElement
:
FieldDefinition
;
static
FieldDefinition
;
Return ?
ClassFieldDefinitionEvaluation
of
FieldDefinition
with argument
object
.
ClassElement
:
MethodDefinition
static
MethodDefinition
Return ?
MethodDefinitionEvaluation
of
MethodDefinition
with arguments
object
and
false
.
ClassElement
:
ClassStaticBlock
Return the
ClassStaticBlockDefinitionEvaluation
of
ClassStaticBlock
with argument
object
.
ClassElement
:
;
Return
unused
.
15.7.14
Runtime Semantics: ClassDefinitionEvaluation
The
syntax-directed operation
ClassDefinitionEvaluation takes arguments
classBinding
(a String or
undefined
),
className
(a
property key
or a
Private Name
), and
sourceText
(
ECMAScript source text
) and returns either a
normal completion containing
a
function object
or an
abrupt completion
.
Note
For ease of specification, private methods and accessors are included alongside private fields in the
[[PrivateElements]]
slot of class instances. However, any given object has either all or none of the private methods and accessors defined by a given class. This feature has been designed so that implementations may choose to implement private methods and accessors using a strategy which does not require tracking each method or accessor individually.
For example, an implementation could directly associate instance private methods with their corresponding
Private Name
and track, for each object, which class
constructors
have run with that object as their
this
value. Looking up an instance private method on an object then consists of checking that the class
constructor
which defines the method has been used to initialize the object, then returning the method associated with the
Private Name
.
This differs from private fields: because field initializers can throw during class instantiation, an individual object may have some proper subset of the private fields of a given class, and so private fields must in general be tracked individually.
It is defined piecewise over the following productions:
ClassTail
:
ClassHeritage
opt
{
ClassBody
opt
}
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
classEnv
be
NewDeclarativeEnvironment
(
env
).
If
classBinding
is not
undefined
, then
Perform !
classEnv
.
CreateImmutableBinding
(
classBinding
,
true
).
Let
outerPrivateEnvironment
be the
running execution context
's PrivateEnvironment.
Let
classPrivateEnvironment
be
NewPrivateEnvironment
(
outerPrivateEnvironment
).
If
ClassBody
is present, then
For each String
dn
of the
PrivateBoundIdentifiers
of
ClassBody
, do
If
classPrivateEnvironment
.
[[Names]]
contains a
Private Name
pn
such that
pn
.
[[Description]]
is
dn
, then
Assert
: This is only possible for getter/setter pairs.
Else,
Let
name
be a new
Private Name
whose
[[Description]]
is
dn
.
Append
name
to
classPrivateEnvironment
.
[[Names]]
.
If
ClassHeritage
is not present, then
Let
protoParent
be
%Object.prototype%
.
Let
constructorParent
be
%Function.prototype%
.
Else,
Set the
running execution context
's LexicalEnvironment to
classEnv
.
NOTE: The
running execution context
's PrivateEnvironment is
outerPrivateEnvironment
when evaluating
ClassHeritage
.
Let
superclassRef
be
Completion
(
Evaluation
of
ClassHeritage
).
Set the
running execution context
's LexicalEnvironment to
env
.
Let
superclass
be ?
GetValue
(?
superclassRef
).
If
superclass
is
null
, then
Let
protoParent
be
null
.
Let
constructorParent
be
%Function.prototype%
.
Else if
IsConstructor
(
superclass
) is
false
, then
Throw a
TypeError
exception.
Else,
Let
protoParent
be ?
Get
(
superclass
,
"prototype"
).
If
protoParent
is not an Object
and
protoParent
is not
null
, throw a
TypeError
exception.
Let
constructorParent
be
superclass
.
Let
proto
be
OrdinaryObjectCreate
(
protoParent
).
If
ClassBody
is not present, let
constructor
be
empty
.
Else, let
constructor
be the
ConstructorMethod
of
ClassBody
.
Set the
running execution context
's LexicalEnvironment to
classEnv
.
Set the
running execution context
's PrivateEnvironment to
classPrivateEnvironment
.
If
constructor
is
empty
, then
Let
defaultConstructor
be a new
Abstract Closure
with no parameters that captures nothing and performs the following steps when called:
Let
args
be the
List
of arguments that was passed to this function by
[[Call]]
or
[[Construct]]
.
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
F
be the
active function object
.
If
F
.
[[ConstructorKind]]
is
derived
, then
NOTE: This branch behaves similarly to
constructor(...args) { super(...args); }
. The most notable distinction is that while the aforementioned
ECMAScript source text
observably calls the
%Symbol.iterator%
method on
%Array.prototype%
, this function does not.
Let
func
be !
F
.
[[GetPrototypeOf]]
().
If
IsConstructor
(
func
) is
false
, throw a
TypeError
exception.
Let
result
be ?
Construct
(
func
,
args
, NewTarget).
Else,
NOTE: This branch behaves similarly to
constructor() {}
.
Let
result
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Object.prototype%"
).
Perform ?
InitializeInstanceElements
(
result
,
F
).
Return
NormalCompletion
(
result
).
Let
F
be
CreateBuiltinFunction
(
defaultConstructor
, 0,
className
, «
[[ConstructorKind]]
,
[[SourceText]]
,
[[PrivateMethods]]
,
[[Fields]]
»,
the current Realm Record
,
constructorParent
).
Else,
Let
constructorInfo
be !
DefineMethod
of
constructor
with arguments
proto
and
constructorParent
.
Let
F
be
constructorInfo
.
[[Closure]]
.
Perform
MakeClassConstructor
(
F
).
Perform
SetFunctionName
(
F
,
className
).
Set
F
.
[[SourceText]]
to
sourceText
.
Perform
MakeConstructor
(
F
,
false
,
proto
).
If
ClassHeritage
is present, set
F
.
[[ConstructorKind]]
to
derived
.
Perform !
DefineMethodProperty
(
proto
,
"constructor"
,
F
,
false
).
If
ClassBody
is not present, let
elements
be a new empty
List
.
Else, let
elements
be the
NonConstructorElements
of
ClassBody
.
Let
instancePrivateMethods
be a new empty
List
.
Let
staticPrivateMethods
be a new empty
List
.
Let
instanceFields
be a new empty
List
.
Let
staticElements
be a new empty
List
.
For each
ClassElement
e
of
elements
, do
If
IsStatic
of
e
is
false
, then
Let
element
be
Completion
(
ClassElementEvaluation
of
e
with argument
proto
).
Else,
Let
element
be
Completion
(
ClassElementEvaluation
of
e
with argument
F
).
If
element
is an
abrupt completion
, then
Set the
running execution context
's LexicalEnvironment to
env
.
Set the
running execution context
's PrivateEnvironment to
outerPrivateEnvironment
.
Return ?
element
.
Set
element
to !
element
.
If
element
is a
PrivateElement
, then
Assert
:
element
.
[[Kind]]
is either
method
or
accessor
.
If
IsStatic
of
e
is
false
, let
container
be
instancePrivateMethods
.
Else, let
container
be
staticPrivateMethods
.
If
container
contains a
PrivateElement
pe
such that
pe
.
[[Key]]
is
element
.
[[Key]]
, then
Assert
:
element
.
[[Kind]]
and
pe
.
[[Kind]]
are both
accessor
.
If
element
.
[[Get]]
is
undefined
, then
Let
combined
be
PrivateElement
{
[[Key]]
:
element
.
[[Key]]
,
[[Kind]]
:
accessor
,
[[Get]]
:
pe
.
[[Get]]
,
[[Set]]
:
element
.
[[Set]]
}.
Else,
Let
combined
be
PrivateElement
{
[[Key]]
:
element
.
[[Key]]
,
[[Kind]]
:
accessor
,
[[Get]]
:
element
.
[[Get]]
,
[[Set]]
:
pe
.
[[Set]]
}.
Replace
pe
in
container
with
combined
.
Else,
Append
element
to
container
.
Else if
element
is a
ClassFieldDefinition Record
, then
If
IsStatic
of
e
is
false
, append
element
to
instanceFields
.
Else, append
element
to
staticElements
.
Else if
element
is a
ClassStaticBlockDefinition Record
, then
Append
element
to
staticElements
.
Set the
running execution context
's LexicalEnvironment to
env
.
If
classBinding
is not
undefined
, then
Perform !
classEnv
.
InitializeBinding
(
classBinding
,
F
).
Set
F
.
[[PrivateMethods]]
to
instancePrivateMethods
.
Set
F
.
[[Fields]]
to
instanceFields
.
For each
PrivateElement
method
of
staticPrivateMethods
, do
Perform !
PrivateMethodOrAccessorAdd
(
F
,
method
).
For each element
elementRecord
of
staticElements
, do
If
elementRecord
is a
ClassFieldDefinition Record
, then
Let
result
be
Completion
(
DefineField
(
F
,
elementRecord
)).
Else,
Assert
:
elementRecord
is a
ClassStaticBlockDefinition Record
.
Let
result
be
Completion
(
Call
(
elementRecord
.
[[BodyFunction]]
,
F
)).
If
result
is an
abrupt completion
, then
Set the
running execution context
's PrivateEnvironment to
outerPrivateEnvironment
.
Return ?
result
.
Set the
running execution context
's PrivateEnvironment to
outerPrivateEnvironment
.
Return
F
.
15.7.15
Runtime Semantics: BindingClassDeclarationEvaluation
The
syntax-directed operation
BindingClassDeclarationEvaluation takes no arguments and returns either a
normal completion containing
a
function object
or an
abrupt completion
. It is defined piecewise over the following productions:
ClassDeclaration
:
class
BindingIdentifier
ClassTail
Let
className
be the
StringValue
of
BindingIdentifier
.
Let
sourceText
be the
source text matched by
ClassDeclaration
.
Let
value
be ?
ClassDefinitionEvaluation
of
ClassTail
with arguments
className
,
className
, and
sourceText
.
Let
env
be the
running execution context
's LexicalEnvironment.
Perform ?
InitializeBoundName
(
className
,
value
,
env
).
Return
value
.
ClassDeclaration
:
class
ClassTail
Let
sourceText
be the
source text matched by
ClassDeclaration
.
Return ?
ClassDefinitionEvaluation
of
ClassTail
with arguments
undefined
,
"default"
, and
sourceText
.
Note
ClassDeclaration
:
class
ClassTail
only occurs as part of an
ExportDeclaration
and establishing its binding is handled as part of the evaluation action for that production. See
16.2.3.7
.
15.7.16
Runtime Semantics: Evaluation
ClassDeclaration
:
class
BindingIdentifier
ClassTail
Perform ?
BindingClassDeclarationEvaluation
of this
ClassDeclaration
.
Return
empty
.
Note
ClassDeclaration
:
class
ClassTail
only occurs as part of an
ExportDeclaration
and is never directly evaluated.
ClassExpression
:
class
ClassTail
Let
sourceText
be the
source text matched by
ClassExpression
.
Return ?
ClassDefinitionEvaluation
of
ClassTail
with arguments
undefined
,
""
, and
sourceText
.
ClassExpression
:
class
BindingIdentifier
ClassTail
Let
className
be the
StringValue
of
BindingIdentifier
.
Let
sourceText
be the
source text matched by
ClassExpression
.
Return ?
ClassDefinitionEvaluation
of
ClassTail
with arguments
className
,
className
, and
sourceText
.
ClassElementName
:
PrivateIdentifier
Let
privateIdentifier
be the
StringValue
of
PrivateIdentifier
.
Let
privateEnvRec
be the
running execution context
's PrivateEnvironment.
Let
names
be
privateEnvRec
.
[[Names]]
.
Assert
: Exactly one element of
names
is a
Private Name
whose
[[Description]]
is
privateIdentifier
.
Let
privateName
be the
Private Name
in
names
whose
[[Description]]
is
privateIdentifier
.
Return
privateName
.
ClassStaticBlockStatementList
:
[empty]
Return
undefined
.
15.8
Async Function Definitions
Syntax
AsyncFunctionDeclaration
[Yield, Await, Default]
:
async
[no
LineTerminator
here]
function
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
[+Default]
async
[no
LineTerminator
here]
function
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncFunctionExpression
:
async
[no
LineTerminator
here]
function
BindingIdentifier
[~Yield, +Await]
opt
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncMethod
[Yield, Await]
:
async
[no
LineTerminator
here]
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncFunctionBody
:
FunctionBody
[~Yield, +Await]
AwaitExpression
[Yield]
:
await
UnaryExpression
[?Yield, +Await]
Note 1
await
is parsed as a
keyword
of an
AwaitExpression
when the
[Await]
parameter is present. The
[Await]
parameter is present in the top level of the following contexts, although the parameter may be absent in some contexts depending on the nonterminals, such as
FunctionBody
:
In an
AsyncFunctionBody
.
In the
FormalParameters
of an
AsyncFunctionDeclaration
,
AsyncFunctionExpression
,
AsyncGeneratorDeclaration
, or
AsyncGeneratorExpression
.
AwaitExpression
in this position is a Syntax error via
static semantics
.
In a
Module
.
When
Script
is the syntactic
goal symbol
,
await
may be parsed as an identifier when the
[Await]
parameter is absent. This includes the following contexts:
Anywhere outside of an
AsyncFunctionBody
or
FormalParameters
of an
AsyncFunctionDeclaration
,
AsyncFunctionExpression
,
AsyncGeneratorDeclaration
, or
AsyncGeneratorExpression
.
In the
BindingIdentifier
of a
FunctionExpression
,
GeneratorExpression
, or
AsyncGeneratorExpression
.
Note 2
Unlike
YieldExpression
, it is a Syntax Error to omit the operand of an
AwaitExpression
. You must await something.
15.8.1
Static Semantics: Early Errors
AsyncMethod
:
async
ClassElementName
(
UniqueFormalParameters
)
{
AsyncFunctionBody
}
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
AsyncFunctionBody
is
true
and
IsSimpleParameterList
of
UniqueFormalParameters
is
false
.
It is a Syntax Error if
HasDirectSuper
of
AsyncMethod
is
true
.
It is a Syntax Error if
UniqueFormalParameters
Contains
AwaitExpression
is
true
.
It is a Syntax Error if any element of the
BoundNames
of
UniqueFormalParameters
also occurs in the
LexicallyDeclaredNames
of
AsyncFunctionBody
.
AsyncFunctionDeclaration
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
AsyncFunctionExpression
:
async
function
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncFunctionBody
}
It is a Syntax Error if
FunctionBodyContainsUseStrict
of
AsyncFunctionBody
is
true
and
IsSimpleParameterList
of
FormalParameters
is
false
.
It is a Syntax Error if
FormalParameters
Contains
AwaitExpression
is
true
.
If
IsStrict
(
FormalParameters
) is
true
, the Early Error rules for
UniqueFormalParameters
:
FormalParameters
are applied.
If
BindingIdentifier
is present and
IsStrict
(
BindingIdentifier
) is
true
, it is a Syntax Error if the
StringValue
of
BindingIdentifier
is either
"eval"
or
"arguments"
.
It is a Syntax Error if any element of the
BoundNames
of
FormalParameters
also occurs in the
LexicallyDeclaredNames
of
AsyncFunctionBody
.
It is a Syntax Error if
FormalParameters
Contains
SuperProperty
is
true
.
It is a Syntax Error if
AsyncFunctionBody
Contains
SuperProperty
is
true
.
It is a Syntax Error if
FormalParameters
Contains
SuperCall
is
true
.
It is a Syntax Error if
AsyncFunctionBody
Contains
SuperCall
is
true
.
15.8.2
Runtime Semantics: InstantiateAsyncFunctionObject
The
syntax-directed operation
InstantiateAsyncFunctionObject takes arguments
env
(an
Environment Record
) and
privateEnv
(a
PrivateEnvironment Record
or
null
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
AsyncFunctionDeclaration
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
Let
name
be the
StringValue
of
BindingIdentifier
.
Let
sourceText
be the
source text matched by
AsyncFunctionDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%AsyncFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncFunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
name
).
Return
F
.
AsyncFunctionDeclaration
:
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
Let
sourceText
be the
source text matched by
AsyncFunctionDeclaration
.
Let
F
be
OrdinaryFunctionCreate
(
%AsyncFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncFunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
"default"
).
Return
F
.
15.8.3
Runtime Semantics: InstantiateAsyncFunctionExpression
The
syntax-directed operation
InstantiateAsyncFunctionExpression takes optional argument
name
(a
property key
or a
Private Name
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
AsyncFunctionExpression
:
async
function
(
FormalParameters
)
{
AsyncFunctionBody
}
If
name
is not present, set
name
to
""
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncFunctionExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncFunctionBody
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Return
closure
.
AsyncFunctionExpression
:
async
function
BindingIdentifier
(
FormalParameters
)
{
AsyncFunctionBody
}
Assert
:
name
is not present.
Set
name
to the
StringValue
of
BindingIdentifier
.
Let
outerEnv
be the LexicalEnvironment of the
running execution context
.
Let
funcEnv
be
NewDeclarativeEnvironment
(
outerEnv
).
Perform !
funcEnv
.
CreateImmutableBinding
(
name
,
false
).
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncFunctionExpression
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncFunction.prototype%
,
sourceText
,
FormalParameters
,
AsyncFunctionBody
,
non-lexical-this
,
funcEnv
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Perform !
funcEnv
.
InitializeBinding
(
name
,
closure
).
Return
closure
.
Note
The
BindingIdentifier
in an
AsyncFunctionExpression
can be referenced from inside the
AsyncFunctionExpression
's
AsyncFunctionBody
to allow the function to call itself recursively. However, unlike in a
FunctionDeclaration
, the
BindingIdentifier
in a
AsyncFunctionExpression
cannot be referenced from and does not affect the scope enclosing the
AsyncFunctionExpression
.
15.8.4
Runtime Semantics: EvaluateAsyncFunctionBody
The
syntax-directed operation
EvaluateAsyncFunctionBody takes arguments
functionObject
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
return completion
. It is defined piecewise over the following productions:
AsyncFunctionBody
:
FunctionBody
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
completion
be
Completion
(
FunctionDeclarationInstantiation
(
functionObject
,
argumentsList
)).
If
completion
is an
abrupt completion
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
completion
.
[[Value]]
»).
Else,
Perform
AsyncFunctionStart
(
promiseCapability
,
FunctionBody
).
Return
ReturnCompletion
(
promiseCapability
.
[[Promise]]
).
15.8.5
Runtime Semantics: Evaluation
AsyncFunctionExpression
:
async
function
BindingIdentifier
opt
(
FormalParameters
)
{
AsyncFunctionBody
}
Return
InstantiateAsyncFunctionExpression
of
AsyncFunctionExpression
.
AwaitExpression
:
await
UnaryExpression
Let
exprRef
be ?
Evaluation
of
UnaryExpression
.
Let
value
be ?
GetValue
(
exprRef
).
Return ?
Await
(
value
).
15.9
Async Arrow Function Definitions
Syntax
AsyncArrowFunction
[In, Yield, Await]
:
async
[no
LineTerminator
here]
AsyncArrowBindingIdentifier
[?Yield]
[no
LineTerminator
here]
=>
AsyncConciseBody
[?In]
CoverCallExpressionAndAsyncArrowHead
[?Yield, ?Await]
[no
LineTerminator
here]
=>
AsyncConciseBody
[?In]
AsyncConciseBody
[In]
:
[lookahead ≠
{
]
ExpressionBody
[?In, +Await]
{
AsyncFunctionBody
}
AsyncArrowBindingIdentifier
[Yield]
:
BindingIdentifier
[?Yield, +Await]
CoverCallExpressionAndAsyncArrowHead
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
Supplemental Syntax
When processing an instance of the production
AsyncArrowFunction
:
CoverCallExpressionAndAsyncArrowHead
=>
AsyncConciseBody
the interpretation of
CoverCallExpressionAndAsyncArrowHead
is refined using the following grammar:
AsyncArrowHead
:
async
[no
LineTerminator
here]
ArrowFormalParameters
[~Yield, +Await]
15.9.1
Static Semantics: Early Errors
AsyncArrowFunction
:
async
AsyncArrowBindingIdentifier
=>
AsyncConciseBody
It is a Syntax Error if any element of the
BoundNames
of
AsyncArrowBindingIdentifier
also occurs in the
LexicallyDeclaredNames
of
AsyncConciseBody
.
AsyncArrowFunction
:
CoverCallExpressionAndAsyncArrowHead
=>
AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead
must cover
an
AsyncArrowHead
.
It is a Syntax Error if
CoverCallExpressionAndAsyncArrowHead
Contains
YieldExpression
is
true
.
It is a Syntax Error if
CoverCallExpressionAndAsyncArrowHead
Contains
AwaitExpression
is
true
.
It is a Syntax Error if any element of the
BoundNames
of
CoverCallExpressionAndAsyncArrowHead
also occurs in the
LexicallyDeclaredNames
of
AsyncConciseBody
.
It is a Syntax Error if
AsyncConciseBodyContainsUseStrict
of
AsyncConciseBody
is
true
and
IsSimpleParameterList
of
CoverCallExpressionAndAsyncArrowHead
is
false
.
15.9.2
Static Semantics: AsyncConciseBodyContainsUseStrict
The
syntax-directed operation
AsyncConciseBodyContainsUseStrict takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
AsyncConciseBody
:
ExpressionBody
Return
false
.
AsyncConciseBody
:
{
AsyncFunctionBody
}
Return
FunctionBodyContainsUseStrict
of
AsyncFunctionBody
.
15.9.3
Runtime Semantics: EvaluateAsyncConciseBody
The
syntax-directed operation
EvaluateAsyncConciseBody takes arguments
functionObject
(an ECMAScript
function object
) and
argumentsList
(a
List
of
ECMAScript language values
) and returns a
return completion
. It is defined piecewise over the following productions:
AsyncConciseBody
:
ExpressionBody
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
completion
be
Completion
(
FunctionDeclarationInstantiation
(
functionObject
,
argumentsList
)).
If
completion
is an
abrupt completion
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
completion
.
[[Value]]
»).
Else,
Perform
AsyncFunctionStart
(
promiseCapability
,
ExpressionBody
).
Return
ReturnCompletion
(
promiseCapability
.
[[Promise]]
).
15.9.4
Runtime Semantics: InstantiateAsyncArrowFunctionExpression
The
syntax-directed operation
InstantiateAsyncArrowFunctionExpression takes optional argument
name
(a
property key
or a
Private Name
) and returns an ECMAScript
function object
. It is defined piecewise over the following productions:
AsyncArrowFunction
:
async
AsyncArrowBindingIdentifier
=>
AsyncConciseBody
If
name
is not present, set
name
to
""
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncArrowFunction
.
Let
parameters
be
AsyncArrowBindingIdentifier
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncFunction.prototype%
,
sourceText
,
parameters
,
AsyncConciseBody
,
lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Return
closure
.
AsyncArrowFunction
:
CoverCallExpressionAndAsyncArrowHead
=>
AsyncConciseBody
If
name
is not present, set
name
to
""
.
Let
env
be the LexicalEnvironment of the
running execution context
.
Let
privateEnv
be the
running execution context
's PrivateEnvironment.
Let
sourceText
be the
source text matched by
AsyncArrowFunction
.
Let
head
be the
AsyncArrowHead
that is
covered
by
CoverCallExpressionAndAsyncArrowHead
.
Let
parameters
be the
ArrowFormalParameters
of
head
.
Let
closure
be
OrdinaryFunctionCreate
(
%AsyncFunction.prototype%
,
sourceText
,
parameters
,
AsyncConciseBody
,
lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
closure
,
name
).
Return
closure
.
15.9.5
Runtime Semantics: Evaluation
AsyncArrowFunction
:
async
AsyncArrowBindingIdentifier
=>
AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead
=>
AsyncConciseBody
Return
InstantiateAsyncArrowFunctionExpression
of
AsyncArrowFunction
.
15.10
Tail Position Calls
15.10.1
Static Semantics: IsInTailPosition (
call
)
The abstract operation IsInTailPosition takes argument
call
(a
CallExpression
Parse Node
, a
MemberExpression
Parse Node
, or an
OptionalChain
Parse Node
) and returns a Boolean. It performs the following steps when called:
If
IsStrict
(
call
) is
false
, return
false
.
If
call
is not contained within a
FunctionBody
, a
ConciseBody
, or an
AsyncConciseBody
, return
false
.
Let
body
be the
FunctionBody
,
ConciseBody
, or
AsyncConciseBody
that most closely contains
call
.
If
body
is the
FunctionBody
of a
GeneratorBody
, return
false
.
If
body
is the
FunctionBody
of an
AsyncFunctionBody
, return
false
.
If
body
is the
FunctionBody
of an
AsyncGeneratorBody
, return
false
.
If
body
is an
AsyncConciseBody
, return
false
.
Return the result of
HasCallInTailPosition
of
body
with argument
call
.
Note
Tail Position calls are only defined in
strict mode code
because of a common non-standard language extension (see
10.2.4
) that enables observation of the chain of caller contexts.
15.10.2
Static Semantics: HasCallInTailPosition
The
syntax-directed operation
HasCallInTailPosition takes argument
call
(a
CallExpression
Parse Node
, a
MemberExpression
Parse Node
, or an
OptionalChain
Parse Node
) and returns a Boolean.
Note 1
call
is a
Parse Node
that represents a specific range of source text. When the following algorithms compare
call
to another
Parse Node
, it is a test of whether they represent the same source text.
Note 2
A potential tail position call that is immediately followed by return
GetValue
of the call result is also a possible tail position call. A function call cannot return a
Reference Record
, so such a
GetValue
operation will always return the same value as the actual function call result.
It is defined piecewise over the following productions:
StatementList
:
StatementList
StatementListItem
Let
has
be
HasCallInTailPosition
of
StatementList
with argument
call
.
If
has
is
true
, return
true
.
Return
HasCallInTailPosition
of
StatementListItem
with argument
call
.
FunctionStatementList
:
[empty]
StatementListItem
:
Declaration
Statement
:
VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ThrowStatement
DebuggerStatement
Block
:
{
}
ReturnStatement
:
return
;
LabelledItem
:
FunctionDeclaration
ForInOfStatement
:
for
(
LeftHandSideExpression
of
AssignmentExpression
)
Statement
for
(
var
ForBinding
of
AssignmentExpression
)
Statement
for
(
ForDeclaration
of
AssignmentExpression
)
Statement
CaseBlock
:
{
}
Return
false
.
IfStatement
:
if
(
Expression
)
Statement
else
Statement
Let
has
be
HasCallInTailPosition
of the first
Statement
with argument
call
.
If
has
is
true
, return
true
.
Return
HasCallInTailPosition
of the second
Statement
with argument
call
.
IfStatement
:
if
(
Expression
)
Statement
DoWhileStatement
:
do
Statement
while
(
Expression
)
;
WhileStatement
:
while
(
Expression
)
Statement
ForStatement
:
for
(
Expression
opt
;
Expression
opt
;
Expression
opt
)
Statement
for
(
var
VariableDeclarationList
;
Expression
opt
;
Expression
opt
)
Statement
for
(
LexicalDeclaration
Expression
opt
;
Expression
opt
)
Statement
ForInOfStatement
:
for
(
LeftHandSideExpression
in
Expression
)
Statement
for
(
var
ForBinding
in
Expression
)
Statement
for
(
ForDeclaration
in
Expression
)
Statement
WithStatement
:
with
(
Expression
)
Statement
Return
HasCallInTailPosition
of
Statement
with argument
call
.
LabelledStatement
:
LabelIdentifier
:
LabelledItem
Return
HasCallInTailPosition
of
LabelledItem
with argument
call
.
ReturnStatement
:
return
Expression
;
Return
HasCallInTailPosition
of
Expression
with argument
call
.
SwitchStatement
:
switch
(
Expression
)
CaseBlock
Return
HasCallInTailPosition
of
CaseBlock
with argument
call
.
CaseBlock
:
{
CaseClauses
opt
DefaultClause
CaseClauses
opt
}
Let
has
be
false
.
If the first
CaseClauses
is present, set
has
to
HasCallInTailPosition
of the first
CaseClauses
with argument
call
.
If
has
is
true
, return
true
.
Set
has
to
HasCallInTailPosition
of
DefaultClause
with argument
call
.
If
has
is
true
, return
true
.
If the second
CaseClauses
is present, set
has
to
HasCallInTailPosition
of the second
CaseClauses
with argument
call
.
Return
has
.
CaseClauses
:
CaseClauses
CaseClause
Let
has
be
HasCallInTailPosition
of
CaseClauses
with argument
call
.
If
has
is
true
, return
true
.
Return
HasCallInTailPosition
of
CaseClause
with argument
call
.
CaseClause
:
case
Expression
:
StatementList
opt
DefaultClause
:
default
:
StatementList
opt
If
StatementList
is present, return
HasCallInTailPosition
of
StatementList
with argument
call
.
Return
false
.
TryStatement
:
try
Block
Catch
Return
HasCallInTailPosition
of
Catch
with argument
call
.
TryStatement
:
try
Block
Finally
try
Block
Catch
Finally
Return
HasCallInTailPosition
of
Finally
with argument
call
.
Catch
:
catch
(
CatchParameter
)
Block
Return
HasCallInTailPosition
of
Block
with argument
call
.
AssignmentExpression
:
YieldExpression
ArrowFunction
AsyncArrowFunction
LeftHandSideExpression
=
AssignmentExpression
LeftHandSideExpression
AssignmentOperator
AssignmentExpression
LeftHandSideExpression
&&=
AssignmentExpression
LeftHandSideExpression
||=
AssignmentExpression
LeftHandSideExpression
??=
AssignmentExpression
BitwiseANDExpression
:
BitwiseANDExpression
&
EqualityExpression
BitwiseXORExpression
:
BitwiseXORExpression
^
BitwiseANDExpression
BitwiseORExpression
:
BitwiseORExpression
|
BitwiseXORExpression
EqualityExpression
:
EqualityExpression
==
RelationalExpression
EqualityExpression
!=
RelationalExpression
EqualityExpression
===
RelationalExpression
EqualityExpression
!==
RelationalExpression
RelationalExpression
:
RelationalExpression
<
ShiftExpression
RelationalExpression
>
ShiftExpression
RelationalExpression
<=
ShiftExpression
RelationalExpression
>=
ShiftExpression
RelationalExpression
instanceof
ShiftExpression
RelationalExpression
in
ShiftExpression
PrivateIdentifier
in
ShiftExpression
ShiftExpression
:
ShiftExpression
<<
AdditiveExpression
ShiftExpression
>>
AdditiveExpression
ShiftExpression
>>>
AdditiveExpression
AdditiveExpression
:
AdditiveExpression
+
MultiplicativeExpression
AdditiveExpression
-
MultiplicativeExpression
MultiplicativeExpression
:
MultiplicativeExpression
MultiplicativeOperator
ExponentiationExpression
ExponentiationExpression
:
UpdateExpression
**
ExponentiationExpression
UpdateExpression
:
LeftHandSideExpression
++
LeftHandSideExpression
--
++
UnaryExpression
--
UnaryExpression
UnaryExpression
:
delete
UnaryExpression
void
UnaryExpression
typeof
UnaryExpression
+
UnaryExpression
-
UnaryExpression
~
UnaryExpression
!
UnaryExpression
AwaitExpression
CallExpression
:
SuperCall
ImportCall
CallExpression
[
Expression
]
CallExpression
.
IdentifierName
CallExpression
.
PrivateIdentifier
NewExpression
:
new
NewExpression
MemberExpression
:
MemberExpression
[
Expression
]
MemberExpression
.
IdentifierName
SuperProperty
MetaProperty
new
MemberExpression
Arguments
MemberExpression
.
PrivateIdentifier
PrimaryExpression
:
this
IdentifierReference
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
Return
false
.
Expression
:
AssignmentExpression
Expression
,
AssignmentExpression
Return
HasCallInTailPosition
of
AssignmentExpression
with argument
call
.
ConditionalExpression
:
ShortCircuitExpression
?
AssignmentExpression
:
AssignmentExpression
Let
has
be
HasCallInTailPosition
of the first
AssignmentExpression
with argument
call
.
If
has
is
true
, return
true
.
Return
HasCallInTailPosition
of the second
AssignmentExpression
with argument
call
.
LogicalANDExpression
:
LogicalANDExpression
&&
BitwiseORExpression
Return
HasCallInTailPosition
of
BitwiseORExpression
with argument
call
.
LogicalORExpression
:
LogicalORExpression
||
LogicalANDExpression
Return
HasCallInTailPosition
of
LogicalANDExpression
with argument
call
.
CoalesceExpression
:
CoalesceExpressionHead
??
BitwiseORExpression
Return
HasCallInTailPosition
of
BitwiseORExpression
with argument
call
.
CallExpression
:
CoverCallExpressionAndAsyncArrowHead
CallExpression
Arguments
CallExpression
TemplateLiteral
If this
CallExpression
is
call
, return
true
.
Return
false
.
OptionalExpression
:
MemberExpression
OptionalChain
CallExpression
OptionalChain
OptionalExpression
OptionalChain
Return
HasCallInTailPosition
of
OptionalChain
with argument
call
.
OptionalChain
:
?.
[
Expression
]
?.
IdentifierName
?.
PrivateIdentifier
OptionalChain
[
Expression
]
OptionalChain
.
IdentifierName
OptionalChain
.
PrivateIdentifier
Return
false
.
OptionalChain
:
?.
Arguments
OptionalChain
Arguments
If this
OptionalChain
is
call
, return
true
.
Return
false
.
MemberExpression
:
MemberExpression
TemplateLiteral
If this
MemberExpression
is
call
, return
true
.
Return
false
.
PrimaryExpression
:
CoverParenthesizedExpressionAndArrowParameterList
Let
expr
be the
ParenthesizedExpression
that is
covered
by
CoverParenthesizedExpressionAndArrowParameterList
.
Return
HasCallInTailPosition
of
expr
with argument
call
.
ParenthesizedExpression
:
(
Expression
)
Return
HasCallInTailPosition
of
Expression
with argument
call
.
15.10.3
PrepareForTailCall ( )
The abstract operation PrepareForTailCall takes no arguments and returns
unused
. It performs the following steps when called:
Assert
: The current
execution context
will not subsequently be used for the evaluation of any ECMAScript code or built-in functions. The invocation of Call subsequent to the invocation of this abstract operation will create and push a new
execution context
before performing any such evaluation.
Discard all resources associated with the current
execution context
.
Return
unused
.
A tail position call must either release any transient internal resources associated with the currently executing function
execution context
before invoking the target function or reuse those resources in support of the target function.
Note
For example, a tail position call should only grow an implementation's activation record stack by the amount that the size of the target function's activation record exceeds the size of the calling function's activation record. If the target function's activation record is smaller, then the total size of the stack should decrease.
16
ECMAScript Language: Scripts and Modules
16.1
Scripts
Syntax
Script
:
ScriptBody
opt
ScriptBody
:
StatementList
[~Yield, ~Await, ~Return]
16.1.1
Static Semantics: Early Errors
Script
:
ScriptBody
It is a Syntax Error if the
LexicallyDeclaredNames
of
ScriptBody
contains any duplicate entries.
It is a Syntax Error if any element of the
LexicallyDeclaredNames
of
ScriptBody
also occurs in the
VarDeclaredNames
of
ScriptBody
.
ScriptBody
:
StatementList
It is a Syntax Error if
StatementList
Contains
super
unless the source text containing
super
is eval code that is being processed by a
direct eval
. Additional
early error
rules for
super
within
direct eval
are defined in
19.2.1.1
.
It is a Syntax Error if
StatementList
Contains
NewTarget
unless the source text containing
NewTarget
is eval code that is being processed by a
direct eval
. Additional
early error
rules for
NewTarget
in
direct eval
are defined in
19.2.1.1
.
It is a Syntax Error if
ContainsDuplicateLabels
of
StatementList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedBreakTarget
of
StatementList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedContinueTarget
of
StatementList
with arguments « » and « » is
true
.
It is a Syntax Error if
AllPrivateIdentifiersValid
of
StatementList
with argument « » is
false
unless the source text containing
ScriptBody
is eval code that is being processed by a
direct eval
.
16.1.2
Static Semantics: ScriptIsStrict
The
syntax-directed operation
ScriptIsStrict takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
Script
:
ScriptBody
opt
If
ScriptBody
is present and the
Directive Prologue
of
ScriptBody
contains a
Use Strict Directive
, return
true
; otherwise return
false
.
16.1.3
Runtime Semantics: Evaluation
Script
:
[empty]
Return
undefined
.
16.1.4
Script Records
A
Script Record
encapsulates information about a script being evaluated. Each script record contains the fields listed in
Table 34
.
Table 34:
Script Record
Fields
Field Name
Value Type
Meaning
[[Realm]]
a
Realm Record
The
realm
within which this script was created.
[[ECMAScriptCode]]
a
Script
Parse Node
The result of parsing the source text of this script.
[[LoadedModules]]
a
List
of
LoadedModuleRequest Records
A map from the specifier strings imported by this script to the resolved
Module Record
. The list does not contain two different
Records
r1
and
r2
such that
ModuleRequestsEqual
(
r1
,
r2
) is
true
.
[[HostDefined]]
anything (default value is
empty
)
Field reserved for use by
host environments
that need to associate additional information with a script.
16.1.5
ParseScript (
sourceText
,
realm
,
hostDefined
)
The abstract operation ParseScript takes arguments
sourceText
(
ECMAScript source text
),
realm
(a
Realm Record
), and
hostDefined
(anything) and returns a
Script Record
or a non-empty
List
of
SyntaxError
objects. It creates a
Script Record
based upon the result of parsing
sourceText
as a
Script
. It performs the following steps when called:
Let
script
be
ParseText
(
sourceText
,
Script
).
If
script
is a
List
of errors, return
script
.
Return
Script Record
{
[[Realm]]
:
realm
,
[[ECMAScriptCode]]
:
script
,
[[LoadedModules]]
: « »,
[[HostDefined]]
:
hostDefined
}.
Note
An implementation may parse script source text and analyse it for Early Error conditions prior to evaluation of ParseScript for that script source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseScript upon that source text.
16.1.6
ScriptEvaluation (
scriptRecord
)
The abstract operation ScriptEvaluation takes argument
scriptRecord
(a
Script Record
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
Let
globalEnv
be
scriptRecord
.
[[Realm]]
.
[[GlobalEnv]]
.
Let
scriptContext
be a new
ECMAScript code execution context
.
Set the Function of
scriptContext
to
null
.
Set the
Realm
of
scriptContext
to
scriptRecord
.
[[Realm]]
.
Set the ScriptOrModule of
scriptContext
to
scriptRecord
.
Set the VariableEnvironment of
scriptContext
to
globalEnv
.
Set the LexicalEnvironment of
scriptContext
to
globalEnv
.
Set the PrivateEnvironment of
scriptContext
to
null
.
Suspend the
running execution context
.
Push
scriptContext
onto the
execution context stack
;
scriptContext
is now the
running execution context
.
Let
script
be
scriptRecord
.
[[ECMAScriptCode]]
.
Let
result
be
Completion
(
GlobalDeclarationInstantiation
(
script
,
globalEnv
)).
If
result
is a
normal completion
, then
Set
result
to
Completion
(
Evaluation
of
script
).
If
result
is a
normal completion
and
result
.
[[Value]]
is
empty
, then
Set
result
to
NormalCompletion
(
undefined
).
Suspend
scriptContext
and remove it from the
execution context stack
.
Assert
: The
execution context stack
is not empty.
Resume the context that is now on the top of the
execution context stack
as the
running execution context
.
Return ?
result
.
16.1.7
GlobalDeclarationInstantiation (
script
,
env
)
The abstract operation GlobalDeclarationInstantiation takes arguments
script
(a
Script
Parse Node
) and
env
(a
Global Environment Record
) and returns either a
normal completion containing
unused
or a
throw completion
.
script
is the
Script
for which the
execution context
is being established.
env
is the global environment in which bindings are to be created.
Note 1
When an
execution context
is established for evaluating scripts, declarations are instantiated in the current global environment. Each global binding declared in the code is instantiated.
It performs the following steps when called:
Let
lexNames
be the
LexicallyDeclaredNames
of
script
.
Let
varNames
be the
VarDeclaredNames
of
script
.
For each element
name
of
lexNames
, do
If
HasLexicalDeclaration
(
env
,
name
) is
true
, throw a
SyntaxError
exception.
Let
hasRestrictedGlobal
be ?
HasRestrictedGlobalProperty
(
env
,
name
).
NOTE: Global
var
and
function
bindings (except those that are introduced by non-strict
direct eval
) are non-configurable and are therefore restricted global properties.
If
hasRestrictedGlobal
is
true
, throw a
SyntaxError
exception.
For each element
name
of
varNames
, do
If
HasLexicalDeclaration
(
env
,
name
) is
true
, throw a
SyntaxError
exception.
Let
varDeclarations
be the
VarScopedDeclarations
of
script
.
Let
functionsToInitialize
be a new empty
List
.
Let
declaredFunctionNames
be a new empty
List
.
For each element
d
of
varDeclarations
, in reverse
List
order, do
If
d
is not either a
VariableDeclaration
, a
ForBinding
, or a
BindingIdentifier
, then
Assert
:
d
is either a
FunctionDeclaration
, a
GeneratorDeclaration
, an
AsyncFunctionDeclaration
, or an
AsyncGeneratorDeclaration
.
NOTE: If there are multiple function declarations for the same name, the last declaration is used.
Let
fn
be the sole element of the
BoundNames
of
d
.
If
declaredFunctionNames
does not contain
fn
, then
Let
fnDefinable
be ?
CanDeclareGlobalFunction
(
env
,
fn
).
If
fnDefinable
is
false
, throw a
TypeError
exception.
Append
fn
to
declaredFunctionNames
.
Insert
d
as the first element of
functionsToInitialize
.
Let
declaredVarNames
be a new empty
List
.
For each element
d
of
varDeclarations
, do
If
d
is either a
VariableDeclaration
, a
ForBinding
, or a
BindingIdentifier
, then
For each String
vn
of the
BoundNames
of
d
, do
If
declaredFunctionNames
does not contain
vn
, then
Let
vnDefinable
be ?
CanDeclareGlobalVar
(
env
,
vn
).
If
vnDefinable
is
false
, throw a
TypeError
exception.
If
declaredVarNames
does not contain
vn
, then
Append
vn
to
declaredVarNames
.
NOTE: No abnormal terminations occur after this algorithm step if the
global object
is an
ordinary object
. However, if the
global object
is a
Proxy exotic object
it may exhibit behaviours that cause abnormal terminations in some of the following steps.
Normative Optional
If the
host
is a web browser or otherwise supports
Block-Level Function Declarations Web Legacy Compatibility Semantics
, then
Let
strict
be
ScriptIsStrict
of
script
.
If
strict
is
false
, then
Let
declaredFunctionOrVarNames
be the
list-concatenation
of
declaredFunctionNames
and
declaredVarNames
.
For each
FunctionDeclaration
f
that is directly contained in the
StatementList
of any
Block
,
CaseClause
, or
DefaultClause
x
such that
script
Contains
x
is
true
, do
Let
F
be the
StringValue
of the
BindingIdentifier
of
f
.
If replacing the
FunctionDeclaration
f
with a
VariableStatement
that has
F
as a
BindingIdentifier
would not produce any Early Errors for
script
, then
If
HasLexicalDeclaration
(
env
,
F
) is
false
, then
Let
fnDefinable
be ?
CanDeclareGlobalVar
(
env
,
F
).
If
fnDefinable
is
true
, then
NOTE: A var binding for
F
is only instantiated here if it is neither a VarDeclaredName nor the name of another
FunctionDeclaration
.
If
declaredFunctionOrVarNames
does not contain
F
, then
Perform ?
CreateGlobalVarBinding
(
env
,
F
,
false
).
Append
F
to
declaredFunctionOrVarNames
.
When the
FunctionDeclaration
f
is evaluated, perform the following steps in place of the
FunctionDeclaration
Evaluation
algorithm provided in
15.2.6
:
Let
gEnv
be the
running execution context
's VariableEnvironment.
Let
bEnv
be the
running execution context
's LexicalEnvironment.
Let
fObj
be !
bEnv
.
GetBindingValue
(
F
,
false
).
Perform ?
gEnv
.
SetMutableBinding
(
F
,
fObj
,
false
)
.
Return
unused
.
Let
lexDeclarations
be the
LexicallyScopedDeclarations
of
script
.
Let
privateEnv
be
null
.
For each element
d
of
lexDeclarations
, do
NOTE: Lexically declared names are only instantiated here but not initialized.
For each element
dn
of the
BoundNames
of
d
, do
If
IsConstantDeclaration
of
d
is
true
, then
Perform ?
env
.
CreateImmutableBinding
(
dn
,
true
)
.
Else,
Perform ?
env
.
CreateMutableBinding
(
dn
,
false
)
.
For each
Parse Node
f
of
functionsToInitialize
, do
Let
fn
be the sole element of the
BoundNames
of
f
.
Let
fo
be
InstantiateFunctionObject
of
f
with arguments
env
and
privateEnv
.
Perform ?
CreateGlobalFunctionBinding
(
env
,
fn
,
fo
,
false
).
For each String
vn
of
declaredVarNames
, do
Perform ?
CreateGlobalVarBinding
(
env
,
vn
,
false
).
Return
unused
.
Note 2
Early errors
specified in
16.1.1
prevent name conflicts between function/var declarations and let/const/class declarations as well as redeclaration of let/const/class bindings for declaration contained within a single
Script
. However, such conflicts and redeclarations that span more than one
Script
are detected as runtime errors during GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if the
global object
is defined using
Proxy exotic objects
then the runtime tests for conflicting declarations may be unreliable resulting in an
abrupt completion
and some global declarations not being instantiated. If this occurs, the code for the
Script
is not evaluated.
Unlike explicit var or function declarations, properties that are directly created on the
global object
result in global bindings that may be shadowed by let/const/class declarations.
16.2
Modules
Syntax
Module
:
ModuleBody
opt
ModuleBody
:
ModuleItemList
ModuleItemList
:
ModuleItem
ModuleItemList
ModuleItem
ModuleItem
:
ImportDeclaration
ExportDeclaration
StatementListItem
[~Yield, +Await, ~Return]
ModuleExportName
:
IdentifierName
StringLiteral
16.2.1
Module Semantics
16.2.1.1
Static Semantics: Early Errors
ModuleBody
:
ModuleItemList
It is a Syntax Error if the
LexicallyDeclaredNames
of
ModuleItemList
contains any duplicate entries.
It is a Syntax Error if any element of the
LexicallyDeclaredNames
of
ModuleItemList
also occurs in the
VarDeclaredNames
of
ModuleItemList
.
It is a Syntax Error if the
ExportedNames
of
ModuleItemList
contains any duplicate entries.
It is a Syntax Error if any element of the
ExportedBindings
of
ModuleItemList
does not also occur in either the
VarDeclaredNames
of
ModuleItemList
, or the
LexicallyDeclaredNames
of
ModuleItemList
.
It is a Syntax Error if
ModuleItemList
Contains
super
.
It is a Syntax Error if
ModuleItemList
Contains
NewTarget
.
It is a Syntax Error if
ContainsDuplicateLabels
of
ModuleItemList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedBreakTarget
of
ModuleItemList
with argument « » is
true
.
It is a Syntax Error if
ContainsUndefinedContinueTarget
of
ModuleItemList
with arguments « » and « » is
true
.
It is a Syntax Error if
AllPrivateIdentifiersValid
of
ModuleItemList
with argument « » is
false
.
Note
The duplicate
ExportedNames
rule implies that multiple
export default
ExportDeclaration
items within a
ModuleBody
is a Syntax Error. Additional error conditions relating to conflicting or duplicate declarations are checked during module linking prior to evaluation of a
Module
. If any such errors are detected the
Module
is not evaluated.
ModuleExportName
:
StringLiteral
It is a Syntax Error if
IsStringWellFormedUnicode
(
SV
of
StringLiteral
) is
false
.
16.2.1.2
Static Semantics: ImportedLocalNames (
importEntries
)
The abstract operation ImportedLocalNames takes argument
importEntries
(a
List
of
ImportEntry Records
) and returns a
List
of Strings. It creates a
List
of all of the local name bindings defined by
importEntries
. It performs the following steps when called:
Let
localNames
be a new empty
List
.
For each
ImportEntry Record
i
of
importEntries
, do
Append
i
.
[[LocalName]]
to
localNames
.
Return
localNames
.
16.2.1.3
ModuleRequest Records
A
ModuleRequest Record
represents the request to import a module with given import attributes. It consists of the following fields:
Table 35:
ModuleRequest Record
Fields
Field Name
Value Type
Meaning
[[Specifier]]
a String
The module specifier
[[Attributes]]
a
List
of
ImportAttribute Records
The import attributes
A
LoadedModuleRequest Record
represents the request to import a module together with the resulting
Module Record
. It consists of the same fields defined in table
Table 35
, with the addition of
[[Module]]
:
Table 36:
LoadedModuleRequest Record
Fields
Field Name
Value Type
Meaning
[[Specifier]]
a String
The module specifier
[[Attributes]]
a
List
of
ImportAttribute Records
The import attributes
[[Module]]
a
Module Record
The loaded module corresponding to this module request
An
ImportAttribute Record
consists of the following fields:
Table 37:
ImportAttribute Record
Fields
Field Name
Value Type
Meaning
[[Key]]
a String
The attribute key
[[Value]]
a String
The attribute value
16.2.1.3.1
ModuleRequestsEqual (
left
,
right
)
The abstract operation ModuleRequestsEqual takes arguments
left
(a
ModuleRequest Record
or a
LoadedModuleRequest Record
) and
right
(a
ModuleRequest Record
or a
LoadedModuleRequest Record
) and returns a Boolean. It performs the following steps when called:
If
left
.
[[Specifier]]
is not
right
.
[[Specifier]]
, return
false
.
Let
leftAttrs
be
left
.
[[Attributes]]
.
Let
rightAttrs
be
right
.
[[Attributes]]
.
Let
leftAttrsCount
be the number of elements in
leftAttrs
.
Let
rightAttrsCount
be the number of elements in
rightAttrs
.
If
leftAttrsCount
≠
rightAttrsCount
, return
false
.
For each
ImportAttribute Record
l
of
leftAttrs
, do
If
rightAttrs
does not contain an
ImportAttribute Record
r
such that
l
.
[[Key]]
is
r
.
[[Key]]
and
l
.
[[Value]]
is
r
.
[[Value]]
, return
false
.
Return
true
.
16.2.1.4
Static Semantics: ModuleRequests
The
syntax-directed operation
ModuleRequests takes no arguments and returns a
List
of
ModuleRequest Records
. It is defined piecewise over the following productions:
Module
:
[empty]
Return a new empty
List
.
ModuleItemList
:
ModuleItem
Return the
ModuleRequests
of
ModuleItem
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
requests
be the
ModuleRequests
of
ModuleItemList
.
Let
additionalRequests
be the
ModuleRequests
of
ModuleItem
.
For each
ModuleRequest Record
mr
of
additionalRequests
, do
If
requests
does not contain a
ModuleRequest Record
mr2
such that
ModuleRequestsEqual
(
mr
,
mr2
) is
true
, then
Append
mr
to
requests
.
Return
requests
.
ModuleItem
:
StatementListItem
Return a new empty
List
.
ImportDeclaration
:
import
ImportClause
FromClause
;
Let
specifier
be the
SV
of
FromClause
.
Return a
List
whose sole element is the
ModuleRequest Record
{
[[Specifier]]
:
specifier
,
[[Attributes]]
: « » }.
ImportDeclaration
:
import
ImportClause
FromClause
WithClause
;
Let
specifier
be the
SV
of
FromClause
.
Let
attributes
be
WithClauseToAttributes
of
WithClause
.
Return a
List
whose sole element is the
ModuleRequest Record
{
[[Specifier]]
:
specifier
,
[[Attributes]]
:
attributes
}.
ImportDeclaration
:
import
ModuleSpecifier
;
Let
specifier
be the
SV
of
ModuleSpecifier
.
Return a
List
whose sole element is the
ModuleRequest Record
{
[[Specifier]]
:
specifier
,
[[Attributes]]
: « » }.
ImportDeclaration
:
import
ModuleSpecifier
WithClause
;
Let
specifier
be the
SV
of
ModuleSpecifier
.
Let
attributes
be
WithClauseToAttributes
of
WithClause
.
Return a
List
whose sole element is the
ModuleRequest Record
{
[[Specifier]]
:
specifier
,
[[Attributes]]
:
attributes
}.
ExportDeclaration
:
export
ExportFromClause
FromClause
;
Let
specifier
be the
SV
of
FromClause
.
Return a
List
whose sole element is the
ModuleRequest Record
{
[[Specifier]]
:
specifier
,
[[Attributes]]
: « » }.
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
;
Let
specifier
be the
SV
of
FromClause
.
Let
attributes
be
WithClauseToAttributes
of
WithClause
.
Return a
List
whose sole element is the
ModuleRequest Record
{
[[Specifier]]
:
specifier
,
[[Attributes]]
:
attributes
}.
ExportDeclaration
:
export
NamedExports
;
export
VariableStatement
export
Declaration
export
default
HoistableDeclaration
export
default
ClassDeclaration
export
default
AssignmentExpression
;
Return a new empty
List
.
16.2.1.5
Abstract Module Records
A
Module Record
encapsulates structural information about the imports and exports of a single module. This information is used to link the imports and exports of sets of connected modules. A Module Record includes four fields that are only used when evaluating a module.
For specification purposes Module Record values are values of the
Record
specification type and can be thought of as existing in a simple object-oriented hierarchy where Module Record is an abstract class with both abstract and concrete subclasses. This specification defines the abstract subclass named
Cyclic Module Record
and its concrete subclass named
Source Text Module Record
. Other specifications and implementations may define additional Module Record subclasses corresponding to alternative module definition facilities that they defined.
Module Record defines the fields listed in
Table 38
. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in
Table 39
. All Module definition subclasses must provide concrete implementations of these abstract methods.
Table 38:
Module Record
Fields
Field Name
Value Type
Meaning
[[Realm]]
a
Realm Record
The
Realm
within which this module was created.
[[Environment]]
a
Module Environment Record
or
empty
The
Environment Record
containing the top level bindings for this module. This field is set when the module is linked.
[[Namespace]]
an Object or
empty
The Module Namespace Object (
28.3
) if one has been created for this module.
[[HostDefined]]
anything (default value is
undefined
)
Field reserved for use by
host environments
that need to associate additional information with a module.
Table 39: Abstract Methods of
Module Records
Method
Purpose
Definitions
LoadRequestedModules ( [
hostDefined
] )
The abstract method LoadRequestedModules takes optional argument
hostDefined
(anything) and returns a Promise.
It prepares the module for linking by recursively loading all its dependencies.
Within this specification it has definitions in the following types;
hosts
may provide additional types with their own definitions:
16.2.1.6.1.1 Cyclic Module Record
16.2.1.8.4.1 Synthetic Module Record
GetExportedNames ( [
exportStarSet
] )
The abstract method GetExportedNames takes optional argument
exportStarSet
(a
List
of
Source Text Module Records
) and returns a
List
of Strings.
It returns a list of all names that are either directly or indirectly exported from this module.
LoadRequestedModules
must have completed successfully prior to invoking this method.
Within this specification it has definitions in the following types;
hosts
may provide additional types with their own definitions:
16.2.1.7.2.1 Source Text Module Record
16.2.1.8.4.2 Synthetic Module Record
ResolveExport (
exportName
[ ,
resolveSet
] )
The abstract method ResolveExport takes argument
exportName
(a String) and optional argument
resolveSet
(a
List
of
Records
with fields
[[Module]]
(a
Module Record
) and
[[ExportName]]
(a String)) and returns a
ResolvedBinding Record
,
null
, or
ambiguous
.
It returns the binding of a name exported by this module. Bindings are represented by a
ResolvedBinding Record
, of the form {
[[Module]]
:
Module Record
,
[[BindingName]]
: String |
namespace
}. If the export is a Module Namespace Object without a direct binding in any module,
[[BindingName]]
will be set to
namespace
. It returns
null
if the name cannot be resolved, or
ambiguous
if multiple bindings were found.
Each time this operation is called with a specific
exportName
,
resolveSet
pair as arguments it must return the same result.
LoadRequestedModules
must have completed successfully prior to invoking this method.
Within this specification it has definitions in the following types;
hosts
may provide additional types with their own definitions:
16.2.1.7.2.2 Source Text Module Record
16.2.1.8.4.3 Synthetic Module Record
Link ( )
The abstract method Link takes no arguments and returns either a
normal completion containing
unused
or a
throw completion
.
It prepares the module for evaluation by transitively resolving all module dependencies and creating a
Module Environment Record
.
LoadRequestedModules
must have completed successfully prior to invoking this method.
Within this specification it has definitions in the following types;
hosts
may provide additional types with their own definitions:
16.2.1.6.1.2 Cyclic Module Record
16.2.1.8.4.4 Synthetic Module Record
Evaluate ( )
The abstract method Evaluate takes no arguments and returns a Promise.
It returns a promise for the evaluation of this module and its dependencies, resolving on successful evaluation or if it has already been evaluated successfully, and rejecting for an evaluation error or if it has already been evaluated unsuccessfully. If the promise is rejected,
hosts
are expected to handle the promise rejection and rethrow the evaluation error. Unless this module is a
Cyclic Module Record
, the returned promise must be already settled.
Link
must have completed successfully prior to invoking this method.
Within this specification it has definitions in the following types;
hosts
may provide additional types with their own definitions:
16.2.1.6.1.3 Cyclic Module Record
16.2.1.8.4.5 Synthetic Module Record
16.2.1.5.1
EvaluateModuleSync (
module
)
The abstract operation EvaluateModuleSync takes argument
module
(a
Module Record
) and returns either a
normal completion containing
unused
or a
throw completion
. It synchronously evaluates
module
, provided that the caller guarantees that
module
's evaluation will return an already settled promise. It performs the following steps when called:
Assert
:
module
is not a
Cyclic Module Record
.
Let
promise
be
module
.
Evaluate
().
Assert
:
promise
.
[[PromiseState]]
is either
fulfilled
or
rejected
.
If
promise
.
[[PromiseState]]
is
rejected
, then
If
promise
.
[[PromiseIsHandled]]
is
false
, perform
HostPromiseRejectionTracker
(
promise
,
"handle"
).
Set
promise
.
[[PromiseIsHandled]]
to
true
.
Return
ThrowCompletion
(
promise
.
[[PromiseResult]]
).
Return
unused
.
16.2.1.6
Cyclic Module Records
A
Cyclic Module Record
is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the
Cyclic Module Record
type.
Module Records
that are not subclasses of the
Cyclic Module Record
type must not participate in dependency cycles with
Source Text Module Records
.
In addition to the fields defined in
Table 38
Cyclic Module Records
have the additional fields listed in
Table 40
Table 40: Additional Fields of
Cyclic Module Records
Field Name
Value Type
Meaning
[[Status]]
new
,
unlinked
,
linking
,
linked
,
evaluating
,
evaluating-async
, or
evaluated
Initially
new
. Transitions to
unlinked
,
linking
,
linked
,
evaluating
, possibly
evaluating-async
,
evaluated
(in that order) as the module progresses throughout its lifecycle.
evaluating-async
indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose
[[HasTLA]]
field is
true
that has been executed and is pending top-level completion.
[[EvaluationError]]
a
throw completion
or
empty
A
throw completion
representing the exception that occurred during evaluation.
undefined
if no exception occurred or if
[[Status]]
is not
evaluated
.
[[DFSAncestorIndex]]
an
integer
or
empty
Auxiliary field used during
Link
and
Evaluate
only. If
[[Status]]
is either
linking
or
evaluating
, this is either the module's depth-first traversal index or that of an "earlier" module in the same strongly connected component.
[[RequestedModules]]
a
List
of
ModuleRequest Records
A
List
of the
ModuleRequest Records
associated with the imports in this module. The
List
is in source text occurrence order of the imports.
[[LoadedModules]]
a
List
of
LoadedModuleRequest Records
A map from the specifier strings used by the module represented by this record to request the importation of a module with the relative import attributes to the resolved
Module Record
. The list does not contain two different
Records
r1
and
r2
such that
ModuleRequestsEqual
(
r1
,
r2
) is
true
.
[[CycleRoot]]
a
Cyclic Module Record
or
empty
The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle, this would be the module itself. Once
Evaluate
has completed, a module's
[[DFSAncestorIndex]]
is the depth-first traversal index of its
[[CycleRoot]]
.
[[HasTLA]]
a Boolean
Whether this module is individually asynchronous (for example, if it's a
Source Text Module Record
containing a top-level await). Having an asynchronous dependency does not mean this field is
true
. This field must not change after the module is parsed.
[[AsyncEvaluationOrder]]
unset
, an
integer
, or
done
This field is initially set to
unset
, and remains
unset
for fully synchronous modules. For modules that are either themselves asynchronous or have an asynchronous dependency, it is set to an
integer
that determines the order in which execution of pending modules is queued by
16.2.1.6.1.3.4
. Once the pending module is executed, the field is set to
done
.
[[TopLevelCapability]]
a
PromiseCapability Record
or
empty
If this module is the
[[CycleRoot]]
of some cycle, and
Evaluate
() was called on some module in that cycle, this field contains the
PromiseCapability Record
for that entire evaluation. It is used to settle the Promise object that is returned from the
Evaluate
() abstract method. This field will be
empty
for any dependencies of that module, unless a top-level
Evaluate
() has been initiated for some of those dependencies.
[[AsyncParentModules]]
a
List
of
Cyclic Module Records
If this module or a dependency has
[[HasTLA]]
true
, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
[[PendingAsyncDependencies]]
an
integer
or
empty
If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
In addition to the methods defined in
Table 39
Cyclic Module Records
have the additional methods listed in
Table 41
:
Table 41: Additional Abstract Methods of
Cyclic Module Records
Method
Purpose
Definitions
InitializeEnvironment ( )
The abstract method InitializeEnvironment takes no arguments and returns either a
normal completion containing
unused
or a
throw completion
.
It initializes the
Environment Record
of the module, including resolving all imported bindings, and creates the module's
execution context
.
Within this specification it has definitions in the following types;
hosts
may provide additional types with their own definitions:
16.2.1.7.3.1 Source Text Module Record
ExecuteModule ( [
capability
] )
The abstract method ExecuteModule takes optional argument
capability
(a
PromiseCapability Record
) and returns either a
normal completion containing
unused
or a
throw completion
.
It evaluates the module's code within its
execution context
. If this module has
true
in
[[HasTLA]]
, then a
PromiseCapability Record
is passed as an argument, and the method is expected to resolve or reject the given capability. In this case, the method must not throw an exception, but instead reject the
PromiseCapability Record
if necessary.
Within this specification it has definitions in the following types;
hosts
may provide additional types with their own definitions:
16.2.1.7.3.2 Source Text Module Record
A
GraphLoadingState Record
is a
Record
that contains information about the loading process of a module graph. It's used to continue loading after a call to
HostLoadImportedModule
. Each
GraphLoadingState Record
has the fields defined in
Table 42
:
Table 42:
GraphLoadingState Record
Fields
Field Name
Value Type
Meaning
[[PromiseCapability]]
a
PromiseCapability Record
The promise to resolve when the loading process finishes.
[[IsLoading]]
a Boolean
It is true if the loading process has not finished yet, neither successfully nor with an error.
[[PendingModulesCount]]
a non-negative
integer
It tracks the number of pending
HostLoadImportedModule
calls.
[[Visited]]
a
List
of
Cyclic Module Records
It is a list of the
Cyclic Module Records
that have been already loaded by the current loading process, to avoid infinite loops with circular dependencies.
[[HostDefined]]
anything (default value is
empty
)
It contains
host-defined
data to pass from the
LoadRequestedModules
caller to
HostLoadImportedModule
.
16.2.1.6.1
Implementation of Module Record Abstract Methods
The following are the concrete methods for
Cyclic Module Record
that implement the corresponding
Module Record
abstract methods defined in
Table 39
.
16.2.1.6.1.1
LoadRequestedModules ( [
hostDefined
] )
The
LoadRequestedModules
concrete method of a
Cyclic Module Record
module
takes optional argument
hostDefined
(anything) and returns a Promise. It populates the
[[LoadedModules]]
of all the
Module Records
in the dependency graph of
module
(most of the work is done by the auxiliary function
InnerModuleLoading
). It takes an optional
hostDefined
parameter that is passed to the
HostLoadImportedModule
hook. It performs the following steps when called:
If
hostDefined
is not present, let
hostDefined
be
empty
.
Let
pc
be !
NewPromiseCapability
(
%Promise%
).
Let
state
be the
GraphLoadingState Record
{
[[IsLoading]]
:
true
,
[[PendingModulesCount]]
: 1,
[[Visited]]
: « »,
[[PromiseCapability]]
:
pc
,
[[HostDefined]]
:
hostDefined
}.
Perform
InnerModuleLoading
(
state
,
module
).
Return
pc
.
[[Promise]]
.
Note
The
hostDefined
parameter can be used to pass additional information necessary to fetch the imported modules. It is used, for example, by HTML to set the correct fetch destination for
<link rel="preload" as="...">
tags.
import()
expressions never set the
hostDefined
parameter.
16.2.1.6.1.1.1
InnerModuleLoading (
state
,
module
)
The abstract operation InnerModuleLoading takes arguments
state
(a
GraphLoadingState Record
) and
module
(a
Module Record
) and returns
unused
. It is used by
LoadRequestedModules
to recursively perform the actual loading process for
module
's dependency graph. It performs the following steps when called:
Assert
:
state
.
[[IsLoading]]
is
true
.
If
module
is a
Cyclic Module Record
,
module
.
[[Status]]
is
new
, and
state
.
[[Visited]]
does not contain
module
, then
Append
module
to
state
.
[[Visited]]
.
Let
requestedModulesCount
be the number of elements in
module
.
[[RequestedModules]]
.
Set
state
.
[[PendingModulesCount]]
to
state
.
[[PendingModulesCount]]
+
requestedModulesCount
.
For each
ModuleRequest Record
request
of
module
.
[[RequestedModules]]
, do
If
AllImportAttributesSupported
(
request
.
[[Attributes]]
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
SyntaxError
object).
Perform
ContinueModuleLoading
(
state
,
error
).
Else if
module
.
[[LoadedModules]]
contains a
LoadedModuleRequest Record
record
such that
ModuleRequestsEqual
(
record
,
request
) is
true
, then
Perform
InnerModuleLoading
(
state
,
record
.
[[Module]]
).
Else,
Perform
HostLoadImportedModule
(
module
,
request
,
state
.
[[HostDefined]]
,
state
).
NOTE:
HostLoadImportedModule
will call
FinishLoadingImportedModule
, which re-enters the graph loading process through
ContinueModuleLoading
.
If
state
.
[[IsLoading]]
is
false
, return
unused
.
Assert
:
state
.
[[PendingModulesCount]]
≥ 1.
Set
state
.
[[PendingModulesCount]]
to
state
.
[[PendingModulesCount]]
- 1.
If
state
.
[[PendingModulesCount]]
= 0, then
Set
state
.
[[IsLoading]]
to
false
.
For each
Cyclic Module Record
loaded
of
state
.
[[Visited]]
, do
If
loaded
.
[[Status]]
is
new
, set
loaded
.
[[Status]]
to
unlinked
.
Perform !
Call
(
state
.
[[PromiseCapability]]
.
[[Resolve]]
,
undefined
, «
undefined
»).
Return
unused
.
16.2.1.6.1.1.2
ContinueModuleLoading (
state
,
moduleCompletion
)
The abstract operation ContinueModuleLoading takes arguments
state
(a
GraphLoadingState Record
) and
moduleCompletion
(either a
normal completion containing
a
Module Record
or a
throw completion
) and returns
unused
. It is used to re-enter the loading process after a call to
HostLoadImportedModule
. It performs the following steps when called:
If
state
.
[[IsLoading]]
is
false
, return
unused
.
If
moduleCompletion
is a
normal completion
, then
Perform
InnerModuleLoading
(
state
,
moduleCompletion
.
[[Value]]
).
Else,
Set
state
.
[[IsLoading]]
to
false
.
Perform !
Call
(
state
.
[[PromiseCapability]]
.
[[Reject]]
,
undefined
, «
moduleCompletion
.
[[Value]]
»).
Return
unused
.
16.2.1.6.1.2
Link ( )
The
Link
concrete method of a
Cyclic Module Record
module
takes no arguments and returns either a
normal completion containing
unused
or a
throw completion
. On success,
Link
transitions this module's
[[Status]]
from
unlinked
to
linked
. On failure, an exception is thrown and this module's
[[Status]]
remains
unlinked
. (Most of the work is done by the auxiliary function
InnerModuleLinking
.) It performs the following steps when called:
Assert
:
module
.
[[Status]]
is one of
unlinked
,
linked
,
evaluating-async
, or
evaluated
.
Let
stack
be a new empty
List
.
Let
result
be
Completion
(
InnerModuleLinking
(
module
,
stack
, 0)).
If
result
is an
abrupt completion
, then
For each
Cyclic Module Record
m
of
stack
, do
Assert
:
m
.
[[Status]]
is
linking
.
Set
m
.
[[Status]]
to
unlinked
.
Assert
:
module
.
[[Status]]
is
unlinked
.
Return ?
result
.
Assert
:
module
.
[[Status]]
is one of
linked
,
evaluating-async
, or
evaluated
.
Assert
:
stack
is empty.
Return
unused
.
16.2.1.6.1.2.1
InnerModuleLinking (
module
,
stack
,
index
)
The abstract operation InnerModuleLinking takes arguments
module
(a
Module Record
),
stack
(a
List
of
Cyclic Module Records
), and
index
(a non-negative
integer
) and returns either a
normal completion containing
a non-negative
integer
or a
throw completion
. It is used by
Link
to perform the actual linking process for
module
, as well as recursively on all other modules in the dependency graph. The
stack
and
index
parameters, as well as a module's
[[DFSAncestorIndex]]
field, keep track of the depth-first search (DFS) traversal. In particular,
[[DFSAncestorIndex]]
is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to
linked
together. It performs the following steps when called:
If
module
is not a
Cyclic Module Record
, then
Perform ?
module
.
Link
().
Return
index
.
If
module
.
[[Status]]
is one of
linking
,
linked
,
evaluating-async
, or
evaluated
, then
Return
index
.
Assert
:
module
.
[[Status]]
is
unlinked
.
Set
module
.
[[Status]]
to
linking
.
Let
moduleIndex
be
index
.
Set
module
.
[[DFSAncestorIndex]]
to
index
.
Set
index
to
index
+ 1.
Append
module
to
stack
.
For each
ModuleRequest Record
request
of
module
.
[[RequestedModules]]
, do
Let
requiredModule
be
GetImportedModule
(
module
,
request
).
Set
index
to ?
InnerModuleLinking
(
requiredModule
,
stack
,
index
).
If
requiredModule
is a
Cyclic Module Record
, then
Assert
:
requiredModule
.
[[Status]]
is one of
linking
,
linked
,
evaluating-async
, or
evaluated
.
Assert
:
requiredModule
.
[[Status]]
is
linking
if and only if
stack
contains
requiredModule
.
If
requiredModule
.
[[Status]]
is
linking
, then
Set
module
.
[[DFSAncestorIndex]]
to
min
(
module
.
[[DFSAncestorIndex]]
,
requiredModule
.
[[DFSAncestorIndex]]
).
Perform ?
module
.
InitializeEnvironment
().
Assert
:
module
occurs exactly once in
stack
.
Assert
:
module
.
[[DFSAncestorIndex]]
≤
moduleIndex
.
If
module
.
[[DFSAncestorIndex]]
=
moduleIndex
, then
Let
done
be
false
.
Repeat, while
done
is
false
,
Let
requiredModule
be the last element of
stack
.
Remove the last element of
stack
.
Assert
:
requiredModule
is a
Cyclic Module Record
.
Set
requiredModule
.
[[Status]]
to
linked
.
If
requiredModule
and
module
are the same
Module Record
, set
done
to
true
.
Return
index
.
16.2.1.6.1.3
Evaluate ( )
The
Evaluate
concrete method of a
Cyclic Module Record
module
takes no arguments and returns a Promise.
Evaluate
transitions this module's
[[Status]]
from
linked
to either
evaluating-async
or
evaluated
. The first time it is called on a module in a given strongly connected component,
Evaluate
creates and returns a Promise which resolves when the module has finished evaluating. This Promise is stored in the
[[TopLevelCapability]]
field of the
[[CycleRoot]]
for the component. Future invocations of
Evaluate
on any module in the component return the same Promise. (Most of the work is done by the auxiliary function
InnerModuleEvaluation
.) It performs the following steps when called:
Assert
: This call to
Evaluate
is not happening at the same time as another call to
Evaluate
within the
surrounding agent
.
Assert
:
module
.
[[Status]]
is one of
linked
,
evaluating-async
, or
evaluated
.
If
module
.
[[Status]]
is either
evaluating-async
or
evaluated
, then
If
module
.
[[CycleRoot]]
is not
empty
, then
Set
module
to
module
.
[[CycleRoot]]
.
Else,
Assert
:
module
.
[[Status]]
is
evaluated
and
module
.
[[EvaluationError]]
is a
throw completion
.
If
module
.
[[TopLevelCapability]]
is not
empty
, then
Return
module
.
[[TopLevelCapability]]
.
[[Promise]]
.
Let
stack
be a new empty
List
.
Let
capability
be !
NewPromiseCapability
(
%Promise%
).
Set
module
.
[[TopLevelCapability]]
to
capability
.
Let
result
be
Completion
(
InnerModuleEvaluation
(
module
,
stack
, 0)).
If
result
is an
abrupt completion
, then
For each
Cyclic Module Record
m
of
stack
, do
Assert
:
m
.
[[Status]]
is
evaluating
.
Assert
:
m
.
[[AsyncEvaluationOrder]]
is
unset
.
Set
m
.
[[Status]]
to
evaluated
.
Set
m
.
[[EvaluationError]]
to
result
.
Assert
:
module
.
[[Status]]
is
evaluated
.
Assert
:
module
.
[[EvaluationError]]
and
result
are the same
Completion Record
.
Perform !
Call
(
capability
.
[[Reject]]
,
undefined
, «
result
.
[[Value]]
»).
Else,
Assert
:
module
.
[[Status]]
is either
evaluating-async
or
evaluated
.
Assert
:
module
.
[[EvaluationError]]
is
empty
.
If
module
.
[[Status]]
is
evaluated
, then
Assert
:
module
.
[[AsyncEvaluationOrder]]
is either
unset
or
done
.
NOTE:
module
.
[[AsyncEvaluationOrder]]
is
done
if and only if
module
had already been evaluated and that evaluation was asynchronous.
Perform !
Call
(
capability
.
[[Resolve]]
,
undefined
, «
undefined
»).
Assert
:
stack
is empty.
Return
capability
.
[[Promise]]
.
16.2.1.6.1.3.1
InnerModuleEvaluation (
module
,
stack
,
index
)
The abstract operation InnerModuleEvaluation takes arguments
module
(a
Module Record
),
stack
(a
List
of
Cyclic Module Records
), and
index
(a non-negative
integer
) and returns either a
normal completion containing
a non-negative
integer
or a
throw completion
. It is used by
Evaluate
to perform the actual evaluation process for
module
, as well as recursively on all other modules in the dependency graph. The
stack
and
index
parameters, as well as
module
's
[[DFSAncestorIndex]]
field, are used the same way as in
InnerModuleLinking
. It performs the following steps when called:
If
module
is not a
Cyclic Module Record
, then
Perform ?
EvaluateModuleSync
(
module
).
Return
index
.
If
module
.
[[Status]]
is either
evaluating-async
or
evaluated
, then
If
module
.
[[EvaluationError]]
is
empty
, return
index
.
Otherwise, return ?
module
.
[[EvaluationError]]
.
If
module
.
[[Status]]
is
evaluating
, return
index
.
Assert
:
module
.
[[Status]]
is
linked
.
Set
module
.
[[Status]]
to
evaluating
.
Let
moduleIndex
be
index
.
Set
module
.
[[DFSAncestorIndex]]
to
index
.
Set
module
.
[[PendingAsyncDependencies]]
to 0.
Set
index
to
index
+ 1.
Append
module
to
stack
.
For each
ModuleRequest Record
request
of
module
.
[[RequestedModules]]
, do
Let
requiredModule
be
GetImportedModule
(
module
,
request
).
Set
index
to ?
InnerModuleEvaluation
(
requiredModule
,
stack
,
index
).
If
requiredModule
is a
Cyclic Module Record
, then
Assert
:
requiredModule
.
[[Status]]
is one of
evaluating
,
evaluating-async
, or
evaluated
.
Assert
:
requiredModule
.
[[Status]]
is
evaluating
if and only if
stack
contains
requiredModule
.
If
requiredModule
.
[[Status]]
is
evaluating
, then
Set
module
.
[[DFSAncestorIndex]]
to
min
(
module
.
[[DFSAncestorIndex]]
,
requiredModule
.
[[DFSAncestorIndex]]
).
Else,
Set
requiredModule
to
requiredModule
.
[[CycleRoot]]
.
Assert
:
requiredModule
.
[[Status]]
is either
evaluating-async
or
evaluated
.
If
requiredModule
.
[[EvaluationError]]
is not
empty
, return ?
requiredModule
.
[[EvaluationError]]
.
If
requiredModule
.
[[AsyncEvaluationOrder]]
is an
integer
, then
Set
module
.
[[PendingAsyncDependencies]]
to
module
.
[[PendingAsyncDependencies]]
+ 1.
Append
module
to
requiredModule
.
[[AsyncParentModules]]
.
If
module
.
[[PendingAsyncDependencies]]
> 0 or
module
.
[[HasTLA]]
is
true
, then
Assert
:
module
.
[[AsyncEvaluationOrder]]
is
unset
.
Set
module
.
[[AsyncEvaluationOrder]]
to
IncrementModuleAsyncEvaluationCount
().
If
module
.
[[PendingAsyncDependencies]]
= 0, perform
ExecuteAsyncModule
(
module
).
Else,
Perform ?
module
.
ExecuteModule
()
.
Assert
:
module
occurs exactly once in
stack
.
Assert
:
module
.
[[DFSAncestorIndex]]
≤
moduleIndex
.
If
module
.
[[DFSAncestorIndex]]
=
moduleIndex
, then
Let
done
be
false
.
Repeat, while
done
is
false
,
Let
requiredModule
be the last element of
stack
.
Remove the last element of
stack
.
Assert
:
requiredModule
is a
Cyclic Module Record
.
Assert
:
requiredModule
.
[[AsyncEvaluationOrder]]
is either an
integer
or
unset
.
If
requiredModule
.
[[AsyncEvaluationOrder]]
is
unset
, set
requiredModule
.
[[Status]]
to
evaluated
.
Otherwise, set
requiredModule
.
[[Status]]
to
evaluating-async
.
If
requiredModule
and
module
are the same
Module Record
, set
done
to
true
.
Set
requiredModule
.
[[CycleRoot]]
to
module
.
Return
index
.
Note 1
A module is
evaluating
while it is being traversed by InnerModuleEvaluation. A module is
evaluated
on execution completion or
evaluating-async
during execution if its
[[HasTLA]]
field is
true
or if it has asynchronous dependencies.
Note 2
Any modules depending on a module of an asynchronous cycle when that cycle is not
evaluating
will instead depend on the execution of the root of the cycle via
[[CycleRoot]]
. This ensures that the cycle state can be treated as a single strongly connected component through its root module state.
16.2.1.6.1.3.2
ExecuteAsyncModule (
module
)
The abstract operation ExecuteAsyncModule takes argument
module
(a
Cyclic Module Record
) and returns
unused
. It performs the following steps when called:
Assert
:
module
.
[[Status]]
is either
evaluating
or
evaluating-async
.
Assert
:
module
.
[[HasTLA]]
is
true
.
Let
capability
be !
NewPromiseCapability
(
%Promise%
).
Let
fulfilledClosure
be a new
Abstract Closure
with no parameters that captures
module
and performs the following steps when called:
Perform
AsyncModuleExecutionFulfilled
(
module
).
Return
NormalCompletion
(
undefined
).
Let
onFulfilled
be
CreateBuiltinFunction
(
fulfilledClosure
, 0,
""
, « »).
Let
rejectedClosure
be a new
Abstract Closure
with parameters (
error
) that captures
module
and performs the following steps when called:
Perform
AsyncModuleExecutionRejected
(
module
,
error
).
Return
NormalCompletion
(
undefined
).
Let
onRejected
be
CreateBuiltinFunction
(
rejectedClosure
, 0,
""
, « »).
Perform
PerformPromiseThen
(
capability
.
[[Promise]]
,
onFulfilled
,
onRejected
).
Perform !
module
.
ExecuteModule
(
capability
)
.
Return
unused
.
16.2.1.6.1.3.3
GatherAvailableAncestors (
module
,
execList
)
The abstract operation GatherAvailableAncestors takes arguments
module
(a
Cyclic Module Record
) and
execList
(a
List
of
Cyclic Module Records
) and returns
unused
. It performs the following steps when called:
For each
Cyclic Module Record
m
of
module
.
[[AsyncParentModules]]
, do
If
execList
does not contain
m
and
m
.
[[CycleRoot]]
.
[[EvaluationError]]
is
empty
, then
Assert
:
m
.
[[Status]]
is
evaluating-async
.
Assert
:
m
.
[[EvaluationError]]
is
empty
.
Assert
:
m
.
[[AsyncEvaluationOrder]]
is an
integer
.
Assert
:
m
.
[[PendingAsyncDependencies]]
> 0.
Set
m
.
[[PendingAsyncDependencies]]
to
m
.
[[PendingAsyncDependencies]]
- 1.
If
m
.
[[PendingAsyncDependencies]]
= 0, then
Append
m
to
execList
.
If
m
.
[[HasTLA]]
is
false
, perform
GatherAvailableAncestors
(
m
,
execList
).
Return
unused
.
Note
When an asynchronous execution for a root
module
is fulfilled, this function determines the list of modules which are able to synchronously execute together on this completion, populating them in
execList
.
16.2.1.6.1.3.4
AsyncModuleExecutionFulfilled (
module
)
The abstract operation AsyncModuleExecutionFulfilled takes argument
module
(a
Cyclic Module Record
) and returns
unused
. It performs the following steps when called:
If
module
.
[[Status]]
is
evaluated
, then
Assert
:
module
.
[[EvaluationError]]
is not
empty
.
Return
unused
.
Assert
:
module
.
[[Status]]
is
evaluating-async
.
Assert
:
module
.
[[AsyncEvaluationOrder]]
is an
integer
.
Assert
:
module
.
[[EvaluationError]]
is
empty
.
Set
module
.
[[AsyncEvaluationOrder]]
to
done
.
Set
module
.
[[Status]]
to
evaluated
.
If
module
.
[[TopLevelCapability]]
is not
empty
, then
Assert
:
module
.
[[CycleRoot]]
and
module
are the same
Module Record
.
Perform !
Call
(
module
.
[[TopLevelCapability]]
.
[[Resolve]]
,
undefined
, «
undefined
»).
Let
execList
be a new empty
List
.
Perform
GatherAvailableAncestors
(
module
,
execList
).
Assert
: All elements of
execList
have their
[[AsyncEvaluationOrder]]
field set to an
integer
,
[[PendingAsyncDependencies]]
field set to 0, and
[[EvaluationError]]
field set to
empty
.
Let
sortedExecList
be a
List
whose elements are the elements of
execList
, sorted by their
[[AsyncEvaluationOrder]]
field in ascending order.
For each
Cyclic Module Record
m
of
sortedExecList
, do
If
m
.
[[Status]]
is
evaluated
, then
Assert
:
m
.
[[EvaluationError]]
is not
empty
.
Else if
m
.
[[HasTLA]]
is
true
, then
Perform
ExecuteAsyncModule
(
m
).
Else,
Let
result
be
Completion
(
m
.
ExecuteModule
()
).
If
result
is an
abrupt completion
, then
Perform
AsyncModuleExecutionRejected
(
m
,
result
.
[[Value]]
).
Else,
Set
m
.
[[AsyncEvaluationOrder]]
to
done
.
Set
m
.
[[Status]]
to
evaluated
.
If
m
.
[[TopLevelCapability]]
is not
empty
, then
Assert
:
m
.
[[CycleRoot]]
and
m
are the same
Module Record
.
Perform !
Call
(
m
.
[[TopLevelCapability]]
.
[[Resolve]]
,
undefined
, «
undefined
»).
Return
unused
.
16.2.1.6.1.3.5
AsyncModuleExecutionRejected (
module
,
error
)
The abstract operation AsyncModuleExecutionRejected takes arguments
module
(a
Cyclic Module Record
) and
error
(an
ECMAScript language value
) and returns
unused
. It performs the following steps when called:
If
module
.
[[Status]]
is
evaluated
, then
Assert
:
module
.
[[EvaluationError]]
is not
empty
.
Return
unused
.
Assert
:
module
.
[[Status]]
is
evaluating-async
.
Assert
:
module
.
[[AsyncEvaluationOrder]]
is an
integer
.
Assert
:
module
.
[[EvaluationError]]
is
empty
.
Set
module
.
[[EvaluationError]]
to
ThrowCompletion
(
error
).
Set
module
.
[[Status]]
to
evaluated
.
Set
module
.
[[AsyncEvaluationOrder]]
to
done
.
NOTE:
module
.
[[AsyncEvaluationOrder]]
is set to
done
for symmetry with
AsyncModuleExecutionFulfilled
. In
InnerModuleEvaluation
, the value of a module's
[[AsyncEvaluationOrder]]
internal slot is unused when its
[[EvaluationError]]
internal slot is not
empty
.
If
module
.
[[TopLevelCapability]]
is not
empty
, then
Assert
:
module
.
[[CycleRoot]]
and
module
are the same
Module Record
.
Perform !
Call
(
module
.
[[TopLevelCapability]]
.
[[Reject]]
,
undefined
, «
error
»).
For each
Cyclic Module Record
m
of
module
.
[[AsyncParentModules]]
, do
Perform
AsyncModuleExecutionRejected
(
m
,
error
).
Return
unused
.
16.2.1.6.2
Example Cyclic Module Record Graphs
This non-normative section gives a series of examples of the linking and evaluation of a few common module graphs, with a specific focus on how errors can occur.
First consider the following simple module graph:
Figure 2: A simple module graph
Let's first assume that there are no error conditions. When a
host
first calls
A
.
LoadRequestedModules
(), this will complete successfully by assumption, and recursively load the dependencies of
B
and
C
as well (respectively,
C
and none), and then set
A
.
[[Status]]
=
B
.
[[Status]]
=
C
.
[[Status]]
=
unlinked
. Then, when the
host
calls
A
.
Link
(), it will complete successfully (again by assumption) such that
A
.
[[Status]]
=
B
.
[[Status]]
=
C
.
[[Status]]
=
linked
. These preparatory steps can be performed at any time. Later, when the
host
is ready to incur any possible side effects of the modules, it can call
A
.
Evaluate
(), which will complete successfully, returning a Promise resolving to
undefined
(again by assumption), recursively having evaluated first
C
and then
B
. Each module's
[[Status]]
at this point will be
evaluated
.
Consider then cases involving linking errors, after a successful call to
A
.
LoadRequestedModules
(). If
InnerModuleLinking
of
C
succeeds but, thereafter, fails for
B
, for example because it imports something that
C
does not provide, then the original
A
.
Link
() will fail, and both
A
and
B
's
[[Status]]
remain
unlinked
.
C
's
[[Status]]
has become
linked
, though.
Finally, consider a case involving evaluation errors after a successful call to
Link
(). If
InnerModuleEvaluation
of
C
succeeds but, thereafter, fails for
B
, for example because
B
contains code that throws an exception, then the original
A
.
Evaluate
() will fail, returning a rejected Promise. The resulting exception will be recorded in both
A
and
B
's
[[EvaluationError]]
fields, and their
[[Status]]
will become
evaluated
.
C
will also become
evaluated
but, in contrast to
A
and
B
, will remain without an
[[EvaluationError]]
, as it successfully completed evaluation. Storing the exception ensures that any time a
host
tries to reuse
A
or
B
by calling their
Evaluate
() method, it will encounter the same exception. (
Hosts
are not required to reuse
Cyclic Module Records
; similarly,
hosts
are not required to expose the exception objects thrown by these methods. However, the specification enables such uses.)
Now consider a different type of error condition:
Figure 3: A module graph with an unresolvable module
In this scenario, module
A
declares a dependency on some other module, but no
Module Record
exists for that module, i.e.
HostLoadImportedModule
calls
FinishLoadingImportedModule
with an exception when asked for it. This could occur for a variety of reasons, such as the corresponding resource not existing, or the resource existing but
ParseModule
returning some errors when trying to parse the resulting source text.
Hosts
can choose to expose the cause of failure via the completion they pass to
FinishLoadingImportedModule
. In any case, this exception causes a loading failure, which results in
A
's
[[Status]]
remaining
new
.
The difference here between loading, linking and evaluation errors is due to the following characteristic:
Evaluation
must be only performed once, as it can cause side effects; it is thus important to remember whether evaluation has already been performed, even if unsuccessfully. (In the error case, it makes sense to also remember the exception because otherwise subsequent
Evaluate
() calls would have to synthesize a new one.)
Linking, on the other hand, is side-effect-free, and thus even if it fails, it can be retried at a later time with no issues.
Loading closely interacts with the
host
, and it may be desirable for some of them to allow users to retry failed loads (for example, if the failure is caused by temporarily bad network conditions).
Now, consider a module graph with a cycle:
Figure 4: A cyclic module graph
Here we assume that the entry point is module
A
, so that the
host
proceeds by calling
A
.
LoadRequestedModules
(), which performs
InnerModuleLoading
on
A
. This in turn calls
InnerModuleLoading
on
B
and
C
. Because of the cycle, this again triggers
InnerModuleLoading
on
A
, but at this point it is a no-op since
A
's dependencies loading has already been triggered during this
LoadRequestedModules
process. When all the modules in the graph have been successfully loaded, their
[[Status]]
transitions from
new
to
unlinked
at the same time.
Then the
host
proceeds by calling
A
.
Link
(), which performs
InnerModuleLinking
on
A
. This in turn calls
InnerModuleLinking
on
B
. Because of the cycle, this again triggers
InnerModuleLinking
on
A
, but at this point it is a no-op since
A
.
[[Status]]
is already
linking
.
B
.
[[Status]]
itself remains
linking
when control gets back to
A
and
InnerModuleLinking
is triggered on
C
. After this returns with
C
.
[[Status]]
being
linked
, both
A
and
B
transition from
linking
to
linked
together; this is by design, since they form a strongly connected component. It's possible to transition the status of modules in the same SCC at the same time because during this phase the module graph is traversed with a depth-first search.
An analogous story occurs for the evaluation phase of a cyclic module graph, in the success case.
Now consider a case where
A
has a linking error; for example, it tries to import a binding from
C
that does not exist. In that case, the above steps still occur, including the early return from the second call to
InnerModuleLinking
on
A
. However, once we unwind back to the original
InnerModuleLinking
on
A
, it fails during
InitializeEnvironment
, namely right after
C
.
ResolveExport
(). The thrown
SyntaxError
exception propagates up to
A
.
Link
, which resets all modules that are currently on its
stack
(these are always exactly the modules that are still
linking
). Hence both
A
and
B
become
unlinked
. Note that
C
is left as
linked
.
Alternatively, consider a case where
A
has an evaluation error; for example, its source code throws an exception. In that case, the evaluation-time analogue of the above steps still occurs, including the early return from the second call to
InnerModuleEvaluation
on
A
. However, once we unwind back to the original
InnerModuleEvaluation
on
A
, it fails by assumption. The exception thrown propagates up to
A
.
Evaluate
(), which records the error in all modules that are currently on its
stack
(i.e., the modules that are still
evaluating
) as well as via
[[AsyncParentModules]]
, which form a chain for modules which contain or depend on top-level
await
through the whole dependency graph through the
AsyncModuleExecutionRejected
algorithm. Hence both
A
and
B
become
evaluated
and the exception is recorded in both
A
and
B
's
[[EvaluationError]]
fields, while
C
is left as
evaluated
with no
[[EvaluationError]]
.
Lastly, consider a module graph with a cycle, where all modules complete asynchronously:
Figure 5: An asynchronous cyclic module graph
Loading and linking happen as before, and all modules end up with
[[Status]]
set to
linked
.
Calling
A
.
Evaluate
() calls
InnerModuleEvaluation
on
A
,
B
, and
D
, which all transition to
evaluating
. Then
InnerModuleEvaluation
is called on
A
again, which is a no-op because it is already
evaluating
. At this point,
D
.
[[PendingAsyncDependencies]]
is 0, so
ExecuteAsyncModule
(
D
) is called and we call
D
.
ExecuteModule
with a new PromiseCapability tracking the asynchronous execution of
D
. We unwind back to the
InnerModuleEvaluation
on
B
, setting
B
.
[[PendingAsyncDependencies]]
to 1 and
B
.
[[AsyncEvaluationOrder]]
to 1. We unwind back to the original
InnerModuleEvaluation
on
A
, setting
A
.
[[PendingAsyncDependencies]]
to 1. In the next iteration of the loop over
A
's dependencies, we call
InnerModuleEvaluation
on
C
and thus on
D
(again a no-op) and
E
. As
E
has no dependencies and is not part of a cycle, we call
ExecuteAsyncModule
(
E
) in the same manner as
D
and
E
is immediately removed from the stack. We unwind once more to the
InnerModuleEvaluation
on
C
, setting
C
.
[[AsyncEvaluationOrder]]
to 3. Now we finish the loop over
A
's dependencies, set
A
.
[[AsyncEvaluationOrder]]
to 4, and remove the entire strongly connected component from the stack, transitioning all of the modules to
evaluating-async
at once. At this point, the fields of the modules are as given in
Table 43
.
Table 43: Module fields after the initial
Evaluate
() call
Field
Module
A
B
C
D
E
[[DFSAncestorIndex]]
0
0
0
0
4
[[Status]]
evaluating-async
evaluating-async
evaluating-async
evaluating-async
evaluating-async
[[AsyncEvaluationOrder]]
4
1
3
0
2
[[AsyncParentModules]]
« »
«
A
»
«
A
»
«
B
,
C
»
«
C
»
[[PendingAsyncDependencies]]
2 (
B
and
C
)
1 (
D
)
2 (
D
and
E
)
0
0
Let us assume that
E
finishes executing first. When that happens,
AsyncModuleExecutionFulfilled
is called,
E
.
[[Status]]
is set to
evaluated
and
C
.
[[PendingAsyncDependencies]]
is decremented to become 1. The fields of the updated modules are as given in
Table 44
.
Table 44: Module fields after module
E
finishes executing
Field
Module
C
E
[[DFSAncestorIndex]]
0
4
[[Status]]
evaluating-async
evaluated
[[AsyncEvaluationOrder]]
3
done
[[AsyncParentModules]]
«
A
»
«
C
»
[[PendingAsyncDependencies]]
1 (
D
)
0
D
is next to finish (as it was the only module that was still executing). When that happens,
AsyncModuleExecutionFulfilled
is called again and
D
.
[[Status]]
is set to
evaluated
. Its ancestors available for execution are
B
(whose
[[AsyncEvaluationOrder]]
is 1) and
C
(whose
[[AsyncEvaluationOrder]]
is 3), thus
B
will be handled first:
B
.
[[PendingAsyncDependencies]]
is decremented to become 0,
ExecuteAsyncModule
is called on
B
, and it starts executing.
C
.
[[PendingAsyncDependencies]]
is also decremented to become 0, and
C
starts executing (potentially in parallel to
B
if
B
contains an
await
). The fields of the updated modules are as given in
Table 45
.
Table 45: Module fields after module
D
finishes executing
Field
Module
B
C
D
[[DFSAncestorIndex]]
0
0
0
[[Status]]
evaluating-async
evaluating-async
evaluated
[[AsyncEvaluationOrder]]
1
3
done
[[AsyncParentModules]]
«
A
»
«
A
»
«
B
,
C
»
[[PendingAsyncDependencies]]
0
0
0
Let us assume that
C
finishes executing next. When that happens,
AsyncModuleExecutionFulfilled
is called again,
C
.
[[Status]]
is set to
evaluated
and
A
.
[[PendingAsyncDependencies]]
is decremented to become 1. The fields of the updated modules are as given in
Table 46
.
Table 46: Module fields after module
C
finishes executing
Field
Module
A
C
[[DFSAncestorIndex]]
0
0
[[Status]]
evaluating-async
evaluated
[[AsyncEvaluationOrder]]
4
done
[[AsyncParentModules]]
« »
«
A
»
[[PendingAsyncDependencies]]
1 (
B
)
0
Then,
B
finishes executing. When that happens,
AsyncModuleExecutionFulfilled
is called again and
B
.
[[Status]]
is set to
evaluated
.
A
.
[[PendingAsyncDependencies]]
is decremented to become 0, so
ExecuteAsyncModule
is called and it starts executing. The fields of the updated modules are as given in
Table 47
.
Table 47: Module fields after module
B
finishes executing
Field
Module
A
B
[[DFSAncestorIndex]]
0
0
[[Status]]
evaluating-async
evaluated
[[AsyncEvaluationOrder]]
4
done
[[AsyncParentModules]]
« »
«
A
»
[[PendingAsyncDependencies]]
0
0
Finally,
A
finishes executing. When that happens,
AsyncModuleExecutionFulfilled
is called again and
A
.
[[Status]]
is set to
evaluated
. At this point, the Promise in
A
.
[[TopLevelCapability]]
(which was returned from
A
.
Evaluate
()) is resolved, and this concludes the handling of this module graph. The fields of the updated module are as given in
Table 48
.
Table 48: Module fields after module
A
finishes executing
Field
Module
A
[[DFSAncestorIndex]]
0
[[Status]]
evaluated
[[AsyncEvaluationOrder]]
done
[[AsyncParentModules]]
« »
[[PendingAsyncDependencies]]
0
Alternatively, consider a failure case where
C
fails execution and returns an error before
B
has finished executing. When that happens,
AsyncModuleExecutionRejected
is called, which sets
C
.
[[Status]]
to
evaluated
and
C
.
[[EvaluationError]]
to the error. It then propagates this error to all of the AsyncParentModules by performing
AsyncModuleExecutionRejected
on each of them. The fields of the updated modules are as given in
Table 49
.
Table 49: Module fields after module
C
finishes with an error
Field
Module
A
C
[[DFSAncestorIndex]]
0
0
[[Status]]
evaluated
evaluated
[[AsyncEvaluationOrder]]
done
done
[[AsyncParentModules]]
« »
«
A
»
[[PendingAsyncDependencies]]
1 (
B
)
0
[[EvaluationError]]
empty
C
's evaluation error
A
will be rejected with the same error as
C
since
C
will call
AsyncModuleExecutionRejected
on
A
with
C
's error.
A
.
[[Status]]
is set to
evaluated
. At this point the Promise in
A
.
[[TopLevelCapability]]
(which was returned from
A
.
Evaluate
()) is rejected. The fields of the updated module are as given in
Table 50
.
Table 50: Module fields after module
A
is rejected
Field
Module
A
[[DFSAncestorIndex]]
0
[[Status]]
evaluated
[[AsyncEvaluationOrder]]
done
[[AsyncParentModules]]
« »
[[PendingAsyncDependencies]]
0
[[EvaluationError]]
C
's
Evaluation
Error
Then,
B
finishes executing without an error. When that happens,
AsyncModuleExecutionFulfilled
is called again and
B
.
[[Status]]
is set to
evaluated
.
GatherAvailableAncestors
is called on
B
. However,
A
.
[[CycleRoot]]
is
A
which has an evaluation error, so it will not be added to the returned
sortedExecList
and
AsyncModuleExecutionFulfilled
will return without further processing. Any future importer of
B
will resolve the rejection of
B
.
[[CycleRoot]]
.
[[EvaluationError]]
from the evaluation error from
C
that was set on the cycle root
A
. The fields of the updated modules are as given in
Table 51
.
Table 51: Module fields after module
B
finishes executing in an erroring graph
Field
Module
A
B
[[DFSAncestorIndex]]
0
0
[[Status]]
evaluated
evaluated
[[AsyncEvaluationOrder]]
4
1
[[AsyncParentModules]]
« »
«
A
»
[[PendingAsyncDependencies]]
0
0
[[EvaluationError]]
C
's
Evaluation
Error
empty
16.2.1.7
Source Text Module Records
A
Source Text Module Record
is used to represent information about a module that was defined from
ECMAScript source text
(
11
) that was parsed using the
goal symbol
Module
. Its fields contain digested information about the names that are imported and exported by the module, and its concrete methods use these digests to link and evaluate the module.
A
Source Text Module Record
can exist in a module graph with other subclasses of the abstract
Module Record
type, and can participate in cycles with other subclasses of the
Cyclic Module Record
type.
In addition to the fields defined in
Table 40
,
Source Text Module Records
have the additional fields listed in
Table 52
. Each of these fields is initially set in
ParseModule
.
Table 52: Additional Fields of
Source Text Module Records
Field Name
Value Type
Meaning
[[ECMAScriptCode]]
a
Parse Node
The result of parsing the source text of this module using
Module
as the
goal symbol
.
[[Context]]
an
ECMAScript code execution context
or
empty
The
execution context
associated with this module. It is
empty
until the module's environment has been initialized.
[[ImportMeta]]
an Object or
empty
An object exposed through the
import.meta
meta property. It is
empty
until it is accessed by ECMAScript code.
[[ImportEntries]]
a
List
of
ImportEntry Records
A
List
of ImportEntry records derived from the code of this module.
[[LocalExportEntries]]
a
List
of
ExportEntry Records
A
List
of ExportEntry records derived from the code of this module that correspond to declarations that occur within the module.
[[IndirectExportEntries]]
a
List
of
ExportEntry Records
A
List
of ExportEntry records derived from the code of this module that correspond to reexported imports that occur within the module or exports from
export * as namespace
declarations.
[[StarExportEntries]]
a
List
of
ExportEntry Records
A
List
of ExportEntry records derived from the code of this module that correspond to
export *
declarations that occur within the module, not including
export * as namespace
declarations.
An
ImportEntry Record
is a
Record
that digests information about a single declarative import. Each
ImportEntry Record
has the fields defined in
Table 53
:
Table 53:
ImportEntry Record
Fields
Field Name
Value Type
Meaning
[[ModuleRequest]]
a
ModuleRequest Record
ModuleRequest Record
representing the
ModuleSpecifier
and import attributes of the
ImportDeclaration
.
[[ImportName]]
a String or
namespace-object
The name under which the desired binding is exported by the module identified by
[[ModuleRequest]]
. The value
namespace-object
indicates that the import request is for the target module's namespace object.
[[LocalName]]
a String
The name that is used to locally access the imported value from within the importing module.
Note 1
Table 54
gives examples of ImportEntry records fields used to represent the syntactic import forms:
Table 54 (Informative): Import Forms Mappings to
ImportEntry Records
Import Statement Form
[[ModuleRequest]]
[[ImportName]]
[[LocalName]]
import v from "mod";
"mod"
"default"
"v"
import * as ns from "mod";
"mod"
namespace-object
"ns"
import {x} from "mod";
"mod"
"x"
"x"
import {x as v} from "mod";
"mod"
"x"
"v"
import "mod";
An
ImportEntry Record
is not created.
An
ExportEntry Record
is a
Record
that digests information about a single declarative export. Each
ExportEntry Record
has the fields defined in
Table 55
:
Table 55:
ExportEntry Record
Fields
Field Name
Value Type
Meaning
[[ExportName]]
a String or
null
The name used to export this binding by this module.
[[ModuleRequest]]
a
ModuleRequest Record
or
null
The
ModuleRequest Record
representing the
ModuleSpecifier
and import attributes of the
ExportDeclaration
.
null
if the
ExportDeclaration
does not have a
ModuleSpecifier
.
[[ImportName]]
a String,
null
,
all
, or
all-but-default
The name under which the desired binding is exported by the module identified by
[[ModuleRequest]]
.
null
if the
ExportDeclaration
does not have a
ModuleSpecifier
.
all
is used for
export * as ns from "mod"
declarations.
all-but-default
is used for
export * from "mod"
declarations.
[[LocalName]]
a String or
null
The name that is used to locally access the exported value from within the importing module.
null
if the exported value is not locally accessible from within the module.
Note 2
Table 56
gives examples of the ExportEntry record fields used to represent the syntactic export forms:
Table 56 (Informative): Export Forms Mappings to
ExportEntry Records
Export Statement Form
[[ExportName]]
[[ModuleRequest]]
[[ImportName]]
[[LocalName]]
export var v;
"v"
null
null
"v"
export default function f() {}
"default"
null
null
"f"
export default function () {}
"default"
null
null
"*default*"
export default 42;
"default"
null
null
"*default*"
export {x};
"x"
null
null
"x"
export {v as x};
"x"
null
null
"v"
export {x} from "mod";
"x"
"mod"
"x"
null
export {v as x} from "mod";
"x"
"mod"
"v"
null
export * from "mod";
null
"mod"
all-but-default
null
export * as ns from "mod";
"ns"
"mod"
all
null
The following definitions specify the required concrete methods and other
abstract operations
for
Source Text Module Records
16.2.1.7.1
ParseModule (
sourceText
,
realm
,
hostDefined
)
The abstract operation ParseModule takes arguments
sourceText
(
ECMAScript source text
),
realm
(a
Realm Record
), and
hostDefined
(anything) and returns a
Source Text Module Record
or a non-empty
List
of
SyntaxError
objects. It creates a
Source Text Module Record
based upon the result of parsing
sourceText
as a
Module
. It performs the following steps when called:
Let
body
be
ParseText
(
sourceText
,
Module
).
If
body
is a
List
of errors, return
body
.
Let
requestedModules
be the
ModuleRequests
of
body
.
Let
importEntries
be the
ImportEntries
of
body
.
Let
importedBoundNames
be
ImportedLocalNames
(
importEntries
).
Let
indirectExportEntries
be a new empty
List
.
Let
localExportEntries
be a new empty
List
.
Let
starExportEntries
be a new empty
List
.
Let
exportEntries
be the
ExportEntries
of
body
.
For each
ExportEntry Record
ee
of
exportEntries
, do
If
ee
.
[[ModuleRequest]]
is
null
, then
If
importedBoundNames
does not contain
ee
.
[[LocalName]]
, then
Append
ee
to
localExportEntries
.
Else,
NOTE: When exporting a binding or namespace object which was originally imported from another module, the
ExportEntry Record
is rewritten to match the form it would have if the binding or namespace object had been re-exported directly from the original module rather than imported then exported. This allows conflicts which arise from exporting the same binding or namespace twice under the same name through
export * from
to be ignored rather than being treated as ambiguous in step
9.e.iii
of
the ResolveExport concrete method of Source Text Module Records
.
Let
ie
be the element of
importEntries
whose
[[LocalName]]
is
ee
.
[[LocalName]]
.
If
ie
.
[[ImportName]]
is
namespace-object
, then
NOTE: This is a re-export of an imported module namespace object.
Append the
ExportEntry Record
{
[[ModuleRequest]]
:
ie
.
[[ModuleRequest]]
,
[[ImportName]]
:
all
,
[[LocalName]]
:
null
,
[[ExportName]]
:
ee
.
[[ExportName]]
} to
indirectExportEntries
.
Else,
NOTE: This is a re-export of a single name.
Append the
ExportEntry Record
{
[[ModuleRequest]]
:
ie
.
[[ModuleRequest]]
,
[[ImportName]]
:
ie
.
[[ImportName]]
,
[[LocalName]]
:
null
,
[[ExportName]]
:
ee
.
[[ExportName]]
} to
indirectExportEntries
.
Else if
ee
.
[[ImportName]]
is
all-but-default
, then
Assert
:
ee
.
[[ExportName]]
is
null
.
Append
ee
to
starExportEntries
.
Else,
Append
ee
to
indirectExportEntries
.
Let
async
be
body
Contains
await
.
Return
Source Text Module Record
{
[[Realm]]
:
realm
,
[[Environment]]
:
empty
,
[[Namespace]]
:
empty
,
[[CycleRoot]]
:
empty
,
[[HasTLA]]
:
async
,
[[AsyncEvaluationOrder]]
:
unset
,
[[TopLevelCapability]]
:
empty
,
[[AsyncParentModules]]
: « »,
[[PendingAsyncDependencies]]
:
empty
,
[[Status]]
:
new
,
[[EvaluationError]]
:
empty
,
[[HostDefined]]
:
hostDefined
,
[[ECMAScriptCode]]
:
body
,
[[Context]]
:
empty
,
[[ImportMeta]]
:
empty
,
[[RequestedModules]]
:
requestedModules
,
[[LoadedModules]]
: « »,
[[ImportEntries]]
:
importEntries
,
[[LocalExportEntries]]
:
localExportEntries
,
[[IndirectExportEntries]]
:
indirectExportEntries
,
[[StarExportEntries]]
:
starExportEntries
,
[[DFSAncestorIndex]]
:
empty
}.
Note
An implementation may parse module source text and analyse it for Early Error conditions prior to the evaluation of ParseModule for that module source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseModule upon that source text.
16.2.1.7.2
Implementation of Module Record Abstract Methods
The following are the concrete methods for
Source Text Module Record
that implement the corresponding
Module Record
abstract methods defined in
Table 39
.
16.2.1.7.2.1
GetExportedNames ( [
exportStarSet
] )
The
GetExportedNames
concrete method of a
Source Text Module Record
module
takes optional argument
exportStarSet
(a
List
of
Source Text Module Records
) and returns a
List
of Strings. It performs the following steps when called:
Assert
:
module
.
[[Status]]
is not
new
.
If
exportStarSet
is not present, set
exportStarSet
to a new empty
List
.
If
exportStarSet
contains
module
, then
Assert
: We've reached the starting point of an
export *
circularity.
Return a new empty
List
.
Append
module
to
exportStarSet
.
Let
exportedNames
be a new empty
List
.
For each
ExportEntry Record
e
of
module
.
[[LocalExportEntries]]
, do
Assert
:
module
provides the direct binding for this export.
Assert
:
e
.
[[ExportName]]
is not
null
.
Append
e
.
[[ExportName]]
to
exportedNames
.
For each
ExportEntry Record
e
of
module
.
[[IndirectExportEntries]]
, do
Assert
:
module
imports a specific binding for this export.
Assert
:
e
.
[[ExportName]]
is not
null
.
Append
e
.
[[ExportName]]
to
exportedNames
.
For each
ExportEntry Record
e
of
module
.
[[StarExportEntries]]
, do
Assert
:
e
.
[[ModuleRequest]]
is not
null
.
Let
requestedModule
be
GetImportedModule
(
module
,
e
.
[[ModuleRequest]]
).
Let
starNames
be
requestedModule
.
GetExportedNames
(
exportStarSet
).
For each element
n
of
starNames
, do
If
n
is not
"default"
, then
If
exportedNames
does not contain
n
, then
Append
n
to
exportedNames
.
Return
exportedNames
.
Note
GetExportedNames
does not filter out or throw an exception for names that have ambiguous star export bindings.
16.2.1.7.2.2
ResolveExport (
exportName
[ ,
resolveSet
] )
The
ResolveExport
concrete method of a
Source Text Module Record
module
takes argument
exportName
(a String) and optional argument
resolveSet
(a
List
of
Records
with fields
[[Module]]
(a
Module Record
) and
[[ExportName]]
(a String)) and returns a
ResolvedBinding Record
,
null
, or
ambiguous
.
ResolveExport
attempts to resolve an imported binding to the actual defining module and local binding name. The defining module may be the module represented by the
Module Record
this method was invoked on or some other module that is imported by that module. The parameter
resolveSet
is used to detect unresolved circular import/export paths. If a pair consisting of specific
Module Record
and
exportName
is reached that is already in
resolveSet
, an import circularity has been encountered. Before recursively calling
ResolveExport
, a pair consisting of
module
and
exportName
is added to
resolveSet
.
If a defining module is found, a
ResolvedBinding Record
{
[[Module]]
,
[[BindingName]]
} is returned. This record identifies the resolved binding of the originally requested export, unless this is the export of a namespace with no local binding. In this case,
[[BindingName]]
will be set to
namespace
. If no definition was found or the request is found to be circular,
null
is returned. If the request is found to be ambiguous,
ambiguous
is returned.
It performs the following steps when called:
Assert
:
module
.
[[Status]]
is not
new
.
If
resolveSet
is not present, set
resolveSet
to a new empty
List
.
For each
Record
{
[[Module]]
,
[[ExportName]]
}
r
of
resolveSet
, do
If
module
and
r
.
[[Module]]
are the same
Module Record
and
exportName
is
r
.
[[ExportName]]
, then
Assert
: This is a circular import request.
Return
null
.
Append the
Record
{
[[Module]]
:
module
,
[[ExportName]]
:
exportName
} to
resolveSet
.
For each
ExportEntry Record
e
of
module
.
[[LocalExportEntries]]
, do
If
e
.
[[ExportName]]
is
exportName
, then
Assert
:
module
provides the direct binding for this export.
Return
ResolvedBinding Record
{
[[Module]]
:
module
,
[[BindingName]]
:
e
.
[[LocalName]]
}.
For each
ExportEntry Record
e
of
module
.
[[IndirectExportEntries]]
, do
If
e
.
[[ExportName]]
is
exportName
, then
Assert
:
e
.
[[ModuleRequest]]
is not
null
.
Let
importedModule
be
GetImportedModule
(
module
,
e
.
[[ModuleRequest]]
).
If
e
.
[[ImportName]]
is
all
, then
Assert
:
module
does not provide the direct binding for this export.
Return
ResolvedBinding Record
{
[[Module]]
:
importedModule
,
[[BindingName]]
:
namespace
}.
Else,
Assert
:
module
imports a specific binding for this export.
Assert
:
e
.
[[ImportName]]
is a String
.
Return
importedModule
.
ResolveExport
(
e
.
[[ImportName]]
,
resolveSet
).
If
exportName
is
"default"
, then
Assert
: A
default
export was not explicitly defined by this module.
Return
null
.
NOTE: A
default
export cannot be provided by an
export * from "mod"
declaration.
Let
starResolution
be
null
.
For each
ExportEntry Record
e
of
module
.
[[StarExportEntries]]
, do
Assert
:
e
.
[[ModuleRequest]]
is not
null
.
Let
importedModule
be
GetImportedModule
(
module
,
e
.
[[ModuleRequest]]
).
Let
resolution
be
importedModule
.
ResolveExport
(
exportName
,
resolveSet
).
If
resolution
is
ambiguous
, return
ambiguous
.
If
resolution
is not
null
, then
Assert
:
resolution
is a
ResolvedBinding Record
.
If
starResolution
is
null
, then
Set
starResolution
to
resolution
.
Else,
Assert
: There is more than one
*
export that includes the requested name.
If
resolution
.
[[Module]]
and
starResolution
.
[[Module]]
are not the same
Module Record
, return
ambiguous
.
If
resolution
.
[[BindingName]]
is not
starResolution
.
[[BindingName]]
, return
ambiguous
.
Return
starResolution
.
16.2.1.7.3
Implementation of Cyclic Module Record Abstract Methods
The following are the concrete methods for
Source Text Module Record
that implement the corresponding
Cyclic Module Record
abstract methods defined in
Table 41
.
16.2.1.7.3.1
InitializeEnvironment ( )
The
InitializeEnvironment
concrete method of a
Source Text Module Record
module
takes no arguments and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
For each
ExportEntry Record
e
of
module
.
[[IndirectExportEntries]]
, do
Assert
:
e
.
[[ExportName]]
is not
null
.
Let
resolution
be
module
.
ResolveExport
(
e
.
[[ExportName]]
).
If
resolution
is either
null
or
ambiguous
, throw a
SyntaxError
exception.
Assert
:
resolution
is a
ResolvedBinding Record
.
Assert
: All named exports from
module
are resolvable.
Let
realm
be
module
.
[[Realm]]
.
Assert
:
realm
is not
undefined
.
Let
env
be
NewModuleEnvironment
(
realm
.
[[GlobalEnv]]
).
Set
module
.
[[Environment]]
to
env
.
For each
ImportEntry Record
in
of
module
.
[[ImportEntries]]
, do
Let
importedModule
be
GetImportedModule
(
module
,
in
.
[[ModuleRequest]]
).
If
in
.
[[ImportName]]
is
namespace-object
, then
Let
namespace
be
GetModuleNamespace
(
importedModule
).
Perform !
env
.
CreateImmutableBinding
(
in
.
[[LocalName]]
,
true
).
Perform !
env
.
InitializeBinding
(
in
.
[[LocalName]]
,
namespace
).
Else,
Let
resolution
be
importedModule
.
ResolveExport
(
in
.
[[ImportName]]
).
If
resolution
is either
null
or
ambiguous
, throw a
SyntaxError
exception.
If
resolution
.
[[BindingName]]
is
namespace
, then
Let
namespace
be
GetModuleNamespace
(
resolution
.
[[Module]]
).
Perform !
env
.
CreateImmutableBinding
(
in
.
[[LocalName]]
,
true
).
Perform !
env
.
InitializeBinding
(
in
.
[[LocalName]]
,
namespace
).
Else,
Perform
CreateImportBinding
(
env
,
in
.
[[LocalName]]
,
resolution
.
[[Module]]
,
resolution
.
[[BindingName]]
).
Let
moduleContext
be a new
ECMAScript code execution context
.
Set the Function of
moduleContext
to
null
.
Assert
:
module
.
[[Realm]]
is not
undefined
.
Set the
Realm
of
moduleContext
to
module
.
[[Realm]]
.
Set the ScriptOrModule of
moduleContext
to
module
.
Set the VariableEnvironment of
moduleContext
to
module
.
[[Environment]]
.
Set the LexicalEnvironment of
moduleContext
to
module
.
[[Environment]]
.
Set the PrivateEnvironment of
moduleContext
to
null
.
Set
module
.
[[Context]]
to
moduleContext
.
Push
moduleContext
onto the
execution context stack
;
moduleContext
is now the
running execution context
.
Let
code
be
module
.
[[ECMAScriptCode]]
.
Let
varDeclarations
be the
VarScopedDeclarations
of
code
.
Let
declaredVarNames
be a new empty
List
.
For each element
d
of
varDeclarations
, do
For each element
dn
of the
BoundNames
of
d
, do
If
declaredVarNames
does not contain
dn
, then
Perform !
env
.
CreateMutableBinding
(
dn
,
false
).
Perform !
env
.
InitializeBinding
(
dn
,
undefined
).
Append
dn
to
declaredVarNames
.
Let
lexDeclarations
be the
LexicallyScopedDeclarations
of
code
.
Let
privateEnv
be
null
.
For each element
d
of
lexDeclarations
, do
For each element
dn
of the
BoundNames
of
d
, do
If
IsConstantDeclaration
of
d
is
true
, then
Perform !
env
.
CreateImmutableBinding
(
dn
,
true
).
Else,
Perform !
env
.
CreateMutableBinding
(
dn
,
false
).
If
d
is either a
FunctionDeclaration
, a
GeneratorDeclaration
, an
AsyncFunctionDeclaration
, or an
AsyncGeneratorDeclaration
, then
Let
fo
be
InstantiateFunctionObject
of
d
with arguments
env
and
privateEnv
.
Perform !
env
.
InitializeBinding
(
dn
,
fo
).
Remove
moduleContext
from the
execution context stack
.
Return
unused
.
16.2.1.7.3.2
ExecuteModule ( [
capability
] )
The
ExecuteModule
concrete method of a
Source Text Module Record
module
takes optional argument
capability
(a
PromiseCapability Record
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
moduleContext
be a new
ECMAScript code execution context
.
Set the Function of
moduleContext
to
null
.
Set the
Realm
of
moduleContext
to
module
.
[[Realm]]
.
Set the ScriptOrModule of
moduleContext
to
module
.
Assert
:
module
has been linked and declarations in its module environment have been instantiated.
Set the VariableEnvironment of
moduleContext
to
module
.
[[Environment]]
.
Set the LexicalEnvironment of
moduleContext
to
module
.
[[Environment]]
.
Suspend the
running execution context
.
If
module
.
[[HasTLA]]
is
false
, then
Assert
:
capability
is not present.
Push
moduleContext
onto the
execution context stack
;
moduleContext
is now the
running execution context
.
Let
result
be
Completion
(
Evaluation
of
module
.
[[ECMAScriptCode]]
).
Suspend
moduleContext
and remove it from the
execution context stack
.
Resume the context that is now on the top of the
execution context stack
as the
running execution context
.
If
result
is an
abrupt completion
, then
Return ?
result
.
Else,
Assert
:
capability
is a
PromiseCapability Record
.
Perform
AsyncBlockStart
(
capability
,
module
.
[[ECMAScriptCode]]
,
moduleContext
).
Return
unused
.
16.2.1.8
Synthetic Module Records
A
Synthetic Module Record
is used to represent information about a module that is defined by specifications. Its exported names are statically defined at creation, while their corresponding values can change over time using
SetSyntheticModuleExport
. It has no imports or dependencies.
Note
A Synthetic Module Record could be used for defining a variety of module types: for example, JSON modules or CSS modules.
In addition to the fields defined in
Table 38
Synthetic Module Records have the additional fields listed in
Table 57
.
Table 57: Additional Fields of
Synthetic Module Records
Field Name
Value Type
Meaning
[[ExportNames]]
a
List
of Strings
The names of the exports of the module. This list does not contain duplicates.
[[EvaluationSteps]]
an
Abstract Closure
The initialization logic to perform upon evaluation of the module, taking the
Synthetic Module Record
as its sole argument. It must not modify
[[ExportNames]]
. It may return an
abrupt completion
.
16.2.1.8.1
CreateDefaultExportSyntheticModule (
defaultExport
)
The abstract operation CreateDefaultExportSyntheticModule takes argument
defaultExport
(an
ECMAScript language value
) and returns a
Synthetic Module Record
. It creates a
Synthetic Module Record
whose default export is
defaultExport
. It performs the following steps when called:
Let
realm
be
the current Realm Record
.
Let
setDefaultExport
be a new
Abstract Closure
with parameters (
module
) that captures
defaultExport
and performs the following steps when called:
Perform
SetSyntheticModuleExport
(
module
,
"default"
,
defaultExport
).
Return
NormalCompletion
(
unused
).
Return the
Synthetic Module Record
{
[[Realm]]
:
realm
,
[[Environment]]
:
empty
,
[[Namespace]]
:
empty
,
[[HostDefined]]
:
undefined
,
[[ExportNames]]
: «
"default"
»,
[[EvaluationSteps]]
:
setDefaultExport
}.
16.2.1.8.2
ParseJSONModule (
source
)
The abstract operation ParseJSONModule takes argument
source
(a String) and returns either a
normal completion containing
a
Synthetic Module Record
, or a
throw completion
. It performs the following steps when called:
Let
json
be ?
ParseJSON
(
source
).
Return
CreateDefaultExportSyntheticModule
(
json
).
16.2.1.8.3
SetSyntheticModuleExport (
module
,
exportName
,
exportValue
)
The abstract operation SetSyntheticModuleExport takes arguments
module
(a
Synthetic Module Record
),
exportName
(a String), and
exportValue
(an
ECMAScript language value
) and returns
unused
. It can be used to set or change the exported value for an existing export of a
Synthetic Module Record
. It performs the following steps when called:
Assert
:
module
.
[[ExportNames]]
contains
exportName
.
Let
envRec
be
module
.
[[Environment]]
.
Assert
:
envRec
is not
empty
.
Perform !
envRec
.
SetMutableBinding
(
exportName
,
exportValue
,
true
).
Return
unused
.
16.2.1.8.4
Implementation of Module Record Abstract Methods
The following are the concrete methods for
Synthetic Module Record
that implement the corresponding
Module Record
abstract methods defined in
Table 39
.
16.2.1.8.4.1
LoadRequestedModules ( [
hostDefined
] )
The
LoadRequestedModules
concrete method of a
Synthetic Module Record
module
takes optional argument
hostDefined
(anything) and returns a Promise. It performs the following steps when called:
NOTE: This implementation of
LoadRequestedModules
does not use
hostDefined
.
Return !
PromiseResolve
(
%Promise%
,
undefined
).
Note
Synthetic Module Records
have no dependencies.
16.2.1.8.4.2
GetExportedNames ( [
exportStarSet
] )
The
GetExportedNames
concrete method of a
Synthetic Module Record
module
takes optional argument
exportStarSet
(a
List
of
Source Text Module Records
) and returns a
List
of Strings. It performs the following steps when called:
NOTE: This implementation of
GetExportedNames
does not use
exportStarSet
.
Return
module
.
[[ExportNames]]
.
16.2.1.8.4.3
ResolveExport (
exportName
[ ,
resolveSet
] )
The
ResolveExport
concrete method of a
Synthetic Module Record
module
takes argument
exportName
(a String) and optional argument
resolveSet
(a
List
of
Records
with fields
[[Module]]
(a
Module Record
) and
[[ExportName]]
(a String)) and returns a
ResolvedBinding Record
,
null
, or
ambiguous
. It performs the following steps when called:
NOTE: This implementation of
ResolveExport
does not use
resolveSet
.
If
module
.
[[ExportNames]]
does not contain
exportName
, return
null
.
Return
ResolvedBinding Record
{
[[Module]]
:
module
,
[[BindingName]]
:
exportName
}.
16.2.1.8.4.4
Link ( )
The
Link
concrete method of a
Synthetic Module Record
module
takes no arguments and returns a
normal completion containing
unused
. It performs the following steps when called:
Let
realm
be
module
.
[[Realm]]
.
Let
env
be
NewModuleEnvironment
(
realm
.
[[GlobalEnv]]
).
Set
module
.
[[Environment]]
to
env
.
For each String
exportName
of
module
.
[[ExportNames]]
, do
Perform !
env
.
CreateMutableBinding
(
exportName
,
false
).
Perform !
env
.
InitializeBinding
(
exportName
,
undefined
).
Return
NormalCompletion
(
unused
).
16.2.1.8.4.5
Evaluate ( )
The
Evaluate
concrete method of a
Synthetic Module Record
module
takes no arguments and returns a Promise. It performs the following steps when called:
Let
moduleContext
be a new
ECMAScript code execution context
.
Set the Function of
moduleContext
to
null
.
Set the
Realm
of
moduleContext
to
module
.
[[Realm]]
.
Set the ScriptOrModule of
moduleContext
to
module
.
Set the VariableEnvironment of
moduleContext
to
module
.
[[Environment]]
.
Set the LexicalEnvironment of
moduleContext
to
module
.
[[Environment]]
.
Suspend the
running execution context
.
Push
moduleContext
onto the
execution context stack
;
moduleContext
is now the
running execution context
.
Let
steps
be
module
.
[[EvaluationSteps]]
.
Let
result
be
Completion
(
steps
(
module
)).
Suspend
moduleContext
and remove it from the
execution context stack
.
Resume the context that is now on the top of the
execution context stack
as the
running execution context
.
Let
pc
be !
NewPromiseCapability
(
%Promise%
).
IfAbruptRejectPromise
(
result
,
pc
).
Perform !
Call
(
pc
.
[[Resolve]]
,
undefined
, «
undefined
»).
Return
pc
.
[[Promise]]
.
16.2.1.9
GetImportedModule (
referrer
,
request
)
The abstract operation GetImportedModule takes arguments
referrer
(a
Cyclic Module Record
) and
request
(a
ModuleRequest Record
) and returns a
Module Record
. It performs the following steps when called:
Let
records
be a
List
consisting of each
LoadedModuleRequest Record
r
of
referrer
.
[[LoadedModules]]
such that
ModuleRequestsEqual
(
r
,
request
) is
true
.
Assert
:
records
has exactly one element, since
LoadRequestedModules
has completed successfully on
referrer
prior to invoking this abstract operation.
Let
record
be the sole element of
records
.
Return
record
.
[[Module]]
.
16.2.1.10
HostLoadImportedModule (
referrer
,
moduleRequest
,
hostDefined
,
payload
)
The
host-defined
abstract operation HostLoadImportedModule takes arguments
referrer
(a
Script Record
, a
Cyclic Module Record
, or a
Realm Record
),
moduleRequest
(a
ModuleRequest Record
),
hostDefined
(anything), and
payload
(a
GraphLoadingState Record
or a
PromiseCapability Record
) and returns
unused
.
Note 1
An example of when
referrer
can be a
Realm Record
is in a web browser
host
. There, if a user clicks on a control given by
<
button
type
=
"button"
onclick
=
"import('./foo.mjs')"
>
Click me
</
button
>
there will be no
active script or module
at the time the
import()
expression runs. More generally, this can happen in any situation where the
host
pushes
execution contexts
with
null
ScriptOrModule components onto the
execution context stack
.
An implementation of HostLoadImportedModule must conform to the following requirements:
The
host environment
must perform
FinishLoadingImportedModule
(
referrer
,
moduleRequest
,
payload
,
result
), where
result
is either a
normal completion containing
the loaded
Module Record
or a
throw completion
, either synchronously or asynchronously.
If this operation is called multiple times with two (
referrer
,
moduleRequest
) pairs such that:
the first
referrer
is the same as the second
referrer
;
ModuleRequestsEqual
(the first
moduleRequest
, the second
moduleRequest
) is
true
;
and it performs
FinishLoadingImportedModule
(
referrer
,
moduleRequest
,
payload
,
result
) where
result
is a
normal completion
, then it must perform
FinishLoadingImportedModule
(
referrer
,
moduleRequest
,
payload
,
result
) with the same
result
each time.
If
moduleRequest
.
[[Attributes]]
has an entry
entry
such that
entry
.
[[Key]]
is
"type"
and
entry
.
[[Value]]
is
"json"
, when the
host environment
performs
FinishLoadingImportedModule
(
referrer
,
moduleRequest
,
payload
,
result
),
result
must either be the
Completion Record
returned by an invocation of
ParseJSONModule
or a
throw completion
.
The operation must treat
payload
as an opaque value to be passed through to
FinishLoadingImportedModule
.
The actual process performed is
host-defined
, but typically consists of performing whatever I/O operations are necessary to load the appropriate
Module Record
. Multiple different (
referrer
,
moduleRequest
.
[[Specifier]]
,
moduleRequest
.
[[Attributes]]
) triples may map to the same
Module Record
instance. The actual mapping semantics is
host-defined
but typically a normalization process is applied to
specifier
as part of the mapping process. A typical normalization process would include actions such as expansion of relative and abbreviated path specifiers.
Note 2
The above text requires that
hosts
support JSON modules when imported with
type: "json"
(and HostLoadImportedModule completes normally), but it does not prohibit
hosts
from supporting JSON modules when imported without
type: "json"
.
16.2.1.11
FinishLoadingImportedModule (
referrer
,
moduleRequest
,
payload
,
result
)
The abstract operation FinishLoadingImportedModule takes arguments
referrer
(a
Script Record
, a
Cyclic Module Record
, or a
Realm Record
),
moduleRequest
(a
ModuleRequest Record
),
payload
(a
GraphLoadingState Record
or a
PromiseCapability Record
), and
result
(either a
normal completion containing
a
Module Record
or a
throw completion
) and returns
unused
. It performs the following steps when called:
If
result
is a
normal completion
, then
If
referrer
.
[[LoadedModules]]
contains a
LoadedModuleRequest Record
record
such that
ModuleRequestsEqual
(
record
,
moduleRequest
) is
true
, then
Assert
:
record
.
[[Module]]
and
result
.
[[Value]]
are the same
Module Record
.
Else,
Append the
LoadedModuleRequest Record
{
[[Specifier]]
:
moduleRequest
.
[[Specifier]]
,
[[Attributes]]
:
moduleRequest
.
[[Attributes]]
,
[[Module]]
:
result
.
[[Value]]
} to
referrer
.
[[LoadedModules]]
.
If
payload
is a
GraphLoadingState Record
, then
Perform
ContinueModuleLoading
(
payload
,
result
).
Else,
Perform
ContinueDynamicImport
(
payload
,
result
).
Return
unused
.
16.2.1.12
AllImportAttributesSupported (
attributes
)
The abstract operation AllImportAttributesSupported takes argument
attributes
(a
List
of
ImportAttribute Records
) and returns a Boolean. It performs the following steps when called:
Let
supported
be
HostGetSupportedImportAttributes
().
For each
ImportAttribute Record
attribute
of
attributes
, do
If
supported
does not contain
attribute
.
[[Key]]
, return
false
.
Return
true
.
16.2.1.12.1
HostGetSupportedImportAttributes ( )
The
host-defined
abstract operation HostGetSupportedImportAttributes takes no arguments and returns a
List
of Strings. It allows
host environments
to specify which import attributes they support. Only attributes with supported keys will be provided to the
host
.
An implementation of HostGetSupportedImportAttributes must conform to the following requirements:
It must return a
List
of Strings, each indicating a supported attribute.
Each time this operation is called, it must return the same
List
with the same contents in the same order.
The default implementation of HostGetSupportedImportAttributes is to return a new empty
List
.
Note
The purpose of requiring the
host
to specify its supported import attributes, rather than passing all attributes to the
host
and letting it then choose which ones it wants to handle, is to ensure that unsupported attributes are handled in a consistent way across different
hosts
.
16.2.1.13
GetModuleNamespace (
module
)
The abstract operation GetModuleNamespace takes argument
module
(an instance of a concrete subclass of
Module Record
) and returns a Module Namespace Object. It retrieves the Module Namespace Object representing
module
's exports, lazily creating it the first time it was requested, and storing it in
module
.
[[Namespace]]
for future retrieval. It performs the following steps when called:
Assert
: If
module
is a
Cyclic Module Record
, then
module
.
[[Status]]
is not
new
or
unlinked
.
Let
namespace
be
module
.
[[Namespace]]
.
If
namespace
is
empty
, then
Let
exportedNames
be
module
.
GetExportedNames
().
Let
unambiguousNames
be a new empty
List
.
For each element
name
of
exportedNames
, do
Let
resolution
be
module
.
ResolveExport
(
name
).
If
resolution
is a
ResolvedBinding Record
, append
name
to
unambiguousNames
.
Set
namespace
to
ModuleNamespaceCreate
(
module
,
unambiguousNames
).
Return
namespace
.
Note
GetModuleNamespace never throws. Instead, unresolvable names are simply excluded from the namespace at this point. They will lead to a real linking error later unless they are all ambiguous star exports that are not explicitly requested anywhere.
16.2.1.14
Runtime Semantics: Evaluation
Module
:
[empty]
Return
undefined
.
ModuleBody
:
ModuleItemList
Let
result
be
Completion
(
Evaluation
of
ModuleItemList
).
If
result
is a
normal completion
and
result
.
[[Value]]
is
empty
, then
Return
undefined
.
Return ?
result
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
sl
be ?
Evaluation
of
ModuleItemList
.
Let
s
be
Completion
(
Evaluation
of
ModuleItem
).
Return ?
UpdateEmpty
(
s
,
sl
).
Note
The value of a
ModuleItemList
is the value of the last value-producing item in the
ModuleItemList
.
ModuleItem
:
ImportDeclaration
Return
empty
.
16.2.2
Imports
Syntax
ImportDeclaration
:
import
ImportClause
FromClause
WithClause
opt
;
import
ModuleSpecifier
WithClause
opt
;
ImportClause
:
ImportedDefaultBinding
NameSpaceImport
NamedImports
ImportedDefaultBinding
,
NameSpaceImport
ImportedDefaultBinding
,
NamedImports
ImportedDefaultBinding
:
ImportedBinding
NameSpaceImport
:
*
as
ImportedBinding
NamedImports
:
{
}
{
ImportsList
}
{
ImportsList
,
}
FromClause
:
from
ModuleSpecifier
ImportsList
:
ImportSpecifier
ImportsList
,
ImportSpecifier
ImportSpecifier
:
ImportedBinding
ModuleExportName
as
ImportedBinding
ModuleSpecifier
:
StringLiteral
ImportedBinding
:
BindingIdentifier
[~Yield, +Await]
WithClause
:
with
{
}
with
{
WithEntries
,
opt
}
WithEntries
:
AttributeKey
:
StringLiteral
AttributeKey
:
StringLiteral
,
WithEntries
AttributeKey
:
IdentifierName
StringLiteral
16.2.2.1
Static Semantics: Early Errors
ModuleItem
:
ImportDeclaration
It is a Syntax Error if the
BoundNames
of
ImportDeclaration
contains any duplicate entries.
WithClause
:
with
{
WithEntries
,
opt
}
It is a Syntax Error if
WithClauseToAttributes
of
WithClause
has two different entries
a
and
b
such that
a
.
[[Key]]
is
b
.
[[Key]]
.
16.2.2.2
Static Semantics: ImportEntries
The
syntax-directed operation
ImportEntries takes no arguments and returns a
List
of
ImportEntry Records
. It is defined piecewise over the following productions:
Module
:
[empty]
Return a new empty
List
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
entries1
be the
ImportEntries
of
ModuleItemList
.
Let
entries2
be the
ImportEntries
of
ModuleItem
.
Return the
list-concatenation
of
entries1
and
entries2
.
ModuleItem
:
ExportDeclaration
StatementListItem
Return a new empty
List
.
ImportDeclaration
:
import
ImportClause
FromClause
WithClause
opt
;
Let
module
be the sole element of the
ModuleRequests
of
ImportDeclaration
.
Return the
ImportEntriesForModule
of
ImportClause
with argument
module
.
ImportDeclaration
:
import
ModuleSpecifier
WithClause
opt
;
Return a new empty
List
.
16.2.2.3
Static Semantics: ImportEntriesForModule
The
syntax-directed operation
ImportEntriesForModule takes argument
module
(a
ModuleRequest Record
) and returns a
List
of
ImportEntry Records
. It is defined piecewise over the following productions:
ImportClause
:
ImportedDefaultBinding
,
NameSpaceImport
Let
entries1
be the
ImportEntriesForModule
of
ImportedDefaultBinding
with argument
module
.
Let
entries2
be the
ImportEntriesForModule
of
NameSpaceImport
with argument
module
.
Return the
list-concatenation
of
entries1
and
entries2
.
ImportClause
:
ImportedDefaultBinding
,
NamedImports
Let
entries1
be the
ImportEntriesForModule
of
ImportedDefaultBinding
with argument
module
.
Let
entries2
be the
ImportEntriesForModule
of
NamedImports
with argument
module
.
Return the
list-concatenation
of
entries1
and
entries2
.
ImportedDefaultBinding
:
ImportedBinding
Let
localName
be the sole element of the
BoundNames
of
ImportedBinding
.
Let
defaultEntry
be the
ImportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
"default"
,
[[LocalName]]
:
localName
}.
Return «
defaultEntry
».
NameSpaceImport
:
*
as
ImportedBinding
Let
localName
be the
StringValue
of
ImportedBinding
.
Let
entry
be the
ImportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
namespace-object
,
[[LocalName]]
:
localName
}.
Return «
entry
».
NamedImports
:
{
}
Return a new empty
List
.
ImportsList
:
ImportsList
,
ImportSpecifier
Let
specs1
be the
ImportEntriesForModule
of
ImportsList
with argument
module
.
Let
specs2
be the
ImportEntriesForModule
of
ImportSpecifier
with argument
module
.
Return the
list-concatenation
of
specs1
and
specs2
.
ImportSpecifier
:
ImportedBinding
Let
localName
be the sole element of the
BoundNames
of
ImportedBinding
.
Let
entry
be the
ImportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
localName
,
[[LocalName]]
:
localName
}.
Return «
entry
».
ImportSpecifier
:
ModuleExportName
as
ImportedBinding
Let
importName
be the
StringValue
of
ModuleExportName
.
Let
localName
be the
StringValue
of
ImportedBinding
.
Let
entry
be the
ImportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
importName
,
[[LocalName]]
:
localName
}.
Return «
entry
».
16.2.2.4
Static Semantics: WithClauseToAttributes
The
syntax-directed operation
WithClauseToAttributes takes no arguments and returns a
List
of
ImportAttribute Records
. It is defined piecewise over the following productions:
WithClause
:
with
{
}
Return a new empty
List
.
WithClause
:
with
{
WithEntries
,
opt
}
Let
attributes
be
WithClauseToAttributes
of
WithEntries
.
Sort
attributes
according to the lexicographic order of their
[[Key]]
field, treating the value of each such field as a sequence of UTF-16 code unit values. NOTE: This sorting is observable only in that
hosts
are prohibited from changing behaviour based on the order in which attributes are enumerated.
Return
attributes
.
WithEntries
:
AttributeKey
:
StringLiteral
Let
key
be the
PropName
of
AttributeKey
.
Let
entry
be the
ImportAttribute Record
{
[[Key]]
:
key
,
[[Value]]
: the
SV
of
StringLiteral
}.
Return «
entry
».
WithEntries
:
AttributeKey
:
StringLiteral
,
WithEntries
Let
key
be the
PropName
of
AttributeKey
.
Let
entry
be the
ImportAttribute Record
{
[[Key]]
:
key
,
[[Value]]
: the
SV
of
StringLiteral
}.
Let
rest
be
WithClauseToAttributes
of
WithEntries
.
Return the
list-concatenation
of «
entry
» and
rest
.
16.2.3
Exports
Syntax
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
export
NamedExports
;
export
VariableStatement
[~Yield, +Await]
export
Declaration
[~Yield, +Await]
export
default
HoistableDeclaration
[~Yield, +Await, +Default]
export
default
ClassDeclaration
[~Yield, +Await, +Default]
export
default
[lookahead ∉ {
function
,
async
[no
LineTerminator
here]
function
,
class
}]
AssignmentExpression
[+In, ~Yield, +Await]
;
ExportFromClause
:
*
*
as
ModuleExportName
NamedExports
NamedExports
:
{
}
{
ExportsList
}
{
ExportsList
,
}
ExportsList
:
ExportSpecifier
ExportsList
,
ExportSpecifier
ExportSpecifier
:
ModuleExportName
ModuleExportName
as
ModuleExportName
16.2.3.1
Static Semantics: Early Errors
ExportDeclaration
:
export
NamedExports
;
It is a Syntax Error if the
ReferencedBindings
of
NamedExports
contains any
StringLiteral
s.
For each
IdentifierName
n
in the
ReferencedBindings
of
NamedExports
: It is a Syntax Error if the
StringValue
of
n
is a
ReservedWord
or the
StringValue
of
n
is one of
"implements"
,
"interface"
,
"let"
,
"package"
,
"private"
,
"protected"
,
"public"
, or
"static"
.
Note
The above rule means that each
ReferencedBindings
of
NamedExports
is treated as an
IdentifierReference
.
16.2.3.2
Static Semantics: ExportedBindings
The
syntax-directed operation
ExportedBindings takes no arguments and returns a
List
of Strings.
Note
ExportedBindings are the locally bound names that are explicitly associated with a
Module
's
ExportedNames
.
It is defined piecewise over the following productions:
ModuleItemList
:
ModuleItemList
ModuleItem
Let
names1
be the
ExportedBindings
of
ModuleItemList
.
Let
names2
be the
ExportedBindings
of
ModuleItem
.
Return the
list-concatenation
of
names1
and
names2
.
ModuleItem
:
ImportDeclaration
StatementListItem
Return a new empty
List
.
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
Return a new empty
List
.
ExportDeclaration
:
export
NamedExports
;
Return the
ExportedBindings
of
NamedExports
.
ExportDeclaration
:
export
VariableStatement
Return the
BoundNames
of
VariableStatement
.
ExportDeclaration
:
export
Declaration
Return the
BoundNames
of
Declaration
.
ExportDeclaration
:
export
default
HoistableDeclaration
export
default
ClassDeclaration
export
default
AssignmentExpression
;
Return the
BoundNames
of this
ExportDeclaration
.
NamedExports
:
{
}
Return a new empty
List
.
ExportsList
:
ExportsList
,
ExportSpecifier
Let
names1
be the
ExportedBindings
of
ExportsList
.
Let
names2
be the
ExportedBindings
of
ExportSpecifier
.
Return the
list-concatenation
of
names1
and
names2
.
ExportSpecifier
:
ModuleExportName
Return a
List
whose sole element is the
StringValue
of
ModuleExportName
.
ExportSpecifier
:
ModuleExportName
as
ModuleExportName
Return a
List
whose sole element is the
StringValue
of the first
ModuleExportName
.
16.2.3.3
Static Semantics: ExportedNames
The
syntax-directed operation
ExportedNames takes no arguments and returns a
List
of Strings.
Note
ExportedNames are the externally visible names that a
Module
explicitly maps to one of its local name bindings.
It is defined piecewise over the following productions:
ModuleItemList
:
ModuleItemList
ModuleItem
Let
names1
be the
ExportedNames
of
ModuleItemList
.
Let
names2
be the
ExportedNames
of
ModuleItem
.
Return the
list-concatenation
of
names1
and
names2
.
ModuleItem
:
ExportDeclaration
Return the
ExportedNames
of
ExportDeclaration
.
ModuleItem
:
ImportDeclaration
StatementListItem
Return a new empty
List
.
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
Return the
ExportedNames
of
ExportFromClause
.
ExportFromClause
:
*
Return a new empty
List
.
ExportFromClause
:
*
as
ModuleExportName
Return a
List
whose sole element is the
StringValue
of
ModuleExportName
.
ExportFromClause
:
NamedExports
Return the
ExportedNames
of
NamedExports
.
ExportDeclaration
:
export
VariableStatement
Return the
BoundNames
of
VariableStatement
.
ExportDeclaration
:
export
Declaration
Return the
BoundNames
of
Declaration
.
ExportDeclaration
:
export
default
HoistableDeclaration
export
default
ClassDeclaration
export
default
AssignmentExpression
;
Return «
"default"
».
NamedExports
:
{
}
Return a new empty
List
.
ExportsList
:
ExportsList
,
ExportSpecifier
Let
names1
be the
ExportedNames
of
ExportsList
.
Let
names2
be the
ExportedNames
of
ExportSpecifier
.
Return the
list-concatenation
of
names1
and
names2
.
ExportSpecifier
:
ModuleExportName
Return a
List
whose sole element is the
StringValue
of
ModuleExportName
.
ExportSpecifier
:
ModuleExportName
as
ModuleExportName
Return a
List
whose sole element is the
StringValue
of the second
ModuleExportName
.
16.2.3.4
Static Semantics: ExportEntries
The
syntax-directed operation
ExportEntries takes no arguments and returns a
List
of
ExportEntry Records
. It is defined piecewise over the following productions:
Module
:
[empty]
Return a new empty
List
.
ModuleItemList
:
ModuleItemList
ModuleItem
Let
entries1
be the
ExportEntries
of
ModuleItemList
.
Let
entries2
be the
ExportEntries
of
ModuleItem
.
Return the
list-concatenation
of
entries1
and
entries2
.
ModuleItem
:
ImportDeclaration
StatementListItem
Return a new empty
List
.
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
Let
module
be the sole element of the
ModuleRequests
of
ExportDeclaration
.
Return the
ExportEntriesForModule
of
ExportFromClause
with argument
module
.
ExportDeclaration
:
export
NamedExports
;
Return the
ExportEntriesForModule
of
NamedExports
with argument
null
.
ExportDeclaration
:
export
VariableStatement
Let
entries
be a new empty
List
.
Let
names
be the
BoundNames
of
VariableStatement
.
For each element
name
of
names
, do
Append the
ExportEntry Record
{
[[ModuleRequest]]
:
null
,
[[ImportName]]
:
null
,
[[LocalName]]
:
name
,
[[ExportName]]
:
name
} to
entries
.
Return
entries
.
ExportDeclaration
:
export
Declaration
Let
entries
be a new empty
List
.
Let
names
be the
BoundNames
of
Declaration
.
For each element
name
of
names
, do
Append the
ExportEntry Record
{
[[ModuleRequest]]
:
null
,
[[ImportName]]
:
null
,
[[LocalName]]
:
name
,
[[ExportName]]
:
name
} to
entries
.
Return
entries
.
ExportDeclaration
:
export
default
HoistableDeclaration
Let
names
be the
BoundNames
of
HoistableDeclaration
.
Let
localName
be the sole element of
names
.
Return a
List
whose sole element is a new
ExportEntry Record
{
[[ModuleRequest]]
:
null
,
[[ImportName]]
:
null
,
[[LocalName]]
:
localName
,
[[ExportName]]
:
"default"
}.
ExportDeclaration
:
export
default
ClassDeclaration
Let
names
be the
BoundNames
of
ClassDeclaration
.
Let
localName
be the sole element of
names
.
Return a
List
whose sole element is a new
ExportEntry Record
{
[[ModuleRequest]]
:
null
,
[[ImportName]]
:
null
,
[[LocalName]]
:
localName
,
[[ExportName]]
:
"default"
}.
ExportDeclaration
:
export
default
AssignmentExpression
;
Let
entry
be the
ExportEntry Record
{
[[ModuleRequest]]
:
null
,
[[ImportName]]
:
null
,
[[LocalName]]
:
"*default*"
,
[[ExportName]]
:
"default"
}.
Return «
entry
».
Note
"*default*"
is used within this specification as a synthetic name for anonymous default export values. See
this note
for more details.
16.2.3.5
Static Semantics: ExportEntriesForModule
The
syntax-directed operation
ExportEntriesForModule takes argument
module
(a
ModuleRequest Record
or
null
) and returns a
List
of
ExportEntry Records
. It is defined piecewise over the following productions:
ExportFromClause
:
*
Let
entry
be the
ExportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
all-but-default
,
[[LocalName]]
:
null
,
[[ExportName]]
:
null
}.
Return «
entry
».
ExportFromClause
:
*
as
ModuleExportName
Let
exportName
be the
StringValue
of
ModuleExportName
.
Let
entry
be the
ExportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
all
,
[[LocalName]]
:
null
,
[[ExportName]]
:
exportName
}.
Return «
entry
».
NamedExports
:
{
}
Return a new empty
List
.
ExportsList
:
ExportsList
,
ExportSpecifier
Let
specs1
be the
ExportEntriesForModule
of
ExportsList
with argument
module
.
Let
specs2
be the
ExportEntriesForModule
of
ExportSpecifier
with argument
module
.
Return the
list-concatenation
of
specs1
and
specs2
.
ExportSpecifier
:
ModuleExportName
Let
sourceName
be the
StringValue
of
ModuleExportName
.
If
module
is
null
, then
Let
localName
be
sourceName
.
Let
importName
be
null
.
Else,
Let
localName
be
null
.
Let
importName
be
sourceName
.
Return a
List
whose sole element is a new
ExportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
importName
,
[[LocalName]]
:
localName
,
[[ExportName]]
:
sourceName
}.
ExportSpecifier
:
ModuleExportName
as
ModuleExportName
Let
sourceName
be the
StringValue
of the first
ModuleExportName
.
Let
exportName
be the
StringValue
of the second
ModuleExportName
.
If
module
is
null
, then
Let
localName
be
sourceName
.
Let
importName
be
null
.
Else,
Let
localName
be
null
.
Let
importName
be
sourceName
.
Return a
List
whose sole element is a new
ExportEntry Record
{
[[ModuleRequest]]
:
module
,
[[ImportName]]
:
importName
,
[[LocalName]]
:
localName
,
[[ExportName]]
:
exportName
}.
16.2.3.6
Static Semantics: ReferencedBindings
The
syntax-directed operation
ReferencedBindings takes no arguments and returns a
List
of
Parse Nodes
. It is defined piecewise over the following productions:
NamedExports
:
{
}
Return a new empty
List
.
ExportsList
:
ExportsList
,
ExportSpecifier
Let
names1
be the
ReferencedBindings
of
ExportsList
.
Let
names2
be the
ReferencedBindings
of
ExportSpecifier
.
Return the
list-concatenation
of
names1
and
names2
.
ExportSpecifier
:
ModuleExportName
as
ModuleExportName
Return the
ReferencedBindings
of the first
ModuleExportName
.
ModuleExportName
:
IdentifierName
Return a
List
whose sole element is the
IdentifierName
.
ModuleExportName
:
StringLiteral
Return a
List
whose sole element is the
StringLiteral
.
16.2.3.7
Runtime Semantics: Evaluation
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
export
NamedExports
;
Return
empty
.
ExportDeclaration
:
export
VariableStatement
Return ?
Evaluation
of
VariableStatement
.
ExportDeclaration
:
export
Declaration
Return ?
Evaluation
of
Declaration
.
ExportDeclaration
:
export
default
HoistableDeclaration
Return ?
Evaluation
of
HoistableDeclaration
.
ExportDeclaration
:
export
default
ClassDeclaration
Let
value
be ?
BindingClassDeclarationEvaluation
of
ClassDeclaration
.
Let
className
be the sole element of the
BoundNames
of
ClassDeclaration
.
If
className
is
"*default*"
, then
Let
env
be the
running execution context
's LexicalEnvironment.
Perform ?
InitializeBoundName
(
"*default*"
,
value
,
env
).
Return
empty
.
ExportDeclaration
:
export
default
AssignmentExpression
;
If
IsAnonymousFunctionDefinition
(
AssignmentExpression
) is
true
, then
Let
value
be ?
NamedEvaluation
of
AssignmentExpression
with argument
"default"
.
Else,
Let
rhs
be ?
Evaluation
of
AssignmentExpression
.
Let
value
be ?
GetValue
(
rhs
).
Let
env
be the
running execution context
's LexicalEnvironment.
Perform ?
InitializeBoundName
(
"*default*"
,
value
,
env
).
Return
empty
.
17
Error Handling and Language Extensions
An implementation must report most errors at the time the relevant ECMAScript language construct is evaluated. An
early error
is an error that can be detected and reported prior to the evaluation of any construct in the
Script
containing the error. The presence of an
early error
prevents the evaluation of the construct. An implementation must report
early errors
in a
Script
as part of parsing that
Script
in
ParseScript
.
Early errors
in a
Module
are reported at the point when the
Module
would be evaluated and the
Module
is never initialized.
Early errors
in
eval
code are reported at the time
eval
is called and prevent evaluation of the
eval
code. All errors that are not
early errors
are runtime errors.
An implementation must report as an
early error
any occurrence of a condition that is listed in a “Static Semantics: Early Errors” subclause of this specification.
An implementation shall not treat other kinds of errors as
early errors
even if the compiler can prove that a construct cannot execute without error under any circumstances. An implementation may issue an early warning in such a case, but it should not report the error until the relevant construct is actually executed.
An implementation shall report all errors as specified, except for the following:
Except as restricted in
17.1
, a
host
or implementation may extend
Script
syntax,
Module
syntax, and regular expression pattern or flag syntax. To permit this, all operations (such as calling
eval
, using a regular expression literal, or using the Function or RegExp
constructor
) that are allowed to throw
SyntaxError
are permitted to exhibit
host-defined
behaviour instead of throwing
SyntaxError
when they encounter a
host-defined
extension to the script syntax or regular expression pattern or flag syntax.
Except as restricted in
17.1
, a
host
or implementation may provide additional types, values, objects, properties, and functions beyond those described in this specification. This may cause constructs (such as looking up a variable in the global scope) to have
host-defined
behaviour instead of throwing an error (such as
ReferenceError
).
17.1
Forbidden Extensions
An implementation must not extend this specification in the following ways:
ECMAScript
function objects
defined using syntactic
constructors
in
strict mode code
must not be created with own properties named
"caller"
or
"arguments"
. Such own properties also must not be created for
function objects
defined using an
ArrowFunction
,
MethodDefinition
,
GeneratorDeclaration
,
GeneratorExpression
,
AsyncGeneratorDeclaration
,
AsyncGeneratorExpression
,
ClassDeclaration
,
ClassExpression
,
AsyncFunctionDeclaration
,
AsyncFunctionExpression
, or
AsyncArrowFunction
regardless of whether the definition is contained in
strict mode code
. Built-in functions,
strict functions
created using the Function
constructor
, generator functions created using the Generator
constructor
, async functions created using the AsyncFunction
constructor
, and functions created using the
bind
method also must not be created with such own properties.
If an implementation extends any
function object
with an own property named
"caller"
the value of that property, as observed using
[[Get]]
or
[[GetOwnProperty]]
, must not be a
strict function
object. If it is an
accessor property
, the function that is the value of the property's
[[Get]]
attribute must never return a
strict function
when called.
Neither mapped nor unmapped arguments objects may be created with an own property named
"caller"
.
The behaviour of built-in methods which are specified in ECMA-402, such as those named
toLocaleString
, must not be extended except as specified in ECMA-402.
The RegExp pattern grammars in
22.2.1
and
B.1.2
must not be extended to recognize any of the source characters A-Z or a-z as
IdentityEscape
[+UnicodeMode]
when the
[UnicodeMode]
grammar parameter is present.
The Syntactic Grammar must not be extended in any manner that allows the token
:
to immediately follow source text that is matched by the
BindingIdentifier
nonterminal symbol.
When processing
strict mode code
, an implementation must not relax the
early error
rules of
12.9.3.1
.
TemplateEscapeSequence
must not be extended to include
LegacyOctalEscapeSequence
or
NonOctalDecimalEscapeSequence
as defined in
12.9.4
.
When processing
strict mode code
, the extensions defined in
B.3.1
,
B.3.2
,
B.3.3
, and
B.3.5
must not be supported.
When parsing for the
Module
goal symbol
, the lexical grammar extensions defined in
B.1.1
must not be supported.
ImportCall
must not be extended.
18
ECMAScript Standard Built-in Objects
There are certain built-in objects available whenever an ECMAScript
Script
or
Module
begins execution. One, the
global object
, is part of the global environment of the executing program. Others are accessible as initial properties of the
global object
or indirectly as properties of accessible built-in objects.
Unless specified otherwise, a built-in object that is callable as a function is a built-in
function object
with the characteristics described in
10.3
. Unless specified otherwise, the
[[Extensible]]
internal slot of a built-in object initially has the value
true
. Every built-in
function object
has a
[[Realm]]
internal slot whose value is the
Realm Record
of the
realm
for which the object was initially created.
Many built-in objects are functions: they can be invoked with arguments. Some of them furthermore are
constructors
: they are functions intended for use with the
new
operator. For each built-in function, this specification describes the arguments required by that function and the properties of that
function object
. For each built-in
constructor
, this specification furthermore describes properties of the prototype object of that
constructor
and properties of specific object instances returned by a
new
expression that invokes that
constructor
.
Unless otherwise specified in the description of a particular function, if a built-in function or
constructor
is given fewer arguments than the function is specified to require, the function or
constructor
shall behave exactly as if it had been given sufficient additional arguments, each such argument being the
undefined
value. Such missing arguments are considered to be “not present” and may be identified in that manner by specification algorithms. In the description of a particular function, the terms “
this
value” and “NewTarget” have the meanings given in
10.3
.
Unless otherwise specified in the description of a particular function, if a built-in function or
constructor
described is given more arguments than the function is specified to allow, the extra arguments are evaluated by the call and then ignored by the function. However, an implementation may define implementation specific behaviour relating to such arguments as long as the behaviour is not the throwing of a
TypeError
exception that is predicated simply on the presence of an extra argument.
Note 1
Implementations that add additional capabilities to the set of built-in functions are encouraged to do so by adding new functions rather than adding new parameters to existing functions.
Unless otherwise specified every built-in function and every built-in
constructor
has the
Function prototype object
, which is the initial value of the expression
Function.prototype
(
20.2.3
), as the value of its
[[Prototype]]
internal slot.
Unless otherwise specified every built-in prototype object has the
Object prototype object
, which is the initial value of the expression
Object.prototype
(
20.1.3
), as the value of its
[[Prototype]]
internal slot, except the
Object prototype object
itself.
If this specification defines a built-in
constructor
's behaviour via algorithm steps, then that is its behaviour for the purposes of both
[[Call]]
and
[[Construct]]
. If such an algorithm needs to distinguish the two cases, it checks whether NewTarget is
undefined
, which indicates a
[[Call]]
invocation.
Built-in
function objects
that are not identified as
constructors
do not implement the
[[Construct]]
internal method unless otherwise specified in the description of a particular function.
Built-in
function objects
that are not
constructors
do not have a
"prototype"
property unless otherwise specified in the description of a particular function.
Each built-in function defined in this specification is created by calling the
CreateBuiltinFunction
abstract operation (
10.3.4
). The values of the
length
and
name
parameters are the initial values of the
"length"
and
"name"
properties as discussed below. The values of the
prefix
parameter are similarly discussed below.
Every built-in
function object
, including
constructors
, has a
"length"
property whose value is a non-negative
integral Number
. Unless otherwise specified, this value is the number of required parameters shown in the subclause heading for the function description. Optional parameters and rest parameters are not included in the parameter count.
Note 2
For example, the
function object
that is the initial value of the
"map"
property of the
Array prototype object
is described under the subclause heading «Array.prototype.map (callback [ , thisArg])» which shows the two named arguments callback and thisArg, the latter being optional; therefore the value of the
"length"
property of that
function object
is
1
𝔽
.
Unless otherwise specified, the
"length"
property of a built-in
function object
has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
Every built-in
function object
, including
constructors
, has a
"name"
property whose value
is a String
. Unless otherwise specified, this value is the name that is given to the function in this specification. Functions that are identified as anonymous functions use the empty String as the value of the
"name"
property. For functions that are specified as properties of objects, the name value is the
property name
string used to access the function. Functions that are specified as get or set accessor functions of built-in properties have
"get"
or
"set"
(respectively) passed to the
prefix
parameter when calling
CreateBuiltinFunction
.
The value of the
"name"
property is explicitly specified for each built-in functions whose
property key
is a Symbol
value. If such an explicitly specified value starts with the prefix
"get "
or
"set "
and the function for which it is specified is a get or set accessor function of a built-in property, the value without the prefix is passed to the
name
parameter, and the value
"get"
or
"set"
(respectively) is passed to the
prefix
parameter when calling
CreateBuiltinFunction
.
Unless otherwise specified, the
"name"
property of a built-in
function object
has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
Every other
data property
described in clauses
19
through
28
and in Annex
B.2
has the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
} unless otherwise specified.
Every
accessor property
described in clauses
19
through
28
and in Annex
B.2
has the attributes {
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
} unless otherwise specified. If only a get accessor function is described, the set accessor function is the default value,
undefined
. If only a set accessor is described the get accessor is the default value,
undefined
.
19
The Global Object
The
global object
:
is created before control enters any
execution context
.
does not have a
[[Construct]]
internal method; it cannot be used as a
constructor
with the
new
operator.
does not have a
[[Call]]
internal method; it cannot be invoked as a function.
has a
[[Prototype]]
internal slot whose value is
host-defined
.
may have
host-defined
properties in addition to the properties defined in this specification. This may include a property whose value is the global object itself.
19.1
Value Properties of the Global Object
19.1.1
globalThis
The initial value of the
"globalThis"
property of the
global object
in a
Realm Record
realm
is
realm
.
[[GlobalEnv]]
.
[[GlobalThisValue]]
.
This property has the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
19.1.2
Infinity
The value of
Infinity
is
+∞
𝔽
(see
6.1.6.1
). This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
19.1.3
NaN
The value of
NaN
is
NaN
(see
6.1.6.1
). This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
19.1.4
undefined
The value of
undefined
is
undefined
(see
6.1.1
). This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
19.2
Function Properties of the Global Object
19.2.1
eval (
x
)
This function is the
%eval%
intrinsic object.
It performs the following steps when called:
Return ?
PerformEval
(
x
,
false
,
false
).
19.2.1.1
PerformEval (
x
,
strictCaller
,
direct
)
The abstract operation PerformEval takes arguments
x
(an
ECMAScript language value
),
strictCaller
(a Boolean), and
direct
(a Boolean) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Assert
: If
direct
is
false
, then
strictCaller
is also
false
.
If
x
is not a String
, return
x
.
Let
evalRealm
be
the current Realm Record
.
NOTE: In the case of a
direct eval
,
evalRealm
is the
realm
of both the caller of
eval
and of the
eval
function itself.
Perform ?
HostEnsureCanCompileStrings
(
evalRealm
, « »,
x
,
direct
).
Let
inFunction
be
false
.
Let
inMethod
be
false
.
Let
inDerivedConstructor
be
false
.
Let
inClassFieldInitializer
be
false
.
If
direct
is
true
, then
Let
thisEnvRec
be
GetThisEnvironment
().
If
thisEnvRec
is a
Function Environment Record
, then
Let
F
be
thisEnvRec
.
[[FunctionObject]]
.
Set
inFunction
to
true
.
Set
inMethod
to
thisEnvRec
.
HasSuperBinding
().
If
F
.
[[ConstructorKind]]
is
derived
, set
inDerivedConstructor
to
true
.
Let
classFieldInitializerName
be
F
.
[[ClassFieldInitializerName]]
.
If
classFieldInitializerName
is not
empty
, set
inClassFieldInitializer
to
true
.
Perform the following substeps in an
implementation-defined
order, possibly interleaving parsing and error detection:
Let
script
be
ParseText
(
x
,
Script
).
If
script
is a
List
of errors, throw a
SyntaxError
exception.
If
script
Contains
ScriptBody
is
false
, return
undefined
.
Let
body
be the
ScriptBody
of
script
.
If
inFunction
is
false
and
body
Contains
NewTarget
, throw a
SyntaxError
exception.
If
inMethod
is
false
and
body
Contains
SuperProperty
, throw a
SyntaxError
exception.
If
inDerivedConstructor
is
false
and
body
Contains
SuperCall
, throw a
SyntaxError
exception.
If
inClassFieldInitializer
is
true
and
ContainsArguments
of
body
is
true
, throw a
SyntaxError
exception.
If
strictCaller
is
true
, let
strictEval
be
true
.
Else, let
strictEval
be
ScriptIsStrict
of
script
.
Let
runningContext
be the
running execution context
.
NOTE: If
direct
is
true
,
runningContext
will be the
execution context
that performed the
direct eval
. If
direct
is
false
,
runningContext
will be the
execution context
for the invocation of the
eval
function.
If
direct
is
true
, then
Let
lexEnv
be
NewDeclarativeEnvironment
(
runningContext
's LexicalEnvironment).
Let
varEnv
be
runningContext
's VariableEnvironment.
Let
privateEnv
be
runningContext
's PrivateEnvironment.
Else,
Let
lexEnv
be
NewDeclarativeEnvironment
(
evalRealm
.
[[GlobalEnv]]
).
Let
varEnv
be
evalRealm
.
[[GlobalEnv]]
.
Let
privateEnv
be
null
.
If
strictEval
is
true
, set
varEnv
to
lexEnv
.
If
runningContext
is not already suspended, suspend
runningContext
.
Let
evalContext
be a new
ECMAScript code execution context
.
Set
evalContext
's Function to
null
.
Set
evalContext
's
Realm
to
evalRealm
.
Set
evalContext
's ScriptOrModule to
runningContext
's ScriptOrModule.
Set
evalContext
's VariableEnvironment to
varEnv
.
Set
evalContext
's LexicalEnvironment to
lexEnv
.
Set
evalContext
's PrivateEnvironment to
privateEnv
.
Push
evalContext
onto the
execution context stack
;
evalContext
is now the
running execution context
.
Let
result
be
Completion
(
EvalDeclarationInstantiation
(
body
,
varEnv
,
lexEnv
,
privateEnv
,
strictEval
)).
If
result
is a
normal completion
, then
Set
result
to
Completion
(
Evaluation
of
body
).
If
result
is a
normal completion
and
result
.
[[Value]]
is
empty
, then
Set
result
to
NormalCompletion
(
undefined
).
Suspend
evalContext
and remove it from the
execution context stack
.
Resume the context that is now on the top of the
execution context stack
as the
running execution context
.
Return ?
result
.
Note
The eval code cannot instantiate variable or function bindings in the variable environment of the calling context that invoked the eval if either the code of the calling context or the eval code is
strict mode code
. Instead such bindings are instantiated in a new VariableEnvironment that is only accessible to the eval code. Bindings introduced by
let
,
const
, or
class
declarations are always instantiated in a new LexicalEnvironment.
19.2.1.2
HostEnsureCanCompileStrings (
calleeRealm
,
parameterStrings
,
bodyString
,
direct
)
The
host-defined
abstract operation HostEnsureCanCompileStrings takes arguments
calleeRealm
(a
Realm Record
),
parameterStrings
(a
List
of Strings),
bodyString
(a String), and
direct
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It allows
host environments
to block certain ECMAScript functions which allow developers to interpret and evaluate strings as ECMAScript code.
parameterStrings
represents the strings that, when using one of the function
constructors
, will be concatenated together to build the parameters list.
bodyString
represents the function body or the string passed to an
eval
call.
direct
signifies whether the evaluation is a
direct eval
.
The default implementation of HostEnsureCanCompileStrings is to return
NormalCompletion
(
unused
).
19.2.1.3
EvalDeclarationInstantiation (
body
,
varEnv
,
lexEnv
,
privateEnv
,
strict
)
The abstract operation EvalDeclarationInstantiation takes arguments
body
(a
ScriptBody
Parse Node
),
varEnv
(an
Environment Record
),
lexEnv
(a
Declarative Environment Record
),
privateEnv
(a
PrivateEnvironment Record
or
null
), and
strict
(a Boolean) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
varNames
be the
VarDeclaredNames
of
body
.
Let
varDeclarations
be the
VarScopedDeclarations
of
body
.
If
strict
is
false
, then
If
varEnv
is a
Global Environment Record
, then
For each element
name
of
varNames
, do
If
HasLexicalDeclaration
(
varEnv
,
name
) is
true
, throw a
SyntaxError
exception.
NOTE:
eval
will not create a global var declaration that would be shadowed by a global lexical declaration.
Let
thisEnv
be
lexEnv
.
Assert
: The following loop will terminate.
Repeat, while
thisEnv
and
varEnv
are not the same
Environment Record
,
If
thisEnv
is not an Object
Environment Record
, then
NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
For each element
name
of
varNames
, do
If !
thisEnv
.
HasBinding
(
name
) is
true
, then
Normative Optional
If the
host
is a web browser or otherwise supports
VariableStatements in Catch Blocks
, then
If
thisEnv
is not the
Environment Record
for a
Catch
clause, throw a
SyntaxError
exception.
Else,
Throw a
SyntaxError
exception.
NOTE: A
direct eval
will not hoist var declaration over a like-named lexical declaration.
Set
thisEnv
to
thisEnv
.
[[OuterEnv]]
.
Let
privateIdentifiers
be a new empty
List
.
Let
pointer
be
privateEnv
.
Repeat, while
pointer
is not
null
,
For each
Private Name
binding
of
pointer
.
[[Names]]
, do
If
privateIdentifiers
does not contain
binding
.
[[Description]]
, append
binding
.
[[Description]]
to
privateIdentifiers
.
Set
pointer
to
pointer
.
[[OuterPrivateEnvironment]]
.
If
AllPrivateIdentifiersValid
of
body
with argument
privateIdentifiers
is
false
, throw a
SyntaxError
exception.
Let
functionsToInitialize
be a new empty
List
.
Let
declaredFunctionNames
be a new empty
List
.
For each element
d
of
varDeclarations
, in reverse
List
order, do
If
d
is not either a
VariableDeclaration
, a
ForBinding
, or a
BindingIdentifier
, then
Assert
:
d
is either a
FunctionDeclaration
, a
GeneratorDeclaration
, an
AsyncFunctionDeclaration
, or an
AsyncGeneratorDeclaration
.
NOTE: If there are multiple function declarations for the same name, the last declaration is used.
Let
fn
be the sole element of the
BoundNames
of
d
.
If
declaredFunctionNames
does not contain
fn
, then
If
varEnv
is a
Global Environment Record
, then
Let
fnDefinable
be ?
CanDeclareGlobalFunction
(
varEnv
,
fn
).
If
fnDefinable
is
false
, throw a
TypeError
exception.
Append
fn
to
declaredFunctionNames
.
Insert
d
as the first element of
functionsToInitialize
.
Let
declaredVarNames
be a new empty
List
.
For each element
d
of
varDeclarations
, do
If
d
is either a
VariableDeclaration
, a
ForBinding
, or a
BindingIdentifier
, then
For each String
vn
of the
BoundNames
of
d
, do
If
declaredFunctionNames
does not contain
vn
, then
If
varEnv
is a
Global Environment Record
, then
Let
vnDefinable
be ?
CanDeclareGlobalVar
(
varEnv
,
vn
).
If
vnDefinable
is
false
, throw a
TypeError
exception.
If
declaredVarNames
does not contain
vn
, then
Append
vn
to
declaredVarNames
.
Normative Optional
If
strict
is
false
and the
host
is a web browser or otherwise supports
Block-Level Function Declarations Web Legacy Compatibility Semantics
, then
Let
declaredFunctionOrVarNames
be the
list-concatenation
of
declaredFunctionNames
and
declaredVarNames
.
For each
FunctionDeclaration
f
that is directly contained in the
StatementList
of any
Block
,
CaseClause
, or
DefaultClause
x
such that
body
Contains
x
is
true
, do
Let
F
be the
StringValue
of the
BindingIdentifier
of
f
.
If replacing the
FunctionDeclaration
f
with a
VariableStatement
that has
F
as a
BindingIdentifier
would not produce any Early Errors for
body
, then
Let
bindingExists
be
false
.
Set
thisEnv
to
lexEnv
.
Assert
: The following loop will terminate.
Repeat, while
thisEnv
is not
varEnv
,
If
thisEnv
is not an Object
Environment Record
, then
If !
thisEnv
.
HasBinding
(
F
) is
true
, then
Normative Optional
If the
host
is a web browser or otherwise supports
VariableStatements in Catch Blocks
, then
If
thisEnv
is not the
Environment Record
for a
Catch
clause, set
bindingExists
to
true
.
Else,
Set
bindingExists
to
true
.
Set
thisEnv
to
thisEnv
.
[[OuterEnv]]
.
If
bindingExists
is
false
and
varEnv
is a
Global Environment Record
, then
If
HasLexicalDeclaration
(
varEnv
,
F
) is
false
, then
Let
fnDefinable
be ?
CanDeclareGlobalVar
(
varEnv
,
F
).
Else,
Let
fnDefinable
be
false
.
Else,
Let
fnDefinable
be
true
.
If
bindingExists
is
false
and
fnDefinable
is
true
, then
If
declaredFunctionOrVarNames
does not contain
F
, then
If
varEnv
is a
Global Environment Record
, then
Perform ?
CreateGlobalVarBinding
(
varEnv
,
F
,
true
).
Else,
Set
bindingExists
to !
varEnv
.
HasBinding
(
F
).
If
bindingExists
is
false
, then
Perform !
varEnv
.
CreateMutableBinding
(
F
,
true
).
Perform !
varEnv
.
InitializeBinding
(
F
,
undefined
).
Append
F
to
declaredFunctionOrVarNames
.
When the
FunctionDeclaration
f
is evaluated, perform the following steps in place of the
FunctionDeclaration
Evaluation
algorithm provided in
15.2.6
:
Let
gEnv
be the
running execution context
's VariableEnvironment.
Let
bEnv
be the
running execution context
's LexicalEnvironment.
Let
fObj
be !
bEnv
.
GetBindingValue
(
F
,
false
).
Perform ?
gEnv
.
SetMutableBinding
(
F
,
fObj
,
false
)
.
Return
unused
.
NOTE: No abnormal terminations occur after this algorithm step unless
varEnv
is a
Global Environment Record
and the
global object
is a
Proxy exotic object
.
Let
lexDeclarations
be the
LexicallyScopedDeclarations
of
body
.
For each element
d
of
lexDeclarations
, do
NOTE: Lexically declared names are only instantiated here but not initialized.
For each element
dn
of the
BoundNames
of
d
, do
If
IsConstantDeclaration
of
d
is
true
, then
Perform ?
lexEnv
.
CreateImmutableBinding
(
dn
,
true
).
Else,
Perform ?
lexEnv
.
CreateMutableBinding
(
dn
,
false
).
For each
Parse Node
f
of
functionsToInitialize
, do
Let
fn
be the sole element of the
BoundNames
of
f
.
Let
fo
be
InstantiateFunctionObject
of
f
with arguments
lexEnv
and
privateEnv
.
If
varEnv
is a
Global Environment Record
, then
Perform ?
CreateGlobalFunctionBinding
(
varEnv
,
fn
,
fo
,
true
).
Else,
Let
bindingExists
be !
varEnv
.
HasBinding
(
fn
).
If
bindingExists
is
false
, then
NOTE: The following invocation cannot return an
abrupt completion
because of the validation preceding step
14
.
Perform !
varEnv
.
CreateMutableBinding
(
fn
,
true
).
Perform !
varEnv
.
InitializeBinding
(
fn
,
fo
).
Else,
Perform !
varEnv
.
SetMutableBinding
(
fn
,
fo
,
false
).
For each String
vn
of
declaredVarNames
, do
If
varEnv
is a
Global Environment Record
, then
Perform ?
CreateGlobalVarBinding
(
varEnv
,
vn
,
true
).
Else,
Let
bindingExists
be !
varEnv
.
HasBinding
(
vn
).
If
bindingExists
is
false
, then
NOTE: The following invocation cannot return an
abrupt completion
because of the validation preceding step
14
.
Perform !
varEnv
.
CreateMutableBinding
(
vn
,
true
).
Perform !
varEnv
.
InitializeBinding
(
vn
,
undefined
).
Return
unused
.
19.2.2
isFinite (
number
)
This function is the
%isFinite%
intrinsic object.
It performs the following steps when called:
Let
num
be ?
ToNumber
(
number
).
If
num
is not
finite
, return
false
.
Otherwise, return
true
.
19.2.3
isNaN (
number
)
This function is the
%isNaN%
intrinsic object.
It performs the following steps when called:
Let
num
be ?
ToNumber
(
number
).
If
num
is
NaN
, return
true
.
Otherwise, return
false
.
Note
A reliable way for ECMAScript code to test if a value
X
is
NaN
is an expression of the form
X !== X
. The result will be
true
if and only if
X
is
NaN
.
19.2.4
parseFloat (
string
)
This function produces a Number value dictated by interpretation of the contents of the
string
argument as a decimal literal.
It is the
%parseFloat%
intrinsic object.
It performs the following steps when called:
Let
inputString
be ?
ToString
(
string
).
Let
trimmedString
be !
TrimString
(
inputString
,
start
).
Let
trimmed
be
StringToCodePoints
(
trimmedString
).
Let
trimmedPrefix
be the longest prefix of
trimmed
that satisfies the syntax of a
StrDecimalLiteral
, which might be
trimmed
itself. If there is no such prefix, return
NaN
.
Let
parsedNumber
be
ParseText
(
trimmedPrefix
,
StrDecimalLiteral
).
Assert
:
parsedNumber
is a
Parse Node
.
Return the
StringNumericValue
of
parsedNumber
.
Note
This function may interpret only a leading portion of
string
as a Number value; it ignores any code units that cannot be interpreted as part of the notation of a decimal literal, and no indication is given that any such code units were ignored.
19.2.5
parseInt (
string
,
radix
)
This function produces an
integral Number
dictated by interpretation of the contents of
string
according to the specified
radix
. Leading white space in
string
is ignored. If
radix
coerces to 0 (such as when it is
undefined
), it is assumed to be 10 except when the number representation begins with
"0x"
or
"0X"
, in which case it is assumed to be 16. If
radix
is 16, the number representation may optionally begin with
"0x"
or
"0X"
.
It is the
%parseInt%
intrinsic object.
It performs the following steps when called:
Let
inputString
be ?
ToString
(
string
).
Let
S
be !
TrimString
(
inputString
,
start
).
Let
sign
be 1.
If
S
is not empty and the first code unit of
S
is the code unit 0x002D (HYPHEN-MINUS), set
sign
to -1.
If
S
is not empty and the first code unit of
S
is either the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), set
S
to the
substring
of
S
from index 1.
Let
R
be
ℝ
(?
ToInt32
(
radix
)).
Let
stripPrefix
be
true
.
If
R
≠ 0, then
If
R
< 2 or
R
> 36, return
NaN
.
If
R
≠ 16, set
stripPrefix
to
false
.
Else,
Set
R
to 10.
If
stripPrefix
is
true
, then
If the length of
S
≥ 2 and the first two code units of
S
are either
"0x"
or
"0X"
, then
Set
S
to the
substring
of
S
from index 2.
Set
R
to 16.
If
S
contains a code unit that is not a radix-
R
digit, let
end
be the index within
S
of the first such code unit; otherwise let
end
be the length of
S
.
Let
Z
be the
substring
of
S
from 0 to
end
.
If
Z
is empty, return
NaN
.
Let
mathInt
be the
integer
value that is represented by
Z
in radix-
R
notation, using the letters
A
through
Z
and
a
through
z
for digits with values 10 through 35. (However, if
R
= 10 and
Z
contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if
R
is not one of 2, 4, 8, 10, 16, or 32, then
mathInt
may be an
implementation-approximated
integer
representing the
integer
value denoted by
Z
in radix-
R
notation.)
If
mathInt
= 0, then
If
sign
= -1, return
-0
𝔽
.
Return
+0
𝔽
.
Return
𝔽
(
sign
×
mathInt
).
Note
This function may interpret only a leading portion of
string
as an
integer
value; it ignores any code units that cannot be interpreted as part of the notation of an
integer
, and no indication is given that any such code units were ignored.
19.2.6
URI Handling Functions
Uniform Resource Identifiers, or URIs, are Strings that identify resources (e.g. web pages or files) and transport protocols by which to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language itself does not provide any support for using URIs except for functions that encode and decode URIs as described in this section.
encodeURI
and
decodeURI
are intended to work with complete URIs; they assume that any reserved characters are intended to have special meaning (e.g., as delimiters) and so are not encoded.
encodeURIComponent
and
decodeURIComponent
are intended to work with the individual components of a URI; they assume that any reserved characters represent text and must be encoded to avoid special meaning when the component is part of a complete URI.
Note 1
The set of reserved characters is based upon RFC 2396 and does not reflect changes introduced by the more recent RFC 3986.
Note 2
Many implementations of ECMAScript provide additional functions and methods that manipulate web pages; these functions are beyond the scope of this standard.
19.2.6.1
decodeURI (
encodedURI
)
This function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the
encodeURI
function is replaced with the UTF-16 encoding of the code point that it represents. Escape sequences that could not have been introduced by
encodeURI
are not replaced.
It is the
%decodeURI%
intrinsic object.
It performs the following steps when called:
Let
uriString
be ?
ToString
(
encodedURI
).
Let
preserveEscapeSet
be
";/?:@&=+$,#"
.
Return ?
Decode
(
uriString
,
preserveEscapeSet
).
19.2.6.2
decodeURIComponent (
encodedURIComponent
)
This function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the
encodeURIComponent
function is replaced with the UTF-16 encoding of the code point that it represents.
It is the
%decodeURIComponent%
intrinsic object.
It performs the following steps when called:
Let
componentString
be ?
ToString
(
encodedURIComponent
).
Let
preserveEscapeSet
be the empty String.
Return ?
Decode
(
componentString
,
preserveEscapeSet
).
19.2.6.3
encodeURI (
uri
)
This function computes a new version of a UTF-16 encoded (
6.1.4
) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code point.
It is the
%encodeURI%
intrinsic object.
It performs the following steps when called:
Let
uriString
be ?
ToString
(
uri
).
Let
extraUnescaped
be
";/?:@&=+$,#"
.
Return ?
Encode
(
uriString
,
extraUnescaped
).
19.2.6.4
encodeURIComponent (
uriComponent
)
This function computes a new version of a UTF-16 encoded (
6.1.4
) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code point.
It is the
%encodeURIComponent%
intrinsic object.
It performs the following steps when called:
Let
componentString
be ?
ToString
(
uriComponent
).
Let
extraUnescaped
be the empty String.
Return ?
Encode
(
componentString
,
extraUnescaped
).
19.2.6.5
Encode (
string
,
extraUnescaped
)
The abstract operation Encode takes arguments
string
(a String) and
extraUnescaped
(a String) and returns either a
normal completion containing
a String or a
throw completion
. It performs URI encoding and escaping, interpreting
string
as a sequence of UTF-16 encoded code points as described in
6.1.4
. If a character is identified as unreserved in RFC 2396 or appears in
extraUnescaped
, it is not escaped. It performs the following steps when called:
Let
len
be the length of
string
.
Let
R
be the empty String.
Let
alwaysUnescaped
be the
string-concatenation
of
the ASCII word characters
and
"-.!~*'()"
.
Let
unescapedSet
be the
string-concatenation
of
alwaysUnescaped
and
extraUnescaped
.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
C
be the code unit at index
k
within
string
.
If
unescapedSet
contains
C
, then
Set
k
to
k
+ 1.
Set
R
to the
string-concatenation
of
R
and
C
.
Else,
Let
cp
be
CodePointAt
(
string
,
k
).
If
cp
.
[[IsUnpairedSurrogate]]
is
true
, throw a
URIError
exception.
Set
k
to
k
+
cp
.
[[CodeUnitCount]]
.
Let
Octets
be the
List
of octets resulting by applying the UTF-8 transformation to
cp
.
[[CodePoint]]
.
For each element
octet
of
Octets
, do
Let
hex
be the String representation of
octet
, formatted as an uppercase hexadecimal number.
Set
R
to the
string-concatenation
of
R
,
"%"
, and
StringPad
(
hex
, 2,
"0"
,
start
).
Return
R
.
Note
Because percent-encoding is used to represent individual octets, a single code point may be expressed as multiple consecutive escape sequences (one for each of its 8-bit UTF-8 code units).
19.2.6.6
Decode (
string
,
preserveEscapeSet
)
The abstract operation Decode takes arguments
string
(a String) and
preserveEscapeSet
(a String) and returns either a
normal completion containing
a String or a
throw completion
. It performs URI unescaping and decoding, preserving any escape sequences that correspond to Basic Latin characters in
preserveEscapeSet
. It performs the following steps when called:
Let
len
be the length of
string
.
Let
R
be the empty String.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
C
be the code unit at index
k
within
string
.
Let
S
be
C
.
If
C
is the code unit 0x0025 (PERCENT SIGN), then
If
k
+ 3 >
len
, throw a
URIError
exception.
Let
escape
be the
substring
of
string
from
k
to
k
+ 3.
Let
B
be
ParseHexOctet
(
string
,
k
+ 1).
If
B
is not an
integer
, throw a
URIError
exception.
Set
k
to
k
+ 2.
Let
n
be the number of leading 1 bits in
B
.
If
n
= 0, then
Let
asciiChar
be the code unit whose numeric value is
B
.
If
preserveEscapeSet
contains
asciiChar
, set
S
to
escape
; otherwise set
S
to
asciiChar
.
Else,
If
n
= 1 or
n
> 4, throw a
URIError
exception.
Let
Octets
be «
B
».
Let
j
be 1.
Repeat, while
j
<
n
,
Set
k
to
k
+ 1.
If
k
+ 3 >
len
, throw a
URIError
exception.
If the code unit at index
k
within
string
is not the code unit 0x0025 (PERCENT SIGN), throw a
URIError
exception.
Let
continuationByte
be
ParseHexOctet
(
string
,
k
+ 1).
If
continuationByte
is not an
integer
, throw a
URIError
exception.
Append
continuationByte
to
Octets
.
Set
k
to
k
+ 2.
Set
j
to
j
+ 1.
Assert
: The length of
Octets
is
n
.
If
Octets
does not contain a valid UTF-8 encoding of a Unicode code point, throw a
URIError
exception.
Let
V
be the code point obtained by applying the UTF-8 transformation to
Octets
, that is, from a
List
of octets into a 21-bit value.
Set
S
to
UTF16EncodeCodePoint
(
V
).
Set
R
to the
string-concatenation
of
R
and
S
.
Set
k
to
k
+ 1.
Return
R
.
Note
RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For example, the invalid sequence 0xC0 0x80 must not decode into the code unit 0x0000. Implementations of the Decode algorithm are required to throw a
URIError
when encountering such invalid sequences.
19.2.6.7
ParseHexOctet (
string
,
position
)
The abstract operation ParseHexOctet takes arguments
string
(a String) and
position
(a non-negative
integer
) and returns either a non-negative
integer
or a non-empty
List
of
SyntaxError
objects. It parses a sequence of two hexadecimal characters at the specified
position
in
string
into an unsigned 8-bit
integer
. It performs the following steps when called:
Let
len
be the length of
string
.
Assert
:
position
+ 2 ≤
len
.
Let
hexDigits
be the
substring
of
string
from
position
to
position
+ 2.
Let
parseResult
be
ParseText
(
hexDigits
,
HexDigits
[~Sep]
).
If
parseResult
is not a
Parse Node
, return
parseResult
.
Let
n
be the MV of
parseResult
.
Assert
:
n
is in the
inclusive interval
from 0 to 255.
Return
n
.
19.3
Constructor Properties of the Global Object
19.3.1
AggregateError ( . . . )
See
20.5.7.1
.
19.3.2
Array ( . . . )
See
23.1.1
.
19.3.3
ArrayBuffer ( . . . )
See
25.1.4
.
19.3.4
BigInt ( . . . )
See
21.2.1
.
19.3.5
BigInt64Array ( . . . )
See
23.2.5
.
19.3.6
BigUint64Array ( . . . )
See
23.2.5
.
19.3.7
Boolean ( . . . )
See
20.3.1
.
19.3.8
DataView ( . . . )
See
25.3.2
.
19.3.9
Date ( . . . )
See
21.4.2
.
19.3.10
Error ( . . . )
See
20.5.1
.
19.3.11
EvalError ( . . . )
See
20.5.5.1
.
19.3.12
FinalizationRegistry ( . . . )
See
26.2.1
.
19.3.13
Float16Array ( . . . )
See
23.2.5
.
19.3.14
Float32Array ( . . . )
See
23.2.5
.
19.3.15
Float64Array ( . . . )
See
23.2.5
.
19.3.16
Function ( . . . )
See
20.2.1
.
19.3.17
Int8Array ( . . . )
See
23.2.5
.
19.3.18
Int16Array ( . . . )
See
23.2.5
.
19.3.19
Int32Array ( . . . )
See
23.2.5
.
19.3.20
Iterator ( . . . )
See
27.1.3.1
.
19.3.21
Map ( . . . )
See
24.1.1
.
19.3.22
Number ( . . . )
See
21.1.1
.
19.3.23
Object ( . . . )
See
20.1.1
.
19.3.24
Promise ( . . . )
See
27.2.3
.
19.3.25
Proxy ( . . . )
See
28.2.1
.
19.3.26
RangeError ( . . . )
See
20.5.5.2
.
19.3.27
ReferenceError ( . . . )
See
20.5.5.3
.
19.3.28
RegExp ( . . . )
See
22.2.4
.
19.3.29
Set ( . . . )
See
24.2.2
.
19.3.30
SharedArrayBuffer ( . . . )
See
25.2.3
.
19.3.31
String ( . . . )
See
22.1.1
.
19.3.32
Symbol ( . . . )
See
20.4.1
.
19.3.33
SyntaxError ( . . . )
See
20.5.5.4
.
19.3.34
TypeError ( . . . )
See
20.5.5.5
.
19.3.35
Uint8Array ( . . . )
See
23.2.5
.
19.3.36
Uint8ClampedArray ( . . . )
See
23.2.5
.
19.3.37
Uint16Array ( . . . )
See
23.2.5
.
19.3.38
Uint32Array ( . . . )
See
23.2.5
.
19.3.39
URIError ( . . . )
See
20.5.5.6
.
19.3.40
WeakMap ( . . . )
See
24.3.1
.
19.3.41
WeakRef ( . . . )
See
26.1.1
.
19.3.42
WeakSet ( . . . )
See
24.4
.
19.4
Other Properties of the Global Object
19.4.1
Atomics
See
25.4
.
19.4.2
JSON
See
25.5
.
19.4.3
Math
See
21.3
.
19.4.4
Reflect
See
28.1
.
20
Fundamental Objects
20.1
Object Objects
20.1.1
The Object Constructor
The Object
constructor
:
is
%Object%
.
is the initial value of the
"Object"
property of the
global object
.
creates a new
ordinary object
when called as a
constructor
.
performs a type conversion when called as a function rather than as a
constructor
.
may be used as the value of an
extends
clause of a class definition.
20.1.1.1
Object (
value
)
This function performs the following steps when called:
If NewTarget is neither
undefined
nor the
active function object
, then
Return ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Object.prototype%"
).
If
value
is either
undefined
or
null
, return
OrdinaryObjectCreate
(
%Object.prototype%
).
Return !
ToObject
(
value
).
20.1.2
Properties of the Object Constructor
The Object
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following additional properties:
20.1.2.1
Object.assign (
target
, ...
sources
)
This function copies the values of all of the enumerable own properties from one or more source objects to a
target
object.
It performs the following steps when called:
Let
to
be ?
ToObject
(
target
).
If only one argument was passed, return
to
.
For each element
nextSource
of
sources
, do
If
nextSource
is neither
undefined
nor
null
, then
Let
from
be !
ToObject
(
nextSource
).
Let
keys
be ?
from
.
[[OwnPropertyKeys]]
()
.
For each element
nextKey
of
keys
, do
Let
desc
be ?
from
.
[[GetOwnProperty]]
(
nextKey
)
.
If
desc
is not
undefined
and
desc
.
[[Enumerable]]
is
true
, then
Let
propValue
be ?
Get
(
from
,
nextKey
).
Perform ?
Set
(
to
,
nextKey
,
propValue
,
true
).
Return
to
.
The
"length"
property of this function is
2
𝔽
.
20.1.2.2
Object.create (
O
,
Properties
)
This function creates a new object with a specified prototype.
It performs the following steps when called:
If
O
is not an Object
and
O
is not
null
, throw a
TypeError
exception.
Let
obj
be
OrdinaryObjectCreate
(
O
).
If
Properties
is not
undefined
, then
Return ?
ObjectDefineProperties
(
obj
,
Properties
).
Return
obj
.
20.1.2.3
Object.defineProperties (
O
,
Properties
)
This function adds own properties and/or updates the attributes of existing own properties of an object.
It performs the following steps when called:
If
O
is not an Object
, throw a
TypeError
exception.
Return ?
ObjectDefineProperties
(
O
,
Properties
).
20.1.2.3.1
ObjectDefineProperties (
O
,
Properties
)
The abstract operation ObjectDefineProperties takes arguments
O
(an Object) and
Properties
(an
ECMAScript language value
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
Let
props
be ?
ToObject
(
Properties
).
Let
keys
be ?
props
.
[[OwnPropertyKeys]]
()
.
Let
descriptors
be a new empty
List
.
For each element
nextKey
of
keys
, do
Let
propDesc
be ?
props
.
[[GetOwnProperty]]
(
nextKey
)
.
If
propDesc
is not
undefined
and
propDesc
.
[[Enumerable]]
is
true
, then
Let
descObj
be ?
Get
(
props
,
nextKey
).
Let
desc
be ?
ToPropertyDescriptor
(
descObj
).
Append the
Record
{
[[Key]]
:
nextKey
,
[[Descriptor]]
:
desc
} to
descriptors
.
For each element
property
of
descriptors
, do
Perform ?
DefinePropertyOrThrow
(
O
,
property
.
[[Key]]
,
property
.
[[Descriptor]]
).
Return
O
.
20.1.2.4
Object.defineProperty (
O
,
P
,
Attributes
)
This function adds an own property and/or updates the attributes of an existing own property of an object.
It performs the following steps when called:
If
O
is not an Object
, throw a
TypeError
exception.
Let
key
be ?
ToPropertyKey
(
P
).
Let
desc
be ?
ToPropertyDescriptor
(
Attributes
).
Perform ?
DefinePropertyOrThrow
(
O
,
key
,
desc
).
Return
O
.
20.1.2.5
Object.entries (
O
)
This function performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Let
entryList
be ?
EnumerableOwnProperties
(
obj
,
key+value
).
Return
CreateArrayFromList
(
entryList
).
20.1.2.6
Object.freeze (
O
)
This function performs the following steps when called:
If
O
is not an Object
, return
O
.
Let
status
be ?
SetIntegrityLevel
(
O
,
frozen
).
If
status
is
false
, throw a
TypeError
exception.
Return
O
.
20.1.2.7
Object.fromEntries (
iterable
)
This function performs the following steps when called:
Perform ?
RequireObjectCoercible
(
iterable
).
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Assert
:
obj
is an extensible
ordinary object
with no own properties.
Let
closure
be a new
Abstract Closure
with parameters (
key
,
value
) that captures
obj
and performs the following steps when called:
Let
propertyKey
be ?
ToPropertyKey
(
key
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
propertyKey
,
value
).
Return
NormalCompletion
(
undefined
).
Let
adder
be
CreateBuiltinFunction
(
closure
, 2,
""
, « »).
Return ?
AddEntriesFromIterable
(
obj
,
iterable
,
adder
).
Note
The function created for
adder
is never directly accessible to ECMAScript code.
20.1.2.8
Object.getOwnPropertyDescriptor (
O
,
P
)
This function performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Let
key
be ?
ToPropertyKey
(
P
).
Let
desc
be ?
obj
.
[[GetOwnProperty]]
(
key
)
.
Return
FromPropertyDescriptor
(
desc
).
20.1.2.9
Object.getOwnPropertyDescriptors (
O
)
This function performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Let
ownKeys
be ?
obj
.
[[OwnPropertyKeys]]
()
.
Let
descriptors
be
OrdinaryObjectCreate
(
%Object.prototype%
).
For each element
key
of
ownKeys
, do
Let
desc
be ?
obj
.
[[GetOwnProperty]]
(
key
)
.
Let
descriptor
be
FromPropertyDescriptor
(
desc
).
If
descriptor
is not
undefined
, perform !
CreateDataPropertyOrThrow
(
descriptors
,
key
,
descriptor
).
Return
descriptors
.
20.1.2.10
Object.getOwnPropertyNames (
O
)
This function performs the following steps when called:
Return
CreateArrayFromList
(?
GetOwnPropertyKeys
(
O
,
string
)).
20.1.2.11
Object.getOwnPropertySymbols (
O
)
This function performs the following steps when called:
Return
CreateArrayFromList
(?
GetOwnPropertyKeys
(
O
,
symbol
)).
20.1.2.11.1
GetOwnPropertyKeys (
O
,
type
)
The abstract operation GetOwnPropertyKeys takes arguments
O
(an
ECMAScript language value
) and
type
(
string
or
symbol
) and returns either a
normal completion containing
a
List
of
property keys
or a
throw completion
. It performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Let
keys
be ?
obj
.
[[OwnPropertyKeys]]
()
.
Let
nameList
be a new empty
List
.
For each element
nextKey
of
keys
, do
If
nextKey
is a Symbol
and
type
is
symbol
, or if
nextKey
is a String
and
type
is
string
, then
Append
nextKey
to
nameList
.
Return
nameList
.
20.1.2.12
Object.getPrototypeOf (
O
)
This function performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Return ?
obj
.
[[GetPrototypeOf]]
()
.
20.1.2.13
Object.groupBy (
items
,
callback
)
Note
callback
should be a function that accepts two arguments.
groupBy
calls
callback
once for each element in
items
, in ascending order, and constructs a new object. Each value returned by
callback
is coerced to a
property key
. For each such
property key
, the result object has a property whose key is that
property key
and whose value is an array containing all the elements for which the
callback
return value coerced to that key.
callback
is called with two arguments: the value of the element and the index of the element.
The return value of
groupBy
is an object that does not inherit from
%Object.prototype%
.
This function performs the following steps when called:
Let
groups
be ?
GroupBy
(
items
,
callback
,
property
).
Let
obj
be
OrdinaryObjectCreate
(
null
).
For each
Record
{
[[Key]]
,
[[Elements]]
}
g
of
groups
, do
Let
elements
be
CreateArrayFromList
(
g
.
[[Elements]]
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
g
.
[[Key]]
,
elements
).
Return
obj
.
20.1.2.14
Object.hasOwn (
O
,
P
)
This function performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Let
key
be ?
ToPropertyKey
(
P
).
Return ?
HasOwnProperty
(
obj
,
key
).
20.1.2.15
Object.is (
value1
,
value2
)
This function performs the following steps when called:
Return
SameValue
(
value1
,
value2
).
20.1.2.16
Object.isExtensible (
O
)
This function performs the following steps when called:
If
O
is not an Object
, return
false
.
Return ?
IsExtensible
(
O
).
20.1.2.17
Object.isFrozen (
O
)
This function performs the following steps when called:
If
O
is not an Object
, return
true
.
Return ?
TestIntegrityLevel
(
O
,
frozen
).
20.1.2.18
Object.isSealed (
O
)
This function performs the following steps when called:
If
O
is not an Object
, return
true
.
Return ?
TestIntegrityLevel
(
O
,
sealed
).
20.1.2.19
Object.keys (
O
)
This function performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Let
keyList
be ?
EnumerableOwnProperties
(
obj
,
key
).
Return
CreateArrayFromList
(
keyList
).
20.1.2.20
Object.preventExtensions (
O
)
This function performs the following steps when called:
If
O
is not an Object
, return
O
.
Let
status
be ?
O
.
[[PreventExtensions]]
()
.
If
status
is
false
, throw a
TypeError
exception.
Return
O
.
20.1.2.21
Object.prototype
The initial value of
Object.prototype
is the
Object prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.1.2.22
Object.seal (
O
)
This function performs the following steps when called:
If
O
is not an Object
, return
O
.
Let
status
be ?
SetIntegrityLevel
(
O
,
sealed
).
If
status
is
false
, throw a
TypeError
exception.
Return
O
.
20.1.2.23
Object.setPrototypeOf (
O
,
proto
)
This function performs the following steps when called:
Perform ?
RequireObjectCoercible
(
O
).
If
proto
is not an Object
and
proto
is not
null
, throw a
TypeError
exception.
If
O
is not an Object
, return
O
.
Let
status
be ?
O
.
[[SetPrototypeOf]]
(
proto
)
.
If
status
is
false
, throw a
TypeError
exception.
Return
O
.
20.1.2.24
Object.values (
O
)
This function performs the following steps when called:
Let
obj
be ?
ToObject
(
O
).
Let
valueList
be ?
EnumerableOwnProperties
(
obj
,
value
).
Return
CreateArrayFromList
(
valueList
).
20.1.3
Properties of the Object Prototype Object
The
Object prototype object
:
is
%Object.prototype%
.
has an
[[Extensible]]
internal slot whose value is
true
.
has the internal methods defined for
ordinary objects
, except for the
[[SetPrototypeOf]]
method, which is as defined in
10.4.7.1
. (Thus, it is an
immutable prototype exotic object
.)
has a
[[Prototype]]
internal slot whose value is
null
.
20.1.3.1
Object.prototype.constructor
The initial value of
Object.prototype.constructor
is
%Object%
.
20.1.3.2
Object.prototype.hasOwnProperty (
V
)
This method performs the following steps when called:
Let
P
be ?
ToPropertyKey
(
V
).
Let
O
be ?
ToObject
(
this
value).
Return ?
HasOwnProperty
(
O
,
P
).
Note
The ordering of steps
1
and
2
is chosen to ensure that any exception that would have been thrown by step
1
in previous editions of this specification will continue to be thrown even if the
this
value is
undefined
or
null
.
20.1.3.3
Object.prototype.isPrototypeOf (
V
)
This method performs the following steps when called:
If
V
is not an Object
, return
false
.
Let
O
be ?
ToObject
(
this
value).
Repeat,
Set
V
to ?
V
.
[[GetPrototypeOf]]
()
.
If
V
is
null
, return
false
.
If
SameValue
(
O
,
V
) is
true
, return
true
.
Note
The ordering of steps
1
and
2
preserves the behaviour specified by previous editions of this specification for the case where
V
is not an object and the
this
value is
undefined
or
null
.
20.1.3.4
Object.prototype.propertyIsEnumerable (
V
)
This method performs the following steps when called:
Let
P
be ?
ToPropertyKey
(
V
).
Let
O
be ?
ToObject
(
this
value).
Let
desc
be ?
O
.
[[GetOwnProperty]]
(
P
)
.
If
desc
is
undefined
, return
false
.
Return
desc
.
[[Enumerable]]
.
Note 1
This method does not consider objects in the prototype chain.
Note 2
The ordering of steps
1
and
2
is chosen to ensure that any exception that would have been thrown by step
1
in previous editions of this specification will continue to be thrown even if the
this
value is
undefined
or
null
.
20.1.3.5
Object.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
This method performs the following steps when called:
Let
O
be the
this
value.
Return ?
Invoke
(
O
,
"toString"
).
The optional parameters to this method are not used but are intended to correspond to the parameter pattern used by ECMA-402
toLocaleString
methods. Implementations that do not include ECMA-402 support must not use those parameter positions for other purposes.
Note 1
This method provides a generic
toLocaleString
implementation for objects that have no locale-sensitive
toString
behaviour.
Array
,
Number
,
Date
, and
%TypedArray%
provide their own locale-sensitive
toLocaleString
methods.
Note 2
ECMA-402 intentionally does not provide an alternative to this default implementation.
20.1.3.6
Object.prototype.toString ( )
This method performs the following steps when called:
If the
this
value is
undefined
, return
"[object Undefined]"
.
If the
this
value is
null
, return
"[object Null]"
.
Let
O
be !
ToObject
(
this
value).
Let
isArray
be ?
IsArray
(
O
).
If
isArray
is
true
, let
builtinTag
be
"Array"
.
Else if
O
has a
[[ParameterMap]]
internal slot, let
builtinTag
be
"Arguments"
.
Else if
O
has a
[[Call]]
internal method, let
builtinTag
be
"Function"
.
Else if
O
has an
[[ErrorData]]
internal slot, let
builtinTag
be
"Error"
.
Else if
O
has a
[[BooleanData]]
internal slot, let
builtinTag
be
"Boolean"
.
Else if
O
has a
[[NumberData]]
internal slot, let
builtinTag
be
"Number"
.
Else if
O
has a
[[StringData]]
internal slot, let
builtinTag
be
"String"
.
Else if
O
has a
[[DateValue]]
internal slot, let
builtinTag
be
"Date"
.
Else if
O
has a
[[RegExpMatcher]]
internal slot, let
builtinTag
be
"RegExp"
.
Else, let
builtinTag
be
"Object"
.
Let
tag
be ?
Get
(
O
,
%Symbol.toStringTag%
).
If
tag
is not a String
, set
tag
to
builtinTag
.
Return the
string-concatenation
of
"[object "
,
tag
, and
"]"
.
Note
Historically, this method was occasionally used to access the String value of the
[[Class]]
internal slot that was used in previous editions of this specification as a nominal type tag for various built-in objects. The above definition of
toString
preserves compatibility for legacy code that uses
toString
as a test for those specific kinds of built-in objects. It does not provide a reliable type testing mechanism for other kinds of built-in or program defined objects. In addition, programs can use
%Symbol.toStringTag%
in ways that will invalidate the reliability of such legacy type tests.
20.1.3.7
Object.prototype.valueOf ( )
This method performs the following steps when called:
Return ?
ToObject
(
this
value).
Normative Optional
,
Legacy
20.1.3.8
Object.prototype.__proto__
Object.prototype.__proto__
is an
accessor property
with attributes {
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}. The
[[Get]]
and
[[Set]]
attributes are defined as follows:
20.1.3.8.1
get Object.prototype.__proto__
The value of the
[[Get]]
attribute is a built-in function that requires no arguments. It performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Return ?
O
.
[[GetPrototypeOf]]
()
.
20.1.3.8.2
set Object.prototype.__proto__
The value of the
[[Set]]
attribute is a built-in function that takes an argument
proto
. It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
If
proto
is not an Object
and
proto
is not
null
, return
undefined
.
If
O
is not an Object
, return
undefined
.
Let
status
be ?
O
.
[[SetPrototypeOf]]
(
proto
)
.
If
status
is
false
, throw a
TypeError
exception.
Return
undefined
.
Normative Optional
,
Legacy
20.1.3.9
Legacy Object.prototype Accessor Methods
20.1.3.9.1
Object.prototype.__defineGetter__ (
P
,
getter
)
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
If
IsCallable
(
getter
) is
false
, throw a
TypeError
exception.
Let
desc
be PropertyDescriptor {
[[Get]]
:
getter
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
true
}.
Let
key
be ?
ToPropertyKey
(
P
).
Perform ?
DefinePropertyOrThrow
(
O
,
key
,
desc
).
Return
undefined
.
20.1.3.9.2
Object.prototype.__defineSetter__ (
P
,
setter
)
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
If
IsCallable
(
setter
) is
false
, throw a
TypeError
exception.
Let
desc
be PropertyDescriptor {
[[Set]]
:
setter
,
[[Enumerable]]
:
true
,
[[Configurable]]
:
true
}.
Let
key
be ?
ToPropertyKey
(
P
).
Perform ?
DefinePropertyOrThrow
(
O
,
key
,
desc
).
Return
undefined
.
20.1.3.9.3
Object.prototype.__lookupGetter__ (
P
)
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
key
be ?
ToPropertyKey
(
P
).
Repeat,
Let
desc
be ?
O
.
[[GetOwnProperty]]
(
key
)
.
If
desc
is not
undefined
, then
If
IsAccessorDescriptor
(
desc
) is
true
, return
desc
.
[[Get]]
.
Return
undefined
.
Set
O
to ?
O
.
[[GetPrototypeOf]]
()
.
If
O
is
null
, return
undefined
.
20.1.3.9.4
Object.prototype.__lookupSetter__ (
P
)
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
key
be ?
ToPropertyKey
(
P
).
Repeat,
Let
desc
be ?
O
.
[[GetOwnProperty]]
(
key
)
.
If
desc
is not
undefined
, then
If
IsAccessorDescriptor
(
desc
) is
true
, return
desc
.
[[Set]]
.
Return
undefined
.
Set
O
to ?
O
.
[[GetPrototypeOf]]
()
.
If
O
is
null
, return
undefined
.
20.1.4
Properties of Object Instances
Object instances have no special properties beyond those inherited from the
Object prototype object
.
20.2
Function Objects
20.2.1
The Function Constructor
The Function
constructor
:
is
%Function%
.
is the initial value of the
"Function"
property of the
global object
.
creates and initializes a new
function object
when called as a function rather than as a
constructor
. Thus the function call
Function(…)
is equivalent to the object creation expression
new Function(…)
with the same arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Function behaviour must include a
super
call to the Function
constructor
to create and initialize a subclass instance with the internal slots necessary for built-in function behaviour. All ECMAScript syntactic forms for defining
function objects
create instances of Function. There is no syntactic means to create instances of Function subclasses except for the built-in GeneratorFunction, AsyncFunction, and AsyncGeneratorFunction subclasses.
20.2.1.1
Function ( ...
parameterArgs
,
bodyArg
)
The last argument (if any) specifies the body (executable code) of a function; any preceding arguments specify formal parameters.
This function performs the following steps when called:
Let
C
be the
active function object
.
If
bodyArg
is not present, set
bodyArg
to the empty String.
Return ?
CreateDynamicFunction
(
C
, NewTarget,
normal
,
parameterArgs
,
bodyArg
).
Note
It is permissible but not necessary to have one argument for each formal parameter to be specified. For example, all three of the following expressions produce the same result:
new
Function
(
"a"
,
"b"
,
"c"
,
"return a+b+c"
)
new
Function
(
"a, b, c"
,
"return a+b+c"
)
new
Function
(
"a,b"
,
"c"
,
"return a+b+c"
)
20.2.1.1.1
CreateDynamicFunction (
constructor
,
newTarget
,
kind
,
parameterArgs
,
bodyArg
)
The abstract operation CreateDynamicFunction takes arguments
constructor
(a
constructor
),
newTarget
(a
constructor
or
undefined
),
kind
(
normal
,
generator
,
async
, or
async-generator
),
parameterArgs
(a
List
of
ECMAScript language values
), and
bodyArg
(an
ECMAScript language value
) and returns either a
normal completion containing
an ECMAScript
function object
or a
throw completion
.
constructor
is the
constructor
function that is performing this action.
newTarget
is the
constructor
that
new
was initially applied to.
parameterArgs
and
bodyArg
reflect the argument values that were passed to
constructor
. It performs the following steps when called:
If
newTarget
is
undefined
, set
newTarget
to
constructor
.
If
kind
is
normal
, then
Let
prefix
be
"function"
.
Let
exprSym
be the grammar symbol
FunctionExpression
.
Let
bodySym
be the grammar symbol
FunctionBody
[~Yield, ~Await]
.
Let
parameterSym
be the grammar symbol
FormalParameters
[~Yield, ~Await]
.
Let
fallbackProto
be
"%Function.prototype%"
.
Else if
kind
is
generator
, then
Let
prefix
be
"function*"
.
Let
exprSym
be the grammar symbol
GeneratorExpression
.
Let
bodySym
be the grammar symbol
GeneratorBody
.
Let
parameterSym
be the grammar symbol
FormalParameters
[+Yield, ~Await]
.
Let
fallbackProto
be
"%GeneratorFunction.prototype%"
.
Else if
kind
is
async
, then
Let
prefix
be
"async function"
.
Let
exprSym
be the grammar symbol
AsyncFunctionExpression
.
Let
bodySym
be the grammar symbol
AsyncFunctionBody
.
Let
parameterSym
be the grammar symbol
FormalParameters
[~Yield, +Await]
.
Let
fallbackProto
be
"%AsyncFunction.prototype%"
.
Else,
Assert
:
kind
is
async-generator
.
Let
prefix
be
"async function*"
.
Let
exprSym
be the grammar symbol
AsyncGeneratorExpression
.
Let
bodySym
be the grammar symbol
AsyncGeneratorBody
.
Let
parameterSym
be the grammar symbol
FormalParameters
[+Yield, +Await]
.
Let
fallbackProto
be
"%AsyncGeneratorFunction.prototype%"
.
Let
argCount
be the number of elements in
parameterArgs
.
Let
parameterStrings
be a new empty
List
.
For each element
arg
of
parameterArgs
, do
Append ?
ToString
(
arg
) to
parameterStrings
.
Let
bodyString
be ?
ToString
(
bodyArg
).
Let
currentRealm
be
the current Realm Record
.
Perform ?
HostEnsureCanCompileStrings
(
currentRealm
,
parameterStrings
,
bodyString
,
false
).
Let
P
be the empty String.
If
argCount
> 0, then
Set
P
to
parameterStrings
[0].
Let
k
be 1.
Repeat, while
k
<
argCount
,
Let
nextArgString
be
parameterStrings
[
k
].
Set
P
to the
string-concatenation
of
P
,
","
(a comma), and
nextArgString
.
Set
k
to
k
+ 1.
Let
bodyParseString
be the
string-concatenation
of 0x000A (LINE FEED),
bodyString
, and 0x000A (LINE FEED).
Let
sourceString
be the
string-concatenation
of
prefix
,
" anonymous("
,
P
, 0x000A (LINE FEED),
") {"
,
bodyParseString
, and
"}"
.
Let
sourceText
be
StringToCodePoints
(
sourceString
).
Let
parameters
be
ParseText
(
P
,
parameterSym
).
If
parameters
is a
List
of errors, throw a
SyntaxError
exception.
Let
body
be
ParseText
(
bodyParseString
,
bodySym
).
If
body
is a
List
of errors, throw a
SyntaxError
exception.
NOTE: The parameters and body are parsed separately to ensure that each is valid alone. For example,
new Function("/*", "*/ ) {")
does not evaluate to a function.
NOTE: If this step is reached,
sourceText
must have the syntax of
exprSym
(although the reverse implication does not hold). The purpose of the next two steps is to enforce any Early Error rules which apply to
exprSym
directly.
Let
expr
be
ParseText
(
sourceText
,
exprSym
).
If
expr
is a
List
of errors, throw a
SyntaxError
exception.
Let
proto
be ?
GetPrototypeFromConstructor
(
newTarget
,
fallbackProto
).
Let
env
be
currentRealm
.
[[GlobalEnv]]
.
Let
privateEnv
be
null
.
Let
F
be
OrdinaryFunctionCreate
(
proto
,
sourceText
,
parameters
,
body
,
non-lexical-this
,
env
,
privateEnv
).
Perform
SetFunctionName
(
F
,
"anonymous"
).
If
kind
is
generator
, then
Let
prototype
be
OrdinaryObjectCreate
(
%GeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
F
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Else if
kind
is
async-generator
, then
Let
prototype
be
OrdinaryObjectCreate
(
%AsyncGeneratorPrototype%
).
Perform !
DefinePropertyOrThrow
(
F
,
"prototype"
, PropertyDescriptor {
[[Value]]
:
prototype
,
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Else if
kind
is
normal
, then
Perform
MakeConstructor
(
F
).
NOTE: Functions whose
kind
is
async
are not constructable and do not have a
[[Construct]]
internal method or a
"prototype"
property.
Return
F
.
Note
CreateDynamicFunction defines a
"prototype"
property on any function it creates whose
kind
is not
async
to provide for the possibility that the function will be used as a
constructor
.
20.2.2
Properties of the Function Constructor
The Function
constructor
:
is itself a built-in
function object
.
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has a
"length"
property whose value is
1
𝔽
.
has the following properties:
20.2.2.1
Function.prototype
The value of
Function.prototype
is the
Function prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.2.3
Properties of the Function Prototype Object
The
Function prototype object
:
is
%Function.prototype%
.
is itself a built-in
function object
.
accepts any arguments and returns
undefined
when invoked.
does not have a
[[Construct]]
internal method; it cannot be used as a
constructor
with the
new
operator.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
does not have a
"prototype"
property.
has a
"length"
property whose value is
+0
𝔽
.
has a
"name"
property whose value is the empty String.
Note
The Function prototype object is specified to be a
function object
to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.
20.2.3.1
Function.prototype.apply (
thisArg
,
argArray
)
This method performs the following steps when called:
Let
func
be the
this
value.
If
IsCallable
(
func
) is
false
, throw a
TypeError
exception.
If
argArray
is either
undefined
or
null
, then
Perform
PrepareForTailCall
().
Return ?
Call
(
func
,
thisArg
).
Let
argList
be ?
CreateListFromArrayLike
(
argArray
).
Perform
PrepareForTailCall
().
Return ?
Call
(
func
,
thisArg
,
argList
).
Note 1
The
thisArg
value is passed without modification as the
this
value. This is a change from Edition 3, where an
undefined
or
null
thisArg
is replaced with the
global object
and
ToObject
is applied to all other values and that result is passed as the
this
value. Even though the
thisArg
is passed without modification,
non-strict functions
still perform these transformations upon entry to the function.
Note 2
If
func
is either an arrow function or a
bound function exotic object
, then the
thisArg
will be ignored by the function
[[Call]]
in step
6
.
20.2.3.2
Function.prototype.bind (
thisArg
, ...
args
)
This method performs the following steps when called:
Let
Target
be the
this
value.
If
IsCallable
(
Target
) is
false
, throw a
TypeError
exception.
Let
F
be ?
BoundFunctionCreate
(
Target
,
thisArg
,
args
).
Let
L
be 0.
Let
targetHasLength
be ?
HasOwnProperty
(
Target
,
"length"
).
If
targetHasLength
is
true
, then
Let
targetLen
be ?
Get
(
Target
,
"length"
).
If
targetLen
is a Number
, then
If
targetLen
is
+∞
𝔽
, then
Set
L
to +∞.
Else if
targetLen
is
-∞
𝔽
, then
Set
L
to 0.
Else,
Let
targetLenAsInt
be !
ToIntegerOrInfinity
(
targetLen
).
Assert
:
targetLenAsInt
is
finite
.
Let
argCount
be the number of elements in
args
.
Set
L
to
max
(
targetLenAsInt
-
argCount
, 0).
Perform
SetFunctionLength
(
F
,
L
).
Let
targetName
be ?
Get
(
Target
,
"name"
).
If
targetName
is not a String
, set
targetName
to the empty String.
Perform
SetFunctionName
(
F
,
targetName
,
"bound"
).
Return
F
.
Note 1
Function objects
created using
Function.prototype.bind
are
exotic objects
. They also do not have a
"prototype"
property.
Note 2
If
Target
is either an arrow function or a
bound function exotic object
, then the
thisArg
passed to this method will not be used by subsequent calls to
F
.
20.2.3.3
Function.prototype.call (
thisArg
, ...
args
)
This method performs the following steps when called:
Let
func
be the
this
value.
If
IsCallable
(
func
) is
false
, throw a
TypeError
exception.
Perform
PrepareForTailCall
().
Return ?
Call
(
func
,
thisArg
,
args
).
Note 1
The
thisArg
value is passed without modification as the
this
value. This is a change from Edition 3, where an
undefined
or
null
thisArg
is replaced with the
global object
and
ToObject
is applied to all other values and that result is passed as the
this
value. Even though the
thisArg
is passed without modification,
non-strict functions
still perform these transformations upon entry to the function.
Note 2
If
func
is either an arrow function or a
bound function exotic object
, then the
thisArg
will be ignored by the function
[[Call]]
in step
4
.
20.2.3.4
Function.prototype.constructor
The initial value of
Function.prototype.constructor
is
%Function%
.
20.2.3.5
Function.prototype.toString ( )
This method performs the following steps when called:
Let
func
be the
this
value.
If
func
is an Object
,
func
has a
[[SourceText]]
internal slot,
func
.
[[SourceText]]
is a sequence of Unicode code points, and
HostHasSourceTextAvailable
(
func
) is
true
, then
Return
CodePointsToString
(
func
.
[[SourceText]]
).
If
func
is a
built-in function object
, return an
implementation-defined
String source code representation of
func
. The representation must have the syntax of a
NativeFunction
. Additionally, if
func
has an
[[InitialName]]
internal slot and
func
.
[[InitialName]]
is a String
, the portion of the returned String that would be matched by
NativeFunctionAccessor
opt
PropertyName
must be
func
.
[[InitialName]]
.
If
func
is an Object
and
IsCallable
(
func
) is
true
, return an
implementation-defined
String source code representation of
func
. The representation must have the syntax of a
NativeFunction
.
Throw a
TypeError
exception.
NativeFunction
:
function
NativeFunctionAccessor
opt
PropertyName
[~Yield, ~Await]
opt
(
FormalParameters
[~Yield, ~Await]
)
{
[
native
code
]
}
NativeFunctionAccessor
:
get
set
20.2.3.6
Function.prototype [ %Symbol.hasInstance% ] (
V
)
This method performs the following steps when called:
Let
F
be the
this
value.
Return ?
OrdinaryHasInstance
(
F
,
V
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
This is the default implementation of
%Symbol.hasInstance%
that most functions inherit.
%Symbol.hasInstance%
is called by the
instanceof
operator to determine whether a value is an instance of a specific
constructor
. An expression such as
v
instanceof
F
evaluates as
F[%
Symbol
.
hasInstance
%](v)
A
constructor
function can control which objects are recognized as its instances by
instanceof
by exposing a different
%Symbol.hasInstance%
method on the function.
This property is non-writable and non-configurable to prevent tampering that could be used to globally expose the target function of a bound function.
The value of the
"name"
property of this method is
"[Symbol.hasInstance]"
.
20.2.4
Function Instances
Every Function instance is an ECMAScript
function object
and has the internal slots listed in
Table 25
.
Function objects
created using the
Function.prototype.bind
method (
20.2.3.2
) have the internal slots listed in
Table 26
.
Function instances have the following properties:
20.2.4.1
length
The value of the
"length"
property is an
integral Number
that indicates the typical number of arguments expected by the function. However, the language permits the function to be invoked with some other number of arguments. The behaviour of a function when invoked on a number of arguments other than the number specified by its
"length"
property depends on the function. This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
20.2.4.2
name
The value of the
"name"
property
is a String
that is descriptive of the function. The name has no semantic significance but is typically a variable or
property name
that is used to refer to the function at its point of definition in
ECMAScript source text
. This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
Anonymous
function objects
that do not have a contextual name associated with them by this specification use the empty String as the value of the
"name"
property.
20.2.4.3
prototype
Function instances that can be used as a
constructor
have a
"prototype"
property. Whenever such a Function instance is created another
ordinary object
is also created and is the initial value of the function's
"prototype"
property. Unless otherwise specified, the value of the
"prototype"
property is used to initialize the
[[Prototype]]
internal slot of the object created when that function is invoked as a
constructor
.
This property has the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
Function objects
created using
Function.prototype.bind
, or by evaluating a
MethodDefinition
(that is not a
GeneratorMethod
or
AsyncGeneratorMethod
) or an
ArrowFunction
do not have a
"prototype"
property.
20.2.5
HostHasSourceTextAvailable (
func
)
The
host-defined
abstract operation HostHasSourceTextAvailable takes argument
func
(a
function object
) and returns a Boolean. It allows
host environments
to prevent the source text from being provided for
func
.
An implementation of HostHasSourceTextAvailable must conform to the following requirements:
It must be deterministic with respect to its parameters. Each time it is called with a specific
func
as its argument, it must return the same result.
The default implementation of HostHasSourceTextAvailable is to return
true
.
20.3
Boolean Objects
20.3.1
The Boolean Constructor
The Boolean
constructor
:
is
%Boolean%
.
is the initial value of the
"Boolean"
property of the
global object
.
creates and initializes a new Boolean object when called as a
constructor
.
performs a type conversion when called as a function rather than as a
constructor
.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Boolean behaviour must include a
super
call to the Boolean
constructor
to create and initialize the subclass instance with a
[[BooleanData]]
internal slot.
20.3.1.1
Boolean (
value
)
This function performs the following steps when called:
Let
b
be
ToBoolean
(
value
).
If NewTarget is
undefined
, return
b
.
Let
O
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Boolean.prototype%"
, «
[[BooleanData]]
»).
Set
O
.
[[BooleanData]]
to
b
.
Return
O
.
20.3.2
Properties of the Boolean Constructor
The Boolean
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
20.3.2.1
Boolean.prototype
The initial value of
Boolean.prototype
is the
Boolean prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.3.3
Properties of the Boolean Prototype Object
The
Boolean prototype object
:
is
%Boolean.prototype%
.
is an
ordinary object
.
is itself a Boolean object; it has a
[[BooleanData]]
internal slot with the value
false
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
20.3.3.1
Boolean.prototype.constructor
The initial value of
Boolean.prototype.constructor
is
%Boolean%
.
20.3.3.2
Boolean.prototype.toString ( )
This method performs the following steps when called:
Let
b
be ?
ThisBooleanValue
(
this
value).
If
b
is
true
, return
"true"
; else return
"false"
.
20.3.3.3
Boolean.prototype.valueOf ( )
This method performs the following steps when called:
Return ?
ThisBooleanValue
(
this
value).
20.3.3.3.1
ThisBooleanValue (
value
)
The abstract operation ThisBooleanValue takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
value
is a Boolean
, return
value
.
If
value
is an Object
and
value
has a
[[BooleanData]]
internal slot, then
Let
b
be
value
.
[[BooleanData]]
.
Assert
:
b
is a Boolean
.
Return
b
.
Throw a
TypeError
exception.
20.3.4
Properties of Boolean Instances
Boolean instances are
ordinary objects
that inherit properties from the
Boolean prototype object
. Boolean instances have a
[[BooleanData]]
internal slot. The
[[BooleanData]]
internal slot is the Boolean value represented by this Boolean object.
20.4
Symbol Objects
20.4.1
The Symbol Constructor
The Symbol
constructor
:
is
%Symbol%
.
is the initial value of the
"Symbol"
property of the
global object
.
returns a new Symbol value when called as a function.
is not intended to be used with the
new
operator.
is not intended to be subclassed.
may be used as the value of an
extends
clause of a class definition but a
super
call to it will cause an exception.
20.4.1.1
Symbol ( [
description
] )
This function performs the following steps when called:
If NewTarget is not
undefined
, throw a
TypeError
exception.
If
description
is
undefined
, let
descString
be
undefined
.
Else, let
descString
be ?
ToString
(
description
).
Return a new Symbol whose
[[Description]]
is
descString
.
20.4.2
Properties of the Symbol Constructor
The Symbol
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
20.4.2.1
Symbol.asyncIterator
The initial value of
Symbol.asyncIterator
is the well-known symbol
%Symbol.asyncIterator%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.2
Symbol.for (
key
)
This function performs the following steps when called:
Let
stringKey
be ?
ToString
(
key
).
For each element
e
of the
GlobalSymbolRegistry List
, do
If
e
.
[[Key]]
is
stringKey
, return
e
.
[[Symbol]]
.
Assert
: The
GlobalSymbolRegistry List
does not currently contain an entry for
stringKey
.
Let
newSymbol
be a new Symbol whose
[[Description]]
is
stringKey
.
Append the GlobalSymbolRegistry
Record
{
[[Key]]
:
stringKey
,
[[Symbol]]
:
newSymbol
} to the
GlobalSymbolRegistry List
.
Return
newSymbol
.
The
GlobalSymbolRegistry List
is an append-only
List
that is globally available. It is shared by all
realms
. Prior to the evaluation of any ECMAScript code, it is initialized as a new empty
List
. Elements of the GlobalSymbolRegistry List are
Records
with the structure defined in
Table 58
.
Table 58: GlobalSymbolRegistry
Record
Fields
Field Name
Value
Usage
[[Key]]
a String
A string key used to globally identify a Symbol.
[[Symbol]]
a Symbol
A symbol that can be retrieved from any
realm
.
20.4.2.3
Symbol.hasInstance
The initial value of
Symbol.hasInstance
is the well-known symbol
%Symbol.hasInstance%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.4
Symbol.isConcatSpreadable
The initial value of
Symbol.isConcatSpreadable
is the well-known symbol
%Symbol.isConcatSpreadable%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.5
Symbol.iterator
The initial value of
Symbol.iterator
is the well-known symbol
%Symbol.iterator%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.6
Symbol.keyFor (
sym
)
This function performs the following steps when called:
If
sym
is not a Symbol
, throw a
TypeError
exception.
Return
KeyForSymbol
(
sym
).
20.4.2.7
Symbol.match
The initial value of
Symbol.match
is the well-known symbol
%Symbol.match%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.8
Symbol.matchAll
The initial value of
Symbol.matchAll
is the well-known symbol
%Symbol.matchAll%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.9
Symbol.prototype
The initial value of
Symbol.prototype
is the
Symbol prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.10
Symbol.replace
The initial value of
Symbol.replace
is the well-known symbol
%Symbol.replace%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.11
Symbol.search
The initial value of
Symbol.search
is the well-known symbol
%Symbol.search%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.12
Symbol.species
The initial value of
Symbol.species
is the well-known symbol
%Symbol.species%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.13
Symbol.split
The initial value of
Symbol.split
is the well-known symbol
%Symbol.split%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.14
Symbol.toPrimitive
The initial value of
Symbol.toPrimitive
is the well-known symbol
%Symbol.toPrimitive%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.15
Symbol.toStringTag
The initial value of
Symbol.toStringTag
is the well-known symbol
%Symbol.toStringTag%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.2.16
Symbol.unscopables
The initial value of
Symbol.unscopables
is the well-known symbol
%Symbol.unscopables%
(
Table 1
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.4.3
Properties of the Symbol Prototype Object
The
Symbol prototype object
:
is
%Symbol.prototype%
.
is an
ordinary object
.
is not a Symbol
instance and does not have a
[[SymbolData]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
20.4.3.1
Symbol.prototype.constructor
The initial value of
Symbol.prototype.constructor
is
%Symbol%
.
20.4.3.2
get Symbol.prototype.description
Symbol.prototype.description
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
s
be the
this
value.
Let
sym
be ?
ThisSymbolValue
(
s
).
Return
sym
.
[[Description]]
.
20.4.3.3
Symbol.prototype.toString ( )
This method performs the following steps when called:
Let
sym
be ?
ThisSymbolValue
(
this
value).
Return
SymbolDescriptiveString
(
sym
).
20.4.3.3.1
SymbolDescriptiveString (
sym
)
The abstract operation SymbolDescriptiveString takes argument
sym
(a Symbol) and returns a String. It performs the following steps when called:
Let
desc
be
sym
.
[[Description]]
.
If
desc
is
undefined
, set
desc
to the empty String.
Assert
:
desc
is a String
.
Return the
string-concatenation
of
"Symbol("
,
desc
, and
")"
.
20.4.3.4
Symbol.prototype.valueOf ( )
This method performs the following steps when called:
Return ?
ThisSymbolValue
(
this
value).
20.4.3.4.1
ThisSymbolValue (
value
)
The abstract operation ThisSymbolValue takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a Symbol or a
throw completion
. It performs the following steps when called:
If
value
is a Symbol
, return
value
.
If
value
is an Object
and
value
has a
[[SymbolData]]
internal slot, then
Let
s
be
value
.
[[SymbolData]]
.
Assert
:
s
is a Symbol
.
Return
s
.
Throw a
TypeError
exception.
20.4.3.5
Symbol.prototype [ %Symbol.toPrimitive% ] (
hint
)
This method is called by ECMAScript language operators to convert a Symbol object to a primitive value.
It performs the following steps when called:
Return ?
ThisSymbolValue
(
this
value).
Note
The argument is ignored.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
The value of the
"name"
property of this method is
"[Symbol.toPrimitive]"
.
20.4.3.6
Symbol.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Symbol"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
20.4.4
Properties of Symbol Instances
Symbol instances are
ordinary objects
that inherit properties from the
Symbol prototype object
. Symbol instances have a
[[SymbolData]]
internal slot. The
[[SymbolData]]
internal slot is the Symbol value represented by this Symbol object.
20.4.5
Abstract Operations for Symbols
20.4.5.1
KeyForSymbol (
sym
)
The abstract operation KeyForSymbol takes argument
sym
(a Symbol) and returns a String or
undefined
. If
sym
is in the
GlobalSymbolRegistry List
, the String used to register
sym
will be returned. It performs the following steps when called:
For each element
e
of the
GlobalSymbolRegistry List
, do
If
SameValue
(
e
.
[[Symbol]]
,
sym
) is
true
, return
e
.
[[Key]]
.
Assert
: The
GlobalSymbolRegistry List
does not currently contain an entry for
sym
.
Return
undefined
.
20.5
Error Objects
Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.
When an ECMAScript implementation detects a runtime error, it throws a new instance of one of the
NativeError
objects defined in
20.5.5
or a new instance of the AggregateError object defined in
20.5.7
.
20.5.1
The Error Constructor
The Error
constructor
:
is
%Error%
.
is the initial value of the
"Error"
property of the
global object
.
creates and initializes a new Error object when called as a function rather than as a
constructor
. Thus the function call
Error(…)
is equivalent to the object creation expression
new Error(…)
with the same arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Error behaviour must include a
super
call to the Error
constructor
to create and initialize subclass instances with an
[[ErrorData]]
internal slot.
20.5.1.1
Error (
message
[ ,
options
] )
This function performs the following steps when called:
If NewTarget is
undefined
, let
newTarget
be the
active function object
; else let
newTarget
be NewTarget.
Let
O
be ?
OrdinaryCreateFromConstructor
(
newTarget
,
"%Error.prototype%"
, «
[[ErrorData]]
»).
If
message
is not
undefined
, then
Let
msg
be ?
ToString
(
message
).
Perform
CreateNonEnumerableDataPropertyOrThrow
(
O
,
"message"
,
msg
).
Perform ?
InstallErrorCause
(
O
,
options
).
Return
O
.
20.5.2
Properties of the Error Constructor
The Error
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
20.5.2.1
Error.isError (
arg
)
This function performs the following steps when called:
If
arg
is not an Object
, return
false
.
If
arg
does not have an
[[ErrorData]]
internal slot, return
false
.
Return
true
.
20.5.2.2
Error.prototype
The initial value of
Error.prototype
is the
Error prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.5.3
Properties of the Error Prototype Object
The
Error prototype object
:
is
%Error.prototype%
.
is an
ordinary object
.
is not an Error instance and does not have an
[[ErrorData]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
20.5.3.1
Error.prototype.constructor
The initial value of
Error.prototype.constructor
is
%Error%
.
20.5.3.2
Error.prototype.message
The initial value of
Error.prototype.message
is the empty String.
20.5.3.3
Error.prototype.name
The initial value of
Error.prototype.name
is
"Error"
.
20.5.3.4
Error.prototype.toString ( )
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
name
be ?
Get
(
O
,
"name"
).
If
name
is
undefined
, set
name
to
"Error"
; otherwise set
name
to ?
ToString
(
name
).
Let
msg
be ?
Get
(
O
,
"message"
).
If
msg
is
undefined
, set
msg
to the empty String; otherwise set
msg
to ?
ToString
(
msg
).
If
name
is the empty String, return
msg
.
If
msg
is the empty String, return
name
.
Return the
string-concatenation
of
name
, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and
msg
.
20.5.4
Properties of Error Instances
Error instances are
ordinary objects
that inherit properties from the
Error prototype object
and have an
[[ErrorData]]
internal slot whose value is
undefined
. The only specified use of
[[ErrorData]]
is to identify Error, AggregateError, and
NativeError
instances as Error objects within
Object.prototype.toString
and
Error.isError
.
20.5.5
Native Error Types Used in This Standard
A new instance of one of the
NativeError
objects below or of the AggregateError object is thrown when a runtime error is detected. All
NativeError
objects share the same structure, as described in
20.5.6
.
20.5.5.1
EvalError
The EvalError
constructor
is
%EvalError%
.
This exception is not currently used within this specification. This object remains for compatibility with previous editions of this specification.
20.5.5.2
RangeError
The RangeError
constructor
is
%RangeError%
.
Indicates a value that is not in the set or range of allowable values.
20.5.5.3
ReferenceError
The ReferenceError
constructor
is
%ReferenceError%
.
Indicate that an invalid reference has been detected.
20.5.5.4
SyntaxError
The SyntaxError
constructor
is
%SyntaxError%
.
Indicates that a parsing error has occurred.
20.5.5.5
TypeError
The TypeError
constructor
is
%TypeError%
.
TypeError is used to indicate an unsuccessful operation when none of the other
NativeError
objects are an appropriate indication of the failure cause.
20.5.5.6
URIError
The URIError
constructor
is
%URIError%
.
Indicates that one of the global URI handling functions was used in a way that is incompatible with its definition.
20.5.6
NativeError
Object Structure
Each of these objects has the structure described below, differing only in the name used as the
constructor
name and in the
"name"
property of the prototype object.
For each error object, references to
NativeError
in the definition should be replaced with the appropriate error object name from
20.5.5
.
20.5.6.1
The
NativeError
Constructors
Each
NativeError
constructor
:
creates and initializes a new
NativeError
object when called as a function rather than as a
constructor
. A call of the object as a function is equivalent to calling it as a
constructor
with the same arguments. Thus the function call
NativeError
(…)
is equivalent to the object creation expression
new
NativeError
(…)
with the same arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified
NativeError
behaviour must include a
super
call to the
NativeError
constructor
to create and initialize subclass instances with an
[[ErrorData]]
internal slot.
20.5.6.1.1
NativeError
(
message
[ ,
options
] )
Each
NativeError
function performs the following steps when called:
If NewTarget is
undefined
, let
newTarget
be the
active function object
; else let
newTarget
be NewTarget.
Let
O
be ?
OrdinaryCreateFromConstructor
(
newTarget
,
"%
NativeError
.prototype%"
, «
[[ErrorData]]
»).
If
message
is not
undefined
, then
Let
msg
be ?
ToString
(
message
).
Perform
CreateNonEnumerableDataPropertyOrThrow
(
O
,
"message"
,
msg
).
Perform ?
InstallErrorCause
(
O
,
options
).
Return
O
.
The actual value of the string passed in step
2
is either
"%EvalError.prototype%"
,
"%RangeError.prototype%"
,
"%ReferenceError.prototype%"
,
"%SyntaxError.prototype%"
,
"%TypeError.prototype%"
, or
"%URIError.prototype%"
corresponding to which
NativeError
constructor
is being defined.
20.5.6.2
Properties of the
NativeError
Constructors
Each
NativeError
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Error%
.
has a
"name"
property whose value is the String value
"
NativeError
"
.
has the following properties:
20.5.6.2.1
NativeError
.prototype
The initial value of
NativeError
.prototype
is a
NativeError
prototype object (
20.5.6.3
). Each
NativeError
constructor
has a distinct prototype object.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.5.6.3
Properties of the
NativeError
Prototype Objects
Each
NativeError
prototype object
:
is an
ordinary object
.
is not an Error instance and does not have an
[[ErrorData]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%Error.prototype%
.
20.5.6.3.1
NativeError
.prototype.constructor
The initial value of the
"constructor"
property of the prototype for a given
NativeError
constructor
is the
constructor
itself.
20.5.6.3.2
NativeError
.prototype.message
The initial value of the
"message"
property of the prototype for a given
NativeError
constructor
is the empty String.
20.5.6.3.3
NativeError
.prototype.name
The initial value of the
"name"
property of the prototype for a given
NativeError
constructor
is the String value consisting of the name of the
constructor
(the name used instead of
NativeError
).
20.5.6.4
Properties of
NativeError
Instances
NativeError
instances are
ordinary objects
that inherit properties from their
NativeError
prototype object and have an
[[ErrorData]]
internal slot whose value is
undefined
. The only specified use of
[[ErrorData]]
is by
Object.prototype.toString
(
20.1.3.6
) and
Error.isError
(
20.5.2.1
) to identify Error, AggregateError, or
NativeError
instances.
20.5.7
AggregateError Objects
20.5.7.1
The AggregateError Constructor
The AggregateError
constructor
:
is
%AggregateError%
.
is the initial value of the
"AggregateError"
property of the
global object
.
creates and initializes a new AggregateError object when called as a function rather than as a
constructor
. Thus the function call
AggregateError(…)
is equivalent to the object creation expression
new AggregateError(…)
with the same arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified AggregateError behaviour must include a
super
call to the AggregateError
constructor
to create and initialize subclass instances with an
[[ErrorData]]
internal slot.
20.5.7.1.1
AggregateError (
errors
,
message
[ ,
options
] )
This function performs the following steps when called:
If NewTarget is
undefined
, let
newTarget
be the
active function object
; else let
newTarget
be NewTarget.
Let
O
be ?
OrdinaryCreateFromConstructor
(
newTarget
,
"%AggregateError.prototype%"
, «
[[ErrorData]]
»).
If
message
is not
undefined
, then
Let
msg
be ?
ToString
(
message
).
Perform
CreateNonEnumerableDataPropertyOrThrow
(
O
,
"message"
,
msg
).
Perform ?
InstallErrorCause
(
O
,
options
).
Let
errorsList
be ?
IteratorToList
(?
GetIterator
(
errors
,
sync
)).
Perform !
DefinePropertyOrThrow
(
O
,
"errors"
, PropertyDescriptor {
[[Configurable]]
:
true
,
[[Enumerable]]
:
false
,
[[Writable]]
:
true
,
[[Value]]
:
CreateArrayFromList
(
errorsList
) }).
Return
O
.
20.5.7.2
Properties of the AggregateError Constructor
The AggregateError
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Error%
.
has the following properties:
20.5.7.2.1
AggregateError.prototype
The initial value of
AggregateError.prototype
is
%AggregateError.prototype%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
20.5.7.3
Properties of the AggregateError Prototype Object
The
AggregateError prototype object
:
is
%AggregateError.prototype%
.
is an
ordinary object
.
is not an Error instance or an AggregateError instance and does not have an
[[ErrorData]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%Error.prototype%
.
20.5.7.3.1
AggregateError.prototype.constructor
The initial value of
AggregateError.prototype.constructor
is
%AggregateError%
.
20.5.7.3.2
AggregateError.prototype.message
The initial value of
AggregateError.prototype.message
is the empty String.
20.5.7.3.3
AggregateError.prototype.name
The initial value of
AggregateError.prototype.name
is
"AggregateError"
.
20.5.7.4
Properties of AggregateError Instances
AggregateError instances are
ordinary objects
that inherit properties from their
AggregateError prototype object
and have an
[[ErrorData]]
internal slot whose value is
undefined
. The only specified use of
[[ErrorData]]
is by
Object.prototype.toString
(
20.1.3.6
) and
Error.isError
(
20.5.2.1
) to identify Error, AggregateError, or
NativeError
instances.
20.5.8
Abstract Operations for Error Objects
20.5.8.1
InstallErrorCause (
O
,
options
)
The abstract operation InstallErrorCause takes arguments
O
(an Object) and
options
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It is used to create a
"cause"
property on
O
when a
"cause"
property is present on
options
. It performs the following steps when called:
If
options
is an Object
and ?
HasProperty
(
options
,
"cause"
) is
true
, then
Let
cause
be ?
Get
(
options
,
"cause"
).
Perform
CreateNonEnumerableDataPropertyOrThrow
(
O
,
"cause"
,
cause
).
Return
unused
.
21
Numbers and Dates
21.1
Number Objects
21.1.1
The Number Constructor
The Number
constructor
:
is
%Number%
.
is the initial value of the
"Number"
property of the
global object
.
creates and initializes a new Number object when called as a
constructor
.
performs a type conversion when called as a function rather than as a
constructor
.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Number behaviour must include a
super
call to the Number
constructor
to create and initialize the subclass instance with a
[[NumberData]]
internal slot.
21.1.1.1
Number (
value
)
This function performs the following steps when called:
If
value
is present, then
Let
prim
be ?
ToNumeric
(
value
).
If
prim
is a BigInt
, let
n
be
𝔽
(
ℝ
(
prim
)).
Otherwise, let
n
be
prim
.
Else,
Let
n
be
+0
𝔽
.
If NewTarget is
undefined
, return
n
.
Let
O
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Number.prototype%"
, «
[[NumberData]]
»).
Set
O
.
[[NumberData]]
to
n
.
Return
O
.
21.1.2
Properties of the Number Constructor
The Number
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
21.1.2.1
Number.EPSILON
The value of
Number.EPSILON
is the
Number value for
the magnitude of the difference between 1 and the smallest value greater than 1 that is representable as a Number value, which is approximately 2.2204460492503130808472633361816 × 10
-16
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.2
Number.isFinite (
number
)
This function performs the following steps when called:
If
number
is not a Number
, return
false
.
If
number
is not
finite
, return
false
.
Otherwise, return
true
.
21.1.2.3
Number.isInteger (
number
)
This function performs the following steps when called:
If
number
is an
integral Number
, return
true
.
Return
false
.
21.1.2.4
Number.isNaN (
number
)
This function performs the following steps when called:
If
number
is not a Number
, return
false
.
If
number
is
NaN
, return
true
.
Otherwise, return
false
.
Note
This function differs from the global isNaN function (
19.2.3
) in that it does not convert its argument to a Number before determining whether it is
NaN
.
21.1.2.5
Number.isSafeInteger (
number
)
Note
An
integer
n
is a "
safe integer
" if and only if the
Number value for
n
is not the
Number value for
any other
integer
.
This function performs the following steps when called:
If
number
is an
integral Number
, then
If
abs
(
ℝ
(
number
)) ≤ 2
53
- 1, return
true
.
Return
false
.
21.1.2.6
Number.MAX_SAFE_INTEGER
Note
Due to rounding behaviour necessitated by precision limitations of
IEEE 754-2019
, the
Number value for
every
integer
greater than
Number.MAX_SAFE_INTEGER
is shared with at least one other
integer
. Such large-magnitude
integers
are therefore not
safe
, and are not guaranteed to be exactly representable as Number values or even to be distinguishable from each other. For example, both
9007199254740992
and
9007199254740993
evaluate to the Number value
9007199254740992
𝔽
.
The value of
Number.MAX_SAFE_INTEGER
is
9007199254740991
𝔽
(
𝔽
(2
53
- 1)).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.7
Number.MAX_VALUE
The value of
Number.MAX_VALUE
is the largest positive
finite
value of the
Number type
, which is approximately
1.7976931348623157 × 10
308
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.8
Number.MIN_SAFE_INTEGER
Note
Due to rounding behaviour necessitated by precision limitations of
IEEE 754-2019
, the
Number value for
every
integer
less than
Number.MIN_SAFE_INTEGER
is shared with at least one other
integer
. Such large-magnitude
integers
are therefore not
safe
, and are not guaranteed to be exactly representable as Number values or even to be distinguishable from each other. For example, both
-9007199254740992
and
-9007199254740993
evaluate to the Number value
-9007199254740992
𝔽
.
The value of
Number.MIN_SAFE_INTEGER
is
-9007199254740991
𝔽
(
𝔽
(-(2
53
- 1))).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.9
Number.MIN_VALUE
The value of
Number.MIN_VALUE
is the smallest positive value of the
Number type
, which is approximately
5 × 10
-324
.
In the
IEEE 754-2019
double precision binary representation, the smallest possible value is a denormalized number. If an implementation does not support denormalized values, the value of
Number.MIN_VALUE
must be the smallest non-zero positive value that can actually be represented by the implementation.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.10
Number.NaN
The value of
Number.NaN
is
NaN
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.11
Number.NEGATIVE_INFINITY
The value of
Number.NEGATIVE_INFINITY
is
-∞
𝔽
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.12
Number.parseFloat (
string
)
The initial value of the
"parseFloat"
property is
%parseFloat%
.
21.1.2.13
Number.parseInt (
string
,
radix
)
The initial value of the
"parseInt"
property is
%parseInt%
.
21.1.2.14
Number.POSITIVE_INFINITY
The value of
Number.POSITIVE_INFINITY
is
+∞
𝔽
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.2.15
Number.prototype
The initial value of
Number.prototype
is the
Number prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.1.3
Properties of the Number Prototype Object
The
Number prototype object
:
is
%Number.prototype%
.
is an
ordinary object
.
is itself a Number object; it has a
[[NumberData]]
internal slot with the value
+0
𝔽
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
Unless explicitly stated otherwise, the methods of the Number prototype object defined below are not generic and the
this
value passed to them must be either a Number value or an object that has a
[[NumberData]]
internal slot that has been initialized to a Number value.
The phrase “this Number value” within the specification of a method refers to the result returned by calling the abstract operation
ThisNumberValue
with the
this
value of the method invocation passed as the argument.
21.1.3.1
Number.prototype.constructor
The initial value of
Number.prototype.constructor
is
%Number%
.
21.1.3.2
Number.prototype.toExponential (
fractionDigits
)
This method returns a String containing this Number value represented in decimal exponential notation with one digit before the significand's decimal point and
fractionDigits
digits after the significand's decimal point. If
fractionDigits
is
undefined
, it includes as many significand digits as necessary to uniquely specify the Number (just like in
ToString
except that in this case the Number is always output in exponential notation).
It performs the following steps when called:
Let
x
be ?
ThisNumberValue
(
this
value).
Let
f
be ?
ToIntegerOrInfinity
(
fractionDigits
).
Assert
: If
fractionDigits
is
undefined
, then
f
is 0.
If
x
is not
finite
, return
Number::toString
(
x
, 10).
If
f
< 0 or
f
> 100, throw a
RangeError
exception.
Set
x
to
ℝ
(
x
).
Let
s
be the empty String.
If
x
< 0, then
Set
s
to
"-"
.
Set
x
to -
x
.
If
x
= 0, then
Let
m
be the String value consisting of
f
+ 1 occurrences of the code unit 0x0030 (DIGIT ZERO).
Let
e
be 0.
Else,
If
fractionDigits
is not
undefined
, then
Let
e
and
n
be
integers
such that 10
f
≤
n
< 10
f
+ 1
and for which
n
× 10
e
-
f
-
x
is as close to zero as possible. If there are two such sets of
e
and
n
, pick the
e
and
n
for which
n
× 10
e
-
f
is larger.
Else,
Let
e
,
n
, and
ff
be
integers
such that
ff
≥ 0, 10
ff
≤
n
< 10
ff
+ 1
,
𝔽
(
n
× 10
e
-
ff
) is
𝔽
(
x
), and
ff
is as small as possible. Note that the decimal representation of
n
has
ff
+ 1 digits,
n
is not divisible by 10, and the least significant digit of
n
is not necessarily uniquely determined by these criteria.
Set
f
to
ff
.
Let
m
be the String value consisting of the digits of the decimal representation of
n
(in order, with no leading zeroes).
If
f
≠ 0, then
Let
a
be the first code unit of
m
.
Let
b
be the other
f
code units of
m
.
Set
m
to the
string-concatenation
of
a
,
"."
, and
b
.
If
e
= 0, then
Let
c
be
"+"
.
Let
d
be
"0"
.
Else,
If
e
> 0, then
Let
c
be
"+"
.
Else,
Assert
:
e
< 0.
Let
c
be
"-"
.
Set
e
to -
e
.
Let
d
be the String value consisting of the digits of the decimal representation of
e
(in order, with no leading zeroes).
Set
m
to the
string-concatenation
of
m
,
"e"
,
c
, and
d
.
Return the
string-concatenation
of
s
and
m
.
Note
For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step
10.b.i
be used as a guideline:
Let
e
,
n
, and
ff
be
integers
such that
ff
≥ 0, 10
ff
≤
n
< 10
ff
+ 1
,
𝔽
(
n
× 10
e
-
ff
) is
𝔽
(
x
), and
ff
is as small as possible. If there are multiple possibilities for
n
, choose the value of
n
for which
𝔽
(
n
× 10
e
-
ff
) is closest in value to
𝔽
(
x
). If there are two such possible values of
n
, choose the one that is even.
21.1.3.3
Number.prototype.toFixed (
fractionDigits
)
Note 1
This method returns a String containing this Number value represented in decimal fixed-point notation with
fractionDigits
digits after the decimal point. If
fractionDigits
is
undefined
, 0 is assumed.
It performs the following steps when called:
Let
x
be ?
ThisNumberValue
(
this
value).
Let
f
be ?
ToIntegerOrInfinity
(
fractionDigits
).
Assert
: If
fractionDigits
is
undefined
, then
f
is 0.
If
f
is not
finite
, throw a
RangeError
exception.
If
f
< 0 or
f
> 100, throw a
RangeError
exception.
If
x
is not
finite
, return
Number::toString
(
x
, 10).
Set
x
to
ℝ
(
x
).
Let
s
be the empty String.
If
x
< 0, then
Set
s
to
"-"
.
Set
x
to -
x
.
If
x
≥ 10
21
, then
Let
m
be !
ToString
(
𝔽
(
x
)).
Else,
Let
n
be an
integer
for which
n
/ 10
f
-
x
is as close to zero as possible. If there are two such
n
, pick the larger
n
.
If
n
= 0, let
m
be
"0"
; otherwise let
m
be the String value consisting of the digits of the decimal representation of
n
(in order, with no leading zeroes).
If
f
≠ 0, then
Let
k
be the length of
m
.
If
k
≤
f
, then
Let
z
be the String value consisting of
f
+ 1 -
k
occurrences of the code unit 0x0030 (DIGIT ZERO).
Set
m
to the
string-concatenation
of
z
and
m
.
Set
k
to
f
+ 1.
Let
a
be the first
k
-
f
code units of
m
.
Let
b
be the other
f
code units of
m
.
Set
m
to the
string-concatenation
of
a
,
"."
, and
b
.
Return the
string-concatenation
of
s
and
m
.
Note 2
The output of
toFixed
may be more precise than
toString
for some values because toString only prints enough significant digits to distinguish the number from adjacent Number values. For example,
(1000000000000000128).toString()
returns
"1000000000000000100"
, while
(1000000000000000128).toFixed(0)
returns
"1000000000000000128"
.
21.1.3.4
Number.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method produces a String value that represents this Number value formatted according to the conventions of the
host environment
's current locale. This method is
implementation-defined
, and it is permissible, but not encouraged, for it to return the same thing as
toString
.
The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
21.1.3.5
Number.prototype.toPrecision (
precision
)
This method returns a String containing this Number value represented either in decimal exponential notation with one digit before the significand's decimal point and
precision
- 1
digits after the significand's decimal point or in decimal fixed notation with
precision
significant digits. If
precision
is
undefined
, it calls
ToString
instead.
It performs the following steps when called:
Let
x
be ?
ThisNumberValue
(
this
value).
If
precision
is
undefined
, return !
ToString
(
x
).
Let
p
be ?
ToIntegerOrInfinity
(
precision
).
If
x
is not
finite
, return
Number::toString
(
x
, 10).
If
p
< 1 or
p
> 100, throw a
RangeError
exception.
Set
x
to
ℝ
(
x
).
Let
s
be the empty String.
If
x
< 0, then
Set
s
to the code unit 0x002D (HYPHEN-MINUS).
Set
x
to -
x
.
If
x
= 0, then
Let
m
be the String value consisting of
p
occurrences of the code unit 0x0030 (DIGIT ZERO).
Let
e
be 0.
Else,
Let
e
and
n
be
integers
such that 10
p
- 1
≤
n
< 10
p
and for which
n
× 10
e
-
p
+ 1
-
x
is as close to zero as possible. If there are two such sets of
e
and
n
, pick the
e
and
n
for which
n
× 10
e
-
p
+ 1
is larger.
Let
m
be the String value consisting of the digits of the decimal representation of
n
(in order, with no leading zeroes).
If
e
< -6 or
e
≥
p
, then
Assert
:
e
≠ 0.
If
p
≠ 1, then
Let
a
be the first code unit of
m
.
Let
b
be the other
p
- 1 code units of
m
.
Set
m
to the
string-concatenation
of
a
,
"."
, and
b
.
If
e
> 0, then
Let
c
be the code unit 0x002B (PLUS SIGN).
Else,
Assert
:
e
< 0.
Let
c
be the code unit 0x002D (HYPHEN-MINUS).
Set
e
to -
e
.
Let
d
be the String value consisting of the digits of the decimal representation of
e
(in order, with no leading zeroes).
Return the
string-concatenation
of
s
,
m
, the code unit 0x0065 (LATIN SMALL LETTER E),
c
, and
d
.
If
e
=
p
- 1, return the
string-concatenation
of
s
and
m
.
If
e
≥ 0, then
Set
m
to the
string-concatenation
of the first
e
+ 1 code units of
m
, the code unit 0x002E (FULL STOP), and the remaining
p
- (
e
+ 1) code units of
m
.
Else,
Set
m
to the
string-concatenation
of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(
e
+ 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String
m
.
Return the
string-concatenation
of
s
and
m
.
21.1.3.6
Number.prototype.toString ( [
radix
] )
Note
The optional
radix
should be an
integral Number
value in the
inclusive interval
from
2
𝔽
to
36
𝔽
. If
radix
is
undefined
then
10
𝔽
is used as the value of
radix
.
This method performs the following steps when called:
Let
x
be ?
ThisNumberValue
(
this
value).
If
radix
is
undefined
, let
radixMV
be 10.
Else, let
radixMV
be ?
ToIntegerOrInfinity
(
radix
).
If
radixMV
is not in the
inclusive interval
from 2 to 36, throw a
RangeError
exception.
Return
Number::toString
(
x
,
radixMV
).
This method is not generic; it throws a
TypeError
exception if its
this
value
is not a Number
or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method.
The
"length"
property of this method is
1
𝔽
.
21.1.3.7
Number.prototype.valueOf ( )
Return ?
ThisNumberValue
(
this
value).
21.1.3.7.1
ThisNumberValue (
value
)
The abstract operation ThisNumberValue takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a Number or a
throw completion
. It performs the following steps when called:
If
value
is a Number
, return
value
.
If
value
is an Object
and
value
has a
[[NumberData]]
internal slot, then
Let
n
be
value
.
[[NumberData]]
.
Assert
:
n
is a Number
.
Return
n
.
Throw a
TypeError
exception.
21.1.4
Properties of Number Instances
Number instances are
ordinary objects
that inherit properties from the
Number prototype object
. Number instances also have a
[[NumberData]]
internal slot. The
[[NumberData]]
internal slot is the Number value represented by this Number object.
21.2
BigInt Objects
21.2.1
The BigInt Constructor
The BigInt
constructor
:
is
%BigInt%
.
is the initial value of the
"BigInt"
property of the
global object
.
performs a type conversion when called as a function rather than as a
constructor
.
is not intended to be used with the
new
operator or to be subclassed. It may be used as the value of an
extends
clause of a class definition but a
super
call to the BigInt
constructor
will cause an exception.
21.2.1.1
BigInt (
value
)
This function performs the following steps when called:
If NewTarget is not
undefined
, throw a
TypeError
exception.
Let
prim
be ?
ToPrimitive
(
value
,
number
).
If
prim
is a Number
, return ?
NumberToBigInt
(
prim
).
Otherwise, return ?
ToBigInt
(
prim
).
21.2.1.1.1
NumberToBigInt (
number
)
The abstract operation NumberToBigInt takes argument
number
(a Number) and returns either a
normal completion containing
a BigInt or a
throw completion
. It performs the following steps when called:
If
number
is not an
integral Number
, throw a
RangeError
exception.
Return
ℤ
(
ℝ
(
number
)).
21.2.2
Properties of the BigInt Constructor
The BigInt
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
21.2.2.1
BigInt.asIntN (
bits
,
bigint
)
This function performs the following steps when called:
Set
bits
to ?
ToIndex
(
bits
).
Set
bigint
to ?
ToBigInt
(
bigint
).
Let
mod
be
ℝ
(
bigint
)
modulo
2
bits
.
If
mod
≥ 2
bits
- 1
, return
ℤ
(
mod
- 2
bits
); otherwise return
ℤ
(
mod
).
21.2.2.2
BigInt.asUintN (
bits
,
bigint
)
This function performs the following steps when called:
Set
bits
to ?
ToIndex
(
bits
).
Set
bigint
to ?
ToBigInt
(
bigint
).
Return
ℤ
(
ℝ
(
bigint
)
modulo
2
bits
).
21.2.2.3
BigInt.prototype
The initial value of
BigInt.prototype
is the
BigInt prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.2.3
Properties of the BigInt Prototype Object
The
BigInt prototype object
:
is
%BigInt.prototype%
.
is an
ordinary object
.
is not a BigInt
object; it does not have a
[[BigIntData]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
The phrase “this BigInt value” within the specification of a method refers to the result returned by calling the abstract operation
ThisBigIntValue
with the
this
value of the method invocation passed as the argument.
21.2.3.1
BigInt.prototype.constructor
The initial value of
BigInt.prototype.constructor
is
%BigInt%
.
21.2.3.2
BigInt.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method produces a String value that represents this BigInt value formatted according to the conventions of the
host environment
's current locale. This method is
implementation-defined
, and it is permissible, but not encouraged, for it to return the same thing as
toString
.
The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
21.2.3.3
BigInt.prototype.toString ( [
radix
] )
Note
The optional
radix
should be an
integral Number
value in the
inclusive interval
from
2
𝔽
to
36
𝔽
. If
radix
is
undefined
then
10
𝔽
is used as the value of
radix
.
This method performs the following steps when called:
Let
x
be ?
ThisBigIntValue
(
this
value).
If
radix
is
undefined
, let
radixMV
be 10.
Else, let
radixMV
be ?
ToIntegerOrInfinity
(
radix
).
If
radixMV
is not in the
inclusive interval
from 2 to 36, throw a
RangeError
exception.
Return
BigInt::toString
(
x
,
radixMV
).
This method is not generic; it throws a
TypeError
exception if its
this
value
is not a BigInt
or a BigInt object. Therefore, it cannot be transferred to other kinds of objects for use as a method.
21.2.3.4
BigInt.prototype.valueOf ( )
Return ?
ThisBigIntValue
(
this
value).
21.2.3.4.1
ThisBigIntValue (
value
)
The abstract operation ThisBigIntValue takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a BigInt or a
throw completion
. It performs the following steps when called:
If
value
is a BigInt
, return
value
.
If
value
is an Object
and
value
has a
[[BigIntData]]
internal slot, then
Assert
:
value
.
[[BigIntData]]
is a BigInt
.
Return
value
.
[[BigIntData]]
.
Throw a
TypeError
exception.
21.2.3.5
BigInt.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"BigInt"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
21.2.4
Properties of BigInt Instances
BigInt instances are
ordinary objects
that inherit properties from the
BigInt prototype object
. BigInt instances also have a
[[BigIntData]]
internal slot. The
[[BigIntData]]
internal slot is the BigInt value represented by this BigInt object.
21.3
The Math Object
The Math object:
is
%Math%
.
is the initial value of the
"Math"
property of the
global object
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is not a
function object
.
does not have a
[[Construct]]
internal method; it cannot be used as a
constructor
with the
new
operator.
does not have a
[[Call]]
internal method; it cannot be invoked as a function.
Note
In this specification, the phrase “the
Number value for
x
” has a technical meaning defined in
6.1.6.1
.
21.3.1
Value Properties of the Math Object
21.3.1.1
Math.E
The
Number value for
e
, the base of the natural logarithms, which is approximately 2.7182818284590452354.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.3.1.2
Math.LN10
The
Number value for
the natural logarithm of 10, which is approximately 2.302585092994046.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.3.1.3
Math.LN2
The
Number value for
the natural logarithm of 2, which is approximately 0.6931471805599453.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.3.1.4
Math.LOG10E
The
Number value for
the base-10 logarithm of
e
, the base of the natural logarithms; this value is approximately 0.4342944819032518.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
The value of
Math.LOG10E
is approximately the reciprocal of the value of
Math.LN10
.
21.3.1.5
Math.LOG2E
The
Number value for
the base-2 logarithm of
e
, the base of the natural logarithms; this value is approximately 1.4426950408889634.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
The value of
Math.LOG2E
is approximately the reciprocal of the value of
Math.LN2
.
21.3.1.6
Math.PI
The
Number value for
π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.3.1.7
Math.SQRT1_2
The
Number value for
the square root of ½, which is approximately 0.7071067811865476.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
The value of
Math.SQRT1_2
is approximately the reciprocal of the value of
Math.SQRT2
.
21.3.1.8
Math.SQRT2
The
Number value for
the square root of 2, which is approximately 1.4142135623730951.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.3.1.9
Math [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Math"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
21.3.2
Function Properties of the Math Object
Note
The behaviour of the functions
acos
,
acosh
,
asin
,
asinh
,
atan
,
atanh
,
atan2
,
cbrt
,
cos
,
cosh
,
exp
,
expm1
,
hypot
,
log
,
log1p
,
log2
,
log10
,
pow
,
random
,
sin
,
sinh
,
tan
, and
tanh
is not precisely specified here except to require specific results for certain argument values that represent boundary cases of interest. For other argument values, these functions are intended to compute approximations to the results of familiar mathematical functions, but some latitude is allowed in the choice of approximation algorithms. The general intent is that an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is available to C programmers on that platform.
Although the choice of algorithms is left to the implementation, it is recommended (but not specified by this standard) that implementations use the approximation algorithms for
IEEE 754-2019
arithmetic contained in
fdlibm
, the freely distributable mathematical library from Sun Microsystems (
http://www.netlib.org/fdlibm
).
21.3.2.1
Math.abs (
x
)
This function returns the absolute value of
x
; the result has the same magnitude as
x
but has positive sign.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is
NaN
, return
NaN
.
If
n
is
-0
𝔽
, return
+0
𝔽
.
If
n
is
-∞
𝔽
, return
+∞
𝔽
.
If
n
<
-0
𝔽
, return -
n
.
Return
n
.
21.3.2.2
Math.acos (
x
)
This function returns the inverse cosine of
x
. The result is expressed in radians and is in the
inclusive interval
from
+0
𝔽
to
𝔽
(π).
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is
NaN
,
n
>
1
𝔽
, or
n
<
-1
𝔽
, return
NaN
.
If
n
is
1
𝔽
, return
+0
𝔽
.
Return an
implementation-approximated
Number value representing the inverse cosine of
ℝ
(
n
).
21.3.2.3
Math.acosh (
x
)
This function returns the inverse hyperbolic cosine of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is either
NaN
or
+∞
𝔽
, return
n
.
If
n
is
1
𝔽
, return
+0
𝔽
.
If
n
<
1
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing the inverse hyperbolic cosine of
ℝ
(
n
).
21.3.2.4
Math.asin (
x
)
This function returns the inverse sine of
x
. The result is expressed in radians and is in the
inclusive interval
from
𝔽
(-π / 2) to
𝔽
(π / 2).
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return
n
.
If
n
>
1
𝔽
or
n
<
-1
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing the inverse sine of
ℝ
(
n
).
21.3.2.5
Math.asinh (
x
)
This function returns the inverse hyperbolic sine of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
or
n
is either
+0
𝔽
or
-0
𝔽
, return
n
.
Return an
implementation-approximated
Number value representing the inverse hyperbolic sine of
ℝ
(
n
).
21.3.2.6
Math.atan (
x
)
This function returns the inverse tangent of
x
. The result is expressed in radians and is in the
inclusive interval
from
𝔽
(-π / 2) to
𝔽
(π / 2).
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return
n
.
If
n
is
+∞
𝔽
, return an
implementation-approximated
Number value representing π / 2.
If
n
is
-∞
𝔽
, return an
implementation-approximated
Number value representing -π / 2.
Return an
implementation-approximated
Number value representing the inverse tangent of
ℝ
(
n
).
21.3.2.7
Math.atanh (
x
)
This function returns the inverse hyperbolic tangent of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return
n
.
If
n
>
1
𝔽
or
n
<
-1
𝔽
, return
NaN
.
If
n
is
1
𝔽
, return
+∞
𝔽
.
If
n
is
-1
𝔽
, return
-∞
𝔽
.
Return an
implementation-approximated
Number value representing the inverse hyperbolic tangent of
ℝ
(
n
).
21.3.2.8
Math.atan2 (
y
,
x
)
This function returns the inverse tangent of the quotient
y
/
x
of the arguments
y
and
x
, where the signs of
y
and
x
are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument inverse tangent function that the argument named
y
be first and the argument named
x
be second. The result is expressed in radians and is in the
inclusive interval
from -π to +π.
It performs the following steps when called:
Let
ny
be ?
ToNumber
(
y
).
Let
nx
be ?
ToNumber
(
x
).
If
ny
is
NaN
or
nx
is
NaN
, return
NaN
.
If
ny
is
+∞
𝔽
, then
If
nx
is
+∞
𝔽
, return an
implementation-approximated
Number value representing π / 4.
If
nx
is
-∞
𝔽
, return an
implementation-approximated
Number value representing 3π / 4.
Return an
implementation-approximated
Number value representing π / 2.
If
ny
is
-∞
𝔽
, then
If
nx
is
+∞
𝔽
, return an
implementation-approximated
Number value representing -π / 4.
If
nx
is
-∞
𝔽
, return an
implementation-approximated
Number value representing -3π / 4.
Return an
implementation-approximated
Number value representing -π / 2.
If
ny
is
+0
𝔽
, then
If
nx
>
+0
𝔽
or
nx
is
+0
𝔽
, return
+0
𝔽
.
Return an
implementation-approximated
Number value representing π.
If
ny
is
-0
𝔽
, then
If
nx
>
+0
𝔽
or
nx
is
+0
𝔽
, return
-0
𝔽
.
Return an
implementation-approximated
Number value representing -π.
Assert
:
ny
is
finite
and is neither
+0
𝔽
nor
-0
𝔽
.
If
ny
>
+0
𝔽
, then
If
nx
is
+∞
𝔽
, return
+0
𝔽
.
If
nx
is
-∞
𝔽
, return an
implementation-approximated
Number value representing π.
If
nx
is either
+0
𝔽
or
-0
𝔽
, return an
implementation-approximated
Number value representing π / 2.
If
ny
<
-0
𝔽
, then
If
nx
is
+∞
𝔽
, return
-0
𝔽
.
If
nx
is
-∞
𝔽
, return an
implementation-approximated
Number value representing -π.
If
nx
is either
+0
𝔽
or
-0
𝔽
, return an
implementation-approximated
Number value representing -π / 2.
Assert
:
nx
is
finite
and is neither
+0
𝔽
nor
-0
𝔽
.
Let
r
be the inverse tangent of
abs
(
ℝ
(
ny
) /
ℝ
(
nx
)).
If
nx
<
-0
𝔽
, then
If
ny
>
+0
𝔽
, set
r
to π -
r
.
Else, set
r
to -π +
r
.
Else,
If
ny
<
-0
𝔽
, set
r
to -
r
.
Return an
implementation-approximated
Number value representing
r
.
21.3.2.9
Math.cbrt (
x
)
This function returns the cube root of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
or
n
is either
+0
𝔽
or
-0
𝔽
, return
n
.
Return an
implementation-approximated
Number value representing the cube root of
ℝ
(
n
).
21.3.2.10
Math.ceil (
x
)
This function returns the smallest (closest to -∞)
integral Number
value that is not less than
x
. If
x
is already an
integral Number
, the result is
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
or
n
is either
+0
𝔽
or
-0
𝔽
, return
n
.
If
n
<
-0
𝔽
and
n
>
-1
𝔽
, return
-0
𝔽
.
If
n
is an
integral Number
, return
n
.
Return the smallest (closest to -∞)
integral Number
value that is not less than
n
.
Note
The value of
Math.ceil(x)
is the same as the value of
-Math.floor(-x)
.
21.3.2.11
Math.clz32 (
x
)
This function performs the following steps when called:
Let
n
be ?
ToUint32
(
x
).
Let
p
be the number of leading zero bits in the unsigned 32-bit binary representation of
n
.
Return
𝔽
(
p
).
Note
If
n
is either
+0
𝔽
or
-0
𝔽
, this method returns
32
𝔽
. If the most significant bit of the 32-bit binary encoding of
n
is 1, this method returns
+0
𝔽
.
21.3.2.12
Math.cos (
x
)
This function returns the cosine of
x
. The argument is expressed in radians.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
, return
NaN
.
If
n
is either
+0
𝔽
or
-0
𝔽
, return
1
𝔽
.
Return an
implementation-approximated
Number value representing the cosine of
ℝ
(
n
).
21.3.2.13
Math.cosh (
x
)
This function returns the hyperbolic cosine of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is
NaN
, return
NaN
.
If
n
is either
+∞
𝔽
or
-∞
𝔽
, return
+∞
𝔽
.
If
n
is either
+0
𝔽
or
-0
𝔽
, return
1
𝔽
.
Return an
implementation-approximated
Number value representing the hyperbolic cosine of
ℝ
(
n
).
Note
The value of
Math.cosh(x)
is the same as the value of
(Math.exp(x) + Math.exp(-x)) / 2
.
21.3.2.14
Math.exp (
x
)
This function returns the exponential function of
x
(
e
raised to the power of
x
, where
e
is the base of the natural logarithms).
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is either
NaN
or
+∞
𝔽
, return
n
.
If
n
is either
+0
𝔽
or
-0
𝔽
, return
1
𝔽
.
If
n
is
-∞
𝔽
, return
+0
𝔽
.
Return an
implementation-approximated
Number value representing the exponential function of
ℝ
(
n
).
21.3.2.15
Math.expm1 (
x
)
This function returns the result of subtracting 1 from the exponential function of
x
(
e
raised to the power of
x
, where
e
is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of
x
is close to 0.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
,
-0
𝔽
, or
+∞
𝔽
, return
n
.
If
n
is
-∞
𝔽
, return
-1
𝔽
.
Let
exp
be the exponential function of
ℝ
(
n
).
Return an
implementation-approximated
Number value representing
exp
- 1.
21.3.2.16
Math.floor (
x
)
This function returns the greatest (closest to +∞)
integral Number
value that is not greater than
x
. If
x
is already an
integral Number
, the result is
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
or
n
is either
+0
𝔽
or
-0
𝔽
, return
n
.
If
n
<
1
𝔽
and
n
>
+0
𝔽
, return
+0
𝔽
.
If
n
is an
integral Number
, return
n
.
Return the greatest (closest to +∞)
integral Number
value that is not greater than
n
.
Note
The value of
Math.floor(x)
is the same as the value of
-Math.ceil(-x)
.
21.3.2.17
Math.fround (
x
)
This function performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is
NaN
, return
NaN
.
If
n
is one of
+0
𝔽
,
-0
𝔽
,
+∞
𝔽
, or
-∞
𝔽
, return
n
.
Let
n32
be the result of converting
n
to
IEEE 754-2019
binary32 format using roundTiesToEven mode.
Let
n64
be the result of converting
n32
to
IEEE 754-2019
binary64 format.
Return the ECMAScript Number value corresponding to
n64
.
21.3.2.18
Math.f16round (
x
)
This function performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is
NaN
, return
NaN
.
If
n
is one of
+0
𝔽
,
-0
𝔽
,
+∞
𝔽
, or
-∞
𝔽
, return
n
.
Let
n16
be the result of converting
n
to
IEEE 754-2019
binary16 format using roundTiesToEven mode.
Let
n64
be the result of converting
n16
to
IEEE 754-2019
binary64 format.
Return the ECMAScript Number value corresponding to
n64
.
Note
This operation is not the same as casting to binary32 and then to binary16 because of the possibility of double-rounding: consider the number
k
=
1.00048828125000022204
𝔽
, for example, for which Math.f16round(
k
) is
1.0009765625
𝔽
, but Math.f16round(Math.fround(
k
)) is
1
𝔽
.
Not all platforms provide native support for casting from binary64 to binary16. There are various libraries which can provide this, including the MIT-licensed
half
library. Alternatively, it is possible to first cast from binary64 to binary32 under roundTiesToEven and then check whether the result could lead to incorrect double-rounding. Such cases can be handled explicitly by adjusting the mantissa of the binary32 value so that it is the value which would be produced by performing the initial cast under roundTiesToOdd. Casting the adjusted value to binary16 under roundTiesToEven then produces the correct value.
21.3.2.19
Math.hypot ( ...
args
)
Given zero or more arguments, this function returns the square root of the sum of squares of its arguments.
It performs the following steps when called:
Let
coerced
be a new empty
List
.
For each element
arg
of
args
, do
Let
n
be ?
ToNumber
(
arg
).
Append
n
to
coerced
.
For each element
number
of
coerced
, do
If
number
is either
+∞
𝔽
or
-∞
𝔽
, return
+∞
𝔽
.
Let
onlyZero
be
true
.
For each element
number
of
coerced
, do
If
number
is
NaN
, return
NaN
.
If
number
is neither
+0
𝔽
nor
-0
𝔽
, set
onlyZero
to
false
.
If
onlyZero
is
true
, return
+0
𝔽
.
Return an
implementation-approximated
Number value representing the square root of the sum of squares of the
mathematical values
of the elements of
coerced
.
The
"length"
property of this function is
2
𝔽
.
Note
Implementations should take care to avoid the loss of precision from overflows and underflows that are prone to occur in naive implementations when this function is called with two or more arguments.
21.3.2.20
Math.imul (
x
,
y
)
This function performs the following steps when called:
Let
a
be
ℝ
(?
ToUint32
(
x
)).
Let
b
be
ℝ
(?
ToUint32
(
y
)).
Let
product
be (
a
×
b
)
modulo
2
32
.
If
product
≥ 2
31
, return
𝔽
(
product
- 2
32
); otherwise return
𝔽
(
product
).
21.3.2.21
Math.log (
x
)
This function returns the natural logarithm of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is either
NaN
or
+∞
𝔽
, return
n
.
If
n
is
1
𝔽
, return
+0
𝔽
.
If
n
is either
+0
𝔽
or
-0
𝔽
, return
-∞
𝔽
.
If
n
<
-0
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing
ln
(
ℝ
(
n
)).
21.3.2.22
Math.log1p (
x
)
This function returns the natural logarithm of 1 +
x
. The result is computed in a way that is accurate even when the value of x is close to zero.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
,
-0
𝔽
, or
+∞
𝔽
, return
n
.
If
n
is
-1
𝔽
, return
-∞
𝔽
.
If
n
<
-1
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing
ln
(1 +
ℝ
(
n
)).
21.3.2.23
Math.log10 (
x
)
This function returns the base 10 logarithm of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is either
NaN
or
+∞
𝔽
, return
n
.
If
n
is
1
𝔽
, return
+0
𝔽
.
If
n
is either
+0
𝔽
or
-0
𝔽
, return
-∞
𝔽
.
If
n
<
-0
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing
log10
(
ℝ
(
n
)).
21.3.2.24
Math.log2 (
x
)
This function returns the base 2 logarithm of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is either
NaN
or
+∞
𝔽
, return
n
.
If
n
is
1
𝔽
, return
+0
𝔽
.
If
n
is either
+0
𝔽
or
-0
𝔽
, return
-∞
𝔽
.
If
n
<
-0
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing
log2
(
ℝ
(
n
)).
21.3.2.25
Math.max ( ...
args
)
Given zero or more arguments, this function calls
ToNumber
on each of the arguments and returns the largest of the resulting values.
It performs the following steps when called:
Let
coerced
be a new empty
List
.
For each element
arg
of
args
, do
Let
n
be ?
ToNumber
(
arg
).
Append
n
to
coerced
.
Let
highest
be
-∞
𝔽
.
For each element
number
of
coerced
, do
If
number
is
NaN
, return
NaN
.
If
number
is
+0
𝔽
and
highest
is
-0
𝔽
, set
highest
to
+0
𝔽
.
If
number
>
highest
, set
highest
to
number
.
Return
highest
.
Note
The comparison of values to determine the largest value is done using the
IsLessThan
algorithm except that
+0
𝔽
is considered to be larger than
-0
𝔽
.
The
"length"
property of this function is
2
𝔽
.
21.3.2.26
Math.min ( ...
args
)
Given zero or more arguments, this function calls
ToNumber
on each of the arguments and returns the smallest of the resulting values.
It performs the following steps when called:
Let
coerced
be a new empty
List
.
For each element
arg
of
args
, do
Let
n
be ?
ToNumber
(
arg
).
Append
n
to
coerced
.
Let
lowest
be
+∞
𝔽
.
For each element
number
of
coerced
, do
If
number
is
NaN
, return
NaN
.
If
number
is
-0
𝔽
and
lowest
is
+0
𝔽
, set
lowest
to
-0
𝔽
.
If
number
<
lowest
, set
lowest
to
number
.
Return
lowest
.
Note
The comparison of values to determine the largest value is done using the
IsLessThan
algorithm except that
+0
𝔽
is considered to be larger than
-0
𝔽
.
The
"length"
property of this function is
2
𝔽
.
21.3.2.27
Math.pow (
base
,
exponent
)
This function performs the following steps when called:
Set
base
to ?
ToNumber
(
base
).
Set
exponent
to ?
ToNumber
(
exponent
).
Return
Number::exponentiate
(
base
,
exponent
).
21.3.2.28
Math.random ( )
This function returns a Number value with positive sign, greater than or equal to
+0
𝔽
but strictly less than
1
𝔽
, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an
implementation-defined
algorithm or strategy.
Each
Math.random
function created for distinct
realms
must produce a distinct sequence of values from successive calls.
21.3.2.29
Math.round (
x
)
This function returns the Number value that is closest to
x
and is integral. If two
integral Numbers
are equally close to
x
, then the result is the Number value that is closer to +∞. If
x
is already integral, the result is
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
or
n
is an
integral Number
, return
n
.
If
n
<
0.5
𝔽
and
n
>
+0
𝔽
, return
+0
𝔽
.
If
n
<
-0
𝔽
and
n
≥
-0.5
𝔽
, return
-0
𝔽
.
Return the
integral Number
closest to
n
, preferring the Number closer to +∞ in the case of a tie.
Note 1
Math.round(3.5)
returns 4, but
Math.round(-3.5)
returns -3.
Note 2
The value of
Math.round(x)
is not always the same as the value of
Math.floor(x + 0.5)
. When
x
is
-0
𝔽
or
x
is less than
-0
𝔽
but greater than or equal to
-0.5
𝔽
,
Math.round(x)
returns
-0
𝔽
, but
Math.floor(x + 0.5)
returns
+0
𝔽
.
Math.round(x)
may also differ from the value of
Math.floor(x + 0.5)
because of internal rounding when computing
x + 0.5
.
21.3.2.30
Math.sign (
x
)
This function returns the sign of
x
, indicating whether
x
is positive, negative, or zero.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return
n
.
If
n
<
-0
𝔽
, return
-1
𝔽
.
Return
1
𝔽
.
21.3.2.31
Math.sin (
x
)
This function returns the sine of
x
. The argument is expressed in radians.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return
n
.
If
n
is either
+∞
𝔽
or
-∞
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing the sine of
ℝ
(
n
).
21.3.2.32
Math.sinh (
x
)
This function returns the hyperbolic sine of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
or
n
is either
+0
𝔽
or
-0
𝔽
, return
n
.
Return an
implementation-approximated
Number value representing the hyperbolic sine of
ℝ
(
n
).
Note
The value of
Math.sinh(x)
is the same as the value of
(Math.exp(x) - Math.exp(-x)) / 2
.
21.3.2.33
Math.sqrt (
x
)
This function returns the square root of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
,
-0
𝔽
, or
+∞
𝔽
, return
n
.
If
n
<
-0
𝔽
, return
NaN
.
Return
𝔽
(the square root of
ℝ
(
n
)).
21.3.2.34
Math.sumPrecise (
items
)
Given an
iterable
of Numbers, this function sums each value in the
iterable
and returns their sum. If any value
is not a Number
it throws a
TypeError
exception.
It performs the following steps when called:
Perform ?
RequireObjectCoercible
(
items
).
Let
iteratorRecord
be ?
GetIterator
(
items
,
sync
).
Let
state
be
minus-zero
.
Let
sum
be 0.
Let
count
be 0.
Let
next
be
not-started
.
Repeat, while
next
is not
done
,
Set
next
to ?
IteratorStepValue
(
iteratorRecord
).
If
next
is not
done
, then
If
count
≥ 2
53
- 1, then
NOTE: This step is not expected to be reached in practice and is included only so that implementations may rely on inputs being "reasonably sized" without violating this specification.
Let
error
be
ThrowCompletion
(a newly created
RangeError
object).
Return ?
IteratorClose
(
iteratorRecord
,
error
).
If
next
is not a Number
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iteratorRecord
,
error
).
Let
n
be
next
.
If
state
is not
not-a-number
, then
If
n
is
NaN
, then
Set
state
to
not-a-number
.
Else if
n
is
+∞
𝔽
, then
If
state
is
minus-infinity
, set
state
to
not-a-number
.
Else, set
state
to
plus-infinity
.
Else if
n
is
-∞
𝔽
, then
If
state
is
plus-infinity
, set
state
to
not-a-number
.
Else, set
state
to
minus-infinity
.
Else if
n
is not
-0
𝔽
and
state
is either
minus-zero
or
finite
, then
Set
state
to
finite
.
Set
sum
to
sum
+
ℝ
(
n
).
Set
count
to
count
+ 1.
If
state
is
not-a-number
, return
NaN
.
If
state
is
plus-infinity
, return
+∞
𝔽
.
If
state
is
minus-infinity
, return
-∞
𝔽
.
If
state
is
minus-zero
, return
-0
𝔽
.
Return
𝔽
(
sum
).
Note
The value of
sum
can be computed without arbitrary-precision arithmetic by a variety of algorithms. One such is the "Grow-Expansion" algorithm given in
Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates
by Jonathan Richard Shewchuk. A more recent algorithm is given in "
Fast exact summation using small and large superaccumulators
", code for which is available at
https://gitlab.com/radfordneal/xsum
.
21.3.2.35
Math.tan (
x
)
This function returns the tangent of
x
. The argument is expressed in radians.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return
n
.
If
n
is either
+∞
𝔽
or
-∞
𝔽
, return
NaN
.
Return an
implementation-approximated
Number value representing the tangent of
ℝ
(
n
).
21.3.2.36
Math.tanh (
x
)
This function returns the hyperbolic tangent of
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is one of
NaN
,
+0
𝔽
, or
-0
𝔽
, return
n
.
If
n
is
+∞
𝔽
, return
1
𝔽
.
If
n
is
-∞
𝔽
, return
-1
𝔽
.
Return an
implementation-approximated
Number value representing the hyperbolic tangent of
ℝ
(
n
).
Note
The value of
Math.tanh(x)
is the same as the value of
(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))
.
21.3.2.37
Math.trunc (
x
)
This function returns the integral part of the number
x
, removing any fractional digits. If
x
is already integral, the result is
x
.
It performs the following steps when called:
Let
n
be ?
ToNumber
(
x
).
If
n
is not
finite
or
n
is either
+0
𝔽
or
-0
𝔽
, return
n
.
If
n
<
1
𝔽
and
n
>
+0
𝔽
, return
+0
𝔽
.
If
n
<
-0
𝔽
and
n
>
-1
𝔽
, return
-0
𝔽
.
Return the
integral Number
nearest
n
in the direction of
+0
𝔽
.
21.4
Date Objects
21.4.1
Overview of Date Objects and Definitions of Abstract Operations
The following
abstract operations
operate on
time values
(defined in
21.4.1.1
). Note that, in every case, if any argument to one of these functions is
NaN
, the result will be
NaN
.
21.4.1.1
Time Values and Time Range
Time measurement in ECMAScript is analogous to time measurement in POSIX, in particular sharing definition in terms of the proleptic Gregorian calendar, an
epoch
of midnight at the beginning of 1 January 1970 UTC, and an accounting of every day as comprising exactly 86,400 seconds (each of which is 1000 milliseconds long).
An ECMAScript
time value
is a Number
, either a
finite
integral Number
representing an instant in time to millisecond precision or
NaN
representing no specific instant. A time value that is a multiple of
24 × 60 × 60 × 1000 = 86,400,000
(i.e., is 86,400,000 ×
d
for some
integer
d
) represents the instant at the start of the UTC day that follows the
epoch
by
d
whole UTC days (preceding the
epoch
for negative
d
). Every other
finite
time value
t
is defined relative to the greatest preceding time value
s
that is such a multiple, and represents the instant that occurs within the same UTC day as
s
but follows it by (
t
-
s
) milliseconds.
Time values do not account for UTC leap seconds—there are no time values representing instants within positive leap seconds, and there are time values representing instants removed from the UTC timeline by negative leap seconds. However, the definition of time values nonetheless yields piecewise alignment with UTC, with discontinuities only at leap second boundaries and zero difference outside of leap seconds.
A Number can exactly represent all
integers
from -9,007,199,254,740,992 to 9,007,199,254,740,992 (
21.1.2.8
and
21.1.2.6
). A time value supports a slightly smaller range of -8,640,000,000,000,000 to 8,640,000,000,000,000 milliseconds. This yields a supported time value range of exactly -100,000,000 days to 100,000,000 days relative to midnight at the beginning of 1 January 1970 UTC.
The exact moment of midnight at the beginning of 1 January 1970 UTC is represented by the time value
+0
𝔽
.
Note
In the proleptic Gregorian calendar, leap years are precisely those which are both divisible by 4 and either divisible by 400 or not divisible by 100.
The 400 year cycle of the proleptic Gregorian calendar contains 97 leap years. This yields an average of 365.2425 days per year, which is 31,556,952,000 milliseconds. Therefore, the maximum range a Number could represent exactly with millisecond precision is approximately -285,426 to 285,426 years relative to 1970. The smaller range supported by a time value as specified in this section is approximately -273,790 to 273,790 years relative to 1970.
21.4.1.2
Time-related Constants
These constants are referenced by algorithms in the following sections.
HoursPerDay = 24
MinutesPerHour = 60
SecondsPerMinute = 60
msPerSecond =
1000
𝔽
msPerMinute =
60000
𝔽
=
msPerSecond
×
𝔽
(
SecondsPerMinute
)
msPerHour =
3600000
𝔽
=
msPerMinute
×
𝔽
(
MinutesPerHour
)
msPerDay =
86400000
𝔽
=
msPerHour
×
𝔽
(
HoursPerDay
)
21.4.1.3
Day (
t
)
The abstract operation Day takes argument
t
(a
finite
time value
) and returns an
integral Number
. It returns the day number of the day in which
t
falls. It performs the following steps when called:
Return
𝔽
(
floor
(
ℝ
(
t
/
msPerDay
))).
21.4.1.4
TimeWithinDay (
t
)
The abstract operation TimeWithinDay takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
interval
from
+0
𝔽
(inclusive) to
msPerDay
(exclusive). It returns the number of milliseconds since the start of the day in which
t
falls. It performs the following steps when called:
Return
𝔽
(
ℝ
(
t
)
modulo
ℝ
(
msPerDay
)).
21.4.1.5
DaysInYear (
y
)
The abstract operation DaysInYear takes argument
y
(an
integral Number
) and returns
365
𝔽
or
366
𝔽
. It returns the number of days in year
y
. Leap years have 366 days; all other years have 365. It performs the following steps when called:
Let
ry
be
ℝ
(
y
).
If (
ry
modulo
400) = 0, return
366
𝔽
.
If (
ry
modulo
100) = 0, return
365
𝔽
.
If (
ry
modulo
4) = 0, return
366
𝔽
.
Return
365
𝔽
.
21.4.1.6
DayFromYear (
y
)
The abstract operation DayFromYear takes argument
y
(an
integral Number
) and returns an
integral Number
. It returns the day number of the first day of year
y
. It performs the following steps when called:
Let
ry
be
ℝ
(
y
).
NOTE: In the following steps,
numYears1
,
numYears4
,
numYears100
, and
numYears400
represent the number of years divisible by 1, 4, 100, and 400, respectively, that occur between the
epoch
and the start of year
y
. The number is negative if
y
is before the
epoch
.
Let
numYears1
be (
ry
- 1970).
Let
numYears4
be
floor
((
ry
- 1969) / 4).
Let
numYears100
be
floor
((
ry
- 1901) / 100).
Let
numYears400
be
floor
((
ry
- 1601) / 400).
Return
𝔽
(365 ×
numYears1
+
numYears4
-
numYears100
+
numYears400
).
21.4.1.7
TimeFromYear (
y
)
The abstract operation TimeFromYear takes argument
y
(an
integral Number
) and returns a
time value
. It returns the
time value
of the start of year
y
. It performs the following steps when called:
Return
msPerDay
×
DayFromYear
(
y
).
21.4.1.8
YearFromTime (
t
)
The abstract operation YearFromTime takes argument
t
(a
finite
time value
) and returns an
integral Number
. It returns the year in which
t
falls. It performs the following steps when called:
Return the largest
integral Number
y
(closest to +∞) such that
TimeFromYear
(
y
) ≤
t
.
21.4.1.9
DayWithinYear (
t
)
The abstract operation DayWithinYear takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
365
𝔽
. It performs the following steps when called:
Return
Day
(
t
) -
DayFromYear
(
YearFromTime
(
t
)).
21.4.1.10
InLeapYear (
t
)
The abstract operation InLeapYear takes argument
t
(a
finite
time value
) and returns
+0
𝔽
or
1
𝔽
. It returns
1
𝔽
if
t
is within a leap year and
+0
𝔽
otherwise. It performs the following steps when called:
If
DaysInYear
(
YearFromTime
(
t
)) is
366
𝔽
, return
1
𝔽
; else return
+0
𝔽
.
21.4.1.11
MonthFromTime (
t
)
The abstract operation MonthFromTime takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
11
𝔽
. It returns a Number identifying the month in which
t
falls. A month value of
+0
𝔽
specifies January;
1
𝔽
specifies February;
2
𝔽
specifies March;
3
𝔽
specifies April;
4
𝔽
specifies May;
5
𝔽
specifies June;
6
𝔽
specifies July;
7
𝔽
specifies August;
8
𝔽
specifies September;
9
𝔽
specifies October;
10
𝔽
specifies November; and
11
𝔽
specifies December. Note that
MonthFromTime(
+0
𝔽
) =
+0
𝔽
, corresponding to Thursday, 1 January 1970. It performs the following steps when called:
Let
inLeapYear
be
InLeapYear
(
t
).
Let
dayWithinYear
be
DayWithinYear
(
t
).
If
dayWithinYear
<
31
𝔽
, return
+0
𝔽
.
If
dayWithinYear
<
59
𝔽
+
inLeapYear
, return
1
𝔽
.
If
dayWithinYear
<
90
𝔽
+
inLeapYear
, return
2
𝔽
.
If
dayWithinYear
<
120
𝔽
+
inLeapYear
, return
3
𝔽
.
If
dayWithinYear
<
151
𝔽
+
inLeapYear
, return
4
𝔽
.
If
dayWithinYear
<
181
𝔽
+
inLeapYear
, return
5
𝔽
.
If
dayWithinYear
<
212
𝔽
+
inLeapYear
, return
6
𝔽
.
If
dayWithinYear
<
243
𝔽
+
inLeapYear
, return
7
𝔽
.
If
dayWithinYear
<
273
𝔽
+
inLeapYear
, return
8
𝔽
.
If
dayWithinYear
<
304
𝔽
+
inLeapYear
, return
9
𝔽
.
If
dayWithinYear
<
334
𝔽
+
inLeapYear
, return
10
𝔽
.
Assert
:
dayWithinYear
<
365
𝔽
+
inLeapYear
.
Return
11
𝔽
.
21.4.1.12
DateFromTime (
t
)
The abstract operation DateFromTime takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
1
𝔽
to
31
𝔽
. It returns the day of the month in which
t
falls. It performs the following steps when called:
Let
inLeapYear
be
InLeapYear
(
t
).
Let
dayWithinYear
be
DayWithinYear
(
t
).
Let
month
be
MonthFromTime
(
t
).
If
month
is
+0
𝔽
, return
dayWithinYear
+
1
𝔽
.
If
month
is
1
𝔽
, return
dayWithinYear
-
30
𝔽
.
If
month
is
2
𝔽
, return
dayWithinYear
-
58
𝔽
-
inLeapYear
.
If
month
is
3
𝔽
, return
dayWithinYear
-
89
𝔽
-
inLeapYear
.
If
month
is
4
𝔽
, return
dayWithinYear
-
119
𝔽
-
inLeapYear
.
If
month
is
5
𝔽
, return
dayWithinYear
-
150
𝔽
-
inLeapYear
.
If
month
is
6
𝔽
, return
dayWithinYear
-
180
𝔽
-
inLeapYear
.
If
month
is
7
𝔽
, return
dayWithinYear
-
211
𝔽
-
inLeapYear
.
If
month
is
8
𝔽
, return
dayWithinYear
-
242
𝔽
-
inLeapYear
.
If
month
is
9
𝔽
, return
dayWithinYear
-
272
𝔽
-
inLeapYear
.
If
month
is
10
𝔽
, return
dayWithinYear
-
303
𝔽
-
inLeapYear
.
Assert
:
month
is
11
𝔽
.
Return
dayWithinYear
-
333
𝔽
-
inLeapYear
.
21.4.1.13
WeekDay (
t
)
The abstract operation WeekDay takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
6
𝔽
. It returns a Number identifying the day of the week in which
t
falls. A weekday value of
+0
𝔽
specifies Sunday;
1
𝔽
specifies Monday;
2
𝔽
specifies Tuesday;
3
𝔽
specifies Wednesday;
4
𝔽
specifies Thursday;
5
𝔽
specifies Friday; and
6
𝔽
specifies Saturday. Note that
WeekDay(
+0
𝔽
) =
4
𝔽
, corresponding to Thursday, 1 January 1970. It performs the following steps when called:
Return
𝔽
(
ℝ
(
Day
(
t
) +
4
𝔽
)
modulo
7).
21.4.1.14
HourFromTime (
t
)
The abstract operation HourFromTime takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
23
𝔽
. It returns the hour of the day in which
t
falls. It performs the following steps when called:
Return
𝔽
(
floor
(
ℝ
(
t
/
msPerHour
))
modulo
HoursPerDay
).
21.4.1.15
MinFromTime (
t
)
The abstract operation MinFromTime takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
59
𝔽
. It returns the minute of the hour in which
t
falls. It performs the following steps when called:
Return
𝔽
(
floor
(
ℝ
(
t
/
msPerMinute
))
modulo
MinutesPerHour
).
21.4.1.16
SecFromTime (
t
)
The abstract operation SecFromTime takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
59
𝔽
. It returns the second of the minute in which
t
falls. It performs the following steps when called:
Return
𝔽
(
floor
(
ℝ
(
t
/
msPerSecond
))
modulo
SecondsPerMinute
).
21.4.1.17
msFromTime (
t
)
The abstract operation msFromTime takes argument
t
(a
finite
time value
) and returns an
integral Number
in the
inclusive interval
from
+0
𝔽
to
999
𝔽
. It returns the millisecond of the second in which
t
falls. It performs the following steps when called:
Return
𝔽
(
ℝ
(
t
)
modulo
ℝ
(
msPerSecond
)).
21.4.1.18
GetUTCEpochNanoseconds (
year
,
month
,
day
,
hour
,
minute
,
second
,
millisecond
,
microsecond
,
nanosecond
)
The abstract operation GetUTCEpochNanoseconds takes arguments
year
(an
integer
),
month
(an
integer
in the
inclusive interval
from 1 to 12),
day
(an
integer
in the
inclusive interval
from 1 to 31),
hour
(an
integer
in the
inclusive interval
from 0 to 23),
minute
(an
integer
in the
inclusive interval
from 0 to 59),
second
(an
integer
in the
inclusive interval
from 0 to 59),
millisecond
(an
integer
in the
inclusive interval
from 0 to 999),
microsecond
(an
integer
in the
inclusive interval
from 0 to 999), and
nanosecond
(an
integer
in the
inclusive interval
from 0 to 999) and returns a BigInt. The returned value represents a number of nanoseconds since the
epoch
that corresponds to the given ISO 8601 calendar date and wall-clock time in UTC. It performs the following steps when called:
Let
date
be
MakeDay
(
𝔽
(
year
),
𝔽
(
month
- 1),
𝔽
(
day
)).
Let
time
be
MakeTime
(
𝔽
(
hour
),
𝔽
(
minute
),
𝔽
(
second
),
𝔽
(
millisecond
)).
Let
ms
be
MakeDate
(
date
,
time
).
Assert
:
ms
is an
integral Number
.
Return
ℤ
(
ℝ
(
ms
) × 10
6
+
microsecond
× 10
3
+
nanosecond
).
21.4.1.19
Time Zone Identifiers
Time zones in ECMAScript are represented by
time zone identifiers
, which are Strings composed entirely of code units in the
inclusive interval
from 0x0000 to 0x007F. Time zones supported by an ECMAScript implementation may be
available named time zones
, represented by the
[[Identifier]]
field of the
Time Zone Identifier Records
returned by
AvailableNamedTimeZoneIdentifiers
, or
offset time zones
, represented by Strings for which
IsTimeZoneOffsetString
returns
true
.
A
primary time zone identifier
is the preferred identifier for an available named time zone. A
non-primary time zone identifier
is an identifier for an available named time zone that is not a primary time zone identifier. An
available named time zone identifier
is either a primary time zone identifier or a non-primary time zone identifier. Each available named time zone identifier is associated with exactly one available named time zone. Each available named time zone is associated with exactly one primary time zone identifier and zero or more non-primary time zone identifiers.
ECMAScript implementations must support an available named time zone with the identifier
"UTC"
, which must be the primary time zone identifier for the UTC time zone. In addition, implementations may support any number of other available named time zones.
Implementations that follow the requirements for time zones as described in the ECMA-402 Internationalization API specification are called
time zone aware
. Time zone aware implementations must support available named time zones corresponding to the Zone and
Link
names of the IANA Time Zone Database, and only such names. In time zone aware implementations, a primary time zone identifier is a Zone name, and a non-primary time zone identifier is a
Link
name, respectively, in the IANA Time Zone Database except as specifically overridden by
AvailableNamedTimeZoneIdentifiers
as specified in the ECMA-402 specification. Implementations that do not support the entire IANA Time Zone Database are still recommended to use IANA Time Zone Database names as identifiers to represent time zones.
21.4.1.20
GetNamedTimeZoneEpochNanoseconds (
timeZoneIdentifier
,
year
,
month
,
day
,
hour
,
minute
,
second
,
millisecond
,
microsecond
,
nanosecond
)
The
implementation-defined
abstract operation GetNamedTimeZoneEpochNanoseconds takes arguments
timeZoneIdentifier
(a String),
year
(an
integer
),
month
(an
integer
in the
inclusive interval
from 1 to 12),
day
(an
integer
in the
inclusive interval
from 1 to 31),
hour
(an
integer
in the
inclusive interval
from 0 to 23),
minute
(an
integer
in the
inclusive interval
from 0 to 59),
second
(an
integer
in the
inclusive interval
from 0 to 59),
millisecond
(an
integer
in the
inclusive interval
from 0 to 999),
microsecond
(an
integer
in the
inclusive interval
from 0 to 999), and
nanosecond
(an
integer
in the
inclusive interval
from 0 to 999) and returns a
List
of BigInts. Each value in the returned
List
represents a number of nanoseconds since the
epoch
that corresponds to the given ISO 8601 calendar date and wall-clock time in the named time zone identified by
timeZoneIdentifier
.
When the input represents a local time occurring more than once because of a negative time zone transition (e.g. when daylight saving time ends or the time zone offset is decreased due to a time zone rule change), the returned
List
will have more than one element and will be sorted by ascending numerical value. When the input represents a local time skipped because of a positive time zone transition (e.g. when daylight saving time begins or the time zone offset is increased due to a time zone rule change), the returned
List
will be empty. Otherwise, the returned
List
will have one element.
The default implementation of GetNamedTimeZoneEpochNanoseconds, to be used for ECMAScript implementations that do not include local political rules for any time zones, performs the following steps when called:
Assert
:
timeZoneIdentifier
is
"UTC"
.
Let
epochNanoseconds
be
GetUTCEpochNanoseconds
(
year
,
month
,
day
,
hour
,
minute
,
second
,
millisecond
,
microsecond
,
nanosecond
).
Return «
epochNanoseconds
».
Note
It is required for
time zone aware
implementations (and recommended for all others) to use the time zone information of the IANA Time Zone Database
https://www.iana.org/time-zones/
.
1:30 AM on 5 November 2017 in America/New_York is repeated twice, so GetNamedTimeZoneEpochNanoseconds(
"America/New_York"
, 2017, 11, 5, 1, 30, 0, 0, 0, 0) would return a
List
of length 2 in which the first element represents 05:30 UTC (corresponding with 01:30 US Eastern Daylight Time at UTC offset -04:00) and the second element represents 06:30 UTC (corresponding with 01:30 US Eastern Standard Time at UTC offset -05:00).
2:30 AM on 12 March 2017 in America/New_York does not exist, so GetNamedTimeZoneEpochNanoseconds(
"America/New_York"
, 2017, 3, 12, 2, 30, 0, 0, 0, 0) would return an empty
List
.
21.4.1.21
GetNamedTimeZoneOffsetNanoseconds (
timeZoneIdentifier
,
epochNanoseconds
)
The
implementation-defined
abstract operation GetNamedTimeZoneOffsetNanoseconds takes arguments
timeZoneIdentifier
(a String) and
epochNanoseconds
(a BigInt) and returns an
integer
.
The returned
integer
represents the offset from UTC of the named time zone identified by
timeZoneIdentifier
, at the instant corresponding with
epochNanoseconds
relative to the
epoch
, both in nanoseconds.
The default implementation of GetNamedTimeZoneOffsetNanoseconds, to be used for ECMAScript implementations that do not include local political rules for any time zones, performs the following steps when called:
Assert
:
timeZoneIdentifier
is
"UTC"
.
Return 0.
Note
Time zone offset values may be positive or negative.
21.4.1.22
Time Zone Identifier Record
A
Time Zone Identifier Record
is a
Record
used to describe an
available named time zone identifier
and its corresponding
primary time zone identifier
.
Time Zone Identifier Records have the fields listed in
Table 59
.
Table 59:
Time Zone Identifier Record
Fields
Field Name
Value
Meaning
[[Identifier]]
a String
An
available named time zone identifier
that is supported by the implementation.
[[PrimaryIdentifier]]
a String
The
primary time zone identifier
that
[[Identifier]]
resolves to.
Note
If
[[Identifier]]
is a
primary time zone identifier
, then
[[Identifier]]
is
[[PrimaryIdentifier]]
.
21.4.1.23
AvailableNamedTimeZoneIdentifiers ( )
The
implementation-defined
abstract operation AvailableNamedTimeZoneIdentifiers takes no arguments and returns a
List
of
Time Zone Identifier Records
. Its result describes all
available named time zone identifiers
in this implementation, as well as the
primary time zone identifier
corresponding to each
available named time zone identifier
. The
List
is ordered according to the
[[Identifier]]
field of each
Time Zone Identifier Record
.
Time zone aware
implementations, including all implementations that implement the ECMA-402 Internationalization API, must implement the AvailableNamedTimeZoneIdentifiers abstract operation as specified in the ECMA-402 specification. For implementations that are not
time zone aware
, AvailableNamedTimeZoneIdentifiers performs the following steps when called:
If the implementation does not include local political rules for any time zones, then
Return « the
Time Zone Identifier Record
{
[[Identifier]]
:
"UTC"
,
[[PrimaryIdentifier]]
:
"UTC"
} ».
Let
identifiers
be the
List
of unique
available named time zone identifiers
, sorted according to
lexicographic code unit order
.
Let
result
be a new empty
List
.
For each element
identifier
of
identifiers
, do
Let
primary
be
identifier
.
If
identifier
is a
non-primary time zone identifier
in this implementation and
identifier
is not
"UTC"
, then
Set
primary
to the
primary time zone identifier
associated with
identifier
.
NOTE: An implementation may need to resolve
identifier
iteratively to obtain the
primary time zone identifier
.
Let
record
be the
Time Zone Identifier Record
{
[[Identifier]]
:
identifier
,
[[PrimaryIdentifier]]
:
primary
}.
Append
record
to
result
.
Assert
:
result
contains a
Time Zone Identifier Record
r
such that
r
.
[[Identifier]]
is
"UTC"
and
r
.
[[PrimaryIdentifier]]
is
"UTC"
.
Return
result
.
21.4.1.24
SystemTimeZoneIdentifier ( )
The
implementation-defined
abstract operation SystemTimeZoneIdentifier takes no arguments and returns a String. It returns a String representing the
host environment
's current time zone, which is either a String representing a UTC offset for which
IsTimeZoneOffsetString
returns
true
, or a
primary time zone identifier
. It performs the following steps when called:
If the implementation only supports the UTC time zone, return
"UTC"
.
Let
systemTimeZoneString
be the String representing the
host environment
's current time zone, either a
primary time zone identifier
or an
offset time zone
identifier.
Return
systemTimeZoneString
.
Note
To ensure the level of functionality that implementations commonly provide in the methods of the Date object, it is recommended that SystemTimeZoneIdentifier return an IANA time zone name corresponding to the
host environment
's time zone setting, if such a thing exists.
GetNamedTimeZoneEpochNanoseconds
and
GetNamedTimeZoneOffsetNanoseconds
must reflect the local political rules for standard time and daylight saving time in that time zone, if such rules exist.
For example, if the
host environment
is a browser on a system where the user has chosen US Eastern Time as their time zone, SystemTimeZoneIdentifier returns
"America/New_York"
.
21.4.1.25
LocalTime (
t
)
The abstract operation LocalTime takes argument
t
(a
finite
time value
) and returns an
integral Number
. It converts
t
from UTC to local time. The local political rules for standard time and daylight saving time in effect at
t
should be used to determine the result in the way specified in this section. It performs the following steps when called:
Let
systemTimeZoneIdentifier
be
SystemTimeZoneIdentifier
().
If
IsTimeZoneOffsetString
(
systemTimeZoneIdentifier
) is
true
, then
Let
offsetNs
be
ParseTimeZoneOffsetString
(
systemTimeZoneIdentifier
).
Else,
Let
offsetNs
be
GetNamedTimeZoneOffsetNanoseconds
(
systemTimeZoneIdentifier
,
ℤ
(
ℝ
(
t
) × 10
6
)).
Let
offsetMs
be
truncate
(
offsetNs
/ 10
6
).
Return
t
+
𝔽
(
offsetMs
).
Note 1
If political rules for the local time
t
are not available within the implementation, the result is
t
because
SystemTimeZoneIdentifier
returns
"UTC"
and
GetNamedTimeZoneOffsetNanoseconds
returns 0.
Note 2
It is required for
time zone aware
implementations (and recommended for all others) to use the time zone information of the IANA Time Zone Database
https://www.iana.org/time-zones/
.
Note 3
Two different input
time values
t
UTC
are converted to the same local time
t
local
at a negative time zone transition when there are repeated times (e.g. the daylight saving time ends or the time zone adjustment is decreased.).
LocalTime(
UTC
(
t
local
))
is not necessarily always equal to
t
local
. Correspondingly,
UTC
(LocalTime(
t
UTC
))
is not necessarily always equal to
t
UTC
.
21.4.1.26
UTC (
t
)
The abstract operation UTC takes argument
t
(a Number) and returns a
time value
. It converts
t
from local time to a UTC
time value
. The local political rules for standard time and daylight saving time in effect at
t
should be used to determine the result in the way specified in this section. It performs the following steps when called:
If
t
is not
finite
, return
NaN
.
Let
systemTimeZoneIdentifier
be
SystemTimeZoneIdentifier
().
If
IsTimeZoneOffsetString
(
systemTimeZoneIdentifier
) is
true
, then
Let
offsetNs
be
ParseTimeZoneOffsetString
(
systemTimeZoneIdentifier
).
Else,
Let
possibleInstants
be
GetNamedTimeZoneEpochNanoseconds
(
systemTimeZoneIdentifier
,
ℝ
(
YearFromTime
(
t
)),
ℝ
(
MonthFromTime
(
t
)) + 1,
ℝ
(
DateFromTime
(
t
)),
ℝ
(
HourFromTime
(
t
)),
ℝ
(
MinFromTime
(
t
)),
ℝ
(
SecFromTime
(
t
)),
ℝ
(
msFromTime
(
t
)), 0, 0).
NOTE: The following steps ensure that when
t
represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone offset is decreased due to a time zone rule change) or skipped local time at a positive time zone transition (e.g. when the daylight saving time starts or the time zone offset is increased due to a time zone rule change),
t
is interpreted using the time zone offset before the transition.
If
possibleInstants
is not empty, then
Let
disambiguatedInstant
be
possibleInstants
[0].
Else,
NOTE:
t
represents a local time skipped at a positive time zone transition (e.g. due to daylight saving time starting or a time zone rule change increasing the UTC offset).
Let
possibleInstantsBefore
be
GetNamedTimeZoneEpochNanoseconds
(
systemTimeZoneIdentifier
,
ℝ
(
YearFromTime
(
tBefore
)),
ℝ
(
MonthFromTime
(
tBefore
)) + 1,
ℝ
(
DateFromTime
(
tBefore
)),
ℝ
(
HourFromTime
(
tBefore
)),
ℝ
(
MinFromTime
(
tBefore
)),
ℝ
(
SecFromTime
(
tBefore
)),
ℝ
(
msFromTime
(
tBefore
)), 0, 0), where
tBefore
is the largest
integral Number
<
t
for which
possibleInstantsBefore
is not empty (i.e.,
tBefore
represents the last local time before the transition).
Let
disambiguatedInstant
be the last element of
possibleInstantsBefore
.
Let
offsetNs
be
GetNamedTimeZoneOffsetNanoseconds
(
systemTimeZoneIdentifier
,
disambiguatedInstant
).
Let
offsetMs
be
truncate
(
offsetNs
/ 10
6
).
Return
t
-
𝔽
(
offsetMs
).
Input
t
is nominally a
time value
but may be any Number value. The algorithm must not limit
t
to the
time value
range, so that inputs corresponding with a boundary of the
time value
range can be supported regardless of local UTC offset. For example, the maximum
time value
is 8.64 × 10
15
, corresponding with
"+275760-09-13T00:00:00Z"
. In an environment where the local time zone offset is ahead of UTC by 1 hour at that instant, it is represented by the larger input of 8.64 × 10
15
+ 3.6 × 10
6
, corresponding with
"+275760-09-13T01:00:00+01:00"
.
If political rules for the local time
t
are not available within the implementation, the result is
t
because
SystemTimeZoneIdentifier
returns
"UTC"
and
GetNamedTimeZoneOffsetNanoseconds
returns 0.
Note 1
It is required for
time zone aware
implementations (and recommended for all others) to use the time zone information of the IANA Time Zone Database
https://www.iana.org/time-zones/
.
1:30 AM on 5 November 2017 in America/New_York is repeated twice (fall backward), but it must be interpreted as 1:30 AM UTC-04 instead of 1:30 AM UTC-05. In UTC(
TimeClip
(
MakeDate
(
MakeDay
(2017, 10, 5),
MakeTime
(1, 30, 0, 0)))), the value of
offsetMs
is
-4 ×
msPerHour
.
2:30 AM on 12 March 2017 in America/New_York does not exist, but it must be interpreted as 2:30 AM UTC-05 (equivalent to 3:30 AM UTC-04). In UTC(
TimeClip
(
MakeDate
(
MakeDay
(2017, 2, 12),
MakeTime
(2, 30, 0, 0)))), the value of
offsetMs
is
-5 ×
msPerHour
.
Note 2
UTC(
LocalTime
(
t
UTC
))
is not necessarily always equal to
t
UTC
. Correspondingly,
LocalTime
(UTC(
t
local
))
is not necessarily always equal to
t
local
.
21.4.1.27
MakeTime (
hour
,
min
,
sec
,
ms
)
The abstract operation MakeTime takes arguments
hour
(a Number),
min
(a Number),
sec
(a Number), and
ms
(a Number) and returns a Number. It calculates a number of milliseconds. It performs the following steps when called:
If
hour
is not
finite
,
min
is not
finite
,
sec
is not
finite
, or
ms
is not
finite
, return
NaN
.
Let
h
be
𝔽
(!
ToIntegerOrInfinity
(
hour
)).
Let
m
be
𝔽
(!
ToIntegerOrInfinity
(
min
)).
Let
s
be
𝔽
(!
ToIntegerOrInfinity
(
sec
)).
Let
milli
be
𝔽
(!
ToIntegerOrInfinity
(
ms
)).
Return ((
h
×
msPerHour
+
m
×
msPerMinute
) +
s
×
msPerSecond
) +
milli
.
Note
The arithmetic in MakeTime is floating-point arithmetic, which is not associative, so the operations must be performed in the correct order.
21.4.1.28
MakeDay (
year
,
month
,
date
)
The abstract operation MakeDay takes arguments
year
(a Number),
month
(a Number), and
date
(a Number) and returns a Number. It calculates a number of days. It performs the following steps when called:
If
year
is not
finite
,
month
is not
finite
, or
date
is not
finite
, return
NaN
.
Let
y
be
𝔽
(!
ToIntegerOrInfinity
(
year
)).
Let
m
be
𝔽
(!
ToIntegerOrInfinity
(
month
)).
Let
dt
be
𝔽
(!
ToIntegerOrInfinity
(
date
)).
Let
ym
be
y
+
𝔽
(
floor
(
ℝ
(
m
) / 12)).
If
ym
is not
finite
, return
NaN
.
Let
mn
be
𝔽
(
ℝ
(
m
)
modulo
12).
Find a
finite
time value
t
such that
YearFromTime
(
t
) is
ym
,
MonthFromTime
(
t
) is
mn
, and
DateFromTime
(
t
) is
1
𝔽
; but if this is not possible (because some argument is out of range), return
NaN
.
Return
Day
(
t
) +
dt
-
1
𝔽
.
21.4.1.29
MakeDate (
day
,
time
)
The abstract operation MakeDate takes arguments
day
(a Number) and
time
(a Number) and returns a Number. It calculates a number of milliseconds. It performs the following steps when called:
If
day
is not
finite
or
time
is not
finite
, return
NaN
.
Let
tv
be
day
×
msPerDay
+
time
.
If
tv
is not
finite
, return
NaN
.
Return
tv
.
21.4.1.30
MakeFullYear (
year
)
The abstract operation MakeFullYear takes argument
year
(a Number) and returns an
integral Number
or
NaN
. It returns the full year associated with the
integer
part of
year
, interpreting any value in the
inclusive interval
from 0 to 99 as a count of years since the start of 1900. For alignment with the proleptic Gregorian calendar, "full year" is defined as the signed count of complete years since the start of year 0 (1 B.C.). It performs the following steps when called:
If
year
is
NaN
, return
NaN
.
Let
truncated
be !
ToIntegerOrInfinity
(
year
).
If
truncated
is in the
inclusive interval
from 0 to 99, return
1900
𝔽
+
𝔽
(
truncated
).
Return
𝔽
(
truncated
).
21.4.1.31
TimeClip (
time
)
The abstract operation TimeClip takes argument
time
(a Number) and returns a Number. It calculates a number of milliseconds. It performs the following steps when called:
If
time
is not
finite
, return
NaN
.
If
abs
(
ℝ
(
time
)) > 8.64 × 10
15
, return
NaN
.
Return
𝔽
(!
ToIntegerOrInfinity
(
time
)).
21.4.1.32
Date Time String Format
ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 calendar date extended format. The format is as follows:
YYYY-MM-DDTHH:mm:ss.sssZ
Where the elements are as follows:
YYYY
is the year in the proleptic Gregorian calendar as four decimal digits from 0000 to 9999, or as an
expanded year
of
"+"
or
"-"
followed by six decimal digits.
-
"-"
(hyphen) appears literally twice in the string.
MM
is the month of the year as two decimal digits from 01 (January) to 12 (December).
DD
is the day of the month as two decimal digits from 01 to 31.
T
"T"
appears literally in the string, to indicate the beginning of the time element.
HH
is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.
:
":"
(colon) appears literally twice in the string.
mm
is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.
ss
is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.
.
"."
(dot) appears literally in the string.
sss
is the number of complete milliseconds since the start of the second as three decimal digits.
Z
is the UTC offset representation specified as
"Z"
(for UTC with no offset) or as either
"+"
or
"-"
followed by a time expression
HH:mm
(a subset of the
time zone offset string format
for indicating local time ahead of or behind UTC, respectively)
This format includes date-only forms:
YYYY YYYY-MM YYYY-MM-DD
It also includes “date-time” forms that consist of one of the above date-only forms immediately followed by one of the following time forms with an optional UTC offset representation appended:
THH:mm THH:mm:ss THH:mm:ss.sss
A string containing out-of-bounds or nonconforming elements is not a valid instance of this format.
Note 1
As every day both starts and ends with midnight, the two notations
00:00
and
24:00
are available to distinguish the two midnights that can be associated with one date. This means that the following two notations refer to exactly the same point in time:
1995-02-04T24:00
and
1995-02-05T00:00
. This interpretation of the latter form as "end of a calendar day" is consistent with ISO 8601, even though that specification reserves it for describing time intervals and does not permit it within representations of single points in time.
Note 2
There exists no international standard that specifies abbreviations for civil time zones like CET, EST, etc. and sometimes the same abbreviation is even used for two very different time zones. For this reason, both ISO 8601 and this format specify numeric representations of time zone offsets.
21.4.1.32.1
Expanded Years
Covering the full
time value
range of approximately 273,790 years forward or backward from 1 January 1970 (
21.4.1.1
) requires representing years before 0 or after 9999. ISO 8601 permits expansion of the year representation, but only by mutual agreement of the partners in information interchange. In the simplified ECMAScript format, such an expanded year representation shall have 6 digits and is always prefixed with a + or - sign. The year 0 is considered positive and must be prefixed with a + sign. The representation of the year 0 as -000000 is invalid. Strings matching the
Date Time String Format
with expanded years representing instants in time outside the range of a
time value
are treated as unrecognizable by
Date.parse
and cause that function to return
NaN
without falling back to implementation-specific behaviour or heuristics.
Note
Examples of date-
time values
with expanded years:
-271821-04-20T00:00:00Z
271822 B.C.
-000001-01-01T00:00:00Z
2 B.C.
+000000-01-01T00:00:00Z
1 B.C.
+000001-01-01T00:00:00Z
1 A.D.
+001970-01-01T00:00:00Z
1970 A.D.
+002009-12-15T00:00:00Z
2009 A.D.
+275760-09-13T00:00:00Z
275760 A.D.
21.4.1.33
Time Zone Offset String Format
ECMAScript defines a string interchange format for UTC offsets, derived from ISO 8601. The format is described by the following grammar.
Syntax
UTCOffset
:::
ASCIISign
Hour
ASCIISign
Hour
HourSubcomponents
[+Extended]
ASCIISign
Hour
HourSubcomponents
[~Extended]
ASCIISign
:::
one of
+
-
Hour
:::
0
DecimalDigit
1
DecimalDigit
20
21
22
23
HourSubcomponents
[Extended]
:::
TimeSeparator
[?Extended]
MinuteSecond
TimeSeparator
[?Extended]
MinuteSecond
TimeSeparator
[?Extended]
MinuteSecond
TemporalDecimalFraction
opt
TimeSeparator
[Extended]
:::
[+Extended]
:
[~Extended]
[empty]
MinuteSecond
:::
0
DecimalDigit
1
DecimalDigit
2
DecimalDigit
3
DecimalDigit
4
DecimalDigit
5
DecimalDigit
TemporalDecimalFraction
:::
TemporalDecimalSeparator
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
:::
one of
.
,
21.4.1.33.1
IsTimeZoneOffsetString (
offsetString
)
The abstract operation IsTimeZoneOffsetString takes argument
offsetString
(a String) and returns a Boolean. The return value indicates whether
offsetString
conforms to the grammar given by
UTCOffset
. It performs the following steps when called:
Let
parseResult
be
ParseText
(
offsetString
,
UTCOffset
).
If
parseResult
is a
List
of errors, return
false
.
Return
true
.
21.4.1.33.2
ParseTimeZoneOffsetString (
offsetString
)
The abstract operation ParseTimeZoneOffsetString takes argument
offsetString
(a String) and returns an
integer
. The return value is the UTC offset, as a number of nanoseconds, that corresponds to the String
offsetString
. It performs the following steps when called:
Let
parseResult
be
ParseText
(
offsetString
,
UTCOffset
).
Assert
:
parseResult
is not a
List
of errors.
Assert
:
parseResult
contains a
ASCIISign
Parse Node
.
Let
parsedSign
be the
source text matched by
the
ASCIISign
Parse Node
contained within
parseResult
.
If
parsedSign
is the single code point U+002D (HYPHEN-MINUS), then
Let
sign
be -1.
Else,
Let
sign
be 1.
NOTE: Applications of
StringToNumber
below do not lose precision, since each of the parsed values is guaranteed to be a sufficiently short string of decimal digits.
Assert
:
parseResult
contains an
Hour
Parse Node
.
Let
parsedHours
be the
source text matched by
the
Hour
Parse Node
contained within
parseResult
.
Let
hours
be
ℝ
(
StringToNumber
(
CodePointsToString
(
parsedHours
))).
If
parseResult
does not contain a
MinuteSecond
Parse Node
, then
Let
minutes
be 0.
Else,
Let
parsedMinutes
be the
source text matched by
the first
MinuteSecond
Parse Node
contained within
parseResult
.
Let
minutes
be
ℝ
(
StringToNumber
(
CodePointsToString
(
parsedMinutes
))).
If
parseResult
does not contain two
MinuteSecond
Parse Nodes
, then
Let
seconds
be 0.
Else,
Let
parsedSeconds
be the
source text matched by
the second
MinuteSecond
Parse Node
contained within
parseResult
.
Let
seconds
be
ℝ
(
StringToNumber
(
CodePointsToString
(
parsedSeconds
))).
If
parseResult
does not contain a
TemporalDecimalFraction
Parse Node
, then
Let
nanoseconds
be 0.
Else,
Let
parsedFraction
be the
source text matched by
the
TemporalDecimalFraction
Parse Node
contained within
parseResult
.
Let
fraction
be the
string-concatenation
of
CodePointsToString
(
parsedFraction
) and
"000000000"
.
Let
nanosecondsString
be the
substring
of
fraction
from 1 to 10.
Let
nanoseconds
be
ℝ
(
StringToNumber
(
nanosecondsString
)).
Return
sign
× (((
hours
× 60 +
minutes
) × 60 +
seconds
) × 10
9
+
nanoseconds
).
21.4.2
The Date Constructor
The Date
constructor
:
is
%Date%
.
is the initial value of the
"Date"
property of the
global object
.
creates and initializes a new Date when called as a
constructor
.
returns a String representing the current time (UTC) when called as a function rather than as a
constructor
.
is a function whose behaviour differs based upon the number and types of its arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Date behaviour must include a
super
call to the Date
constructor
to create and initialize the subclass instance with a
[[DateValue]]
internal slot.
21.4.2.1
Date ( ...
values
)
This function performs the following steps when called:
If NewTarget is
undefined
, then
Let
now
be the
time value
(UTC) identifying the current time.
Return
ToDateString
(
now
).
Let
numberOfArgs
be the number of elements in
values
.
If
numberOfArgs
= 0, then
Let
dv
be the
time value
(UTC) identifying the current time.
Else if
numberOfArgs
= 1, then
Let
value
be
values
[0].
If
value
is an Object
and
value
has a
[[DateValue]]
internal slot, then
Let
tv
be
value
.
[[DateValue]]
.
Else,
Let
v
be ?
ToPrimitive
(
value
).
If
v
is a String
, then
Assert
: The next step never returns an
abrupt completion
because
v
is a String
.
Let
tv
be the result of parsing
v
as a date, in exactly the same manner as for the
parse
method (
21.4.3.2
).
Else,
Let
tv
be ?
ToNumber
(
v
).
Let
dv
be
TimeClip
(
tv
).
Else,
Assert
:
numberOfArgs
≥ 2.
Let
y
be ?
ToNumber
(
values
[0]).
Let
m
be ?
ToNumber
(
values
[1]).
If
numberOfArgs
> 2, let
dt
be ?
ToNumber
(
values
[2]); else let
dt
be
1
𝔽
.
If
numberOfArgs
> 3, let
h
be ?
ToNumber
(
values
[3]); else let
h
be
+0
𝔽
.
If
numberOfArgs
> 4, let
min
be ?
ToNumber
(
values
[4]); else let
min
be
+0
𝔽
.
If
numberOfArgs
> 5, let
s
be ?
ToNumber
(
values
[5]); else let
s
be
+0
𝔽
.
If
numberOfArgs
> 6, let
milli
be ?
ToNumber
(
values
[6]); else let
milli
be
+0
𝔽
.
Let
yr
be
MakeFullYear
(
y
).
Let
finalDate
be
MakeDate
(
MakeDay
(
yr
,
m
,
dt
),
MakeTime
(
h
,
min
,
s
,
milli
)).
Let
dv
be
TimeClip
(
UTC
(
finalDate
)).
Let
O
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Date.prototype%"
, «
[[DateValue]]
»).
Set
O
.
[[DateValue]]
to
dv
.
Return
O
.
21.4.3
Properties of the Date Constructor
The Date
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has a
"length"
property whose value is
7
𝔽
.
has the following properties:
21.4.3.1
Date.now ( )
This function returns the
time value
designating the UTC date and time of the occurrence of the call to it.
21.4.3.2
Date.parse (
string
)
This function applies the
ToString
operator to its argument. If
ToString
results in an
abrupt completion
the
Completion Record
is immediately returned. Otherwise, this function interprets the resulting String as a date and time; it returns a Number, the UTC
time value
corresponding to the date and time. The String may be interpreted as a local time, a UTC time, or a time in some other time zone, depending on the contents of the String. The function first attempts to parse the String according to the format described in Date Time String Format (
21.4.1.32
), including expanded years. If the String does not conform to that format the function may fall back to any implementation-specific heuristics or implementation-specific date formats. Strings that are unrecognizable or contain out-of-bounds format element values shall cause this function to return
NaN
.
If the String conforms to the
Date Time String Format
, substitute values take the place of absent format elements. When the
MM
or
DD
elements are absent,
"01"
is used. When the
HH
,
mm
, or
ss
elements are absent,
"00"
is used. When the
sss
element is absent,
"000"
is used. When the UTC offset representation is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time.
If
x
is any Date whose milliseconds amount is zero within a particular implementation of ECMAScript, then all of the following expressions should produce the same numeric value in that implementation, if all the properties referenced have their initial values:
x.
valueOf
()
Date
.
parse
(x.
toString
())
Date
.
parse
(x.
toUTCString
())
Date
.
parse
(x.
toISOString
())
However, the expression
Date
.
parse
(x.
toLocaleString
())
is not required to produce the same Number value as the preceding three expressions and, in general, the value produced by this function is
implementation-defined
when given any String value that does not conform to the Date Time String Format (
21.4.1.32
) and that could not be produced in that implementation by the
toString
or
toUTCString
method.
21.4.3.3
Date.prototype
The initial value of
Date.prototype
is the
Date prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
21.4.3.4
Date.UTC (
year
[ ,
month
[ ,
date
[ ,
hours
[ ,
minutes
[ ,
seconds
[ ,
ms
] ] ] ] ] ] )
This function performs the following steps when called:
Let
y
be ?
ToNumber
(
year
).
If
month
is present, let
m
be ?
ToNumber
(
month
); else let
m
be
+0
𝔽
.
If
date
is present, let
dt
be ?
ToNumber
(
date
); else let
dt
be
1
𝔽
.
If
hours
is present, let
h
be ?
ToNumber
(
hours
); else let
h
be
+0
𝔽
.
If
minutes
is present, let
min
be ?
ToNumber
(
minutes
); else let
min
be
+0
𝔽
.
If
seconds
is present, let
s
be ?
ToNumber
(
seconds
); else let
s
be
+0
𝔽
.
If
ms
is present, let
milli
be ?
ToNumber
(
ms
); else let
milli
be
+0
𝔽
.
Let
yr
be
MakeFullYear
(
y
).
Return
TimeClip
(
MakeDate
(
MakeDay
(
yr
,
m
,
dt
),
MakeTime
(
h
,
min
,
s
,
milli
))).
The
"length"
property of this function is
7
𝔽
.
Note
This function differs from the Date
constructor
in two ways: it returns a
time value
as a Number, rather than creating a Date, and it interprets the arguments in UTC rather than as local time.
21.4.4
Properties of the Date Prototype Object
The
Date prototype object
:
is
%Date.prototype%
.
is itself an
ordinary object
.
is not a Date instance and does not have a
[[DateValue]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
Unless explicitly defined otherwise, the methods of the Date prototype object defined below are not generic and the
this
value passed to them must be an object that has a
[[DateValue]]
internal slot that has been initialized to a
time value
.
21.4.4.1
Date.prototype.constructor
The initial value of
Date.prototype.constructor
is
%Date%
.
21.4.4.2
Date.prototype.getDate ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
DateFromTime
(
LocalTime
(
t
)).
21.4.4.3
Date.prototype.getDay ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
WeekDay
(
LocalTime
(
t
)).
21.4.4.4
Date.prototype.getFullYear ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
YearFromTime
(
LocalTime
(
t
)).
21.4.4.5
Date.prototype.getHours ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
HourFromTime
(
LocalTime
(
t
)).
21.4.4.6
Date.prototype.getMilliseconds ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
msFromTime
(
LocalTime
(
t
)).
21.4.4.7
Date.prototype.getMinutes ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
MinFromTime
(
LocalTime
(
t
)).
21.4.4.8
Date.prototype.getMonth ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
MonthFromTime
(
LocalTime
(
t
)).
21.4.4.9
Date.prototype.getSeconds ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
SecFromTime
(
LocalTime
(
t
)).
21.4.4.10
Date.prototype.getTime ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Return
dateObject
.
[[DateValue]]
.
21.4.4.11
Date.prototype.getTimezoneOffset ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return (
t
-
LocalTime
(
t
)) /
msPerMinute
.
21.4.4.12
Date.prototype.getUTCDate ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
DateFromTime
(
t
).
21.4.4.13
Date.prototype.getUTCDay ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
WeekDay
(
t
).
21.4.4.14
Date.prototype.getUTCFullYear ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
YearFromTime
(
t
).
21.4.4.15
Date.prototype.getUTCHours ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
HourFromTime
(
t
).
21.4.4.16
Date.prototype.getUTCMilliseconds ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
msFromTime
(
t
).
21.4.4.17
Date.prototype.getUTCMinutes ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
MinFromTime
(
t
).
21.4.4.18
Date.prototype.getUTCMonth ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
MonthFromTime
(
t
).
21.4.4.19
Date.prototype.getUTCSeconds ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
SecFromTime
(
t
).
21.4.4.20
Date.prototype.setDate (
date
)
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
dt
be ?
ToNumber
(
date
).
If
t
is
NaN
, return
NaN
.
Set
t
to
LocalTime
(
t
).
Let
newDate
be
MakeDate
(
MakeDay
(
YearFromTime
(
t
),
MonthFromTime
(
t
),
dt
),
TimeWithinDay
(
t
)).
Let
u
be
TimeClip
(
UTC
(
newDate
)).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
21.4.4.21
Date.prototype.setFullYear (
year
[ ,
month
[ ,
date
] ] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
y
be ?
ToNumber
(
year
).
If
t
is
NaN
, set
t
to
+0
𝔽
; otherwise set
t
to
LocalTime
(
t
).
If
month
is not present, let
m
be
MonthFromTime
(
t
); otherwise let
m
be ?
ToNumber
(
month
).
If
date
is not present, let
dt
be
DateFromTime
(
t
); otherwise let
dt
be ?
ToNumber
(
date
).
Let
newDate
be
MakeDate
(
MakeDay
(
y
,
m
,
dt
),
TimeWithinDay
(
t
)).
Let
u
be
TimeClip
(
UTC
(
newDate
)).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
The
"length"
property of this method is
3
𝔽
.
Note
If
month
is not present, this method behaves as if
month
was present with the value
getMonth()
. If
date
is not present, it behaves as if
date
was present with the value
getDate()
.
21.4.4.22
Date.prototype.setHours (
hour
[ ,
min
[ ,
sec
[ ,
ms
] ] ] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
h
be ?
ToNumber
(
hour
).
If
min
is present, let
m
be ?
ToNumber
(
min
).
If
sec
is present, let
s
be ?
ToNumber
(
sec
).
If
ms
is present, let
milli
be ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
Set
t
to
LocalTime
(
t
).
If
min
is not present, let
m
be
MinFromTime
(
t
).
If
sec
is not present, let
s
be
SecFromTime
(
t
).
If
ms
is not present, let
milli
be
msFromTime
(
t
).
Let
date
be
MakeDate
(
Day
(
t
),
MakeTime
(
h
,
m
,
s
,
milli
)).
Let
u
be
TimeClip
(
UTC
(
date
)).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
The
"length"
property of this method is
4
𝔽
.
Note
If
min
is not present, this method behaves as if
min
was present with the value
getMinutes()
. If
sec
is not present, it behaves as if
sec
was present with the value
getSeconds()
. If
ms
is not present, it behaves as if
ms
was present with the value
getMilliseconds()
.
21.4.4.23
Date.prototype.setMilliseconds (
ms
)
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Set
ms
to ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
Set
t
to
LocalTime
(
t
).
Let
time
be
MakeTime
(
HourFromTime
(
t
),
MinFromTime
(
t
),
SecFromTime
(
t
),
ms
).
Let
u
be
TimeClip
(
UTC
(
MakeDate
(
Day
(
t
),
time
))).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
21.4.4.24
Date.prototype.setMinutes (
min
[ ,
sec
[ ,
ms
] ] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
m
be ?
ToNumber
(
min
).
If
sec
is present, let
s
be ?
ToNumber
(
sec
).
If
ms
is present, let
milli
be ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
Set
t
to
LocalTime
(
t
).
If
sec
is not present, let
s
be
SecFromTime
(
t
).
If
ms
is not present, let
milli
be
msFromTime
(
t
).
Let
date
be
MakeDate
(
Day
(
t
),
MakeTime
(
HourFromTime
(
t
),
m
,
s
,
milli
)).
Let
u
be
TimeClip
(
UTC
(
date
)).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
The
"length"
property of this method is
3
𝔽
.
Note
If
sec
is not present, this method behaves as if
sec
was present with the value
getSeconds()
. If
ms
is not present, this behaves as if
ms
was present with the value
getMilliseconds()
.
21.4.4.25
Date.prototype.setMonth (
month
[ ,
date
] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
m
be ?
ToNumber
(
month
).
If
date
is present, let
dt
be ?
ToNumber
(
date
).
If
t
is
NaN
, return
NaN
.
Set
t
to
LocalTime
(
t
).
If
date
is not present, let
dt
be
DateFromTime
(
t
).
Let
newDate
be
MakeDate
(
MakeDay
(
YearFromTime
(
t
),
m
,
dt
),
TimeWithinDay
(
t
)).
Let
u
be
TimeClip
(
UTC
(
newDate
)).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
The
"length"
property of this method is
2
𝔽
.
Note
If
date
is not present, this method behaves as if
date
was present with the value
getDate()
.
21.4.4.26
Date.prototype.setSeconds (
sec
[ ,
ms
] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
s
be ?
ToNumber
(
sec
).
If
ms
is present, let
milli
be ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
Set
t
to
LocalTime
(
t
).
If
ms
is not present, let
milli
be
msFromTime
(
t
).
Let
date
be
MakeDate
(
Day
(
t
),
MakeTime
(
HourFromTime
(
t
),
MinFromTime
(
t
),
s
,
milli
)).
Let
u
be
TimeClip
(
UTC
(
date
)).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
The
"length"
property of this method is
2
𝔽
.
Note
If
ms
is not present, this method behaves as if
ms
was present with the value
getMilliseconds()
.
21.4.4.27
Date.prototype.setTime (
time
)
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be ?
ToNumber
(
time
).
Let
v
be
TimeClip
(
t
).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
21.4.4.28
Date.prototype.setUTCDate (
date
)
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
dt
be ?
ToNumber
(
date
).
If
t
is
NaN
, return
NaN
.
Let
newDate
be
MakeDate
(
MakeDay
(
YearFromTime
(
t
),
MonthFromTime
(
t
),
dt
),
TimeWithinDay
(
t
)).
Let
v
be
TimeClip
(
newDate
).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
21.4.4.29
Date.prototype.setUTCFullYear (
year
[ ,
month
[ ,
date
] ] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, set
t
to
+0
𝔽
.
Let
y
be ?
ToNumber
(
year
).
If
month
is not present, let
m
be
MonthFromTime
(
t
); otherwise let
m
be ?
ToNumber
(
month
).
If
date
is not present, let
dt
be
DateFromTime
(
t
); otherwise let
dt
be ?
ToNumber
(
date
).
Let
newDate
be
MakeDate
(
MakeDay
(
y
,
m
,
dt
),
TimeWithinDay
(
t
)).
Let
v
be
TimeClip
(
newDate
).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
The
"length"
property of this method is
3
𝔽
.
Note
If
month
is not present, this method behaves as if
month
was present with the value
getUTCMonth()
. If
date
is not present, it behaves as if
date
was present with the value
getUTCDate()
.
21.4.4.30
Date.prototype.setUTCHours (
hour
[ ,
min
[ ,
sec
[ ,
ms
] ] ] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
h
be ?
ToNumber
(
hour
).
If
min
is present, let
m
be ?
ToNumber
(
min
).
If
sec
is present, let
s
be ?
ToNumber
(
sec
).
If
ms
is present, let
milli
be ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
If
min
is not present, let
m
be
MinFromTime
(
t
).
If
sec
is not present, let
s
be
SecFromTime
(
t
).
If
ms
is not present, let
milli
be
msFromTime
(
t
).
Let
date
be
MakeDate
(
Day
(
t
),
MakeTime
(
h
,
m
,
s
,
milli
)).
Let
v
be
TimeClip
(
date
).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
The
"length"
property of this method is
4
𝔽
.
Note
If
min
is not present, this method behaves as if
min
was present with the value
getUTCMinutes()
. If
sec
is not present, it behaves as if
sec
was present with the value
getUTCSeconds()
. If
ms
is not present, it behaves as if
ms
was present with the value
getUTCMilliseconds()
.
21.4.4.31
Date.prototype.setUTCMilliseconds (
ms
)
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Set
ms
to ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
Let
time
be
MakeTime
(
HourFromTime
(
t
),
MinFromTime
(
t
),
SecFromTime
(
t
),
ms
).
Let
v
be
TimeClip
(
MakeDate
(
Day
(
t
),
time
)).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
21.4.4.32
Date.prototype.setUTCMinutes (
min
[ ,
sec
[ ,
ms
] ] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
m
be ?
ToNumber
(
min
).
If
sec
is present, let
s
be ?
ToNumber
(
sec
).
If
ms
is present, let
milli
be ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
If
sec
is not present, let
s
be
SecFromTime
(
t
).
If
ms
is not present, let
milli
be
msFromTime
(
t
).
Let
date
be
MakeDate
(
Day
(
t
),
MakeTime
(
HourFromTime
(
t
),
m
,
s
,
milli
)).
Let
v
be
TimeClip
(
date
).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
The
"length"
property of this method is
3
𝔽
.
Note
If
sec
is not present, this method behaves as if
sec
was present with the value
getUTCSeconds()
. If
ms
is not present, it behaves as if
ms
was present with the value return by
getUTCMilliseconds()
.
21.4.4.33
Date.prototype.setUTCMonth (
month
[ ,
date
] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
m
be ?
ToNumber
(
month
).
If
date
is present, let
dt
be ?
ToNumber
(
date
).
If
t
is
NaN
, return
NaN
.
If
date
is not present, let
dt
be
DateFromTime
(
t
).
Let
newDate
be
MakeDate
(
MakeDay
(
YearFromTime
(
t
),
m
,
dt
),
TimeWithinDay
(
t
)).
Let
v
be
TimeClip
(
newDate
).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
The
"length"
property of this method is
2
𝔽
.
Note
If
date
is not present, this method behaves as if
date
was present with the value
getUTCDate()
.
21.4.4.34
Date.prototype.setUTCSeconds (
sec
[ ,
ms
] )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
s
be ?
ToNumber
(
sec
).
If
ms
is present, let
milli
be ?
ToNumber
(
ms
).
If
t
is
NaN
, return
NaN
.
If
ms
is not present, let
milli
be
msFromTime
(
t
).
Let
date
be
MakeDate
(
Day
(
t
),
MakeTime
(
HourFromTime
(
t
),
MinFromTime
(
t
),
s
,
milli
)).
Let
v
be
TimeClip
(
date
).
Set
dateObject
.
[[DateValue]]
to
v
.
Return
v
.
The
"length"
property of this method is
2
𝔽
.
Note
If
ms
is not present, this method behaves as if
ms
was present with the value
getUTCMilliseconds()
.
21.4.4.35
Date.prototype.toDateString ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
tv
be
dateObject
.
[[DateValue]]
.
If
tv
is
NaN
, return
"Invalid Date"
.
Let
t
be
LocalTime
(
tv
).
Return
DateString
(
t
).
21.4.4.36
Date.prototype.toISOString ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
tv
be
dateObject
.
[[DateValue]]
.
If
tv
is
NaN
, throw a
RangeError
exception.
Assert
:
tv
is an
integral Number
.
If
tv
corresponds with a year that cannot be represented in the
Date Time String Format
, throw a
RangeError
exception.
Return a String representation of
tv
in the
Date Time String Format
on the UTC time scale, including all format elements and the UTC offset representation
"Z"
.
21.4.4.37
Date.prototype.toJSON (
key
)
This method provides a String representation of a Date for use by
JSON.stringify
(
25.5.2
).
It performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
tv
be ?
ToPrimitive
(
O
,
number
).
If
tv
is a Number
and
tv
is not
finite
, return
null
.
Return ?
Invoke
(
O
,
"toISOString"
).
Note 1
The argument is ignored.
Note 2
This method is intentionally generic; it does not require that its
this
value be a Date. Therefore, it can be transferred to other kinds of objects for use as a method. However, it does require that any such object have a
toISOString
method.
21.4.4.38
Date.prototype.toLocaleDateString ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method returns a String value. The contents of the String are
implementation-defined
, but are intended to represent the “date” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the
host environment
's current locale.
The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
21.4.4.39
Date.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method returns a String value. The contents of the String are
implementation-defined
, but are intended to represent the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the
host environment
's current locale.
The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
21.4.4.40
Date.prototype.toLocaleTimeString ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method returns a String value. The contents of the String are
implementation-defined
, but are intended to represent the “time” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the
host environment
's current locale.
The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
21.4.4.41
Date.prototype.toString ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
tv
be
dateObject
.
[[DateValue]]
.
Return
ToDateString
(
tv
).
Note 1
For any Date
d
such that
d.
[[DateValue]]
is evenly divisible by 1000, the result of
Date.parse(d.toString())
=
d.valueOf()
. See
21.4.3.2
.
Note 2
This method is not generic; it throws a
TypeError
exception if its
this
value is not a Date. Therefore, it cannot be transferred to other kinds of objects for use as a method.
21.4.4.41.1
TimeString (
tv
)
The abstract operation TimeString takes argument
tv
(a Number, but not
NaN
) and returns a String. It performs the following steps when called:
Let
hour
be
ToZeroPaddedDecimalString
(
ℝ
(
HourFromTime
(
tv
)), 2).
Let
minute
be
ToZeroPaddedDecimalString
(
ℝ
(
MinFromTime
(
tv
)), 2).
Let
second
be
ToZeroPaddedDecimalString
(
ℝ
(
SecFromTime
(
tv
)), 2).
Return the
string-concatenation
of
hour
,
":"
,
minute
,
":"
,
second
, the code unit 0x0020 (SPACE), and
"GMT"
.
21.4.4.41.2
DateString (
tv
)
The abstract operation DateString takes argument
tv
(a Number, but not
NaN
) and returns a String. It performs the following steps when called:
Let
weekday
be the Name of the entry in
Table 60
with the Number
WeekDay
(
tv
).
Let
month
be the Name of the entry in
Table 61
with the Number
MonthFromTime
(
tv
).
Let
day
be
ToZeroPaddedDecimalString
(
ℝ
(
DateFromTime
(
tv
)), 2).
Let
yv
be
YearFromTime
(
tv
).
If
yv
is
+0
𝔽
or
yv
>
+0
𝔽
, let
yearSign
be the empty String; otherwise let
yearSign
be
"-"
.
Let
paddedYear
be
ToZeroPaddedDecimalString
(
abs
(
ℝ
(
yv
)), 4).
Return the
string-concatenation
of
weekday
, the code unit 0x0020 (SPACE),
month
, the code unit 0x0020 (SPACE),
day
, the code unit 0x0020 (SPACE),
yearSign
, and
paddedYear
.
Table 60: Names of days of the week
Number
Name
+0
𝔽
"Sun"
1
𝔽
"Mon"
2
𝔽
"Tue"
3
𝔽
"Wed"
4
𝔽
"Thu"
5
𝔽
"Fri"
6
𝔽
"Sat"
Table 61: Names of months of the year
Number
Name
+0
𝔽
"Jan"
1
𝔽
"Feb"
2
𝔽
"Mar"
3
𝔽
"Apr"
4
𝔽
"May"
5
𝔽
"Jun"
6
𝔽
"Jul"
7
𝔽
"Aug"
8
𝔽
"Sep"
9
𝔽
"Oct"
10
𝔽
"Nov"
11
𝔽
"Dec"
21.4.4.41.3
TimeZoneString (
tv
)
The abstract operation TimeZoneString takes argument
tv
(an
integral Number
) and returns a String. It performs the following steps when called:
Let
systemTimeZoneIdentifier
be
SystemTimeZoneIdentifier
().
If
IsTimeZoneOffsetString
(
systemTimeZoneIdentifier
) is
true
, then
Let
offsetNs
be
ParseTimeZoneOffsetString
(
systemTimeZoneIdentifier
).
Else,
Let
offsetNs
be
GetNamedTimeZoneOffsetNanoseconds
(
systemTimeZoneIdentifier
,
ℤ
(
ℝ
(
tv
) × 10
6
)).
Let
offset
be
𝔽
(
truncate
(
offsetNs
/ 10
6
)).
If
offset
is
+0
𝔽
or
offset
>
+0
𝔽
, then
Let
offsetSign
be
"+"
.
Let
absOffset
be
offset
.
Else,
Let
offsetSign
be
"-"
.
Let
absOffset
be -
offset
.
Let
offsetMin
be
ToZeroPaddedDecimalString
(
ℝ
(
MinFromTime
(
absOffset
)), 2).
Let
offsetHour
be
ToZeroPaddedDecimalString
(
ℝ
(
HourFromTime
(
absOffset
)), 2).
Let
tzName
be an
implementation-defined
string that is either the empty String or the
string-concatenation
of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an
implementation-defined
timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
Return the
string-concatenation
of
offsetSign
,
offsetHour
,
offsetMin
, and
tzName
.
21.4.4.41.4
ToDateString (
tv
)
The abstract operation ToDateString takes argument
tv
(an
integral Number
or
NaN
) and returns a String. It performs the following steps when called:
If
tv
is
NaN
, return
"Invalid Date"
.
Let
t
be
LocalTime
(
tv
).
Return the
string-concatenation
of
DateString
(
t
), the code unit 0x0020 (SPACE),
TimeString
(
t
), and
TimeZoneString
(
tv
).
21.4.4.42
Date.prototype.toTimeString ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
tv
be
dateObject
.
[[DateValue]]
.
If
tv
is
NaN
, return
"Invalid Date"
.
Let
t
be
LocalTime
(
tv
).
Return the
string-concatenation
of
TimeString
(
t
) and
TimeZoneString
(
tv
).
21.4.4.43
Date.prototype.toUTCString ( )
This method returns a String value representing the instant in time corresponding to the
this
value. The format of the String is based upon "HTTP-date" from RFC 7231, generalized to support the full range of times supported by ECMAScript Dates.
It performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
tv
be
dateObject
.
[[DateValue]]
.
If
tv
is
NaN
, return
"Invalid Date"
.
Let
weekday
be the Name of the entry in
Table 60
with the Number
WeekDay
(
tv
).
Let
month
be the Name of the entry in
Table 61
with the Number
MonthFromTime
(
tv
).
Let
day
be
ToZeroPaddedDecimalString
(
ℝ
(
DateFromTime
(
tv
)), 2).
Let
yv
be
YearFromTime
(
tv
).
If
yv
is
+0
𝔽
or
yv
>
+0
𝔽
, let
yearSign
be the empty String; otherwise let
yearSign
be
"-"
.
Let
paddedYear
be
ToZeroPaddedDecimalString
(
abs
(
ℝ
(
yv
)), 4).
Return the
string-concatenation
of
weekday
,
","
, the code unit 0x0020 (SPACE),
day
, the code unit 0x0020 (SPACE),
month
, the code unit 0x0020 (SPACE),
yearSign
,
paddedYear
, the code unit 0x0020 (SPACE), and
TimeString
(
tv
).
21.4.4.44
Date.prototype.valueOf ( )
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Return
dateObject
.
[[DateValue]]
.
21.4.4.45
Date.prototype [ %Symbol.toPrimitive% ] (
hint
)
This method is called by ECMAScript language operators to convert a Date to a primitive value. The allowed values for
hint
are
"default"
,
"number"
, and
"string"
. Dates are unique among built-in ECMAScript object in that they treat
"default"
as being equivalent to
"string"
, All other built-in ECMAScript objects treat
"default"
as being equivalent to
"number"
.
It performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
If
hint
is either
"string"
or
"default"
, then
Let
tryFirst
be
string
.
Else if
hint
is
"number"
, then
Let
tryFirst
be
number
.
Else,
Throw a
TypeError
exception.
Return ?
OrdinaryToPrimitive
(
O
,
tryFirst
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
The value of the
"name"
property of this method is
"[Symbol.toPrimitive]"
.
21.4.5
Properties of Date Instances
Date instances are
ordinary objects
that inherit properties from the
Date prototype object
. Date instances also have a
[[DateValue]]
internal slot. The
[[DateValue]]
internal slot is the
time value
represented by this Date.
22
Text Processing
22.1
String Objects
22.1.1
The String Constructor
The String
constructor
:
is
%String%
.
is the initial value of the
"String"
property of the
global object
.
creates and initializes a new String object when called as a
constructor
.
performs a type conversion when called as a function rather than as a
constructor
.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified String behaviour must include a
super
call to the String
constructor
to create and initialize the subclass instance with a
[[StringData]]
internal slot.
22.1.1.1
String (
value
)
This function performs the following steps when called:
If
value
is not present, then
Let
s
be the empty String.
Else,
If NewTarget is
undefined
and
value
is a Symbol
, return
SymbolDescriptiveString
(
value
).
Let
s
be ?
ToString
(
value
).
If NewTarget is
undefined
, return
s
.
Return
StringCreate
(
s
, ?
GetPrototypeFromConstructor
(NewTarget,
"%String.prototype%"
)).
22.1.2
Properties of the String Constructor
The String
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
22.1.2.1
String.fromCharCode ( ...
codeUnits
)
This function may be called with any number of arguments which form the rest parameter
codeUnits
.
It performs the following steps when called:
Let
result
be the empty String.
For each element
next
of
codeUnits
, do
Let
nextCU
be the code unit whose numeric value is
ℝ
(?
ToUint16
(
next
)).
Set
result
to the
string-concatenation
of
result
and
nextCU
.
Return
result
.
The
"length"
property of this function is
1
𝔽
.
22.1.2.2
String.fromCodePoint ( ...
codePoints
)
This function may be called with any number of arguments which form the rest parameter
codePoints
.
It performs the following steps when called:
Let
result
be the empty String.
For each element
next
of
codePoints
, do
Let
nextCP
be ?
ToNumber
(
next
).
If
nextCP
is not an
integral Number
, throw a
RangeError
exception.
If
ℝ
(
nextCP
) < 0 or
ℝ
(
nextCP
) > 0x10FFFF, throw a
RangeError
exception.
Set
result
to the
string-concatenation
of
result
and
UTF16EncodeCodePoint
(
ℝ
(
nextCP
)).
Assert
: If
codePoints
is empty, then
result
is the empty String.
Return
result
.
The
"length"
property of this function is
1
𝔽
.
22.1.2.3
String.prototype
The initial value of
String.prototype
is the
String prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
22.1.2.4
String.raw (
template
, ...
substitutions
)
This function may be called with a variable number of arguments. The first argument is
template
and the remainder of the arguments form the
List
substitutions
.
It performs the following steps when called:
Let
substitutionCount
be the number of elements in
substitutions
.
Let
cooked
be ?
ToObject
(
template
).
Let
literals
be ?
ToObject
(?
Get
(
cooked
,
"raw"
)).
Let
literalCount
be ?
LengthOfArrayLike
(
literals
).
If
literalCount
≤ 0, return the empty String.
Let
R
be the empty String.
Let
nextIndex
be 0.
Repeat,
Let
nextLiteralVal
be ?
Get
(
literals
, !
ToString
(
𝔽
(
nextIndex
))).
Let
nextLiteral
be ?
ToString
(
nextLiteralVal
).
Set
R
to the
string-concatenation
of
R
and
nextLiteral
.
If
nextIndex
+ 1 =
literalCount
, return
R
.
If
nextIndex
<
substitutionCount
, then
Let
nextSubVal
be
substitutions
[
nextIndex
].
Let
nextSub
be ?
ToString
(
nextSubVal
).
Set
R
to the
string-concatenation
of
R
and
nextSub
.
Set
nextIndex
to
nextIndex
+ 1.
Note
This function is intended for use as a tag function of a Tagged Template (
13.3.11
). When called as such, the first argument will be a well formed template object and the rest parameter will contain the substitution values.
22.1.3
Properties of the String Prototype Object
The
String prototype object
:
is
%String.prototype%
.
is a String
exotic object
and has the internal methods specified for such objects.
has a
[[StringData]]
internal slot whose value is the empty String.
has a
"length"
property whose initial value is
+0
𝔽
and whose attributes are {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
Unless explicitly stated otherwise, the methods of the String prototype object defined below are not generic and the
this
value passed to them must be either a String value or an object that has a
[[StringData]]
internal slot that has been initialized to a String value.
22.1.3.1
String.prototype.at (
index
)
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
len
be the length of
S
.
Let
relativeIndex
be ?
ToIntegerOrInfinity
(
index
).
If
relativeIndex
≥ 0, then
Let
k
be
relativeIndex
.
Else,
Let
k
be
len
+
relativeIndex
.
If
k
< 0 or
k
≥
len
, return
undefined
.
Return the
substring
of
S
from
k
to
k
+ 1.
22.1.3.2
String.prototype.charAt (
pos
)
Note 1
This method returns a single element String containing the code unit at index
pos
within the String value resulting from converting this object to a String. If there is no element at that index, the result is the empty String. The result
is a String
value, not a String object.
If
pos
is an
integral Number
, then the result of
x.charAt(pos)
is equivalent to the result of
x.substring(pos, pos + 1)
.
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
position
be ?
ToIntegerOrInfinity
(
pos
).
Let
size
be the length of
S
.
If
position
< 0 or
position
≥
size
, return the empty String.
Return the
substring
of
S
from
position
to
position
+ 1.
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.3
String.prototype.charCodeAt (
pos
)
Note 1
This method returns a Number (a non-negative
integral Number
less than 2
16
) that is the numeric value of the code unit at index
pos
within the String resulting from converting this object to a String. If there is no element at that index, the result is
NaN
.
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
position
be ?
ToIntegerOrInfinity
(
pos
).
Let
size
be the length of
S
.
If
position
< 0 or
position
≥
size
, return
NaN
.
Return the
Number value for
the numeric value of the code unit at index
position
within the String
S
.
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
22.1.3.4
String.prototype.codePointAt (
pos
)
Note 1
This method returns a non-negative
integral Number
less than or equal to
0x10FFFF
𝔽
that is the numeric value of the UTF-16 encoded code point (
6.1.4
) starting at the string element at index
pos
within the String resulting from converting this object to a String. If there is no element at that index, the result is
undefined
. If a valid UTF-16
surrogate pair
does not begin at
pos
, the result is the code unit at
pos
.
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
position
be ?
ToIntegerOrInfinity
(
pos
).
Let
size
be the length of
S
.
If
position
< 0 or
position
≥
size
, return
undefined
.
Let
cp
be
CodePointAt
(
S
,
position
).
Return
𝔽
(
cp
.
[[CodePoint]]
).
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
22.1.3.5
String.prototype.concat ( ...
args
)
Note 1
When this method is called it returns the String value consisting of the code units of the
this
value (converted to a String) followed by the code units of each of the arguments converted to a String. The result
is a String
value, not a String object.
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
R
be
S
.
For each element
next
of
args
, do
Let
nextString
be ?
ToString
(
next
).
Set
R
to the
string-concatenation
of
R
and
nextString
.
Return
R
.
The
"length"
property of this method is
1
𝔽
.
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
22.1.3.6
String.prototype.constructor
The initial value of
String.prototype.constructor
is
%String%
.
22.1.3.7
String.prototype.endsWith (
searchString
[ ,
endPosition
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
isRegExp
be ?
IsRegExp
(
searchString
).
If
isRegExp
is
true
, throw a
TypeError
exception.
Let
searchStr
be ?
ToString
(
searchString
).
Let
len
be the length of
S
.
If
endPosition
is
undefined
, let
pos
be
len
; else let
pos
be ?
ToIntegerOrInfinity
(
endPosition
).
Let
end
be the result of
clamping
pos
between 0 and
len
.
Let
searchLength
be the length of
searchStr
.
If
searchLength
= 0, return
true
.
Let
start
be
end
-
searchLength
.
If
start
< 0, return
false
.
Let
substring
be the
substring
of
S
from
start
to
end
.
If
substring
is
searchStr
, return
true
.
Return
false
.
Note 1
This method returns
true
if the sequence of code units of
searchString
converted to a String is the same as the corresponding code units of this object (converted to a String) starting at
endPosition
- length(this). Otherwise it returns
false
.
Note 2
Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.
Note 3
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.8
String.prototype.includes (
searchString
[ ,
position
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
isRegExp
be ?
IsRegExp
(
searchString
).
If
isRegExp
is
true
, throw a
TypeError
exception.
Let
searchStr
be ?
ToString
(
searchString
).
Let
pos
be ?
ToIntegerOrInfinity
(
position
).
Assert
: If
position
is
undefined
, then
pos
is 0.
Let
len
be the length of
S
.
Let
start
be the result of
clamping
pos
between 0 and
len
.
Let
index
be
StringIndexOf
(
S
,
searchStr
,
start
).
If
index
is
not-found
, return
false
.
Return
true
.
Note 1
If
searchString
appears as a
substring
of the result of converting this object to a String, at one or more indices that are greater than or equal to
position
, this function returns
true
; otherwise, it returns
false
. If
position
is
undefined
, 0 is assumed, so as to search all of the String.
Note 2
Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.
Note 3
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.9
String.prototype.indexOf (
searchString
[ ,
position
] )
Note 1
If
searchString
appears as a
substring
of the result of converting this object to a String, at one or more indices that are greater than or equal to
position
, then the smallest such index is returned; otherwise,
-1
𝔽
is returned. If
position
is
undefined
,
+0
𝔽
is assumed, so as to search all of the String.
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
searchStr
be ?
ToString
(
searchString
).
Let
pos
be ?
ToIntegerOrInfinity
(
position
).
Assert
: If
position
is
undefined
, then
pos
is 0.
Let
len
be the length of
S
.
Let
start
be the result of
clamping
pos
between 0 and
len
.
Let
result
be
StringIndexOf
(
S
,
searchStr
,
start
).
If
result
is
not-found
, return
-1
𝔽
.
Return
𝔽
(
result
).
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.10
String.prototype.isWellFormed ( )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Return
IsStringWellFormedUnicode
(
S
).
22.1.3.11
String.prototype.lastIndexOf (
searchString
[ ,
position
] )
Note 1
If
searchString
appears as a
substring
of the result of converting this object to a String at one or more indices that are smaller than or equal to
position
, then the greatest such index is returned; otherwise,
-1
𝔽
is returned. If
position
is
undefined
, the length of the String value is assumed, so as to search all of the String.
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
searchStr
be ?
ToString
(
searchString
).
Let
numPos
be ?
ToNumber
(
position
).
Assert
: If
position
is
undefined
, then
numPos
is
NaN
.
If
numPos
is
NaN
, let
pos
be +∞; otherwise let
pos
be !
ToIntegerOrInfinity
(
numPos
).
Let
len
be the length of
S
.
Let
searchLen
be the length of
searchStr
.
If
len
<
searchLen
, return
-1
𝔽
.
Let
start
be the result of
clamping
pos
between 0 and
len
-
searchLen
.
Let
result
be
StringLastIndexOf
(
S
,
searchStr
,
start
).
If
result
is
not-found
, return
-1
𝔽
.
Return
𝔽
(
result
).
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.12
String.prototype.localeCompare (
that
[ ,
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method returns a Number other than
NaN
representing the result of an
implementation-defined
locale-sensitive String comparison of the
this
value (converted to a String
S
) with
that
(converted to a String
thatValue
). The result is intended to correspond with a
sort order
of String values according to conventions of the
host environment
's current locale, and will be negative when
S
is ordered before
thatValue
, positive when
S
is ordered after
thatValue
, and zero in all other cases (representing no relative ordering between
S
and
thatValue
).
Before performing the comparisons, this method performs the following steps to prepare the Strings:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
thatValue
be ?
ToString
(
that
).
The meaning of the optional second and third parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not assign any other interpretation to those parameter positions.
The actual return values are
implementation-defined
to permit encoding additional information in them, but this method, when considered as a method of two arguments, is required to be a
consistent comparator
defining a total ordering on the set of all Strings. This method is also required to recognize and honour canonical equivalence according to the Unicode Standard, including returning
+0
𝔽
when comparing distinguishable Strings that are canonically equivalent.
Note 1
This method itself is not directly suitable as an argument to
Array.prototype.sort
because the latter requires a function of two arguments.
Note 2
This method may rely on whatever language- and/or locale-sensitive comparison functionality is available to the ECMAScript environment from the
host environment
, and is intended to compare according to the conventions of the
host environment
's current locale. However, regardless of comparison capabilities, this method must recognize and honour canonical equivalence according to the Unicode Standard—for example, the following comparisons must all return
+0
𝔽
:
// Å ANGSTROM SIGN vs.
// Å LATIN CAPITAL LETTER A + COMBINING RING ABOVE
"\u212B"
.
localeCompare
(
"A\u030A"
)
// Ω OHM SIGN vs.
// Ω GREEK CAPITAL LETTER OMEGA
"\u2126"
.
localeCompare
(
"\u03A9"
)
// ṩ LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
// ṩ LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
"\u1E69"
.
localeCompare
(
"s\u0307\u0323"
)
// ḍ̇ LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
// ḍ̇ LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
"\u1E0B\u0323"
.
localeCompare
(
"\u1E0D\u0307"
)
// 가 HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
// 가 HANGUL SYLLABLE GA
"\u1100\u1161"
.
localeCompare
(
"\uAC00"
)
For a definition and discussion of canonical equivalence see the Unicode Standard, chapters 2 and 3, as well as
Unicode Standard Annex #15, Unicode Normalization Forms
and
Unicode Technical Note #5, Canonical Equivalence in Applications
. Also see
Unicode Technical Standard #10, Unicode Collation Algorithm
.
It is recommended that this method should not honour Unicode compatibility equivalents or compatibility decompositions as defined in the Unicode Standard, chapter 3, section 3.7.
Note 3
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.13
String.prototype.match (
regexp
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
If
regexp
is an Object
, then
Let
matcher
be ?
GetMethod
(
regexp
,
%Symbol.match%
).
If
matcher
is not
undefined
, then
Return ?
Call
(
matcher
,
regexp
, «
O
»).
Let
S
be ?
ToString
(
O
).
Let
rx
be ?
RegExpCreate
(
regexp
,
undefined
).
Return ?
Invoke
(
rx
,
%Symbol.match%
, «
S
»).
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.14
String.prototype.matchAll (
regexp
)
This method performs a regular expression match of the String representing the
this
value against
regexp
and returns an
iterator
that yields match results. Each match result is an Array containing the matched portion of the String as the first element, followed by the portions matched by any capturing groups. If the regular expression never matches, the returned
iterator
does not yield any match results.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
If
regexp
is an Object
, then
Let
isRegExp
be ?
IsRegExp
(
regexp
).
If
isRegExp
is
true
, then
Let
flags
be ?
Get
(
regexp
,
"flags"
).
Perform ?
RequireObjectCoercible
(
flags
).
If ?
ToString
(
flags
) does not contain
"g"
, throw a
TypeError
exception.
Let
matcher
be ?
GetMethod
(
regexp
,
%Symbol.matchAll%
).
If
matcher
is not
undefined
, then
Return ?
Call
(
matcher
,
regexp
, «
O
»).
Let
S
be ?
ToString
(
O
).
Let
rx
be ?
RegExpCreate
(
regexp
,
"g"
).
Return ?
Invoke
(
rx
,
%Symbol.matchAll%
, «
S
»).
Note 1
This method is intentionally generic, it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
Note 2
Similarly to
String.prototype.split
,
String.prototype.matchAll
is designed to typically act without mutating its inputs.
22.1.3.15
String.prototype.normalize ( [
form
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
If
form
is
undefined
, let
f
be
"NFC"
.
Else, let
f
be ?
ToString
(
form
).
If
f
is not one of
"NFC"
,
"NFD"
,
"NFKC"
, or
"NFKD"
, throw a
RangeError
exception.
Let
ns
be the String value that is the result of normalizing
S
into the normalization form named by
f
as specified in
the latest Unicode Standard, Normalization Forms
.
Return
ns
.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
22.1.3.16
String.prototype.padEnd (
maxLength
[ ,
fillString
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Return ?
StringPaddingBuiltinsImpl
(
O
,
maxLength
,
fillString
,
end
).
22.1.3.17
String.prototype.padStart (
maxLength
[ ,
fillString
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Return ?
StringPaddingBuiltinsImpl
(
O
,
maxLength
,
fillString
,
start
).
22.1.3.17.1
StringPaddingBuiltinsImpl (
O
,
maxLength
,
fillString
,
placement
)
The abstract operation StringPaddingBuiltinsImpl takes arguments
O
(an
ECMAScript language value
),
maxLength
(an
ECMAScript language value
),
fillString
(an
ECMAScript language value
), and
placement
(
start
or
end
) and returns either a
normal completion containing
a String or a
throw completion
. It performs the following steps when called:
Let
S
be ?
ToString
(
O
).
Let
intMaxLength
be
ℝ
(?
ToLength
(
maxLength
)).
Let
stringLength
be the length of
S
.
If
intMaxLength
≤
stringLength
, return
S
.
If
fillString
is
undefined
, set
fillString
to the String value consisting solely of the code unit 0x0020 (SPACE).
Else, set
fillString
to ?
ToString
(
fillString
).
Return
StringPad
(
S
,
intMaxLength
,
fillString
,
placement
).
22.1.3.17.2
StringPad (
S
,
maxLength
,
fillString
,
placement
)
The abstract operation StringPad takes arguments
S
(a String),
maxLength
(a non-negative
integer
),
fillString
(a String), and
placement
(
start
or
end
) and returns a String. It performs the following steps when called:
Let
stringLength
be the length of
S
.
If
maxLength
≤
stringLength
, return
S
.
If
fillString
is the empty String, return
S
.
Let
fillLen
be
maxLength
-
stringLength
.
Let
truncatedStringFiller
be the String value consisting of repeated concatenations of
fillString
truncated to length
fillLen
.
If
placement
is
start
, return the
string-concatenation
of
truncatedStringFiller
and
S
.
Else, return the
string-concatenation
of
S
and
truncatedStringFiller
.
Note 1
The argument
maxLength
will be clamped such that it can be no smaller than the length of
S
.
Note 2
The argument
fillString
defaults to
" "
(the String value consisting of the code unit 0x0020 SPACE).
22.1.3.17.3
ToZeroPaddedDecimalString (
n
,
minLength
)
The abstract operation ToZeroPaddedDecimalString takes arguments
n
(a non-negative
integer
) and
minLength
(a non-negative
integer
) and returns a String. It performs the following steps when called:
Let
S
be the String representation of
n
, formatted as a decimal number.
Return
StringPad
(
S
,
minLength
,
"0"
,
start
).
22.1.3.18
String.prototype.repeat (
count
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
n
be ?
ToIntegerOrInfinity
(
count
).
If
n
< 0 or
n
= +∞, throw a
RangeError
exception.
If
n
= 0, return the empty String.
Return the String value that is made from
n
copies of
S
appended together.
Note 1
This method creates the String value consisting of the code units of the
this
value (converted to String) repeated
count
times.
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.19
String.prototype.replace (
searchValue
,
replaceValue
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
If
searchValue
is an Object
, then
Let
replacer
be ?
GetMethod
(
searchValue
,
%Symbol.replace%
).
If
replacer
is not
undefined
, then
Return ?
Call
(
replacer
,
searchValue
, «
O
,
replaceValue
»).
Let
string
be ?
ToString
(
O
).
Let
searchString
be ?
ToString
(
searchValue
).
Let
functionalReplace
be
IsCallable
(
replaceValue
).
If
functionalReplace
is
false
, then
Set
replaceValue
to ?
ToString
(
replaceValue
).
Let
searchLength
be the length of
searchString
.
Let
position
be
StringIndexOf
(
string
,
searchString
, 0).
If
position
is
not-found
, return
string
.
Let
preceding
be the
substring
of
string
from 0 to
position
.
Let
following
be the
substring
of
string
from
position
+
searchLength
.
If
functionalReplace
is
true
, then
Let
replacement
be ?
ToString
(?
Call
(
replaceValue
,
undefined
, «
searchString
,
𝔽
(
position
),
string
»)).
Else,
Assert
:
replaceValue
is a String
.
Let
captures
be a new empty
List
.
Let
replacement
be !
GetSubstitution
(
searchString
,
string
,
position
,
captures
,
undefined
,
replaceValue
).
Return the
string-concatenation
of
preceding
,
replacement
, and
following
.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.19.1
GetSubstitution (
matched
,
str
,
position
,
captures
,
namedCaptures
,
replacementTemplate
)
The abstract operation GetSubstitution takes arguments
matched
(a String),
str
(a String),
position
(a non-negative
integer
),
captures
(a
List
of either Strings or
undefined
),
namedCaptures
(an Object or
undefined
), and
replacementTemplate
(a String) and returns either a
normal completion containing
a String or a
throw completion
. For the purposes of this abstract operation, a
decimal digit
is a code unit in the
inclusive interval
from 0x0030 (DIGIT ZERO) to 0x0039 (DIGIT NINE). It performs the following steps when called:
Let
stringLength
be the length of
str
.
Assert
:
position
≤
stringLength
.
Let
result
be the empty String.
Let
templateRemainder
be
replacementTemplate
.
Repeat, while
templateRemainder
is not the empty String,
NOTE: The following steps isolate
ref
(a prefix of
templateRemainder
), determine
refReplacement
(its replacement), and then append that replacement to
result
.
If
templateRemainder
starts with
"$$"
, then
Let
ref
be
"$$"
.
Let
refReplacement
be
"$"
.
Else if
templateRemainder
starts with
"$`"
, then
Let
ref
be
"$`"
.
Let
refReplacement
be the
substring
of
str
from 0 to
position
.
Else if
templateRemainder
starts with
"$&"
, then
Let
ref
be
"$&"
.
Let
refReplacement
be
matched
.
Else if
templateRemainder
starts with
"$'"
(0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then
Let
ref
be
"$'"
.
Let
matchLength
be the length of
matched
.
Let
tailPos
be
position
+
matchLength
.
Let
refReplacement
be the
substring
of
str
from
min
(
tailPos
,
stringLength
).
NOTE:
tailPos
can exceed
stringLength
only if this abstract operation was invoked by a call to the intrinsic
%Symbol.replace%
method of
%RegExp.prototype%
on an object whose
"exec"
property is not the intrinsic %RegExp.prototype.exec%.
Else if
templateRemainder
starts with
"$"
followed by 1 or more decimal digits, then
If
templateRemainder
starts with
"$"
followed by 2 or more decimal digits, let
digitCount
be 2; otherwise let
digitCount
be 1.
Let
digits
be the
substring
of
templateRemainder
from 1 to 1 +
digitCount
.
Let
index
be
ℝ
(
StringToNumber
(
digits
)).
Assert
: 0 ≤
index
≤ 99.
Let
captureLen
be the number of elements in
captures
.
If
index
>
captureLen
and
digitCount
= 2, then
NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.
Set
digitCount
to 1.
Set
digits
to the
substring
of
digits
from 0 to 1.
Set
index
to
ℝ
(
StringToNumber
(
digits
)).
Let
ref
be the
substring
of
templateRemainder
from 0 to 1 +
digitCount
.
If 1 ≤
index
≤
captureLen
, then
Let
capture
be
captures
[
index
- 1].
If
capture
is
undefined
, then
Let
refReplacement
be the empty String.
Else,
Let
refReplacement
be
capture
.
Else,
Let
refReplacement
be
ref
.
Else if
templateRemainder
starts with
"$<"
, then
Let
gtPos
be
StringIndexOf
(
templateRemainder
,
">"
, 0).
If
gtPos
is
not-found
or
namedCaptures
is
undefined
, then
Let
ref
be
"$<"
.
Let
refReplacement
be
ref
.
Else,
Let
ref
be the
substring
of
templateRemainder
from 0 to
gtPos
+ 1.
Let
groupName
be the
substring
of
templateRemainder
from 2 to
gtPos
.
Assert
:
namedCaptures
is an Object
.
Let
capture
be ?
Get
(
namedCaptures
,
groupName
).
If
capture
is
undefined
, then
Let
refReplacement
be the empty String.
Else,
Let
refReplacement
be ?
ToString
(
capture
).
Else,
Let
ref
be the
substring
of
templateRemainder
from 0 to 1.
Let
refReplacement
be
ref
.
Let
refLength
be the length of
ref
.
Set
templateRemainder
to the
substring
of
templateRemainder
from
refLength
.
Set
result
to the
string-concatenation
of
result
and
refReplacement
.
Return
result
.
22.1.3.20
String.prototype.replaceAll (
searchValue
,
replaceValue
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
If
searchValue
is an Object
, then
Let
isRegExp
be ?
IsRegExp
(
searchValue
).
If
isRegExp
is
true
, then
Let
flags
be ?
Get
(
searchValue
,
"flags"
).
Perform ?
RequireObjectCoercible
(
flags
).
If ?
ToString
(
flags
) does not contain
"g"
, throw a
TypeError
exception.
Let
replacer
be ?
GetMethod
(
searchValue
,
%Symbol.replace%
).
If
replacer
is not
undefined
, then
Return ?
Call
(
replacer
,
searchValue
, «
O
,
replaceValue
»).
Let
string
be ?
ToString
(
O
).
Let
searchString
be ?
ToString
(
searchValue
).
Let
functionalReplace
be
IsCallable
(
replaceValue
).
If
functionalReplace
is
false
, then
Set
replaceValue
to ?
ToString
(
replaceValue
).
Let
searchLength
be the length of
searchString
.
Let
advanceBy
be
max
(1,
searchLength
).
Let
matchPositions
be a new empty
List
.
Let
position
be
StringIndexOf
(
string
,
searchString
, 0).
Repeat, while
position
is not
not-found
,
Append
position
to
matchPositions
.
Set
position
to
StringIndexOf
(
string
,
searchString
,
position
+
advanceBy
).
Let
endOfLastMatch
be 0.
Let
result
be the empty String.
For each element
p
of
matchPositions
, do
Let
preserved
be the
substring
of
string
from
endOfLastMatch
to
p
.
If
functionalReplace
is
true
, then
Let
replacement
be ?
ToString
(?
Call
(
replaceValue
,
undefined
, «
searchString
,
𝔽
(
p
),
string
»)).
Else,
Assert
:
replaceValue
is a String
.
Let
captures
be a new empty
List
.
Let
replacement
be !
GetSubstitution
(
searchString
,
string
,
p
,
captures
,
undefined
,
replaceValue
).
Set
result
to the
string-concatenation
of
result
,
preserved
, and
replacement
.
Set
endOfLastMatch
to
p
+
searchLength
.
If
endOfLastMatch
< the length of
string
, then
Set
result
to the
string-concatenation
of
result
and the
substring
of
string
from
endOfLastMatch
.
Return
result
.
22.1.3.21
String.prototype.search (
regexp
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
If
regexp
is an Object
, then
Let
searcher
be ?
GetMethod
(
regexp
,
%Symbol.search%
).
If
searcher
is not
undefined
, then
Return ?
Call
(
searcher
,
regexp
, «
O
»).
Let
string
be ?
ToString
(
O
).
Let
rx
be ?
RegExpCreate
(
regexp
,
undefined
).
Return ?
Invoke
(
rx
,
%Symbol.search%
, «
string
»).
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.22
String.prototype.slice (
start
,
end
)
This method returns a
substring
of the result of converting this object to a String, starting from index
start
and running to, but not including, index
end
(or through the end of the String if
end
is
undefined
). If
start
is negative, it is treated as
sourceLength
+
start
where
sourceLength
is the length of the String. If
end
is negative, it is treated as
sourceLength
+
end
where
sourceLength
is the length of the String. The result
is a String
value, not a String object.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
len
be the length of
S
.
Let
intStart
be ?
ToIntegerOrInfinity
(
start
).
If
intStart
= -∞, let
from
be 0.
Else if
intStart
< 0, let
from
be
max
(
len
+
intStart
, 0).
Else, let
from
be
min
(
intStart
,
len
).
If
end
is
undefined
, let
intEnd
be
len
; else let
intEnd
be ?
ToIntegerOrInfinity
(
end
).
If
intEnd
= -∞, let
to
be 0.
Else if
intEnd
< 0, let
to
be
max
(
len
+
intEnd
, 0).
Else, let
to
be
min
(
intEnd
,
len
).
If
from
≥
to
, return the empty String.
Return the
substring
of
S
from
from
to
to
.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
22.1.3.23
String.prototype.split (
separator
,
limit
)
This method returns an Array into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of
separator
; these occurrences are not part of any String in the returned array, but serve to divide up the String value. The value of
separator
may be a String of any length or it may be an object, such as a RegExp, that has a
%Symbol.split%
method.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
If
separator
is an Object
, then
Let
splitter
be ?
GetMethod
(
separator
,
%Symbol.split%
).
If
splitter
is not
undefined
, then
Return ?
Call
(
splitter
,
separator
, «
O
,
limit
»).
Let
S
be ?
ToString
(
O
).
If
limit
is
undefined
, let
lim
be 2
32
- 1; else let
lim
be
ℝ
(?
ToUint32
(
limit
)).
Let
R
be ?
ToString
(
separator
).
If
lim
= 0, then
Return
CreateArrayFromList
(« »).
If
separator
is
undefined
, then
Return
CreateArrayFromList
(«
S
»).
Let
separatorLength
be the length of
R
.
If
separatorLength
= 0, then
Let
strLen
be the length of
S
.
Let
outLen
be the result of
clamping
lim
between 0 and
strLen
.
Let
head
be the
substring
of
S
from 0 to
outLen
.
Let
codeUnits
be a
List
consisting of the sequence of code units that are the elements of
head
.
Return
CreateArrayFromList
(
codeUnits
).
If
S
is the empty String, return
CreateArrayFromList
(«
S
»).
Let
substrings
be a new empty
List
.
Let
i
be 0.
Let
j
be
StringIndexOf
(
S
,
R
, 0).
Repeat, while
j
is not
not-found
,
Let
T
be the
substring
of
S
from
i
to
j
.
Append
T
to
substrings
.
If the number of elements in
substrings
is
lim
, return
CreateArrayFromList
(
substrings
).
Set
i
to
j
+
separatorLength
.
Set
j
to
StringIndexOf
(
S
,
R
,
i
).
Let
T
be the
substring
of
S
from
i
.
Append
T
to
substrings
.
Return
CreateArrayFromList
(
substrings
).
Note 1
The value of
separator
may be an empty String. In this case,
separator
does not match the empty
substring
at the beginning or end of the input String, nor does it match the empty
substring
at the end of the previous separator match. If
separator
is the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each
substring
contains one code unit.
If the
this
value is (or converts to) the empty String, the result depends on whether
separator
can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.
If
separator
is
undefined
, then the result array contains just one String, which is the
this
value (converted to a String). If
limit
is not
undefined
, then the output array is truncated so that it contains no more than
limit
elements.
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.24
String.prototype.startsWith (
searchString
[ ,
position
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
isRegExp
be ?
IsRegExp
(
searchString
).
If
isRegExp
is
true
, throw a
TypeError
exception.
Let
searchStr
be ?
ToString
(
searchString
).
Let
len
be the length of
S
.
If
position
is
undefined
, let
pos
be 0; else let
pos
be ?
ToIntegerOrInfinity
(
position
).
Let
start
be the result of
clamping
pos
between 0 and
len
.
Let
searchLength
be the length of
searchStr
.
If
searchLength
= 0, return
true
.
Let
end
be
start
+
searchLength
.
If
end
>
len
, return
false
.
Let
substring
be the
substring
of
S
from
start
to
end
.
If
substring
is
searchStr
, return
true
.
Return
false
.
Note 1
This method returns
true
if the sequence of code units of
searchString
converted to a String is the same as the corresponding code units of this object (converted to a String) starting at index
position
. Otherwise it returns
false
.
Note 2
Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.
Note 3
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.25
String.prototype.substring (
start
,
end
)
This method returns a
substring
of the result of converting this object to a String, starting from index
start
and running to, but not including, index
end
of the String (or through the end of the String if
end
is
undefined
). The result
is a String
value, not a String object.
If either argument is
NaN
or negative, it is replaced with zero; if either argument is strictly greater than the length of the String, it is replaced with the length of the String.
If
start
is strictly greater than
end
, they are swapped.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
len
be the length of
S
.
Let
intStart
be ?
ToIntegerOrInfinity
(
start
).
If
end
is
undefined
, let
intEnd
be
len
; else let
intEnd
be ?
ToIntegerOrInfinity
(
end
).
Let
finalStart
be the result of
clamping
intStart
between 0 and
len
.
Let
finalEnd
be the result of
clamping
intEnd
between 0 and
len
.
Let
from
be
min
(
finalStart
,
finalEnd
).
Let
to
be
max
(
finalStart
,
finalEnd
).
Return the
substring
of
S
from
from
to
to
.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.26
String.prototype.toLocaleLowerCase ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method interprets a String value as a sequence of UTF-16 encoded code points, as described in
6.1.4
.
It works exactly the same as
toLowerCase
except that it is intended to yield a locale-sensitive result corresponding with conventions of the
host environment
's current locale. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.
The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.27
String.prototype.toLocaleUpperCase ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:
This method interprets a String value as a sequence of UTF-16 encoded code points, as described in
6.1.4
.
It works exactly the same as
toUpperCase
except that it is intended to yield a locale-sensitive result corresponding with conventions of the
host environment
's current locale. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.
The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.28
String.prototype.toLowerCase ( )
This method interprets a String value as a sequence of UTF-16 encoded code points, as described in
6.1.4
.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
sText
be
StringToCodePoints
(
S
).
Let
lowerText
be toLowercase(
sText
), according to the Unicode Default Case Conversion algorithm.
Let
L
be
CodePointsToString
(
lowerText
).
Return
L
.
The result must be derived according to the locale-insensitive case mappings in the Unicode Character Database (this explicitly includes not only the file
UnicodeData.txt
, but also all locale-insensitive mappings in the file
SpecialCasing.txt
that accompanies it).
Note 1
The case mapping of some code points may produce multiple code points. In this case the result String may not be the same length as the source String. Because both
toUpperCase
and
toLowerCase
have context-sensitive behaviour, the methods are not symmetrical. In other words,
s.toUpperCase().toLowerCase()
is not necessarily equal to
s.toLowerCase()
.
Note 2
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.29
String.prototype.toString ( )
This method performs the following steps when called:
Return ?
ThisStringValue
(
this
value).
Note
For a String object, this method happens to return the same thing as the
valueOf
method.
22.1.3.30
String.prototype.toUpperCase ( )
This method interprets a String value as a sequence of UTF-16 encoded code points, as described in
6.1.4
.
It behaves in exactly the same way as
String.prototype.toLowerCase
, except that the String is mapped using the toUppercase algorithm of the Unicode Default Case Conversion.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.31
String.prototype.toWellFormed ( )
This method returns a String representation of this object with all
leading surrogates
and
trailing surrogates
that are not part of a
surrogate pair
replaced with U+FFFD (REPLACEMENT CHARACTER).
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
strLen
be the length of
S
.
Let
k
be 0.
Let
result
be the empty String.
Repeat, while
k
<
strLen
,
Let
cp
be
CodePointAt
(
S
,
k
).
If
cp
.
[[IsUnpairedSurrogate]]
is
true
, then
Set
result
to the
string-concatenation
of
result
and 0xFFFD (REPLACEMENT CHARACTER).
Else,
Set
result
to the
string-concatenation
of
result
and
UTF16EncodeCodePoint
(
cp
.
[[CodePoint]]
).
Set
k
to
k
+
cp
.
[[CodeUnitCount]]
.
Return
result
.
22.1.3.32
String.prototype.trim ( )
This method interprets a String value as a sequence of UTF-16 encoded code points, as described in
6.1.4
.
It performs the following steps when called:
Let
S
be the
this
value.
Return ?
TrimString
(
S
,
start+end
).
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.32.1
TrimString (
string
,
where
)
The abstract operation TrimString takes arguments
string
(an
ECMAScript language value
) and
where
(
start
,
end
, or
start+end
) and returns either a
normal completion containing
a String or a
throw completion
. It interprets
string
as a sequence of UTF-16 encoded code points, as described in
6.1.4
. It performs the following steps when called:
Perform ?
RequireObjectCoercible
(
string
).
Let
S
be ?
ToString
(
string
).
If
where
is
start
, then
Let
T
be the String value that is a copy of
S
with leading white space removed.
Else if
where
is
end
, then
Let
T
be the String value that is a copy of
S
with trailing white space removed.
Else,
Assert
:
where
is
start+end
.
Let
T
be the String value that is a copy of
S
with both leading and trailing white space removed.
Return
T
.
The definition of white space is the union of
WhiteSpace
and
LineTerminator
. When determining whether a Unicode code point is in Unicode general category “Space_Separator” (“Zs”), code unit sequences are interpreted as UTF-16 encoded code point sequences as specified in
6.1.4
.
22.1.3.33
String.prototype.trimEnd ( )
This method interprets a String value as a sequence of UTF-16 encoded code points, as described in
6.1.4
.
It performs the following steps when called:
Let
S
be the
this
value.
Return ?
TrimString
(
S
,
end
).
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.34
String.prototype.trimStart ( )
This method interprets a String value as a sequence of UTF-16 encoded code points, as described in
6.1.4
.
It performs the following steps when called:
Let
S
be the
this
value.
Return ?
TrimString
(
S
,
start
).
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
22.1.3.35
String.prototype.valueOf ( )
This method performs the following steps when called:
Return ?
ThisStringValue
(
this
value).
22.1.3.35.1
ThisStringValue (
value
)
The abstract operation ThisStringValue takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a String or a
throw completion
. It performs the following steps when called:
If
value
is a String
, return
value
.
If
value
is an Object
and
value
has a
[[StringData]]
internal slot, then
Let
s
be
value
.
[[StringData]]
.
Assert
:
s
is a String
.
Return
s
.
Throw a
TypeError
exception.
22.1.3.36
String.prototype [ %Symbol.iterator% ] ( )
This method returns an
iterator object
that iterates over the code points of a String value, returning each code point as a String value.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
s
be ?
ToString
(
O
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
s
and performs the following steps when called:
Let
len
be the length of
s
.
Let
position
be 0.
Repeat, while
position
<
len
,
Let
cp
be
CodePointAt
(
s
,
position
).
Let
nextIndex
be
position
+
cp
.
[[CodeUnitCount]]
.
Let
resultString
be the
substring
of
s
from
position
to
nextIndex
.
Set
position
to
nextIndex
.
Perform ?
GeneratorYield
(
CreateIteratorResultObject
(
resultString
,
false
)).
Return
NormalCompletion
(
unused
).
Return
CreateIteratorFromClosure
(
closure
,
"%StringIteratorPrototype%"
,
%StringIteratorPrototype%
).
The value of the
"name"
property of this method is
"[Symbol.iterator]"
.
22.1.4
Properties of String Instances
String instances are
String exotic objects
and have the internal methods specified for such objects. String instances inherit properties from the
String prototype object
. String instances also have a
[[StringData]]
internal slot. The
[[StringData]]
internal slot is the String value represented by this String object.
String instances have a
"length"
property, and a set of enumerable properties with
integer-indexed
names.
22.1.4.1
length
The number of elements in the String value represented by this String object.
Once a String object is initialized, this property is unchanging. It has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
22.1.5
String Iterator Objects
A
String Iterator
is an object that represents a specific iteration over some specific String instance object. There is not a named
constructor
for String Iterator objects. Instead, String Iterator objects are created by calling certain methods of String instance objects.
22.1.5.1
The %StringIteratorPrototype% Object
The
%StringIteratorPrototype%
object:
has properties that are inherited by all
String Iterator objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
has the following properties:
22.1.5.1.1
%StringIteratorPrototype%.next ( )
Return ?
GeneratorResume
(
this
value,
empty
,
"%StringIteratorPrototype%"
).
22.1.5.1.2
%StringIteratorPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"String Iterator"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
22.2
RegExp (Regular Expression) Objects
A RegExp object contains a regular expression and the associated flags.
Note
The form and functionality of regular expressions is modelled after the regular expression facility in the Perl 5 programming language.
22.2.1
Patterns
The RegExp
constructor
applies the following grammar to the input pattern String. An error occurs if the grammar cannot interpret the String as an expansion of
Pattern
.
Syntax
Pattern
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Disjunction
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
Alternative
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
|
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
[empty]
Alternative
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Term
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Term
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
Assertion
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Quantifier
Assertion
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
^
$
\b
\B
(?=
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?!
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?<=
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?<!
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
Quantifier
::
QuantifierPrefix
QuantifierPrefix
?
QuantifierPrefix
::
*
+
?
{
DecimalDigits
[~Sep]
}
{
DecimalDigits
[~Sep]
,}
{
DecimalDigits
[~Sep]
,
DecimalDigits
[~Sep]
}
Atom
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
PatternCharacter
.
\
AtomEscape
[?UnicodeMode, ?NamedCaptureGroups]
CharacterClass
[?UnicodeMode, ?UnicodeSetsMode]
(
GroupSpecifier
[?UnicodeMode]
opt
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?
RegularExpressionModifiers
:
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?
RegularExpressionModifiers
-
RegularExpressionModifiers
:
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
RegularExpressionModifiers
::
[empty]
RegularExpressionModifiers
RegularExpressionModifier
RegularExpressionModifier
::
one of
i
m
s
SyntaxCharacter
::
one of
^
$
\
.
*
+
?
(
)
[
]
{
}
|
PatternCharacter
::
SourceCharacter
but not
SyntaxCharacter
AtomEscape
[UnicodeMode, NamedCaptureGroups]
::
DecimalEscape
CharacterClassEscape
[?UnicodeMode]
CharacterEscape
[?UnicodeMode]
[+NamedCaptureGroups]
k
GroupName
[?UnicodeMode]
CharacterEscape
[UnicodeMode]
::
ControlEscape
c
AsciiLetter
0
[lookahead ∉
DecimalDigit
]
HexEscapeSequence
RegExpUnicodeEscapeSequence
[?UnicodeMode]
IdentityEscape
[?UnicodeMode]
ControlEscape
::
one of
f
n
r
t
v
GroupSpecifier
[UnicodeMode]
::
?
GroupName
[?UnicodeMode]
GroupName
[UnicodeMode]
::
<
RegExpIdentifierName
[?UnicodeMode]
>
RegExpIdentifierName
[UnicodeMode]
::
RegExpIdentifierStart
[?UnicodeMode]
RegExpIdentifierName
[?UnicodeMode]
RegExpIdentifierPart
[?UnicodeMode]
RegExpIdentifierStart
[UnicodeMode]
::
IdentifierStartChar
\
RegExpUnicodeEscapeSequence
[+UnicodeMode]
[~UnicodeMode]
UnicodeLeadSurrogate
UnicodeTrailSurrogate
RegExpIdentifierPart
[UnicodeMode]
::
IdentifierPartChar
\
RegExpUnicodeEscapeSequence
[+UnicodeMode]
[~UnicodeMode]
UnicodeLeadSurrogate
UnicodeTrailSurrogate
RegExpUnicodeEscapeSequence
[UnicodeMode]
::
[+UnicodeMode]
u
HexLeadSurrogate
\u
HexTrailSurrogate
[+UnicodeMode]
u
HexLeadSurrogate
[+UnicodeMode]
u
HexTrailSurrogate
[+UnicodeMode]
u
HexNonSurrogate
[~UnicodeMode]
u
Hex4Digits
[+UnicodeMode]
u{
CodePoint
}
UnicodeLeadSurrogate
::
any Unicode code point in the inclusive interval from U+D800 to U+DBFF
UnicodeTrailSurrogate
::
any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
Each
\u
HexTrailSurrogate
for which the choice of associated
u
HexLeadSurrogate
is ambiguous shall be associated with the nearest possible
u
HexLeadSurrogate
that would otherwise have no corresponding
\u
HexTrailSurrogate
.
HexLeadSurrogate
::
Hex4Digits
but only if the MV of
Hex4Digits
is in the
inclusive interval
from 0xD800 to 0xDBFF
HexTrailSurrogate
::
Hex4Digits
but only if the MV of
Hex4Digits
is in the
inclusive interval
from 0xDC00 to 0xDFFF
HexNonSurrogate
::
Hex4Digits
but only if the MV of
Hex4Digits
is not in the
inclusive interval
from 0xD800 to 0xDFFF
IdentityEscape
[UnicodeMode]
::
[+UnicodeMode]
SyntaxCharacter
[+UnicodeMode]
/
[~UnicodeMode]
SourceCharacter
but not
UnicodeIDContinue
DecimalEscape
::
NonZeroDigit
DecimalDigits
[~Sep]
opt
[lookahead ∉
DecimalDigit
]
CharacterClassEscape
[UnicodeMode]
::
d
D
s
S
w
W
[+UnicodeMode]
p{
UnicodePropertyValueExpression
}
[+UnicodeMode]
P{
UnicodePropertyValueExpression
}
UnicodePropertyValueExpression
::
UnicodePropertyName
=
UnicodePropertyValue
LoneUnicodePropertyNameOrValue
UnicodePropertyName
::
UnicodePropertyNameCharacters
UnicodePropertyNameCharacters
::
UnicodePropertyNameCharacter
UnicodePropertyNameCharacters
opt
UnicodePropertyValue
::
UnicodePropertyValueCharacters
LoneUnicodePropertyNameOrValue
::
UnicodePropertyValueCharacters
UnicodePropertyValueCharacters
::
UnicodePropertyValueCharacter
UnicodePropertyValueCharacters
opt
UnicodePropertyValueCharacter
::
UnicodePropertyNameCharacter
DecimalDigit
UnicodePropertyNameCharacter
::
AsciiLetter
_
CharacterClass
[UnicodeMode, UnicodeSetsMode]
::
[
[lookahead ≠
^
]
ClassContents
[?UnicodeMode, ?UnicodeSetsMode]
]
[^
ClassContents
[?UnicodeMode, ?UnicodeSetsMode]
]
ClassContents
[UnicodeMode, UnicodeSetsMode]
::
[empty]
[~UnicodeSetsMode]
NonemptyClassRanges
[?UnicodeMode]
[+UnicodeSetsMode]
ClassSetExpression
NonemptyClassRanges
[UnicodeMode]
::
ClassAtom
[?UnicodeMode]
ClassAtom
[?UnicodeMode]
NonemptyClassRangesNoDash
[?UnicodeMode]
ClassAtom
[?UnicodeMode]
-
ClassAtom
[?UnicodeMode]
ClassContents
[?UnicodeMode, ~UnicodeSetsMode]
NonemptyClassRangesNoDash
[UnicodeMode]
::
ClassAtom
[?UnicodeMode]
ClassAtomNoDash
[?UnicodeMode]
NonemptyClassRangesNoDash
[?UnicodeMode]
ClassAtomNoDash
[?UnicodeMode]
-
ClassAtom
[?UnicodeMode]
ClassContents
[?UnicodeMode, ~UnicodeSetsMode]
ClassAtom
[UnicodeMode]
::
-
ClassAtomNoDash
[?UnicodeMode]
ClassAtomNoDash
[UnicodeMode]
::
SourceCharacter
but not one of
\
or
]
or
-
\
ClassEscape
[?UnicodeMode]
ClassEscape
[UnicodeMode]
::
b
[+UnicodeMode]
-
CharacterClassEscape
[?UnicodeMode]
CharacterEscape
[?UnicodeMode]
ClassSetExpression
::
ClassUnion
ClassIntersection
ClassSubtraction
ClassUnion
::
ClassSetRange
ClassUnion
opt
ClassSetOperand
ClassUnion
opt
ClassIntersection
::
ClassSetOperand
&&
[lookahead ≠
&
]
ClassSetOperand
ClassIntersection
&&
[lookahead ≠
&
]
ClassSetOperand
ClassSubtraction
::
ClassSetOperand
--
ClassSetOperand
ClassSubtraction
--
ClassSetOperand
ClassSetRange
::
ClassSetCharacter
-
ClassSetCharacter
ClassSetOperand
::
NestedClass
ClassStringDisjunction
ClassSetCharacter
NestedClass
::
[
[lookahead ≠
^
]
ClassContents
[+UnicodeMode, +UnicodeSetsMode]
]
[^
ClassContents
[+UnicodeMode, +UnicodeSetsMode]
]
\
CharacterClassEscape
[+UnicodeMode]
Note 1
The first two lines here are equivalent to CharacterClass.
ClassStringDisjunction
::
\q{
ClassStringDisjunctionContents
}
ClassStringDisjunctionContents
::
ClassString
ClassString
|
ClassStringDisjunctionContents
ClassString
::
[empty]
NonEmptyClassString
NonEmptyClassString
::
ClassSetCharacter
NonEmptyClassString
opt
ClassSetCharacter
::
[lookahead ∉
ClassSetReservedDoublePunctuator
]
SourceCharacter
but not
ClassSetSyntaxCharacter
\
CharacterEscape
[+UnicodeMode]
\
ClassSetReservedPunctuator
\b
ClassSetReservedDoublePunctuator
::
one of
&&
!!
##
$$
%%
**
++
,,
..
::
;;
<<
==
>>
??
@@
^^
``
~~
ClassSetSyntaxCharacter
::
one of
(
)
[
]
{
}
/
-
\
|
ClassSetReservedPunctuator
::
one of
&
-
!
#
%
,
:
;
<
=
>
@
`
~
Note 2
A number of productions in this section are given alternative definitions in section
B.1.2
.
22.2.1.1
Static Semantics: Early Errors
Note
This section is amended in
B.1.2.1
.
Pattern
::
Disjunction
It is a Syntax Error if
CountLeftCapturingParensWithin
(
Pattern
) ≥ 2
32
- 1.
It is a Syntax Error if
Pattern
contains two distinct
GroupSpecifier
s
x
and
y
such that the
CapturingGroupName
of
x
is the
CapturingGroupName
of
y
and such that
MightBothParticipate
(
x
,
y
) is
true
.
QuantifierPrefix
::
{
DecimalDigits
,
DecimalDigits
}
It is a Syntax Error if the MV of the first
DecimalDigits
is strictly greater than the MV of the second
DecimalDigits
.
Atom
::
(?
RegularExpressionModifiers
:
Disjunction
)
It is a Syntax Error if the
source text matched by
RegularExpressionModifiers
contains the same code point more than once.
Atom
::
(?
RegularExpressionModifiers
-
RegularExpressionModifiers
:
Disjunction
)
It is a Syntax Error if the
source text matched by
the first
RegularExpressionModifiers
and the
source text matched by
the second
RegularExpressionModifiers
are both empty.
It is a Syntax Error if the
source text matched by
the first
RegularExpressionModifiers
contains the same code point more than once.
It is a Syntax Error if the
source text matched by
the second
RegularExpressionModifiers
contains the same code point more than once.
It is a Syntax Error if any code point in the
source text matched by
the first
RegularExpressionModifiers
is also contained in the
source text matched by
the second
RegularExpressionModifiers
.
AtomEscape
::
k
GroupName
It is a Syntax Error if
GroupSpecifiersThatMatch
(
GroupName
) is empty.
AtomEscape
::
DecimalEscape
It is a Syntax Error if the
CapturingGroupNumber
of
DecimalEscape
is strictly greater than
CountLeftCapturingParensWithin
(the
Pattern
containing
AtomEscape
).
NonemptyClassRanges
::
ClassAtom
-
ClassAtom
ClassContents
It is a Syntax Error if
IsCharacterClass
of the first
ClassAtom
is
true
or
IsCharacterClass
of the second
ClassAtom
is
true
.
It is a Syntax Error if
IsCharacterClass
of the first
ClassAtom
is
false
,
IsCharacterClass
of the second
ClassAtom
is
false
, and the
CharacterValue
of the first
ClassAtom
is strictly greater than the
CharacterValue
of the second
ClassAtom
.
NonemptyClassRangesNoDash
::
ClassAtomNoDash
-
ClassAtom
ClassContents
It is a Syntax Error if
IsCharacterClass
of
ClassAtomNoDash
is
true
or
IsCharacterClass
of
ClassAtom
is
true
.
It is a Syntax Error if
IsCharacterClass
of
ClassAtomNoDash
is
false
,
IsCharacterClass
of
ClassAtom
is
false
, and the
CharacterValue
of
ClassAtomNoDash
is strictly greater than the
CharacterValue
of
ClassAtom
.
RegExpIdentifierStart
::
\
RegExpUnicodeEscapeSequence
It is a Syntax Error if the
CharacterValue
of
RegExpUnicodeEscapeSequence
is not the numeric value of some code point matched by the
IdentifierStartChar
lexical grammar production.
RegExpIdentifierStart
::
UnicodeLeadSurrogate
UnicodeTrailSurrogate
It is a Syntax Error if the
RegExpIdentifierCodePoint
of
RegExpIdentifierStart
is not matched by the
UnicodeIDStart
lexical grammar production.
RegExpIdentifierPart
::
\
RegExpUnicodeEscapeSequence
It is a Syntax Error if the
CharacterValue
of
RegExpUnicodeEscapeSequence
is not the numeric value of some code point matched by the
IdentifierPartChar
lexical grammar production.
RegExpIdentifierPart
::
UnicodeLeadSurrogate
UnicodeTrailSurrogate
It is a Syntax Error if the
RegExpIdentifierCodePoint
of
RegExpIdentifierPart
is not matched by the
UnicodeIDContinue
lexical grammar production.
UnicodePropertyValueExpression
::
UnicodePropertyName
=
UnicodePropertyValue
It is a Syntax Error if the
source text matched by
UnicodePropertyName
is not a
Unicode property name
or property alias listed in the “
Property name and aliases
” column of
Table 64
.
It is a Syntax Error if the
source text matched by
UnicodePropertyValue
is not a property value or property value alias for the Unicode property or property alias given by the
source text matched by
UnicodePropertyName
listed in
PropertyValueAliases.txt
.
UnicodePropertyValueExpression
::
LoneUnicodePropertyNameOrValue
It is a Syntax Error if the
source text matched by
LoneUnicodePropertyNameOrValue
is not a Unicode property value or property value alias for the General_Category (gc) property listed in
PropertyValueAliases.txt
, nor a binary property or binary property alias listed in the “
Property name and aliases
” column of
Table 65
, nor a binary property of strings listed in the “
Property name
” column of
Table 66
.
It is a Syntax Error if the enclosing
Pattern
does not have a
[UnicodeSetsMode]
parameter and the
source text matched by
LoneUnicodePropertyNameOrValue
is a binary property of strings listed in the “
Property name
” column of
Table 66
.
CharacterClassEscape
::
P{
UnicodePropertyValueExpression
}
It is a Syntax Error if
MayContainStrings
of the
UnicodePropertyValueExpression
is
true
.
CharacterClass
::
[^
ClassContents
]
It is a Syntax Error if
MayContainStrings
of the
ClassContents
is
true
.
NestedClass
::
[^
ClassContents
]
It is a Syntax Error if
MayContainStrings
of the
ClassContents
is
true
.
ClassSetRange
::
ClassSetCharacter
-
ClassSetCharacter
It is a Syntax Error if the
CharacterValue
of the first
ClassSetCharacter
is strictly greater than the
CharacterValue
of the second
ClassSetCharacter
.
22.2.1.2
Static Semantics: CountLeftCapturingParensWithin (
node
)
The abstract operation CountLeftCapturingParensWithin takes argument
node
(a
Parse Node
) and returns a non-negative
integer
. It returns the number of left-capturing parentheses in
node
. A
left-capturing parenthesis
is any
(
pattern character that is matched by the
(
terminal of the
Atom
::
(
GroupSpecifier
opt
Disjunction
)
production.
Note
This section is amended in
B.1.2.2
.
It performs the following steps when called:
Assert
:
node
is an instance of a production in
the RegExp Pattern grammar
.
Return the number of
Atom
::
(
GroupSpecifier
opt
Disjunction
)
Parse Nodes
contained within
node
.
22.2.1.3
Static Semantics: CountLeftCapturingParensBefore (
node
)
The abstract operation CountLeftCapturingParensBefore takes argument
node
(a
Parse Node
) and returns a non-negative
integer
. It returns the number of
left-capturing parentheses
within the enclosing pattern that occur to the left of
node
.
Note
This section is amended in
B.1.2.2
.
It performs the following steps when called:
Assert
:
node
is an instance of a production in
the RegExp Pattern grammar
.
Let
pattern
be the
Pattern
containing
node
.
Return the number of
Atom
::
(
GroupSpecifier
opt
Disjunction
)
Parse Nodes
contained within
pattern
that either occur before
node
or contain
node
.
22.2.1.4
Static Semantics: MightBothParticipate (
x
,
y
)
The abstract operation MightBothParticipate takes arguments
x
(a
Parse Node
) and
y
(a
Parse Node
) and returns a Boolean. It performs the following steps when called:
Assert
:
x
and
y
have the same enclosing
Pattern
.
If the enclosing
Pattern
contains a
Disjunction
::
Alternative
|
Disjunction
Parse Node
such that either
x
is contained within the
Alternative
and
y
is contained within the derived
Disjunction
, or
x
is contained within the derived
Disjunction
and
y
is contained within the
Alternative
, return
false
.
Return
true
.
22.2.1.5
Static Semantics: CapturingGroupNumber
The
syntax-directed operation
CapturingGroupNumber takes no arguments and returns a positive
integer
.
Note
This section is amended in
B.1.2.1
.
It is defined piecewise over the following productions:
DecimalEscape
::
NonZeroDigit
Return the MV of
NonZeroDigit
.
DecimalEscape
::
NonZeroDigit
DecimalDigits
Let
n
be the number of code points in
DecimalDigits
.
Return (the MV of
NonZeroDigit
× 10
n
plus the MV of
DecimalDigits
).
The definitions of “the MV of
NonZeroDigit
” and “the MV of
DecimalDigits
” are in
12.9.3
.
22.2.1.6
Static Semantics: IsCharacterClass
The
syntax-directed operation
IsCharacterClass takes no arguments and returns a Boolean.
Note
This section is amended in
B.1.2.3
.
It is defined piecewise over the following productions:
ClassAtom
::
-
ClassAtomNoDash
::
SourceCharacter
but not one of
\
or
]
or
-
ClassEscape
::
b
-
CharacterEscape
Return
false
.
ClassEscape
::
CharacterClassEscape
Return
true
.
22.2.1.7
Static Semantics: CharacterValue
The
syntax-directed operation
CharacterValue takes no arguments and returns a non-negative
integer
.
Note 1
This section is amended in
B.1.2.4
.
It is defined piecewise over the following productions:
ClassAtom
::
-
Return the numeric value of U+002D (HYPHEN-MINUS).
ClassAtomNoDash
::
SourceCharacter
but not one of
\
or
]
or
-
Let
ch
be the code point matched by
SourceCharacter
.
Return the numeric value of
ch
.
ClassEscape
::
b
Return the numeric value of U+0008 (BACKSPACE).
ClassEscape
::
-
Return the numeric value of U+002D (HYPHEN-MINUS).
CharacterEscape
::
ControlEscape
Return the numeric value according to
Table 62
.
Table 62: ControlEscape Code Point Values
ControlEscape
Numeric Value
Code Point
Unicode Name
Symbol
t
9
U+0009
CHARACTER TABULATION
<HT>
n
10
U+000A
LINE FEED (LF)
<LF>
v
11
U+000B
LINE TABULATION
<VT>
f
12
U+000C
FORM FEED (FF)
<FF>
r
13
U+000D
CARRIAGE RETURN (CR)
<CR>
CharacterEscape
::
c
AsciiLetter
Let
ch
be the code point matched by
AsciiLetter
.
Let
i
be the numeric value of
ch
.
Return the remainder of dividing
i
by 32.
CharacterEscape
::
0
[lookahead ∉
DecimalDigit
]
Return the numeric value of U+0000 (NULL).
Note 2
\0
represents the <NUL> character and cannot be followed by a decimal digit.
CharacterEscape
::
HexEscapeSequence
Return the MV of
HexEscapeSequence
.
RegExpUnicodeEscapeSequence
::
u
HexLeadSurrogate
\u
HexTrailSurrogate
Let
lead
be the
CharacterValue
of
HexLeadSurrogate
.
Let
trail
be the
CharacterValue
of
HexTrailSurrogate
.
Let
cp
be
UTF16SurrogatePairToCodePoint
(
lead
,
trail
).
Return the numeric value of
cp
.
RegExpUnicodeEscapeSequence
::
u
Hex4Digits
Return the MV of
Hex4Digits
.
RegExpUnicodeEscapeSequence
::
u{
CodePoint
}
Return the MV of
CodePoint
.
HexLeadSurrogate
::
Hex4Digits
HexTrailSurrogate
::
Hex4Digits
HexNonSurrogate
::
Hex4Digits
Return the MV of
Hex4Digits
.
CharacterEscape
::
IdentityEscape
Let
ch
be the code point matched by
IdentityEscape
.
Return the numeric value of
ch
.
ClassSetCharacter
::
SourceCharacter
but not
ClassSetSyntaxCharacter
Let
ch
be the code point matched by
SourceCharacter
.
Return the numeric value of
ch
.
ClassSetCharacter
::
\
ClassSetReservedPunctuator
Let
ch
be the code point matched by
ClassSetReservedPunctuator
.
Return the numeric value of
ch
.
ClassSetCharacter
::
\b
Return the numeric value of U+0008 (BACKSPACE).
22.2.1.8
Static Semantics: MayContainStrings
The
syntax-directed operation
MayContainStrings takes no arguments and returns a Boolean. It is defined piecewise over the following productions:
CharacterClassEscape
::
d
D
s
S
w
W
P{
UnicodePropertyValueExpression
}
UnicodePropertyValueExpression
::
UnicodePropertyName
=
UnicodePropertyValue
NestedClass
::
[^
ClassContents
]
ClassContents
::
[empty]
NonemptyClassRanges
ClassSetOperand
::
ClassSetCharacter
Return
false
.
UnicodePropertyValueExpression
::
LoneUnicodePropertyNameOrValue
If the
source text matched by
LoneUnicodePropertyNameOrValue
is a binary property of strings listed in the “
Property name
” column of
Table 66
, return
true
.
Return
false
.
ClassUnion
::
ClassSetRange
ClassUnion
opt
If the
ClassUnion
is present, return
MayContainStrings
of the
ClassUnion
.
Return
false
.
ClassUnion
::
ClassSetOperand
ClassUnion
opt
If
MayContainStrings
of the
ClassSetOperand
is
true
, return
true
.
If
ClassUnion
is present, return
MayContainStrings
of the
ClassUnion
.
Return
false
.
ClassIntersection
::
ClassSetOperand
&&
ClassSetOperand
If
MayContainStrings
of the first
ClassSetOperand
is
false
, return
false
.
If
MayContainStrings
of the second
ClassSetOperand
is
false
, return
false
.
Return
true
.
ClassIntersection
::
ClassIntersection
&&
ClassSetOperand
If
MayContainStrings
of the
ClassIntersection
is
false
, return
false
.
If
MayContainStrings
of the
ClassSetOperand
is
false
, return
false
.
Return
true
.
ClassSubtraction
::
ClassSetOperand
--
ClassSetOperand
Return
MayContainStrings
of the first
ClassSetOperand
.
ClassSubtraction
::
ClassSubtraction
--
ClassSetOperand
Return
MayContainStrings
of the
ClassSubtraction
.
ClassStringDisjunctionContents
::
ClassString
|
ClassStringDisjunctionContents
If
MayContainStrings
of the
ClassString
is
true
, return
true
.
Return
MayContainStrings
of the
ClassStringDisjunctionContents
.
ClassString
::
[empty]
Return
true
.
ClassString
::
NonEmptyClassString
Return
MayContainStrings
of the
NonEmptyClassString
.
NonEmptyClassString
::
ClassSetCharacter
NonEmptyClassString
opt
If
NonEmptyClassString
is present, return
true
.
Return
false
.
22.2.1.9
Static Semantics: GroupSpecifiersThatMatch (
thisGroupName
)
The abstract operation GroupSpecifiersThatMatch takes argument
thisGroupName
(a
GroupName
Parse Node
) and returns a
List
of
GroupSpecifier
Parse Nodes
. It performs the following steps when called:
Let
name
be the
CapturingGroupName
of
thisGroupName
.
Let
pattern
be the
Pattern
containing
thisGroupName
.
Let
result
be a new empty
List
.
For each
GroupSpecifier
gs
that
pattern
contains, do
If the
CapturingGroupName
of
gs
is
name
, then
Append
gs
to
result
.
Return
result
.
22.2.1.10
Static Semantics: CapturingGroupName
The
syntax-directed operation
CapturingGroupName takes no arguments and returns a String. It is defined piecewise over the following productions:
GroupName
::
<
RegExpIdentifierName
>
Let
idTextUnescaped
be the
RegExpIdentifierCodePoints
of
RegExpIdentifierName
.
Return
CodePointsToString
(
idTextUnescaped
).
22.2.1.11
Static Semantics: RegExpIdentifierCodePoints
The
syntax-directed operation
RegExpIdentifierCodePoints takes no arguments and returns a
List
of code points. It is defined piecewise over the following productions:
RegExpIdentifierName
::
RegExpIdentifierStart
Let
cp
be the
RegExpIdentifierCodePoint
of
RegExpIdentifierStart
.
Return «
cp
».
RegExpIdentifierName
::
RegExpIdentifierName
RegExpIdentifierPart
Let
cps
be the
RegExpIdentifierCodePoints
of the derived
RegExpIdentifierName
.
Let
cp
be the
RegExpIdentifierCodePoint
of
RegExpIdentifierPart
.
Return the
list-concatenation
of
cps
and «
cp
».
22.2.1.12
Static Semantics: RegExpIdentifierCodePoint
The
syntax-directed operation
RegExpIdentifierCodePoint takes no arguments and returns a code point. It is defined piecewise over the following productions:
RegExpIdentifierStart
::
IdentifierStartChar
Return the code point matched by
IdentifierStartChar
.
RegExpIdentifierPart
::
IdentifierPartChar
Return the code point matched by
IdentifierPartChar
.
RegExpIdentifierStart
::
\
RegExpUnicodeEscapeSequence
RegExpIdentifierPart
::
\
RegExpUnicodeEscapeSequence
Return the code point whose numeric value is the
CharacterValue
of
RegExpUnicodeEscapeSequence
.
RegExpIdentifierStart
::
UnicodeLeadSurrogate
UnicodeTrailSurrogate
RegExpIdentifierPart
::
UnicodeLeadSurrogate
UnicodeTrailSurrogate
Let
lead
be the code unit whose numeric value is the numeric value of the code point matched by
UnicodeLeadSurrogate
.
Let
trail
be the code unit whose numeric value is the numeric value of the code point matched by
UnicodeTrailSurrogate
.
Return
UTF16SurrogatePairToCodePoint
(
lead
,
trail
).
22.2.2
Pattern Semantics
A regular expression pattern is converted into an
Abstract Closure
using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the results are the same. The
Abstract Closure
is used as the value of a RegExp object's
[[RegExpMatcher]]
internal slot.
A
Pattern
is a BMP pattern if its associated flags contain neither a
u
nor a
v
. Otherwise, it is a Unicode pattern. A BMP pattern matches against a String interpreted as consisting of a sequence of 16-bit values that are Unicode code points in the range of the Basic Multilingual Plane. A Unicode pattern matches against a String interpreted as consisting of Unicode code points encoded using UTF-16. In the context of describing the behaviour of a BMP pattern “character” means a single 16-bit Unicode BMP code point. In the context of describing the behaviour of a Unicode pattern “character” means a UTF-16 encoded code point (
6.1.4
). In either context, “character value” means the numeric value of the corresponding non-encoded code point.
The syntax and semantics of
Pattern
is defined as if the source text for the
Pattern
was a
List
of
SourceCharacter
values where each
SourceCharacter
corresponds to a Unicode code point. If a BMP pattern contains a non-BMP
SourceCharacter
the entire pattern is encoded using UTF-16 and the individual code units of that encoding are used as the elements of the
List
.
Note
For example, consider a pattern expressed in source text as the single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as a Unicode pattern, it would be a single element (character)
List
consisting of the single code point U+1D11E. However, interpreted as a BMP pattern, it is first UTF-16 encoded to produce a two element
List
consisting of the code units 0xD834 and 0xDD1E.
Patterns are passed to the RegExp
constructor
as ECMAScript String values in which non-BMP characters are UTF-16 encoded. For example, the single character MUSICAL SYMBOL G CLEF pattern, expressed as a String value,
is a String
of length 2 whose elements were the code units 0xD834 and 0xDD1E. So no further translation of the string would be necessary to process it as a BMP pattern consisting of two pattern characters. However, to process it as a Unicode pattern
UTF16SurrogatePairToCodePoint
must be used in producing a
List
whose sole element is a single pattern character, the code point U+1D11E.
An implementation may not actually perform such translations to or from UTF-16, but the semantics of this specification requires that the result of pattern matching be as if such translations were performed.
22.2.2.1
Notation
The descriptions below use the following internal data structures:
A
CharSetElement
is one of the two following entities:
If
rer
.
[[UnicodeSets]]
is
false
, then a CharSetElement is a character in the sense of the Pattern Semantics above.
If
rer
.
[[UnicodeSets]]
is
true
, then a CharSetElement is a sequence whose elements are characters in the sense of the Pattern Semantics above. This includes the empty sequence, sequences of one character, and sequences of more than one character. For convenience, when working with CharSetElements of this kind, an individual character is treated interchangeably with a sequence of one character.
A
CharSet
is a mathematical set of CharSetElements.
A
CaptureRange
is a
Record
{
[[StartIndex]]
,
[[EndIndex]]
} that represents the range of characters included in a capture, where
[[StartIndex]]
is an
integer
representing the start index (inclusive) of the range within
Input
, and
[[EndIndex]]
is an
integer
representing the end index (exclusive) of the range within
Input
. For any
CaptureRange
, these indices must satisfy the invariant that
[[StartIndex]]
≤
[[EndIndex]]
.
A
MatchState
is a
Record
{
[[Input]]
,
[[EndIndex]]
,
[[Captures]]
} where
[[Input]]
is a
List
of characters representing the String being matched,
[[EndIndex]]
is an
integer
, and
[[Captures]]
is a
List
of values, one for each
left-capturing parenthesis
in the pattern.
MatchStates
are used to represent partial match states in the regular expression matching algorithms. The
[[EndIndex]]
is one plus the index of the last input character matched so far by the pattern, while
[[Captures]]
holds the results of capturing parentheses. The
n
th
element of
[[Captures]]
is either a
CaptureRange
representing the range of characters captured by the
n
th
set of capturing parentheses, or
undefined
if the
n
th
set of capturing parentheses hasn't been reached yet. Due to backtracking, many
MatchStates
may be in use at any time during the matching process.
A
MatcherContinuation
is an
Abstract Closure
that takes one
MatchState
argument and returns either a
MatchState
or
failure
. The
MatcherContinuation
attempts to match the remaining portion (specified by the closure's captured values) of the pattern against
Input
, starting at the intermediate state given by its
MatchState
argument. If the match succeeds, the
MatcherContinuation
returns the final
MatchState
that it reached; if the match fails, the
MatcherContinuation
returns
failure
.
A
Matcher
is an
Abstract Closure
that takes two arguments—a
MatchState
and a
MatcherContinuation
—and returns either a
MatchState
or
failure
. A
Matcher
attempts to match a middle subpattern (specified by the closure's captured values) of the pattern against the
MatchState
's
[[Input]]
, starting at the intermediate state given by its
MatchState
argument. The
MatcherContinuation
argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new
MatchState
, the
Matcher
then calls
MatcherContinuation
on that new
MatchState
to test if the rest of the pattern can match as well. If it can, the
Matcher
returns the
MatchState
returned by
MatcherContinuation
; if not, the
Matcher
may try different choices at its choice points, repeatedly calling
MatcherContinuation
until it either succeeds or all possibilities have been exhausted.
22.2.2.1.1
RegExp Records
A
RegExp Record
is a
Record
value used to store information about a RegExp that is needed during compilation and possibly during matching.
It has the following fields:
Table 63:
RegExp Record
Fields
Field Name
Value
Meaning
[[IgnoreCase]]
a Boolean
indicates whether
"i"
appears in the RegExp's flags
[[Multiline]]
a Boolean
indicates whether
"m"
appears in the RegExp's flags
[[DotAll]]
a Boolean
indicates whether
"s"
appears in the RegExp's flags
[[Unicode]]
a Boolean
indicates whether
"u"
appears in the RegExp's flags
[[UnicodeSets]]
a Boolean
indicates whether
"v"
appears in the RegExp's flags
[[CapturingGroupsCount]]
a non-negative
integer
the number of
left-capturing parentheses
in the RegExp's pattern
22.2.2.2
Runtime Semantics: CompilePattern
The
syntax-directed operation
CompilePattern takes argument
rer
(a
RegExp Record
) and returns an
Abstract Closure
that takes a
List
of characters and a non-negative
integer
and returns either a
MatchState
or
failure
. It is defined piecewise over the following productions:
Pattern
::
Disjunction
Let
m
be
CompileSubpattern
of
Disjunction
with arguments
rer
and
forward
.
Return a new
Abstract Closure
with parameters (
Input
,
index
) that captures
rer
and
m
and performs the following steps when called:
Assert
:
Input
is a
List
of characters.
Assert
: 0 ≤
index
≤ the number of elements in
Input
.
Let
c
be a new
MatcherContinuation
with parameters (
y
) that captures nothing and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Return
y
.
Let
cap
be a
List
of
rer
.
[[CapturingGroupsCount]]
undefined
values, indexed 1 through
rer
.
[[CapturingGroupsCount]]
.
Let
x
be the
MatchState
{
[[Input]]
:
Input
,
[[EndIndex]]
:
index
,
[[Captures]]
:
cap
}.
Return
m
(
x
,
c
).
Note
A Pattern compiles to an
Abstract Closure
value.
RegExpBuiltinExec
can then apply this procedure to a
List
of characters and an offset within that
List
to determine whether the pattern would match starting at exactly that offset within the
List
, and, if it does match, what the values of the capturing parentheses would be. The algorithms in
22.2.2
are designed so that compiling a pattern may throw a
SyntaxError
exception; on the other hand, once the pattern is successfully compiled, applying the resulting
Abstract Closure
to find a match in a
List
of characters cannot throw an exception (except for any
implementation-defined
exceptions that can occur anywhere such as out-of-memory).
22.2.2.3
Runtime Semantics: CompileSubpattern
The
syntax-directed operation
CompileSubpattern takes arguments
rer
(a
RegExp Record
) and
direction
(
forward
or
backward
) and returns a
Matcher
.
Note 1
This section is amended in
B.1.2.5
.
It is defined piecewise over the following productions:
Disjunction
::
Alternative
|
Disjunction
Let
m1
be
CompileSubpattern
of
Alternative
with arguments
rer
and
direction
.
Let
m2
be
CompileSubpattern
of
Disjunction
with arguments
rer
and
direction
.
Return
MatchTwoAlternatives
(
m1
,
m2
).
Note 2
The
|
regular expression operator separates two alternatives. The pattern first tries to match the left
Alternative
(followed by the sequel of the regular expression); if it fails, it tries to match the right
Disjunction
(followed by the sequel of the regular expression). If the left
Alternative
, the right
Disjunction
, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left
Alternative
. If choices in the left
Alternative
are exhausted, the right
Disjunction
is tried instead of the left
Alternative
. Any capturing parentheses inside a portion of the pattern skipped by
|
produce
undefined
values instead of Strings. Thus, for example,
/a|ab/.
exec
(
"abc"
)
returns the result
"a"
and not
"ab"
. Moreover,
/((a)|(ab))((c)|(bc))/.
exec
(
"abc"
)
returns the array
[
"abc"
,
"a"
,
"a"
,
undefined
,
"bc"
,
undefined
,
"bc"
]
and not
[
"abc"
,
"ab"
,
undefined
,
"ab"
,
"c"
,
"c"
,
undefined
]
The order in which the two alternatives are tried is independent of the value of
direction
.
Alternative
::
[empty]
Return
EmptyMatcher
().
Alternative
::
Alternative
Term
Let
m1
be
CompileSubpattern
of
Alternative
with arguments
rer
and
direction
.
Let
m2
be
CompileSubpattern
of
Term
with arguments
rer
and
direction
.
Return
MatchSequence
(
m1
,
m2
,
direction
).
Note 3
Consecutive
Term
s try to simultaneously match consecutive portions of
Input
. When
direction
is
forward
, if the left
Alternative
, the right
Term
, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right
Term
, and all choices in the right
Term
are tried before moving on to the next choice in the left
Alternative
. When
direction
is
backward
, the evaluation order of
Alternative
and
Term
are reversed.
Term
::
Assertion
Return
CompileAssertion
of
Assertion
with argument
rer
.
Note 4
The resulting
Matcher
is independent of
direction
.
Term
::
Atom
Return
CompileAtom
of
Atom
with arguments
rer
and
direction
.
Term
::
Atom
Quantifier
Let
m
be
CompileAtom
of
Atom
with arguments
rer
and
direction
.
Let
q
be
CompileQuantifier
of
Quantifier
.
Assert
:
q
.
[[Min]]
≤
q
.
[[Max]]
.
Let
parenIndex
be
CountLeftCapturingParensBefore
(
Term
).
Let
parenCount
be
CountLeftCapturingParensWithin
(
Atom
).
Return a new
Matcher
with parameters (
x
,
c
) that captures
m
,
q
,
parenIndex
, and
parenCount
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Return
RepeatMatcher
(
m
,
q
.
[[Min]]
,
q
.
[[Max]]
,
q
.
[[Greedy]]
,
x
,
c
,
parenIndex
,
parenCount
).
22.2.2.3.1
RepeatMatcher (
m
,
min
,
max
,
greedy
,
x
,
c
,
parenIndex
,
parenCount
)
The abstract operation RepeatMatcher takes arguments
m
(a
Matcher
),
min
(a non-negative
integer
),
max
(a non-negative
integer
or +∞),
greedy
(a Boolean),
x
(a
MatchState
),
c
(a
MatcherContinuation
),
parenIndex
(a non-negative
integer
), and
parenCount
(a non-negative
integer
) and returns either a
MatchState
or
failure
. It performs the following steps when called:
If
max
= 0, return
c
(
x
).
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures
m
,
min
,
max
,
greedy
,
x
,
c
,
parenIndex
, and
parenCount
and performs the following steps when called:
Assert
:
y
is a
MatchState
.
If
min
= 0 and
y
.
[[EndIndex]]
=
x
.
[[EndIndex]]
, return
failure
.
If
min
= 0, let
min2
be 0; otherwise let
min2
be
min
- 1.
If
max
= +∞, let
max2
be +∞; otherwise let
max2
be
max
- 1.
Return
RepeatMatcher
(
m
,
min2
,
max2
,
greedy
,
y
,
c
,
parenIndex
,
parenCount
).
Let
cap
be a copy of
x
.
[[Captures]]
.
For each
integer
k
in the
inclusive interval
from
parenIndex
+ 1 to
parenIndex
+
parenCount
, set
cap
[
k
] to
undefined
.
Let
Input
be
x
.
[[Input]]
.
Let
e
be
x
.
[[EndIndex]]
.
Let
xr
be the
MatchState
{
[[Input]]
:
Input
,
[[EndIndex]]
:
e
,
[[Captures]]
:
cap
}.
If
min
≠ 0, return
m
(
xr
,
d
).
If
greedy
is
false
, then
Let
z
be
c
(
x
).
If
z
is not
failure
, return
z
.
Return
m
(
xr
,
d
).
Let
z
be
m
(
xr
,
d
).
If
z
is not
failure
, return
z
.
Return
c
(
x
).
Note 1
An
Atom
followed by a
Quantifier
is repeated the number of times specified by the
Quantifier
. A
Quantifier
can be non-greedy, in which case the
Atom
pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the
Atom
pattern is repeated as many times as possible while still matching the sequel. The
Atom
pattern is repeated rather than the input character sequence that it matches, so different repetitions of the
Atom
can match different input substrings.
Note 2
If the
Atom
and the sequel of the regular expression all have choice points, the
Atom
is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of
Atom
. All choices in the last (n
th
) repetition of
Atom
are tried before moving on to the next choice in the next-to-last (n - 1)
st
repetition of
Atom
; at which point it may turn out that more or fewer repetitions of
Atom
are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)
st
repetition of
Atom
and so on.
Compare
/a[a-z]{
2
,
4
}/.
exec
(
"abcdefghi"
)
which returns
"abcde"
with
/a[a-z]{
2
,
4
}?/.
exec
(
"abcdefghi"
)
which returns
"abc"
.
Consider also
/(aa|aabaac|ba|b|c)*/.
exec
(
"aabaac"
)
which, by the choice point ordering above, returns the array
[
"aaba"
,
"ba"
]
and not any of:
[
"aabaac"
,
"aabaac"
] [
"aabaac"
,
"c"
]
The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:
"aaaaaaaaaa,aaaaaaaaaaaaaaa"
.
replace
(
/^(a+)\1*,\1+$/
,
"$1"
)
which returns the gcd in unary notation
"aaaaa"
.
Note 3
Step
4
of the RepeatMatcher clears
Atom
's captures each time
Atom
is repeated. We can see its behaviour in the regular expression
/(z)((a+)?(b+)?(c))*/.
exec
(
"zaacbbbcac"
)
which returns the array
[
"zaacbbbcac"
,
"z"
,
"ac"
,
"a"
,
undefined
,
"c"
]
and not
[
"zaacbbbcac"
,
"z"
,
"ac"
,
"a"
,
"bbb"
,
"c"
]
because each iteration of the outermost
*
clears all captured Strings contained in the quantified
Atom
, which in this case includes capture Strings numbered 2, 3, 4, and 5.
Note 4
Step
2.b
of the RepeatMatcher states that once the minimum number of repetitions has been satisfied, any more expansions of
Atom
that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:
/(a*)*/.
exec
(
"b"
)
or the slightly more complicated:
/(a*)b\
1
+/.
exec
(
"baaaac"
)
which returns the array
[
"b"
,
""
]
22.2.2.3.2
EmptyMatcher ( )
The abstract operation EmptyMatcher takes no arguments and returns a
Matcher
. It performs the following steps when called:
Return a new
Matcher
with parameters (
x
,
c
) that captures nothing and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Return
c
(
x
).
22.2.2.3.3
MatchTwoAlternatives (
m1
,
m2
)
The abstract operation MatchTwoAlternatives takes arguments
m1
(a
Matcher
) and
m2
(a
Matcher
) and returns a
Matcher
. It performs the following steps when called:
Return a new
Matcher
with parameters (
x
,
c
) that captures
m1
and
m2
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
r
be
m1
(
x
,
c
).
If
r
is not
failure
, return
r
.
Return
m2
(
x
,
c
).
22.2.2.3.4
MatchSequence (
m1
,
m2
,
direction
)
The abstract operation MatchSequence takes arguments
m1
(a
Matcher
),
m2
(a
Matcher
), and
direction
(
forward
or
backward
) and returns a
Matcher
. It performs the following steps when called:
If
direction
is
forward
, then
Return a new
Matcher
with parameters (
x
,
c
) that captures
m1
and
m2
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures
c
and
m2
and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Return
m2
(
y
,
c
).
Return
m1
(
x
,
d
).
Else,
Assert
:
direction
is
backward
.
Return a new
Matcher
with parameters (
x
,
c
) that captures
m1
and
m2
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures
c
and
m1
and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Return
m1
(
y
,
c
).
Return
m2
(
x
,
d
).
22.2.2.4
Runtime Semantics: CompileAssertion
The
syntax-directed operation
CompileAssertion takes argument
rer
(a
RegExp Record
) and returns a
Matcher
.
Note 1
This section is amended in
B.1.2.6
.
It is defined piecewise over the following productions:
Assertion
::
^
Return a new
Matcher
with parameters (
x
,
c
) that captures
rer
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
Input
be
x
.
[[Input]]
.
Let
e
be
x
.
[[EndIndex]]
.
If
e
= 0, or if
rer
.
[[Multiline]]
is
true
and the character
Input
[
e
- 1] is matched by
LineTerminator
, then
Return
c
(
x
).
Return
failure
.
Note 2
Even when the
y
flag is used with a pattern,
^
always matches only at the beginning of
Input
, or (if
rer
.
[[Multiline]]
is
true
) at the beginning of a line.
Assertion
::
$
Return a new
Matcher
with parameters (
x
,
c
) that captures
rer
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
Input
be
x
.
[[Input]]
.
Let
e
be
x
.
[[EndIndex]]
.
Let
InputLength
be the number of elements in
Input
.
If
e
=
InputLength
, or if
rer
.
[[Multiline]]
is
true
and the character
Input
[
e
] is matched by
LineTerminator
, then
Return
c
(
x
).
Return
failure
.
Assertion
::
\b
Return a new
Matcher
with parameters (
x
,
c
) that captures
rer
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
Input
be
x
.
[[Input]]
.
Let
e
be
x
.
[[EndIndex]]
.
Let
a
be
IsWordChar
(
rer
,
Input
,
e
- 1).
Let
b
be
IsWordChar
(
rer
,
Input
,
e
).
If
a
is
true
and
b
is
false
, or if
a
is
false
and
b
is
true
, return
c
(
x
).
Return
failure
.
Assertion
::
\B
Return a new
Matcher
with parameters (
x
,
c
) that captures
rer
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
Input
be
x
.
[[Input]]
.
Let
e
be
x
.
[[EndIndex]]
.
Let
a
be
IsWordChar
(
rer
,
Input
,
e
- 1).
Let
b
be
IsWordChar
(
rer
,
Input
,
e
).
If
a
is
true
and
b
is
true
, or if
a
is
false
and
b
is
false
, return
c
(
x
).
Return
failure
.
Assertion
::
(?=
Disjunction
)
Let
m
be
CompileSubpattern
of
Disjunction
with arguments
rer
and
forward
.
Return a new
Matcher
with parameters (
x
,
c
) that captures
m
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures nothing and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Return
y
.
Let
r
be
m
(
x
,
d
).
If
r
is
failure
, return
failure
.
Assert
:
r
is a
MatchState
.
Let
cap
be
r
.
[[Captures]]
.
Let
Input
be
x
.
[[Input]]
.
Let
xe
be
x
.
[[EndIndex]]
.
Let
z
be the
MatchState
{
[[Input]]
:
Input
,
[[EndIndex]]
:
xe
,
[[Captures]]
:
cap
}.
Return
c
(
z
).
Note 3
The form
(?=
Disjunction
)
specifies a zero-width positive lookahead. In order for it to succeed, the pattern inside
Disjunction
must match at the current position, but the current position is not advanced before matching the sequel. If
Disjunction
can match at the current position in several ways, only the first one is tried. Unlike other regular expression operators, there is no backtracking into a
(?=
form (this unusual behaviour is inherited from Perl). This only matters when the
Disjunction
contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.
For example,
/(?=(a+))/.
exec
(
"baaabac"
)
matches the empty String immediately after the first
b
and therefore returns the array:
[
""
,
"aaa"
]
To illustrate the lack of backtracking into the lookahead, consider:
/(?=(a+))a*b\
1
/.
exec
(
"baaabac"
)
This expression returns
[
"aba"
,
"a"
]
and not:
[
"aaaba"
,
"a"
]
Assertion
::
(?!
Disjunction
)
Let
m
be
CompileSubpattern
of
Disjunction
with arguments
rer
and
forward
.
Return a new
Matcher
with parameters (
x
,
c
) that captures
m
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures nothing and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Return
y
.
Let
r
be
m
(
x
,
d
).
If
r
is not
failure
, return
failure
.
Return
c
(
x
).
Note 4
The form
(?!
Disjunction
)
specifies a zero-width negative lookahead. In order for it to succeed, the pattern inside
Disjunction
must fail to match at the current position. The current position is not advanced before matching the sequel.
Disjunction
can contain capturing parentheses, but backreferences to them only make sense from within
Disjunction
itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return
undefined
because the negative lookahead must fail for the pattern to succeed. For example,
/(.*?)
a
(?!(a+)b\2c)\
2
(.*)/.
exec
(
"baaabaac"
)
looks for an
a
not immediately followed by some positive number n of
a
's, a
b
, another n
a
's (specified by the first
\2
) and a
c
. The second
\2
is outside the negative lookahead, so it matches against
undefined
and therefore always succeeds. The whole expression returns the array:
[
"baaabaac"
,
"ba"
,
undefined
,
"abaac"
]
Assertion
::
(?<=
Disjunction
)
Let
m
be
CompileSubpattern
of
Disjunction
with arguments
rer
and
backward
.
Return a new
Matcher
with parameters (
x
,
c
) that captures
m
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures nothing and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Return
y
.
Let
r
be
m
(
x
,
d
).
If
r
is
failure
, return
failure
.
Assert
:
r
is a
MatchState
.
Let
cap
be
r
.
[[Captures]]
.
Let
Input
be
x
.
[[Input]]
.
Let
xe
be
x
.
[[EndIndex]]
.
Let
z
be the
MatchState
{
[[Input]]
:
Input
,
[[EndIndex]]
:
xe
,
[[Captures]]
:
cap
}.
Return
c
(
z
).
Assertion
::
(?<!
Disjunction
)
Let
m
be
CompileSubpattern
of
Disjunction
with arguments
rer
and
backward
.
Return a new
Matcher
with parameters (
x
,
c
) that captures
m
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures nothing and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Return
y
.
Let
r
be
m
(
x
,
d
).
If
r
is not
failure
, return
failure
.
Return
c
(
x
).
22.2.2.4.1
IsWordChar (
rer
,
Input
,
e
)
The abstract operation IsWordChar takes arguments
rer
(a
RegExp Record
),
Input
(a
List
of characters), and
e
(an
integer
) and returns a Boolean. It performs the following steps when called:
Let
InputLength
be the number of elements in
Input
.
If
e
= -1 or
e
=
InputLength
, return
false
.
Let
c
be the character
Input
[
e
].
If
WordCharacters
(
rer
) contains
c
, return
true
.
Return
false
.
22.2.2.5
Runtime Semantics: CompileQuantifier
The
syntax-directed operation
CompileQuantifier takes no arguments and returns a
Record
with fields
[[Min]]
(a non-negative
integer
),
[[Max]]
(a non-negative
integer
or +∞), and
[[Greedy]]
(a Boolean). It is defined piecewise over the following productions:
Quantifier
::
QuantifierPrefix
Let
qp
be
CompileQuantifierPrefix
of
QuantifierPrefix
.
Return the
Record
{
[[Min]]
:
qp
.
[[Min]]
,
[[Max]]
:
qp
.
[[Max]]
,
[[Greedy]]
:
true
}.
Quantifier
::
QuantifierPrefix
?
Let
qp
be
CompileQuantifierPrefix
of
QuantifierPrefix
.
Return the
Record
{
[[Min]]
:
qp
.
[[Min]]
,
[[Max]]
:
qp
.
[[Max]]
,
[[Greedy]]
:
false
}.
22.2.2.6
Runtime Semantics: CompileQuantifierPrefix
The
syntax-directed operation
CompileQuantifierPrefix takes no arguments and returns a
Record
with fields
[[Min]]
(a non-negative
integer
) and
[[Max]]
(a non-negative
integer
or +∞). It is defined piecewise over the following productions:
QuantifierPrefix
::
*
Return the
Record
{
[[Min]]
: 0,
[[Max]]
: +∞ }.
QuantifierPrefix
::
+
Return the
Record
{
[[Min]]
: 1,
[[Max]]
: +∞ }.
QuantifierPrefix
::
?
Return the
Record
{
[[Min]]
: 0,
[[Max]]
: 1 }.
QuantifierPrefix
::
{
DecimalDigits
}
Let
i
be the MV of
DecimalDigits
(see
12.9.3
).
Return the
Record
{
[[Min]]
:
i
,
[[Max]]
:
i
}.
QuantifierPrefix
::
{
DecimalDigits
,}
Let
i
be the MV of
DecimalDigits
.
Return the
Record
{
[[Min]]
:
i
,
[[Max]]
: +∞ }.
QuantifierPrefix
::
{
DecimalDigits
,
DecimalDigits
}
Let
i
be the MV of the first
DecimalDigits
.
Let
j
be the MV of the second
DecimalDigits
.
Return the
Record
{
[[Min]]
:
i
,
[[Max]]
:
j
}.
22.2.2.7
Runtime Semantics: CompileAtom
The
syntax-directed operation
CompileAtom takes arguments
rer
(a
RegExp Record
) and
direction
(
forward
or
backward
) and returns a
Matcher
.
Note 1
This section is amended in
B.1.2.7
.
It is defined piecewise over the following productions:
Atom
::
PatternCharacter
Let
ch
be the character matched by
PatternCharacter
.
Let
A
be a one-element
CharSet
containing the character
ch
.
Return
CharacterSetMatcher
(
rer
,
A
,
false
,
direction
).
Atom
::
.
Let
A
be
AllCharacters
(
rer
).
If
rer
.
[[DotAll]]
is not
true
, then
Remove from
A
all characters corresponding to a code point on the right-hand side of the
LineTerminator
production.
Return
CharacterSetMatcher
(
rer
,
A
,
false
,
direction
).
Atom
::
CharacterClass
Let
cc
be
CompileCharacterClass
of
CharacterClass
with argument
rer
.
Let
cs
be
cc
.
[[CharSet]]
.
If
rer
.
[[UnicodeSets]]
is
false
, or if every
CharSetElement
of
cs
consists of a single character (including if
cs
is empty), return
CharacterSetMatcher
(
rer
,
cs
,
cc
.
[[Invert]]
,
direction
).
Assert
:
cc
.
[[Invert]]
is
false
.
Let
lm
be an empty
List
of
Matchers
.
For each
CharSetElement
s
in
cs
containing more than 1 character, iterating in descending order of length, do
Let
cs2
be a one-element
CharSet
containing the last code point of
s
.
Let
m2
be
CharacterSetMatcher
(
rer
,
cs2
,
false
,
direction
).
For each code point
c1
in
s
, iterating backwards from its second-to-last code point, do
Let
cs1
be a one-element
CharSet
containing
c1
.
Let
m1
be
CharacterSetMatcher
(
rer
,
cs1
,
false
,
direction
).
Set
m2
to
MatchSequence
(
m1
,
m2
,
direction
).
Append
m2
to
lm
.
Let
singles
be the
CharSet
containing every
CharSetElement
of
cs
that consists of a single character.
Append
CharacterSetMatcher
(
rer
,
singles
,
false
,
direction
) to
lm
.
If
cs
contains the empty sequence of characters, append
EmptyMatcher
() to
lm
.
Let
m2
be the last
Matcher
in
lm
.
For each
Matcher
m1
of
lm
, iterating backwards from its second-to-last element, do
Set
m2
to
MatchTwoAlternatives
(
m1
,
m2
).
Return
m2
.
Atom
::
(
GroupSpecifier
opt
Disjunction
)
Let
m
be
CompileSubpattern
of
Disjunction
with arguments
rer
and
direction
.
Let
parenIndex
be
CountLeftCapturingParensBefore
(
Atom
).
Return a new
Matcher
with parameters (
x
,
c
) that captures
direction
,
m
, and
parenIndex
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
d
be a new
MatcherContinuation
with parameters (
y
) that captures
x
,
c
,
direction
, and
parenIndex
and performs the following steps when called:
Assert
:
y
is a
MatchState
.
Let
cap
be a copy of
y
.
[[Captures]]
.
Let
Input
be
x
.
[[Input]]
.
Let
xe
be
x
.
[[EndIndex]]
.
Let
ye
be
y
.
[[EndIndex]]
.
If
direction
is
forward
, then
Assert
:
xe
≤
ye
.
Let
r
be the
CaptureRange
{
[[StartIndex]]
:
xe
,
[[EndIndex]]
:
ye
}.
Else,
Assert
:
direction
is
backward
.
Assert
:
ye
≤
xe
.
Let
r
be the
CaptureRange
{
[[StartIndex]]
:
ye
,
[[EndIndex]]
:
xe
}.
Set
cap
[
parenIndex
+ 1] to
r
.
Let
z
be the
MatchState
{
[[Input]]
:
Input
,
[[EndIndex]]
:
ye
,
[[Captures]]
:
cap
}.
Return
c
(
z
).
Return
m
(
x
,
d
).
Note 2
Parentheses of the form
(
Disjunction
)
serve both to group the components of the
Disjunction
pattern together and to save the result of the match. The result can be used either in a backreference (
\
followed by a non-zero decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching
Abstract Closure
. To inhibit the capturing behaviour of parentheses, use the form
(?:
Disjunction
)
instead.
Atom
::
(?
RegularExpressionModifiers
:
Disjunction
)
Let
addModifiers
be the
source text matched by
RegularExpressionModifiers
.
Let
removeModifiers
be the empty String.
Let
modifiedRer
be
UpdateModifiers
(
rer
,
CodePointsToString
(
addModifiers
),
removeModifiers
).
Return
CompileSubpattern
of
Disjunction
with arguments
modifiedRer
and
direction
.
Atom
::
(?
RegularExpressionModifiers
-
RegularExpressionModifiers
:
Disjunction
)
Let
addModifiers
be the
source text matched by
the first
RegularExpressionModifiers
.
Let
removeModifiers
be the
source text matched by
the second
RegularExpressionModifiers
.
Let
modifiedRer
be
UpdateModifiers
(
rer
,
CodePointsToString
(
addModifiers
),
CodePointsToString
(
removeModifiers
)).
Return
CompileSubpattern
of
Disjunction
with arguments
modifiedRer
and
direction
.
AtomEscape
::
DecimalEscape
Let
n
be the
CapturingGroupNumber
of
DecimalEscape
.
Assert
:
n
≤
rer
.
[[CapturingGroupsCount]]
.
Return
BackreferenceMatcher
(
rer
, «
n
»,
direction
).
Note 3
An escape sequence of the form
\
followed by a non-zero decimal number
n
matches the result of the
n
th
set of capturing parentheses (
22.2.2.1
). It is an error if the regular expression has fewer than
n
capturing parentheses. If the regular expression has
n
or more capturing parentheses but the
n
th
one is
undefined
because it has not captured anything, then the backreference always succeeds.
AtomEscape
::
CharacterEscape
Let
cv
be the
CharacterValue
of
CharacterEscape
.
Let
ch
be the character whose character value is
cv
.
Let
A
be a one-element
CharSet
containing the character
ch
.
Return
CharacterSetMatcher
(
rer
,
A
,
false
,
direction
).
AtomEscape
::
CharacterClassEscape
Let
cs
be
CompileToCharSet
of
CharacterClassEscape
with argument
rer
.
If
rer
.
[[UnicodeSets]]
is
false
, or if every
CharSetElement
of
cs
consists of a single character (including if
cs
is empty), return
CharacterSetMatcher
(
rer
,
cs
,
false
,
direction
).
Let
lm
be an empty
List
of
Matchers
.
For each
CharSetElement
s
in
cs
containing more than 1 character, iterating in descending order of length, do
Let
cs2
be a one-element
CharSet
containing the last code point of
s
.
Let
m2
be
CharacterSetMatcher
(
rer
,
cs2
,
false
,
direction
).
For each code point
c1
in
s
, iterating backwards from its second-to-last code point, do
Let
cs1
be a one-element
CharSet
containing
c1
.
Let
m1
be
CharacterSetMatcher
(
rer
,
cs1
,
false
,
direction
).
Set
m2
to
MatchSequence
(
m1
,
m2
,
direction
).
Append
m2
to
lm
.
Let
singles
be the
CharSet
containing every
CharSetElement
of
cs
that consists of a single character.
Append
CharacterSetMatcher
(
rer
,
singles
,
false
,
direction
) to
lm
.
If
cs
contains the empty sequence of characters, append
EmptyMatcher
() to
lm
.
Let
m2
be the last
Matcher
in
lm
.
For each
Matcher
m1
of
lm
, iterating backwards from its second-to-last element, do
Set
m2
to
MatchTwoAlternatives
(
m1
,
m2
).
Return
m2
.
AtomEscape
::
k
GroupName
Let
matchingGroupSpecifiers
be
GroupSpecifiersThatMatch
(
GroupName
).
Let
parenIndices
be a new empty
List
.
For each
GroupSpecifier
groupSpecifier
of
matchingGroupSpecifiers
, do
Let
parenIndex
be
CountLeftCapturingParensBefore
(
groupSpecifier
).
Append
parenIndex
to
parenIndices
.
Return
BackreferenceMatcher
(
rer
,
parenIndices
,
direction
).
22.2.2.7.1
CharacterSetMatcher (
rer
,
A
,
invert
,
direction
)
The abstract operation CharacterSetMatcher takes arguments
rer
(a
RegExp Record
),
A
(a
CharSet
),
invert
(a Boolean), and
direction
(
forward
or
backward
) and returns a
Matcher
. It performs the following steps when called:
If
rer
.
[[UnicodeSets]]
is
true
, then
Assert
:
invert
is
false
.
Assert
: Every
CharSetElement
of
A
consists of a single character.
Return a new
Matcher
with parameters (
x
,
c
) that captures
rer
,
A
,
invert
, and
direction
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
Input
be
x
.
[[Input]]
.
Let
e
be
x
.
[[EndIndex]]
.
If
direction
is
forward
, let
f
be
e
+ 1.
Else, let
f
be
e
- 1.
Let
InputLength
be the number of elements in
Input
.
If
f
< 0 or
f
>
InputLength
, return
failure
.
Let
index
be
min
(
e
,
f
).
Let
ch
be the character
Input
[
index
].
Let
cc
be
Canonicalize
(
rer
,
ch
).
If there exists a
CharSetElement
in
A
containing exactly one character
a
such that
Canonicalize
(
rer
,
a
) is
cc
, let
found
be
true
; otherwise let
found
be
false
.
If
invert
is
false
and
found
is
false
, return
failure
.
If
invert
is
true
and
found
is
true
, return
failure
.
Let
cap
be
x
.
[[Captures]]
.
Let
y
be the
MatchState
{
[[Input]]
:
Input
,
[[EndIndex]]
:
f
,
[[Captures]]
:
cap
}.
Return
c
(
y
).
22.2.2.7.2
BackreferenceMatcher (
rer
,
ns
,
direction
)
The abstract operation BackreferenceMatcher takes arguments
rer
(a
RegExp Record
),
ns
(a
List
of positive
integers
), and
direction
(
forward
or
backward
) and returns a
Matcher
. It performs the following steps when called:
Return a new
Matcher
with parameters (
x
,
c
) that captures
rer
,
ns
, and
direction
and performs the following steps when called:
Assert
:
x
is a
MatchState
.
Assert
:
c
is a
MatcherContinuation
.
Let
Input
be
x
.
[[Input]]
.
Let
cap
be
x
.
[[Captures]]
.
Let
r
be
undefined
.
For each
integer
n
of
ns
, do
If
cap
[
n
] is not
undefined
, then
Assert
:
r
is
undefined
.
Set
r
to
cap
[
n
].
If
r
is
undefined
, return
c
(
x
).
Let
e
be
x
.
[[EndIndex]]
.
Let
rs
be
r
.
[[StartIndex]]
.
Let
re
be
r
.
[[EndIndex]]
.
Let
len
be
re
-
rs
.
If
direction
is
forward
, let
f
be
e
+
len
.
Else, let
f
be
e
-
len
.
Let
InputLength
be the number of elements in
Input
.
If
f
< 0 or
f
>
InputLength
, return
failure
.
Let
g
be
min
(
e
,
f
).
If there exists an
integer
i
in the
interval
from 0 (inclusive) to
len
(exclusive) such that
Canonicalize
(
rer
,
Input
[
rs
+
i
]) is not
Canonicalize
(
rer
,
Input
[
g
+
i
]), return
failure
.
Let
y
be the
MatchState
{
[[Input]]
:
Input
,
[[EndIndex]]
:
f
,
[[Captures]]
:
cap
}.
Return
c
(
y
).
22.2.2.7.3
Canonicalize (
rer
,
ch
)
The abstract operation Canonicalize takes arguments
rer
(a
RegExp Record
) and
ch
(a character) and returns a character. It performs the following steps when called:
If
HasEitherUnicodeFlag
(
rer
) is
true
and
rer
.
[[IgnoreCase]]
is
true
, then
If the file
CaseFolding.txt
of the Unicode Character Database provides a simple or common case folding mapping for
ch
, return the result of applying that mapping to
ch
.
Return
ch
.
If
rer
.
[[IgnoreCase]]
is
false
, return
ch
.
Assert
:
ch
is a UTF-16 code unit.
Let
cp
be the code point whose numeric value is the numeric value of
ch
.
Let
u
be toUppercase(«
cp
»), according to the Unicode Default Case Conversion algorithm.
Let
uStr
be
CodePointsToString
(
u
).
If the length of
uStr
≠ 1, return
ch
.
Let
cu
be
uStr
's single code unit element.
If the numeric value of
ch
≥ 128 and the numeric value of
cu
< 128, return
ch
.
Return
cu
.
Note
In case-insignificant matches when
HasEitherUnicodeFlag
(
rer
) is
true
, all characters are implicitly case-folded using the simple mapping provided by the Unicode Standard immediately before they are compared. The simple mapping always maps to a single code point, so it does not map, for example,
ß
(U+00DF LATIN SMALL LETTER SHARP S) to
ss
or
SS
. It may however map code points outside the Basic Latin block to code points within it—for example,
ſ
(U+017F LATIN SMALL LETTER LONG S) case-folds to
s
(U+0073 LATIN SMALL LETTER S) and
K
(U+212A KELVIN SIGN) case-folds to
k
(U+006B LATIN SMALL LETTER K). Strings containing those code points are matched by regular expressions such as
/[a-z]/ui
.
In case-insignificant matches when
HasEitherUnicodeFlag
(
rer
) is
false
, the mapping is based on Unicode Default Case Conversion algorithm toUppercase rather than toCasefold, which results in some subtle differences. For example,
Ω
(U+2126 OHM SIGN) is mapped by toUppercase to itself but by toCasefold to
ω
(U+03C9 GREEK SMALL LETTER OMEGA) along with
Ω
(U+03A9 GREEK CAPITAL LETTER OMEGA), so
"\u2126"
is matched by
/[ω]/ui
and
/[\u03A9]/ui
but not by
/[ω]/i
or
/[\u03A9]/i
. Also, no code point outside the Basic Latin block is mapped to a code point within it, so strings such as
"\u017F ſ"
and
"\u212A K"
are not matched by
/[a-z]/i
.
22.2.2.7.4
UpdateModifiers (
rer
,
add
,
remove
)
The abstract operation UpdateModifiers takes arguments
rer
(a
RegExp Record
),
add
(a String), and
remove
(a String) and returns a
RegExp Record
. It performs the following steps when called:
Assert
:
add
and
remove
have no elements in common.
Let
ignoreCase
be
rer
.
[[IgnoreCase]]
.
Let
multiline
be
rer
.
[[Multiline]]
.
Let
dotAll
be
rer
.
[[DotAll]]
.
Let
unicode
be
rer
.
[[Unicode]]
.
Let
unicodeSets
be
rer
.
[[UnicodeSets]]
.
Let
capturingGroupsCount
be
rer
.
[[CapturingGroupsCount]]
.
If
remove
contains
"i"
, set
ignoreCase
to
false
.
Else if
add
contains
"i"
, set
ignoreCase
to
true
.
If
remove
contains
"m"
, set
multiline
to
false
.
Else if
add
contains
"m"
, set
multiline
to
true
.
If
remove
contains
"s"
, set
dotAll
to
false
.
Else if
add
contains
"s"
, set
dotAll
to
true
.
Return the
RegExp Record
{
[[IgnoreCase]]
:
ignoreCase
,
[[Multiline]]
:
multiline
,
[[DotAll]]
:
dotAll
,
[[Unicode]]
:
unicode
,
[[UnicodeSets]]
:
unicodeSets
,
[[CapturingGroupsCount]]
:
capturingGroupsCount
}.
22.2.2.8
Runtime Semantics: CompileCharacterClass
The
syntax-directed operation
CompileCharacterClass takes argument
rer
(a
RegExp Record
) and returns a
Record
with fields
[[CharSet]]
(a
CharSet
) and
[[Invert]]
(a Boolean). It is defined piecewise over the following productions:
CharacterClass
::
[
ClassContents
]
Let
A
be
CompileToCharSet
of
ClassContents
with argument
rer
.
Return the
Record
{
[[CharSet]]
:
A
,
[[Invert]]
:
false
}.
CharacterClass
::
[^
ClassContents
]
Let
A
be
CompileToCharSet
of
ClassContents
with argument
rer
.
If
rer
.
[[UnicodeSets]]
is
true
, then
Return the
Record
{
[[CharSet]]
:
CharacterComplement
(
rer
,
A
),
[[Invert]]
:
false
}.
Return the
Record
{
[[CharSet]]
:
A
,
[[Invert]]
:
true
}.
22.2.2.9
Runtime Semantics: CompileToCharSet
The
syntax-directed operation
CompileToCharSet takes argument
rer
(a
RegExp Record
) and returns a
CharSet
.
Note 1
This section is amended in
B.1.2.8
.
It is defined piecewise over the following productions:
ClassContents
::
[empty]
Return the empty
CharSet
.
NonemptyClassRanges
::
ClassAtom
NonemptyClassRangesNoDash
Let
A
be
CompileToCharSet
of
ClassAtom
with argument
rer
.
Let
B
be
CompileToCharSet
of
NonemptyClassRangesNoDash
with argument
rer
.
Return the union of
CharSets
A
and
B
.
NonemptyClassRanges
::
ClassAtom
-
ClassAtom
ClassContents
Let
A
be
CompileToCharSet
of the first
ClassAtom
with argument
rer
.
Let
B
be
CompileToCharSet
of the second
ClassAtom
with argument
rer
.
Let
C
be
CompileToCharSet
of
ClassContents
with argument
rer
.
Let
D
be
CharacterRange
(
A
,
B
).
Return the union of
D
and
C
.
NonemptyClassRangesNoDash
::
ClassAtomNoDash
NonemptyClassRangesNoDash
Let
A
be
CompileToCharSet
of
ClassAtomNoDash
with argument
rer
.
Let
B
be
CompileToCharSet
of
NonemptyClassRangesNoDash
with argument
rer
.
Return the union of
CharSets
A
and
B
.
NonemptyClassRangesNoDash
::
ClassAtomNoDash
-
ClassAtom
ClassContents
Let
A
be
CompileToCharSet
of
ClassAtomNoDash
with argument
rer
.
Let
B
be
CompileToCharSet
of
ClassAtom
with argument
rer
.
Let
C
be
CompileToCharSet
of
ClassContents
with argument
rer
.
Let
D
be
CharacterRange
(
A
,
B
).
Return the union of
D
and
C
.
Note 2
ClassContents
can expand into a single
ClassAtom
and/or ranges of two
ClassAtom
separated by dashes. In the latter case the
ClassContents
includes all characters between the first
ClassAtom
and the second
ClassAtom
, inclusive; an error occurs if either
ClassAtom
does not represent a single character (for example, if one is \w) or if the first
ClassAtom
's character value is strictly greater than the second
ClassAtom
's character value.
Note 3
Even if the pattern ignores case, the case of the two ends of a range is significant in determining which characters belong to the range. Thus, for example, the pattern
/[E-F]/i
matches only the letters
E
,
F
,
e
, and
f
, while the pattern
/[E-f]/i
matches all uppercase and lowercase letters in the Unicode Basic Latin block as well as the symbols
[
,
\
,
]
,
^
,
_
, and
`
.
Note 4
A
-
character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of
ClassContents
, the beginning or end limit of a range specification, or immediately follows a range specification.
ClassAtom
::
-
Return the
CharSet
containing the single character
-
U+002D (HYPHEN-MINUS).
ClassAtomNoDash
::
SourceCharacter
but not one of
\
or
]
or
-
Return the
CharSet
containing the character matched by
SourceCharacter
.
ClassEscape
::
b
-
CharacterEscape
Let
cv
be the
CharacterValue
of this
ClassEscape
.
Let
c
be the character whose character value is
cv
.
Return the
CharSet
containing the single character
c
.
Note 5
A
ClassAtom
can use any of the escape sequences that are allowed in the rest of the regular expression except for
\b
,
\B
, and backreferences. Inside a
CharacterClass
,
\b
means the backspace character, while
\B
and backreferences raise errors. Using a backreference inside a
ClassAtom
causes an error.
CharacterClassEscape
::
d
Return the ten-element
CharSet
containing the characters
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
, and
9
.
CharacterClassEscape
::
D
Let
S
be the
CharSet
returned by
CharacterClassEscape
::
d
.
Return
CharacterComplement
(
rer
,
S
).
CharacterClassEscape
::
s
Return the
CharSet
containing all characters corresponding to a code point on the right-hand side of the
WhiteSpace
or
LineTerminator
productions.
CharacterClassEscape
::
S
Let
S
be the
CharSet
returned by
CharacterClassEscape
::
s
.
Return
CharacterComplement
(
rer
,
S
).
CharacterClassEscape
::
w
Return
MaybeSimpleCaseFolding
(
rer
,
WordCharacters
(
rer
)).
CharacterClassEscape
::
W
Let
S
be the
CharSet
returned by
CharacterClassEscape
::
w
.
Return
CharacterComplement
(
rer
,
S
).
CharacterClassEscape
::
p{
UnicodePropertyValueExpression
}
Return
CompileToCharSet
of
UnicodePropertyValueExpression
with argument
rer
.
CharacterClassEscape
::
P{
UnicodePropertyValueExpression
}
Let
S
be
CompileToCharSet
of
UnicodePropertyValueExpression
with argument
rer
.
Assert
:
S
contains only single code points.
Return
CharacterComplement
(
rer
,
S
).
UnicodePropertyValueExpression
::
UnicodePropertyName
=
UnicodePropertyValue
Let
ps
be the
source text matched by
UnicodePropertyName
.
Let
p
be
UnicodeMatchProperty
(
rer
,
ps
).
Assert
:
p
is a
Unicode property name
or property alias listed in the “
Property name and aliases
” column of
Table 64
.
Let
vs
be the
source text matched by
UnicodePropertyValue
.
Let
v
be
UnicodeMatchPropertyValue
(
p
,
vs
).
Let
A
be the
CharSet
containing all Unicode code points whose character database definition includes the property
p
with value
v
.
Return
MaybeSimpleCaseFolding
(
rer
,
A
).
UnicodePropertyValueExpression
::
LoneUnicodePropertyNameOrValue
Let
s
be the
source text matched by
LoneUnicodePropertyNameOrValue
.
If
UnicodeMatchPropertyValue
(
General_Category
,
s
) is a Unicode property value or property value alias for the General_Category (gc) property listed in
PropertyValueAliases.txt
, then
Return the
CharSet
containing all Unicode code points whose character database definition includes the property “General_Category” with value
s
.
Let
p
be
UnicodeMatchProperty
(
rer
,
s
).
Assert
:
p
is a binary Unicode property or binary property alias listed in the “
Property name and aliases
” column of
Table 65
, or a binary Unicode property of strings listed in the “
Property name
” column of
Table 66
.
Let
A
be the
CharSet
containing all CharSetElements whose character database definition includes the property
p
with value “True”.
Return
MaybeSimpleCaseFolding
(
rer
,
A
).
ClassUnion
::
ClassSetRange
ClassUnion
opt
Let
A
be
CompileToCharSet
of
ClassSetRange
with argument
rer
.
If
ClassUnion
is present, then
Let
B
be
CompileToCharSet
of
ClassUnion
with argument
rer
.
Return the union of
CharSets
A
and
B
.
Return
A
.
ClassUnion
::
ClassSetOperand
ClassUnion
opt
Let
A
be
CompileToCharSet
of
ClassSetOperand
with argument
rer
.
If
ClassUnion
is present, then
Let
B
be
CompileToCharSet
of
ClassUnion
with argument
rer
.
Return the union of
CharSets
A
and
B
.
Return
A
.
ClassIntersection
::
ClassSetOperand
&&
ClassSetOperand
Let
A
be
CompileToCharSet
of the first
ClassSetOperand
with argument
rer
.
Let
B
be
CompileToCharSet
of the second
ClassSetOperand
with argument
rer
.
Return the intersection of
CharSets
A
and
B
.
ClassIntersection
::
ClassIntersection
&&
ClassSetOperand
Let
A
be
CompileToCharSet
of the
ClassIntersection
with argument
rer
.
Let
B
be
CompileToCharSet
of the
ClassSetOperand
with argument
rer
.
Return the intersection of
CharSets
A
and
B
.
ClassSubtraction
::
ClassSetOperand
--
ClassSetOperand
Let
A
be
CompileToCharSet
of the first
ClassSetOperand
with argument
rer
.
Let
B
be
CompileToCharSet
of the second
ClassSetOperand
with argument
rer
.
Return the
CharSet
containing the CharSetElements of
A
which are not also CharSetElements of
B
.
ClassSubtraction
::
ClassSubtraction
--
ClassSetOperand
Let
A
be
CompileToCharSet
of the
ClassSubtraction
with argument
rer
.
Let
B
be
CompileToCharSet
of the
ClassSetOperand
with argument
rer
.
Return the
CharSet
containing the CharSetElements of
A
which are not also CharSetElements of
B
.
ClassSetRange
::
ClassSetCharacter
-
ClassSetCharacter
Let
A
be
CompileToCharSet
of the first
ClassSetCharacter
with argument
rer
.
Let
B
be
CompileToCharSet
of the second
ClassSetCharacter
with argument
rer
.
Return
MaybeSimpleCaseFolding
(
rer
,
CharacterRange
(
A
,
B
)).
Note 6
The result will often consist of two or more ranges. When UnicodeSets is
true
and IgnoreCase is
true
, then
MaybeSimpleCaseFolding
(
rer
, [Ā-č]) will include only the odd-numbered code points of that range.
ClassSetOperand
::
ClassSetCharacter
Let
A
be
CompileToCharSet
of
ClassSetCharacter
with argument
rer
.
Return
MaybeSimpleCaseFolding
(
rer
,
A
).
ClassSetOperand
::
ClassStringDisjunction
Let
A
be
CompileToCharSet
of
ClassStringDisjunction
with argument
rer
.
Return
MaybeSimpleCaseFolding
(
rer
,
A
).
ClassSetOperand
::
NestedClass
Return
CompileToCharSet
of
NestedClass
with argument
rer
.
NestedClass
::
[
ClassContents
]
Return
CompileToCharSet
of
ClassContents
with argument
rer
.
NestedClass
::
[^
ClassContents
]
Let
A
be
CompileToCharSet
of
ClassContents
with argument
rer
.
Return
CharacterComplement
(
rer
,
A
).
NestedClass
::
\
CharacterClassEscape
Return
CompileToCharSet
of
CharacterClassEscape
with argument
rer
.
ClassStringDisjunction
::
\q{
ClassStringDisjunctionContents
}
Return
CompileToCharSet
of
ClassStringDisjunctionContents
with argument
rer
.
ClassStringDisjunctionContents
::
ClassString
Let
s
be
CompileClassSetString
of
ClassString
with argument
rer
.
Return the
CharSet
containing the one string
s
.
ClassStringDisjunctionContents
::
ClassString
|
ClassStringDisjunctionContents
Let
s
be
CompileClassSetString
of
ClassString
with argument
rer
.
Let
A
be the
CharSet
containing the one string
s
.
Let
B
be
CompileToCharSet
of
ClassStringDisjunctionContents
with argument
rer
.
Return the union of
CharSets
A
and
B
.
ClassSetCharacter
::
SourceCharacter
but not
ClassSetSyntaxCharacter
\
CharacterEscape
\
ClassSetReservedPunctuator
Let
cv
be the
CharacterValue
of this
ClassSetCharacter
.
Let
c
be the character whose character value is
cv
.
Return the
CharSet
containing the single character
c
.
ClassSetCharacter
::
\b
Return the
CharSet
containing the single character U+0008 (BACKSPACE).
22.2.2.9.1
CharacterRange (
A
,
B
)
The abstract operation CharacterRange takes arguments
A
(a
CharSet
) and
B
(a
CharSet
) and returns a
CharSet
. It performs the following steps when called:
Assert
:
A
and
B
each contain exactly one character.
Let
a
be the one character in
CharSet
A
.
Let
b
be the one character in
CharSet
B
.
Let
i
be the character value of character
a
.
Let
j
be the character value of character
b
.
Assert
:
i
≤
j
.
Return the
CharSet
containing all characters with a character value in the
inclusive interval
from
i
to
j
.
22.2.2.9.2
HasEitherUnicodeFlag (
rer
)
The abstract operation HasEitherUnicodeFlag takes argument
rer
(a
RegExp Record
) and returns a Boolean. It performs the following steps when called:
If
rer
.
[[Unicode]]
is
true
or
rer
.
[[UnicodeSets]]
is
true
, then
Return
true
.
Return
false
.
22.2.2.9.3
WordCharacters (
rer
)
The abstract operation WordCharacters takes argument
rer
(a
RegExp Record
) and returns a
CharSet
. Returns a
CharSet
containing the characters considered "word characters" for the purposes of
\b
,
\B
,
\w
, and
\W
It performs the following steps when called:
Let
basicWordChars
be the
CharSet
containing every character in
the ASCII word characters
.
Let
extraWordChars
be the
CharSet
containing all characters
c
such that
c
is not in
basicWordChars
but
Canonicalize
(
rer
,
c
) is in
basicWordChars
.
Assert
:
extraWordChars
is empty unless
HasEitherUnicodeFlag
(
rer
) is
true
and
rer
.
[[IgnoreCase]]
is
true
.
Return the union of
basicWordChars
and
extraWordChars
.
22.2.2.9.4
AllCharacters (
rer
)
The abstract operation AllCharacters takes argument
rer
(a
RegExp Record
) and returns a
CharSet
. Returns the set of “all characters” according to the regular expression flags. It performs the following steps when called:
If
rer
.
[[UnicodeSets]]
is
true
and
rer
.
[[IgnoreCase]]
is
true
, then
Return the
CharSet
containing all Unicode code points
c
that do not have a
Simple Case Folding
mapping (that is,
scf
(
c
)=
c
).
Else if
HasEitherUnicodeFlag
(
rer
) is
true
, then
Return the
CharSet
containing all code point values.
Else,
Return the
CharSet
containing all code unit values.
22.2.2.9.5
MaybeSimpleCaseFolding (
rer
,
A
)
The abstract operation MaybeSimpleCaseFolding takes arguments
rer
(a
RegExp Record
) and
A
(a
CharSet
) and returns a
CharSet
. If
rer
.
[[UnicodeSets]]
is
false
or
rer
.
[[IgnoreCase]]
is
false
, it returns
A
. Otherwise, it uses the
Simple Case Folding
(
scf(
cp
)
) definitions in the file
CaseFolding.txt
of the Unicode Character Database (each of which maps a single code point to another single code point) to map each
CharSetElement
of
A
character-by-character into a canonical form and returns the resulting
CharSet
. It performs the following steps when called:
If
rer
.
[[UnicodeSets]]
is
false
or
rer
.
[[IgnoreCase]]
is
false
, return
A
.
Let
B
be a new empty
CharSet
.
For each
CharSetElement
s
of
A
, do
Let
t
be an empty sequence of characters.
For each single code point
cp
in
s
, do
Append
scf
(
cp
) to
t
.
Add
t
to
B
.
Return
B
.
22.2.2.9.6
CharacterComplement (
rer
,
S
)
The abstract operation CharacterComplement takes arguments
rer
(a
RegExp Record
) and
S
(a
CharSet
) and returns a
CharSet
. It performs the following steps when called:
Let
A
be
AllCharacters
(
rer
).
Return the
CharSet
containing the CharSetElements of
A
which are not also CharSetElements of
S
.
22.2.2.9.7
UnicodeMatchProperty (
rer
,
p
)
The abstract operation UnicodeMatchProperty takes arguments
rer
(a
RegExp Record
) and
p
(
ECMAScript source text
) and returns a
Unicode property name
. It performs the following steps when called:
If
rer
.
[[UnicodeSets]]
is
true
and
p
is a
Unicode property name
listed in the “
Property name
” column of
Table 66
, then
Return the
List
of Unicode code points
p
.
Assert
:
p
is a
Unicode property name
or property alias listed in the “
Property name and aliases
” column of
Table 64
or
Table 65
.
Let
c
be the canonical
property name
of
p
as given in the “
Canonical property name
” column of the corresponding row.
Return the
List
of Unicode code points
c
.
Implementations must support the
Unicode property names
and aliases listed in
Table 64
,
Table 65
, and
Table 66
. To ensure interoperability, implementations must not support any other
property names
or aliases.
Note 1
For example,
Script_Extensions
(
property name
) and
scx
(property alias) are valid, but
script_extensions
or
Scx
aren't.
Note 2
The listed properties form a superset of what
UTS18 RL1.2
requires.
Note 3
The spellings of entries in these tables (including casing) match the spellings used in the file
PropertyAliases.txt
in the Unicode Character Database. The precise spellings in that file are
guaranteed to be stable
.
Table 64: Non-binary Unicode property aliases and their canonical
property names
Property name and aliases
Canonical property name
General_Category
General_Category
gc
Script
Script
sc
Script_Extensions
Script_Extensions
scx
Table 65: Binary Unicode property aliases and their canonical
property names
Property name and aliases
Canonical property name
ASCII
ASCII
ASCII_Hex_Digit
ASCII_Hex_Digit
AHex
Alphabetic
Alphabetic
Alpha
Any
Any
Assigned
Assigned
Bidi_Control
Bidi_Control
Bidi_C
Bidi_Mirrored
Bidi_Mirrored
Bidi_M
Case_Ignorable
Case_Ignorable
CI
Cased
Cased
Changes_When_Casefolded
Changes_When_Casefolded
CWCF
Changes_When_Casemapped
Changes_When_Casemapped
CWCM
Changes_When_Lowercased
Changes_When_Lowercased
CWL
Changes_When_NFKC_Casefolded
Changes_When_NFKC_Casefolded
CWKCF
Changes_When_Titlecased
Changes_When_Titlecased
CWT
Changes_When_Uppercased
Changes_When_Uppercased
CWU
Dash
Dash
Default_Ignorable_Code_Point
Default_Ignorable_Code_Point
DI
Deprecated
Deprecated
Dep
Diacritic
Diacritic
Dia
Emoji
Emoji
Emoji_Component
Emoji_Component
EComp
Emoji_Modifier
Emoji_Modifier
EMod
Emoji_Modifier_Base
Emoji_Modifier_Base
EBase
Emoji_Presentation
Emoji_Presentation
EPres
Extended_Pictographic
Extended_Pictographic
ExtPict
Extender
Extender
Ext
Grapheme_Base
Grapheme_Base
Gr_Base
Grapheme_Extend
Grapheme_Extend
Gr_Ext
Hex_Digit
Hex_Digit
Hex
IDS_Binary_Operator
IDS_Binary_Operator
IDSB
IDS_Trinary_Operator
IDS_Trinary_Operator
IDST
ID_Continue
ID_Continue
IDC
ID_Start
ID_Start
IDS
Ideographic
Ideographic
Ideo
Join_Control
Join_Control
Join_C
Logical_Order_Exception
Logical_Order_Exception
LOE
Lowercase
Lowercase
Lower
Math
Math
Noncharacter_Code_Point
Noncharacter_Code_Point
NChar
Pattern_Syntax
Pattern_Syntax
Pat_Syn
Pattern_White_Space
Pattern_White_Space
Pat_WS
Quotation_Mark
Quotation_Mark
QMark
Radical
Radical
Regional_Indicator
Regional_Indicator
RI
Sentence_Terminal
Sentence_Terminal
STerm
Soft_Dotted
Soft_Dotted
SD
Terminal_Punctuation
Terminal_Punctuation
Term
Unified_Ideograph
Unified_Ideograph
UIdeo
Uppercase
Uppercase
Upper
Variation_Selector
Variation_Selector
VS
White_Space
White_Space
space
XID_Continue
XID_Continue
XIDC
XID_Start
XID_Start
XIDS
Table 66: Binary Unicode properties of strings
Property name
Basic_Emoji
Emoji_Keycap_Sequence
RGI_Emoji_Modifier_Sequence
RGI_Emoji_Flag_Sequence
RGI_Emoji_Tag_Sequence
RGI_Emoji_ZWJ_Sequence
RGI_Emoji
22.2.2.9.8
UnicodeMatchPropertyValue (
p
,
v
)
The abstract operation UnicodeMatchPropertyValue takes arguments
p
(
ECMAScript source text
) and
v
(
ECMAScript source text
) and returns a Unicode property value. It performs the following steps when called:
Assert
:
p
is a canonical, unaliased
Unicode property name
listed in the “
Canonical property name
” column of
Table 64
.
Assert
:
v
is a property value or property value alias for the Unicode property
p
listed in
PropertyValueAliases.txt
.
Let
value
be the canonical property value of
v
as given in the “Canonical property value” column of the corresponding row.
Return the
List
of Unicode code points
value
.
Implementations must support the Unicode property values and property value aliases listed in
PropertyValueAliases.txt
for the properties listed in
Table 64
. To ensure interoperability, implementations must not support any other property values or property value aliases.
Note 1
For example,
Xpeo
and
Old_Persian
are valid
Script_Extensions
values, but
xpeo
and
Old Persian
aren't.
Note 2
This algorithm differs from
the matching rules for symbolic values listed in UAX44
: case,
white space
, U+002D (HYPHEN-MINUS), and U+005F (LOW LINE) are not ignored, and the
Is
prefix is not supported.
22.2.2.10
Runtime Semantics: CompileClassSetString
The
syntax-directed operation
CompileClassSetString takes argument
rer
(a
RegExp Record
) and returns a sequence of characters. It is defined piecewise over the following productions:
ClassString
::
[empty]
Return an empty sequence of characters.
ClassString
::
NonEmptyClassString
Return
CompileClassSetString
of
NonEmptyClassString
with argument
rer
.
NonEmptyClassString
::
ClassSetCharacter
NonEmptyClassString
opt
Let
cs
be
CompileToCharSet
of
ClassSetCharacter
with argument
rer
.
Let
s1
be the sequence of characters that is the single
CharSetElement
of
cs
.
If
NonEmptyClassString
is present, then
Let
s2
be
CompileClassSetString
of
NonEmptyClassString
with argument
rer
.
Return the concatenation of
s1
and
s2
.
Return
s1
.
22.2.3
Abstract Operations for RegExp Creation
22.2.3.1
RegExpCreate (
P
,
F
)
The abstract operation RegExpCreate takes arguments
P
(an
ECMAScript language value
) and
F
(a String or
undefined
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
Let
obj
be !
RegExpAlloc
(
%RegExp%
).
Return ?
RegExpInitialize
(
obj
,
P
,
F
).
22.2.3.2
RegExpAlloc (
newTarget
)
The abstract operation RegExpAlloc takes argument
newTarget
(a
constructor
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
Let
obj
be ?
OrdinaryCreateFromConstructor
(
newTarget
,
"%RegExp.prototype%"
, «
[[OriginalSource]]
,
[[OriginalFlags]]
,
[[RegExpRecord]]
,
[[RegExpMatcher]]
»).
Perform !
DefinePropertyOrThrow
(
obj
,
"lastIndex"
, PropertyDescriptor {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}).
Return
obj
.
22.2.3.3
RegExpInitialize (
obj
,
pattern
,
flags
)
The abstract operation RegExpInitialize takes arguments
obj
(an Object),
pattern
(an
ECMAScript language value
), and
flags
(an
ECMAScript language value
) and returns either a
normal completion containing
an Object or a
throw completion
. It performs the following steps when called:
If
pattern
is
undefined
, let
P
be the empty String.
Else, let
P
be ?
ToString
(
pattern
).
If
flags
is
undefined
, let
F
be the empty String.
Else, let
F
be ?
ToString
(
flags
).
If
F
contains any code unit other than
"d"
,
"g"
,
"i"
,
"m"
,
"s"
,
"u"
,
"v"
, or
"y"
, or if
F
contains any code unit more than once, throw a
SyntaxError
exception.
If
F
contains
"i"
, let
i
be
true
; else let
i
be
false
.
If
F
contains
"m"
, let
m
be
true
; else let
m
be
false
.
If
F
contains
"s"
, let
s
be
true
; else let
s
be
false
.
If
F
contains
"u"
, let
u
be
true
; else let
u
be
false
.
If
F
contains
"v"
, let
v
be
true
; else let
v
be
false
.
If
u
is
true
or
v
is
true
, then
Let
patternText
be
StringToCodePoints
(
P
).
Else,
Let
patternText
be the result of interpreting each of
P
's 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.
Let
parseResult
be
ParsePattern
(
patternText
,
u
,
v
).
If
parseResult
is a non-empty
List
of
SyntaxError
objects, throw a
SyntaxError
exception.
Assert
:
parseResult
is a
Pattern
Parse Node
.
Set
obj
.
[[OriginalSource]]
to
P
.
Set
obj
.
[[OriginalFlags]]
to
F
.
Let
capturingGroupsCount
be
CountLeftCapturingParensWithin
(
parseResult
).
Let
rer
be the
RegExp Record
{
[[IgnoreCase]]
:
i
,
[[Multiline]]
:
m
,
[[DotAll]]
:
s
,
[[Unicode]]
:
u
,
[[UnicodeSets]]
:
v
,
[[CapturingGroupsCount]]
:
capturingGroupsCount
}.
Set
obj
.
[[RegExpRecord]]
to
rer
.
Set
obj
.
[[RegExpMatcher]]
to
CompilePattern
of
parseResult
with argument
rer
.
Perform ?
Set
(
obj
,
"lastIndex"
,
+0
𝔽
,
true
).
Return
obj
.
22.2.3.4
Static Semantics: ParsePattern (
patternText
,
u
,
v
)
The abstract operation ParsePattern takes arguments
patternText
(a sequence of Unicode code points),
u
(a Boolean), and
v
(a Boolean) and returns a
Parse Node
or a non-empty
List
of
SyntaxError
objects.
Note
This section is amended in
B.1.2.9
.
It performs the following steps when called:
If
v
is
true
and
u
is
true
, then
Let
parseResult
be a
List
containing one or more
SyntaxError
objects.
Else if
v
is
true
, then
Let
parseResult
be
ParseText
(
patternText
,
Pattern
[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]
).
Else if
u
is
true
, then
Let
parseResult
be
ParseText
(
patternText
,
Pattern
[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]
).
Else,
Let
parseResult
be
ParseText
(
patternText
,
Pattern
[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]
).
Return
parseResult
.
22.2.4
The RegExp Constructor
The RegExp
constructor
:
is
%RegExp%
.
is the initial value of the
"RegExp"
property of the
global object
.
creates and initializes a new RegExp object when called as a
constructor
.
when called as a function rather than as a
constructor
, returns either a new RegExp object, or the argument itself if the only argument is a RegExp object.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified RegExp behaviour must include a
super
call to the RegExp
constructor
to create and initialize subclass instances with the necessary internal slots.
22.2.4.1
RegExp (
pattern
,
flags
)
This function performs the following steps when called:
Let
patternIsRegExp
be ?
IsRegExp
(
pattern
).
If NewTarget is
undefined
, then
Let
newTarget
be the
active function object
.
If
patternIsRegExp
is
true
and
flags
is
undefined
, then
Let
patternConstructor
be ?
Get
(
pattern
,
"constructor"
).
If
SameValue
(
newTarget
,
patternConstructor
) is
true
, return
pattern
.
Else,
Let
newTarget
be NewTarget.
If
pattern
is an Object
and
pattern
has a
[[RegExpMatcher]]
internal slot, then
Let
P
be
pattern
.
[[OriginalSource]]
.
If
flags
is
undefined
, let
F
be
pattern
.
[[OriginalFlags]]
.
Else, let
F
be
flags
.
Else if
patternIsRegExp
is
true
, then
Let
P
be ?
Get
(
pattern
,
"source"
).
If
flags
is
undefined
, then
Let
F
be ?
Get
(
pattern
,
"flags"
).
Else,
Let
F
be
flags
.
Else,
Let
P
be
pattern
.
Let
F
be
flags
.
Let
O
be ?
RegExpAlloc
(
newTarget
).
Return ?
RegExpInitialize
(
O
,
P
,
F
).
Note
If pattern is supplied using a
StringLiteral
, the usual escape sequence substitutions are performed before the String is processed by this function. If pattern must contain an escape sequence to be recognized by this function, any U+005C (REVERSE SOLIDUS) code points must be escaped within the
StringLiteral
to prevent them being removed when the contents of the
StringLiteral
are formed.
22.2.5
Properties of the RegExp Constructor
The RegExp
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
22.2.5.1
RegExp.escape (
S
)
This function returns a copy of
S
in which characters that are potentially special in a regular expression
Pattern
have been replaced by equivalent escape sequences.
It performs the following steps when called:
If
S
is not a String
, throw a
TypeError
exception.
Let
escaped
be the empty String.
Let
cpList
be
StringToCodePoints
(
S
).
For each code point
cp
of
cpList
, do
If
escaped
is the empty String and
cp
is matched by either
DecimalDigit
or
AsciiLetter
, then
NOTE: Escaping a leading digit ensures that output corresponds with pattern text which may be used after a
\0
character escape or a
DecimalEscape
such as
\1
and still match
S
rather than be interpreted as an extension of the preceding escape sequence. Escaping a leading ASCII letter does the same for the context after
\c
.
Let
numericValue
be the numeric value of
cp
.
Let
hex
be
Number::toString
(
𝔽
(
numericValue
), 16).
Assert
: The length of
hex
is 2.
Set
escaped
to the
string-concatenation
of the code unit 0x005C (REVERSE SOLIDUS),
"x"
, and
hex
.
Else,
Set
escaped
to the
string-concatenation
of
escaped
and
EncodeForRegExpEscape
(
cp
).
Return
escaped
.
Note
Despite having similar names,
EscapeRegExpPattern
and
RegExp.escape
do not perform similar actions. The former escapes a pattern for representation as a string, while this function escapes a string for representation inside a pattern.
22.2.5.1.1
EncodeForRegExpEscape (
cp
)
The abstract operation EncodeForRegExpEscape takes argument
cp
(a code point) and returns a String. It returns a String representing a
Pattern
for matching
cp
. If
cp
is white space or an ASCII punctuator, the returned value is an escape sequence. Otherwise, the returned value
is a String
representation of
cp
itself. It performs the following steps when called:
If
cp
is matched by
SyntaxCharacter
or
cp
is U+002F (SOLIDUS), then
Return the
string-concatenation
of 0x005C (REVERSE SOLIDUS) and
UTF16EncodeCodePoint
(
cp
).
Else if
cp
is a code point listed in the “Code Point” column of
Table 62
, then
Return the
string-concatenation
of 0x005C (REVERSE SOLIDUS) and the string in the “ControlEscape” column of the row whose “Code Point” column contains
cp
.
Let
otherPunctuators
be the
string-concatenation
of
",-=<>#&!%:;@~'`"
and the code unit 0x0022 (QUOTATION MARK).
Let
toEscape
be
StringToCodePoints
(
otherPunctuators
).
If
toEscape
contains
cp
,
cp
is matched by either
WhiteSpace
or
LineTerminator
, or
cp
has the same numeric value as a
leading surrogate
or
trailing surrogate
, then
Let
cpNum
be the numeric value of
cp
.
If
cpNum
≤ 0xFF, then
Let
hex
be
Number::toString
(
𝔽
(
cpNum
), 16).
Return the
string-concatenation
of the code unit 0x005C (REVERSE SOLIDUS),
"x"
, and
StringPad
(
hex
, 2,
"0"
,
start
).
Let
escaped
be the empty String.
Let
codeUnits
be
UTF16EncodeCodePoint
(
cp
).
For each code unit
cu
of
codeUnits
, do
Set
escaped
to the
string-concatenation
of
escaped
and
UnicodeEscape
(
cu
).
Return
escaped
.
Return
UTF16EncodeCodePoint
(
cp
).
22.2.5.2
RegExp.prototype
The initial value of
RegExp.prototype
is the
RegExp prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
22.2.5.3
get RegExp [ %Symbol.species% ]
RegExp[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
Note
RegExp prototype methods normally use their
this
value's
constructor
to create a derived object. However, a subclass
constructor
may over-ride that default behaviour by redefining its
%Symbol.species%
property.
22.2.6
Properties of the RegExp Prototype Object
The
RegExp prototype object
:
is
%RegExp.prototype%
.
is an
ordinary object
.
is not a RegExp instance and does not have a
[[RegExpMatcher]]
internal slot or any of the other internal slots of RegExp instance objects.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
Note
The RegExp prototype object does not have a
"valueOf"
property of its own; however, it inherits the
"valueOf"
property from the
Object prototype object
.
22.2.6.1
RegExp.prototype.constructor
The initial value of
RegExp.prototype.constructor
is
%RegExp%
.
22.2.6.2
RegExp.prototype.exec (
string
)
This method searches
string
for an occurrence of the regular expression pattern and returns an Array containing the results of the match, or
null
if
string
did not match.
It performs the following steps when called:
Let
R
be the
this
value.
Perform ?
RequireInternalSlot
(
R
,
[[RegExpMatcher]]
).
Let
S
be ?
ToString
(
string
).
Return ?
RegExpBuiltinExec
(
R
,
S
).
22.2.6.3
get RegExp.prototype.dotAll
RegExp.prototype.dotAll
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x0073 (LATIN SMALL LETTER S).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.6.4
get RegExp.prototype.flags
RegExp.prototype.flags
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
If
R
is not an Object
, throw a
TypeError
exception.
Let
codeUnits
be a new empty
List
.
Let
hasIndices
be
ToBoolean
(?
Get
(
R
,
"hasIndices"
)).
If
hasIndices
is
true
, append the code unit 0x0064 (LATIN SMALL LETTER D) to
codeUnits
.
Let
global
be
ToBoolean
(?
Get
(
R
,
"global"
)).
If
global
is
true
, append the code unit 0x0067 (LATIN SMALL LETTER G) to
codeUnits
.
Let
ignoreCase
be
ToBoolean
(?
Get
(
R
,
"ignoreCase"
)).
If
ignoreCase
is
true
, append the code unit 0x0069 (LATIN SMALL LETTER I) to
codeUnits
.
Let
multiline
be
ToBoolean
(?
Get
(
R
,
"multiline"
)).
If
multiline
is
true
, append the code unit 0x006D (LATIN SMALL LETTER M) to
codeUnits
.
Let
dotAll
be
ToBoolean
(?
Get
(
R
,
"dotAll"
)).
If
dotAll
is
true
, append the code unit 0x0073 (LATIN SMALL LETTER S) to
codeUnits
.
Let
unicode
be
ToBoolean
(?
Get
(
R
,
"unicode"
)).
If
unicode
is
true
, append the code unit 0x0075 (LATIN SMALL LETTER U) to
codeUnits
.
Let
unicodeSets
be
ToBoolean
(?
Get
(
R
,
"unicodeSets"
)).
If
unicodeSets
is
true
, append the code unit 0x0076 (LATIN SMALL LETTER V) to
codeUnits
.
Let
sticky
be
ToBoolean
(?
Get
(
R
,
"sticky"
)).
If
sticky
is
true
, append the code unit 0x0079 (LATIN SMALL LETTER Y) to
codeUnits
.
Return the String value whose code units are the elements of the
List
codeUnits
. If
codeUnits
has no elements, the empty String is returned.
22.2.6.4.1
RegExpHasFlag (
R
,
codeUnit
)
The abstract operation RegExpHasFlag takes arguments
R
(an
ECMAScript language value
) and
codeUnit
(a code unit) and returns either a
normal completion containing
either a Boolean or
undefined
, or a
throw completion
. It performs the following steps when called:
If
R
is not an Object
, throw a
TypeError
exception.
If
R
does not have an
[[OriginalFlags]]
internal slot, then
If
SameValue
(
R
,
%RegExp.prototype%
) is
true
, return
undefined
.
Otherwise, throw a
TypeError
exception.
Let
flags
be
R
.
[[OriginalFlags]]
.
If
flags
contains
codeUnit
, return
true
.
Return
false
.
22.2.6.5
get RegExp.prototype.global
RegExp.prototype.global
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x0067 (LATIN SMALL LETTER G).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.6.6
get RegExp.prototype.hasIndices
RegExp.prototype.hasIndices
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x0064 (LATIN SMALL LETTER D).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.6.7
get RegExp.prototype.ignoreCase
RegExp.prototype.ignoreCase
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x0069 (LATIN SMALL LETTER I).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.6.8
RegExp.prototype [ %Symbol.match% ] (
string
)
This method performs the following steps when called:
Let
rx
be the
this
value.
If
rx
is not an Object
, throw a
TypeError
exception.
Let
S
be ?
ToString
(
string
).
Let
flags
be ?
ToString
(?
Get
(
rx
,
"flags"
)).
If
flags
does not contain
"g"
, then
Return ?
RegExpExec
(
rx
,
S
).
Else,
If
flags
contains
"u"
or
flags
contains
"v"
, let
fullUnicode
be
true
; otherwise let
fullUnicode
be
false
.
Perform ?
Set
(
rx
,
"lastIndex"
,
+0
𝔽
,
true
).
Let
A
be !
ArrayCreate
(0).
Let
n
be 0.
Repeat,
Let
result
be ?
RegExpExec
(
rx
,
S
).
If
result
is
null
, then
If
n
= 0, return
null
.
Return
A
.
Else,
Let
matchStr
be ?
ToString
(?
Get
(
result
,
"0"
)).
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
n
)),
matchStr
).
If
matchStr
is the empty String, then
Let
thisIndex
be
ℝ
(?
ToLength
(?
Get
(
rx
,
"lastIndex"
))).
Let
nextIndex
be
AdvanceStringIndex
(
S
,
thisIndex
,
fullUnicode
).
Perform ?
Set
(
rx
,
"lastIndex"
,
𝔽
(
nextIndex
),
true
).
Set
n
to
n
+ 1.
The value of the
"name"
property of this method is
"[Symbol.match]"
.
Note
The
%Symbol.match%
property is used by the
IsRegExp
abstract operation to identify objects that have the basic behaviour of regular expressions. The absence of a
%Symbol.match%
property or the existence of such a property whose value does not Boolean coerce to
true
indicates that the object is not intended to be used as a regular expression object.
22.2.6.9
RegExp.prototype [ %Symbol.matchAll% ] (
string
)
This method performs the following steps when called:
Let
R
be the
this
value.
If
R
is not an Object
, throw a
TypeError
exception.
Let
S
be ?
ToString
(
string
).
Let
C
be ?
SpeciesConstructor
(
R
,
%RegExp%
).
Let
flags
be ?
ToString
(?
Get
(
R
,
"flags"
)).
Let
matcher
be ?
Construct
(
C
, «
R
,
flags
»).
Let
lastIndex
be ?
ToLength
(?
Get
(
R
,
"lastIndex"
)).
Perform ?
Set
(
matcher
,
"lastIndex"
,
lastIndex
,
true
).
If
flags
contains
"g"
, let
global
be
true
.
Else, let
global
be
false
.
If
flags
contains
"u"
or
flags
contains
"v"
, let
fullUnicode
be
true
.
Else, let
fullUnicode
be
false
.
Return
CreateRegExpStringIterator
(
matcher
,
S
,
global
,
fullUnicode
).
The value of the
"name"
property of this method is
"[Symbol.matchAll]"
.
22.2.6.10
get RegExp.prototype.multiline
RegExp.prototype.multiline
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x006D (LATIN SMALL LETTER M).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.6.11
RegExp.prototype [ %Symbol.replace% ] (
string
,
replaceValue
)
This method performs the following steps when called:
Let
rx
be the
this
value.
If
rx
is not an Object
, throw a
TypeError
exception.
Let
S
be ?
ToString
(
string
).
Let
lengthS
be the length of
S
.
Let
functionalReplace
be
IsCallable
(
replaceValue
).
If
functionalReplace
is
false
, then
Set
replaceValue
to ?
ToString
(
replaceValue
).
Let
flags
be ?
ToString
(?
Get
(
rx
,
"flags"
)).
If
flags
contains
"g"
, let
global
be
true
; otherwise let
global
be
false
.
If
global
is
true
, then
Perform ?
Set
(
rx
,
"lastIndex"
,
+0
𝔽
,
true
).
Let
results
be a new empty
List
.
Let
done
be
false
.
Repeat, while
done
is
false
,
Let
result
be ?
RegExpExec
(
rx
,
S
).
If
result
is
null
, then
Set
done
to
true
.
Else,
Append
result
to
results
.
If
global
is
false
, then
Set
done
to
true
.
Else,
Let
matchStr
be ?
ToString
(?
Get
(
result
,
"0"
)).
If
matchStr
is the empty String, then
Let
thisIndex
be
ℝ
(?
ToLength
(?
Get
(
rx
,
"lastIndex"
))).
If
flags
contains
"u"
or
flags
contains
"v"
, let
fullUnicode
be
true
; otherwise let
fullUnicode
be
false
.
Let
nextIndex
be
AdvanceStringIndex
(
S
,
thisIndex
,
fullUnicode
).
Perform ?
Set
(
rx
,
"lastIndex"
,
𝔽
(
nextIndex
),
true
).
Let
accumulatedResult
be the empty String.
Let
nextSourcePosition
be 0.
For each element
result
of
results
, do
Let
resultLength
be ?
LengthOfArrayLike
(
result
).
Let
nCaptures
be
max
(
resultLength
- 1, 0).
Let
matched
be ?
ToString
(?
Get
(
result
,
"0"
)).
Let
matchLength
be the length of
matched
.
Let
position
be ?
ToIntegerOrInfinity
(?
Get
(
result
,
"index"
)).
Set
position
to the result of
clamping
position
between 0 and
lengthS
.
Let
captures
be a new empty
List
.
Let
n
be 1.
Repeat, while
n
≤
nCaptures
,
Let
capN
be ?
Get
(
result
, !
ToString
(
𝔽
(
n
))).
If
capN
is not
undefined
, then
Set
capN
to ?
ToString
(
capN
).
Append
capN
to
captures
.
NOTE: When
n
= 1, the preceding step puts the first element into
captures
(at index 0). More generally, the
n
th
capture (the characters captured by the
n
th
set of capturing parentheses) is at
captures
[
n
- 1].
Set
n
to
n
+ 1.
Let
namedCaptures
be ?
Get
(
result
,
"groups"
).
If
functionalReplace
is
true
, then
Let
replacerArgs
be the
list-concatenation
of «
matched
»,
captures
, and «
𝔽
(
position
),
S
».
If
namedCaptures
is not
undefined
, then
Append
namedCaptures
to
replacerArgs
.
Let
replacementValue
be ?
Call
(
replaceValue
,
undefined
,
replacerArgs
).
Let
replacementString
be ?
ToString
(
replacementValue
).
Else,
If
namedCaptures
is not
undefined
, then
Set
namedCaptures
to ?
ToObject
(
namedCaptures
).
Let
replacementString
be ?
GetSubstitution
(
matched
,
S
,
position
,
captures
,
namedCaptures
,
replaceValue
).
If
position
≥
nextSourcePosition
, then
NOTE:
position
should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of
rx
. In such cases, the corresponding substitution is ignored.
Set
accumulatedResult
to the
string-concatenation
of
accumulatedResult
, the
substring
of
S
from
nextSourcePosition
to
position
, and
replacementString
.
Set
nextSourcePosition
to
position
+
matchLength
.
If
nextSourcePosition
≥
lengthS
, return
accumulatedResult
.
Return the
string-concatenation
of
accumulatedResult
and the
substring
of
S
from
nextSourcePosition
.
The value of the
"name"
property of this method is
"[Symbol.replace]"
.
22.2.6.12
RegExp.prototype [ %Symbol.search% ] (
string
)
This method performs the following steps when called:
Let
rx
be the
this
value.
If
rx
is not an Object
, throw a
TypeError
exception.
Let
S
be ?
ToString
(
string
).
Let
previousLastIndex
be ?
Get
(
rx
,
"lastIndex"
).
If
previousLastIndex
is not
+0
𝔽
, then
Perform ?
Set
(
rx
,
"lastIndex"
,
+0
𝔽
,
true
).
Let
result
be ?
RegExpExec
(
rx
,
S
).
Let
currentLastIndex
be ?
Get
(
rx
,
"lastIndex"
).
If
SameValue
(
currentLastIndex
,
previousLastIndex
) is
false
, then
Perform ?
Set
(
rx
,
"lastIndex"
,
previousLastIndex
,
true
).
If
result
is
null
, return
-1
𝔽
.
Return ?
Get
(
result
,
"index"
).
The value of the
"name"
property of this method is
"[Symbol.search]"
.
Note
The
"lastIndex"
and
"global"
properties of this RegExp object are ignored when performing the search. The
"lastIndex"
property is left unchanged.
22.2.6.13
get RegExp.prototype.source
RegExp.prototype.source
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
If
R
is not an Object
, throw a
TypeError
exception.
If
R
does not have an
[[OriginalSource]]
internal slot, then
If
SameValue
(
R
,
%RegExp.prototype%
) is
true
, return
"(?:)"
.
Otherwise, throw a
TypeError
exception.
Assert
:
R
has an
[[OriginalFlags]]
internal slot.
Let
src
be
R
.
[[OriginalSource]]
.
Let
flags
be
R
.
[[OriginalFlags]]
.
Return
EscapeRegExpPattern
(
src
,
flags
).
22.2.6.13.1
EscapeRegExpPattern (
P
,
F
)
The abstract operation EscapeRegExpPattern takes arguments
P
(a String) and
F
(a String) and returns a String. It performs the following steps when called:
If
F
contains
"v"
, then
Let
patternSymbol
be
Pattern
[+UnicodeMode, +UnicodeSetsMode]
.
Else if
F
contains
"u"
, then
Let
patternSymbol
be
Pattern
[+UnicodeMode, ~UnicodeSetsMode]
.
Else,
Let
patternSymbol
be
Pattern
[~UnicodeMode, ~UnicodeSetsMode]
.
Let
S
be a String in the form of a
patternSymbol
equivalent to
P
interpreted as UTF-16 encoded Unicode code points (
6.1.4
), in which certain code points are escaped as described below.
S
may or may not differ from
P
; however, the
Abstract Closure
that would result from evaluating
S
as a
patternSymbol
must behave identically to the
Abstract Closure
given by the constructed object's
[[RegExpMatcher]]
internal slot. Multiple calls to this abstract operation using the same values for
P
and
F
must produce identical results.
The code points
/
or any
LineTerminator
occurring in the pattern shall be escaped in
S
as necessary to ensure that the
string-concatenation
of
"/"
,
S
,
"/"
, and
F
can be parsed (in an appropriate lexical context) as a
RegularExpressionLiteral
that behaves identically to the constructed regular expression. For example, if
P
is
"/"
, then
S
could be
"\/"
or
"\u002F"
, among other possibilities, but not
"/"
, because
///
followed by
F
would be parsed as a
SingleLineComment
rather than a
RegularExpressionLiteral
. If
P
is the empty String, this specification can be met by letting
S
be
"(?:)"
.
Return
S
.
Note
Despite having similar names,
RegExp.escape
and EscapeRegExpPattern do not perform similar actions. The former escapes a string for representation inside a pattern, while this function escapes a pattern for representation as a string.
22.2.6.14
RegExp.prototype [ %Symbol.split% ] (
string
,
limit
)
Note 1
This method returns an Array into which substrings of the result of converting
string
to a String have been stored. The substrings are determined by searching from left to right for matches of the
this
value regular expression; these occurrences are not part of any String in the returned array, but serve to divide up the String value.
The
this
value may be an empty regular expression or a regular expression that can match an empty String. In this case, the regular expression does not match the empty
substring
at the beginning or end of the input String, nor does it match the empty
substring
at the end of the previous separator match. (For example, if the regular expression matches the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each
substring
contains one code unit.) Only the first match at a given index of the String is considered, even if backtracking could yield a non-empty
substring
match at that index. (For example,
/a*?/[Symbol.split]("ab")
evaluates to the array
["a", "b"]
, while
/a*/[Symbol.split]("ab")
evaluates to the array
["","b"]
.)
If
string
is (or converts to) the empty String, the result depends on whether the regular expression can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.
If the regular expression contains capturing parentheses, then each time
separator
is matched the results (including any
undefined
results) of the capturing parentheses are spliced into the output array. For example,
/<(\/)?([^
<>
]+)>/[Symbol.split]("A
<
B
>
bold
</
B
>
and
<
CODE
>
coded
</
CODE
>
")
evaluates to the array
[
"A"
,
undefined
,
"B"
,
"bold"
,
"/"
,
"B"
,
"and"
,
undefined
,
"CODE"
,
"coded"
,
"/"
,
"CODE"
,
""
]
If
limit
is not
undefined
, then the output array is truncated so that it contains no more than
limit
elements.
This method performs the following steps when called:
Let
rx
be the
this
value.
If
rx
is not an Object
, throw a
TypeError
exception.
Let
S
be ?
ToString
(
string
).
Let
C
be ?
SpeciesConstructor
(
rx
,
%RegExp%
).
Let
flags
be ?
ToString
(?
Get
(
rx
,
"flags"
)).
If
flags
contains
"u"
or
flags
contains
"v"
, let
unicodeMatching
be
true
.
Else, let
unicodeMatching
be
false
.
If
flags
contains
"y"
, let
newFlags
be
flags
.
Else, let
newFlags
be the
string-concatenation
of
flags
and
"y"
.
Let
splitter
be ?
Construct
(
C
, «
rx
,
newFlags
»).
Let
A
be !
ArrayCreate
(0).
Let
lengthA
be 0.
If
limit
is
undefined
, let
lim
be 2
32
- 1; else let
lim
be
ℝ
(?
ToUint32
(
limit
)).
If
lim
= 0, return
A
.
If
S
is the empty String, then
Let
z
be ?
RegExpExec
(
splitter
,
S
).
If
z
is not
null
, return
A
.
Perform !
CreateDataPropertyOrThrow
(
A
,
"0"
,
S
).
Return
A
.
Let
size
be the length of
S
.
Let
p
be 0.
Let
q
be
p
.
Repeat, while
q
<
size
,
Perform ?
Set
(
splitter
,
"lastIndex"
,
𝔽
(
q
),
true
).
Let
z
be ?
RegExpExec
(
splitter
,
S
).
If
z
is
null
, then
Set
q
to
AdvanceStringIndex
(
S
,
q
,
unicodeMatching
).
Else,
Let
e
be
ℝ
(?
ToLength
(?
Get
(
splitter
,
"lastIndex"
))).
Set
e
to
min
(
e
,
size
).
If
e
=
p
, then
Set
q
to
AdvanceStringIndex
(
S
,
q
,
unicodeMatching
).
Else,
Let
T
be the
substring
of
S
from
p
to
q
.
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
lengthA
)),
T
).
Set
lengthA
to
lengthA
+ 1.
If
lengthA
=
lim
, return
A
.
Set
p
to
e
.
Let
numberOfCaptures
be ?
LengthOfArrayLike
(
z
).
Set
numberOfCaptures
to
max
(
numberOfCaptures
- 1, 0).
Let
i
be 1.
Repeat, while
i
≤
numberOfCaptures
,
Let
nextCapture
be ?
Get
(
z
, !
ToString
(
𝔽
(
i
))).
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
lengthA
)),
nextCapture
).
Set
i
to
i
+ 1.
Set
lengthA
to
lengthA
+ 1.
If
lengthA
=
lim
, return
A
.
Set
q
to
p
.
Let
T
be the
substring
of
S
from
p
to
size
.
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
lengthA
)),
T
).
Return
A
.
The value of the
"name"
property of this method is
"[Symbol.split]"
.
Note 2
This method ignores the value of the
"global"
and
"sticky"
properties of this RegExp object.
22.2.6.15
get RegExp.prototype.sticky
RegExp.prototype.sticky
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x0079 (LATIN SMALL LETTER Y).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.6.16
RegExp.prototype.test (
S
)
This method performs the following steps when called:
Let
R
be the
this
value.
If
R
is not an Object
, throw a
TypeError
exception.
Let
string
be ?
ToString
(
S
).
Let
match
be ?
RegExpExec
(
R
,
string
).
If
match
is not
null
, return
true
; else return
false
.
22.2.6.17
RegExp.prototype.toString ( )
Let
R
be the
this
value.
If
R
is not an Object
, throw a
TypeError
exception.
Let
pattern
be ?
ToString
(?
Get
(
R
,
"source"
)).
Let
flags
be ?
ToString
(?
Get
(
R
,
"flags"
)).
Let
result
be the
string-concatenation
of
"/"
,
pattern
,
"/"
, and
flags
.
Return
result
.
Note
The returned String has the form of a
RegularExpressionLiteral
that evaluates to another RegExp object with the same behaviour as this object.
22.2.6.18
get RegExp.prototype.unicode
RegExp.prototype.unicode
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x0075 (LATIN SMALL LETTER U).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.6.19
get RegExp.prototype.unicodeSets
RegExp.prototype.unicodeSets
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
R
be the
this
value.
Let
cu
be the code unit 0x0076 (LATIN SMALL LETTER V).
Return ?
RegExpHasFlag
(
R
,
cu
).
22.2.7
Abstract Operations for RegExp Matching
22.2.7.1
RegExpExec (
R
,
S
)
The abstract operation RegExpExec takes arguments
R
(an Object) and
S
(a String) and returns either a
normal completion containing
either an Object or
null
, or a
throw completion
. It performs the following steps when called:
Let
exec
be ?
Get
(
R
,
"exec"
).
If
IsCallable
(
exec
) is
true
, then
Let
result
be ?
Call
(
exec
,
R
, «
S
»).
If
result
is not an Object
and
result
is not
null
, throw a
TypeError
exception.
Return
result
.
Perform ?
RequireInternalSlot
(
R
,
[[RegExpMatcher]]
).
Return ?
RegExpBuiltinExec
(
R
,
S
).
Note
If a callable
"exec"
property is not found this algorithm falls back to attempting to use the built-in RegExp matching algorithm. This provides compatible behaviour for code written for prior editions where most built-in algorithms that use regular expressions did not perform a dynamic property lookup of
"exec"
.
22.2.7.2
RegExpBuiltinExec (
R
,
S
)
The abstract operation RegExpBuiltinExec takes arguments
R
(an initialized RegExp instance) and
S
(a String) and returns either a
normal completion containing
either an
Array exotic object
or
null
, or a
throw completion
. It performs the following steps when called:
Let
length
be the length of
S
.
Let
lastIndex
be
ℝ
(?
ToLength
(!
Get
(
R
,
"lastIndex"
))).
Let
flags
be
R
.
[[OriginalFlags]]
.
If
flags
contains
"g"
, let
global
be
true
; else let
global
be
false
.
If
flags
contains
"y"
, let
sticky
be
true
; else let
sticky
be
false
.
If
flags
contains
"d"
, let
hasIndices
be
true
; else let
hasIndices
be
false
.
If
global
is
false
and
sticky
is
false
, set
lastIndex
to 0.
Let
matcher
be
R
.
[[RegExpMatcher]]
.
If
flags
contains
"u"
or
flags
contains
"v"
, let
fullUnicode
be
true
; else let
fullUnicode
be
false
.
Let
matchSucceeded
be
false
.
If
fullUnicode
is
true
, let
input
be
StringToCodePoints
(
S
); otherwise let
input
be a
List
whose elements are the code units that are the elements of
S
.
NOTE: Each element of
input
is considered to be a character.
Repeat, while
matchSucceeded
is
false
,
If
lastIndex
>
length
, then
If
global
is
true
or
sticky
is
true
, then
Perform ?
Set
(
R
,
"lastIndex"
,
+0
𝔽
,
true
).
Return
null
.
Let
inputIndex
be the index into
input
of the character that was obtained from element
lastIndex
of
S
.
Let
r
be
matcher
(
input
,
inputIndex
).
If
r
is
failure
, then
If
sticky
is
true
, then
Perform ?
Set
(
R
,
"lastIndex"
,
+0
𝔽
,
true
).
Return
null
.
Set
lastIndex
to
AdvanceStringIndex
(
S
,
lastIndex
,
fullUnicode
).
Else,
Assert
:
r
is a
MatchState
.
Set
matchSucceeded
to
true
.
Let
e
be
r
.
[[EndIndex]]
.
If
fullUnicode
is
true
, set
e
to
GetStringIndex
(
S
,
e
).
If
global
is
true
or
sticky
is
true
, then
Perform ?
Set
(
R
,
"lastIndex"
,
𝔽
(
e
),
true
).
Let
n
be the number of elements in
r
.
[[Captures]]
.
Assert
:
n
=
R
.
[[RegExpRecord]]
.
[[CapturingGroupsCount]]
.
Assert
:
n
< 2
32
- 1.
Let
A
be !
ArrayCreate
(
n
+ 1).
Assert
: The
mathematical value of
A
's
"length"
property is
n
+ 1.
Perform !
CreateDataPropertyOrThrow
(
A
,
"index"
,
𝔽
(
lastIndex
)).
Perform !
CreateDataPropertyOrThrow
(
A
,
"input"
,
S
).
Let
match
be the
Match Record
{
[[StartIndex]]
:
lastIndex
,
[[EndIndex]]
:
e
}.
Let
indices
be a new empty
List
.
Let
groupNames
be a new empty
List
.
Append
match
to
indices
.
Let
matchedSubstr
be
GetMatchString
(
S
,
match
).
Perform !
CreateDataPropertyOrThrow
(
A
,
"0"
,
matchedSubstr
).
If
R
contains any
GroupName
, then
Let
groups
be
OrdinaryObjectCreate
(
null
).
Let
hasGroups
be
true
.
Else,
Let
groups
be
undefined
.
Let
hasGroups
be
false
.
Perform !
CreateDataPropertyOrThrow
(
A
,
"groups"
,
groups
).
Let
matchedGroupNames
be a new empty
List
.
For each
integer
i
such that 1 ≤
i
≤
n
, in ascending order, do
Let
captureI
be
i
th
element of
r
.
[[Captures]]
.
If
captureI
is
undefined
, then
Let
capturedValue
be
undefined
.
Append
undefined
to
indices
.
Else,
Let
captureStart
be
captureI
.
[[StartIndex]]
.
Let
captureEnd
be
captureI
.
[[EndIndex]]
.
If
fullUnicode
is
true
, then
Set
captureStart
to
GetStringIndex
(
S
,
captureStart
).
Set
captureEnd
to
GetStringIndex
(
S
,
captureEnd
).
Let
capture
be the
Match Record
{
[[StartIndex]]
:
captureStart
,
[[EndIndex]]
:
captureEnd
}.
Let
capturedValue
be
GetMatchString
(
S
,
capture
).
Append
capture
to
indices
.
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
i
)),
capturedValue
).
If the
i
th
capture of
R
was defined with a
GroupName
, then
Let
s
be the
CapturingGroupName
of that
GroupName
.
If
matchedGroupNames
contains
s
, then
Assert
:
capturedValue
is
undefined
.
Append
undefined
to
groupNames
.
Else,
If
capturedValue
is not
undefined
, append
s
to
matchedGroupNames
.
NOTE: If there are multiple groups named
s
,
groups
may already have an
s
property at this point. However, because
groups
is an
ordinary object
whose properties are all writable
data properties
, the call to
CreateDataPropertyOrThrow
is nevertheless guaranteed to succeed.
Perform !
CreateDataPropertyOrThrow
(
groups
,
s
,
capturedValue
).
Append
s
to
groupNames
.
Else,
Append
undefined
to
groupNames
.
If
hasIndices
is
true
, then
Let
indicesArray
be
MakeMatchIndicesIndexPairArray
(
S
,
indices
,
groupNames
,
hasGroups
).
Perform !
CreateDataPropertyOrThrow
(
A
,
"indices"
,
indicesArray
).
Return
A
.
22.2.7.3
AdvanceStringIndex (
S
,
index
,
unicode
)
The abstract operation AdvanceStringIndex takes arguments
S
(a String),
index
(a non-negative
integer
), and
unicode
(a Boolean) and returns an
integer
. It performs the following steps when called:
Assert
:
index
≤ 2
53
- 1.
If
unicode
is
false
, return
index
+ 1.
Let
length
be the length of
S
.
If
index
+ 1 ≥
length
, return
index
+ 1.
Let
cp
be
CodePointAt
(
S
,
index
).
Return
index
+
cp
.
[[CodeUnitCount]]
.
22.2.7.4
GetStringIndex (
S
,
codePointIndex
)
The abstract operation GetStringIndex takes arguments
S
(a String) and
codePointIndex
(a non-negative
integer
) and returns a non-negative
integer
. It interprets
S
as a sequence of UTF-16 encoded code points, as described in
6.1.4
, and returns the code unit index corresponding to code point index
codePointIndex
when such an index exists. Otherwise, it returns the length of
S
. It performs the following steps when called:
If
S
is the empty String, return 0.
Let
len
be the length of
S
.
Let
codeUnitCount
be 0.
Let
codePointCount
be 0.
Repeat, while
codeUnitCount
<
len
,
If
codePointCount
=
codePointIndex
, return
codeUnitCount
.
Let
cp
be
CodePointAt
(
S
,
codeUnitCount
).
Set
codeUnitCount
to
codeUnitCount
+
cp
.
[[CodeUnitCount]]
.
Set
codePointCount
to
codePointCount
+ 1.
Return
len
.
22.2.7.5
Match Records
A
Match Record
is a
Record
value used to encapsulate the start and end indices of a regular expression match or capture.
Match Records have the fields listed in
Table 67
.
Table 67:
Match Record
Fields
Field Name
Value
Meaning
[[StartIndex]]
a non-negative
integer
The number of code units from the start of a string at which the match begins (inclusive).
[[EndIndex]]
an
integer
≥
[[StartIndex]]
The number of code units from the start of a string at which the match ends (exclusive).
22.2.7.6
GetMatchString (
S
,
match
)
The abstract operation GetMatchString takes arguments
S
(a String) and
match
(a
Match Record
) and returns a String. It performs the following steps when called:
Assert
:
match
.
[[StartIndex]]
≤
match
.
[[EndIndex]]
≤ the length of
S
.
Return the
substring
of
S
from
match
.
[[StartIndex]]
to
match
.
[[EndIndex]]
.
22.2.7.7
GetMatchIndexPair (
S
,
match
)
The abstract operation GetMatchIndexPair takes arguments
S
(a String) and
match
(a
Match Record
) and returns an Array. It performs the following steps when called:
Assert
:
match
.
[[StartIndex]]
≤
match
.
[[EndIndex]]
≤ the length of
S
.
Return
CreateArrayFromList
(«
𝔽
(
match
.
[[StartIndex]]
),
𝔽
(
match
.
[[EndIndex]]
) »).
22.2.7.8
MakeMatchIndicesIndexPairArray (
S
,
indices
,
groupNames
,
hasGroups
)
The abstract operation MakeMatchIndicesIndexPairArray takes arguments
S
(a String),
indices
(a
List
of either
Match Records
or
undefined
),
groupNames
(a
List
of either Strings or
undefined
), and
hasGroups
(a Boolean) and returns an Array. It performs the following steps when called:
Let
n
be the number of elements in
indices
.
Assert
:
n
< 2
32
- 1.
Assert
:
groupNames
has
n
- 1 elements.
NOTE: The
groupNames
List
contains elements aligned with the
indices
List
starting at
indices
[1].
Let
A
be !
ArrayCreate
(
n
).
If
hasGroups
is
true
, then
Let
groups
be
OrdinaryObjectCreate
(
null
).
Else,
Let
groups
be
undefined
.
Perform !
CreateDataPropertyOrThrow
(
A
,
"groups"
,
groups
).
For each
integer
i
such that 0 ≤
i
<
n
, in ascending order, do
Let
matchIndices
be
indices
[
i
].
If
matchIndices
is not
undefined
, then
Let
matchIndexPair
be
GetMatchIndexPair
(
S
,
matchIndices
).
Else,
Let
matchIndexPair
be
undefined
.
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
i
)),
matchIndexPair
).
If
i
> 0, then
Let
s
be
groupNames
[
i
- 1].
If
s
is not
undefined
, then
Assert
:
groups
is not
undefined
.
NOTE: If there are multiple groups named
s
,
groups
may already have an
s
property at this point. However, because
groups
is an
ordinary object
whose properties are all writable
data properties
, the call to
CreateDataPropertyOrThrow
is nevertheless guaranteed to succeed.
Perform !
CreateDataPropertyOrThrow
(
groups
,
s
,
matchIndexPair
).
Return
A
.
22.2.8
Properties of RegExp Instances
RegExp instances are
ordinary objects
that inherit properties from the
RegExp prototype object
. RegExp instances have internal slots
[[OriginalSource]]
,
[[OriginalFlags]]
,
[[RegExpRecord]]
, and
[[RegExpMatcher]]
. The value of the
[[RegExpMatcher]]
internal slot is an
Abstract Closure
representation of the
Pattern
of the RegExp object.
Note
Prior to ECMAScript 2015, RegExp instances were specified as having the own
data properties
"source"
,
"global"
,
"ignoreCase"
, and
"multiline"
. Those properties are now specified as
accessor properties
of
RegExp.prototype
.
RegExp instances also have the following property:
22.2.8.1
lastIndex
The value of the
"lastIndex"
property specifies the String index at which to start the next match. It is coerced to an
integral Number
when used (see
22.2.7.2
). This property shall have the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
22.2.9
RegExp String Iterator Objects
A
RegExp String Iterator
is an object that represents a specific iteration over some specific String instance object, matching against some specific RegExp instance object. There is not a named
constructor
for RegExp String Iterator objects. Instead, RegExp String Iterator objects are created by calling certain methods of RegExp instance objects.
22.2.9.1
CreateRegExpStringIterator (
R
,
S
,
global
,
fullUnicode
)
The abstract operation CreateRegExpStringIterator takes arguments
R
(an Object),
S
(a String),
global
(a Boolean), and
fullUnicode
(a Boolean) and returns an Object. It performs the following steps when called:
Let
iterator
be
OrdinaryObjectCreate
(
%RegExpStringIteratorPrototype%
, «
[[IteratingRegExp]]
,
[[IteratedString]]
,
[[Global]]
,
[[Unicode]]
,
[[Done]]
»).
Set
iterator
.
[[IteratingRegExp]]
to
R
.
Set
iterator
.
[[IteratedString]]
to
S
.
Set
iterator
.
[[Global]]
to
global
.
Set
iterator
.
[[Unicode]]
to
fullUnicode
.
Set
iterator
.
[[Done]]
to
false
.
Return
iterator
.
22.2.9.2
The %RegExpStringIteratorPrototype% Object
The
%RegExpStringIteratorPrototype%
object:
has properties that are inherited by all
RegExp String Iterator objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
has the following properties:
22.2.9.2.1
%RegExpStringIteratorPrototype%.next ( )
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
If
O
does not have all of the internal slots of a
RegExp String Iterator
Object Instance (see
22.2.9.3
), throw a
TypeError
exception.
If
O
.
[[Done]]
is
true
, then
Return
CreateIteratorResultObject
(
undefined
,
true
).
Let
R
be
O
.
[[IteratingRegExp]]
.
Let
S
be
O
.
[[IteratedString]]
.
Let
global
be
O
.
[[Global]]
.
Let
fullUnicode
be
O
.
[[Unicode]]
.
Let
match
be ?
RegExpExec
(
R
,
S
).
If
match
is
null
, then
Set
O
.
[[Done]]
to
true
.
Return
CreateIteratorResultObject
(
undefined
,
true
).
If
global
is
false
, then
Set
O
.
[[Done]]
to
true
.
Return
CreateIteratorResultObject
(
match
,
false
).
Let
matchStr
be ?
ToString
(?
Get
(
match
,
"0"
)).
If
matchStr
is the empty String, then
Let
thisIndex
be
ℝ
(?
ToLength
(?
Get
(
R
,
"lastIndex"
))).
Let
nextIndex
be
AdvanceStringIndex
(
S
,
thisIndex
,
fullUnicode
).
Perform ?
Set
(
R
,
"lastIndex"
,
𝔽
(
nextIndex
),
true
).
Return
CreateIteratorResultObject
(
match
,
false
).
22.2.9.2.2
%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"RegExp String Iterator"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
22.2.9.3
Properties of RegExp String Iterator Instances
RegExp String Iterator
instances are
ordinary objects
that inherit properties from the
%RegExpStringIteratorPrototype%
intrinsic object.
RegExp String Iterator
instances are initially created with the internal slots listed in
Table 68
.
Table 68: Internal Slots of
RegExp String Iterator
Instances
Internal Slot
Type
Description
[[IteratingRegExp]]
an Object
The regular expression used for iteration.
IsRegExp
(
[[IteratingRegExp]]
) is initially
true
.
[[IteratedString]]
a String
The String value being iterated upon.
[[Global]]
a Boolean
Indicates whether the
[[IteratingRegExp]]
is global or not.
[[Unicode]]
a Boolean
Indicates whether the
[[IteratingRegExp]]
is in Unicode mode or not.
[[Done]]
a Boolean
Indicates whether the iteration is complete or not.
23
Indexed Collections
23.1
Array Objects
Arrays are
exotic objects
that give special treatment to a certain class of
property names
. See
10.4.2
for a definition of this special treatment.
23.1.1
The Array Constructor
The Array
constructor
:
is
%Array%
.
is the initial value of the
"Array"
property of the
global object
.
creates and initializes a new Array when called as a
constructor
.
also creates and initializes a new Array when called as a function rather than as a
constructor
. Thus the function call
Array(…)
is equivalent to the object creation expression
new Array(…)
with the same arguments.
is a function whose behaviour differs based upon the number and types of its arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the exotic Array behaviour must include a
super
call to the Array
constructor
to initialize subclass instances that are
Array exotic objects
. However, most of the
Array.prototype
methods are generic methods that are not dependent upon their
this
value being an
Array exotic object
.
23.1.1.1
Array ( ...
values
)
This function performs the following steps when called:
If NewTarget is
undefined
, let
newTarget
be the
active function object
; else let
newTarget
be NewTarget.
Let
proto
be ?
GetPrototypeFromConstructor
(
newTarget
,
"%Array.prototype%"
).
Let
numberOfArgs
be the number of elements in
values
.
If
numberOfArgs
= 0, then
Return !
ArrayCreate
(0,
proto
).
Else if
numberOfArgs
= 1, then
Let
len
be
values
[0].
Let
array
be !
ArrayCreate
(0,
proto
).
If
len
is not a Number
, then
Perform !
CreateDataPropertyOrThrow
(
array
,
"0"
,
len
).
Let
intLen
be
1
𝔽
.
Else,
Let
intLen
be !
ToUint32
(
len
).
If
SameValueZero
(
intLen
,
len
) is
false
, throw a
RangeError
exception.
Perform !
Set
(
array
,
"length"
,
intLen
,
true
).
Return
array
.
Else,
Assert
:
numberOfArgs
≥ 2.
Let
array
be ?
ArrayCreate
(
numberOfArgs
,
proto
).
Let
k
be 0.
Repeat, while
k
<
numberOfArgs
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
itemK
be
values
[
k
].
Perform !
CreateDataPropertyOrThrow
(
array
,
Pk
,
itemK
).
Set
k
to
k
+ 1.
Assert
: The
mathematical value of
array
's
"length"
property is
numberOfArgs
.
Return
array
.
23.1.2
Properties of the Array Constructor
The Array
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has a
"length"
property whose value is
1
𝔽
.
has the following properties:
23.1.2.1
Array.from (
items
[ ,
mapper
[ ,
thisArg
] ] )
This function performs the following steps when called:
Let
C
be the
this
value.
If
mapper
is
undefined
, then
Let
mapping
be
false
.
Else,
If
IsCallable
(
mapper
) is
false
, throw a
TypeError
exception.
Let
mapping
be
true
.
Let
usingIterator
be ?
GetMethod
(
items
,
%Symbol.iterator%
).
If
usingIterator
is not
undefined
, then
If
IsConstructor
(
C
) is
true
, then
Let
A
be ?
Construct
(
C
).
Else,
Let
A
be !
ArrayCreate
(0).
Let
iteratorRecord
be ?
GetIteratorFromMethod
(
items
,
usingIterator
).
Let
k
be 0.
Repeat,
If
k
≥ 2
53
- 1, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iteratorRecord
,
error
).
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Perform ?
Set
(
A
,
"length"
,
𝔽
(
k
),
true
).
Return
A
.
If
mapping
is
true
, then
Let
mappedValue
be
Completion
(
Call
(
mapper
,
thisArg
, «
next
,
𝔽
(
k
) »)).
IfAbruptCloseIterator
(
mappedValue
,
iteratorRecord
).
Else,
Let
mappedValue
be
next
.
Let
defineStatus
be
Completion
(
CreateDataPropertyOrThrow
(
A
,
Pk
,
mappedValue
)).
IfAbruptCloseIterator
(
defineStatus
,
iteratorRecord
).
Set
k
to
k
+ 1.
NOTE:
items
is not
iterable
so assume it is an
array-like object
.
Let
arrayLike
be !
ToObject
(
items
).
Let
len
be ?
LengthOfArrayLike
(
arrayLike
).
If
IsConstructor
(
C
) is
true
, then
Let
A
be ?
Construct
(
C
, «
𝔽
(
len
) »).
Else,
Let
A
be ?
ArrayCreate
(
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be ?
Get
(
arrayLike
,
Pk
).
If
mapping
is
true
, then
Let
mappedValue
be ?
Call
(
mapper
,
thisArg
, «
kValue
,
𝔽
(
k
) »).
Else,
Let
mappedValue
be
kValue
.
Perform ?
CreateDataPropertyOrThrow
(
A
,
Pk
,
mappedValue
).
Set
k
to
k
+ 1.
Perform ?
Set
(
A
,
"length"
,
𝔽
(
len
),
true
).
Return
A
.
Note
This method is an intentionally generic factory method; it does not require that its
this
value be the Array
constructor
. Therefore it can be transferred to or inherited by any other
constructors
that may be called with a single numeric argument.
23.1.2.2
Array.fromAsync (
items
[ ,
mapper
[ ,
thisArg
] ] )
This async function performs the following steps when called:
Let
C
be the
this
value.
Let
mapping
be
false
.
If
mapper
is not
undefined
, then
If
IsCallable
(
mapper
) is
false
, throw a
TypeError
exception.
Set
mapping
to
true
.
Let
iteratorRecord
be
undefined
.
Let
usingAsyncIterator
be ?
GetMethod
(
items
,
%Symbol.asyncIterator%
).
If
usingAsyncIterator
is
undefined
, then
Let
usingSyncIterator
be ?
GetMethod
(
items
,
%Symbol.iterator%
).
If
usingSyncIterator
is not
undefined
, then
Set
iteratorRecord
to
CreateAsyncFromSyncIterator
(?
GetIteratorFromMethod
(
items
,
usingSyncIterator
)).
Else,
Set
iteratorRecord
to ?
GetIteratorFromMethod
(
items
,
usingAsyncIterator
).
If
iteratorRecord
is not
undefined
, then
If
IsConstructor
(
C
) is
true
, then
Let
A
be ?
Construct
(
C
).
Else,
Let
A
be !
ArrayCreate
(0).
Let
k
be 0.
Repeat,
If
k
≥ 2
53
- 1, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
AsyncIteratorClose
(
iteratorRecord
,
error
).
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
nextResult
be ?
Call
(
iteratorRecord
.
[[NextMethod]]
,
iteratorRecord
.
[[Iterator]]
).
Set
nextResult
to ?
Await
(
nextResult
).
If
nextResult
is not an Object
, throw a
TypeError
exception.
Let
done
be ?
IteratorComplete
(
nextResult
).
If
done
is
true
, then
Perform ?
Set
(
A
,
"length"
,
𝔽
(
k
),
true
).
Return
A
.
Let
nextValue
be ?
IteratorValue
(
nextResult
).
If
mapping
is
true
, then
Let
mappedValue
be
Completion
(
Call
(
mapper
,
thisArg
, «
nextValue
,
𝔽
(
k
) »)).
IfAbruptCloseAsyncIterator
(
mappedValue
,
iteratorRecord
).
Set
mappedValue
to
Completion
(
Await
(
mappedValue
)).
IfAbruptCloseAsyncIterator
(
mappedValue
,
iteratorRecord
).
Else,
Let
mappedValue
be
nextValue
.
Let
defineStatus
be
Completion
(
CreateDataPropertyOrThrow
(
A
,
Pk
,
mappedValue
)).
IfAbruptCloseAsyncIterator
(
defineStatus
,
iteratorRecord
).
Set
k
to
k
+ 1.
Else,
NOTE:
items
is neither
async iterable
nor
iterable
so assume it is an
array-like object
.
Let
arrayLike
be !
ToObject
(
items
).
Let
len
be ?
LengthOfArrayLike
(
arrayLike
).
If
IsConstructor
(
C
) is
true
, then
Let
A
be ?
Construct
(
C
, «
𝔽
(
len
) »).
Else,
Let
A
be ?
ArrayCreate
(
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be ?
Get
(
arrayLike
,
Pk
).
Set
kValue
to ?
Await
(
kValue
).
If
mapping
is
true
, then
Let
mappedValue
be ?
Call
(
mapper
,
thisArg
, «
kValue
,
𝔽
(
k
) »).
Set
mappedValue
to ?
Await
(
mappedValue
).
Else,
Let
mappedValue
be
kValue
.
Perform ?
CreateDataPropertyOrThrow
(
A
,
Pk
,
mappedValue
).
Set
k
to
k
+ 1.
Perform ?
Set
(
A
,
"length"
,
𝔽
(
len
),
true
).
Return
A
.
Note
This method is an intentionally generic factory method; it does not require that its
this
value be the Array
constructor
. Therefore it can be transferred to or inherited by any other
constructors
that may be called with a single numeric argument.
23.1.2.3
Array.isArray (
arg
)
This function performs the following steps when called:
Return ?
IsArray
(
arg
).
23.1.2.4
Array.of ( ...
items
)
This method performs the following steps when called:
Let
len
be the number of elements in
items
.
Let
lenNumber
be
𝔽
(
len
).
Let
C
be the
this
value.
If
IsConstructor
(
C
) is
true
, then
Let
A
be ?
Construct
(
C
, «
lenNumber
»).
Else,
Let
A
be ?
ArrayCreate
(
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
kValue
be
items
[
k
].
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Perform ?
CreateDataPropertyOrThrow
(
A
,
Pk
,
kValue
).
Set
k
to
k
+ 1.
Perform ?
Set
(
A
,
"length"
,
lenNumber
,
true
).
Return
A
.
Note
This method is an intentionally generic factory method; it does not require that its
this
value be the Array
constructor
. Therefore it can be transferred to or inherited by other
constructors
that may be called with a single numeric argument.
23.1.2.5
Array.prototype
The value of
Array.prototype
is the
Array prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
23.1.2.6
get Array [ %Symbol.species% ]
Array[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
Note
Array prototype methods normally use their
this
value's
constructor
to create a derived object. However, a subclass
constructor
may over-ride that default behaviour by redefining its
%Symbol.species%
property.
23.1.3
Properties of the Array Prototype Object
The
Array prototype object
:
is
%Array.prototype%
.
is an
Array exotic object
and has the internal methods specified for such objects.
has a
"length"
property whose initial value is
+0
𝔽
and whose attributes are {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
Note
The Array prototype object is specified to be an
Array exotic object
to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.
23.1.3.1
Array.prototype.at (
index
)
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
relativeIndex
be ?
ToIntegerOrInfinity
(
index
).
If
relativeIndex
≥ 0, then
Let
k
be
relativeIndex
.
Else,
Let
k
be
len
+
relativeIndex
.
If
k
< 0 or
k
≥
len
, return
undefined
.
Return ?
Get
(
O
, !
ToString
(
𝔽
(
k
))).
23.1.3.2
Array.prototype.concat ( ...
items
)
This method returns an array containing the array elements of the object followed by the array elements of each argument.
It performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
A
be ?
ArraySpeciesCreate
(
O
, 0).
Let
n
be 0.
Prepend
O
to
items
.
For each element
E
of
items
, do
Let
spreadable
be ?
IsConcatSpreadable
(
E
).
If
spreadable
is
true
, then
Let
len
be ?
LengthOfArrayLike
(
E
).
If
n
+
len
> 2
53
- 1, throw a
TypeError
exception.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
exists
be ?
HasProperty
(
E
,
Pk
).
If
exists
is
true
, then
Let
subElement
be ?
Get
(
E
,
Pk
).
Perform ?
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
n
)),
subElement
).
Set
n
to
n
+ 1.
Set
k
to
k
+ 1.
Else,
NOTE:
E
is added as a single item rather than spread.
If
n
≥ 2
53
- 1, throw a
TypeError
exception.
Perform ?
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
n
)),
E
).
Set
n
to
n
+ 1.
Perform ?
Set
(
A
,
"length"
,
𝔽
(
n
),
true
).
Return
A
.
The
"length"
property of this method is
1
𝔽
.
Note 1
The explicit setting of the
"length"
property in step
6
is intended to ensure the length is correct when the final non-empty element of
items
has trailing holes or when
A
is not a built-in Array.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.2.1
IsConcatSpreadable (
O
)
The abstract operation IsConcatSpreadable takes argument
O
(an
ECMAScript language value
) and returns either a
normal completion containing
a Boolean or a
throw completion
. It performs the following steps when called:
If
O
is not an Object
, return
false
.
Let
spreadable
be ?
Get
(
O
,
%Symbol.isConcatSpreadable%
).
If
spreadable
is not
undefined
, return
ToBoolean
(
spreadable
).
Return ?
IsArray
(
O
).
23.1.3.3
Array.prototype.constructor
The initial value of
Array.prototype.constructor
is
%Array%
.
23.1.3.4
Array.prototype.copyWithin (
target
,
start
[ ,
end
] )
Note 1
The
end
argument is optional. If it is not provided, the length of the
this
value is used.
Note 2
If
target
is negative, it is treated as
length
+
target
where
length
is the length of the array. If
start
is negative, it is treated as
length
+
start
. If
end
is negative, it is treated as
length
+
end
.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
relativeTarget
be ?
ToIntegerOrInfinity
(
target
).
If
relativeTarget
= -∞, let
to
be 0.
Else if
relativeTarget
< 0, let
to
be
max
(
len
+
relativeTarget
, 0).
Else, let
to
be
min
(
relativeTarget
,
len
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
from
be 0.
Else if
relativeStart
< 0, let
from
be
max
(
len
+
relativeStart
, 0).
Else, let
from
be
min
(
relativeStart
,
len
).
If
end
is
undefined
, let
relativeEnd
be
len
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
final
be 0.
Else if
relativeEnd
< 0, let
final
be
max
(
len
+
relativeEnd
, 0).
Else, let
final
be
min
(
relativeEnd
,
len
).
Let
count
be
min
(
final
-
from
,
len
-
to
).
If
from
<
to
and
to
<
from
+
count
, then
Let
direction
be -1.
Set
from
to
from
+
count
- 1.
Set
to
to
to
+
count
- 1.
Else,
Let
direction
be 1.
Repeat, while
count
> 0,
Let
fromKey
be !
ToString
(
𝔽
(
from
)).
Let
toKey
be !
ToString
(
𝔽
(
to
)).
Let
fromPresent
be ?
HasProperty
(
O
,
fromKey
).
If
fromPresent
is
true
, then
Let
fromValue
be ?
Get
(
O
,
fromKey
).
Perform ?
Set
(
O
,
toKey
,
fromValue
,
true
).
Else,
Assert
:
fromPresent
is
false
.
Perform ?
DeletePropertyOrThrow
(
O
,
toKey
).
Set
from
to
from
+
direction
.
Set
to
to
to
+
direction
.
Set
count
to
count
- 1.
Return
O
.
Note 3
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.5
Array.prototype.entries ( )
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Return
CreateArrayIterator
(
O
,
key+value
).
23.1.3.6
Array.prototype.every (
callback
[ ,
thisArg
] )
Note 1
callback
should be a function that accepts three arguments and returns a value that is coercible to a Boolean value.
every
calls
callback
once for each element present in the array, in ascending order, until it finds one where
callback
returns
false
. If such an element is found,
every
immediately returns
false
. Otherwise,
every
returns
true
.
callback
is called only for elements of the array which actually exist; it is not called for missing elements of the array.
If a
thisArg
parameter is provided, it will be used as the
this
value for each invocation of
callback
. If it is not provided,
undefined
is used instead.
callback
is called with three arguments: the value of the element, the index of the element, and the object being traversed.
every
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
The range of elements processed by
every
is set before the first call to
callback
. Elements which are appended to the array after the call to
every
begins will not be visited by
callback
. If existing elements of the array are changed, their value as passed to
callback
will be the value at the time
every
visits them; elements that are deleted after the call to
every
begins and before being visited are not visited.
every
acts like the "for all" quantifier in mathematics. In particular, for an empty array, it returns
true
.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Let
testResult
be
ToBoolean
(?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»)).
If
testResult
is
false
, return
false
.
Set
k
to
k
+ 1.
Return
true
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.7
Array.prototype.fill (
value
[ ,
start
[ ,
end
] ] )
Note 1
The
start
argument is optional. If it is not provided,
+0
𝔽
is used.
The
end
argument is optional. If it is not provided, the length of the
this
value is used.
Note 2
If
start
is negative, it is treated as
length
+
start
where
length
is the length of the array. If
end
is negative, it is treated as
length
+
end
.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
k
be 0.
Else if
relativeStart
< 0, let
k
be
max
(
len
+
relativeStart
, 0).
Else, let
k
be
min
(
relativeStart
,
len
).
If
end
is
undefined
, let
relativeEnd
be
len
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
final
be 0.
Else if
relativeEnd
< 0, let
final
be
max
(
len
+
relativeEnd
, 0).
Else, let
final
be
min
(
relativeEnd
,
len
).
Repeat, while
k
<
final
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Perform ?
Set
(
O
,
Pk
,
value
,
true
).
Set
k
to
k
+ 1.
Return
O
.
Note 3
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.8
Array.prototype.filter (
callback
[ ,
thisArg
] )
Note 1
callback
should be a function that accepts three arguments and returns a value that is coercible to a Boolean value.
filter
calls
callback
once for each element in the array, in ascending order, and constructs a new array of all the values for which
callback
returns
true
.
callback
is called only for elements of the array which actually exist; it is not called for missing elements of the array.
If a
thisArg
parameter is provided, it will be used as the
this
value for each invocation of
callback
. If it is not provided,
undefined
is used instead.
callback
is called with three arguments: the value of the element, the index of the element, and the object being traversed.
filter
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
The range of elements processed by
filter
is set before the first call to
callback
. Elements which are appended to the array after the call to
filter
begins will not be visited by
callback
. If existing elements of the array are changed their value as passed to
callback
will be the value at the time
filter
visits them; elements that are deleted after the call to
filter
begins and before being visited are not visited.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
A
be ?
ArraySpeciesCreate
(
O
, 0).
Let
k
be 0.
Let
to
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Let
selected
be
ToBoolean
(?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»)).
If
selected
is
true
, then
Perform ?
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
to
)),
kValue
).
Set
to
to
to
+ 1.
Set
k
to
k
+ 1.
Return
A
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.9
Array.prototype.find (
predicate
[ ,
thisArg
] )
Note 1
This method calls
predicate
once for each element of the array, in ascending index order, until it finds one where
predicate
returns a value that coerces to
true
. If such an element is found,
find
immediately returns that element value. Otherwise,
find
returns
undefined
.
See
FindViaPredicate
for additional information.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
ascending
,
predicate
,
thisArg
).
Return
findRec
.
[[Value]]
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.10
Array.prototype.findIndex (
predicate
[ ,
thisArg
] )
Note 1
This method calls
predicate
once for each element of the array, in ascending index order, until it finds one where
predicate
returns a value that coerces to
true
. If such an element is found,
findIndex
immediately returns the index of that element value. Otherwise,
findIndex
returns -1.
See
FindViaPredicate
for additional information.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
ascending
,
predicate
,
thisArg
).
Return
findRec
.
[[Index]]
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.11
Array.prototype.findLast (
predicate
[ ,
thisArg
] )
Note 1
This method calls
predicate
once for each element of the array, in descending index order, until it finds one where
predicate
returns a value that coerces to
true
. If such an element is found,
findLast
immediately returns that element value. Otherwise,
findLast
returns
undefined
.
See
FindViaPredicate
for additional information.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
descending
,
predicate
,
thisArg
).
Return
findRec
.
[[Value]]
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.12
Array.prototype.findLastIndex (
predicate
[ ,
thisArg
] )
Note 1
This method calls
predicate
once for each element of the array, in descending index order, until it finds one where
predicate
returns a value that coerces to
true
. If such an element is found,
findLastIndex
immediately returns the index of that element value. Otherwise,
findLastIndex
returns -1.
See
FindViaPredicate
for additional information.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
descending
,
predicate
,
thisArg
).
Return
findRec
.
[[Index]]
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.12.1
FindViaPredicate (
O
,
len
,
direction
,
predicate
,
thisArg
)
The abstract operation FindViaPredicate takes arguments
O
(an Object),
len
(a non-negative
integer
),
direction
(
ascending
or
descending
),
predicate
(an
ECMAScript language value
), and
thisArg
(an
ECMAScript language value
) and returns either a
normal completion containing
a
Record
with fields
[[Index]]
(an
integral Number
) and
[[Value]]
(an
ECMAScript language value
) or a
throw completion
.
O
should be an
array-like object
or a
TypedArray
. This operation calls
predicate
once for each element of
O
, in either ascending index order or descending index order (as indicated by
direction
), until it finds one where
predicate
returns a value that coerces to
true
. At that point, this operation returns a
Record
that gives the index and value of the element found. If no such element is found, this operation returns a
Record
that specifies
-1
𝔽
for the index and
undefined
for the value.
predicate
should be a function. When called for an element of the array, it is passed three arguments: the value of the element, the index of the element, and the object being traversed. Its return value will be coerced to a Boolean value.
thisArg
will be used as the
this
value for each invocation of
predicate
.
This operation does not directly mutate the object on which it is called, but the object may be mutated by the calls to
predicate
.
The range of elements processed is set before the first call to
predicate
, just before the traversal begins. Elements that are appended to the array after this will not be visited by
predicate
. If existing elements of the array are changed, their value as passed to
predicate
will be the value at the time that this operation visits them. Elements that are deleted after traversal begins and before being visited are still visited and are either looked up from the prototype or are
undefined
.
It performs the following steps when called:
If
IsCallable
(
predicate
) is
false
, throw a
TypeError
exception.
If
direction
is
ascending
, then
Let
indices
be a
List
of the
integers
in the
interval
from 0 (inclusive) to
len
(exclusive), in ascending order.
Else,
Let
indices
be a
List
of the
integers
in the
interval
from 0 (inclusive) to
len
(exclusive), in descending order.
For each
integer
k
of
indices
, do
Let
Pk
be !
ToString
(
𝔽
(
k
)).
NOTE: If
O
is a
TypedArray
, the following invocation of
Get
will return a
normal completion
.
Let
kValue
be ?
Get
(
O
,
Pk
).
Let
testResult
be ?
Call
(
predicate
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»).
If
ToBoolean
(
testResult
) is
true
, return the
Record
{
[[Index]]
:
𝔽
(
k
),
[[Value]]
:
kValue
}.
Return the
Record
{
[[Index]]
:
-1
𝔽
,
[[Value]]
:
undefined
}.
23.1.3.13
Array.prototype.flat ( [
depth
] )
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
sourceLen
be ?
LengthOfArrayLike
(
O
).
Let
depthNum
be 1.
If
depth
is not
undefined
, then
Set
depthNum
to ?
ToIntegerOrInfinity
(
depth
).
If
depthNum
< 0, set
depthNum
to 0.
Let
A
be ?
ArraySpeciesCreate
(
O
, 0).
Perform ?
FlattenIntoArray
(
A
,
O
,
sourceLen
, 0,
depthNum
).
Return
A
.
23.1.3.13.1
FlattenIntoArray (
target
,
source
,
sourceLen
,
start
,
depth
[ ,
mapperFunction
[ ,
thisArg
] ] )
The abstract operation FlattenIntoArray takes arguments
target
(an Object),
source
(an Object),
sourceLen
(a non-negative
integer
),
start
(a non-negative
integer
), and
depth
(a non-negative
integer
or +∞) and optional arguments
mapperFunction
(a
function object
) and
thisArg
(an
ECMAScript language value
) and returns either a
normal completion containing
a non-negative
integer
or a
throw completion
. It performs the following steps when called:
Assert
: If
mapperFunction
is present, then
IsCallable
(
mapperFunction
) is
true
,
thisArg
is present, and
depth
is 1.
Let
targetIndex
be
start
.
Let
sourceIndex
be
+0
𝔽
.
Repeat, while
ℝ
(
sourceIndex
) <
sourceLen
,
Let
P
be !
ToString
(
sourceIndex
).
Let
exists
be ?
HasProperty
(
source
,
P
).
If
exists
is
true
, then
Let
element
be ?
Get
(
source
,
P
).
If
mapperFunction
is present, then
Set
element
to ?
Call
(
mapperFunction
,
thisArg
, «
element
,
sourceIndex
,
source
»).
Let
shouldFlatten
be
false
.
If
depth
> 0, then
Set
shouldFlatten
to ?
IsArray
(
element
).
If
shouldFlatten
is
true
, then
If
depth
= +∞, let
newDepth
be +∞.
Else, let
newDepth
be
depth
- 1.
Let
elementLen
be ?
LengthOfArrayLike
(
element
).
Set
targetIndex
to ?
FlattenIntoArray
(
target
,
element
,
elementLen
,
targetIndex
,
newDepth
).
Else,
If
targetIndex
≥ 2
53
- 1, throw a
TypeError
exception.
Perform ?
CreateDataPropertyOrThrow
(
target
, !
ToString
(
𝔽
(
targetIndex
)),
element
).
Set
targetIndex
to
targetIndex
+ 1.
Set
sourceIndex
to
sourceIndex
+
1
𝔽
.
Return
targetIndex
.
23.1.3.14
Array.prototype.flatMap (
mapperFunction
[ ,
thisArg
] )
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
sourceLen
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
mapperFunction
) is
false
, throw a
TypeError
exception.
Let
A
be ?
ArraySpeciesCreate
(
O
, 0).
Perform ?
FlattenIntoArray
(
A
,
O
,
sourceLen
, 0, 1,
mapperFunction
,
thisArg
).
Return
A
.
23.1.3.15
Array.prototype.forEach (
callback
[ ,
thisArg
] )
Note 1
callback
should be a function that accepts three arguments.
forEach
calls
callback
once for each element present in the array, in ascending order.
callback
is called only for elements of the array which actually exist; it is not called for missing elements of the array.
If a
thisArg
parameter is provided, it will be used as the
this
value for each invocation of
callback
. If it is not provided,
undefined
is used instead.
callback
is called with three arguments: the value of the element, the index of the element, and the object being traversed.
forEach
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
The range of elements processed by
forEach
is set before the first call to
callback
. Elements which are appended to the array after the call to
forEach
begins will not be visited by
callback
. If existing elements of the array are changed, their value as passed to
callback
will be the value at the time
forEach
visits them; elements that are deleted after the call to
forEach
begins and before being visited are not visited.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Perform ?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»).
Set
k
to
k
+ 1.
Return
undefined
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.16
Array.prototype.includes (
searchElement
[ ,
fromIndex
] )
Note 1
This method compares
searchElement
to the elements of the array, in ascending order, using the
SameValueZero
algorithm, and if found at any position, returns
true
; otherwise, it returns
false
.
The optional second argument
fromIndex
defaults to
+0
𝔽
(i.e. the whole array is searched). If it is greater than or equal to the length of the array,
false
is returned, i.e. the array will not be searched. If it is less than
-0
𝔽
, it is used as the offset from the end of the array to compute
fromIndex
. If the computed index is less than or equal to
+0
𝔽
, the whole array will be searched.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
len
= 0, return
false
.
Let
n
be ?
ToIntegerOrInfinity
(
fromIndex
).
Assert
: If
fromIndex
is
undefined
, then
n
is 0.
If
n
= +∞, return
false
.
Else if
n
= -∞, set
n
to 0.
If
n
≥ 0, then
Let
k
be
n
.
Else,
Let
k
be
len
+
n
.
If
k
< 0, set
k
to 0.
Repeat, while
k
<
len
,
Let
elementK
be ?
Get
(
O
, !
ToString
(
𝔽
(
k
))).
If
SameValueZero
(
searchElement
,
elementK
) is
true
, return
true
.
Set
k
to
k
+ 1.
Return
false
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
Note 3
This method intentionally differs from the similar
indexOf
method in two ways. First, it uses the
SameValueZero
algorithm, instead of
IsStrictlyEqual
, allowing it to detect
NaN
array elements. Second, it does not skip missing array elements, instead treating them as
undefined
.
23.1.3.17
Array.prototype.indexOf (
searchElement
[ ,
fromIndex
] )
This method compares
searchElement
to the elements of the array, in ascending order, using the
IsStrictlyEqual
algorithm, and if found at one or more indices, returns the smallest such index; otherwise, it returns
-1
𝔽
.
Note 1
The optional second argument
fromIndex
defaults to
+0
𝔽
(i.e. the whole array is searched). If it is greater than or equal to the length of the array,
-1
𝔽
is returned, i.e. the array will not be searched. If it is less than
-0
𝔽
, it is used as the offset from the end of the array to compute
fromIndex
. If the computed index is less than or equal to
+0
𝔽
, the whole array will be searched.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
len
= 0, return
-1
𝔽
.
Let
n
be ?
ToIntegerOrInfinity
(
fromIndex
).
Assert
: If
fromIndex
is
undefined
, then
n
is 0.
If
n
= +∞, return
-1
𝔽
.
Else if
n
= -∞, set
n
to 0.
If
n
≥ 0, then
Let
k
be
n
.
Else,
Let
k
be
len
+
n
.
If
k
< 0, set
k
to 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
elementK
be ?
Get
(
O
,
Pk
).
If
IsStrictlyEqual
(
searchElement
,
elementK
) is
true
, return
𝔽
(
k
).
Set
k
to
k
+ 1.
Return
-1
𝔽
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.18
Array.prototype.join (
separator
)
This method converts the elements of the array to Strings, and then concatenates these Strings, separated by occurrences of the
separator
. If no separator is provided, a single comma is used as the separator.
It performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
separator
is
undefined
, let
sep
be
","
.
Else, let
sep
be ?
ToString
(
separator
).
Let
R
be the empty String.
Let
k
be 0.
Repeat, while
k
<
len
,
If
k
> 0, set
R
to the
string-concatenation
of
R
and
sep
.
Let
element
be ?
Get
(
O
, !
ToString
(
𝔽
(
k
))).
If
element
is neither
undefined
nor
null
, then
Let
S
be ?
ToString
(
element
).
Set
R
to the
string-concatenation
of
R
and
S
.
Set
k
to
k
+ 1.
Return
R
.
Note
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.
23.1.3.19
Array.prototype.keys ( )
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Return
CreateArrayIterator
(
O
,
key
).
23.1.3.20
Array.prototype.lastIndexOf (
searchElement
[ ,
fromIndex
] )
Note 1
This method compares
searchElement
to the elements of the array in descending order using the
IsStrictlyEqual
algorithm, and if found at one or more indices, returns the largest such index; otherwise, it returns
-1
𝔽
.
The optional second argument
fromIndex
defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than
-0
𝔽
, it is used as the offset from the end of the array to compute
fromIndex
. If the computed index is less than or equal to
+0
𝔽
,
-1
𝔽
is returned.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
len
= 0, return
-1
𝔽
.
If
fromIndex
is present, let
n
be ?
ToIntegerOrInfinity
(
fromIndex
); else let
n
be
len
- 1.
If
n
= -∞, return
-1
𝔽
.
If
n
≥ 0, then
Let
k
be
min
(
n
,
len
- 1).
Else,
Let
k
be
len
+
n
.
Repeat, while
k
≥ 0,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
elementK
be ?
Get
(
O
,
Pk
).
If
IsStrictlyEqual
(
searchElement
,
elementK
) is
true
, return
𝔽
(
k
).
Set
k
to
k
- 1.
Return
-1
𝔽
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.21
Array.prototype.map (
callback
[ ,
thisArg
] )
Note 1
callback
should be a function that accepts three arguments.
map
calls
callback
once for each element in the array, in ascending order, and constructs a new Array from the results.
callback
is called only for elements of the array which actually exist; it is not called for missing elements of the array.
If a
thisArg
parameter is provided, it will be used as the
this
value for each invocation of
callback
. If it is not provided,
undefined
is used instead.
callback
is called with three arguments: the value of the element, the index of the element, and the object being traversed.
map
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
The range of elements processed by
map
is set before the first call to
callback
. Elements which are appended to the array after the call to
map
begins will not be visited by
callback
. If existing elements of the array are changed, their value as passed to
callback
will be the value at the time
map
visits them; elements that are deleted after the call to
map
begins and before being visited are not visited.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
A
be ?
ArraySpeciesCreate
(
O
,
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Let
mappedValue
be ?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»).
Perform ?
CreateDataPropertyOrThrow
(
A
,
Pk
,
mappedValue
).
Set
k
to
k
+ 1.
Return
A
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.22
Array.prototype.pop ( )
Note 1
This method removes the last element of the array and returns it.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
len
= 0, then
Perform ?
Set
(
O
,
"length"
,
+0
𝔽
,
true
).
Return
undefined
.
Else,
Assert
:
len
> 0.
Let
newLen
be
𝔽
(
len
- 1).
Let
index
be !
ToString
(
newLen
).
Let
element
be ?
Get
(
O
,
index
).
Perform ?
DeletePropertyOrThrow
(
O
,
index
).
Perform ?
Set
(
O
,
"length"
,
newLen
,
true
).
Return
element
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.23
Array.prototype.push ( ...
items
)
Note 1
This method appends the arguments to the end of the array, in the order in which they appear. It returns the new length of the array.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
argCount
be the number of elements in
items
.
If
len
+
argCount
> 2
53
- 1, throw a
TypeError
exception.
For each element
E
of
items
, do
Perform ?
Set
(
O
, !
ToString
(
𝔽
(
len
)),
E
,
true
).
Set
len
to
len
+ 1.
Perform ?
Set
(
O
,
"length"
,
𝔽
(
len
),
true
).
Return
𝔽
(
len
).
The
"length"
property of this method is
1
𝔽
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.24
Array.prototype.reduce (
callback
[ ,
initialValue
] )
Note 1
callback
should be a function that takes four arguments.
reduce
calls the callback, as a function, once for each element after the first element present in the array, in ascending order.
callback
is called with four arguments: the
previousValue
(value from the previous call to
callback
), the
currentValue
(value of the current element), the
currentIndex
, and the object being traversed. The first time that callback is called, the
previousValue
and
currentValue
can be one of two values. If an
initialValue
was supplied in the call to
reduce
, then
previousValue
will be
initialValue
and
currentValue
will be the first value in the array. If no
initialValue
was supplied, then
previousValue
will be the first value in the array and
currentValue
will be the second. It is a
TypeError
if the array contains no elements and
initialValue
is not provided.
reduce
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
The range of elements processed by
reduce
is set before the first call to
callback
. Elements that are appended to the array after the call to
reduce
begins will not be visited by
callback
. If existing elements of the array are changed, their value as passed to
callback
will be the value at the time
reduce
visits them; elements that are deleted after the call to
reduce
begins and before being visited are not visited.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
If
len
= 0 and
initialValue
is not present, throw a
TypeError
exception.
Let
k
be 0.
Let
accumulator
be
undefined
.
If
initialValue
is present, then
Set
accumulator
to
initialValue
.
Else,
Let
kPresent
be
false
.
Repeat, while
kPresent
is
false
and
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Set
kPresent
to ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Set
accumulator
to ?
Get
(
O
,
Pk
).
Set
k
to
k
+ 1.
If
kPresent
is
false
, throw a
TypeError
exception.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Set
accumulator
to ?
Call
(
callback
,
undefined
, «
accumulator
,
kValue
,
𝔽
(
k
),
O
»).
Set
k
to
k
+ 1.
Return
accumulator
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.25
Array.prototype.reduceRight (
callback
[ ,
initialValue
] )
Note 1
callback
should be a function that takes four arguments.
reduceRight
calls the callback, as a function, once for each element after the first element present in the array, in descending order.
callback
is called with four arguments: the
previousValue
(value from the previous call to
callback
), the
currentValue
(value of the current element), the
currentIndex
, and the object being traversed. The first time the function is called, the
previousValue
and
currentValue
can be one of two values. If an
initialValue
was supplied in the call to
reduceRight
, then
previousValue
will be
initialValue
and
currentValue
will be the last value in the array. If no
initialValue
was supplied, then
previousValue
will be the last value in the array and
currentValue
will be the second-to-last value. It is a
TypeError
if the array contains no elements and
initialValue
is not provided.
reduceRight
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
The range of elements processed by
reduceRight
is set before the first call to
callback
. Elements that are appended to the array after the call to
reduceRight
begins will not be visited by
callback
. If existing elements of the array are changed by
callback
, their value as passed to
callback
will be the value at the time
reduceRight
visits them; elements that are deleted after the call to
reduceRight
begins and before being visited are not visited.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
If
len
= 0 and
initialValue
is not present, throw a
TypeError
exception.
Let
k
be
len
- 1.
Let
accumulator
be
undefined
.
If
initialValue
is present, then
Set
accumulator
to
initialValue
.
Else,
Let
kPresent
be
false
.
Repeat, while
kPresent
is
false
and
k
≥ 0,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Set
kPresent
to ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Set
accumulator
to ?
Get
(
O
,
Pk
).
Set
k
to
k
- 1.
If
kPresent
is
false
, throw a
TypeError
exception.
Repeat, while
k
≥ 0,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Set
accumulator
to ?
Call
(
callback
,
undefined
, «
accumulator
,
kValue
,
𝔽
(
k
),
O
»).
Set
k
to
k
- 1.
Return
accumulator
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.26
Array.prototype.reverse ( )
Note 1
This method rearranges the elements of the array so as to reverse their order. It returns the reversed array.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
middle
be
floor
(
len
/ 2).
Let
lower
be 0.
Repeat, while
lower
≠
middle
,
Let
upper
be
len
-
lower
- 1.
Let
upperP
be !
ToString
(
𝔽
(
upper
)).
Let
lowerP
be !
ToString
(
𝔽
(
lower
)).
Let
lowerExists
be ?
HasProperty
(
O
,
lowerP
).
If
lowerExists
is
true
, then
Let
lowerValue
be ?
Get
(
O
,
lowerP
).
Let
upperExists
be ?
HasProperty
(
O
,
upperP
).
If
upperExists
is
true
, then
Let
upperValue
be ?
Get
(
O
,
upperP
).
If
lowerExists
is
true
and
upperExists
is
true
, then
Perform ?
Set
(
O
,
lowerP
,
upperValue
,
true
).
Perform ?
Set
(
O
,
upperP
,
lowerValue
,
true
).
Else if
lowerExists
is
false
and
upperExists
is
true
, then
Perform ?
Set
(
O
,
lowerP
,
upperValue
,
true
).
Perform ?
DeletePropertyOrThrow
(
O
,
upperP
).
Else if
lowerExists
is
true
and
upperExists
is
false
, then
Perform ?
DeletePropertyOrThrow
(
O
,
lowerP
).
Perform ?
Set
(
O
,
upperP
,
lowerValue
,
true
).
Else,
Assert
:
lowerExists
and
upperExists
are both
false
.
NOTE: No action is required.
Set
lower
to
lower
+ 1.
Return
O
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.
23.1.3.27
Array.prototype.shift ( )
This method removes the first element of the array and returns it.
It performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
len
= 0, then
Perform ?
Set
(
O
,
"length"
,
+0
𝔽
,
true
).
Return
undefined
.
Let
first
be ?
Get
(
O
,
"0"
).
Let
k
be 1.
Repeat, while
k
<
len
,
Let
from
be !
ToString
(
𝔽
(
k
)).
Let
to
be !
ToString
(
𝔽
(
k
- 1)).
Let
fromPresent
be ?
HasProperty
(
O
,
from
).
If
fromPresent
is
true
, then
Let
fromValue
be ?
Get
(
O
,
from
).
Perform ?
Set
(
O
,
to
,
fromValue
,
true
).
Else,
Assert
:
fromPresent
is
false
.
Perform ?
DeletePropertyOrThrow
(
O
,
to
).
Set
k
to
k
+ 1.
Perform ?
DeletePropertyOrThrow
(
O
, !
ToString
(
𝔽
(
len
- 1))).
Perform ?
Set
(
O
,
"length"
,
𝔽
(
len
- 1),
true
).
Return
first
.
Note
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.28
Array.prototype.slice (
start
,
end
)
This method returns an array containing the elements of the array from element
start
up to, but not including, element
end
(or through the end of the array if
end
is
undefined
). If
start
is negative, it is treated as
length
+
start
where
length
is the length of the array. If
end
is negative, it is treated as
length
+
end
where
length
is the length of the array.
It performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
k
be 0.
Else if
relativeStart
< 0, let
k
be
max
(
len
+
relativeStart
, 0).
Else, let
k
be
min
(
relativeStart
,
len
).
If
end
is
undefined
, let
relativeEnd
be
len
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
final
be 0.
Else if
relativeEnd
< 0, let
final
be
max
(
len
+
relativeEnd
, 0).
Else, let
final
be
min
(
relativeEnd
,
len
).
Let
count
be
max
(
final
-
k
, 0).
Let
A
be ?
ArraySpeciesCreate
(
O
,
count
).
Let
n
be 0.
Repeat, while
k
<
final
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Perform ?
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
n
)),
kValue
).
Set
k
to
k
+ 1.
Set
n
to
n
+ 1.
Perform ?
Set
(
A
,
"length"
,
𝔽
(
n
),
true
).
Return
A
.
Note 1
The explicit setting of the
"length"
property in step
15
is intended to ensure the length is correct even when
A
is not a built-in Array.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.29
Array.prototype.some (
callback
[ ,
thisArg
] )
Note 1
callback
should be a function that accepts three arguments and returns a value that is coercible to a Boolean value.
some
calls
callback
once for each element present in the array, in ascending order, until it finds one where
callback
returns
true
. If such an element is found,
some
immediately returns
true
. Otherwise,
some
returns
false
.
callback
is called only for elements of the array which actually exist; it is not called for missing elements of the array.
If a
thisArg
parameter is provided, it will be used as the
this
value for each invocation of
callback
. If it is not provided,
undefined
is used instead.
callback
is called with three arguments: the value of the element, the index of the element, and the object being traversed.
some
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
The range of elements processed by
some
is set before the first call to
callback
. Elements that are appended to the array after the call to
some
begins will not be visited by
callback
. If existing elements of the array are changed, their value as passed to
callback
will be the value at the time that
some
visits them; elements that are deleted after the call to
some
begins and before being visited are not visited.
some
acts like the "exists" quantifier in mathematics. In particular, for an empty array, it returns
false
.
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be ?
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
kValue
be ?
Get
(
O
,
Pk
).
Let
testResult
be
ToBoolean
(?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»)).
If
testResult
is
true
, return
true
.
Set
k
to
k
+ 1.
Return
false
.
Note 2
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.30
Array.prototype.sort (
comparator
)
This method sorts the elements of this array. If
comparator
is not
undefined
, it should be a function that accepts two arguments
x
and
y
and returns a negative Number if
x
<
y
, a positive Number if
x
>
y
, or a zero otherwise.
It performs the following steps when called:
If
comparator
is not
undefined
and
IsCallable
(
comparator
) is
false
, throw a
TypeError
exception.
Let
obj
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
obj
).
Let
SortCompare
be a new
Abstract Closure
with parameters (
x
,
y
) that captures
comparator
and performs the following steps when called:
Return ?
CompareArrayElements
(
x
,
y
,
comparator
).
Let
sortedList
be ?
SortIndexedProperties
(
obj
,
len
,
SortCompare
,
skip-holes
).
Let
itemCount
be the number of elements in
sortedList
.
Let
j
be 0.
Repeat, while
j
<
itemCount
,
Perform ?
Set
(
obj
, !
ToString
(
𝔽
(
j
)),
sortedList
[
j
],
true
).
Set
j
to
j
+ 1.
NOTE: The call to
SortIndexedProperties
in step
5
uses
skip-holes
. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.
Repeat, while
j
<
len
,
Perform ?
DeletePropertyOrThrow
(
obj
, !
ToString
(
𝔽
(
j
))).
Set
j
to
j
+ 1.
Return
obj
.
Note 1
Because non-existent property values always compare greater than
undefined
property values, and
undefined
always compares greater than any other value (see
CompareArrayElements
),
undefined
property values always sort to the end of the result, followed by non-existent property values.
Note 2
Method calls performed by the
ToString
abstract operations
in steps
5
and
6
have the potential to cause
SortCompare
to not behave as a
consistent comparator
.
Note 3
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.
23.1.3.30.1
SortIndexedProperties (
obj
,
len
,
SortCompare
,
holes
)
The abstract operation SortIndexedProperties takes arguments
obj
(an Object),
len
(a non-negative
integer
),
SortCompare
(an
Abstract Closure
with two parameters), and
holes
(
skip-holes
or
read-through-holes
) and returns either a
normal completion containing
a
List
of
ECMAScript language values
or a
throw completion
. It performs the following steps when called:
Let
items
be a new empty
List
.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
If
holes
is
skip-holes
, then
Let
kRead
be ?
HasProperty
(
obj
,
Pk
).
Else,
Assert
:
holes
is
read-through-holes
.
Let
kRead
be
true
.
If
kRead
is
true
, then
Let
kValue
be ?
Get
(
obj
,
Pk
).
Append
kValue
to
items
.
Set
k
to
k
+ 1.
Sort
items
using an
implementation-defined
sequence of
calls to
SortCompare
. If any such call returns an
abrupt completion
, stop before performing any further calls to
SortCompare
and return that
Completion Record
.
Return
items
.
The
sort order
is the ordering of
items
after completion of step
4
of the algorithm above. The
sort order
is
implementation-defined
if
SortCompare
is not a
consistent comparator
for the elements of
items
. When SortIndexedProperties is invoked by
Array.prototype.sort
or
Array.prototype.toSorted
, the
sort order
is also
implementation-defined
if
comparator
is
undefined
, and all applications of
ToString
, to any specific value passed as an argument to
SortCompare
, do not produce the same result.
Unless the
sort order
is specified to be
implementation-defined
, it must satisfy all of the following conditions:
There must be some mathematical permutation π of the non-negative
integers
less than
itemCount
, such that for every non-negative
integer
j
less than
itemCount
, the element
old[
j
]
is exactly the same as
new[π(
j
)]
.
Then for all non-negative
integers
j
and
k
, each less than
itemCount
, if
ℝ
(
SortCompare
(old[
j
], old[
k
])) < 0
, then
π(
j
) < π(
k
)
.
And for all non-negative
integers
j
and
k
such that
j
<
k
<
itemCount
, if
ℝ
(
SortCompare
(old[
j
], old[
k
])) = 0
, then
π(
j
) < π(
k
)
; i.e., the sort is stable.
Here the notation
old[
j
]
is used to refer to
items
[
j
]
before step
4
is executed, and the notation
new[
j
]
to refer to
items
[
j
]
after step
4
has been executed.
An abstract closure or function
comparator
is a
consistent comparator
for a set of values
S
if all of the requirements below are met for all values
a
,
b
, and
c
(possibly the same value) in the set
S
: The notation
a
<
C
b
means
ℝ
(
comparator
(
a
,
b
)) < 0
;
a
=
C
b
means
ℝ
(
comparator
(
a
,
b
)) = 0
; and
a
>
C
b
means
ℝ
(
comparator
(
a
,
b
)) > 0
.
Calling
comparator
(
a
,
b
) always returns the same value
v
when given a specific pair of values
a
and
b
as its two arguments. Furthermore,
v
is a Number
, and
v
is not
NaN
. Note that this implies that exactly one of
a
<
C
b
,
a
=
C
b
, and
a
>
C
b
will be true for a given pair of
a
and
b
.
Calling
comparator
(
a
,
b
) does not modify
obj
or any object on
obj
's prototype chain.
a
=
C
a
(reflexivity)
If
a
=
C
b
, then
b
=
C
a
(symmetry)
If
a
=
C
b
and
b
=
C
c
, then
a
=
C
c
(transitivity of =
C
)
If
a
<
C
b
and
b
<
C
c
, then
a
<
C
c
(transitivity of <
C
)
If
a
>
C
b
and
b
>
C
c
, then
a
>
C
c
(transitivity of >
C
)
Note
The above conditions are necessary and sufficient to ensure that
comparator
divides the set
S
into equivalence classes and that these equivalence classes are totally ordered.
23.1.3.30.2
CompareArrayElements (
x
,
y
,
comparator
)
The abstract operation CompareArrayElements takes arguments
x
(an
ECMAScript language value
),
y
(an
ECMAScript language value
), and
comparator
(a
function object
or
undefined
) and returns either a
normal completion containing
a Number or an
abrupt completion
. It performs the following steps when called:
If
x
and
y
are both
undefined
, return
+0
𝔽
.
If
x
is
undefined
, return
1
𝔽
.
If
y
is
undefined
, return
-1
𝔽
.
If
comparator
is not
undefined
, then
Let
v
be ?
ToNumber
(?
Call
(
comparator
,
undefined
, «
x
,
y
»)).
If
v
is
NaN
, return
+0
𝔽
.
Return
v
.
Let
xString
be ?
ToString
(
x
).
Let
yString
be ?
ToString
(
y
).
Let
xSmaller
be !
IsLessThan
(
xString
,
yString
,
true
).
If
xSmaller
is
true
, return
-1
𝔽
.
Let
ySmaller
be !
IsLessThan
(
yString
,
xString
,
true
).
If
ySmaller
is
true
, return
1
𝔽
.
Return
+0
𝔽
.
23.1.3.31
Array.prototype.splice (
start
,
deleteCount
, ...
items
)
Note 1
This method deletes the
deleteCount
elements of the array starting at
integer index
start
and replaces them with the elements of
items
. It returns an Array containing the deleted elements (if any).
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
actualStart
be 0.
Else if
relativeStart
< 0, let
actualStart
be
max
(
len
+
relativeStart
, 0).
Else, let
actualStart
be
min
(
relativeStart
,
len
).
Let
itemCount
be the number of elements in
items
.
If
start
is not present, then
Let
actualDeleteCount
be 0.
Else if
deleteCount
is not present, then
Let
actualDeleteCount
be
len
-
actualStart
.
Else,
Let
dc
be ?
ToIntegerOrInfinity
(
deleteCount
).
Let
actualDeleteCount
be the result of
clamping
dc
between 0 and
len
-
actualStart
.
If
len
+
itemCount
-
actualDeleteCount
> 2
53
- 1, throw a
TypeError
exception.
Let
A
be ?
ArraySpeciesCreate
(
O
,
actualDeleteCount
).
Let
k
be 0.
Repeat, while
k
<
actualDeleteCount
,
Let
from
be !
ToString
(
𝔽
(
actualStart
+
k
)).
If ?
HasProperty
(
O
,
from
) is
true
, then
Let
fromValue
be ?
Get
(
O
,
from
).
Perform ?
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
k
)),
fromValue
).
Set
k
to
k
+ 1.
Perform ?
Set
(
A
,
"length"
,
𝔽
(
actualDeleteCount
),
true
).
If
itemCount
<
actualDeleteCount
, then
Set
k
to
actualStart
.
Repeat, while
k
< (
len
-
actualDeleteCount
),
Let
from
be !
ToString
(
𝔽
(
k
+
actualDeleteCount
)).
Let
to
be !
ToString
(
𝔽
(
k
+
itemCount
)).
If ?
HasProperty
(
O
,
from
) is
true
, then
Let
fromValue
be ?
Get
(
O
,
from
).
Perform ?
Set
(
O
,
to
,
fromValue
,
true
).
Else,
Perform ?
DeletePropertyOrThrow
(
O
,
to
).
Set
k
to
k
+ 1.
Set
k
to
len
.
Repeat, while
k
> (
len
-
actualDeleteCount
+
itemCount
),
Perform ?
DeletePropertyOrThrow
(
O
, !
ToString
(
𝔽
(
k
- 1))).
Set
k
to
k
- 1.
Else if
itemCount
>
actualDeleteCount
, then
Set
k
to (
len
-
actualDeleteCount
).
Repeat, while
k
>
actualStart
,
Let
from
be !
ToString
(
𝔽
(
k
+
actualDeleteCount
- 1)).
Let
to
be !
ToString
(
𝔽
(
k
+
itemCount
- 1)).
If ?
HasProperty
(
O
,
from
) is
true
, then
Let
fromValue
be ?
Get
(
O
,
from
).
Perform ?
Set
(
O
,
to
,
fromValue
,
true
).
Else,
Perform ?
DeletePropertyOrThrow
(
O
,
to
).
Set
k
to
k
- 1.
Set
k
to
actualStart
.
For each element
E
of
items
, do
Perform ?
Set
(
O
, !
ToString
(
𝔽
(
k
)),
E
,
true
).
Set
k
to
k
+ 1.
Perform ?
Set
(
O
,
"length"
,
𝔽
(
len
-
actualDeleteCount
+
itemCount
),
true
).
Return
A
.
Note 2
The explicit setting of the
"length"
property in steps
15
and
20
is intended to ensure the lengths are correct even when the objects are not built-in Arrays.
Note 3
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.32
Array.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.
Note 1
The first edition of ECMA-402 did not include a replacement specification for this method.
The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.
This method performs the following steps when called:
Let
array
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
array
).
Let
separator
be the
implementation-defined
list-separator String value appropriate for the
host environment
's current locale (such as
", "
).
Let
R
be the empty String.
Let
k
be 0.
Repeat, while
k
<
len
,
If
k
> 0, set
R
to the
string-concatenation
of
R
and
separator
.
Let
element
be ?
Get
(
array
, !
ToString
(
𝔽
(
k
))).
If
element
is neither
undefined
nor
null
, then
Let
S
be ?
ToString
(?
Invoke
(
element
,
"toLocaleString"
)).
Set
R
to the
string-concatenation
of
R
and
S
.
Set
k
to
k
+ 1.
Return
R
.
Note 2
This method converts the elements of the array to Strings using their
toLocaleString
methods, and then concatenates these Strings, separated by occurrences of an
implementation-defined
locale-sensitive separator String. This method is analogous to
toString
except that it is intended to yield a locale-sensitive result corresponding with conventions of the
host environment
's current locale.
Note 3
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.33
Array.prototype.toReversed ( )
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
A
be ?
ArrayCreate
(
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
from
be !
ToString
(
𝔽
(
len
-
k
- 1)).
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
fromValue
be ?
Get
(
O
,
from
).
Perform !
CreateDataPropertyOrThrow
(
A
,
Pk
,
fromValue
).
Set
k
to
k
+ 1.
Return
A
.
23.1.3.34
Array.prototype.toSorted (
comparator
)
This method performs the following steps when called:
If
comparator
is not
undefined
and
IsCallable
(
comparator
) is
false
, throw a
TypeError
exception.
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
A
be ?
ArrayCreate
(
len
).
Let
SortCompare
be a new
Abstract Closure
with parameters (
x
,
y
) that captures
comparator
and performs the following steps when called:
Return ?
CompareArrayElements
(
x
,
y
,
comparator
).
Let
sortedList
be ?
SortIndexedProperties
(
O
,
len
,
SortCompare
,
read-through-holes
).
Let
j
be 0.
Repeat, while
j
<
len
,
Perform !
CreateDataPropertyOrThrow
(
A
, !
ToString
(
𝔽
(
j
)),
sortedList
[
j
]).
Set
j
to
j
+ 1.
Return
A
.
23.1.3.35
Array.prototype.toSpliced (
start
,
skipCount
, ...
items
)
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
actualStart
be 0.
Else if
relativeStart
< 0, let
actualStart
be
max
(
len
+
relativeStart
, 0).
Else, let
actualStart
be
min
(
relativeStart
,
len
).
Let
insertCount
be the number of elements in
items
.
If
start
is not present, then
Let
actualSkipCount
be 0.
Else if
skipCount
is not present, then
Let
actualSkipCount
be
len
-
actualStart
.
Else,
Let
sc
be ?
ToIntegerOrInfinity
(
skipCount
).
Let
actualSkipCount
be the result of
clamping
sc
between 0 and
len
-
actualStart
.
Let
newLen
be
len
+
insertCount
-
actualSkipCount
.
If
newLen
> 2
53
- 1, throw a
TypeError
exception.
Let
A
be ?
ArrayCreate
(
newLen
).
Let
i
be 0.
Let
r
be
actualStart
+
actualSkipCount
.
Repeat, while
i
<
actualStart
,
Let
Pi
be !
ToString
(
𝔽
(
i
)).
Let
iValue
be ?
Get
(
O
,
Pi
).
Perform !
CreateDataPropertyOrThrow
(
A
,
Pi
,
iValue
).
Set
i
to
i
+ 1.
For each element
E
of
items
, do
Let
Pi
be !
ToString
(
𝔽
(
i
)).
Perform !
CreateDataPropertyOrThrow
(
A
,
Pi
,
E
).
Set
i
to
i
+ 1.
Repeat, while
i
<
newLen
,
Let
Pi
be !
ToString
(
𝔽
(
i
)).
Let
from
be !
ToString
(
𝔽
(
r
)).
Let
fromValue
be ?
Get
(
O
,
from
).
Perform !
CreateDataPropertyOrThrow
(
A
,
Pi
,
fromValue
).
Set
i
to
i
+ 1.
Set
r
to
r
+ 1.
Return
A
.
23.1.3.36
Array.prototype.toString ( )
This method performs the following steps when called:
Let
array
be ?
ToObject
(
this
value).
Let
func
be ?
Get
(
array
,
"join"
).
If
IsCallable
(
func
) is
false
, set
func
to the intrinsic function %Object.prototype.toString%.
Return ?
Call
(
func
,
array
).
Note
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.37
Array.prototype.unshift ( ...
items
)
This method prepends the arguments to the start of the array, such that their order within the array is the same as the order in which they appear in the argument list.
It performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
argCount
be the number of elements in
items
.
If
argCount
> 0, then
If
len
+
argCount
> 2
53
- 1, throw a
TypeError
exception.
Let
k
be
len
.
Repeat, while
k
> 0,
Let
from
be !
ToString
(
𝔽
(
k
- 1)).
Let
to
be !
ToString
(
𝔽
(
k
+
argCount
- 1)).
Let
fromPresent
be ?
HasProperty
(
O
,
from
).
If
fromPresent
is
true
, then
Let
fromValue
be ?
Get
(
O
,
from
).
Perform ?
Set
(
O
,
to
,
fromValue
,
true
).
Else,
Assert
:
fromPresent
is
false
.
Perform ?
DeletePropertyOrThrow
(
O
,
to
).
Set
k
to
k
- 1.
Let
j
be
+0
𝔽
.
For each element
E
of
items
, do
Perform ?
Set
(
O
, !
ToString
(
j
),
E
,
true
).
Set
j
to
j
+
1
𝔽
.
Perform ?
Set
(
O
,
"length"
,
𝔽
(
len
+
argCount
),
true
).
Return
𝔽
(
len
+
argCount
).
The
"length"
property of this method is
1
𝔽
.
Note
This method is intentionally generic; it does not require that its
this
value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.
23.1.3.38
Array.prototype.values ( )
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Return
CreateArrayIterator
(
O
,
value
).
23.1.3.39
Array.prototype.with (
index
,
value
)
This method performs the following steps when called:
Let
O
be ?
ToObject
(
this
value).
Let
len
be ?
LengthOfArrayLike
(
O
).
Let
relativeIndex
be ?
ToIntegerOrInfinity
(
index
).
If
relativeIndex
≥ 0, let
actualIndex
be
relativeIndex
.
Else, let
actualIndex
be
len
+
relativeIndex
.
If
actualIndex
≥
len
or
actualIndex
< 0, throw a
RangeError
exception.
Let
A
be ?
ArrayCreate
(
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
If
k
=
actualIndex
, let
fromValue
be
value
.
Else, let
fromValue
be ?
Get
(
O
,
Pk
).
Perform !
CreateDataPropertyOrThrow
(
A
,
Pk
,
fromValue
).
Set
k
to
k
+ 1.
Return
A
.
23.1.3.40
Array.prototype [ %Symbol.iterator% ] ( )
The initial value of the
%Symbol.iterator%
property is %Array.prototype.values%, defined in
23.1.3.38
.
23.1.3.41
Array.prototype [ %Symbol.unscopables% ]
The initial value of the
%Symbol.unscopables%
data property
is an object created by the following steps:
Let
unscopableList
be
OrdinaryObjectCreate
(
null
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"at"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"copyWithin"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"entries"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"fill"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"find"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"findIndex"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"findLast"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"findLastIndex"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"flat"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"flatMap"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"includes"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"keys"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"toReversed"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"toSorted"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"toSpliced"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
unscopableList
,
"values"
,
true
).
Return
unscopableList
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
Note
The own
property names
of this object are
property names
that were not included as standard properties of
Array.prototype
prior to the ECMAScript 2015 specification. These names are ignored for
with
statement binding purposes in order to preserve the behaviour of existing code that might use one of these names as a binding in an outer scope that is shadowed by a
with
statement whose binding object is an Array.
The reason that
"with"
is not included in the
unscopableList
is because it is already a
reserved word
.
23.1.4
Properties of Array Instances
Array instances are
Array exotic objects
and have the internal methods specified for such objects. Array instances inherit properties from the
Array prototype object
.
Array instances have a
"length"
property, and a set of enumerable properties with
array index
names.
23.1.4.1
length
The
"length"
property of an Array instance is a
data property
whose value is always numerically greater than the name of every configurable own property whose name is an
array index
.
The
"length"
property initially has the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
Reducing the value of the
"length"
property has the side-effect of deleting own array elements whose
array index
is between the old and new length values. However, non-configurable properties can not be deleted. Attempting to set the
"length"
property of an Array to a value that is numerically less than or equal to the largest numeric own
property name
of an existing non-configurable
array-indexed
property of the array will result in the length being set to a numeric value that is one greater than that non-configurable numeric own
property name
. See
10.4.2.1
.
23.1.5
Array Iterator Objects
An
Array Iterator
is an object that represents a specific iteration over some specific Array instance object. There is not a named
constructor
for Array Iterator objects. Instead, Array Iterator objects are created by calling certain methods of Array instance objects.
23.1.5.1
CreateArrayIterator (
array
,
kind
)
The abstract operation CreateArrayIterator takes arguments
array
(an Object) and
kind
(
key+value
,
key
, or
value
) and returns an Object. It is used to create
iterator objects
for Array methods that return such
iterators
. It performs the following steps when called:
Let
iterator
be
OrdinaryObjectCreate
(
%ArrayIteratorPrototype%
, «
[[IteratedArrayLike]]
,
[[ArrayLikeNextIndex]]
,
[[ArrayLikeIterationKind]]
»).
Set
iterator
.
[[IteratedArrayLike]]
to
array
.
Set
iterator
.
[[ArrayLikeNextIndex]]
to 0.
Set
iterator
.
[[ArrayLikeIterationKind]]
to
kind
.
Return
iterator
.
23.1.5.2
The %ArrayIteratorPrototype% Object
The
%ArrayIteratorPrototype%
object:
has properties that are inherited by all
Array Iterator objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
has the following properties:
23.1.5.2.1
%ArrayIteratorPrototype%.next ( )
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
If
O
does not have all of the internal slots of an
Array Iterator
Instance (
23.1.5.3
), throw a
TypeError
exception.
Let
array
be
O
.
[[IteratedArrayLike]]
.
If
array
is
undefined
, return
CreateIteratorResultObject
(
undefined
,
true
).
Let
index
be
O
.
[[ArrayLikeNextIndex]]
.
Let
kind
be
O
.
[[ArrayLikeIterationKind]]
.
If
array
has a
[[TypedArrayName]]
internal slot, then
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
array
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Let
len
be
TypedArrayLength
(
taRecord
).
Else,
Let
len
be ?
LengthOfArrayLike
(
array
).
If
index
≥
len
, then
Set
O
.
[[IteratedArrayLike]]
to
undefined
.
Return
CreateIteratorResultObject
(
undefined
,
true
).
Set
O
.
[[ArrayLikeNextIndex]]
to
index
+ 1.
Let
indexNumber
be
𝔽
(
index
).
If
kind
is
key
, then
Let
result
be
indexNumber
.
Else,
Let
elementKey
be !
ToString
(
indexNumber
).
Let
elementValue
be ?
Get
(
array
,
elementKey
).
If
kind
is
value
, then
Let
result
be
elementValue
.
Else,
Assert
:
kind
is
key+value
.
Let
result
be
CreateArrayFromList
(«
indexNumber
,
elementValue
»).
Return
CreateIteratorResultObject
(
result
,
false
).
23.1.5.2.2
%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Array Iterator"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
23.1.5.3
Properties of Array Iterator Instances
Array Iterator
instances are
ordinary objects
that inherit properties from the
%ArrayIteratorPrototype%
intrinsic object.
Array Iterator
instances are initially created with the internal slots listed in
Table 69
.
Table 69: Internal Slots of
Array Iterator
Instances
Internal Slot
Type
Description
[[IteratedArrayLike]]
an Object or
undefined
The
array-like object
that is being iterated.
[[ArrayLikeNextIndex]]
a non-negative
integer
The
integer index
of the next element to be examined by this
iterator
.
[[ArrayLikeIterationKind]]
key+value
,
key
, or
value
A value that identifies what is returned for each element of the iteration.
23.2
TypedArray Objects
A
TypedArray
presents an array-like view of an underlying binary data buffer (
25.1
). A
TypedArray element type
is the underlying binary scalar data type that all elements of a
TypedArray
instance have. There is a distinct
TypedArray
constructor
, listed in
Table 70
, for each of the supported element types. Each
constructor
in
Table 70
has a corresponding distinct prototype object.
Table 70: The
TypedArray
Constructors
Constructor
Name and Intrinsic
Element Type
Element Size
Conversion Operation
Description
Int8Array
%Int8Array%
int8
1
ToInt8
8-bit two's complement signed
integer
Uint8Array
%Uint8Array%
uint8
1
ToUint8
8-bit unsigned
integer
Uint8ClampedArray
%Uint8ClampedArray%
uint8clamped
1
ToUint8Clamp
8-bit unsigned
integer
(clamped conversion)
Int16Array
%Int16Array%
int16
2
ToInt16
16-bit two's complement signed
integer
Uint16Array
%Uint16Array%
uint16
2
ToUint16
16-bit unsigned
integer
Int32Array
%Int32Array%
int32
4
ToInt32
32-bit two's complement signed
integer
Uint32Array
%Uint32Array%
uint32
4
ToUint32
32-bit unsigned
integer
BigInt64Array
%BigInt64Array%
bigint64
8
ToBigInt64
64-bit two's complement signed
integer
BigUint64Array
%BigUint64Array%
biguint64
8
ToBigUint64
64-bit unsigned
integer
Float16Array
%Float16Array%
float16
2
16-bit IEEE floating point
Float32Array
%Float32Array%
float32
4
32-bit IEEE floating point
Float64Array
%Float64Array%
float64
8
64-bit IEEE floating point
In the definitions below, references to
TypedArray
should be replaced with the appropriate
constructor
name from the above table.
23.2.1
The %TypedArray% Intrinsic Object
The
%TypedArray%
intrinsic object:
is a
constructor
function object
that all of the
TypedArray
constructor
objects inherit from.
along with its corresponding prototype object, provides common properties that are inherited by all
TypedArray
constructors
and their instances.
does not have a global name or appear as a property of the
global object
.
acts as the abstract superclass of the various
TypedArray
constructors
.
will throw an error when invoked, because it is an abstract class
constructor
. The
TypedArray
constructors
do not perform a
super
call to it.
23.2.1.1
%TypedArray% ( )
This function performs the following steps when called:
Throw a
TypeError
exception.
The
"length"
property of this function is
+0
𝔽
.
23.2.2
Properties of the %TypedArray% Intrinsic Object
The
%TypedArray%
intrinsic object:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has a
"name"
property whose value is
"TypedArray"
.
has the following properties:
23.2.2.1
%TypedArray%.from (
source
[ ,
mapper
[ ,
thisArg
] ] )
This method performs the following steps when called:
Let
C
be the
this
value.
If
IsConstructor
(
C
) is
false
, throw a
TypeError
exception.
If
mapper
is
undefined
, then
Let
mapping
be
false
.
Else,
If
IsCallable
(
mapper
) is
false
, throw a
TypeError
exception.
Let
mapping
be
true
.
Let
usingIterator
be ?
GetMethod
(
source
,
%Symbol.iterator%
).
If
usingIterator
is not
undefined
, then
Let
values
be ?
IteratorToList
(?
GetIteratorFromMethod
(
source
,
usingIterator
)).
Let
len
be the number of elements in
values
.
Let
targetObj
be ?
TypedArrayCreateFromConstructor
(
C
, «
𝔽
(
len
) »).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be the first element of
values
.
Remove the first element from
values
.
If
mapping
is
true
, then
Let
mappedValue
be ?
Call
(
mapper
,
thisArg
, «
kValue
,
𝔽
(
k
) »).
Else,
Let
mappedValue
be
kValue
.
Perform ?
Set
(
targetObj
,
Pk
,
mappedValue
,
true
).
Set
k
to
k
+ 1.
Assert
:
values
is now an empty
List
.
Return
targetObj
.
NOTE:
source
is not an
iterable object
, so assume it is already an
array-like object
.
Let
arrayLike
be !
ToObject
(
source
).
Let
len
be ?
LengthOfArrayLike
(
arrayLike
).
Let
targetObj
be ?
TypedArrayCreateFromConstructor
(
C
, «
𝔽
(
len
) »).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be ?
Get
(
arrayLike
,
Pk
).
If
mapping
is
true
, then
Let
mappedValue
be ?
Call
(
mapper
,
thisArg
, «
kValue
,
𝔽
(
k
) »).
Else,
Let
mappedValue
be
kValue
.
Perform ?
Set
(
targetObj
,
Pk
,
mappedValue
,
true
).
Set
k
to
k
+ 1.
Return
targetObj
.
23.2.2.2
%TypedArray%.of ( ...
items
)
This method performs the following steps when called:
Let
len
be the number of elements in
items
.
Let
C
be the
this
value.
If
IsConstructor
(
C
) is
false
, throw a
TypeError
exception.
Let
newObj
be ?
TypedArrayCreateFromConstructor
(
C
, «
𝔽
(
len
) »).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
kValue
be
items
[
k
].
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Perform ?
Set
(
newObj
,
Pk
,
kValue
,
true
).
Set
k
to
k
+ 1.
Return
newObj
.
23.2.2.3
%TypedArray%.prototype
The initial value of
%TypedArray%
.prototype
is the
%TypedArray% prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
23.2.2.4
get %TypedArray% [ %Symbol.species% ]
%TypedArray%
[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
Note
%TypedArray.prototype%
methods normally use their
this
value's
constructor
to create a derived object. However, a subclass
constructor
may over-ride that default behaviour by redefining its
%Symbol.species%
property.
23.2.3
Properties of the %TypedArray% Prototype Object
The
%TypedArray% prototype object
:
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is
%TypedArray.prototype%
.
is an
ordinary object
.
does not have a
[[ViewedArrayBuffer]]
or any other of the internal slots that are specific to
TypedArray
instance objects.
23.2.3.1
%TypedArray%.prototype.at (
index
)
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
relativeIndex
be ?
ToIntegerOrInfinity
(
index
).
If
relativeIndex
≥ 0, then
Let
k
be
relativeIndex
.
Else,
Let
k
be
len
+
relativeIndex
.
If
k
< 0 or
k
≥
len
, return
undefined
.
Return !
Get
(
O
, !
ToString
(
𝔽
(
k
))).
23.2.3.2
get %TypedArray%.prototype.buffer
%TypedArray%
.prototype.buffer
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[TypedArrayName]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
buffer
be
O
.
[[ViewedArrayBuffer]]
.
Return
buffer
.
23.2.3.3
get %TypedArray%.prototype.byteLength
%TypedArray%
.prototype.byteLength
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[TypedArrayName]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, return
+0
𝔽
.
Let
size
be
TypedArrayByteLength
(
taRecord
).
Return
𝔽
(
size
).
23.2.3.4
get %TypedArray%.prototype.byteOffset
%TypedArray%
.prototype.byteOffset
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[TypedArrayName]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, return
+0
𝔽
.
Let
offset
be
O
.
[[ByteOffset]]
.
Return
𝔽
(
offset
).
23.2.3.5
%TypedArray%.prototype.constructor
The initial value of
%TypedArray%
.prototype.constructor
is
%TypedArray%
.
23.2.3.6
%TypedArray%.prototype.copyWithin (
target
,
start
[ ,
end
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.copyWithin
as defined in
23.1.3.4
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
relativeTarget
be ?
ToIntegerOrInfinity
(
target
).
If
relativeTarget
= -∞, let
targetIndex
be 0.
Else if
relativeTarget
< 0, let
targetIndex
be
max
(
len
+
relativeTarget
, 0).
Else, let
targetIndex
be
min
(
relativeTarget
,
len
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
startIndex
be 0.
Else if
relativeStart
< 0, let
startIndex
be
max
(
len
+
relativeStart
, 0).
Else, let
startIndex
be
min
(
relativeStart
,
len
).
If
end
is
undefined
, let
relativeEnd
be
len
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
endIndex
be 0.
Else if
relativeEnd
< 0, let
endIndex
be
max
(
len
+
relativeEnd
, 0).
Else, let
endIndex
be
min
(
relativeEnd
,
len
).
Let
count
be
min
(
endIndex
-
startIndex
,
len
-
targetIndex
).
If
count
> 0, then
NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.
Let
buffer
be
O
.
[[ViewedArrayBuffer]]
.
Set
taRecord
to
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Set
len
to
TypedArrayLength
(
taRecord
).
NOTE: Side-effects of the above steps may have reduced the size of
O
, in which case copying should proceed with the longest still-applicable prefix.
Set
count
to
min
(
count
,
len
-
startIndex
,
len
-
targetIndex
).
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
byteOffset
be
O
.
[[ByteOffset]]
.
Let
toByteIndex
be (
targetIndex
×
elementSize
) +
byteOffset
.
Let
fromByteIndex
be (
startIndex
×
elementSize
) +
byteOffset
.
Let
countBytes
be
count
×
elementSize
.
If
fromByteIndex
<
toByteIndex
and
toByteIndex
<
fromByteIndex
+
countBytes
, then
Let
direction
be -1.
Set
fromByteIndex
to
fromByteIndex
+
countBytes
- 1.
Set
toByteIndex
to
toByteIndex
+
countBytes
- 1.
Else,
Let
direction
be 1.
Repeat, while
countBytes
> 0,
Let
value
be
GetValueFromBuffer
(
buffer
,
fromByteIndex
,
uint8
,
true
,
unordered
).
Perform
SetValueInBuffer
(
buffer
,
toByteIndex
,
uint8
,
value
,
true
,
unordered
).
Set
fromByteIndex
to
fromByteIndex
+
direction
.
Set
toByteIndex
to
toByteIndex
+
direction
.
Set
countBytes
to
countBytes
- 1.
Return
O
.
23.2.3.7
%TypedArray%.prototype.entries ( )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
ValidateTypedArray
(
O
,
seq-cst
).
Return
CreateArrayIterator
(
O
,
key+value
).
23.2.3.8
%TypedArray%.prototype.every (
callback
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.every
as defined in
23.1.3.6
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Let
testResult
be
ToBoolean
(?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»)).
If
testResult
is
false
, return
false
.
Set
k
to
k
+ 1.
Return
true
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.9
%TypedArray%.prototype.fill (
value
[ ,
start
[ ,
end
] ] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.fill
as defined in
23.1.3.7
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
O
.
[[ContentType]]
is
bigint
, set
value
to ?
ToBigInt
(
value
).
Otherwise, set
value
to ?
ToNumber
(
value
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
startIndex
be 0.
Else if
relativeStart
< 0, let
startIndex
be
max
(
len
+
relativeStart
, 0).
Else, let
startIndex
be
min
(
relativeStart
,
len
).
If
end
is
undefined
, let
relativeEnd
be
len
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
endIndex
be 0.
Else if
relativeEnd
< 0, let
endIndex
be
max
(
len
+
relativeEnd
, 0).
Else, let
endIndex
be
min
(
relativeEnd
,
len
).
Set
taRecord
to
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Set
len
to
TypedArrayLength
(
taRecord
).
Set
endIndex
to
min
(
endIndex
,
len
).
Let
k
be
startIndex
.
Repeat, while
k
<
endIndex
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Perform !
Set
(
O
,
Pk
,
value
,
true
).
Set
k
to
k
+ 1.
Return
O
.
23.2.3.10
%TypedArray%.prototype.filter (
callback
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.filter
as defined in
23.1.3.8
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
kept
be a new empty
List
.
Let
captured
be 0.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Let
selected
be
ToBoolean
(?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»)).
If
selected
is
true
, then
Append
kValue
to
kept
.
Set
captured
to
captured
+ 1.
Set
k
to
k
+ 1.
Let
A
be ?
TypedArraySpeciesCreate
(
O
, «
𝔽
(
captured
) »).
Let
n
be 0.
For each element
e
of
kept
, do
Perform !
Set
(
A
, !
ToString
(
𝔽
(
n
)),
e
,
true
).
Set
n
to
n
+ 1.
Return
A
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.11
%TypedArray%.prototype.find (
predicate
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.find
as defined in
23.1.3.9
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
ascending
,
predicate
,
thisArg
).
Return
findRec
.
[[Value]]
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.12
%TypedArray%.prototype.findIndex (
predicate
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.findIndex
as defined in
23.1.3.10
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
ascending
,
predicate
,
thisArg
).
Return
findRec
.
[[Index]]
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.13
%TypedArray%.prototype.findLast (
predicate
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.findLast
as defined in
23.1.3.11
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
descending
,
predicate
,
thisArg
).
Return
findRec
.
[[Value]]
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.14
%TypedArray%.prototype.findLastIndex (
predicate
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.findLastIndex
as defined in
23.1.3.12
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
findRec
be ?
FindViaPredicate
(
O
,
len
,
descending
,
predicate
,
thisArg
).
Return
findRec
.
[[Index]]
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.15
%TypedArray%.prototype.forEach (
callback
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.forEach
as defined in
23.1.3.15
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Perform ?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»).
Set
k
to
k
+ 1.
Return
undefined
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.16
%TypedArray%.prototype.includes (
searchElement
[ ,
fromIndex
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.includes
as defined in
23.1.3.16
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
len
= 0, return
false
.
Let
n
be ?
ToIntegerOrInfinity
(
fromIndex
).
Assert
: If
fromIndex
is
undefined
, then
n
is 0.
If
n
= +∞, return
false
.
Else if
n
= -∞, set
n
to 0.
If
n
≥ 0, then
Let
k
be
n
.
Else,
Let
k
be
len
+
n
.
If
k
< 0, set
k
to 0.
Repeat, while
k
<
len
,
Let
elementK
be !
Get
(
O
, !
ToString
(
𝔽
(
k
))).
If
SameValueZero
(
searchElement
,
elementK
) is
true
, return
true
.
Set
k
to
k
+ 1.
Return
false
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.17
%TypedArray%.prototype.indexOf (
searchElement
[ ,
fromIndex
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.indexOf
as defined in
23.1.3.17
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
len
= 0, return
-1
𝔽
.
Let
n
be ?
ToIntegerOrInfinity
(
fromIndex
).
Assert
: If
fromIndex
is
undefined
, then
n
is 0.
If
n
= +∞, return
-1
𝔽
.
Else if
n
= -∞, set
n
to 0.
If
n
≥ 0, then
Let
k
be
n
.
Else,
Let
k
be
len
+
n
.
If
k
< 0, set
k
to 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be !
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
elementK
be !
Get
(
O
,
Pk
).
If
IsStrictlyEqual
(
searchElement
,
elementK
) is
true
, return
𝔽
(
k
).
Set
k
to
k
+ 1.
Return
-1
𝔽
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.18
%TypedArray%.prototype.join (
separator
)
The interpretation and use of the arguments of this method are the same as for
Array.prototype.join
as defined in
23.1.3.18
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
separator
is
undefined
, let
sep
be
","
.
Else, let
sep
be ?
ToString
(
separator
).
Let
R
be the empty String.
Let
k
be 0.
Repeat, while
k
<
len
,
If
k
> 0, set
R
to the
string-concatenation
of
R
and
sep
.
Let
element
be !
Get
(
O
, !
ToString
(
𝔽
(
k
))).
If
element
is not
undefined
, then
Let
S
be !
ToString
(
element
).
Set
R
to the
string-concatenation
of
R
and
S
.
Set
k
to
k
+ 1.
Return
R
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.19
%TypedArray%.prototype.keys ( )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
ValidateTypedArray
(
O
,
seq-cst
).
Return
CreateArrayIterator
(
O
,
key
).
23.2.3.20
%TypedArray%.prototype.lastIndexOf (
searchElement
[ ,
fromIndex
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.lastIndexOf
as defined in
23.1.3.20
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
len
= 0, return
-1
𝔽
.
If
fromIndex
is present, let
n
be ?
ToIntegerOrInfinity
(
fromIndex
); else let
n
be
len
- 1.
If
n
= -∞, return
-1
𝔽
.
If
n
≥ 0, then
Let
k
be
min
(
n
,
len
- 1).
Else,
Let
k
be
len
+
n
.
Repeat, while
k
≥ 0,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kPresent
be !
HasProperty
(
O
,
Pk
).
If
kPresent
is
true
, then
Let
elementK
be !
Get
(
O
,
Pk
).
If
IsStrictlyEqual
(
searchElement
,
elementK
) is
true
, return
𝔽
(
k
).
Set
k
to
k
- 1.
Return
-1
𝔽
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.21
get %TypedArray%.prototype.length
%TypedArray%
.prototype.length
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[TypedArrayName]]
).
Assert
:
O
has
[[ViewedArrayBuffer]]
and
[[ArrayLength]]
internal slots.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, return
+0
𝔽
.
Let
length
be
TypedArrayLength
(
taRecord
).
Return
𝔽
(
length
).
This function is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.22
%TypedArray%.prototype.map (
callback
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.map
as defined in
23.1.3.21
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
A
be ?
TypedArraySpeciesCreate
(
O
, «
𝔽
(
len
) »).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Let
mappedValue
be ?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»).
Perform ?
Set
(
A
,
Pk
,
mappedValue
,
true
).
Set
k
to
k
+ 1.
Return
A
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.23
%TypedArray%.prototype.reduce (
callback
[ ,
initialValue
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.reduce
as defined in
23.1.3.24
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
If
len
= 0 and
initialValue
is not present, throw a
TypeError
exception.
Let
k
be 0.
Let
accumulator
be
undefined
.
If
initialValue
is present, then
Set
accumulator
to
initialValue
.
Else,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Set
accumulator
to !
Get
(
O
,
Pk
).
Set
k
to
k
+ 1.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Set
accumulator
to ?
Call
(
callback
,
undefined
, «
accumulator
,
kValue
,
𝔽
(
k
),
O
»).
Set
k
to
k
+ 1.
Return
accumulator
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.24
%TypedArray%.prototype.reduceRight (
callback
[ ,
initialValue
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.reduceRight
as defined in
23.1.3.25
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
If
len
= 0 and
initialValue
is not present, throw a
TypeError
exception.
Let
k
be
len
- 1.
Let
accumulator
be
undefined
.
If
initialValue
is present, then
Set
accumulator
to
initialValue
.
Else,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Set
accumulator
to !
Get
(
O
,
Pk
).
Set
k
to
k
- 1.
Repeat, while
k
≥ 0,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Set
accumulator
to ?
Call
(
callback
,
undefined
, «
accumulator
,
kValue
,
𝔽
(
k
),
O
»).
Set
k
to
k
- 1.
Return
accumulator
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.25
%TypedArray%.prototype.reverse ( )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.reverse
as defined in
23.1.3.26
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
middle
be
floor
(
len
/ 2).
Let
lower
be 0.
Repeat, while
lower
≠
middle
,
Let
upper
be
len
-
lower
- 1.
Let
upperP
be !
ToString
(
𝔽
(
upper
)).
Let
lowerP
be !
ToString
(
𝔽
(
lower
)).
Let
lowerValue
be !
Get
(
O
,
lowerP
).
Let
upperValue
be !
Get
(
O
,
upperP
).
Perform !
Set
(
O
,
lowerP
,
upperValue
,
true
).
Perform !
Set
(
O
,
upperP
,
lowerValue
,
true
).
Set
lower
to
lower
+ 1.
Return
O
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.26
%TypedArray%.prototype.set (
source
[ ,
offset
] )
This method sets multiple values in this
TypedArray
, reading the values from
source
. The details differ based upon the type of
source
. The optional
offset
value indicates the first element index in this
TypedArray
where values are written. If omitted, it is assumed to be 0.
It performs the following steps when called:
Let
target
be the
this
value.
Perform ?
RequireInternalSlot
(
target
,
[[TypedArrayName]]
).
Assert
:
target
has a
[[ViewedArrayBuffer]]
internal slot.
Let
targetOffset
be ?
ToIntegerOrInfinity
(
offset
).
If
targetOffset
< 0, throw a
RangeError
exception.
If
source
is an Object
that has a
[[TypedArrayName]]
internal slot, then
Perform ?
SetTypedArrayFromTypedArray
(
target
,
targetOffset
,
source
).
Else,
Perform ?
SetTypedArrayFromArrayLike
(
target
,
targetOffset
,
source
).
Return
undefined
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.26.1
SetTypedArrayFromArrayLike (
target
,
targetOffset
,
source
)
The abstract operation SetTypedArrayFromArrayLike takes arguments
target
(a
TypedArray
),
targetOffset
(a non-negative
integer
or +∞), and
source
(an
ECMAScript language value
, but not a
TypedArray
) and returns either a
normal completion containing
unused
or a
throw completion
. It sets multiple values in
target
, starting at index
targetOffset
, reading the values from
source
. It performs the following steps when called:
Let
targetRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
target
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
targetRecord
) is
true
, throw a
TypeError
exception.
Let
targetLength
be
TypedArrayLength
(
targetRecord
).
Let
src
be ?
ToObject
(
source
).
Let
srcLength
be ?
LengthOfArrayLike
(
src
).
If
targetOffset
= +∞, throw a
RangeError
exception.
If
srcLength
+
targetOffset
>
targetLength
, throw a
RangeError
exception.
Let
k
be 0.
Repeat, while
k
<
srcLength
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
value
be ?
Get
(
src
,
Pk
).
Let
targetIndex
be
𝔽
(
targetOffset
+
k
).
Perform ?
TypedArraySetElement
(
target
,
targetIndex
,
value
).
Set
k
to
k
+ 1.
Return
unused
.
23.2.3.26.2
SetTypedArrayFromTypedArray (
target
,
targetOffset
,
source
)
The abstract operation SetTypedArrayFromTypedArray takes arguments
target
(a
TypedArray
),
targetOffset
(a non-negative
integer
or +∞), and
source
(a
TypedArray
) and returns either a
normal completion containing
unused
or a
throw completion
. It sets multiple values in
target
, starting at index
targetOffset
, reading the values from
source
. It performs the following steps when called:
Let
targetBuffer
be
target
.
[[ViewedArrayBuffer]]
.
Let
targetRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
target
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
targetRecord
) is
true
, throw a
TypeError
exception.
Let
targetLength
be
TypedArrayLength
(
targetRecord
).
Let
srcBuffer
be
source
.
[[ViewedArrayBuffer]]
.
Let
srcRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
source
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
srcRecord
) is
true
, throw a
TypeError
exception.
Let
srcLength
be
TypedArrayLength
(
srcRecord
).
Let
targetType
be
TypedArrayElementType
(
target
).
Let
targetElementSize
be
TypedArrayElementSize
(
target
).
Let
targetByteOffset
be
target
.
[[ByteOffset]]
.
Let
srcType
be
TypedArrayElementType
(
source
).
Let
srcElementSize
be
TypedArrayElementSize
(
source
).
Let
srcByteOffset
be
source
.
[[ByteOffset]]
.
If
targetOffset
= +∞, throw a
RangeError
exception.
If
srcLength
+
targetOffset
>
targetLength
, throw a
RangeError
exception.
If
target
.
[[ContentType]]
is not
source
.
[[ContentType]]
, throw a
TypeError
exception.
If
IsSharedArrayBuffer
(
srcBuffer
) is
true
,
IsSharedArrayBuffer
(
targetBuffer
) is
true
, and
srcBuffer
.
[[ArrayBufferData]]
is
targetBuffer
.
[[ArrayBufferData]]
, let
sameSharedArrayBuffer
be
true
; otherwise let
sameSharedArrayBuffer
be
false
.
If
SameValue
(
srcBuffer
,
targetBuffer
) is
true
or
sameSharedArrayBuffer
is
true
, then
Let
srcByteLength
be
TypedArrayByteLength
(
srcRecord
).
Set
srcBuffer
to ?
CloneArrayBuffer
(
srcBuffer
,
srcByteOffset
,
srcByteLength
).
Let
srcByteIndex
be 0.
Else,
Let
srcByteIndex
be
srcByteOffset
.
Let
targetByteIndex
be (
targetOffset
×
targetElementSize
) +
targetByteOffset
.
Let
limit
be
targetByteIndex
+ (
targetElementSize
×
srcLength
).
If
srcType
is
targetType
, then
NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.
Repeat, while
targetByteIndex
<
limit
,
Let
value
be
GetValueFromBuffer
(
srcBuffer
,
srcByteIndex
,
uint8
,
true
,
unordered
).
Perform
SetValueInBuffer
(
targetBuffer
,
targetByteIndex
,
uint8
,
value
,
true
,
unordered
).
Set
srcByteIndex
to
srcByteIndex
+ 1.
Set
targetByteIndex
to
targetByteIndex
+ 1.
Else,
Repeat, while
targetByteIndex
<
limit
,
Let
value
be
GetValueFromBuffer
(
srcBuffer
,
srcByteIndex
,
srcType
,
true
,
unordered
).
Perform
SetValueInBuffer
(
targetBuffer
,
targetByteIndex
,
targetType
,
value
,
true
,
unordered
).
Set
srcByteIndex
to
srcByteIndex
+
srcElementSize
.
Set
targetByteIndex
to
targetByteIndex
+
targetElementSize
.
Return
unused
.
23.2.3.27
%TypedArray%.prototype.slice (
start
,
end
)
The interpretation and use of the arguments of this method are the same as for
Array.prototype.slice
as defined in
23.1.3.28
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
srcArrayLength
be
TypedArrayLength
(
taRecord
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
startIndex
be 0.
Else if
relativeStart
< 0, let
startIndex
be
max
(
srcArrayLength
+
relativeStart
, 0).
Else, let
startIndex
be
min
(
relativeStart
,
srcArrayLength
).
If
end
is
undefined
, let
relativeEnd
be
srcArrayLength
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
endIndex
be 0.
Else if
relativeEnd
< 0, let
endIndex
be
max
(
srcArrayLength
+
relativeEnd
, 0).
Else, let
endIndex
be
min
(
relativeEnd
,
srcArrayLength
).
Let
countBytes
be
max
(
endIndex
-
startIndex
, 0).
Let
A
be ?
TypedArraySpeciesCreate
(
O
, «
𝔽
(
countBytes
) »).
If
countBytes
> 0, then
Set
taRecord
to
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Set
endIndex
to
min
(
endIndex
,
TypedArrayLength
(
taRecord
)).
Set
countBytes
to
max
(
endIndex
-
startIndex
, 0).
Let
srcType
be
TypedArrayElementType
(
O
).
Let
targetType
be
TypedArrayElementType
(
A
).
If
srcType
is
targetType
, then
NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.
Let
srcBuffer
be
O
.
[[ViewedArrayBuffer]]
.
Let
targetBuffer
be
A
.
[[ViewedArrayBuffer]]
.
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
srcByteOffset
be
O
.
[[ByteOffset]]
.
Let
srcByteIndex
be (
startIndex
×
elementSize
) +
srcByteOffset
.
Let
targetByteIndex
be
A
.
[[ByteOffset]]
.
Let
endByteIndex
be
targetByteIndex
+ (
countBytes
×
elementSize
).
Repeat, while
targetByteIndex
<
endByteIndex
,
Let
value
be
GetValueFromBuffer
(
srcBuffer
,
srcByteIndex
,
uint8
,
true
,
unordered
).
Perform
SetValueInBuffer
(
targetBuffer
,
targetByteIndex
,
uint8
,
value
,
true
,
unordered
).
Set
srcByteIndex
to
srcByteIndex
+ 1.
Set
targetByteIndex
to
targetByteIndex
+ 1.
Else,
Let
n
be 0.
Let
k
be
startIndex
.
Repeat, while
k
<
endIndex
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Perform !
Set
(
A
, !
ToString
(
𝔽
(
n
)),
kValue
,
true
).
Set
k
to
k
+ 1.
Set
n
to
n
+ 1.
Return
A
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.28
%TypedArray%.prototype.some (
callback
[ ,
thisArg
] )
The interpretation and use of the arguments of this method are the same as for
Array.prototype.some
as defined in
23.1.3.29
.
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be !
Get
(
O
,
Pk
).
Let
testResult
be
ToBoolean
(?
Call
(
callback
,
thisArg
, «
kValue
,
𝔽
(
k
),
O
»)).
If
testResult
is
true
, return
true
.
Set
k
to
k
+ 1.
Return
false
.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.29
%TypedArray%.prototype.sort (
comparator
)
This is a distinct method that, except as described below, implements the same requirements as those of
Array.prototype.sort
as defined in
23.1.3.30
. The implementation of this method may be optimized with the knowledge that the
this
value is an object that has a fixed length and whose
integer-indexed
properties are not sparse.
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
It performs the following steps when called:
If
comparator
is not
undefined
and
IsCallable
(
comparator
) is
false
, throw a
TypeError
exception.
Let
obj
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
obj
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
NOTE: The following closure performs a numeric comparison rather than the string comparison used in
23.1.3.30
.
Let
SortCompare
be a new
Abstract Closure
with parameters (
x
,
y
) that captures
comparator
and performs the following steps when called:
Return ?
CompareTypedArrayElements
(
x
,
y
,
comparator
).
Let
sortedList
be ?
SortIndexedProperties
(
obj
,
len
,
SortCompare
,
read-through-holes
).
Let
j
be 0.
Repeat, while
j
<
len
,
Perform !
Set
(
obj
, !
ToString
(
𝔽
(
j
)),
sortedList
[
j
],
true
).
Set
j
to
j
+ 1.
Return
obj
.
Note
Because
NaN
always compares greater than any other value (see
CompareTypedArrayElements
),
NaN
property values always sort to the end of the result when
comparator
is not provided.
23.2.3.30
%TypedArray%.prototype.subarray (
start
,
end
)
This method returns a new
TypedArray
whose element type is the element type of this
TypedArray
and whose ArrayBuffer is the ArrayBuffer of this
TypedArray
, referencing the elements in the
interval
from
start
(inclusive) to
end
(exclusive). If either
start
or
end
is negative, it refers to an index from the end of the array, as opposed to from the beginning.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[TypedArrayName]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
buffer
be
O
.
[[ViewedArrayBuffer]]
.
Let
srcRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
srcRecord
) is
true
, then
Let
srcLength
be 0.
Else,
Let
srcLength
be
TypedArrayLength
(
srcRecord
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
startIndex
be 0.
Else if
relativeStart
< 0, let
startIndex
be
max
(
srcLength
+
relativeStart
, 0).
Else, let
startIndex
be
min
(
relativeStart
,
srcLength
).
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
srcByteOffset
be
O
.
[[ByteOffset]]
.
Let
beginByteOffset
be
srcByteOffset
+ (
startIndex
×
elementSize
).
If
O
.
[[ArrayLength]]
is
auto
and
end
is
undefined
, then
Let
argumentsList
be «
buffer
,
𝔽
(
beginByteOffset
) ».
Else,
If
end
is
undefined
, let
relativeEnd
be
srcLength
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
endIndex
be 0.
Else if
relativeEnd
< 0, let
endIndex
be
max
(
srcLength
+
relativeEnd
, 0).
Else, let
endIndex
be
min
(
relativeEnd
,
srcLength
).
Let
newLength
be
max
(
endIndex
-
startIndex
, 0).
Let
argumentsList
be «
buffer
,
𝔽
(
beginByteOffset
),
𝔽
(
newLength
) ».
Return ?
TypedArraySpeciesCreate
(
O
,
argumentsList
).
This method is not generic. The
this
value must be an object with a
[[TypedArrayName]]
internal slot.
23.2.3.31
%TypedArray%.prototype.toLocaleString ( [
reserved1
[ ,
reserved2
] ] )
This is a distinct method that implements the same algorithm as
Array.prototype.toLocaleString
as defined in
23.1.3.32
except that
TypedArrayLength
is called in place of performing a
[[Get]]
of
"length"
. The implementation of the algorithm may be optimized with the knowledge that the
this
value has a fixed length when the underlying buffer is not resizable and whose
integer-indexed
properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.
This method is not generic.
ValidateTypedArray
is called with the
this
value and
seq-cst
as arguments prior to evaluating the algorithm. If its result is an
abrupt completion
that exception is thrown instead of evaluating the algorithm.
Note
If the ECMAScript implementation includes the ECMA-402 Internationalization API this method is based upon the algorithm for
Array.prototype.toLocaleString
that is in the ECMA-402 specification.
23.2.3.32
%TypedArray%.prototype.toReversed ( )
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
A
be ?
TypedArrayCreateSameType
(
O
,
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
from
be !
ToString
(
𝔽
(
len
-
k
- 1)).
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
fromValue
be !
Get
(
O
,
from
).
Perform !
Set
(
A
,
Pk
,
fromValue
,
true
).
Set
k
to
k
+ 1.
Return
A
.
23.2.3.33
%TypedArray%.prototype.toSorted (
comparator
)
This method performs the following steps when called:
If
comparator
is not
undefined
and
IsCallable
(
comparator
) is
false
, throw a
TypeError
exception.
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
A
be ?
TypedArrayCreateSameType
(
O
,
len
).
NOTE: The following closure performs a numeric comparison rather than the string comparison used in
23.1.3.34
.
Let
SortCompare
be a new
Abstract Closure
with parameters (
x
,
y
) that captures
comparator
and performs the following steps when called:
Return ?
CompareTypedArrayElements
(
x
,
y
,
comparator
).
Let
sortedList
be ?
SortIndexedProperties
(
O
,
len
,
SortCompare
,
read-through-holes
).
Let
j
be 0.
Repeat, while
j
<
len
,
Perform !
Set
(
A
, !
ToString
(
𝔽
(
j
)),
sortedList
[
j
],
true
).
Set
j
to
j
+ 1.
Return
A
.
23.2.3.34
%TypedArray%.prototype.toString ( )
The initial value of the
"toString"
property is %Array.prototype.toString%, defined in
23.1.3.36
.
23.2.3.35
%TypedArray%.prototype.values ( )
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
ValidateTypedArray
(
O
,
seq-cst
).
Return
CreateArrayIterator
(
O
,
value
).
23.2.3.36
%TypedArray%.prototype.with (
index
,
value
)
This method performs the following steps when called:
Let
O
be the
this
value.
Let
taRecord
be ?
ValidateTypedArray
(
O
,
seq-cst
).
Let
len
be
TypedArrayLength
(
taRecord
).
Let
relativeIndex
be ?
ToIntegerOrInfinity
(
index
).
If
relativeIndex
≥ 0, let
actualIndex
be
relativeIndex
.
Else, let
actualIndex
be
len
+
relativeIndex
.
If
O
.
[[ContentType]]
is
bigint
, let
numericValue
be ?
ToBigInt
(
value
).
Else, let
numericValue
be ?
ToNumber
(
value
).
If
IsValidIntegerIndex
(
O
,
𝔽
(
actualIndex
)) is
false
, throw a
RangeError
exception.
Let
A
be ?
TypedArrayCreateSameType
(
O
,
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
If
k
=
actualIndex
, let
fromValue
be
numericValue
.
Else, let
fromValue
be !
Get
(
O
,
Pk
).
Perform !
Set
(
A
,
Pk
,
fromValue
,
true
).
Set
k
to
k
+ 1.
Return
A
.
23.2.3.37
%TypedArray%.prototype [ %Symbol.iterator% ] ( )
The initial value of the
%Symbol.iterator%
property is %TypedArray.prototype.values%, defined in
23.2.3.35
.
23.2.3.38
get %TypedArray%.prototype [ %Symbol.toStringTag% ]
%TypedArray%
.prototype[%Symbol.toStringTag%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, return
undefined
.
If
O
does not have a
[[TypedArrayName]]
internal slot, return
undefined
.
Let
name
be
O
.
[[TypedArrayName]]
.
Assert
:
name
is a String
.
Return
name
.
This property has the attributes {
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
The initial value of the
"name"
property of this function is
"get [Symbol.toStringTag]"
.
23.2.4
Abstract Operations for TypedArray Objects
23.2.4.1
TypedArrayCreateFromConstructor (
constructor
,
argumentList
)
The abstract operation TypedArrayCreateFromConstructor takes arguments
constructor
(a
constructor
) and
argumentList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
a
TypedArray
or a
throw completion
. It is used to specify the creation of a new
TypedArray
using a
constructor
function. It performs the following steps when called:
Let
newTypedArray
be ?
Construct
(
constructor
,
argumentList
).
Let
taRecord
be ?
ValidateTypedArray
(
newTypedArray
,
seq-cst
).
Assert
:
newTypedArray
has all the internal slots mentioned in
Properties of
TypedArray
Instances
.
If the number of elements in
argumentList
is 1 and
argumentList
[0]
is a Number
, then
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Let
length
be
TypedArrayLength
(
taRecord
).
If
length
<
ℝ
(
argumentList
[0]), throw a
TypeError
exception.
Return
newTypedArray
.
23.2.4.2
TypedArrayCreateSameType (
exemplar
,
length
)
The abstract operation TypedArrayCreateSameType takes arguments
exemplar
(a
TypedArray
) and
length
(a non-negative
integer
) and returns either a
normal completion containing
a
TypedArray
or a
throw completion
. It is used to specify the creation of a new
TypedArray
using a
constructor
function that is derived from
exemplar
. Unlike
TypedArraySpeciesCreate
, which can construct custom
TypedArray
subclasses through the use of
%Symbol.species%
, this operation always uses one of the built-in
TypedArray
constructors
. It performs the following steps when called:
Let
constructor
be the intrinsic object associated with the
constructor
name
exemplar
.
[[TypedArrayName]]
in
Table 70
.
Let
result
be ?
TypedArrayCreateFromConstructor
(
constructor
, «
𝔽
(
length
) »).
Assert
:
result
has
[[TypedArrayName]]
and
[[ContentType]]
internal slots.
Assert
:
result
.
[[ContentType]]
is
exemplar
.
[[ContentType]]
.
Return
result
.
23.2.4.3
TypedArraySpeciesCreate (
exemplar
,
argumentList
)
The abstract operation TypedArraySpeciesCreate takes arguments
exemplar
(a
TypedArray
) and
argumentList
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
a
TypedArray
or a
throw completion
. It is used to specify the creation of a new
TypedArray
using a
constructor
function that is derived from
exemplar
. Unlike
ArraySpeciesCreate
, which can create non-Array objects through the use of
%Symbol.species%
, this operation enforces that the
constructor
function creates an actual
TypedArray
. It performs the following steps when called:
Let
defaultConstructor
be the intrinsic object associated with the
constructor
name
exemplar
.
[[TypedArrayName]]
in
Table 70
.
Let
constructor
be ?
SpeciesConstructor
(
exemplar
,
defaultConstructor
).
Let
result
be ?
TypedArrayCreateFromConstructor
(
constructor
,
argumentList
).
If
result
.
[[ContentType]]
is not
exemplar
.
[[ContentType]]
, throw a
TypeError
exception.
Return
result
.
23.2.4.4
ValidateTypedArray (
O
,
order
)
The abstract operation ValidateTypedArray takes arguments
O
(an
ECMAScript language value
) and
order
(
seq-cst
or
unordered
) and returns either a
normal completion containing
a
TypedArray With Buffer Witness Record
or a
throw completion
. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
O
,
[[TypedArrayName]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
O
,
order
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Return
taRecord
.
23.2.4.5
TypedArrayElementSize (
O
)
The abstract operation TypedArrayElementSize takes argument
O
(a
TypedArray
) and returns a non-negative
integer
. It performs the following steps when called:
Return the Element Size value specified in
Table 70
for
O
.
[[TypedArrayName]]
.
23.2.4.6
TypedArrayElementType (
O
)
The abstract operation TypedArrayElementType takes argument
O
(a
TypedArray
) and returns a
TypedArray element type
. It performs the following steps when called:
Return the Element Type value specified in
Table 70
for
O
.
[[TypedArrayName]]
.
23.2.4.7
CompareTypedArrayElements (
x
,
y
,
comparator
)
The abstract operation CompareTypedArrayElements takes arguments
x
(a Number or a BigInt),
y
(a Number or a BigInt), and
comparator
(a
function object
or
undefined
) and returns either a
normal completion containing
a Number or an
abrupt completion
. It performs the following steps when called:
Assert
:
x
is a Number
and
y
is a Number
, or
x
is a BigInt
and
y
is a BigInt
.
If
comparator
is not
undefined
, then
Let
v
be ?
ToNumber
(?
Call
(
comparator
,
undefined
, «
x
,
y
»)).
If
v
is
NaN
, return
+0
𝔽
.
Return
v
.
If
x
and
y
are both
NaN
, return
+0
𝔽
.
If
x
is
NaN
, return
1
𝔽
.
If
y
is
NaN
, return
-1
𝔽
.
If
x
<
y
, return
-1
𝔽
.
If
x
>
y
, return
1
𝔽
.
If
x
is
-0
𝔽
and
y
is
+0
𝔽
, return
-1
𝔽
.
If
x
is
+0
𝔽
and
y
is
-0
𝔽
, return
1
𝔽
.
Return
+0
𝔽
.
Note
This performs a numeric comparison rather than the string comparison used in
23.1.3.30.2
.
23.2.5
The
TypedArray
Constructors
Each
TypedArray
constructor
:
is an intrinsic object that has the structure described below, differing only in the name used as the
constructor
name instead of
TypedArray
, in
Table 70
, except where otherwise noted.
is a function whose behaviour differs based upon the number and types of its arguments. The actual behaviour of a call of
TypedArray
depends upon the number and kind of arguments that are passed to it.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified
TypedArray
behaviour must include a
super
call to the
TypedArray
constructor
to create and initialize the subclass instance with the internal state necessary to support the
%TypedArray%
.prototype
built-in methods.
23.2.5.1
TypedArray
( ...
args
)
Each
TypedArray
constructor
performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
constructorName
be the String value of the
Constructor
Name value specified in
Table 70
for this
TypedArray
constructor
.
Let
proto
be
"%
TypedArray
.prototype%"
.
Let
numberOfArgs
be the number of elements in
args
.
If
numberOfArgs
= 0, then
Return ?
AllocateTypedArray
(
constructorName
, NewTarget,
proto
, 0).
Else,
Let
firstArgument
be
args
[0].
If
firstArgument
is an Object
, then
Let
O
be ?
AllocateTypedArray
(
constructorName
, NewTarget,
proto
).
If
firstArgument
has a
[[TypedArrayName]]
internal slot, then
Perform ?
InitializeTypedArrayFromTypedArray
(
O
,
firstArgument
).
Else if
firstArgument
has an
[[ArrayBufferData]]
internal slot, then
If
numberOfArgs
> 1, let
byteOffset
be
args
[1]; else let
byteOffset
be
undefined
.
If
numberOfArgs
> 2, let
length
be
args
[2]; else let
length
be
undefined
.
Perform ?
InitializeTypedArrayFromArrayBuffer
(
O
,
firstArgument
,
byteOffset
,
length
).
Else,
Assert
:
firstArgument
is an Object
and
firstArgument
does not have either a
[[TypedArrayName]]
or an
[[ArrayBufferData]]
internal slot.
Let
usingIterator
be ?
GetMethod
(
firstArgument
,
%Symbol.iterator%
).
If
usingIterator
is not
undefined
, then
Let
values
be ?
IteratorToList
(?
GetIteratorFromMethod
(
firstArgument
,
usingIterator
)).
Perform ?
InitializeTypedArrayFromList
(
O
,
values
).
Else,
NOTE:
firstArgument
is not an
iterable object
, so assume it is already an
array-like object
.
Perform ?
InitializeTypedArrayFromArrayLike
(
O
,
firstArgument
).
Return
O
.
Else,
Assert
:
firstArgument
is not an Object
.
Let
elementLength
be ?
ToIndex
(
firstArgument
).
Return ?
AllocateTypedArray
(
constructorName
, NewTarget,
proto
,
elementLength
).
23.2.5.1.1
AllocateTypedArray (
constructorName
,
newTarget
,
defaultProto
[ ,
length
] )
The abstract operation AllocateTypedArray takes arguments
constructorName
(a String which is the name of a
TypedArray
constructor
in
Table 70
),
newTarget
(a
constructor
), and
defaultProto
(a String) and optional argument
length
(a non-negative
integer
) and returns either a
normal completion containing
a
TypedArray
or a
throw completion
. It is used to validate and create an instance of a
TypedArray
constructor
. If the
length
argument is passed, an ArrayBuffer of that length is also allocated and associated with the new
TypedArray
instance. AllocateTypedArray provides common semantics that is used by
TypedArray
. It performs the following steps when called:
Let
proto
be ?
GetPrototypeFromConstructor
(
newTarget
,
defaultProto
).
Let
obj
be
TypedArrayCreate
(
proto
).
Assert
:
obj
.
[[ViewedArrayBuffer]]
is
undefined
.
Set
obj
.
[[TypedArrayName]]
to
constructorName
.
If
constructorName
is either
"BigInt64Array"
or
"BigUint64Array"
, set
obj
.
[[ContentType]]
to
bigint
.
Otherwise, set
obj
.
[[ContentType]]
to
number
.
If
length
is not present, then
Set
obj
.
[[ByteLength]]
to 0.
Set
obj
.
[[ByteOffset]]
to 0.
Set
obj
.
[[ArrayLength]]
to 0.
Else,
Perform ?
AllocateTypedArrayBuffer
(
obj
,
length
).
Return
obj
.
23.2.5.1.2
InitializeTypedArrayFromTypedArray (
O
,
srcArray
)
The abstract operation InitializeTypedArrayFromTypedArray takes arguments
O
(a
TypedArray
) and
srcArray
(a
TypedArray
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
srcData
be
srcArray
.
[[ViewedArrayBuffer]]
.
Let
elementType
be
TypedArrayElementType
(
O
).
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
srcType
be
TypedArrayElementType
(
srcArray
).
Let
srcElementSize
be
TypedArrayElementSize
(
srcArray
).
Let
srcByteOffset
be
srcArray
.
[[ByteOffset]]
.
Let
srcRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
srcArray
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
srcRecord
) is
true
, throw a
TypeError
exception.
Let
elementLength
be
TypedArrayLength
(
srcRecord
).
Let
byteLength
be
elementSize
×
elementLength
.
If
elementType
is
srcType
, then
Let
data
be ?
CloneArrayBuffer
(
srcData
,
srcByteOffset
,
byteLength
).
Else,
Let
data
be ?
AllocateArrayBuffer
(
%ArrayBuffer%
,
byteLength
).
If
srcArray
.
[[ContentType]]
is not
O
.
[[ContentType]]
, throw a
TypeError
exception.
Let
srcByteIndex
be
srcByteOffset
.
Let
targetByteIndex
be 0.
Let
count
be
elementLength
.
Repeat, while
count
> 0,
Let
value
be
GetValueFromBuffer
(
srcData
,
srcByteIndex
,
srcType
,
true
,
unordered
).
Perform
SetValueInBuffer
(
data
,
targetByteIndex
,
elementType
,
value
,
true
,
unordered
).
Set
srcByteIndex
to
srcByteIndex
+
srcElementSize
.
Set
targetByteIndex
to
targetByteIndex
+
elementSize
.
Set
count
to
count
- 1.
Set
O
.
[[ViewedArrayBuffer]]
to
data
.
Set
O
.
[[ByteLength]]
to
byteLength
.
Set
O
.
[[ByteOffset]]
to 0.
Set
O
.
[[ArrayLength]]
to
elementLength
.
Return
unused
.
23.2.5.1.3
InitializeTypedArrayFromArrayBuffer (
O
,
buffer
,
byteOffset
,
length
)
The abstract operation InitializeTypedArrayFromArrayBuffer takes arguments
O
(a
TypedArray
),
buffer
(an ArrayBuffer or a SharedArrayBuffer),
byteOffset
(an
ECMAScript language value
), and
length
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
offset
be ?
ToIndex
(
byteOffset
).
If
offset
modulo
elementSize
≠ 0, throw a
RangeError
exception.
Let
bufferIsFixedLength
be
IsFixedLengthArrayBuffer
(
buffer
).
If
length
is not
undefined
, then
Let
newLength
be ?
ToIndex
(
length
).
If
IsDetachedBuffer
(
buffer
) is
true
, throw a
TypeError
exception.
Let
bufferByteLength
be
ArrayBufferByteLength
(
buffer
,
seq-cst
).
If
length
is
undefined
and
bufferIsFixedLength
is
false
, then
If
offset
>
bufferByteLength
, throw a
RangeError
exception.
Set
O
.
[[ByteLength]]
to
auto
.
Set
O
.
[[ArrayLength]]
to
auto
.
Else,
If
length
is
undefined
, then
If
bufferByteLength
modulo
elementSize
≠ 0, throw a
RangeError
exception.
Let
newByteLength
be
bufferByteLength
-
offset
.
If
newByteLength
< 0, throw a
RangeError
exception.
Else,
Let
newByteLength
be
newLength
×
elementSize
.
If
offset
+
newByteLength
>
bufferByteLength
, throw a
RangeError
exception.
Set
O
.
[[ByteLength]]
to
newByteLength
.
Set
O
.
[[ArrayLength]]
to
newByteLength
/
elementSize
.
Set
O
.
[[ViewedArrayBuffer]]
to
buffer
.
Set
O
.
[[ByteOffset]]
to
offset
.
Return
unused
.
23.2.5.1.4
InitializeTypedArrayFromList (
O
,
values
)
The abstract operation InitializeTypedArrayFromList takes arguments
O
(a
TypedArray
) and
values
(a
List
of
ECMAScript language values
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
len
be the number of elements in
values
.
Perform ?
AllocateTypedArrayBuffer
(
O
,
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be the first element of
values
.
Remove the first element from
values
.
Perform ?
Set
(
O
,
Pk
,
kValue
,
true
).
Set
k
to
k
+ 1.
Assert
:
values
is now an empty
List
.
Return
unused
.
23.2.5.1.5
InitializeTypedArrayFromArrayLike (
O
,
arrayLike
)
The abstract operation InitializeTypedArrayFromArrayLike takes arguments
O
(a
TypedArray
) and
arrayLike
(an Object, but not a
TypedArray
or an ArrayBuffer) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Let
len
be ?
LengthOfArrayLike
(
arrayLike
).
Perform ?
AllocateTypedArrayBuffer
(
O
,
len
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
Pk
be !
ToString
(
𝔽
(
k
)).
Let
kValue
be ?
Get
(
arrayLike
,
Pk
).
Perform ?
Set
(
O
,
Pk
,
kValue
,
true
).
Set
k
to
k
+ 1.
Return
unused
.
23.2.5.1.6
AllocateTypedArrayBuffer (
O
,
length
)
The abstract operation AllocateTypedArrayBuffer takes arguments
O
(a
TypedArray
) and
length
(a non-negative
integer
) and returns either a
normal completion containing
unused
or a
throw completion
. It allocates and associates an ArrayBuffer with
O
. It performs the following steps when called:
Assert
:
O
.
[[ViewedArrayBuffer]]
is
undefined
.
Let
elementSize
be
TypedArrayElementSize
(
O
).
Let
byteLength
be
elementSize
×
length
.
Let
data
be ?
AllocateArrayBuffer
(
%ArrayBuffer%
,
byteLength
).
Set
O
.
[[ViewedArrayBuffer]]
to
data
.
Set
O
.
[[ByteLength]]
to
byteLength
.
Set
O
.
[[ByteOffset]]
to 0.
Set
O
.
[[ArrayLength]]
to
length
.
Return
unused
.
23.2.6
Properties of the
TypedArray
Constructors
Each
TypedArray
constructor
:
has a
[[Prototype]]
internal slot whose value is
%TypedArray%
.
has a
"length"
property whose value is
3
𝔽
.
has a
"name"
property whose value is the String value of the
constructor
name specified for it in
Table 70
.
has the following properties:
23.2.6.1
TypedArray
.BYTES_PER_ELEMENT
The value of
TypedArray
.BYTES_PER_ELEMENT
is the Element Size value specified in
Table 70
for
TypedArray
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
23.2.6.2
TypedArray
.prototype
The initial value of
TypedArray
.prototype
is the corresponding
TypedArray
prototype intrinsic object (
23.2.7
).
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
23.2.7
Properties of the
TypedArray
Prototype Objects
Each
TypedArray
prototype object:
has a
[[Prototype]]
internal slot whose value is
%TypedArray.prototype%
.
is an
ordinary object
.
does not have a
[[ViewedArrayBuffer]]
or any other of the internal slots that are specific to
TypedArray
instance objects.
23.2.7.1
TypedArray
.prototype.BYTES_PER_ELEMENT
The value of
TypedArray
.prototype.BYTES_PER_ELEMENT
is the Element Size value specified in
Table 70
for
TypedArray
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
23.2.7.2
TypedArray
.prototype.constructor
The initial value of the
"constructor"
property of the prototype for a given
TypedArray
constructor
is the
constructor
itself.
23.2.8
Properties of
TypedArray
Instances
TypedArray
instances are
TypedArrays
. Each
TypedArray
instance inherits properties from the corresponding
TypedArray
prototype object. Each
TypedArray
instance has the following internal slots:
[[ViewedArrayBuffer]]
,
[[TypedArrayName]]
,
[[ContentType]]
,
[[ByteLength]]
,
[[ByteOffset]]
, and
[[ArrayLength]]
.
23.3
Uint8Array Objects
A Uint8Array is a particular kind of
TypedArray
as described above. In addition, there are additional methods on the Uint8Array
constructor
(
23.3.1
) and on the Uint8Array prototype object (
23.3.2
).
23.3.1
Additional Properties of the Uint8Array Constructor
23.3.1.1
Uint8Array.fromBase64 (
string
[ ,
options
] )
If
string
is not a String
, throw a
TypeError
exception.
Let
opts
be ?
GetOptionsObject
(
options
).
Let
alphabet
be ?
Get
(
opts
,
"alphabet"
).
If
alphabet
is
undefined
, set
alphabet
to
"base64"
.
If
alphabet
is neither
"base64"
nor
"base64url"
, throw a
TypeError
exception.
Let
lastChunkHandling
be ?
Get
(
opts
,
"lastChunkHandling"
).
If
lastChunkHandling
is
undefined
, set
lastChunkHandling
to
"loose"
.
If
lastChunkHandling
is not one of
"loose"
,
"strict"
, or
"stop-before-partial"
, throw a
TypeError
exception.
Let
result
be
FromBase64
(
string
,
alphabet
,
lastChunkHandling
).
If
result
.
[[Error]]
is not
none
, then
Return
ThrowCompletion
(
result
.
[[Error]]
).
Let
resultLength
be the number of elements in
result
.
[[Bytes]]
.
Let
ta
be ?
AllocateTypedArray
(
"Uint8Array"
,
%Uint8Array%
,
"%Uint8Array.prototype%"
,
resultLength
).
Assert
:
ta
.
[[ViewedArrayBuffer]]
.
[[ArrayBufferByteLength]]
is the number of elements in
result
.
[[Bytes]]
.
Set the value at each index of
ta
.
[[ViewedArrayBuffer]]
.
[[ArrayBufferData]]
to the value at the corresponding index of
result
.
[[Bytes]]
.
Return
ta
.
23.3.1.2
Uint8Array.fromHex (
string
)
If
string
is not a String
, throw a
TypeError
exception.
Let
result
be
FromHex
(
string
).
If
result
.
[[Error]]
is not
none
, then
Return
ThrowCompletion
(
result
.
[[Error]]
).
Let
resultLength
be the number of elements in
result
.
[[Bytes]]
.
Let
ta
be ?
AllocateTypedArray
(
"Uint8Array"
,
%Uint8Array%
,
"%Uint8Array.prototype%"
,
resultLength
).
Assert
:
ta
.
[[ViewedArrayBuffer]]
.
[[ArrayBufferByteLength]]
is the number of elements in
result
.
[[Bytes]]
.
Set the value at each index of
ta
.
[[ViewedArrayBuffer]]
.
[[ArrayBufferData]]
to the value at the corresponding index of
result
.
[[Bytes]]
.
Return
ta
.
23.3.2
Additional Properties of the Uint8Array Prototype Object
23.3.2.1
Uint8Array.prototype.setFromBase64 (
string
[ ,
options
] )
Let
into
be the
this
value.
Perform ?
ValidateUint8Array
(
into
).
If
string
is not a String
, throw a
TypeError
exception.
Let
opts
be ?
GetOptionsObject
(
options
).
Let
alphabet
be ?
Get
(
opts
,
"alphabet"
).
If
alphabet
is
undefined
, set
alphabet
to
"base64"
.
If
alphabet
is neither
"base64"
nor
"base64url"
, throw a
TypeError
exception.
Let
lastChunkHandling
be ?
Get
(
opts
,
"lastChunkHandling"
).
If
lastChunkHandling
is
undefined
, set
lastChunkHandling
to
"loose"
.
If
lastChunkHandling
is not one of
"loose"
,
"strict"
, or
"stop-before-partial"
, throw a
TypeError
exception.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
into
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Let
byteLength
be
TypedArrayLength
(
taRecord
).
Let
result
be
FromBase64
(
string
,
alphabet
,
lastChunkHandling
,
byteLength
).
Let
bytes
be
result
.
[[Bytes]]
.
Let
written
be the number of elements in
bytes
.
NOTE:
FromBase64
does not invoke any user code, so the ArrayBuffer backing
into
cannot have been detached or shrunk.
Assert
:
written
≤
byteLength
.
Perform
SetUint8ArrayBytes
(
into
,
bytes
).
If
result
.
[[Error]]
is not
none
, then
Return
ThrowCompletion
(
result
.
[[Error]]
).
Let
resultObject
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"read"
,
𝔽
(
result
.
[[Read]]
)).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"written"
,
𝔽
(
written
)).
Return
resultObject
.
23.3.2.2
Uint8Array.prototype.setFromHex (
string
)
Let
into
be the
this
value.
Perform ?
ValidateUint8Array
(
into
).
If
string
is not a String
, throw a
TypeError
exception.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
into
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Let
byteLength
be
TypedArrayLength
(
taRecord
).
Let
result
be
FromHex
(
string
,
byteLength
).
Let
bytes
be
result
.
[[Bytes]]
.
Let
written
be the number of elements in
bytes
.
NOTE:
FromHex
does not invoke any user code, so the ArrayBuffer backing
into
cannot have been detached or shrunk.
Assert
:
written
≤
byteLength
.
Perform
SetUint8ArrayBytes
(
into
,
bytes
).
If
result
.
[[Error]]
is not
none
, then
Return
ThrowCompletion
(
result
.
[[Error]]
).
Let
resultObject
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"read"
,
𝔽
(
result
.
[[Read]]
)).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"written"
,
𝔽
(
written
)).
Return
resultObject
.
23.3.2.3
Uint8Array.prototype.toBase64 ( [
options
] )
Let
O
be the
this
value.
Perform ?
ValidateUint8Array
(
O
).
Let
opts
be ?
GetOptionsObject
(
options
).
Let
alphabet
be ?
Get
(
opts
,
"alphabet"
).
If
alphabet
is
undefined
, set
alphabet
to
"base64"
.
If
alphabet
is neither
"base64"
nor
"base64url"
, throw a
TypeError
exception.
Let
omitPadding
be
ToBoolean
(?
Get
(
opts
,
"omitPadding"
)).
Let
toEncode
be ?
GetUint8ArrayBytes
(
O
).
If
alphabet
is
"base64"
, then
Let
outAscii
be the sequence of code points which results from encoding
toEncode
according to the base64 encoding specified in section 4 of
RFC 4648
. Padding is included if and only if
omitPadding
is
false
.
Else,
Assert
:
alphabet
is
"base64url"
.
Let
outAscii
be the sequence of code points which results from encoding
toEncode
according to the base64url encoding specified in section 5 of
RFC 4648
. Padding is included if and only if
omitPadding
is
false
.
Return
CodePointsToString
(
outAscii
).
23.3.2.4
Uint8Array.prototype.toHex ( )
Let
O
be the
this
value.
Perform ?
ValidateUint8Array
(
O
).
Let
toEncode
be ?
GetUint8ArrayBytes
(
O
).
Let
out
be the empty String.
For each byte
byte
of
toEncode
, do
Let
hex
be
Number::toString
(
𝔽
(
byte
), 16).
Set
hex
to
StringPad
(
hex
, 2,
"0"
,
start
).
Set
out
to the
string-concatenation
of
out
and
hex
.
Return
out
.
23.3.3
Abstract Operations for Uint8Array Objects
23.3.3.1
ValidateUint8Array (
ta
)
The abstract operation ValidateUint8Array takes argument
ta
(an
ECMAScript language value
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
ta
,
[[TypedArrayName]]
).
If
ta
.
[[TypedArrayName]]
is not
"Uint8Array"
, throw a
TypeError
exception.
Return
unused
.
23.3.3.2
GetUint8ArrayBytes (
ta
)
The abstract operation GetUint8ArrayBytes takes argument
ta
(a Uint8Array) and returns either a
normal completion containing
a
List
of
byte values
or a
throw completion
. It performs the following steps when called:
Let
buffer
be
ta
.
[[ViewedArrayBuffer]]
.
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
ta
,
seq-cst
).
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Let
len
be
TypedArrayLength
(
taRecord
).
Let
byteOffset
be
ta
.
[[ByteOffset]]
.
Let
bytes
be a new empty
List
.
Let
index
be 0.
Repeat, while
index
<
len
,
Let
byteIndex
be
byteOffset
+
index
.
Let
byte
be
ℝ
(
GetValueFromBuffer
(
buffer
,
byteIndex
,
uint8
,
true
,
unordered
)).
Append
byte
to
bytes
.
Set
index
to
index
+ 1.
Return
bytes
.
23.3.3.3
SetUint8ArrayBytes (
into
,
bytes
)
The abstract operation SetUint8ArrayBytes takes arguments
into
(a Uint8Array) and
bytes
(a
List
of
byte values
) and returns
unused
. It performs the following steps when called:
Let
offset
be
into
.
[[ByteOffset]]
.
Let
len
be the number of elements in
bytes
.
Let
index
be 0.
Repeat, while
index
<
len
,
Let
byte
be
bytes
[
index
].
Let
byteIndexInBuffer
be
index
+
offset
.
Perform
SetValueInBuffer
(
into
.
[[ViewedArrayBuffer]]
,
byteIndexInBuffer
,
uint8
,
𝔽
(
byte
),
true
,
unordered
).
Set
index
to
index
+ 1.
Return
unused
.
23.3.3.4
SkipAsciiWhitespace (
string
,
index
)
The abstract operation SkipAsciiWhitespace takes arguments
string
(a String) and
index
(a non-negative
integer
) and returns a non-negative
integer
. It performs the following steps when called:
Let
length
be the length of
string
.
Repeat, while
index
<
length
,
Let
char
be the code unit at index
index
within
string
.
If
char
is not one of 0x0009 (TAB), 0x000A (LF), 0x000C (FF), 0x000D (CR), or 0x0020 (SPACE), then
Return
index
.
Set
index
to
index
+ 1.
Return
index
.
23.3.3.5
DecodeFinalBase64Chunk (
chunk
,
throwOnExtraBits
)
The abstract operation DecodeFinalBase64Chunk takes arguments
chunk
(a String of length 2 or 3) and
throwOnExtraBits
(a Boolean) and returns either a
normal completion containing
a
List
of
byte values
, or a
throw completion
. It performs the following steps when called:
Let
chunkLength
be the length of
chunk
.
If
chunkLength
= 2, then
Set
chunk
to the
string-concatenation
of
chunk
and
"AA"
.
Else,
Assert
:
chunkLength
is 3.
Set
chunk
to the
string-concatenation
of
chunk
and
"A"
.
Let
bytes
be
DecodeFullLengthBase64Chunk
(
chunk
).
If
chunkLength
= 2, then
If
throwOnExtraBits
is
true
and
bytes
[1] ≠ 0, then
Throw a
SyntaxError
exception.
Return «
bytes
[0] ».
Else,
If
throwOnExtraBits
is
true
and
bytes
[2] ≠ 0, then
Throw a
SyntaxError
exception.
Return «
bytes
[0],
bytes
[1] ».
23.3.3.6
DecodeFullLengthBase64Chunk (
chunk
)
The abstract operation DecodeFullLengthBase64Chunk takes argument
chunk
(a String of length 4) and returns a
List
of
byte values
of length 3.
The
standard base64 alphabet
is
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
, i.e., the String whose elements are the code units corresponding to every letter and number in the Unicode Basic Latin block along with
"+"
and
"/"
.
Let
byteSequence
be the unique sequence of 3 bytes resulting from decoding
chunk
as base64 (i.e., the sequence such that applying the base64 encoding specified in section 4 of
RFC 4648
to
byteSequence
would produce
chunk
).
Return a
List
whose elements are the elements of
byteSequence
, in order.
23.3.3.7
FromBase64 (
string
,
alphabet
,
lastChunkHandling
[ ,
maxLength
] )
The abstract operation FromBase64 takes arguments
string
(a String),
alphabet
(
"base64"
or
"base64url"
), and
lastChunkHandling
(
"loose"
,
"strict"
, or
"stop-before-partial"
) and optional argument
maxLength
(a non-negative
integer
) and returns a
Record
with fields
[[Read]]
(an
integer
),
[[Bytes]]
(a
List
of
byte values
), and
[[Error]]
(a
SyntaxError
object or
none
). It performs the following steps when called:
If
maxLength
is not present, then
Set
maxLength
to 2
53
- 1.
NOTE: Because the input
is a String
, the length of Strings is limited to 2
53
- 1 characters, and the output requires no more bytes than the input has characters, this limit can never be reached. However, it is editorially convenient to use a
finite
value for
maxLength
.
NOTE: The order of validation and decoding in the algorithm below is not observable. Implementations are encouraged to perform them in whatever order is most efficient, possibly interleaving validation with decoding.
If
maxLength
= 0, then
Return the
Record
{
[[Read]]
: 0,
[[Bytes]]
: « »,
[[Error]]
:
none
}.
Let
read
be 0.
Let
bytes
be a new empty
List
.
Let
chunk
be the empty String.
Let
chunkLength
be 0.
Let
index
be 0.
Let
length
be the length of
string
.
Repeat,
Set
index
to
SkipAsciiWhitespace
(
string
,
index
).
If
index
=
length
, then
If
chunkLength
> 0, then
If
lastChunkHandling
is
"stop-before-partial"
, then
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
none
}.
Else if
lastChunkHandling
is
"loose"
, then
If
chunkLength
= 1, then
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Set
bytes
to the
list-concatenation
of
bytes
and !
DecodeFinalBase64Chunk
(
chunk
,
false
).
Else,
Assert
:
lastChunkHandling
is
"strict"
.
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Return the
Record
{
[[Read]]
:
length
,
[[Bytes]]
:
bytes
,
[[Error]]
:
none
}.
Let
char
be the
substring
of
string
from
index
to
index
+ 1.
Set
index
to
index
+ 1.
If
char
is
"="
, then
If
chunkLength
< 2, then
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Set
index
to
SkipAsciiWhitespace
(
string
,
index
).
If
chunkLength
= 2, then
If
index
=
length
, then
If
lastChunkHandling
is
"stop-before-partial"
, then
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
none
}.
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Set
char
to the
substring
of
string
from
index
to
index
+ 1.
If
char
is
"="
, then
Set
index
to
SkipAsciiWhitespace
(
string
,
index
+ 1).
If
index
<
length
, then
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
If
lastChunkHandling
is
"strict"
, let
throwOnExtraBits
be
true
; otherwise let
throwOnExtraBits
be
false
.
Let
decodeResult
be
Completion
(
DecodeFinalBase64Chunk
(
chunk
,
throwOnExtraBits
)).
If
decodeResult
is an
abrupt completion
, then
Let
error
be
decodeResult
.
[[Value]]
.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Set
bytes
to the
list-concatenation
of
bytes
and !
decodeResult
.
Return the
Record
{
[[Read]]
:
length
,
[[Bytes]]
:
bytes
,
[[Error]]
:
none
}.
If
alphabet
is
"base64url"
, then
If
char
is either
"+"
or
"/"
, then
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Else if
char
is
"-"
, then
Set
char
to
"+"
.
Else if
char
is
"_"
, then
Set
char
to
"/"
.
If the sole code unit of
char
is not an element of the
standard base64 alphabet
, then
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Let
remaining
be
maxLength
- the number of elements in
bytes
.
If
remaining
= 1 and
chunkLength
= 2, or if
remaining
= 2 and
chunkLength
= 3, then
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
none
}.
Set
chunk
to the
string-concatenation
of
chunk
and
char
.
Set
chunkLength
to the length of
chunk
.
If
chunkLength
= 4, then
Set
bytes
to the
list-concatenation
of
bytes
and
DecodeFullLengthBase64Chunk
(
chunk
).
Set
chunk
to the empty String.
Set
chunkLength
to 0.
Set
read
to
index
.
If the number of elements in
bytes
=
maxLength
, then
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
none
}.
23.3.3.8
FromHex (
string
[ ,
maxLength
] )
The abstract operation FromHex takes argument
string
(a String) and optional argument
maxLength
(a non-negative
integer
) and returns a
Record
with fields
[[Read]]
(an
integer
),
[[Bytes]]
(a
List
of
byte values
), and
[[Error]]
(a
SyntaxError
object or
none
). It performs the following steps when called:
If
maxLength
is not present, set
maxLength
to 2
53
- 1.
Let
length
be the length of
string
.
Let
bytes
be a new empty
List
.
Let
read
be 0.
If
length
modulo
2 ≠ 0, then
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Repeat, while
read
<
length
and the number of elements in
bytes
<
maxLength
,
Let
hexits
be the
substring
of
string
from
read
to
read
+ 2.
If
hexits
contains any code units which are not in
"0123456789abcdefABCDEF"
, then
Let
error
be a newly created
SyntaxError
object.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
error
}.
Set
read
to
read
+ 2.
Let
byte
be the
integer
value represented by
hexits
in base-16 notation, using the letters
A
through
F
and
a
through
f
for digits with values 10 through 15.
Append
byte
to
bytes
.
Return the
Record
{
[[Read]]
:
read
,
[[Bytes]]
:
bytes
,
[[Error]]
:
none
}.
24
Keyed Collections
24.1
Map Objects
Maps are collections of key/value pairs where both the keys and values may be arbitrary
ECMAScript language values
. A distinct key value may only occur in one key/value pair within the Map's collection. Distinct key values are discriminated using the semantics of the
SameValueZero
comparison algorithm.
Maps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of Maps. It is not intended to be a viable implementation model.
24.1.1
The Map Constructor
The Map
constructor
:
is
%Map%
.
is the initial value of the
"Map"
property of the
global object
.
creates and initializes a new Map when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value in an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Map behaviour must include a
super
call to the Map
constructor
to create and initialize the subclass instance with the internal state necessary to support the
Map.prototype
built-in methods.
24.1.1.1
Map ( [
iterable
] )
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
map
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Map.prototype%"
, «
[[MapData]]
»).
Set
map
.
[[MapData]]
to a new empty
List
.
If
iterable
is either
undefined
or
null
, return
map
.
Let
adder
be ?
Get
(
map
,
"set"
).
If
IsCallable
(
adder
) is
false
, throw a
TypeError
exception.
Return ?
AddEntriesFromIterable
(
map
,
iterable
,
adder
).
Note
If the parameter
iterable
is present, it is expected to be an object that implements a
%Symbol.iterator%
method that returns an
iterator object
that produces a two element
array-like object
whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.
24.1.1.2
AddEntriesFromIterable (
target
,
iterable
,
adder
)
The abstract operation AddEntriesFromIterable takes arguments
target
(an Object),
iterable
(an
ECMAScript language value
, but not
undefined
or
null
), and
adder
(a
function object
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
.
adder
will be invoked, with
target
as the receiver. It performs the following steps when called:
Let
iteratorRecord
be ?
GetIterator
(
iterable
,
sync
).
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, return
target
.
If
next
is not an Object
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iteratorRecord
,
error
).
Let
k
be
Completion
(
Get
(
next
,
"0"
)).
IfAbruptCloseIterator
(
k
,
iteratorRecord
).
Let
v
be
Completion
(
Get
(
next
,
"1"
)).
IfAbruptCloseIterator
(
v
,
iteratorRecord
).
Let
status
be
Completion
(
Call
(
adder
,
target
, «
k
,
v
»)).
IfAbruptCloseIterator
(
status
,
iteratorRecord
).
Note
The parameter
iterable
is expected to be an object that implements a
%Symbol.iterator%
method that returns an
iterator object
that produces a two element
array-like object
whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.
24.1.2
Properties of the Map Constructor
The Map
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
24.1.2.1
Map.groupBy (
items
,
callback
)
Note
callback
should be a function that accepts two arguments.
groupBy
calls
callback
once for each element in
items
, in ascending order, and constructs a new Map. Each value returned by
callback
is used as a key in the Map. For each such key, the result Map has an entry whose key is that key and whose value is an array containing all the elements for which
callback
returned that key.
callback
is called with two arguments: the value of the element and the index of the element.
The return value of
groupBy
is a Map.
This function performs the following steps when called:
Let
groups
be ?
GroupBy
(
items
,
callback
,
collection
).
Let
map
be !
Construct
(
%Map%
).
For each
Record
{
[[Key]]
,
[[Elements]]
}
g
of
groups
, do
Let
elements
be
CreateArrayFromList
(
g
.
[[Elements]]
).
Let
entry
be the
Record
{
[[Key]]
:
g
.
[[Key]]
,
[[Value]]
:
elements
}.
Append
entry
to
map
.
[[MapData]]
.
Return
map
.
24.1.2.2
Map.prototype
The initial value of
Map.prototype
is the
Map prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
24.1.2.3
get Map [ %Symbol.species% ]
Map[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
Note
Methods that create derived collection objects should call
%Symbol.species%
to determine the
constructor
to use to create the derived objects. Subclass
constructor
may over-ride
%Symbol.species%
to change the default
constructor
assignment.
24.1.3
Properties of the Map Prototype Object
The
Map prototype object
:
is
%Map.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have a
[[MapData]]
internal slot.
24.1.3.1
Map.prototype.clear ( )
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
Set
p
.
[[Key]]
to
empty
.
Set
p
.
[[Value]]
to
empty
.
Return
undefined
.
Note
The existing
[[MapData]]
List
is preserved because there may be existing
Map Iterator objects
that are suspended midway through iterating over that
List
.
24.1.3.2
Map.prototype.constructor
The initial value of
Map.prototype.constructor
is
%Map%
.
24.1.3.3
Map.prototype.delete (
key
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
Set
key
to
CanonicalizeKeyedCollectionKey
(
key
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, then
Set
p
.
[[Key]]
to
empty
.
Set
p
.
[[Value]]
to
empty
.
Return
true
.
Return
false
.
Note
The value
empty
is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.
24.1.3.4
Map.prototype.entries ( )
This method performs the following steps when called:
Let
M
be the
this
value.
Return ?
CreateMapIterator
(
M
,
key+value
).
24.1.3.5
Map.prototype.forEach (
callback
[ ,
thisArg
] )
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
entries
be
M
.
[[MapData]]
.
Let
numEntries
be the number of elements in
entries
.
Let
index
be 0.
Repeat, while
index
<
numEntries
,
Let
e
be
entries
[
index
].
Set
index
to
index
+ 1.
If
e
.
[[Key]]
is not
empty
, then
Perform ?
Call
(
callback
,
thisArg
, «
e
.
[[Value]]
,
e
.
[[Key]]
,
M
»).
NOTE: The number of elements in
entries
may have increased during execution of
callback
.
Set
numEntries
to the number of elements in
entries
.
Return
undefined
.
Note
callback
should be a function that accepts three arguments.
forEach
calls
callback
once for each key/value pair present in the Map, in key insertion order.
callback
is called only for keys of the Map which actually exist; it is not called for keys that have been deleted from the Map.
If a
thisArg
parameter is provided, it will be used as the
this
value for each invocation of
callback
. If it is not provided,
undefined
is used instead.
callback
is called with three arguments: the value of the item, the key of the item, and the Map being traversed.
forEach
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
. Each entry of a map's
[[MapData]]
is only visited once. New keys added after the call to
forEach
begins are visited. A key will be revisited if it is deleted after it has been visited and then re-added before the
forEach
call completes. Keys that are deleted after the call to
forEach
begins and before being visited are not visited unless the key is added again before the
forEach
call completes.
24.1.3.6
Map.prototype.get (
key
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
Set
key
to
CanonicalizeKeyedCollectionKey
(
key
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
p
.
[[Value]]
.
Return
undefined
.
24.1.3.7
Map.prototype.getOrInsert (
key
,
value
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
Set
key
to
CanonicalizeKeyedCollectionKey
(
key
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
p
.
[[Value]]
.
Let
p
be the
Record
{
[[Key]]
:
key
,
[[Value]]
:
value
}.
Append
p
to
M
.
[[MapData]]
.
Return
value
.
24.1.3.8
Map.prototype.getOrInsertComputed (
key
,
callback
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Set
key
to
CanonicalizeKeyedCollectionKey
(
key
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
p
.
[[Value]]
.
Let
value
be ?
Call
(
callback
,
undefined
, «
key
»).
NOTE: The Map may have been modified during execution of
callback
.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, then
Set
p
.
[[Value]]
to
value
.
Return
value
.
Let
p
be the
Record
{
[[Key]]
:
key
,
[[Value]]
:
value
}.
Append
p
to
M
.
[[MapData]]
.
Return
value
.
24.1.3.9
Map.prototype.has (
key
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
Set
key
to
CanonicalizeKeyedCollectionKey
(
key
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
true
.
Return
false
.
24.1.3.10
Map.prototype.keys ( )
This method performs the following steps when called:
Let
M
be the
this
value.
Return ?
CreateMapIterator
(
M
,
key
).
24.1.3.11
Map.prototype.set (
key
,
value
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
Set
key
to
CanonicalizeKeyedCollectionKey
(
key
).
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, then
Set
p
.
[[Value]]
to
value
.
Return
M
.
Let
p
be the
Record
{
[[Key]]
:
key
,
[[Value]]
:
value
}.
Append
p
to
M
.
[[MapData]]
.
Return
M
.
24.1.3.12
get Map.prototype.size
Map.prototype.size
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[MapData]]
).
Let
count
be 0.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[MapData]]
, do
If
p
.
[[Key]]
is not
empty
, set
count
to
count
+ 1.
Return
𝔽
(
count
).
24.1.3.13
Map.prototype.values ( )
This method performs the following steps when called:
Let
M
be the
this
value.
Return ?
CreateMapIterator
(
M
,
value
).
24.1.3.14
Map.prototype [ %Symbol.iterator% ] ( )
The initial value of the
%Symbol.iterator%
property is %Map.prototype.entries%, defined in
24.1.3.4
.
24.1.3.15
Map.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Map"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
24.1.4
Properties of Map Instances
Map instances are
ordinary objects
that inherit properties from the
Map prototype object
. Map instances also have a
[[MapData]]
internal slot.
24.1.5
Map Iterator Objects
A
Map Iterator
is an object that represents a specific iteration over some specific Map instance object. There is not a named
constructor
for Map Iterator objects. Instead, Map Iterator objects are created by calling certain methods of Map instance objects.
24.1.5.1
CreateMapIterator (
map
,
kind
)
The abstract operation CreateMapIterator takes arguments
map
(an
ECMAScript language value
) and
kind
(
key+value
,
key
, or
value
) and returns either a
normal completion containing
a Generator or a
throw completion
. It is used to create
iterator objects
for Map methods that return such
iterators
. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
map
,
[[MapData]]
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
map
and
kind
and performs the following steps when called:
Let
entries
be
map
.
[[MapData]]
.
Let
index
be 0.
Let
numEntries
be the number of elements in
entries
.
Repeat, while
index
<
numEntries
,
Let
e
be
entries
[
index
].
Set
index
to
index
+ 1.
If
e
.
[[Key]]
is not
empty
, then
If
kind
is
key
, then
Let
result
be
e
.
[[Key]]
.
Else if
kind
is
value
, then
Let
result
be
e
.
[[Value]]
.
Else,
Assert
:
kind
is
key+value
.
Let
result
be
CreateArrayFromList
(«
e
.
[[Key]]
,
e
.
[[Value]]
»).
Perform ?
GeneratorYield
(
CreateIteratorResultObject
(
result
,
false
)).
NOTE: The number of elements in
entries
may have increased while execution of this abstract operation was paused by
GeneratorYield
.
Set
numEntries
to the number of elements in
entries
.
Return
NormalCompletion
(
unused
).
Return
CreateIteratorFromClosure
(
closure
,
"%MapIteratorPrototype%"
,
%MapIteratorPrototype%
).
24.1.5.2
The %MapIteratorPrototype% Object
The
%MapIteratorPrototype%
object:
has properties that are inherited by all
Map Iterator objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
has the following properties:
24.1.5.2.1
%MapIteratorPrototype%.next ( )
Return ?
GeneratorResume
(
this
value,
empty
,
"%MapIteratorPrototype%"
).
24.1.5.2.2
%MapIteratorPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Map Iterator"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
24.2
Set Objects
Set objects
are collections of
ECMAScript language values
. A Set may contain each distinct value at most once. Distinct values are discriminated using the semantics of the
SameValueZero
comparison algorithm.
Set objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of Set objects. It is not intended to be a viable implementation model.
24.2.1
Abstract Operations For Set Objects
24.2.1.1
Set Records
A
Set Record
is a
Record
value used to encapsulate the interface of a Set or similar object.
Set Records have the fields listed in
Table 71
.
Table 71:
Set Record
Fields
Field Name
Value
Meaning
[[SetObject]]
an Object
the Set or similar object.
[[Size]]
a non-negative
integer
or +∞
The reported size of the object.
[[Has]]
a
function object
The
has
method of the object.
[[Keys]]
a
function object
The
keys
method of the object.
24.2.1.2
GetSetRecord (
obj
)
The abstract operation GetSetRecord takes argument
obj
(an
ECMAScript language value
) and returns either a
normal completion containing
a
Set Record
or a
throw completion
. It performs the following steps when called:
If
obj
is not an Object
, throw a
TypeError
exception.
Let
rawSize
be ?
Get
(
obj
,
"size"
).
Let
numSize
be ?
ToNumber
(
rawSize
).
NOTE: If
rawSize
is
undefined
, then
numSize
will be
NaN
.
If
numSize
is
NaN
, throw a
TypeError
exception.
Let
intSize
be !
ToIntegerOrInfinity
(
numSize
).
If
intSize
< 0, throw a
RangeError
exception.
Let
has
be ?
Get
(
obj
,
"has"
).
If
IsCallable
(
has
) is
false
, throw a
TypeError
exception.
Let
keys
be ?
Get
(
obj
,
"keys"
).
If
IsCallable
(
keys
) is
false
, throw a
TypeError
exception.
Return a new
Set Record
{
[[SetObject]]
:
obj
,
[[Size]]
:
intSize
,
[[Has]]
:
has
,
[[Keys]]
:
keys
}.
24.2.1.3
SetDataHas (
setData
,
value
)
The abstract operation SetDataHas takes arguments
setData
(a
List
of either
ECMAScript language values
or
empty
) and
value
(an
ECMAScript language value
) and returns a Boolean. It performs the following steps when called:
If
SetDataIndex
(
setData
,
value
) is
not-found
, return
false
.
Return
true
.
24.2.1.4
SetDataIndex (
setData
,
value
)
The abstract operation SetDataIndex takes arguments
setData
(a
List
of either
ECMAScript language values
or
empty
) and
value
(an
ECMAScript language value
) and returns a non-negative
integer
or
not-found
. It performs the following steps when called:
Set
value
to
CanonicalizeKeyedCollectionKey
(
value
).
Let
size
be the number of elements in
setData
.
Let
index
be 0.
Repeat, while
index
<
size
,
Let
e
be
setData
[
index
].
If
e
is not
empty
and
e
is
value
, then
Return
index
.
Set
index
to
index
+ 1.
Return
not-found
.
24.2.1.5
SetDataSize (
setData
)
The abstract operation SetDataSize takes argument
setData
(a
List
of either
ECMAScript language values
or
empty
) and returns a non-negative
integer
. It performs the following steps when called:
Let
count
be 0.
For each element
e
of
setData
, do
If
e
is not
empty
, set
count
to
count
+ 1.
Return
count
.
24.2.2
The Set Constructor
The Set
constructor
:
is
%Set%
.
is the initial value of the
"Set"
property of the
global object
.
creates and initializes a new
Set object
when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value in an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Set behaviour must include a
super
call to the Set
constructor
to create and initialize the subclass instance with the internal state necessary to support the
Set.prototype
built-in methods.
24.2.2.1
Set ( [
iterable
] )
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
set
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Set.prototype%"
, «
[[SetData]]
»).
Set
set
.
[[SetData]]
to a new empty
List
.
If
iterable
is either
undefined
or
null
, return
set
.
Let
adder
be ?
Get
(
set
,
"add"
).
If
IsCallable
(
adder
) is
false
, throw a
TypeError
exception.
Let
iteratorRecord
be ?
GetIterator
(
iterable
,
sync
).
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, return
set
.
Let
status
be
Completion
(
Call
(
adder
,
set
, «
next
»)).
IfAbruptCloseIterator
(
status
,
iteratorRecord
).
24.2.3
Properties of the Set Constructor
The Set
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
24.2.3.1
Set.prototype
The initial value of
Set.prototype
is the
Set prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
24.2.3.2
get Set [ %Symbol.species% ]
Set[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
Note
Methods that create derived collection objects should call
%Symbol.species%
to determine the
constructor
to use to create the derived objects. Subclass
constructor
may over-ride
%Symbol.species%
to change the default
constructor
assignment.
24.2.4
Properties of the Set Prototype Object
The
Set prototype object
:
is
%Set.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have a
[[SetData]]
internal slot.
24.2.4.1
Set.prototype.add (
value
)
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[SetData]]
).
Set
value
to
CanonicalizeKeyedCollectionKey
(
value
).
For each element
e
of
S
.
[[SetData]]
, do
If
e
is not
empty
and
SameValue
(
e
,
value
) is
true
, then
Return
S
.
Append
value
to
S
.
[[SetData]]
.
Return
S
.
24.2.4.2
Set.prototype.clear ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[SetData]]
).
For each element
e
of
S
.
[[SetData]]
, do
Replace the element of
S
.
[[SetData]]
whose value is
e
with an element whose value is
empty
.
Return
undefined
.
Note
The existing
[[SetData]]
List
is preserved because there may be existing
Set Iterator objects
that are suspended midway through iterating over that
List
.
24.2.4.3
Set.prototype.constructor
The initial value of
Set.prototype.constructor
is
%Set%
.
24.2.4.4
Set.prototype.delete (
value
)
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[SetData]]
).
Set
value
to
CanonicalizeKeyedCollectionKey
(
value
).
For each element
e
of
S
.
[[SetData]]
, do
If
e
is not
empty
and
SameValue
(
e
,
value
) is
true
, then
Replace the element of
S
.
[[SetData]]
whose value is
e
with an element whose value is
empty
.
Return
true
.
Return
false
.
Note
The value
empty
is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.
24.2.4.5
Set.prototype.difference (
other
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[SetData]]
).
Let
otherRec
be ?
GetSetRecord
(
other
).
Let
resultSetData
be a copy of
O
.
[[SetData]]
.
If
SetDataSize
(
O
.
[[SetData]]
) ≤
otherRec
.
[[Size]]
, then
Let
thisSize
be the number of elements in
O
.
[[SetData]]
.
Let
index
be 0.
Repeat, while
index
<
thisSize
,
Let
e
be
resultSetData
[
index
].
If
e
is not
empty
, then
Let
inOther
be
ToBoolean
(?
Call
(
otherRec
.
[[Has]]
,
otherRec
.
[[SetObject]]
, «
e
»)).
If
inOther
is
true
, then
Set
resultSetData
[
index
] to
empty
.
Set
index
to
index
+ 1.
Else,
Let
keysIter
be ?
GetIteratorFromMethod
(
otherRec
.
[[SetObject]]
,
otherRec
.
[[Keys]]
).
Let
next
be
not-started
.
Repeat, while
next
is not
done
,
Set
next
to ?
IteratorStepValue
(
keysIter
).
If
next
is not
done
, then
Set
next
to
CanonicalizeKeyedCollectionKey
(
next
).
Let
valueIndex
be
SetDataIndex
(
resultSetData
,
next
).
If
valueIndex
is not
not-found
, then
Set
resultSetData
[
valueIndex
] to
empty
.
Let
result
be
OrdinaryObjectCreate
(
%Set.prototype%
, «
[[SetData]]
»).
Set
result
.
[[SetData]]
to
resultSetData
.
Return
result
.
24.2.4.6
Set.prototype.entries ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateSetIterator
(
S
,
key+value
).
Note
For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.
24.2.4.7
Set.prototype.forEach (
callback
[ ,
thisArg
] )
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[SetData]]
).
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
Let
entries
be
S
.
[[SetData]]
.
Let
numEntries
be the number of elements in
entries
.
Let
index
be 0.
Repeat, while
index
<
numEntries
,
Let
e
be
entries
[
index
].
Set
index
to
index
+ 1.
If
e
is not
empty
, then
Perform ?
Call
(
callback
,
thisArg
, «
e
,
e
,
S
»).
NOTE: The number of elements in
entries
may have increased during execution of
callback
.
Set
numEntries
to the number of elements in
entries
.
Return
undefined
.
Note
callback
should be a function that accepts three arguments.
forEach
calls
callback
once for each value present in the
Set object
, in value insertion order.
callback
is called only for values of the Set which actually exist; it is not called for keys that have been deleted from the set.
If a
thisArg
parameter is provided, it will be used as the
this
value for each invocation of
callback
. If it is not provided,
undefined
is used instead.
callback
is called with three arguments: the first two arguments are a value contained in the Set. The same value is passed for both arguments. The
Set object
being traversed is passed as the third argument.
The
callback
is called with three arguments to be consistent with the call back functions used by
forEach
methods for Map and Array. For Sets, each item value is considered to be both the key and the value.
forEach
does not directly mutate the object on which it is called but the object may be mutated by the calls to
callback
.
Each value is normally visited only once. However, a value will be revisited if it is deleted after it has been visited and then re-added before the
forEach
call completes. Values that are deleted after the call to
forEach
begins and before being visited are not visited unless the value is added again before the
forEach
call completes. New values added after the call to
forEach
begins are visited.
24.2.4.8
Set.prototype.has (
value
)
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[SetData]]
).
Set
value
to
CanonicalizeKeyedCollectionKey
(
value
).
For each element
e
of
S
.
[[SetData]]
, do
If
e
is not
empty
and
SameValue
(
e
,
value
) is
true
, return
true
.
Return
false
.
24.2.4.9
Set.prototype.intersection (
other
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[SetData]]
).
Let
otherRec
be ?
GetSetRecord
(
other
).
Let
resultSetData
be a new empty
List
.
If
SetDataSize
(
O
.
[[SetData]]
) ≤
otherRec
.
[[Size]]
, then
Let
thisSize
be the number of elements in
O
.
[[SetData]]
.
Let
index
be 0.
Repeat, while
index
<
thisSize
,
Let
e
be
O
.
[[SetData]]
[
index
].
Set
index
to
index
+ 1.
If
e
is not
empty
, then
Let
inOther
be
ToBoolean
(?
Call
(
otherRec
.
[[Has]]
,
otherRec
.
[[SetObject]]
, «
e
»)).
If
inOther
is
true
, then
NOTE: It is possible for earlier calls to
otherRec
.
[[Has]]
to remove and re-add an element of
O
.
[[SetData]]
, which can cause the same element to be visited twice during this iteration.
If
SetDataHas
(
resultSetData
,
e
) is
false
, then
Append
e
to
resultSetData
.
NOTE: The number of elements in
O
.
[[SetData]]
may have increased during execution of
otherRec
.
[[Has]]
.
Set
thisSize
to the number of elements in
O
.
[[SetData]]
.
Else,
Let
keysIter
be ?
GetIteratorFromMethod
(
otherRec
.
[[SetObject]]
,
otherRec
.
[[Keys]]
).
Let
next
be
not-started
.
Repeat, while
next
is not
done
,
Set
next
to ?
IteratorStepValue
(
keysIter
).
If
next
is not
done
, then
Set
next
to
CanonicalizeKeyedCollectionKey
(
next
).
Let
inThis
be
SetDataHas
(
O
.
[[SetData]]
,
next
).
If
inThis
is
true
, then
NOTE: Because
other
is an arbitrary object, it is possible for its
"keys"
iterator
to produce the same value more than once.
If
SetDataHas
(
resultSetData
,
next
) is
false
, then
Append
next
to
resultSetData
.
Let
result
be
OrdinaryObjectCreate
(
%Set.prototype%
, «
[[SetData]]
»).
Set
result
.
[[SetData]]
to
resultSetData
.
Return
result
.
24.2.4.10
Set.prototype.isDisjointFrom (
other
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[SetData]]
).
Let
otherRec
be ?
GetSetRecord
(
other
).
If
SetDataSize
(
O
.
[[SetData]]
) ≤
otherRec
.
[[Size]]
, then
Let
thisSize
be the number of elements in
O
.
[[SetData]]
.
Let
index
be 0.
Repeat, while
index
<
thisSize
,
Let
e
be
O
.
[[SetData]]
[
index
].
Set
index
to
index
+ 1.
If
e
is not
empty
, then
Let
inOther
be
ToBoolean
(?
Call
(
otherRec
.
[[Has]]
,
otherRec
.
[[SetObject]]
, «
e
»)).
If
inOther
is
true
, return
false
.
NOTE: The number of elements in
O
.
[[SetData]]
may have increased during execution of
otherRec
.
[[Has]]
.
Set
thisSize
to the number of elements in
O
.
[[SetData]]
.
Else,
Let
keysIter
be ?
GetIteratorFromMethod
(
otherRec
.
[[SetObject]]
,
otherRec
.
[[Keys]]
).
Let
next
be
not-started
.
Repeat, while
next
is not
done
,
Set
next
to ?
IteratorStepValue
(
keysIter
).
If
next
is not
done
, then
If
SetDataHas
(
O
.
[[SetData]]
,
next
) is
true
, then
Perform ?
IteratorClose
(
keysIter
,
NormalCompletion
(
unused
)).
Return
false
.
Return
true
.
24.2.4.11
Set.prototype.isSubsetOf (
other
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[SetData]]
).
Let
otherRec
be ?
GetSetRecord
(
other
).
If
SetDataSize
(
O
.
[[SetData]]
) >
otherRec
.
[[Size]]
, return
false
.
Let
thisSize
be the number of elements in
O
.
[[SetData]]
.
Let
index
be 0.
Repeat, while
index
<
thisSize
,
Let
e
be
O
.
[[SetData]]
[
index
].
Set
index
to
index
+ 1.
If
e
is not
empty
, then
Let
inOther
be
ToBoolean
(?
Call
(
otherRec
.
[[Has]]
,
otherRec
.
[[SetObject]]
, «
e
»)).
If
inOther
is
false
, return
false
.
NOTE: The number of elements in
O
.
[[SetData]]
may have increased during execution of
otherRec
.
[[Has]]
.
Set
thisSize
to the number of elements in
O
.
[[SetData]]
.
Return
true
.
24.2.4.12
Set.prototype.isSupersetOf (
other
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[SetData]]
).
Let
otherRec
be ?
GetSetRecord
(
other
).
If
SetDataSize
(
O
.
[[SetData]]
) <
otherRec
.
[[Size]]
, return
false
.
Let
keysIter
be ?
GetIteratorFromMethod
(
otherRec
.
[[SetObject]]
,
otherRec
.
[[Keys]]
).
Let
next
be
not-started
.
Repeat, while
next
is not
done
,
Set
next
to ?
IteratorStepValue
(
keysIter
).
If
next
is not
done
, then
If
SetDataHas
(
O
.
[[SetData]]
,
next
) is
false
, then
Perform ?
IteratorClose
(
keysIter
,
NormalCompletion
(
unused
)).
Return
false
.
Return
true
.
24.2.4.13
Set.prototype.keys ( )
The initial value of the
"keys"
property is %Set.prototype.values%, defined in
24.2.4.17
.
Note
For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.
24.2.4.14
get Set.prototype.size
Set.prototype.size
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[SetData]]
).
Let
size
be
SetDataSize
(
S
.
[[SetData]]
).
Return
𝔽
(
size
).
24.2.4.15
Set.prototype.symmetricDifference (
other
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[SetData]]
).
Let
otherRec
be ?
GetSetRecord
(
other
).
Let
keysIter
be ?
GetIteratorFromMethod
(
otherRec
.
[[SetObject]]
,
otherRec
.
[[Keys]]
).
Let
resultSetData
be a copy of
O
.
[[SetData]]
.
Let
next
be
not-started
.
Repeat, while
next
is not
done
,
Set
next
to ?
IteratorStepValue
(
keysIter
).
If
next
is not
done
, then
Set
next
to
CanonicalizeKeyedCollectionKey
(
next
).
Let
resultIndex
be
SetDataIndex
(
resultSetData
,
next
).
If
resultIndex
is
not-found
, let
alreadyInResult
be
false
; otherwise let
alreadyInResult
be
true
.
If
SetDataHas
(
O
.
[[SetData]]
,
next
) is
true
, then
If
alreadyInResult
is
true
, set
resultSetData
[
resultIndex
] to
empty
.
Else,
If
alreadyInResult
is
false
, append
next
to
resultSetData
.
Let
result
be
OrdinaryObjectCreate
(
%Set.prototype%
, «
[[SetData]]
»).
Set
result
.
[[SetData]]
to
resultSetData
.
Return
result
.
24.2.4.16
Set.prototype.union (
other
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[SetData]]
).
Let
otherRec
be ?
GetSetRecord
(
other
).
Let
keysIter
be ?
GetIteratorFromMethod
(
otherRec
.
[[SetObject]]
,
otherRec
.
[[Keys]]
).
Let
resultSetData
be a copy of
O
.
[[SetData]]
.
Let
next
be
not-started
.
Repeat, while
next
is not
done
,
Set
next
to ?
IteratorStepValue
(
keysIter
).
If
next
is not
done
, then
Set
next
to
CanonicalizeKeyedCollectionKey
(
next
).
If
SetDataHas
(
resultSetData
,
next
) is
false
, then
Append
next
to
resultSetData
.
Let
result
be
OrdinaryObjectCreate
(
%Set.prototype%
, «
[[SetData]]
»).
Set
result
.
[[SetData]]
to
resultSetData
.
Return
result
.
24.2.4.17
Set.prototype.values ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateSetIterator
(
S
,
value
).
24.2.4.18
Set.prototype [ %Symbol.iterator% ] ( )
The initial value of the
%Symbol.iterator%
property is %Set.prototype.values%, defined in
24.2.4.17
.
24.2.4.19
Set.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Set"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
24.2.5
Properties of Set Instances
Set instances are
ordinary objects
that inherit properties from the
Set prototype object
. Set instances also have a
[[SetData]]
internal slot.
24.2.6
Set Iterator Objects
A
Set Iterator
is an
ordinary object
, with the structure defined below, that represents a specific iteration over some specific Set instance object. There is not a named
constructor
for Set Iterator objects. Instead, Set Iterator objects are created by calling certain methods of Set instance objects.
24.2.6.1
CreateSetIterator (
set
,
kind
)
The abstract operation CreateSetIterator takes arguments
set
(an
ECMAScript language value
) and
kind
(
key+value
or
value
) and returns either a
normal completion containing
a Generator or a
throw completion
. It is used to create
iterator objects
for Set methods that return such
iterators
. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
set
,
[[SetData]]
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
set
and
kind
and performs the following steps when called:
Let
index
be 0.
Let
entries
be
set
.
[[SetData]]
.
Let
numEntries
be the number of elements in
entries
.
Repeat, while
index
<
numEntries
,
Let
e
be
entries
[
index
].
Set
index
to
index
+ 1.
If
e
is not
empty
, then
If
kind
is
key+value
, then
Let
result
be
CreateArrayFromList
(«
e
,
e
»).
Perform ?
GeneratorYield
(
CreateIteratorResultObject
(
result
,
false
)).
Else,
Assert
:
kind
is
value
.
Perform ?
GeneratorYield
(
CreateIteratorResultObject
(
e
,
false
)).
NOTE: The number of elements in
entries
may have increased while execution of this abstract operation was paused by
GeneratorYield
.
Set
numEntries
to the number of elements in
entries
.
Return
NormalCompletion
(
unused
).
Return
CreateIteratorFromClosure
(
closure
,
"%SetIteratorPrototype%"
,
%SetIteratorPrototype%
).
24.2.6.2
The %SetIteratorPrototype% Object
The
%SetIteratorPrototype%
object:
has properties that are inherited by all
Set Iterator objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
has the following properties:
24.2.6.2.1
%SetIteratorPrototype%.next ( )
Return ?
GeneratorResume
(
this
value,
empty
,
"%SetIteratorPrototype%"
).
24.2.6.2.2
%SetIteratorPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Set Iterator"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
24.3
WeakMap Objects
WeakMaps are collections of key/value pairs where the keys are objects and/or symbols and values may be arbitrary
ECMAScript language values
. A WeakMap may be queried to see if it contains a key/value pair with a specific key, but no mechanism is provided for enumerating the values it holds as keys. In certain conditions, values which are not
live
are removed as WeakMap keys, as described in
9.9.3
.
An implementation may impose an arbitrarily determined latency between the time a key/value pair of a WeakMap becomes inaccessible and the time when the key/value pair is removed from the WeakMap. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to observe a key of a WeakMap that does not require the observer to present the observed key.
WeakMaps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of key/value pairs in the collection. The data structure used in this specification is only intended to describe the required observable semantics of WeakMaps. It is not intended to be a viable implementation model.
Note
WeakMap and WeakSet are intended to provide mechanisms for dynamically associating state with an object or symbol in a manner that does not “leak” memory resources if, in the absence of the WeakMap or WeakSet instance, the object or symbol otherwise became inaccessible and subject to resource reclamation by the implementation's garbage collection mechanisms. This characteristic can be achieved by using an inverted per-object/symbol mapping of WeakMap or WeakSet instances to keys. Alternatively, each WeakMap or WeakSet instance may internally store its key and value data, but this approach requires coordination between the WeakMap or WeakSet implementation and the garbage collector. The following references describe mechanism that may be useful to implementations of WeakMap and WeakSet:
Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In
Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97)
, A. Michael Berman (Ed.). ACM, New York, NY, USA, 176-183,
http://doi.acm.org/10.1145/263698.263733
.
Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008,
http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak
24.3.1
The WeakMap Constructor
The WeakMap
constructor
:
is
%WeakMap%
.
is the initial value of the
"WeakMap"
property of the
global object
.
creates and initializes a new WeakMap when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value in an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified WeakMap behaviour must include a
super
call to the WeakMap
constructor
to create and initialize the subclass instance with the internal state necessary to support the
WeakMap.prototype
built-in methods.
24.3.1.1
WeakMap ( [
iterable
] )
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
map
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%WeakMap.prototype%"
, «
[[WeakMapData]]
»).
Set
map
.
[[WeakMapData]]
to a new empty
List
.
If
iterable
is either
undefined
or
null
, return
map
.
Let
adder
be ?
Get
(
map
,
"set"
).
If
IsCallable
(
adder
) is
false
, throw a
TypeError
exception.
Return ?
AddEntriesFromIterable
(
map
,
iterable
,
adder
).
Note
If the parameter
iterable
is present, it is expected to be an object that implements a
%Symbol.iterator%
method that returns an
iterator object
that produces a two element
array-like object
whose first element is a value that will be used as a WeakMap key and whose second element is the value to associate with that key.
24.3.2
Properties of the WeakMap Constructor
The WeakMap
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
24.3.2.1
WeakMap.prototype
The initial value of
WeakMap.prototype
is the
WeakMap prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
24.3.3
Properties of the WeakMap Prototype Object
The
WeakMap prototype object
:
is
%WeakMap.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have a
[[WeakMapData]]
internal slot.
24.3.3.1
WeakMap.prototype.constructor
The initial value of
WeakMap.prototype.constructor
is
%WeakMap%
.
24.3.3.2
WeakMap.prototype.delete (
key
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[WeakMapData]]
).
If
CanBeHeldWeakly
(
key
) is
false
, return
false
.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[WeakMapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, then
Set
p
.
[[Key]]
to
empty
.
Set
p
.
[[Value]]
to
empty
.
Return
true
.
Return
false
.
Note
The value
empty
is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.
24.3.3.3
WeakMap.prototype.get (
key
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[WeakMapData]]
).
If
CanBeHeldWeakly
(
key
) is
false
, return
undefined
.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[WeakMapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
p
.
[[Value]]
.
Return
undefined
.
24.3.3.4
WeakMap.prototype.getOrInsert (
key
,
value
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[WeakMapData]]
).
If
CanBeHeldWeakly
(
key
) is
false
, throw a
TypeError
exception.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[WeakMapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
p
.
[[Value]]
.
Let
p
be the
Record
{
[[Key]]
:
key
,
[[Value]]
:
value
}.
Append
p
to
M
.
[[WeakMapData]]
.
Return
value
.
24.3.3.5
WeakMap.prototype.getOrInsertComputed (
key
,
callback
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[WeakMapData]]
).
If
CanBeHeldWeakly
(
key
) is
false
, throw a
TypeError
exception.
If
IsCallable
(
callback
) is
false
, throw a
TypeError
exception.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[WeakMapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
p
.
[[Value]]
.
Let
value
be ?
Call
(
callback
,
undefined
, «
key
»).
NOTE: The WeakMap may have been modified during execution of
callback
.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[WeakMapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, then
Set
p
.
[[Value]]
to
value
.
Return
value
.
Let
p
be the
Record
{
[[Key]]
:
key
,
[[Value]]
:
value
}.
Append
p
to
M
.
[[WeakMapData]]
.
Return
value
.
24.3.3.6
WeakMap.prototype.has (
key
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[WeakMapData]]
).
If
CanBeHeldWeakly
(
key
) is
false
, return
false
.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[WeakMapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, return
true
.
Return
false
.
24.3.3.7
WeakMap.prototype.set (
key
,
value
)
This method performs the following steps when called:
Let
M
be the
this
value.
Perform ?
RequireInternalSlot
(
M
,
[[WeakMapData]]
).
If
CanBeHeldWeakly
(
key
) is
false
, throw a
TypeError
exception.
For each
Record
{
[[Key]]
,
[[Value]]
}
p
of
M
.
[[WeakMapData]]
, do
If
p
.
[[Key]]
is not
empty
and
SameValue
(
p
.
[[Key]]
,
key
) is
true
, then
Set
p
.
[[Value]]
to
value
.
Return
M
.
Let
p
be the
Record
{
[[Key]]
:
key
,
[[Value]]
:
value
}.
Append
p
to
M
.
[[WeakMapData]]
.
Return
M
.
24.3.3.8
WeakMap.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"WeakMap"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
24.3.4
Properties of WeakMap Instances
WeakMap instances are
ordinary objects
that inherit properties from the
WeakMap prototype object
. WeakMap instances also have a
[[WeakMapData]]
internal slot.
24.4
WeakSet Objects
WeakSets are collections of objects and/or symbols. A distinct object or symbol may only occur once as an element of a WeakSet's collection. A WeakSet may be queried to see if it contains a specific value, but no mechanism is provided for enumerating the values it holds. In certain conditions, values which are not
live
are removed as WeakSet elements, as described in
9.9.3
.
An implementation may impose an arbitrarily determined latency between the time a value contained in a WeakSet becomes inaccessible and the time when the value is removed from the WeakSet. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to determine if a WeakSet contains a particular value that does not require the observer to present the observed value.
WeakSets must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of WeakSets. It is not intended to be a viable implementation model.
Note
See the NOTE in
24.3
.
24.4.1
The WeakSet Constructor
The WeakSet
constructor
:
is
%WeakSet%
.
is the initial value of the
"WeakSet"
property of the
global object
.
creates and initializes a new WeakSet when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value in an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified WeakSet behaviour must include a
super
call to the WeakSet
constructor
to create and initialize the subclass instance with the internal state necessary to support the
WeakSet.prototype
built-in methods.
24.4.1.1
WeakSet ( [
iterable
] )
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
set
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%WeakSet.prototype%"
, «
[[WeakSetData]]
»).
Set
set
.
[[WeakSetData]]
to a new empty
List
.
If
iterable
is either
undefined
or
null
, return
set
.
Let
adder
be ?
Get
(
set
,
"add"
).
If
IsCallable
(
adder
) is
false
, throw a
TypeError
exception.
Let
iteratorRecord
be ?
GetIterator
(
iterable
,
sync
).
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, return
set
.
Let
status
be
Completion
(
Call
(
adder
,
set
, «
next
»)).
IfAbruptCloseIterator
(
status
,
iteratorRecord
).
24.4.2
Properties of the WeakSet Constructor
The WeakSet
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
24.4.2.1
WeakSet.prototype
The initial value of
WeakSet.prototype
is the
WeakSet prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
24.4.3
Properties of the WeakSet Prototype Object
The
WeakSet prototype object
:
is
%WeakSet.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have a
[[WeakSetData]]
internal slot.
24.4.3.1
WeakSet.prototype.add (
value
)
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[WeakSetData]]
).
If
CanBeHeldWeakly
(
value
) is
false
, throw a
TypeError
exception.
For each element
e
of
S
.
[[WeakSetData]]
, do
If
e
is not
empty
and
SameValue
(
e
,
value
) is
true
, then
Return
S
.
Append
value
to
S
.
[[WeakSetData]]
.
Return
S
.
24.4.3.2
WeakSet.prototype.constructor
The initial value of
WeakSet.prototype.constructor
is
%WeakSet%
.
24.4.3.3
WeakSet.prototype.delete (
value
)
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[WeakSetData]]
).
If
CanBeHeldWeakly
(
value
) is
false
, return
false
.
For each element
e
of
S
.
[[WeakSetData]]
, do
If
e
is not
empty
and
SameValue
(
e
,
value
) is
true
, then
Replace the element of
S
.
[[WeakSetData]]
whose value is
e
with an element whose value is
empty
.
Return
true
.
Return
false
.
Note
The value
empty
is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.
24.4.3.4
WeakSet.prototype.has (
value
)
This method performs the following steps when called:
Let
S
be the
this
value.
Perform ?
RequireInternalSlot
(
S
,
[[WeakSetData]]
).
If
CanBeHeldWeakly
(
value
) is
false
, return
false
.
For each element
e
of
S
.
[[WeakSetData]]
, do
If
e
is not
empty
and
SameValue
(
e
,
value
) is
true
, return
true
.
Return
false
.
24.4.3.5
WeakSet.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"WeakSet"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
24.4.4
Properties of WeakSet Instances
WeakSet instances are
ordinary objects
that inherit properties from the
WeakSet prototype object
. WeakSet instances also have a
[[WeakSetData]]
internal slot.
24.5
Abstract Operations for Keyed Collections
24.5.1
CanonicalizeKeyedCollectionKey (
key
)
The abstract operation CanonicalizeKeyedCollectionKey takes argument
key
(an
ECMAScript language value
) and returns an
ECMAScript language value
. It performs the following steps when called:
If
key
is
-0
𝔽
, return
+0
𝔽
.
Return
key
.
25
Structured Data
25.1
ArrayBuffer Objects
25.1.1
Notation
The descriptions below in this section,
25.4
, and
29
use the read-modify-write modification function internal data structure.
A
read-modify-write modification function
is a mathematical function that is represented as an abstract closure that takes two
Lists
of
byte values
as arguments and returns a
List
of
byte values
. These abstract closures satisfy all of the following properties:
They perform all their algorithm steps atomically.
Their individual algorithm steps are not observable.
Note
To aid verifying that a read-modify-write modification function's algorithm steps constitute a pure, mathematical function, the following editorial conventions are recommended:
They do not access, directly or transitively via invoked
abstract operations
and abstract closures, any language or specification values except their parameters and captured values.
They do not invoke, directly or transitively,
abstract operations
and abstract closures that return
Completion Records
.
They do not return
Completion Records
.
25.1.2
Fixed-length and Resizable ArrayBuffer Objects
A
fixed-length ArrayBuffer
is an ArrayBuffer whose byte length cannot change after creation.
A
resizable ArrayBuffer
is an ArrayBuffer whose byte length may change after creation via calls to
ArrayBuffer.prototype.resize (
newLength
)
.
The kind of ArrayBuffer object that is created depends on the arguments passed to
ArrayBuffer (
length
[ ,
options
] )
.
25.1.3
Abstract Operations For ArrayBuffer Objects
25.1.3.1
AllocateArrayBuffer (
constructor
,
byteLength
[ ,
maxByteLength
] )
The abstract operation AllocateArrayBuffer takes arguments
constructor
(a
constructor
) and
byteLength
(a non-negative
integer
) and optional argument
maxByteLength
(a non-negative
integer
or
empty
) and returns either a
normal completion containing
an ArrayBuffer or a
throw completion
. It is used to create an ArrayBuffer. It performs the following steps when called:
Let
slots
be «
[[ArrayBufferData]]
,
[[ArrayBufferByteLength]]
,
[[ArrayBufferDetachKey]]
».
If
maxByteLength
is present and
maxByteLength
is not
empty
, let
allocatingResizableBuffer
be
true
; otherwise let
allocatingResizableBuffer
be
false
.
If
allocatingResizableBuffer
is
true
, then
If
byteLength
>
maxByteLength
, throw a
RangeError
exception.
Append
[[ArrayBufferMaxByteLength]]
to
slots
.
Let
obj
be ?
OrdinaryCreateFromConstructor
(
constructor
,
"%ArrayBuffer.prototype%"
,
slots
).
Let
block
be ?
CreateByteDataBlock
(
byteLength
).
Set
obj
.
[[ArrayBufferData]]
to
block
.
Set
obj
.
[[ArrayBufferByteLength]]
to
byteLength
.
If
allocatingResizableBuffer
is
true
, then
If it is not possible to create a
Data Block
block
consisting of
maxByteLength
bytes, throw a
RangeError
exception.
NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations may throw if, for example, virtual memory cannot be reserved up front.
Set
obj
.
[[ArrayBufferMaxByteLength]]
to
maxByteLength
.
Return
obj
.
25.1.3.2
ArrayBufferByteLength (
arrayBuffer
,
order
)
The abstract operation ArrayBufferByteLength takes arguments
arrayBuffer
(an ArrayBuffer or SharedArrayBuffer) and
order
(
seq-cst
or
unordered
) and returns a non-negative
integer
. It performs the following steps when called:
If
IsGrowableSharedArrayBuffer
(
arrayBuffer
) is
true
, then
Let
bufferByteLengthBlock
be
arrayBuffer
.
[[ArrayBufferByteLengthData]]
.
Let
rawLength
be
GetRawBytesFromSharedBlock
(
bufferByteLengthBlock
, 0,
biguint64
,
true
,
order
).
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
isLittleEndian
be
AR
.
[[LittleEndian]]
.
Return
ℝ
(
RawBytesToNumeric
(
biguint64
,
rawLength
,
isLittleEndian
)).
Assert
:
IsDetachedBuffer
(
arrayBuffer
) is
false
.
Return
arrayBuffer
.
[[ArrayBufferByteLength]]
.
25.1.3.3
ArrayBufferCopyAndDetach (
arrayBuffer
,
newLength
,
preserveResizability
)
The abstract operation ArrayBufferCopyAndDetach takes arguments
arrayBuffer
(an
ECMAScript language value
),
newLength
(an
ECMAScript language value
), and
preserveResizability
(
preserve-resizability
or
fixed-length
) and returns either a
normal completion containing
an ArrayBuffer or a
throw completion
. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
arrayBuffer
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
arrayBuffer
) is
true
, throw a
TypeError
exception.
If
newLength
is
undefined
, then
Let
newByteLength
be
arrayBuffer
.
[[ArrayBufferByteLength]]
.
Else,
Let
newByteLength
be ?
ToIndex
(
newLength
).
If
IsDetachedBuffer
(
arrayBuffer
) is
true
, throw a
TypeError
exception.
If
preserveResizability
is
preserve-resizability
and
IsFixedLengthArrayBuffer
(
arrayBuffer
) is
false
, then
Let
newMaxByteLength
be
arrayBuffer
.
[[ArrayBufferMaxByteLength]]
.
Else,
Let
newMaxByteLength
be
empty
.
If
arrayBuffer
.
[[ArrayBufferDetachKey]]
is not
undefined
, throw a
TypeError
exception.
Let
newBuffer
be ?
AllocateArrayBuffer
(
%ArrayBuffer%
,
newByteLength
,
newMaxByteLength
).
Let
copyLength
be
min
(
newByteLength
,
arrayBuffer
.
[[ArrayBufferByteLength]]
).
Let
fromBlock
be
arrayBuffer
.
[[ArrayBufferData]]
.
Let
toBlock
be
newBuffer
.
[[ArrayBufferData]]
.
Perform
CopyDataBlockBytes
(
toBlock
, 0,
fromBlock
, 0,
copyLength
).
NOTE: Neither creation of the new
Data Block
nor copying from the old
Data Block
are observable. Implementations may implement this method as a zero-copy move or a
realloc
.
Perform !
DetachArrayBuffer
(
arrayBuffer
).
Return
newBuffer
.
25.1.3.4
IsDetachedBuffer (
arrayBuffer
)
The abstract operation IsDetachedBuffer takes argument
arrayBuffer
(an ArrayBuffer or a SharedArrayBuffer) and returns a Boolean. It performs the following steps when called:
If
arrayBuffer
.
[[ArrayBufferData]]
is
null
, return
true
.
Return
false
.
25.1.3.5
DetachArrayBuffer (
arrayBuffer
[ ,
key
] )
The abstract operation DetachArrayBuffer takes argument
arrayBuffer
(an ArrayBuffer) and optional argument
key
(anything) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Assert
:
IsSharedArrayBuffer
(
arrayBuffer
) is
false
.
If
key
is not present, set
key
to
undefined
.
If
arrayBuffer
.
[[ArrayBufferDetachKey]]
is not
key
, throw a
TypeError
exception.
Set
arrayBuffer
.
[[ArrayBufferData]]
to
null
.
Set
arrayBuffer
.
[[ArrayBufferByteLength]]
to 0.
Return
unused
.
Note
Detaching an ArrayBuffer instance disassociates the
Data Block
used as its backing store from the instance and sets the byte length of the buffer to 0.
25.1.3.6
CloneArrayBuffer (
srcBuffer
,
srcByteOffset
,
srcLength
)
The abstract operation CloneArrayBuffer takes arguments
srcBuffer
(an ArrayBuffer or a SharedArrayBuffer),
srcByteOffset
(a non-negative
integer
), and
srcLength
(a non-negative
integer
) and returns either a
normal completion containing
an ArrayBuffer or a
throw completion
. It creates a new ArrayBuffer whose data is a copy of
srcBuffer
's data over the range starting at
srcByteOffset
and continuing for
srcLength
bytes. It performs the following steps when called:
Assert
:
IsDetachedBuffer
(
srcBuffer
) is
false
.
Let
targetBuffer
be ?
AllocateArrayBuffer
(
%ArrayBuffer%
,
srcLength
).
Let
srcBlock
be
srcBuffer
.
[[ArrayBufferData]]
.
Let
targetBlock
be
targetBuffer
.
[[ArrayBufferData]]
.
Perform
CopyDataBlockBytes
(
targetBlock
, 0,
srcBlock
,
srcByteOffset
,
srcLength
).
Return
targetBuffer
.
25.1.3.7
GetArrayBufferMaxByteLengthOption (
options
)
The abstract operation GetArrayBufferMaxByteLengthOption takes argument
options
(an
ECMAScript language value
) and returns either a
normal completion containing
either a non-negative
integer
or
empty
, or a
throw completion
. It performs the following steps when called:
If
options
is not an Object
, return
empty
.
Let
maxByteLength
be ?
Get
(
options
,
"maxByteLength"
).
If
maxByteLength
is
undefined
, return
empty
.
Return ?
ToIndex
(
maxByteLength
).
25.1.3.8
HostResizeArrayBuffer (
buffer
,
newByteLength
)
The
host-defined
abstract operation HostResizeArrayBuffer takes arguments
buffer
(an ArrayBuffer) and
newByteLength
(a non-negative
integer
) and returns either a
normal completion containing
either
handled
or
unhandled
, or a
throw completion
. It gives the
host
an opportunity to perform
implementation-defined
resizing of
buffer
. If the
host
chooses not to handle resizing of
buffer
, it may return
unhandled
for the default behaviour.
The implementation of HostResizeArrayBuffer must conform to the following requirements:
The abstract operation does not detach
buffer
.
If the abstract operation completes normally with
handled
,
buffer
.
[[ArrayBufferByteLength]]
is
newByteLength
.
The default implementation of HostResizeArrayBuffer is to return
NormalCompletion
(
unhandled
).
25.1.3.9
IsFixedLengthArrayBuffer (
arrayBuffer
)
The abstract operation IsFixedLengthArrayBuffer takes argument
arrayBuffer
(an ArrayBuffer or a SharedArrayBuffer) and returns a Boolean. It performs the following steps when called:
If
arrayBuffer
has an
[[ArrayBufferMaxByteLength]]
internal slot, return
false
.
Return
true
.
25.1.3.10
IsUnsignedElementType (
type
)
The abstract operation IsUnsignedElementType takes argument
type
(a
TypedArray element type
) and returns a Boolean. It verifies if the argument
type
is an unsigned
TypedArray element type
. It performs the following steps when called:
If
type
is one of
uint8
,
uint8clamped
,
uint16
,
uint32
, or
biguint64
, return
true
.
Return
false
.
25.1.3.11
IsUnclampedIntegerElementType (
type
)
The abstract operation IsUnclampedIntegerElementType takes argument
type
(a
TypedArray element type
) and returns a Boolean. It verifies if the argument
type
is an
Integer
TypedArray element type
not including
uint8clamped
. It performs the following steps when called:
If
type
is one of
int8
,
uint8
,
int16
,
uint16
,
int32
, or
uint32
, return
true
.
Return
false
.
25.1.3.12
IsBigIntElementType (
type
)
The abstract operation IsBigIntElementType takes argument
type
(a
TypedArray element type
) and returns a Boolean. It verifies if the argument
type
is a BigInt
TypedArray element type
. It performs the following steps when called:
If
type
is either
biguint64
or
bigint64
, return
true
.
Return
false
.
25.1.3.13
IsNoTearConfiguration (
type
,
order
)
The abstract operation IsNoTearConfiguration takes arguments
type
(a
TypedArray element type
) and
order
(
seq-cst
,
unordered
, or
init
) and returns a Boolean. It performs the following steps when called:
If
IsUnclampedIntegerElementType
(
type
) is
true
, return
true
.
If
IsBigIntElementType
(
type
) is
true
and
order
is neither
init
nor
unordered
, return
true
.
Return
false
.
25.1.3.14
RawBytesToNumeric (
type
,
rawBytes
,
isLittleEndian
)
The abstract operation RawBytesToNumeric takes arguments
type
(a
TypedArray element type
),
rawBytes
(a
List
of
byte values
), and
isLittleEndian
(a Boolean) and returns a Number or a BigInt. It performs the following steps when called:
Let
elementSize
be the Element Size value specified in
Table 70
for Element Type
type
.
If
isLittleEndian
is
false
, reverse the order of the elements of
rawBytes
.
If
type
is
float16
, then
Let
value
be the byte elements of
rawBytes
concatenated and interpreted as a little-endian bit string encoding of an
IEEE 754-2019
binary16 value.
If
value
is a NaN, return
NaN
.
Return the Number value that corresponds to
value
.
If
type
is
float32
, then
Let
value
be the byte elements of
rawBytes
concatenated and interpreted as a little-endian bit string encoding of an
IEEE 754-2019
binary32 value.
If
value
is a NaN, return
NaN
.
Return the Number value that corresponds to
value
.
If
type
is
float64
, then
Let
value
be the byte elements of
rawBytes
concatenated and interpreted as a little-endian bit string encoding of an
IEEE 754-2019
binary64 value.
If
value
is a NaN, return
NaN
.
Return the Number value that corresponds to
value
.
If
IsUnsignedElementType
(
type
) is
true
, then
Let
intValue
be the byte elements of
rawBytes
concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
Else,
Let
intValue
be the byte elements of
rawBytes
concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length
elementSize
× 8.
If
IsBigIntElementType
(
type
) is
true
, return the BigInt value that corresponds to
intValue
.
Otherwise, return the Number value that corresponds to
intValue
.
25.1.3.15
GetRawBytesFromSharedBlock (
block
,
byteIndex
,
type
,
isTypedArray
,
order
)
The abstract operation GetRawBytesFromSharedBlock takes arguments
block
(a
Shared Data Block
),
byteIndex
(a non-negative
integer
),
type
(a
TypedArray element type
),
isTypedArray
(a Boolean), and
order
(
seq-cst
or
unordered
) and returns a
List
of
byte values
. It performs the following steps when called:
Let
elementSize
be the Element Size value specified in
Table 70
for Element Type
type
.
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
If
isTypedArray
is
true
and
IsNoTearConfiguration
(
type
,
order
) is
true
, let
noTear
be
true
; otherwise let
noTear
be
false
.
Let
rawValue
be a
List
of length
elementSize
whose elements are nondeterministically chosen
byte values
.
NOTE: In implementations,
rawValue
is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the
memory model
to describe observable behaviour of hardware with weak consistency.
Let
readEvent
be
ReadSharedMemory
{
[[Order]]
:
order
,
[[NoTear]]
:
noTear
,
[[Block]]
:
block
,
[[ByteIndex]]
:
byteIndex
,
[[ElementSize]]
:
elementSize
}.
Append
readEvent
to
eventsRecord
.
[[EventList]]
.
Append
Chosen Value Record
{
[[Event]]
:
readEvent
,
[[ChosenValue]]
:
rawValue
} to
execution
.
[[ChosenValues]]
.
Return
rawValue
.
25.1.3.16
GetValueFromBuffer (
arrayBuffer
,
byteIndex
,
type
,
isTypedArray
,
order
[ ,
isLittleEndian
] )
The abstract operation GetValueFromBuffer takes arguments
arrayBuffer
(an ArrayBuffer or SharedArrayBuffer),
byteIndex
(a non-negative
integer
),
type
(a
TypedArray element type
),
isTypedArray
(a Boolean), and
order
(
seq-cst
or
unordered
) and optional argument
isLittleEndian
(a Boolean) and returns a Number or a BigInt. It performs the following steps when called:
Assert
:
IsDetachedBuffer
(
arrayBuffer
) is
false
.
Assert
: There are sufficient bytes in
arrayBuffer
starting at
byteIndex
to represent a value of
type
.
Let
block
be
arrayBuffer
.
[[ArrayBufferData]]
.
Let
elementSize
be the Element Size value specified in
Table 70
for Element Type
type
.
If
IsSharedArrayBuffer
(
arrayBuffer
) is
true
, then
Assert
:
block
is a
Shared Data Block
.
Let
rawValue
be
GetRawBytesFromSharedBlock
(
block
,
byteIndex
,
type
,
isTypedArray
,
order
).
Else,
Let
rawValue
be a
List
whose elements are bytes from
block
at indices in the
interval
from
byteIndex
(inclusive) to
byteIndex
+
elementSize
(exclusive).
Assert
: The number of elements in
rawValue
is
elementSize
.
If
isLittleEndian
is not present, then
Let
AR
be the
Agent Record
of the
surrounding agent
.
Set
isLittleEndian
to
AR
.
[[LittleEndian]]
.
Return
RawBytesToNumeric
(
type
,
rawValue
,
isLittleEndian
).
25.1.3.17
NumericToRawBytes (
type
,
value
,
isLittleEndian
)
The abstract operation NumericToRawBytes takes arguments
type
(a
TypedArray element type
),
value
(a Number or a BigInt), and
isLittleEndian
(a Boolean) and returns a
List
of
byte values
. It performs the following steps when called:
If
type
is
float16
, then
Let
rawBytes
be a
List
whose elements are the 2 bytes that are the result of converting
value
to
IEEE 754-2019
binary16 format using roundTiesToEven mode. The bytes are arranged in little endian order. If
value
is
NaN
,
rawBytes
may be set to any implementation chosen
IEEE 754-2019
binary16 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable
NaN
value.
Else if
type
is
float32
, then
Let
rawBytes
be a
List
whose elements are the 4 bytes that are the result of converting
value
to
IEEE 754-2019
binary32 format using roundTiesToEven mode. The bytes are arranged in little endian order. If
value
is
NaN
,
rawBytes
may be set to any implementation chosen
IEEE 754-2019
binary32 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable
NaN
value.
Else if
type
is
float64
, then
Let
rawBytes
be a
List
whose elements are the 8 bytes that are the
IEEE 754-2019
binary64 format encoding of
value
. The bytes are arranged in little endian order. If
value
is
NaN
,
rawBytes
may be set to any implementation chosen
IEEE 754-2019
binary64 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable
NaN
value.
Else,
Let
n
be the Element Size value specified in
Table 70
for Element Type
type
.
Let
conversionOperation
be the abstract operation named in the Conversion Operation column in
Table 70
for Element Type
type
.
Let
intValue
be
ℝ
(!
conversionOperation
(
value
)).
If
intValue
≥ 0, then
Let
rawBytes
be a
List
whose elements are the
n
-byte binary encoding of
intValue
. The bytes are ordered in little endian order.
Else,
Let
rawBytes
be a
List
whose elements are the
n
-byte binary two's complement encoding of
intValue
. The bytes are ordered in little endian order.
If
isLittleEndian
is
false
, reverse the order of the elements of
rawBytes
.
Return
rawBytes
.
25.1.3.18
SetValueInBuffer (
arrayBuffer
,
byteIndex
,
type
,
value
,
isTypedArray
,
order
[ ,
isLittleEndian
] )
The abstract operation SetValueInBuffer takes arguments
arrayBuffer
(an ArrayBuffer or SharedArrayBuffer),
byteIndex
(a non-negative
integer
),
type
(a
TypedArray element type
),
value
(a Number or a BigInt),
isTypedArray
(a Boolean), and
order
(
seq-cst
,
unordered
, or
init
) and optional argument
isLittleEndian
(a Boolean) and returns
unused
. It performs the following steps when called:
Assert
:
IsDetachedBuffer
(
arrayBuffer
) is
false
.
Assert
: There are sufficient bytes in
arrayBuffer
starting at
byteIndex
to represent a value of
type
.
Assert
:
value
is a BigInt
if
IsBigIntElementType
(
type
) is
true
; otherwise,
value
is a Number
.
Let
block
be
arrayBuffer
.
[[ArrayBufferData]]
.
Let
elementSize
be the Element Size value specified in
Table 70
for Element Type
type
.
Let
AR
be the
Agent Record
of the
surrounding agent
.
If
isLittleEndian
is not present, then
Set
isLittleEndian
to
AR
.
[[LittleEndian]]
.
Let
rawBytes
be
NumericToRawBytes
(
type
,
value
,
isLittleEndian
).
If
IsSharedArrayBuffer
(
arrayBuffer
) is
true
, then
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
If
isTypedArray
is
true
and
IsNoTearConfiguration
(
type
,
order
) is
true
, let
noTear
be
true
; otherwise let
noTear
be
false
.
Append
WriteSharedMemory
{
[[Order]]
:
order
,
[[NoTear]]
:
noTear
,
[[Block]]
:
block
,
[[ByteIndex]]
:
byteIndex
,
[[ElementSize]]
:
elementSize
,
[[Payload]]
:
rawBytes
} to
eventsRecord
.
[[EventList]]
.
Else,
Store the individual bytes of
rawBytes
into
block
, starting at
block
[
byteIndex
].
Return
unused
.
25.1.3.19
GetModifySetValueInBuffer (
arrayBuffer
,
byteIndex
,
type
,
value
,
op
)
The abstract operation GetModifySetValueInBuffer takes arguments
arrayBuffer
(an ArrayBuffer or a SharedArrayBuffer),
byteIndex
(a non-negative
integer
),
type
(a
TypedArray element type
),
value
(a Number or a BigInt), and
op
(a
read-modify-write modification function
) and returns a Number or a BigInt. It performs the following steps when called:
Assert
:
IsDetachedBuffer
(
arrayBuffer
) is
false
.
Assert
: There are sufficient bytes in
arrayBuffer
starting at
byteIndex
to represent a value of
type
.
Assert
:
value
is a BigInt
if
IsBigIntElementType
(
type
) is
true
; otherwise,
value
is a Number
.
Let
block
be
arrayBuffer
.
[[ArrayBufferData]]
.
Let
elementSize
be the Element Size value specified in
Table 70
for Element Type
type
.
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
isLittleEndian
be
AR
.
[[LittleEndian]]
.
Let
rawBytes
be
NumericToRawBytes
(
type
,
value
,
isLittleEndian
).
If
IsSharedArrayBuffer
(
arrayBuffer
) is
true
, then
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
Let
rawBytesRead
be a
List
of length
elementSize
whose elements are nondeterministically chosen
byte values
.
NOTE: In implementations,
rawBytesRead
is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the
memory model
to describe observable behaviour of hardware with weak consistency.
Let
rmwEvent
be
ReadModifyWriteSharedMemory
{
[[Order]]
:
seq-cst
,
[[NoTear]]
:
true
,
[[Block]]
:
block
,
[[ByteIndex]]
:
byteIndex
,
[[ElementSize]]
:
elementSize
,
[[Payload]]
:
rawBytes
,
[[ModifyOp]]
:
op
}.
Append
rmwEvent
to
eventsRecord
.
[[EventList]]
.
Append
Chosen Value Record
{
[[Event]]
:
rmwEvent
,
[[ChosenValue]]
:
rawBytesRead
} to
execution
.
[[ChosenValues]]
.
Else,
Let
rawBytesRead
be a
List
of length
elementSize
whose elements are the sequence of
elementSize
bytes starting with
block
[
byteIndex
].
Let
rawBytesModified
be
op
(
rawBytesRead
,
rawBytes
).
Store the individual bytes of
rawBytesModified
into
block
, starting at
block
[
byteIndex
].
Return
RawBytesToNumeric
(
type
,
rawBytesRead
,
isLittleEndian
).
25.1.4
The ArrayBuffer Constructor
The ArrayBuffer
constructor
:
is
%ArrayBuffer%
.
is the initial value of the
"ArrayBuffer"
property of the
global object
.
creates and initializes a new ArrayBuffer when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified ArrayBuffer behaviour must include a
super
call to the ArrayBuffer
constructor
to create and initialize subclass instances with the internal state necessary to support the
ArrayBuffer.prototype
built-in methods.
25.1.4.1
ArrayBuffer (
length
[ ,
options
] )
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
byteLength
be ?
ToIndex
(
length
).
Let
requestedMaxByteLength
be ?
GetArrayBufferMaxByteLengthOption
(
options
).
Return ?
AllocateArrayBuffer
(NewTarget,
byteLength
,
requestedMaxByteLength
).
25.1.5
Properties of the ArrayBuffer Constructor
The ArrayBuffer
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
25.1.5.1
ArrayBuffer.isView (
arg
)
This function performs the following steps when called:
If
arg
is not an Object
, return
false
.
If
arg
has a
[[ViewedArrayBuffer]]
internal slot, return
true
.
Return
false
.
25.1.5.2
ArrayBuffer.prototype
The initial value of
ArrayBuffer.prototype
is the
ArrayBuffer prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
25.1.5.3
get ArrayBuffer [ %Symbol.species% ]
ArrayBuffer[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
Note
ArrayBuffer.prototype.slice (
start
,
end
)
normally uses its
this
value's
constructor
to create a derived object. However, a subclass
constructor
may over-ride that default behaviour for the
ArrayBuffer.prototype.slice (
start
,
end
)
method by redefining its
%Symbol.species%
property.
25.1.6
Properties of the ArrayBuffer Prototype Object
The
ArrayBuffer prototype object
:
is
%ArrayBuffer.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have an
[[ArrayBufferData]]
or
[[ArrayBufferByteLength]]
internal slot.
25.1.6.1
get ArrayBuffer.prototype.byteLength
ArrayBuffer.prototype.byteLength
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
true
, throw a
TypeError
exception.
If
IsDetachedBuffer
(
O
) is
true
, return
+0
𝔽
.
Let
length
be
O
.
[[ArrayBufferByteLength]]
.
Return
𝔽
(
length
).
25.1.6.2
ArrayBuffer.prototype.constructor
The initial value of
ArrayBuffer.prototype.constructor
is
%ArrayBuffer%
.
25.1.6.3
get ArrayBuffer.prototype.detached
ArrayBuffer.prototype.detached
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
true
, throw a
TypeError
exception.
Return
IsDetachedBuffer
(
O
).
25.1.6.4
get ArrayBuffer.prototype.maxByteLength
ArrayBuffer.prototype.maxByteLength
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
true
, throw a
TypeError
exception.
If
IsDetachedBuffer
(
O
) is
true
, return
+0
𝔽
.
If
IsFixedLengthArrayBuffer
(
O
) is
true
, then
Let
length
be
O
.
[[ArrayBufferByteLength]]
.
Else,
Let
length
be
O
.
[[ArrayBufferMaxByteLength]]
.
Return
𝔽
(
length
).
25.1.6.5
get ArrayBuffer.prototype.resizable
ArrayBuffer.prototype.resizable
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
true
, throw a
TypeError
exception.
If
IsFixedLengthArrayBuffer
(
O
) is
false
, return
true
; otherwise return
false
.
25.1.6.6
ArrayBuffer.prototype.resize (
newLength
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferMaxByteLength]]
).
If
IsSharedArrayBuffer
(
O
) is
true
, throw a
TypeError
exception.
Let
newByteLength
be ?
ToIndex
(
newLength
).
If
IsDetachedBuffer
(
O
) is
true
, throw a
TypeError
exception.
If
newByteLength
>
O
.
[[ArrayBufferMaxByteLength]]
, throw a
RangeError
exception.
Let
hostHandled
be ?
HostResizeArrayBuffer
(
O
,
newByteLength
).
If
hostHandled
is
handled
, return
undefined
.
Let
oldBlock
be
O
.
[[ArrayBufferData]]
.
Let
newBlock
be ?
CreateByteDataBlock
(
newByteLength
).
Let
copyLength
be
min
(
newByteLength
,
O
.
[[ArrayBufferByteLength]]
).
Perform
CopyDataBlockBytes
(
newBlock
, 0,
oldBlock
, 0,
copyLength
).
NOTE: Neither creation of the new
Data Block
nor copying from the old
Data Block
are observable. Implementations may implement this method as in-place growth or shrinkage.
Set
O
.
[[ArrayBufferData]]
to
newBlock
.
Set
O
.
[[ArrayBufferByteLength]]
to
newByteLength
.
Return
undefined
.
25.1.6.7
ArrayBuffer.prototype.slice (
start
,
end
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
true
, throw a
TypeError
exception.
If
IsDetachedBuffer
(
O
) is
true
, throw a
TypeError
exception.
Let
len
be
O
.
[[ArrayBufferByteLength]]
.
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
first
be 0.
Else if
relativeStart
< 0, let
first
be
max
(
len
+
relativeStart
, 0).
Else, let
first
be
min
(
relativeStart
,
len
).
If
end
is
undefined
, let
relativeEnd
be
len
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
final
be 0.
Else if
relativeEnd
< 0, let
final
be
max
(
len
+
relativeEnd
, 0).
Else, let
final
be
min
(
relativeEnd
,
len
).
Let
newLen
be
max
(
final
-
first
, 0).
Let
ctor
be ?
SpeciesConstructor
(
O
,
%ArrayBuffer%
).
Let
new
be ?
Construct
(
ctor
, «
𝔽
(
newLen
) »).
Perform ?
RequireInternalSlot
(
new
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
new
) is
true
, throw a
TypeError
exception.
If
IsDetachedBuffer
(
new
) is
true
, throw a
TypeError
exception.
If
SameValue
(
new
,
O
) is
true
, throw a
TypeError
exception.
If
new
.
[[ArrayBufferByteLength]]
<
newLen
, throw a
TypeError
exception.
NOTE: Side-effects of the above steps may have detached or resized
O
.
If
IsDetachedBuffer
(
O
) is
true
, throw a
TypeError
exception.
Let
fromBuf
be
O
.
[[ArrayBufferData]]
.
Let
toBuf
be
new
.
[[ArrayBufferData]]
.
Let
currentLen
be
O
.
[[ArrayBufferByteLength]]
.
If
first
<
currentLen
, then
Let
count
be
min
(
newLen
,
currentLen
-
first
).
Perform
CopyDataBlockBytes
(
toBuf
, 0,
fromBuf
,
first
,
count
).
Return
new
.
25.1.6.8
ArrayBuffer.prototype.transfer ( [
newLength
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Return ?
ArrayBufferCopyAndDetach
(
O
,
newLength
,
preserve-resizability
).
25.1.6.9
ArrayBuffer.prototype.transferToFixedLength ( [
newLength
] )
This method performs the following steps when called:
Let
O
be the
this
value.
Return ?
ArrayBufferCopyAndDetach
(
O
,
newLength
,
fixed-length
).
25.1.6.10
ArrayBuffer.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"ArrayBuffer"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
25.1.7
Properties of ArrayBuffer Instances
ArrayBuffer instances inherit properties from the
ArrayBuffer prototype object
. ArrayBuffer instances each have an
[[ArrayBufferData]]
internal slot, an
[[ArrayBufferByteLength]]
internal slot, and an
[[ArrayBufferDetachKey]]
internal slot. ArrayBuffer instances which are resizable each have an
[[ArrayBufferMaxByteLength]]
internal slot.
ArrayBuffer instances whose
[[ArrayBufferData]]
is
null
are considered to be detached and all operators to access or modify data contained in the ArrayBuffer instance will fail.
ArrayBuffer instances whose
[[ArrayBufferDetachKey]]
is set to a value other than
undefined
need to have all
DetachArrayBuffer
calls passing that same "detach key" as an argument, otherwise a TypeError will result. This internal slot is only ever set by certain embedding environments, not by algorithms in this specification.
25.1.8
Resizable ArrayBuffer Guidelines
Note 1
The following are guidelines for ECMAScript programmers working with
resizable ArrayBuffer
.
We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differs greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.
When choosing a value for the
"maxByteLength"
option for
resizable ArrayBuffer
, we recommend that the smallest possible size for the application be chosen. We recommend that
"maxByteLength"
does not exceed 1,073,741,824 (2
30
bytes or 1GiB).
Please note that successfully constructing a
resizable ArrayBuffer
for a particular maximum size does not guarantee that future resizes will succeed.
Note 2
The following are guidelines for ECMAScript implementers implementing
resizable ArrayBuffer
.
Resizable ArrayBuffer
can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the
constructor
's
"maxByteLength"
option.
If a
host
is multi-tenanted (i.e. it runs many ECMAScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of
"maxByteLength"
≥ 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risk.
If a
host
does not have virtual memory, such as those running on embedded devices without an MMU, or if a
host
only implements resizing by copying, it may accept any
Number value for
the
"maxByteLength"
option. However, we recommend a
RangeError
be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximum amount of usable memory on the device.
25.2
SharedArrayBuffer Objects
25.2.1
Fixed-length and Growable SharedArrayBuffer Objects
A
fixed-length SharedArrayBuffer
is a SharedArrayBuffer whose byte length cannot change after creation.
A
growable SharedArrayBuffer
is a SharedArrayBuffer whose byte length may increase after creation via calls to
SharedArrayBuffer.prototype.grow (
newLength
)
.
The kind of SharedArrayBuffer object that is created depends on the arguments passed to
SharedArrayBuffer (
length
[ ,
options
] )
.
25.2.2
Abstract Operations for SharedArrayBuffer Objects
25.2.2.1
AllocateSharedArrayBuffer (
constructor
,
byteLength
[ ,
maxByteLength
] )
The abstract operation AllocateSharedArrayBuffer takes arguments
constructor
(a
constructor
) and
byteLength
(a non-negative
integer
) and optional argument
maxByteLength
(a non-negative
integer
or
empty
) and returns either a
normal completion containing
a SharedArrayBuffer or a
throw completion
. It is used to create a SharedArrayBuffer. It performs the following steps when called:
Let
slots
be «
[[ArrayBufferData]]
».
If
maxByteLength
is present and
maxByteLength
is not
empty
, let
allocatingGrowableBuffer
be
true
; otherwise let
allocatingGrowableBuffer
be
false
.
If
allocatingGrowableBuffer
is
true
, then
If
byteLength
>
maxByteLength
, throw a
RangeError
exception.
Append
[[ArrayBufferByteLengthData]]
and
[[ArrayBufferMaxByteLength]]
to
slots
.
Else,
Append
[[ArrayBufferByteLength]]
to
slots
.
Let
obj
be ?
OrdinaryCreateFromConstructor
(
constructor
,
"%SharedArrayBuffer.prototype%"
,
slots
).
If
allocatingGrowableBuffer
is
true
, let
allocLength
be
maxByteLength
; otherwise let
allocLength
be
byteLength
.
Let
block
be ?
CreateSharedByteDataBlock
(
allocLength
).
Set
obj
.
[[ArrayBufferData]]
to
block
.
If
allocatingGrowableBuffer
is
true
, then
Assert
:
byteLength
≤
maxByteLength
.
Let
byteLengthBlock
be ?
CreateSharedByteDataBlock
(8).
Perform
SetValueInBuffer
(
byteLengthBlock
, 0,
biguint64
,
ℤ
(
byteLength
),
true
,
seq-cst
).
Set
obj
.
[[ArrayBufferByteLengthData]]
to
byteLengthBlock
.
Set
obj
.
[[ArrayBufferMaxByteLength]]
to
maxByteLength
.
Else,
Set
obj
.
[[ArrayBufferByteLength]]
to
byteLength
.
Return
obj
.
25.2.2.2
IsSharedArrayBuffer (
obj
)
The abstract operation IsSharedArrayBuffer takes argument
obj
(an ArrayBuffer or a SharedArrayBuffer) and returns a Boolean. It tests whether an object is a SharedArrayBuffer. It performs the following steps when called:
If
obj
.
[[ArrayBufferData]]
is a
Shared Data Block
, return
true
.
Return
false
.
25.2.2.3
IsGrowableSharedArrayBuffer (
obj
)
The abstract operation IsGrowableSharedArrayBuffer takes argument
obj
(an ArrayBuffer or a SharedArrayBuffer) and returns a Boolean. It tests whether an object is a
growable SharedArrayBuffer
. It performs the following steps when called:
If
IsSharedArrayBuffer
(
obj
) is
true
and
obj
has an
[[ArrayBufferByteLengthData]]
internal slot, return
true
.
Return
false
.
25.2.2.4
HostGrowSharedArrayBuffer (
buffer
,
newByteLength
)
The
host-defined
abstract operation HostGrowSharedArrayBuffer takes arguments
buffer
(a SharedArrayBuffer) and
newByteLength
(a non-negative
integer
) and returns either a
normal completion containing
either
handled
or
unhandled
, or a
throw completion
. It gives the
host
an opportunity to perform
implementation-defined
growing of
buffer
. If the
host
chooses not to handle growing of
buffer
, it may return
unhandled
for the default behaviour.
The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:
If the abstract operation does not complete normally with
unhandled
, and
newByteLength
< the current byte length of the
buffer
or
newByteLength
>
buffer
.
[[ArrayBufferMaxByteLength]]
, throw a
RangeError
exception.
Let
AR
be the
Agent Record
of the
surrounding agent
. Let
isLittleEndian
be
AR
.
[[LittleEndian]]
. If the abstract operation completes normally with
handled
, a
WriteSharedMemory
or
ReadModifyWriteSharedMemory
event whose
[[Order]]
is
seq-cst
,
[[Payload]]
is
NumericToRawBytes
(
biguint64
,
newByteLength
,
isLittleEndian
),
[[Block]]
is
buffer
.
[[ArrayBufferByteLengthData]]
,
[[ByteIndex]]
is 0, and
[[ElementSize]]
is 8 is added to the
surrounding agent
's
candidate execution
such that racing calls to
SharedArrayBuffer.prototype.grow (
newLength
)
are not "lost", i.e. silently do nothing.
Note
The second requirement above is intentionally vague about how or when the current byte length of
buffer
is read. Because the byte length must be updated via an atomic read-modify-write operation on the underlying hardware, architectures that use load-link/store-conditional or load-exclusive/store-exclusive instruction pairs may wish to keep the paired instructions close in the instruction stream. As such,
SharedArrayBuffer.prototype.grow (
newLength
)
itself does not perform bounds checking on
newByteLength
before calling HostGrowSharedArrayBuffer, nor is there a requirement on when the current byte length is read.
This is in contrast with
HostResizeArrayBuffer
, which is guaranteed that 0 ≤
newByteLength
≤
buffer
.
[[ArrayBufferMaxByteLength]]
.
The default implementation of HostGrowSharedArrayBuffer is to return
NormalCompletion
(
unhandled
).
25.2.3
The SharedArrayBuffer Constructor
The SharedArrayBuffer
constructor
:
is
%SharedArrayBuffer%
.
is the initial value of the
"SharedArrayBuffer"
property of the
global object
, if that property is present (see below).
creates and initializes a new SharedArrayBuffer when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified SharedArrayBuffer behaviour must include a
super
call to the SharedArrayBuffer
constructor
to create and initialize subclass instances with the internal state necessary to support the
SharedArrayBuffer.prototype
built-in methods.
Whenever a
host
does not provide concurrent access to SharedArrayBuffers it may omit the
"SharedArrayBuffer"
property of the
global object
.
Note
Unlike an
ArrayBuffer
, a
SharedArrayBuffer
cannot become detached, and its internal
[[ArrayBufferData]]
slot is never
null
.
25.2.3.1
SharedArrayBuffer (
length
[ ,
options
] )
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Let
byteLength
be ?
ToIndex
(
length
).
Let
requestedMaxByteLength
be ?
GetArrayBufferMaxByteLengthOption
(
options
).
Return ?
AllocateSharedArrayBuffer
(NewTarget,
byteLength
,
requestedMaxByteLength
).
25.2.4
Properties of the SharedArrayBuffer Constructor
The SharedArrayBuffer
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
25.2.4.1
SharedArrayBuffer.prototype
The initial value of
SharedArrayBuffer.prototype
is the
SharedArrayBuffer prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
25.2.4.2
get SharedArrayBuffer [ %Symbol.species% ]
SharedArrayBuffer[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
25.2.5
Properties of the SharedArrayBuffer Prototype Object
The
SharedArrayBuffer prototype object
:
is
%SharedArrayBuffer.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have an
[[ArrayBufferData]]
or
[[ArrayBufferByteLength]]
internal slot.
25.2.5.1
get SharedArrayBuffer.prototype.byteLength
SharedArrayBuffer.prototype.byteLength
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
false
, throw a
TypeError
exception.
Let
length
be
ArrayBufferByteLength
(
O
,
seq-cst
).
Return
𝔽
(
length
).
25.2.5.2
SharedArrayBuffer.prototype.constructor
The initial value of
SharedArrayBuffer.prototype.constructor
is
%SharedArrayBuffer%
.
25.2.5.3
SharedArrayBuffer.prototype.grow (
newLength
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferMaxByteLength]]
).
If
IsSharedArrayBuffer
(
O
) is
false
, throw a
TypeError
exception.
Let
newByteLength
be ?
ToIndex
(
newLength
).
Let
hostHandled
be ?
HostGrowSharedArrayBuffer
(
O
,
newByteLength
).
If
hostHandled
is
handled
, return
undefined
.
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
isLittleEndian
be
AR
.
[[LittleEndian]]
.
Let
byteLengthBlock
be
O
.
[[ArrayBufferByteLengthData]]
.
Let
currentByteLengthRawBytes
be
GetRawBytesFromSharedBlock
(
byteLengthBlock
, 0,
biguint64
,
true
,
seq-cst
).
Let
newByteLengthRawBytes
be
NumericToRawBytes
(
biguint64
,
ℤ
(
newByteLength
),
isLittleEndian
).
Repeat,
NOTE: This is a compare-and-exchange loop to ensure that parallel, racing grows of the same buffer are totally ordered, are not lost, and do not silently do nothing. The loop exits if it was able to attempt to grow uncontended.
Let
currentByteLength
be
ℝ
(
RawBytesToNumeric
(
biguint64
,
currentByteLengthRawBytes
,
isLittleEndian
)).
If
newByteLength
=
currentByteLength
, return
undefined
.
If
newByteLength
<
currentByteLength
or
newByteLength
>
O
.
[[ArrayBufferMaxByteLength]]
, throw a
RangeError
exception.
Let
byteLengthDelta
be
newByteLength
-
currentByteLength
.
If it is impossible to create a new
Shared Data Block
value consisting of
byteLengthDelta
bytes, throw a
RangeError
exception.
NOTE: No new
Shared Data Block
is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a
max
-sized
Shared Data Block
at construction time, and this step captures the requirement that implementations that run out of memory must throw a
RangeError
.
Let
readByteLengthRawBytes
be
AtomicCompareExchangeInSharedBlock
(
byteLengthBlock
, 0, 8,
currentByteLengthRawBytes
,
newByteLengthRawBytes
).
If
ByteListEqual
(
readByteLengthRawBytes
,
currentByteLengthRawBytes
) is
true
, return
undefined
.
Set
currentByteLengthRawBytes
to
readByteLengthRawBytes
.
Note
Spurious failures of the compare-exchange to update the length are prohibited. If the bounds checking for the new length passes and the implementation is not out of memory, a
ReadModifyWriteSharedMemory
event (i.e. a successful compare-exchange) is always added into the
candidate execution
.
Parallel calls to SharedArrayBuffer.prototype.grow are totally ordered. For example, consider two racing calls:
sab.grow(10)
and
sab.grow(20)
. One of the two calls is guaranteed to win the race. The call to
sab.grow(10)
will never shrink
sab
even if
sab.grow(20)
happened first; in that case it will instead throw a RangeError.
25.2.5.4
get SharedArrayBuffer.prototype.growable
SharedArrayBuffer.prototype.growable
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
false
, throw a
TypeError
exception.
If
IsFixedLengthArrayBuffer
(
O
) is
false
, return
true
; otherwise return
false
.
25.2.5.5
get SharedArrayBuffer.prototype.maxByteLength
SharedArrayBuffer.prototype.maxByteLength
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
false
, throw a
TypeError
exception.
If
IsFixedLengthArrayBuffer
(
O
) is
true
, then
Let
length
be
O
.
[[ArrayBufferByteLength]]
.
Else,
Let
length
be
O
.
[[ArrayBufferMaxByteLength]]
.
Return
𝔽
(
length
).
25.2.5.6
SharedArrayBuffer.prototype.slice (
start
,
end
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
O
) is
false
, throw a
TypeError
exception.
Let
len
be
ArrayBufferByteLength
(
O
,
seq-cst
).
Let
relativeStart
be ?
ToIntegerOrInfinity
(
start
).
If
relativeStart
= -∞, let
first
be 0.
Else if
relativeStart
< 0, let
first
be
max
(
len
+
relativeStart
, 0).
Else, let
first
be
min
(
relativeStart
,
len
).
If
end
is
undefined
, let
relativeEnd
be
len
; else let
relativeEnd
be ?
ToIntegerOrInfinity
(
end
).
If
relativeEnd
= -∞, let
final
be 0.
Else if
relativeEnd
< 0, let
final
be
max
(
len
+
relativeEnd
, 0).
Else, let
final
be
min
(
relativeEnd
,
len
).
Let
newLen
be
max
(
final
-
first
, 0).
Let
ctor
be ?
SpeciesConstructor
(
O
,
%SharedArrayBuffer%
).
Let
new
be ?
Construct
(
ctor
, «
𝔽
(
newLen
) »).
Perform ?
RequireInternalSlot
(
new
,
[[ArrayBufferData]]
).
If
IsSharedArrayBuffer
(
new
) is
false
, throw a
TypeError
exception.
If
new
.
[[ArrayBufferData]]
is
O
.
[[ArrayBufferData]]
, throw a
TypeError
exception.
If
ArrayBufferByteLength
(
new
,
seq-cst
) <
newLen
, throw a
TypeError
exception.
Let
fromBuf
be
O
.
[[ArrayBufferData]]
.
Let
toBuf
be
new
.
[[ArrayBufferData]]
.
Perform
CopyDataBlockBytes
(
toBuf
, 0,
fromBuf
,
first
,
newLen
).
Return
new
.
25.2.5.7
SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"SharedArrayBuffer"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
25.2.6
Properties of SharedArrayBuffer Instances
SharedArrayBuffer instances inherit properties from the
SharedArrayBuffer prototype object
. SharedArrayBuffer instances each have an
[[ArrayBufferData]]
internal slot. SharedArrayBuffer instances which are not growable each have an
[[ArrayBufferByteLength]]
internal slot. SharedArrayBuffer instances which are growable each have an
[[ArrayBufferByteLengthData]]
internal slot and an
[[ArrayBufferMaxByteLength]]
internal slot.
Note
SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.
25.2.7
Growable SharedArrayBuffer Guidelines
Note 1
The following are guidelines for ECMAScript programmers working with
growable SharedArrayBuffer
.
We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.
When choosing a value for the
"maxByteLength"
option for
growable SharedArrayBuffer
, we recommend that the smallest possible size for the application be chosen. We recommend that
"maxByteLength"
does not exceed 1073741824, or 1GiB.
Please note that successfully constructing a
growable SharedArrayBuffer
for a particular maximum size does not guarantee that future grows will succeed.
Not all loads of a
growable SharedArrayBuffer
's length are synchronizing
seq-cst
loads. Loads of the length that are for bounds-checking of an
integer-indexed
property access, e.g.
u8[idx]
, are not synchronizing. In general, in the absence of explicit synchronization, one property access being in-bound does not imply a subsequent property access in the same
agent
is also in-bound. In contrast, explicit loads of the length via the
length
and
byteLength
getters on SharedArrayBuffer,
%TypedArray%
.prototype, and DataView.prototype are synchronizing. Loads of the length that are performed by built-in methods to check if a
TypedArray
is entirely out-of-bounds are also synchronizing.
Note 2
The following are guidelines for ECMAScript implementers implementing
growable SharedArrayBuffer
.
We recommend
growable SharedArrayBuffer
be implemented as in-place growth via reserving virtual memory up front.
Because grow operations can happen in parallel with memory accesses on a
growable SharedArrayBuffer
, the constraints of the
memory model
require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a
growable SharedArrayBuffer
cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.
Grown memory must appear zeroed from the moment of its creation, including to any racy accesses in parallel. This can be accomplished via zero-filled-on-demand virtual memory pages, or careful synchronization if manually zeroing memory.
Integer-indexed
property access on
TypedArray
views of growable SharedArrayBuffers is intended to be optimizable similarly to access on
TypedArray
views of non-growable SharedArrayBuffers, because
integer-indexed
property loads on are not synchronizing on the underlying buffer's length (see programmer guidelines above). For example, bounds checks for property accesses may still be hoisted out of loops.
In practice it is difficult to implement
growable SharedArrayBuffer
by copying on
hosts
that do not have virtual memory, such as those running on embedded devices without an MMU. Memory usage behaviour of growable SharedArrayBuffers on such
hosts
may significantly differ from that of
hosts
with virtual memory. Such
hosts
should clearly communicate memory usage expectations to users.
25.3
DataView Objects
25.3.1
Abstract Operations For DataView Objects
25.3.1.1
DataView With Buffer Witness Records
A
DataView With Buffer Witness Record
is a
Record
value used to encapsulate a DataView along with a cached byte length of the viewed buffer. It is used to help ensure there is a single
ReadSharedMemory
event of the byte length data block when the viewed buffer is a
growable SharedArrayBuffer
.
DataView With Buffer Witness Records have the fields listed in
Table 72
.
Table 72:
DataView With Buffer Witness Record
Fields
Field Name
Value
Meaning
[[Object]]
a DataView
The DataView object whose buffer's byte length is loaded.
[[CachedBufferByteLength]]
a non-negative
integer
or
detached
The byte length of the object's
[[ViewedArrayBuffer]]
when the
Record
was created.
25.3.1.2
MakeDataViewWithBufferWitnessRecord (
obj
,
order
)
The abstract operation MakeDataViewWithBufferWitnessRecord takes arguments
obj
(a DataView) and
order
(
seq-cst
or
unordered
) and returns a
DataView With Buffer Witness Record
. It performs the following steps when called:
Let
buffer
be
obj
.
[[ViewedArrayBuffer]]
.
If
IsDetachedBuffer
(
buffer
) is
true
, then
Let
byteLength
be
detached
.
Else,
Let
byteLength
be
ArrayBufferByteLength
(
buffer
,
order
).
Return the
DataView With Buffer Witness Record
{
[[Object]]
:
obj
,
[[CachedBufferByteLength]]
:
byteLength
}.
25.3.1.3
GetViewByteLength (
viewRecord
)
The abstract operation GetViewByteLength takes argument
viewRecord
(a
DataView With Buffer Witness Record
) and returns a non-negative
integer
. It performs the following steps when called:
Assert
:
IsViewOutOfBounds
(
viewRecord
) is
false
.
Let
view
be
viewRecord
.
[[Object]]
.
If
view
.
[[ByteLength]]
is not
auto
, return
view
.
[[ByteLength]]
.
Assert
:
IsFixedLengthArrayBuffer
(
view
.
[[ViewedArrayBuffer]]
) is
false
.
Let
byteOffset
be
view
.
[[ByteOffset]]
.
Let
byteLength
be
viewRecord
.
[[CachedBufferByteLength]]
.
Assert
:
byteLength
is not
detached
.
Return
byteLength
-
byteOffset
.
25.3.1.4
IsViewOutOfBounds (
viewRecord
)
The abstract operation IsViewOutOfBounds takes argument
viewRecord
(a
DataView With Buffer Witness Record
) and returns a Boolean. It performs the following steps when called:
Let
view
be
viewRecord
.
[[Object]]
.
Let
bufferByteLength
be
viewRecord
.
[[CachedBufferByteLength]]
.
If
IsDetachedBuffer
(
view
.
[[ViewedArrayBuffer]]
) is
true
, then
Assert
:
bufferByteLength
is
detached
.
Return
true
.
Assert
:
bufferByteLength
is a non-negative
integer
.
Let
byteOffsetStart
be
view
.
[[ByteOffset]]
.
If
view
.
[[ByteLength]]
is
auto
, then
Let
byteOffsetEnd
be
bufferByteLength
.
Else,
Let
byteOffsetEnd
be
byteOffsetStart
+
view
.
[[ByteLength]]
.
NOTE: A 0-length DataView whose
[[ByteOffset]]
is
bufferByteLength
is not considered out-of-bounds.
If
byteOffsetStart
>
bufferByteLength
or
byteOffsetEnd
>
bufferByteLength
, return
true
.
Return
false
.
25.3.1.5
GetViewValue (
view
,
requestIndex
,
isLittleEndian
,
type
)
The abstract operation GetViewValue takes arguments
view
(an
ECMAScript language value
),
requestIndex
(an
ECMAScript language value
),
isLittleEndian
(an
ECMAScript language value
), and
type
(a
TypedArray element type
) and returns either a
normal completion containing
either a Number or a BigInt, or a
throw completion
. It is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
view
,
[[DataView]]
).
Assert
:
view
has a
[[ViewedArrayBuffer]]
internal slot.
Let
getIndex
be ?
ToIndex
(
requestIndex
).
Set
isLittleEndian
to
ToBoolean
(
isLittleEndian
).
Let
viewOffset
be
view
.
[[ByteOffset]]
.
Let
viewRecord
be
MakeDataViewWithBufferWitnessRecord
(
view
,
unordered
).
NOTE: Bounds checking is not a synchronizing operation when
view
's backing buffer is a
growable SharedArrayBuffer
.
If
IsViewOutOfBounds
(
viewRecord
) is
true
, throw a
TypeError
exception.
Let
viewSize
be
GetViewByteLength
(
viewRecord
).
Let
elementSize
be the Element Size value specified in
Table 70
for Element Type
type
.
If
getIndex
+
elementSize
>
viewSize
, throw a
RangeError
exception.
Let
bufferIndex
be
getIndex
+
viewOffset
.
Return
GetValueFromBuffer
(
view
.
[[ViewedArrayBuffer]]
,
bufferIndex
,
type
,
false
,
unordered
,
isLittleEndian
).
25.3.1.6
SetViewValue (
view
,
requestIndex
,
isLittleEndian
,
type
,
value
)
The abstract operation SetViewValue takes arguments
view
(an
ECMAScript language value
),
requestIndex
(an
ECMAScript language value
),
isLittleEndian
(an
ECMAScript language value
),
type
(a
TypedArray element type
), and
value
(an
ECMAScript language value
) and returns either a
normal completion containing
undefined
or a
throw completion
. It is used by functions on DataView instances to store values into the view's buffer. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
view
,
[[DataView]]
).
Assert
:
view
has a
[[ViewedArrayBuffer]]
internal slot.
Let
getIndex
be ?
ToIndex
(
requestIndex
).
If
IsBigIntElementType
(
type
) is
true
, let
numberValue
be ?
ToBigInt
(
value
).
Otherwise, let
numberValue
be ?
ToNumber
(
value
).
Set
isLittleEndian
to
ToBoolean
(
isLittleEndian
).
Let
viewOffset
be
view
.
[[ByteOffset]]
.
Let
viewRecord
be
MakeDataViewWithBufferWitnessRecord
(
view
,
unordered
).
NOTE: Bounds checking is not a synchronizing operation when
view
's backing buffer is a
growable SharedArrayBuffer
.
If
IsViewOutOfBounds
(
viewRecord
) is
true
, throw a
TypeError
exception.
Let
viewSize
be
GetViewByteLength
(
viewRecord
).
Let
elementSize
be the Element Size value specified in
Table 70
for Element Type
type
.
If
getIndex
+
elementSize
>
viewSize
, throw a
RangeError
exception.
Let
bufferIndex
be
getIndex
+
viewOffset
.
Perform
SetValueInBuffer
(
view
.
[[ViewedArrayBuffer]]
,
bufferIndex
,
type
,
numberValue
,
false
,
unordered
,
isLittleEndian
).
Return
undefined
.
25.3.2
The DataView Constructor
The DataView
constructor
:
is
%DataView%
.
is the initial value of the
"DataView"
property of the
global object
.
creates and initializes a new DataView when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified DataView behaviour must include a
super
call to the DataView
constructor
to create and initialize subclass instances with the internal state necessary to support the
DataView.prototype
built-in methods.
25.3.2.1
DataView (
buffer
[ ,
byteOffset
[ ,
byteLength
] ] )
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Perform ?
RequireInternalSlot
(
buffer
,
[[ArrayBufferData]]
).
Let
offset
be ?
ToIndex
(
byteOffset
).
If
IsDetachedBuffer
(
buffer
) is
true
, throw a
TypeError
exception.
Let
bufferByteLength
be
ArrayBufferByteLength
(
buffer
,
seq-cst
).
If
offset
>
bufferByteLength
, throw a
RangeError
exception.
Let
bufferIsFixedLength
be
IsFixedLengthArrayBuffer
(
buffer
).
If
byteLength
is
undefined
, then
If
bufferIsFixedLength
is
true
, then
Let
viewByteLength
be
bufferByteLength
-
offset
.
Else,
Let
viewByteLength
be
auto
.
Else,
Let
viewByteLength
be ?
ToIndex
(
byteLength
).
If
offset
+
viewByteLength
>
bufferByteLength
, throw a
RangeError
exception.
Let
O
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%DataView.prototype%"
, «
[[DataView]]
,
[[ViewedArrayBuffer]]
,
[[ByteLength]]
,
[[ByteOffset]]
»).
If
IsDetachedBuffer
(
buffer
) is
true
, throw a
TypeError
exception.
Set
bufferByteLength
to
ArrayBufferByteLength
(
buffer
,
seq-cst
).
If
offset
>
bufferByteLength
, throw a
RangeError
exception.
If
byteLength
is not
undefined
, then
If
offset
+
viewByteLength
>
bufferByteLength
, throw a
RangeError
exception.
Set
O
.
[[ViewedArrayBuffer]]
to
buffer
.
Set
O
.
[[ByteLength]]
to
viewByteLength
.
Set
O
.
[[ByteOffset]]
to
offset
.
Return
O
.
25.3.3
Properties of the DataView Constructor
The DataView
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
25.3.3.1
DataView.prototype
The initial value of
DataView.prototype
is the
DataView prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
25.3.4
Properties of the DataView Prototype Object
The
DataView prototype object
:
is
%DataView.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have a
[[DataView]]
,
[[ViewedArrayBuffer]]
,
[[ByteLength]]
, or
[[ByteOffset]]
internal slot.
25.3.4.1
get DataView.prototype.buffer
DataView.prototype.buffer
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[DataView]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
buffer
be
O
.
[[ViewedArrayBuffer]]
.
Return
buffer
.
25.3.4.2
get DataView.prototype.byteLength
DataView.prototype.byteLength
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[DataView]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
viewRecord
be
MakeDataViewWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsViewOutOfBounds
(
viewRecord
) is
true
, throw a
TypeError
exception.
Let
size
be
GetViewByteLength
(
viewRecord
).
Return
𝔽
(
size
).
25.3.4.3
get DataView.prototype.byteOffset
DataView.prototype.byteOffset
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[DataView]]
).
Assert
:
O
has a
[[ViewedArrayBuffer]]
internal slot.
Let
viewRecord
be
MakeDataViewWithBufferWitnessRecord
(
O
,
seq-cst
).
If
IsViewOutOfBounds
(
viewRecord
) is
true
, throw a
TypeError
exception.
Let
offset
be
O
.
[[ByteOffset]]
.
Return
𝔽
(
offset
).
25.3.4.4
DataView.prototype.constructor
The initial value of
DataView.prototype.constructor
is
%DataView%
.
25.3.4.5
DataView.prototype.getBigInt64 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
bigint64
).
25.3.4.6
DataView.prototype.getBigUint64 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
biguint64
).
25.3.4.7
DataView.prototype.getFloat16 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
float16
).
25.3.4.8
DataView.prototype.getFloat32 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
float32
).
25.3.4.9
DataView.prototype.getFloat64 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
float64
).
25.3.4.10
DataView.prototype.getInt8 (
byteOffset
)
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
GetViewValue
(
view
,
byteOffset
,
true
,
int8
).
25.3.4.11
DataView.prototype.getInt16 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
int16
).
25.3.4.12
DataView.prototype.getInt32 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
int32
).
25.3.4.13
DataView.prototype.getUint8 (
byteOffset
)
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
GetViewValue
(
view
,
byteOffset
,
true
,
uint8
).
25.3.4.14
DataView.prototype.getUint16 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
uint16
).
25.3.4.15
DataView.prototype.getUint32 (
byteOffset
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
GetViewValue
(
view
,
byteOffset
,
littleEndian
,
uint32
).
25.3.4.16
DataView.prototype.setBigInt64 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
bigint64
,
value
).
25.3.4.17
DataView.prototype.setBigUint64 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
biguint64
,
value
).
25.3.4.18
DataView.prototype.setFloat16 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
float16
,
value
).
25.3.4.19
DataView.prototype.setFloat32 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
float32
,
value
).
25.3.4.20
DataView.prototype.setFloat64 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
float64
,
value
).
25.3.4.21
DataView.prototype.setInt8 (
byteOffset
,
value
)
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
SetViewValue
(
view
,
byteOffset
,
true
,
int8
,
value
).
25.3.4.22
DataView.prototype.setInt16 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
int16
,
value
).
25.3.4.23
DataView.prototype.setInt32 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
int32
,
value
).
25.3.4.24
DataView.prototype.setUint8 (
byteOffset
,
value
)
This method performs the following steps when called:
Let
view
be the
this
value.
Return ?
SetViewValue
(
view
,
byteOffset
,
true
,
uint8
,
value
).
25.3.4.25
DataView.prototype.setUint16 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
uint16
,
value
).
25.3.4.26
DataView.prototype.setUint32 (
byteOffset
,
value
[ ,
littleEndian
] )
This method performs the following steps when called:
Let
view
be the
this
value.
If
littleEndian
is not present, set
littleEndian
to
false
.
Return ?
SetViewValue
(
view
,
byteOffset
,
littleEndian
,
uint32
,
value
).
25.3.4.27
DataView.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"DataView"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
25.3.5
Properties of DataView Instances
DataView instances are
ordinary objects
that inherit properties from the
DataView prototype object
. DataView instances each have
[[DataView]]
,
[[ViewedArrayBuffer]]
,
[[ByteLength]]
, and
[[ByteOffset]]
internal slots.
Note
The value of the
[[DataView]]
internal slot is not used within this specification. The simple presence of that internal slot is used within the specification to identify objects created using the DataView
constructor
.
25.4
The Atomics Object
The Atomics object:
is
%Atomics%
.
is the initial value of the
"Atomics"
property of the
global object
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
does not have a
[[Construct]]
internal method; it cannot be used as a
constructor
with the
new
operator.
does not have a
[[Call]]
internal method; it cannot be invoked as a function.
The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let
agents
wait for and dispatch primitive events. When used with discipline, the Atomics functions allow multi-
agent
programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs. The rules that govern shared-memory communication are provided by the
memory model
, defined below.
Note
For informative guidelines for programming and implementing shared memory in ECMAScript, please see the notes at the end of the
memory model
section.
25.4.1
Waiter Record
A
Waiter Record
is a
Record
value used to denote a particular call to
Atomics.wait
or
Atomics.waitAsync
.
A Waiter Record has fields listed in
Table 73
.
Table 73:
Waiter Record
Fields
Field Name
Value
Meaning
[[AgentSignifier]]
an
agent signifier
The
agent
that called
Atomics.wait
or
Atomics.waitAsync
.
[[PromiseCapability]]
a
PromiseCapability Record
or
blocking
If denoting a call to
Atomics.waitAsync
, the resulting promise, otherwise
blocking
.
[[TimeoutTime]]
a non-negative
extended mathematical value
The earliest time by which timeout may be triggered; computed using
time values
.
[[Result]]
"ok"
or
"timed-out"
The return value of the call.
25.4.2
WaiterList Records
A
WaiterList Record
is used to explain waiting and notification of
agents
via
Atomics.wait
,
Atomics.waitAsync
, and
Atomics.notify
.
A WaiterList Record has fields listed in
Table 74
.
Table 74:
WaiterList Record
Fields
Field Name
Value
Meaning
[[Waiters]]
a
List
of
Waiter Records
The calls to
Atomics.wait
or
Atomics.waitAsync
that are waiting on the location with which this WaiterList is associated.
[[MostRecentLeaveEvent]]
a
Synchronize event
or
empty
The event of the most recent leaving of its
critical section
, or
empty
if its
critical section
has never been entered.
There can be multiple
Waiter Records
in a WaiterList with the same
agent signifier
.
The
agent cluster
has a store of WaiterList Records; the store is indexed by (
block
,
i
), where
block
is a
Shared Data Block
and
i
a byte offset into the memory of
block
. WaiterList Records are
agent
-independent: a lookup in the store of WaiterList Records by (
block
,
i
) will result in the same WaiterList Record in any
agent
in the
agent cluster
.
Each WaiterList Record has a
critical section
that controls exclusive access to that WaiterList Record during evaluation. Only a single
agent
may enter a WaiterList Record's critical section at one time. Entering and leaving a WaiterList Record's critical section is controlled by the
abstract operations
EnterCriticalSection
and
LeaveCriticalSection
. Operations on a WaiterList Record—adding and removing waiting
agents
, traversing the list of
agents
, suspending and notifying
agents
on the list, setting and retrieving the
Synchronize event
—may only be performed by
agents
that have entered the WaiterList Record's critical section.
25.4.3
Abstract Operations for Atomics
25.4.3.1
ValidateIntegerTypedArray (
typedArray
,
waitable
)
The abstract operation ValidateIntegerTypedArray takes arguments
typedArray
(an
ECMAScript language value
) and
waitable
(a Boolean) and returns either a
normal completion containing
a
TypedArray With Buffer Witness Record
, or a
throw completion
. It performs the following steps when called:
Let
taRecord
be ?
ValidateTypedArray
(
typedArray
,
unordered
).
NOTE: Bounds checking is not a synchronizing operation when
typedArray
's backing buffer is a
growable SharedArrayBuffer
.
If
waitable
is
true
, then
If
typedArray
.
[[TypedArrayName]]
is neither
"Int32Array"
nor
"BigInt64Array"
, throw a
TypeError
exception.
Else,
Let
type
be
TypedArrayElementType
(
typedArray
).
If
IsUnclampedIntegerElementType
(
type
) is
false
and
IsBigIntElementType
(
type
) is
false
, throw a
TypeError
exception.
Return
taRecord
.
25.4.3.2
ValidateAtomicAccess (
taRecord
,
requestIndex
)
The abstract operation ValidateAtomicAccess takes arguments
taRecord
(a
TypedArray With Buffer Witness Record
) and
requestIndex
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integer
or a
throw completion
. It performs the following steps when called:
Let
length
be
TypedArrayLength
(
taRecord
).
Let
accessIndex
be ?
ToIndex
(
requestIndex
).
Assert
:
accessIndex
≥ 0.
If
accessIndex
≥
length
, throw a
RangeError
exception.
Let
typedArray
be
taRecord
.
[[Object]]
.
Let
elementSize
be
TypedArrayElementSize
(
typedArray
).
Let
offset
be
typedArray
.
[[ByteOffset]]
.
Return (
accessIndex
×
elementSize
) +
offset
.
25.4.3.3
ValidateAtomicAccessOnIntegerTypedArray (
typedArray
,
requestIndex
)
The abstract operation ValidateAtomicAccessOnIntegerTypedArray takes arguments
typedArray
(an
ECMAScript language value
) and
requestIndex
(an
ECMAScript language value
) and returns either a
normal completion containing
an
integer
or a
throw completion
. It performs the following steps when called:
Let
taRecord
be ?
ValidateIntegerTypedArray
(
typedArray
,
false
).
Return ?
ValidateAtomicAccess
(
taRecord
,
requestIndex
).
25.4.3.4
RevalidateAtomicAccess (
typedArray
,
byteIndexInBuffer
)
The abstract operation RevalidateAtomicAccess takes arguments
typedArray
(a
TypedArray
) and
byteIndexInBuffer
(an
integer
) and returns either a
normal completion containing
unused
or a
throw completion
. This operation revalidates the index within the backing buffer for atomic operations after all argument coercions are performed in Atomics methods, as argument coercions can have arbitrary side effects, which could cause the buffer to become out of bounds. This operation does not throw when
typedArray
's backing buffer is a SharedArrayBuffer. It performs the following steps when called:
Let
taRecord
be
MakeTypedArrayWithBufferWitnessRecord
(
typedArray
,
unordered
).
NOTE: Bounds checking is not a synchronizing operation when
typedArray
's backing buffer is a
growable SharedArrayBuffer
.
If
IsTypedArrayOutOfBounds
(
taRecord
) is
true
, throw a
TypeError
exception.
Assert
:
byteIndexInBuffer
≥
typedArray
.
[[ByteOffset]]
.
If
byteIndexInBuffer
≥
taRecord
.
[[CachedBufferByteLength]]
, throw a
RangeError
exception.
Return
unused
.
25.4.3.5
GetWaiterList (
block
,
i
)
The abstract operation GetWaiterList takes arguments
block
(a
Shared Data Block
) and
i
(a non-negative
integer
that is evenly divisible by 4) and returns a
WaiterList Record
. It performs the following steps when called:
Assert
:
i
and
i
+ 3 are valid byte offsets within the memory of
block
.
Return the
WaiterList Record
that is referenced by the pair (
block
,
i
).
25.4.3.6
EnterCriticalSection (
WL
)
The abstract operation EnterCriticalSection takes argument
WL
(a
WaiterList Record
) and returns
unused
. It performs the following steps when called:
Assert
: The
surrounding agent
is not in the
critical section
for any
WaiterList Record
.
Wait until no
agent
is in the
critical section
for
WL
, then enter the
critical section
for
WL
(without allowing any other
agent
to enter).
If
WL
.
[[MostRecentLeaveEvent]]
is not
empty
, then
NOTE: A
WL
whose
critical section
has been entered at least once has a
Synchronize event
set by
LeaveCriticalSection
.
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
Let
enterEvent
be a new
Synchronize event
.
Append
enterEvent
to
eventsRecord
.
[[EventList]]
.
Append (
WL
.
[[MostRecentLeaveEvent]]
,
enterEvent
) to
eventsRecord
.
[[AgentSynchronizesWith]]
.
Return
unused
.
EnterCriticalSection has
contention
when an
agent
attempting to enter the
critical section
must wait for another
agent
to leave it. When there is no contention, FIFO order of EnterCriticalSection calls is observable. When there is contention, an implementation may choose an arbitrary order but may not cause an
agent
to wait indefinitely.
25.4.3.7
LeaveCriticalSection (
WL
)
The abstract operation LeaveCriticalSection takes argument
WL
(a
WaiterList Record
) and returns
unused
. It performs the following steps when called:
Assert
: The
surrounding agent
is in the
critical section
for
WL
.
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
Let
leaveEvent
be a new
Synchronize event
.
Append
leaveEvent
to
eventsRecord
.
[[EventList]]
.
Set
WL
.
[[MostRecentLeaveEvent]]
to
leaveEvent
.
Leave the
critical section
for
WL
.
Return
unused
.
25.4.3.8
AddWaiter (
WL
,
waiterRecord
)
The abstract operation AddWaiter takes arguments
WL
(a
WaiterList Record
) and
waiterRecord
(a
Waiter Record
) and returns
unused
. It performs the following steps when called:
Assert
: The
surrounding agent
is in the
critical section
for
WL
.
Assert
: There is no
Waiter Record
in
WL
.
[[Waiters]]
whose
[[PromiseCapability]]
field is
waiterRecord
.
[[PromiseCapability]]
and whose
[[AgentSignifier]]
field is
waiterRecord
.
[[AgentSignifier]]
.
Append
waiterRecord
to
WL
.
[[Waiters]]
.
Return
unused
.
25.4.3.9
RemoveWaiter (
WL
,
waiterRecord
)
The abstract operation RemoveWaiter takes arguments
WL
(a
WaiterList Record
) and
waiterRecord
(a
Waiter Record
) and returns
unused
. It performs the following steps when called:
Assert
: The
surrounding agent
is in the
critical section
for
WL
.
Assert
:
WL
.
[[Waiters]]
contains
waiterRecord
.
Remove
waiterRecord
from
WL
.
[[Waiters]]
.
Return
unused
.
25.4.3.10
RemoveWaiters (
WL
,
c
)
The abstract operation RemoveWaiters takes arguments
WL
(a
WaiterList Record
) and
c
(a non-negative
integer
or +∞) and returns a
List
of
Waiter Records
. It performs the following steps when called:
Assert
: The
surrounding agent
is in the
critical section
for
WL
.
Let
len
be the number of elements in
WL
.
[[Waiters]]
.
Let
n
be
min
(
c
,
len
).
Let
L
be a
List
whose elements are the first
n
elements of
WL
.
[[Waiters]]
.
Remove the first
n
elements of
WL
.
[[Waiters]]
.
Return
L
.
25.4.3.11
SuspendThisAgent (
WL
,
waiterRecord
)
The abstract operation SuspendThisAgent takes arguments
WL
(a
WaiterList Record
) and
waiterRecord
(a
Waiter Record
) and returns
unused
. It performs the following steps when called:
Assert
: The
surrounding agent
is in the
critical section
for
WL
.
Assert
:
WL
.
[[Waiters]]
contains
waiterRecord
.
Let
thisAgent
be
AgentSignifier
().
Assert
:
waiterRecord
.
[[AgentSignifier]]
is
thisAgent
.
Assert
:
waiterRecord
.
[[PromiseCapability]]
is
blocking
.
Assert
:
AgentCanSuspend
() is
true
.
Perform
LeaveCriticalSection
(
WL
) and suspend the
surrounding agent
until the time is
waiterRecord
.
[[TimeoutTime]]
, performing the combined operation in such a way that a notification that arrives after the
critical section
is exited but before the suspension takes effect is not lost. The
surrounding agent
can only wake from suspension due to a timeout or due to another
agent
calling
NotifyWaiter
with arguments
WL
and
thisAgent
(i.e. via a call to
Atomics.notify
).
Perform
EnterCriticalSection
(
WL
).
Return
unused
.
25.4.3.12
NotifyWaiter (
WL
,
waiterRecord
)
The abstract operation NotifyWaiter takes arguments
WL
(a
WaiterList Record
) and
waiterRecord
(a
Waiter Record
) and returns
unused
. It performs the following steps when called:
Assert
: The
surrounding agent
is in the
critical section
for
WL
.
If
waiterRecord
.
[[PromiseCapability]]
is
blocking
, then
Wake the
agent
whose signifier is
waiterRecord
.
[[AgentSignifier]]
from suspension.
NOTE: This causes the
agent
to resume execution in
SuspendThisAgent
.
Else if
AgentSignifier
() is
waiterRecord
.
[[AgentSignifier]]
, then
Let
promiseCapability
be
waiterRecord
.
[[PromiseCapability]]
.
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
waiterRecord
.
[[Result]]
»).
Else,
Perform
EnqueueResolveInAgentJob
(
waiterRecord
.
[[AgentSignifier]]
,
waiterRecord
.
[[PromiseCapability]]
,
waiterRecord
.
[[Result]]
).
Return
unused
.
Note
An
agent
must not access another
agent
's promise capability in any capacity beyond passing it to the
host
.
25.4.3.13
EnqueueResolveInAgentJob (
agentSignifier
,
promiseCapability
,
resolution
)
The abstract operation EnqueueResolveInAgentJob takes arguments
agentSignifier
(an
agent signifier
),
promiseCapability
(a
PromiseCapability Record
), and
resolution
(
"ok"
or
"timed-out"
) and returns
unused
. It performs the following steps when called:
Let
resolveJob
be a new
Job
Abstract Closure
with no parameters that captures
agentSignifier
,
promiseCapability
, and
resolution
and performs the following steps when called:
Assert
:
AgentSignifier
() is
agentSignifier
.
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
resolution
»).
Return
unused
.
Let
realmInTargetAgent
be !
GetFunctionRealm
(
promiseCapability
.
[[Resolve]]
).
Assert
:
agentSignifier
is
realmInTargetAgent
.
[[AgentSignifier]]
.
Perform
HostEnqueueGenericJob
(
resolveJob
,
realmInTargetAgent
).
Return
unused
.
25.4.3.14
DoWait (
mode
,
typedArray
,
index
,
value
,
timeout
)
The abstract operation DoWait takes arguments
mode
(
sync
or
async
),
typedArray
(an
ECMAScript language value
),
index
(an
ECMAScript language value
),
value
(an
ECMAScript language value
), and
timeout
(an
ECMAScript language value
) and returns either a
normal completion containing
either an Object,
"not-equal"
,
"timed-out"
, or
"ok"
, or a
throw completion
. It performs the following steps when called:
Let
taRecord
be ?
ValidateIntegerTypedArray
(
typedArray
,
true
).
Let
buffer
be
taRecord
.
[[Object]]
.
[[ViewedArrayBuffer]]
.
If
IsSharedArrayBuffer
(
buffer
) is
false
, throw a
TypeError
exception.
Let
byteIndexInBuffer
be ?
ValidateAtomicAccess
(
taRecord
,
index
).
Let
arrayTypeName
be
typedArray
.
[[TypedArrayName]]
.
If
arrayTypeName
is
"BigInt64Array"
, let
v
be ?
ToBigInt64
(
value
).
Else, let
v
be ?
ToInt32
(
value
).
Let
q
be ?
ToNumber
(
timeout
).
If
q
is either
NaN
or
+∞
𝔽
, let
t
be +∞; else if
q
is
-∞
𝔽
, let
t
be 0; else let
t
be
max
(
ℝ
(
q
), 0).
If
mode
is
sync
and
AgentCanSuspend
() is
false
, throw a
TypeError
exception.
Let
block
be
buffer
.
[[ArrayBufferData]]
.
Let
WL
be
GetWaiterList
(
block
,
byteIndexInBuffer
).
If
mode
is
sync
, then
Let
promiseCapability
be
blocking
.
Let
resultObject
be
undefined
.
Else,
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
resultObject
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform
EnterCriticalSection
(
WL
).
Let
elementType
be
TypedArrayElementType
(
typedArray
).
Let
w
be
GetValueFromBuffer
(
buffer
,
byteIndexInBuffer
,
elementType
,
true
,
seq-cst
).
If
v
≠
w
, then
Perform
LeaveCriticalSection
(
WL
).
If
mode
is
sync
, return
"not-equal"
.
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"async"
,
false
).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"value"
,
"not-equal"
).
Return
resultObject
.
If
t
= 0 and
mode
is
async
, then
NOTE: There is no special handling of synchronous immediate timeouts. Asynchronous immediate timeouts have special handling in order to fail fast and avoid unnecessary Promise jobs.
Perform
LeaveCriticalSection
(
WL
).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"async"
,
false
).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"value"
,
"timed-out"
).
Return
resultObject
.
Let
thisAgent
be
AgentSignifier
().
Let
now
be the
time value
(UTC) identifying the current time.
Let
additionalTimeout
be an
implementation-defined
non-negative
mathematical value
.
Let
timeoutTime
be
ℝ
(
now
) +
t
+
additionalTimeout
.
NOTE: When
t
is +∞,
timeoutTime
is also +∞.
Let
waiterRecord
be a new
Waiter Record
{
[[AgentSignifier]]
:
thisAgent
,
[[PromiseCapability]]
:
promiseCapability
,
[[TimeoutTime]]
:
timeoutTime
,
[[Result]]
:
"ok"
}.
Perform
AddWaiter
(
WL
,
waiterRecord
).
If
mode
is
sync
, then
Perform
SuspendThisAgent
(
WL
,
waiterRecord
).
Else if
timeoutTime
is
finite
, then
Perform
EnqueueAtomicsWaitAsyncTimeoutJob
(
WL
,
waiterRecord
).
Perform
LeaveCriticalSection
(
WL
).
If
mode
is
sync
, return
waiterRecord
.
[[Result]]
.
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"async"
,
true
).
Perform !
CreateDataPropertyOrThrow
(
resultObject
,
"value"
,
promiseCapability
.
[[Promise]]
).
Return
resultObject
.
Note
additionalTimeout
allows implementations to pad timeouts as necessary, such as for reducing power consumption or coarsening timer resolution to mitigate timing attacks. This value may differ from call to call of DoWait.
25.4.3.15
EnqueueAtomicsWaitAsyncTimeoutJob (
WL
,
waiterRecord
)
The abstract operation EnqueueAtomicsWaitAsyncTimeoutJob takes arguments
WL
(a
WaiterList Record
) and
waiterRecord
(a
Waiter Record
) and returns
unused
. It performs the following steps when called:
Let
timeoutJob
be a new
Job
Abstract Closure
with no parameters that captures
WL
and
waiterRecord
and performs the following steps when called:
Perform
EnterCriticalSection
(
WL
).
If
WL
.
[[Waiters]]
contains
waiterRecord
, then
Let
timeOfJobExecution
be the
time value
(UTC) identifying the current time.
Assert
:
ℝ
(
timeOfJobExecution
) ≥
waiterRecord
.
[[TimeoutTime]]
(ignoring potential non-monotonicity of
time values
).
Set
waiterRecord
.
[[Result]]
to
"timed-out"
.
Perform
RemoveWaiter
(
WL
,
waiterRecord
).
Perform
NotifyWaiter
(
WL
,
waiterRecord
).
Perform
LeaveCriticalSection
(
WL
).
Return
unused
.
Let
now
be the
time value
(UTC) identifying the current time.
Let
currentRealm
be
the current Realm Record
.
Perform
HostEnqueueTimeoutJob
(
timeoutJob
,
currentRealm
,
𝔽
(
waiterRecord
.
[[TimeoutTime]]
) -
now
).
Return
unused
.
25.4.3.16
AtomicCompareExchangeInSharedBlock (
block
,
byteIndexInBuffer
,
elementSize
,
expectedBytes
,
replacementBytes
)
The abstract operation AtomicCompareExchangeInSharedBlock takes arguments
block
(a
Shared Data Block
),
byteIndexInBuffer
(an
integer
),
elementSize
(a non-negative
integer
),
expectedBytes
(a
List
of
byte values
), and
replacementBytes
(a
List
of
byte values
) and returns a
List
of
byte values
. It performs the following steps when called:
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
execution
be
AR
.
[[CandidateExecution]]
.
Let
eventsRecord
be the
Agent Events Record
of
execution
.
[[EventsRecords]]
whose
[[AgentSignifier]]
is
AgentSignifier
().
Let
rawBytesRead
be a
List
of length
elementSize
whose elements are nondeterministically chosen
byte values
.
NOTE: In implementations,
rawBytesRead
is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the
memory model
to describe observable behaviour of hardware with weak consistency.
NOTE: The comparison of the expected value and the read value is performed outside of the
read-modify-write modification function
to avoid needlessly strong synchronization when the expected value is not equal to the read value.
If
ByteListEqual
(
rawBytesRead
,
expectedBytes
) is
true
, then
Let
second
be a new
read-modify-write modification function
with parameters (
oldBytes
,
newBytes
) that captures nothing and performs the following steps atomically when called:
Return
newBytes
.
Let
event
be
ReadModifyWriteSharedMemory
{
[[Order]]
:
seq-cst
,
[[NoTear]]
:
true
,
[[Block]]
:
block
,
[[ByteIndex]]
:
byteIndexInBuffer
,
[[ElementSize]]
:
elementSize
,
[[Payload]]
:
replacementBytes
,
[[ModifyOp]]
:
second
}.
Else,
Let
event
be
ReadSharedMemory
{
[[Order]]
:
seq-cst
,
[[NoTear]]
:
true
,
[[Block]]
:
block
,
[[ByteIndex]]
:
byteIndexInBuffer
,
[[ElementSize]]
:
elementSize
}.
Append
event
to
eventsRecord
.
[[EventList]]
.
Append
Chosen Value Record
{
[[Event]]
:
event
,
[[ChosenValue]]
:
rawBytesRead
} to
execution
.
[[ChosenValues]]
.
Return
rawBytesRead
.
25.4.3.17
AtomicReadModifyWrite (
typedArray
,
index
,
value
,
op
)
The abstract operation AtomicReadModifyWrite takes arguments
typedArray
(an
ECMAScript language value
),
index
(an
ECMAScript language value
),
value
(an
ECMAScript language value
), and
op
(a
read-modify-write modification function
) and returns either a
normal completion containing
either a Number or a BigInt, or a
throw completion
.
op
takes two
List
of
byte values
arguments and returns a
List
of
byte values
. This operation atomically loads a value, combines it with another value, and stores the combination. It returns the loaded value. It performs the following steps when called:
Let
byteIndexInBuffer
be ?
ValidateAtomicAccessOnIntegerTypedArray
(
typedArray
,
index
).
If
typedArray
.
[[ContentType]]
is
bigint
, let
v
be ?
ToBigInt
(
value
).
Otherwise, let
v
be
𝔽
(?
ToIntegerOrInfinity
(
value
)).
Perform ?
RevalidateAtomicAccess
(
typedArray
,
byteIndexInBuffer
).
Let
buffer
be
typedArray
.
[[ViewedArrayBuffer]]
.
Let
elementType
be
TypedArrayElementType
(
typedArray
).
Return
GetModifySetValueInBuffer
(
buffer
,
byteIndexInBuffer
,
elementType
,
v
,
op
).
25.4.3.18
ByteListBitwiseOp (
op
,
xBytes
,
yBytes
)
The abstract operation ByteListBitwiseOp takes arguments
op
(
&
,
^
, or
|
),
xBytes
(a
List
of
byte values
), and
yBytes
(a
List
of
byte values
) and returns a
List
of
byte values
. The operation atomically performs a bitwise operation on all
byte values
of the arguments and returns a
List
of
byte values
. It performs the following steps when called:
Assert
:
xBytes
and
yBytes
have the same number of elements.
Let
result
be a new empty
List
.
Let
i
be 0.
For each element
xByte
of
xBytes
, do
Let
yByte
be
yBytes
[
i
].
If
op
is
&
, then
Let
resultByte
be the result of applying the bitwise AND operation to
xByte
and
yByte
.
Else if
op
is
^
, then
Let
resultByte
be the result of applying the bitwise exclusive OR (XOR) operation to
xByte
and
yByte
.
Else,
Assert
:
op
is
|
.
Let
resultByte
be the result of applying the bitwise inclusive OR operation to
xByte
and
yByte
.
Set
i
to
i
+ 1.
Append
resultByte
to
result
.
Return
result
.
25.4.3.19
ByteListEqual (
xBytes
,
yBytes
)
The abstract operation ByteListEqual takes arguments
xBytes
(a
List
of
byte values
) and
yBytes
(a
List
of
byte values
) and returns a Boolean. It performs the following steps when called:
If
xBytes
and
yBytes
do not have the same number of elements, return
false
.
Let
i
be 0.
For each element
xByte
of
xBytes
, do
Let
yByte
be
yBytes
[
i
].
If
xByte
≠
yByte
, return
false
.
Set
i
to
i
+ 1.
Return
true
.
25.4.4
Atomics.add (
typedArray
,
index
,
value
)
This function performs the following steps when called:
Let
add
be a new
read-modify-write modification function
with parameters (
xBytes
,
yBytes
) that captures
typedArray
and performs the following steps atomically when called:
Let
type
be
TypedArrayElementType
(
typedArray
).
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
isLittleEndian
be
AR
.
[[LittleEndian]]
.
Let
x
be
RawBytesToNumeric
(
type
,
xBytes
,
isLittleEndian
).
Let
y
be
RawBytesToNumeric
(
type
,
yBytes
,
isLittleEndian
).
If
x
is a Number
, then
Let
sum
be
Number::add
(
x
,
y
).
Else,
Assert
:
x
is a BigInt
.
Let
sum
be
BigInt::add
(
x
,
y
).
Let
sumBytes
be
NumericToRawBytes
(
type
,
sum
,
isLittleEndian
).
Assert
:
sumBytes
,
xBytes
, and
yBytes
have the same number of elements.
Return
sumBytes
.
Return ?
AtomicReadModifyWrite
(
typedArray
,
index
,
value
,
add
).
25.4.5
Atomics.and (
typedArray
,
index
,
value
)
This function performs the following steps when called:
Let
and
be a new
read-modify-write modification function
with parameters (
xBytes
,
yBytes
) that captures nothing and performs the following steps atomically when called:
Return
ByteListBitwiseOp
(
&
,
xBytes
,
yBytes
).
Return ?
AtomicReadModifyWrite
(
typedArray
,
index
,
value
,
and
).
25.4.6
Atomics.compareExchange (
typedArray
,
index
,
expectedValue
,
replacementValue
)
This function performs the following steps when called:
Let
byteIndexInBuffer
be ?
ValidateAtomicAccessOnIntegerTypedArray
(
typedArray
,
index
).
Let
buffer
be
typedArray
.
[[ViewedArrayBuffer]]
.
Let
block
be
buffer
.
[[ArrayBufferData]]
.
If
typedArray
.
[[ContentType]]
is
bigint
, then
Let
expected
be ?
ToBigInt
(
expectedValue
).
Let
replacement
be ?
ToBigInt
(
replacementValue
).
Else,
Let
expected
be
𝔽
(?
ToIntegerOrInfinity
(
expectedValue
)).
Let
replacement
be
𝔽
(?
ToIntegerOrInfinity
(
replacementValue
)).
Perform ?
RevalidateAtomicAccess
(
typedArray
,
byteIndexInBuffer
).
Let
elementType
be
TypedArrayElementType
(
typedArray
).
Let
elementSize
be
TypedArrayElementSize
(
typedArray
).
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
isLittleEndian
be
AR
.
[[LittleEndian]]
.
Let
expectedBytes
be
NumericToRawBytes
(
elementType
,
expected
,
isLittleEndian
).
Let
replacementBytes
be
NumericToRawBytes
(
elementType
,
replacement
,
isLittleEndian
).
If
IsSharedArrayBuffer
(
buffer
) is
true
, then
Let
rawBytesRead
be
AtomicCompareExchangeInSharedBlock
(
block
,
byteIndexInBuffer
,
elementSize
,
expectedBytes
,
replacementBytes
).
Else,
Let
rawBytesRead
be a
List
of length
elementSize
whose elements are the sequence of
elementSize
bytes starting with
block
[
byteIndexInBuffer
].
If
ByteListEqual
(
rawBytesRead
,
expectedBytes
) is
true
, then
Store the individual bytes of
replacementBytes
into
block
, starting at
block
[
byteIndexInBuffer
].
Return
RawBytesToNumeric
(
elementType
,
rawBytesRead
,
isLittleEndian
).
25.4.7
Atomics.exchange (
typedArray
,
index
,
value
)
This function performs the following steps when called:
Let
second
be a new
read-modify-write modification function
with parameters (
oldBytes
,
newBytes
) that captures nothing and performs the following steps atomically when called:
Return
newBytes
.
Return ?
AtomicReadModifyWrite
(
typedArray
,
index
,
value
,
second
).
25.4.8
Atomics.isLockFree (
size
)
This function performs the following steps when called:
Let
n
be ?
ToIntegerOrInfinity
(
size
).
Let
AR
be the
Agent Record
of the
surrounding agent
.
If
n
= 1, return
AR
.
[[IsLockFree1]]
.
If
n
= 2, return
AR
.
[[IsLockFree2]]
.
If
n
= 4, return
true
.
If
n
= 8, return
AR
.
[[IsLockFree8]]
.
Return
false
.
Note
This function is an optimization primitive. The intuition is that if the atomic step of an atomic primitive (
compareExchange
,
load
,
store
,
add
,
sub
,
and
,
or
,
xor
, or
exchange
) on a datum of size
n
bytes will be performed without the
surrounding agent
acquiring a lock outside the
n
bytes comprising the datum, then
Atomics.isLockFree
(
n
) will return
true
. High-performance algorithms will use this function to determine whether to use locks or atomic operations in
critical sections
. If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.
Atomics.isLockFree
(4) always returns
true
as that can be supported on all known relevant hardware. Being able to assume this will generally simplify programs.
Regardless of the value returned by this function, all atomic operations are guaranteed to be atomic. For example, they will never have a visible operation take place in the middle of the operation (e.g., "tearing").
25.4.9
Atomics.load (
typedArray
,
index
)
This function performs the following steps when called:
Let
byteIndexInBuffer
be ?
ValidateAtomicAccessOnIntegerTypedArray
(
typedArray
,
index
).
Perform ?
RevalidateAtomicAccess
(
typedArray
,
byteIndexInBuffer
).
Let
buffer
be
typedArray
.
[[ViewedArrayBuffer]]
.
Let
elementType
be
TypedArrayElementType
(
typedArray
).
Return
GetValueFromBuffer
(
buffer
,
byteIndexInBuffer
,
elementType
,
true
,
seq-cst
).
25.4.10
Atomics.or (
typedArray
,
index
,
value
)
This function performs the following steps when called:
Let
or
be a new
read-modify-write modification function
with parameters (
xBytes
,
yBytes
) that captures nothing and performs the following steps atomically when called:
Return
ByteListBitwiseOp
(
|
,
xBytes
,
yBytes
).
Return ?
AtomicReadModifyWrite
(
typedArray
,
index
,
value
,
or
).
25.4.11
Atomics.store (
typedArray
,
index
,
value
)
This function performs the following steps when called:
Let
byteIndexInBuffer
be ?
ValidateAtomicAccessOnIntegerTypedArray
(
typedArray
,
index
).
If
typedArray
.
[[ContentType]]
is
bigint
, let
v
be ?
ToBigInt
(
value
).
Otherwise, let
v
be
𝔽
(?
ToIntegerOrInfinity
(
value
)).
Perform ?
RevalidateAtomicAccess
(
typedArray
,
byteIndexInBuffer
).
Let
buffer
be
typedArray
.
[[ViewedArrayBuffer]]
.
Let
elementType
be
TypedArrayElementType
(
typedArray
).
Perform
SetValueInBuffer
(
buffer
,
byteIndexInBuffer
,
elementType
,
v
,
true
,
seq-cst
).
Return
v
.
25.4.12
Atomics.sub (
typedArray
,
index
,
value
)
This function performs the following steps when called:
Let
subtract
be a new
read-modify-write modification function
with parameters (
xBytes
,
yBytes
) that captures
typedArray
and performs the following steps atomically when called:
Let
type
be
TypedArrayElementType
(
typedArray
).
Let
AR
be the
Agent Record
of the
surrounding agent
.
Let
isLittleEndian
be
AR
.
[[LittleEndian]]
.
Let
x
be
RawBytesToNumeric
(
type
,
xBytes
,
isLittleEndian
).
Let
y
be
RawBytesToNumeric
(
type
,
yBytes
,
isLittleEndian
).
If
x
is a Number
, then
Let
difference
be
Number::subtract
(
x
,
y
).
Else,
Assert
:
x
is a BigInt
.
Let
difference
be
BigInt::subtract
(
x
,
y
).
Let
differenceBytes
be
NumericToRawBytes
(
type
,
difference
,
isLittleEndian
).
Assert
:
differenceBytes
,
xBytes
, and
yBytes
have the same number of elements.
Return
differenceBytes
.
Return ?
AtomicReadModifyWrite
(
typedArray
,
index
,
value
,
subtract
).
25.4.13
Atomics.wait (
typedArray
,
index
,
value
,
timeout
)
This function puts the
surrounding agent
in a wait queue and suspends it until notified or until the wait times out, returning a String differentiating those cases.
It performs the following steps when called:
Return ?
DoWait
(
sync
,
typedArray
,
index
,
value
,
timeout
).
25.4.14
Atomics.waitAsync (
typedArray
,
index
,
value
,
timeout
)
This function returns a Promise that is resolved when the calling
agent
is notified or the timeout is reached.
It performs the following steps when called:
Return ?
DoWait
(
async
,
typedArray
,
index
,
value
,
timeout
).
25.4.15
Atomics.notify (
typedArray
,
index
,
count
)
This function notifies some
agents
that are sleeping in the wait queue.
It performs the following steps when called:
Let
taRecord
be ?
ValidateIntegerTypedArray
(
typedArray
,
true
).
Let
byteIndexInBuffer
be ?
ValidateAtomicAccess
(
taRecord
,
index
).
If
count
is
undefined
, then
Let
c
be +∞.
Else,
Let
intCount
be ?
ToIntegerOrInfinity
(
count
).
Let
c
be
max
(
intCount
, 0).
Let
buffer
be
typedArray
.
[[ViewedArrayBuffer]]
.
Let
block
be
buffer
.
[[ArrayBufferData]]
.
If
IsSharedArrayBuffer
(
buffer
) is
false
, return
+0
𝔽
.
Let
WL
be
GetWaiterList
(
block
,
byteIndexInBuffer
).
Perform
EnterCriticalSection
(
WL
).
Let
S
be
RemoveWaiters
(
WL
,
c
).
For each element
W
of
S
, do
Perform
NotifyWaiter
(
WL
,
W
).
Perform
LeaveCriticalSection
(
WL
).
Let
n
be the number of elements in
S
.
Return
𝔽
(
n
).
25.4.16
Atomics.xor (
typedArray
,
index
,
value
)
This function performs the following steps when called:
Let
xor
be a new
read-modify-write modification function
with parameters (
xBytes
,
yBytes
) that captures nothing and performs the following steps atomically when called:
Return
ByteListBitwiseOp
(
^
,
xBytes
,
yBytes
).
Return ?
AtomicReadModifyWrite
(
typedArray
,
index
,
value
,
xor
).
25.4.17
Atomics [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Atomics"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
25.5
The JSON Object
The JSON object:
is
%JSON%
.
is the initial value of the
"JSON"
property of the
global object
.
is an
ordinary object
.
contains two functions,
parse
and
stringify
, that are used to parse and construct JSON texts.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
does not have a
[[Construct]]
internal method; it cannot be used as a
constructor
with the
new
operator.
does not have a
[[Call]]
internal method; it cannot be invoked as a function.
The JSON Data Interchange Format is defined in ECMA-404. The JSON interchange format used in this specification is exactly that described by ECMA-404. Conforming implementations of
JSON.parse
and
JSON.stringify
must support the exact interchange format described in the ECMA-404 specification without any deletions or extensions to the format.
25.5.1
JSON.parse (
text
[ ,
reviver
] )
This function parses a JSON text (a JSON-formatted String) and produces an
ECMAScript language value
. The JSON format represents literals, arrays, and objects with a syntax similar to the syntax for ECMAScript literals, Array Initializers, and Object Initializers. After parsing, JSON objects are realized as ECMAScript objects. JSON arrays are realized as ECMAScript Array instances. JSON strings, numbers, booleans, and null are realized as ECMAScript Strings, Numbers, Booleans, and
null
.
The optional
reviver
parameter is a function that takes two parameters,
key
and
value
. It can filter and transform the results. It is called with each of the
key
/
value
pairs produced by the parse, and its return value is used instead of the original value. If it returns what it received, the structure is not modified. If it returns
undefined
then the property is deleted from the result.
Let
jsonString
be ?
ToString
(
text
).
Let
unfiltered
be ?
ParseJSON
(
jsonString
).
If
IsCallable
(
reviver
) is
true
, then
Let
root
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Let
rootName
be the empty String.
Perform !
CreateDataPropertyOrThrow
(
root
,
rootName
,
unfiltered
).
Return ?
InternalizeJSONProperty
(
root
,
rootName
,
reviver
).
Else,
Return
unfiltered
.
The
"length"
property of this function is
2
𝔽
.
25.5.1.1
ParseJSON (
text
)
The abstract operation ParseJSON takes argument
text
(a String) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
If
StringToCodePoints
(
text
) is not a valid JSON text as specified in ECMA-404, throw a
SyntaxError
exception.
Let
scriptString
be the
string-concatenation
of
"("
,
text
, and
");"
.
Let
script
be
ParseText
(
scriptString
,
Script
).
NOTE: The
early error
rules defined in
13.2.5.1
have special handling for the above invocation of
ParseText
.
Assert
:
script
is a
Parse Node
.
Let
result
be !
Evaluation
of
script
.
NOTE: The
PropertyDefinitionEvaluation
semantics defined in
13.2.5.5
have special handling for the above evaluation.
Assert
:
result
is either a String, a Number, a Boolean, an Object that is defined by either an
ArrayLiteral
or an
ObjectLiteral
, or
null
.
Return
result
.
It is not permitted for a conforming implementation of
JSON.parse
to extend the JSON grammars. If an implementation wishes to support a modified or extended JSON interchange format it must do so by defining a different parse function.
Note 1
Valid JSON text is a subset of the ECMAScript
PrimaryExpression
syntax. Step
1
verifies that
jsonString
conforms to that subset, and step
8
asserts that evaluation returns a value of an appropriate type.
However, because
13.2.5.5
behaves differently during ParseJSON, the same source text can produce different results when evaluated as a
PrimaryExpression
rather than as JSON. Furthermore, the Early Error for duplicate
"__proto__"
properties in object literals, which likewise does not apply during ParseJSON, means that not all texts accepted by ParseJSON are valid as a
PrimaryExpression
, despite matching the grammar.
Note 2
In the case where there are duplicate name Strings within an object, lexically preceding values for the same key shall be overwritten.
25.5.1.2
InternalizeJSONProperty (
holder
,
name
,
reviver
)
The abstract operation InternalizeJSONProperty takes arguments
holder
(an Object),
name
(a String), and
reviver
(a
function object
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
.
Note
This algorithm intentionally does not throw an exception if either
[[Delete]]
or
CreateDataProperty
return
false
.
It performs the following steps when called:
Let
val
be ?
Get
(
holder
,
name
).
If
val
is an Object
, then
Let
isArray
be ?
IsArray
(
val
).
If
isArray
is
true
, then
Let
len
be ?
LengthOfArrayLike
(
val
).
Let
I
be 0.
Repeat, while
I
<
len
,
Let
prop
be !
ToString
(
𝔽
(
I
)).
Let
newElement
be ?
InternalizeJSONProperty
(
val
,
prop
,
reviver
).
If
newElement
is
undefined
, then
Perform ?
val
.
[[Delete]]
(
prop
)
.
Else,
Perform ?
CreateDataProperty
(
val
,
prop
,
newElement
).
Set
I
to
I
+ 1.
Else,
Let
keys
be ?
EnumerableOwnProperties
(
val
,
key
).
For each String
P
of
keys
, do
Let
newElement
be ?
InternalizeJSONProperty
(
val
,
P
,
reviver
).
If
newElement
is
undefined
, then
Perform ?
val
.
[[Delete]]
(
P
)
.
Else,
Perform ?
CreateDataProperty
(
val
,
P
,
newElement
).
Return ?
Call
(
reviver
,
holder
, «
name
,
val
»).
25.5.2
JSON.stringify (
value
[ ,
replacer
[ ,
space
] ] )
This function returns a String in UTF-16 encoded JSON format representing an
ECMAScript language value
, or
undefined
. It can take three parameters. The
value
parameter is an
ECMAScript language value
, which is usually an object or array, although it can also be a String, Boolean, Number or
null
. The optional
replacer
parameter is either a function that alters the way objects and arrays are stringified, or an array of Strings and Numbers that acts as an inclusion list for selecting the object properties that will be stringified. The optional
space
parameter
is a String
or Number that allows the result to have white space injected into it to improve human readability.
It performs the following steps when called:
Let
stack
be a new empty
List
.
Let
indent
be the empty String.
Let
PropertyList
be
undefined
.
Let
ReplacerFunction
be
undefined
.
If
replacer
is an Object
, then
If
IsCallable
(
replacer
) is
true
, then
Set
ReplacerFunction
to
replacer
.
Else,
Let
isArray
be ?
IsArray
(
replacer
).
If
isArray
is
true
, then
Set
PropertyList
to a new empty
List
.
Let
len
be ?
LengthOfArrayLike
(
replacer
).
Let
k
be 0.
Repeat, while
k
<
len
,
Let
prop
be !
ToString
(
𝔽
(
k
)).
Let
v
be ?
Get
(
replacer
,
prop
).
Let
item
be
undefined
.
If
v
is a String
, then
Set
item
to
v
.
Else if
v
is a Number
, then
Set
item
to !
ToString
(
v
).
Else if
v
is an Object
, then
If
v
has a
[[StringData]]
or
[[NumberData]]
internal slot, set
item
to ?
ToString
(
v
).
If
item
is not
undefined
and
PropertyList
does not contain
item
, then
Append
item
to
PropertyList
.
Set
k
to
k
+ 1.
If
space
is an Object
, then
If
space
has a
[[NumberData]]
internal slot, then
Set
space
to ?
ToNumber
(
space
).
Else if
space
has a
[[StringData]]
internal slot, then
Set
space
to ?
ToString
(
space
).
If
space
is a Number
, then
Let
spaceMV
be !
ToIntegerOrInfinity
(
space
).
Set
spaceMV
to
min
(10,
spaceMV
).
If
spaceMV
< 1, let
gap
be the empty String; otherwise let
gap
be the String value containing
spaceMV
occurrences of the code unit 0x0020 (SPACE).
Else if
space
is a String
, then
If the length of
space
≤ 10, let
gap
be
space
; otherwise let
gap
be the
substring
of
space
from 0 to 10.
Else,
Let
gap
be the empty String.
Let
wrapper
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
wrapper
, the empty String,
value
).
Let
state
be the
JSON Serialization Record
{
[[ReplacerFunction]]
:
ReplacerFunction
,
[[Stack]]
:
stack
,
[[Indent]]
:
indent
,
[[Gap]]
:
gap
,
[[PropertyList]]
:
PropertyList
}.
Return ?
SerializeJSONProperty
(
state
, the empty String,
wrapper
).
The
"length"
property of this function is
3
𝔽
.
Note 1
JSON structures are allowed to be nested to any depth, but they must be acyclic. If
value
is or contains a cyclic structure, then this function must throw a
TypeError
exception. This is an example of a value that cannot be stringified:
a = []; a[
0
] = a; my_text =
JSON
.
stringify
(a);
// This must throw a TypeError.
Note 2
Symbolic primitive values are rendered as follows:
The
null
value is rendered in JSON text as the String value
"null"
.
The
undefined
value is not rendered.
The
true
value is rendered in JSON text as the String value
"true"
.
The
false
value is rendered in JSON text as the String value
"false"
.
Note 3
String values are wrapped in QUOTATION MARK (
"
) code units. The code units
"
and
\
are escaped with
\
prefixes. Control characters code units are replaced with escape sequences
\u
HHHH, or with the shorter forms,
\b
(BACKSPACE),
\f
(FORM FEED),
\n
(LINE FEED),
\r
(CARRIAGE RETURN),
\t
(CHARACTER TABULATION).
Note 4
Finite
numbers are stringified as if by calling
ToString
(
number
).
NaN
and
Infinity
regardless of sign are represented as the String value
"null"
.
Note 5
Values that do not have a JSON representation (such as
undefined
and functions) do not produce a String. Instead they produce the
undefined
value. In arrays these values are represented as the String value
"null"
. In objects an unrepresentable value causes the property to be excluded from stringification.
Note 6
An object is rendered as U+007B (LEFT CURLY BRACKET) followed by zero or more properties, separated with a U+002C (COMMA), closed with a U+007D (RIGHT CURLY BRACKET). A property is a quoted String representing the
property name
, a U+003A (COLON), and then the stringified property value. An array is rendered as an opening U+005B (LEFT SQUARE BRACKET) followed by zero or more values, separated with a U+002C (COMMA), closed with a U+005D (RIGHT SQUARE BRACKET).
25.5.2.1
JSON Serialization Record
A
JSON Serialization Record
is a
Record
value used to enable serialization to the JSON format.
JSON Serialization Records have the fields listed in
Table 75
.
Table 75:
JSON Serialization Record
Fields
Field Name
Value
Meaning
[[ReplacerFunction]]
a
function object
or
undefined
A function that can supply replacement values for object properties (from JSON.stringify's
replacer
parameter).
[[PropertyList]]
either a
List
of Strings or
undefined
The names of properties to include when serializing a non-array object (from JSON.stringify's
replacer
parameter).
[[Gap]]
a String
The unit of indentation (from JSON.stringify's
space
parameter).
[[Stack]]
a
List
of Objects
The set of nested objects that are in the process of being serialized. Used to detect cyclic structures.
[[Indent]]
a String
The current indentation.
25.5.2.2
SerializeJSONProperty (
state
,
key
,
holder
)
The abstract operation SerializeJSONProperty takes arguments
state
(a
JSON Serialization Record
),
key
(a String), and
holder
(an Object) and returns either a
normal completion containing
either a String or
undefined
, or a
throw completion
. It performs the following steps when called:
Let
value
be ?
Get
(
holder
,
key
).
If
value
is an Object
or
value
is a BigInt
, then
Let
toJSON
be ?
GetV
(
value
,
"toJSON"
).
If
IsCallable
(
toJSON
) is
true
, then
Set
value
to ?
Call
(
toJSON
,
value
, «
key
»).
If
state
.
[[ReplacerFunction]]
is not
undefined
, then
Set
value
to ?
Call
(
state
.
[[ReplacerFunction]]
,
holder
, «
key
,
value
»).
If
value
is an Object
, then
If
value
has a
[[NumberData]]
internal slot, then
Set
value
to ?
ToNumber
(
value
).
Else if
value
has a
[[StringData]]
internal slot, then
Set
value
to ?
ToString
(
value
).
Else if
value
has a
[[BooleanData]]
internal slot, then
Set
value
to
value
.
[[BooleanData]]
.
Else if
value
has a
[[BigIntData]]
internal slot, then
Set
value
to
value
.
[[BigIntData]]
.
If
value
is
null
, return
"null"
.
If
value
is
true
, return
"true"
.
If
value
is
false
, return
"false"
.
If
value
is a String
, return
QuoteJSONString
(
value
).
If
value
is a Number
, then
If
value
is
finite
, return !
ToString
(
value
).
Return
"null"
.
If
value
is a BigInt
, throw a
TypeError
exception.
If
value
is an Object
and
IsCallable
(
value
) is
false
, then
Let
isArray
be ?
IsArray
(
value
).
If
isArray
is
true
, return ?
SerializeJSONArray
(
state
,
value
).
Return ?
SerializeJSONObject
(
state
,
value
).
Return
undefined
.
25.5.2.3
QuoteJSONString (
value
)
The abstract operation QuoteJSONString takes argument
value
(a String) and returns a String. It wraps
value
in 0x0022 (QUOTATION MARK) code units and escapes certain other code units within it. This operation interprets
value
as a sequence of UTF-16 encoded code points, as described in
6.1.4
. It performs the following steps when called:
Let
product
be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).
For each code point
C
of
StringToCodePoints
(
value
), do
If
C
is listed in the “Code Point” column of
Table 76
, then
Set
product
to the
string-concatenation
of
product
and the escape sequence for
C
as specified in the “Escape Sequence” column of the corresponding row.
Else if
C
has a numeric value less than 0x0020 (SPACE) or
C
has the same numeric value as a
leading surrogate
or
trailing surrogate
, then
Let
unit
be the code unit whose numeric value is the numeric value of
C
.
Set
product
to the
string-concatenation
of
product
and
UnicodeEscape
(
unit
).
Else,
Set
product
to the
string-concatenation
of
product
and
UTF16EncodeCodePoint
(
C
).
Set
product
to the
string-concatenation
of
product
and the code unit 0x0022 (QUOTATION MARK).
Return
product
.
Table 76: JSON Single Character Escape Sequences
Code Point
Unicode Character Name
Escape Sequence
U+0008
BACKSPACE
\b
U+0009
CHARACTER TABULATION
\t
U+000A
LINE FEED (LF)
\n
U+000C
FORM FEED (FF)
\f
U+000D
CARRIAGE RETURN (CR)
\r
U+0022
QUOTATION MARK
\"
U+005C
REVERSE SOLIDUS
\\
25.5.2.4
UnicodeEscape (
C
)
The abstract operation UnicodeEscape takes argument
C
(a code unit) and returns a String. It represents
C
as a Unicode escape sequence. It performs the following steps when called:
Let
n
be the numeric value of
C
.
Assert
:
n
≤ 0xFFFF.
Let
hex
be the String representation of
n
, formatted as a lowercase hexadecimal number.
Return the
string-concatenation
of the code unit 0x005C (REVERSE SOLIDUS),
"u"
, and
StringPad
(
hex
, 4,
"0"
,
start
).
25.5.2.5
SerializeJSONObject (
state
,
value
)
The abstract operation SerializeJSONObject takes arguments
state
(a
JSON Serialization Record
) and
value
(an Object) and returns either a
normal completion containing
a String or a
throw completion
. It serializes an object. It performs the following steps when called:
If
state
.
[[Stack]]
contains
value
, throw a
TypeError
exception because the structure is cyclical.
Append
value
to
state
.
[[Stack]]
.
Let
stepBack
be
state
.
[[Indent]]
.
Set
state
.
[[Indent]]
to the
string-concatenation
of
state
.
[[Indent]]
and
state
.
[[Gap]]
.
If
state
.
[[PropertyList]]
is not
undefined
, then
Let
K
be
state
.
[[PropertyList]]
.
Else,
Let
K
be ?
EnumerableOwnProperties
(
value
,
key
).
Let
partial
be a new empty
List
.
For each element
P
of
K
, do
Let
strP
be ?
SerializeJSONProperty
(
state
,
P
,
value
).
If
strP
is not
undefined
, then
Let
member
be
QuoteJSONString
(
P
).
Set
member
to the
string-concatenation
of
member
and
":"
.
If
state
.
[[Gap]]
is not the empty String, then
Set
member
to the
string-concatenation
of
member
and the code unit 0x0020 (SPACE).
Set
member
to the
string-concatenation
of
member
and
strP
.
Append
member
to
partial
.
If
partial
is empty, then
Let
final
be
"{}"
.
Else,
If
state
.
[[Gap]]
is the empty String, then
Let
properties
be the String value formed by concatenating all the element Strings of
partial
with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
Let
final
be the
string-concatenation
of
"{"
,
properties
, and
"}"
.
Else,
Let
separator
be the
string-concatenation
of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and
state
.
[[Indent]]
.
Let
properties
be the String value formed by concatenating all the element Strings of
partial
with each adjacent pair of Strings separated with
separator
. The
separator
String is not inserted either before the first String or after the last String.
Let
final
be the
string-concatenation
of
"{"
, the code unit 0x000A (LINE FEED),
state
.
[[Indent]]
,
properties
, the code unit 0x000A (LINE FEED),
stepBack
, and
"}"
.
Remove the last element of
state
.
[[Stack]]
.
Set
state
.
[[Indent]]
to
stepBack
.
Return
final
.
25.5.2.6
SerializeJSONArray (
state
,
value
)
The abstract operation SerializeJSONArray takes arguments
state
(a
JSON Serialization Record
) and
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a String or a
throw completion
. It serializes an array. It performs the following steps when called:
If
state
.
[[Stack]]
contains
value
, throw a
TypeError
exception because the structure is cyclical.
Append
value
to
state
.
[[Stack]]
.
Let
stepBack
be
state
.
[[Indent]]
.
Set
state
.
[[Indent]]
to the
string-concatenation
of
state
.
[[Indent]]
and
state
.
[[Gap]]
.
Let
partial
be a new empty
List
.
Let
len
be ?
LengthOfArrayLike
(
value
).
Let
index
be 0.
Repeat, while
index
<
len
,
Let
strP
be ?
SerializeJSONProperty
(
state
, !
ToString
(
𝔽
(
index
)),
value
).
If
strP
is
undefined
, then
Append
"null"
to
partial
.
Else,
Append
strP
to
partial
.
Set
index
to
index
+ 1.
If
partial
is empty, then
Let
final
be
"[]"
.
Else,
If
state
.
[[Gap]]
is the empty String, then
Let
properties
be the String value formed by concatenating all the element Strings of
partial
with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
Let
final
be the
string-concatenation
of
"["
,
properties
, and
"]"
.
Else,
Let
separator
be the
string-concatenation
of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and
state
.
[[Indent]]
.
Let
properties
be the String value formed by concatenating all the element Strings of
partial
with each adjacent pair of Strings separated with
separator
. The
separator
String is not inserted either before the first String or after the last String.
Let
final
be the
string-concatenation
of
"["
, the code unit 0x000A (LINE FEED),
state
.
[[Indent]]
,
properties
, the code unit 0x000A (LINE FEED),
stepBack
, and
"]"
.
Remove the last element of
state
.
[[Stack]]
.
Set
state
.
[[Indent]]
to
stepBack
.
Return
final
.
Note
The representation of arrays includes only the elements in the
interval
from
+0
𝔽
(inclusive) to
array.length
(exclusive). Properties whose keys are not
array indices
are excluded from the stringification. An array is stringified as an opening LEFT SQUARE BRACKET, elements separated by COMMA, and a closing RIGHT SQUARE BRACKET.
25.5.3
JSON [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"JSON"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
26
Managing Memory
26.1
WeakRef Objects
A
WeakRef
is an object that is used to refer to a target object or symbol without preserving it from garbage collection.
WeakRefs
can be dereferenced to allow access to the target value, if the target hasn't been reclaimed by garbage collection.
26.1.1
The WeakRef Constructor
The
WeakRef
constructor
:
is
%WeakRef%
.
is the initial value of the
"WeakRef"
property of the
global object
.
creates and initializes a new WeakRef when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value in an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified
WeakRef
behaviour must include a
super
call to the
WeakRef
constructor
to create and initialize the subclass instance with the internal state necessary to support the
WeakRef.prototype
built-in methods.
26.1.1.1
WeakRef (
target
)
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
If
CanBeHeldWeakly
(
target
) is
false
, throw a
TypeError
exception.
Let
weakRef
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%WeakRef.prototype%"
, «
[[WeakRefTarget]]
»).
Perform
AddToKeptObjects
(
target
).
Set
weakRef
.
[[WeakRefTarget]]
to
target
.
Return
weakRef
.
26.1.2
Properties of the WeakRef Constructor
The
WeakRef
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
26.1.2.1
WeakRef.prototype
The initial value of
WeakRef.prototype
is the
WeakRef prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
26.1.3
Properties of the WeakRef Prototype Object
The
WeakRef prototype object
:
is
%WeakRef.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have a
[[WeakRefTarget]]
internal slot.
Normative Optional
26.1.3.1
WeakRef.prototype.constructor
The initial value of
WeakRef.prototype.constructor
is
%WeakRef%
.
26.1.3.2
WeakRef.prototype.deref ( )
This method performs the following steps when called:
Let
weakRef
be the
this
value.
Perform ?
RequireInternalSlot
(
weakRef
,
[[WeakRefTarget]]
).
Return
WeakRefDeref
(
weakRef
).
Note
If the
WeakRef
returns a
target
value that is not
undefined
, then this
target
value should not be garbage collected until the current execution of ECMAScript code has completed. The
AddToKeptObjects
operation makes sure read consistency is maintained.
let
target = {
foo
(
) {} };
let
weakRef =
new
WeakRef
(target);
// ... later ...
if
(weakRef.
deref
()) { weakRef.
deref
().
foo
(); }
In the above example, if the first deref does not evaluate to
undefined
then the second deref cannot either.
26.1.3.3
WeakRef.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"WeakRef"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
26.1.4
WeakRef Abstract Operations
26.1.4.1
WeakRefDeref (
weakRef
)
The abstract operation WeakRefDeref takes argument
weakRef
(a
WeakRef
) and returns an
ECMAScript language value
. It performs the following steps when called:
Let
target
be
weakRef
.
[[WeakRefTarget]]
.
If
target
is not
empty
, then
Perform
AddToKeptObjects
(
target
).
Return
target
.
Return
undefined
.
Note
This abstract operation is defined separately from WeakRef.prototype.deref strictly to make it possible to succinctly define liveness.
26.1.5
Properties of WeakRef Instances
WeakRef
instances are
ordinary objects
that inherit properties from the
WeakRef prototype object
.
WeakRef
instances also have a
[[WeakRefTarget]]
internal slot.
26.2
FinalizationRegistry Objects
A
FinalizationRegistry
is an object that manages registration and unregistration of cleanup operations that are performed when target objects and symbols are garbage collected.
26.2.1
The FinalizationRegistry Constructor
The
FinalizationRegistry
constructor
:
is
%FinalizationRegistry%
.
is the initial value of the
"FinalizationRegistry"
property of the
global object
.
creates and initializes a new FinalizationRegistry when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value in an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified
FinalizationRegistry
behaviour must include a
super
call to the
FinalizationRegistry
constructor
to create and initialize the subclass instance with the internal state necessary to support the
FinalizationRegistry.prototype
built-in methods.
26.2.1.1
FinalizationRegistry (
cleanupCallback
)
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
If
IsCallable
(
cleanupCallback
) is
false
, throw a
TypeError
exception.
Let
finalizationRegistry
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%FinalizationRegistry.prototype%"
, «
[[Realm]]
,
[[CleanupCallback]]
,
[[Cells]]
»).
Let
fn
be the
active function object
.
Set
finalizationRegistry
.
[[Realm]]
to
fn
.
[[Realm]]
.
Set
finalizationRegistry
.
[[CleanupCallback]]
to
HostMakeJobCallback
(
cleanupCallback
).
Set
finalizationRegistry
.
[[Cells]]
to a new empty
List
.
Return
finalizationRegistry
.
26.2.2
Properties of the FinalizationRegistry Constructor
The
FinalizationRegistry
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
26.2.2.1
FinalizationRegistry.prototype
The initial value of
FinalizationRegistry.prototype
is the
FinalizationRegistry prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
26.2.3
Properties of the FinalizationRegistry Prototype Object
The
FinalizationRegistry prototype object
:
is
%FinalizationRegistry.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have
[[Cells]]
and
[[CleanupCallback]]
internal slots.
26.2.3.1
FinalizationRegistry.prototype.constructor
The initial value of
FinalizationRegistry.prototype.constructor
is
%FinalizationRegistry%
.
26.2.3.2
FinalizationRegistry.prototype.register (
target
,
heldValue
[ ,
unregisterToken
] )
This method performs the following steps when called:
Let
finalizationRegistry
be the
this
value.
Perform ?
RequireInternalSlot
(
finalizationRegistry
,
[[Cells]]
).
If
CanBeHeldWeakly
(
target
) is
false
, throw a
TypeError
exception.
If
SameValue
(
target
,
heldValue
) is
true
, throw a
TypeError
exception.
If
CanBeHeldWeakly
(
unregisterToken
) is
false
, then
If
unregisterToken
is not
undefined
, throw a
TypeError
exception.
Set
unregisterToken
to
empty
.
Let
cell
be the
Record
{
[[WeakRefTarget]]
:
target
,
[[HeldValue]]
:
heldValue
,
[[UnregisterToken]]
:
unregisterToken
}.
Append
cell
to
finalizationRegistry
.
[[Cells]]
.
Return
undefined
.
Note
Based on the algorithms and definitions in this specification,
cell
.
[[HeldValue]]
is
live
when
finalizationRegistry
.
[[Cells]]
contains
cell
; however, this does not necessarily mean that
cell
.
[[UnregisterToken]]
or
cell
.
[[Target]]
are
live
. For example, registering an object with itself as its unregister token would not keep the object alive forever.
26.2.3.3
FinalizationRegistry.prototype.unregister (
unregisterToken
)
This method performs the following steps when called:
Let
finalizationRegistry
be the
this
value.
Perform ?
RequireInternalSlot
(
finalizationRegistry
,
[[Cells]]
).
If
CanBeHeldWeakly
(
unregisterToken
) is
false
, throw a
TypeError
exception.
Let
removed
be
false
.
For each
Record
{
[[WeakRefTarget]]
,
[[HeldValue]]
,
[[UnregisterToken]]
}
cell
of
finalizationRegistry
.
[[Cells]]
, do
If
cell
.
[[UnregisterToken]]
is not
empty
and
SameValue
(
cell
.
[[UnregisterToken]]
,
unregisterToken
) is
true
, then
Remove
cell
from
finalizationRegistry
.
[[Cells]]
.
Set
removed
to
true
.
Return
removed
.
26.2.3.4
FinalizationRegistry.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"FinalizationRegistry"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
26.2.4
Properties of FinalizationRegistry Instances
FinalizationRegistry
instances are
ordinary objects
that inherit properties from the
FinalizationRegistry prototype object
.
FinalizationRegistry
instances also have
[[Cells]]
and
[[CleanupCallback]]
internal slots.
27
Control Abstraction Objects
27.1
Iteration
27.1.1
Common Iteration Interfaces
An interface is a set of
property keys
whose associated values match a specific specification. Any object that provides all the properties as described by an interface's specification
conforms
to that interface. An interface is not represented by a distinct object. There may be many separately implemented objects that conform to any interface. An individual object may conform to multiple interfaces.
27.1.1.1
The Iterable Interface
The
iterable interface
includes the property described in
Table 77
:
Table 77:
Iterable
Interface Required Properties
Property
Value
Requirements
%Symbol.iterator%
a function that returns an
iterator object
The returned object must conform to the
iterator interface
.
27.1.1.2
The Iterator Interface
An object that implements the
iterator interface
must include the property in
Table 78
. Such objects may also implement the properties in
Table 79
.
Table 78:
Iterator
Interface Required Properties
Property
Value
Requirements
"next"
a function that returns an
IteratorResult object
The returned object must conform to the
IteratorResult interface
. If a previous call to the
next
method of an
iterator
has returned an
IteratorResult object
whose
"done"
property is
true
, then all subsequent calls to the
next
method of that object should also return an
IteratorResult object
whose
"done"
property is
true
. However, this requirement is not enforced.
Note 1
Arguments may be passed to the
next
function but their interpretation and validity is dependent upon the target iterator. The for-of statement and other common users of iterators do not pass any arguments, so iterator objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.
Table 79:
Iterator
Interface Optional Properties
Property
Value
Requirements
"return"
a function that returns an
IteratorResult object
The returned object must conform to the
IteratorResult interface
. Invoking this method notifies the
iterator object
that the caller does not intend to make any more
next
method calls to the
iterator
. The returned
IteratorResult object
will typically have a
"done"
property whose value is
true
, and a
"value"
property with the value passed as the argument of the
return
method. However, this requirement is not enforced.
"throw"
a function that returns an
IteratorResult object
The returned object must conform to the
IteratorResult interface
. Invoking this method notifies the
iterator object
that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to
throw
the value passed as the argument. If the method does not
throw
, the returned
IteratorResult object
will typically have a
"done"
property whose value is
true
.
Note 2
Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including
for
-
of
,
yield*
, and array destructuring call these methods after performing an existence check. Most ECMAScript library functions that accept
iterable objects
as arguments also conditionally call them.
27.1.1.3
The Async Iterable Interface
The
async iterable interface
includes the properties described in
Table 80
:
Table 80: Async
Iterable
Interface Required Properties
Property
Value
Requirements
%Symbol.asyncIterator%
a function that returns an
async iterator object
The returned object must conform to the
async iterator interface
.
27.1.1.4
The Async Iterator Interface
An object that implements the
async iterator interface
must include the properties in
Table 81
. Such objects may also implement the properties in
Table 82
.
Table 81: Async
Iterator
Interface Required Properties
Property
Value
Requirements
"next"
a function that returns a promise for an
IteratorResult object
The returned promise, when fulfilled, must fulfill with an object that conforms to the
IteratorResult interface
. If a previous call to the
next
method of an
async iterator
has returned a promise for an
IteratorResult object
whose
"done"
property is
true
, then all subsequent calls to the
next
method of that object should also return a promise for an
IteratorResult object
whose
"done"
property is
true
. However, this requirement is not enforced.
Additionally, the
IteratorResult object
that serves as a fulfillment value should have a
"value"
property whose value is not a promise (or "thenable"). However, this requirement is also not enforced.
Note 1
Arguments may be passed to the
next
function but their interpretation and validity is dependent upon the target async iterator. The
for
-
await
-
of
statement and other common users of async iterators do not pass any arguments, so async iterator objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.
Table 82: Async
Iterator
Interface Optional Properties
Property
Value
Requirements
"return"
a function that returns a promise for an
IteratorResult object
The returned promise, when fulfilled, must fulfill with an object that conforms to the
IteratorResult interface
. Invoking this method notifies the
async iterator object
that the caller does not intend to make any more
next
method calls to the
async iterator
. The returned promise will fulfill with an
IteratorResult object
which will typically have a
"done"
property whose value is
true
, and a
"value"
property with the value passed as the argument of the
return
method. However, this requirement is not enforced.
Additionally, the
IteratorResult object
that serves as a fulfillment value should have a
"value"
property whose value is not a promise (or "thenable"). If the argument value is used in the typical manner, then if it is a rejected promise, a promise rejected with the same reason should be returned; if it is a fulfilled promise, then its fulfillment value should be used as the
"value"
property of the returned promise's
IteratorResult object
fulfillment value. However, these requirements are also not enforced.
"throw"
a function that returns a promise for an
IteratorResult object
The returned promise, when fulfilled, must fulfill with an object that conforms to the
IteratorResult interface
. Invoking this method notifies the
async iterator object
that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to return a rejected promise which rejects with the value passed as the argument.
If the returned promise is fulfilled, the
IteratorResult object
fulfillment value will typically have a
"done"
property whose value is
true
. Additionally, it should have a
"value"
property whose value is not a promise (or "thenable"), but this requirement is not enforced.
Note 2
Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including
for
-
await
-
of
and
yield*
call these methods after performing an existence check.
27.1.1.5
The IteratorResult Interface
The
IteratorResult interface
includes the properties listed in
Table 83
:
Table 83: IteratorResult Interface Properties
Property
Value
Requirements
"done"
a Boolean
This is the result status of an
iterator
next
method call. If the end of the
iterator
was reached
"done"
is
true
. If the end was not reached
"done"
is
false
and a value is available. If a
"done"
property (either own or inherited) does not exist, it is considered to have the value
false
.
"value"
an
ECMAScript language value
If done is
false
, this is the current iteration element value. If done is
true
, this is the return value of the
iterator
, if it supplied one. If the
iterator
does not have a return value,
"value"
is
undefined
. In that case, the
"value"
property may be absent from the conforming object if it does not inherit an explicit
"value"
property.
27.1.2
Iterator Helper Objects
An
Iterator Helper object
is an
ordinary object
that represents a lazy transformation of some specific source
iterator object
. There is not a named
constructor
for Iterator Helper objects. Instead, Iterator Helper objects are created by calling certain methods of
Iterator
instance objects.
27.1.2.1
The %IteratorHelperPrototype% Object
The
%IteratorHelperPrototype%
object:
has properties that are inherited by all
Iterator Helper objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
has the following properties:
27.1.2.1.1
%IteratorHelperPrototype%.next ( )
Return ?
GeneratorResume
(
this
value,
undefined
,
"Iterator Helper"
).
27.1.2.1.2
%IteratorHelperPrototype%.return ( )
Let
O
be
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[UnderlyingIterators]]
).
Assert
:
O
has a
[[GeneratorState]]
internal slot.
If
O
.
[[GeneratorState]]
is
suspended-start
, then
Set
O
.
[[GeneratorState]]
to
completed
.
NOTE: Once a generator enters the completed state it never leaves it and its associated
execution context
is never resumed. Any execution state associated with
O
can be discarded at this point.
Perform ?
IteratorCloseAll
(
O
.
[[UnderlyingIterators]]
,
NormalCompletion
(
unused
)).
Return
CreateIteratorResultObject
(
undefined
,
true
).
Let
C
be
ReturnCompletion
(
undefined
).
Return ?
GeneratorResumeAbrupt
(
O
,
C
,
"Iterator Helper"
).
27.1.2.1.3
%IteratorHelperPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Iterator Helper"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.1.3
Iterator Objects
27.1.3.1
The Iterator Constructor
The
Iterator
constructor
:
is
%Iterator%
.
is the initial value of the
"Iterator"
property of the
global object
.
is designed to be subclassable. It may be used as the value of an
extends
clause of a class definition.
27.1.3.1.1
Iterator ( )
This function performs the following steps when called:
If NewTarget is either
undefined
or the
active function object
, throw a
TypeError
exception.
Return ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Iterator.prototype%"
).
27.1.3.2
Properties of the Iterator Constructor
The
Iterator
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
27.1.3.2.1
Iterator.concat ( ...
items
)
Let
iterables
be a new empty
List
.
For each element
item
of
items
, do
If
item
is not an Object
, throw a
TypeError
exception.
Let
method
be ?
GetMethod
(
item
,
%Symbol.iterator%
).
If
method
is
undefined
, throw a
TypeError
exception.
Append the
Record
{
[[OpenMethod]]
:
method
,
[[Iterable]]
:
item
} to
iterables
.
Let
closure
be a new
Abstract Closure
with no parameters that captures
iterables
and performs the following steps when called:
For each
Record
iterable
of
iterables
, do
Let
iter
be ?
Call
(
iterable
.
[[OpenMethod]]
,
iterable
.
[[Iterable]]
).
If
iter
is not an Object
, throw a
TypeError
exception.
Let
iteratorRecord
be ?
GetIteratorDirect
(
iter
).
Let
innerAlive
be
true
.
Repeat, while
innerAlive
is
true
,
Let
innerValue
be ?
IteratorStepValue
(
iteratorRecord
).
If
innerValue
is
done
, then
Set
innerAlive
to
false
.
Else,
Let
completion
be
Completion
(
Yield
(
innerValue
)).
If
completion
is an
abrupt completion
, then
Return ?
IteratorClose
(
iteratorRecord
,
completion
).
Return
ReturnCompletion
(
undefined
).
Let
gen
be
CreateIteratorFromClosure
(
closure
,
"Iterator Helper"
,
%IteratorHelperPrototype%
, «
[[UnderlyingIterators]]
»).
Set
gen
.
[[UnderlyingIterators]]
to a new empty
List
.
Return
gen
.
27.1.3.2.2
Iterator.from (
O
)
Let
iteratorRecord
be ?
GetIteratorFlattenable
(
O
,
iterate-string-primitives
).
Let
hasInstance
be ?
OrdinaryHasInstance
(
%Iterator%
,
iteratorRecord
.
[[Iterator]]
).
If
hasInstance
is
true
, then
Return
iteratorRecord
.
[[Iterator]]
.
Let
wrapper
be
OrdinaryObjectCreate
(
%WrapForValidIteratorPrototype%
, «
[[Iterated]]
»).
Set
wrapper
.
[[Iterated]]
to
iteratorRecord
.
Return
wrapper
.
27.1.3.2.2.1
The %WrapForValidIteratorPrototype% Object
The
%WrapForValidIteratorPrototype%
object:
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
27.1.3.2.2.1.1
%WrapForValidIteratorPrototype%.next ( )
Let
O
be
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[Iterated]]
).
Let
iteratorRecord
be
O
.
[[Iterated]]
.
Return ?
Call
(
iteratorRecord
.
[[NextMethod]]
,
iteratorRecord
.
[[Iterator]]
).
27.1.3.2.2.1.2
%WrapForValidIteratorPrototype%.return ( )
Let
O
be
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[Iterated]]
).
Let
iterator
be
O
.
[[Iterated]]
.
[[Iterator]]
.
Assert
:
iterator
is an Object
.
Let
returnMethod
be ?
GetMethod
(
iterator
,
"return"
).
If
returnMethod
is
undefined
, then
Return
CreateIteratorResultObject
(
undefined
,
true
).
Return ?
Call
(
returnMethod
,
iterator
).
27.1.3.2.3
Iterator.prototype
The initial value of Iterator.prototype is the
Iterator prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
27.1.3.3
Properties of the Iterator Prototype Object
The
Iterator prototype object
:
is
%Iterator.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
Note
All objects defined in this specification that implement the
iterator interface
also inherit from %Iterator.prototype%. ECMAScript code may also define objects that inherit from %Iterator.prototype%. %Iterator.prototype% provides a place where additional methods that are applicable to all
iterator objects
may be added.
The following expression is one way that ECMAScript code can access the %Iterator.prototype% object:
Object
.
getPrototypeOf
(
Object
.
getPrototypeOf
([][
Symbol
.
iterator
]()))
27.1.3.3.1
Iterator.prototype.constructor
Iterator.prototype.constructor
is an
accessor property
with attributes {
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}. The
[[Get]]
and
[[Set]]
attributes are defined as follows:
27.1.3.3.1.1
get Iterator.prototype.constructor
The value of the
[[Get]]
attribute is a built-in function that requires no arguments. It performs the following steps when called:
Return
%Iterator%
.
27.1.3.3.1.2
set Iterator.prototype.constructor
The value of the
[[Set]]
attribute is a built-in function that takes an argument
v
. It performs the following steps when called:
Perform ?
SetterThatIgnoresPrototypeProperties
(
this
value,
%Iterator.prototype%
,
"constructor"
,
v
).
Return
undefined
.
Note
Unlike the
"constructor"
property on most built-in prototypes, for web-compatibility reasons this property must be an accessor.
27.1.3.3.2
Iterator.prototype.drop (
limit
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
Let
numLimit
be
Completion
(
ToNumber
(
limit
)).
IfAbruptCloseIterator
(
numLimit
,
iterated
).
If
numLimit
is
NaN
, then
Let
error
be
ThrowCompletion
(a newly created
RangeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Let
integerLimit
be !
ToIntegerOrInfinity
(
numLimit
).
If
integerLimit
< 0, then
Let
error
be
ThrowCompletion
(a newly created
RangeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
iterated
and
integerLimit
and performs the following steps when called:
Let
remaining
be
integerLimit
.
Repeat, while
remaining
> 0,
If
remaining
≠ +∞, then
Set
remaining
to
remaining
- 1.
Let
next
be ?
IteratorStep
(
iterated
).
If
next
is
done
, return
ReturnCompletion
(
undefined
).
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
ReturnCompletion
(
undefined
).
Let
completion
be
Completion
(
Yield
(
value
)).
IfAbruptCloseIterator
(
completion
,
iterated
).
Let
result
be
CreateIteratorFromClosure
(
closure
,
"Iterator Helper"
,
%IteratorHelperPrototype%
, «
[[UnderlyingIterators]]
»).
Set
result
.
[[UnderlyingIterators]]
to «
iterated
».
Return
result
.
27.1.3.3.3
Iterator.prototype.every (
predicate
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
predicate
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
true
.
Let
result
be
Completion
(
Call
(
predicate
,
undefined
, «
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
result
,
iterated
).
If
ToBoolean
(
result
) is
false
, return ?
IteratorClose
(
iterated
,
NormalCompletion
(
false
)).
Set
counter
to
counter
+ 1.
27.1.3.3.4
Iterator.prototype.filter (
predicate
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
predicate
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
iterated
and
predicate
and performs the following steps when called:
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
ReturnCompletion
(
undefined
).
Let
selected
be
Completion
(
Call
(
predicate
,
undefined
, «
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
selected
,
iterated
).
If
ToBoolean
(
selected
) is
true
, then
Let
completion
be
Completion
(
Yield
(
value
)).
IfAbruptCloseIterator
(
completion
,
iterated
).
Set
counter
to
counter
+ 1.
Let
result
be
CreateIteratorFromClosure
(
closure
,
"Iterator Helper"
,
%IteratorHelperPrototype%
, «
[[UnderlyingIterators]]
»).
Set
result
.
[[UnderlyingIterators]]
to «
iterated
».
Return
result
.
27.1.3.3.5
Iterator.prototype.find (
predicate
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
predicate
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
undefined
.
Let
result
be
Completion
(
Call
(
predicate
,
undefined
, «
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
result
,
iterated
).
If
ToBoolean
(
result
) is
true
, return ?
IteratorClose
(
iterated
,
NormalCompletion
(
value
)).
Set
counter
to
counter
+ 1.
27.1.3.3.6
Iterator.prototype.flatMap (
mapper
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
mapper
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
iterated
and
mapper
and performs the following steps when called:
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
ReturnCompletion
(
undefined
).
Let
mapped
be
Completion
(
Call
(
mapper
,
undefined
, «
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
mapped
,
iterated
).
Let
innerIterator
be
Completion
(
GetIteratorFlattenable
(
mapped
,
reject-primitives
)).
IfAbruptCloseIterator
(
innerIterator
,
iterated
).
Let
innerAlive
be
true
.
Repeat, while
innerAlive
is
true
,
Let
innerValue
be
Completion
(
IteratorStepValue
(
innerIterator
)).
IfAbruptCloseIterator
(
innerValue
,
iterated
).
If
innerValue
is
done
, then
Set
innerAlive
to
false
.
Else,
Let
completion
be
Completion
(
Yield
(
innerValue
)).
If
completion
is an
abrupt completion
, then
Let
backupCompletion
be
Completion
(
IteratorClose
(
innerIterator
,
completion
)).
IfAbruptCloseIterator
(
backupCompletion
,
iterated
).
Return ?
IteratorClose
(
iterated
,
completion
).
Set
counter
to
counter
+ 1.
Let
result
be
CreateIteratorFromClosure
(
closure
,
"Iterator Helper"
,
%IteratorHelperPrototype%
, «
[[UnderlyingIterators]]
»).
Set
result
.
[[UnderlyingIterators]]
to «
iterated
».
Return
result
.
27.1.3.3.7
Iterator.prototype.forEach (
procedure
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
procedure
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
undefined
.
Let
result
be
Completion
(
Call
(
procedure
,
undefined
, «
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
result
,
iterated
).
Set
counter
to
counter
+ 1.
27.1.3.3.8
Iterator.prototype.map (
mapper
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
mapper
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
iterated
and
mapper
and performs the following steps when called:
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
ReturnCompletion
(
undefined
).
Let
mapped
be
Completion
(
Call
(
mapper
,
undefined
, «
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
mapped
,
iterated
).
Let
completion
be
Completion
(
Yield
(
mapped
)).
IfAbruptCloseIterator
(
completion
,
iterated
).
Set
counter
to
counter
+ 1.
Let
result
be
CreateIteratorFromClosure
(
closure
,
"Iterator Helper"
,
%IteratorHelperPrototype%
, «
[[UnderlyingIterators]]
»).
Set
result
.
[[UnderlyingIterators]]
to «
iterated
».
Return
result
.
27.1.3.3.9
Iterator.prototype.reduce (
reducer
[ ,
initialValue
] )
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
reducer
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
If
initialValue
is not present, then
Let
accumulator
be ?
IteratorStepValue
(
iterated
).
If
accumulator
is
done
, throw a
TypeError
exception.
Let
counter
be 1.
Else,
Let
accumulator
be
initialValue
.
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
accumulator
.
Let
result
be
Completion
(
Call
(
reducer
,
undefined
, «
accumulator
,
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
result
,
iterated
).
Set
accumulator
to
result
.
Set
counter
to
counter
+ 1.
27.1.3.3.10
Iterator.prototype.some (
predicate
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
If
IsCallable
(
predicate
) is
false
, then
Let
error
be
ThrowCompletion
(a newly created
TypeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
counter
be 0.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
false
.
Let
result
be
Completion
(
Call
(
predicate
,
undefined
, «
value
,
𝔽
(
counter
) »)).
IfAbruptCloseIterator
(
result
,
iterated
).
If
ToBoolean
(
result
) is
true
, return ?
IteratorClose
(
iterated
,
NormalCompletion
(
true
)).
Set
counter
to
counter
+ 1.
27.1.3.3.11
Iterator.prototype.take (
limit
)
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be the
Iterator Record
{
[[Iterator]]
:
O
,
[[NextMethod]]
:
undefined
,
[[Done]]
:
false
}.
Let
numLimit
be
Completion
(
ToNumber
(
limit
)).
IfAbruptCloseIterator
(
numLimit
,
iterated
).
If
numLimit
is
NaN
, then
Let
error
be
ThrowCompletion
(a newly created
RangeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Let
integerLimit
be !
ToIntegerOrInfinity
(
numLimit
).
If
integerLimit
< 0, then
Let
error
be
ThrowCompletion
(a newly created
RangeError
object).
Return ?
IteratorClose
(
iterated
,
error
).
Set
iterated
to ?
GetIteratorDirect
(
O
).
Let
closure
be a new
Abstract Closure
with no parameters that captures
iterated
and
integerLimit
and performs the following steps when called:
Let
remaining
be
integerLimit
.
Repeat,
If
remaining
= 0, then
Return ?
IteratorClose
(
iterated
,
ReturnCompletion
(
undefined
)).
If
remaining
≠ +∞, then
Set
remaining
to
remaining
- 1.
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
ReturnCompletion
(
undefined
).
Let
completion
be
Completion
(
Yield
(
value
)).
IfAbruptCloseIterator
(
completion
,
iterated
).
Let
result
be
CreateIteratorFromClosure
(
closure
,
"Iterator Helper"
,
%IteratorHelperPrototype%
, «
[[UnderlyingIterators]]
»).
Set
result
.
[[UnderlyingIterators]]
to «
iterated
».
Return
result
.
27.1.3.3.12
Iterator.prototype.toArray ( )
This method performs the following steps when called:
Let
O
be the
this
value.
If
O
is not an Object
, throw a
TypeError
exception.
Let
iterated
be ?
GetIteratorDirect
(
O
).
Let
items
be a new empty
List
.
Repeat,
Let
value
be ?
IteratorStepValue
(
iterated
).
If
value
is
done
, return
CreateArrayFromList
(
items
).
Append
value
to
items
.
27.1.3.3.13
Iterator.prototype [ %Symbol.iterator% ] ( )
This function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"[Symbol.iterator]"
.
27.1.3.3.14
Iterator.prototype [ %Symbol.toStringTag% ]
Iterator.prototype[%Symbol.toStringTag%]
is an
accessor property
with attributes {
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}. The
[[Get]]
and
[[Set]]
attributes are defined as follows:
27.1.3.3.14.1
get Iterator.prototype [ %Symbol.toStringTag% ]
The value of the
[[Get]]
attribute is a built-in function that requires no arguments. It performs the following steps when called:
Return
"Iterator"
.
27.1.3.3.14.2
set Iterator.prototype [ %Symbol.toStringTag% ]
The value of the
[[Set]]
attribute is a built-in function that takes an argument
v
. It performs the following steps when called:
Perform ?
SetterThatIgnoresPrototypeProperties
(
this
value,
%Iterator.prototype%
,
%Symbol.toStringTag%
,
v
).
Return
undefined
.
Note
Unlike the
%Symbol.toStringTag%
property on most built-in prototypes, for web-compatibility reasons this property must be an accessor.
27.1.4
The %AsyncIteratorPrototype% Object
The
%AsyncIteratorPrototype%
object:
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
Note
All objects defined in this specification that implement the
async iterator interface
also inherit from %AsyncIteratorPrototype%. ECMAScript code may also define objects that inherit from %AsyncIteratorPrototype%. The %AsyncIteratorPrototype% object provides a place where additional methods that are applicable to all
async iterator objects
may be added.
27.1.4.1
%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )
This function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"[Symbol.asyncIterator]"
.
27.1.5
Async-from-Sync Iterator Objects
An
Async-from-Sync Iterator object
is an
async iterator
that adapts a specific synchronous
iterator
. Async-from-Sync Iterator objects are never directly accessible to ECMAScript code. There is not a named
constructor
for Async-from-Sync Iterator objects. Instead, Async-from-Sync Iterator objects are created by the
CreateAsyncFromSyncIterator
abstract operation as needed.
27.1.5.1
CreateAsyncFromSyncIterator (
syncIteratorRecord
)
The abstract operation CreateAsyncFromSyncIterator takes argument
syncIteratorRecord
(an
Iterator Record
) and returns an
Iterator Record
. It is used to create an async
Iterator Record
from a synchronous
Iterator Record
. It performs the following steps when called:
Let
asyncIterator
be
OrdinaryObjectCreate
(
%AsyncFromSyncIteratorPrototype%
, «
[[SyncIteratorRecord]]
»).
Set
asyncIterator
.
[[SyncIteratorRecord]]
to
syncIteratorRecord
.
Let
nextMethod
be !
Get
(
asyncIterator
,
"next"
).
Let
iteratorRecord
be the
Iterator Record
{
[[Iterator]]
:
asyncIterator
,
[[NextMethod]]
:
nextMethod
,
[[Done]]
:
false
}.
Return
iteratorRecord
.
27.1.5.2
The %AsyncFromSyncIteratorPrototype% Object
The
%AsyncFromSyncIteratorPrototype%
object:
has properties that are inherited by all
Async-from-Sync Iterator objects
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%AsyncIteratorPrototype%
.
is never directly accessible to ECMAScript code.
has the following properties:
27.1.5.2.1
%AsyncFromSyncIteratorPrototype%.next ( [
value
] )
Let
O
be the
this
value.
Assert
:
O
is an Object
that has a
[[SyncIteratorRecord]]
internal slot.
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
syncIteratorRecord
be
O
.
[[SyncIteratorRecord]]
.
If
value
is present, then
Let
result
be
Completion
(
IteratorNext
(
syncIteratorRecord
,
value
)).
Else,
Let
result
be
Completion
(
IteratorNext
(
syncIteratorRecord
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Return
AsyncFromSyncIteratorContinuation
(
result
,
promiseCapability
,
syncIteratorRecord
,
true
).
27.1.5.2.2
%AsyncFromSyncIteratorPrototype%.return ( [
value
] )
Let
O
be the
this
value.
Assert
:
O
is an Object
that has a
[[SyncIteratorRecord]]
internal slot.
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
syncIteratorRecord
be
O
.
[[SyncIteratorRecord]]
.
Let
syncIterator
be
syncIteratorRecord
.
[[Iterator]]
.
Let
return
be
Completion
(
GetMethod
(
syncIterator
,
"return"
)).
IfAbruptRejectPromise
(
return
,
promiseCapability
).
If
return
is
undefined
, then
Let
iteratorResult
be
CreateIteratorResultObject
(
value
,
true
).
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
iteratorResult
»).
Return
promiseCapability
.
[[Promise]]
.
If
value
is present, then
Let
result
be
Completion
(
Call
(
return
,
syncIterator
, «
value
»)).
Else,
Let
result
be
Completion
(
Call
(
return
,
syncIterator
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
If
result
is not an Object
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, « a newly created
TypeError
object »).
Return
promiseCapability
.
[[Promise]]
.
Return
AsyncFromSyncIteratorContinuation
(
result
,
promiseCapability
,
syncIteratorRecord
,
false
).
27.1.5.2.3
%AsyncFromSyncIteratorPrototype%.throw ( [
value
] )
Note
In this specification,
value
is always provided, but is left optional for consistency with
%AsyncFromSyncIteratorPrototype%.return ( [
value
] )
.
Let
O
be the
this
value.
Assert
:
O
is an Object
that has a
[[SyncIteratorRecord]]
internal slot.
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
syncIteratorRecord
be
O
.
[[SyncIteratorRecord]]
.
Let
syncIterator
be
syncIteratorRecord
.
[[Iterator]]
.
Let
throw
be
Completion
(
GetMethod
(
syncIterator
,
"throw"
)).
IfAbruptRejectPromise
(
throw
,
promiseCapability
).
If
throw
is
undefined
, then
NOTE: If
syncIterator
does not have a
throw
method, close it to give it a chance to clean up before we reject the capability.
Let
closeCompletion
be
NormalCompletion
(
empty
).
Let
result
be
Completion
(
IteratorClose
(
syncIteratorRecord
,
closeCompletion
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
NOTE: The next step throws a
TypeError
to indicate that there was a protocol violation:
syncIterator
does not have a
throw
method.
NOTE: If closing
syncIterator
does not throw then the result of that operation is ignored, even if it yields a rejected promise.
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, « a newly created
TypeError
object »).
Return
promiseCapability
.
[[Promise]]
.
If
value
is present, then
Let
result
be
Completion
(
Call
(
throw
,
syncIterator
, «
value
»)).
Else,
Let
result
be
Completion
(
Call
(
throw
,
syncIterator
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
If
result
is not an Object
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, « a newly created
TypeError
object »).
Return
promiseCapability
.
[[Promise]]
.
Return
AsyncFromSyncIteratorContinuation
(
result
,
promiseCapability
,
syncIteratorRecord
,
true
).
27.1.5.3
Properties of Async-from-Sync Iterator Instances
Async-from-Sync
Iterator
instances are
ordinary objects
that inherit properties from the
%AsyncFromSyncIteratorPrototype%
intrinsic object. Async-from-Sync
Iterator
instances are initially created with the internal slots listed in
Table 84
.
Table 84: Internal Slots of Async-from-Sync
Iterator
Instances
Internal Slot
Type
Description
[[SyncIteratorRecord]]
an
Iterator Record
Represents the original synchronous
iterator
which is being adapted.
27.1.5.4
AsyncFromSyncIteratorContinuation (
result
,
promiseCapability
,
syncIteratorRecord
,
closeOnRejection
)
The abstract operation AsyncFromSyncIteratorContinuation takes arguments
result
(an Object),
promiseCapability
(a
PromiseCapability Record
for an intrinsic
%Promise%
),
syncIteratorRecord
(an
Iterator Record
), and
closeOnRejection
(a Boolean) and returns a Promise. It performs the following steps when called:
NOTE: Because
promiseCapability
is derived from the intrinsic
%Promise%
, the calls to
promiseCapability
.
[[Reject]]
entailed by the use
IfAbruptRejectPromise
below are guaranteed not to throw.
Let
done
be
Completion
(
IteratorComplete
(
result
)).
IfAbruptRejectPromise
(
done
,
promiseCapability
).
Let
value
be
Completion
(
IteratorValue
(
result
)).
IfAbruptRejectPromise
(
value
,
promiseCapability
).
Let
valueWrapper
be
Completion
(
PromiseResolve
(
%Promise%
,
value
)).
If
valueWrapper
is an
abrupt completion
,
done
is
false
, and
closeOnRejection
is
true
, then
Set
valueWrapper
to
Completion
(
IteratorClose
(
syncIteratorRecord
,
valueWrapper
)).
IfAbruptRejectPromise
(
valueWrapper
,
promiseCapability
).
Let
unwrap
be a new
Abstract Closure
with parameters (
v
) that captures
done
and performs the following steps when called:
Return
CreateIteratorResultObject
(
v
,
done
).
Let
onFulfilled
be
CreateBuiltinFunction
(
unwrap
, 1,
""
, « »).
NOTE:
onFulfilled
is used when processing the
"value"
property of an
IteratorResult object
in order to wait for its value if it is a promise and re-package the result in a new "unwrapped"
IteratorResult object
.
If
done
is
true
, or if
closeOnRejection
is
false
, then
Let
onRejected
be
undefined
.
Else,
Let
closeIterator
be a new
Abstract Closure
with parameters (
error
) that captures
syncIteratorRecord
and performs the following steps when called:
Return ?
IteratorClose
(
syncIteratorRecord
,
ThrowCompletion
(
error
)).
Let
onRejected
be
CreateBuiltinFunction
(
closeIterator
, 1,
""
, « »).
NOTE:
onRejected
is used to close the
Iterator
when the
"value"
property of an
IteratorResult object
it yields is a rejected promise.
Perform
PerformPromiseThen
(
valueWrapper
,
onFulfilled
,
onRejected
,
promiseCapability
).
Return
promiseCapability
.
[[Promise]]
.
27.2
Promise Objects
A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.
Any Promise is in one of three mutually exclusive states:
fulfilled
,
rejected
, and
pending
:
A promise
p
is fulfilled if
p.then(f, r)
will immediately enqueue a
Job
to call the function
f
.
A promise
p
is rejected if
p.then(f, r)
will immediately enqueue a
Job
to call the function
r
.
A promise is pending if it is neither fulfilled nor rejected.
A promise is said to be
settled
if it is not pending, i.e. if it is either fulfilled or rejected.
A promise is
resolved
if it is settled or if it has been “locked in” to match the state of another promise. Attempting to resolve or reject a resolved promise has no effect. A promise is
unresolved
if it is not resolved. An unresolved promise is always in the pending state. A resolved promise may be pending, fulfilled or rejected.
27.2.1
Promise Abstract Operations
27.2.1.1
PromiseCapability Records
A
PromiseCapability Record
is a
Record
value used to encapsulate a Promise or promise-like object along with the functions that are capable of resolving or rejecting that promise. PromiseCapability Records are produced by the
NewPromiseCapability
abstract operation.
PromiseCapability Records have the fields listed in
Table 85
.
Table 85:
PromiseCapability Record
Fields
Field Name
Value
Meaning
[[Promise]]
an Object
An object that is usable as a promise.
[[Resolve]]
a
function object
The function that is used to resolve the given promise.
[[Reject]]
a
function object
The function that is used to reject the given promise.
27.2.1.1.1
IfAbruptRejectPromise (
value
,
capability
)
IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps that use a
PromiseCapability Record
. An algorithm step of the form:
IfAbruptRejectPromise
(
value
,
capability
).
means the same thing as:
Assert
:
value
is a
Completion Record
.
If
value
is an
abrupt completion
, then
Perform ?
Call
(
capability
.
[[Reject]]
,
undefined
, «
value
.
[[Value]]
»).
Return
capability
.
[[Promise]]
.
Else,
Set
value
to !
value
.
27.2.1.2
PromiseReaction Records
A
PromiseReaction Record
is a
Record
value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction Records are created by the
PerformPromiseThen
abstract operation, and are used by the
Abstract Closure
returned by
NewPromiseReactionJob
.
PromiseReaction Records have the fields listed in
Table 86
.
Table 86:
PromiseReaction Record
Fields
Field Name
Value
Meaning
[[Capability]]
a
PromiseCapability Record
or
undefined
The capabilities of the promise for which this record provides a reaction handler.
[[Type]]
fulfill
or
reject
The
[[Type]]
is used when
[[Handler]]
is
empty
to allow for behaviour specific to the settlement type.
[[Handler]]
a
JobCallback Record
or
empty
The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If
[[Handler]]
is
empty
, a function that depends on the value of
[[Type]]
will be used instead.
27.2.1.3
CreateResolvingFunctions (
promise
)
The abstract operation CreateResolvingFunctions takes argument
promise
(a Promise) and returns a
Record
with fields
[[Resolve]]
(a
function object
) and
[[Reject]]
(a
function object
). It performs the following steps when called:
Let
alreadyResolved
be the
Record
{
[[Value]]
:
false
}.
Let
resolveSteps
be a new
Abstract Closure
with parameters (
resolution
) that captures
promise
and
alreadyResolved
and performs the following steps when called:
If
alreadyResolved
.
[[Value]]
is
true
, return
undefined
.
Set
alreadyResolved
.
[[Value]]
to
true
.
If
SameValue
(
resolution
,
promise
) is
true
, then
Let
selfResolutionError
be a newly created
TypeError
object.
Perform
RejectPromise
(
promise
,
selfResolutionError
).
Return
undefined
.
If
resolution
is not an Object
, then
Perform
FulfillPromise
(
promise
,
resolution
).
Return
undefined
.
Let
then
be
Completion
(
Get
(
resolution
,
"then"
)).
If
then
is an
abrupt completion
, then
Perform
RejectPromise
(
promise
,
then
.
[[Value]]
).
Return
undefined
.
Let
thenAction
be
then
.
[[Value]]
.
If
IsCallable
(
thenAction
) is
false
, then
Perform
FulfillPromise
(
promise
,
resolution
).
Return
undefined
.
Let
thenJobCallback
be
HostMakeJobCallback
(
thenAction
).
Let
job
be
NewPromiseResolveThenableJob
(
promise
,
resolution
,
thenJobCallback
).
Perform
HostEnqueuePromiseJob
(
job
.
[[Job]]
,
job
.
[[Realm]]
).
Return
undefined
.
Let
resolve
be
CreateBuiltinFunction
(
resolveSteps
, 1,
""
, « »).
Let
rejectSteps
be a new
Abstract Closure
with parameters (
reason
) that captures
promise
and
alreadyResolved
and performs the following steps when called:
If
alreadyResolved
.
[[Value]]
is
true
, return
undefined
.
Set
alreadyResolved
.
[[Value]]
to
true
.
Perform
RejectPromise
(
promise
,
reason
).
Return
undefined
.
Let
reject
be
CreateBuiltinFunction
(
rejectSteps
, 1,
""
, « »).
Return the
Record
{
[[Resolve]]
:
resolve
,
[[Reject]]
:
reject
}.
27.2.1.4
FulfillPromise (
promise
,
value
)
The abstract operation FulfillPromise takes arguments
promise
(a Promise) and
value
(an
ECMAScript language value
) and returns
unused
. It performs the following steps when called:
Assert
:
promise
.
[[PromiseState]]
is
pending
.
Let
reactions
be
promise
.
[[PromiseFulfillReactions]]
.
Set
promise
.
[[PromiseResult]]
to
value
.
Set
promise
.
[[PromiseFulfillReactions]]
to
undefined
.
Set
promise
.
[[PromiseRejectReactions]]
to
undefined
.
Set
promise
.
[[PromiseState]]
to
fulfilled
.
Perform
TriggerPromiseReactions
(
reactions
,
value
).
Return
unused
.
27.2.1.5
NewPromiseCapability (
C
)
The abstract operation NewPromiseCapability takes argument
C
(an
ECMAScript language value
) and returns either a
normal completion containing
a
PromiseCapability Record
or a
throw completion
. It attempts to use
C
as a
constructor
in the fashion of the built-in Promise
constructor
to create a promise and extract its
resolve
and
reject
functions. The promise plus the
resolve
and
reject
functions are used to initialize a new
PromiseCapability Record
. It performs the following steps when called:
If
IsConstructor
(
C
) is
false
, throw a
TypeError
exception.
NOTE:
C
is assumed to be a
constructor
function that supports the parameter conventions of the Promise
constructor
(see
27.2.3.1
).
Let
resolvingFunctions
be the
Record
{
[[Resolve]]
:
undefined
,
[[Reject]]
:
undefined
}.
Let
executorClosure
be a new
Abstract Closure
with parameters (
resolve
,
reject
) that captures
resolvingFunctions
and performs the following steps when called:
If
resolvingFunctions
.
[[Resolve]]
is not
undefined
, throw a
TypeError
exception.
If
resolvingFunctions
.
[[Reject]]
is not
undefined
, throw a
TypeError
exception.
Set
resolvingFunctions
.
[[Resolve]]
to
resolve
.
Set
resolvingFunctions
.
[[Reject]]
to
reject
.
Return
NormalCompletion
(
undefined
).
Let
executor
be
CreateBuiltinFunction
(
executorClosure
, 2,
""
, « »).
Let
promise
be ?
Construct
(
C
, «
executor
»).
If
IsCallable
(
resolvingFunctions
.
[[Resolve]]
) is
false
, throw a
TypeError
exception.
If
IsCallable
(
resolvingFunctions
.
[[Reject]]
) is
false
, throw a
TypeError
exception.
Return the
PromiseCapability Record
{
[[Promise]]
:
promise
,
[[Resolve]]
:
resolvingFunctions
.
[[Resolve]]
,
[[Reject]]
:
resolvingFunctions
.
[[Reject]]
}.
Note
This abstract operation supports Promise subclassing, as it is generic on any
constructor
that calls a passed executor function argument in the same way as the Promise
constructor
. It is used to generalize static methods of the Promise
constructor
to any subclass.
27.2.1.6
IsPromise (
x
)
The abstract operation IsPromise takes argument
x
(an
ECMAScript language value
) and returns a Boolean. It checks for the promise brand on an object. It performs the following steps when called:
If
x
is not an Object
, return
false
.
If
x
does not have a
[[PromiseState]]
internal slot, return
false
.
Return
true
.
27.2.1.7
RejectPromise (
promise
,
reason
)
The abstract operation RejectPromise takes arguments
promise
(a Promise) and
reason
(an
ECMAScript language value
) and returns
unused
. It performs the following steps when called:
Assert
:
promise
.
[[PromiseState]]
is
pending
.
Let
reactions
be
promise
.
[[PromiseRejectReactions]]
.
Set
promise
.
[[PromiseResult]]
to
reason
.
Set
promise
.
[[PromiseFulfillReactions]]
to
undefined
.
Set
promise
.
[[PromiseRejectReactions]]
to
undefined
.
Set
promise
.
[[PromiseState]]
to
rejected
.
If
promise
.
[[PromiseIsHandled]]
is
false
, perform
HostPromiseRejectionTracker
(
promise
,
"reject"
).
Perform
TriggerPromiseReactions
(
reactions
,
reason
).
Return
unused
.
27.2.1.8
TriggerPromiseReactions (
reactions
,
argument
)
The abstract operation TriggerPromiseReactions takes arguments
reactions
(a
List
of
PromiseReaction Records
) and
argument
(an
ECMAScript language value
) and returns
unused
. It enqueues a new
Job
for each record in
reactions
. Each such
Job
processes the
[[Type]]
and
[[Handler]]
of the
PromiseReaction Record
, and if the
[[Handler]]
is not
empty
, calls it passing the given argument. If the
[[Handler]]
is
empty
, the behaviour is determined by the
[[Type]]
. It performs the following steps when called:
For each element
reaction
of
reactions
, do
Let
job
be
NewPromiseReactionJob
(
reaction
,
argument
).
Perform
HostEnqueuePromiseJob
(
job
.
[[Job]]
,
job
.
[[Realm]]
).
Return
unused
.
27.2.1.9
HostPromiseRejectionTracker (
promise
,
operation
)
The
host-defined
abstract operation HostPromiseRejectionTracker takes arguments
promise
(a Promise) and
operation
(
"reject"
or
"handle"
) and returns
unused
. It allows
host environments
to track promise rejections.
The default implementation of HostPromiseRejectionTracker is to return
unused
.
Note 1
HostPromiseRejectionTracker is called in two scenarios:
When a promise is rejected without any handlers, it is called with its
operation
argument set to
"reject"
.
When a handler is added to a rejected promise for the first time, it is called with its
operation
argument set to
"handle"
.
A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.
Note 2
If
operation
is
"handle"
, an implementation should not hold a reference to
promise
in a way that would interfere with garbage collection. An implementation may hold a reference to
promise
if
operation
is
"reject"
, since it is expected that rejections will be rare and not on hot code paths.
27.2.2
Promise Jobs
27.2.2.1
NewPromiseReactionJob (
reaction
,
argument
)
The abstract operation NewPromiseReactionJob takes arguments
reaction
(a
PromiseReaction Record
) and
argument
(an
ECMAScript language value
) and returns a
Record
with fields
[[Job]]
(a
Job
Abstract Closure
) and
[[Realm]]
(a
Realm Record
or
null
). It returns a new
Job
Abstract Closure
that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:
Let
job
be a new
Job
Abstract Closure
with no parameters that captures
reaction
and
argument
and performs the following steps when called:
Let
promiseCapability
be
reaction
.
[[Capability]]
.
Let
type
be
reaction
.
[[Type]]
.
Let
handler
be
reaction
.
[[Handler]]
.
If
handler
is
empty
, then
If
type
is
fulfill
, then
Let
handlerResult
be
NormalCompletion
(
argument
).
Else,
Assert
:
type
is
reject
.
Let
handlerResult
be
ThrowCompletion
(
argument
).
Else,
Let
handlerResult
be
Completion
(
HostCallJobCallback
(
handler
,
undefined
, «
argument
»)).
If
promiseCapability
is
undefined
, then
Assert
:
handlerResult
is not an
abrupt completion
.
Return
empty
.
Assert
:
promiseCapability
is a
PromiseCapability Record
.
If
handlerResult
is an
abrupt completion
, then
Return ?
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
handlerResult
.
[[Value]]
»).
Else,
Return ?
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
handlerResult
.
[[Value]]
»).
Let
handlerRealm
be
null
.
If
reaction
.
[[Handler]]
is not
empty
, then
Let
getHandlerRealmResult
be
Completion
(
GetFunctionRealm
(
reaction
.
[[Handler]]
.
[[Callback]]
)).
If
getHandlerRealmResult
is a
normal completion
, set
handlerRealm
to
getHandlerRealmResult
.
[[Value]]
.
Else, set
handlerRealm
to
the current Realm Record
.
NOTE:
handlerRealm
is never
null
unless the handler is
undefined
. When the handler is a revoked Proxy and no ECMAScript code runs,
handlerRealm
is used to create error objects.
Return the
Record
{
[[Job]]
:
job
,
[[Realm]]
:
handlerRealm
}.
27.2.2.2
NewPromiseResolveThenableJob (
promiseToResolve
,
thenable
,
then
)
The abstract operation NewPromiseResolveThenableJob takes arguments
promiseToResolve
(a Promise),
thenable
(an Object), and
then
(a
JobCallback Record
) and returns a
Record
with fields
[[Job]]
(a
Job
Abstract Closure
) and
[[Realm]]
(a
Realm Record
). It performs the following steps when called:
Let
job
be a new
Job
Abstract Closure
with no parameters that captures
promiseToResolve
,
thenable
, and
then
and performs the following steps when called:
Let
resolvingFunctions
be
CreateResolvingFunctions
(
promiseToResolve
).
Let
thenCallResult
be
Completion
(
HostCallJobCallback
(
then
,
thenable
, «
resolvingFunctions
.
[[Resolve]]
,
resolvingFunctions
.
[[Reject]]
»)).
If
thenCallResult
is an
abrupt completion
, then
Return ?
Call
(
resolvingFunctions
.
[[Reject]]
,
undefined
, «
thenCallResult
.
[[Value]]
»).
Return !
thenCallResult
.
Let
getThenRealmResult
be
Completion
(
GetFunctionRealm
(
then
.
[[Callback]]
)).
If
getThenRealmResult
is a
normal completion
, let
thenRealm
be
getThenRealmResult
.
[[Value]]
.
Else, let
thenRealm
be
the current Realm Record
.
NOTE:
thenRealm
is never
null
. When
then
.
[[Callback]]
is a revoked Proxy and no code runs,
thenRealm
is used to create error objects.
Return the
Record
{
[[Job]]
:
job
,
[[Realm]]
:
thenRealm
}.
Note
This
Job
uses the supplied thenable and its
then
method to resolve the given promise. This process must take place as a
Job
to ensure that the evaluation of the
then
method occurs after evaluation of any surrounding code has completed.
27.2.3
The Promise Constructor
The Promise
constructor
:
is
%Promise%
.
is the initial value of the
"Promise"
property of the
global object
.
creates and initializes a new Promise when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
may be used as the value in an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified Promise behaviour must include a
super
call to the Promise
constructor
to create and initialize the subclass instance with the internal state necessary to support the
Promise
and
Promise.prototype
built-in methods.
27.2.3.1
Promise (
executor
)
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
If
IsCallable
(
executor
) is
false
, throw a
TypeError
exception.
Let
promise
be ?
OrdinaryCreateFromConstructor
(NewTarget,
"%Promise.prototype%"
, «
[[PromiseState]]
,
[[PromiseResult]]
,
[[PromiseFulfillReactions]]
,
[[PromiseRejectReactions]]
,
[[PromiseIsHandled]]
»).
Set
promise
.
[[PromiseState]]
to
pending
.
Set
promise
.
[[PromiseResult]]
to
empty
.
Set
promise
.
[[PromiseFulfillReactions]]
to a new empty
List
.
Set
promise
.
[[PromiseRejectReactions]]
to a new empty
List
.
Set
promise
.
[[PromiseIsHandled]]
to
false
.
Let
resolvingFunctions
be
CreateResolvingFunctions
(
promise
).
Let
completion
be
Completion
(
Call
(
executor
,
undefined
, «
resolvingFunctions
.
[[Resolve]]
,
resolvingFunctions
.
[[Reject]]
»)).
If
completion
is an
abrupt completion
, then
Perform ?
Call
(
resolvingFunctions
.
[[Reject]]
,
undefined
, «
completion
.
[[Value]]
»).
Return
promise
.
Note
The
executor
argument must be a
function object
. It is called for initiating and reporting completion of the possibly deferred action represented by this Promise. The executor is called with two arguments:
resolve
and
reject
. These are functions that may be used by the
executor
function to report eventual completion or failure of the deferred computation. Returning from the executor function does not mean that the deferred action has been completed but only that the request to eventually perform the deferred action has been accepted.
The
resolve
function that is passed to an
executor
function accepts a single argument. The
executor
code may eventually call the
resolve
function to indicate that it wishes to resolve the associated Promise. The argument passed to the
resolve
function represents the eventual value of the deferred action and can be either the actual fulfillment value or another promise which will provide the value if it is fulfilled.
The
reject
function that is passed to an
executor
function accepts a single argument. The
executor
code may eventually call the
reject
function to indicate that the associated Promise is rejected and will never be fulfilled. The argument passed to the
reject
function is used as the rejection value of the promise. Typically it will be an Error object.
The resolve and reject functions passed to an
executor
function by the Promise
constructor
have the capability to actually resolve and reject the associated promise. Subclasses may have different
constructor
behaviour that passes in customized values for resolve and reject.
27.2.4
Properties of the Promise Constructor
The Promise
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
has the following properties:
27.2.4.1
Promise.all (
iterable
)
This function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed
iterable
to promises as it runs this algorithm.
Let
C
be the
this
value.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Let
promiseResolve
be
Completion
(
GetPromiseResolve
(
C
)).
IfAbruptRejectPromise
(
promiseResolve
,
promiseCapability
).
Let
iteratorRecord
be
Completion
(
GetIterator
(
iterable
,
sync
)).
IfAbruptRejectPromise
(
iteratorRecord
,
promiseCapability
).
Let
result
be
Completion
(
PerformPromiseAll
(
iteratorRecord
,
C
,
promiseCapability
,
promiseResolve
)).
If
result
is an
abrupt completion
, then
If
iteratorRecord
.
[[Done]]
is
false
, set
result
to
Completion
(
IteratorClose
(
iteratorRecord
,
result
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Return !
result
.
Note
This function requires its
this
value to be a
constructor
function that supports the parameter conventions of the Promise
constructor
.
27.2.4.1.1
GetPromiseResolve (
promiseConstructor
)
The abstract operation GetPromiseResolve takes argument
promiseConstructor
(a
constructor
) and returns either a
normal completion containing
a
function object
or a
throw completion
. It performs the following steps when called:
Let
promiseResolve
be ?
Get
(
promiseConstructor
,
"resolve"
).
If
IsCallable
(
promiseResolve
) is
false
, throw a
TypeError
exception.
Return
promiseResolve
.
27.2.4.1.2
PerformPromiseAll (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
The abstract operation PerformPromiseAll takes arguments
iteratorRecord
(an
Iterator Record
),
constructor
(a
constructor
),
resultCapability
(a
PromiseCapability Record
), and
promiseResolve
(a
function object
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
values
be a new empty
List
.
NOTE:
remainingElementsCount
starts at 1 instead of 0 to ensure
resultCapability
.
[[Resolve]]
is only called once, even in the presence of a misbehaving
"then"
which calls the passed callback before the input
iterator
is exhausted.
Let
remainingElementsCount
be the
Record
{
[[Value]]
: 1 }.
Let
index
be 0.
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
- 1.
If
remainingElementsCount
.
[[Value]]
= 0, then
Let
valuesArray
be
CreateArrayFromList
(
values
).
Perform ?
Call
(
resultCapability
.
[[Resolve]]
,
undefined
, «
valuesArray
»).
Return
resultCapability
.
[[Promise]]
.
Append
undefined
to
values
.
Let
nextPromise
be ?
Call
(
promiseResolve
,
constructor
, «
next
»).
Let
fulfilledSteps
be a new
Abstract Closure
with parameters (
value
) that captures
values
,
resultCapability
, and
remainingElementsCount
and performs the following steps when called:
Let
F
be the
active function object
.
If
F
.
[[AlreadyCalled]]
is
true
, return
undefined
.
Set
F
.
[[AlreadyCalled]]
to
true
.
Let
thisIndex
be
F
.
[[Index]]
.
Set
values
[
thisIndex
] to
value
.
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
- 1.
If
remainingElementsCount
.
[[Value]]
= 0, then
Let
valuesArray
be
CreateArrayFromList
(
values
).
Return ?
Call
(
resultCapability
.
[[Resolve]]
,
undefined
, «
valuesArray
»).
Return
undefined
.
Let
onFulfilled
be
CreateBuiltinFunction
(
fulfilledSteps
, 1,
""
, «
[[AlreadyCalled]]
,
[[Index]]
»).
Set
onFulfilled
.
[[AlreadyCalled]]
to
false
.
Set
onFulfilled
.
[[Index]]
to
index
.
Set
index
to
index
+ 1.
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
+ 1.
Perform ?
Invoke
(
nextPromise
,
"then"
, «
onFulfilled
,
resultCapability
.
[[Reject]]
»).
27.2.4.2
Promise.allSettled (
iterable
)
This function returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected. It resolves all elements of the passed
iterable
to promises as it runs this algorithm.
Let
C
be the
this
value.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Let
promiseResolve
be
Completion
(
GetPromiseResolve
(
C
)).
IfAbruptRejectPromise
(
promiseResolve
,
promiseCapability
).
Let
iteratorRecord
be
Completion
(
GetIterator
(
iterable
,
sync
)).
IfAbruptRejectPromise
(
iteratorRecord
,
promiseCapability
).
Let
result
be
Completion
(
PerformPromiseAllSettled
(
iteratorRecord
,
C
,
promiseCapability
,
promiseResolve
)).
If
result
is an
abrupt completion
, then
If
iteratorRecord
.
[[Done]]
is
false
, set
result
to
Completion
(
IteratorClose
(
iteratorRecord
,
result
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Return !
result
.
Note
This function requires its
this
value to be a
constructor
function that supports the parameter conventions of the Promise
constructor
.
27.2.4.2.1
PerformPromiseAllSettled (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
The abstract operation PerformPromiseAllSettled takes arguments
iteratorRecord
(an
Iterator Record
),
constructor
(a
constructor
),
resultCapability
(a
PromiseCapability Record
), and
promiseResolve
(a
function object
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
values
be a new empty
List
.
NOTE:
remainingElementsCount
starts at 1 instead of 0 to ensure
resultCapability
.
[[Resolve]]
is only called once, even in the presence of a misbehaving
"then"
which calls one of the passed callbacks before the input
iterator
is exhausted.
Let
remainingElementsCount
be the
Record
{
[[Value]]
: 1 }.
Let
index
be 0.
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
- 1.
If
remainingElementsCount
.
[[Value]]
= 0, then
Let
valuesArray
be
CreateArrayFromList
(
values
).
Perform ?
Call
(
resultCapability
.
[[Resolve]]
,
undefined
, «
valuesArray
»).
Return
resultCapability
.
[[Promise]]
.
Append
undefined
to
values
.
Let
nextPromise
be ?
Call
(
promiseResolve
,
constructor
, «
next
»).
Let
alreadyCalled
be the
Record
{
[[Value]]
:
false
}.
Let
fulfilledSteps
be a new
Abstract Closure
with parameters (
value
) that captures
values
,
resultCapability
, and
remainingElementsCount
and performs the following steps when called:
Let
F
be the
active function object
.
If
F
.
[[AlreadyCalled]]
.
[[Value]]
is
true
, return
undefined
.
Set
F
.
[[AlreadyCalled]]
.
[[Value]]
to
true
.
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"status"
,
"fulfilled"
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"value"
,
value
).
Let
thisIndex
be
F
.
[[Index]]
.
Set
values
[
thisIndex
] to
obj
.
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
- 1.
If
remainingElementsCount
.
[[Value]]
= 0, then
Let
valuesArray
be
CreateArrayFromList
(
values
).
Return ?
Call
(
resultCapability
.
[[Resolve]]
,
undefined
, «
valuesArray
»).
Return
undefined
.
Let
onFulfilled
be
CreateBuiltinFunction
(
fulfilledSteps
, 1,
""
, «
[[AlreadyCalled]]
,
[[Index]]
»).
Set
onFulfilled
.
[[AlreadyCalled]]
to
alreadyCalled
.
Set
onFulfilled
.
[[Index]]
to
index
.
Let
rejectedSteps
be a new
Abstract Closure
with parameters (
error
) that captures
values
,
resultCapability
, and
remainingElementsCount
and performs the following steps when called:
Let
F
be the
active function object
.
If
F
.
[[AlreadyCalled]]
.
[[Value]]
is
true
, return
undefined
.
Set
F
.
[[AlreadyCalled]]
.
[[Value]]
to
true
.
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"status"
,
"rejected"
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"reason"
,
error
).
Let
thisIndex
be
F
.
[[Index]]
.
Set
values
[
thisIndex
] to
obj
.
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
- 1.
If
remainingElementsCount
.
[[Value]]
= 0, then
Let
valuesArray
be
CreateArrayFromList
(
values
).
Return ?
Call
(
resultCapability
.
[[Resolve]]
,
undefined
, «
valuesArray
»).
Return
undefined
.
Let
onRejected
be
CreateBuiltinFunction
(
rejectedSteps
, 1,
""
, «
[[AlreadyCalled]]
,
[[Index]]
»).
Set
onRejected
.
[[AlreadyCalled]]
to
alreadyCalled
.
Set
onRejected
.
[[Index]]
to
index
.
Set
index
to
index
+ 1.
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
+ 1.
Perform ?
Invoke
(
nextPromise
,
"then"
, «
onFulfilled
,
onRejected
»).
27.2.4.3
Promise.any (
iterable
)
This function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an
AggregateError
holding the rejection reasons if all of the given promises are rejected. It resolves all elements of the passed
iterable
to promises as it runs this algorithm.
Let
C
be the
this
value.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Let
promiseResolve
be
Completion
(
GetPromiseResolve
(
C
)).
IfAbruptRejectPromise
(
promiseResolve
,
promiseCapability
).
Let
iteratorRecord
be
Completion
(
GetIterator
(
iterable
,
sync
)).
IfAbruptRejectPromise
(
iteratorRecord
,
promiseCapability
).
Let
result
be
Completion
(
PerformPromiseAny
(
iteratorRecord
,
C
,
promiseCapability
,
promiseResolve
)).
If
result
is an
abrupt completion
, then
If
iteratorRecord
.
[[Done]]
is
false
, set
result
to
Completion
(
IteratorClose
(
iteratorRecord
,
result
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Return !
result
.
Note
This function requires its
this
value to be a
constructor
function that supports the parameter conventions of the
Promise
constructor
.
27.2.4.3.1
PerformPromiseAny (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
The abstract operation PerformPromiseAny takes arguments
iteratorRecord
(an
Iterator Record
),
constructor
(a
constructor
),
resultCapability
(a
PromiseCapability Record
), and
promiseResolve
(a
function object
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
errors
be a new empty
List
.
NOTE:
remainingElementsCount
starts at 1 instead of 0 to ensure
resultCapability
.
[[Reject]]
is only called once, even in the presence of a misbehaving
"then"
which calls the passed callback before the input
iterator
is exhausted.
Let
remainingElementsCount
be the
Record
{
[[Value]]
: 1 }.
Let
index
be 0.
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
- 1.
If
remainingElementsCount
.
[[Value]]
= 0, then
Let
aggregateError
be a newly created
AggregateError
object.
Perform !
DefinePropertyOrThrow
(
aggregateError
,
"errors"
, PropertyDescriptor {
[[Configurable]]
:
true
,
[[Enumerable]]
:
false
,
[[Writable]]
:
true
,
[[Value]]
:
CreateArrayFromList
(
errors
) }).
Perform ?
Call
(
resultCapability
.
[[Reject]]
,
undefined
, «
aggregateError
»).
Return
resultCapability
.
[[Promise]]
.
Append
undefined
to
errors
.
Let
nextPromise
be ?
Call
(
promiseResolve
,
constructor
, «
next
»).
Let
rejectedSteps
be a new
Abstract Closure
with parameters (
error
) that captures
errors
,
resultCapability
, and
remainingElementsCount
and performs the following steps when called:
Let
F
be the
active function object
.
If
F
.
[[AlreadyCalled]]
is
true
, return
undefined
.
Set
F
.
[[AlreadyCalled]]
to
true
.
Let
thisIndex
be
F
.
[[Index]]
.
Set
errors
[
thisIndex
] to
error
.
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
- 1.
If
remainingElementsCount
.
[[Value]]
= 0, then
Let
aggregateError
be a newly created
AggregateError
object.
Perform !
DefinePropertyOrThrow
(
aggregateError
,
"errors"
, PropertyDescriptor {
[[Configurable]]
:
true
,
[[Enumerable]]
:
false
,
[[Writable]]
:
true
,
[[Value]]
:
CreateArrayFromList
(
errors
) }).
Return ?
Call
(
resultCapability
.
[[Reject]]
,
undefined
, «
aggregateError
»).
Return
undefined
.
Let
onRejected
be
CreateBuiltinFunction
(
rejectedSteps
, 1,
""
, «
[[AlreadyCalled]]
,
[[Index]]
»).
Set
onRejected
.
[[AlreadyCalled]]
to
false
.
Set
onRejected
.
[[Index]]
to
index
.
Set
index
to
index
+ 1.
Set
remainingElementsCount
.
[[Value]]
to
remainingElementsCount
.
[[Value]]
+ 1.
Perform ?
Invoke
(
nextPromise
,
"then"
, «
resultCapability
.
[[Resolve]]
,
onRejected
»).
27.2.4.4
Promise.prototype
The initial value of
Promise.prototype
is the
Promise prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
27.2.4.5
Promise.race (
iterable
)
This function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed
iterable
to promises as it runs this algorithm.
Let
C
be the
this
value.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Let
promiseResolve
be
Completion
(
GetPromiseResolve
(
C
)).
IfAbruptRejectPromise
(
promiseResolve
,
promiseCapability
).
Let
iteratorRecord
be
Completion
(
GetIterator
(
iterable
,
sync
)).
IfAbruptRejectPromise
(
iteratorRecord
,
promiseCapability
).
Let
result
be
Completion
(
PerformPromiseRace
(
iteratorRecord
,
C
,
promiseCapability
,
promiseResolve
)).
If
result
is an
abrupt completion
, then
If
iteratorRecord
.
[[Done]]
is
false
, set
result
to
Completion
(
IteratorClose
(
iteratorRecord
,
result
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Return !
result
.
Note 1
If the
iterable
argument yields no values or if none of the promises yielded by
iterable
ever settle, then the pending promise returned by this method will never be settled.
Note 2
This function expects its
this
value to be a
constructor
function that supports the parameter conventions of the Promise
constructor
. It also expects that its
this
value provides a
resolve
method.
27.2.4.5.1
PerformPromiseRace (
iteratorRecord
,
constructor
,
resultCapability
,
promiseResolve
)
The abstract operation PerformPromiseRace takes arguments
iteratorRecord
(an
Iterator Record
),
constructor
(a
constructor
),
resultCapability
(a
PromiseCapability Record
), and
promiseResolve
(a
function object
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Repeat,
Let
next
be ?
IteratorStepValue
(
iteratorRecord
).
If
next
is
done
, then
Return
resultCapability
.
[[Promise]]
.
Let
nextPromise
be ?
Call
(
promiseResolve
,
constructor
, «
next
»).
Perform ?
Invoke
(
nextPromise
,
"then"
, «
resultCapability
.
[[Resolve]]
,
resultCapability
.
[[Reject]]
»).
27.2.4.6
Promise.reject (
r
)
This function returns a new promise rejected with the passed argument.
Let
C
be the
this
value.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Perform ?
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
r
»).
Return
promiseCapability
.
[[Promise]]
.
Note
This function expects its
this
value to be a
constructor
function that supports the parameter conventions of the Promise
constructor
.
27.2.4.7
Promise.resolve (
x
)
This function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this
constructor
.
Let
C
be the
this
value.
If
C
is not an Object
, throw a
TypeError
exception.
Return ?
PromiseResolve
(
C
,
x
).
Note
This function expects its
this
value to be a
constructor
function that supports the parameter conventions of the Promise
constructor
.
27.2.4.7.1
PromiseResolve (
C
,
x
)
The abstract operation PromiseResolve takes arguments
C
(an Object) and
x
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It returns a new promise resolved with
x
. It performs the following steps when called:
If
IsPromise
(
x
) is
true
, then
Let
xConstructor
be ?
Get
(
x
,
"constructor"
).
If
SameValue
(
xConstructor
,
C
) is
true
, return
x
.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Perform ?
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
x
»).
Return
promiseCapability
.
[[Promise]]
.
27.2.4.8
Promise.try (
callback
, ...
args
)
This function performs the following steps when called:
Let
C
be the
this
value.
If
C
is not an Object
, throw a
TypeError
exception.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Let
status
be
Completion
(
Call
(
callback
,
undefined
,
args
)).
If
status
is an
abrupt completion
, then
Perform ?
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
status
.
[[Value]]
»).
Else,
Perform ?
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
status
.
[[Value]]
»).
Return
promiseCapability
.
[[Promise]]
.
Note
This function expects its
this
value to be a
constructor
function that supports the parameter conventions of the Promise
constructor
.
27.2.4.9
Promise.withResolvers ( )
This function returns an object with three properties: a new promise together with the
resolve
and
reject
functions associated with it.
Let
C
be the
this
value.
Let
promiseCapability
be ?
NewPromiseCapability
(
C
).
Let
obj
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"promise"
,
promiseCapability
.
[[Promise]]
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"resolve"
,
promiseCapability
.
[[Resolve]]
).
Perform !
CreateDataPropertyOrThrow
(
obj
,
"reject"
,
promiseCapability
.
[[Reject]]
).
Return
obj
.
27.2.4.10
get Promise [ %Symbol.species% ]
Promise[%Symbol.species%]
is an
accessor property
whose set accessor function is
undefined
. Its get accessor function performs the following steps when called:
Return the
this
value.
The value of the
"name"
property of this function is
"get [Symbol.species]"
.
Note
Promise prototype methods normally use their
this
value's
constructor
to create a derived object. However, a subclass
constructor
may over-ride that default behaviour by redefining its
%Symbol.species%
property.
27.2.5
Properties of the Promise Prototype Object
The
Promise prototype object
:
is
%Promise.prototype%
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is an
ordinary object
.
does not have a
[[PromiseState]]
internal slot or any of the other internal slots of Promise instances.
27.2.5.1
Promise.prototype.catch (
onRejected
)
This method performs the following steps when called:
Let
promise
be the
this
value.
Return ?
Invoke
(
promise
,
"then"
, «
undefined
,
onRejected
»).
27.2.5.2
Promise.prototype.constructor
The initial value of
Promise.prototype.constructor
is
%Promise%
.
27.2.5.3
Promise.prototype.finally (
onFinally
)
This method performs the following steps when called:
Let
promise
be the
this
value.
If
promise
is not an Object
, throw a
TypeError
exception.
Let
C
be ?
SpeciesConstructor
(
promise
,
%Promise%
).
Assert
:
IsConstructor
(
C
) is
true
.
If
IsCallable
(
onFinally
) is
false
, then
Let
thenFinally
be
onFinally
.
Let
catchFinally
be
onFinally
.
Else,
Let
thenFinallyClosure
be a new
Abstract Closure
with parameters (
value
) that captures
onFinally
and
C
and performs the following steps when called:
Let
result
be ?
Call
(
onFinally
,
undefined
).
Let
p
be ?
PromiseResolve
(
C
,
result
).
Let
returnValue
be a new
Abstract Closure
with no parameters that captures
value
and performs the following steps when called:
Return
NormalCompletion
(
value
).
Let
valueThunk
be
CreateBuiltinFunction
(
returnValue
, 0,
""
, « »).
Return ?
Invoke
(
p
,
"then"
, «
valueThunk
»).
Let
thenFinally
be
CreateBuiltinFunction
(
thenFinallyClosure
, 1,
""
, « »).
Let
catchFinallyClosure
be a new
Abstract Closure
with parameters (
reason
) that captures
onFinally
and
C
and performs the following steps when called:
Let
result
be ?
Call
(
onFinally
,
undefined
).
Let
p
be ?
PromiseResolve
(
C
,
result
).
Let
throwReason
be a new
Abstract Closure
with no parameters that captures
reason
and performs the following steps when called:
Return
ThrowCompletion
(
reason
).
Let
thrower
be
CreateBuiltinFunction
(
throwReason
, 0,
""
, « »).
Return ?
Invoke
(
p
,
"then"
, «
thrower
»).
Let
catchFinally
be
CreateBuiltinFunction
(
catchFinallyClosure
, 1,
""
, « »).
Return ?
Invoke
(
promise
,
"then"
, «
thenFinally
,
catchFinally
»).
27.2.5.4
Promise.prototype.then (
onFulfilled
,
onRejected
)
This method performs the following steps when called:
Let
promise
be the
this
value.
If
IsPromise
(
promise
) is
false
, throw a
TypeError
exception.
Let
C
be ?
SpeciesConstructor
(
promise
,
%Promise%
).
Let
resultCapability
be ?
NewPromiseCapability
(
C
).
Return
PerformPromiseThen
(
promise
,
onFulfilled
,
onRejected
,
resultCapability
).
27.2.5.4.1
PerformPromiseThen (
promise
,
onFulfilled
,
onRejected
[ ,
resultCapability
] )
The abstract operation PerformPromiseThen takes arguments
promise
(a Promise),
onFulfilled
(an
ECMAScript language value
), and
onRejected
(an
ECMAScript language value
) and optional argument
resultCapability
(a
PromiseCapability Record
) and returns an
ECMAScript language value
. It performs the “then” operation on
promise
using
onFulfilled
and
onRejected
as its settlement actions. If
resultCapability
is passed, the result is stored by updating
resultCapability
's promise. If it is not passed, then PerformPromiseThen is being called by a specification-internal operation where the result does not matter. It performs the following steps when called:
Assert
:
IsPromise
(
promise
) is
true
.
If
resultCapability
is not present, then
Set
resultCapability
to
undefined
.
If
IsCallable
(
onFulfilled
) is
false
, then
Let
onFulfilledJobCallback
be
empty
.
Else,
Let
onFulfilledJobCallback
be
HostMakeJobCallback
(
onFulfilled
).
If
IsCallable
(
onRejected
) is
false
, then
Let
onRejectedJobCallback
be
empty
.
Else,
Let
onRejectedJobCallback
be
HostMakeJobCallback
(
onRejected
).
Let
fulfillReaction
be the
PromiseReaction Record
{
[[Capability]]
:
resultCapability
,
[[Type]]
:
fulfill
,
[[Handler]]
:
onFulfilledJobCallback
}.
Let
rejectReaction
be the
PromiseReaction Record
{
[[Capability]]
:
resultCapability
,
[[Type]]
:
reject
,
[[Handler]]
:
onRejectedJobCallback
}.
If
promise
.
[[PromiseState]]
is
pending
, then
Append
fulfillReaction
to
promise
.
[[PromiseFulfillReactions]]
.
Append
rejectReaction
to
promise
.
[[PromiseRejectReactions]]
.
Else if
promise
.
[[PromiseState]]
is
fulfilled
, then
Let
value
be
promise
.
[[PromiseResult]]
.
Let
fulfillJob
be
NewPromiseReactionJob
(
fulfillReaction
,
value
).
Perform
HostEnqueuePromiseJob
(
fulfillJob
.
[[Job]]
,
fulfillJob
.
[[Realm]]
).
Else,
Assert
:
promise
.
[[PromiseState]]
is
rejected
.
Let
reason
be
promise
.
[[PromiseResult]]
.
If
promise
.
[[PromiseIsHandled]]
is
false
, perform
HostPromiseRejectionTracker
(
promise
,
"handle"
).
Let
rejectJob
be
NewPromiseReactionJob
(
rejectReaction
,
reason
).
Perform
HostEnqueuePromiseJob
(
rejectJob
.
[[Job]]
,
rejectJob
.
[[Realm]]
).
Set
promise
.
[[PromiseIsHandled]]
to
true
.
If
resultCapability
is
undefined
, then
Return
undefined
.
Else,
Return
resultCapability
.
[[Promise]]
.
27.2.5.5
Promise.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Promise"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.2.6
Properties of Promise Instances
Promise instances are
ordinary objects
that inherit properties from the
Promise prototype object
(the intrinsic,
%Promise.prototype%
). Promise instances are initially created with the internal slots described in
Table 87
.
Table 87: Internal Slots of Promise Instances
Internal Slot
Type
Description
[[PromiseState]]
pending
,
fulfilled
, or
rejected
Governs how a promise will react to incoming calls to its
then
method.
[[PromiseResult]]
an
ECMAScript language value
or
empty
The value with which the promise has been fulfilled or rejected, if any.
empty
if and only if the
[[PromiseState]]
is
pending
.
[[PromiseFulfillReactions]]
a
List
of
PromiseReaction Records
Records
to be processed when/if the promise transitions from the
pending
state to the
fulfilled
state.
[[PromiseRejectReactions]]
a
List
of
PromiseReaction Records
Records
to be processed when/if the promise transitions from the
pending
state to the
rejected
state.
[[PromiseIsHandled]]
a Boolean
Indicates whether the promise has ever had a fulfillment or rejection handler; used in unhandled rejection tracking.
27.3
GeneratorFunction Objects
GeneratorFunctions are functions that are usually created by evaluating
GeneratorDeclaration
s,
GeneratorExpression
s, and
GeneratorMethod
s. They may also be created by calling the
%GeneratorFunction%
intrinsic.
Figure 6 (Informative): Generator Objects Relationships
27.3.1
The GeneratorFunction Constructor
The GeneratorFunction
constructor
:
is
%GeneratorFunction%
.
is a subclass of
Function
.
creates and initializes a new GeneratorFunction when called as a function rather than as a
constructor
. Thus the function call
GeneratorFunction (…)
is equivalent to the object creation expression
new GeneratorFunction (…)
with the same arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified GeneratorFunction behaviour must include a
super
call to the GeneratorFunction
constructor
to create and initialize subclass instances with the internal slots necessary for built-in GeneratorFunction behaviour. All ECMAScript syntactic forms for defining generator
function objects
create direct instances of GeneratorFunction. There is no syntactic means to create instances of GeneratorFunction subclasses.
27.3.1.1
GeneratorFunction ( ...
parameterArgs
,
bodyArg
)
The last argument (if any) specifies the body (executable code) of a generator function; any preceding arguments specify formal parameters.
This function performs the following steps when called:
Let
C
be the
active function object
.
If
bodyArg
is not present, set
bodyArg
to the empty String.
Return ?
CreateDynamicFunction
(
C
, NewTarget,
generator
,
parameterArgs
,
bodyArg
).
Note
See NOTE for
20.2.1.1
.
27.3.2
Properties of the GeneratorFunction Constructor
The GeneratorFunction
constructor
:
is a standard built-in
function object
that inherits from the Function
constructor
.
has a
[[Prototype]]
internal slot whose value is
%Function%
.
has a
"length"
property whose value is
1
𝔽
.
has a
"name"
property whose value is
"GeneratorFunction"
.
has the following properties:
27.3.2.1
GeneratorFunction.prototype
The initial value of
GeneratorFunction.prototype
is the
GeneratorFunction prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
27.3.3
Properties of the GeneratorFunction Prototype Object
The
GeneratorFunction prototype object
:
is
%GeneratorFunction.prototype%
(see
Figure 6
).
is an
ordinary object
.
is not a
function object
and does not have an
[[ECMAScriptCode]]
internal slot or any other of the internal slots listed in
Table 25
or
Table 88
.
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
27.3.3.1
GeneratorFunction.prototype.constructor
The initial value of
GeneratorFunction.prototype.constructor
is
%GeneratorFunction%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.3.3.2
GeneratorFunction.prototype.prototype
The initial value of
GeneratorFunction.prototype.prototype
is
%GeneratorPrototype%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.3.3.3
GeneratorFunction.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"GeneratorFunction"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.3.4
GeneratorFunction Instances
Every GeneratorFunction instance is an ECMAScript
function object
and has the internal slots listed in
Table 25
. The value of the
[[IsClassConstructor]]
internal slot for all such instances is
false
.
Each GeneratorFunction instance has the following own properties:
27.3.4.1
length
The specification for the
"length"
property of Function instances given in
20.2.4.1
also applies to GeneratorFunction instances.
27.3.4.2
name
The specification for the
"name"
property of Function instances given in
20.2.4.2
also applies to GeneratorFunction instances.
27.3.4.3
prototype
Whenever a GeneratorFunction instance is created another
ordinary object
is also created and is the initial value of the generator function's
"prototype"
property. The value of the prototype property is used to initialize the
[[Prototype]]
internal slot of a newly created Generator when the generator
function object
is invoked using
[[Call]]
.
This property has the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
Unlike Function instances, the object that is the value of a GeneratorFunction's
"prototype"
property does not have a
"constructor"
property whose value is the GeneratorFunction instance.
27.4
AsyncGeneratorFunction Objects
AsyncGeneratorFunctions are functions that are usually created by evaluating
AsyncGeneratorDeclaration
,
AsyncGeneratorExpression
, and
AsyncGeneratorMethod
syntactic productions. They may also be created by calling the
%AsyncGeneratorFunction%
intrinsic.
27.4.1
The AsyncGeneratorFunction Constructor
The AsyncGeneratorFunction
constructor
:
is
%AsyncGeneratorFunction%
.
is a subclass of
Function
.
creates and initializes a new AsyncGeneratorFunction when called as a function rather than as a
constructor
. Thus the function call
AsyncGeneratorFunction (...)
is equivalent to the object creation expression
new AsyncGeneratorFunction (...)
with the same arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified AsyncGeneratorFunction behaviour must include a
super
call to the AsyncGeneratorFunction
constructor
to create and initialize subclass instances with the internal slots necessary for built-in AsyncGeneratorFunction behaviour. All ECMAScript syntactic forms for defining async generator
function objects
create direct instances of AsyncGeneratorFunction. There is no syntactic means to create instances of AsyncGeneratorFunction subclasses.
27.4.1.1
AsyncGeneratorFunction ( ...
parameterArgs
,
bodyArg
)
The last argument (if any) specifies the body (executable code) of an async generator function; any preceding arguments specify formal parameters.
This function performs the following steps when called:
Let
C
be the
active function object
.
If
bodyArg
is not present, set
bodyArg
to the empty String.
Return ?
CreateDynamicFunction
(
C
, NewTarget,
async-generator
,
parameterArgs
,
bodyArg
).
Note
See NOTE for
20.2.1.1
.
27.4.2
Properties of the AsyncGeneratorFunction Constructor
The AsyncGeneratorFunction
constructor
:
is a standard built-in
function object
that inherits from the Function
constructor
.
has a
[[Prototype]]
internal slot whose value is
%Function%
.
has a
"length"
property whose value is
1
𝔽
.
has a
"name"
property whose value is
"AsyncGeneratorFunction"
.
has the following properties:
27.4.2.1
AsyncGeneratorFunction.prototype
The initial value of
AsyncGeneratorFunction.prototype
is the
AsyncGeneratorFunction prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
27.4.3
Properties of the AsyncGeneratorFunction Prototype Object
The
AsyncGeneratorFunction prototype object
:
is
%AsyncGeneratorFunction.prototype%
.
is an
ordinary object
.
is not a
function object
and does not have an
[[ECMAScriptCode]]
internal slot or any other of the internal slots listed in
Table 25
or
Table 89
.
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
27.4.3.1
AsyncGeneratorFunction.prototype.constructor
The initial value of
AsyncGeneratorFunction.prototype.constructor
is
%AsyncGeneratorFunction%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.4.3.2
AsyncGeneratorFunction.prototype.prototype
The initial value of
AsyncGeneratorFunction.prototype.prototype
is
%AsyncGeneratorPrototype%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.4.3.3
AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"AsyncGeneratorFunction"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.4.4
AsyncGeneratorFunction Instances
Every AsyncGeneratorFunction instance is an ECMAScript
function object
and has the internal slots listed in
Table 25
. The value of the
[[IsClassConstructor]]
internal slot for all such instances is
false
.
Each AsyncGeneratorFunction instance has the following own properties:
27.4.4.1
length
The value of the
"length"
property is an
integral Number
that indicates the typical number of arguments expected by the AsyncGeneratorFunction. However, the language permits the function to be invoked with some other number of arguments. The behaviour of an AsyncGeneratorFunction when invoked on a number of arguments other than the number specified by its
"length"
property depends on the function.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.4.4.2
name
The specification for the
"name"
property of Function instances given in
20.2.4.2
also applies to AsyncGeneratorFunction instances.
27.4.4.3
prototype
Whenever an AsyncGeneratorFunction instance is created, another
ordinary object
is also created and is the initial value of the async generator function's
"prototype"
property. The value of the prototype property is used to initialize the
[[Prototype]]
internal slot of a newly created AsyncGenerator when the generator
function object
is invoked using
[[Call]]
.
This property has the attributes {
[[Writable]]
:
true
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
Note
Unlike function instances, the object that is the value of an AsyncGeneratorFunction's
"prototype"
property does not have a
"constructor"
property whose value is the AsyncGeneratorFunction instance.
27.5
Generator Objects
A Generator is created by calling a generator function and conforms to both the
iterator interface
and the
iterable interface
.
Generator instances directly inherit properties from the initial value of the
"prototype"
property of the generator function that created the instance. Generator instances indirectly inherit properties from
%GeneratorPrototype%
.
27.5.1
The %GeneratorPrototype% Object
The
%GeneratorPrototype%
object:
is
%GeneratorFunction.prototype.prototype%
.
is an
ordinary object
.
is not a Generator instance and does not have a
[[GeneratorState]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%Iterator.prototype%
.
has properties that are indirectly inherited by all Generator instances.
27.5.1.1
%GeneratorPrototype%.constructor
The initial value of
%GeneratorPrototype%
.constructor
is
%GeneratorFunction.prototype%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.5.1.2
%GeneratorPrototype%.next (
value
)
Return ?
GeneratorResume
(
this
value,
value
,
empty
).
27.5.1.3
%GeneratorPrototype%.return (
value
)
This method performs the following steps when called:
Let
g
be the
this
value.
Let
C
be
ReturnCompletion
(
value
).
Return ?
GeneratorResumeAbrupt
(
g
,
C
,
empty
).
27.5.1.4
%GeneratorPrototype%.throw (
exception
)
This method performs the following steps when called:
Let
g
be the
this
value.
Let
C
be
ThrowCompletion
(
exception
).
Return ?
GeneratorResumeAbrupt
(
g
,
C
,
empty
).
27.5.1.5
%GeneratorPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Generator"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.5.2
Properties of Generator Instances
Generator instances are initially created with the internal slots described in
Table 88
.
Table 88: Internal Slots of Generator Instances
Internal Slot
Type
Description
[[GeneratorState]]
suspended-start
,
suspended-yield
,
executing
, or
completed
The current execution state of the generator.
[[GeneratorContext]]
an
execution context
The
execution context
that is used when executing the code of this generator.
[[GeneratorBrand]]
a String or
empty
A brand used to distinguish different kinds of generators. The
[[GeneratorBrand]]
of generators declared by
ECMAScript source text
is always
empty
.
27.5.3
Generator Abstract Operations
27.5.3.1
GeneratorStart (
generator
,
generatorBody
)
The abstract operation GeneratorStart takes arguments
generator
(a Generator) and
generatorBody
(a
FunctionBody
Parse Node
or an
Abstract Closure
with no parameters) and returns
unused
. It performs the following steps when called:
Assert
:
generator
.
[[GeneratorState]]
is
suspended-start
.
Let
genContext
be the
running execution context
.
Set the Generator component of
genContext
to
generator
.
Let
closure
be a new
Abstract Closure
with no parameters that captures
generatorBody
and performs the following steps when called:
Let
acGenContext
be the
running execution context
.
Let
acGenerator
be the Generator component of
acGenContext
.
If
generatorBody
is a
Parse Node
, then
Let
result
be
Completion
(
Evaluation
of
generatorBody
).
Else,
Assert
:
generatorBody
is an
Abstract Closure
with no parameters.
Let
result
be
Completion
(
generatorBody
()).
Assert
: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
Remove
acGenContext
from the
execution context stack
and restore the
execution context
that is at the top of the
execution context stack
as the
running execution context
.
Set
acGenerator
.
[[GeneratorState]]
to
completed
.
NOTE: Once a generator enters the
completed
state it never leaves it and its associated
execution context
is never resumed. Any execution state associated with
acGenerator
can be discarded at this point.
If
result
is a
normal completion
, then
Let
resultValue
be
undefined
.
Else if
result
is a
return completion
, then
Let
resultValue
be
result
.
[[Value]]
.
Else,
Assert
:
result
is a
throw completion
.
Return ?
result
.
Return
NormalCompletion
(
CreateIteratorResultObject
(
resultValue
,
true
)).
Set the code evaluation state of
genContext
such that when evaluation is resumed for that
execution context
,
closure
will be called with no arguments.
Set
generator
.
[[GeneratorContext]]
to
genContext
.
Return
unused
.
27.5.3.2
GeneratorValidate (
generator
,
generatorBrand
)
The abstract operation GeneratorValidate takes arguments
generator
(an
ECMAScript language value
) and
generatorBrand
(a String or
empty
) and returns either a
normal completion containing
one of
suspended-start
,
suspended-yield
, or
completed
, or a
throw completion
. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
generator
,
[[GeneratorState]]
).
Perform ?
RequireInternalSlot
(
generator
,
[[GeneratorBrand]]
).
If
generator
.
[[GeneratorBrand]]
is not
generatorBrand
, throw a
TypeError
exception.
Assert
:
generator
has a
[[GeneratorContext]]
internal slot.
Let
state
be
generator
.
[[GeneratorState]]
.
If
state
is
executing
, throw a
TypeError
exception.
Return
state
.
27.5.3.3
GeneratorResume (
generator
,
value
,
generatorBrand
)
The abstract operation GeneratorResume takes arguments
generator
(an
ECMAScript language value
),
value
(an
ECMAScript language value
or
empty
), and
generatorBrand
(a String or
empty
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
state
be ?
GeneratorValidate
(
generator
,
generatorBrand
).
If
state
is
completed
, return
CreateIteratorResultObject
(
undefined
,
true
).
Assert
:
state
is either
suspended-start
or
suspended-yield
.
Let
genContext
be
generator
.
[[GeneratorContext]]
.
Let
methodContext
be the
running execution context
.
Suspend
methodContext
.
Set
generator
.
[[GeneratorState]]
to
executing
.
Push
genContext
onto the
execution context stack
;
genContext
is now the
running execution context
.
Resume the suspended evaluation of
genContext
using
NormalCompletion
(
value
) as the result of the operation that suspended it. Let
result
be the value returned by the resumed computation.
Assert
: When we return here,
genContext
has already been removed from the
execution context stack
and
methodContext
is the currently
running execution context
.
Return ?
result
.
27.5.3.4
GeneratorResumeAbrupt (
generator
,
abruptCompletion
,
generatorBrand
)
The abstract operation GeneratorResumeAbrupt takes arguments
generator
(an
ECMAScript language value
),
abruptCompletion
(a
return completion
or a
throw completion
), and
generatorBrand
(a String or
empty
) and returns either a
normal completion containing
an
ECMAScript language value
or a
throw completion
. It performs the following steps when called:
Let
state
be ?
GeneratorValidate
(
generator
,
generatorBrand
).
If
state
is
suspended-start
, then
Set
generator
.
[[GeneratorState]]
to
completed
.
NOTE: Once a generator enters the
completed
state it never leaves it and its associated
execution context
is never resumed. Any execution state associated with
generator
can be discarded at this point.
Set
state
to
completed
.
If
state
is
completed
, then
If
abruptCompletion
is a
return completion
, then
Return
CreateIteratorResultObject
(
abruptCompletion
.
[[Value]]
,
true
).
Return ?
abruptCompletion
.
Assert
:
state
is
suspended-yield
.
Let
genContext
be
generator
.
[[GeneratorContext]]
.
Let
methodContext
be the
running execution context
.
Suspend
methodContext
.
Set
generator
.
[[GeneratorState]]
to
executing
.
Push
genContext
onto the
execution context stack
;
genContext
is now the
running execution context
.
Resume the suspended evaluation of
genContext
using
abruptCompletion
as the result of the operation that suspended it. Let
result
be the
Completion Record
returned by the resumed computation.
Assert
: When we return here,
genContext
has already been removed from the
execution context stack
and
methodContext
is the currently
running execution context
.
Return ?
result
.
27.5.3.5
GetGeneratorKind ( )
The abstract operation GetGeneratorKind takes no arguments and returns
non-generator
,
sync
, or
async
. It performs the following steps when called:
Let
genContext
be the
running execution context
.
If
genContext
does not have a Generator component, return
non-generator
.
Let
generator
be the Generator component of
genContext
.
If
generator
has an
[[AsyncGeneratorState]]
internal slot, return
async
.
Else, return
sync
.
27.5.3.6
GeneratorYield (
iteratorResult
)
The abstract operation GeneratorYield takes argument
iteratorResult
(an Object that conforms to the
IteratorResult interface
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
Let
genContext
be the
running execution context
.
Assert
:
genContext
is the
execution context
of a generator.
Let
generator
be the value of the Generator component of
genContext
.
Assert
:
GetGeneratorKind
() is
sync
.
Set
generator
.
[[GeneratorState]]
to
suspended-yield
.
Remove
genContext
from the
execution context stack
and restore the
execution context
that is at the top of the
execution context stack
as the
running execution context
.
Let
callerContext
be the
running execution context
.
Resume
callerContext
passing
NormalCompletion
(
iteratorResult
). If
genContext
is ever resumed again, let
resumptionValue
be the
Completion Record
with which it is resumed.
Assert
: If control reaches here, then
genContext
is the
running execution context
again.
Return
resumptionValue
.
27.5.3.7
Yield (
value
)
The abstract operation Yield takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
Let
generatorKind
be
GetGeneratorKind
().
If
generatorKind
is
async
, return ?
AsyncGeneratorYield
(?
Await
(
value
)).
Otherwise, return ?
GeneratorYield
(
CreateIteratorResultObject
(
value
,
false
)).
27.5.3.8
CreateIteratorFromClosure (
closure
,
generatorBrand
,
generatorPrototype
[ ,
extraSlots
] )
The abstract operation CreateIteratorFromClosure takes arguments
closure
(an
Abstract Closure
with no parameters),
generatorBrand
(a String or
empty
), and
generatorPrototype
(an Object) and optional argument
extraSlots
(a
List
of names of internal slots) and returns a Generator. It performs the following steps when called:
NOTE:
closure
can contain uses of the
Yield
operation to yield an
IteratorResult object
.
If
extraSlots
is not present, set
extraSlots
to a new empty
List
.
Let
internalSlotsList
be the
list-concatenation
of
extraSlots
and «
[[GeneratorState]]
,
[[GeneratorContext]]
,
[[GeneratorBrand]]
».
Let
generator
be
OrdinaryObjectCreate
(
generatorPrototype
,
internalSlotsList
).
Set
generator
.
[[GeneratorBrand]]
to
generatorBrand
.
Set
generator
.
[[GeneratorState]]
to
suspended-start
.
Let
callerContext
be the
running execution context
.
Let
calleeContext
be a new
execution context
.
Set the Function of
calleeContext
to
null
.
Set the
Realm
of
calleeContext
to
the current Realm Record
.
Set the ScriptOrModule of
calleeContext
to
callerContext
's ScriptOrModule.
If
callerContext
is not already suspended, suspend
callerContext
.
Push
calleeContext
onto the
execution context stack
;
calleeContext
is now the
running execution context
.
Perform
GeneratorStart
(
generator
,
closure
).
Remove
calleeContext
from the
execution context stack
and restore
callerContext
as the
running execution context
.
Return
generator
.
27.6
AsyncGenerator Objects
An AsyncGenerator is created by calling an async generator function and conforms to both the
async iterator interface
and the
async iterable interface
.
AsyncGenerator instances directly inherit properties from the initial value of the
"prototype"
property of the async generator function that created the instance. AsyncGenerator instances indirectly inherit properties from
%AsyncGeneratorPrototype%
.
27.6.1
The %AsyncGeneratorPrototype% Object
The
%AsyncGeneratorPrototype%
object:
is
%AsyncGeneratorFunction.prototype.prototype%
.
is an
ordinary object
.
is not an AsyncGenerator instance and does not have an
[[AsyncGeneratorState]]
internal slot.
has a
[[Prototype]]
internal slot whose value is
%AsyncIteratorPrototype%
.
has properties that are indirectly inherited by all AsyncGenerator instances.
27.6.1.1
%AsyncGeneratorPrototype%.constructor
The initial value of
%AsyncGeneratorPrototype%
.constructor
is
%AsyncGeneratorFunction.prototype%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.6.1.2
%AsyncGeneratorPrototype%.next (
value
)
Let
generator
be the
this
value.
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
result
be
Completion
(
AsyncGeneratorValidate
(
generator
,
empty
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Let
state
be
generator
.
[[AsyncGeneratorState]]
.
If
state
is
completed
, then
Let
iteratorResult
be
CreateIteratorResultObject
(
undefined
,
true
).
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
iteratorResult
»).
Return
promiseCapability
.
[[Promise]]
.
Let
completion
be
NormalCompletion
(
value
).
Perform
AsyncGeneratorEnqueue
(
generator
,
completion
,
promiseCapability
).
If
state
is either
suspended-start
or
suspended-yield
, then
Perform
AsyncGeneratorResume
(
generator
,
completion
).
Else,
Assert
:
state
is either
executing
or
draining-queue
.
Return
promiseCapability
.
[[Promise]]
.
27.6.1.3
%AsyncGeneratorPrototype%.return (
value
)
Let
generator
be the
this
value.
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
result
be
Completion
(
AsyncGeneratorValidate
(
generator
,
empty
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Let
completion
be
ReturnCompletion
(
value
).
Perform
AsyncGeneratorEnqueue
(
generator
,
completion
,
promiseCapability
).
Let
state
be
generator
.
[[AsyncGeneratorState]]
.
If
state
is either
suspended-start
or
completed
, then
Set
generator
.
[[AsyncGeneratorState]]
to
draining-queue
.
Perform
AsyncGeneratorAwaitReturn
(
generator
).
Else if
state
is
suspended-yield
, then
Perform
AsyncGeneratorResume
(
generator
,
completion
).
Else,
Assert
:
state
is either
executing
or
draining-queue
.
Return
promiseCapability
.
[[Promise]]
.
27.6.1.4
%AsyncGeneratorPrototype%.throw (
exception
)
Let
generator
be the
this
value.
Let
promiseCapability
be !
NewPromiseCapability
(
%Promise%
).
Let
result
be
Completion
(
AsyncGeneratorValidate
(
generator
,
empty
)).
IfAbruptRejectPromise
(
result
,
promiseCapability
).
Let
state
be
generator
.
[[AsyncGeneratorState]]
.
If
state
is
suspended-start
, then
Set
generator
.
[[AsyncGeneratorState]]
to
completed
.
Set
state
to
completed
.
If
state
is
completed
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
exception
»).
Return
promiseCapability
.
[[Promise]]
.
Let
completion
be
ThrowCompletion
(
exception
).
Perform
AsyncGeneratorEnqueue
(
generator
,
completion
,
promiseCapability
).
If
state
is
suspended-yield
, then
Perform
AsyncGeneratorResume
(
generator
,
completion
).
Else,
Assert
:
state
is either
executing
or
draining-queue
.
Return
promiseCapability
.
[[Promise]]
.
27.6.1.5
%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"AsyncGenerator"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.6.2
Properties of AsyncGenerator Instances
AsyncGenerator instances are initially created with the internal slots described below:
Table 89: Internal Slots of AsyncGenerator Instances
Internal Slot
Type
Description
[[AsyncGeneratorState]]
suspended-start
,
suspended-yield
,
executing
,
draining-queue
, or
completed
The current execution state of the async generator.
[[AsyncGeneratorContext]]
an
execution context
The
execution context
that is used when executing the code of this async generator.
[[AsyncGeneratorQueue]]
a
List
of
AsyncGeneratorRequest
Records
Records
which represent requests to resume the async generator. Except during state transitions, it is non-empty if and only if
[[AsyncGeneratorState]]
is either
executing
or
draining-queue
.
[[GeneratorBrand]]
a String or
empty
A brand used to distinguish different kinds of async generators. The
[[GeneratorBrand]]
of async generators declared by
ECMAScript source text
is always
empty
.
27.6.3
AsyncGenerator Abstract Operations
27.6.3.1
AsyncGeneratorRequest Records
An
AsyncGeneratorRequest
is a
Record
value used to store information about how an async generator should be resumed and contains capabilities for fulfilling or rejecting the corresponding promise.
They have the following fields:
Table 90: AsyncGeneratorRequest
Record
Fields
Field Name
Value
Meaning
[[Completion]]
a
Completion Record
The
Completion Record
which should be used to resume the async generator.
[[Capability]]
a
PromiseCapability Record
The promise capabilities associated with this request.
27.6.3.2
AsyncGeneratorStart (
generator
,
generatorBody
)
The abstract operation AsyncGeneratorStart takes arguments
generator
(an AsyncGenerator) and
generatorBody
(a
FunctionBody
Parse Node
or an
Abstract Closure
with no parameters) and returns
unused
. It performs the following steps when called:
Assert
:
generator
.
[[AsyncGeneratorState]]
is
suspended-start
.
Let
genContext
be the
running execution context
.
Set the Generator component of
genContext
to
generator
.
Let
closure
be a new
Abstract Closure
with no parameters that captures
generatorBody
and performs the following steps when called:
Let
acGenContext
be the
running execution context
.
Let
acGenerator
be the Generator component of
acGenContext
.
If
generatorBody
is a
Parse Node
, then
Let
result
be
Completion
(
Evaluation
of
generatorBody
).
Else,
Assert
:
generatorBody
is an
Abstract Closure
with no parameters.
Let
result
be
Completion
(
generatorBody
()).
Assert
: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
Remove
acGenContext
from the
execution context stack
and restore the
execution context
that is at the top of the
execution context stack
as the
running execution context
.
Set
acGenerator
.
[[AsyncGeneratorState]]
to
draining-queue
.
If
result
is a
normal completion
, set
result
to
NormalCompletion
(
undefined
).
If
result
is a
return completion
, set
result
to
NormalCompletion
(
result
.
[[Value]]
).
Perform
AsyncGeneratorCompleteStep
(
acGenerator
,
result
,
true
).
Perform
AsyncGeneratorDrainQueue
(
acGenerator
).
Return
NormalCompletion
(
undefined
).
Set the code evaluation state of
genContext
such that when evaluation is resumed for that
execution context
,
closure
will be called with no arguments.
Set
generator
.
[[AsyncGeneratorContext]]
to
genContext
.
Set
generator
.
[[AsyncGeneratorQueue]]
to a new empty
List
.
Return
unused
.
27.6.3.3
AsyncGeneratorValidate (
generator
,
generatorBrand
)
The abstract operation AsyncGeneratorValidate takes arguments
generator
(an
ECMAScript language value
) and
generatorBrand
(a String or
empty
) and returns either a
normal completion containing
unused
or a
throw completion
. It performs the following steps when called:
Perform ?
RequireInternalSlot
(
generator
,
[[AsyncGeneratorContext]]
).
Perform ?
RequireInternalSlot
(
generator
,
[[AsyncGeneratorState]]
).
Perform ?
RequireInternalSlot
(
generator
,
[[AsyncGeneratorQueue]]
).
If
generator
.
[[GeneratorBrand]]
is not
generatorBrand
, throw a
TypeError
exception.
Return
unused
.
27.6.3.4
AsyncGeneratorEnqueue (
generator
,
completion
,
promiseCapability
)
The abstract operation AsyncGeneratorEnqueue takes arguments
generator
(an AsyncGenerator),
completion
(a
Completion Record
), and
promiseCapability
(a
PromiseCapability Record
) and returns
unused
. It performs the following steps when called:
Let
request
be
AsyncGeneratorRequest
{
[[Completion]]
:
completion
,
[[Capability]]
:
promiseCapability
}.
Append
request
to
generator
.
[[AsyncGeneratorQueue]]
.
Return
unused
.
27.6.3.5
AsyncGeneratorCompleteStep (
generator
,
completion
,
done
[ ,
realm
] )
The abstract operation AsyncGeneratorCompleteStep takes arguments
generator
(an AsyncGenerator),
completion
(a
Completion Record
), and
done
(a Boolean) and optional argument
realm
(a
Realm Record
) and returns
unused
. It performs the following steps when called:
Assert
:
generator
.
[[AsyncGeneratorQueue]]
is not empty.
Let
next
be the first element of
generator
.
[[AsyncGeneratorQueue]]
.
Remove the first element from
generator
.
[[AsyncGeneratorQueue]]
.
Let
promiseCapability
be
next
.
[[Capability]]
.
Let
value
be
completion
.
[[Value]]
.
If
completion
is a
throw completion
, then
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
value
»).
Else,
Assert
:
completion
is a
normal completion
.
If
realm
is present, then
Let
oldRealm
be the
running execution context
's
Realm
.
Set the
running execution context
's
Realm
to
realm
.
Let
iteratorResult
be
CreateIteratorResultObject
(
value
,
done
).
Set the
running execution context
's
Realm
to
oldRealm
.
Else,
Let
iteratorResult
be
CreateIteratorResultObject
(
value
,
done
).
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
iteratorResult
»).
Return
unused
.
27.6.3.6
AsyncGeneratorResume (
generator
,
completion
)
The abstract operation AsyncGeneratorResume takes arguments
generator
(an AsyncGenerator) and
completion
(a
Completion Record
) and returns
unused
. It performs the following steps when called:
Assert
:
generator
.
[[AsyncGeneratorState]]
is either
suspended-start
or
suspended-yield
.
Let
genContext
be
generator
.
[[AsyncGeneratorContext]]
.
Let
callerContext
be the
running execution context
.
Suspend
callerContext
.
Set
generator
.
[[AsyncGeneratorState]]
to
executing
.
Push
genContext
onto the
execution context stack
;
genContext
is now the
running execution context
.
Resume the suspended evaluation of
genContext
using
completion
as the result of the operation that suspended it. Let
result
be the
Completion Record
returned by the resumed computation.
Assert
:
result
is never an
abrupt completion
.
Assert
: When we return here,
genContext
has already been removed from the
execution context stack
and
callerContext
is the currently
running execution context
.
Return
unused
.
27.6.3.7
AsyncGeneratorUnwrapYieldResumption (
resumptionValue
)
The abstract operation AsyncGeneratorUnwrapYieldResumption takes argument
resumptionValue
(a
Completion Record
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
If
resumptionValue
is not a
return completion
, return ?
resumptionValue
.
Let
awaited
be
Completion
(
Await
(
resumptionValue
.
[[Value]]
)).
If
awaited
is a
throw completion
, return ?
awaited
.
Assert
:
awaited
is a
normal completion
.
Return
ReturnCompletion
(
awaited
.
[[Value]]
).
27.6.3.8
AsyncGeneratorYield (
value
)
The abstract operation AsyncGeneratorYield takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
an
ECMAScript language value
or an
abrupt completion
. It performs the following steps when called:
Let
genContext
be the
running execution context
.
Assert
:
genContext
is the
execution context
of a generator.
Let
generator
be the value of the Generator component of
genContext
.
Assert
:
GetGeneratorKind
() is
async
.
Let
completion
be
NormalCompletion
(
value
).
Assert
: The
execution context stack
has at least two elements.
Let
previousContext
be the second to top element of the
execution context stack
.
Let
previousRealm
be
previousContext
's
Realm
.
Perform
AsyncGeneratorCompleteStep
(
generator
,
completion
,
false
,
previousRealm
).
Let
queue
be
generator
.
[[AsyncGeneratorQueue]]
.
If
queue
is not empty, then
NOTE: Execution continues without suspending the generator.
Let
toYield
be the first element of
queue
.
Let
resumptionValue
be
Completion
(
toYield
.
[[Completion]]
).
Return ?
AsyncGeneratorUnwrapYieldResumption
(
resumptionValue
).
Else,
Set
generator
.
[[AsyncGeneratorState]]
to
suspended-yield
.
Remove
genContext
from the
execution context stack
and restore the
execution context
that is at the top of the
execution context stack
as the
running execution context
.
Let
callerContext
be the
running execution context
.
Resume
callerContext
passing
undefined
. If
genContext
is ever resumed again, let
resumptionValue
be the
Completion Record
with which it is resumed.
Assert
: If control reaches here, then
genContext
is the
running execution context
again.
Return ?
AsyncGeneratorUnwrapYieldResumption
(
resumptionValue
).
27.6.3.9
AsyncGeneratorAwaitReturn (
generator
)
The abstract operation AsyncGeneratorAwaitReturn takes argument
generator
(an AsyncGenerator) and returns
unused
. It performs the following steps when called:
Assert
:
generator
.
[[AsyncGeneratorState]]
is
draining-queue
.
Let
queue
be
generator
.
[[AsyncGeneratorQueue]]
.
Assert
:
queue
is not empty.
Let
next
be the first element of
queue
.
Let
completion
be
Completion
(
next
.
[[Completion]]
).
Assert
:
completion
is a
return completion
.
Let
promiseCompletion
be
Completion
(
PromiseResolve
(
%Promise%
,
completion
.
[[Value]]
)).
If
promiseCompletion
is an
abrupt completion
, then
Perform
AsyncGeneratorCompleteStep
(
generator
,
promiseCompletion
,
true
).
Perform
AsyncGeneratorDrainQueue
(
generator
).
Return
unused
.
Assert
:
promiseCompletion
is a
normal completion
.
Let
promise
be
promiseCompletion
.
[[Value]]
.
Let
fulfilledClosure
be a new
Abstract Closure
with parameters (
value
) that captures
generator
and performs the following steps when called:
Assert
:
generator
.
[[AsyncGeneratorState]]
is
draining-queue
.
Let
result
be
NormalCompletion
(
value
).
Perform
AsyncGeneratorCompleteStep
(
generator
,
result
,
true
).
Perform
AsyncGeneratorDrainQueue
(
generator
).
Return
NormalCompletion
(
undefined
).
Let
onFulfilled
be
CreateBuiltinFunction
(
fulfilledClosure
, 1,
""
, « »).
Let
rejectedClosure
be a new
Abstract Closure
with parameters (
reason
) that captures
generator
and performs the following steps when called:
Assert
:
generator
.
[[AsyncGeneratorState]]
is
draining-queue
.
Let
result
be
ThrowCompletion
(
reason
).
Perform
AsyncGeneratorCompleteStep
(
generator
,
result
,
true
).
Perform
AsyncGeneratorDrainQueue
(
generator
).
Return
NormalCompletion
(
undefined
).
Let
onRejected
be
CreateBuiltinFunction
(
rejectedClosure
, 1,
""
, « »).
Perform
PerformPromiseThen
(
promise
,
onFulfilled
,
onRejected
).
Return
unused
.
27.6.3.10
AsyncGeneratorDrainQueue (
generator
)
The abstract operation AsyncGeneratorDrainQueue takes argument
generator
(an AsyncGenerator) and returns
unused
. It drains the generator's AsyncGeneratorQueue until it encounters an
AsyncGeneratorRequest
which holds a
return completion
. It performs the following steps when called:
Assert
:
generator
.
[[AsyncGeneratorState]]
is
draining-queue
.
Let
queue
be
generator
.
[[AsyncGeneratorQueue]]
.
Repeat, while
queue
is not empty,
Let
next
be the first element of
queue
.
Let
completion
be
Completion
(
next
.
[[Completion]]
).
If
completion
is a
return completion
, then
Perform
AsyncGeneratorAwaitReturn
(
generator
).
Return
unused
.
Else,
If
completion
is a
normal completion
, then
Set
completion
to
NormalCompletion
(
undefined
).
Perform
AsyncGeneratorCompleteStep
(
generator
,
completion
,
true
).
Set
generator
.
[[AsyncGeneratorState]]
to
completed
.
Return
unused
.
27.7
AsyncFunction Objects
AsyncFunctions are functions that are usually created by evaluating
AsyncFunctionDeclaration
s,
AsyncFunctionExpression
s,
AsyncMethod
s, and
AsyncArrowFunction
s. They may also be created by calling the
%AsyncFunction%
intrinsic.
27.7.1
The AsyncFunction Constructor
The AsyncFunction
constructor
:
is
%AsyncFunction%
.
is a subclass of
Function
.
creates and initializes a new AsyncFunction when called as a function rather than as a
constructor
. Thus the function call
AsyncFunction(…)
is equivalent to the object creation expression
new AsyncFunction(…)
with the same arguments.
may be used as the value of an
extends
clause of a class definition. Subclass
constructors
that intend to inherit the specified AsyncFunction behaviour must include a
super
call to the AsyncFunction
constructor
to create and initialize a subclass instance with the internal slots necessary for built-in async function behaviour. All ECMAScript syntactic forms for defining async
function objects
create direct instances of AsyncFunction. There is no syntactic means to create instances of AsyncFunction subclasses.
27.7.1.1
AsyncFunction ( ...
parameterArgs
,
bodyArg
)
The last argument (if any) specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.
This function performs the following steps when called:
Let
C
be the
active function object
.
If
bodyArg
is not present, set
bodyArg
to the empty String.
Return ?
CreateDynamicFunction
(
C
, NewTarget,
async
,
parameterArgs
,
bodyArg
).
Note
See NOTE for
20.2.1.1
.
27.7.2
Properties of the AsyncFunction Constructor
The AsyncFunction
constructor
:
is a standard built-in
function object
that inherits from the Function
constructor
.
has a
[[Prototype]]
internal slot whose value is
%Function%
.
has a
"length"
property whose value is
1
𝔽
.
has a
"name"
property whose value is
"AsyncFunction"
.
has the following properties:
27.7.2.1
AsyncFunction.prototype
The initial value of
AsyncFunction.prototype
is the
AsyncFunction prototype object
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
27.7.3
Properties of the AsyncFunction Prototype Object
The
AsyncFunction prototype object
:
is
%AsyncFunction.prototype%
.
is an
ordinary object
.
is not a
function object
and does not have an
[[ECMAScriptCode]]
internal slot or any other of the internal slots listed in
Table 25
.
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
27.7.3.1
AsyncFunction.prototype.constructor
The initial value of
AsyncFunction.prototype.constructor
is
%AsyncFunction%
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.7.3.2
AsyncFunction.prototype [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"AsyncFunction"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
27.7.4
AsyncFunction Instances
Every AsyncFunction instance is an ECMAScript
function object
and has the internal slots listed in
Table 25
. The value of the
[[IsClassConstructor]]
internal slot for all such instances is
false
. AsyncFunction instances are not
constructors
and do not have a
[[Construct]]
internal method. AsyncFunction instances do not have a prototype property as they are not constructable.
Each AsyncFunction instance has the following own properties:
27.7.4.1
length
The specification for the
"length"
property of Function instances given in
20.2.4.1
also applies to AsyncFunction instances.
27.7.4.2
name
The specification for the
"name"
property of Function instances given in
20.2.4.2
also applies to AsyncFunction instances.
27.7.5
Async Functions Abstract Operations
27.7.5.1
AsyncFunctionStart (
promiseCapability
,
asyncFunctionBody
)
The abstract operation AsyncFunctionStart takes arguments
promiseCapability
(a
PromiseCapability Record
) and
asyncFunctionBody
(a
FunctionBody
Parse Node
, an
ExpressionBody
Parse Node
, or an
Abstract Closure
with no parameters) and returns
unused
. It performs the following steps when called:
Let
runningContext
be the
running execution context
.
Let
asyncContext
be a copy of
runningContext
.
NOTE: Copying the execution state is required for
AsyncBlockStart
to resume its execution. It is ill-defined to resume a currently executing context.
Perform
AsyncBlockStart
(
promiseCapability
,
asyncFunctionBody
,
asyncContext
).
Return
unused
.
27.7.5.2
AsyncBlockStart (
promiseCapability
,
asyncBody
,
asyncContext
)
The abstract operation AsyncBlockStart takes arguments
promiseCapability
(a
PromiseCapability Record
),
asyncBody
(a
Parse Node
or an
Abstract Closure
with no parameters), and
asyncContext
(an
execution context
) and returns
unused
. It performs the following steps when called:
Let
runningContext
be the
running execution context
.
Let
closure
be a new
Abstract Closure
with no parameters that captures
promiseCapability
and
asyncBody
and performs the following steps when called:
Let
acAsyncContext
be the
running execution context
.
If
asyncBody
is a
Parse Node
, then
Let
result
be
Completion
(
Evaluation
of
asyncBody
).
Else,
Assert
:
asyncBody
is an
Abstract Closure
with no parameters.
Let
result
be
Completion
(
asyncBody
()).
Assert
: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.
Remove
acAsyncContext
from the
execution context stack
and restore the
execution context
that is at the top of the
execution context stack
as the
running execution context
.
If
result
is a
normal completion
, then
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
undefined
»).
Else if
result
is a
return completion
, then
Perform !
Call
(
promiseCapability
.
[[Resolve]]
,
undefined
, «
result
.
[[Value]]
»).
Else,
Assert
:
result
is a
throw completion
.
Perform !
Call
(
promiseCapability
.
[[Reject]]
,
undefined
, «
result
.
[[Value]]
»).
Return
NormalCompletion
(
unused
).
Set the code evaluation state of
asyncContext
such that when evaluation is resumed for that
execution context
,
closure
will be called with no arguments.
Push
asyncContext
onto the
execution context stack
;
asyncContext
is now the
running execution context
.
Resume the suspended evaluation of
asyncContext
. Let
result
be the value returned by the resumed computation.
Assert
: When we return here,
asyncContext
has already been removed from the
execution context stack
and
runningContext
is the currently
running execution context
.
Assert
:
result
is a
normal completion
with a value of
unused
. The possible sources of this value are
Await
or, if the async function doesn't await anything, step
2.i
above.
Return
unused
.
27.7.5.3
Await (
value
)
The abstract operation Await takes argument
value
(an
ECMAScript language value
) and returns either a
normal completion containing
either an
ECMAScript language value
or
empty
, or a
throw completion
. It performs the following steps when called:
Let
asyncContext
be the
running execution context
.
Let
promise
be ?
PromiseResolve
(
%Promise%
,
value
).
Let
fulfilledClosure
be a new
Abstract Closure
with parameters (
v
) that captures
asyncContext
and performs the following steps when called:
Let
prevContext
be the
running execution context
.
Suspend
prevContext
.
Push
asyncContext
onto the
execution context stack
;
asyncContext
is now the
running execution context
.
Resume the suspended evaluation of
asyncContext
using
NormalCompletion
(
v
) as the result of the operation that suspended it.
Assert
: When we reach this step,
asyncContext
has already been removed from the
execution context stack
and
prevContext
is the currently
running execution context
.
Return
NormalCompletion
(
undefined
).
Let
onFulfilled
be
CreateBuiltinFunction
(
fulfilledClosure
, 1,
""
, « »).
Let
rejectedClosure
be a new
Abstract Closure
with parameters (
reason
) that captures
asyncContext
and performs the following steps when called:
Let
prevContext
be the
running execution context
.
Suspend
prevContext
.
Push
asyncContext
onto the
execution context stack
;
asyncContext
is now the
running execution context
.
Resume the suspended evaluation of
asyncContext
using
ThrowCompletion
(
reason
) as the result of the operation that suspended it.
Assert
: When we reach this step,
asyncContext
has already been removed from the
execution context stack
and
prevContext
is the currently
running execution context
.
Return
NormalCompletion
(
undefined
).
Let
onRejected
be
CreateBuiltinFunction
(
rejectedClosure
, 1,
""
, « »).
Perform
PerformPromiseThen
(
promise
,
onFulfilled
,
onRejected
).
Remove
asyncContext
from the
execution context stack
and restore the
execution context
that is at the top of the
execution context stack
as the
running execution context
.
Let
callerContext
be the
running execution context
.
Resume
callerContext
passing
empty
. If
asyncContext
is ever resumed again, let
completion
be the
Completion Record
with which it is resumed.
Assert
: If control reaches here, then
asyncContext
is the
running execution context
again.
Return
completion
.
28
Reflection
28.1
The Reflect Object
The Reflect object:
is
%Reflect%
.
is the initial value of the
"Reflect"
property of the
global object
.
is an
ordinary object
.
has a
[[Prototype]]
internal slot whose value is
%Object.prototype%
.
is not a
function object
.
does not have a
[[Construct]]
internal method; it cannot be used as a
constructor
with the
new
operator.
does not have a
[[Call]]
internal method; it cannot be invoked as a function.
28.1.1
Reflect.apply (
target
,
thisArgument
,
argumentsList
)
This function performs the following steps when called:
If
IsCallable
(
target
) is
false
, throw a
TypeError
exception.
Let
args
be ?
CreateListFromArrayLike
(
argumentsList
).
Perform
PrepareForTailCall
().
Return ?
Call
(
target
,
thisArgument
,
args
).
28.1.2
Reflect.construct (
target
,
argumentsList
[ ,
newTarget
] )
This function performs the following steps when called:
If
IsConstructor
(
target
) is
false
, throw a
TypeError
exception.
If
newTarget
is not present, set
newTarget
to
target
.
Else if
IsConstructor
(
newTarget
) is
false
, throw a
TypeError
exception.
Let
args
be ?
CreateListFromArrayLike
(
argumentsList
).
Return ?
Construct
(
target
,
args
,
newTarget
).
28.1.3
Reflect.defineProperty (
target
,
propertyKey
,
attributes
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
key
be ?
ToPropertyKey
(
propertyKey
).
Let
desc
be ?
ToPropertyDescriptor
(
attributes
).
Return ?
target
.
[[DefineOwnProperty]]
(
key
,
desc
)
.
28.1.4
Reflect.deleteProperty (
target
,
propertyKey
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
key
be ?
ToPropertyKey
(
propertyKey
).
Return ?
target
.
[[Delete]]
(
key
)
.
28.1.5
Reflect.get (
target
,
propertyKey
[ ,
receiver
] )
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
key
be ?
ToPropertyKey
(
propertyKey
).
If
receiver
is not present, then
Set
receiver
to
target
.
Return ?
target
.
[[Get]]
(
key
,
receiver
)
.
28.1.6
Reflect.getOwnPropertyDescriptor (
target
,
propertyKey
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
key
be ?
ToPropertyKey
(
propertyKey
).
Let
desc
be ?
target
.
[[GetOwnProperty]]
(
key
)
.
Return
FromPropertyDescriptor
(
desc
).
28.1.7
Reflect.getPrototypeOf (
target
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Return ?
target
.
[[GetPrototypeOf]]
()
.
28.1.8
Reflect.has (
target
,
propertyKey
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
key
be ?
ToPropertyKey
(
propertyKey
).
Return ?
target
.
[[HasProperty]]
(
key
)
.
28.1.9
Reflect.isExtensible (
target
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Return ?
target
.
[[IsExtensible]]
()
.
28.1.10
Reflect.ownKeys (
target
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
keys
be ?
target
.
[[OwnPropertyKeys]]
()
.
Return
CreateArrayFromList
(
keys
).
28.1.11
Reflect.preventExtensions (
target
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Return ?
target
.
[[PreventExtensions]]
()
.
28.1.12
Reflect.set (
target
,
propertyKey
,
V
[ ,
receiver
] )
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
Let
key
be ?
ToPropertyKey
(
propertyKey
).
If
receiver
is not present, then
Set
receiver
to
target
.
Return ?
target
.
[[Set]]
(
key
,
V
,
receiver
)
.
28.1.13
Reflect.setPrototypeOf (
target
,
proto
)
This function performs the following steps when called:
If
target
is not an Object
, throw a
TypeError
exception.
If
proto
is not an Object
and
proto
is not
null
, throw a
TypeError
exception.
Return ?
target
.
[[SetPrototypeOf]]
(
proto
)
.
28.1.14
Reflect [ %Symbol.toStringTag% ]
The initial value of the
%Symbol.toStringTag%
property is the String value
"Reflect"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
true
}.
28.2
Proxy Objects
28.2.1
The Proxy Constructor
The Proxy
constructor
:
is
%Proxy%
.
is the initial value of the
"Proxy"
property of the
global object
.
creates and initializes a new Proxy object when called as a
constructor
.
is not intended to be called as a function and will throw an exception when called in that manner.
28.2.1.1
Proxy (
target
,
handler
)
This function performs the following steps when called:
If NewTarget is
undefined
, throw a
TypeError
exception.
Return ?
ProxyCreate
(
target
,
handler
).
28.2.2
Properties of the Proxy Constructor
The Proxy
constructor
:
has a
[[Prototype]]
internal slot whose value is
%Function.prototype%
.
does not have a
"prototype"
property because Proxy objects do not have a
[[Prototype]]
internal slot that requires initialization.
has the following properties:
28.2.2.1
Proxy.revocable (
target
,
handler
)
This function creates a revocable Proxy object.
It performs the following steps when called:
Let
proxy
be ?
ProxyCreate
(
target
,
handler
).
Let
revokerClosure
be a new
Abstract Closure
with no parameters that captures nothing and performs the following steps when called:
Let
F
be the
active function object
.
Let
p
be
F
.
[[RevocableProxy]]
.
If
p
is
null
, return
NormalCompletion
(
undefined
).
Set
F
.
[[RevocableProxy]]
to
null
.
Assert
:
p
is a
Proxy exotic object
.
Set
p
.
[[ProxyTarget]]
to
null
.
Set
p
.
[[ProxyHandler]]
to
null
.
Return
NormalCompletion
(
undefined
).
Let
revoker
be
CreateBuiltinFunction
(
revokerClosure
, 0,
""
, «
[[RevocableProxy]]
»).
Set
revoker
.
[[RevocableProxy]]
to
proxy
.
Let
result
be
OrdinaryObjectCreate
(
%Object.prototype%
).
Perform !
CreateDataPropertyOrThrow
(
result
,
"proxy"
,
proxy
).
Perform !
CreateDataPropertyOrThrow
(
result
,
"revoke"
,
revoker
).
Return
result
.
28.3
Module Namespace Objects
A Module Namespace Object is a
module namespace exotic object
that provides runtime property-based access to a module's exported bindings. There is no
constructor
function for Module Namespace Objects. Instead, such an object is created for each module that is imported by an
ImportDeclaration
that contains a
NameSpaceImport
.
In addition to the properties specified in
10.4.6
each Module Namespace Object has the following own property:
28.3.1
%Symbol.toStringTag%
The initial value of the
%Symbol.toStringTag%
property is the String value
"Module"
.
This property has the attributes {
[[Writable]]
:
false
,
[[Enumerable]]
:
false
,
[[Configurable]]
:
false
}.
29
Memory Model
The memory consistency model, or
memory model
, specifies the possible orderings of
Shared Data Block events
, arising via accessing
TypedArray
instances backed by a SharedArrayBuffer and via methods on the Atomics object. When the program has no data races (defined below), the ordering of events appears as sequentially consistent, i.e., as an interleaving of actions from each
agent
. When the program has data races, shared memory operations may appear sequentially inconsistent. For example, programs may exhibit causality-violating behaviour and other astonishments. These astonishments arise from compiler transforms and the design of CPUs (e.g., out-of-order execution and speculation). The memory model defines both the precise conditions under which a program exhibits sequentially consistent behaviour as well as the possible values read from data races. To wit, there is no undefined behaviour.
The memory model is defined as relational constraints on
Memory events
introduced by
abstract operations
on SharedArrayBuffer or by methods on the Atomics object during an evaluation.
Note
This section provides an axiomatic model on
Memory events
introduced by the
abstract operations
on SharedArrayBuffers. It bears stressing that the model is not expressible algorithmically, unlike the rest of this specification. The nondeterministic introduction of events by
abstract operations
is the interface between the operational semantics of ECMAScript evaluation and the axiomatic semantics of the memory model. The semantics of these events is defined by considering graphs of all events in an evaluation. These are neither Static Semantics nor Runtime Semantics. There is no demonstrated algorithmic implementation, but instead a set of constraints that determine if a particular event graph is allowed or disallowed.
29.1
Memory Model Fundamentals
Shared memory accesses (reads and writes) are divided into two groups, atomic accesses and data accesses, defined below. Atomic accesses are sequentially consistent, i.e., there is a strict total ordering of events agreed upon by all
agents
in an
agent cluster
. Non-atomic accesses do not have a strict total ordering agreed upon by all
agents
, i.e., unordered.
Note 1
No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.
A
Shared Data Block event
is either a
ReadSharedMemory
,
WriteSharedMemory
, or
ReadModifyWriteSharedMemory
Record
. A
read event
is either a ReadSharedMemory or a ReadModifyWriteSharedMemory. A
write event
is either a WriteSharedMemory or a ReadModifyWriteSharedMemory.
Table 91:
ReadSharedMemory
Event Fields
Field Name
Value
Meaning
[[Order]]
seq-cst
or
unordered
The weakest ordering guaranteed by the
memory model
for the event.
[[NoTear]]
a Boolean
Whether this event is allowed to read from multiple
write events
with equal
memory range
as this event.
[[Block]]
a
Shared Data Block
The block the event operates on.
[[ByteIndex]]
a non-negative
integer
The byte address of the read in
[[Block]]
.
[[ElementSize]]
a non-negative
integer
The size of the read.
Table 92:
WriteSharedMemory
Event Fields
Field Name
Value
Meaning
[[Order]]
seq-cst
,
unordered
, or
init
The weakest ordering guaranteed by the
memory model
for the event.
[[NoTear]]
a Boolean
Whether this event is allowed to be read from multiple
read events
with equal
memory range
as this event.
[[Block]]
a
Shared Data Block
The block the event operates on.
[[ByteIndex]]
a non-negative
integer
The byte address of the write in
[[Block]]
.
[[ElementSize]]
a non-negative
integer
The size of the write.
[[Payload]]
a
List
of
byte values
The
List
of
byte values
to be read by other events.
Table 93:
ReadModifyWriteSharedMemory
Event Fields
Field Name
Value
Meaning
[[Order]]
seq-cst
Read-modify-
write events
are always sequentially consistent.
[[NoTear]]
true
Read-modify-
write events
cannot tear.
[[Block]]
a
Shared Data Block
The block the event operates on.
[[ByteIndex]]
a non-negative
integer
The byte address of the read-modify-write in
[[Block]]
.
[[ElementSize]]
a non-negative
integer
The size of the read-modify-write.
[[Payload]]
a
List
of
byte values
The
List
of
byte values
to be passed to
[[ModifyOp]]
.
[[ModifyOp]]
a
read-modify-write modification function
An abstract closure that returns a modified
List
of
byte values
from a read
List
of
byte values
and
[[Payload]]
.
Shared Data Block events are introduced to
candidate execution
Agent Events Records
by
abstract operations
or by methods on the Atomics object. Some operations also introduce
Synchronize events
, which have no fields and exist purely to directly constrain the permitted orderings of other events. And finally, there are
host
-specific events. A
Memory event
is either a Shared Data Block event, Synchronize event, or such a
host
-specific event.
Let the
memory range
of a Shared Data Block event
e
be the Set of all
integers
in the
interval
from
e
.
[[ByteIndex]]
(inclusive) to
e
.
[[ByteIndex]]
+
e
.
[[ElementSize]]
(exclusive). Two events' memory ranges are equal when the events have the same
[[Block]]
,
[[ByteIndex]]
, and
[[ElementSize]]
. Two events' memory ranges are overlapping when the events have the same
[[Block]]
, the ranges are not equal, and their intersection is non-empty. Two events' memory ranges are disjoint when the events do not have the same
[[Block]]
or their ranges are neither equal nor overlapping.
Note 2
Examples of
host
-specific synchronizing events that should be accounted for are: sending a SharedArrayBuffer from one
agent
to another (e.g., by
postMessage
in a browser), starting and stopping
agents
, and communicating within the
agent cluster
via channels other than shared memory. For a particular execution
execution
, those events are provided by the
host
via the
host-synchronizes-with
strict partial order
. Additionally,
hosts
can add
host
-specific synchronizing events to
execution
.
[[EventList]]
so as to participate in the
is-agent-order-before
Relation
.
Events are ordered within
candidate executions
by the relations defined below.
29.2
Agent Events Records
An
Agent Events Record
is a
Record
with the following fields.
Table 94:
Agent Events Record
Fields
Field Name
Value
Meaning
[[AgentSignifier]]
an
agent signifier
The
agent
whose evaluation resulted in this ordering.
[[EventList]]
a
List
of
Memory events
Events are appended to the list during evaluation.
[[AgentSynchronizesWith]]
a
List
of pairs of
Synchronize events
Synchronize
relationships introduced by the operational semantics.
29.3
Chosen Value Records
A
Chosen Value Record
is a
Record
with the following fields.
Table 95:
Chosen Value Record
Fields
Field Name
Value
Meaning
[[Event]]
a
Shared Data Block event
The
ReadSharedMemory
or
ReadModifyWriteSharedMemory
event that was introduced for this chosen value.
[[ChosenValue]]
a
List
of
byte values
The bytes that were nondeterministically chosen during evaluation.
29.4
Candidate Executions
A
candidate execution
of the evaluation of an
agent cluster
is a
Record
with the following fields.
Table 96: Candidate Execution
Record
Fields
Field Name
Value
Meaning
[[EventsRecords]]
a
List
of
Agent Events Records
Maps an
agent
to
Lists
of
Memory events
appended during the evaluation.
[[ChosenValues]]
a
List
of
Chosen Value Records
Maps
ReadSharedMemory
or
ReadModifyWriteSharedMemory
events to the
List
of
byte values
chosen during the evaluation.
An
empty candidate execution
is a candidate execution
Record
whose fields are empty
Lists
.
29.5
Abstract Operations for the Memory Model
29.5.1
EventSet (
execution
)
The abstract operation EventSet takes argument
execution
(a
candidate execution
) and returns a Set of
Memory events
. It performs the following steps when called:
Let
events
be an empty Set.
For each
Agent Events Record
aer
of
execution
.
[[EventsRecords]]
, do
For each
Memory event
E
of
aer
.
[[EventList]]
, do
Add
E
to
events
.
Return
events
.
29.5.2
SharedDataBlockEventSet (
execution
)
The abstract operation SharedDataBlockEventSet takes argument
execution
(a
candidate execution
) and returns a Set of
Shared Data Block events
. It performs the following steps when called:
Let
events
be an empty Set.
For each
Memory event
E
of
EventSet
(
execution
), do
If
E
is a
Shared Data Block event
, add
E
to
events
.
Return
events
.
29.5.3
HostEventSet (
execution
)
The abstract operation HostEventSet takes argument
execution
(a
candidate execution
) and returns a Set of
Memory events
. It performs the following steps when called:
Return a new Set containing all elements of
EventSet
(
execution
) that are not in
SharedDataBlockEventSet
(
execution
).
29.5.4
ComposeWriteEventBytes (
execution
,
byteIndex
,
Ws
)
The abstract operation ComposeWriteEventBytes takes arguments
execution
(a
candidate execution
),
byteIndex
(a non-negative
integer
), and
Ws
(a
List
of either
WriteSharedMemory
or
ReadModifyWriteSharedMemory
events) and returns a
List
of
byte values
. It performs the following steps when called:
Let
byteLocation
be
byteIndex
.
Let
bytesRead
be a new empty
List
.
For each element
W
of
Ws
, do
Assert
:
W
has
byteLocation
in its
memory range
.
Let
payloadIndex
be
byteLocation
-
W
.
[[ByteIndex]]
.
If
W
is a
WriteSharedMemory
event, then
Let
byte
be
W
.
[[Payload]]
[
payloadIndex
].
Else,
Assert
:
W
is a
ReadModifyWriteSharedMemory
event.
Let
bytes
be
ValueOfReadEvent
(
execution
,
W
).
Let
bytesModified
be
W
.
[[ModifyOp]]
(
bytes
,
W
.
[[Payload]]
).
Let
byte
be
bytesModified
[
payloadIndex
].
Append
byte
to
bytesRead
.
Set
byteLocation
to
byteLocation
+ 1.
Return
bytesRead
.
Note 1
The read-modify-write modification
[[ModifyOp]]
is given by the function properties on the Atomics object that introduce
ReadModifyWriteSharedMemory
events.
Note 2
This abstract operation composes a
List
of
write events
into a
List
of
byte values
. It is used in the event semantics of
ReadSharedMemory
and
ReadModifyWriteSharedMemory
events.
29.5.5
ValueOfReadEvent (
execution
,
R
)
The abstract operation ValueOfReadEvent takes arguments
execution
(a
candidate execution
) and
R
(a
ReadSharedMemory
or
ReadModifyWriteSharedMemory
event) and returns a
List
of
byte values
. It performs the following steps when called:
Let
Ws
be
reads-bytes-from
(
R
) in
execution
.
Assert
:
Ws
is a
List
of
WriteSharedMemory
or
ReadModifyWriteSharedMemory
events with length equal to
R
.
[[ElementSize]]
.
Return
ComposeWriteEventBytes
(
execution
,
R
.
[[ByteIndex]]
,
Ws
).
29.6
Relations of Candidate Executions
The following relations and mathematical functions are parameterized over a particular
candidate execution
and order its
Memory events
.
29.6.1
is-agent-order-before
For a
candidate execution
execution
, its
is-agent-order-before
Relation
is the
least Relation
on
Memory events
that satisfies the following.
For events
E
and
D
,
E
is-agent-order-before
D
in
execution
if there is some
Agent Events Record
aer
in
execution
.
[[EventsRecords]]
such that
aer
.
[[EventList]]
contains both
E
and
D
and
E
is before
D
in
List
order of
aer
.
[[EventList]]
.
Note
Each
agent
introduces events in a per-
agent
strict total order
during the evaluation. This is the union of those
strict total orders
.
29.6.2
reads-bytes-from
For a
candidate execution
execution
, its
reads-bytes-from
function is a mathematical function mapping
Memory events
in
SharedDataBlockEventSet
(
execution
) to
Lists
of events in
SharedDataBlockEventSet
(
execution
) that satisfies the following conditions.
For each
ReadSharedMemory
or
ReadModifyWriteSharedMemory
event
R
in
SharedDataBlockEventSet
(
execution
), reads-bytes-from(
R
) in
execution
is a
List
of length
R
.
[[ElementSize]]
whose elements are
WriteSharedMemory
or
ReadModifyWriteSharedMemory
events
Ws
such that all of the following are true.
Each event
W
with index
i
in
Ws
has
R
.
[[ByteIndex]]
+
i
in its
memory range
.
R
is not in
Ws
.
A
candidate execution
always admits a reads-bytes-from function.
29.6.3
reads-from
For a
candidate execution
execution
, its
reads-from
Relation
is the
least Relation
on
Memory events
that satisfies the following.
For events
R
and
W
,
R
reads-from
W
in
execution
if
SharedDataBlockEventSet
(
execution
) contains both
R
and
W
, and
reads-bytes-from
(
R
) in
execution
contains
W
.
29.6.4
host-synchronizes-with
For a
candidate execution
execution
, its
host-synchronizes-with
Relation
is a
host
-provided
strict partial order
on
host
-specific
Memory events
that satisfies at least the following.
If
E
host-synchronizes-with
D
in
execution
,
HostEventSet
(
execution
) contains
E
and
D
.
There is no cycle in the union of host-synchronizes-with and
is-agent-order-before
in
execution
.
Note 1
For two
host
-specific events
E
and
D
in a
candidate execution
execution
,
E
host-synchronizes-with
D
in
execution
implies
E
happens-before
D
in
execution
.
Note 2
This
Relation
allows the
host
to provide additional synchronization mechanisms, such as
postMessage
between HTML workers.
29.6.5
synchronizes-with
For a
candidate execution
execution
, its
synchronizes-with
Relation
is the
least Relation
on
Memory events
that satisfies the following.
For events
R
and
W
,
W
synchronizes-with
R
in
execution
if
R
reads-from
W
in
execution
,
R
.
[[Order]]
is
seq-cst
,
W
.
[[Order]]
is
seq-cst
, and
R
and
W
have equal
memory ranges
.
For each element
eventsRecord
of
execution
.
[[EventsRecords]]
, the following is true.
For events
S
and
Sw
,
S
synchronizes-with
Sw
in
execution
if
eventsRecord
.
[[AgentSynchronizesWith]]
contains (
S
,
Sw
).
For events
E
and
D
,
E
synchronizes-with
D
in
execution
if
execution
.
[[HostSynchronizesWith]]
contains (
E
,
D
).
Note 1
Owing to convention in
memory model
literature, in a
candidate execution
execution
,
write events
synchronizes-with
read events
, instead of
read events
synchronizes-with
write events
.
Note 2
In a
candidate execution
execution
,
init
events do not participate in this
Relation
and are instead constrained directly by
happens-before
.
Note 3
In a
candidate execution
execution
, not all
seq-cst
events related by
reads-from
are related by synchronizes-with. Only events that also have equal
memory ranges
are related by synchronizes-with.
Note 4
For
Shared Data Block events
R
and
W
in a
candidate execution
execution
such that
W
synchronizes-with
R
,
R
may
reads-from
other writes than
W
.
29.6.6
happens-before
For a
candidate execution
execution
, its
happens-before
Relation
is the
least Relation
on
Memory events
that satisfies the following.
For events
E
and
D
,
E
happens-before
D
in
execution
if any of the following conditions are true.
E
is-agent-order-before
D
in
execution
.
E
synchronizes-with
D
in
execution
.
SharedDataBlockEventSet
(
execution
) contains both
E
and
D
,
E
.
[[Order]]
is
init
, and
E
and
D
have overlapping
memory ranges
.
There is an event
F
such that
E
happens-before
F
and
F
happens-before
D
in
execution
.
Note
Because happens-before is a superset of
agent
-order, a
candidate execution
is consistent with the single-thread evaluation semantics of ECMAScript.
29.7
Properties of Valid Executions
29.7.1
Valid Chosen Reads
A
candidate execution
execution
has valid chosen reads if the following algorithm returns
true
.
For each
ReadSharedMemory
or
ReadModifyWriteSharedMemory
event
R
of
SharedDataBlockEventSet
(
execution
), do
Let
chosenValueRecord
be the element of
execution
.
[[ChosenValues]]
whose
[[Event]]
field is
R
.
Let
chosenValue
be
chosenValueRecord
.
[[ChosenValue]]
.
Let
readValue
be
ValueOfReadEvent
(
execution
,
R
).
Let
chosenLen
be the number of elements in
chosenValue
.
Let
readLen
be the number of elements in
readValue
.
If
chosenLen
≠
readLen
, then
Return
false
.
If
chosenValue
[
i
] ≠
readValue
[
i
] for some
integer
i
in the
interval
from 0 (inclusive) to
chosenLen
(exclusive), then
Return
false
.
Return
true
.
29.7.2
Coherent Reads
A
candidate execution
execution
has coherent reads if the following algorithm returns
true
.
For each
ReadSharedMemory
or
ReadModifyWriteSharedMemory
event
R
of
SharedDataBlockEventSet
(
execution
), do
Let
Ws
be
reads-bytes-from
(
R
) in
execution
.
Let
byteLocation
be
R
.
[[ByteIndex]]
.
For each element
W
of
Ws
, do
If
R
happens-before
W
in
execution
, then
Return
false
.
If there exists a
WriteSharedMemory
or
ReadModifyWriteSharedMemory
event
V
that has
byteLocation
in its
memory range
such that
W
happens-before
V
in
execution
and
V
happens-before
R
in
execution
, then
Return
false
.
Set
byteLocation
to
byteLocation
+ 1.
Return
true
.
29.7.3
Tear Free Reads
A
candidate execution
execution
has tear free reads if the following algorithm returns
true
.
For each
ReadSharedMemory
or
ReadModifyWriteSharedMemory
event
R
of
SharedDataBlockEventSet
(
execution
), do
If
R
.
[[NoTear]]
is
true
, then
Assert
: The remainder of dividing
R
.
[[ByteIndex]]
by
R
.
[[ElementSize]]
is 0.
For each
Memory event
W
such that
R
reads-from
W
in
execution
and
W
.
[[NoTear]]
is
true
, do
If
R
and
W
have equal
memory ranges
and there exists a
Memory event
V
such that
V
and
W
have equal
memory ranges
,
V
.
[[NoTear]]
is
true
,
W
and
V
are not the same
Shared Data Block event
, and
R
reads-from
V
in
execution
, then
Return
false
.
Return
true
.
Note
A
Shared Data Block event
's
[[NoTear]]
field is
true
when that event was introduced via accessing an
integer
TypedArray
, and
false
when introduced via accessing a floating point
TypedArray
or DataView.
Intuitively, this requirement says when a
memory range
is accessed in an aligned fashion via an
integer
TypedArray
, a single
write event
on that range must "win" when in a
data race
with other
write events
with equal ranges. More precisely, this requirement says an aligned
read event
cannot read a value composed of bytes from multiple, different
write events
all with equal ranges. It is possible, however, for an aligned
read event
to read from multiple
write events
with overlapping ranges.
29.7.4
Sequentially Consistent Atomics
For a
candidate execution
execution
,
is-memory-order-before
is a
strict total order
of all
Memory events
in
EventSet
(
execution
) that satisfies the following.
For events
E
and
D
,
E
is-memory-order-before
D
in
execution
if
E
happens-before
D
in
execution
.
For events
R
and
W
such that
R
reads-from
W
in
execution
, there is no
WriteSharedMemory
or
ReadModifyWriteSharedMemory
event
V
in
SharedDataBlockEventSet
(
execution
) such that
V
.
[[Order]]
is
seq-cst
,
W
is-memory-order-before
V
in
execution
,
V
is-memory-order-before
R
in
execution
, and any of the following conditions are true.
W
synchronizes-with
R
in
execution
, and
V
and
R
have equal
memory ranges
.
W
happens-before
R
and
V
happens-before
R
in
execution
,
W
.
[[Order]]
is
seq-cst
, and
W
and
V
have equal
memory ranges
.
W
happens-before
R
and
W
happens-before
V
in
execution
,
R
.
[[Order]]
is
seq-cst
, and
V
and
R
have equal
memory ranges
.
Note 1
This clause additionally constrains
seq-cst
events on equal
memory ranges
.
For each
WriteSharedMemory
or
ReadModifyWriteSharedMemory
event
W
in
SharedDataBlockEventSet
(
execution
), if
W
.
[[Order]]
is
seq-cst
, then it is not the case that there is an infinite number of
ReadSharedMemory
or
ReadModifyWriteSharedMemory
events in
SharedDataBlockEventSet
(
execution
) with equal
memory range
that is memory-order before
W
.
Note 2
This clause together with the forward progress guarantee on
agents
ensure the liveness condition that
seq-cst
writes
become visible to
seq-cst
reads
with equal
memory range
in
finite
time.
A
candidate execution
has sequentially consistent atomics if it admits an is-memory-order-before
Relation
.
Note 3
While is-memory-order-before includes all events in
EventSet
(
execution
), those that are not constrained by
happens-before
or
synchronizes-with
in
execution
are allowed to occur anywhere in the order.
29.7.5
Valid Executions
A
candidate execution
execution
is a valid execution (or simply an execution) if all of the following are true.
The
host
provides a
host-synchronizes-with
Relation
for
execution
.
execution
admits a
happens-before
Relation
that is a
strict partial order
.
execution
has valid chosen reads.
execution
has coherent reads.
execution
has tear free reads.
execution
has sequentially consistent atomics.
All programs have at least one valid execution.
29.8
Races
For an execution
execution
and events
E
and
D
that are contained in
SharedDataBlockEventSet
(
execution
),
E
and
D
are in a
race
if the following algorithm returns
true
.
If
E
and
D
are not the same
Shared Data Block event
, then
If it is not the case that both
E
happens-before
D
in
execution
and
D
happens-before
E
in
execution
, then
If
E
and
D
are both
WriteSharedMemory
or
ReadModifyWriteSharedMemory
events and
E
and
D
do not have disjoint
memory ranges
, then
Return
true
.
If
E
reads-from
D
in
execution
or
D
reads-from
E
in
execution
, then
Return
true
.
Return
false
.
29.9
Data Races
For an execution
execution
and events
E
and
D
that are contained in
SharedDataBlockEventSet
(
execution
),
E
and
D
are in a
data race
if the following algorithm returns
true
.
If
E
and
D
are in a
race
in
execution
, then
If
E
.
[[Order]]
is not
seq-cst
or
D
.
[[Order]]
is not
seq-cst
, then
Return
true
.
If
E
and
D
have overlapping
memory ranges
, then
Return
true
.
Return
false
.
29.10
Data Race Freedom
An execution
execution
is
data race free
if there are no two events in
SharedDataBlockEventSet
(
execution
) that are in a
data race
.
A program is data race free if all its executions are data race free.
The
memory model
guarantees sequential consistency of all events for data race free programs.
29.11
Shared Memory Guidelines
Note 1
The following are guidelines for ECMAScript programmers working with shared memory.
We recommend programs be kept
data race free
, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location.
Data race free
programs have interleaving semantics where each step in the evaluation semantics of each
agent
are interleaved with each other. For
data race free
programs, it is not necessary to understand the details of the
memory model
. The details are unlikely to build intuition that will help one to better write ECMAScript.
More generally, even if a program is not
data race free
it may have predictable behaviour, so long as atomic operations are not involved in any data races and the operations that race all have the same access size. The simplest way to arrange for atomics not to be involved in races is to ensure that different memory cells are used by atomic and non-atomic operations and that atomic accesses of different sizes are not used to access the same cells at the same time. Effectively, the program should treat shared memory as strongly typed as much as possible. One still cannot depend on the ordering and timing of non-atomic accesses that race, but if memory is treated as strongly typed the racing accesses will not "tear" (bits of their values will not be mixed).
Note 2
The following are guidelines for ECMAScript implementers writing compiler transformations for programs using shared memory.
It is desirable to allow most program transformations that are valid in a single-
agent
setting in a multi-
agent
setting, to ensure that the performance of each
agent
in a multi-
agent
program is as good as it would be in a single-
agent
setting. Frequently these transformations are hard to judge. We outline some rules about program transformations that are intended to be taken as normative (in that they are implied by the
memory model
or stronger than what the
memory model
implies) but which are likely not exhaustive. These rules are intended to apply to program transformations that precede the introductions of the
Memory events
that make up the
is-agent-order-before
Relation
.
Let an
agent-order slice
be the subset of the
is-agent-order-before
Relation
pertaining to a single
agent
.
Let
possible read values
of a
read event
be the set of all values of
ValueOfReadEvent
for that event across all valid executions.
Any transformation of an agent-order slice that is valid in the absence of shared memory is valid in the presence of shared memory, with the following exceptions.
Atomics are carved in stone
: Program transformations must not cause any
Shared Data Block events
whose
[[Order]]
is
seq-cst
to be removed from the
is-agent-order-before
Relation
, nor to be reordered with respect to each other, nor to be reordered inside an agent-order slice with respect to events whose
[[Order]]
is
unordered
.
(In practice, the prohibition on reorderings forces a compiler to assume that every
seq-cst
operation is a synchronization and included in the final
is-memory-order-before
Relation
, which it would usually have to assume anyway in the absence of inter-
agent
program analysis. It also forces the compiler to assume that every call where the callee's effects on the memory-order are unknown may contain
seq-cst
operations.)
Reads must be stable
: Any given shared memory read must only observe a single value in an execution.
(For example, if what is semantically a single read in the program is executed multiple times then the program is subsequently allowed to observe only one of the values read. A transformation known as rematerialization can violate this rule.)
Writes must be stable
: All observable writes to shared memory must follow from program semantics in an execution.
(For example, a transformation may not introduce certain observable writes, such as by using read-modify-write operations on a larger location to write a smaller datum, writing a value to memory that the program could not have written, or writing a just-read value back to the location it was read from, if that location could have been overwritten by another
agent
after the read.)
Possible read values must be non-empty
: Program transformations cannot cause the possible read values of a shared memory read to become empty.
(Counterintuitively, this rule in effect restricts transformations on writes, because writes have force in
memory model
insofar as to be read by
read events
. For example, writes may be moved and coalesced and sometimes reordered between two
seq-cst
operations, but the transformation may not remove every write that updates a location; some write must be preserved.)
Examples of transformations that remain valid are: merging multiple non-atomic reads from the same location, reordering non-atomic reads, introducing speculative non-atomic reads, merging multiple non-atomic writes to the same location, reordering non-atomic writes to different locations, and hoisting non-atomic reads out of loops even if that affects termination. Note in general that aliased
TypedArrays
make it hard to prove that locations are different.
Note 3
The following are guidelines for ECMAScript implementers generating machine code for shared memory accesses.
For architectures with memory models no weaker than those of ARM or Power, non-atomic stores and loads may be compiled to bare stores and loads on the target architecture. Atomic stores and loads may be compiled down to instructions that guarantee sequential consistency. If no such instructions exist, memory barriers are to be employed, such as placing barriers on both sides of a bare store or load. Read-modify-write operations may be compiled to read-modify-write instructions on the target architecture, such as
LOCK
-prefixed instructions on x86, load-exclusive/store-exclusive instructions on ARM, and load-link/store-conditional instructions on Power.
Specifically, the
memory model
is intended to allow code generation as follows.
Every atomic operation in the program is assumed to be necessary.
Atomic operations are never rearranged with each other or with non-atomic operations.
Functions are always assumed to perform atomic operations.
Atomic operations are never implemented as read-modify-write operations on larger data, but as non-lock-free atomics if the platform does not have atomic operations of the appropriate size. (We already assume that every platform has normal memory access operations of every interesting size.)
Naive code generation uses these patterns:
Regular loads and stores compile to single load and store instructions.
Lock-free atomic loads and stores compile to a full (sequentially consistent) fence, a regular load or store, and a full fence.
Lock-free atomic read-modify-write accesses compile to a full fence, an atomic read-modify-write instruction sequence, and a full fence.
Non-lock-free atomics compile to a spinlock acquire, a full fence, a series of non-atomic load and store instructions, a full fence, and a spinlock release.
That mapping is correct so long as an atomic operation on a
memory range
does not race with a non-atomic write or with an atomic operation of different size. However, that is all we need: the
memory model
effectively demotes the atomic operations involved in a race to non-atomic status. On the other hand, the naive mapping is quite strong: it allows atomic operations to be used as sequentially consistent fences, which the
memory model
does not actually guarantee.
Local improvements to those basic patterns are also allowed, subject to the constraints of the
memory model
. For example:
There are obvious platform-dependent improvements that remove redundant fences. For example, on x86 the fences around lock-free atomic loads and stores can always be omitted except for the fence following a store, and no fence is needed for lock-free read-modify-write instructions, as these all use
LOCK
-prefixed instructions. On many platforms there are fences of several strengths, and weaker fences can be used in certain contexts without destroying sequential consistency.
Most modern platforms support lock-free atomics for all the data sizes required by ECMAScript atomics. Should non-lock-free atomics be needed, the fences surrounding the body of the atomic operation can usually be folded into the lock and unlock steps. The simplest solution for non-lock-free atomics is to have a single lock word per SharedArrayBuffer.
There are also more complicated platform-dependent local improvements, requiring some code analysis. For example, two back-to-back fences often have the same effect as a single fence, so if code is generated for two atomic operations in sequence, only a single fence need separate them. On x86, even a single fence separating atomic stores can be omitted, as the fence following a store is only needed to separate the store from a subsequent load.
Annex A
(informative)
Grammar Summary
A.1
Lexical Grammar
SourceCharacter
::
any Unicode code point
InputElementDiv
::
WhiteSpace
LineTerminator
Comment
CommonToken
DivPunctuator
RightBracePunctuator
InputElementRegExp
::
WhiteSpace
LineTerminator
Comment
CommonToken
RightBracePunctuator
RegularExpressionLiteral
InputElementRegExpOrTemplateTail
::
WhiteSpace
LineTerminator
Comment
CommonToken
RegularExpressionLiteral
TemplateSubstitutionTail
InputElementTemplateTail
::
WhiteSpace
LineTerminator
Comment
CommonToken
DivPunctuator
TemplateSubstitutionTail
InputElementHashbangOrRegExp
::
WhiteSpace
LineTerminator
Comment
CommonToken
HashbangComment
RegularExpressionLiteral
WhiteSpace
::
<TAB>
<VT>
<FF>
<ZWNBSP>
<USP>
LineTerminator
::
<LF>
<CR>
<LS>
<PS>
LineTerminatorSequence
::
<LF>
<CR>
[lookahead ≠
<LF>
]
<LS>
<PS>
<CR>
<LF>
Comment
::
MultiLineComment
SingleLineComment
MultiLineComment
::
/*
MultiLineCommentChars
opt
*/
MultiLineCommentChars
::
MultiLineNotAsteriskChar
MultiLineCommentChars
opt
*
PostAsteriskCommentChars
opt
PostAsteriskCommentChars
::
MultiLineNotForwardSlashOrAsteriskChar
MultiLineCommentChars
opt
*
PostAsteriskCommentChars
opt
MultiLineNotAsteriskChar
::
SourceCharacter
but not
*
MultiLineNotForwardSlashOrAsteriskChar
::
SourceCharacter
but not one of
/
or
*
SingleLineComment
::
//
SingleLineCommentChars
opt
SingleLineCommentChars
::
SingleLineCommentChar
SingleLineCommentChars
opt
SingleLineCommentChar
::
SourceCharacter
but not
LineTerminator
HashbangComment
::
#!
SingleLineCommentChars
opt
CommonToken
::
IdentifierName
PrivateIdentifier
Punctuator
NumericLiteral
StringLiteral
Template
PrivateIdentifier
::
#
IdentifierName
IdentifierName
::
IdentifierStart
IdentifierName
IdentifierPart
IdentifierStart
::
IdentifierStartChar
\
UnicodeEscapeSequence
IdentifierPart
::
IdentifierPartChar
\
UnicodeEscapeSequence
IdentifierStartChar
::
UnicodeIDStart
$
_
IdentifierPartChar
::
UnicodeIDContinue
$
AsciiLetter
::
one of
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
UnicodeIDStart
::
any Unicode code point with the Unicode property “ID_Start”
UnicodeIDContinue
::
any Unicode code point with the Unicode property “ID_Continue”
ReservedWord
::
one of
await
break
case
catch
class
const
continue
debugger
default
delete
do
else
enum
export
extends
false
finally
for
function
if
import
in
instanceof
new
null
return
super
switch
this
throw
true
try
typeof
var
void
while
with
yield
Punctuator
::
OptionalChainingPunctuator
OtherPunctuator
OptionalChainingPunctuator
::
?.
[lookahead ∉
DecimalDigit
]
OtherPunctuator
::
one of
{
(
)
[
]
.
...
;
,
<
>
<=
>=
==
!=
===
!==
+
-
*
%
**
++
--
<<
>>
>>>
&
|
^
!
~
&&
||
??
?
:
=
+=
-=
*=
%=
**=
<<=
>>=
>>>=
&=
|=
^=
&&=
||=
??=
=>
DivPunctuator
::
/
/=
RightBracePunctuator
::
}
NullLiteral
::
null
BooleanLiteral
::
true
false
NumericLiteralSeparator
::
_
NumericLiteral
::
DecimalLiteral
DecimalBigIntegerLiteral
NonDecimalIntegerLiteral
[+Sep]
NonDecimalIntegerLiteral
[+Sep]
BigIntLiteralSuffix
LegacyOctalIntegerLiteral
DecimalBigIntegerLiteral
::
0
BigIntLiteralSuffix
NonZeroDigit
DecimalDigits
[+Sep]
opt
BigIntLiteralSuffix
NonZeroDigit
NumericLiteralSeparator
DecimalDigits
[+Sep]
BigIntLiteralSuffix
NonDecimalIntegerLiteral
[Sep]
::
BinaryIntegerLiteral
[?Sep]
OctalIntegerLiteral
[?Sep]
HexIntegerLiteral
[?Sep]
BigIntLiteralSuffix
::
n
DecimalLiteral
::
DecimalIntegerLiteral
.
DecimalDigits
[+Sep]
opt
ExponentPart
[+Sep]
opt
.
DecimalDigits
[+Sep]
ExponentPart
[+Sep]
opt
DecimalIntegerLiteral
ExponentPart
[+Sep]
opt
DecimalIntegerLiteral
::
0
NonZeroDigit
NonZeroDigit
NumericLiteralSeparator
opt
DecimalDigits
[+Sep]
NonOctalDecimalIntegerLiteral
DecimalDigits
[Sep]
::
DecimalDigit
DecimalDigits
[?Sep]
DecimalDigit
[+Sep]
DecimalDigits
[+Sep]
NumericLiteralSeparator
DecimalDigit
DecimalDigit
::
one of
0
1
2
3
4
5
6
7
8
9
NonZeroDigit
::
one of
1
2
3
4
5
6
7
8
9
ExponentPart
[Sep]
::
ExponentIndicator
SignedInteger
[?Sep]
ExponentIndicator
::
one of
e
E
SignedInteger
[Sep]
::
DecimalDigits
[?Sep]
+
DecimalDigits
[?Sep]
-
DecimalDigits
[?Sep]
BinaryIntegerLiteral
[Sep]
::
0b
BinaryDigits
[?Sep]
0B
BinaryDigits
[?Sep]
BinaryDigits
[Sep]
::
BinaryDigit
BinaryDigits
[?Sep]
BinaryDigit
[+Sep]
BinaryDigits
[+Sep]
NumericLiteralSeparator
BinaryDigit
BinaryDigit
::
one of
0
1
OctalIntegerLiteral
[Sep]
::
0o
OctalDigits
[?Sep]
0O
OctalDigits
[?Sep]
OctalDigits
[Sep]
::
OctalDigit
OctalDigits
[?Sep]
OctalDigit
[+Sep]
OctalDigits
[+Sep]
NumericLiteralSeparator
OctalDigit
LegacyOctalIntegerLiteral
::
0
OctalDigit
LegacyOctalIntegerLiteral
OctalDigit
NonOctalDecimalIntegerLiteral
::
0
NonOctalDigit
LegacyOctalLikeDecimalIntegerLiteral
NonOctalDigit
NonOctalDecimalIntegerLiteral
DecimalDigit
LegacyOctalLikeDecimalIntegerLiteral
::
0
OctalDigit
LegacyOctalLikeDecimalIntegerLiteral
OctalDigit
OctalDigit
::
one of
0
1
2
3
4
5
6
7
NonOctalDigit
::
one of
8
9
HexIntegerLiteral
[Sep]
::
0x
HexDigits
[?Sep]
0X
HexDigits
[?Sep]
HexDigits
[Sep]
::
HexDigit
HexDigits
[?Sep]
HexDigit
[+Sep]
HexDigits
[+Sep]
NumericLiteralSeparator
HexDigit
HexDigit
::
one of
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
A
B
C
D
E
F
StringLiteral
::
"
DoubleStringCharacters
opt
"
'
SingleStringCharacters
opt
'
DoubleStringCharacters
::
DoubleStringCharacter
DoubleStringCharacters
opt
SingleStringCharacters
::
SingleStringCharacter
SingleStringCharacters
opt
DoubleStringCharacter
::
SourceCharacter
but not one of
"
or
\
or
LineTerminator
<LS>
<PS>
\
EscapeSequence
LineContinuation
SingleStringCharacter
::
SourceCharacter
but not one of
'
or
\
or
LineTerminator
<LS>
<PS>
\
EscapeSequence
LineContinuation
LineContinuation
::
\
LineTerminatorSequence
EscapeSequence
::
CharacterEscapeSequence
0
[lookahead ∉
DecimalDigit
]
LegacyOctalEscapeSequence
NonOctalDecimalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence
CharacterEscapeSequence
::
SingleEscapeCharacter
NonEscapeCharacter
SingleEscapeCharacter
::
one of
'
"
\
b
f
n
r
t
v
NonEscapeCharacter
::
SourceCharacter
but not one of
EscapeCharacter
or
LineTerminator
EscapeCharacter
::
SingleEscapeCharacter
DecimalDigit
x
u
LegacyOctalEscapeSequence
::
0
[lookahead ∈ {
8
,
9
}]
NonZeroOctalDigit
[lookahead ∉
OctalDigit
]
ZeroToThree
OctalDigit
[lookahead ∉
OctalDigit
]
FourToSeven
OctalDigit
ZeroToThree
OctalDigit
OctalDigit
NonZeroOctalDigit
::
OctalDigit
but not
0
ZeroToThree
::
one of
0
1
2
3
FourToSeven
::
one of
4
5
6
7
NonOctalDecimalEscapeSequence
::
one of
8
9
HexEscapeSequence
::
x
HexDigit
HexDigit
UnicodeEscapeSequence
::
u
Hex4Digits
u{
CodePoint
}
Hex4Digits
::
HexDigit
HexDigit
HexDigit
HexDigit
RegularExpressionLiteral
::
/
RegularExpressionBody
/
RegularExpressionFlags
RegularExpressionBody
::
RegularExpressionFirstChar
RegularExpressionChars
RegularExpressionChars
::
[empty]
RegularExpressionChars
RegularExpressionChar
RegularExpressionFirstChar
::
RegularExpressionNonTerminator
but not one of
*
or
\
or
/
or
[
RegularExpressionBackslashSequence
RegularExpressionClass
RegularExpressionChar
::
RegularExpressionNonTerminator
but not one of
\
or
/
or
[
RegularExpressionBackslashSequence
RegularExpressionClass
RegularExpressionBackslashSequence
::
\
RegularExpressionNonTerminator
RegularExpressionNonTerminator
::
SourceCharacter
but not
LineTerminator
RegularExpressionClass
::
[
RegularExpressionClassChars
]
RegularExpressionClassChars
::
[empty]
RegularExpressionClassChars
RegularExpressionClassChar
RegularExpressionClassChar
::
RegularExpressionNonTerminator
but not one of
]
or
\
RegularExpressionBackslashSequence
RegularExpressionFlags
::
[empty]
RegularExpressionFlags
IdentifierPartChar
Template
::
NoSubstitutionTemplate
TemplateHead
NoSubstitutionTemplate
::
`
TemplateCharacters
opt
`
TemplateHead
::
`
TemplateCharacters
opt
${
TemplateSubstitutionTail
::
TemplateMiddle
TemplateTail
TemplateMiddle
::
}
TemplateCharacters
opt
${
TemplateTail
::
}
TemplateCharacters
opt
`
TemplateCharacters
::
TemplateCharacter
TemplateCharacters
opt
TemplateCharacter
::
$
[lookahead ≠
{
]
\
TemplateEscapeSequence
\
NotEscapeSequence
LineContinuation
LineTerminatorSequence
SourceCharacter
but not one of
`
or
\
or
$
or
LineTerminator
TemplateEscapeSequence
::
CharacterEscapeSequence
0
[lookahead ∉
DecimalDigit
]
HexEscapeSequence
UnicodeEscapeSequence
NotEscapeSequence
::
0
DecimalDigit
DecimalDigit
but not
0
x
[lookahead ∉
HexDigit
]
x
HexDigit
[lookahead ∉
HexDigit
]
u
[lookahead ∉
HexDigit
]
[lookahead ≠
{
]
u
HexDigit
[lookahead ∉
HexDigit
]
u
HexDigit
HexDigit
[lookahead ∉
HexDigit
]
u
HexDigit
HexDigit
HexDigit
[lookahead ∉
HexDigit
]
u
{
[lookahead ∉
HexDigit
]
u
{
NotCodePoint
[lookahead ∉
HexDigit
]
u
{
CodePoint
[lookahead ∉
HexDigit
]
[lookahead ≠
}
]
NotCodePoint
::
HexDigits
[~Sep]
but only if the MV of
HexDigits
> 0x10FFFF
CodePoint
::
HexDigits
[~Sep]
but only if the MV of
HexDigits
≤ 0x10FFFF
A.2
Expressions
IdentifierReference
[Yield, Await]
:
Identifier
[~Yield]
yield
[~Await]
await
BindingIdentifier
[Yield, Await]
:
Identifier
yield
await
LabelIdentifier
[Yield, Await]
:
Identifier
[~Yield]
yield
[~Await]
await
Identifier
:
IdentifierName
but not
ReservedWord
PrimaryExpression
[Yield, Await]
:
this
IdentifierReference
[?Yield, ?Await]
Literal
ArrayLiteral
[?Yield, ?Await]
ObjectLiteral
[?Yield, ?Await]
FunctionExpression
ClassExpression
[?Yield, ?Await]
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
[?Yield, ?Await, ~Tagged]
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
CoverParenthesizedExpressionAndArrowParameterList
[Yield, Await]
:
(
Expression
[+In, ?Yield, ?Await]
)
(
Expression
[+In, ?Yield, ?Await]
,
)
(
)
(
...
BindingIdentifier
[?Yield, ?Await]
)
(
...
BindingPattern
[?Yield, ?Await]
)
(
Expression
[+In, ?Yield, ?Await]
,
...
BindingIdentifier
[?Yield, ?Await]
)
(
Expression
[+In, ?Yield, ?Await]
,
...
BindingPattern
[?Yield, ?Await]
)
When processing an instance of the production
PrimaryExpression
[Yield, Await]
:
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
the interpretation of
CoverParenthesizedExpressionAndArrowParameterList
is refined using the following grammar:
ParenthesizedExpression
[Yield, Await]
:
(
Expression
[+In, ?Yield, ?Await]
)
Literal
:
NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
ArrayLiteral
[Yield, Await]
:
[
Elision
opt
]
[
ElementList
[?Yield, ?Await]
]
[
ElementList
[?Yield, ?Await]
,
Elision
opt
]
ElementList
[Yield, Await]
:
Elision
opt
AssignmentExpression
[+In, ?Yield, ?Await]
Elision
opt
SpreadElement
[?Yield, ?Await]
ElementList
[?Yield, ?Await]
,
Elision
opt
AssignmentExpression
[+In, ?Yield, ?Await]
ElementList
[?Yield, ?Await]
,
Elision
opt
SpreadElement
[?Yield, ?Await]
Elision
:
,
Elision
,
SpreadElement
[Yield, Await]
:
...
AssignmentExpression
[+In, ?Yield, ?Await]
ObjectLiteral
[Yield, Await]
:
{
}
{
PropertyDefinitionList
[?Yield, ?Await]
}
{
PropertyDefinitionList
[?Yield, ?Await]
,
}
PropertyDefinitionList
[Yield, Await]
:
PropertyDefinition
[?Yield, ?Await]
PropertyDefinitionList
[?Yield, ?Await]
,
PropertyDefinition
[?Yield, ?Await]
PropertyDefinition
[Yield, Await]
:
IdentifierReference
[?Yield, ?Await]
CoverInitializedName
[?Yield, ?Await]
PropertyName
[?Yield, ?Await]
:
AssignmentExpression
[+In, ?Yield, ?Await]
MethodDefinition
[?Yield, ?Await]
...
AssignmentExpression
[+In, ?Yield, ?Await]
PropertyName
[Yield, Await]
:
LiteralPropertyName
ComputedPropertyName
[?Yield, ?Await]
LiteralPropertyName
:
IdentifierName
StringLiteral
NumericLiteral
ComputedPropertyName
[Yield, Await]
:
[
AssignmentExpression
[+In, ?Yield, ?Await]
]
CoverInitializedName
[Yield, Await]
:
IdentifierReference
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
Initializer
[In, Yield, Await]
:
=
AssignmentExpression
[?In, ?Yield, ?Await]
TemplateLiteral
[Yield, Await, Tagged]
:
NoSubstitutionTemplate
SubstitutionTemplate
[?Yield, ?Await, ?Tagged]
SubstitutionTemplate
[Yield, Await, Tagged]
:
TemplateHead
Expression
[+In, ?Yield, ?Await]
TemplateSpans
[?Yield, ?Await, ?Tagged]
TemplateSpans
[Yield, Await, Tagged]
:
TemplateTail
TemplateMiddleList
[?Yield, ?Await, ?Tagged]
TemplateTail
TemplateMiddleList
[Yield, Await, Tagged]
:
TemplateMiddle
Expression
[+In, ?Yield, ?Await]
TemplateMiddleList
[?Yield, ?Await, ?Tagged]
TemplateMiddle
Expression
[+In, ?Yield, ?Await]
MemberExpression
[Yield, Await]
:
PrimaryExpression
[?Yield, ?Await]
MemberExpression
[?Yield, ?Await]
[
Expression
[+In, ?Yield, ?Await]
]
MemberExpression
[?Yield, ?Await]
.
IdentifierName
MemberExpression
[?Yield, ?Await]
TemplateLiteral
[?Yield, ?Await, +Tagged]
SuperProperty
[?Yield, ?Await]
MetaProperty
new
MemberExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
MemberExpression
[?Yield, ?Await]
.
PrivateIdentifier
SuperProperty
[Yield, Await]
:
super
[
Expression
[+In, ?Yield, ?Await]
]
super
.
IdentifierName
MetaProperty
:
NewTarget
ImportMeta
NewTarget
:
new
.
target
ImportMeta
:
import
.
meta
NewExpression
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
new
NewExpression
[?Yield, ?Await]
CallExpression
[Yield, Await]
:
CoverCallExpressionAndAsyncArrowHead
[?Yield, ?Await]
SuperCall
[?Yield, ?Await]
ImportCall
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
[
Expression
[+In, ?Yield, ?Await]
]
CallExpression
[?Yield, ?Await]
.
IdentifierName
CallExpression
[?Yield, ?Await]
TemplateLiteral
[?Yield, ?Await, +Tagged]
CallExpression
[?Yield, ?Await]
.
PrivateIdentifier
When processing an instance of the production
CallExpression
[Yield, Await]
:
CoverCallExpressionAndAsyncArrowHead
[?Yield, ?Await]
the interpretation of
CoverCallExpressionAndAsyncArrowHead
is refined using the following grammar:
CallMemberExpression
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
SuperCall
[Yield, Await]
:
super
Arguments
[?Yield, ?Await]
ImportCall
[Yield, Await]
:
import
(
AssignmentExpression
[+In, ?Yield, ?Await]
,
opt
)
import
(
AssignmentExpression
[+In, ?Yield, ?Await]
,
AssignmentExpression
[+In, ?Yield, ?Await]
,
opt
)
Arguments
[Yield, Await]
:
(
)
(
ArgumentList
[?Yield, ?Await]
)
(
ArgumentList
[?Yield, ?Await]
,
)
ArgumentList
[Yield, Await]
:
AssignmentExpression
[+In, ?Yield, ?Await]
...
AssignmentExpression
[+In, ?Yield, ?Await]
ArgumentList
[?Yield, ?Await]
,
AssignmentExpression
[+In, ?Yield, ?Await]
ArgumentList
[?Yield, ?Await]
,
...
AssignmentExpression
[+In, ?Yield, ?Await]
OptionalExpression
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
OptionalExpression
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
OptionalChain
[Yield, Await]
:
?.
Arguments
[?Yield, ?Await]
?.
[
Expression
[+In, ?Yield, ?Await]
]
?.
IdentifierName
?.
TemplateLiteral
[?Yield, ?Await, +Tagged]
?.
PrivateIdentifier
OptionalChain
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
OptionalChain
[?Yield, ?Await]
[
Expression
[+In, ?Yield, ?Await]
]
OptionalChain
[?Yield, ?Await]
.
IdentifierName
OptionalChain
[?Yield, ?Await]
TemplateLiteral
[?Yield, ?Await, +Tagged]
OptionalChain
[?Yield, ?Await]
.
PrivateIdentifier
LeftHandSideExpression
[Yield, Await]
:
NewExpression
[?Yield, ?Await]
CallExpression
[?Yield, ?Await]
OptionalExpression
[?Yield, ?Await]
UpdateExpression
[Yield, Await]
:
LeftHandSideExpression
[?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
[no
LineTerminator
here]
++
LeftHandSideExpression
[?Yield, ?Await]
[no
LineTerminator
here]
--
++
UnaryExpression
[?Yield, ?Await]
--
UnaryExpression
[?Yield, ?Await]
UnaryExpression
[Yield, Await]
:
UpdateExpression
[?Yield, ?Await]
delete
UnaryExpression
[?Yield, ?Await]
void
UnaryExpression
[?Yield, ?Await]
typeof
UnaryExpression
[?Yield, ?Await]
+
UnaryExpression
[?Yield, ?Await]
-
UnaryExpression
[?Yield, ?Await]
~
UnaryExpression
[?Yield, ?Await]
!
UnaryExpression
[?Yield, ?Await]
[+Await]
AwaitExpression
[?Yield]
ExponentiationExpression
[Yield, Await]
:
UnaryExpression
[?Yield, ?Await]
UpdateExpression
[?Yield, ?Await]
**
ExponentiationExpression
[?Yield, ?Await]
MultiplicativeExpression
[Yield, Await]
:
ExponentiationExpression
[?Yield, ?Await]
MultiplicativeExpression
[?Yield, ?Await]
MultiplicativeOperator
ExponentiationExpression
[?Yield, ?Await]
MultiplicativeOperator
:
one of
*
/
%
AdditiveExpression
[Yield, Await]
:
MultiplicativeExpression
[?Yield, ?Await]
AdditiveExpression
[?Yield, ?Await]
+
MultiplicativeExpression
[?Yield, ?Await]
AdditiveExpression
[?Yield, ?Await]
-
MultiplicativeExpression
[?Yield, ?Await]
ShiftExpression
[Yield, Await]
:
AdditiveExpression
[?Yield, ?Await]
ShiftExpression
[?Yield, ?Await]
<<
AdditiveExpression
[?Yield, ?Await]
ShiftExpression
[?Yield, ?Await]
>>
AdditiveExpression
[?Yield, ?Await]
ShiftExpression
[?Yield, ?Await]
>>>
AdditiveExpression
[?Yield, ?Await]
RelationalExpression
[In, Yield, Await]
:
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
<
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
>
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
<=
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
>=
ShiftExpression
[?Yield, ?Await]
RelationalExpression
[?In, ?Yield, ?Await]
instanceof
ShiftExpression
[?Yield, ?Await]
[+In]
RelationalExpression
[+In, ?Yield, ?Await]
in
ShiftExpression
[?Yield, ?Await]
[+In]
PrivateIdentifier
in
ShiftExpression
[?Yield, ?Await]
EqualityExpression
[In, Yield, Await]
:
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
==
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
!=
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
===
RelationalExpression
[?In, ?Yield, ?Await]
EqualityExpression
[?In, ?Yield, ?Await]
!==
RelationalExpression
[?In, ?Yield, ?Await]
BitwiseANDExpression
[In, Yield, Await]
:
EqualityExpression
[?In, ?Yield, ?Await]
BitwiseANDExpression
[?In, ?Yield, ?Await]
&
EqualityExpression
[?In, ?Yield, ?Await]
BitwiseXORExpression
[In, Yield, Await]
:
BitwiseANDExpression
[?In, ?Yield, ?Await]
BitwiseXORExpression
[?In, ?Yield, ?Await]
^
BitwiseANDExpression
[?In, ?Yield, ?Await]
BitwiseORExpression
[In, Yield, Await]
:
BitwiseXORExpression
[?In, ?Yield, ?Await]
BitwiseORExpression
[?In, ?Yield, ?Await]
|
BitwiseXORExpression
[?In, ?Yield, ?Await]
LogicalANDExpression
[In, Yield, Await]
:
BitwiseORExpression
[?In, ?Yield, ?Await]
LogicalANDExpression
[?In, ?Yield, ?Await]
&&
BitwiseORExpression
[?In, ?Yield, ?Await]
LogicalORExpression
[In, Yield, Await]
:
LogicalANDExpression
[?In, ?Yield, ?Await]
LogicalORExpression
[?In, ?Yield, ?Await]
||
LogicalANDExpression
[?In, ?Yield, ?Await]
CoalesceExpression
[In, Yield, Await]
:
CoalesceExpressionHead
[?In, ?Yield, ?Await]
??
BitwiseORExpression
[?In, ?Yield, ?Await]
CoalesceExpressionHead
[In, Yield, Await]
:
CoalesceExpression
[?In, ?Yield, ?Await]
BitwiseORExpression
[?In, ?Yield, ?Await]
ShortCircuitExpression
[In, Yield, Await]
:
LogicalORExpression
[?In, ?Yield, ?Await]
CoalesceExpression
[?In, ?Yield, ?Await]
ConditionalExpression
[In, Yield, Await]
:
ShortCircuitExpression
[?In, ?Yield, ?Await]
ShortCircuitExpression
[?In, ?Yield, ?Await]
?
AssignmentExpression
[+In, ?Yield, ?Await]
:
AssignmentExpression
[?In, ?Yield, ?Await]
AssignmentExpression
[In, Yield, Await]
:
ConditionalExpression
[?In, ?Yield, ?Await]
[+Yield]
YieldExpression
[?In, ?Await]
ArrowFunction
[?In, ?Yield, ?Await]
AsyncArrowFunction
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
=
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
AssignmentOperator
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
&&=
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
||=
AssignmentExpression
[?In, ?Yield, ?Await]
LeftHandSideExpression
[?Yield, ?Await]
??=
AssignmentExpression
[?In, ?Yield, ?Await]
AssignmentOperator
:
one of
*=
/=
%=
+=
-=
<<=
>>=
>>>=
&=
^=
|=
**=
In certain circumstances when processing an instance of the production
AssignmentExpression
[In, Yield, Await]
:
LeftHandSideExpression
[?Yield, ?Await]
=
AssignmentExpression
[?In, ?Yield, ?Await]
the interpretation of
LeftHandSideExpression
is refined using the following grammar:
AssignmentPattern
[Yield, Await]
:
ObjectAssignmentPattern
[?Yield, ?Await]
ArrayAssignmentPattern
[?Yield, ?Await]
ObjectAssignmentPattern
[Yield, Await]
:
{
}
{
AssignmentRestProperty
[?Yield, ?Await]
}
{
AssignmentPropertyList
[?Yield, ?Await]
}
{
AssignmentPropertyList
[?Yield, ?Await]
,
AssignmentRestProperty
[?Yield, ?Await]
opt
}
ArrayAssignmentPattern
[Yield, Await]
:
[
Elision
opt
AssignmentRestElement
[?Yield, ?Await]
opt
]
[
AssignmentElementList
[?Yield, ?Await]
]
[
AssignmentElementList
[?Yield, ?Await]
,
Elision
opt
AssignmentRestElement
[?Yield, ?Await]
opt
]
AssignmentRestProperty
[Yield, Await]
:
...
DestructuringAssignmentTarget
[?Yield, ?Await]
AssignmentPropertyList
[Yield, Await]
:
AssignmentProperty
[?Yield, ?Await]
AssignmentPropertyList
[?Yield, ?Await]
,
AssignmentProperty
[?Yield, ?Await]
AssignmentElementList
[Yield, Await]
:
AssignmentElisionElement
[?Yield, ?Await]
AssignmentElementList
[?Yield, ?Await]
,
AssignmentElisionElement
[?Yield, ?Await]
AssignmentElisionElement
[Yield, Await]
:
Elision
opt
AssignmentElement
[?Yield, ?Await]
AssignmentProperty
[Yield, Await]
:
IdentifierReference
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
PropertyName
[?Yield, ?Await]
:
AssignmentElement
[?Yield, ?Await]
AssignmentElement
[Yield, Await]
:
DestructuringAssignmentTarget
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
AssignmentRestElement
[Yield, Await]
:
...
DestructuringAssignmentTarget
[?Yield, ?Await]
DestructuringAssignmentTarget
[Yield, Await]
:
LeftHandSideExpression
[?Yield, ?Await]
Expression
[In, Yield, Await]
:
AssignmentExpression
[?In, ?Yield, ?Await]
Expression
[?In, ?Yield, ?Await]
,
AssignmentExpression
[?In, ?Yield, ?Await]
A.3
Statements
Statement
[Yield, Await, Return]
:
BlockStatement
[?Yield, ?Await, ?Return]
VariableStatement
[?Yield, ?Await]
EmptyStatement
ExpressionStatement
[?Yield, ?Await]
IfStatement
[?Yield, ?Await, ?Return]
BreakableStatement
[?Yield, ?Await, ?Return]
ContinueStatement
[?Yield, ?Await]
BreakStatement
[?Yield, ?Await]
[+Return]
ReturnStatement
[?Yield, ?Await]
WithStatement
[?Yield, ?Await, ?Return]
LabelledStatement
[?Yield, ?Await, ?Return]
ThrowStatement
[?Yield, ?Await]
TryStatement
[?Yield, ?Await, ?Return]
DebuggerStatement
Declaration
[Yield, Await]
:
HoistableDeclaration
[?Yield, ?Await, ~Default]
ClassDeclaration
[?Yield, ?Await, ~Default]
LexicalDeclaration
[+In, ?Yield, ?Await]
HoistableDeclaration
[Yield, Await, Default]
:
FunctionDeclaration
[?Yield, ?Await, ?Default]
GeneratorDeclaration
[?Yield, ?Await, ?Default]
AsyncFunctionDeclaration
[?Yield, ?Await, ?Default]
AsyncGeneratorDeclaration
[?Yield, ?Await, ?Default]
BreakableStatement
[Yield, Await, Return]
:
IterationStatement
[?Yield, ?Await, ?Return]
SwitchStatement
[?Yield, ?Await, ?Return]
BlockStatement
[Yield, Await, Return]
:
Block
[?Yield, ?Await, ?Return]
Block
[Yield, Await, Return]
:
{
StatementList
[?Yield, ?Await, ?Return]
opt
}
StatementList
[Yield, Await, Return]
:
StatementListItem
[?Yield, ?Await, ?Return]
StatementList
[?Yield, ?Await, ?Return]
StatementListItem
[?Yield, ?Await, ?Return]
StatementListItem
[Yield, Await, Return]
:
Statement
[?Yield, ?Await, ?Return]
Declaration
[?Yield, ?Await]
LexicalDeclaration
[In, Yield, Await]
:
LetOrConst
BindingList
[?In, ?Yield, ?Await]
;
LetOrConst
:
let
const
BindingList
[In, Yield, Await]
:
LexicalBinding
[?In, ?Yield, ?Await]
BindingList
[?In, ?Yield, ?Await]
,
LexicalBinding
[?In, ?Yield, ?Await]
LexicalBinding
[In, Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
opt
BindingPattern
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
VariableStatement
[Yield, Await]
:
var
VariableDeclarationList
[+In, ?Yield, ?Await]
;
VariableDeclarationList
[In, Yield, Await]
:
VariableDeclaration
[?In, ?Yield, ?Await]
VariableDeclarationList
[?In, ?Yield, ?Await]
,
VariableDeclaration
[?In, ?Yield, ?Await]
VariableDeclaration
[In, Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
opt
BindingPattern
[?Yield, ?Await]
Initializer
[?In, ?Yield, ?Await]
BindingPattern
[Yield, Await]
:
ObjectBindingPattern
[?Yield, ?Await]
ArrayBindingPattern
[?Yield, ?Await]
ObjectBindingPattern
[Yield, Await]
:
{
}
{
BindingRestProperty
[?Yield, ?Await]
}
{
BindingPropertyList
[?Yield, ?Await]
}
{
BindingPropertyList
[?Yield, ?Await]
,
BindingRestProperty
[?Yield, ?Await]
opt
}
ArrayBindingPattern
[Yield, Await]
:
[
Elision
opt
BindingRestElement
[?Yield, ?Await]
opt
]
[
BindingElementList
[?Yield, ?Await]
]
[
BindingElementList
[?Yield, ?Await]
,
Elision
opt
BindingRestElement
[?Yield, ?Await]
opt
]
BindingRestProperty
[Yield, Await]
:
...
BindingIdentifier
[?Yield, ?Await]
BindingPropertyList
[Yield, Await]
:
BindingProperty
[?Yield, ?Await]
BindingPropertyList
[?Yield, ?Await]
,
BindingProperty
[?Yield, ?Await]
BindingElementList
[Yield, Await]
:
BindingElisionElement
[?Yield, ?Await]
BindingElementList
[?Yield, ?Await]
,
BindingElisionElement
[?Yield, ?Await]
BindingElisionElement
[Yield, Await]
:
Elision
opt
BindingElement
[?Yield, ?Await]
BindingProperty
[Yield, Await]
:
SingleNameBinding
[?Yield, ?Await]
PropertyName
[?Yield, ?Await]
:
BindingElement
[?Yield, ?Await]
BindingElement
[Yield, Await]
:
SingleNameBinding
[?Yield, ?Await]
BindingPattern
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
SingleNameBinding
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
BindingRestElement
[Yield, Await]
:
...
BindingIdentifier
[?Yield, ?Await]
...
BindingPattern
[?Yield, ?Await]
EmptyStatement
:
;
ExpressionStatement
[Yield, Await]
:
[lookahead ∉ {
{
,
function
,
async
[no
LineTerminator
here]
function
,
class
,
let
[
}]
Expression
[+In, ?Yield, ?Await]
;
IfStatement
[Yield, Await, Return]
:
if
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
else
Statement
[?Yield, ?Await, ?Return]
if
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[lookahead ≠
else
]
IterationStatement
[Yield, Await, Return]
:
DoWhileStatement
[?Yield, ?Await, ?Return]
WhileStatement
[?Yield, ?Await, ?Return]
ForStatement
[?Yield, ?Await, ?Return]
ForInOfStatement
[?Yield, ?Await, ?Return]
DoWhileStatement
[Yield, Await, Return]
:
do
Statement
[?Yield, ?Await, ?Return]
while
(
Expression
[+In, ?Yield, ?Await]
)
;
WhileStatement
[Yield, Await, Return]
:
while
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
ForStatement
[Yield, Await, Return]
:
for
(
[lookahead ≠
let
[
]
Expression
[~In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
)
Statement
[?Yield, ?Await, ?Return]
for
(
var
VariableDeclarationList
[~In, ?Yield, ?Await]
;
Expression
[+In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
)
Statement
[?Yield, ?Await, ?Return]
for
(
LexicalDeclaration
[~In, ?Yield, ?Await]
Expression
[+In, ?Yield, ?Await]
opt
;
Expression
[+In, ?Yield, ?Await]
opt
)
Statement
[?Yield, ?Await, ?Return]
ForInOfStatement
[Yield, Await, Return]
:
for
(
[lookahead ≠
let
[
]
LeftHandSideExpression
[?Yield, ?Await]
in
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
var
ForBinding
[?Yield, ?Await]
in
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
ForDeclaration
[?Yield, ?Await]
in
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
[lookahead ∉ {
let
,
async
of
}]
LeftHandSideExpression
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
var
ForBinding
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
for
(
ForDeclaration
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[+Await]
for
await
(
[lookahead ≠
let
]
LeftHandSideExpression
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[+Await]
for
await
(
var
ForBinding
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
[+Await]
for
await
(
ForDeclaration
[?Yield, ?Await]
of
AssignmentExpression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
ForDeclaration
[Yield, Await]
:
LetOrConst
ForBinding
[?Yield, ?Await]
ForBinding
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
BindingPattern
[?Yield, ?Await]
ContinueStatement
[Yield, Await]
:
continue
;
continue
[no
LineTerminator
here]
LabelIdentifier
[?Yield, ?Await]
;
BreakStatement
[Yield, Await]
:
break
;
break
[no
LineTerminator
here]
LabelIdentifier
[?Yield, ?Await]
;
ReturnStatement
[Yield, Await]
:
return
;
return
[no
LineTerminator
here]
Expression
[+In, ?Yield, ?Await]
;
WithStatement
[Yield, Await, Return]
:
with
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
SwitchStatement
[Yield, Await, Return]
:
switch
(
Expression
[+In, ?Yield, ?Await]
)
CaseBlock
[?Yield, ?Await, ?Return]
CaseBlock
[Yield, Await, Return]
:
{
CaseClauses
[?Yield, ?Await, ?Return]
opt
}
{
CaseClauses
[?Yield, ?Await, ?Return]
opt
DefaultClause
[?Yield, ?Await, ?Return]
CaseClauses
[?Yield, ?Await, ?Return]
opt
}
CaseClauses
[Yield, Await, Return]
:
CaseClause
[?Yield, ?Await, ?Return]
CaseClauses
[?Yield, ?Await, ?Return]
CaseClause
[?Yield, ?Await, ?Return]
CaseClause
[Yield, Await, Return]
:
case
Expression
[+In, ?Yield, ?Await]
:
StatementList
[?Yield, ?Await, ?Return]
opt
DefaultClause
[Yield, Await, Return]
:
default
:
StatementList
[?Yield, ?Await, ?Return]
opt
LabelledStatement
[Yield, Await, Return]
:
LabelIdentifier
[?Yield, ?Await]
:
LabelledItem
[?Yield, ?Await, ?Return]
LabelledItem
[Yield, Await, Return]
:
Statement
[?Yield, ?Await, ?Return]
FunctionDeclaration
[?Yield, ?Await, ~Default]
ThrowStatement
[Yield, Await]
:
throw
[no
LineTerminator
here]
Expression
[+In, ?Yield, ?Await]
;
TryStatement
[Yield, Await, Return]
:
try
Block
[?Yield, ?Await, ?Return]
Catch
[?Yield, ?Await, ?Return]
try
Block
[?Yield, ?Await, ?Return]
Finally
[?Yield, ?Await, ?Return]
try
Block
[?Yield, ?Await, ?Return]
Catch
[?Yield, ?Await, ?Return]
Finally
[?Yield, ?Await, ?Return]
Catch
[Yield, Await, Return]
:
catch
(
CatchParameter
[?Yield, ?Await]
)
Block
[?Yield, ?Await, ?Return]
catch
Block
[?Yield, ?Await, ?Return]
Finally
[Yield, Await, Return]
:
finally
Block
[?Yield, ?Await, ?Return]
CatchParameter
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
BindingPattern
[?Yield, ?Await]
DebuggerStatement
:
debugger
;
A.4
Functions and Classes
UniqueFormalParameters
[Yield, Await]
:
FormalParameters
[?Yield, ?Await]
FormalParameters
[Yield, Await]
:
[empty]
FunctionRestParameter
[?Yield, ?Await]
FormalParameterList
[?Yield, ?Await]
FormalParameterList
[?Yield, ?Await]
,
FormalParameterList
[?Yield, ?Await]
,
FunctionRestParameter
[?Yield, ?Await]
FormalParameterList
[Yield, Await]
:
FormalParameter
[?Yield, ?Await]
FormalParameterList
[?Yield, ?Await]
,
FormalParameter
[?Yield, ?Await]
FunctionRestParameter
[Yield, Await]
:
BindingRestElement
[?Yield, ?Await]
FormalParameter
[Yield, Await]
:
BindingElement
[?Yield, ?Await]
FunctionDeclaration
[Yield, Await, Default]
:
function
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
[+Default]
function
(
FormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
FunctionExpression
:
function
BindingIdentifier
[~Yield, ~Await]
opt
(
FormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
FunctionBody
[Yield, Await]
:
FunctionStatementList
[?Yield, ?Await]
FunctionStatementList
[Yield, Await]
:
StatementList
[?Yield, ?Await, +Return]
opt
ArrowFunction
[In, Yield, Await]
:
ArrowParameters
[?Yield, ?Await]
[no
LineTerminator
here]
=>
ConciseBody
[?In]
ArrowParameters
[Yield, Await]
:
BindingIdentifier
[?Yield, ?Await]
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
ConciseBody
[In]
:
[lookahead ≠
{
]
ExpressionBody
[?In, ~Await]
{
FunctionBody
[~Yield, ~Await]
}
ExpressionBody
[In, Await]
:
AssignmentExpression
[?In, ~Yield, ?Await]
When processing an instance of the production
ArrowParameters
[Yield, Await]
:
CoverParenthesizedExpressionAndArrowParameterList
[?Yield, ?Await]
the interpretation of
CoverParenthesizedExpressionAndArrowParameterList
is refined using the following grammar:
ArrowFormalParameters
[Yield, Await]
:
(
UniqueFormalParameters
[?Yield, ?Await]
)
AsyncArrowFunction
[In, Yield, Await]
:
async
[no
LineTerminator
here]
AsyncArrowBindingIdentifier
[?Yield]
[no
LineTerminator
here]
=>
AsyncConciseBody
[?In]
CoverCallExpressionAndAsyncArrowHead
[?Yield, ?Await]
[no
LineTerminator
here]
=>
AsyncConciseBody
[?In]
AsyncConciseBody
[In]
:
[lookahead ≠
{
]
ExpressionBody
[?In, +Await]
{
AsyncFunctionBody
}
AsyncArrowBindingIdentifier
[Yield]
:
BindingIdentifier
[?Yield, +Await]
CoverCallExpressionAndAsyncArrowHead
[Yield, Await]
:
MemberExpression
[?Yield, ?Await]
Arguments
[?Yield, ?Await]
When processing an instance of the production
AsyncArrowFunction
[In, Yield, Await]
:
CoverCallExpressionAndAsyncArrowHead
[?Yield, ?Await]
[no
LineTerminator
here]
=>
AsyncConciseBody
[?In]
the interpretation of
CoverCallExpressionAndAsyncArrowHead
is refined using the following grammar:
AsyncArrowHead
:
async
[no
LineTerminator
here]
ArrowFormalParameters
[~Yield, +Await]
MethodDefinition
[Yield, Await]
:
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[~Yield, ~Await]
)
{
FunctionBody
[~Yield, ~Await]
}
GeneratorMethod
[?Yield, ?Await]
AsyncMethod
[?Yield, ?Await]
AsyncGeneratorMethod
[?Yield, ?Await]
get
ClassElementName
[?Yield, ?Await]
(
)
{
FunctionBody
[~Yield, ~Await]
}
set
ClassElementName
[?Yield, ?Await]
(
PropertySetParameterList
)
{
FunctionBody
[~Yield, ~Await]
}
PropertySetParameterList
:
FormalParameter
[~Yield, ~Await]
GeneratorDeclaration
[Yield, Await, Default]
:
function
*
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
[+Default]
function
*
(
FormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
GeneratorExpression
:
function
*
BindingIdentifier
[+Yield, ~Await]
opt
(
FormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
GeneratorMethod
[Yield, Await]
:
*
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[+Yield, ~Await]
)
{
GeneratorBody
}
GeneratorBody
:
FunctionBody
[+Yield, ~Await]
YieldExpression
[In, Await]
:
yield
yield
[no
LineTerminator
here]
AssignmentExpression
[?In, +Yield, ?Await]
yield
[no
LineTerminator
here]
*
AssignmentExpression
[?In, +Yield, ?Await]
AsyncGeneratorDeclaration
[Yield, Await, Default]
:
async
[no
LineTerminator
here]
function
*
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
[+Default]
async
[no
LineTerminator
here]
function
*
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorExpression
:
async
[no
LineTerminator
here]
function
*
BindingIdentifier
[+Yield, +Await]
opt
(
FormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorMethod
[Yield, Await]
:
async
[no
LineTerminator
here]
*
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[+Yield, +Await]
)
{
AsyncGeneratorBody
}
AsyncGeneratorBody
:
FunctionBody
[+Yield, +Await]
AsyncFunctionDeclaration
[Yield, Await, Default]
:
async
[no
LineTerminator
here]
function
BindingIdentifier
[?Yield, ?Await]
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
[+Default]
async
[no
LineTerminator
here]
function
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncFunctionExpression
:
async
[no
LineTerminator
here]
function
BindingIdentifier
[~Yield, +Await]
opt
(
FormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncMethod
[Yield, Await]
:
async
[no
LineTerminator
here]
ClassElementName
[?Yield, ?Await]
(
UniqueFormalParameters
[~Yield, +Await]
)
{
AsyncFunctionBody
}
AsyncFunctionBody
:
FunctionBody
[~Yield, +Await]
AwaitExpression
[Yield]
:
await
UnaryExpression
[?Yield, +Await]
ClassDeclaration
[Yield, Await, Default]
:
class
BindingIdentifier
[?Yield, ?Await]
ClassTail
[?Yield, ?Await]
[+Default]
class
ClassTail
[?Yield, ?Await]
ClassExpression
[Yield, Await]
:
class
BindingIdentifier
[?Yield, ?Await]
opt
ClassTail
[?Yield, ?Await]
ClassTail
[Yield, Await]
:
ClassHeritage
[?Yield, ?Await]
opt
{
ClassBody
[?Yield, ?Await]
opt
}
ClassHeritage
[Yield, Await]
:
extends
LeftHandSideExpression
[?Yield, ?Await]
ClassBody
[Yield, Await]
:
ClassElementList
[?Yield, ?Await]
ClassElementList
[Yield, Await]
:
ClassElement
[?Yield, ?Await]
ClassElementList
[?Yield, ?Await]
ClassElement
[?Yield, ?Await]
ClassElement
[Yield, Await]
:
MethodDefinition
[?Yield, ?Await]
static
MethodDefinition
[?Yield, ?Await]
FieldDefinition
[?Yield, ?Await]
;
static
FieldDefinition
[?Yield, ?Await]
;
ClassStaticBlock
;
FieldDefinition
[Yield, Await]
:
ClassElementName
[?Yield, ?Await]
Initializer
[+In, ?Yield, ?Await]
opt
ClassElementName
[Yield, Await]
:
PropertyName
[?Yield, ?Await]
PrivateIdentifier
ClassStaticBlock
:
static
{
ClassStaticBlockBody
}
ClassStaticBlockBody
:
ClassStaticBlockStatementList
ClassStaticBlockStatementList
:
StatementList
[~Yield, +Await, ~Return]
opt
A.5
Scripts and Modules
Script
:
ScriptBody
opt
ScriptBody
:
StatementList
[~Yield, ~Await, ~Return]
Module
:
ModuleBody
opt
ModuleBody
:
ModuleItemList
ModuleItemList
:
ModuleItem
ModuleItemList
ModuleItem
ModuleItem
:
ImportDeclaration
ExportDeclaration
StatementListItem
[~Yield, +Await, ~Return]
ModuleExportName
:
IdentifierName
StringLiteral
ImportDeclaration
:
import
ImportClause
FromClause
WithClause
opt
;
import
ModuleSpecifier
WithClause
opt
;
ImportClause
:
ImportedDefaultBinding
NameSpaceImport
NamedImports
ImportedDefaultBinding
,
NameSpaceImport
ImportedDefaultBinding
,
NamedImports
ImportedDefaultBinding
:
ImportedBinding
NameSpaceImport
:
*
as
ImportedBinding
NamedImports
:
{
}
{
ImportsList
}
{
ImportsList
,
}
FromClause
:
from
ModuleSpecifier
ImportsList
:
ImportSpecifier
ImportsList
,
ImportSpecifier
ImportSpecifier
:
ImportedBinding
ModuleExportName
as
ImportedBinding
ModuleSpecifier
:
StringLiteral
ImportedBinding
:
BindingIdentifier
[~Yield, +Await]
WithClause
:
with
{
}
with
{
WithEntries
,
opt
}
WithEntries
:
AttributeKey
:
StringLiteral
AttributeKey
:
StringLiteral
,
WithEntries
AttributeKey
:
IdentifierName
StringLiteral
ExportDeclaration
:
export
ExportFromClause
FromClause
WithClause
opt
;
export
NamedExports
;
export
VariableStatement
[~Yield, +Await]
export
Declaration
[~Yield, +Await]
export
default
HoistableDeclaration
[~Yield, +Await, +Default]
export
default
ClassDeclaration
[~Yield, +Await, +Default]
export
default
[lookahead ∉ {
function
,
async
[no
LineTerminator
here]
function
,
class
}]
AssignmentExpression
[+In, ~Yield, +Await]
;
ExportFromClause
:
*
*
as
ModuleExportName
NamedExports
NamedExports
:
{
}
{
ExportsList
}
{
ExportsList
,
}
ExportsList
:
ExportSpecifier
ExportsList
,
ExportSpecifier
ExportSpecifier
:
ModuleExportName
ModuleExportName
as
ModuleExportName
A.6
Number Conversions
StringNumericLiteral
:::
StrWhiteSpace
opt
StrWhiteSpace
opt
StrNumericLiteral
StrWhiteSpace
opt
StrWhiteSpace
:::
StrWhiteSpaceChar
StrWhiteSpace
opt
StrWhiteSpaceChar
:::
WhiteSpace
LineTerminator
StrNumericLiteral
:::
StrDecimalLiteral
NonDecimalIntegerLiteral
[~Sep]
StrDecimalLiteral
:::
StrUnsignedDecimalLiteral
+
StrUnsignedDecimalLiteral
-
StrUnsignedDecimalLiteral
StrUnsignedDecimalLiteral
:::
Infinity
DecimalDigits
[~Sep]
.
DecimalDigits
[~Sep]
opt
ExponentPart
[~Sep]
opt
.
DecimalDigits
[~Sep]
ExponentPart
[~Sep]
opt
DecimalDigits
[~Sep]
ExponentPart
[~Sep]
opt
All grammar symbols not explicitly defined by the
StringNumericLiteral
grammar have the definitions used in the
Lexical Grammar for numeric literals
.
StringIntegerLiteral
:::
StrWhiteSpace
opt
StrWhiteSpace
opt
StrIntegerLiteral
StrWhiteSpace
opt
StrIntegerLiteral
:::
SignedInteger
[~Sep]
NonDecimalIntegerLiteral
[~Sep]
A.7
Time Zone Offset String Format
UTCOffset
:::
ASCIISign
Hour
ASCIISign
Hour
HourSubcomponents
[+Extended]
ASCIISign
Hour
HourSubcomponents
[~Extended]
ASCIISign
:::
one of
+
-
Hour
:::
0
DecimalDigit
1
DecimalDigit
20
21
22
23
HourSubcomponents
[Extended]
:::
TimeSeparator
[?Extended]
MinuteSecond
TimeSeparator
[?Extended]
MinuteSecond
TimeSeparator
[?Extended]
MinuteSecond
TemporalDecimalFraction
opt
TimeSeparator
[Extended]
:::
[+Extended]
:
[~Extended]
[empty]
MinuteSecond
:::
0
DecimalDigit
1
DecimalDigit
2
DecimalDigit
3
DecimalDigit
4
DecimalDigit
5
DecimalDigit
TemporalDecimalFraction
:::
TemporalDecimalSeparator
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
DecimalDigit
TemporalDecimalSeparator
:::
one of
.
,
A.8
Regular Expressions
Pattern
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Disjunction
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
Alternative
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
|
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Alternative
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
[empty]
Alternative
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Term
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Term
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
Assertion
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Atom
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Quantifier
Assertion
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
^
$
\b
\B
(?=
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?!
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?<=
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?<!
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
Quantifier
::
QuantifierPrefix
QuantifierPrefix
?
QuantifierPrefix
::
*
+
?
{
DecimalDigits
[~Sep]
}
{
DecimalDigits
[~Sep]
,}
{
DecimalDigits
[~Sep]
,
DecimalDigits
[~Sep]
}
Atom
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
PatternCharacter
.
\
AtomEscape
[?UnicodeMode, ?NamedCaptureGroups]
CharacterClass
[?UnicodeMode, ?UnicodeSetsMode]
(
GroupSpecifier
[?UnicodeMode]
opt
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?
RegularExpressionModifiers
:
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?
RegularExpressionModifiers
-
RegularExpressionModifiers
:
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
RegularExpressionModifiers
::
[empty]
RegularExpressionModifiers
RegularExpressionModifier
RegularExpressionModifier
::
one of
i
m
s
SyntaxCharacter
::
one of
^
$
\
.
*
+
?
(
)
[
]
{
}
|
PatternCharacter
::
SourceCharacter
but not
SyntaxCharacter
AtomEscape
[UnicodeMode, NamedCaptureGroups]
::
DecimalEscape
CharacterClassEscape
[?UnicodeMode]
CharacterEscape
[?UnicodeMode]
[+NamedCaptureGroups]
k
GroupName
[?UnicodeMode]
CharacterEscape
[UnicodeMode]
::
ControlEscape
c
AsciiLetter
0
[lookahead ∉
DecimalDigit
]
HexEscapeSequence
RegExpUnicodeEscapeSequence
[?UnicodeMode]
IdentityEscape
[?UnicodeMode]
ControlEscape
::
one of
f
n
r
t
v
GroupSpecifier
[UnicodeMode]
::
?
GroupName
[?UnicodeMode]
GroupName
[UnicodeMode]
::
<
RegExpIdentifierName
[?UnicodeMode]
>
RegExpIdentifierName
[UnicodeMode]
::
RegExpIdentifierStart
[?UnicodeMode]
RegExpIdentifierName
[?UnicodeMode]
RegExpIdentifierPart
[?UnicodeMode]
RegExpIdentifierStart
[UnicodeMode]
::
IdentifierStartChar
\
RegExpUnicodeEscapeSequence
[+UnicodeMode]
[~UnicodeMode]
UnicodeLeadSurrogate
UnicodeTrailSurrogate
RegExpIdentifierPart
[UnicodeMode]
::
IdentifierPartChar
\
RegExpUnicodeEscapeSequence
[+UnicodeMode]
[~UnicodeMode]
UnicodeLeadSurrogate
UnicodeTrailSurrogate
RegExpUnicodeEscapeSequence
[UnicodeMode]
::
[+UnicodeMode]
u
HexLeadSurrogate
\u
HexTrailSurrogate
[+UnicodeMode]
u
HexLeadSurrogate
[+UnicodeMode]
u
HexTrailSurrogate
[+UnicodeMode]
u
HexNonSurrogate
[~UnicodeMode]
u
Hex4Digits
[+UnicodeMode]
u{
CodePoint
}
UnicodeLeadSurrogate
::
any Unicode code point in the inclusive interval from U+D800 to U+DBFF
UnicodeTrailSurrogate
::
any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
Each
\u
HexTrailSurrogate
for which the choice of associated
u
HexLeadSurrogate
is ambiguous shall be associated with the nearest possible
u
HexLeadSurrogate
that would otherwise have no corresponding
\u
HexTrailSurrogate
.
HexLeadSurrogate
::
Hex4Digits
but only if the MV of
Hex4Digits
is in the
inclusive interval
from 0xD800 to 0xDBFF
HexTrailSurrogate
::
Hex4Digits
but only if the MV of
Hex4Digits
is in the
inclusive interval
from 0xDC00 to 0xDFFF
HexNonSurrogate
::
Hex4Digits
but only if the MV of
Hex4Digits
is not in the
inclusive interval
from 0xD800 to 0xDFFF
IdentityEscape
[UnicodeMode]
::
[+UnicodeMode]
SyntaxCharacter
[+UnicodeMode]
/
[~UnicodeMode]
SourceCharacter
but not
UnicodeIDContinue
DecimalEscape
::
NonZeroDigit
DecimalDigits
[~Sep]
opt
[lookahead ∉
DecimalDigit
]
CharacterClassEscape
[UnicodeMode]
::
d
D
s
S
w
W
[+UnicodeMode]
p{
UnicodePropertyValueExpression
}
[+UnicodeMode]
P{
UnicodePropertyValueExpression
}
UnicodePropertyValueExpression
::
UnicodePropertyName
=
UnicodePropertyValue
LoneUnicodePropertyNameOrValue
UnicodePropertyName
::
UnicodePropertyNameCharacters
UnicodePropertyNameCharacters
::
UnicodePropertyNameCharacter
UnicodePropertyNameCharacters
opt
UnicodePropertyValue
::
UnicodePropertyValueCharacters
LoneUnicodePropertyNameOrValue
::
UnicodePropertyValueCharacters
UnicodePropertyValueCharacters
::
UnicodePropertyValueCharacter
UnicodePropertyValueCharacters
opt
UnicodePropertyValueCharacter
::
UnicodePropertyNameCharacter
DecimalDigit
UnicodePropertyNameCharacter
::
AsciiLetter
_
CharacterClass
[UnicodeMode, UnicodeSetsMode]
::
[
[lookahead ≠
^
]
ClassContents
[?UnicodeMode, ?UnicodeSetsMode]
]
[^
ClassContents
[?UnicodeMode, ?UnicodeSetsMode]
]
ClassContents
[UnicodeMode, UnicodeSetsMode]
::
[empty]
[~UnicodeSetsMode]
NonemptyClassRanges
[?UnicodeMode]
[+UnicodeSetsMode]
ClassSetExpression
NonemptyClassRanges
[UnicodeMode]
::
ClassAtom
[?UnicodeMode]
ClassAtom
[?UnicodeMode]
NonemptyClassRangesNoDash
[?UnicodeMode]
ClassAtom
[?UnicodeMode]
-
ClassAtom
[?UnicodeMode]
ClassContents
[?UnicodeMode, ~UnicodeSetsMode]
NonemptyClassRangesNoDash
[UnicodeMode]
::
ClassAtom
[?UnicodeMode]
ClassAtomNoDash
[?UnicodeMode]
NonemptyClassRangesNoDash
[?UnicodeMode]
ClassAtomNoDash
[?UnicodeMode]
-
ClassAtom
[?UnicodeMode]
ClassContents
[?UnicodeMode, ~UnicodeSetsMode]
ClassAtom
[UnicodeMode]
::
-
ClassAtomNoDash
[?UnicodeMode]
ClassAtomNoDash
[UnicodeMode]
::
SourceCharacter
but not one of
\
or
]
or
-
\
ClassEscape
[?UnicodeMode]
ClassEscape
[UnicodeMode]
::
b
[+UnicodeMode]
-
CharacterClassEscape
[?UnicodeMode]
CharacterEscape
[?UnicodeMode]
ClassSetExpression
::
ClassUnion
ClassIntersection
ClassSubtraction
ClassUnion
::
ClassSetRange
ClassUnion
opt
ClassSetOperand
ClassUnion
opt
ClassIntersection
::
ClassSetOperand
&&
[lookahead ≠
&
]
ClassSetOperand
ClassIntersection
&&
[lookahead ≠
&
]
ClassSetOperand
ClassSubtraction
::
ClassSetOperand
--
ClassSetOperand
ClassSubtraction
--
ClassSetOperand
ClassSetRange
::
ClassSetCharacter
-
ClassSetCharacter
ClassSetOperand
::
NestedClass
ClassStringDisjunction
ClassSetCharacter
NestedClass
::
[
[lookahead ≠
^
]
ClassContents
[+UnicodeMode, +UnicodeSetsMode]
]
[^
ClassContents
[+UnicodeMode, +UnicodeSetsMode]
]
\
CharacterClassEscape
[+UnicodeMode]
ClassStringDisjunction
::
\q{
ClassStringDisjunctionContents
}
ClassStringDisjunctionContents
::
ClassString
ClassString
|
ClassStringDisjunctionContents
ClassString
::
[empty]
NonEmptyClassString
NonEmptyClassString
::
ClassSetCharacter
NonEmptyClassString
opt
ClassSetCharacter
::
[lookahead ∉
ClassSetReservedDoublePunctuator
]
SourceCharacter
but not
ClassSetSyntaxCharacter
\
CharacterEscape
[+UnicodeMode]
\
ClassSetReservedPunctuator
\b
ClassSetReservedDoublePunctuator
::
one of
&&
!!
##
$$
%%
**
++
,,
..
::
;;
<<
==
>>
??
@@
^^
``
~~
ClassSetSyntaxCharacter
::
one of
(
)
[
]
{
}
/
-
\
|
ClassSetReservedPunctuator
::
one of
&
-
!
#
%
,
:
;
<
=
>
@
`
~
Annex B
(normative)
Additional ECMAScript Features for Web Browsers
The ECMAScript language syntax and semantics defined in this annex are required when the ECMAScript
host
is a web browser. The content of this annex is normative but optional if the ECMAScript
host
is not a web browser.
Some features defined in this annex are specified in this annex, and some are specified in the main body of this document.
When a feature is specified in the main body, each point where it affects the document is marked with the words "
Normative Optional
" in a coloured box. Moreover, where the feature involves particular wording in an algorithm or
early error
rule, this is guarded by the condition that “
the host supports
” the relevant feature. Web browsers are required to support all such features.
Note
This annex describes various legacy features and other characteristics of web browser ECMAScript
hosts
. All of the language features and behaviours specified in this annex have one or more undesirable characteristics and in the absence of legacy usage would be removed from this specification. However, the usage of these features by large numbers of existing web pages means that web browsers must continue to support them. The specifications in this annex define the requirements for interoperable implementations of these legacy features.
These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. ECMAScript implementations are discouraged from implementing these features unless the implementation is part of a web browser or is required to run the same legacy ECMAScript code that web browsers encounter.
B.1
Additional Syntax
B.1.1
HTML-like Comments
The syntax and semantics of
12.4
is extended as follows except that this extension is not allowed when parsing source text using the
goal symbol
Module
:
Syntax
InputElementHashbangOrRegExp
::
WhiteSpace
LineTerminator
Comment
CommonToken
HashbangComment
RegularExpressionLiteral
HTMLCloseComment
Comment
::
MultiLineComment
SingleLineComment
SingleLineHTMLOpenComment
SingleLineHTMLCloseComment
SingleLineDelimitedComment
MultiLineComment
::
/*
FirstCommentLine
opt
LineTerminator
MultiLineCommentChars
opt
*/
HTMLCloseComment
opt
FirstCommentLine
::
SingleLineDelimitedCommentChars
SingleLineHTMLOpenComment
::
<!--
SingleLineCommentChars
opt
SingleLineHTMLCloseComment
::
LineTerminatorSequence
HTMLCloseComment
SingleLineDelimitedComment
::
/*
SingleLineDelimitedCommentChars
opt
*/
HTMLCloseComment
::
WhiteSpaceSequence
opt
SingleLineDelimitedCommentSequence
opt
-->
SingleLineCommentChars
opt
SingleLineDelimitedCommentChars
::
SingleLineNotAsteriskChar
SingleLineDelimitedCommentChars
opt
*
SingleLinePostAsteriskCommentChars
opt
SingleLineNotAsteriskChar
::
SourceCharacter
but not one of
*
or
LineTerminator
SingleLinePostAsteriskCommentChars
::
SingleLineNotForwardSlashOrAsteriskChar
SingleLineDelimitedCommentChars
opt
*
SingleLinePostAsteriskCommentChars
opt
SingleLineNotForwardSlashOrAsteriskChar
::
SourceCharacter
but not one of
/
or
*
or
LineTerminator
WhiteSpaceSequence
::
WhiteSpace
WhiteSpaceSequence
opt
SingleLineDelimitedCommentSequence
::
SingleLineDelimitedComment
WhiteSpaceSequence
opt
SingleLineDelimitedCommentSequence
opt
Similar to a
MultiLineComment
that contains a line terminator code point, a
SingleLineHTMLCloseComment
is considered to be a
LineTerminator
for purposes of parsing by the syntactic grammar.
B.1.2
Regular Expressions Patterns
The syntax of
22.2.1
is modified and extended as follows. These changes introduce ambiguities that are broken by the ordering of grammar productions and by contextual information. When parsing using the following grammar, each alternative is considered only if previous production alternatives do not match.
This alternative pattern grammar and semantics only changes the syntax and semantics of BMP patterns. The following grammar extensions include productions parameterized with the [UnicodeMode] parameter. However, none of these extensions change the syntax of Unicode patterns recognized when parsing with the [UnicodeMode] parameter present on the
goal symbol
.
Syntax
Term
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
[+UnicodeMode]
Assertion
[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
[+UnicodeMode]
Atom
[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
Quantifier
[+UnicodeMode]
Atom
[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
[~UnicodeMode]
QuantifiableAssertion
[?NamedCaptureGroups]
Quantifier
[~UnicodeMode]
Assertion
[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
[~UnicodeMode]
ExtendedAtom
[?NamedCaptureGroups]
Quantifier
[~UnicodeMode]
ExtendedAtom
[?NamedCaptureGroups]
Assertion
[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups]
::
^
$
\b
\B
[+UnicodeMode]
(?=
Disjunction
[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
[+UnicodeMode]
(?!
Disjunction
[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
[~UnicodeMode]
QuantifiableAssertion
[?NamedCaptureGroups]
(?<=
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
(?<!
Disjunction
[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
)
QuantifiableAssertion
[NamedCaptureGroups]
::
(?=
Disjunction
[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
)
(?!
Disjunction
[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
)
ExtendedAtom
[NamedCaptureGroups]
::
.
\
AtomEscape
[~UnicodeMode, ?NamedCaptureGroups]
\
[lookahead =
c
]
CharacterClass
[~UnicodeMode, ~UnicodeSetsMode]
(
GroupSpecifier
[~UnicodeMode]
opt
Disjunction
[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
)
(?
RegularExpressionModifiers
:
Disjunction
[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
)
(?
RegularExpressionModifiers
-
RegularExpressionModifiers
:
Disjunction
[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
)
InvalidBracedQuantifier
ExtendedPatternCharacter
InvalidBracedQuantifier
::
{
DecimalDigits
[~Sep]
}
{
DecimalDigits
[~Sep]
,}
{
DecimalDigits
[~Sep]
,
DecimalDigits
[~Sep]
}
ExtendedPatternCharacter
::
SourceCharacter
but not one of
^
$
\
.
*
+
?
(
)
[
|
AtomEscape
[UnicodeMode, NamedCaptureGroups]
::
[+UnicodeMode]
DecimalEscape
[~UnicodeMode]
DecimalEscape
but only if the
CapturingGroupNumber
of
DecimalEscape
is ≤
CountLeftCapturingParensWithin
(the
Pattern
containing
DecimalEscape
)
CharacterClassEscape
[?UnicodeMode]
CharacterEscape
[?UnicodeMode, ?NamedCaptureGroups]
[+NamedCaptureGroups]
k
GroupName
[?UnicodeMode]
CharacterEscape
[UnicodeMode, NamedCaptureGroups]
::
ControlEscape
c
AsciiLetter
0
[lookahead ∉
DecimalDigit
]
HexEscapeSequence
RegExpUnicodeEscapeSequence
[?UnicodeMode]
[~UnicodeMode]
LegacyOctalEscapeSequence
IdentityEscape
[?UnicodeMode, ?NamedCaptureGroups]
IdentityEscape
[UnicodeMode, NamedCaptureGroups]
::
[+UnicodeMode]
SyntaxCharacter
[+UnicodeMode]
/
[~UnicodeMode]
SourceCharacterIdentityEscape
[?NamedCaptureGroups]
SourceCharacterIdentityEscape
[NamedCaptureGroups]
::
[~NamedCaptureGroups]
SourceCharacter
but not
c
[+NamedCaptureGroups]
SourceCharacter
but not one of
c
or
k
ClassAtomNoDash
[UnicodeMode, NamedCaptureGroups]
::
SourceCharacter
but not one of
\
or
]
or
-
\
ClassEscape
[?UnicodeMode, ?NamedCaptureGroups]
\
[lookahead =
c
]
ClassEscape
[UnicodeMode, NamedCaptureGroups]
::
b
[+UnicodeMode]
-
[~UnicodeMode]
c
ClassControlLetter
CharacterClassEscape
[?UnicodeMode]
CharacterEscape
[?UnicodeMode, ?NamedCaptureGroups]
ClassControlLetter
::
DecimalDigit
_
Note
When the same left-hand sides occurs with both [+UnicodeMode] and [~UnicodeMode] guards it is to control the disambiguation priority.
B.1.2.1
Static Semantics: Early Errors
The semantics of
22.2.1.1
is extended as follows:
ExtendedAtom
::
InvalidBracedQuantifier
It is a Syntax Error if any source text is matched by this production.
Additionally, the rules for the following productions are modified with the addition of the
highlighted
text:
NonemptyClassRanges
::
ClassAtom
-
ClassAtom
ClassContents
It is a Syntax Error if
IsCharacterClass
of the first
ClassAtom
is
true
or
IsCharacterClass
of the second
ClassAtom
is
true
and this production has a
[UnicodeMode]
parameter
.
It is a Syntax Error if
IsCharacterClass
of the first
ClassAtom
is
false
,
IsCharacterClass
of the second
ClassAtom
is
false
, and the
CharacterValue
of the first
ClassAtom
is strictly greater than the
CharacterValue
of the second
ClassAtom
.
NonemptyClassRangesNoDash
::
ClassAtomNoDash
-
ClassAtom
ClassContents
It is a Syntax Error if
IsCharacterClass
of
ClassAtomNoDash
is
true
or
IsCharacterClass
of
ClassAtom
is
true
and this production has a
[UnicodeMode]
parameter
.
It is a Syntax Error if
IsCharacterClass
of
ClassAtomNoDash
is
false
,
IsCharacterClass
of
ClassAtom
is
false
, and the
CharacterValue
of
ClassAtomNoDash
is strictly greater than the
CharacterValue
of
ClassAtom
.
B.1.2.2
Static Semantics: CountLeftCapturingParensWithin and CountLeftCapturingParensBefore
In the definitions of
CountLeftCapturingParensWithin
and
CountLeftCapturingParensBefore
, references to “
Atom
::
(
GroupSpecifier
opt
Disjunction
)
” are to be interpreted as meaning “
Atom
::
(
GroupSpecifier
opt
Disjunction
)
” or “
ExtendedAtom
::
(
GroupSpecifier
opt
Disjunction
)
”.
B.1.2.3
Static Semantics: IsCharacterClass
The semantics of
22.2.1.6
is extended as follows:
ClassAtomNoDash
::
\
[lookahead =
c
]
Return
false
.
B.1.2.4
Static Semantics: CharacterValue
The semantics of
22.2.1.7
is extended as follows:
ClassAtomNoDash
::
\
[lookahead =
c
]
Return the numeric value of U+005C (REVERSE SOLIDUS).
ClassEscape
::
c
ClassControlLetter
Let
ch
be the code point matched by
ClassControlLetter
.
Let
i
be the numeric value of
ch
.
Return the remainder of dividing
i
by 32.
CharacterEscape
::
LegacyOctalEscapeSequence
Return the MV of
LegacyOctalEscapeSequence
(see
12.9.4.3
).
B.1.2.5
Runtime Semantics: CompileSubpattern
The semantics of
CompileSubpattern
is extended as follows:
The rule for
Term
::
QuantifiableAssertion
Quantifier
is the same as for
Term
::
Atom
Quantifier
but with
QuantifiableAssertion
substituted for
Atom
.
The rule for
Term
::
ExtendedAtom
Quantifier
is the same as for
Term
::
Atom
Quantifier
but with
ExtendedAtom
substituted for
Atom
.
The rule for
Term
::
ExtendedAtom
is the same as for
Term
::
Atom
but with
ExtendedAtom
substituted for
Atom
.
B.1.2.6
Runtime Semantics: CompileAssertion
CompileAssertion
rules for the
Assertion
::
(?=
Disjunction
)
and
Assertion
::
(?!
Disjunction
)
productions are also used for the
QuantifiableAssertion
productions, but with
QuantifiableAssertion
substituted for
Assertion
.
B.1.2.7
Runtime Semantics: CompileAtom
CompileAtom
rules for the
Atom
productions except for
Atom
::
PatternCharacter
are also used for the
ExtendedAtom
productions, but with
ExtendedAtom
substituted for
Atom
. The following rules, with parameter
direction
, are also added:
ExtendedAtom
::
\
[lookahead =
c
]
Let
A
be the
CharSet
containing the single character
\
U+005C (REVERSE SOLIDUS).
Return
CharacterSetMatcher
(
rer
,
A
,
false
,
direction
).
ExtendedAtom
::
ExtendedPatternCharacter
Let
ch
be the character represented by
ExtendedPatternCharacter
.
Let
A
be a one-element
CharSet
containing the character
ch
.
Return
CharacterSetMatcher
(
rer
,
A
,
false
,
direction
).
B.1.2.8
Runtime Semantics: CompileToCharSet
The semantics of
22.2.2.9
is extended as follows:
The following two rules replace the corresponding rules of
CompileToCharSet
.
NonemptyClassRanges
::
ClassAtom
-
ClassAtom
ClassContents
Let
A
be
CompileToCharSet
of the first
ClassAtom
with argument
rer
.
Let
B
be
CompileToCharSet
of the second
ClassAtom
with argument
rer
.
Let
C
be
CompileToCharSet
of
ClassContents
with argument
rer
.
Let
D
be
CharacterRangeOrUnion
(
rer
,
A
,
B
).
Return the union of
D
and
C
.
NonemptyClassRangesNoDash
::
ClassAtomNoDash
-
ClassAtom
ClassContents
Let
A
be
CompileToCharSet
of
ClassAtomNoDash
with argument
rer
.
Let
B
be
CompileToCharSet
of
ClassAtom
with argument
rer
.
Let
C
be
CompileToCharSet
of
ClassContents
with argument
rer
.
Let
D
be
CharacterRangeOrUnion
(
rer
,
A
,
B
).
Return the union of
D
and
C
.
In addition, the following rules are added to
CompileToCharSet
.
ClassEscape
::
c
ClassControlLetter
Let
cv
be the
CharacterValue
of this
ClassEscape
.
Let
c
be the character whose character value is
cv
.
Return the
CharSet
containing the single character
c
.
ClassAtomNoDash
::
\
[lookahead =
c
]
Return the
CharSet
containing the single character
\
U+005C (REVERSE SOLIDUS).
Note
This production can only be reached from the sequence
\c
within a character class where it is not followed by an acceptable control character.
B.1.2.8.1
CharacterRangeOrUnion (
rer
,
A
,
B
)
The abstract operation CharacterRangeOrUnion takes arguments
rer
(a
RegExp Record
),
A
(a
CharSet
), and
B
(a
CharSet
) and returns a
CharSet
. It performs the following steps when called:
If
HasEitherUnicodeFlag
(
rer
) is
false
, then
If
A
does not contain exactly one character or
B
does not contain exactly one character, then
Let
C
be the
CharSet
containing the single character
-
U+002D (HYPHEN-MINUS).
Return the union of
CharSets
A
,
B
and
C
.
Return
CharacterRange
(
A
,
B
).
B.1.2.9
Static Semantics: ParsePattern (
patternText
,
u
,
v
)
The semantics of
22.2.3.4
is extended as follows:
The abstract operation
ParsePattern
takes arguments
patternText
(a sequence of Unicode code points),
u
(a Boolean), and
v
(a Boolean). It performs the following steps when called:
If
v
is
true
and
u
is
true
, then
Let
parseResult
be a
List
containing one or more
SyntaxError
objects.
Else if
v
is
true
, then
Let
parseResult
be
ParseText
(
patternText
,
Pattern
[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]
).
Else if
u
is
true
, then
Let
parseResult
be
ParseText
(
patternText
,
Pattern
[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]
).
Else,
Let
parseResult
be
ParseText
(
patternText
,
Pattern
[~UnicodeMode, ~UnicodeSetsMode, ~NamedCaptureGroups]
).
If
parseResult
is a
Parse Node
and
parseResult
contains a
GroupName
, then
Set
parseResult
to
ParseText
(
patternText
,
Pattern
[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]
).
Return
parseResult
.
B.2
Additional Built-in Properties
When the ECMAScript
host
is a web browser the following additional properties of the standard built-in objects are defined.
B.2.1
Additional Properties of the Global Object
The entries in
Table 97
are added to
Table 6
.
Table 97: Additional Well-known Intrinsic Objects
Intrinsic Name
Global Name
ECMAScript Language Association
%escape%
escape
The
escape
function (
B.2.1.1
)
%unescape%
unescape
The
unescape
function (
B.2.1.2
)
B.2.1.1
escape (
string
)
This function is a property of the
global object
. It computes a new version of a String value in which certain code units have been replaced by a hexadecimal escape sequence.
When replacing a code unit of numeric value less than or equal to 0x00FF, a two-digit escape sequence of the form
%
xx
is used. When replacing a code unit of numeric value strictly greater than 0x00FF, a four-digit escape sequence of the form
%u
xxxx
is used.
It is the
%escape%
intrinsic object.
It performs the following steps when called:
Set
string
to ?
ToString
(
string
).
Let
len
be the length of
string
.
Let
R
be the empty String.
Let
unescapedSet
be the
string-concatenation
of
the ASCII word characters
and
"@*+-./"
.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
C
be the code unit at index
k
within
string
.
If
unescapedSet
contains
C
, then
Let
S
be
C
.
Else,
Let
n
be the numeric value of
C
.
If
n
< 256, then
Let
hex
be the String representation of
n
, formatted as an uppercase hexadecimal number.
Let
S
be the
string-concatenation
of
"%"
and
StringPad
(
hex
, 2,
"0"
,
start
).
Else,
Let
hex
be the String representation of
n
, formatted as an uppercase hexadecimal number.
Let
S
be the
string-concatenation
of
"%u"
and
StringPad
(
hex
, 4,
"0"
,
start
).
Set
R
to the
string-concatenation
of
R
and
S
.
Set
k
to
k
+ 1.
Return
R
.
Note
The encoding is partly based on the encoding described in RFC 1738, but the entire encoding specified in this standard is described above without regard to the contents of RFC 1738. This encoding does not reflect changes to RFC 1738 made by RFC 3986.
B.2.1.2
unescape (
string
)
This function is a property of the
global object
. It computes a new version of a String value in which each escape sequence of the sort that might be introduced by the
escape
function is replaced with the code unit that it represents.
It is the
%unescape%
intrinsic object.
It performs the following steps when called:
Set
string
to ?
ToString
(
string
).
Let
len
be the length of
string
.
Let
R
be the empty String.
Let
k
be 0.
Repeat, while
k
<
len
,
Let
C
be the code unit at index
k
within
string
.
If
C
is the code unit 0x0025 (PERCENT SIGN), then
Let
hexDigits
be the empty String.
Let
optionalAdvance
be 0.
If
k
+ 5 <
len
and the code unit at index
k
+ 1 within
string
is the code unit 0x0075 (LATIN SMALL LETTER U), then
Set
hexDigits
to the
substring
of
string
from
k
+ 2 to
k
+ 6.
Set
optionalAdvance
to 5.
Else if
k
+ 3 ≤
len
, then
Set
hexDigits
to the
substring
of
string
from
k
+ 1 to
k
+ 3.
Set
optionalAdvance
to 2.
Let
parseResult
be
ParseText
(
hexDigits
,
HexDigits
[~Sep]
).
If
parseResult
is a
Parse Node
, then
Let
n
be the MV of
parseResult
.
Set
C
to the code unit whose numeric value is
n
.
Set
k
to
k
+
optionalAdvance
.
Set
R
to the
string-concatenation
of
R
and
C
.
Set
k
to
k
+ 1.
Return
R
.
B.2.2
Additional Properties of the String.prototype Object
B.2.2.1
String.prototype.substr (
start
,
length
)
This method returns a
substring
of the result of converting the
this
value to a String, starting from index
start
and running for
length
code units (or through the end of the String if
length
is
undefined
). If
start
is negative, it is treated as
sourceLength
+
start
where
sourceLength
is the length of the String. The result
is a String
value, not a String object.
It performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireObjectCoercible
(
O
).
Let
S
be ?
ToString
(
O
).
Let
size
be the length of
S
.
Let
intStart
be ?
ToIntegerOrInfinity
(
start
).
If
intStart
= -∞, set
intStart
to 0.
Else if
intStart
< 0, set
intStart
to
max
(
size
+
intStart
, 0).
Else, set
intStart
to
min
(
intStart
,
size
).
If
length
is
undefined
, let
intLength
be
size
; otherwise let
intLength
be ?
ToIntegerOrInfinity
(
length
).
Set
intLength
to the result of
clamping
intLength
between 0 and
size
.
Let
intEnd
be
min
(
intStart
+
intLength
,
size
).
Return the
substring
of
S
from
intStart
to
intEnd
.
Note
This method is intentionally generic; it does not require that its
this
value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
B.2.2.2
String.prototype.anchor (
name
)
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"a"
,
"name"
,
name
).
B.2.2.2.1
CreateHTML (
string
,
tag
,
attribute
,
value
)
The abstract operation CreateHTML takes arguments
string
(an
ECMAScript language value
),
tag
(a String),
attribute
(a String), and
value
(an
ECMAScript language value
) and returns either a
normal completion containing
a String or a
throw completion
. It performs the following steps when called:
Perform ?
RequireObjectCoercible
(
string
).
Let
S
be ?
ToString
(
string
).
Let
p1
be the
string-concatenation
of
"<"
and
tag
.
If
attribute
is not the empty String, then
Let
V
be ?
ToString
(
value
).
Let
escapedV
be the String value that is the same as
V
except that each occurrence of the code unit 0x0022 (QUOTATION MARK) in
V
has been replaced with the six code unit sequence
"&quot;"
.
Set
p1
to the
string-concatenation
of:
p1
the code unit 0x0020 (SPACE)
attribute
the code unit 0x003D (EQUALS SIGN)
the code unit 0x0022 (QUOTATION MARK)
escapedV
the code unit 0x0022 (QUOTATION MARK)
Let
p2
be the
string-concatenation
of
p1
and
">"
.
Let
p3
be the
string-concatenation
of
p2
and
S
.
Let
p4
be the
string-concatenation
of
p3
,
"</"
,
tag
, and
">"
.
Return
p4
.
B.2.2.3
String.prototype.big ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"big"
,
""
,
""
).
B.2.2.4
String.prototype.blink ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"blink"
,
""
,
""
).
B.2.2.5
String.prototype.bold ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"b"
,
""
,
""
).
B.2.2.6
String.prototype.fixed ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"tt"
,
""
,
""
).
B.2.2.7
String.prototype.fontcolor (
colour
)
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"font"
,
"color"
,
colour
).
B.2.2.8
String.prototype.fontsize (
size
)
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"font"
,
"size"
,
size
).
B.2.2.9
String.prototype.italics ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"i"
,
""
,
""
).
B.2.2.10
String.prototype.link (
url
)
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"a"
,
"href"
,
url
).
B.2.2.11
String.prototype.small ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"small"
,
""
,
""
).
B.2.2.12
String.prototype.strike ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"strike"
,
""
,
""
).
B.2.2.13
String.prototype.sub ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"sub"
,
""
,
""
).
B.2.2.14
String.prototype.sup ( )
This method performs the following steps when called:
Let
S
be the
this
value.
Return ?
CreateHTML
(
S
,
"sup"
,
""
,
""
).
B.2.2.15
String.prototype.trimLeft ( )
Note
The property
"trimStart"
is preferred. The
"trimLeft"
property is provided principally for compatibility with old code. It is recommended that the
"trimStart"
property be used in new ECMAScript code.
The initial value of the
"trimLeft"
property is %String.prototype.trimStart%, defined in
22.1.3.34
.
B.2.2.16
String.prototype.trimRight ( )
Note
The property
"trimEnd"
is preferred. The
"trimRight"
property is provided principally for compatibility with old code. It is recommended that the
"trimEnd"
property be used in new ECMAScript code.
The initial value of the
"trimRight"
property is %String.prototype.trimEnd%, defined in
22.1.3.33
.
B.2.3
Additional Properties of the Date.prototype Object
B.2.3.1
Date.prototype.getYear ( )
Note
The
getFullYear
method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
If
t
is
NaN
, return
NaN
.
Return
YearFromTime
(
LocalTime
(
t
)) -
1900
𝔽
.
B.2.3.2
Date.prototype.setYear (
year
)
Note
The
setFullYear
method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”
This method performs the following steps when called:
Let
dateObject
be the
this
value.
Perform ?
RequireInternalSlot
(
dateObject
,
[[DateValue]]
).
Let
t
be
dateObject
.
[[DateValue]]
.
Let
y
be ?
ToNumber
(
year
).
If
t
is
NaN
, set
t
to
+0
𝔽
; otherwise set
t
to
LocalTime
(
t
).
Let
yyyy
be
MakeFullYear
(
y
).
Let
d
be
MakeDay
(
yyyy
,
MonthFromTime
(
t
),
DateFromTime
(
t
)).
Let
date
be
MakeDate
(
d
,
TimeWithinDay
(
t
)).
Let
u
be
TimeClip
(
UTC
(
date
)).
Set
dateObject
.
[[DateValue]]
to
u
.
Return
u
.
B.2.3.3
Date.prototype.toGMTString ( )
Note
The
toUTCString
method is preferred. This method is provided principally for compatibility with old code.
The initial value of the
"toGMTString"
property is %Date.prototype.toUTCString%, defined in
21.4.4.43
.
B.2.4
Additional Properties of the RegExp.prototype Object
B.2.4.1
RegExp.prototype.compile (
pattern
,
flags
)
This method performs the following steps when called:
Let
O
be the
this
value.
Perform ?
RequireInternalSlot
(
O
,
[[RegExpMatcher]]
).
If
pattern
is an Object
and
pattern
has a
[[RegExpMatcher]]
internal slot, then
If
flags
is not
undefined
, throw a
TypeError
exception.
Let
P
be
pattern
.
[[OriginalSource]]
.
Let
F
be
pattern
.
[[OriginalFlags]]
.
Else,
Let
P
be
pattern
.
Let
F
be
flags
.
Return ?
RegExpInitialize
(
O
,
P
,
F
).
Note
This method completely reinitializes the
this
value RegExp with a new pattern and flags. An implementation may interpret use of this method as an assertion that the resulting RegExp object will be used multiple times and hence is a candidate for extra optimization.
B.3
Other Additional Features
B.3.1
Labelled Function Declarations
Prior to ECMAScript 2015, the specification of
LabelledStatement
did not allow for the association of a statement label with a
FunctionDeclaration
. However, a labelled
FunctionDeclaration
was an allowable extension for
non-strict code
and most browser-hosted ECMAScript implementations supported that extension. In ECMAScript 2015 and later, the grammar production for
LabelledStatement
permits use of
FunctionDeclaration
as a
LabelledItem
but
14.13.1
includes an Early Error rule that produces a Syntax Error if that occurs. That rule is then modified to suppress the Syntax Error in
non-strict code
if
the host supports
this feature.
Note
The
early error
rules for
WithStatement
,
IfStatement
, and
IterationStatement
prevent these statements from containing a labelled
FunctionDeclaration
in
non-strict code
.
B.3.2
Block-Level Function Declarations Web Legacy Compatibility Semantics
Prior to ECMAScript 2015, the ECMAScript specification did not define the occurrence of a
FunctionDeclaration
as an element of a
Block
statement's
StatementList
. However, support for that form of
FunctionDeclaration
was an allowable extension and most browser-hosted ECMAScript implementations permitted them. Unfortunately, the semantics of such declarations differ among those implementations. Because of these semantic differences, existing web
ECMAScript source text
that uses
Block
level function declarations is only portable among browser implementations if the usage only depends upon the semantic intersection of all of the browser implementations for such declarations. The following are the use cases that fall within that intersection semantics:
A function is declared and only referenced within a single block.
One or more
FunctionDeclaration
s whose
BindingIdentifier
is the name
f
occur within the function code of an enclosing function
g
and that declaration is nested within a
Block
.
No other declaration of
f
that is not a
var
declaration occurs within the function code of
g
.
All occurrences of
f
as an
IdentifierReference
are within the
StatementList
of the
Block
containing the declaration of
f
.
A function is declared and possibly used within a single
Block
but also referenced by an inner function definition that is not contained within that same
Block
.
One or more
FunctionDeclaration
s whose
BindingIdentifier
is the name
f
occur within the function code of an enclosing function
g
and that declaration is nested within a
Block
.
No other declaration of
f
that is not a
var
declaration occurs within the function code of
g
.
There may be occurrences of
f
as an
IdentifierReference
within the
StatementList
of the
Block
containing the declaration of
f
.
There is at least one occurrence of
f
as an
IdentifierReference
within another function
h
that is nested within
g
and no other declaration of
f
shadows the references to
f
from within
h
.
All invocations of
h
occur after the declaration of
f
has been evaluated.
A function is declared and possibly used within a single block but also referenced within subsequent blocks.
One or more
FunctionDeclaration
whose
BindingIdentifier
is the name
f
occur within the function code of an enclosing function
g
and that declaration is nested within a
Block
.
No other declaration of
f
that is not a
var
declaration occurs within the function code of
g
.
There may be occurrences of
f
as an
IdentifierReference
within the
StatementList
of the
Block
containing the declaration of
f
.
There is at least one occurrence of
f
as an
IdentifierReference
within the function code of
g
that lexically follows the
Block
containing the declaration of
f
.
The first use case is interoperable with the semantics of
Block
level function declarations provided by ECMAScript 2015. Any pre-existing
ECMAScript source text
that employs that use case will operate using the Block level function declarations semantics defined by clauses
10
,
14
, and
15
.
ECMAScript 2015 interoperability for the second and third use cases requires the following extensions to the clause
10
, clause
15
, clause
19.2.1
and clause
16.1.7
semantics.
If an ECMAScript implementation has a mechanism for reporting diagnostic warning messages, a warning should be produced when code contains a
FunctionDeclaration
for which these compatibility semantics are applied and introduce observable differences from non-compatibility semantics. For example, if a var binding is not introduced because its introduction would create an
early error
, a warning message should not be produced.
This feature involves special semantics at the following points:
one of the
early error
rules for
Block
:
{
StatementList
}
in
14.2.1
one of the
early error
rules for
SwitchStatement
:
switch
(
Expression
)
CaseBlock
in
14.12.1
step
32.a
in
FunctionDeclarationInstantiation
step
3.a.ii.1
in
BlockDeclarationInstantiation
step
3.b.iii
in
BlockDeclarationInstantiation
step
12
in
GlobalDeclarationInstantiation
step
13
in
EvalDeclarationInstantiation
B.3.3
FunctionDeclarations in IfStatement Statement Clauses
The following augments the
IfStatement
production in
14.6
:
IfStatement
[Yield, Await, Return]
:
if
(
Expression
[+In, ?Yield, ?Await]
)
FunctionDeclaration
[?Yield, ?Await, ~Default]
else
Statement
[?Yield, ?Await, ?Return]
if
(
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
else
FunctionDeclaration
[?Yield, ?Await, ~Default]
if
(
Expression
[+In, ?Yield, ?Await]
)
FunctionDeclaration
[?Yield, ?Await, ~Default]
else
FunctionDeclaration
[?Yield, ?Await, ~Default]
if
(
Expression
[+In, ?Yield, ?Await]
)
FunctionDeclaration
[?Yield, ?Await, ~Default]
[lookahead ≠
else
]
This production only applies when parsing
non-strict code
.
Source text matched by
this production is processed as if each matching occurrence of
FunctionDeclaration
[?Yield, ?Await, ~Default]
was the sole
StatementListItem
of a
BlockStatement
occupying that position in the source text. The semantics of such a synthetic
BlockStatement
includes the web legacy compatibility semantics specified in
B.3.2
.
B.3.4
VariableStatements in Catch Blocks
In this feature, the
Block
of a
Catch
clause may contain
var
declarations that bind a name that is also bound by the
CatchParameter
. This is accomplished by modifying an
early error
rule for
Catch
:
catch
(
CatchParameter
)
Block
in
14.15.1
.
Note
At runtime, such bindings are instantiated in the VariableDeclarationEnvironment. They do not shadow the same-named bindings introduced by the
CatchParameter
and hence the
Initializer
for such
var
declarations will assign to the corresponding catch parameter rather than the
var
binding.
This modified behaviour also applies to
var
and
function
declarations introduced by
direct eval
calls contained within the
Block
of a
Catch
clause. This change is accomplished by modifying steps
3.d.i.2.a.i
and
13.b.ii.4.a.i.i
in
EvalDeclarationInstantiation
.
B.3.5
Initializers in ForIn Statement Heads
The following augments the
ForInOfStatement
production in
14.7.5
:
ForInOfStatement
[Yield, Await, Return]
:
for
(
var
BindingIdentifier
[?Yield, ?Await]
Initializer
[~In, ?Yield, ?Await]
in
Expression
[+In, ?Yield, ?Await]
)
Statement
[?Yield, ?Await, ?Return]
This production only applies when parsing
non-strict code
.
The
static semantics
of
ContainsDuplicateLabels
in
8.3.1
are augmented with the following:
ForInOfStatement
:
for
(
var
BindingIdentifier
Initializer
in
Expression
)
Statement
Return
ContainsDuplicateLabels
of
Statement
with argument
labelSet
.
The
static semantics
of
ContainsUndefinedBreakTarget
in
8.3.2
are augmented with the following:
ForInOfStatement
:
for
(
var
BindingIdentifier
Initializer
in
Expression
)
Statement
Return
ContainsUndefinedBreakTarget
of
Statement
with argument
labelSet
.
The
static semantics
of
ContainsUndefinedContinueTarget
in
8.3.3
are augmented with the following:
ForInOfStatement
:
for
(
var
BindingIdentifier
Initializer
in
Expression
)
Statement
Return
ContainsUndefinedContinueTarget
of
Statement
with arguments
iterationSet
and « ».
The
static semantics
of
IsDestructuring
in
14.7.5.2
are augmented with the following:
BindingIdentifier
:
Identifier
yield
await
Return
false
.
The
static semantics
of
VarDeclaredNames
in
8.2.6
are augmented with the following:
ForInOfStatement
:
for
(
var
BindingIdentifier
Initializer
in
Expression
)
Statement
Let
names1
be the
BoundNames
of
BindingIdentifier
.
Let
names2
be the
VarDeclaredNames
of
Statement
.
Return the
list-concatenation
of
names1
and
names2
.
The
static semantics
of
VarScopedDeclarations
in
8.2.7
are augmented with the following:
ForInOfStatement
:
for
(
var
BindingIdentifier
Initializer
in
Expression
)
Statement
Let
declarations1
be «
BindingIdentifier
».
Let
declarations2
be the
VarScopedDeclarations
of
Statement
.
Return the
list-concatenation
of
declarations1
and
declarations2
.
The
runtime semantics
of
ForInOfLoopEvaluation
in
14.7.5.5
are augmented with the following:
ForInOfStatement
:
for
(
var
BindingIdentifier
Initializer
in
Expression
)
Statement
Let
bindingId
be the
StringValue
of
BindingIdentifier
.
Let
lhs
be ?
ResolveBinding
(
bindingId
).
If
IsAnonymousFunctionDefinition
(
Initializer
) is
true
, then
Let
value
be ?
NamedEvaluation
of
Initializer
with argument
bindingId
.
Else,
Let
rhs
be ?
Evaluation
of
Initializer
.
Let
value
be ?
GetValue
(
rhs
).
Perform ?
PutValue
(
lhs
,
value
).
Let
keyResult
be ?
ForIn/OfHeadEvaluation
(« »,
Expression
,
enumerate
).
Return ?
ForIn/OfBodyEvaluation
(
BindingIdentifier
,
Statement
,
keyResult
,
enumerate
,
var-binding
,
labelSet
).
B.3.6
The
[[IsHTMLDDA]]
Internal Slot
An
[[IsHTMLDDA]]
internal slot
may exist on
host-defined
objects. Objects with an
[[IsHTMLDDA]]
internal slot behave like
undefined
in the
ToBoolean
and
IsLooselyEqual
abstract operations
and when used as an operand for the
typeof
operator
.
Note
Objects with an
[[IsHTMLDDA]]
internal slot are never created by this specification. However, the
document.all
object
in web browsers is a
host-defined
exotic object
with this slot that exists for web compatibility purposes. There are no other known examples of this type of object and implementations should not create any with the exception of
document.all
.
This feature involves special semantics at the following points:
step
3
in
ToBoolean
step
4
in
IsLooselyEqual
step
12
in the evaluation semantics for
typeof
B.3.7
Non-default behaviour in HostMakeJobCallback
The
HostMakeJobCallback
abstract operation allows
hosts
which are web browsers to specify non-default behaviour.
B.3.8
Non-default behaviour in HostEnsureCanAddPrivateElement
The
HostEnsureCanAddPrivateElement
abstract operation allows
hosts
which are web browsers to specify non-default behaviour.
B.3.9
Runtime Errors for Function Call Assignment Targets
When a function call (
13.3.6
) is used as an assignment target in
non-strict code
, instead of producing an
early error
, a
ReferenceError
exception is thrown during evaluation of the assignment.
Note
When the assignment target is the
LeftHandSideExpression
of an
AssignmentExpression
, the assignment operator must be
=
or an
AssignmentOperator
; in particular, the allowance here does not apply to the logical assignment operators (
??=
,
&&=
,
||=
).
See step
1
of
AssignmentTargetType
for
CallExpression
:
CoverCallExpressionAndAsyncArrowHead
and
CallExpression
:
CallExpression
Arguments
.
Annex C
(informative)
The Strict Mode of ECMAScript
The strict mode restriction and exceptions
implements
,
interface
,
let
,
package
,
private
,
protected
,
public
,
static
, and
yield
are
reserved words
within
strict mode code
. (
12.7.2
).
A conforming implementation, when processing
strict mode code
, must disallow instances of the productions
NumericLiteral
::
LegacyOctalIntegerLiteral
and
DecimalIntegerLiteral
::
NonOctalDecimalIntegerLiteral
.
A conforming implementation, when processing
strict mode code
, must disallow instances of the productions
EscapeSequence
::
LegacyOctalEscapeSequence
and
EscapeSequence
::
NonOctalDecimalEscapeSequence
.
Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the
global object
. When a simple assignment occurs within
strict mode code
, its
LeftHandSideExpression
must not evaluate to an unresolvable Reference. If it does a
ReferenceError
exception is thrown (
6.2.5.6
). The
LeftHandSideExpression
also may not be a reference to a
data property
with the attribute value {
[[Writable]]
:
false
}, to an
accessor property
with the attribute value {
[[Set]]
:
undefined
}, nor to a non-existent property of an object whose
[[Extensible]]
internal slot is
false
. In these cases a
TypeError
exception is thrown (
13.15
).
An
IdentifierReference
with the
StringValue
"eval"
or
"arguments"
may not appear as the
LeftHandSideExpression
of an Assignment operator (
13.15
) or of an
UpdateExpression
(
13.4
) or as the
UnaryExpression
operated upon by a Prefix Increment (
13.4.4
) or a Prefix Decrement (
13.4.5
) operator.
Arguments objects for
strict functions
define a non-configurable
accessor property
"callee"
which throws a
TypeError
exception on access (
10.4.4.6
).
Arguments objects for
strict functions
do not dynamically share their
array-indexed
property values with the corresponding formal parameter bindings of their functions. (
10.4.4
).
For
strict functions
, if an arguments object is created the binding of the local identifier
arguments
to the arguments object is immutable and hence may not be the target of an assignment expression. (
10.2.11
).
It is a
SyntaxError
if the
StringValue
of a
BindingIdentifier
is either
"eval"
or
"arguments"
within
strict mode code
(
13.1.1
).
Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code (
19.2.1
).
If
this
is evaluated within
strict mode code
, then the
this
value is not coerced to an object. A
this
value of either
undefined
or
null
is not converted to the
global object
and primitive values are not converted to wrapper objects. The
this
value passed via a function call (including calls made using
Function.prototype.apply
and
Function.prototype.call
) do not coerce the passed
this
value to an object (
10.2.1.2
,
20.2.3.1
,
20.2.3.3
).
When a
delete
operator occurs within
strict mode code
, a
SyntaxError
is thrown if its
UnaryExpression
is a direct reference to a variable, function argument, or function name (
13.5.1.1
).
When a
delete
operator occurs within
strict mode code
, a
TypeError
is thrown if the property to be deleted has the attribute {
[[Configurable]]
:
false
} or otherwise cannot be deleted (
13.5.1.2
).
Strict mode code
may not include a
WithStatement
. The occurrence of a
WithStatement
in such a context is a
SyntaxError
(
14.11.1
).
It is a
SyntaxError
if a
CatchParameter
occurs within
strict mode code
and the
BoundNames
of
CatchParameter
contains either
eval
or
arguments
(
14.15.1
).
It is a
SyntaxError
if the same
BindingIdentifier
appears more than once in the
FormalParameters
of a
strict function
. An attempt to create such a function using a Function, Generator, or AsyncFunction
constructor
is a
SyntaxError
(
15.2.1
,
20.2.1.1.1
).
An implementation may not extend, beyond that defined in this specification, the meanings within
strict functions
of properties named
"caller"
or
"arguments"
of function instances.
Annex D
(informative)
Host Layering Points
See
4.2
for the definition of
host
.
D.1
Host Hooks
HostCallJobCallback
(...)
HostEnqueueFinalizationRegistryCleanupJob
(...)
HostEnqueueGenericJob
(...)
HostEnqueuePromiseJob
(...)
HostEnqueueTimeoutJob
(...)
HostEnsureCanCompileStrings
(...)
HostFinalizeImportMeta
(...)
HostGetImportMetaProperties
(...)
HostGrowSharedArrayBuffer
(...)
HostHasSourceTextAvailable
(...)
HostLoadImportedModule
(...)
HostGetSupportedImportAttributes
(...)
HostMakeJobCallback
(...)
HostPromiseRejectionTracker
(...)
HostResizeArrayBuffer
(...)
InitializeHostDefinedRealm
(...)
D.2
Host-defined Fields
[[HostDefined]]
on
Realm Records
: See
Table 19
.
[[HostDefined]]
on
Script Records
: See
Table 34
.
[[HostDefined]]
on
Module Records
: See
Table 38
.
[[HostDefined]]
on
JobCallback Records
: See
Table 23
.
[[HostSynchronizesWith]]
on Candidate Executions: See
Table 96
.
[[IsHTMLDDA]]
: See
B.3.6
.
D.3
Host-defined Objects
The
global object
: See clause
19
.
D.4
Running Jobs
Preparation steps before, and cleanup steps after, invocation of
Job
Abstract Closures
. See
9.5
.
D.5
Internal Methods of Exotic Objects
Any of the essential internal methods in
Table 4
for any
exotic object
not specified within this specification.
D.6
Built-in Objects and Methods
Any built-in objects and methods not defined within this specification, except as restricted in
17.1
.
Annex E
(informative)
Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact
9.1.1.4.14
-
9.1.1.4.17
Edition 5 and 5.1 used a property existence test to determine whether a
global object
property corresponding to a new global declaration already existed. ECMAScript 2015 uses an own property existence test. This corresponds to what has been most commonly implemented by web browsers.
10.4.2.1
: The 5
th
Edition moved the capture of the current array length prior to the
integer
conversion of the
array index
or new length value. However, the captured length value could become invalid if the conversion process has the side-effect of changing the array length. ECMAScript 2015 specifies that the current array length must be captured after the possible occurrence of such side-effects.
21.4.1.31
: Previous editions permitted the
TimeClip
abstract operation to return either
+0
𝔽
or
-0
𝔽
as the representation of a 0
time value
. ECMAScript 2015 specifies that
+0
𝔽
always returned. This means that for ECMAScript 2015 the
time value
of a Date is never observably
-0
𝔽
and methods that return
time values
never return
-0
𝔽
.
21.4.1.32
: If a UTC offset representation is not present, the local time zone is used. Edition 5.1 incorrectly stated that a missing time zone should be interpreted as
"z"
.
21.4.4.36
: If the year cannot be represented using the Date Time String Format specified in
21.4.1.32
a RangeError exception is thrown. Previous editions did not specify the behaviour for that case.
21.4.4.41
: Previous editions did not specify the value returned by
Date.prototype.toString
when the
time value
is
NaN
. ECMAScript 2015 specifies the result to be the String value
"Invalid Date"
.
22.2.4.1
,
22.2.6.13.1
: Any LineTerminator code points in the value of the
"source"
property of a RegExp instance must be expressed using an escape sequence. Edition 5.1 only required the escaping of
/
.
22.2.6.8
,
22.2.6.11
: In previous editions, the specifications for
String.prototype.match
and
String.prototype.replace
was incorrect for cases where the pattern argument was a RegExp value whose
global
flag is set. The previous specifications stated that for each attempt to match the pattern, if
lastIndex
did not change, it should be incremented by 1. The correct behaviour is that
lastIndex
should be incremented by 1 only if the pattern matched the empty String.
23.1.3.30
: Previous editions did not specify how a
NaN
value returned by a
comparator
was interpreted by
Array.prototype.sort
. ECMAScript 2015 specifies that such as value is treated as if
+0
𝔽
was returned from the
comparator
. ECMAScript 2015 also specifies that
ToNumber
is applied to the result returned by a
comparator
. In previous editions, the effect of a
comparator
result that
is not a Number
value was
implementation-defined
. In practice, implementations call
ToNumber
.
Annex F
(informative)
Additions and Changes That Introduce Incompatibilities with Prior Editions
6.2.5
: In ECMAScript 2015, Function calls are not allowed to return a
Reference Record
.
7.1.4.1
: In ECMAScript 2015,
ToNumber
applied to a String value now recognizes and converts
BinaryIntegerLiteral
and
OctalIntegerLiteral
numeric strings. In previous editions such strings were converted to
NaN
.
9.3
: In ECMAScript 2018, Template objects are canonicalized based on
Parse Node
(source location), instead of across all occurrences of that template literal or tagged template in a
Realm
in previous editions.
12.2
: In ECMAScript 2016, Unicode 8.0.0 or higher is mandated, as opposed to ECMAScript 2015 which mandated Unicode 5.1. In particular, this caused U+180E MONGOLIAN VOWEL SEPARATOR, which was in the
Space_Separator
(
Zs
) category and thus treated as whitespace in ECMAScript 2015, to be moved to the
Format
(
Cf
) category (as of Unicode 6.3.0). This causes whitespace-sensitive methods to behave differently. For example,
"\u180E".trim().length
was
0
in previous editions, but
1
in ECMAScript 2016 and later. Additionally, ECMAScript 2017 mandated always using the latest version of the Unicode Standard.
12.7
: In ECMAScript 2015, the valid code points for an
IdentifierName
are specified in terms of the Unicode properties “ID_Start” and “ID_Continue”. In previous editions, the valid
IdentifierName
or
Identifier
code points were specified by enumerating various Unicode code point categories.
12.10.1
: In ECMAScript 2015, Automatic Semicolon Insertion adds a semicolon at the end of a do-while statement if the semicolon is missing. This change aligns the specification with the actual behaviour of most existing implementations.
13.2.5.1
: In ECMAScript 2015, it is no longer an
early error
to have duplicate
property names
in Object Initializers.
13.15.1
: In ECMAScript 2015,
strict mode code
containing an assignment to an immutable binding such as the function name of a
FunctionExpression
does not produce an
early error
. Instead it produces a runtime error.
14.2
: In ECMAScript 2015, a
StatementList
beginning with the token let followed by the input elements
LineTerminator
then
Identifier
is the start of a
LexicalDeclaration
. In previous editions, automatic semicolon insertion would always insert a semicolon before the
Identifier
input element.
14.5
: In ECMAScript 2015, a
StatementListItem
beginning with the token
let
followed by the token
[
is the start of a
LexicalDeclaration
. In previous editions such a sequence would be the start of an
ExpressionStatement
.
14.6.2
: In ECMAScript 2015, the normal result of an
IfStatement
is never the value
empty
. If no
Statement
part is evaluated or if the evaluated
Statement
part produces a
normal completion containing
empty
, the result of the
IfStatement
is
undefined
.
14.7
: In ECMAScript 2015, if the
(
token of a for statement is immediately followed by the token sequence
let [
then the
let
is treated as the start of a
LexicalDeclaration
. In previous editions such a token sequence would be the start of an
Expression
.
14.7
: In ECMAScript 2015, if the ( token of a for-in statement is immediately followed by the token sequence
let [
then the
let
is treated as the start of a
ForDeclaration
. In previous editions such a token sequence would be the start of an
LeftHandSideExpression
.
14.7
: Prior to ECMAScript 2015, an initialization expression could appear as part of the
VariableDeclaration
that precedes the
in
keyword
. In ECMAScript 2015, the
ForBinding
in that same position does not allow the occurrence of such an initializer. In ECMAScript 2017, such an initializer is permitted only in
non-strict code
.
14.7
: In ECMAScript 2015, the result of evaluating an
IterationStatement
is never a
normal completion
whose
[[Value]]
is
empty
. If the
Statement
part of an
IterationStatement
is not evaluated or if the final evaluation of the
Statement
part produces a
normal completion
whose
[[Value]]
is
empty
, the result of evaluating the
IterationStatement
is a
normal completion
whose
[[Value]]
is
undefined
.
14.11.2
: In ECMAScript 2015, the result of evaluating a
WithStatement
is never a
normal completion
whose
[[Value]]
is
empty
. If evaluation of the
Statement
part of a
WithStatement
produces a
normal completion
whose
[[Value]]
is
empty
, the result of evaluating the
WithStatement
is a
normal completion
whose
[[Value]]
is
undefined
.
14.12.4
: In ECMAScript 2015, the result of evaluating a
SwitchStatement
is never a
normal completion
whose
[[Value]]
is
empty
. If evaluation of the
CaseBlock
part of a
SwitchStatement
produces a
normal completion
whose
[[Value]]
is
empty
, the result of evaluating the
SwitchStatement
is a
normal completion
whose
[[Value]]
is
undefined
.
14.15
: In ECMAScript 2015, it is an
early error
for a
Catch
clause to contain a
var
declaration for the same
Identifier
that appears as the
Catch
clause parameter. In previous editions, such a variable declaration would be instantiated in the enclosing variable environment but the declaration's
Initializer
value would be assigned to the
Catch
parameter.
14.15
,
19.2.1.3
: In ECMAScript 2015, a runtime
SyntaxError
is thrown if a
Catch
clause evaluates a non-strict direct
eval
whose eval code includes a
var
or
FunctionDeclaration
declaration that binds the same
Identifier
that appears as the
Catch
clause parameter.
14.15.3
: In ECMAScript 2015, the result of a
TryStatement
is never the value
empty
. If the
Block
part of a
TryStatement
evaluates to a
normal completion containing
empty
, the result of the
TryStatement
is
undefined
. If the
Block
part of a
TryStatement
evaluates to a
throw completion
and it has a
Catch
part that evaluates to a
normal completion containing
empty
, the result of the
TryStatement
is
undefined
if there is no
Finally
clause or if its
Finally
clause evaluates to an
empty
normal completion
.
15.4.5
In ECMAScript 2015, the
function objects
that are created as the values of the
[[Get]]
or
[[Set]]
attribute of
accessor properties
in an
ObjectLiteral
are not
constructor
functions and they do not have a
"prototype"
own property. In the previous edition, they were
constructors
and had a
"prototype"
property.
20.1.2.6
: In ECMAScript 2015, if the argument to
Object.freeze
is not an object it is treated as if it was a non-extensible
ordinary object
with no own properties. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.8
: In ECMAScript 2015, if the argument to
Object.getOwnPropertyDescriptor
is not an object an attempt is made to coerce the argument using
ToObject
. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.10
: In ECMAScript 2015, if the argument to
Object.getOwnPropertyNames
is not an object an attempt is made to coerce the argument using
ToObject
. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.12
: In ECMAScript 2015, if the argument to
Object.getPrototypeOf
is not an object an attempt is made to coerce the argument using
ToObject
. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.16
: In ECMAScript 2015, if the argument to
Object.isExtensible
is not an object it is treated as if it was a non-extensible
ordinary object
with no own properties. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.17
: In ECMAScript 2015, if the argument to
Object.isFrozen
is not an object it is treated as if it was a non-extensible
ordinary object
with no own properties. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.18
: In ECMAScript 2015, if the argument to
Object.isSealed
is not an object it is treated as if it was a non-extensible
ordinary object
with no own properties. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.19
: In ECMAScript 2015, if the argument to
Object.keys
is not an object an attempt is made to coerce the argument using
ToObject
. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.20
: In ECMAScript 2015, if the argument to
Object.preventExtensions
is not an object it is treated as if it was a non-extensible
ordinary object
with no own properties. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.1.2.22
: In ECMAScript 2015, if the argument to
Object.seal
is not an object it is treated as if it was a non-extensible
ordinary object
with no own properties. In the previous edition, a non-object argument always causes a
TypeError
to be thrown.
20.2.3.2
: In ECMAScript 2015, the
[[Prototype]]
internal slot of a bound function is set to the
[[GetPrototypeOf]]
value of its target function. In the previous edition,
[[Prototype]]
was always set to
%Function.prototype%
.
20.2.4.1
: In ECMAScript 2015, the
"length"
property of function instances is configurable. In previous editions it was non-configurable.
20.5.6.2
: In ECMAScript 2015, the
[[Prototype]]
internal slot of a
NativeError
constructor
is the Error
constructor
. In previous editions it was the
Function prototype object
.
21.4.4
In ECMAScript 2015, the
Date prototype object
is not a Date instance. In previous editions it was a Date instance whose TimeValue was
NaN
.
22.1.3.12
In ECMAScript 2015, the
String.prototype.localeCompare
function must treat Strings that are canonically equivalent according to the Unicode Standard as being identical. In previous editions implementations were permitted to ignore canonical equivalence and could instead use a bit-wise comparison.
22.1.3.28
and
22.1.3.30
In ECMAScript 2015, lowercase/upper conversion processing operates on code points. In previous editions such the conversion processing was only applied to individual code units. The only affected code points are those in the Deseret block of Unicode.
22.1.3.32
In ECMAScript 2015, the
String.prototype.trim
method is defined to recognize white space code points that may exist outside of the Unicode BMP. However, as of Unicode 7 no such code points are defined. In previous editions such code points would not have been recognized as white space.
22.2.4.1
In ECMAScript 2015, If the
pattern
argument is a RegExp instance and the
flags
argument is not
undefined
, a new RegExp instance is created just like
pattern
except that
pattern
's flags are replaced by the argument
flags
. In previous editions a
TypeError
exception was thrown when
pattern
was a RegExp instance and
flags
was not
undefined
.
22.2.6
In ECMAScript 2015, the
RegExp prototype object
is not a RegExp instance. In previous editions it was a RegExp instance whose pattern is the empty String.
22.2.6
In ECMAScript 2015,
"source"
,
"global"
,
"ignoreCase"
, and
"multiline"
are
accessor properties
defined on the
RegExp prototype object
. In previous editions they were
data properties
defined on RegExp instances.
25.4.15
: In ECMAScript 2019,
Atomics.wake
has been renamed to
Atomics.notify
to prevent confusion with
Atomics.wait
.
27.1.5.4
,
27.6.3.6
: In ECMAScript 2019, the number of
Jobs
enqueued by
await
was reduced, which could create an observable difference in resolution order between a
then()
call and an
await
expression.
Bibliography
IEEE 754-2019
:
IEEE Standard for Floating-Point Arithmetic
. Institute of Electrical and Electronic Engineers, New York (2019)
Note
There are no normative changes between IEEE 754-2008 and IEEE 754-2019 that affect the ECMA-262 specification.
The Unicode Standard
, available at <
https://unicode.org/versions/latest
>
Unicode Technical Note #5: Canonical Equivalence in Applications
, available at <
https://unicode.org/notes/tn5/
>
Unicode Technical Standard #10: Unicode Collation Algorithm
, available at <
https://unicode.org/reports/tr10/
>
Unicode Standard Annex #15, Unicode Normalization Forms
, available at <
https://unicode.org/reports/tr15/
>
Unicode Standard Annex #18: Unicode Regular Expressions
, available at <
https://unicode.org/reports/tr18/
>
Unicode Standard Annex #24: Unicode
Script
Property
, available at <
https://unicode.org/reports/tr24/
>
Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax
, available at <
https://unicode.org/reports/tr31/
>
Unicode Standard Annex #44: Unicode Character Database
, available at <
https://unicode.org/reports/tr44/
>
Unicode Technical Standard #51: Unicode Emoji
, available at <
https://unicode.org/reports/tr51/
>
IANA Time Zone Database
, available at <
https://www.iana.org/time-zones
>
ISO 8601:2004(E)
Data elements and interchange formats — Information interchange — Representation of dates and times
RFC 1738 “Uniform Resource Locators (URL)”
, available at <
https://tools.ietf.org/html/rfc1738
>
RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”
, available at <
https://tools.ietf.org/html/rfc2396
>
RFC 3629 “UTF-8, a transformation format of ISO 10646”
, available at <
https://tools.ietf.org/html/rfc3629
>
RFC 7231 “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”
, available at <
https://tools.ietf.org/html/rfc7231
>
Colophon
This specification is authored on
GitHub
in a plaintext source format called
Ecmarkup
. Ecmarkup is an HTML and Markdown dialect that provides a framework and toolset for authoring Ecma specifications in plaintext and processing the specification into a full-featured HTML rendering that follows the editorial conventions for this document. Ecmarkup builds on and integrates a number of other formats and technologies including
Grammarkdown
for defining syntax and
Ecmarkdown
for authoring algorithm steps. PDF renderings of this specification are produced using a print stylesheet which takes advantage of the CSS Paged Media specification and is converted using
PrinceXML
.
Prior editions of this specification were authored using Word—the Ecmarkup source text that formed the basis of this edition was produced by converting the ECMAScript 2015 Word document to Ecmarkup using an automated conversion tool.
Copyright & Software License
Ecma International
Rue du Rhone 114
CH-1204 Geneva
Tel: +41 22 849 6000
Fax: +41 22 849 6001
Web:
https://ecma-international.org/
Copyright Notice
ALTERNATIVE COPYRIGHT NOTICE AND COPYRIGHT LICENSE
© 2026 Ecma International
By obtaining and/or copying this work, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions.
Permission under Ecma’s copyright to copy, modify, prepare derivative works of, and distribute this work, with or without modification, for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the work or portions thereof, including modifications:
(i) The full text of this COPYRIGHT NOTICE AND COPYRIGHT LICENSE in a location viewable to users of the redistributed or derivative work.
(ii) Any pre-existing intellectual property disclaimers, notices, or terms and conditions. If none exist, the Ecma alternative copyright notice should be included.
(iii) Notice of any changes or modifications, through a copyright statement on the document such as “This document includes material copied from or derived from ECMAScript® 2026 Language Specification https://tc39.es/ecma262/.
Copyright © Ecma International.”
Disclaimers
THIS WORK IS PROVIDED “AS IS,” AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT.
The name and trademarks of copyright holders may NOT be used in advertising or publicity pertaining to the work without specific, written prior permission. Title to copyright in this work will at all times remain with copyright holders.
Software License
All Software contained in this document ("Software") is protected by copyright and is being made available under the "BSD License", included below. This Software may be subject to third party rights (rights from parties other than Ecma International), including patent rights, and no licenses under such third party rights are granted under this license even if the third party concerned is a member of Ecma International. SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS AVAILABLE AT
https://ecma-international.org/memento/codeofconduct.htm
FOR INFORMATION REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO IMPLEMENT ECMA INTERNATIONAL STANDARDS.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
Neither the name of the authors nor Ecma International may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
