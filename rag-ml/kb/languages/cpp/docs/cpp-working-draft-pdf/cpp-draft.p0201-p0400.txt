

===== PAGE 201 =====

Dxxxx
5 When theswitch statement is executed, its condition is evaluated. If one of the case constants has the same
value as the condition, control is passed to the statement following the matched case label. If no case constant
matches the condition, and if there is adefault label, control passes to the statement labeled by the default
label. If no case matches and if there is nodefault then none of the statements in the switch is executed.
6 case and default labels in themselves do not alter the flow of control, which continues unimpeded across
such labels. To exit from a switch, seebreak, 8.8.2.
[Note 1: Usually, the substatement that is the subject of a switch is compound andcase and default labels appear
on the top-level statements contained within the (compound) substatement, but this is not required. Declarations can
appear in the substatement of aswitch statement. —end note]
7 A switch statement of the form
switch ( init-statement condition) statement
is equivalent to
{
init-statement
switch ( condition ) statement
}
except that theinit-statement is in the same scope as thecondition.
8.6 Iteration statements [stmt.iter]
8.6.1 General [stmt.iter.general]
1 Iteration statements specify looping.
iteration-statement:
while ( condition ) statement
do statement while ( expression ) ;
for ( init-statement conditionopt ; expressionopt ) statement
for ( init-statementopt for-range-declaration : for-range-initializer ) statement
[Note 1: An init-statement ends with a semicolon.—end note]
2 The substatement in aniteration-statement implicitly defines a block scope (6.4) which is entered and exited
each time through the loop. If the substatement in aniteration-statement is a single statement and not a
compound-statement, it is as if it was rewritten to be acompound-statement containing the original statement.
[Example 1:
while (--x >= 0)
int i;
can be equivalently rewritten as
while (--x >= 0) {
int i;
}
Thus after thewhile statement, i is no longer in scope.—end example]
3 A trivially empty iteration statementis an iteration statement matching one of the following forms:
—(3.1) while ( expression ) ;
—(3.2) while ( expression ) { }
—(3.3) do ; while ( expression ) ;
—(3.4) do { } while ( expression ) ;
—(3.5) for ( init-statement expressionopt ; ) ;
—(3.6) for ( init-statement expressionopt ; ) { }
The controlling expressionof a trivially empty iteration statement is theexpression of awhile, do, orfor
statement (ortrue, if thefor statement has noexpression). Atrivial infinite loopis a trivially empty iteration
statement for which the converted controlling expression is a constant expression, when interpreted as a
constant-expression (7.7), and evaluates totrue. The statement of a trivial infinite loop is replaced with a call
to the functionstd::this_thread::yield (32.4.5); it is implementation-defined whether this replacement
occurs on freestanding implementations.
§ 8.6.1 © ISO/IEC
190

===== PAGE 202 =====

Dxxxx
[Note 2: In a freestanding environment, concurrent forward progress is not guaranteed; such systems therefore require
explicit cooperation. A call to yield can add implicit cooperation where none is otherwise intended.—end note]
8.6.2 The while statement [stmt.while]
1 In thewhile statement, the substatement is executed repeatedly until the value of the condition (8.1) becomes
false. The test takes place before each execution of the substatement.
2 A while statement is equivalent to
label :
{
if ( condition ) {
statement
goto label ;
}
}
[Note 1: The variable created in the condition is destroyed and created with each iteration of the loop.
[Example 1:
struct A {
int val;
A(int i) : val(i) { }
~A() { }
operator bool() { return val != 0; }
};
int i = 1;
while (A a = i) {
// ...
i = 0;
}
In the while-loop, the constructor and destructor are each called twice, once for the condition that succeeds and once
for the condition that fails.—end example]
—end note]
8.6.3 The do statement [stmt.do]
1 The expression is contextually converted tobool (7.3); if that conversion is ill-formed, the program is
ill-formed.
2 In thedo statement, the substatement is executed repeatedly until the value of the expression becomesfalse.
The test takes place after each execution of the statement.
8.6.4 The for statement [stmt.for]
1 The for statement
for ( init-statement conditionopt ; expressionopt ) statement
is equivalent to
{
init-statement
while ( condition ) {
statement
expression ;
}
}
except that theinit-statement is in the same scope as thecondition, and except that acontinue in statement
(not enclosed in another iteration statement) will executeexpression before re-evaluatingcondition.
[Note 1: Thus the first statement specifies initialization for the loop; the condition (8.1) specifies a test, sequenced
before each iteration, such that the loop is exited when the condition becomesfalse; the expression often specifies
incrementing that is sequenced after each iteration.—end note]
2 Either or both of thecondition and theexpression can be omitted. A missingcondition makes the implied
while clause equivalent towhile (true).
§ 8.6.4 © ISO/IEC
191

===== PAGE 203 =====

Dxxxx
8.6.5 The range-based for statement [stmt.ranged]
1 The range-basedfor statement
for ( init-statementopt for-range-declaration : for-range-initializer ) statement
is equivalent to
{
init-statementopt
auto &&range = for-range-initializer ;
auto begin = begin-expr ;
auto end = end-expr ;
for ( ;begin != end ; ++begin ) {
for-range-declaration = * begin ;
statement
}
}
where
—(1.1) if thefor-range-initializer is anexpression, it is regarded as if it were surrounded by parentheses (so that
a comma operator cannot be reinterpreted as delimiting twoinit-declarators);
—(1.2) range , begin , andend are variables defined for exposition only; and
—(1.3) begin-expr and end-expr are determined as follows:
—(1.3.1) if the type ofrange is a reference to an array typeR, begin-expr and end-expr are range and
range + N, respectively, whereN is the array bound. IfR is an array of unknown bound or an
array of incomplete type, the program is ill-formed;
—(1.3.2) if the type ofrange is a reference to a class typeC, and searches in the scope ofC (6.5.2) for
the names begin and end each find at least one declaration,begin-expr and end-expr are
range .begin() and range .end(), respectively;
—(1.3.3) otherwise, begin-expr and end-expr are begin(range ) and end(range ), respectively, where
begin and end undergo argument-dependent lookup (6.5.4).
[Note 1: Ordinary unqualified lookup (6.5.3) is not performed.—end note]
[Example 1:
int array[5] = { 1, 2, 3, 4, 5 };
for (int& x : array)
x *= 2;
—end example]
[Note 2: The lifetime of some temporaries in thefor-range-initializer is extended to cover the entire loop (6.8.7).—end
note]
[Example 2:
using T = std::list<int>;
const T& f1(const T& t) { return t; }
const T& f2(T t) { return t; }
T g();
void foo() {
for (auto e : f1(g())) {} // OK, lifetime of return value ofg() extended
for (auto e : f2(g())) {} // undefined behavior
}
—end example]
8.7 Expansion statements [stmt.expand]
1 Expansion statements specify repeated instantiations (13.7.1) of their substatement.
expansion-statement:
template for (init-statementopt for-range-declaration : expansion-initializer ) compound-statement
expansion-initializer:
expression
expansion-init-list
§ 8.7 © ISO/IEC
192

===== PAGE 204 =====

Dxxxx
expansion-init-list:
{ expression-list ,opt }
{ }
2 The compound-statement of anexpansion-statement is a control-flow-limited statement (8.2).
3 For an expressionE, let the expressionsbegin-expr and end-expr be determined as specified in 8.6.5. An
expression isexpansion-iterable if it does not have array type and either
—(3.1) begin-expr and end-expr are of the formE.begin() and E.end(), or
—(3.2) argument-dependent lookups forbegin(E) and forend(E) each find at least one function or function
template.
4 An expansion statement is
—(4.1) an enumerating expansion statementif itsexpansion-initializer is of the formexpansion-init-list;
—(4.2) otherwise, aniterating expansion statementif itsexpansion-initializer is an expansion-iterable expression;
—(4.3) otherwise, adestructuring expansion statement.
5 An expansion statementS is equivalent to acompound-statement containing instantiations of thefor-range-
declaration (including its implied initialization), together with the compound-statement ofS, as follows:
—(5.1) If S is an enumerating expansion statement,S is equivalent to:
{
init-statement
S0
...
SN−1
}
where N is the number of elements in theexpression-list, Si is
{
for-range-declaration = Ei;
compound-statement
}
and Ei is theith element of theexpression-list.
—(5.2) Otherwise, ifS is an iterating expansion statement,S is equivalent to:
{
init-statement
constexpr auto&& range = expansion-initializer;
constexpr auto begin = begin-expr; // see 8.6.5
constexpr auto end = end-expr; // see 8.6.5
S0
...
SN−1
}
where N is the result of evaluating the expression
[] consteval {
std::ptrdiff_t result = 0;
for (auto i = begin ; i != end ; ++i) ++result;
return result; // distance frombegin to end
}()
and Si is
{
constexpr auto iter = begin + decltype(begin - begin){i };
for-range-declaration = *iter ;
compound-statement
}
§ 8.7 © ISO/IEC
193

===== PAGE 205 =====

Dxxxx
The variables range , begin , end , and iter are defined for exposition only. The identifier i is
considered to be a prvalue of typestd::ptrdiff_t; the program is ill-formed ifi is not representable
as such a value.
[Note 1: The instantiation is ill-formed ifrange is not a constant expression (7.7).—end note]
—(5.3) Otherwise, S is a destructuring expansion statement and, ifN is 0, S is equivalent to:
{
init-statement
constexpropt auto&& range = expansion-initializer;
}
otherwise, S is equivalent to:
{
init-statement
constexpropt auto&& [u0, u1, ... , uN−1] = expansion-initializer;
S0
...
SN−1
}
where N is the structured binding size of the type of theexpansion-initializer and Si is
{
for-range-declaration = ui;
compound-statement
}
The keywordconstexpr is present in the declaration ofu0,u1,...,u N−1 if and only ifconstexpr is
one of thedecl-specifiers of thedecl-specifier-seq of thefor-range-declaration.
6 [Example 1:
consteval int f(auto const&... Containers) {
int result = 0;
template for (auto const& c : {Containers...}) { // OK, enumerating expansion statement
result += c[0];
}
return result;
}
constexpr int c1[] = {1, 2, 3};
constexpr int c2[] = {4, 3, 2, 1};
static_assert(f(c1, c2) == 5);
—end example]
7 [Example 2:
consteval int f() {
constexpr std::array<int, 3> arr {1, 2, 3};
int result = 0;
template for (constexpr int s : arr) { // OK, iterating expansion statement
result += sizeof(char[s]);
}
return result;
}
static_assert(f() == 6);
—end example]
8 [Example 3:
struct S {
int i;
short s;
};
consteval long f(S s) {
long result = 0;
§ 8.7 © ISO/IEC
194

===== PAGE 206 =====

Dxxxx
template for (auto x : s) { // OK, destructuring expansion statement
result += sizeof(x);
}
return result;
}
static_assert(f(S{}) == sizeof(int) + sizeof(short));
—end example]
8.8 Jump statements [stmt.jump]
8.8.1 General [stmt.jump.general]
1 Jump statements unconditionally transfer control.
jump-statement:
break ;
continue ;
return expr-or-braced-init-listopt ;
coroutine-return-statement
goto identifier ;
2 [Note 1: On exit from a scope (however accomplished), objects with automatic storage duration (6.8.6.4) that have
been constructed in that scope are destroyed in the reverse order of their construction (8.10). For temporaries,
see 6.8.7. However, the program can be terminated (by callingstd::exit() or std::abort() (17.5), for example)
without destroying objects with automatic storage duration.—end note]
[Note 2: A suspension of a coroutine (7.6.2.4) is not considered to be an exit from a scope.—end note]
8.8.2 The break statement [stmt.break]
1 A break statement shall be enclosed by (8.1) aniteration-statement (8.6), an expansion-statement (8.7),
or aswitch statement (8.5.3). Thebreak statement causes termination of the innermost such enclosing
statement; control passes to the statement following the terminated statement, if any.
8.8.3 The continue statement [stmt.cont]
1 A continue statement shall be enclosed by (8.1) aniteration-statement or anexpansion-statement. If the
innermost enclosing such statementX is aniteration-statement (8.6), thecontinue statement causes control
to pass to the end of thestatement of X. Otherwise, control passes to the end of thecompound-statement of
the currentSi (8.7).
8.8.4 The return statement [stmt.return]
1 A function returns control to its caller by thereturn statement.
2 The expr-or-braced-init-list of areturn statement is called its operand. Areturn statement with no operand
shall be used only in a function whose return type iscv void, a constructor (11.4.5), or a destructor (11.4.7).
A return statement with an operand of typevoid shall be used only in a function that has acv void return
type. A return statement with any other operand shall be used only in a function that has a return type
other thancv void; thereturn statement initializes the returned reference or prvalue result object of the
(explicit or implicit) function call by copy-initialization (9.5) from the operand.
[Note 1: A constructor or destructor does not have a return type.—end note]
[Note 2: A return statement can involve an invocation of a constructor to perform a copy or move of the operand if it
is not a prvalue or if its type differs from the return type of the function. A copy operation associated with areturn
statement can be elided or converted to a move operation if an automatic storage duration variable is returned (11.9.6).
—end note]
3 The destructor for the result object is potentially invoked (11.4.7, 14.3).
[Example 1:
class A {
~A() {}
};
A f() { return A(); } // error: destructor ofA is private (even though it is never invoked)
—end example]
§ 8.8.4 © ISO/IEC
195

===== PAGE 207 =====

Dxxxx
4 Flowing off the end of a constructor, a destructor, or a non-coroutine function with acv void return type
is equivalent to areturn with no operand. Otherwise, flowing off the end of a function that is neither
main (6.10.3.1) nor a coroutine (9.6.4) results in undefined behavior.
5 The copy-initialization of the result of the call is sequenced before the destruction of temporaries at the end
of the full-expression established by the operand of thereturn statement, which, in turn, is sequenced before
the destruction of local variables (8.8) of the block enclosing thereturn statement.
[Note 3: These operations are sequenced before the destruction of local variables in each remaining enclosing block of
the function (8.10), which, in turn, is sequenced before the evaluation of postcondition assertions of the function (9.4.1),
which, in turn, is sequenced before the destruction of function parameters (7.6.1.3).—end note]
6 In a function other than an invented function forstd::is_convertible (21.3.8), areturn statement that
binds
—(6.1) a returned reference or
—(6.2) a constituent reference (6.8.2) of a returned object
to a temporary expression (6.8.7) is ill-formed.
[Example 2:
auto&& f1() {
return 42; // ill-formed
}
const double& f2() {
static int x = 42;
return x; // ill-formed
}
auto&& id(auto&& r) {
return static_cast<decltype(r)&&>(r);
}
auto&& f3() {
return id(42); // OK, but probably a bug
}
—end example]
8.8.5 The co_return statement [stmt.return.coroutine]
coroutine-return-statement:
co_return expr-or-braced-init-listopt ;
1 A co_return statement transfers control to the caller or resumer of a coroutine (9.6.4). A coroutine shall
not enclose areturn statement (8.8.4).
[Note 1: For this determination, it is irrelevant whether thereturn statement is enclosed by a discarded statement
(8.5.2). —end note]
2 The expr-or-braced-init-list of aco_return statement is called its operand. Letp be an lvalue naming the
coroutine promise object (9.6.4). Aco_return statement is equivalent to:
{ S; goto final-suspend ; }
where final-suspend is the exposition-only label defined in 9.6.4 andS is defined as follows:
—(2.1) If the operand is abraced-init-list or an expression of non-void type, S is p.return_value(expr-or-
braced-init-list). The expressionS shall be a prvalue of typevoid.
—(2.2) Otherwise, S is the compound-statement { expressionopt ; p.return_void(); }. The expression
p.return_void() shall be a prvalue of typevoid.
3 If a search for the namereturn_void in the scope of the promise type finds any declarations, flowing off the
end of a coroutine’sfunction-body is equivalent to aco_return with no operand; otherwise flowing off the
end of a coroutine’sfunction-body results in undefined behavior.
8.8.6 The goto statement [stmt.goto]
1 The goto statement unconditionally transfers control to the statement labeled by the identifier. The identifier
shall be a label (8.2) located in the current function.
§ 8.8.6 © ISO/IEC
196

===== PAGE 208 =====

Dxxxx
8.9 Assertion statement [stmt.contract.assert]
assertion-statement:
contract_assert attribute-specifier-seqopt ( conditional-expression ) ;
1 An assertion-statement introduces a contract assertion (6.11). The optionalattribute-specifier-seq appertains
to the introduced contract assertion.
2 The predicate (6.11.1) of anassertion-statement is itsconditional-expression contextually converted tobool.
3 The evaluation of consecutiveassertion-statements is an evaluation in sequence (6.11.2) of the contract
assertions introduced by thoseassertion-statements.
[Note 1: A sequence ofassertion-statements can thus be repeatedly evaluated as a group.
[Example 1:
int f(int i)
{
contract_assert(i == 0); // #1
contract_assert(i >= 0); // #2
return 0;
}
int g = f(0); // can evaluate #1, #2, #1, #2
—end example]
—end note]
8.10 Declaration statement [stmt.dcl]
1 A declaration statement introduces one or more new names into a block; it has the form
declaration-statement:
block-declaration
[Note 1: If an identifier introduced by a declaration was previously declared in an outer block, the outer declaration is
hidden for the remainder of the block (6.5.3), after which it resumes its force.—end note]
2 A block variable with automatic storage duration (6.8.6.4) isactive everywhere in the scope to which it
belongs after itsinit-declarator. Upon each transfer of control (including sequential execution of statements)
within a function from pointP to pointQ, all block variables with automatic storage duration that are
active atP and not atQ are destroyed in the reverse order of their construction. Then, all block variables
with automatic storage duration that are active atQ but not atP are initialized in declaration order; unless
all such variables have vacuous initialization (6.8.4), the transfer of control shall not be a jump.69 When a
declaration-statement is executed,P and Q are the points immediately before and after it; when a function
returns, Q is after its body.
[Example 1:
void f() {
// ...
goto lx; // error: jump into scope ofa
// ...
ly:
X a = 1;
// ...
lx:
goto ly; // OK, jump implies destructor call fora followed by
// construction again immediately following labelly
}
—end example]
3 Dynamic initialization of a block variable with static storage duration (6.8.6.2) or thread storage duration
(6.8.6.3) is performed the first time control passes through its declaration; such a variable is considered
initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the
initialization is not complete, so it will be tried again the next time control enters the declaration. If control
enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait
for completion of the initialization.
69) The transfer from the condition of aswitch statement to acase label is considered a jump in this respect.
§ 8.10 © ISO/IEC
197

===== PAGE 209 =====

Dxxxx
[Note 2: A conforming implementation cannot introduce any deadlock around execution of the initializer. Deadlocks
might still be caused by the program logic; the implementation need only avoid deadlocks due to its own synchronization
operations. —end note]
If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.
[Example 2:
int foo(int i) {
static int s = foo(2*i); // undefined behavior: recursive call
return i+1;
}
—end example]
4 An object associated with a block variable with static or thread storage duration will be destroyed if and
only if it was constructed.
[Note 3: 6.10.3.4 describes the order in which such objects are destroyed.—end note]
8.11 Ambiguity resolution [stmt.ambig]
1 There is an ambiguity in the grammar involvingexpression-statements anddeclarations: Anexpression-statement
with a function-style explicit type conversion (7.6.1.4) as its leftmost subexpression can be indistinguishable
from adeclaration where the firstdeclarator starts with a(. In those cases thestatement is considered a
declaration, except as specified below.
2 [Note 1: If thestatement cannot syntactically be adeclaration, there is no ambiguity, so this rule does not apply.
In some cases, the wholestatement needs to be examined to determine whether this is the case. This resolves the
meaning of many examples.
[Example 1: Assuming T is asimple-type-specifier (9.2.9.3),
T(a)->m = 7; // expression-statement
T(a)++; // expression-statement
T(a,5)<<c; // expression-statement
T(*d)(int); // declaration
T(e)[5]; // declaration
T(f) = { 1, 2 }; // declaration
T(*g)(double(3)); // declaration
In the last example above,g, which is a pointer toT, is initialized todouble(3). This is of course ill-formed for
semantic reasons, but that does not affect the syntactic analysis.—end example]
The remaining cases aredeclarations.
[Example 2:
class T {
// ...
public:
T();
T(int);
T(int, int);
};
T(a); // declaration
T(*b)(); // declaration
T(c)=7; // declaration
T(d),e,f=3; // declaration
extern int h;
T(g)(h,2); // declaration
—end example]
—end note]
3 The disambiguation is purely syntactic; that is, the meaning of the names occurring in such a statement,
beyond whether they aretype-names or not, is not generally used in or changed by the disambiguation. Class
templates are instantiated as necessary to determine if a qualified name is atype-name. Disambiguation
precedes parsing, and a statement disambiguated as a declaration may be an ill-formed declaration. If, during
parsing, lookup finds that a name in a template argument is bound to (part of) the declaration being parsed,
the program is ill-formed. No diagnostic is required.
§ 8.11 © ISO/IEC
198

===== PAGE 210 =====

Dxxxx
[Example 3:
struct T1 {
T1 operator()(int x) { return T1(x); }
int operator=(int x) { return x; }
T1(int) { }
};
struct T2 { T2(int) { } };
int a, (*(*b)(T2))(int), c, d;
void f() {
// disambiguation requires this to be parsed as a declaration:
T1(a) = 3,
T2(4), // T2 will be declared as a variable of typeT1, but this will not
(*(*b)(T2(c)))(int(d)); // allow the last part of the declaration to parse properly,
// since it depends onT2 being a type-name
}
—end example]
4 A syntactically ambiguous statement that can syntactically be adeclaration with an outermostdeclarator
with atrailing-return-type is considered adeclaration only if it starts withauto.
[Example 4:
struct M;
struct S {
S* operator()();
int N;
int M;
void mem(S s) {
auto(s)()->M; // expression,S::M hides ::M
}
};
void f(S s) {
{
auto(s)()->N; // expression
auto(s)()->M; // function declaration
}
{
S(s)()->N; // expression
S(s)()->M; // expression
}
}
—end example]
§ 8.11 © ISO/IEC
199

===== PAGE 211 =====

Dxxxx
9 Declarations [dcl]
9.1 Preamble [dcl.pre]
1 Declarations generally specify how names are to be interpreted. Declarations have the form
declaration-seq:
declaration declaration-seqopt
declaration:
name-declaration
special-declaration
name-declaration:
block-declaration
nodeclspec-function-declaration
function-definition
friend-type-declaration
template-declaration
deduction-guide
linkage-specification
namespace-definition
empty-declaration
attribute-declaration
module-import-declaration
special-declaration:
explicit-instantiation
explicit-specialization
export-declaration
block-declaration:
simple-declaration
asm-declaration
namespace-alias-definition
using-declaration
using-enum-declaration
using-directive
static_assert-declaration
consteval-block-declaration
alias-declaration
opaque-enum-declaration
nodeclspec-function-declaration:
attribute-specifier-seqopt declarator ;
alias-declaration:
using identifier attribute-specifier-seqopt = defining-type-id ;
sb-identifier:
...opt identifier attribute-specifier-seqopt
sb-identifier-list:
sb-identifier
sb-identifier-list , sb-identifier
structured-binding-declaration:
attribute-specifier-seqopt decl-specifier-seq ref-qualifieropt [ sb-identifier-list ]
simple-declaration:
decl-specifier-seq init-declarator-listopt ;
attribute-specifier-seq decl-specifier-seq init-declarator-list;
structured-binding-declaration initializer;
static_assert-message:
unevaluated-string
constant-expression
§ 9.1 © ISO/IEC
200

===== PAGE 212 =====

Dxxxx
static_assert-declaration:
static_assert ( constant-expression ) ;
static_assert ( constant-expression , static_assert-message ) ;
consteval-block-declaration:
consteval compound-statement
empty-declaration:
;
attribute-declaration:
attribute-specifier-seq ;
[Note 1: asm-declarations are described in 9.11, andlinkage-specifications are described in 9.12;function-definitions are
described in 9.6 andtemplate-declarations anddeduction-guides are described in 13.7.2.3;namespace-definitions are
described in 9.9.2,using-declarations are described in 9.10 andusing-directives are described in 9.9.4.—end note]
2 Certain declarations contain one or more scopes (6.4.1). Unless otherwise stated, utterances in Clause 9 about
components in, of, or contained by a declaration or subcomponent thereof refer only to those components of
the declaration that arenot nested within scopes nested within the declaration.
3 If aname-declaration matches the syntactic requirements offriend-type-declaration, it is afriend-type-declaration.
4 A simple-declaration or nodeclspec-function-declaration of the form
attribute-specifier-seqopt decl-specifier-seqopt init-declarator-listopt ;
is divided into three parts. Attributes are described in 9.13.decl-specifiers, the principal components of a
decl-specifier-seq, are described in 9.2.declarators, the components of aninit-declarator-list, are described in 9.3.
The attribute-specifier-seq appertains to each of the entities declared by thedeclarators of theinit-declarator-list.
[Note 2: In the declaration for an entity, attributes appertaining to that entity can appear at the start of the
declaration and after thedeclarator-id for that declaration. —end note]
[Example 1:
[[noreturn]] void f [[noreturn]] (); // OK
—end example]
5 If adeclarator-id is a name, theinit-declarator and (hence) the declaration introduce that name.
[Note 3: Otherwise, thedeclarator-id is aqualified-id or names a destructor or itsunqualified-id is atemplate-id and no
name is introduced. —end note]
The defining-type-specifiers (9.2.9) in thedecl-specifier-seq and the recursivedeclarator structure describe a
type (9.3.4), which is then associated with thedeclarator-id.
6 In a simple-declaration, the optionalinit-declarator-list can be omitted only when declaring a class (11.1)
or enumeration (9.8.1), that is, when thedecl-specifier-seq contains either aclass-specifier, anelaborated-
type-specifier with a class-key (11.3), or anenum-specifier. In these cases and whenever aclass-specifier
or enum-specifier is present in thedecl-specifier-seq, the identifiers in these specifiers are also declared (as
class-names, enum-names, orenumerators, depending on the syntax). In such cases, thedecl-specifier-seq shall
(re)introduce one or more names into the program.
[Example 2:
enum { }; // error
typedef class { }; // error
—end example]
7 A simple-declaration or acondition with astructured-binding-declaration is called astructured binding declaration
(9.7). Each decl-specifier in thedecl-specifier-seq shall be constexpr, constinit, static, thread_local,
auto (9.2.9.7), or a cv-qualifier. The declaration shall contain at most onesb-identifier whose identifier
is preceded by an ellipsis. If the declaration contains any suchsb-identifier, it shall declare a templated
entity (13.1).
[Example 3:
template<class T> concept C = true;
C auto [x, y] = std::pair{1, 2}; // error: constrainedplaceholder-type-specifier
// not permitted for structured bindings
—end example]
§ 9.1 © ISO/IEC
201

===== PAGE 213 =====

Dxxxx
The initializer shall be of the form “= assignment-expression”, of the form “{ assignment-expression }”, or
of the form “( assignment-expression )”. If the structured-binding-declaration appears as a condition, the
assignment-expression shall be of non-union class type. Otherwise, theassignment-expression shall be of array
or non-union class type.
8 If the decl-specifier-seq contains the typedef specifier, the declaration is atypedef declarationand each
declarator-id is declared to be atypedef-name (9.2.4).
[Note 4: Such adeclarator-id is anidentifier (11.4.8.3). —end note]
Otherwise, if the type associated with adeclarator-id is a function type (9.3.4.6), the declaration is afunction
declaration. Otherwise, if the type associated with adeclarator-id is an object or reference type, the declaration
is anobject declaration. Otherwise, the program is ill-formed.
[Example 4:
int f(), x; // OK, function declaration forf and object declaration forx
extern void g(), // OK, function declaration forg
y; // error: void is not an object type
—end example]
9 An object definition causes storage of appropriate size and alignment to be reserved and any appropriate
initialization (9.5) to be done.
10 Syntactic components beyond those found in the general form ofsimple-declaration are added to a function
declaration to make afunction-definition. A token sequence starting with{ or = is treated as afunction-
body (9.6.1) if the type of thedeclarator-id (9.3.4.1) is a function type, and is otherwise treated as a
brace-or-equal-initializer (9.5.1).
[Note 5: If the declaration acquires a function type through template instantiation, the program is ill-formed; see
13.9.1. The function type of a function definition cannot be specified with atypedef-name (9.3.4.6). —end note]
11 A nodeclspec-function-declaration shall declare a constructor, destructor, or conversion function.
[Note 6: Because a member function cannot be subject to a non-defining declaration outside of a class definition (11.4.2),
a nodeclspec-function-declaration can only be used in atemplate-declaration (13.1), explicit-instantiation (13.9.3), or
explicit-specialization (13.9.4). —end note]
12 If astatic_assert-message matches the syntactic requirements ofunevaluated-string, it is anunevaluated-string
and the text of thestatic_assert-message is the text of theunevaluated-string. Otherwise, astatic_assert-
message shall be an expressionM such that
—(12.1) the expressionM.size() is implicitly convertible to the typestd::size_t, and
—(12.2) the expressionM.data() is implicitly convertible to the type “pointer toconst char”.
13 In astatic_assert-declaration, theconstant-expression E is contextually converted tobool and the converted
expression shall be a constant expression (7.7). If the value of the expressionE when so converted istrue
or the expression is evaluated in the context of a template definition, the declaration has no effect and the
static_assert-message is an unevaluated operand (7.2.3). Otherwise, thestatic_assert-declaration fails and
—(13.1) the program is ill-formed, and
—(13.2) if thestatic_assert-message is aconstant-expression M,
—(13.2.1) M.size() shall be a converted constant expression of typestd::size_t and letN denote the
value of that expression,
—(13.2.2) M.data(), implicitly converted to the type “pointer toconst char”, shall be a core constant
expression and letD denote the converted expression,
—(13.2.3) for eachi where 0 ≤i<N , D[i] shall be an integral constant expression, and
—(13.2.4) the text of thestatic_assert-message is formed by the sequence ofN code units, starting atD, of
the ordinary literal encoding (5.3.1).
14 Recommended practice: When astatic_assert-declaration fails, the resulting diagnostic message should include
the text of thestatic_assert-message, if one is supplied.
[Example 5:
static_assert(sizeof(int) == sizeof(void*), "wrong pointer size");
static_assert(sizeof(int[2])); // OK, narrowing allowed
§ 9.1 © ISO/IEC
202

===== PAGE 214 =====

Dxxxx
template <class T>
void f(T t) {
if constexpr (sizeof(T) == sizeof(int)) {
use(t);
} else {
static_assert(false, "must be int-sized");
}
}
void g(char c) {
f(0); // OK
f(c); // error on implementations wheresizeof(int) > 1: must beint-sized
}
—end example]
15 For aconsteval-block-declaration D, the expressionE corresponding toD is:
[] static consteval -> void compound-statement ()
E shall be a constant expression (7.7).
[Note 7: The evaluation of the expression corresponding to aconsteval-block-declaration (5.2) can produce injected
declarations as side effects.—end note]
[Example 6:
struct S;
consteval {
std::meta::define_aggregate(^^S, {}); // OK
template<class T>
struct X { }; // error: local templates are not allowed
template<class T>
concept C = true; // error: local concepts are not allowed
return; // OK
}
—end example]
16 An empty-declaration has no effect.
17 Except where otherwise specified, the meaning of anattribute-declaration is implementation-defined.
9.2 Specifiers [dcl.spec]
9.2.1 General [dcl.spec.general]
1 The specifiers that can be used in a declaration are
decl-specifier:
storage-class-specifier
defining-type-specifier
function-specifier
friend
typedef
constexpr
consteval
constinit
inline
decl-specifier-seq:
decl-specifier attribute-specifier-seqopt
decl-specifier decl-specifier-seq
The optionalattribute-specifier-seq in adecl-specifier-seq appertains to the type determined by the preceding
decl-specifiers (9.3.4). Theattribute-specifier-seq affects the type only for the declaration it appears in, not
other declarations involving the same type.
2 At most one of each of thedecl-specifiers friend, typedef, orinline shall appear in adecl-specifier-seq. At
most one of theconstexpr, consteval, andconstinit keywords shall appear in adecl-specifier-seq.
§ 9.2.1 © ISO/IEC
203

===== PAGE 215 =====

Dxxxx
3 If atype-name is encountered while parsing adecl-specifier-seq, it is interpreted as part of thedecl-specifier-seq
if and only if there is no previousdefining-type-specifier other than acv-qualifier in thedecl-specifier-seq. The
sequence shall be self-consistent as described below.
[Example 1:
typedef char* Pc;
static Pc; // error: name missing
Here, the declarationstatic Pcis ill-formed because no name was specified for the static variable of typePc. To get a
variable calledPc, atype-specifier (other thanconst or volatile) has to be present to indicate that thetypedef-name
Pc is the name being (re)declared, rather than being part of thedecl-specifier sequence. For another example,
void f(const Pc); // void f(char* const) (not const char*)
void g(const int Pc); // void g(const int)
—end example]
4 [Note 1: Since signed, unsigned, long, andshort by default implyint, atype-name appearing after one of those
specifiers is treated as the name being (re)declared.
[Example 2:
void h(unsigned Pc); // void h(unsigned int)
void k(unsigned int Pc); // void k(unsigned int)
—end example]
—end note]
9.2.2 Storage class specifiers [dcl.stc]
1 The storage class specifiers are
storage-class-specifier:
static
thread_local
extern
mutable
At most onestorage-class-specifier shall appear in a givendecl-specifier-seq, except thatthread_local may
appear withstatic or extern. If thread_local appears in any declaration of a variable it shall be present
in all declarations of that entity. If astorage-class-specifier appears in adecl-specifier-seq, there can be no
typedef specifier in the samedecl-specifier-seq and theinit-declarator-list or member-declarator-list of the
declaration shall not be empty (except for an anonymous union declared in a namespace scope (11.5.2)). The
storage-class-specifier applies to the name declared by eachinit-declarator in the list and not to any names
declared by other specifiers.
[Note 1: See 13.9.4 and 13.9.3 for restrictions in explicit specializations and explicit instantiations, respectively.—end
note]
2 [Note 2: A variable declared without astorage-class-specifier at block scope or declared as a function parameter has
automatic storage duration by default (6.8.6.4).—end note]
3 The thread_local specifier indicates that the named entity has thread storage duration (6.8.6.3). It shall
be applied only to the declaration of a variable of namespace or block scope, to a structured binding
declaration (9.7), or to the declaration of a static data member. Whenthread_local is applied to a variable
of block scope thestorage-class-specifier static is implied if no otherstorage-class-specifier appears in the
decl-specifier-seq.
4 The static specifier shall be applied only to the declaration of a variable or function, to a structured
binding declaration (9.7), or to the declaration of an anonymous union (11.5.2). There can be nostatic
function declarations within a block, nor anystatic function parameters. Astatic specifier used in the
declaration of a variable declares the variable to have static storage duration (6.8.6.2), unless accompanied by
the thread_local specifier, which declares the variable to have thread storage duration (6.8.6.3). Astatic
specifier can be used in declarations of class members; 11.4.9 describes its effect. For the linkage of a name
declared with astatic specifier, see 6.7.
5 The extern specifier shall be applied only to the declaration of a variable or function. Theextern specifier
shall not be used in the declaration of a class member or function parameter. For the linkage of a name
declared with anextern specifier, see 6.7.
§ 9.2.2 © ISO/IEC
204

===== PAGE 216 =====

Dxxxx
[Note 3: The extern keyword can also be used inexplicit-instantiations and linkage-specifications, but it is not a
storage-class-specifier in such contexts.—end note]
6 All declarations for a given entity shall give its name the same linkage.
[Note 4: The linkage given by some declarations is affected by previous declarations. Overloads are distinct entities.
—end note]
[Example 1:
static char* f(); // f() has internal linkage
char* f() // f() still has internal linkage
{ /* ... */ }
char* g(); // g() has external linkage
static char* g() // error: inconsistent linkage
{ /* ... */ }
void h();
inline void h(); // external linkage
inline void l();
void l(); // external linkage
inline void m();
extern void m(); // external linkage
static void n();
inline void n(); // internal linkage
static int a; // a has internal linkage
int a; // error: two definitions
static int b; // b has internal linkage
extern int b; // b still has internal linkage
int c; // c has external linkage
static int c; // error: inconsistent linkage
extern int d; // d has external linkage
static int d; // error: inconsistent linkage
—end example]
7 The name of a declared but undefined class can be used in anextern declaration. Such a declaration can
only be used in ways that do not require a complete class type.
[Example 2:
struct S;
extern S a;
extern S f();
extern void g(S);
void h() {
g(a); // error: S is incomplete
f(); // error: S is incomplete
}
—end example]
8 The mutable specifier shall appear only in the declaration of a non-static data member (11.4) whose type is
neither const-qualified nor a reference type.
[Example 3:
class X {
mutable const int* p; // OK
mutable int* const q; // error
};
§ 9.2.2 © ISO/IEC
205

===== PAGE 217 =====

Dxxxx
—end example]
9 [Note 5: Themutable specifier on a class data member nullifies aconst specifier applied to the containing class object
and permits modification of the mutable class member even though the rest of the object is const (6.9.5, 9.2.9.2).
—end note]
9.2.3 Function specifiers [dcl.fct.spec]
1 A function-specifier can be used only in a function declaration. At most oneexplicit-specifier and at most one
virtual keyword shall appear in adecl-specifier-seq.
function-specifier:
virtual
explicit-specifier
explicit-specifier:
explicit ( constant-expression )
explicit
2 The virtual specifier shall be used only in the initial declaration of a non-static member function; see 11.7.3.
3 An explicit-specifier shall be used only in the declaration of a constructor or conversion function within its
class definition; see 11.4.8.2 and 11.4.8.3.
4 In anexplicit-specifier, theconstant-expression, if supplied, shall be a contextually converted constant expression
of typebool (7.7). The explicit-specifier explicit without aconstant-expression is equivalent to theexplicit-
specifier explicit(true). If the constant expression evaluates totrue, the function is explicit. Otherwise,
the function is not explicit. A( token that followsexplicit is parsed as part of theexplicit-specifier.
[Example 1:
struct S {
explicit(sizeof(char[2])) S(char); // error: narrowing conversion of value 2 to typebool
explicit(sizeof(char)) S(bool); // OK, conversion of value 1 to typebool is non-narrowing
};
—end example]
9.2.4 The typedef specifier [dcl.typedef]
1 Declarations containing thedecl-specifier typedef declare type aliases. The typedef specifier shall not be
combined in adecl-specifier-seq with any other kind of specifier except adefining-type-specifier, and it shall
not be used in thedecl-specifier-seq of a parameter-declaration (9.3.4.6) nor in thedecl-specifier-seq of a
function-definition (9.6). If atypedef specifier appears in a declaration without adeclarator, the program is
ill-formed.
typedef-name:
identifier
simple-template-id
A name declared with thetypedef specifier becomes atypedef-name. The underlying entity of the type alias
is the type associated with theidentifier (9.3) orsimple-template-id (13.1). A typedef-name does not introduce
a new type the way a class declaration (11.3) or enum declaration (9.8.1) does.
[Example 1: After
typedef int MILES, *KLICKSP;
the constructions
MILES distance;
extern KLICKSP metricp;
are all correct declarations; the type ofdistance is int and that ofmetricp is “pointer toint”. —end example]
2 A type alias can also be declared by analias-declaration. The identifier following theusing keyword is not
looked up; it becomes thetypedef-name of a type alias and the optionalattribute-specifier-seq following the
identifier appertains to that type alias. Such a type alias has the same semantics as if it were introduced by
the typedef specifier.
[Example 2:
using handler_t = void (*)(int);
extern handler_t ignore;
extern void (*ignore)(int); // redeclareignore
§ 9.2.4 © ISO/IEC
206

===== PAGE 218 =====

Dxxxx
template<class T> struct P { };
using cell = P<cell*>; // error: cell not found (6.4.2)
—end example]
The defining-type-specifier-seq of the defining-type-id shall not define a class or enumeration if thealias-
declaration is thedeclaration of atemplate-declaration.
3 A simple-template-id is only atypedef-name if itstemplate-name names an alias template or a type template
template parameter.
[Note 1: A simple-template-id that names a class template specialization is aclass-name (11.3). If atypedef-name
is used to identify the subject of anelaborated-type-specifier (9.2.9.5), a class definition (Clause 11), a constructor
declaration (11.4.5), or a destructor declaration (11.4.7), the program is ill-formed.—end note]
[Example 3:
struct S {
S();
~S();
};
typedef struct S T;
S a = T(); // OK
struct T * p; // error
—end example]
4 An unnamed class or enumerationC defined in a typedef declaration has the firsttypedef-name declared by
the declaration to be of typeC as itstypedef name for linkage purposes(6.7).
[Note 2: A typedef declaration involving alambda-expression does not itself define the associated closure type, and so
the closure type is not given a typedef name for linkage purposes.—end note]
[Example 4:
typedef struct { } *ps, S; // S is the typedef name for linkage purposes
typedef decltype([]{}) C; // the closure type has no typedef name for linkage purposes
—end example]
5 An unnamed class with a typedef name for linkage purposes shall not
—(5.1) declare any members other than non-static data members, member enumerations, or member classes,
—(5.2) have any base classes or default member initializers, or
—(5.3) contain alambda-expression,
and all member classes shall also satisfy these requirements (recursively).
[Example 5:
typedef struct {
int f() {}
} X; // error: struct with typedef name for linkage has member functions
—end example]
9.2.5 The friend specifier [dcl.friend]
1 The friend specifier is used to specify access to class members; see 11.8.4.
9.2.6 The constexpr and consteval specifiers [dcl.constexpr]
1 The constexpr specifier shall be applied only to the definition of a variable or variable template, a structured
binding declaration, or the declaration of a function or function template. Theconsteval specifier shall
be applied only to the declaration of a function or function template. A function or static data member
declared with theconstexpr or consteval specifier on its first declaration is implicitly an inline function
or variable (9.2.8). If any declaration of a function or function template has aconstexpr or consteval
specifier, then all its declarations shall contain the same specifier.
[Note 1: An explicit specialization can differ from the template declaration with respect to theconstexpr or consteval
specifier. —end note]
[Note 2: Function parameters cannot be declaredconstexpr. —end note]
§ 9.2.6 © ISO/IEC
207

===== PAGE 219 =====

Dxxxx
[Example 1:
constexpr void square(int &x); // OK, declaration
constexpr int bufsz = 1024; // OK, definition
constexpr struct pixel { // error: pixel is a type
int x;
int y;
constexpr pixel(int); // OK, declaration
};
constexpr pixel::pixel(int a)
: x(a), y(x) // OK, definition
{ square(x); }
constexpr pixel small(2); // error: square not defined, sosmall(2)
// not constant (7.7) soconstexpr not satisfied
constexpr void square(int &x) { // OK, definition
x *= x;
}
constexpr pixel large(4); // OK,square defined
int next(constexpr int x) { // error: not for parameters
return x + 1;
}
extern constexpr int memsz; // error: not a definition
—end example]
2 A constexpr or consteval specifier used in the declaration of a function declares that function to be a
constexpr function.
[Note 3: A function declared with theconsteval specifier is an immediate function (7.7).—end note]
A destructor, an allocation function, or a deallocation function shall not be declared with theconsteval
specifier.
3 A function isconstexpr-suitable if it is not a coroutine (9.6.4).
Except for instantiated constexpr functions, non-templated constexpr functions shall be constexpr-suitable.
[Example 2:
constexpr int square(int x)
{ return x * x; } // OK
constexpr long long_max()
{ return 2147483647; } // OK
constexpr int abs(int x) {
if (x < 0)
x = -x;
return x; // OK
}
constexpr int constant_non_42(int n) { // OK
if (n == 42) {
static int value = n;
return value;
}
return n;
}
constexpr int uninit() {
struct { int a; } s;
return s.a; // error: uninitialized read ofs.a
}
constexpr int prev(int x)
{ return --x; } // OK
constexpr int g(int x, int n) { // OK
int r = 1;
while (--n > 0) r *= x;
return r;
}
—end example]
§ 9.2.6 © ISO/IEC
208

===== PAGE 220 =====

Dxxxx
4 An invocation of a constexpr function in a given context produces the same result as an invocation of an
equivalent non-constexpr function in the same context in all respects except that
—(4.1) an invocation of a constexpr function can appear in a constant expression (7.7) and
—(4.2) copy elision is not performed in a constant expression (11.9.6).
[Note 4: Declaring a function constexpr can change whether an expression is a constant expression. This can indirectly
cause calls tostd::is_constant_evaluated within an invocation of the function to produce a different value.—end
note]
[Note 5: It is possible to write a constexpr function for which no invocation satisfies the requirements of a core
constant expression. —end note]
5 The constexpr and consteval specifiers have no effect on the type of a constexpr function.
[Example 3:
constexpr int bar(int x, int y) // OK
{ return x + y + x*y; }
// ...
int bar(int x, int y) // error: redefinition ofbar
{ return x * 2 + 3 * y; }
—end example]
6 A constexpr specifier used in an object declaration declares the object as const. Such an object shall have
literal type and shall be initialized. Aconstexpr variable shall be constant-initializable (7.7). Aconstexpr
variable that is an object, as well as any temporary to which aconstexpr reference is bound, shall have
constant destruction.
[Example 4:
struct pixel {
int x, y;
};
constexpr pixel ur = { 1294, 1024 }; // OK
constexpr pixel origin; // error: initializer missing
namespace N {
void f() {
int x;
constexpr int& ar = x; // OK
static constexpr int& sr = x; // error: x is not constexpr-representable
// at the point indicated below
}
// immediate scope here is that ofN
}
—end example]
9.2.7 The constinit specifier [dcl.constinit]
1 The constinit specifier shall be applied only to a declaration of a variable with static or thread storage
duration or to a structured binding declaration (9.7).
[Note 1: A structured binding declaration introduces a uniquely named variable, to which theconstinit specifier
applies. —end note]
If the specifier is applied to any declaration of a variable, it shall be applied to the initializing declaration.
No diagnostic is required if noconstinit declaration is reachable at the point of the initializing declaration.
2 If a variable declared with theconstinit specifier has dynamic initialization (6.10.3.3), the program is
ill-formed, even if the implementation would perform that initialization as a static initialization (6.10.3.2).
[Note 2: The constinit specifier ensures that the variable is initialized during static initialization.—end note]
3 [Example 1:
const char * g() { return "dynamic initialization"; }
constexpr const char * f(bool p) { return p ? "constant initializer" : g(); }
constinit const char * c = f(true); // OK
constinit const char * d = f(false); // error
—end example]
§ 9.2.7 © ISO/IEC
209

===== PAGE 221 =====

Dxxxx
9.2.8 The inline specifier [dcl.inline]
1 The inline specifier shall be applied only to the declaration of a function or variable. Theinline specifier
shall not appear on a block scope declaration or on the declaration of a function parameter. If theinline
specifier is used in a friend function declaration, that declaration shall be a definition or the function shall
have previously been declared inline.
2 A function declaration (9.3.4.6, 11.4.2, 11.8.4) with aninline specifier declares aninline function. A variable
declaration with aninline specifier declares aninline variable.
[Note 1: An inline function or variable with external or module linkage can be defined in multiple translation
units (6.3), but is one entity with one address. A type orstatic variable defined in the body of such a function is
therefore a single entity.—end note]
[Note 2: The inline keyword has no effect on the linkage of a function. In certain cases, an inline function cannot
use names with internal linkage; see 6.7.—end note]
3 The inline specifier indicates to the implementation that inline substitution of the function body at the point
of call is to be preferred to the usual function call mechanism. An implementation is not required to perform
this inline substitution at the point of call; however, even if this inline substitution is omitted, the other rules
for inline functions specified in this subclause shall still be respected.
4 If a definition of a function or variable is reachable at the point of its first declaration as inline, the program
is ill-formed. If a function or variable with external or module linkage is declared inline in one definition
domain, an inline declaration of it shall be reachable from the end of every definition domain in which it is
declared; no diagnostic is required.
[Note 3: A call to an inline function or a use of an inline variable can be encountered before its definition becomes
reachable in a translation unit.—end note]
5 If an inline function or variable that is attached to a named module is declared in a definition domain, it
shall be defined in that domain.
[Note 4: A constexpr function (9.2.6) is implicitly inline. In the global module, a function defined within a class
definition is implicitly inline (11.4.2, 11.8.4).—end note]
9.2.9 Type specifiers [dcl.type]
9.2.9.1 General [dcl.type.general]
1 The type-specifiers are
type-specifier:
simple-type-specifier
elaborated-type-specifier
typename-specifier
cv-qualifier
type-specifier-seq:
type-specifier attribute-specifier-seqopt
type-specifier type-specifier-seq
defining-type-specifier:
type-specifier
class-specifier
enum-specifier
defining-type-specifier-seq:
defining-type-specifier attribute-specifier-seqopt
defining-type-specifier defining-type-specifier-seq
The optionalattribute-specifier-seq in atype-specifier-seq or adefining-type-specifier-seq appertains to the type
denoted by the precedingtype-specifiers ordefining-type-specifiers (9.3.4). Theattribute-specifier-seq affects
the type only for the declaration it appears in, not other declarations involving the same type.
2 As a general rule, at most onedefining-type-specifier is allowed in the completedecl-specifier-seq of adeclaration
or in adefining-type-specifier-seq, and at most onetype-specifier is allowed in atype-specifier-seq. The only
exceptions to this rule are the following:
—(2.1) const can be combined with any type specifier except itself.
—(2.2) volatile can be combined with any type specifier except itself.
—(2.3) signed or unsigned can be combined withchar, long, short, orint.
§ 9.2.9.1 © ISO/IEC
210

===== PAGE 222 =====

Dxxxx
—(2.4) short or long can be combined withint.
—(2.5) long can be combined withdouble.
—(2.6) long can be combined withlong.
3 Except in a declaration of a constructor, destructor, or conversion function, at least onedefining-type-specifier
that is not acv-qualifier shall appear in a completetype-specifier-seq or a completedecl-specifier-seq.
4 [Note 1: enum-specifiers, class-specifiers, andtypename-specifiers are discussed in 9.8.1, Clause 11, and 13.8, respectively.
The remainingtype-specifiers are discussed in the rest of 9.2.9.—end note]
9.2.9.2 The cv-qualifiers [dcl.type.cv]
1 There are twocv-qualifiers, const and volatile. Eachcv-qualifier shall appear at most once in acv-qualifier-
seq. If a cv-qualifier appears in adecl-specifier-seq, the init-declarator-list or member-declarator-list of the
declaration shall not be empty.
[Note 1: 6.9.5 and 9.3.4.6 describe how cv-qualifiers affect object and function types.—end note]
Redundant cv-qualifications are ignored.
[Note 2: For example, these could be introduced by typedefs.—end note]
2 [Note 3: Declaring a variableconst can affect its linkage (9.2.2) and its usability in constant expressions (7.7). As
described in 9.5, the definition of an object or subobject of const-qualified type must specify an initializer or be subject
to default-initialization. —end note]
3 A pointer or reference to a cv-qualified type need not actually point or refer to a cv-qualified object, but it
is treated as if it does; a const-qualified access path cannot be used to modify an object even if the object
referenced is a non-const object and can be modified through some other access path.
[Note 4: Cv-qualifiers are supported by the type system so that they cannot be subverted without casting (7.6.1.11).
—end note]
4 Any attempt to modify (7.6.19, 7.6.1.6, 7.6.2.3) a const object (6.9.5) during its lifetime (6.8.4) results in
undefined behavior.
[Example 1:
const int ci = 3; // cv-qualified (initialized as required)
ci = 4; // error: attempt to modifyconst
int i = 2; // not cv-qualified
const int* cip; // pointer toconst int
cip = &i; // OK, cv-qualified access path to unqualified
*cip = 4; // error: attempt to modify through ptr toconst
int* ip;
ip = const_cast<int*>(cip); // cast needed to convertconst int* to int*
*ip = 4; // defined: *ip points toi, a non-const object
const int* ciq = new const int (3); // initialized as required
int* iq = const_cast<int*>(ciq); // cast required
*iq = 4; // undefined behavior: modifies a const object
For another example,
struct X {
mutable int i;
int j;
};
struct Y {
X x;
Y();
};
const Y y;
y.x.i++; // well-formed: mutable member can be modified
y.x.j++; // error: const-qualified member modified
Y* p = const_cast<Y*>(&y); // cast away const-ness ofy
p->x.i = 99; // well-formed: mutable member can be modified
p->x.j = 99; // undefined behavior: modifies a const subobject
§ 9.2.9.2 © ISO/IEC
211

===== PAGE 223 =====

Dxxxx
—end example]
5 The semantics of an access through a volatile glvalue are implementation-defined. If an attempt is made to
access an object defined with a volatile-qualified type through the use of a non-volatile glvalue, the behavior
is undefined.
6 [Note 5: volatile is a hint to the implementation to avoid aggressive optimization involving the object because it is
possible for the value of the object to change by means undetectable by an implementation. Furthermore, for some
implementations, volatile can indicate that special hardware instructions are needed to access the object. See 6.10.1
for detailed semantics. In general, the semantics ofvolatile are intended to be the same in C++ as they are in C.
—end note]
9.2.9.3 Simple type specifiers [dcl.type.simple]
1 The simple type specifiers are
simple-type-specifier:
nested-name-specifieropt type-name
nested-name-specifier template simple-template-id
computed-type-specifier
placeholder-type-specifier
nested-name-specifieropt template-name
char
char8_t
char16_t
char32_t
wchar_t
bool
short
int
long
signed
unsigned
float
double
void
type-name:
class-name
enum-name
typedef-name
computed-type-specifier:
decltype-specifier
pack-index-specifier
splice-type-specifier
2 The component names of asimple-type-specifier are those of itsnested-name-specifier, type-name, simple-
template-id, template-name, and/ortype-constraint (if it is aplaceholder-type-specifier). The component name
of atype-name is the first name in it.
3 A placeholder-type-specifier is a placeholder for a type to be deduced (9.2.9.7). Atype-specifier is a placeholder
for a deduced class type (9.2.9.8) if either
—(3.1) it is of the formtypenameopt nested-name-specifieropt template-name or
—(3.2) it is of the formtypenameopt splice-specifier and thesplice-specifier designates a class template or alias
template.
The nested-name-specifier or splice-specifier, if any, shall be non-dependent and thetemplate-name or splice-
specifier shall designate a deducible template. Adeducible templateis either a class template or is an alias
template whosedefining-type-id is of the form
typenameopt nested-name-specifieropt templateopt simple-template-id
where thenested-name-specifier (if any) is non-dependent and thetemplate-name of thesimple-template-id
names a deducible template.
[Note 1: An injected-class-name is never interpreted as atemplate-name in contexts where class template argument
deduction would be performed (13.8.2).—end note]
§ 9.2.9.3 © ISO/IEC
212

===== PAGE 224 =====

Dxxxx
The othersimple-type-specifiers specify either a previously-declared type, a type determined from an expression,
or one of the fundamental types (6.9.2). Table 17 summarizes the valid combinations ofsimple-type-specifiers
and the types they specify.
Table 17 —simple-type-specifiers and the types they specify [tab:dcl.type.simple]
Specifier(s) Type
type-name the type named
simple-template-id the type as defined in 13.3
decltype-specifier the type as defined in 9.2.9.6
pack-index-specifier the type as defined in 9.2.9.4
placeholder-type-specifier the type as defined in 9.2.9.7
template-name the type as defined in 9.2.9.8
splice-type-specifier the type as defined in 9.2.9.9
char “char”
unsigned char “unsigned char”
signed char “signed char”
char8_t “char8_t”
char16_t “char16_t”
char32_t “char32_t”
bool “bool”
unsigned “unsigned int”
unsigned int “unsigned int”
signed “int”
signed int “int”
int “int”
unsigned short int “unsigned short int”
unsigned short “unsigned short int”
unsigned long int “unsigned long int”
unsigned long “unsigned long int”
unsigned long long int “unsigned long long int”
unsigned long long “unsigned long long int”
signed long int “long int”
signed long “long int”
signed long long int “long long int”
signed long long “long long int”
long long int “long long int”
long long “long long int”
long int “long int”
long “long int”
signed short int “short int”
signed short “short int”
short int “short int”
short “short int”
wchar_t “wchar_t”
float “float”
double “double”
long double “long double”
void “void”
4 When multiplesimple-type-specifiers are allowed, they can be freely intermixed with otherdecl-specifiers in
any order.
[Note 2: It is implementation-defined whether objects ofchar type are represented as signed or unsigned quantities.
The signed specifier forceschar objects to be signed; it is redundant in other contexts.—end note]
9.2.9.4 Pack indexing specifier [dcl.type.pack.index]
pack-index-specifier:
typedef-name ... [ constant-expression ]
§ 9.2.9.4 © ISO/IEC
213

===== PAGE 225 =====

Dxxxx
1 The typedef-name P in apack-index-specifier shall denote a pack.
2 The constant-expression shall be a converted constant expression (7.7) of typestd::size_t whose valueV,
termed the index, is such that0 ≤V <sizeof...(P).
3 A pack-index-specifier is a pack expansion (13.7.4).
4 [Note 1: The pack-index-specifier denotes the type of theVth element of the pack.—end note]
9.2.9.5 Elaborated type specifiers [dcl.type.elab]
elaborated-type-specifier:
class-key attribute-specifier-seqopt nested-name-specifieropt identifier
class-key simple-template-id
class-key nested-name-specifiertemplateopt simple-template-id
enum nested-name-specifieropt identifier
1 The component names of anelaborated-type-specifier are itsidentifier (if any) and those of itsnested-name-
specifier and simple-template-id (if any).
2 If anelaborated-type-specifier is the sole constituent of a declaration, the declaration is ill-formed unless it is
an explicit specialization (13.9.4), a partial specialization (13.7.6), an explicit instantiation (13.9.3), or it has
one of the following forms:
class-key attribute-specifier-seqopt identifier ;
class-key attribute-specifier-seqopt simple-template-id ;
In the first case, theelaborated-type-specifier declares theidentifier as aclass-name. The second case shall
appear only in anexplicit-specialization (13.9.4) or in atemplate-declaration (where it declares a partial
specialization). The attribute-specifier-seq, if any, appertains to the class or template being declared.
3 Otherwise, anelaborated-type-specifier E shall not have anattribute-specifier-seq. If E contains anidentifier
but nonested-name-specifier and (unqualified) lookup for theidentifier finds nothing,E shall not be introduced
by theenum keyword and declares theidentifier as aclass-name. The target scope ofE is the nearest enclosing
namespace or block scope.
4 A friend-type-specifier that is anelaborated-type-specifier shall have one of the following forms:
class-key nested-name-specifieropt identifier
class-key simple-template-id
class-key nested-name-specifiertemplateopt simple-template-id
Any unqualified lookup for theidentifier (in the first case) does not consider scopes that contain the nearest
enclosing namespace or block scope; no name is bound.
[Note 1: A using-directive in the target scope is ignored if it refers to a namespace not contained by that scope.—end
note]
5 [Note 2: 6.5.6 describes how name lookup proceeds in anelaborated-type-specifier. An elaborated-type-specifier can
be used to refer to a previously declaredclass-name or enum-name even if the name has been hidden by a non-type
declaration. —end note]
6 If theidentifier or simple-template-id in anelaborated-type-specifier resolves to aclass-name or enum-name,
the elaborated-type-specifier introduces it into the declaration the same way asimple-type-specifier introduces
its type-name (9.2.9.3). If theidentifier or simple-template-id resolves to atypedef-name (9.2.4, 13.3), the
elaborated-type-specifier is ill-formed.
[Note 3: This implies that, within a class template with a templatetype-parameter T, the declaration
friend class T;
is ill-formed. However, the similar declarationfriend T; is well-formed (11.8.4). —end note]
7 The class-key or enum keyword present in anelaborated-type-specifier shall agree in kind with the declaration
to which the name in theelaborated-type-specifier refers. This rule also applies to the form ofelaborated-type-
specifier that declares aclass-name or friend class since it can be construed as referring to the definition of the
class. Thus, in anyelaborated-type-specifier, theenum keyword shall be used to refer to an enumeration (9.8.1),
the union class-key shall be used to refer to a union (11.5), and either theclass or struct class-key shall be
used to refer to a non-union class (11.1).
[Example 1:
enum class E { a, b };
enum E x = E::a; // OK
§ 9.2.9.5 © ISO/IEC
214

===== PAGE 226 =====

Dxxxx
struct S { } s;
class S* p = &s; // OK
—end example]
9.2.9.6 Decltype specifiers [dcl.type.decltype]
decltype-specifier:
decltype ( expression )
1 For an expressionE, the type denoted bydecltype(E) is defined as follows:
—(1.1) ifEisan unparenthesizedid-expressionnamingastructuredbinding (9.7), decltype(E)isthereferenced
type as given in the specification of the structured binding declaration;
—(1.2) otherwise, if E is an unparenthesized id-expression naming a constant template parameter (13.2),
decltype(E) is the type of the template parameter after performing any necessary type deduction
(9.2.9.7, 9.2.9.8);
—(1.3) otherwise, ifE is an unparenthesizedid-expression or an unparenthesized class member access (7.6.1.5),
decltype(E) is the type of the entity named byE. If there is no such entity, the program is ill-formed;
—(1.4) otherwise, ifE is an unparenthesizedsplice-expression, decltype(E) is the type of the entity, object,
or value designated by thesplice-specifier of E;
—(1.5) otherwise, ifE is an xvalue,decltype(E) is T&&, whereT is the type ofE;
—(1.6) otherwise, ifE is an lvalue,decltype(E) is T&, whereT is the type ofE;
—(1.7) otherwise, decltype(E) is the type ofE.
The operand of thedecltype specifier is an unevaluated operand (7.2.3).
[Example 1:
const int&& foo();
int i;
struct A { double x; };
const A* a = new A();
decltype(foo()) x1 = 17; // type isconst int&&
decltype(i) x2; // type isint
decltype(a->x) x3; // type isdouble
decltype((a->x)) x4 = x3; // type isconst double&
decltype([:^^x1:]) x5 = 18; // type isconst int&&
decltype(([:^^x1:])) x6 = 19; // type isconst int&
void f() {
[](auto ...pack) {
decltype(pack...[0]) x7; // type isint
decltype((pack...[0])) x8; // type isint&
}(0);
}
—end example]
[Note 1: The rules for determining types involvingdecltype(auto) are specified in 9.2.9.7.—end note]
2 If the operand of adecltype-specifier is a prvalue and is not a (possibly parenthesized) immediate invocation
(7.7), the temporary materialization conversion is not applied (7.3.5) and no result object is provided for the
prvalue. The type of the prvalue may be incomplete or an abstract class type.
[Note 2: As a result, storage is not allocated for the prvalue and it is not destroyed. Thus, a class type is not
instantiated as a result of being the type of a function call in this context. In this context, the common purpose
of writing the expression is merely to refer to its type. In that sense, adecltype-specifier is analogous to a use of a
typedef-name, so the usual reasons for requiring a complete type do not apply. In particular, it is not necessary to
allocate storage for a temporary object or to enforce the semantic constraints associated with invoking the type’s
destructor. —end note]
[Note 3: Unlike the preceding rule, parentheses have no special meaning in this context.—end note]
[Example 2:
template<class T> struct A { ~A() = delete; };
template<class T> auto h()
-> A<T>;
§ 9.2.9.6 © ISO/IEC
215

===== PAGE 227 =====

Dxxxx
template<class T> auto i(T) // identity
-> T;
template<class T> auto f(T) // #1
-> decltype(i(h<T>())); // forces completion ofA<T> and implicitly usesA<T>::~A()
// for the temporary introduced by the use ofh().
// (A temporary is not introduced as a result of the use ofi().)
template<class T> auto f(T) // #2
-> void;
auto g() -> void {
f(42); // OK, calls #2. (#1 is not a viable candidate: type deduction
// fails (13.10.3) becauseA<int>::~A() is implicitly used in its
// decltype-specifier)
}
template<class T> auto q(T)
-> decltype((h<T>())); // does not force completion ofA<T>; A<T>::~A() is not implicitly
// used within the context of thisdecltype-specifier
void r() {
q(42); // error: deduction againstq succeeds, so overload resolution selects
// the specialization “q(T) -> decltype((h<T>()))” with T=int;
// the return type isA<int>, so a temporary is introduced and its
// destructor is used, so the program is ill-formed
}
—end example]
9.2.9.7 Placeholder type specifiers [dcl.spec.auto]
9.2.9.7.1 General [dcl.spec.auto.general]
placeholder-type-specifier:
type-constraintopt auto
type-constraintopt decltype ( auto )
1 A placeholder-type-specifier designates a placeholder type that will be replaced later, typically by deduction
from an initializer.
2 The type of aparameter-declaration of a
—(2.1) function declaration (9.3.4.6),
—(2.2) lambda-expression (7.5.6), or
—(2.3) template-parameter (13.2)
can be declared using a placeholder-type-specifier of the form type-constraintopt auto. The placeholder
type shall appear as one of thedecl-specifiers in thedecl-specifier-seq or as one of thetype-specifiers in a
trailing-return-type that specifies the type that replaces such adecl-specifier (see below); the placeholder type
is ageneric parameter type placeholderof the function declaration,lambda-expression, ortemplate-parameter,
respectively.
[Note 1: Having a generic parameter type placeholder signifies that the function is an abbreviated function template
(9.3.4.6) or the lambda is a generic lambda (7.5.6).—end note]
3 A placeholder type can appear in thedecl-specifier-seq for a function declarator that includes atrailing-return-
type (9.3.4.6).
4 A placeholder type can appear in thedecl-specifier-seq or type-specifier-seq in the declared return type of a
function declarator that declares a function other than a conversion function (11.4.8.3); the return type of
the function is deduced from non-discardedreturn statements, if any, in the body of the function (8.5.2).
5 The type of a variable declared using a placeholder type is deduced from its initializer. This use is allowed in
an initializing declaration (9.5) of a variable. The placeholder type shall appear as one of thedecl-specifiers
in thedecl-specifier-seq or as one of thetype-specifiers in atrailing-return-type that specifies the type that
replaces such adecl-specifier; thedecl-specifier-seq shall be followed by one or moredeclarators, each of which
shall be followed by a non-emptyinitializer.
[Example 1:
auto x = 5; // OK,x has typeint
const auto *v = &x, u = 6; // OK,v has typeconst int*, u has typeconst int
static auto y = 0.0; // OK,y has typedouble
§ 9.2.9.7.1 © ISO/IEC
216

===== PAGE 228 =====

Dxxxx
auto int r; // error: auto is not astorage-class-specifier
auto f() -> int; // OK,f returns int
auto g() { return 0.0; } // OK,g returns double
auto (*fp)() -> auto = f; // OK
auto h(); // OK,h’s return type will be deduced when it is defined
—end example]
The auto type-specifier can also be used to introduce a structured binding declaration (9.7).
6 A placeholder type can also be used in thetype-specifier-seq of thenew-type-id or in thetype-id of anew-
expression (7.6.2.8). In such atype-id, the placeholder type shall appear as one of thetype-specifiers in the
type-specifier-seq or as one of thetype-specifiers in atrailing-return-type that specifies the type that replaces
such atype-specifier.
7 The auto type-specifier can also be used as thesimple-type-specifier in an explicit type conversion (functional
notation) (7.6.1.4).
8 A program that uses a placeholder type in a context not explicitly allowed in 9.2.9.7 is ill-formed.
9 If theinit-declarator-list contains more than oneinit-declarator, they shall all form declarations of variables.
The type of each declared variable is determined by placeholder type deduction (9.2.9.7.2), and if the type
that replaces the placeholder type is not the same in each deduction, the program is ill-formed.
[Example 2:
auto x = 5, *y = &x; // OK,auto is int
auto a = 5, b = { 1, 2 }; // error: different types forauto
—end example]
10 If a function with a declared return type that contains a placeholder type has multiple non-discardedreturn
statements, the return type is deduced for each suchreturn statement. If the type deduced is not the same
in each deduction, the program is ill-formed.
11 If a function with a declared return type that uses a placeholder type has no non-discardedreturn statements,
the return type is deduced as though from areturn statement with no operand at the closing brace of the
function body.
[Example 3:
auto f() { } // OK, return type isvoid
auto* g() { } // error: cannot deduceauto* from void()
—end example]
12 An exported function with a declared return type that uses a placeholder type shall be defined in the
translation unit containing its exported declaration, outside theprivate-module-fragment (if any).
[Note 2: The deduced return type cannot have a name with internal linkage (6.7).—end note]
13 If a variable or function with an undeduced placeholder type is named by an expression (6.3), the program is
ill-formed. Once a non-discardedreturn statement has been seen in a function, however, the return type
deduced from that statement can be used in the rest of the function, including in otherreturn statements.
[Example 4:
auto n = n; // error: n’s initializer refers ton
auto f();
void g() { &f; } // error: f’s return type is unknown
auto sum(int i) {
if (i == 1)
return i; // sum’s return type isint
else
return sum(i-1)+i; // OK,sum’s return type has been deduced
}
—end example]
14 A result binding never has an undeduced placeholder type (9.4.2).
[Example 5:
auto f()
post(r : r == 7) // OK
{
§ 9.2.9.7.1 © ISO/IEC
217

===== PAGE 229 =====

Dxxxx
return 7;
}
—end example]
15 Return type deduction for a templated function with a placeholder in its declared type occurs when the
definition is instantiated even if the function body contains areturn statement with a non-type-dependent
operand.
[Note 3: Therefore, any use of a specialization of the function template will cause an implicit instantiation. Any
errors that arise from this instantiation are not in the immediate context of the function type and can result in the
program being ill-formed (13.10.3).—end note]
[Example 6:
template <class T> auto f(T t) { return t; } // return type deduced at instantiation time
typedef decltype(f(1)) fint_t; // instantiatesf<int> to deduce return type
template<class T> auto f(T* t) { return *t; }
void g() { int (*p)(int*) = &f; } // instantiates bothfs to determine return types,
// chooses second
—end example]
16 If a function or function templateF has a declared return type that uses a placeholder type, redeclarations
or specializations ofF shall use that placeholder type, not a deduced type; otherwise, they shall not use a
placeholder type.
[Example 7:
auto f();
auto f() { return 42; } // return type isint
auto f(); // OK
int f(); // error: auto and int don’t match
decltype(auto) f(); // error: auto and decltype(auto) don’t match
template <typename T> auto g(T t) { return t; } // #1
template auto g(int); // OK, return type isint
template char g(char); // error: no matching template
template<> auto g(double); // OK, forward declaration with unknown return type
template <class T> T g(T t) { return t; } // OK, not functionally equivalent to #1
template char g(char); // OK, now there is a matching template
template auto g(float); // still matches #1
void h() { return g(42); } // error: ambiguous
template <typename T> struct A {
friend T frf(T);
};
auto frf(int i) { return i; } // not a friend ofA<int>
extern int v;
auto v = 17; // OK, redeclaresv
struct S {
static int i;
};
auto S::i = 23; // OK
—end example]
17 A function declared with a return type that uses a placeholder type shall not bevirtual (11.7.3).
18 A function declared with a return type that uses a placeholder type shall not be a coroutine (9.6.4).
19 An explicit instantiation declaration (13.9.3) does not cause the instantiation of an entity declared using a
placeholder type, but it also does not prevent that entity from being instantiated as needed to determine its
type.
[Example 8:
template <typename T> auto f(T t) { return t; }
extern template auto f(int); // does not instantiatef<int>
int (*p)(int) = f; // instantiatesf<int> to determine its return type, but an explicit
§ 9.2.9.7.1 © ISO/IEC
218

===== PAGE 230 =====

Dxxxx
// instantiation definition is still required somewhere in the program
—end example]
9.2.9.7.2 Placeholder type deduction [dcl.type.auto.deduct]
1 Placeholder type deductionis the process by which a type containing a placeholder type is replaced by a
deduced type.
2 A typeT containing a placeholder type, and a correspondinginitializer-clause E, are determined as follows:
—(2.1) For a non-discardedreturn statement that occurs in a function declared with a return type that
contains a placeholder type,T is the declared return type.
—(2.1.1) If thereturn statement has no operand, thenE is void().
—(2.1.2) If the operand is abraced-init-list (9.5.5), the program is ill-formed.
—(2.1.3) If the operand is anexpression X that is not anassignment-expression, E is (X).
[Note 1: A comma expression (7.6.20) is not anassignment-expression. —end note]
—(2.1.4) Otherwise, E is the operand of thereturn statement.
If E has typevoid, T shall be eithertype-constraintopt decltype(auto) or cv type-constraintopt auto.
—(2.2) For a variable declared with a type that contains a placeholder type,T is the declared type of the
variable.
—(2.2.1) If the initializer of the variable is abrace-or-equal-initializer of the form= initializer-clause, E is the
initializer-clause.
—(2.2.2) If the initializer is abraced-init-list, it shall consist of a single brace-enclosedassignment-expression
and E is theassignment-expression.
—(2.2.3) If the initializer is a parenthesizedexpression-list, theexpression-list shall be a singleassignment-
expression and E is theassignment-expression.
—(2.3) For an explicit type conversion (7.6.1.4),T is the specified type, which shall beauto.
—(2.3.1) If the initializer is abraced-init-list, it shall consist of a single brace-enclosedassignment-expression
and E is theassignment-expression.
—(2.3.2) If the initializer is a parenthesizedexpression-list, theexpression-list shall be a singleassignment-
expression and E is theassignment-expression.
—(2.4) For a constant template parameter declared with a type that contains a placeholder type,T is the
declared type of the constant template parameter andE is the corresponding template argument.
T shall not be an array type.
3 If the placeholder-type-specifier is of the formtype-constraintopt auto, the deduced typeT′ replacing T is
determined using the rules for template argument deduction. If the initialization is copy-list-initialization, a
declaration ofstd::initializer_list shall precede (6.5.1) theplaceholder-type-specifier. Obtain P from T
by replacing the occurrence oftype-constraintopt auto either with a new invented type template parameterU
or, if the initialization is copy-list-initialization, withstd::initializer_list<U>. IfE is a value synthesized
for a constant template parameter of typedecltype(auto) (13.7.7.3), the declaration is ill-formed. Otherwise,
deduce a value forU using the rules of template argument deduction from a function call (13.10.3.2), where
P is a function template parameter type and the corresponding argument isE. If the deduction fails, the
declaration is ill-formed. Otherwise,T′is obtained by substituting the deducedU into P.
[Example 1:
auto x1 = { 1, 2 }; // decltype(x1) is std::initializer_list<int>
auto x2 = { 1, 2.0 }; // error: cannot deduce element type
auto x3{ 1, 2 }; // error: not a single element
auto x4 = { 3 }; // decltype(x4) is std::initializer_list<int>
auto x5{ 3 }; // decltype(x5) is int
—end example]
[Example 2:
const auto &i = expr;
The type ofi is the deduced type of the parameteru in the callf(expr) of the following invented function template:
§ 9.2.9.7.2 © ISO/IEC
219

===== PAGE 231 =====

Dxxxx
template <class U> void f(const U& u);
—end example]
4 If theplaceholder-type-specifier is of the formtype-constraintopt decltype(auto), T shall be the placeholder
alone. The type deduced forT is determined as described in 9.2.9.6, as thoughE had been the operand of
the decltype.
[Example 3:
int i;
int&& f();
auto x2a(i); // decltype(x2a) is int
decltype(auto) x2d(i); // decltype(x2d) is int
auto x3a = i; // decltype(x3a) is int
decltype(auto) x3d = i; // decltype(x3d) is int
auto x4a = (i); // decltype(x4a) is int
decltype(auto) x4d = (i); // decltype(x4d) is int&
auto x5a = f(); // decltype(x5a) is int
decltype(auto) x5d = f(); // decltype(x5d) is int&&
auto x6a = { 1, 2 }; // decltype(x6a) is std::initializer_list<int>
decltype(auto) x6d = { 1, 2 }; // error: { 1, 2 } is not an expression
auto *x7a = &i; // decltype(x7a) is int*
decltype(auto)*x7d = &i; // error: declared type is not plaindecltype(auto)
auto f1(int x) -> decltype((x)) { return (x); } // return type isint&
auto f2(int x) -> decltype(auto) { return (x); } // return type isint&&
—end example]
5 For aplaceholder-type-specifier with a type-constraint, the immediately-declared constraint (13.2) of the
type-constraint for the type deduced for the placeholder shall be satisfied.
9.2.9.8 Deduced class template specialization types [dcl.type.class.deduct]
1 If a placeholder for a deduced class type appears as adecl-specifier in thedecl-specifier-seq of an initializing
declaration (9.5) of a variable, the declared type of the variable shall becv T, whereT is the placeholder.
[Example 1:
template <class ...T> struct A {
A(T...) {}
};
A x[29]{}; // error: no declarator operators allowed
const A& y{}; // error: no declarator operators allowed
—end example]
The placeholder is replaced by the return type of the function selected by overload resolution for class template
deduction (12.2.2.9). If thedecl-specifier-seq is followed by aninit-declarator-list or member-declarator-list
containing more than onedeclarator, the type that replaces the placeholder shall be the same in each
deduction.
2 A placeholder for a deduced class type can also be used in thetype-specifier-seq in the new-type-id or
type-id of anew-expression (7.6.2.8), as thesimple-type-specifier in an explicit type conversion (functional
notation) (7.6.1.4), or as thetype-specifier in theparameter-declaration of atemplate-parameter (13.2). A
placeholder for a deduced class type shall not appear in any other context.
3 [Example 2:
template<class T> struct container {
container(T t) {}
template<class Iter> container(Iter beg, Iter end);
};
template<class Iter>
container(Iter b, Iter e) -> container<typename std::iterator_traits<Iter>::value_type>;
std::vector<double> v = { /* ... */ };
container c(7); // OK, deducesint for T
auto d = container(v.begin(), v.end()); // OK, deducesdouble for T
container e{5, 6}; // error: int is not an iterator
—end example]
§ 9.2.9.8 © ISO/IEC
220

===== PAGE 232 =====

Dxxxx
9.2.9.9 Type splicing [dcl.type.splice]
splice-type-specifier:
typenameopt splice-specifier
typenameopt splice-specialization-specifier
1 A splice-specifier or splice-specialization-specifier immediately followed by:: is never interpreted as part of
a splice-type-specifier. A splice-specifier or splice-specialization-specifier not preceded bytypename is only
interpreted as asplice-type-specifier within a type-only context (13.8.1).
[Example 1:
template<std::meta::info R> void tfn() {
typename [:R:]::type m; // OK,typename applies to the qualified name
}
struct S { using type = int; };
void fn() {
[:^^S::type:] *var; // error: [:^^S::type:] is an expression
typename [:^^S::type:] *var; // OK, declares variable with typeint*
}
using alias = [:^^S::type:]; // OK, type-only context
—end example]
2 For asplice-type-specifier of the formtypenameopt splice-specifier, thesplice-specifier shall designate a type, a
class template, or an alias template. Thesplice-type-specifier designates the same entity as thesplice-specifier.
3 For asplice-type-specifier of the formtypenameopt splice-specialization-specifier, the splice-specifier of the
splice-specialization-specifier shall designate a templateT that is either a class template or an alias template.
The splice-type-specifier designates the specialization ofT corresponding to the template argument list of the
splice-specialization-specifier.
9.3 Declarators [dcl.decl]
9.3.1 General [dcl.decl.general]
1 A declarator declares a single variable, function, or type, within a declaration. Theinit-declarator-list appearing
in asimple-declaration is a comma-separated sequence of declarators, each of which can have an initializer.
init-declarator-list:
init-declarator
init-declarator-list , init-declarator
init-declarator:
declarator initializer
declarator requires-clauseopt function-contract-specifier-seqopt
2 In all contexts, adeclarator is interpreted as given below. Where anabstract-declarator can be used (or
omitted) in place of adeclarator (9.3.4.6, 14.1), it is as if a unique identifier were included in the appropriate
place (9.3.2). The preceding specifiers indicate the type, storage duration, linkage, or other properties of
the entity or entities being declared. Each declarator specifies one entity and (optionally) names it and/or
modifies the type of the specifiers with operators such as* (pointer to) and() (function returning).
[Note 1: An init-declarator can also specify an initializer (9.5).—end note]
3 Each init-declarator or member-declarator in a declaration is analyzed separately as if it were in a declaration
by itself.
[Note 2: A declaration with several declarators is usually equivalent to the corresponding sequence of declarations
each with a single declarator. That is,
T D1, D2, ... Dn;
is usually equivalent to
T D1; T D2; ... T Dn;
where T is adecl-specifier-seq and eachDi is aninit-declarator or member-declarator. One exception is when a name
introduced by one of thedeclarators hides a type name used by thedecl-specifiers, so that when the samedecl-specifiers
are used in a subsequent declaration, they do not have the same meaning, as in
struct S { /* ... */ };
§ 9.3.1 © ISO/IEC
221

===== PAGE 233 =====

Dxxxx
S S, T; // declare two instances ofstruct S
which is not equivalent to
struct S { /* ... */ };
S S;
S T; // error
Another exception is whenT is auto (9.2.9.7), for example:
auto i = 1, j = 2.0; // error: deduced types fori and j do not match
as opposed to
auto i = 1; // OK,i deduced to have typeint
auto j = 2.0; // OK,j deduced to have typedouble
—end note]
4 The optionalrequires-clause in aninit-declarator or member-declarator shall be present only if the declarator
declares a templated function (13.1). When present after a declarator, therequires-clause is called thetrailing
requires-clause. The trailingrequires-clause introduces theconstraint-expression that results from interpreting
its constraint-logical-or-expression as aconstraint-expression.
[Example 1:
void f1(int a) requires true; // error: non-templated function
template<typename T>
auto f2(T a) -> bool requires true; // OK
template<typename T>
auto f3(T a) requires true -> bool; // error: requires-clause precedestrailing-return-type
void (*pf)() requires true; // error: constraint on a variable
void g(int (*)() requires true); // error: constraint on aparameter-declaration
auto* p = new void(*)(char) requires true; // error: not a function declaration
—end example]
5 The optionalfunction-contract-specifier-seq (9.4.1) in aninit-declarator shall be present only if thedeclarator
declares a function.
6 Declarators have the syntax
declarator:
ptr-declarator
noptr-declarator parameters-and-qualifiers trailing-return-type
ptr-declarator:
noptr-declarator
ptr-operator ptr-declarator
noptr-declarator:
declarator-id attribute-specifier-seqopt
noptr-declarator parameters-and-qualifiers
noptr-declarator [ constant-expressionopt ] attribute-specifier-seqopt
( ptr-declarator )
parameters-and-qualifiers:
( parameter-declaration-clause ) cv-qualifier-seqopt
ref-qualifieropt noexcept-specifieropt attribute-specifier-seqopt
trailing-return-type:
-> type-id
ptr-operator:
* attribute-specifier-seqopt cv-qualifier-seqopt
& attribute-specifier-seqopt
&& attribute-specifier-seqopt
nested-name-specifier * attribute-specifier-seqopt cv-qualifier-seqopt
cv-qualifier-seq:
cv-qualifier cv-qualifier-seqopt
cv-qualifier:
const
volatile
§ 9.3.1 © ISO/IEC
222

===== PAGE 234 =====

Dxxxx
ref-qualifier:
&
&&
declarator-id:
...opt id-expression
9.3.2 Type names [dcl.name]
1 To specify type conversions explicitly, and as an argument ofsizeof, alignof, new, ortypeid, the name of
a type shall be specified. This can be done with atype-id or new-type-id (7.6.2.8), which is syntactically a
declaration for a variable or function of that type that omits the name of the entity.
type-id:
type-specifier-seq abstract-declaratoropt
defining-type-id:
defining-type-specifier-seq abstract-declaratoropt
abstract-declarator:
ptr-abstract-declarator
noptr-abstract-declaratoropt parameters-and-qualifiers trailing-return-type
abstract-pack-declarator
ptr-abstract-declarator:
noptr-abstract-declarator
ptr-operator ptr-abstract-declaratoropt
noptr-abstract-declarator:
noptr-abstract-declaratoropt parameters-and-qualifiers
noptr-abstract-declaratoropt [ constant-expressionopt ] attribute-specifier-seqopt
( ptr-abstract-declarator )
abstract-pack-declarator:
noptr-abstract-pack-declarator
ptr-operator abstract-pack-declarator
noptr-abstract-pack-declarator:
noptr-abstract-pack-declarator parameters-and-qualifiers
...
It is possible to identify uniquely the location in theabstract-declarator where the identifier would appear if
the construction were a declarator in a declaration. The named type is then the same as the type of the
hypothetical identifier.
[Example 1:
int // int i
int * // int *pi
int *[3] // int *p[3]
int (*)[3] // int (*p3i)[3]
int *() // int *f()
int (*)(double) // int (*pf)(double)
name respectively the types “int”, “pointer toint”, “array of 3 pointers toint”, “pointer to array of 3int”, “function
of (no parameters) returning pointer toint”, and “pointer to a function of (double) returningint”. —end example]
2 [Note 1: A type can also be named by a typedef-name, which is introduced by a typedef declaration oralias-
declaration (9.2.4). —end note]
9.3.3 Ambiguity resolution [dcl.ambig.res]
1 The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 8.11
can also occur in the context of a declaration. In that context, the choice is between an object declaration
with a function-style cast as the initializer and a declaration involving a function declarator with a redundant
set of parentheses around a parameter name. Just as for the ambiguities mentioned in 8.11, the resolution is
to consider any construct, such as the potential parameter declaration, that could possibly be a declaration
to be a declaration. However, a construct that can syntactically be adeclaration whose outermostdeclarator
would match the grammar of adeclarator with atrailing-return-type is a declaration only if it starts withauto.
[Note 1: A declaration can be explicitly disambiguated by adding parentheses around the argument. The ambiguity
can be avoided by use of copy-initialization or list-initialization syntax, or by use of a non-function-style cast.—end
note]
§ 9.3.3 © ISO/IEC
223

===== PAGE 235 =====

Dxxxx
[Example 1:
struct S {
S(int);
};
typedef struct BB { int C[2]; } *B, C;
void foo(double a) {
S v(int(a)); // function declaration
S w(int()); // function declaration
S x((int(a))); // object declaration
S y((int)a); // object declaration
S z = int(a); // object declaration
S a(B()->C); // object declaration
S b(auto()->C); // function declaration
}
—end example]
2 An ambiguity can arise from the similarity between a function-style cast and atype-id. The resolution is that
any construct that could possibly be atype-id in its syntactic context shall be considered atype-id. However,
a construct that can syntactically be atype-id whose outermostabstract-declarator would match the grammar
of anabstract-declarator with atrailing-return-type is considered atype-id only if it starts withauto.
[Example 2:
template <class T> struct X {};
template <int N> struct Y {};
X<int()> a; // type-id
X<int(1)> b; // expression (ill-formed)
Y<int()> c; // type-id (ill-formed)
Y<int(1)> d; // expression
void foo(signed char a) {
sizeof(int()); // type-id (ill-formed)
sizeof(int(a)); // expression
sizeof(int(unsigned(a))); // type-id (ill-formed)
(int())+1; // type-id (ill-formed)
(int(a))+1; // expression
(int(unsigned(a)))+1; // type-id (ill-formed)
}
typedef struct BB { int C[2]; } *B, C;
void g() {
sizeof(B()->C[1]); // OK,sizeof(expression)
sizeof(auto()->C[1]); // error: sizeof of a function returning an array
}
—end example]
3 Another ambiguity arises in aparameter-declaration-clause when atype-name is nested in parentheses. In this
case, the choice is between the declaration of a parameter of type pointer to function and the declaration of a
parameter with redundant parentheses around thedeclarator-id. The resolution is to consider thetype-name
as asimple-type-specifier rather than adeclarator-id.
[Example 3:
class C { };
void f(int(C)) { } // void f(int(*fp)(C c)) { }
// not: void f(int C) { }
int g(C);
void foo() {
f(1); // error: cannot convert1 to function pointer
f(g); // OK
}
§ 9.3.3 © ISO/IEC
224

===== PAGE 236 =====

Dxxxx
For another example,
class C { };
void h(int *(C[10])); // void h(int *(*_fp)(C _parm[10]));
// not: void h(int *C[10]);
—end example]
9.3.4 Meaning of declarators [dcl.meaning]
9.3.4.1 General [dcl.meaning.general]
1 A declarator contains exactly onedeclarator-id; it names the entity that is declared. If theunqualified-id
occurring in adeclarator-id is a template-id, the declarator shall appear in thedeclaration of a template-
declaration (13.7), explicit-specialization (13.9.4), orexplicit-instantiation (13.9.3).
[Note 1: An unqualified-id that is not anidentifier is used to declare certain functions (11.4.8.3, 11.4.7, 12.4, 12.6).
—end note]
The optionalattribute-specifier-seq following adeclarator-id appertains to the entity that is declared.
2 If the declaration is a friend declaration:
—(2.1) The declarator does not bind a name.
—(2.2) If theid-expression E in thedeclarator-id of thedeclarator is aqualified-id or atemplate-id:
—(2.2.1) If the friend declaration is not a template declaration, then in the lookup for the terminal name of
E:
—(2.2.1.1) if theunqualified-id in E is atemplate-id, all function declarations are discarded;
—(2.2.1.2) otherwise, if thedeclarator corresponds (6.4.1) to any declaration found of a non-template
function, all function template declarations are discarded;
—(2.2.1.3) each remaining function template is replaced with the specialization chosen by deduction from
the friend declaration (13.10.3.7) or discarded if deduction fails.
—(2.2.2) The declarator shall correspond to one or more declarations found by the lookup; they shall all
have the same target scope, and the target scope of thedeclarator is that scope.
—(2.3) Otherwise, the terminal name ofE is not looked up. The declaration’s target scope is the innermost
enclosing namespace scope; if the declaration is contained by a block scope, the declaration shall
correspond to a reachable (10.7) declaration that inhabits the innermost block scope.
3 Otherwise:
—(3.1) If theid-expression in thedeclarator-id of thedeclarator is aqualified-id Q, letS be its lookup context
(6.5.5); the declaration shall inhabit a namespace scope.
—(3.2) Otherwise, letS be the entity associated with the scope inhabited by thedeclarator.
—(3.3) If thedeclarator declares an explicit instantiation or a partial or explicit specialization, thedeclarator
does not bind a name. If it declares a class member, the terminal name of thedeclarator-id is not looked
up; otherwise, only those lookup results that are nominable inS are considered when identifying any
function template specialization being declared (13.10.3.7).
[Example 1:
namespace N {
inline namespace O {
template<class T> void f(T); // #1
template<class T> void g(T) {}
}
namespace P {
template<class T> void f(T*); // #2, more specialized than #1
template<class> int g;
}
using P::f,P::g;
}
template<> void N::f(int*) {} // OK, #2 is not nominable
template void N::g(int); // error: lookup is ambiguous
—end example]
§ 9.3.4.1 © ISO/IEC
225

===== PAGE 237 =====

Dxxxx
—(3.4) Otherwise, the terminal name of thedeclarator-id is not looked up. If it is a qualified name, the
declarator shall correspond to one or more declarations nominable inS; all the declarations shall have
the same target scope and the target scope of thedeclarator is that scope.
[Example 2:
namespace Q {
namespace V {
void f();
}
void V::f() { /* ... */ } // OK
void V::g() { /* ... */ } // error: g() is not yet a member ofV
namespace V {
void g();
}
}
namespace R {
void Q::V::g() { /* ... */ } // error: R doesn’t encloseQ
}
—end example]
—(3.5) If the declaration inhabits a block scopeS and declares a function (9.3.4.6) or uses theextern specifier,
the declaration shall not be attached to a named module (10.1); its target scope is the innermost
enclosing namespace scope, but the name is bound inS.
[Example 3:
namespace X {
void p() {
q(); // error: q not yet declared
extern void q(); // q is a member of namespaceX
extern void r(); // r is a member of namespaceX
}
void middle() {
q(); // error: q not found
}
void q() { /* ... */ } // definition ofX::q
}
void q() { /* ... */ } // some other, unrelatedq
void X::r() { /* ... */ } // error: r cannot be declared byqualified-id
—end example]
4 A static, thread_local, extern, mutable, friend, inline, virtual, constexpr, consteval, constinit,
or typedef specifier or anexplicit-specifier applies directly to eachdeclarator-id in a declaration; the type
specified for eachdeclarator-id depends on both thedecl-specifier-seq and itsdeclarator.
5 Thus, (for eachdeclarator) a declaration has the form
T D
where T is of the formattribute-specifier-seqopt decl-specifier-seq and D is a declarator. Following is a recursive
procedure for determining the type specified for the containeddeclarator-id by such a declaration.
6 First, thedecl-specifier-seq determines a type. In a declaration
T D
the decl-specifier-seq T determines the typeT.
[Example 4: In the declaration
int unsigned i;
the type specifiersint unsigned determine the type “unsigned int” (9.2.9.3). —end example]
7 In a declarationattribute-specifier-seqopt T Dwhere D is an unadorneddeclarator-id, the type of the declared
entity is “T”.
§ 9.3.4.1 © ISO/IEC
226

===== PAGE 238 =====

Dxxxx
8 In a declarationT Dwhere D has the form
( D1 )
the type of the containeddeclarator-id is the same as that of the containeddeclarator-id in the declaration
T D1
Parentheses do not alter the type of the embeddeddeclarator-id, but they can alter the binding of complex
declarators.
9.3.4.2 Pointers [dcl.ptr]
1 In a declarationT Dwhere D has the form
* attribute-specifier-seqopt cv-qualifier-seqopt D1
and the type of the containeddeclarator-id in the declarationT D1is “derived-declarator-type-listT”, the type
of thedeclarator-id in D is “derived-declarator-type-listcv-qualifier-seq pointer toT”. Thecv-qualifiers apply to
the pointer and not to the object pointed to. Similarly, the optionalattribute-specifier-seq (9.13.1) appertains
to the pointer and not to the object pointed to.
2 [Example 1: The declarations
const int ci = 10, *pc = &ci, *const cpc = pc, **ppc;
int i, *p, *const cp = &i;
declare ci, a constant integer;pc, a pointer to a constant integer;cpc, a constant pointer to a constant integer;ppc, a
pointer to a pointer to a constant integer;i, an integer;p, a pointer to integer; andcp, a constant pointer to integer.
The value ofci, cpc, andcp cannot be changed after initialization. The value ofpc can be changed, and so can the
object pointed to bycp. Examples of some correct operations are
i = ci;
*cp = ci;
pc++;
pc = cpc;
pc = p;
ppc = &pc;
Examples of ill-formed operations are
ci = 1; // error
ci++; // error
*pc = 2; // error
cp = &ci; // error
cpc++; // error
p = pc; // error
ppc = &p; // error
Each is unacceptable because it would either change the value of an object declaredconst or allow it to be changed
through a cv-unqualified pointer later, for example:
*ppc = &ci; // OK, but would makep point toci because of previous error
*p = 5; // clobberci
See also 7.6.19 and 9.5.—end example]
3 [Note 1: Forming a pointer to reference type is ill-formed; see 9.3.4.3. Forming a function pointer type is ill-formed if
the function type hascv-qualifiers or aref-qualifier; see 9.3.4.6. Since the address of a bit-field (11.4.10) cannot be
taken, a pointer can never point to a bit-field.—end note]
9.3.4.3 References [dcl.ref]
1 In a declarationT Dwhere D has either of the forms
& attribute-specifier-seqopt D1
&& attribute-specifier-seqopt D1
and the type of the containeddeclarator-id in the declarationT D1is “derived-declarator-type-listT”, the type
of thedeclarator-id in D is “derived-declarator-type-listreference toT”. The optionalattribute-specifier-seq
appertains to the reference type. Cv-qualified references are ill-formed except when the cv-qualifiers are
introduced through the use of atypedef-name (9.2.4, 13.2) ordecltype-specifier (9.2.9.6), in which case the
cv-qualifiers are ignored.
§ 9.3.4.3 © ISO/IEC
227

===== PAGE 239 =====

Dxxxx
[Example 1:
typedef int& A;
const A aref = 3; // error: lvalue reference to non-const initialized with rvalue
The type ofaref is “lvalue reference toint”, not “lvalue reference toconst int”. —end example]
[Note 1: A reference can be thought of as a name of an object.—end note]
Forming the type “reference tocv void” is ill-formed.
2 A reference type that is declared using& is called anlvalue reference, and a reference type that is declared
using && is called anrvalue reference. Lvalue references and rvalue references are distinct types. Except
where explicitly noted, they are semantically equivalent and commonly referred to as references.
3 [Example 2:
void f(double& a) { a += 3.14; }
// ...
double d = 0;
f(d);
declares a to be a reference parameter off so the callf(d) will add3.14 to d.
int v[20];
// ...
int& g(int i) { return v[i]; }
// ...
g(3) = 7;
declares the functiong() to return a reference to an integer sog(3)=7 will assign7 to the fourth element of the array
v. For another example,
struct link {
link* next;
};
link* first;
void h(link*& p) { // p is a reference to pointer
p->next = first;
first = p;
p = 0;
}
void k() {
link* q = new link;
h(q);
}
declares p to be a reference to a pointer tolink so h(q) will leaveq with the value zero. See also 9.5.4.—end
example]
4 It is unspecified whether or not a reference requires storage (6.8.6).
5 There shall be no references to references, no arrays of references, and no pointers to references. The
declaration of a reference shall contain aninitializer (9.5.4) except when the declaration contains an explicit
extern specifier (9.2.2), is a class member (11.4) declaration within a class definition, or is the declaration of
a parameter or a return type (9.3.4.6); see 6.2.
6 Attempting to bind a reference to a function where the converted initializer is a glvalue whose type is not
call-compatible (7.6.1.3) with the type of the function’s definition results in undefined behavior. Attempting
to bind a reference to an object where the converted initializer is a glvalue through which the object is not
type-accessible (7.2.1) results in undefined behavior.
[Note 2: The object designated by such a glvalue can be outside its lifetime (6.8.4). Because a null pointer value or a
pointer past the end of an object does not point to an object, a reference in a well-defined program cannot refer to
such things; see 7.6.2.2. As described in 11.4.10, a reference cannot be bound directly to a bit-field.—end note]
The behavior of an evaluation of a reference (7.5.5, 7.6.1.5) that does not happen after (6.10.2.2) the
initialization of the reference is undefined.
§ 9.3.4.3 © ISO/IEC
228

===== PAGE 240 =====

Dxxxx
[Example 3:
int &f(int&);
int &g();
extern int &ir3;
int *ip = 0;
int &ir1 = *ip; // undefined behavior: null pointer
int &ir2 = f(ir3); // undefined behavior:ir3 not yet initialized
int &ir3 = g();
int &ir4 = f(ir4); // undefined behavior:ir4 used in its own initializer
char x alignas(int);
int &ir5 = *reinterpret_cast<int *>(&x); // undefined behavior: initializer refers to char object
—end example]
7 If atypedef-name (9.2.4, 13.2) or adecltype-specifier (9.2.9.6) denotes a typeTR that is a reference to a type
T, an attempt to create the type “lvalue reference tocv TR” creates the type “lvalue reference toT”, while an
attempt to create the type “rvalue reference tocv TR” creates the typeTR.
[Note 3: This rule is known as reference collapsing.—end note]
[Example 4:
int i;
typedef int& LRI;
typedef int&& RRI;
LRI& r1 = i; // r1 has the typeint&
const LRI& r2 = i; // r2 has the typeint&
const LRI&& r3 = i; // r3 has the typeint&
RRI& r4 = i; // r4 has the typeint&
RRI&& r5 = 5; // r5 has the typeint&&
decltype(r2)& r6 = i; // r6 has the typeint&
decltype(r2)&& r7 = i; // r7 has the typeint&
—end example]
8 [Note 4: Forming a reference to function type is ill-formed if the function type hascv-qualifiers or aref-qualifier;
see 9.3.4.6. —end note]
9.3.4.4 Pointers to members [dcl.mptr]
1 The component names of aptr-operator are those of itsnested-name-specifier, if any.
2 In a declarationT Dwhere D has the form
nested-name-specifier * attribute-specifier-seqopt cv-qualifier-seqopt D1
and thenested-name-specifier designates a class, and the type of the containeddeclarator-id in the declaration
T D1 is “derived-declarator-type-list T”, the type of thedeclarator-id in D is “derived-declarator-type-list
cv-qualifier-seq pointer to member of classnested-name-specifier of typeT”. The optionalattribute-specifier-
seq (9.13.1) appertains to the pointer-to-member. Thenested-name-specifier shall not designate an anonymous
union.
3 [Example 1:
struct X {
void f(int);
int a;
};
struct Y;
int X::* pmi = &X::a;
void (X::* pmf)(int) = &X::f;
double X::* pmd;
char Y::* pmc;
declares pmi, pmf, pmd and pmc to be a pointer to a member ofX of typeint, a pointer to a member ofX of type
void(int), a pointer to a member ofX of typedouble and a pointer to a member ofY of typechar respectively. The
§ 9.3.4.4 © ISO/IEC
229

===== PAGE 241 =====

Dxxxx
declaration ofpmd is well-formed even thoughX has no members of typedouble. Similarly, the declaration ofpmc is
well-formed even thoughY is an incomplete type.pmi and pmf can be used like this:
X obj;
// ...
obj.*pmi = 7; // assign 7 to an integer member ofobj
(obj.*pmf)(7); // call a function member ofobj with the argument7
—end example]
4 A pointer to member shall not point to a static member of a class (11.4.9), a member with reference type, or
“cv void”.
5 [Note 1: See also 7.6.2 and 7.6.4. The type “pointer to member” is distinct from the type “pointer”, that is, a pointer
to member is declared only by the pointer-to-member declarator syntax, and never by the pointer declarator syntax.
There is no “reference-to-member” type in C++. —end note]
9.3.4.5 Arrays [dcl.array]
1 In a declarationT Dwhere D has the form
D1 [ constant-expressionopt ] attribute-specifier-seqopt
and the type of the containeddeclarator-id in the declarationT D1is “derived-declarator-type-listT”, the
type of thedeclarator-id in D is “derived-declarator-type-listarray ofN T”. Theconstant-expression shall be
a converted constant expression of typestd::size_t (7.7). Its valueN specifies thearray bound, i.e., the
number of elements in the array;N shall be greater than zero.
2 In a declarationT Dwhere D has the form
D1 [ ] attribute-specifier-seqopt
and the type of the containeddeclarator-id in the declarationT D1is “derived-declarator-type-listT”, the type
of thedeclarator-id in D is “derived-declarator-type-listarray of unknown bound ofT”, except as specified
below.
3 A type of the form “array ofN U” or “array of unknown bound ofU” is an array type. The optional
attribute-specifier-seq appertains to the array type.
4 U is called the arrayelement type; this type shall not be a reference type, a function type, an array of unknown
bound, orcv void.
[Note 1: An array can be constructed from one of the fundamental types (exceptvoid), from a pointer, from a pointer
to member, from a class, from an enumeration type, or from an array of known bound.—end note]
[Example 1:
float fa[17], *afp[17];
declares an array offloat numbers and an array of pointers tofloat numbers. —end example]
5 Any type of the form “cv-qualifier-seq array ofN U” is adjusted to “array ofN cv-qualifier-seq U”, and similarly
for “array of unknown bound ofU”.
[Example 2:
typedef int A[5], AA[2][3];
typedef const A CA; // type is “array of 5const int”
typedef const AA CAA; // type is “array of 2 array of 3const int”
—end example]
[Note 2: An “array ofN cv-qualifier-seq U” has cv-qualified type; see 6.9.5.—end note]
6 An object of type “array ofN U” consists of a contiguously allocated non-empty set ofN subobjects of typeU,
known as theelements of the array, and numbered0 to N-1. The element numbered0 is termed thefirst
element of the array.
7 In addition to declarations in which an incomplete object type is allowed, an array bound may be omitted in
some cases in the declaration of a function parameter (9.3.4.6). An array bound may also be omitted when
an object (but not a non-static data member) of array type is initialized and the declarator is followed by an
initializer (9.5, 11.4, 7.6.1.4, 7.6.2.8). In these cases, the array bound is calculated from the number of initial
elements (say,N) supplied (9.5.2), and the type of the array is “array ofN U”.
§ 9.3.4.5 © ISO/IEC
230

===== PAGE 242 =====

Dxxxx
8 Furthermore, if there is a reachable declaration of the entity that specifies a bound and has the same host
scope (6.4.1), an omitted array bound is taken to be the same as in that earlier declaration, and similarly for
the definition of a static data member of a class.
[Example 3:
extern int x[10];
struct S {
static int y[10];
};
int x[]; // OK, bound is 10
int S::y[]; // OK, bound is 10
void f() {
extern int x[];
int i = sizeof(x); // error: incomplete object type
}
namespace A { extern int z[3]; }
int A::z[] = {}; // OK, defines an array of 3 elements
—end example]
9 [Note 3: When several “array of” specifications are adjacent, a multidimensional array type is created; only the first
of the constant expressions that specify the bounds of the arrays can be omitted.
[Example 4:
int x3d[3][5][7];
declares an array of three elements, each of which is an array of five elements, each of which is an array of seven
integers. The overall array can be viewed as a three-dimensional array of integers, with rank3 ×5 ×7. Any of the
expressions x3d, x3d[i], x3d[i][j], x3d[i][j][k] can reasonably appear in an expression. The expressionx3d[i]
is equivalent to*(x3d + i); in that expression,x3d is subject to the array-to-pointer conversion (7.3.3) and is first
converted to a pointer to a 2-dimensional array with rank5 ×7 that points to the first element ofx3d. Then i is
added, which on typical implementations involves multiplyingi by the length of the object to which the pointer
points, which issizeof(int)×5 ×7. The result of the addition and indirection is an lvalue denoting theith array
element ofx3d (an array of five arrays of seven integers). If there is another subscript, the same argument applies
again, sox3d[i][j] is an lvalue denoting thejth array element of theith array element ofx3d (an array of seven
integers), andx3d[i][j][k] is an lvalue denoting thekth array element of thejth array element of theith array
element ofx3d (an integer). —end example]
The first subscript in the declaration helps determine the amount of storage consumed by an array but plays no other
part in subscript calculations.—end note]
10 [Note 4: Conversions affecting expressions of array type are described in 7.3.3.—end note]
11 [Note 5: The subscript operator can be overloaded for a class (12.4.5). For the operator’s built-in meaning, see 7.6.1.2.
—end note]
9.3.4.6 Functions [dcl.fct]
1 In a declarationT Dwhere T may be empty andD has the form
D1 ( parameter-declaration-clause ) cv-qualifier-seqopt
ref-qualifieropt noexcept-specifieropt attribute-specifier-seqopt trailing-return-typeopt
a derived-declarator-type-listis determined as follows:
—(1.1) If theunqualified-id of thedeclarator-id is aconversion-function-id, thederived-declarator-type-listis
empty.
—(1.2) Otherwise, thederived-declarator-type-listis as appears in the type “derived-declarator-type-listT” of
the containeddeclarator-id in the declarationT D1.
The declared return typeU of the function type is determined as follows:
—(1.3) If thetrailing-return-type is present,T shall be the singletype-specifier auto, andU is the type specified
by thetrailing-return-type.
—(1.4) Otherwise, if the declaration declares a conversion function, see 11.4.8.3.
—(1.5) Otherwise, U is T.
§ 9.3.4.6 © ISO/IEC
231

===== PAGE 243 =====

Dxxxx
The type of thedeclarator-id in D is “derived-declarator-type-listnoexceptopt function of parameter-type-list
cv-qualifier-seqopt ref-qualifieropt returning U”, where
—(1.6) the parameter-type-list is derived from theparameter-declaration-clause as described below and
—(1.7) the optionalnoexcept is present if and only if the exception specification (14.5) is non-throwing.
Such a type is afunction type.70 The optionalattribute-specifier-seq appertains to the function type.
parameter-declaration-clause:
...
parameter-declaration-listopt
parameter-declaration-list , ...
parameter-declaration-list ...
parameter-declaration-list:
parameter-declaration
parameter-declaration-list , parameter-declaration
parameter-declaration:
attribute-specifier-seqopt thisopt decl-specifier-seq declarator
attribute-specifier-seqopt decl-specifier-seq declarator= initializer-clause
attribute-specifier-seqopt thisopt decl-specifier-seq abstract-declaratoropt
attribute-specifier-seqopt decl-specifier-seq abstract-declaratoropt = initializer-clause
The optionalattribute-specifier-seq in aparameter-declaration appertains to the parameter.
2 The parameter-declaration-clause determines the arguments that can be specified, and their processing, when
the function is called.
[Note 1: The parameter-declaration-clause is used to convert the arguments specified on the function call; see 7.6.1.3.
—end note]
If theparameter-declaration-clause is empty, the function takes no arguments. A parameter list consisting of a
single unnamed non-object parameter of non-dependent typevoid is equivalent to an empty parameter list.
Except for this special case, a parameter shall not have typecv void. A parameter with volatile-qualified type
is deprecated; see D.4. If theparameter-declaration-clause terminates with an ellipsis or a function parameter
pack (13.7.4), the number of arguments shall be equal to or greater than the number of parameters that do
not have a default argument and are not function parameter packs. Where syntactically correct and where
“...” is not part of anabstract-declarator, “...” is synonymous with “, ...”. Aparameter-declaration-clause
of the formparameter-declaration-list ... is deprecated (D.5).
[Example 1: The declaration
int printf(const char*, ...);
declares a function that can be called with varying numbers and types of arguments.
printf("hello world");
printf("a=%d b=%d", a, b);
However, the first argument must be of a type that can be converted to aconst char*. —end example]
[Note 2: The standard header<cstdarg> (17.14.2) contains a mechanism for accessing arguments passed using the
ellipsis (see 7.6.1.3 and 17.14).—end note]
3 The type of a function is determined using the following rules. The type of each parameter (including function
parameter packs) is determined from its ownparameter-declaration (9.3). After determining the type of each
parameter, any parameter of type “array ofT” or of function typeT is adjusted to be “pointer toT”. After
producing the list of parameter types, any top-levelcv-qualifiers modifying a parameter type are deleted when
forming the function type. The resulting list of transformed parameter types and the presence or absence of
the ellipsis or a function parameter pack is the function’sparameter-type-list.
[Note 3: This transformation does not affect the types of the parameters. For example,int(*)(const int p,
decltype(p)*) and int(*)(int, const int*) are identical types. —end note]
[Example 2:
void f(char*); // #1
void f(char[]) {} // defines #1
void f(const char*) {} // OK, another overload
void f(char *const) {} // error: redefines #1
70) As indicated by syntax, cv-qualifiers are a significant component in function return types.
§ 9.3.4.6 © ISO/IEC
232

===== PAGE 244 =====

Dxxxx
void g(char(*)[2]); // #2
void g(char[3][2]) {} // defines #2
void g(char[3][3]) {} // OK, another overload
void h(int x(const int)); // #3
void h(int (*)(int)) {} // defines #3
—end example]
4 A function with a parameter-type-list that has an ellipsis is termed avararg function.
5 An explicit-object-parameter-declarationis aparameter-declaration with athis specifier. An explicit-object-
parameter-declaration shall appear only as the firstparameter-declaration of aparameter-declaration-list of one
of:
—(5.1) a declaration of a member function or member function template (11.4), or
—(5.2) an explicit instantiation (13.9.3) or explicit specialization (13.9.4) of a templated member function, or
—(5.3) a lambda-declarator (7.5.6).
A member-declarator with an explicit-object-parameter-declaration shall not include aref-qualifier or a
cv-qualifier-seq and shall not be declaredstatic or virtual.
[Example 3:
struct C {
void f(this C& self);
template <typename Self> void g(this Self&& self, int);
void h(this C) const; // error: const not allowed here
};
void test(C c) {
c.f(); // OK, callsC::f
c.g(42); // OK, callsC::g<C&>
std::move(c).g(42); // OK, callsC::g<C>
}
—end example]
6 A function parameter declared with an explicit-object-parameter-declaration is anexplicit object parameter.
An explicit object parameter shall not be a function parameter pack (13.7.4). Anexplicit object member
function is a non-static member function with an explicit object parameter. Animplicit object member
function is a non-static member function without an explicit object parameter.
7 The object parameterof a non-static member function is either the explicit object parameter or the implicit
object parameter (12.2.2).
8 A non-object parameteris a function parameter that is not the explicit object parameter. Thenon-object-
parameter-type-listof a member function is the parameter-type-list of that function with the explicit object
parameter, if any, omitted.
[Note 4: The non-object-parameter-type-list consists of the adjusted types of all the non-object parameters.—end
note]
9 A function type with acv-qualifier-seq or aref-qualifier (including a type denoted bytypedef-name (9.2.4,
13.2)) shall appear only as:
—(9.1) the function type for a non-static member function,
—(9.2) the function type to which a pointer to member refers,
—(9.3) the top-level function type of a function typedef declaration oralias-declaration,
—(9.4) the type-id in the default argument of atype-parameter (13.2),
—(9.5) the type-id of atemplate-argument for atype-parameter (13.4.2), or
—(9.6) the operand of areflect-expression (7.6.2.10).
[Example 4:
typedef int FIC(int) const;
FIC f; // error: does not declare a member function
§ 9.3.4.6 © ISO/IEC
233

===== PAGE 245 =====

Dxxxx
struct S {
FIC f; // OK
};
FIC S::*pm = &S::f; // OK
constexpr std::meta::info yeti = ^^void(int) const &; // OK
—end example]
10 The effect of acv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top of
the function type. In the latter case, the cv-qualifiers are ignored.
[Note 5: A function type that has acv-qualifier-seq is not a cv-qualified type; there are no cv-qualified function types.
—end note]
[Example 5:
typedef void F();
struct S {
const F f; // OK, equivalent to:void f();
};
—end example]
11 The return type, the parameter-type-list, theref-qualifier, thecv-qualifier-seq, and the exception specification,
but not the default arguments (9.3.4.7) or the trailingrequires-clause (9.3), are part of the function type.
[Note 6: Function types are checked during the assignments and initializations of pointers to functions, references to
functions, and pointers to member functions.—end note]
12 [Example 6: The declaration
int fseek(FILE*, long, int);
declares a function taking three arguments of the specified types, and returningint (9.2.9). —end example]
13 [Note 7: A single name can be used for several different functions in a single scope; this is function overloading (Clause
12). —end note]
14 The return type shall be a non-array object type, a reference type, orcv void.
[Note 8: An array of placeholder type is considered an array type.—end note]
15 A volatile-qualified return type is deprecated; see D.4.
16 Types shall not be defined in return or parameter types.
17 A typedef of function type may be used to declare a function but shall not be used to define a function (9.6).
[Example 7:
typedef void F();
F fv; // OK, equivalent tovoid fv();
F fv { } // error
void fv() { } // OK, definition offv
—end example]
18 An identifier can optionally be provided as a parameter name; if present in a function definition (9.6), it
names a parameter.
[Note 9: In particular, parameter names are also optional in function definitions and names used for a parameter in
different declarations and the definition of a function need not be the same.—end note]
19 [Example 8: The declaration
int i,
*pi,
f(),
*fpi(int),
(*pif)(const char*, const char*),
(*fpif(int))(int);
declares an integeri, a pointerpi to an integer, a functionf taking no arguments and returning an integer, a function
fpi taking an integer argument and returning a pointer to an integer, a pointerpif to a function which takes two
pointers to constant characters and returns an integer, a functionfpif taking an integer argument and returning a
pointer to a function that takes an integer argument and returns an integer. It is especially useful to comparefpi
and pif. The binding of*fpi(int) is *(fpi(int)), so the declaration suggests, and the same construction in an
expression requires, the calling of a functionfpi, and then using indirection through the (pointer) result to yield an
§ 9.3.4.6 © ISO/IEC
234

===== PAGE 246 =====

Dxxxx
integer. In the declarator(*pif)(const char*, const char*), the extra parentheses are necessary to indicate that
indirection through a pointer to a function yields a function, which is then called.—end example]
[Note 10: Typedefs andtrailing-return-types are sometimes convenient when the return type of a function is complex.
For example, the functionfpif above can be declared
typedef int IFUNC(int);
IFUNC* fpif(int);
or
auto fpif(int)->int(*)(int);
A trailing-return-type is most useful for a type that would be more complicated to specify before thedeclarator-id:
template <class T, class U> auto add(T t, U u) -> decltype(t + u);
rather than
template <class T, class U> decltype((*(T*)0) + (*(U*)0)) add(T t, U u);
—end note]
20 A non-template functionis a function that is not a function template specialization.
[Note 11: A function template is not a function.—end note]
21 An abbreviated function templateis a function declaration that has one or more generic parameter type
placeholders (9.2.9.7). An abbreviated function template is equivalent to a function template (13.7.7) whose
template-parameter-list includes one inventedtype-parameter for each generic parameter type placeholder of
the function declaration, in order of appearance. For aplaceholder-type-specifier of the formauto, the invented
parameter is an unconstrainedtype-parameter. For aplaceholder-type-specifier of the formtype-constraint auto,
the invented parameter is atype-parameter with thattype-constraint. The inventedtype-parameter declares a
template parameter pack if the correspondingparameter-declaration declares a function parameter pack. If
the placeholder containsdecltype(auto), the program is ill-formed. The adjusted function parameters of an
abbreviated function template are derived from theparameter-declaration-clause by replacing each occurrence
of a placeholder with the name of the corresponding inventedtype-parameter.
[Example 9:
template<typename T> concept C1 = /∗ ... ∗/;
template<typename T> concept C2 = /∗ ... ∗/;
template<typename... Ts> concept C3 = /∗ ... ∗/;
void g1(const C1 auto*, C2 auto&);
void g2(C1 auto&...);
void g3(C3 auto...);
void g4(C3 auto);
The declarations above are functionally equivalent (but not equivalent) to their respective declarations below:
template<C1 T, C2 U> void g1(const T*, U&);
template<C1... Ts> void g2(Ts&...);
template<C3... Ts> void g3(Ts...);
template<C3 T> void g4(T);
Abbreviated function templates can be specialized like all function templates.
template<> void g1<int>(const int*, const double&); // OK, specialization ofg1<int, const double>
—end example]
22 An abbreviated function template can have atemplate-head. The inventedtype-parameters are appended to
the template-parameter-list after the explicitly declaredtemplate-parameters.
[Example 10:
template<typename> concept C = /∗ ... ∗/;
template <typename T, C U>
void g(T x, U y, C auto z);
This is functionally equivalent to each of the following two declarations.
template<typename T, C U, C W>
void g(T x, U y, W z);
§ 9.3.4.6 © ISO/IEC
235

===== PAGE 247 =====

Dxxxx
template<typename T, typename U, typename W>
requires C<U> && C<W>
void g(T x, U y, W z);
—end example]
23 A function declaration at block scope shall not declare an abbreviated function template.
24 A declarator-id or abstract-declarator containing an ellipsis shall only be used in aparameter-declaration.
When it is part of aparameter-declaration-clause, theparameter-declaration declares a function parameter
pack (13.7.4). Otherwise, theparameter-declaration is part of atemplate-parameter-list and declares a template
parameter pack; see 13.2. A function parameter pack is a pack expansion (13.7.4).
[Example 11:
template<typename... T> void f(T (* ...t)(int, int));
int add(int, int);
float subtract(int, int);
void g() {
f(add, subtract);
}
—end example]
25 There is a syntactic ambiguity when an ellipsis occurs at the end of aparameter-declaration-clause without
a preceding comma. In this case, the ellipsis is parsed as part of theabstract-declarator if the type of the
parameter either names a template parameter pack that has not been expanded or containsauto; otherwise,
it is parsed as part of theparameter-declaration-clause.71
9.3.4.7 Default arguments [dcl.fct.default]
1 If an initializer-clause is specified in aparameter-declaration that is not atemplate-parameter (13.2), this
initializer-clause is used as a default argument.
[Note 1: Default arguments will be used in calls where trailing arguments are missing (7.6.1.3).—end note]
2 [Example 1: The declaration
void point(int = 3, int = 4);
declares a function that can be called with zero, one, or two arguments of typeint. It can be called in any of these
ways:
point(1,2); point(1); point();
The last two calls are equivalent topoint(1,4) and point(3,4), respectively. —end example]
3 A default argument shall be specified only in theparameter-declaration-clause of a function declaration or
lambda-declarator. A default argument shall not be specified for a function parameter pack. A default
argument shall not occur within adeclarator or abstract-declarator of aparameter-declaration.72
4 For non-template functions, default arguments can be added in later declarations of a function that have
the same host scope. Declarations that have different host scopes have completely distinct sets of default
arguments. That is, declarations in inner scopes do not acquire default arguments from declarations in
outer scopes, and vice versa. In a given function declaration, each parameter subsequent to a parameter
with a default argument shall have a default argument supplied in this or a previous declaration, unless the
parameter was expanded from a parameter pack, or shall be a function parameter pack.
[Note 2: A default argument cannot be redefined by a later declaration (not even to the same value) (6.3).—end
note]
[Example 2:
void g(int = 0, ...); // OK, ellipsis is not a parameter so it can follow
// a parameter with a default argument
void f(int, int);
void f(int, int = 7);
71) One can explicitly disambiguate the parse either by introducing a comma (so the ellipsis will be parsed as part of the
parameter-declaration-clause) or by introducing a name for the parameter (so the ellipsis will be parsed as part of thedeclarator-id).
72) This means that default arguments cannot appear, for example, in declarations of pointers to functions, references to
functions, ortypedef declarations.
§ 9.3.4.7 © ISO/IEC
236

===== PAGE 248 =====

Dxxxx
void h() {
f(3); // OK, callsf(3, 7)
void f(int = 1, int); // error: does not use default from surrounding scope
}
void m() {
void f(int, int); // has no defaults
f(4); // error: wrong number of arguments
void f(int, int = 5); // OK
f(4); // OK, callsf(4, 5);
void f(int, int = 5); // error: cannot redefine, even to same value
}
void n() {
f(6); // OK, callsf(6, 7)
}
template<class ... T> struct C {
void f(int n = 0, T...);
};
C<int> c; // OK, instantiates declarationvoid C::f(int n = 0, int)
—end example]
For a given inline function defined in different translation units, the accumulated sets of default arguments
at the end of the translation units shall be the same; no diagnostic is required. If a friend declarationD
specifies a default argument expression, that declaration shall be a definition and there shall be no other
declaration of the function or function template which is reachable fromD or from whichD is reachable.
5 The default argument has the same semantic constraints as the initializer in a declaration of a variable of the
parameter type, using the copy-initialization semantics (9.5). The names in the default argument are looked
up, and the semantic constraints are checked, at the point where the default argument appears, except that
an immediate invocation (7.7) that is a potentially-evaluated subexpression (6.10.1) of theinitializer-clause
in aparameter-declaration is neither evaluated nor checked for whether it is a constant expression at that
point. Name lookup and checking of semantic constraints for default arguments of templated functions are
performed as described in 13.9.2.
[Example 3: In the following code,g will be called with the valuef(2):
int a = 1;
int f(int);
int g(int x = f(a)); // default argument:f(::a)
void h() {
a = 2;
{
int a = 3;
g(); // g(f(::a))
}
}
—end example]
[Note 3: A default argument is a complete-class context (11.4). Access checking applies to names in default arguments
as described in 11.8.—end note]
6 Except for member functions of templated classes, the default arguments in a member function definition
that appears outside of the class definition are added to the set of default arguments provided by the member
function declaration in the class definition; the program is ill-formed if a default constructor (11.4.5.2),
copy or move constructor (11.4.5.3), or copy or move assignment operator (11.4.6) is so declared. Default
arguments for a member function of a templated class shall be specified on the initial declaration of the
member function within the templated class.
[Example 4:
class C {
void f(int i = 3);
void g(int i, int j = 99);
};
void C::f(int i = 3) {} // error: default argument already specified in class scope
§ 9.3.4.7 © ISO/IEC
237

===== PAGE 249 =====

Dxxxx
void C::g(int i = 88, int j) {} // in this translation unit,C::g can be called with no arguments
—end example]
7 [Note 4: A local variable cannot be odr-used (6.3) in a default argument.—end note]
[Example 5:
void f() {
int i;
extern void g(int x = i); // error
extern void h(int x = sizeof(i)); // OK
// ...
}
—end example]
8 [Note 5: The keywordthis cannot appear in a default argument of a member function; see 7.5.3.
[Example 6:
class A {
void f(A* p = this) { } // error
};
—end example]
—end note]
9 A default argument is evaluated each time the function is called with no argument for the corresponding
parameter. A parameter shall not appear as a potentially-evaluated expression in a default argument.
[Note 6: Parameters of a function declared before a default argument are in scope and can hide namespace and class
member names. —end note]
[Example 7:
int a;
int f(int a, int b = a); // error: parametera used as default argument
typedef int I;
int g(float I, int b = I(2)); // error: parameterI found
int h(int a, int b = sizeof(a)); // OK, unevaluated operand (7.2.3)
—end example]
A non-static member shall not be designated in a default argument unless
—(9.1) it is designated by theid-expression or splice-expression of a class member access expression (7.6.1.5),
—(9.2) it is designated by an expression used to form a pointer to member (7.6.2.2), or
—(9.3) it appears as the operand of areflect-expression (7.6.2.10).
[Example 8: The declaration ofX::mem1() in the following example is ill-formed because no object is supplied for the
non-static memberX::a used as an initializer.
int b;
class X {
int a;
int mem1(int i = a); // error: non-static membera used as default argument
int mem2(int i = b); // OK, useX::b
consteval void mem3(std::meta::info r = ^^a) {} // OK
int mem4(int i = [:^^a:]); // error: non-static membera designated in default argument
static int b;
};
The declaration ofX::mem2() is meaningful, however, since no object is needed to access the static memberX::b.
Classes, objects, and members are described in Clause 11.—end example]
A default argument is not part of the type of a function.
[Example 9:
int f(int = 0);
void h() {
int j = f(1);
§ 9.3.4.7 © ISO/IEC
238

===== PAGE 250 =====

Dxxxx
int k = f(); // OK, meansf(0)
}
int (*p1)(int) = &f;
int (*p2)() = &f; // error: type mismatch
—end example]
[Note 7: When an overload set contains a declaration of a function whose host scope isS, any default argument
associated with any reachable declaration whose host scope isS is available to the call (12.2.3).—end note]
[Note 8: The candidate might have been found through ausing-declarator from which the declaration that provides
the default argument is not reachable.—end note]
10 A virtual function call (11.7.3) uses the default arguments in the declaration of the virtual function determined
by the static type of the pointer or reference denoting the object. An overriding function in a derived class
does not acquire default arguments from the function it overrides.
[Example 10:
struct A {
virtual void f(int a = 7);
};
struct B : public A {
void f(int a);
};
void m() {
B* pb = new B;
A* pa = pb;
pa->f(); // OK, callspa->B::f(7)
pb->f(); // error: wrong number of arguments forB::f()
}
—end example]
9.4 Function contract specifiers [dcl.contract]
9.4.1 General [dcl.contract.func]
function-contract-specifier-seq:
function-contract-specifier function-contract-specifier-seqopt
function-contract-specifier:
precondition-specifier
postcondition-specifier
precondition-specifier:
pre attribute-specifier-seqopt ( conditional-expression )
postcondition-specifier:
post attribute-specifier-seqopt ( result-name-introduceropt conditional-expression )
1 A function contract assertionis a contract assertion (6.11.1) associated with a function. Aprecondition-
specifier introduces aprecondition assertion, which is a function contract assertion associated with entering a
function. A postcondition-specifier introduces apostcondition assertion, which is a function contract assertion
associated with exiting a function normally.
[Note 1: A postcondition assertion is not associated with exiting a function in any other fashion, such as via an
exception (7.6.18) or via a call tolongjmp (17.14.3). —end note]
2 The predicate (6.11.1) of a function contract assertion is itsconditional-expression contextually converted to
bool.
3 Each function-contract-specifier of afunction-contract-specifier-seq (if any) of an unspecified first declaration
(6.2) of a function introduces a corresponding function contract assertion for that function. The optional
attribute-specifier-seq following pre or post appertains to the introduced contract assertion.
[Note 2: The function-contract-specifier-seq of alambda-declarator applies to the function call operator or operator
template of the corresponding closure type (7.5.6.2).—end note]
4 A declaration D of a function or function templatef that is not a first declaration shall have either no
function-contract-specifier-seq or the samefunction-contract-specifier-seq (see below) as any first declaration
F reachable fromD. If D and F are in different translation units, a diagnostic is required only ifD is
§ 9.4.1 © ISO/IEC
239

===== PAGE 251 =====

Dxxxx
attached to a named module. If a declarationF1 is a first declaration off in one translation unit and
a declaration F2 is a first declaration off in another translation unit,F1 and F2 shall specify the same
function-contract-specifier-seq, no diagnostic required.
5 A function-contract-specifier-seq S1 is the same as afunction-contract-specifier-seq S2 if S1 and S2 consist
of the samefunction-contract-specifiers in the same order. Afunction-contract-specifier C1 on a function
declaration D1 is the same as afunction-contract-specifier C2 on a function declarationD2 if
—(5.1) their predicatesP1 and P2 would satisfy the one-definition rule (6.3) if placed in function definitions on
the declarationsD1 and D2, respectively, except for
—(5.1.1) renaming of the parameters off,
—(5.1.2) renaming of template parameters of a template enclosing , and
—(5.1.3) renaming of the result binding (9.4.2), if any,
and, ifD1 and D2 are in different translation units, corresponding entities defined within each predicate
behave as if there is a single entity with a single definition, and
—(5.2) both C1 and C2 specify aresult-name-introducer or neither do.
If this condition is not met solely due to the comparison of twolambda-expressions that are contained within
P1 and P2, no diagnostic is required.
[Note 3: Equivalentfunction-contract-specifier-seqs apply to all uses and definitions of a function across all translation
units. —end note]
[Example 1:
bool b1, b2;
void f() pre (b1) pre ([]{ return b2; }());
void f(); // OK,function-contract-specifiers omitted
void f() pre (b1) pre ([]{ return b2; }()); // error: closures have different types.
void f() pre (b1); // error: function-contract-specifiers only partially repeated
int g() post(r : b1);
int g() post(b1); // error: mismatchedresult-name-introducer presence
namespace N {
void h() pre (b1);
bool b1;
void h() pre (b1); // error:function-contract-specifiers differ according to
// the one-definition rule (6.3).
}
—end example]
6 A virtual function (11.7.3), a deleted function (9.6.3), or a function defaulted on its first declaration (9.6.2)
shall not have afunction-contract-specifier-seq.
7 If the predicate of a postcondition assertion of a functionf odr-uses (6.3) a non-reference parameter off,
that parameter and the corresponding parameter on all declarations off shall haveconst type.
[Note 4: This requirement applies even to declarations that do not specify thepostcondition-specifier. Parameters
with array or function type will decay to non-const types even if aconst qualifier is present.
[Example 2:
int f(const int i[10])
post(r : r == i[0]); // error: i has typeconst int * (not int* const).
—end example]
—end note]
8 [Note 5: The function contract assertions of a function are evaluated even when invoked indirectly, such as through a
pointer to function or a pointer to member function. A pointer to function, pointer to member function, or function
type alias cannot have afunction-contract-specifier-seq associated directly with it.—end note]
9 The function contract assertions of a function are considered to beneeded (13.9.2) when
—(9.1) the function is odr-used (6.3) or
§ 9.4.1 © ISO/IEC
240

===== PAGE 252 =====

Dxxxx
—(9.2) the function is defined.
[Note 6: Overload resolution does not considerfunction-contract-specifiers (13.10.3, 13.9.2).
[Example 3:
template <typename T> void f(T t) pre( t == "" );
template <typename T> void f(T&& t);
void g()
{
f(5); // error: ambiguous
}
—end example]
—end note]
9.4.2 Referring to the result object [dcl.contract.res]
attributed-identifier:
identifier attribute-specifier-seqopt
result-name-introducer:
attributed-identifier :
1 The result-name-introducer of apostcondition-specifier is a declaration. Theresult-name-introducer introduces
the identifier as the name of aresult bindingof the associated function. If a postcondition assertion has a
result-name-introducer and the return type of the function iscv void, the program is ill-formed. A result
binding denotes the object or reference returned by invocation of that function. The type of a result binding
is the return type of its associated function. The optionalattribute-specifier-seq of theattributed-identifier in
the result-name-introducer appertains to the result binding so introduced.
[Note 1: An id-expression that names a result binding is aconst lvalue (7.5.5.2). —end note]
[Example 1:
int f()
post(r : r == 1)
{
return 1;
}
int i = f(); // Postcondition check succeeds.
—end example]
[Example 2:
struct A {};
struct B {
B() {}
B(const B&) {}
};
template <typename T>
T f(T* const ptr)
post(r: &r == ptr)
{
return {};
}
int main() {
A a = f(&a); // The postcondition check can fail if the implementation introduces
// a temporary for the return value (6.8.7).
B b = f(&b); // The postcondition check succeeds, no temporary is introduced.
}
—end example]
2 When the declared return type of a non-templated function contains a placeholder type, apostcondition-
specifier with aresult-name-introducer shall be present only on a definition.
[Example 3:
§ 9.4.2 © ISO/IEC
241

===== PAGE 253 =====

Dxxxx
auto g(auto&)
post (r: r >= 0); // OK,g is a template.
auto h()
post (r: r >= 0); // error: cannot name the return value
auto k()
post (r: r >= 0) // OK
{
return 0;
}
—end example]
9.5 Initializers [dcl.init]
9.5.1 General [dcl.init.general]
1 The process of initialization described in 9.5 applies to all initializations regardless of syntactic context,
including the initialization of a function parameter (7.6.1.3), the initialization of a return value (8.8.4), or
when an initializer follows a declarator.
initializer:
brace-or-equal-initializer
( expression-list )
brace-or-equal-initializer:
= initializer-clause
braced-init-list
initializer-clause:
assignment-expression
braced-init-list
braced-init-list:
{ initializer-list ,opt }
{ designated-initializer-list ,opt }
{ }
initializer-list:
initializer-clause ...opt
initializer-list , initializer-clause ...opt
designated-initializer-list:
designated-initializer-clause
designated-initializer-list , designated-initializer-clause
designated-initializer-clause:
designator brace-or-equal-initializer
designator:
. identifier
expr-or-braced-init-list:
expression
braced-init-list
[Note 1: The rules in 9.5 apply even if the grammar permits only thebrace-or-equal-initializer form ofinitializer in a
given context. —end note]
2 Except for objects declared with theconstexpr specifier, for which see 9.2.6, aninitializer in the definition
of a variable can consist of arbitrary expressions involving literals and previously declared variables and
functions, regardless of the variable’s storage duration.
[Example 1:
int f(int);
int a = 2;
int b = f(a);
int c(b);
—end example]
3 [Note 2: Default arguments are more restricted; see 9.3.4.7.—end note]
§ 9.5.1 © ISO/IEC
242

===== PAGE 254 =====

Dxxxx
4 [Note 3: The order of initialization of variables with static storage duration is described in 6.10.3 and 8.10.—end
note]
5 A declarationD of a variable with linkage shall not have aninitializer if D inhabits a block scope.
6 To zero-initialize an object or reference of typeT means:
—(6.1) if T is std::meta::info, the object is initialized to a null reflection value;
—(6.2) if T is any other scalar type (6.9.1), the object is initialized to the value obtained by converting the
integer literal0 (zero) toT;73
—(6.3) if T is a (possibly cv-qualified) non-union class type, its padding bits (6.9.1) are initialized to zero bits
and each non-static data member, each non-virtual base class subobject, and, if the object is not a base
class subobject, each virtual base class subobject is zero-initialized;
—(6.4) if T is a (possibly cv-qualified) union type, its padding bits (6.9.1) are initialized to zero bits and the
object’s first non-static named data member is zero-initialized;
—(6.5) if T is an array type, each element is zero-initialized;
—(6.6) if T is a reference type, no initialization is performed.
7 To default-initialize an object of typeT means:
—(7.1) If T is a (possibly cv-qualified) class type (Clause 11), constructors are considered. The applicable
constructors are enumerated (12.2.2.4), and the best one for theinitializer () is chosen through overload
resolution (12.2). The constructor thus selected is called, with an empty argument list, to initialize the
object.
—(7.2) If T is an array type, the semantic constraints of default-initializing a hypothetical element shall be
met and each element is default-initialized.
—(7.3) If T is std::meta::info, the object is zero-initialized.
—(7.4) Otherwise, no initialization is performed.
8 A typecv T is const-default-constructible if
—(8.1) T is std::meta::info;
—(8.2) T is std::nullptr_t;
—(8.3) default-initialization of T would invoke a user-provided constructor ofT (not inherited from a base
class);
—(8.4) T is a class type where
—(8.4.1) each direct non-variant non-static data member ofT has a default member initializer or is of
const-default-constructible type,
—(8.4.2) if T is a union with at least one non-static data member, exactly one variant member has a default
member initializer,
—(8.4.3) if T is not a union, the type of each anonymous union member is const-default-constructible, and
—(8.4.4) each potentially constructed base class ofT is const-default-constructible; or
—(8.5) T is an array of const-default-constructible type.
If a program calls for the default-initialization of an object of a const-qualified typeT, T shall be a const-
default-constructible type.
9 To value-initialize an object of typeT means:
—(9.1) If T is a (possibly cv-qualified) class type (Clause 11), then letC be the constructor selected to default-
initialize the object, if any. IfC is not user-provided, the object is first zero-initialized. In all cases, the
object is then default-initialized.
—(9.2) If T is an array type, the semantic constraints of value-initializing a hypothetical element shall be met
and each element is value-initialized.
—(9.3) Otherwise, the object is zero-initialized.
10 A program that calls for default-initialization or value-initialization of an entity of reference type is ill-formed.
73) As specified in 7.3.12, converting an integer literal whose value is0 to a pointer type results in a null pointer value.
§ 9.5.1 © ISO/IEC
243

===== PAGE 255 =====

Dxxxx
11 [Note 4: For every object with static storage duration, static initialization (6.10.3.2) is performed at program startup
before any other initialization takes place. In some cases, additional initialization is done later.—end note]
12 If no initializer is specified for an object, the object is default-initialized.
13 If the entity being initialized does not have class or array type, theexpression-list in a parenthesized initializer
shall be a single expression.
14 The initialization that occurs in the= form of abrace-or-equal-initializer or condition (8.5), as well as in
argument passing, function return, throwing an exception (14.2), handling an exception (14.4), and aggregate
member initialization other than by adesignated-initializer-clause (9.5.2), is calledcopy-initialization.
[Note 5: Copy-initialization can invoke a move (11.4.5.3).—end note]
15 The initialization that occurs
—(15.1) for aninitializer that is a parenthesizedexpression-list or abraced-init-list,
—(15.2) for anew-initializer (7.6.2.8),
—(15.3) in astatic_cast expression (7.6.1.9),
—(15.4) in a functional notation type conversion (7.6.1.4), and
—(15.5) in thebraced-init-list form of acondition
is calleddirect-initialization.
16 The semantics of initializers are as follows. Thedestination typeis the cv-unqualified type of the object or
reference being initialized and thesource typeis the type of the initializer expression. If the initializer is not
a single (possibly parenthesized) expression, the source type is not defined.
—(16.1) If the initializer is a (non-parenthesized)braced-init-list or is= braced-init-list, the object or reference is
list-initialized (9.5.5).
—(16.2) If the destination type is a reference type, see 9.5.4.
—(16.3) If the destination type is an array of characters, an array ofchar8_t, an array ofchar16_t, an array
of char32_t, or an array ofwchar_t, and the initializer is astring-literal, see 9.5.3.
—(16.4) If the initializer is(), the object is value-initialized.
[Note 6: Since () is not permitted by the syntax forinitializer,
X a();
is not the declaration of an object of classX, but the declaration of a function taking no arguments and returning
an X. The form() can appear in certain other initialization contexts (7.6.2.8, 7.6.1.4, 11.9.3).—end note]
—(16.5) Otherwise, if the destination type is an array, the object is initialized as follows. Theinitializer shall be
of the form( expression-list ). Let x1, ... , xk be the elements of theexpression-list. If the destination
type is an array of unknown bound, it is defined as havingk elements. Let n denote the array size
after this potential adjustment. Ifk is greater thann, the program is ill-formed. Otherwise, theith
array element is copy-initialized withxi for each1 ≤i≤k, and value-initialized for eachk <i≤n.
For each1 ≤i<j ≤n, every value computation and side effect associated with the initialization of the
ith element of the array is sequenced before those associated with the initialization of thejth element.
—(16.6) Otherwise, if the destination type is a class type:
—(16.6.1) If the initializer expression is a prvalue and the cv-unqualified version of the source type is the
same as the destination type, the initializer expression is used to initialize the destination object.
[Example 2: T x = T(T(T())); value-initializes x (7.2.1, 7.6.1.4). —end example]
—(16.6.2) Otherwise, if the initialization is direct-initialization, or if it is copy-initialization where the cv-
unqualified version of the source type is the same as or is derived from the class of the destination
type, constructors are considered. The applicable constructors are enumerated (12.2.2.4), and the
best one is chosen through overload resolution (12.2). Then:
—(16.6.2.1) If overload resolution is successful, the selected constructor is called to initialize the object,
with the initializer expression orexpression-list as its argument(s).
—(16.6.2.2) Otherwise, if no constructor is viable, the destination type is an aggregate class, and the
initializer is a parenthesizedexpression-list, the object is initialized as follows. Lete1, ... , en
be the elements of the aggregate (9.5.2). Letx1, ... , xk be the elements of theexpression-list.
If k is greater thann, the program is ill-formed. The elementei is copy-initialized withxi for
§ 9.5.1 © ISO/IEC
244

===== PAGE 256 =====

Dxxxx
1 ≤i≤k. The remaining elements are initialized with their default member initializers, if
any, and otherwise are value-initialized. For each1 ≤i<j ≤n, every value computation and
side effect associated with the initialization ofei is sequenced before those associated with the
initialization ofej.
[Note 7: By contrast with direct-list-initialization, narrowing conversions (9.5.5) can appear, des-
ignators are not permitted, a temporary object bound to a reference does not have its lifetime
extended (6.8.7), and there is no brace elision.
[Example 3:
struct A {
int a;
int&& r;
};
int f();
int n = 10;
A a1{1, f()}; // OK, lifetime is extended
A a2(1, f()); // well-formed, but dangling reference
A a3{1.0, 1}; // error: narrowing conversion
A a4(1.0, 1); // well-formed, but dangling reference
A a5(1.0, std::move(n)); // OK
—end example]
—end note]
—(16.6.2.3) Otherwise, the initialization is ill-formed.
—(16.6.3) Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversions that can
convert from the source type to the destination type or (when a conversion function is used) to a
derived class thereof are enumerated as described in 12.2.2.5, and the best one is chosen through
overload resolution (12.2). If the conversion cannot be done or is ambiguous, the initialization is
ill-formed. The function selected is called with the initializer expression as its argument; if the
function is a constructor, the call is a prvalue of the cv-unqualified version of the destination type
whose result object is initialized by the constructor. The call is used to direct-initialize, according
to the rules above, the object that is the destination of the copy-initialization.
—(16.7) Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered.
The applicable conversion functions are enumerated (12.2.2.6), and the best one is chosen through
overload resolution (12.2). The user-defined conversion so selected is called to convert the initializer
expression into the object being initialized. If the conversion cannot be done or is ambiguous, the
initialization is ill-formed.
—(16.8) Otherwise, if the initialization is direct-initialization, the source type isstd::nullptr_t, and the
destination type isbool, the initial value of the object being initialized isfalse.
—(16.9) Otherwise, the initial value of the object being initialized is the (possibly converted) value of the
initializer expression. A standard conversion sequence (7.3) is used to convert the initializer expression
to a prvalue of the destination type; no user-defined conversions are considered. If the conversion
cannot be done, the initialization is ill-formed. When initializing a bit-field with a value that it cannot
represent, the resulting value of the bit-field is implementation-defined.
[Note 8: An expression of type “cv1 T” can initialize an object of type “cv2 T” independently of the cv-qualifiers
cv1 and cv2.
int a;
const int b = a;
int c = b;
—end note]
17 An immediate invocation (7.7) that is not evaluated where it appears (9.3.4.7, 11.4.1) is evaluated and
checked for whether it is a constant expression at the point where the enclosinginitializer is used in a function
call, a constructor definition, or an aggregate initialization.
18 An initializer-clause followed by an ellipsis is a pack expansion (13.7.4).
§ 9.5.1 © ISO/IEC
245

===== PAGE 257 =====

Dxxxx
19 Initialization includes the evaluation of all subexpressions of eachinitializer-clause of the initializer (possibly
nested withinbraced-init-lists) and the creation of any temporary objects for function arguments or return
values (6.8.7).
20 If the destination type is not an aggregate and the initializer is a parenthesizedexpression-list, the expressions
are evaluated in the order specified for function calls (7.6.1.3).
21 The sameidentifier shall not appear in multipledesignators of adesignated-initializer-list.
22 The deemed constructionof an object occurs when its initialization completes; for the purposes of 6.10.3.4, if
the initialization is a full-expression, deemed construction occurs when the evaluation of that full-expression
completes. The object is deemed to be constructed, even if the object is of non-class type or no constructor
of the object’s class is invoked for the initialization.
[Note 9: Such an object might have been value-initialized or initialized by aggregate initialization (9.5.2) or by an
inherited constructor (11.9.4). —end note]
Destroying an object of class type invokes the destructor of the class. Destroying a scalar type has no effect
other than ending the lifetime of the object (6.8.4). Destroying an array destroys each element in reverse
subscript order.
23 A declaration that specifies the initialization of a variable, whether from an explicit initializer or by default-
initialization, is called theinitializing declarationof that variable.
[Note 10: In most cases this is the defining declaration (6.2) of the variable, but the initializing declaration of a
non-inline static data member (11.4.9.3) can be the declaration within the class definition and not the definition (if
any) outside it. —end note]
9.5.2 Aggregates [dcl.init.aggr]
1 An aggregate is an array or a class (Clause 11) with
—(1.1) no user-declared or inherited constructors (11.4.5),
—(1.2) no private or protected direct non-static data members (11.8),
—(1.3) no private or protected direct base classes (11.8.3), and
—(1.4) no virtual functions (11.7.3) or virtual base classes (11.7.2).
[Note 1: Aggregate initialization does not allow accessing protected and private base class’ members, including
constructors. —end note]
2 The elements of an aggregate are:
—(2.1) for an array, the array elements in increasing subscript order, or
—(2.2) for a class, the direct base classes in declaration order, followed by the direct non-static data members
(11.4) that are not members of an anonymous union, in declaration order.
3 When an aggregate is initialized by an initializer list as specified in 9.5.5, the elements of the initializer list
are taken as initializers for the elements of the aggregate. Theexplicitly initialized elementsof the aggregate
are determined as follows:
—(3.1) If the initializer list is a brace-encloseddesignated-initializer-list, the aggregate shall be of class type, the
identifier in eachdesignator shall name a direct non-static data member of the class, and the explicitly
initialized elements of the aggregate are the elements that are, or contain, those members.
—(3.2) If the initializer list is a brace-enclosedinitializer-list, the explicitly initialized elements of the aggregate
are those for which an element of the initializer list appertains to the aggregate element or to a subobject
thereof (see below).
—(3.3) Otherwise, the initializer list must be{}, and there are no explicitly initialized elements.
4 For each explicitly initialized element:
—(4.1) If the element is an anonymous union member and the initializer list is a brace-encloseddesignated-
initializer-list, the element is initialized by thebraced-init-list { D }, whereD is thedesignated-initializer-
clause naming a member of the anonymous union member. There shall be only one suchdesignated-
initializer-clause.
[Example 1:
§ 9.5.2 © ISO/IEC
246

===== PAGE 258 =====

Dxxxx
struct C {
union {
int a;
const char* p;
};
int x;
} c = { .a = 1, .x = 3 };
initializes c.a with 1 andc.x with 3. —end example]
—(4.2) Otherwise, if the initializer list is a brace-encloseddesignated-initializer-list, the element is initialized
with thebrace-or-equal-initializer of the correspondingdesignated-initializer-clause. If that initializer
is of the form= assignment-expression and a narrowing conversion (9.5.5) is required to convert the
expression, the program is ill-formed.
[Note 2: The form of the initializer determines whether copy-initialization or direct-initialization is performed.
—end note]
—(4.3) Otherwise, the initializer list is a brace-enclosedinitializer-list. If aninitializer-clause appertains to the
aggregate element, then the aggregate element is copy-initialized from theinitializer-clause. Otherwise,
the aggregate element is copy-initialized from a brace-enclosedinitializer-list consisting of all of the
initializer-clauses that appertain to subobjects of the aggregate element, in the order of appearance.
[Note 3: If an initializer is itself an initializer list, the element is list-initialized, which will result in a recursive
application of the rules in this subclause if the element is an aggregate.—end note]
[Example 2:
struct A {
int x;
struct B {
int i;
int j;
} b;
} a = { 1, { 2, 3 } };
initializes a.x with 1,a.b.i with 2,a.b.j with 3.
struct base1 { int b1, b2 = 42; };
struct base2 {
base2() {
b3 = 42;
}
int b3;
};
struct derived : base1, base2 {
int d;
};
derived d1{{1, 2}, {}, 4};
derived d2{{}, {}, 4};
initializes d1.b1 with 1,d1.b2 with 2,d1.b3 with 42,d1.d with 4, andd2.b1 with 0,d2.b2 with 42,d2.b3
with 42,d2.d with 4. —end example]
5 For a non-union aggregate, each element that is not an explicitly initialized element is initialized as follows:
—(5.1) If the element has a default member initializer (11.4), the element is initialized from that initializer.
—(5.2) Otherwise, if the element is not a reference, the element is copy-initialized from an empty initializer
list (9.5.5).
—(5.3) Otherwise, the program is ill-formed.
If the aggregate is a union and the initializer list is empty, then
—(5.4) if any variant member has a default member initializer, that member is initialized from its default
member initializer;
—(5.5) otherwise, the first member of the union (if any) is copy-initialized from an empty initializer list.
6 [Example 3:
struct S { int a; const char* b; int c; int d = b[a]; };
§ 9.5.2 © ISO/IEC
247

===== PAGE 259 =====

Dxxxx
S ss = { 1, "asdf" };
initializes ss.a with 1,ss.b with "asdf", ss.c with the value of an expression of the formint{} (that is,0), and
ss.d with the value ofss.b[ss.a] (that is,’s’).
struct A {
string a;
int b = 42;
int c = -1;
};
A{.c=21} has the following steps:
—(6.1) Initialize a with {}
—(6.2) Initialize b with = 42
—(6.3) Initialize c with = 21
—end example]
7 The initializations of the elements of the aggregate are evaluated in the element order. That is, all value
computations and side effects associated with a given element are sequenced before those of any element that
follows it in order.
8 An aggregate that is a class can also be initialized with a single expression not enclosed in braces, as described
in 9.5.
9 The destructor for each element of class type other than an anonymous union member is potentially
invoked (11.4.7) from the context where the aggregate initialization occurs.
[Note 4: This provision ensures that destructors can be called for fully-constructed subobjects in case an exception is
thrown (14.3). —end note]
10 The number of elements (9.3.4.5) in an array of unknown bound initialized with a brace-enclosedinitializer-list
is the number of explicitly initialized elements of the array.
[Example 4:
int x[] = { 1, 3, 5 };
declares and initializesx as a one-dimensional array that has three elements since no size was specified and there are
three initializers. —end example]
[Example 5: In
struct X { int i, j, k; };
X a[] = { 1, 2, 3, 4, 5, 6 };
X b[2] = { { 1, 2, 3 }, { 4, 5, 6 } };
a and b have the same value.—end example]
An array of unknown bound shall not be initialized with an emptybraced-init-list {}.74
[Note 5: A default member initializer does not determine the bound for a member array of unknown bound. Since
the default member initializer is ignored if a suitablemem-initializer is present (11.9.3), the default member initializer
is not considered to initialize the array of unknown bound.
[Example 6:
struct S {
int y[] = { 0 }; // error: non-static data member of incomplete type
};
—end example]
—end note]
11 [Note 6: Static data members, non-static data members of anonymous union members, and unnamed bit-fields are
not considered elements of the aggregate.
[Example 7:
struct A {
int i;
static int s;
int j;
74) The syntax provides for emptybraced-init-lists, but nonetheless C++ does not have zero length arrays.
§ 9.5.2 © ISO/IEC
248

===== PAGE 260 =====

Dxxxx
int :17;
int k;
} a = { 1, 2, 3 };
Here, the second initializer 2 initializesa.j and not the static data memberA::s, and the third initializer 3 initializes
a.k and not the unnamed bit-field before it.—end example]
—end note]
12 If a member has a default member initializer and a potentially-evaluated subexpression thereof is an aggregate
initialization that would use that default member initializer, the program is ill-formed.
[Example 8:
struct A;
extern A a;
struct A {
const A& a1 { A{a,a} }; // OK
const A& a2 { A{} }; // error
};
A a{a,a}; // OK
struct B {
int n = B{}.n; // error
};
—end example]
13 When initializing a multidimensional array, theinitializer-clauses initialize the elements with the last (rightmost)
index of the array varying the fastest (9.3.4.5).
[Example 9:
int x[2][2] = { 3, 1, 4, 2 };
initializes x[0][0] to 3, x[0][1] to 1, x[1][0] to 4, andx[1][1] to 2. On the other hand,
float y[4][3] = {
{ 1 }, { 2 }, { 3 }, { 4 }
};
initializes the first column ofy (regarded as a two-dimensional array) and leaves the rest zero.—end example]
14 Each initializer-clause in a brace-enclosedinitializer-list is said toappertain to an element of the aggregate
being initialized or to an element of one of its subaggregates. Considering the sequence ofinitializer-clauses,
and the sequence of aggregate elements initially formed as the sequence of elements of the aggregate being
initialized and potentially modified as described below, eachinitializer-clause appertains to the corresponding
aggregate element if
—(14.1) the aggregate element is not an aggregate, or
—(14.2) the initializer-clause begins with a left brace, or
—(14.3) the initializer-clause is an expression and an implicit conversion sequence can be formed that converts
the expression to the type of the aggregate element, or
—(14.4) the aggregate element is an aggregate that itself has no aggregate elements.
Otherwise, the aggregate element is an aggregate and that subaggregate is replaced in the list of aggregate
elements by the sequence of its own aggregate elements, and the appertainment analysis resumes with the
first such element and the sameinitializer-clause.
[Note 7: These rules apply recursively to the aggregate’s subaggregates.
[Example 10: In
struct S1 { int a, b; };
struct S2 { S1 s, t; };
S2 x[2] = { 1, 2, 3, 4, 5, 6, 7, 8 };
S2 y[2] = {
{
{ 1, 2 },
{ 3, 4 }
},
§ 9.5.2 © ISO/IEC
249

===== PAGE 261 =====

Dxxxx
{
{ 5, 6 },
{ 7, 8 }
}
};
x and y have the same value.—end example]
—end note]
This process continues until allinitializer-clauses have been exhausted. If anyinitializer-clause remains that
does not appertain to an element of the aggregate or one of its subaggregates, the program is ill-formed.
[Example 11:
char cv[4] = { 'a', 's', 'd', 'f', 0 }; // error: too many initializers
—end example]
15 [Example 12:
float y[4][3] = {
{ 1, 3, 5 },
{ 2, 4, 6 },
{ 3, 5, 7 },
};
is a completely-braced initialization: 1, 3, and 5 initialize the first row of the arrayy[0], namelyy[0][0], y[0][1],
and y[0][2]. Likewise the next two lines initializey[1] and y[2]. The initializer ends early and thereforey[3]’s
elements are initialized as if explicitly initialized with an expression of the formfloat(), that is, are initialized with
0.0. In the following example, braces in theinitializer-list are elided; however theinitializer-list has the same effect as
the completely-bracedinitializer-list of the above example,
float y[4][3] = {
1, 3, 5, 2, 4, 6, 3, 5, 7
};
The initializer fory begins with a left brace, but the one fory[0] does not, therefore three elements from the list are
used. Likewise the next three are taken successively fory[1] and y[2]. —end example]
16 [Note 8: The initializer for an empty subaggregate is needed if any initializers are provided for subsequent elements.
[Example 13:
struct S { } s;
struct A {
S s1;
int i1;
S s2;
int i2;
S s3;
int i3;
} a = {
{ }, // Required initialization
0,
s, // Required initialization
0
}; // Initialization not required forA::s3 becauseA::i3 is also not initialized
—end example]
—end note]
17 [Example 14:
struct A {
int i;
operator int();
};
struct B {
A a1, a2;
int z;
};
A a;
B b = { 4, a, a };
§ 9.5.2 © ISO/IEC
250

===== PAGE 262 =====

Dxxxx
Braces are elided around theinitializer-clause for b.a1.i. b.a1.i is initialized with 4,b.a2 is initialized witha, b.z is
initialized with whatevera.operator int() returns. —end example]
18 [Note 9: An aggregate array or an aggregate class can contain elements of a class type with a user-declared
constructor (11.4.5). Initialization of these aggregate objects is described in 11.9.2.—end note]
19 [Note 10: Whether the initialization of aggregates with static storage duration is static or dynamic is specified
in 6.10.3.2, 6.10.3.3, and 8.10.—end note]
20 When a union is initialized with an initializer list, there shall not be more than one explicitly initialized
element.
[Example 15:
union u { int a; const char* b; };
u a = { 1 };
u b = a;
u c = 1; // error
u d = { 0, "asdf" }; // error
u e = { "asdf" }; // error
u f = { .b = "asdf" };
u g = { .a = 1, .b = "asdf" }; // error
—end example]
21 [Note 11: As described above, the braces around theinitializer-clause for a union member can be omitted if the union
is a member of another aggregate.—end note]
9.5.3 Character arrays [dcl.init.string]
1 An array of ordinary character type (6.9.2),char8_tarray,char16_tarray,char32_tarray, orwchar_tarray
may be initialized by an ordinary string literal, UTF-8 string literal, UTF-16 string literal, UTF-32 string
literal, or wide string literal, respectively, or by an appropriately-typedstring-literal enclosed in braces (5.13.5).
Additionally, an array ofchar or unsigned char may be initialized by a UTF-8 string literal, or by such a
string literal enclosed in braces. Successive characters of the value of thestring-literal initialize the elements
of the array, with an integral conversion (7.3.9) if necessary for the source and destination value.
[Example 1:
char msg[] = "Syntax error on line %s\n";
shows a character array whose members are initialized with astring-literal. Note that because’\n’ is a single character
and because a trailing’\0’ is appended,sizeof(msg) is 25. —end example]
2 There shall not be more initializers than there are array elements.
[Example 2:
char cv[4] = "asdf"; // error
is ill-formed since there is no space for the implied trailing’\0’. —end example]
3 If there are fewer initializers than there are array elements, each element not explicitly initialized shall be
zero-initialized (9.5).
9.5.4 References [dcl.init.ref]
1 A variable whose declared type is “reference toT” (9.3.4.3) shall be initialized.
[Example 1:
int g(int) noexcept;
void f() {
int i;
int& r = i; // r refers toi
r = 1; // the value ofi becomes1
int* p = &r; // p points toi
int& rr = r; // rr refers to whatr refers to, that is, toi
int (&rg)(int) = g; // rg refers to the functiong
rg(i); // calls functiong
int a[3];
int (&ra)[3] = a; // ra refers to the arraya
ra[1] = i; // modifiesa[1]
}
§ 9.5.4 © ISO/IEC
251

===== PAGE 263 =====

Dxxxx
—end example]
2 A reference cannot be changed to refer to another object after initialization.
[Note 1: Assignment to a reference assigns to the object referred to by the reference (7.6.19).—end note]
Argument passing (7.6.1.3) and function value return (8.8.4) are initializations.
3 The initializer can be omitted for a reference only in a parameter declaration (9.3.4.6), in the declaration of a
function return type, in the declaration of a class member within its class definition (11.4), and where the
extern specifier is explicitly used.
[Example 2:
int& r1; // error: initializer missing
extern int& r2; // OK
—end example]
4 Given types “cv1 T1” and “cv2 T2”, “cv1 T1” isreference-relatedto “cv2 T2” ifT1 is similar (7.3.6) toT2,
or T1 is a base class ofT2. “cv1 T1” isreference-compatiblewith “cv2 T2” if a prvalue of type “pointer to
cv2 T2” can be converted to the type “pointer tocv1 T1” via a standard conversion sequence (7.3). In all
cases where the reference-compatible relationship of two types is used to establish the validity of a reference
binding and the standard conversion sequence would be ill-formed, a program that necessitates such a binding
is ill-formed.
5 A reference to type “cv1 T1” is initialized by an expression of type “cv2 T2” as follows:
—(5.1) If the reference is an lvalue reference and the initializer expression
—(5.1.1) is an lvalue (but is not a bit-field), and “cv1 T1” is reference-compatible with “cv2 T2”, or
—(5.1.2) has a class type (i.e.,T2 is a class type), whereT1 is not reference-related toT2, and can be
converted to an lvalue of type “cv3 T3”, where “cv1 T1” is reference-compatible with “cv3 T3”75
(this conversion is selected by enumerating the applicable conversion functions (12.2.2.7) and
choosing the best one through overload resolution (12.2)),
then the reference binds to the initializer expression lvalue in the first case and to the lvalue result
of the conversion in the second case (or, in either case, to the appropriate base class subobject of the
object).
[Note 2: The usual lvalue-to-rvalue (7.3.2), array-to-pointer (7.3.3), and function-to-pointer (7.3.4) standard
conversions are not needed, and therefore are suppressed, when such direct bindings to lvalues are done.—end
note]
[Example 3:
double d = 2.0;
double& rd = d; // rd refers tod
const double& rcd = d; // rcd refers tod
struct A { };
struct B : A { operator int&(); } b;
A& ra = b; // ra refers toA subobject inb
const A& rca = b; // rca refers toA subobject inb
int& ir = B(); // ir refers to the result ofB::operator int&
—end example]
—(5.2) Otherwise, if the reference is an lvalue reference to a type that is not const-qualified or is volatile-qualified,
the program is ill-formed.
[Example 4:
double& rd2 = 2.0; // error: not an lvalue and reference notconst
int i = 2;
double& rd3 = i; // error: type mismatch and reference notconst
—end example]
—(5.3) Otherwise, if the initializer expression
—(5.3.1) is an rvalue (but not a bit-field) or an lvalue of function type and “cv1 T1” is reference-compatible
with “cv2 T2”, or
75) This requires a conversion function (11.4.8.3) returning a reference type.
§ 9.5.4 © ISO/IEC
252

===== PAGE 264 =====

Dxxxx
—(5.3.2) has a class type (i.e.,T2 is a class type), whereT1 is not reference-related toT2, and can be
converted to an rvalue of type “cv3 T3” or an lvalue of function type “cv3 T3”, where “cv1 T1” is
reference-compatible with “cv3 T3” (see 12.2.2.7),
then the initializer expression in the first case and the converted expression in the second case is called
the converted initializer. If the converted initializer is a prvalue, let its type be denoted byT4; the
temporary materialization conversion (7.3.5) is applied, considering the type of the prvalue to be “cv1
T4” (7.3.6). In any case, the reference binds to the resulting glvalue (or to an appropriate base class
subobject).
[Example 5:
struct A { };
struct B : A { } b;
extern B f();
const A& rca2 = f(); // binds to theA subobject of theB rvalue.
A&& rra = f(); // same as above
struct X {
operator B();
operator int&();
} x;
const A& r = x; // binds to theA subobject of the result of the conversion
int i2 = 42;
int&& rri = static_cast<int&&>(i2); // binds directly toi2
B&& rrb = x; // binds directly to the result ofoperator B
constexpr int f() {
const int &x = 42;
const_cast<int &>(x) = 1; // undefined behavior
return x;
}
constexpr int z = f(); // error: not a constant expression
typedef int *AP[3]; // array of 3 pointer toint
typedef const int *const ACPC[3]; // array of 3 const pointer toconst int
ACPC &&r = AP{}; // binds directly
—end example]
—(5.4) Otherwise, T1 shall not be reference-related toT2.
—(5.4.1) If T1 or T2 is a class type, user-defined conversions are considered using the rules for copy-
initialization of an object of type “cv1 T1” by user-defined conversion (9.5, 12.2.2.5, 12.2.2.6); the
program is ill-formed if the corresponding non-reference copy-initialization would be ill-formed. The
result E of the call to the conversion function, as described for the non-reference copy-initialization,
is then used to direct-initialize the reference using the form(E). For this direct-initialization,
user-defined conversions are not considered.
—(5.4.2) Otherwise, the initializer expression is implicitly converted to a prvalue of type “T1”. The temporary
materialization conversion is applied, considering the type of the prvalue to be “cv1 T1”, and the
reference is bound to the result.
[Example 6:
struct Banana { };
struct Enigma { operator const Banana(); };
struct Alaska { operator Banana&(); };
void enigmatic() {
typedef const Banana ConstBanana;
Banana &&banana1 = ConstBanana(); // error
Banana &&banana2 = Enigma(); // error
Banana &&banana3 = Alaska(); // error
}
const double& rcd2 = 2; // rcd2 refers to temporary with typeconst double and value2.0
double&& rrd = 2; // rrd refers to temporary with value2.0
const volatile int cvi = 1;
const int& r2 = cvi; // error: cv-qualifier dropped
§ 9.5.4 © ISO/IEC
253

===== PAGE 265 =====

Dxxxx
struct A { operator volatile int&(); } a;
const int& r3 = a; // error: cv-qualifier dropped
// from result of conversion function
double d2 = 1.0;
double&& rrd2 = d2; // error: initializer is lvalue of reference-related type
struct X { operator int&(); };
int&& rri2 = X(); // error: result of conversion function is
// lvalue of reference-related type
int i3 = 2;
double&& rrd3 = i3; // rrd3 refers to temporary with value2.0
—end example]
In all cases except the last (i.e., implicitly converting the initializer expression to the referenced type), the
reference is said tobind directlyto the initializer expression.
6 [Note 3: 6.8.7 describes the lifetime of temporaries bound to references.—end note]
9.5.5 List-initialization [dcl.init.list]
1 List-initialization is initialization of an object or reference from abraced-init-list. Such an initializer is called
an initializer list, and the comma-separatedinitializer-clauses of theinitializer-list or designated-initializer-clauses
of thedesignated-initializer-list are called theelements of the initializer list. An initializer list may be empty.
List-initialization can occur in direct-initialization or copy-initialization contexts; list-initialization in a
direct-initialization context is calleddirect-list-initialization and list-initialization in a copy-initialization
context is calledcopy-list-initialization. Direct-initialization that is not list-initialization is calleddirect-non-
list-initialization.
[Note 1: List-initialization can be used
—(1.1) as the initializer in a variable definition (9.5),
—(1.2) as the initializer in anew-expression (7.6.2.8),
—(1.3) in areturn statement (8.8.4),
—(1.4) as afor-range-initializer (8.6),
—(1.5) as a function argument (7.6.1.3),
—(1.6) as a template argument (13.4.3),
—(1.7) as a subscript (7.6.1.2),
—(1.8) as an argument to a constructor invocation (9.5, 7.6.1.4),
—(1.9) as an initializer for a non-static data member (11.4),
—(1.10) in amem-initializer (11.9.3), or
—(1.11) on the right-hand side of an assignment (7.6.19).
[Example 1:
int a = {1};
std::complex<double> z{1,2};
new std::vector<std::string>{"once", "upon", "a", "time"}; // 4 string elements
f( {"Nicholas","Annemarie"} ); // pass list of two elements
return { "Norah" }; // return list of one element
int* e {}; // initialization to zero / null pointer
x = double{1}; // explicitly construct adouble
std::map<std::string,int> anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
—end example]
—end note]
2 A constructor is aninitializer-list constructorif its first parameter is of typestd::initializer_list<E> or
reference tocv std::initializer_list<E> for some typeE, and either there are no other parameters or
else all other parameters have default arguments (9.3.4.7).
[Note 2: Initializer-list constructors are favored over other constructors in list-initialization (12.2.2.8). Passing an
initializer list as the argument to the constructor templatetemplate<class T> C(T) of a classC does not create an
initializer-list constructor, because an initializer list argument causes the corresponding parameter to be a non-deduced
context (13.10.3.2). —end note]
§ 9.5.5 © ISO/IEC
254

===== PAGE 266 =====

Dxxxx
The templatestd::initializer_list is not predefined; if a standard library declaration (17.11.2, 16.4.2.4)
of std::initializer_listis not reachable from (10.7) a use ofstd::initializer_list— even an implicit
use in which the type is not named (9.2.9.7) — the program is ill-formed.
3 List-initialization of an object or reference of typecv T is defined as follows:
—(3.1) If thebraced-init-list contains adesignated-initializer-list and T is not a reference type,T shall be an
aggregate class. The orderedidentifiers in thedesignators of thedesignated-initializer-list shall form a
subsequence of the orderedidentifiers in the direct non-static data members ofT. Aggregate initialization
is performed (9.5.2).
[Example 2:
struct A { int x; int y; int z; };
A a{.y = 2, .x = 1}; // error: designator order does not match declaration order
A b{.x = 1, .z = 2}; // OK,b.y initialized to0
—end example]
—(3.2) If T is an aggregate class and the initializer list has a single element of typecv1 U, where U is
T or a class derived fromT, the object is initialized from that element (by copy-initialization for
copy-list-initialization, or by direct-initialization for direct-list-initialization).
—(3.3) Otherwise, if T is a character array and the initializer list has a single element that is an appropriately-
typed string-literal (9.5.3), initialization is performed as described in that subclause.
—(3.4) Otherwise, ifT is an aggregate, aggregate initialization is performed (9.5.2).
[Example 3:
double ad[] = { 1, 2.0 }; // OK
int ai[] = { 1, 2.0 }; // error: narrowing
struct S2 {
int m1;
double m2, m3;
};
S2 s21 = { 1, 2, 3.0 }; // OK
S2 s22 { 1.0, 2, 3 }; // error: narrowing
S2 s23 { }; // OK, default to 0,0,0
—end example]
—(3.5) Otherwise, if the initializer list has no elements andT is a class type with a default constructor, the
object is value-initialized.
—(3.6) Otherwise, ifT is a specialization ofstd::initializer_list, the object is constructed as described
below.
—(3.7) Otherwise, ifT is a class type, constructors are considered. The applicable constructors are enumerated
and the best one is chosen through overload resolution (12.2, 12.2.2.8). If a narrowing conversion (see
below) is required to convert any of the arguments, the program is ill-formed.
[Example 4:
struct S {
S(std::initializer_list<double>); // #1
S(std::initializer_list<int>); // #2
S(std::initializer_list<S>); // #3
S(); // #4
// ...
};
S s1 = { 1.0, 2.0, 3.0 }; // invoke #1
S s2 = { 1, 2, 3 }; // invoke #2
S s3{s2}; // invoke #3 (not the copy constructor)
S s4 = { }; // invoke #4
—end example]
[Example 5:
struct Map {
Map(std::initializer_list<std::pair<std::string,int>>);
};
§ 9.5.5 © ISO/IEC
255

===== PAGE 267 =====

Dxxxx
Map ship = {{"Sophie",14}, {"Surprise",28}};
—end example]
[Example 6:
struct S {
// no initializer-list constructors
S(int, double, double); // #1
S(); // #2
// ...
};
S s1 = { 1, 2, 3.0 }; // OK, invoke #1
S s2 { 1.0, 2, 3 }; // error: narrowing
S s3 { }; // OK, invoke #2
—end example]
—(3.8) Otherwise, if T is an enumeration with a fixed underlying type (9.8.1)U, the initializer-list has a
single elementv of scalar type,v can be implicitly converted toU, and the initialization is direct-list-
initialization, the object is initialized with the valueT(v) (7.6.1.4); if a narrowing conversion is required
to convertv to U, the program is ill-formed.
[Example 7:
enum byte : unsigned char { };
byte b { 42 }; // OK
byte c = { 42 }; // error
byte d = byte{ 42 }; // OK; same value asb
byte e { -1 }; // error
struct A { byte b; };
A a1 = { { 42 } }; // error
A a2 = { byte{ 42 } }; // OK
void f(byte);
f({ 42 }); // error
enum class Handle : uint32_t { Invalid = 0 };
Handle h { 42 }; // OK
—end example]
—(3.9) Otherwise, if the initializer list is not adesignated-initializer-list and has a single element of typeE and
either T is not a reference type or its referenced type is reference-related toE, the object or reference is
initialized from that element (by copy-initialization for copy-list-initialization, or by direct-initialization
for direct-list-initialization); if a narrowing conversion (see below) is required to convert the element to
T, the program is ill-formed.
[Example 8:
int x1 {2}; // OK
int x2 {2.0}; // error: narrowing
—end example]
—(3.10) Otherwise, ifT is a reference type, a prvalue is generated. The prvalue initializes its result object by
copy-list-initialization from the initializer list. The prvalue is then used to direct-initialize the reference.
The type of the prvalue is the type referenced byT, unlessT is “reference to array of unknown bound
of U”, in which case the type of the prvalue is the type ofx in the declarationU x[] H, whereH is
the initializer list.
[Note 3: As usual, the binding will fail and the program is ill-formed if the reference type is an lvalue reference
to a non-const type.—end note]
[Example 9:
struct S {
S(std::initializer_list<double>); // #1
S(const std::string&); // #2
// ...
};
§ 9.5.5 © ISO/IEC
256

===== PAGE 268 =====

Dxxxx
const S& r1 = { 1, 2, 3.0 }; // OK, invoke #1
const S& r2 { "Spinach" }; // OK, invoke #2
S& r3 = { 1, 2, 3 }; // error: initializer is not an lvalue
const int& i1 = { 1 }; // OK
const int& i2 = { 1.1 }; // error: narrowing
const int (&iar)[2] = { 1, 2 }; // OK,iar is bound to temporary array
struct A { } a;
struct B { explicit B(const A&); };
const B& b2{a}; // error: cannot copy-list-initializeB temporary fromA
struct C { int x; };
C&& c = { .x = 1 }; // OK
—end example]
—(3.11) Otherwise, if the initializer list has no elements, the object is value-initialized.
[Example 10:
int** pp {}; // initialized to null pointer
—end example]
—(3.12) Otherwise, the program is ill-formed.
[Example 11:
struct A { int i; int j; };
A a1 { 1, 2 }; // aggregate initialization
A a2 { 1.2 }; // error: narrowing
struct B {
B(std::initializer_list<int>);
};
B b1 { 1, 2 }; // createsinitializer_list<int> and calls constructor
B b2 { 1, 2.0 }; // error: narrowing
struct C {
C(int i, double j);
};
C c1 = { 1, 2.2 }; // calls constructor with arguments (1, 2.2)
C c2 = { 1.1, 2 }; // error: narrowing
int j { 1 }; // initialize to 1
int k { }; // initialize to 0
—end example]
4 Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack
expansions (13.7.4), are evaluated in the order in which they appear. That is, every value computation and
side effect associated with a giveninitializer-clause is sequenced before every value computation and side effect
associated with anyinitializer-clause that follows it in the comma-separated list of theinitializer-list.
[Note 4: This evaluation ordering holds regardless of the semantics of the initialization; for example, it applies when
the elements of theinitializer-list are interpreted as arguments of a constructor call, even though ordinarily there are
no sequencing constraints on the arguments of a call.—end note]
5 An object of typestd::initializer_list<E> is constructed from an initializer list as if the implementation
generated and materialized (7.3.5) a prvalue of type “array ofN const E”, whereN is the number of elements
in the initializer list; this is called the initializer list’sbacking array. Each element of the backing array is
copy-initialized with the corresponding element of the initializer list, and thestd::initializer_list<E>
object is constructed to refer to that array.
[Note 5: A constructor or conversion function selected for the copy needs to be accessible (11.8) in the context of the
initializer list. —end note]
If a narrowing conversion is required to initialize any of the elements, the program is ill-formed.
[Note 6: Backing arrays are potentially non-unique objects (6.8.2).—end note]
6 The backing array has the same lifetime as any other temporary object (6.8.7), except that initializing an
initializer_list object from the array extends the lifetime of the array exactly like binding a reference to
a temporary.
§ 9.5.5 © ISO/IEC
257

===== PAGE 269 =====

Dxxxx
[Example 12:
void f(std::initializer_list<double> il);
void g(float x) {
f({1, x, 3});
}
void h() {
f({1, 2, 3});
}
struct A {
mutable int i;
};
void q(std::initializer_list<A>);
void r() {
q({A{1}, A{2}, A{3}});
}
The initialization will be implemented in a way roughly equivalent to this:
void g(float x) {
const double __a[3] = {double{1}, double{x}, double{3}}; // backing array
f(std::initializer_list<double>(__a, __a+3));
}
void h() {
static constexpr double __b[3] = {double{1}, double{2}, double{3}}; // backing array
f(std::initializer_list<double>(__b, __b+3));
}
void r() {
const A __c[3] = {A{1}, A{2}, A{3}}; // backing array
q(std::initializer_list<A>(__c, __c+3));
}
assuming that the implementation can construct aninitializer_list object with a pair of pointers, and with the
understanding that__b does not outlive the call tof. —end example]
[Example 13:
typedef std::complex<double> cmplx;
std::vector<cmplx> v1 = { 1, 2, 3 };
void f() {
std::vector<cmplx> v2{ 1, 2, 3 };
std::initializer_list<int> i3 = { 1, 2, 3 };
}
struct A {
std::initializer_list<int> i4;
A() : i4{ 1, 2, 3 } {} // ill-formed, would create a dangling reference
};
Forv1 and v2, theinitializer_list object is a parameter in a function call, so the array created for{ 1, 2, 3 }
has full-expression lifetime. Fori3, theinitializer_list object is a variable, so the array persists for the lifetime of
the variable. Fori4, theinitializer_list object is initialized in the constructor’sctor-initializer as if by binding a
temporary array to a reference member, so the program is ill-formed (11.9.3).—end example]
7 A narrowing conversionis an implicit conversion
—(7.1) from a floating-point type to an integer type, or
—(7.2) from a floating-point typeT to another floating-point type whose floating-point conversion rank is
neither greater than nor equal to that ofT, except where the result of the conversion is a constant
expression and either its value is finite and the conversion did not overflow, or the values before and
after the conversion are not finite, or
—(7.3) from an integer type or unscoped enumeration type to a floating-point type, except where the source is
a constant expression and the actual value after conversion will fit into the target type and will produce
the original value when converted back to the original type, or
§ 9.5.5 © ISO/IEC
258

===== PAGE 270 =====

Dxxxx
—(7.4) from an integer type or unscoped enumeration type to an integer type that cannot represent all the
values of the original type, except where
—(7.4.1) the source is a bit-field whose widthw is less than that of its type (or, for an enumeration type,
its underlying type) and the target type can represent all the values of a hypothetical extended
integer type with widthw and with the same signedness as the original type or
—(7.4.2) the source is a constant expression whose value after integral promotions will fit into the target
type, or
—(7.5) from a pointer type or a pointer-to-member type tobool.
[Note 7: As indicated above, such conversions are not allowed at the top level in list-initializations.—end note]
[Example 14:
int x = 999; // x is not a constant expression
const int y = 999;
const int z = 99;
char c1 = x; // OK, though it potentially narrows (in this case, it does narrow)
char c2{x}; // error: potentially narrows
char c3{y}; // error: narrows (assumingchar is 8 bits)
char c4{z}; // OK, no narrowing needed
unsigned char uc1 = {5}; // OK, no narrowing needed
unsigned char uc2 = {-1}; // error: narrows
unsigned int ui1 = {-1}; // error: narrows
signed int si1 =
{ (unsigned int)-1 }; // error: narrows
int ii = {2.0}; // error: narrows
float f1 { x }; // error: potentially narrows
float f2 { 7 }; // OK, 7 can be exactly represented as afloat
bool b = {"meow"}; // error: narrows
int f(int);
int a[] = { 2, f(2), f(2.0) }; // OK, thedouble-to-int conversion is not at the top level
—end example]
9.6 Function definitions [dcl.fct.def]
9.6.1 General [dcl.fct.def.general]
1 Function definitions have the form
function-definition:
attribute-specifier-seqopt decl-specifier-seqopt declarator virt-specifier-seqopt
function-contract-specifier-seqopt function-body
attribute-specifier-seqopt decl-specifier-seqopt declarator requires-clause
function-contract-specifier-seqopt function-body
function-body:
ctor-initializeropt compound-statement
function-try-block
= default ;
deleted-function-body
deleted-function-body:
= delete ;
= delete (unevaluated-string ) ;
Any informal reference to the body of a function should be interpreted as a reference to the non-terminal
function-body, including, for a constructor, default member initializers or default initialization used to initialize
a base or member subobject in the absence of amem-initializer-id (11.9.3). The optionalattribute-specifier-seq
in afunction-definition appertains to the function. Afunction-definition with avirt-specifier-seq shall be a
member-declaration (11.4). A function-definition with arequires-clause shall define a templated function.
2 In afunction-definition, eithervoid declarator ; or declarator ; shall be a well-formed function declaration as
described in 9.3.4.6. A function shall be defined only in namespace or class scope. The type of a parameter
or the return type for a function definition shall not be a (possibly cv-qualified) class type that is incomplete
or abstract within the function body unless the function is deleted (9.6.3).
§ 9.6.1 © ISO/IEC
259

===== PAGE 271 =====

Dxxxx
3 [Example 1: A simple example of a complete function definition is
int max(int a, int b, int c) {
int m = (a > b) ? a : b;
return (m > c) ? m : c;
}
Here int is thedecl-specifier-seq; max(int a, int b, int c)is thedeclarator; { /* ... */ } is thefunction-body.
—end example]
4 A ctor-initializer is used only in a constructor; see 11.4.5 and 11.9.
5 [Note 1: A cv-qualifier-seq affects the type ofthis in the body of a member function; see 7.5.3.—end note]
6 [Note 2: Unused parameters need not be named. For example,
void print(int a, int) {
std::printf("a = %d\n",a);
}
—end note]
7 A function-local predefined variableis a variable with static storage duration that is implicitly defined in a
function parameter scope.
8 The function-local predefined variable__func__ is defined as if a definition of the form
static const char __func__[] = "function-name ";
had been provided, wherefunction-name is an implementation-defined string. It is unspecified whether
such a variable has an address distinct from that of any other object in the program.76
[Example 2:
struct S {
S() : s(__func__) { } // OK
const char* s;
};
void f(const char* s = __func__); // error: __func__ is undeclared
—end example]
9.6.2 Explicitly-defaulted functions [dcl.fct.def.default]
1 A function definition whosefunction-body is of the form= default ;is called anexplicitly-defaulted definition.
A function that is explicitly defaulted shall
—(1.1) be a special member function (11.4.4) or a comparison operator function (12.4.3, 11.10.1), and
—(1.2) not have default arguments (9.3.4.7).
2 An explicitly defaulted special member functionF1 is allowed to differ from the corresponding special member
function F2 that would have been implicitly declared, as follows:
—(2.1) F1 and F2 may have differingref-qualifiers;
—(2.2) if F2 has an implicit object parameter of type “reference toC”, F1 may be an explicit object member
function whose explicit object parameter is of (possibly different) type “reference toC”, in which case
the type ofF1 would differ from the type ofF2 in that the type ofF1 has an additional parameter;
—(2.3) F1 and F2 may have differing exception specifications; and
—(2.4) if F2 has a non-object parameter of typeconst C&, the corresponding non-object parameter ofF1 may
be of typeC&.
If the type ofF1 differs from the type ofF2 in a way other than as allowed by the preceding rules, then:
—(2.5) if F1 is an assignment operator, and the return type ofF1 differs from the return type ofF2 or F1’s
non-object parameter type is not a reference, the program is ill-formed;
—(2.6) otherwise, ifF1 is explicitly defaulted on its first declaration, it is defined as deleted;
—(2.7) otherwise, the program is ill-formed.
3 A function explicitly defaulted on its first declaration is implicitly inline (9.2.8), and is implicitly constexpr
(9.2.6) if it is constexpr-suitable.
76) Implementations are permitted to provide additional predefined variables with names that are reserved to the implementation
(5.11). If a predefined variable is not odr-used (6.3), its string value need not be present in the program image.
§ 9.6.2 © ISO/IEC
260

===== PAGE 272 =====

Dxxxx
[Note 1: Other defaulted functions are not implicitly constexpr.—end note]
4 [Example 1:
struct S {
S(int a = 0) = default; // error: default argument
void operator=(const S&) = default; // error: non-matching return type
~S() noexcept(false) = default; // OK, despite mismatched exception specification
private:
int i;
S(S&); // OK, private copy constructor
};
S::S(S&) = default; // OK, defines copy constructor
struct T {
T();
T(T &&) noexcept(false);
};
struct U {
T t;
U();
U(U &&) noexcept = default;
};
U u1;
U u2 = static_cast<U&&>(u1); // OK, callsstd::terminate if T::T(T&&) throws
—end example]
5 Explicitly-defaulted functions and implicitly-declared functions are collectively calleddefaulted functions, and
the implementation shall provide implicit definitions for them (11.4.5, 11.4.7, 11.4.5.3, 11.4.6) as described
below, including possibly defining them as deleted. A defaulted prospective destructor (11.4.7) that is not a
destructor is defined as deleted. A defaulted special member function that is neither a prospective destructor
nor an eligible special member function (11.4.4) is defined as deleted. A function isuser-provided if it is user-
declared and not explicitly defaulted or deleted on its first declaration. A user-provided explicitly-defaulted
function (i.e., explicitly defaulted after its first declaration) is implicitly defined at the point where it is
explicitly defaulted; if such a function is implicitly defined as deleted, the program is ill-formed.
[Note 2: Declaring a function as defaulted after its first declaration can provide efficient execution and concise
definition while enabling a stable binary interface to an evolving code base.—end note]
A non-user-provided defaulted function (i.e., implicitly declared or explicitly defaulted in the class) that is
not defined as deleted is implicitly defined when it is odr-used (6.3) or needed for constant evaluation (7.7).
[Note 3: The implicit definition of a non-user-provided defaulted function does not bind any names.—end note]
6 [Example 2:
struct trivial {
trivial() = default;
trivial(const trivial&) = default;
trivial(trivial&&) = default;
trivial& operator=(const trivial&) = default;
trivial& operator=(trivial&&) = default;
~trivial() = default;
};
struct nontrivial1 {
nontrivial1();
};
nontrivial1::nontrivial1() = default; // not first declaration
—end example]
9.6.3 Deleted definitions [dcl.fct.def.delete]
1 A deleted definitionof a function is a function definition whosefunction-body is adeleted-function-body or an
explicitly-defaulted definition of the function where the function is defined as deleted. Adeleted functionis a
function with a deleted definition or a function that is implicitly defined as deleted.
§ 9.6.3 © ISO/IEC
261

===== PAGE 273 =====

Dxxxx
2 A construct that designates a deleted function implicitly or explicitly, other than to declare it or to appear as
the operand of areflect-expression (7.6.2.10), is ill-formed.
Recommended practice: The resulting diagnostic message should include the text of theunevaluated-string, if
one is supplied.
[Note 1: This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member to the
function. It applies even for references in expressions that are not potentially-evaluated. For an overload set, only
the function selected by overload resolution is referenced. The implicit odr-use (6.3) of a virtual function does not,
by itself, constitute a reference. Theunevaluated-string, if present, can be used to explain the rationale for deletion
and/or to suggest an alternative.—end note]
3 [Example 1: One can prevent default initialization and initialization by non-doubles with
struct onlydouble {
onlydouble() = delete; // OK, but redundant
template<class T>
onlydouble(T) = delete;
onlydouble(double);
};
—end example]
[Example 2: One can prevent use of a class in certainnew-expressions by using deleted definitions of a user-declared
operator new for that class.
struct sometype {
void* operator new(std::size_t) = delete;
void* operator new[](std::size_t) = delete;
};
sometype* p = new sometype; // error: deleted classoperator new
sometype* q = new sometype[3]; // error: deleted classoperator new[]
—end example]
[Example 3: One can make a class uncopyable, i.e., move-only, by using deleted definitions of the copy constructor
and copy assignment operator, and then providing defaulted definitions of the move constructor and move assignment
operator.
struct moveonly {
moveonly() = default;
moveonly(const moveonly&) = delete;
moveonly(moveonly&&) = default;
moveonly& operator=(const moveonly&) = delete;
moveonly& operator=(moveonly&&) = default;
~moveonly() = default;
};
moveonly* p;
moveonly q(*p); // error: deleted copy constructor
—end example]
4 A deleted function is implicitly an inline function (9.2.8).
[Note 2: The one-definition rule (6.3) applies to deleted definitions.—end note]
A deleted definition of a function shall be the first declaration of the function or, for an explicit specialization
of a function template, the first declaration of that specialization. An implicitly declared allocation or
deallocation function (6.8.6.5) shall not be defined as deleted.
[Example 4:
struct sometype {
sometype();
};
sometype::sometype() = delete; // error: not first declaration
—end example]
9.6.4 Coroutine definitions [dcl.fct.def.coroutine]
1 A function is acoroutine if itsfunction-body encloses acoroutine-return-statement (8.8.5), anawait-expression
(7.6.2.4), or ayield-expression (7.6.17). The parameter-declaration-clause of the coroutine shall not terminate
with an ellipsis that is not part of aparameter-declaration.
§ 9.6.4 © ISO/IEC
262

===== PAGE 274 =====

Dxxxx
2 [Example 1:
task<int> f();
task<void> g1() {
int i = co_await f();
std::cout << "f() => " << i << std::endl;
}
template <typename... Args>
task<void> g2(Args&&...) { // OK, ellipsis is a pack expansion
int i = co_await f();
std::cout << "f() => " << i << std::endl;
}
task<void> g3(int a, ...) { // error: variable parameter list not allowed
int i = co_await f();
std::cout << "f() => " << i << std::endl;
}
—end example]
3 The promise typeof a coroutine isstd::coroutine_traits<R, P1, ... , Pn>::promise_type, whereR is
the return type of the function, andP1 ... Pn is the sequence of types of the non-object function parameters,
preceded by the type of the object parameter (9.3.4.6) if the coroutine is a non-static member function. The
promise type shall be a class type.
4 In the following,pi is an lvalue of typePi, where p1 denotes the object parameter andpi+1 denotes the
ith non-object function parameter for an implicit object member function, andpi denotes theith function
parameter otherwise. For an implicit object member function,q1 is an lvalue that denotes*this; any other
qi is an lvalue that denotes the parameter copy corresponding topi, as described below.
5 A coroutine behaves as if the top-level cv-qualifiers in allparameter-declarations in the declarator of its
function-definition were removed and itsfunction-body were replaced by the followingreplacement body:
{
promise-typepromise promise-constructor-arguments;
try {
co_await promise .initial_suspend() ;
function-body
} catch ( ... ) {
if (!initial-await-resume-called )
throw ;
promise .unhandled_exception() ;
}
final-suspend :
co_await promise .final_suspend() ;
}
where
—(5.1) the await-expression containing the call toinitial_suspend is theinitial await expression, and
—(5.2) the await-expression containing the call tofinal_suspend is thefinal await expression, and
—(5.3) initial-await-resume-called is initiallyfalse and is set totrue immediately before the evaluation of
the await-resume expression (7.6.2.4) of the initial await expression, and
—(5.4) promise-type denotes the promise type, and
—(5.5) the object denoted by the exposition-only namepromise is thepromise objectof the coroutine, and
—(5.6) the label denoted by the namefinal-suspend is defined for exposition only (8.8.5), and
—(5.7) promise-constructor-argumentsis determined as follows: overload resolution is performed on a promise
constructor call created by assembling an argument listq1 ... qn. If a viable constructor is found (12.2.3),
then promise-constructor-arguments is (q1, ... , qn), otherwise promise-constructor-arguments is
empty, and
§ 9.6.4 © ISO/IEC
263

===== PAGE 275 =====

Dxxxx
—(5.8) a coroutine is suspended at theinitial suspend pointif it is suspended at the initial await expression,
and
—(5.9) a coroutine is suspended at afinal suspend pointif it is suspended
—(5.9.1) at a final await expression or
—(5.9.2) due to an exception exiting fromunhandled_exception().
6 [Note 1: An odr-use of a non-reference parameter in a postcondition assertion of a coroutine is ill-formed (9.4.1).
—end note]
7 If searches for the namesreturn_void and return_value in the scope of the promise type each find any
declarations, the program is ill-formed.
[Note 2: If return_void is found, flowing off the end of a coroutine is equivalent to aco_return with no operand.
Otherwise, flowing off the end of a coroutine results in undefined behavior (8.8.5).—end note]
8 The expressionpromise .get_return_object() is used to initialize the returned reference or prvalue result
object of a call to a coroutine. The call toget_return_object is sequenced before the call toinitial_-
suspend and is invoked at most once.
9 A suspended coroutine can be resumed to continue execution by invoking a resumption member function
(17.13.4.6) of a coroutine handle (17.13.4) that refers to the coroutine. The evaluation that invoked a
resumption member function is called theresumer. Invoking a resumption member function for a coroutine
that is not suspended results in undefined behavior.
10 An implementation may need to allocate additional storage for a coroutine. This storage is known as the
coroutine stateand is obtained by calling a non-array allocation function (6.8.6.5.2) as part of the replacement
body. The allocation function’s name is looked up by searching for it in the scope of the promise type.
—(10.1) If the search finds any declarations, overload resolution is performed on a function call created by
assembling an argument list. The first argument is the amount of space requested, and is a prvalue
of typestd::size_t. The lvaluesp1 ... pn with their original types (including cv-qualifiers) are the
successive arguments. If no viable function is found (12.2.3), overload resolution is performed again on
a function call created by passing just the amount of space required as a prvalue of typestd::size_t.
—(10.2) If the search finds no declarations, a search is performed in the global scope. Overload resolution is
performed on a function call created by passing the amount of space required as a prvalue of type
std::size_t.
11 If a search for the nameget_return_object_on_allocation_failurein the scope of the promise type (6.5.2)
finds any declarations, then the result of a call to an allocation function used to obtain storage for the
coroutine state is assumed to returnnullptr if it fails to obtain storage, and if a global allocation function
is selected, the::operator new(size_t, nothrow_t) form is used. The allocation function used in this
case shall have a non-throwingnoexcept-specifier. If the allocation function returnsnullptr, the coroutine
transfers control to the caller of the coroutine and the return value is obtained by a call toT::get_return_-
object_on_allocation_failure(), whereT is the promise type.
[Example 2:
#include <iostream>
#include <coroutine>
// ::operator new(size_t, nothrow_t) will be used if allocation is needed
struct generator {
struct promise_type;
using handle = std::coroutine_handle<promise_type>;
struct promise_type {
int current_value;
static auto get_return_object_on_allocation_failure() { return generator{nullptr}; }
auto get_return_object() { return generator{handle::from_promise(*this)}; }
auto initial_suspend() { return std::suspend_always{}; }
auto final_suspend() noexcept { return std::suspend_always{}; }
void unhandled_exception() { std::terminate(); }
void return_void() {}
auto yield_value(int value) {
current_value = value;
return std::suspend_always{};
§ 9.6.4 © ISO/IEC
264

===== PAGE 276 =====

Dxxxx
}
};
bool move_next() { return coro ? (coro.resume(), !coro.done()) : false; }
int current_value() { return coro.promise().current_value; }
generator(generator const&) = delete;
generator(generator && rhs) : coro(rhs.coro) { rhs.coro = nullptr; }
~generator() { if (coro) coro.destroy(); }
private:
generator(handle h) : coro(h) {}
handle coro;
};
generator f() { co_yield 1; co_yield 2; }
int main() {
auto g = f();
while (g.move_next()) std::cout << g.current_value() << std::endl;
}
—end example]
12 The coroutine state is destroyed when control flows off the end of the coroutine or thedestroy member
function (17.13.4.6) of a coroutine handle (17.13.4) that refers to the coroutine is invoked. In the latter
case, control in the coroutine is considered to be transferred out of the function (8.10). The storage for the
coroutine state is released by calling a non-array deallocation function (6.8.6.5.3). Ifdestroy is called for a
coroutine that is not suspended, the program has undefined behavior.
13 The deallocation function’s name is looked up by searching for it in the scope of the promise type. If
nothing is found, a search is performed in the global scope. If both a usual deallocation function with only a
pointer parameter and a usual deallocation function with both a pointer parameter and a size parameter
are found, then the selected deallocation function shall be the one with two parameters. Otherwise, the
selected deallocation function shall be the function with one parameter. If no usual deallocation function is
found, the program is ill-formed. The selected deallocation function shall be called with the address of the
block of storage to be reclaimed as its first argument. If a deallocation function with a parameter of type
std::size_t is used, the size of the block is passed as the corresponding argument.
14 When a coroutine is invoked, a copy is created for each coroutine parameter at the beginning of the replacement
body. For a parameter whose original declaration specified the typecv T,
—(14.1) if T is a reference type, the copy is a reference of typecv T bound to the same object as a parameter;
—(14.2) otherwise, the copy is a variable of typecv T with automatic storage duration that is direct-initialized
from an xvalue of typeT referring to the parameter.
[Note 3: An identifier in thefunction-body that names one of these parameters refers to the created copy, not the
original parameter (7.5.5.2). —end note]
The initialization and destruction of each parameter copy occurs in the context of the called coroutine.
Initializations of parameter copies are sequenced before the call to the coroutine promise constructor and
indeterminately sequenced with respect to each other. The lifetime of parameter copies ends immediately
after the lifetime of the coroutine promise object ends.
[Note 4: If a coroutine has a parameter passed by reference, resuming the coroutine after the lifetime of the entity
referred to by that parameter has ended is likely to result in undefined behavior.—end note]
15 If the evaluation of the expressionpromise .unhandled_exception() exits via an exception, the coroutine
is considered suspended at the final suspend point and the exception propagates to the caller or resumer.
16 The expressionco_await promise .final_suspend() shall not be potentially-throwing (14.5).
9.6.5 Replaceable function definitions [dcl.fct.def.replace]
1 Certain functions for which a definition is supplied by the implementation arereplaceable. A C++ program
may provide a definition with the signature of a replaceable function, called areplacement function. The
replacement function is used instead of the default version supplied by the implementation. Such replacement
occurs prior to program startup (6.3, 6.10.3). A declaration of the replacement function
—(1.1) shall not be inline,
—(1.2) shall be attached to the global module,
—(1.3) shall have C++ language linkage,
§ 9.6.5 © ISO/IEC
265

===== PAGE 277 =====

Dxxxx
—(1.4) shall have the same return type as the replaceable function, and
—(1.5) if the function is declared in a standard library header, shall be such that it would be valid as a
redeclaration of the declaration in that header;
no diagnostic is required.
[Note 1: The one-definition rule (6.3) applies to the definitions of a replaceable function provided by the program.
The implementation-supplied function definition is an otherwise-unnamed function with no linkage.—end note]
9.7 Structured binding declarations [dcl.struct.bind]
1 A structured binding declaration introduces theidentifiers v0, v1, v2,..., vN−1 of the sb-identifier-list as
names. An sb-identifier that contains an ellipsis introduces a structured binding pack (13.7.4). Astructured
binding is either ansb-identifier that does not contain an ellipsis or an element of a structured binding pack.
The optionalattribute-specifier-seq of ansb-identifier appertains to the associated structured bindings. Letcv
denote thecv-qualifiers in thedecl-specifier-seq and S consist of eachdecl-specifier of thedecl-specifier-seq that
is constexpr, constinit, or astorage-class-specifier. A cv that includesvolatile is deprecated; see D.4.
First, a variable with a unique namee is introduced. If theassignment-expression in theinitializer has array
type cv1 A and noref-qualifier is present,e is defined by
attribute-specifier-seqopt S cv A e ;
and each element is copy-initialized or direct-initialized from the corresponding element of theassignment-
expression as specified by the form of theinitializer. Otherwise, e is defined as-if by
attribute-specifier-seqopt decl-specifier-seq ref-qualifieropt e initializer ;
where the declaration is never interpreted as a function declaration and the parts of the declaration other
than thedeclarator-id are taken from the corresponding structured binding declaration. The type of the
id-expression e is calledE.
[Note 1: E is never a reference type (7.2).—end note]
2 The structured binding sizeof E, as defined below, is the number of structured bindings that need to be
introduced by the structured binding declaration. If there is no structured binding pack, then the number of
elements in thesb-identifier-list shall be equal to the structured binding size ofE. Otherwise, the number
of non-pack elements shall be no more than the structured binding size ofE; the number of elements of
the structured binding pack is the structured binding size ofE less the number of non-pack elements in the
sb-identifier-list.
3 Let SBi denote theith structured binding in the structured binding declaration after expanding the structured
binding pack, if any.
[Note 2: If there is no structured binding pack, then SBi denotes vi. —end note]
[Example 1:
struct C { int x, y, z; };
template<class T>
void now_i_know_my() {
auto [a, b, c] = C(); // OK, SB0 is a, SB1 is b, and SB2 is c
auto [d, ...e] = C(); // OK, SB0 is d, the packe (v1) contains two structured bindings:SB1 and SB2
auto [...f, g] = C(); // OK, the packf (v0) contains two structured bindings: SB0 and SB1, and SB2
is g
auto [h, i, j, ...k] = C(); // OK, the packk is empty
auto [l, m, n, o, ...p] = C(); // error: structured binding size is too small
}
—end example]
4 If a structured binding declaration appears as acondition, the decision variable (8.1) of the condition ise .
5 If theinitializer refers to one of the names introduced by the structured binding declaration, the program is
ill-formed.
6 E shall not be an array type of unknown bound. IfE is any other array type with element typeT, the
structured binding size ofE is equal to the number of elements ofE. Each SBi is the name of an lvalue that
refers to the elementi of the array and whose type isT; the referenced type isT.
[Note 3: The top-level cv-qualifiers ofT are cv. —end note]
§ 9.7 © ISO/IEC
266

===== PAGE 278 =====

Dxxxx
[Example 2:
auto f() -> int(&)[2];
auto [ x, y ] = f(); // x and y refer to elements in a copy of the array return value
auto& [ xr, yr ] = f(); // xr and yr refer to elements in the array referred to byf’s return value
auto g() -> int(&)[4];
template<size_t N>
void h(int (&arr)[N]) {
auto [a, ...b, c] = arr; // a names the first element of the array,b is a pack referring to the second and
// third elements, andc names the fourth element
auto& [...e] = arr; // e is a pack referring to the four elements of the array
}
void call_h() {
h(g());
}
—end example]
7 Otherwise, if thequalified-id std::tuple_size<E> names a complete class type with a member namedvalue,
the expressionstd::tuple_size<E>::value shall be a well-formed integral constant expression whose value
is non-negative; the structured binding size ofE is equal to that value. Leti be an index prvalue of type
std::size_t corresponding tovi. If a search for the nameget in the scope ofE (6.5.2) finds at least one
declaration that is a function template whose first template parameter is a constant template parameter, the
initializer ise.get<i>(). Otherwise, the initializer isget<i>(e ), whereget undergoes argument-dependent
lookup (6.5.4). In either case,get<i> is interpreted as atemplate-id.
[Note 4: Ordinary unqualified lookup (6.5.3) is not performed.—end note]
In either case,e is an lvalue if the type of the entitye is an lvalue reference and an xvalue otherwise. Given
the typeTi designated bystd::tuple_element<i, E>::type and the typeUi designated by eitherTi& or
Ti&&, whereUi is an lvalue reference if the initializer is an lvalue and an rvalue reference otherwise, variables
are introduced with unique namesri as follows:
S Ui ri = initializer ;
Each SBi is the name of an lvalue of typeTi that refers to the object bound tori; the referenced type isTi.
The initialization ofe and any conversion ofe considered as a decision variable (8.1) is sequenced before the
initialization of anyri. The initialization of eachri is sequenced before the initialization of anyrj where
i<j .
8 Otherwise, all ofE’s non-static data members shall be direct members ofE or of the same base class ofE,
well-formed when named ase.name in the context of the structured binding,E shall not have an anonymous
union member, and the structured binding size ofE is equal to the number of non-static data members ofE.
Designating the non-static data members ofE as m0, m1, m2,... (in declaration order), eachSBi is the name
of an lvalue that refers to the membermi of e and whose type is that ofe.mi (7.6.1.5); the referenced type is
the declared type ofmi if that type is a reference type, or the type ofe.mi otherwise. The lvalue is a bit-field
if that member is a bit-field.
[Example 3:
struct S { mutable int x1 : 2; volatile double y1; };
S f();
const auto [ x, y ] = f();
The type of theid-expression x is “int”, the type of theid-expression y is “const volatile double”. —end example]
9.8 Enumerations [enum]
9.8.1 Enumeration declarations [dcl.enum]
1 An enumeration is a distinct type (6.9.4) with named constants. Its name becomes anenum-name within its
scope.
enum-name:
identifier
§ 9.8.1 © ISO/IEC
267

===== PAGE 279 =====

Dxxxx
enum-specifier:
enum-head { enumerator-listopt }
enum-head { enumerator-list , }
enum-head:
enum-key attribute-specifier-seqopt enum-head-nameopt enum-baseopt
enum-head-name:
nested-name-specifieropt identifier
opaque-enum-declaration:
enum-key attribute-specifier-seqopt enum-head-name enum-baseopt ;
enum-key:
enum
enum class
enum struct
enum-base:
: type-specifier-seq
enumerator-list:
enumerator-definition
enumerator-list , enumerator-definition
enumerator-definition:
enumerator
enumerator = constant-expression
enumerator:
identifier attribute-specifier-seqopt
The optionalattribute-specifier-seq in theenum-head and theopaque-enum-declaration appertains to the enu-
meration; the attributes in thatattribute-specifier-seq are thereafter considered attributes of the enumeration
whenever it is named. A: following “enum nested-name-specifieropt identifier” within thedecl-specifier-seq of
a member-declaration is parsed as part of anenum-base.
[Note 1: This resolves a potential ambiguity between the declaration of an enumeration with anenum-base and the
declaration of an unnamed bit-field of enumeration type.
[Example 1:
struct S {
enum E : int {};
enum E : int {}; // error: redeclaration of enumeration
};
—end example]
—end note]
The identifier in anenum-head-name is not looked up and is introduced by theenum-specifier or opaque-
enum-declaration. If theenum-head-name of anopaque-enum-declaration contains anested-name-specifier, the
declaration shall be an explicit specialization (13.9.4).
2 The enumeration type declared with anenum-key of onlyenumis anunscoped enumeration, and itsenumerators
are unscoped enumerators. The enum-keys enum class and enum struct are semantically equivalent; an
enumeration type declared with one of these is ascoped enumeration, and its enumerators are scoped
enumerators. The optionalenum-head-name shall not be omitted in the declaration of a scoped enumeration.
The type-specifier-seq of an enum-base shall name an integral type; any cv-qualification is ignored. An
opaque-enum-declaration declaring an unscoped enumeration shall not omit theenum-base. The identifiers
in anenumerator-list are declared as constants, and can appear wherever constants are required. The same
identifier shall not appear as the name of multiple enumerators in anenumerator-list. An enumerator-definition
with = gives the associatedenumerator the value indicated by theconstant-expression. Anenumerator-definition
without = gives the associatedenumerator the value zero if it is the firstenumerator-definition, and the value
of the previousenumerator increased by one otherwise.
[Example 2:
enum { a, b, c=0 };
enum { d, e, f=e+2 };
defines a, c, andd to be zero,b and e to be1, andf to be3. —end example]
§ 9.8.1 © ISO/IEC
268

===== PAGE 280 =====

Dxxxx
The optionalattribute-specifier-seq in anenumerator appertains to that enumerator.
3 An opaque-enum-declaration is either a redeclaration of an enumeration in the current scope or a declaration
of a new enumeration.
[Note 2: An enumeration declared by anopaque-enum-declaration has a fixed underlying type and is a complete type.
The list of enumerators can be provided in a later redeclaration with anenum-specifier. —end note]
A scoped enumeration shall not be later redeclared as unscoped or with a different underlying type. An
unscoped enumeration shall not be later redeclared as scoped and each redeclaration shall include anenum-base
specifying the same underlying type as in the original declaration.
4 If anenum-head-name contains anested-name-specifier, the enclosingenum-specifier or opaque-enum-declaration
D shall not inhabit a class scope and shall correspond to one or more declarations nominable in the class,
class template, or namespace to which thenested-name-specifier refers (6.4.1). All those declarations shall
have the same target scope; the target scope ofD is that scope.
5 Each enumeration defines a type that is different from all other types. Each enumeration also has anunderlying
type. The underlying type can be explicitly specified using anenum-base. For a scoped enumeration type, the
underlying type isint if it is not explicitly specified. In both of these cases, the underlying type is said to be
fixed. Following the closing brace of anenum-specifier, each enumerator has the type of its enumeration. If
the underlying type is fixed, the type of each enumerator prior to the closing brace is the underlying type and
the constant-expression in theenumerator-definition shall be a converted constant expression of the underlying
type (7.7). If the underlying type is not fixed, the type of each enumerator prior to the closing brace is
determined as follows:
—(5.1) If an initializer is specified for an enumerator, theconstant-expression shall be an integral constant
expression (7.7). If the expression has unscoped enumeration type, the enumerator has the underlying
type of that enumeration type, otherwise it has the same type as the expression.
—(5.2) If no initializer is specified for the first enumerator, its type is an unspecified signed integral type.
—(5.3) Otherwise the type of the enumerator is the same as that of the preceding enumerator unless the
incremented value is not representable in that type, in which case the type is an unspecified integral
type sufficient to contain the incremented value. If no such type exists, the program is ill-formed.
6 An enumeration whose underlying type is fixed is an incomplete type until immediately after itsenum-base
(if any), at which point it becomes a complete type. An enumeration whose underlying type is not fixed is an
incomplete type until the closing} of itsenum-specifier, at which point it becomes a complete type.
7 For an enumeration whose underlying type is not fixed, the underlying type is an integral type that can
represent all the enumerator values defined in the enumeration. If no integral type can represent all the
enumerator values, the enumeration is ill-formed. It is implementation-defined which integral type is used
as the underlying type except that the underlying type shall not be larger thanint unless the value of an
enumerator cannot fit in anint or unsigned int. If theenumerator-list is empty, the underlying type is as
if the enumeration had a single enumerator with value 0.
8 For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the
underlying type. Otherwise, the values of the enumeration are the values representable by a hypothetical
integer type with minimal widthM such that all enumerators can be represented. The width of the smallest
bit-field large enough to hold all the values of the enumeration type isM. It is possible to define an
enumeration that has values not defined by any of its enumerators. If theenumerator-list is empty, the values
of the enumeration are as if the enumeration had a single enumerator with value 0.77
9 An enumeration has the same size, value representation, and alignment requirements (6.8.3) as its underlying
type. Furthermore, each value of an enumeration has the same representation as the corresponding value of
the underlying type.
10 Two enumeration types arelayout-compatible enumerationsif they have the same underlying type.
11 The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by
integral promotion (7.3.7).
[Example 3:
enum color { red, yellow, green=20, blue };
color col = red;
77) This set of values is used to define promotion and conversion semantics for the enumeration type. It does not preclude an
expression of enumeration type from having a value that falls outside this range.
§ 9.8.1 © ISO/IEC
269

===== PAGE 281 =====

Dxxxx
color* cp = &col;
if (*cp == blue) // ...
makes color a type describing various colors, and then declarescol as an object of that type, andcp as a pointer to
an object of that type. The possible values of an object of typecolor are red, yellow, green, blue; these values can
be converted to the integral values0, 1, 20, and21. Since enumerations are distinct types, objects of typecolor can
be assigned only values of typecolor.
color c = 1; // error: type mismatch, no conversion fromint to color
int i = yellow; // OK,yellow converted to integral value1, integral promotion
Note that this implicitenum to int conversion is not provided for a scoped enumeration:
enum class Col { red, yellow, green };
int x = Col::red; // error: noCol to int conversion
Col y = Col::red;
if (y) { } // error: noCol to bool conversion
—end example]
12 The name of each unscoped enumerator is also bound in the scope that immediately contains theenum-
specifier. An unnamed enumeration that does not have a typedef name for linkage purposes (9.2.4) and that
has a first enumerator is denoted, for linkage purposes (6.7), by its underlying type and its first enumerator;
such an enumeration is said to have an enumerator as a name for linkage purposes.
[Note 3: Each unnamed enumeration with no enumerators is a distinct type.—end note]
[Example 4:
enum direction { left='l', right='r' };
void g() {
direction d; // OK
d = left; // OK
d = direction::right; // OK
}
enum class altitude { high='h', low='l' };
void h() {
altitude a; // OK
a = high; // error: high not in scope
a = altitude::low; // OK
}
—end example]
9.8.2 The using enum declaration [enum.udecl]
using-enum-declaration:
using enum using-enum-declarator ;
using-enum-declarator:
nested-name-specifieropt identifier
nested-name-specifieropt simple-template-id
splice-type-specifier
1 A using-enum-declarator of the formsplice-type-specifier designates the same type designated by thesplice-type-
specifier. Any otherusing-enum-declarator names the set of declarations found by type-only lookup (6.5.1) for
the using-enum-declarator (6.5.3, 6.5.5). Theusing-enum-declarator shall designate a non-dependent type with
a reachableenum-specifier.
[Example 1:
enum E { x };
void f() {
int E;
using enum E; // OK
}
using F = E;
using enum F; // OK
template<class T> using EE = T;
§ 9.8.2 © ISO/IEC
270

===== PAGE 282 =====

Dxxxx
void g() {
using enum EE<E>; // OK
}
—end example]
2 A using-enum-declaration is equivalent to ausing-declaration for each enumerator.
3 [Note 1: A using-enum-declaration in class scope makes the enumerators of the named enumeration available via
member lookup.
[Example 2:
enum class fruit { orange, apple };
struct S {
using enum fruit; // OK, introducesorange and apple into S
};
void f() {
S s;
s.orange; // OK, namesfruit::orange
S::orange; // OK, namesfruit::orange
}
—end example]
—end note]
4 [Note 2: Twousing-enum-declarations that introduce two enumerators of the same name conflict.
[Example 3:
enum class fruit { orange, apple };
enum class color { red, orange };
void f() {
using enum fruit; // OK
using enum color; // error: color::orange and fruit::orange conflict
}
—end example]
—end note]
9.9 Namespaces [basic.namespace]
9.9.1 General [basic.namespace.general]
1 A namespace is an optionally-named entity whose scope can contain declarations of any kind of entity. The
name of a namespace can be used to access entities that belong to that namespace; that is, themembers of
the namespace. Unlike other entities, the definition of a namespace can be split over several parts of one or
more translation units and modules.
2 [Note 1: Anamespace-definition is exported if it contains anyexport-declarations (10.2). A namespace is never attached
to a named module and never has a name with module linkage.—end note]
[Example 1:
export module M;
namespace N1 {} // N1 is not exported
export namespace N2 {} // N2 is exported
namespace N3 { export int n; } // N3 is exported
—end example]
3 There is aglobal namespacewith no declaration; see 6.4.6. The global namespace belongs to the global scope;
it is not an unnamed namespace (9.9.2.2).
[Note 2: Lacking a declaration, it cannot be found by name lookup.—end note]
9.9.2 Namespace definition [namespace.def]
9.9.2.1 General [namespace.def.general]
namespace-name:
identifier
namespace-alias
§ 9.9.2.1 © ISO/IEC
271

===== PAGE 283 =====

Dxxxx
namespace-definition:
named-namespace-definition
unnamed-namespace-definition
nested-namespace-definition
named-namespace-definition:
inlineopt namespace attribute-specifier-seqopt identifier { namespace-body }
unnamed-namespace-definition:
inlineopt namespace attribute-specifier-seqopt { namespace-body }
nested-namespace-definition:
namespace enclosing-namespace-specifier :: inlineopt identifier { namespace-body }
enclosing-namespace-specifier:
identifier
enclosing-namespace-specifier :: inlineopt identifier
namespace-body:
declaration-seqopt
1 Every namespace-definition shall inhabit a namespace scope (6.4.6).
2 In anamed-namespace-definition D, theidentifier is the name of the namespace. Theidentifier is looked up
by searching for it in the scopes of the namespaceA in whichD appears and of every element of the inline
namespace set ofA. If the lookup finds anamespace-definition for a namespaceN, D extends N, and the
target scope ofD is the scope to whichN belongs. If the lookup finds nothing, theidentifier is introduced as
a namespace-name into A.
3 Because anamespace-definition contains declarations in itsnamespace-body and anamespace-definition is itself
a declaration, it follows thatnamespace-definitions can be nested.
[Example 1:
namespace Outer {
int i;
namespace Inner {
void f() { i++; } // Outer::i
int i;
void g() { i++; } // Inner::i
}
}
—end example]
4 If the optional initialinline keyword appears in anamespace-definition for a particular namespace, that
namespace is declared to be aninline namespace. Theinline keyword may be used on anamespace-definition
that extends a namespace only if it was previously used on thenamespace-definition that initially declared
the namespace-name for that namespace.
5 The optionalattribute-specifier-seq in anamed-namespace-definition appertains to the namespace being defined
or extended.
6 Members of an inline namespace can be used in most respects as though they were members of the innermost
enclosing namespace. Specifically, the inline namespace and its enclosing namespace are both added to the
set of associated namespaces used in argument-dependent lookup (6.5.4) whenever one of them is, and a
using-directive (9.9.4) that names the inline namespace is implicitly inserted into the enclosing namespace as
for an unnamed namespace (9.9.2.2). Furthermore, each member of the inline namespace can subsequently
be partially specialized (13.7.6), explicitly instantiated (13.9.3), or explicitly specialized (13.9.4) as though
it were a member of the enclosing namespace. Finally, looking up a name in the enclosing namespace via
explicit qualification (6.5.5.3) will include members of the inline namespace even if there are declarations of
that name in the enclosing namespace.
7 These properties are transitive: if a namespaceN contains an inline namespaceM, which in turn contains an
inline namespaceO, then the members ofO can be used as though they were members ofM or N. The inline
namespace setof N is the transitive closure of all inline namespaces inN.
8 A nested-namespace-definition with anenclosing-namespace-specifier E, identifier I and namespace-body B is
equivalent to
namespace E { inlineopt namespace I { B } }
§ 9.9.2.1 © ISO/IEC
272

===== PAGE 284 =====

Dxxxx
where the optionalinline is present if and only if theidentifier I is preceded byinline.
[Example 2:
namespace A::inline B::C {
int i;
}
The above has the same effect as:
namespace A {
inline namespace B {
namespace C {
int i;
}
}
}
—end example]
9.9.2.2 Unnamed namespaces [namespace.unnamed]
1 An unnamed-namespace-definition behaves as if it were replaced by
inlineopt namespace unique { /* empty body */ }
using namespace unique ;
namespace unique { namespace-body }
where inline appears if and only if it appears in theunnamed-namespace-definition and all occurrences of
unique in a translation unit are replaced by the same identifier, and this identifier differs from all other
identifiers in the program. The optionalattribute-specifier-seq in theunnamed-namespace-definition appertains
to unique .
[Example 1:
namespace { int i; } // unique ::i
void f() { i++; } // unique ::i++
namespace A {
namespace {
int i; // A::unique ::i
int j; // A::unique ::j
}
void g() { i++; } // A::unique ::i++
}
using namespace A;
void h() {
i++; // error: unique ::i or A::unique ::i
A::i++; // A::unique ::i
j++; // A::unique ::j
}
—end example]
9.9.3 Namespace alias [namespace.alias]
1 A namespace-alias-definition declares anamespace aliasaccording to the following grammar:
namespace-alias:
identifier
namespace-alias-definition:
namespace identifier = qualified-namespace-specifier ;
namespace identifier = splice-specifier ;
qualified-namespace-specifier:
nested-name-specifieropt namespace-name
2 The splice-specifier (if any) shall designate a namespace that is not the global namespace.
3 The identifier in anamespace-alias-definition becomes anamespace-alias.
§ 9.9.3 © ISO/IEC
273

===== PAGE 285 =====

Dxxxx
4 The underlying entity (6.1) of the namespace alias is the namespace either denoted by thequalified-namespace-
specifier or designated by thesplice-specifier.
[Note 1: When looking up anamespace-name in anamespace-alias-definition, only namespace names are considered,
see 6.5.7. —end note]
9.9.4 Using namespace directive [namespace.udir]
using-directive:
attribute-specifier-seqopt using namespace nested-name-specifieropt namespace-name ;
attribute-specifier-seqopt using namespace splice-specifier ;
1 The splice-specifier (if any) shall designate a namespace that is not the global namespace. Thenested-name-
specifier, namespace-name, andsplice-specifier shall not be dependent.
2 A using-directive shall not appear in class scope, but may appear in namespace scope or in block scope.
[Note 1: When looking up anamespace-name in ausing-directive, only namespace names are considered, see 6.5.7.
—end note]
The optionalattribute-specifier-seq appertains to theusing-directive.
3 [Note 2: Ausing-directive makes the names in the designated namespace usable in the scope in which theusing-directive
appears after theusing-directive (6.5.3, 6.5.5.3). During unqualified name lookup, the names appear as if they were
declared in the nearest enclosing namespace which contains both theusing-directive and the designated namespace.
—end note]
4 [Note 3: A using-directive does not introduce any names.—end note]
[Example 1:
namespace A {
int i;
namespace B {
namespace C {
int i;
}
using namespace A::B::C;
void f1() {
i = 5; // OK,C::i visible in B and hidesA::i
}
}
namespace D {
using namespace B;
using namespace C;
void f2() {
i = 5; // ambiguous,B::C::i or A::i?
}
}
void f3() {
i = 5; // usesA::i
}
}
void f4() {
i = 5; // error: neitheri is visible
}
—end example]
5 [Note 4: A using-directive is transitive: if a scope contains ausing-directive that designates a namespace that itself
contains using-directives, the namespaces designated by thoseusing-directives are also eligible to be considered.—end
note]
[Example 2:
namespace M {
int i;
}
namespace N {
int i;
§ 9.9.4 © ISO/IEC
274

===== PAGE 286 =====

Dxxxx
using namespace M;
}
void f() {
using namespace N;
i = 7; // error: bothM::i and N::i are visible
}
For another example,
namespace A {
int i;
}
namespace B {
int i;
int j;
namespace C {
namespace D {
using namespace A;
int j;
int k;
int a = i; // B::i hides A::i
}
using namespace D;
int k = 89; // no problem yet
int l = k; // ambiguous: C::k or D::k
int m = i; // B::i hides A::i
int n = j; // D::j hides B::j
}
}
—end example]
6 [Note 5: Declarations in a namespace that appear after ausing-directive for that namespace can be found through
that using-directive after they appear. —end note]
7 [Note 6: If name lookup finds a declaration for a name in two different namespaces, and the declarations do not
declare the same entity and do not declare functions or function templates, the use of the name is ill-formed (6.5). In
particular, the name of a variable, function or enumerator does not hide the name of a class or enumeration declared
in a different namespace. For example,
namespace A {
class X { };
extern "C" int g();
extern "C++" int h();
}
namespace B {
void X(int);
extern "C" int g();
extern "C++" int h(int);
}
using namespace A;
using namespace B;
void f() {
X(1); // error: nameX found in two namespaces
g(); // OK, nameg refers to the same entity
h(); // OK, overload resolution selectsA::h
}
—end note]
8 [Note 7: The order in which namespaces are considered and the relationships among the namespaces implied by the
using-directives do not affect overload resolution. Neither is any function excluded because another has the same
signature, even if one is in a namespace reachable throughusing-directives in the namespace of the other.78 —end
78) During name lookup in a class hierarchy, some ambiguities can be resolved by considering whether one member hides the
other along some paths (6.5.2). There is no such disambiguation when considering the set of names found as a result of following
using-directives.
§ 9.9.4 © ISO/IEC
275

===== PAGE 287 =====

Dxxxx
note]
[Example 3:
namespace D {
int d1;
void f(char);
}
using namespace D;
int d1; // OK, no conflict withD::d1
namespace E {
int e;
void f(int);
}
namespace D { // namespace extension
int d2;
using namespace E;
void f(int);
}
void f() {
d1++; // error: ambiguous::d1 or D::d1?
::d1++; // OK
D::d1++; // OK
d2++; // OK,D::d2
e++; // OK,E::e
f(1); // error: ambiguous:D::f(int) or E::f(int)?
f('a'); // OK,D::f(char)
}
—end example]
9.10 The using declaration [namespace.udecl]
using-declaration:
using using-declarator-list ;
using-declarator-list:
using-declarator ...opt
using-declarator-list , using-declarator ...opt
using-declarator:
typenameopt nested-name-specifier unqualified-id
1 The component names of ausing-declarator are those of itsnested-name-specifier and unqualified-id. Eachusing-
declarator in ausing-declaration79 names the set of declarations found by lookup (6.5.5) for theusing-declarator,
except that class and enumeration declarations that would be discarded are merely ignored when checking
for ambiguity (6.5), conversion function templates with a dependent return type are ignored, and certain
functions are hidden as described below. If the terminal name of theusing-declarator is dependent (13.8.3.2),
the using-declarator is considered to name a constructor if and only if thenested-name-specifier has a terminal
name that is the same as theunqualified-id. If the lookup in any instantiation finds that ausing-declarator
that is not considered to name a constructor does do so, or that ausing-declarator that is considered to name
a constructor does not, the program is ill-formed.
2 If theusing-declarator names a constructor, it declares that the classinherits the named set of constructor
declarations from the nominated base class.
[Note 1: Otherwise, theunqualified-id in theusing-declarator is bound to theusing-declarator, which is replaced during
name lookup with the declarations it names (6.5). If such a declaration is of an enumeration, the names of its
enumerators are not bound. For the keywordtypename, see 13.8. —end note]
3 In ausing-declaration used as amember-declaration, eachusing-declarator shall either name an enumerator or
have anested-name-specifier naming a base class of the current class (7.5.3).
79) A using-declaration with more than oneusing-declarator is equivalent to a corresponding sequence ofusing-declarations with
one using-declarator each.
§ 9.10 © ISO/IEC
276

===== PAGE 288 =====

Dxxxx
[Example 1:
enum class button { up, down };
struct S {
using button::up;
button b = up; // OK
};
—end example]
If ausing-declarator names a constructor, itsnested-name-specifier shall name a direct base class of the current
class. If the immediate (class) scope is associated with a class template, it shall derive from the specified
base class or have at least one dependent base class.
[Example 2:
struct B {
void f(char);
enum E { e };
union { int x; };
};
struct C {
int f();
};
struct D : B {
using B::f; // OK,B is a base ofD
using B::e; // OK,e is an enumerator of baseB
using B::x; // OK,x is a union member of baseB
using C::f; // error: C isn’t a base ofD
void f(int) { f('c'); } // calls B::f(char)
void g(int) { g('c'); } // recursively callsD::g(int)
};
template <typename... bases>
struct X : bases... {
using bases::f...;
};
X<B, C> x; // OK,B::f and C::f named
—end example]
4 [Note 2: Since destructors do not have names, ausing-declaration cannot refer to a destructor for a base class.—end
note]
If a constructor or assignment operator brought from a base class into a derived class has the signature of a
copy/move constructor or assignment operator for the derived class (11.4.5.3, 11.4.6), theusing-declaration
does not by itself suppress the implicit declaration of the derived class member; the member from the base
class is hidden or overridden by the implicitly-declared copy/move constructor or assignment operator of the
derived class, as described below.
5 A using-declaration shall not name atemplate-id.
[Example 3:
struct A {
template <class T> void f(T);
template <class T> struct X { };
};
struct B : A {
using A::f<double>; // error
using A::X<int>; // error
};
—end example]
6 A using-declaration shall not name a namespace.
7 A using-declaration that names a class member other than an enumerator shall be amember-declaration.
[Example 4:
§ 9.10 © ISO/IEC
277

===== PAGE 289 =====

Dxxxx
struct X {
int i;
static int s;
};
void f() {
using X::i; // error: X::i is a class member and this is not a member declaration.
using X::s; // error: X::s is a class member and this is not a member declaration.
}
—end example]
8 If a declaration is named by twousing-declarators that inhabit the same class scope, the program is ill-formed.
[Example 5:
struct C {
int i;
};
struct D1 : C { };
struct D2 : C { };
struct D3 : D1, D2 {
using D1::i; // OK, equivalent tousing C::i
using D1::i; // error: duplicate
using D2::i; // error: duplicate, also namesC::i
};
—end example]
9 [Note 3: A using-declarator whose nested-name-specifier names a namespace does not name declarations added to the
namespace after it. Thus, additional overloads added after theusing-declaration are ignored, but default function
arguments (9.3.4.7), default template arguments (13.2), and template specializations (13.7.6, 13.9.4) are considered.
—end note]
[Example 6:
namespace A {
void f(int);
}
using A::f; // f is a synonym forA::f; that is, forA::f(int).
namespace A {
void f(char);
}
void foo() {
f('a'); // calls f(int), even thoughf(char) exists.
}
void bar() {
using A::f; // f is a synonym forA::f; that is, forA::f(int) and A::f(char).
f('a'); // calls f(char)
}
—end example]
10 If a declaration named by a using-declaration that inhabits the target scope of another declaration B
potentially conflicts with it (6.4.1), and either is reachable from the other, the program is ill-formed unlessB
is name-independent and theusing-declaration precedes B.
[Example 7:
int _;
void f() {
int _; // B
_ = 0;
using ::_; // error:using-declaration does not precede B
}
§ 9.10 © ISO/IEC
278

===== PAGE 290 =====

Dxxxx
—end example]
If two declarations named byusing-declarations that inhabit the same scope potentially conflict, either is
reachable from the other, and they do not both declare functions or function templates, the program is
ill-formed.
[Note 4: Overload resolution possibly cannot distinguish between conflicting function declarations.—end note]
[Example 8:
namespace A {
int x;
int f(int);
int g;
void h();
}
namespace B {
int i;
struct g { };
struct x { };
void f(int);
void f(double);
void g(char); // OK, hidesstruct g
}
void func() {
int i;
using B::i; // error: conflicts
void f(char);
using B::f; // OK, eachf is a function
using A::f; // OK, but interferes withB::f(int)
f(1); // error: ambiguous
static_cast<int(*)(int)>(f)(1); // OK, callsA::f
f(3.5); // calls B::f(double)
using B::g;
g('a'); // calls B::g(char)
struct g g1; // g1 has class typeB::g
using A::g; // error: conflicts withB::g
void h();
using A::h; // error: conflicts
using B::x;
using A::x; // OK, hidesstruct B::x
using A::x; // OK, does not conflict with previoususing A::x
x = 99; // assigns toA::x
struct x x1; // x1 has class typeB::x
}
—end example]
11 The set of declarations named by ausing-declarator that inhabits a classC does not include member functions
and member function templates of a base class that, when considered as members ofC, correspond to a
declaration of a function or function template inC.
[Example 9:
struct B {
virtual void f(int);
virtual void f(char);
void g(int);
void h(int);
void i();
void j();
};
struct D : B {
using B::f;
void f(int); // OK,D::f(int) overrides B::f(int);
§ 9.10 © ISO/IEC
279

===== PAGE 291 =====

Dxxxx
using B::g;
void g(char); // OK
using B::h;
void h(int); // OK,D::h(int) hides B::h(int)
using B::i;
void i(this B &); // OK
using B::j;
void j(this D &); // OK,D::j() hides B::j()
};
void k(D* p)
{
p->f(1); // calls D::f(int)
p->f('a'); // calls B::f(char)
p->g(1); // calls B::g(int)
p->g('a'); // calls D::g(char)
p->i(); // calls B::i, becauseB::i as a member ofD is a better match thanD::i
p->j(); // calls D::j
}
struct B1 {
B1(int);
};
struct B2 {
B2(int);
};
struct D1 : B1, B2 {
using B1::B1;
using B2::B2;
};
D1 d1(0); // error: ambiguous
struct D2 : B1, B2 {
using B1::B1;
using B2::B2;
D2(int); // OK,D2::D2(int) hides B1::B1(int) and B2::B2(int)
};
D2 d2(0); // calls D2::D2(int)
—end example]
12 [Note 5: For the purpose of forming a set of candidates during overload resolution, the functions named by a
using-declaration in a derived class are treated as though they were direct members of the derived class. In particular,
the implicit object parameter is treated as if it were a reference to the derived class rather than to the base class (12.2.2).
This has no effect on the type of the function, and in all other respects the function remains part of the base class.
—end note]
13 Constructors that are named by ausing-declaration are treated as though they were constructors of the
derived class when looking up the constructors of the derived class (6.5.5.2) or forming a set of overload
candidates (12.2.2.4, 12.2.2.5, 12.2.2.8).
[Note 6: If such a constructor is selected to perform the initialization of an object of class type, all subobjects other
than the base class from which the constructor originated are implicitly initialized (11.9.4). A constructor of a derived
class is sometimes preferred to a constructor of a base class if they would otherwise be ambiguous (12.2.4).—end
note]
14 In ausing-declarator that does not name a constructor, every declaration named shall be accessible. In a
using-declarator that names a constructor, no access check is performed.
15 [Note 7: Because a using-declarator designates a base class member (and not a member subobject or a member
function of a base class subobject), ausing-declarator cannot be used to resolve inherited member ambiguities.
§ 9.10 © ISO/IEC
280

===== PAGE 292 =====

Dxxxx
[Example 10:
struct A { int x(); };
struct B : A { };
struct C : A {
using A::x;
int x(int);
};
struct D : B, C {
using C::x;
int x(double);
};
int f(D* d) {
return d->x(); // error: overload resolution selectsA::x, but A is an ambiguous base class
}
—end example]
—end note]
16 A using-declaration has the usual accessibility for amember-declaration. Base-class constructors considered
because of ausing-declarator are accessible if they would be accessible when used to construct an object of
the base class; the accessibility of theusing-declaration is ignored.
[Example 11:
class A {
private:
void f(char);
public:
void f(int);
protected:
void g();
};
class B : public A {
using A::f; // error: A::f(char) is inaccessible
public:
using A::g; // B::g is a public synonym forA::g
};
—end example]
9.11 The asm declaration [dcl.asm]
1 An asm declaration has the form
asm-declaration:
attribute-specifier-seqopt asm ( balanced-token-seq ) ;
The asm declaration is conditionally-supported; any restrictions on thebalanced-token-seq and its meaning
are implementation-defined. The optionalattribute-specifier-seq in anasm-declaration appertains to theasm
declaration.
[Note 1: Typically it is used to pass information through the implementation to an assembler.—end note]
9.12 Linkage specifications [dcl.link]
1 All functions and variables whose names have external linkage and all function types have alanguage linkage.
[Note 1: Some of the properties associated with an entity with language linkage are specific to each implementation
and are not described here. For example, a particular language linkage might be associated with a particular form of
representing names of objects and functions with external linkage, or with a particular calling convention, etc.—end
note]
The default language linkage of all function types, functions, and variables is C++ language linkage. Two
function types with different language linkages are distinct types even if they are otherwise identical.
2 Linkage (6.7) between C++ and non-C++ code fragments can be achieved using alinkage-specification:
§ 9.12 © ISO/IEC
281

===== PAGE 293 =====

Dxxxx
linkage-specification:
extern unevaluated-string { declaration-seqopt }
extern unevaluated-string name-declaration
The unevaluated-string indicates the required language linkage.
[Note 2: Escape sequences anduniversal-character-names have been replaced (5.13.6).—end note]
This document specifies the semantics for theunevaluated-strings "C" and "C++". Use of anunevaluated-string
other than"C" or "C++" is conditionally-supported, with implementation-defined semantics.
[Note 3: Therefore, alinkage-specification with a language linkage that is unknown to the implementation requires a
diagnostic. —end note]
Recommended practice: The spelling of the language linkage should be taken from the document defining
that language. For example,Ada (not ADA) andFortran or FORTRAN, depending on the vintage.
3 Every implementation shall provide for linkage to the C programming language,"C", and C++, "C++".
[Example 1:
complex sqrt(complex); // C++ language linkage by default
extern "C" {
double sqrt(double); // C language linkage
}
—end example]
4 A module-import-declaration appearing in a linkage specification with other than C++ language linkage is
conditionally-supported with implementation-defined semantics.
5 Linkage specifications nest. When linkage specifications nest, the innermost one determines the language
linkage.
[Note 4: A linkage specification does not establish a scope.—end note]
A linkage-specification shall inhabit a namespace scope. In alinkage-specification, the specified language
linkage applies to the function types of all function declarators and to all functions and variables whose
names have external linkage.
[Example 2:
extern "C" // f1 and its function type have C language linkage;
void f1(void(*pf)(int)); // pf is a pointer to a C function
extern "C" typedef void FUNC();
FUNC f2; // f2 has C++ language linkage and
// its type has C language linkage
extern "C" FUNC f3; // f3 and its type have C language linkage
void (*pf2)(FUNC*); // the variablepf2 has C++ language linkage; its type
// is “pointer to C++ function that takes one parameter of type
// pointer to C function”
extern "C" {
static void f4(); // the name of the functionf4 has internal linkage,
// sof4 has no language linkage; its type has C language linkage
}
extern "C" void f5() {
extern void f4(); // OK, name linkage (internal) and function type linkage (C language linkage)
// obtained from previous declaration.
}
extern void f4(); // OK, name linkage (internal) and function type linkage (C language linkage)
// obtained from previous declaration.
void f6() {
extern void f4(); // OK, name linkage (internal) and function type linkage (C language linkage)
// obtained from previous declaration.
}
§ 9.12 © ISO/IEC
282

===== PAGE 294 =====

Dxxxx
—end example]
A C language linkage is ignored in determining the language linkage of class members, friend functions with
a trailingrequires-clause, and the function type of non-static class member functions.
[Example 3:
extern "C" typedef void FUNC_c();
class C {
void mf1(FUNC_c*); // the functionmf1 and its type have C++ language linkage;
// the parameter has type “pointer to C function”
FUNC_c mf2; // the functionmf2 and its type have C++ language linkage
static FUNC_c* q; // the data memberq has C++ language linkage;
// its type is “pointer to C function”
};
extern "C" {
class X {
void mf(); // the functionmf and its type have C++ language linkage
void mf2(void(*)()); // the functionmf2 has C++ language linkage;
// the parameter has type “pointer to C function”
};
}
—end example]
6 If two declarations of an entity give it different language linkages, the program is ill-formed; no diagnostic is
required if neither declaration is reachable from the other. A redeclaration of an entity without a linkage
specification inherits the language linkage of the entity and (if applicable) its type.
7 Two declarations declare the same entity if they (re)introduce the same name, one declares a function or
variable with C language linkage, and the other declares such an entity or declares a variable that belongs to
the global scope.
[Example 4:
int x;
namespace A {
extern "C" int f();
extern "C" int g() { return 1; }
extern "C" int h();
extern "C" int x(); // error: same name as global-space objectx
}
namespace B {
extern "C" int f(); // A::f and B::f refer to the same function
extern "C" int g() { return 1; } // error: the functiong with C language linkage has two definitions
}
int A::f() { return 98; } // definition for the functionf with C language linkage
extern "C" int h() { return 97; } // definition for the functionh with C language linkage
// A::h and ::h refer to the same function
—end example]
8 A declaration directly contained in alinkage-specification is treated as if it contains theextern specifier (9.2.2)
for the purpose of determining the linkage of the declared name and whether it is a definition. Such a
declaration shall not have astorage-class-specifier.
[Example 5:
extern "C" double f();
static double f(); // error
extern "C" int i; // declaration
extern "C" {
int i; // definition
}
§ 9.12 © ISO/IEC
283

===== PAGE 295 =====

Dxxxx
extern "C" static void g(); // error
—end example]
9 [Note 5: Because the language linkage is part of a function type, when indirecting through a pointer to C function,
the function to which the resulting lvalue refers is considered a C function.—end note]
10 Linkage from C++ to entities defined in other languages and to entities defined in C++ from other languages
is implementation-defined and language-dependent. Only where the object layout strategies of two language
implementations are similar enough can such linkage be achieved.
9.13 Attributes [dcl.attr]
9.13.1 Attribute syntax and semantics [dcl.attr.grammar]
1 Attributes and annotations specify additional information for various source constructs such as types, variables,
names, contract assertions, blocks, or translation units.
attribute-specifier-seq:
attribute-specifier attribute-specifier-seqopt
attribute-specifier:
[ [ attribute-using-prefixopt attribute-list ] ]
[ [ annotation-list ] ]
alignment-specifier
alignment-specifier:
alignas ( type-id ...opt )
alignas ( constant-expression ...opt )
attribute-using-prefix:
using attribute-namespace :
attribute-list:
attributeopt
attribute-list , attributeopt
attribute ...
attribute-list , attribute ...
annotation-list:
annotation ...opt
annotation-list , annotation ...opt
attribute:
attribute-token attribute-argument-clauseopt
annotation:
= constant-expression
attribute-token:
identifier
attribute-scoped-token
attribute-scoped-token:
attribute-namespace :: identifier
attribute-namespace:
identifier
attribute-argument-clause:
( balanced-token-seqopt )
balanced-token-seq:
balanced-token balanced-token-seqopt
balanced-token:
( balanced-token-seqopt )
[ balanced-token-seqopt ]
{ balanced-token-seqopt }
[: balanced-token-seqopt :]
any token other than(, ), [, ], {, }, [:, or:]
2 If anattribute-specifier contains anattribute-using-prefix, theattribute-list following thatattribute-using-prefix
shall not contain anattribute-scoped-token and everyattribute-token in thatattribute-list is treated as if its
identifier were prefixed withN::, whereN is theattribute-namespace specified in theattribute-using-prefix.
§ 9.13.1 © ISO/IEC
284

===== PAGE 296 =====

Dxxxx
[Note 1: This rule imposes no constraints on how anattribute-using-prefix affects the tokens in anattribute-argument-
clause. —end note]
[Example 1:
[[using CC: opt(1), debug]] // same as[[CC::opt(1), CC::debug]]
void f() {}
[[using CC: opt(1)]] [[CC::debug]] // same as[[CC::opt(1)]] [[CC::debug]]
void g() {}
[[using CC: CC::opt(1)]] // error: cannot combineusing and scoped attribute token
void h() {}
—end example]
3 [Note 2: For each individual attribute, the form of thebalanced-token-seq will be specified. —end note]
4 In an attribute-list, an ellipsis may appear only if thatattribute’s specification permits it. An attribute
followed by an ellipsis is a pack expansion (13.7.4). Anattribute-specifier that contains anattribute-list with
no attributes has no effect. The order in which theattribute-tokens appear in anattribute-list is not significant.
If a keyword (5.12) or an alternative token (5.9) that satisfies the syntactic requirements of anidentifier (5.11)
is contained in anattribute-token, it is considered an identifier. No name lookup (6.5) is performed on any of
the identifiers contained in anattribute-token. The attribute-token determines additional requirements on the
attribute-argument-clause (if any).
5 An annotation followed by an ellipsis is a pack expansion (13.7.4).
6 Each attribute-specifier-seq is said to appertain to some entity or statement, identified by the syntactic
context where it appears (Clause 8, Clause 9, 9.3). If anattribute-specifier-seq that appertains to some
entity or statement contains anattribute or alignment-specifier that is not allowed to apply to that entity or
statement, the program is ill-formed. If anattribute-specifier-seq appertains to a friend declaration (11.8.4),
that declaration shall be a definition.
[Note 3: An attribute-specifier-seq cannot appertain to an explicit instantiation (13.9.3).—end note]
7 For anattribute-token (including anattribute-scoped-token) not specified in this document, the behavior is
implementation-defined; any suchattribute-token that is not recognized by the implementation is ignored.
[Note 4: A program is ill-formed if it contains anattribute specified in 9.13 that violates the rules specifying to which
entity or statement the attribute can apply or the syntax rules for the attribute’sattribute-argument-clause, if any.
—end note]
[Note 5: The attributes specified in 9.13 have optional semantics: given a well-formed program, removing all instances
of any one of thoseattributes results in a program whose set of possible executions (4.1.2) for a given input is a subset
of those of the original program for the same input, absent implementation-defined guarantees with respect to that
attribute. —end note]
An attribute-token is reserved for future standardization if
—(7.1) it is not anattribute-scoped-token and is not specified in this document, or
—(7.2) it is anattribute-scoped-token and itsattribute-namespace is std followed by zero or more digits.
Each implementation should choose a distinctive name for theattribute-namespace in anattribute-scoped-token.
8 Two consecutive left square bracket tokens shall appear only when introducing anattribute-specifier or within
the balanced-token-seq of anattribute-argument-clause.
[Note 6: If two consecutive left square brackets appear where anattribute-specifier is not allowed, the program is
ill-formed even if the brackets match an alternative grammar production.—end note]
[Example 2:
int p[10];
void f() {
int x = 42, y[5];
int(p[[x] { return x; }()]); // error: invalid attribute on a nesteddeclarator-id and
// not a function-style cast of an element ofp.
y[[] { return 2; }()] = 2; // error even though attributes are not allowed in this context.
int i [[vendor::attr([[]])]]; // well-formed implementation-defined attribute.
}
—end example]
§ 9.13.1 © ISO/IEC
285

===== PAGE 297 =====

Dxxxx
9.13.2 Alignment specifier [dcl.align]
1 An alignment-specifier may be applied to a variable or to a class data member, but it shall not be applied to a
bit-field, a function parameter, or anexception-declaration (14.4). An alignment-specifier may also be applied
to the declaration of a class (in anelaborated-type-specifier (9.2.9.5) orclass-head (Clause 11), respectively).
An alignment-specifier with an ellipsis is a pack expansion (13.7.4).
2 When thealignment-specifier is of the formalignas( constant-expression ):
—(2.1) the constant-expression shall be an integral constant expression
—(2.2) if the constant expression does not evaluate to an alignment value (6.8.3), or evaluates to an extended
alignment and the implementation does not support that alignment in the context of the declaration,
the program is ill-formed.
3 An alignment-specifier of the form alignas( type-id ) has the same effect as alignas(alignof( type-
id )) (7.6.2.6).
4 The alignment requirement of an entity is the strictest nonzero alignment specified by itsalignment-specifiers,
if any; otherwise, thealignment-specifiers have no effect.
5 The combined effect of allalignment-specifiers in a declaration shall not specify an alignment that is less strict
than the alignment that would be required for the entity being declared if allalignment-specifiers appertaining
to that entity were omitted.
[Example 1:
struct alignas(8) S {};
struct alignas(1) U {
S s;
}; // error: U specifies an alignment that is less strict than if thealignas(1) were omitted.
—end example]
6 If the defining declaration of an entity has analignment-specifier, any non-defining declaration of that entity
shall either specify equivalent alignment or have noalignment-specifier. Conversely, if any declaration of
an entity has analignment-specifier, every defining declaration of that entity shall specify an equivalent
alignment. No diagnostic is required if declarations of an entity have differentalignment-specifiers in different
translation units.
[Example 2:
// Translation unit #1:
struct S { int x; } s, *p = &s;
// Translation unit #2:
struct alignas(16) S; // ill-formed, no diagnostic required: definition ofS lacks alignment
extern S* p;
—end example]
7 [Example 3: An aligned buffer with an alignment requirement ofA and holdingN elements of typeT can be declared
as:
alignas(T) alignas(A) T buffer[N];
Specifying alignas(T) ensures that the final requested alignment will not be weaker thanalignof(T), and therefore
the program will not be ill-formed.—end example]
8 [Example 4:
alignas(double) void f(); // error: alignment applied to function
alignas(double) unsigned char c[sizeof(double)]; // array of characters, suitably aligned for adouble
extern unsigned char c[sizeof(double)]; // noalignas necessary
alignas(float)
extern unsigned char c[sizeof(double)]; // error: different alignment in declaration
—end example]
9.13.3 Assumption attribute [dcl.attr.assume]
1 The attribute-token assume may be applied to a null statement; such a statement is anassumption. An
attribute-argument-clause shall be present and shall have the form:
( conditional-expression )
§ 9.13.3 © ISO/IEC
286

===== PAGE 298 =====

Dxxxx
The expression is contextually converted tobool (7.3.1). The expression is not evaluated. If the converted
expression would evaluate totrue at the point where the assumption appears, the assumption has no effect.
Otherwise, evaluation of the assumption has runtime-undefined behavior.
2 [Note 1: The expression is potentially evaluated (6.3). The use of assumptions is intended to allow implementations
to analyze the form of the expression and deduce information used to optimize the program. Implementations
are not required to deduce any information from any particular assumption. It is expected that the value of a
has-attribute-expression for the assume attribute is 0 if an implementation does not attempt to deduce any such
information from assumptions. —end note]
3 [Example 1:
int divide_by_32(int x) {
[[assume(x >= 0)]];
return x/32; // The instructions produced for the division
// may omit handling of negative values.
}
int f(int y) {
[[assume(++y == 43)]]; // y is not incremented
return y; // statement may be replaced withreturn 42;
}
—end example]
9.13.4 Deprecated attribute [dcl.attr.deprecated]
1 The attribute-token deprecated can be used to mark names and entities whose use is still allowed, but is
discouraged for some reason.
[Note 1: In particular, deprecated is appropriate for names and entities that are deemed obsolescent or unsafe.
—end note]
An attribute-argument-clause may be present and, if present, it shall have the form:
( unevaluated-string )
[Note 2: The unevaluated-string in theattribute-argument-clause can be used to explain the rationale for deprecation
and/or to suggest a replacing entity.—end note]
2 The attribute may be applied to the declaration of a class, a type alias, a variable, a non-static data member,
a function, a namespace, an enumeration, an enumerator, a concept, or a template specialization.
3 An entity declared without thedeprecated attribute can later be redeclared with the attribute and vice-versa.
[Note 3: Thus, an entity initially declared without the attribute can be marked as deprecated by a subsequent
redeclaration. However, after an entity is marked as deprecated, later redeclarations do not un-deprecate the entity.
—end note]
Redeclarations using different forms of the attribute (with or without theattribute-argument-clause or with
different attribute-argument-clauses) are allowed.
4 Recommended practice: Implementations should use thedeprecatedattribute to produce a diagnostic message
in case the program refers to a name or entity other than to declare it, after a declaration that specifies
the attribute. The diagnostic message should include the text provided within theattribute-argument-clause
of anydeprecated attribute applied to the name or entity. The value of ahas-attribute-expression for the
deprecated attribute should be0 unless the implementation can issue such diagnostic messages.
9.13.5 Fallthrough attribute [dcl.attr.fallthrough]
1 The attribute-token fallthrough may be applied to a null statement (8.3); such a statement is afallthrough
statement. No attribute-argument-clause shall be present. A fallthrough statement may only appear within an
enclosing switch statement (8.5.3). The next statement that would be executed after a fallthrough statement
shall be a labeled statement whose label is a case label or default label for the sameswitch statement and, if
the fallthrough statement is contained in an iteration statement, the next statement shall be part of the same
execution of the substatement of the innermost enclosing iteration statement. The program is ill-formed if
there is no such statement. The innermost enclosingswitch statement of a fallthrough statementS shall be
contained in the innermost enclosing expansion statement (8.7) ofS, if any.
2 Recommended practice: The use of a fallthrough statement should suppress a warning that an implementation
might otherwise issue for a case or default label that is reachable from another case or default label along
some path of execution. The value of ahas-attribute-expression for thefallthrough attribute should be0
§ 9.13.5 © ISO/IEC
287

===== PAGE 299 =====

Dxxxx
if the attribute does not cause suppression of such warnings. Implementations should issue a warning if a
fallthrough statement is not dynamically reachable.
3 [Example 1:
void f(int n) {
void g(), h(), i();
switch (n) {
case 1:
case 2:
g();
[[fallthrough]];
case 3: // warning on fallthrough discouraged
do {
[[fallthrough]]; // error: next statement is not part of the same substatement execution
} while (false);
case 6:
do {
[[fallthrough]]; // error: next statement is not part of the same substatement execution
} while (n--);
case 7:
while (false) {
[[fallthrough]]; // error: next statement is not part of the same substatement execution
}
case 5:
h();
case 4: // implementation may warn on fallthrough
i();
[[fallthrough]]; // error
}
}
—end example]
9.13.6 Indeterminate storage [dcl.attr.indet]
1 The attribute-token indeterminate may be applied to the definition of a block variable with automatic
storage duration or to aparameter-declaration of a function declaration. Noattribute-argument-clause shall be
present. The attribute specifies that the storage of an object with automatic storage duration is initially
indeterminate rather than erroneous (6.8.5).
2 If a function parameter is declared with theindeterminate attribute, it shall be so declared in the first
declaration of its function. If a function parameter is declared with theindeterminate attribute in the
first declaration of its function in one translation unit and the same function is declared without the
indeterminate attribute on the same parameter in its first declaration in another translation unit, the
program is ill-formed, no diagnostic required.
3 [Note 1: Reading from an uninitialized variable that is marked[[indeterminate]] can cause undefined behavior.
void f(int);
void g() {
int x [[indeterminate]], y;
f(y); // erroneous behavior (6.8.5)
f(x); // undefined behavior
}
struct T {
T() {}
int x;
};
int h(T t [[indeterminate]]) {
f(t.x); // undefined behavior when called below
return 0;
}
int _ = h(T());
—end note]
§ 9.13.6 © ISO/IEC
288

===== PAGE 300 =====

Dxxxx
9.13.7 Likelihood attributes [dcl.attr.likelihood]
1 The attribute-tokens likely and unlikely may be applied to labels or statements. Noattribute-argument-
clause shall be present. Theattribute-token likely shall not appear in anattribute-specifier-seq that contains
the attribute-token unlikely.
2 [Note 1: The use of thelikely attribute is intended to allow implementations to optimize for the case where paths
of execution including it are arbitrarily more likely than any alternative path of execution that does not include
such an attribute on a statement or label. The use of theunlikely attribute is intended to allow implementations
to optimize for the case where paths of execution including it are arbitrarily more unlikely than any alternative
path of execution that does not include such an attribute on a statement or label. It is expected that the value of a
has-attribute-expression for thelikely and unlikely attributes is0 if the implementation does not attempt to use
these attributes for such optimizations. A path of execution includes a label if and only if it contains a jump to that
label. —end note]
[Note 2: Excessive usage of either of these attributes is liable to result in performance degradation.—end note]
3 [Example 1:
void g(int);
int f(int n) {
if (n > 5) [[unlikely]] { // n > 5 is considered to be arbitrarily unlikely
g(0);
return n * 2 + 1;
}
switch (n) {
case 1:
g(1);
[[fallthrough]];
[[likely]] case 2: // n == 2 is considered to be arbitrarily more
g(2); // likely than any other value ofn
break;
}
return 3;
}
—end example]
9.13.8 Maybe unused attribute [dcl.attr.unused]
1 The attribute-token maybe_unused indicates that a name, label, or entity is possibly intentionally unused. No
attribute-argument-clause shall be present.
2 The attribute may be applied to the declaration of a class, type alias, variable (including a structured binding
declaration), structured binding, result binding (9.4.2), non-static data member, function, enumeration, or
enumerator, or to anidentifier label (8.2).
3 A name or entity declared without themaybe_unused attribute can later be redeclared with the attribute
and vice versa. An entity is considered marked after the first declaration that marks it.
4 Recommended practice: For an entity markedmaybe_unused, implementations should not emit a warning
that the entity or its structured bindings (if any) are used or unused. For a structured binding declaration not
marked maybe_unused, implementations should not emit such a warning unless all of its structured bindings
are unused. For a label to whichmaybe_unused is applied, implementations should not emit a warning that
the label is used or unused. The value of ahas-attribute-expression for themaybe_unused attribute should be
0 if the attribute does not cause suppression of such warnings.
5 [Example 1:
[[maybe_unused]] void f([[maybe_unused]] bool thing1,
[[maybe_unused]] bool thing2) {
[[maybe_unused]] bool b = thing1 && thing2;
assert(b);
#ifdef NDEBUG
goto x;
#endif
[[maybe_unused]] x:
}
§ 9.13.8 © ISO/IEC
289

===== PAGE 301 =====

Dxxxx
Implementations should not warn thatb or x is unused, whether or notNDEBUG is defined. —end example]
9.13.9 Nodiscard attribute [dcl.attr.nodiscard]
1 The attribute-token nodiscard may be applied to a function or a lambda call operator or to the declaration
of a class or enumeration. Anattribute-argument-clause may be present and, if present, shall have the form:
( unevaluated-string )
2 A name or entity declared without thenodiscard attribute can later be redeclared with the attribute and
vice-versa.
[Note 1: Thus, an entity initially declared without the attribute can be marked asnodiscard by a subsequent
redeclaration. However, after an entity is marked asnodiscard, later redeclarations do not remove thenodiscard
from the entity.—end note]
Redeclarations using different forms of the attribute (with or without theattribute-argument-clause or with
different attribute-argument-clauses) are allowed.
3 A nodiscard typeis a (possibly cv-qualified) class or enumeration type markednodiscard in a reachable
declaration. A nodiscard callis either
—(3.1) a function call expression (7.6.1.3) that calls a function declarednodiscard in a reachable declaration
or whose return type is a nodiscard type, or
—(3.2) an explicit type conversion (7.6.1.4, 7.6.1.9, 7.6.3) that constructs an object through a constructor
declared nodiscard in a reachable declaration, or that initializes an object of a nodiscard type.
4 Recommended practice: Appearance of a nodiscard call as a potentially-evaluated discarded-value expression
(7.2) of non-void type is discouraged unless explicitly cast tovoid. Implementations should issue a warning
in such cases. The value of ahas-attribute-expression for thenodiscard attribute should be0 unless the
implementation can issue such warnings.
[Note 2: This is typically because discarding the return value of a nodiscard call has surprising consequences.—end
note]
The unevaluated-string in anodiscard attribute-argument-clause should be used in the message of the warning
as the rationale for why the result should not be discarded.
5 [Example 1:
struct [[nodiscard]] my_scopeguard { /* ... */ };
struct my_unique {
my_unique() = default; // does not acquire resource
[[nodiscard]] my_unique(int fd) { /* ... */ } // acquires resource
~my_unique() noexcept { /* ... */ } // releases resource, if any
/* ... */
};
struct [[nodiscard]] error_info { /* ... */ };
error_info enable_missile_safety_mode();
void launch_missiles();
void test_missiles() {
my_scopeguard(); // warning encouraged
(void)my_scopeguard(), // warning not encouraged, cast tovoid
launch_missiles(); // comma operator, statement continues
my_unique(42); // warning encouraged
my_unique(); // warning not encouraged
enable_missile_safety_mode(); // warning encouraged
launch_missiles();
}
error_info &foo();
void f() { foo(); } // warning not encouraged: not a nodiscard call, because neither
// the (reference) return type nor the function is declared nodiscard
—end example]
9.13.10 Noreturn attribute [dcl.attr.noreturn]
1 The attribute-token noreturn specifies that a function does not return. Noattribute-argument-clause shall
be present. The attribute may be applied to a function or a lambda call operator. The first declaration of
a function shall specify thenoreturn attribute if any declaration of that function specifies thenoreturn
§ 9.13.10 © ISO/IEC
290

===== PAGE 302 =====

Dxxxx
attribute. If a function is declared with thenoreturn attribute in one translation unit and the same function
is declared without thenoreturnattribute in another translation unit, the program is ill-formed, no diagnostic
required.
2 If a functionf is invoked wheref was previously declared with thenoreturn attribute and that invocation
eventually returns, the behavior is runtime-undefined.
[Note 1: The function can terminate by throwing an exception.—end note]
3 Recommended practice: Implementations should issue a warning if a function marked[[noreturn]] might
return. Thevalueofa has-attribute-expressionforthe noreturnattributeshouldbe 0unlesstheimplementation
can issue such warnings.
4 [Example 1:
[[ noreturn ]] void f() {
throw "error"; // OK
}
[[ noreturn ]] void q(int i) { // behavior is undefined if called with an argument<= 0
if (i > 0)
throw "positive";
}
—end example]
9.13.11 No unique address attribute [dcl.attr.nouniqueaddr]
1 The attribute-token no_unique_address specifies that a non-static data member is a potentially-overlapping
subobject (6.8.2). Noattribute-argument-clause shall be present. The attribute may appertain to a non-static
data member other than a bit-field.
2 [Note 1: The non-static data member can share the address of another non-static data member or that of a base class,
and any padding that would normally be inserted at the end of the object can be reused as storage for other members.
—end note]
Recommended practice: The value of ahas-attribute-expression for theno_unique_address attribute should
be 0 for a given implementation unless this attribute can cause a potentially-overlapping subobject to have
zero size.
[Example 1:
template<typename Key, typename Value,
typename Hash, typename Pred, typename Allocator>
class hash_map {
[[no_unique_address]] Hash hasher;
[[no_unique_address]] Pred pred;
[[no_unique_address]] Allocator alloc;
Bucket *buckets;
// ...
public:
// ...
};
Here, hasher, pred, andalloc could have the same address asbuckets if their respective types are all empty.—end
example]
9.13.12 Annotations [dcl.attr.annotation]
1 An annotation may be applied to abase-specifier or to any declaration of a type, type alias, variable, function,
namespace, enumerator, or non-static data member.
2 Let E be the expressionstd::meta::reflect_constant(constant-expression). E shall be a constant expres-
sion; the result ofE is theunderlying constantof the annotation.
3 Each annotation produces a unique annotation.
4 Substituting into anannotation is not in the immediate context.
[Example 1:
[[=1]] void f();
[[=2, =3, =2]] void g();
§ 9.13.12 © ISO/IEC
291

===== PAGE 303 =====

Dxxxx
void g [[=4, =2]] ();
f has one annotation andg has five annotations. These can be queried with metafunctions such asstd::meta::anno-
tations_of (21.4.12). —end example]
[Example 2:
template<class T>
[[=T::type()]] void f(T t);
void f(int);
void g() {
f(0); // OK
f('0'); // error, substituting into the annotation results in an invalid expression
}
—end example]
§ 9.13.12 © ISO/IEC
292

===== PAGE 304 =====

Dxxxx
10 Modules [module]
10.1 Module units and purviews [module.unit]
module-declaration:
export-keywordopt module-keyword module-name module-partitionopt attribute-specifier-seqopt ;
module-name:
module-name-qualifieropt identifier
module-partition:
: module-name-qualifieropt identifier
module-name-qualifier:
identifier .
module-name-qualifier identifier.
1 A module unitis a translation unit that contains amodule-declaration. A named moduleis the collection of
module units with the samemodule-name. The identifiersmodule and import shall not appear asidentifiers
in amodule-name or module-partition. All module-names either beginning with anidentifier consisting of
std followed by zero or moredigits or containing a reserved identifier (5.11) are reserved and shall not be
specified in amodule-declaration; no diagnostic is required. If anyidentifier in a reservedmodule-name is a
reserved identifier, the module name is reserved for use by C++ implementations; otherwise it is reserved for
future standardization. The optionalattribute-specifier-seq appertains to themodule-declaration.
2 A module interface unitis a module unit whosemodule-declaration starts withexport-keyword; any other
module unit is amodule implementation unit. A named module shall contain exactly one module interface
unit with nomodule-partition, known as theprimary module interface unitof the module; no diagnostic is
required.
3 A module partitionis a module unit whosemodule-declaration contains amodule-partition. A named module
shall not contain multiple module partitions with the samemodule-partition. All module partitions of a
module that are module interface units shall be directly or indirectly exported by the primary module
interface unit (10.3). No diagnostic is required for a violation of these rules.
[Note 1: Module partitions can be imported only by other module units in the same module. The division of a module
into module units is not visible outside the module.—end note]
4 [Example 1:
Translation unit #1:
export module A;
export import :Foo;
export int baz();
Translation unit #2:
export module A:Foo;
import :Internals;
export int foo() { return 2 * (bar() + 1); }
Translation unit #3:
module A:Internals;
int bar();
Translation unit #4:
module A;
import :Internals;
int bar() { return baz() - 10; }
int baz() { return 30; }
Module A contains four translation units:
—(4.1) a primary module interface unit,
—(4.2) a module partitionA:Foo, which is a module interface unit forming part of the interface of moduleA,
§ 10.1 © ISO/IEC
293

===== PAGE 305 =====

Dxxxx
—(4.3) a module partitionA:Internals, which does not contribute to the external interface of moduleA, and
—(4.4) a module implementation unit providing a definition ofbar and baz, which cannot be imported because it does
not have a partition name.
—end example]
5 A module unit purviewis the sequence oftokens starting at themodule-declaration and extending to the end
of the translation unit. Thepurview of a named moduleM is the set of module unit purviews ofM’s module
units.
6 The global moduleis the collection of allglobal-module-fragments and all translation units that are not module
units. Declarations appearing in such a context are said to be in thepurview of the global module.
[Note 2: The global module has no name, no module interface unit, and is not introduced by anymodule-declaration.
—end note]
7 A module is either a named module or the global module. A declaration isattached to a module as follows:
—(7.1) If the declaration is a non-dependent friend declaration that nominates a function with adeclarator-id
that is aqualified-id or template-id or that nominates a class other than with anelaborated-type-specifier
with neither anested-name-specifier nor asimple-template-id, it is attached to the module to which the
friend is attached (6.7).
—(7.2) Otherwise, if the declaration
—(7.2.1) declares a namespace whose name has external linkage,
—(7.2.2) declares a type alias,
—(7.2.3) declares a namespace alias, or
—(7.2.4) appears within alinkage-specification (9.12)
it is attached to the global module.
—(7.3) Otherwise, the declaration is attached to the module in whose purview it appears.
8 A module-declaration that contains neither anexport-keyword nor amodule-partition implicitly imports the
primary module interface unit of the module as if by amodule-import-declaration.
[Example 2:
Translation unit #1:
module B:Y; // does not implicitly importB
int y();
Translation unit #2:
export module B;
import :Y; // OK, does not create interface dependency cycle
int n = y();
Translation unit #3:
module B:X1; // does not implicitly importB
int &a = n; // error: n not visible here
Translation unit #4:
module B:X2; // does not implicitly importB
import B;
int &b = n; // OK
Translation unit #5:
module B; // implicitly importsB
int &c = n; // OK
—end example]
10.2 Export declaration [module.interface]
export-declaration:
export name-declaration
export { declaration-seqopt }
export-keyword module-import-declaration
§ 10.2 © ISO/IEC
294

===== PAGE 306 =====

Dxxxx
1 An export-declaration shall inhabit a namespace scope and appear in the purview of a module interface unit.
An export-declaration shall not appear directly or indirectly within an unnamed namespace or aprivate-
module-fragment. An export-declaration has the declarative effects of itsname-declaration, declaration-seq (if
any), ormodule-import-declaration. The name-declaration of anexport-declaration shall not declare a partial
specialization (13.7.1). Thedeclaration-seq of anexport-declaration shall not contain anexport-declaration or
module-import-declaration.
[Note 1: An export-declaration does not establish a scope.—end note]
2 A declaration isexported if it is declared within anexport-declaration and inhabits a namespace scope or it is
—(2.1) a namespace-definition that contains an exported declaration, or
—(2.2) a declaration within a header unit (10.3) that introduces at least one name.
3 If an exported declaration is not within a header unit, it shall not declare a name with internal linkage.
4 [Example 1:
Source file"a.h":
export int x;
Translation unit #1:
module;
#include "a.h" // error: declaration ofx is not in the
// purview of a module interface unit
export module M;
export namespace {} // error: namespace has internal linkage
namespace {
export int a2; // error: export of name with internal linkage
}
export static int b; // error: b explicitly declared static
export int f(); // OK
export namespace N { } // OK
export using namespace N; // OK
—end example]
5 If an exported declaration is ausing-declaration (9.10) and is not within a header unit, all entities named by
the using-declarators (if any) shall either be a type alias or have been introduced with a name having external
linkage.
[Example 2:
Source file"b.h":
int f();
Importable header"c.h":
int g();
Translation unit #1:
export module X;
export int h();
Translation unit #2:
module;
#include "b.h"
export module M;
import "c.h";
import X;
export using ::f, ::g, ::h; // OK
struct S;
export using ::S; // error: S has module linkage
namespace N {
export int h();
static int h(int); // #1
}
export using N::h; // error: #1 has internal linkage
§ 10.2 © ISO/IEC
295

===== PAGE 307 =====

Dxxxx
—end example]
[Note 2: The underlying entity of an exported type alias need not have a name with external linkage.
[Example 3:
export module M;
struct S;
export using T = S; // OK, exports nameT denoting typeS
—end example]
—end note]
6 A redeclaration of an entityX is implicitly exported ifX was introduced by an exported declaration; otherwise
it shall not be exported unless it is a type alias, a namespace, or a namespace alias.
[Example 4:
export module M;
struct S { int n; };
typedef S S;
export typedef S S; // OK
export struct S; // error: exported declaration follows non-exported declaration
namespace N { // external linkage, attached to global module, not exported
void f();
}
namespace N { // OK, exported namespace redeclaring non-exported namespace
export void g();
}
—end example]
7 [Note 3: Names introduced by exported declarations never have module linkage. They have external linkage, no
linkage, or (in the case of header units) internal linkage; see 6.7. Namespace-scope declarations exported by a module
can be found by name lookup in any translation unit importing that module (6.5). Class and enumeration member
names can be found by name lookup in any context in which a definition of the type is reachable.—end note]
[Example 5:
Interface unit ofM:
export module M;
export struct X {
static void f();
struct Y { };
};
namespace {
struct S { };
}
export void f(S); // OK
struct T { };
export T id(T); // OK
export struct A; // A exported as incomplete
export auto rootFinder(double a) {
return [=](double x) { return (x + a/x)/2; };
}
export const int n = 5; // OK,n has external linkage
Implementation unit ofM:
module M;
struct A {
int value;
};
Main program:
import M;
§ 10.2 © ISO/IEC
296

===== PAGE 308 =====

Dxxxx
int main() {
X::f(); // OK,X is exported and definition ofX is reachable
X::Y y; // OK,X::Y is exported as a complete type
auto f = rootFinder(2); // OK
return A{45}.value; // error: A is incomplete
}
—end example]
8 [Note 4: Declarations in an exportednamespace-definition or in an exportedlinkage-specification (9.12) are exported
and subject to the rules of exported declarations.
[Example 6:
export module M;
int g;
export namespace N {
int x; // OK
using ::g; // error: ::g has module linkage
}
—end example]
—end note]
10.3 Import declaration [module.import]
module-import-declaration:
import-keyword module-name attribute-specifier-seqopt ;
import-keyword module-partition attribute-specifier-seqopt ;
import-keyword header-name attribute-specifier-seqopt ;
1 A module-import-declaration shall inhabit the global namespace scope. In a module unit, all module-
import-declarations andexport-declarations exportingmodule-import-declarations shall appear before all other
declarations in thedeclaration-seq of thetranslation-unit and of theprivate-module-fragment (if any). The
optional attribute-specifier-seq appertains to themodule-import-declaration.
2 A module-import-declaration imports a set of translation units determined as described below.
[Note 1: Namespace-scope declarations exported by the imported translation units can be found by name lookup (6.5)
in the importing translation unit and declarations within the imported translation units become reachable (10.7) in
the importing translation unit after the import declaration.—end note]
3 A module-import-declaration that specifies amodule-name M imports all module interface units ofM.
4 A module-import-declaration that specifies amodule-partition shall only appear after themodule-declaration in
a module unit of some moduleM. Such a declaration imports the so-named module partition ofM.
5 A module-import-declaration that specifies aheader-name H imports a synthesizedheader unit, which is a
translation unit formed by applying phases 1 to 7 of translation (5.2) to the source file or header nominated
by H, which shall not contain amodule-declaration.
[Note 2: A header unit is a separate translation unit with an independent set of defined macros. All declarations
within a header unit are implicitly exported (10.2), and are attached to the global module (10.1).—end note]
An importable headeris a member of an implementation-defined set of headers that includes all importable C++
library headers (16.4.2.3).H shall identify an importable header. Given two suchmodule-import-declarations:
—(5.1) if theirheader-names identify different headers or source files (15.3), they import distinct header units;
—(5.2) otherwise, if they appear in the same translation unit, they import the same header unit;
—(5.3) otherwise, it is unspecified whether they import the same header unit.
[Note 3: It is therefore possible that multiple copies exist of entities declared with internal linkage in an
importable header. —end note]
[Note 4: A module-import-declaration nominating aheader-name is also recognized by the preprocessor, and results in
macros defined at the end of phase 4 of translation of the header unit being made visible as described in 15.6. Any
other module-import-declaration does not make macros visible.—end note]
6 A declaration of a name with internal linkage is permitted within a header unit despite all declarations being
implicitly exported (10.2).
[Note 5: A definition that appears in multiple translation units cannot in general refer to such names (6.3).—end
note]
§ 10.3 © ISO/IEC
297

===== PAGE 309 =====

Dxxxx
A header unit shall not contain a definition of a non-inline function or variable whose name has external
linkage.
7 When amodule-import-declaration imports a translation unitT, it also imports all translation units imported
by exportedmodule-import-declarations inT; such translation units are said to beexported by T. Additionally,
when amodule-import-declaration in a module unit of some moduleM imports another module unitU of M,
it also imports all translation units imported by non-exportedmodule-import-declarations in the module unit
purview ofU.80 These rules can in turn lead to the importation of yet more translation units.
[Note 6: Such indirect importation does not make macros available, because a translation unit is a sequence of tokens
in translation phase 7 (5.2). Macros can be made available by directly importing header units as described in 15.6.
—end note]
8 A module implementation unit shall not be exported.
[Example 1:
Translation unit #1:
module M:Part;
Translation unit #2:
export module M;
export import :Part; // error: exported partition:Part is an implementation unit
—end example]
9 A module implementation unit of a moduleM that is not a module partition shall not contain amodule-
import-declaration nominating M.
[Example 2:
module M;
import M; // error: cannot importM in its own unit
—end example]
10 A translation unit has aninterface dependencyon a translation unitU if it contains a declaration (possibly
a module-declaration) that importsU or if it has an interface dependency on a translation unit that has an
interface dependency onU. A translation unit shall not have an interface dependency on itself.
[Example 3:
Interface unit ofM1:
export module M1;
import M2;
Interface unit ofM2:
export module M2;
import M3;
Interface unit ofM3:
export module M3;
import M1; // error: cyclic interface dependencyM3 →M1 →M2 →M3
—end example]
10.4 Global module fragment [module.global.frag]
global-module-fragment:
module-keyword ; declaration-seqopt
1 A global-module-fragment specifies the contents of theglobal module fragmentfor a module unit. The global
module fragment can be used to provide declarations that are attached to the global module and usable
within the module unit.
2 A declarationD is decl-reachablefrom a declarationS in the same translation unit if
—(2.1) D does not declare a function or function template andS contains anid-expression, namespace-name,
type-name, template-name, orconcept-name naming D, or
80) This is consistent with the lookup rules for imported names (6.5).
§ 10.4 © ISO/IEC
298

===== PAGE 310 =====

Dxxxx
—(2.2) D declares a function or function template that is named by an expression (6.3) appearing inS, or
—(2.3) S contains a dependent callE (13.8.3) andD is found by any name lookup performed for an expression
synthesized fromE by replacing each type-dependent argument or operand with a value of a placeholder
type with no associated namespaces or entities, or
[Note 1: This includes the lookup foroperator== performed when considering rewriting an!= expression, the
lookup for operator<=> performed when considering rewriting a relational comparison, and the lookup for
operator!= when considering whether anoperator== is a rewrite target.—end note]
—(2.4) S contains an expression that takes the address of an overload set (12.3) that containsD and for which
the target type is dependent, or
—(2.5) there exists a declarationM that is not anamespace-definition for whichM is decl-reachable fromS
and either
—(2.5.1) D is decl-reachable fromM, or
—(2.5.2) D and M declare the same entity, andD neither is a friend declaration nor inhabits a block scope,
or
—(2.5.3) D declares a namespaceN and M is a member ofN, or
—(2.5.4) one ofD and M declares a class or class templateC and the other declares a member or friend of
C, or
—(2.5.5) one ofD and M declares an enumerationE and the other declares an enumerator ofE, or
—(2.5.6) D declares a function or variable andM is declared inD,81 or
—(2.5.7) one ofD and M declares a template and the other declares a partial or explicit specialization or
an implicit or explicit instantiation of that template, or
—(2.5.8) M declares a class template andD is a deduction guide for that template, or
—(2.5.9) one ofD and M declares a class or enumeration type and the other introduces a typedef name for
linkage purposes for that type.
In this determination, it is unspecified
—(2.6) whether a reference to analias-declaration, typedef declaration, using-declaration, ornamespace-alias-
definition is replaced by the declarations they name prior to this determination,
—(2.7) whether asimple-template-id that does not denote a dependent type and whosetemplate-name names
an alias template is replaced by its denoted type prior to this determination,
—(2.8) whether adecltype-specifier that does not denote a dependent type is replaced by its denoted type prior
to this determination,
—(2.9) whether a non-value-dependent constant expression is replaced by the result of constant evaluation
prior to this determination, and
—(2.10) whether a splice-expression, a splice-type-specifier, a splice-scope-specifier, or any splice-specifier or
splice-specialization-specifier outside of the preceding is replaced in any non-dependent context by the
construct that it designates prior to this determination.
3 A declarationD in a global module fragment of a module unit isdiscarded if D is not decl-reachable from any
declaration in thedeclaration-seq of thetranslation-unit.
[Note 2: A discarded declaration is neither reachable nor visible to name lookup outside the module unit, nor in
template instantiations whose points of instantiation (13.8.4.1) are outside the module unit, even when the instantiation
context (10.6) includes the module unit.—end note]
4 [Example 1:
const int size = 2;
int ary1[size]; // unspecified whethersize is decl-reachable fromary1
constexpr int identity(int x) { return x; }
int ary2[identity(2)]; // unspecified whetheridentity is decl-reachable fromary2
template<typename> struct S;
template<typename, int> struct S2;
constexpr int g(int);
81) A declaration can appear within alambda-expression in the initializer of a variable.
§ 10.4 © ISO/IEC
299

===== PAGE 311 =====

Dxxxx
template<typename T, int N>
S<S2<T, g(N)>> f(); // S, S2, g, and :: are decl-reachable fromf
template<int N>
void h() noexcept(g(N) == N); // g and :: are decl-reachable fromh
—end example]
5 [Example 2:
Source file"foo.h":
namespace N {
struct X {};
int d();
int e();
inline int f(X, int = d()) { return e(); }
int g(X);
int h(X);
}
Module M interface:
module;
#include "foo.h"
export module M;
template<typename T> int use_f() {
N::X x; // N::X, N, and :: are decl-reachable fromuse_f
return f(x, 123); // N::f is decl-reachable fromuse_f,
// N::e is indirectly decl-reachable fromuse_f
// because it is decl-reachable fromN::f, and
// N::d is decl-reachable fromuse_f
// because it is decl-reachable fromN::f
// even though it is not used in this call
}
template<typename T> int use_g() {
N::X x; // N::X, N, and :: are decl-reachable fromuse_g
return g((T(), x)); // N::g is not decl-reachable fromuse_g
}
template<typename T> int use_h() {
N::X x; // N::X, N, and :: are decl-reachable fromuse_h
return h((T(), x)); // N::h is not decl-reachable fromuse_h, but
// N::h is decl-reachable fromuse_h<int>
}
int k = use_h<int>();
// use_h<int> is decl-reachable fromk, so
// N::h is decl-reachable fromk
Module M implementation:
module M;
int a = use_f<int>(); // OK
int b = use_g<int>(); // error: no viable function for call tog;
// g is not decl-reachable from purview of
// moduleM’s interface, so is discarded
int c = use_h<int>(); // OK
—end example]
10.5 Private module fragment [module.private.frag]
private-module-fragment:
module-keyword : private ;declaration-seqopt
1 A private-module-fragment shall appear only in a primary module interface unit (10.1). A module unit with a
private-module-fragment shall be the only module unit of its module; no diagnostic is required.
2 [Note 1: A private-module-fragment ends the portion of the module interface unit that can affect the behavior of other
translation units. Aprivate-module-fragment allows a module to be represented as a single translation unit without
making all of the contents of the module reachable to importers. The presence of aprivate-module-fragment affects:
§ 10.5 © ISO/IEC
300

===== PAGE 312 =====

Dxxxx
—(2.1) the point by which the definition of an inline function or variable is required (9.2.8),
—(2.2) the point by which the definition of an exported function with a placeholder return type is required (9.2.9.7),
—(2.3) whether a declaration is required not to be an exposure (6.7),
—(2.4) where definitions for inline functions and templates must appear (6.3, 9.2.8, 13.1),
—(2.5) the instantiation contexts of templates instantiated before it (10.6), and
—(2.6) the reachability of declarations within it (10.7).
—end note]
3 [Example 1:
export module A;
export inline void fn_e(); // error: exported inline functionfn_e not defined
// before private module fragment
inline void fn_m(); // error: non-exported inline functionfn_m not defined
static void fn_s();
export struct X;
export void g(X *x) {
fn_s(); // OK, call to static function in same translation unit
}
export X *factory(); // OK
module :private;
struct X {}; // definition not reachable from importers ofA
X *factory() {
return new X ();
}
void fn_e() {}
void fn_m() {}
void fn_s() {}
—end example]
10.6 Instantiation context [module.context]
1 The instantiation contextis a set of points within the program that determines which declarations are found
by argument-dependent name lookup (6.5.4) and which are reachable (10.7) in the context of a particular
declaration or template instantiation.
2 During the implicit definition of a defaulted function (11.4.4, 11.10.1), the instantiation context contains
each point in the instantiation context from the definition of the class and each point in the instantiation
context of the program construct that resulted in the implicit definition of the defaulted function.
3 During the implicit instantiation of a template whose point of instantiation is specified as that of an enclosing
specialization (13.8.4.1), the instantiation context contains each point in the instantiation context of the
enclosing specialization and, if the template is defined in a module interface unit of a moduleM and the
point of instantiation is not in a module interface unit ofM, the point at the end of thedeclaration-seq of the
primary module interface unit ofM (prior to theprivate-module-fragment, if any).
4 During the implicit instantiation of a template that is implicitly instantiated because it is referenced from
within the implicit definition of a defaulted function, the instantiation context contains each point in the
instantiation context of the defaulted function.
5 During the instantiation of any other template specialization, the instantiation context contains the point of
instantiation of the template.
6 During the implicit instantiation of any construct that resulted from the evaluation of an expression as a
core constant expression, the instantiation context contains each point in the evaluation context (7.7).
[Note 1: Implicit instantiations can result from invocations of library functions (21.4). The evaluation context can
include synthesized points associated with injected declarations produced bystd::meta::define_aggregate (21.4.16).
—end note]
7 In any other case, the instantiation context at a point within the program contains that point.
8 The instantiation context contains only the points specified above.
§ 10.6 © ISO/IEC
301

===== PAGE 313 =====

Dxxxx
9 [Example 1:
Translation unit #1:
export module stuff;
export template<typename T, typename U> void foo(T, U u) { auto v = u; }
export template<typename T, typename U> void bar(T, U u) { auto v = *u; }
Translation unit #2:
export module M1;
import "defn.h"; // providesstruct X {};
import stuff;
export template<typename T> void f(T t) {
X x;
foo(t, x);
}
Translation unit #3:
export module M2;
import "decl.h"; // providesstruct X; (not a definition)
import stuff;
export template<typename T> void g(T t) {
X *x;
bar(t, x);
}
Translation unit #4:
import M1;
import M2;
void test() {
f(0);
g(0);
}
The call tof(0) is valid; the instantiation context offoo<int, X> comprises
—(9.1) the point at the end of translation unit #1,
—(9.2) the point at the end of translation unit #2, and
—(9.3) the point of the call tof(0),
so the definition ofX is reachable (10.7).
It is unspecified whether the call tog(0) is valid: the instantiation context ofbar<int, X> comprises
—(9.4) the point at the end of translation unit #1,
—(9.5) the point at the end of translation unit #3, and
—(9.6) the point of the call tog(0),
so the definition ofX need not be reachable, as described in 10.7.—end example]
10.7 Reachability [module.reach]
1 A translation unitU is necessarily reachablefrom a pointP if U is a module interface unit on which the
translation unit containingP has an interface dependency, or the translation unit containingP imports U,
in either case prior toP (10.3).
[Note 1: While module interface units are reachable even when they are only transitively imported via a non-exported
import declaration, namespace-scope names from such module interface units are not found by name lookup (6.5).
—end note]
2 All translation units that are necessarily reachable arereachable. Additional translation units on which the
point within the program has an interface dependency may be considered reachable, but it is unspecified
which are and under what circumstances.82
[Note 2: It is advisable to avoid depending on the reachability of any additional translation units in programs intending
to be portable. —end note]
82) Implementations are therefore not required to prevent the semantic effects of additional translation units involved in the
compilation from being observed.
§ 10.7 © ISO/IEC
302

===== PAGE 314 =====

Dxxxx
3 A declarationD is reachable froma pointP if
—(3.1) P is a non-synthesized point and
—(3.1.1) D appears prior toP in the same translation unit, or
—(3.1.2) D is not discarded (10.4), appears in a translation unit that is reachable fromP, and does not
appear within aprivate-module-fragment; or
—(3.2) D is the injected declaration for whichP is the corresponding synthesized point.
[Example 1:
class Incomplete;
consteval {
int n = nonstatic_data_members_of(
define_aggregate(^^Incomplete, {data_member_spec(^^int, {.name="x"})}),
std::meta::access_context::current()
).size();
Incomplete y; // error: type ofy is incomplete
}
/∗ P ∗/
The value ofn is 1. The memberIncomplete::x members-of-precedes (21.4.10) the synthesized point P associated
with the injected declaration produced by the call todefine_aggregate. —end example]
4 A declaration isreachable if it is reachable from any point in the instantiation context (10.6).
[Note 3: Whether a declaration is exported has no bearing on whether it is reachable.—end note]
5 The accumulated properties of all reachable declarations of an entity within a context determine the behavior
of the entity within that context.
[Note 4: These reachable semantic properties include type completeness, type definitions, initializers, default arguments
of functions or template declarations, attributes, names bound, etc. Since default arguments are evaluated in the
context of the call expression, the reachable semantic properties of the corresponding parameter types apply in that
context.
[Example 2:
Translation unit #1:
export module M:A;
export struct B;
Translation unit #2:
module M:B;
struct B {
operator int();
};
Translation unit #3:
module M:C;
import :A;
B b1; // error: no reachable definition ofstruct B
Translation unit #4:
export module M;
export import :A;
import :B;
B b2;
export void f(B b = B());
Translation unit #5:
import M;
B b3; // error: no reachable definition ofstruct B
void g() { f(); } // error: no reachable definition ofstruct B
—end example]
§ 10.7 © ISO/IEC
303

===== PAGE 315 =====

Dxxxx
—end note]
6 [Note 5: Declarations of an entity can be reachable even where they cannot be found by name lookup.—end note]
[Example 3:
Translation unit #1:
export module A;
struct X {};
export using Y = X;
Translation unit #2:
import A;
Y y; // OK, definition ofX is reachable
X x; // error: X not visible to unqualified lookup
—end example]
§ 10.7 © ISO/IEC
304

===== PAGE 316 =====

Dxxxx
11 Classes [class]
11.1 Preamble [class.pre]
1 A class is a type. Its name becomes aclass-name (11.3) within its scope.
class-name:
identifier
simple-template-id
A class-specifier or anelaborated-type-specifier (9.2.9.5) is used to make aclass-name. An object of a class
consists of a (possibly empty) sequence of members and base class objects.
class-specifier:
class-head { member-specificationopt }
class-head:
class-key attribute-specifier-seqopt class-head-name class-property-specifier-seqopt base-clauseopt
class-key attribute-specifier-seqopt base-clauseopt
class-head-name:
nested-name-specifieropt class-name
class-property-specifier-seq:
class-property-specifier class-property-specifier-seqopt
class-property-specifier:
final
class-key:
class
struct
union
A class declaration where theclass-name in theclass-head-name is asimple-template-id shall be an explicit
specialization (13.9.4) or a partial specialization (13.7.6). A class-specifier whose class-head omits the
class-head-name defines anunnamed class.
[Note 1: An unnamed class thus can’t befinal. —end note]
Otherwise, theclass-name is anidentifier; it is not looked up, and theclass-specifier introduces it.
2 The component name of theclass-name is also bound in the scope of the class (template) itself; this is known
as theinjected-class-name. For purposes of access checking, the injected-class-name is treated as if it were a
public member name. Aclass-specifier is commonly referred to as aclass definition. A class is considered
defined after the closing brace of itsclass-specifier has been seen even though its member functions are in
general not yet defined. The optionalattribute-specifier-seq appertains to the class; the attributes in the
attribute-specifier-seq are thereafter considered attributes of the class whenever it is named.
3 If aclass-head-name contains anested-name-specifier, theclass-specifier shall not inhabit a class scope. If its
class-name is anidentifier, theclass-specifier shall correspond to one or more declarations nominable in the
class, class template, or namespace to which thenested-name-specifier refers; they shall all have the same
target scope, and the target scope of theclass-specifier is that scope.
[Example 1:
namespace N {
template<class>
struct A {
struct B;
};
}
using N::A;
template<class T> struct A<T>::B {}; // OK
template<> struct A<void> {}; // OK
—end example]
§ 11.1 © ISO/IEC
305

===== PAGE 317 =====

Dxxxx
4 [Note 2: The class-key determines whether the class is a union (11.5) and whether access is public or private by
default (11.8). A union holds the value of at most one data member at a time.—end note]
5 Each class-property-specifier shall appear at most once within a singleclass-property-specifier-seq. Whenever a
class-key is followed by aclass-head-name, the identifierfinal, and a colon or left brace, the identifier is
interpreted as aclass-property-specifier.
[Example 2:
struct A;
struct A final {}; // OK, definition ofstruct A,
// not value-initialization of variablefinal
struct X {
struct C { constexpr operator int() { return 5; } };
struct B final : C{}; // OK, definition of nested classB,
// not declaration of a bit-field memberfinal
};
—end example]
6 If a class is marked with theclass-property-specifier final and that class appears as aclass-or-decltype in a
base-clause (11.7), the program is ill-formed.
7 [Note 3: Complete objects of class type have nonzero size. Base class subobjects and members declared with the
no_unique_address attribute (9.13.11) are not so constrained.—end note]
8 [Note 4: Class objects can be assigned (12.4.3.2, 11.4.6), passed as arguments to functions (9.5, 11.4.5.3), and returned
by functions (except objects of classes for which copying or moving has been restricted; see 9.6.3 and 11.8). Other
plausible operators, such as equality comparison, can be defined by the user; see 12.4.—end note]
11.2 Properties of classes [class.prop]
1 A trivially copyable classis a class:
—(1.1) that has at least one eligible copy constructor, move constructor, copy assignment operator, or move
assignment operator (11.4.4, 11.4.5.3, 11.4.6),
—(1.2) where each eligible copy constructor, move constructor, copy assignment operator, and move assignment
operator is trivial, and
—(1.3) that has a trivial, non-deleted destructor (11.4.7).
2 A classS is astandard-layout classif it:
—(2.1) has no non-static data members of type non-standard-layout class (or array of such types) or reference,
—(2.2) has no virtual functions (11.7.3) and no virtual base classes (11.7.2),
—(2.3) has the same access control (11.8) for all non-static data members,
—(2.4) has no non-standard-layout base classes,
—(2.5) has at most one base class subobject of any given type,
—(2.6) has all non-static data members and bit-fields in the class and its base classes first declared in the same
class, and
—(2.7) has no element of the setM(S) of types as a base class, where for any typeX, M(X) is defined as
follows.83
[Note 1: M(X) is the set of the types of all non-base-class subobjects that can be at a zero offset inX. —end
note]
—(2.7.1) If X is a non-union class type with no non-static data members, the setM(X) is empty.
—(2.7.2) If X is a non-union class type with a non-static data member of typeX0 that is either of zero size
or is the first non-static data member ofX (where said member may be an anonymous union), the
set M(X) consists ofX0 and the elements ofM(X0).
—(2.7.3) If X is a union type, the setM(X) is the union of allM(Ui) and the set containing allUi, where
each Ui is the type of theith non-static data member ofX.
83) This ensures that two subobjects that have the same class type and that belong to the same most derived object are not
allocated at the same address (7.6.10).
§ 11.2 © ISO/IEC
306

===== PAGE 318 =====

Dxxxx
—(2.7.4) If X is an array type with element typeXe, the setM(X) consists ofXe and the elements ofM(Xe).
—(2.7.5) If X is a non-class, non-array type, the setM(X) is empty.
3 [Example 1:
struct B { int i; }; // standard-layout class
struct C : B { }; // standard-layout class
struct D : C { }; // standard-layout class
struct E : D { char : 4; }; // not a standard-layout class
struct Q {};
struct S : Q { };
struct T : Q { };
struct U : S, T { }; // not a standard-layout class
—end example]
4 A standard-layout structis a standard-layout class defined with theclass-key struct or theclass-key class.
A standard-layout unionis a standard-layout class defined with theclass-key union.
5 [Note 2: Standard-layout classes are useful for communicating with code written in other programming languages.
Their layout is specified in 11.4.1 and 7.6.9.—end note]
6 [Example 2:
struct N { // neither trivially copyable nor standard-layout
int i;
int j;
virtual ~N();
};
struct T { // trivially copyable but not standard-layout
int i;
private:
int j;
};
struct SL { // standard-layout but not trivially copyable
int i;
int j;
~SL();
};
struct POD { // both trivially copyable and standard-layout
int i;
int j;
};
—end example]
7 [Note 3: Aggregates of class type are described in 9.5.2.—end note]
8 A classS is animplicit-lifetime classif
—(8.1) it is an aggregate whose destructor is not user-provided or
—(8.2) it has at least one trivial eligible constructor and a trivial, non-deleted destructor.
11.3 Class names [class.name]
1 A class definition introduces a new type.
[Example 1:
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
declares three variables of three different types. This implies that
a1 = a2; // error: Y assigned toX
§ 11.3 © ISO/IEC
307

===== PAGE 319 =====

Dxxxx
a1 = a3; // error: int assigned toX
are type mismatches, and that
int f(X);
int f(Y);
declare overloads (Clause 12) namedf and not simply a single functionf twice. For the same reason,
struct S { int a; };
struct S { int a; }; // error: double definition
is ill-formed because it definesS twice. —end example]
2 [Note 1: It can be necessary to use anelaborated-type-specifier to refer to a class that belongs to a scope in which its
name is also bound to a variable, function, or enumerator (6.5.6).
[Example 2:
struct stat {
// ...
};
stat gstat; // use plainstat to define variable
int stat(struct stat*); // stat now also names a function
void f() {
struct stat* ps; // struct prefix needed to namestruct stat
stat(ps); // call stat function
}
—end example]
An elaborated-type-specifier can also be used to declare anidentifier as aclass-name.
[Example 3:
struct s { int a; };
void g() {
struct s; // hide globalstruct s with a block-scope declaration
s* p; // refer to localstruct s
struct s { char* p; }; // define localstruct s
struct s; // redeclaration, has no effect
}
—end example]
Such declarations allow definition of classes that refer to each other.
[Example 4:
class Vector;
class Matrix {
// ...
friend Vector operator*(const Matrix&, const Vector&);
};
class Vector {
// ...
friend Vector operator*(const Matrix&, const Vector&);
};
Declaration of friends is described in 11.8.4, operator functions in 12.4.—end example]
—end note]
3 [Note 2: An elaborated-type-specifier (9.2.9.5) can also be used as atype-specifier as part of a declaration. It differs
from a class declaration in that it can refer to an existing class of the given name.—end note]
[Example 5:
struct s { int a; };
§ 11.3 © ISO/IEC
308

===== PAGE 320 =====

Dxxxx
void g(int s) {
struct s* p = new struct s; // globals
p->a = s; // parameters
}
—end example]
4 [Note 3: The declaration of a class name takes effect immediately after theidentifier is seen in the class definition or
elaborated-type-specifier.
[Example 6:
class A * A;
first specifiesA to be the name of a class and then redefines it as the name of a pointer to an object of that class.
This means that the elaborated formclass A must be used to refer to the class. Such artistry with names can be
confusing and is best avoided.—end example]
—end note]
5 A simple-template-id is only aclass-name if itstemplate-name names a class template.
11.4 Class members [class.mem]
11.4.1 General [class.mem.general]
member-specification:
member-declaration member-specificationopt
access-specifier : member-specificationopt
member-declaration:
attribute-specifier-seqopt decl-specifier-seqopt member-declarator-listopt ;
function-definition
friend-type-declaration
using-declaration
using-enum-declaration
static_assert-declaration
consteval-block-declaration
template-declaration
explicit-specialization
deduction-guide
alias-declaration
opaque-enum-declaration
empty-declaration
member-declarator-list:
member-declarator
member-declarator-list , member-declarator
member-declarator:
declarator virt-specifier-seqopt function-contract-specifier-seqopt pure-specifieropt
declarator requires-clause function-contract-specifier-seqopt
declarator brace-or-equal-initializer
identifieropt attribute-specifier-seqopt : constant-expression brace-or-equal-initializeropt
virt-specifier-seq:
virt-specifier virt-specifier-seqopt
virt-specifier:
override
final
pure-specifier:
= 0
friend-type-declaration:
friend friend-type-specifier-list ;
friend-type-specifier-list:
friend-type-specifier ...opt
friend-type-specifier-list , friend-type-specifier ...opt
§ 11.4.1 © ISO/IEC
309

===== PAGE 321 =====

Dxxxx
friend-type-specifier:
simple-type-specifier
elaborated-type-specifier
typename-specifier
1 In the absence of avirt-specifier-seq, the token sequence= 0 is treated as apure-specifier if the type of the
declarator-id (9.3.4.1) is a function type, and is otherwise treated as abrace-or-equal-initializer.
[Note 1: If the member declaration acquires a function type through template instantiation, the program is ill-formed;
see 13.9.1. —end note]
2 The optionalfunction-contract-specifier-seq (9.4.1) in amember-declarator shall be present only if thedeclarator
declares a function.
3 The member-specification in a class definition declares the full set of members of the class; no member
can be added elsewhere. A direct member of a classX is a member ofX that was first declared within
the member-specification of X, including anonymous union members (11.5.2) and direct members thereof.
Members of a class are data members, member functions (11.4.2), nested types, enumerators, and member
templates (13.7.3) and specializations thereof.
[Note 2: A specialization of a static data member template is a static data member. A specialization of a member
function template is a member function. A specialization of a member class template is a nested class.—end note]
4 A member-declaration does not itself declare new members of the class if it is
—(4.1) a friend declaration (11.8.4),
—(4.2) a deduction-guide (13.7.2.3),
—(4.3) a template-declaration whose declaration is one of the above,
—(4.4) a static_assert-declaration,
—(4.5) a consteval-block-declaration,
—(4.6) a using-declaration (9.10), or
—(4.7) an empty-declaration.
For any othermember-declaration, each declared entity that is not an unnamed bit-field (11.4.10) is a member
of the class, and each suchmember-declaration shall either declare at least one member name of the class or
declare at least one unnamed bit-field.
5 A data memberis either a non-function member introduced by amember-declarator or an anonymous union
member. A member functionis a member that is a function. Nested types are classes (11.3, 11.4.12) and
enumerations (9.8.1) declared in the class and arbitrary types declared as members by use of a typedef
declaration (9.2.4) oralias-declaration. The enumerators of an unscoped enumeration (9.8.1) defined in the
class are members of the class.
6 A data member or member function may be declaredstatic in itsmember-declaration, in which case it is a
static member(see 11.4.9) (astatic data member(11.4.9.3) orstatic member function(11.4.9.2), respectively)
of the class. Any other data member or member function is anon-static member(a non-static data member
or non-static member function(11.4.3), respectively).
7 Every object of class type has a unique member subobject corresponding to each of its direct non-static data
members. If any non-static data member of a classC is of reference type, then letD be an invented class that
is identical toC except that each non-static member ofD corresponding to a member ofC of type “reference
to T” instead has type “pointer toT”. Every member subobject of a complete object of typeC has the same
size, alignment, and offset as that of the corresponding subobject of a complete object of typeD. The size
and alignment ofC are the same as the size and alignment ofD.
8 A member shall not be declared twice in themember-specification, except that
—(8.1) a nested class or member class template can be declared and then later defined, and
—(8.2) an enumeration can be introduced with anopaque-enum-declaration and later redeclared with an
enum-specifier.
[Note 3: A single name can denote several member functions provided their types are sufficiently different (6.4.1).
—end note]
9 A redeclaration of a class member outside its class definition shall be a definition, an explicit specialization,
or an explicit instantiation (13.9.4, 13.9.3). The member shall not be a non-static data member.
§ 11.4.1 © ISO/IEC
310

===== PAGE 322 =====

Dxxxx
10 A complete-class contextof a class (template) is a
—(10.1) function body (9.6.1),
—(10.2) default argument (9.3.4.7),
—(10.3) default template argument (13.2),
—(10.4) noexcept-specifier (14.5),
—(10.5) function-contract-specifier (9.4.1), or
—(10.6) default member initializer
within themember-specification of the class or class template.
[Note 4: A complete-class context of a nested class is also a complete-class context of any enclosing class, if the nested
class is defined within themember-specification of the enclosing class.—end note]
11 A classC is complete at a program pointP if the definition ofC is reachable fromP (10.7) or ifP is in a
complete-class context ofC. Otherwise, C is incomplete atP.
12 If a member-declaration matches the syntactic requirements offriend-type-declaration, it is afriend-type-
declaration.
13 In amember-declarator, an= immediately following thedeclarator is interpreted as introducing apure-specifier
if thedeclarator-id has function type, otherwise it is interpreted as introducing abrace-or-equal-initializer.
[Example 1:
struct S {
using T = void();
T * p = 0; // OK,brace-or-equal-initializer
virtual T f = 0; // OK,pure-specifier
};
—end example]
14 In amember-declarator for a bit-field, theconstant-expression is parsed as the longest sequence of tokens that
could syntactically form aconstant-expression.
[Example 2:
int a;
const int b = 0;
struct S {
int x1 : 8 = 42; // OK,"= 42" is brace-or-equal-initializer
int x2 : 8 { 42 }; // OK,"{ 42 }" is brace-or-equal-initializer
int y1 : true ? 8 : a = 42; // OK,brace-or-equal-initializer is absent
int y2 : true ? 8 : b = 42; // error: cannot assign toconst int
int y3 : (true ? 8 : b) = 42; // OK,"= 42" is brace-or-equal-initializer
int z : 1 || new int { 0 }; // OK,brace-or-equal-initializer is absent
};
—end example]
15 A brace-or-equal-initializer shall appear only in the declaration of a data member. (For static data members,
see 11.4.9.3; for non-static data members, see 11.9.3 and 9.5.2). Abrace-or-equal-initializer for a non-static
data member specifies adefault member initializerfor the member, and shall not directly or indirectly cause
the implicit definition of a defaulted default constructor for the enclosing class or the exception specification
of that constructor. An immediate invocation (7.7) that is a potentially-evaluated subexpression (6.10.1) of
a default member initializer is neither evaluated nor checked for whether it is a constant expression at the
point where the subexpression appears.
16 A member shall not be declared with theextern storage-class-specifier. Within a class definition, a member
shall not be declared with thethread_local storage-class-specifier unless also declaredstatic.
17 The decl-specifier-seq may be omitted in constructor, destructor, and conversion function declarations only;
when declaring another kind of member thedecl-specifier-seq shall contain atype-specifier that is not a
cv-qualifier. The member-declarator-list can be omitted only after aclass-specifier or anenum-specifier or in a
friend declaration (11.8.4). Apure-specifier shall be used only in the declaration of a virtual function (11.7.3)
that is not a friend declaration.
§ 11.4.1 © ISO/IEC
311

===== PAGE 323 =====

Dxxxx
18 The optionalattribute-specifier-seq in amember-declaration appertains to each of the entities declared by the
member-declarators; it shall not appear if the optionalmember-declarator-list is omitted.
19 A virt-specifier-seq shall contain at most one of eachvirt-specifier. A virt-specifier-seq shall appear only in the
first declaration of a virtual member function (11.7.3).
20 The type of a non-static data member shall not be an incomplete type (6.9.1), an abstract class type (11.7.4),
or a (possibly multidimensional) array thereof.
[Note 5: In particular, a classC cannot contain a non-static member of classC, but it can contain a pointer or reference
to an object of classC. —end note]
21 [Note 6: See 7.5.5 for restrictions on the use of non-static data members and non-static member functions.—end
note]
22 [Note 7: The type of a non-static member function is an ordinary function type, and the type of a non-static data
member is an ordinary object type. There are no special member function types or data member types.—end note]
23 [Example 3: A simple example of a class definition is
struct tnode {
char tword[20];
int count;
tnode* left;
tnode* right;
};
which contains an array of twenty characters, an integer, and two pointers to objects of the same type. Once this
definition has been given, the declaration
tnode s, *sp;
declares s to be a tnode and sp to be a pointer to atnode. With these declarations, sp->count refers to the
count member of the object to whichsp points; s.left refers to theleft subtree pointer of the objects; and
s.right->tword[0] refers to the initial character of thetword member of theright subtree ofs. —end example]
24 [Note 8: Non-variant non-static data members of non-zero size (6.8.2) are allocated so that later members have higher
addresses within a class object (7.6.9). Implementation alignment requirements can cause two adjacent members not
to be allocated immediately after each other; so can requirements for space for managing virtual functions (11.7.3)
and virtual base classes (11.7.2).—end note]
25 If T is the name of a class, then each of the following shall have a name different fromT:
—(25.1) every static data member of classT;
—(25.2) every member function of classT;
[Note 9: This restriction does not apply to constructors, which do not have names (11.4.5).—end note]
—(25.3) every member of classT that is itself a type;
—(25.4) every member template of classT;
—(25.5) every enumerator of every member of classT that is an unscoped enumeration type; and
—(25.6) every member of every anonymous union that is a member of classT.
26 In addition, if classT has a user-declared constructor (11.4.5), every non-static data member of classT shall
have a name different fromT.
27 The common initial sequenceof two standard-layout struct (11.2) types is the longest sequence of non-static
data members and bit-fields in declaration order, starting with the first such entity in each of the structs,
such that
—(27.1) corresponding entities have layout-compatible types (6.9),
—(27.2) corresponding entities have the same alignment requirements (6.8.3),
—(27.3) if ahas-attribute-expression (15.2) is not0 for theno_unique_address attribute, then neither entity is
declared with theno_unique_address attribute (9.13.11), and
—(27.4) either both entities are bit-fields with the same width or neither is a bit-field.
[Example 4:
struct A { int a; char b; };
struct B { const int b1; volatile char b2; };
struct C { int c; unsigned : 0; char b; };
§ 11.4.1 © ISO/IEC
312

===== PAGE 324 =====

Dxxxx
struct D { int d; char b : 4; };
struct E { unsigned int e; char b; };
The common initial sequence ofA and B comprises all members of either class. The common initial sequence ofA and
C and ofA and D comprises the first member in each case. The common initial sequence ofA and E is empty. —end
example]
28 Two standard-layout struct (11.2) types arelayout-compatible classes if their common initial sequence
comprises all members and bit-fields of both classes (6.9).
29 Two standard-layout unions are layout-compatible if they have the same number of non-static data members
and corresponding non-static data members (in any order) have layout-compatible types (6.9.1).
30 In a standard-layout union with an active member (11.5) of struct typeT1, it is permitted to read a non-static
data memberm of another union member of struct typeT2 provided m is part of the common initial sequence
of T1 and T2; the behavior is as if the corresponding member ofT1 were nominated.
[Example 5:
struct T1 { int a, b; };
struct T2 { int c; double d; };
union U { T1 t1; T2 t2; };
int f() {
U u = { { 1, 2 } }; // active member ist1
return u.t2.c; // OK, as ifu.t1.a were nominated
}
—end example]
[Note 10: Reading a volatile object through a glvalue of non-volatile type has undefined behavior (9.2.9.2).—end
note]
31 If a standard-layout class object has any non-static data members, its address is the same as the address of
its first non-static data member if that member is not a bit-field. Its address is also the same as the address
of each of its base class subobjects.
[Note 11: There can therefore be unnamed padding within a standard-layout struct object inserted by an implementa-
tion, but not at its beginning, as necessary to achieve appropriate alignment.—end note]
[Note 12: The object and its first subobject are pointer-interconvertible (6.9.4, 7.6.1.9).—end note]
32 A data member descriptionis a quintuple (T, N, A, W, NUA) describing the potential declaration of a
non-static data member where
—(32.1) T is a type,
—(32.2) N is anidentifier or ⊥,
—(32.3) A is an alignment or⊥,
—(32.4) W is a bit-field width or⊥, and
—(32.5) NUA is a boolean value.
Two data member descriptions are equal if each of their respective components are the same entities, are the
same identifiers, have equal values, or are both⊥.
[Note 13: The components of a data member description describe a data member such that
—(32.6) its type is specified using the type given byT,
—(32.7) it is declared with the name given byN if N is not⊥and is otherwise unnamed,
—(32.8) it is declared with thealignment-specifier (9.13.2) given byalignas(A) if A is not⊥and is otherwise declared
without analignment-specifier,
—(32.9) it is a bit-field (11.4.10) with the width given byW if W is not⊥and is otherwise not a bit-field, and
—(32.10) it is declared with the attribute[[no_unique_address]] (9.13.11) ifNUA is true and is otherwise declared
without that attribute.
Data member descriptions are represented by reflections (6.9.2) returned bystd::meta::data_member_spec (21.4.16)
and can be reified as data members of a class usingstd::meta::define_aggregate. —end note]
11.4.2 Member functions [class.mfct]
1 If a member function is attached to the global module and is defined (9.6) in its class definition, it is
inline (9.2.8).
§ 11.4.2 © ISO/IEC
313

===== PAGE 325 =====

Dxxxx
[Note 1: A member function is also inline if it is declaredinline, constexpr, orconsteval. —end note]
2 [Example 1:
struct X {
typedef int T;
static T count;
void f(T);
};
void X::f(T t = count) { }
The definition of the member functionf of classX inhabits the global scope; the notationX::f indicates that the
function f is a member of classX and in the scope of classX. In the function definition, the parameter typeT refers to
the typedef memberT declared in classX and the default argumentcount refers to the static data membercount
declared in classX. —end example]
3 Member functions of a local class shall be defined inline in their class definition, if they are defined at all.
4 [Note 2: A member function can be declared (but not defined) using a typedef for a function type. The resulting
member function has exactly the same type as it would have if the function declarator were provided explicitly,
see 9.3.4.6 and 13.4.
[Example 2:
typedef void fv();
typedef void fvc() const;
struct S {
fv memfunc1; // equivalent to:void memfunc1();
void memfunc2();
fvc memfunc3; // equivalent to:void memfunc3() const;
};
fv S::* pmfv1 = &S::memfunc1;
fv S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;
—end example]
—end note]
11.4.3 Non-static member functions [class.mfct.non.static]
1 A non-static member function may be called for an object of its class type, or for an object of a class
derived (11.7) from its class type, using the class member access syntax (7.6.1.5, 12.2.2.2). A non-static
member function may also be called directly using the function call syntax (7.6.1.3, 12.2.2.2) from within its
class or a class derived from its class, or a member thereof, as described below.
2 [Note 1: An implicit object member function can be declared withcv-qualifiers, which affect the type of thethis
pointer (7.5.3), and/or aref-qualifier (9.3.4.6); both affect overload resolution (12.2.2).—end note]
3 An implicit object member function may be declared virtual (11.7.3) or pure virtual (11.7.4).
11.4.4 Special member functions [special]
1 Default constructors (11.4.5.2), copy constructors, move constructors (11.4.5.3), copy assignment operators,
move assignment operators (11.4.6), and prospective destructors (11.4.7) arespecial member functions.
[Note 1: The implementation will implicitly declare these member functions for some class types when the program
does not explicitly declare them. The implementation will implicitly define them as needed (9.6.2).—end note]
An implicitly-declared special member function is declared at the closing} of theclass-specifier. Programs
shall not define implicitly-declared special member functions.
2 Programs may explicitly refer to implicitly-declared special member functions.
[Example 1: A program may explicitly call or form a pointer to member to an implicitly-declared special member
function.
struct A { }; // implicitly declaredA::operator=
struct B : A {
B& operator=(const B &);
};
B& B::operator=(const B& s) {
this->A::operator=(s); // well-formed
§ 11.4.4 © ISO/IEC
314

===== PAGE 326 =====

Dxxxx
return *this;
}
—end example]
3 [Note 2: The special member functions affect the way objects of class type are created, copied, moved, and destroyed,
and how values can be converted to values of other types. Often such special member functions are called implicitly.
—end note]
4 Special member functions obey the usual access rules (11.8).
[Example 2: Declaring a constructor protected ensures that only derived classes and friends can create objects using
it. —end example]
5 Two special member functions are of the same kind if
—(5.1) they are both default constructors,
—(5.2) they are both copy or move constructors with the same first parameter type, or
—(5.3) they are both copy or move assignment operators with the same first parameter type and the same
cv-qualifiers andref-qualifier, if any.
6 An eligible special member functionis a special member function for which:
—(6.1) the function is not deleted,
—(6.2) the associated constraints (13.5), if any, are satisfied, and
—(6.3) no special member function of the same kind whose associated constraints, if any, are satisfied is more
constrained (13.5.5).
7 For a class, its direct non-static data members, its non-virtual direct base classes, and, if the class is not
abstract (11.7.4), its virtual base classes are called itspotentially constructed subobjects.
11.4.5 Constructors [class.ctor]
11.4.5.1 General [class.ctor.general]
1 A declarator declares aconstructor if it is a function declarator (9.3.4.6) of the form
ptr-declarator ( parameter-declaration-clause ) noexcept-specifieropt attribute-specifier-seqopt
where theptr-declarator consists solely of anid-expression, an optionalattribute-specifier-seq, and optional
surrounding parentheses, and theid-expression has one of the following forms:
—(1.1) in a friend declaration (11.8.4), theid-expression is aqualified-id that names a constructor (6.5.5.2);
—(1.2) otherwise, in amember-declaration that belongs to themember-specification of a class or class template,
the id-expression is the injected-class-name (11.1) of the immediately-enclosing entity;
—(1.3) otherwise, theid-expression is aqualified-id whose unqualified-id is the injected-class-name of its lookup
context.
Constructors do not have names. In a constructor declaration, eachdecl-specifier in the optionaldecl-specifier-
seq shall befriend, inline, constexpr, consteval, or anexplicit-specifier.
[Example 1:
struct S {
S(); // declares the constructor
};
S::S() { } // defines the constructor
—end example]
2 A constructor is used to initialize objects of its class type.
[Note 1: Because constructors do not have names, they are never found during unqualified name lookup; however an
explicit type conversion using the functional notation (7.6.1.4) will cause a constructor to be called to initialize an
object. The syntax looks like an explicit call of the constructor.—end note]
[Example 2:
complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );
—end example]
§ 11.4.5.1 © ISO/IEC
315

===== PAGE 327 =====

Dxxxx
[Note 2: For initialization of objects of class type see 11.9.—end note]
[Note 3: 6.8.7 describes the lifetime of temporary objects.—end note]
[Note 4: Explicit constructor calls do not yield lvalues, see 7.2.1.—end note]
3 [Note 5: Some language constructs have special semantics when used during construction; see 11.9.3 and 11.9.5.
—end note]
4 A constructor can be invoked for aconst, volatile or const volatile object. const and volatile
semantics (9.2.9.2) are not applied on an object under construction. They come into effect when the
constructor for the most derived object (6.8.2) ends.
5 The address of a constructor shall not be taken.
[Note 6: A return statement in the body of a constructor cannot specify a return value (8.8.4).—end note]
6 A constructor shall not be a coroutine.
7 A constructor shall not have an explicit object parameter (9.3.4.6).
11.4.5.2 Default constructors [class.default.ctor]
1 A default constructorfor a classX is a constructor of classX for which each parameter that is not a function
parameter pack has a default argument (including the case of a constructor with no parameters). If there
is no user-declared constructor or constructor template for classX, a non-explicit constructor having no
parameters is implicitly declared as defaulted (9.6). An implicitly-declared default constructor is an inline
public member of its class.
2 A defaulted default constructor for classX is defined as deleted if
—(2.1) any non-static data member with no default member initializer (11.4) is of reference type,
—(2.2) X is a non-union class and any non-variant non-static data member of const-qualified type (or possibly
multidimensional array thereof) with nobrace-or-equal-initializer is not const-default-constructible (9.5),
—(2.3) any non-variant potentially constructed subobject, except for a non-static data member with abrace-or-
equal-initializer, has class typeM (or possibly multidimensional array thereof) and overload resolution
(12.2) as applied to findM’s corresponding constructor does not result in a usable candidate (12.2.1), or
—(2.4) any potentially constructed subobjectS has class typeM (or possibly multidimensional array thereof),
M has a destructor that is deleted or inaccessible from the defaulted default constructor, and eitherS is
non-variant orS has a default member initializer.
3 A default constructor for a classX is trivial if it is not user-provided and if
—(3.1) X has no virtual functions (11.7.3) and no virtual base classes (11.7.2), and
—(3.2) no non-static data member ofX has a default member initializer (11.4), and
—(3.3) all the direct base classes ofX have trivial default constructors, and
—(3.4) either X is a union or for all the non-variant non-static data members ofX that are of class type (or
array thereof), each such class has a trivial default constructor.
Otherwise, the default constructor isnon-trivial.
4 If a default constructor of a union-like classX is trivial, then for each unionU that is eitherX or an anonymous
union member ofX, if the first variant member, if any, ofU has implicit-lifetime type (6.9.1), the default
constructor ofX begins the lifetime of that member if it is not the active member of its union.
[Note 1: It is already the active member ifU was value-initialized. —end note]
Otherwise, an implicitly-defined (9.6.2) default constructor performs the set of initializations of the class that
would be performed by a user-written default constructor for that class with noctor-initializer (11.9.3) and
an emptycompound-statement. If that user-written default constructor would be ill-formed, the program is
ill-formed. The implicitly-defined default constructor isconstexpr. Before the defaulted default constructor
for a class is implicitly defined, all the non-user-provided default constructors for its base classes and its
non-static data members are implicitly defined.
[Note 2: An implicitly-declared default constructor has an exception specification (14.5). An explicitly-defaulted
definition might have an implicit exception specification, see 9.6.—end note]
5 [Note 3: A default constructor is implicitly invoked to initialize a class object when no initializer is specified (9.5.1).
Such a default constructor needs to be accessible (11.8).—end note]
§ 11.4.5.2 © ISO/IEC
316

===== PAGE 328 =====

Dxxxx
6 [Note 4: 11.9.3 describes the order in which constructors for base classes and non-static data members are called and
describes how arguments can be specified for the calls to these constructors.—end note]
11.4.5.3 Copy/move constructors [class.copy.ctor]
1 A non-template constructor for classX is a copy constructor if its first parameter is of typeX&, const X&,
volatile X& or const volatile X&, and either there are no other parameters or else all other parameters
have default arguments (9.3.4.7).
[Example 1: X::X(const X&) and X::X(X&,int=1) are copy constructors.
struct X {
X(int);
X(const X&, int = 1);
};
X a(1); // calls X(int);
X b(a, 0); // calls X(const X&, int);
X c = b; // calls X(const X&, int);
—end example]
2 A non-template constructor for classX is a move constructor if its first parameter is of typeX&&, const
X&&, volatile X&&, or const volatile X&&, and either there are no other parameters or else all other
parameters have default arguments (9.3.4.7).
[Example 2: Y::Y(Y&&) is a move constructor.
struct Y {
Y(const Y&);
Y(Y&&);
};
extern Y f(int);
Y d(f(1)); // calls Y(Y&&)
Y e = d; // calls Y(const Y&)
—end example]
3 [Note 1: All forms of copy/move constructor can be declared for a class.
[Example 3:
struct X {
X(const X&);
X(X&); // OK
X(X&&);
X(const X&&); // OK, but possibly not sensible
};
—end example]
—end note]
4 [Note 2: If a class X only has a copy constructor with a parameter of typeX&, an initializer of typeconst X or
volatile X cannot initialize an object of typecv X.
[Example 4:
struct X {
X(); // default constructor
X(X&); // copy constructor with a non-const parameter
};
const X cx;
X x = cx; // error: X::X(X&) cannot copycx into x
—end example]
—end note]
5 A declaration of a constructor for a classX is ill-formed if its first parameter is of typecv X and either there
are no other parameters or else all other parameters have default arguments. A member function template is
never instantiated to produce such a constructor signature.
[Example 5:
struct S {
template<typename T> S(T);
§ 11.4.5.3 © ISO/IEC
317

===== PAGE 329 =====

Dxxxx
S();
};
S g;
void h() {
S a(g); // does not instantiate the member template to produceS::S<S>(S);
// uses the implicitly declared copy constructor
}
—end example]
6 If the class definition does not explicitly declare a copy constructor, a non-explicit one is declaredimplicitly.
If the class definition declares a move constructor or move assignment operator, the implicitly declared copy
constructor is defined as deleted; otherwise, it is defaulted (9.6). The latter case is deprecated if the class has
a user-declared copy assignment operator or a user-declared destructor (D.6).
7 The implicitly-declared copy constructor for a classX will have the form
X::X(const X&)
if each potentially constructed subobject of a class typeM (or array thereof) has a copy constructor whose first
parameter is of typeconst M&or const volatile M&.84 Otherwise, the implicitly-declared copy constructor
will have the form
X::X(X&)
8 If the definition of a classX does not explicitly declare a move constructor, a non-explicit one will be implicitly
declared as defaulted if and only if
—(8.1) X does not have a user-declared copy constructor,
—(8.2) X does not have a user-declared copy assignment operator,
—(8.3) X does not have a user-declared move assignment operator, and
—(8.4) X does not have a user-declared destructor.
[Note 3: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would
have invoked the move constructor might instead invoke a copy constructor.—end note]
9 The implicitly-declared move constructor for classX will have the form
X::X(X&&)
10 An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy/move
constructor for a classX is defined as deleted (9.6.3) ifX has:
—(10.1) a potentially constructed subobject of typeM (or possibly multidimensional array thereof) for which
overload resolution (12.2), as applied to findM’s corresponding constructor, either does not result in a
usable candidate (12.2.1) or, in the case of a variant member, selects a non-trivial function,
—(10.2) any potentially constructed subobject of class typeM (or possibly multidimensional array thereof) where
M has a destructor that is deleted or inaccessible from the defaulted constructor, or,
—(10.3) for the copy constructor, a non-static data member of rvalue reference type.
[Note 4: A defaulted move constructor that is defined as deleted is ignored by overload resolution (12.2, 12.3). Such a
constructor would otherwise interfere with initialization from an rvalue which can use the copy constructor instead.
—end note]
11 A copy/move constructor for classX is trivial if it is not user-provided and if
—(11.1) class X has no virtual functions (11.7.3) and no virtual base classes (11.7.2), and
—(11.2) the constructor selected to copy/move each direct base class subobject is a direct member of that base
class and is trivial, and
—(11.3) for each non-static data member ofX that is of class type (or array thereof), the constructor selected to
copy/move that member is trivial;
otherwise the copy/move constructor isnon-trivial.
84) This implies that the reference parameter of the implicitly-declared copy constructor cannot bind to avolatile lvalue;
see C.7.7.
§ 11.4.5.3 © ISO/IEC
318

===== PAGE 330 =====

Dxxxx
12 [Note 5: The copy/move constructor is implicitly defined even if the implementation elided its odr-use (6.3, 6.8.7).
—end note]
The implicitly-defined (9.6.2) constructor isconstexpr.
13 Before the defaulted copy/move constructor for a class is implicitly defined, all non-user-provided copy/move
constructors for its potentially constructed subobjects are implicitly defined.
[Note 6: An implicitly-declared copy/move constructor has an implied exception specification (14.5).—end note]
14 The implicitly-defined copy/move constructor for a non-union classX performs a memberwise copy/move of
its bases and members.
[Note 7: Default member initializers of non-static data members are ignored.—end note]
The order of initialization is the same as the order of initialization of bases and members in a user-defined
constructor (see 11.9.3). Letx be either the parameter of the constructor or, for the move constructor, an
xvalue referring to the parameter. Each base or non-static data member is copied/moved in the manner
appropriate to its type:
—(14.1) if the member is an array, each element is direct-initialized with the corresponding subobject ofx;
—(14.2) if a memberm has rvalue reference typeT&&, it is direct-initialized withstatic_cast<T&&>(x.m);
—(14.3) otherwise, the base or member is direct-initialized with the corresponding base or member ofx.
Virtual base class subobjects shall be initialized only once by the implicitly-defined copy/move constructor
(see 11.9.3).
15 The implicitly-defined copy/move constructor for a unionX copies the object representation (6.9.1) ofX. For
each object nested within (6.8.2) the object that is the source of the copy, a corresponding objecto nested
within the destination is identified (if the object is a subobject) or created (otherwise), and the lifetime ofo
begins before the copy is performed.
11.4.6 Copy/move assignment operator [class.copy.assign]
1 A user-declaredcopy assignment operatorX::operator= is a non-static non-template member function of
class X with exactly one non-object parameter of typeX, X&, const X&, volatile X&, orconst volatile
X&.85
[Note 1: More than one form of copy assignment operator can be declared for a class.—end note]
[Note 2: If a classX only has a copy assignment operator with a non-object parameter of typeX&, an expression of
type constX cannot be assigned to an object of typeX.
[Example 1:
struct X {
X();
X& operator=(X&);
};
const X cx;
X x;
void f() {
x = cx; // error: X::operator=(X&) cannot assigncx into x
}
—end example]
—end note]
2 If the class definition does not explicitly declare a copy assignment operator, one is declaredimplicitly. If
the class definition declares a move constructor or move assignment operator, the implicitly declared copy
assignment operator is defined as deleted; otherwise, it is defaulted (9.6). The latter case is deprecated if the
class has a user-declared copy constructor or a user-declared destructor (D.6). The implicitly-declared copy
assignment operator for a classX will have the form
X& X::operator=(const X&)
85) Because a template assignment operator or an assignment operator taking an rvalue reference parameter is never a
copy assignment operator, the presence of such an assignment operator does not suppress the implicit declaration of a copy
assignment operator. Such assignment operators participate in overload resolution with other assignment operators, including
copy assignment operators, and, if selected, will be used to assign an object.
§ 11.4.6 © ISO/IEC
319

===== PAGE 331 =====

Dxxxx
if
—(2.1) each direct base classB of X has a copy assignment operator whose non-object parameter is of type
const B&, const volatile B&, orB, and
—(2.2) for all the non-static data members ofX that are of a class typeM (or array thereof), each such class
type has a copy assignment operator whose non-object parameter is of typeconst M&, const volatile
M&, orM.86
Otherwise, the implicitly-declared copy assignment operator will have the form
X& X::operator=(X&)
3 A user-declared move assignment operatorX::operator= is a non-static non-template member function of
class X with exactly one non-object parameter of typeX&&, const X&&, volatile X&&, orconst volatile
X&&.
[Note 3: More than one form of move assignment operator can be declared for a class.—end note]
4 If the definition of a classX does not explicitly declare a move assignment operator, one will be implicitly
declared as defaulted if and only if
—(4.1) X does not have a user-declared copy constructor,
—(4.2) X does not have a user-declared move constructor,
—(4.3) X does not have a user-declared copy assignment operator, and
—(4.4) X does not have a user-declared destructor.
[Example 2: The class definition
struct S {
int a;
S& operator=(const S&) = default;
};
will not have a default move assignment operator implicitly declared because the copy assignment operator has been
user-declared. The move assignment operator may be explicitly defaulted.
struct S {
int a;
S& operator=(const S&) = default;
S& operator=(S&&) = default;
};
—end example]
5 The implicitly-declared move assignment operator for a classX will have the form
X& X::operator=(X&&)
6 The implicitly-declared copy/move assignment operator for classX has the return typeX&. An implicitly-
declared copy/move assignment operator is an inline public member of its class.
7 A defaulted copy/move assignment operator for classX is defined as deleted ifX has:
—(7.1) a non-static data member ofconst non-class type (or possibly multidimensional array thereof), or
—(7.2) a non-static data member of reference type, or
—(7.3) a direct non-static data member of class typeM (or possibly multidimensional array thereof) or a direct
base classM that cannot be copied/moved because overload resolution (12.2), as applied to findM’s
corresponding assignment operator, either does not result in a usable candidate (12.2.1) or, in the case
of a variant member, selects a non-trivial function.
[Note 4: A defaulted move assignment operator that is defined as deleted is ignored by overload resolution (12.2,
12.3). —end note]
8 Because a copy/move assignment operator is implicitly declared for a class if not declared by the user, a base
class copy/move assignment operator is always hidden by the corresponding assignment operator of a derived
class (12.4.3.2).
86) This implies that the reference parameter of the implicitly-declared copy assignment operator cannot bind to avolatile
lvalue; see C.7.7.
§ 11.4.6 © ISO/IEC
320

===== PAGE 332 =====

Dxxxx
[Note 5: A using-declaration in a derived classC that names an assignment operator from a base class never suppresses
the implicit declaration of an assignment operator ofC, even if the base class assignment operator would be a copy or
move assignment operator if declared as a member ofC. —end note]
9 A copy/move assignment operator for classX is trivial if it is not user-provided and if
—(9.1) class X has no virtual functions (11.7.3) and no virtual base classes (11.7.2), and
—(9.2) the assignment operator selected to copy/move each direct base class subobject is a direct member of
that base class and is trivial, and
—(9.3) for each non-static data member ofX that is of class type (or array thereof), the assignment operator
selected to copy/move that member is trivial;
otherwise the copy/move assignment operator isnon-trivial.
10 An implicitly-defined (9.6.2) copy/move assignment operator isconstexpr.
11 Before the defaulted copy/move assignment operator for a class is implicitly defined, all non-user-provided
copy/move assignment operators for its direct base classes and its non-static data members are implicitly
defined.
[Note 6: An implicitly-declared copy/move assignment operator has an implied exception specification (14.5).—end
note]
12 The implicitly-defined copy/move assignment operator for a non-union classX performs memberwise copy-
/move assignment of its subobjects. The direct base classes ofX are assigned first, in the order of their
declaration in thebase-specifier-list, and then the immediate non-static data members ofX are assigned, in
the order in which they were declared in the class definition. Letx be either the parameter of the function
or, for the move operator, an xvalue referring to the parameter. Each subobject is assigned in the manner
appropriate to its type:
—(12.1) if the subobject is of class type, as if by a call tooperator= with the subobject as the object expression
and the corresponding subobject ofx as a single function argument (as if by explicit qualification; that
is, ignoring any possible virtual overriding functions in more derived classes);
—(12.2) if the subobject is an array, each element is assigned, in the manner appropriate to the element type;
—(12.3) if the subobject is of scalar type, the built-in assignment operator is used.
It is unspecified whether subobjects representing virtual base classes are assigned more than once by the
implicitly-defined copy/move assignment operator.
[Example 3:
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };
It is unspecified whether the virtual base class subobjectV is assigned twice by the implicitly-defined copy/move
assignment operator forC. —end example]
13 The implicitly-defined copy/move assignment operator for a unionX copies the object representation (6.9.1)
of X. If the source and destination of the assignment are not the same object, then for each object nested
within (6.8.2) the object that is the source of the copy, a corresponding objectonested within the destination
is created, and the lifetime ofo begins before the copy is performed.
14 The implicitly-defined copy/move assignment operator for a class returns the object for which the assignment
operator is invoked, that is, the object assigned to.
11.4.7 Destructors [class.dtor]
1 A declaration whosedeclarator-id has anunqualified-id that begins with a~ declares aprospective destructor;
its declarator shall be a function declarator (9.3.4.6) of the form
ptr-declarator ( parameter-declaration-clause ) noexcept-specifieropt attribute-specifier-seqopt
where theptr-declarator consists solely of anid-expression, an optionalattribute-specifier-seq, and optional
surrounding parentheses, and theid-expression has one of the following forms:
—(1.1) in amember-declaration that belongs to themember-specification of a class or class template but is not
a friend declaration (11.8.4), theid-expression is ~class-name and theclass-name is the injected-class-
name (11.1) of the immediately-enclosing entity or
§ 11.4.7 © ISO/IEC
321

===== PAGE 333 =====

Dxxxx
—(1.2) otherwise, theid-expression is nested-name-specifier ~class-name and theclass-name is the injected-class-
name of the class nominated by thenested-name-specifier.
A prospective destructor shall take no arguments (9.3.4.6). Eachdecl-specifier of thedecl-specifier-seq of a
prospective destructor declaration (if any) shall befriend, inline, virtual, orconstexpr.
2 If a class has no user-declared prospective destructor, a prospective destructor is implicitly declared as
defaulted (9.6). An implicitly-declared prospective destructor is an inline public member of its class.
3 An implicitly-declared prospective destructor for a classX will have the form
~X()
4 At the end of the definition of a class, overload resolution is performed among the prospective destructors
declared in that class with an empty argument list to select thedestructor for the class, also known as the
selected destructor. The program is ill-formed if overload resolution fails. Destructor selection does not
constitute a reference to, or odr-use (6.3) of, the selected destructor, and in particular, the selected destructor
may be deleted (9.6.3).
5 The address of a destructor shall not be taken.
[Note 1: A return statement in the body of a destructor cannot specify a return value (8.8.4).—end note]
A destructor can be invoked for aconst, volatile or const volatile object. const and volatile
semantics (9.2.9.2) are not applied on an object under destruction. They stop being in effect when the
destructor for the most derived object (6.8.2) starts.
6 [Note 2: A declaration of a destructor that does not have anoexcept-specifier has the same exception specification as
if it had been implicitly declared (14.5).—end note]
7 A defaulted destructor for a classX is defined as deleted if
—(7.1) X is a non-union class and any non-variant potentially constructed subobject has class typeM (or
possibly multidimensional array thereof) whereM has a destructor that is deleted or is inaccessible from
the defaulted destructor,
—(7.2) X is a union and
—(7.2.1) overload resolution to select a constructor to default-initialize an object of typeX either fails or
selects a constructor that is either deleted or not trivial, or
—(7.2.2) X has a variant memberV of class typeM (or possibly multi-dimensional array thereof) whereV
has a default member initializer andM has a destructor that is non-trivial, or,
—(7.3) for a virtual destructor, lookup of the non-array deallocation function results in an ambiguity or in a
function that is deleted or inaccessible from the defaulted destructor.
8 A destructor for a classX is trivial if it is not user-provided and if
—(8.1) the destructor is not virtual,
—(8.2) all of the direct base classes ofX have trivial destructors, and
—(8.3) either X is a union or for all of the non-variant non-static data members ofX that are of class type (or
array thereof), each such class has a trivial destructor.
Otherwise, the destructor isnon-trivial.
9 A defaulted destructor is a constexpr destructor.
10 Before a defaulted destructor for a class is implicitly defined, all the non-user-provided destructors for its
base classes and its non-static data members are implicitly defined.
11 A prospective destructor can be declaredvirtual (11.7.3) and with apure-specifier (11.7.4). If the destructor
of a class is virtual and any objects of that class or any derived class are created in the program, the destructor
shall be defined.
12 [Note 3: Some language constructs have special semantics when used during destruction; see 11.9.5.—end note]
13 After executing the body of the destructor and destroying any objects with automatic storage duration
allocated within the body, a destructor for classX calls the destructors forX’s direct non-variant non-static
data members other than anonymous unions, the destructors forX’s non-virtual direct base classes and, ifX is
the most derived class (11.9.3), its destructor calls the destructors forX’s virtual base classes. All destructors
are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding
§ 11.4.7 © ISO/IEC
322

===== PAGE 334 =====

Dxxxx
destructors in more derived classes. Bases and members are destroyed in the reverse order of the completion
of their constructor (see 11.9.3).
[Note 4: A return statement (8.8.4) in a destructor might not directly return to the caller; before transferring control
to the caller, the destructors for the members and bases are called.—end note]
Destructors for elements of an array are called in reverse order of their construction (see 11.9).
14 A destructor is invoked implicitly
—(14.1) for a constructed object with static storage duration (6.8.6.2) at program termination (6.10.3.4),
—(14.2) for a constructed object with thread storage duration (6.8.6.3) at thread exit,
—(14.3) for a constructed object with automatic storage duration (6.8.6.4) when the block in which an object is
created exits (8.10),
—(14.4) for a constructed temporary object when its lifetime ends (7.3.5, 6.8.7).
In each case, the context of the invocation is the context of the construction of the object. A destructor may
also be invoked implicitly through use of adelete-expression (7.6.2.9) for a constructed object allocated by a
new-expression (7.6.2.8); the context of the invocation is thedelete-expression.
[Note 5: An array of class type contains several subobjects for each of which the destructor is invoked.—end note]
A destructor can also be invoked explicitly. A destructor ispotentially invokedif it is invoked or as specified
in 7.6.2.8, 8.8.4, 9.5.2, 11.9.3, and 14.2. A program is ill-formed if a destructor that is potentially invoked is
deleted or not accessible from the context of the invocation.
15 At the point of definition of a virtual destructor (including an implicit definition), the non-array deallocation
function is determined as if for the expressiondelete this appearing in a non-virtual destructor of the
destructor’s class (see 7.6.2.9). If the lookup fails or if the deallocation function has a deleted definition (9.6),
the program is ill-formed.
[Note 6: This assures that a deallocation function corresponding to the dynamic type of an object is available for the
delete-expression (11.4.11). —end note]
16 In an explicit destructor call, the destructor is specified by a~ followed by atype-name or computed-type-
specifier that denotes the destructor’s class type. The invocation of a destructor is subject to the usual rules
for member functions (11.4.2); that is, if the object is not of the destructor’s class type and not of a class
derived from the destructor’s class type (including when the destructor is invoked via a null pointer value),
the program has undefined behavior.
[Note 7: Invokingdelete on a null pointer does not call the destructor; see 7.6.2.9.—end note]
[Example 1:
struct B {
virtual ~B() { }
};
struct D : B {
~D() { }
};
D D_object;
typedef B B_alias;
B* B_ptr = &D_object;
void f() {
D_object.B::~B(); // calls B’s destructor
B_ptr->~B(); // calls D’s destructor
B_ptr->~B_alias(); // calls D’s destructor
B_ptr->B_alias::~B(); // calls B’s destructor
B_ptr->B_alias::~B_alias(); // calls B’s destructor
}
—end example]
[Note 8: An explicit destructor call must always be written using a member access operator (7.6.1.5) or aqualified-
id (7.5.5.3); in particular, theunary-expression ~X() in a member function is not an explicit destructor call (7.6.2.2).
—end note]
§ 11.4.7 © ISO/IEC
323

===== PAGE 335 =====

Dxxxx
17 [Note 9: Explicit calls of destructors are rarely needed. One use of such calls is for objects placed at specific addresses
using a placementnew-expression. Such use of explicit placement and destruction of objects can be necessary to cope
with dedicated hardware resources and for writing memory management facilities.
[Example 2:
void* operator new(std::size_t, void* p) { return p; }
struct X {
X(int);
~X();
};
void f(X* p);
void g() { // rare, specialized use:
char* buf = new char[sizeof(X)];
X* p = new(buf) X(222); // usebuf[] and initialize
f(p);
p->X::~X(); // cleanup
}
—end example]
—end note]
18 Once a destructor is invoked for an object, the object’s lifetime ends; the behavior is undefined if the destructor
is invoked for an object whose lifetime has ended (6.8.4).
[Example 3: If the destructor for an object with automatic storage duration is explicitly invoked, and the block is
subsequently left in a manner that would ordinarily invoke implicit destruction of the object, the behavior is undefined.
—end example]
19 [Note 10: The notation for explicit call of a destructor can be used for any scalar type name (7.5.5.5). Allowing this
makes it possible to write code without having to know if a destructor exists for a given type. For example:
typedef int I;
I* p;
p->I::~I();
—end note]
20 A destructor shall not be a coroutine.
11.4.8 Conversions [class.conv]
11.4.8.1 General [class.conv.general]
1 Type conversions of class objects can be specified by constructors and by conversion functions. These
conversions are calleduser-defined conversionsand are used for implicit type conversions (7.3), for initialization
(9.5), and for explicit type conversions (7.6.1.4, 7.6.3, 7.6.1.9).
2 User-defined conversions are applied only where they are unambiguous (6.5.2, 11.4.8.3). Conversions obey
the access control rules (11.8). Access control is applied after ambiguity resolution (6.5).
3 [Note 1: See 12.2 for a discussion of the use of conversions in function calls.—end note]
4 At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single
value.
[Example 1:
struct X {
operator int();
};
struct Y {
operator X();
};
Y a;
int b = a; // error: no viable conversion (a.operator X().operator int() not considered)
int c = X(a); // OK,a.operator X().operator int()
—end example]
§ 11.4.8.1 © ISO/IEC
324

===== PAGE 336 =====

Dxxxx
11.4.8.2 Conversion by constructor [class.conv.ctor]
1 A constructor that is not explicit (9.2.3) specifies a conversion from the types of its parameters (if any) to
the type of its class.
[Example 1:
struct X {
X(int);
X(const char*, int = 0);
X(int, int);
};
void f(X arg) {
X a = 1; // a = X(1)
X b = "Jessie"; // b = X("Jessie",0)
a = 2; // a = X(2)
f(3); // f(X(3))
f({1, 2}); // f(X(1,2))
}
—end example]
2 [Note 1: An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-
initialization syntax (9.5) or where casts (7.6.1.9, 7.6.3) are explicitly used; see also 12.2.2.5. A default constructor can
be an explicit constructor; such a constructor will be used to perform default-initialization or value-initialization (9.5).
[Example 2:
struct Z {
explicit Z();
explicit Z(int);
explicit Z(int, int);
};
Z a; // OK, default-initialization performed
Z b{}; // OK, direct initialization syntax used
Z c = {}; // error: copy-list-initialization
Z a1 = 1; // error: no implicit conversion
Z a3 = Z(1); // OK, direct initialization syntax used
Z a2(1); // OK, direct initialization syntax used
Z* p = new Z(1); // OK, direct initialization syntax used
Z a4 = (Z)1; // OK, explicit cast used
Z a5 = static_cast<Z>(1); // OK, explicit cast used
Z a6 = { 3, 4 }; // error: no implicit conversion
—end example]
—end note]
11.4.8.3 Conversion functions [class.conv.fct]
conversion-function-id:
operator conversion-type-id
conversion-type-id:
type-specifier-seq conversion-declaratoropt
conversion-declarator:
ptr-operator conversion-declaratoropt
1 A declaration whosedeclarator-id has anunqualified-id that is aconversion-function-id declares aconversion
function; itsdeclarator shall be a function declarator (9.3.4.6) of the form
noptr-declarator parameters-and-qualifiers
where thenoptr-declarator consists solely of anid-expression, an optionalattribute-specifier-seq, and optional
surrounding parentheses, and theid-expression has one of the following forms:
—(1.1) in amember-declaration that belongs to themember-specification of a class or class template but is not
a friend declaration (11.8.4), theid-expression is aconversion-function-id;
—(1.2) otherwise, theid-expression is aqualified-id whose unqualified-id is aconversion-function-id.
§ 11.4.8.3 © ISO/IEC
325

===== PAGE 337 =====

Dxxxx
2 A conversion function shall have no non-object parameters and shall be a non-static member function of
a class or class templateX; its declared return type is theconversion-type-id and it specifies a conversion
from X to the type specified by theconversion-type-id, interpreted as atype-id (9.3.2). A decl-specifier in the
decl-specifier-seq of a conversion function (if any) shall not be adefining-type-specifier.
3 [Note 1: A conversion function is never invoked for implicit or explicit conversions of an object to the same object
type (or a reference to it), to a base class of that type (or a reference to it), or tocv void. Even though never directly
called to perform a conversion, such conversion functions can be declared and can potentially be reached through a
call to a virtual conversion function in a base class.—end note]
[Example 1:
struct X {
operator int();
operator auto() -> short; // error: trailing return type
};
void f(X a) {
int i = int(a);
i = (int)a;
i = a;
}
In all three cases the value assigned will be converted byX::operator int(). —end example]
4 A conversion function may be explicit (9.2.3), in which case it is only considered as a user-defined conversion
for direct-initialization (9.5). Otherwise, user-defined conversions are not restricted to use in assignments and
initializations.
[Example 2:
class Y { };
struct Z {
explicit operator Y() const;
};
void h(Z z) {
Y y1(z); // OK, direct-initialization
Y y2 = z; // error: no conversion function candidate for copy-initialization
Y y3 = (Y)z; // OK, cast notation
}
void g(X a, X b) {
int i = (a) ? 1+a : 0;
int j = (a&&b) ? a+b : i;
if (a) {
}
}
—end example]
5 The conversion-type-id shall not represent a function type nor an array type. Theconversion-type-id in a
conversion-function-id is the longest sequence of tokens that could possibly form aconversion-type-id.
[Note 2: This prevents ambiguities between the declarator operator* and its expression counterparts.
[Example 3:
&ac.operator int*i; // syntax error:
// parsed as:&(ac.operator int *)i
// not as:&(ac.operator int)*i
The * is the pointer declarator and not the multiplication operator.—end example]
This rule also prevents ambiguities for attributes.
[Example 4:
operator int [[noreturn]] (); // error: noreturn attribute applied to a type
—end example]
—end note]
§ 11.4.8.3 © ISO/IEC
326

===== PAGE 338 =====

Dxxxx
6 [Note 3: A conversion function in a derived class hides only conversion functions in base classes that convert to
the same type. A conversion function template with a dependent return type hides only templates in base classes
that correspond to it (6.5.2); otherwise, it hides and is hidden as a non-template function. Function overload
resolution (12.2.4) selects the best conversion function to perform the conversion.
[Example 5:
struct X {
operator int();
};
struct Y : X {
operator char();
};
void f(Y& a) {
if (a) { // error: ambiguous betweenX::operator int() and Y::operator char()
}
}
—end example]
—end note]
7 Conversion functions can be virtual.
8 A conversion function template shall not have a deduced return type (9.2.9.7).
[Example 6:
struct S {
template<class T>
operator auto() const { return 1.2; } // error: conversion function template
};
—end example]
11.4.9 Static members [class.static]
11.4.9.1 General [class.static.general]
1 A static members of classX may be referred to using thequalified-id expression X::s; it is not necessary to
use the class member access syntax (7.6.1.5) to refer to a static member. A static member may be referred to
using the class member access syntax, in which case the object expression is evaluated.
[Example 1:
struct process {
static void reschedule();
};
process& g();
void f() {
process::reschedule(); // OK, no object necessary
g().reschedule(); // g() is called
}
—end example]
2 Static members obey the usual class member access rules (11.8). When used in the declaration of a
class member, thestatic specifier shall only be used in the member declarations that appear within the
member-specification of the class definition.
[Note 1: It cannot be specified in member declarations that appear in namespace scope.—end note]
11.4.9.2 Static member functions [class.static.mfct]
1 [Note 1: The rules described in 11.4.2 apply to static member functions.—end note]
2 [Note 2: A static member function does not have athis pointer (7.5.3). A static member function cannot be qualified
with const, volatile, orvirtual (9.3.4.6). —end note]
§ 11.4.9.2 © ISO/IEC
327

===== PAGE 339 =====

Dxxxx
11.4.9.3 Static data members [class.static.data]
1 A static data member is not part of the subobjects of a class. If a static data member is declaredthread_-
local there is one copy of the member per thread. If a static data member is not declaredthread_local
there is one copy of the data member that is shared by all the objects of the class.
2 A static data member shall not bemutable (9.2.2). A static data member shall not be a direct member (11.4)
of an unnamed (11.1) or local (11.6) class or of a (possibly indirectly) nested class (11.4.12) thereof.
3 The declaration of a non-inline static data member in its class definition is not a definition and may be of an
incomplete type other thancv void.
[Note 1: The initializer in the definition of a static data member is in the scope of its class (6.4.7).—end note]
[Example 1:
class process {
static process* run_chain;
static process* running;
};
process* process::running = get_main();
process* process::run_chain = running;
The definition of the static data member run_chain of class process inhabits the global scope; the notation
process::run_chain indicates that the memberrun_chain is a member of classprocess and in the scope of class
process. In the static data member definition, theinitializer expression refers to the static data memberrunning of
class process. —end example]
[Note 2: Once the static data member has been defined, it exists even if no objects of its class have been created.
[Example 2: In the example above,run_chain and running exist even if no objects of classprocess are created by
the program. —end example]
The initialization and destruction of static data members is described in 6.10.3.2, 6.10.3.3, and 6.10.3.4.—end note]
4 If a non-volatile non-inlineconst static data member is of integral or enumeration type, its declaration in
the class definition can specify abrace-or-equal-initializer in which everyinitializer-clause that is anassignment-
expression is a constant expression (7.7). The member shall still be defined in a namespace scope if it is
odr-used (6.3) in the program and the namespace scope definition shall not contain aninitializer. The
declaration of an inline static data member (which is a definition) may specify abrace-or-equal-initializer.
If the member is declared with theconstexpr specifier, it may be redeclared in namespace scope with no
initializer (this usage is deprecated; see D.7). Declarations of other static data members shall not specify a
brace-or-equal-initializer.
5 [Note 3: There is exactly one definition of a static data member that is odr-used (6.3) in a valid program.—end
note]
6 [Note 4: Static data members of a class in namespace scope have the linkage of the name of the class (6.7).—end
note]
11.4.10 Bit-fields [class.bit]
1 A member-declarator of the form
identifieropt attribute-specifier-seqopt : constant-expression brace-or-equal-initializeropt
specifies a bit-field. The optionalattribute-specifier-seq appertains to the entity being declared. A bit-field
shall not be a static member. A bit-field shall have integral or (possibly cv-qualified) enumeration type; the
bit-field semantic property is not part of the type of the class member. Theconstant-expression shall be an
integral constant expression with a value greater than or equal to zero and is called thewidth of the bit-field.
If the width of a bit-field is larger than the width of the bit-field’s type (or, in case of an enumeration type,
of its underlying type), the extra bits are padding bits (6.9.1). Allocation of bit-fields within a class object is
implementation-defined. Alignment of bit-fields is implementation-defined. Bit-fields are packed into some
addressable allocation unit.
[Note 1: Bit-fields straddle allocation units on some machines and not on others. Bit-fields are assigned right-to-left
on some machines, left-to-right on others.—end note]
2 A declaration for a bit-field that omits theidentifier declares anunnamed bit-field. Unnamed bit-fields are
not members and cannot be initialized. An unnamed bit-field shall not be declared with a cv-qualified type.
[Note 2: An unnamed bit-field is useful for padding to conform to externally-imposed layouts.—end note]
§ 11.4.10 © ISO/IEC
328

===== PAGE 340 =====

Dxxxx
As a special case, an unnamed bit-field with a width of zero specifies alignment of the next bit-field at an
allocation unit boundary. Only when declaring an unnamed bit-field may the width be zero.
3 The address-of operator& shall not be applied to a bit-field, so there are no pointers to bit-fields. A non-const
reference shall not bind to a bit-field (9.5.4).
[Note 3: If the initializer for a reference of typeconst T&is an lvalue that refers to a bit-field, the reference is bound to
a temporary initialized to hold the value of the bit-field; the reference is not bound to the bit-field directly. See 9.5.4.
—end note]
4 If a value of integral type (other thanbool) is stored into a bit-field of widthN and the value would be
representable in a hypothetical signed or unsigned integer type with widthN and the same signedness as the
bit-field’s type, the original value and the value of the bit-field compare equal. If the valuetrue or false is
stored into a bit-field of typebool of any size (including a one bit bit-field), the originalbool value and the
value of the bit-field compare equal. If a value of an enumeration type is stored into a bit-field of the same
type and the width is large enough to hold all the values of that enumeration type (9.8.1), the original value
and the value of the bit-field compare equal.
[Example 1:
enum BOOL { FALSE=0, TRUE=1 };
struct A {
BOOL b:1;
};
A a;
void f() {
a.b = TRUE;
if (a.b == TRUE) // yieldstrue
{ /* ... */ }
}
—end example]
11.4.11 Allocation and deallocation functions [class.free]
1 Any allocation function for a classT is a static member (even if not explicitly declaredstatic).
2 [Example 1:
class Arena;
struct B {
void* operator new(std::size_t, Arena*);
};
struct D1 : B {
};
Arena* ap;
void foo(int i) {
new (ap) D1; // calls B::operator new(std::size_t, Arena*)
new D1[i]; // calls ::operator new[](std::size_t)
new D1; // error: ::operator new(std::size_t) hidden
}
—end example]
3 Any deallocation function for a classX is a static member (even if not explicitly declaredstatic).
[Example 2:
class X {
void operator delete(void*);
void operator delete[](void*, std::size_t);
};
class Y {
void operator delete(void*, std::size_t);
void operator delete[](void*);
};
—end example]
4 Since member allocation and deallocation functions arestatic they cannot be virtual.
§ 11.4.11 © ISO/IEC
329

===== PAGE 341 =====

Dxxxx
[Note 1: However, when thecast-expression of a delete-expression refers to an object of class type with a virtual
destructor, because the deallocation function is chosen by the destructor of the dynamic type of the object, the effect
is the same in that case.
[Example 3:
struct B {
virtual ~B();
void operator delete(void*, std::size_t);
};
struct D : B {
void operator delete(void*);
};
struct E : B {
void log_deletion();
void operator delete(E *p, std::destroying_delete_t) {
p->log_deletion();
p->~E();
::operator delete(p);
}
};
void f() {
B* bp = new D;
delete bp; // 1: usesD::operator delete(void*)
bp = new E;
delete bp; // 2: usesE::operator delete(E*, std::destroying_delete_t)
}
Here, storage for the object of classD is deallocated byD::operator delete(), and the object of classE is destroyed
and its storage is deallocated byE::operator delete(), due to the virtual destructor.—end example]
—end note]
[Note 2: Virtual destructors have no effect on the deallocation function actually called when thecast-expression of a
delete-expression refers to an array of objects of class type.
[Example 4:
struct B {
virtual ~B();
void operator delete[](void*, std::size_t);
};
struct D : B {
void operator delete[](void*, std::size_t);
};
void f(int i) {
D* dp = new D[i];
delete [] dp; // usesD::operator delete[](void*, std::size_t)
B* bp = new D[i];
delete[] bp; // undefined behavior
}
—end example]
—end note]
5 Access to the deallocation function is checked statically, even if a different one is actually executed.
[Example 5: For the call on line “// 1” above, ifB::operator delete() had been private, the delete expression
would have been ill-formed.—end example]
6 [Note 3: If a deallocation function has no explicitnoexcept-specifier, it has a non-throwing exception specification (14.5).
—end note]
11.4.12 Nested class declarations [class.nest]
1 A class can be declared within another class. A class declared within another is called anested class.
§ 11.4.12 © ISO/IEC
330

===== PAGE 342 =====

Dxxxx
[Note 1: See 7.5.5 for restrictions on the use of non-static data members and non-static member functions.—end
note]
[Example 1:
int x;
int y;
struct enclose {
int x;
static int s;
struct inner {
void f(int i) {
int a = sizeof(x); // OK, operand of sizeof is an unevaluated operand
x = i; // error: assign toenclose::x
s = i; // OK, assign toenclose::s
::x = i; // OK, assign to globalx
y = i; // OK, assign to globaly
}
void g(enclose* p, int i) {
p->x = i; // OK, assign toenclose::x
}
};
};
inner* p = 0; // error: inner not found
—end example]
2 [Note 2: Nested classes can be defined either in the enclosing class or in an enclosing namespace; member functions
and static data members of a nested class can be defined either in the nested class or in an enclosing namespace scope.
[Example 2:
struct enclose {
struct inner {
static int x;
void f(int i);
};
};
int enclose::inner::x = 1;
void enclose::inner::f(int i) { /* ... */ }
class E {
class I1; // forward declaration of nested class
class I2;
class I1 { }; // definition of nested class
};
class E::I2 { }; // definition of nested class
—end example]
—end note]
3 A friend function (11.8.4) defined within a nested class has no special access rights to members of an enclosing
class.
11.5 Unions [class.union]
11.5.1 General [class.union.general]
1 A union is a class defined with theclass-key union.
2 In a union, a non-static data member isactive if its name refers to an object whose lifetime has begun and
has not ended (6.8.4). At most one of the non-static data members of an object of union type can be active
at any time, that is, the value of at most one of the non-static data members can be stored in a union at any
time.
§ 11.5.1 © ISO/IEC
331

===== PAGE 343 =====

Dxxxx
[Note 1: One special guarantee is made in order to simplify the use of unions: If a standard-layout union contains
several standard-layout structs that share a common initial sequence (11.4), and if a non-static data member of an
object of this standard-layout union type is active and is one of the standard-layout structs, the common initial
sequence of any of the standard-layout struct members can be inspected; see 11.4.—end note]
3 The size of a union is sufficient to contain the largest of its non-static data members. Each non-static data
member is allocated as if it were the sole member of a non-union class.
[Note 2: A union object and its non-static data members are pointer-interconvertible (6.9.4, 7.6.1.9). As a consequence,
all non-static data members of a union object have the same address.—end note]
4 A union can have member functions (including constructors and destructors), but it shall not have virtual
(11.7.3) functions. A union shall not have base classes. A union shall not be used as a base class. If a union
contains a non-static data member of reference type, the program is ill-formed.
[Note 3: If any non-static data member of a union has a non-trivial copy constructor, move constructor (11.4.5.3),
copy assignment operator, or move assignment operator (11.4.6), the corresponding member function of the union
must be user-provided or it will be implicitly deleted (9.6.3) for the union.
[Example 1: Consider the following union:
union U {
int i;
float f;
std::string s;
};
Since std::string (27.4) declares non-trivial versions of all of the special member functions,U will have an implicitly
deleted copy/move constructor and copy/move assignment operator. The default constructor and destructor ofU
are both trivial even thoughstd::string has a non-trivial default constructor and a non-trivial destructor.—end
example]
—end note]
5 When the left operand of an assignment operator involves a member access expression (7.6.1.5) that nominates
a union member, it may begin the lifetime of that union member, as described below. For an expressionE,
define the setS(E) of subexpressions ofE as follows:
—(5.1) If E is of the formA.B, S(E) contains the elements ofS(A), and also containsA.B if B names a union
member of a non-class, non-array type, or of a class type with a trivial default constructor that is not
deleted, or an array of such types.
—(5.2) If E is of the formA[B] and is interpreted as a built-in array subscripting operator,S(E) is S(A) if A is
of array type,S(B) if B is of array type, and empty otherwise.
—(5.3) Otherwise, S(E) is empty.
In an assignment expression of the formE1 = E2 that uses either the built-in assignment operator (7.6.19)
or a trivial assignment operator (11.4.6), for each elementX of S(E1) and each anonymous union member
X (11.5.2) that is a member of a union and has such an element as an immediate subobject (recursively), if
modification of X would have undefined behavior under 6.8.4, an object of the type ofX is implicitly created
in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after
the value computation of the left and right operands and before the assignment.
[Note 4: This ends the lifetime of the previously-active member of the union, if any (6.8.4).—end note]
[Example 2:
union A { int x; int y[4]; };
struct B { A a; };
union C { B b; int k; };
int f() {
C c; // does not start lifetime of any union member
c.b.a.y[3] = 4; // OK,S(c.b.a.y[3]) contains c.b and c.b.a.y;
// creates objects to hold union membersc.b and c.b.a.y
return c.b.a.y[3]; // OK,c.b.a.y refers to newly created object (see 6.8.4)
}
struct X { const int a; int b; };
union Y { X x; int k; };
void g() {
Y y = { { 1, 2 } }; // OK,y.x is active union member (11.4)
§ 11.5.1 © ISO/IEC
332

===== PAGE 344 =====

Dxxxx
int n = y.x.a;
y.k = 4; // OK, ends lifetime ofy.x, y.k is active member of union
y.x.b = n; // undefined behavior:y.x.b modified outside its lifetime,
// S(y.x.b) is empty becauseX’s default constructor is deleted,
// so union membery.x’s lifetime does not implicitly start
}
—end example]
6 [Note 5: In cases where the above rule does not apply, the active member of a union can only be changed by the use
of a placementnew-expression. —end note]
[Example 3: Consider an objectu of aunion type U having non-static data membersm of typeM and n of typeN. If M
has a non-trivial destructor andN has a non-trivial constructor (for instance, if they declare or inherit virtual functions),
the active member ofu can be safely switched fromm to n using the destructor and placementnew-expression as
follows:
u.m.~M();
new (&u.n) N;
—end example]
11.5.2 Anonymous unions [class.union.anon]
1 A union of the form
union { member-specification } ;
is called ananonymous union; it defines an unnamed type and an unnamed object of that type called an
anonymous union memberif it is a non-static data member or ananonymous union variableotherwise.
Each member-declaration in themember-specification of an anonymous union shall define one or more public
non-static data members, be anempty-declaration, or be astatic_assert-declaration. Nested types, anonymous
unions, and functions shall not be declared within an anonymous union. The names of the members of an
anonymous union are bound in the scope inhabited by the union declaration.
[Example 1:
void f() {
union { int a; const char* p; };
a = 1;
p = "Jennifer";
}
Here a and p are used like ordinary (non-member) variables, but since they are union members they have the same
address. —end example]
2 An anonymous union declared in the scope of a namespace with external linkage shall use thestorage-class-
specifier static. Anonymous unions declared at block scope shall not use astorage-class-specifier that is not
permitted in the declaration of a block variable. An anonymous union declaration at class scope shall not
have astorage-class-specifier.
3 [Note 1: A union for which objects, pointers, or references are declared is not an anonymous union.
[Example 2:
void f() {
union { int aa; char* p; } obj, *ptr = &obj;
aa = 1; // error
ptr->aa = 1; // OK
}
The assignment to plainaa is ill-formed since the member name is not visible outside the union, and even if it were
visible, it is not associated with any particular object.—end example]
—end note]
[Note 2: Initialization of unions with no user-declared constructors is described in 9.5.2.—end note]
4 A union-like classis a union or a class that has an anonymous union as a direct member. A union-like class
X has a set ofvariant members. If X is a union, a non-static data member ofX that is not an anonymous
union is a variant member ofX. In addition, a non-static data member of an anonymous union that is a
member of X is also a variant member ofX. At most one variant member of a union may have a default
member initializer.
§ 11.5.2 © ISO/IEC
333

===== PAGE 345 =====

Dxxxx
[Example 3:
union U {
int x = 0;
union {
int k;
};
union {
int z;
int y = 1; // error: initialization for second variant member ofU
};
};
—end example]
11.6 Local class declarations [class.local]
1 A class can be declared within a function definition; such a class is called alocal class.
[Note 1: A declaration in a local class cannot odr-use (6.3) a local entity from an enclosing scope.—end note]
[Example 1:
int x;
void f() {
static int s;
int x;
const int N = 5;
extern int q();
int arr[2];
auto [y, z] = arr;
struct local {
int g() { return x; } // error: odr-use of non-odr-usable variablex
int h() { return s; } // OK
int k() { return ::x; } // OK
int l() { return q(); } // OK
int m() { return N; } // OK, not an odr-use
int* n() { return &N; } // error: odr-use of non-odr-usable variableN
int p() { return y; } // error: odr-use of non-odr-usable structured bindingy
};
}
local* p = 0; // error: local not found
—end example]
2 An enclosing function has no special access to members of the local class; it obeys the usual access rules (11.8).
Member functions of a local class shall be defined within their class definition, if they are defined at all.
3 A class nested within a local class is a local class. A member of a local classX shall be declared only in the
definition ofX or, if the member is a nested class, in the nearest enclosing block scope ofX.
4 [Note 2: A local class cannot have static data members (11.4.9.3).—end note]
11.7 Derived classes [class.derived]
11.7.1 General [class.derived.general]
1 A list of base classes can be specified in a class definition using the notation:
base-clause:
: base-specifier-list
base-specifier-list:
base-specifier ...opt
base-specifier-list , base-specifier ...opt
base-specifier:
attribute-specifier-seqopt class-or-decltype
attribute-specifier-seqopt virtual access-specifieropt class-or-decltype
attribute-specifier-seqopt access-specifier virtualopt class-or-decltype
§ 11.7.1 © ISO/IEC
334

===== PAGE 346 =====

Dxxxx
class-or-decltype:
nested-name-specifieropt type-name
nested-name-specifier template simple-template-id
computed-type-specifier
access-specifier:
private
protected
public
The optionalattribute-specifier-seq appertains to thebase-specifier.
2 The component names of aclass-or-decltype are those of itsnested-name-specifier, type-name, and/orsimple-
template-id. A class-or-decltype shall denote a (possibly cv-qualified) class type that is not an incompletely
defined class (11.4); any cv-qualifiers are ignored. The class denoted by theclass-or-decltype of abase-specifier
is called adirect base classfor the class being defined; for each suchbase-specifier, the correspondingdirect
base class relationshipis the ordered pair (D, B) whereD is the class being defined andB is the direct base
class. The lookup for the component name of thetype-name or simple-template-id is type-only (6.5). A class
B is a base class of a classD if it is a direct base class ofD or a direct base class of one ofD’s base classes. A
class is anindirect base classof another if it is a base class but not a direct base class. A class is said to be
(directly or indirectly)derived from its (direct or indirect) base classes.
[Note 1: See 11.8 for the meaning ofaccess-specifier. —end note]
Members of a base class are also members of the derived class.
[Note 2: Constructors of a base class can be explicitly inherited (9.10). Base class members can be referred
to in expressions in the same manner as other members of the derived class, unless their names are hidden or
ambiguous (6.5.2). The scope resolution operator:: (7.5.5.3) can be used to refer to a direct or indirect base member
explicitly, even if it is hidden in the derived class. A derived class can itself serve as a base class subject to access
control; see 11.8.3. A pointer to a derived class can be implicitly converted to a pointer to an accessible unambiguous
base class (7.3.12). An lvalue of a derived class type can be bound to a reference to an accessible unambiguous base
class (9.5.4). —end note]
3 The base-specifier-list specifies the type of thebase class subobjectscontained in an object of the derived class
type.
[Example 1:
struct Base {
int a, b, c;
};
struct Derived : Base {
int b;
};
struct Derived2 : Derived {
int c;
};
Here, an object of classDerived2 will have a subobject of classDerived which in turn will have a subobject of class
Base. —end example]
4 A base-specifier followed by an ellipsis is a pack expansion (13.7.4).
5 The order in which the base class subobjects are allocated in the most derived object (6.8.2) is unspecified.
[Note 3: A derived class and its base class subobjects can be represented by a directed acyclic graph (DAG) where an
arrow means “directly derived from” (see Figure 3). An arrow need not have a physical representation in memory. A
DAG of subobjects is often referred to as a “subobject lattice”.—end note]
6 [Note 4: Initialization of objects representing base classes can be specified in constructors; see 11.9.3.—end note]
7 [Note 5: A base class subobject can have a layout different from the layout of a most derived object of the same type.
A base class subobject can have a polymorphic behavior (11.9.5) different from the polymorphic behavior of a most
derived object of the same type. A base class subobject can be of zero size; however, two subobjects that have the
same class type and that belong to the same most derived object cannot be allocated at the same address (6.8.2).
—end note]
11.7.2 Multiple base classes [class.mi]
1 A class can be derived from any number of base classes.
§ 11.7.2 © ISO/IEC
335

===== PAGE 347 =====

Dxxxx
Base
Derived1
Derived2
Figure 3 — Directed acyclic graph [fig:class.dag]
[Note 1: The use of more than one direct base class is often called multiple inheritance.—end note]
[Example 1:
class A { /* ... */ };
class B { /* ... */ };
class C { /* ... */ };
class D : public A, public B, public C { /* ... */ };
—end example]
2 [Note 2: The order of derivation is not significant except as specified by the semantics of initialization by constructor
(11.9.3), cleanup (11.4.7), and storage layout (11.4, 11.8.2).—end note]
3 A class shall not be specified as a direct base class of a derived class more than once.
[Note 3: A class can be an indirect base class more than once and can be a direct and an indirect base class. There
are limited things that can be done with such a class; lookup that finds its non-static data members and member
functions in the scope of the derived class will be ambiguous. However, the static members, enumerations and types
can be unambiguously referred to.—end note]
[Example 2:
class X { /* ... */ };
class Y : public X, public X { /* ... */ }; // error
class L { public: int next; /* ... */ };
class A : public L { /* ... */ };
class B : public L { /* ... */ };
class C : public A, public B { void f(); /* ... */ }; // well-formed
class D : public A, public L { void f(); /* ... */ }; // well-formed
—end example]
4 A base class specifier that does not contain the keywordvirtual specifies anon-virtual base class. A base
class specifier that contains the keywordvirtual specifies avirtual base class. For each distinct occurrence
of a non-virtual base class in the class lattice of the most derived class, the most derived object (6.8.2)
shall contain a corresponding distinct base class subobject of that type. For each distinct base class that is
specified virtual, the most derived object shall contain a single base class subobject of that type.
5 [Note 4: For an object of class typeC, each distinct occurrence of a (non-virtual) base classL in the class lattice ofC
corresponds one-to-one with a distinctL subobject within the object of typeC. Given the classC defined above, an
object of classC will have two subobjects of classL as shown in Figure 4.
L L
A B
C
Figure 4 — Non-virtual base [fig:class.nonvirt]
In such lattices, explicit qualification can be used to specify which subobject is meant. The body of functionC::f can
refer to the membernext of eachL subobject:
void C::f() { A::next = B::next; } // well-formed
§ 11.7.2 © ISO/IEC
336

===== PAGE 348 =====

Dxxxx
Without the A:: or B:: qualifiers, the definition ofC::f above would be ill-formed because of ambiguity (6.5.2).
—end note]
6 [Note 5: In contrast, consider the case with a virtual base class:
class V { /* ... */ };
class A : virtual public V { /* ... */ };
class B : virtual public V { /* ... */ };
class C : public A, public B { /* ... */ };
V
A B
C
Figure 5 — Virtual base [fig:class.virt]
For an objectc of class typeC, a single subobject of typeV is shared by every base class subobject ofc that has a
virtual base class of typeV. Given the classC defined above, an object of classC will have one subobject of classV,
as shown in Figure 5.—end note]
7 [Note 6: A class can have both virtual and non-virtual base classes of a given type.
class B { /* ... */ };
class X : virtual public B { /* ... */ };
class Y : virtual public B { /* ... */ };
class Z : public B { /* ... */ };
class AA : public X, public Y, public Z { /* ... */ };
For an object of classAA, allvirtual occurrences of base classB in the class lattice ofAA correspond to a singleB
subobject within the object of typeAA, and every other occurrence of a (non-virtual) base classB in the class lattice
of AA corresponds one-to-one with a distinctB subobject within the object of typeAA. Given the classAA defined
above, classAA has two subobjects of classB: Z’s B and the virtualB shared byX and Y, as shown in Figure 6.
B B
AA
X Y Z
Figure 6 — Virtual and non-virtual base [fig:class.virtnonvirt]
—end note]
11.7.3 Virtual functions [class.virtual]
1 A non-static member function is avirtual functionif it is first declared with the keywordvirtual or if it
overrides a virtual member function declared in a base class (see below).87
[Note 1: Virtual functions support dynamic binding and object-oriented programming.—end note]
A class with a virtual member function is called apolymorphic class.88
2 If a virtual member functionF is declared in a classB, and, in a classD derived (directly or indirectly)
from B, a declaration of a member functionG corresponds (6.4.1) to a declaration ofF, ignoring trailing
requires-clauses, thenG overrides89 F. For convenience, we say that any virtual function overrides itself. A
virtual member functionV of a class objectS is afinal overrider unless the most derived class (6.8.2) of
87) The use of thevirtual specifier in the declaration of an overriding function is valid but redundant (has empty semantics).
88) If all virtual functions are immediate functions, the class is still polymorphic even if its internal representation does not
otherwise require any additions for that polymorphic behavior.
89) A function with the same name but a different parameter list (Clause 12) as a virtual function is not necessarily virtual
and does not override. Access control (11.8) is not considered in determining overriding.
§ 11.7.3 © ISO/IEC
337

===== PAGE 349 =====

Dxxxx
which S is a base class subobject (if any) has another member function that overridesV. In a derived class,
if a virtual member function of a base class subobject has more than one final overrider, the program is
ill-formed.
[Example 1:
struct A {
virtual void f();
};
struct B : virtual A {
virtual void f();
};
struct C : B , virtual A {
using A::f;
};
void foo() {
C c;
c.f(); // calls B::f, the final overrider
c.C::f(); // calls A::f because of the using-declaration
}
—end example]
[Example 2:
struct A { virtual void f(); };
struct B : A { };
struct C : A { void f(); };
struct D : B, C { }; // OK,A::f and C::f are the final overriders
// for theB and C subobjects, respectively
—end example]
3 [Note 2: A virtual member function does not have to be visible to be overridden, for example,
struct B {
virtual void f();
};
struct D : B {
void f(int);
};
struct D2 : D {
void f();
};
the functionf(int) in classD hides the virtual functionf() in its base classB; D::f(int) is not a virtual function.
However,f() declared in classD2 has the same name and the same parameter list asB::f(), and therefore is a virtual
function that overrides the functionB::f() even thoughB::f() is not visible in classD2. —end note]
4 If a virtual functionf in some classB is marked with thevirt-specifier final and in a classD derived fromB
a functionD::f overrides B::f, the program is ill-formed.
[Example 3:
struct B {
virtual void f() const final;
};
struct D : B {
void f() const; // error: D::f attempts to overridefinal B::f
};
—end example]
5 If a virtual function is marked with thevirt-specifier override and does not override a member function of a
base class, the program is ill-formed.
[Example 4:
struct B {
virtual void f(int);
};
§ 11.7.3 © ISO/IEC
338

===== PAGE 350 =====

Dxxxx
struct D : B {
virtual void f(long) override; // error: wrong signature overridingB::f
virtual void f(int) override; // OK
};
—end example]
6 A virtual function shall not have a trailingrequires-clause (9.3).
[Example 5:
template<typename T>
struct A {
virtual void f() requires true; // error: virtual function cannot be constrained (13.5.3)
};
—end example]
7 The ref-qualifier, or lack thereof, of an overriding function shall be the same as that of the overridden function.
8 The return type of an overriding function shall be either identical to the return type of the overridden function
or covariant with the classes of the functions. If a functionD::f overrides a functionB::f, the return types
of the functions are covariant if they satisfy the following criteria:
—(8.1) both are pointers to classes, both are lvalue references to classes, or both are rvalue references to
classes90
—(8.2) the class in the return type ofB::f is the same class as the class in the return type ofD::f, or is an
unambiguous and accessible direct or indirect base class of the class in the return type ofD::f
—(8.3) both pointers or references have the same cv-qualification and the class type in the return type ofD::f
has the same cv-qualification as or less cv-qualification than the class type in the return type ofB::f.
9 If the class type in the covariant return type ofD::f differs from that ofB::f, the class type in the return
type ofD::f shall be complete at the locus (6.4.2) of the overriding declaration or shall be the class typeD.
When the overriding function is called as the final overrider of the overridden function, its result is converted
to the type returned by the (statically chosen) overridden function (7.6.1.3).
[Example 6:
class B { };
class D : private B { friend class Derived; };
struct Base {
virtual void vf1();
virtual void vf2();
virtual void vf3();
virtual B* vf4();
virtual B* vf5();
void f();
};
struct No_good : public Base {
D* vf4(); // error: B (base class ofD) inaccessible
};
class A;
struct Derived : public Base {
void vf1(); // virtual and overridesBase::vf1()
void vf2(int); // not virtual, hidesBase::vf2()
char vf3(); // error: invalid difference in return type only
D* vf4(); // OK, returns pointer to derived class
A* vf5(); // error: returns pointer to incomplete class
void f();
};
void g() {
Derived d;
Base* bp = &d; // standard conversion:
90) Multi-level pointers to classes or references to multi-level pointers to classes are not allowed.
§ 11.7.3 © ISO/IEC
339

===== PAGE 351 =====

Dxxxx
// Derived* to Base*
bp->vf1(); // calls Derived::vf1()
bp->vf2(); // calls Base::vf2()
bp->f(); // calls Base::f() (not virtual)
B* p = bp->vf4(); // calls Derived::vf4() and converts the
// result toB*
Derived* dp = &d;
D* q = dp->vf4(); // calls Derived::vf4() and does not
// convert the result toB*
dp->vf2(); // error: argument mismatch
}
—end example]
10 [Note 3: The interpretation of the call of a virtual function depends on the type of the object for which it is called
(the dynamic type), whereas the interpretation of a call of a non-virtual member function depends only on the type of
the pointer or reference denoting that object (the static type) (7.6.1.3).—end note]
11 [Note 4: The virtual specifier implies membership, so a virtual function cannot be a non-member (9.2.3) function.
Nor can a virtual function be a static member, since a virtual function call relies on a specific object for determining
which function to invoke. A virtual function declared in one class can be declared a friend (11.8.4) in another class.
—end note]
12 A virtual function declared in a class shall be defined, or declared pure (11.7.4) in that class, or both; no
diagnostic is required (6.3).
13 [Example 7: Here are some uses of virtual functions with multiple base classes:
struct A {
virtual void f();
};
struct B1 : A { // note non-virtual derivation
void f();
};
struct B2 : A {
void f();
};
struct D : B1, B2 { // D has two separateA subobjects
};
void foo() {
D d;
// A* ap = &d; // would be ill-formed: ambiguous
B1* b1p = &d;
A* ap = b1p;
D* dp = &d;
ap->f(); // calls D::B1::f
dp->f(); // error: ambiguous
}
In classD above there are two occurrences of classA and hence two occurrences of the virtual member functionA::f.
The final overrider ofB1::A::f is B1::f and the final overrider ofB2::A::f is B2::f. —end example]
14 [Example 8: The following example shows a function that does not have a unique final overrider:
struct A {
virtual void f();
};
struct VB1 : virtual A { // note virtual derivation
void f();
};
struct VB2 : virtual A {
void f();
};
§ 11.7.3 © ISO/IEC
340

===== PAGE 352 =====

Dxxxx
struct Error : VB1, VB2 { // error
};
struct Okay : VB1, VB2 {
void f();
};
Both VB1::f and VB2::f override A::f but there is no overrider of both of them in classError. This example is
therefore ill-formed. ClassOkay is well-formed, however, becauseOkay::f is a final overrider.—end example]
15 [Example 9: The following example uses the well-formed classes from above.
struct VB1a : virtual A { // does not declaref
};
struct Da : VB1a, VB2 {
};
void foe() {
VB1a* vb1ap = new Da;
vb1ap->f(); // calls VB2::f
}
—end example]
16 Explicit qualification with the scope operator (7.5.5.3) suppresses the virtual call mechanism.
[Example 10:
class B { public: virtual void f(); };
class D : public B { public: void f(); };
void D::f() { /* ... */ B::f(); }
Here, the function call inD::f really does callB::f and notD::f. —end example]
17 A deleted function (9.6) shall not override a function that is not deleted. Likewise, a function that is not
deleted shall not override a deleted function.
18 A class with aconsteval virtual function that overrides a virtual function that is notconsteval shall have
consteval-only type (6.9.1). Aconsteval virtual function shall not be overridden by a virtual function that
is notconsteval.
11.7.4 Abstract classes [class.abstract]
1 [Note 1: The abstract class mechanism supports the notion of a general concept, such as ashape, of which only more
concrete variants, such ascircle and square, can actually be used. An abstract class can also be used to define an
interface for which derived classes provide a variety of implementations.—end note]
2 A virtual function is specified as apure virtual functionby using apure-specifier (11.4) in the function
declaration in the class definition.
[Note 2: Such a function might be inherited: see below.—end note]
A class is anabstract classif it has at least one pure virtual function.
[Note 3: An abstract class can be used only as a base class of some other class; no objects of an abstract class can be
created except as subobjects of a class derived from it (6.2, 11.4).—end note]
A pure virtual function need be defined only if called with, or as if with (11.4.7), thequalified-id syntax (7.5.5.3).
[Example 1:
class point { /* ... */ };
class shape { // abstract class
point center;
public:
point where() { return center; }
void move(point p) { center=p; draw(); }
virtual void rotate(int) = 0; // pure virtual
virtual void draw() = 0; // pure virtual
};
—end example]
§ 11.7.4 © ISO/IEC
341

===== PAGE 353 =====

Dxxxx
[Note 4: A function declaration cannot provide both apure-specifier and a definition. —end note]
[Example 2:
struct C {
virtual void f() = 0 { }; // error
};
—end example]
3 [Note 5: An abstract class type cannot be used as a parameter or return type of a function being defined (9.3.4.6) or
called (7.6.1.3), except as specified in 9.2.9.3. Further, an abstract class type cannot be used as the type of an explicit
type conversion (7.6.1.9, 7.6.1.10, 7.6.1.11), because the resulting prvalue would be of abstract class type (7.2.1).
However, pointers and references to abstract class types can appear in such contexts.—end note]
4 A class is abstract if it has at least one pure virtual function for which the final overrider is pure virtual.
[Example 3:
class ab_circle : public shape {
int radius;
public:
void rotate(int) { }
// ab_circle::draw() is a pure virtual
};
Since shape::draw() is a pure virtual functionab_circle::draw() is a pure virtual by default. The alternative
declaration,
class circle : public shape {
int radius;
public:
void rotate(int) { }
void draw(); // a definition is required somewhere
};
would make classcircle non-abstract and a definition ofcircle::draw() must be provided. —end example]
5 [Note 6: An abstract class can be derived from a class that is not abstract, and a pure virtual function can override a
virtual function which is not pure.—end note]
6 Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a
virtual call (11.7.3) to a pure virtual function directly or indirectly for the object being created (or destroyed)
from such a constructor (or destructor) is undefined.
11.8 Member access control [class.access]
11.8.1 General [class.access.general]
1 A member of a class can be
—(1.1) private, that is, it can be named only by members and friends of the class in which it is declared;
—(1.2) protected, that is, it can be named only by members and friends of the class in which it is declared, by
classes derived from that class, and by their friends (see 11.8.5); or
—(1.3) public, that is, it can be named anywhere without access restriction.
[Note 1: A constructor or destructor can be named by an expression (6.3) even though it has no name.—end note]
2 A member of a class can also access all the members to which the class has access. A local class of a member
function may access the same members that the member function itself may access.91
3 Members of a class defined with the keywordclass are private by default. Members of a class defined with
the keywordsstruct or union are public by default.
[Example 1:
class X {
int a; // X::a is private by default
};
91) Access permissions are thus transitive and cumulative to nested and local classes.
§ 11.8.1 © ISO/IEC
342

===== PAGE 354 =====

Dxxxx
struct S {
int a; // S::a is public by default
};
—end example]
4 Access control is applied uniformly to declarations and expressions.
[Note 2: Access control applies to members nominated by friend declarations (11.8.4) andusing-declarations (9.10).
—end note]
When ausing-declarator is named, access control is applied to it, not to the declarations that replace it. For
an overload set, access control is applied only to the function selected by overload resolution.
[Example 2:
struct S {
void f(int);
private:
void f(double);
};
void g(S* sp) {
sp->f(2); // OK, access control applied after overload resolution
}
—end example]
[Note 3: Because access control applies to the declarations named, if access control is applied to a type alias, only the
accessibility of the typedef or alias declaration itself is considered. The accessibility of the underlying entity is not
considered.
[Example 3:
class A {
class B { };
public:
typedef B BB;
};
void f() {
A::BB x; // OK, typedefA::BB is public
A::B y; // access error,A::B is private
}
—end example]
—end note]
5 [Note 4: Access control does not prevent members from being found by name lookup or implicit conversions to base
classes from being considered.—end note]
The interpretation of a given construct is established without regard to access control. If the interpretation
established makes use of inaccessible members or base classes, the construct is ill-formed.
6 All access controls in 11.8 affect the ability to name a class member from the declaration of a particular
entity, including parts of the declaration preceding the name of the entity being declared and, if the entity is
a class, the definitions of members of the class appearing outside the class’smember-specification.
[Note 5: This access also applies to implicit references to constructors, conversion functions, and destructors.—end
note]
7 [Example 4:
class A {
typedef int I; // private member
I f() pre(A::x > 0);
friend I g(I) post(A::x <= 0);
static I x;
template<int> struct Q;
template<int> friend struct R;
protected:
struct B { };
};
§ 11.8.1 © ISO/IEC
343

===== PAGE 355 =====

Dxxxx
A::I A::f() pre(A::x > 0) { return 0; }
A::I g(A::I p = A::x) post(A::x <= 0);
A::I g(A::I p) { return 0; }
A::I A::x = 0;
template<A::I> struct A::Q { };
template<A::I> struct R { };
struct D: A::B, A { };
Here, all the uses ofA::I are well-formed becauseA::f, A::x, and A::Q are members of classA and g and R are
friends of classA. This implies, for example, that access checking on the first use ofA::I must be deferred until
it is determined that this use ofA::I is as the return type of a member of classA. Similarly, the use ofA::B as a
base-specifier is well-formed becauseD is derived fromA, so checking ofbase-specifiers must be deferred until the entire
base-specifier-list has been seen. —end example]
8 Access is checked for a default argument (9.3.4.7) at the point of declaration, rather than at any points of
use of the default argument. Access checking for default arguments in function templates and in member
functions of class templates is performed as described in 13.9.2.
9 Access for a defaulttemplate-argument (13.2) is checked in the context in which it appears rather than at any
points of use of it.
[Example 5:
class B { };
template <class T> class C {
protected:
typedef T TT;
};
template <class U, class V = typename U::TT>
class D : public U { };
D <C<B> >* d; // access error,C::TT is protected
—end example]
11.8.2 Access specifiers [class.access.spec]
1 Member declarations can be labeled by anaccess-specifier (11.7):
access-specifier : member-specificationopt
An access-specifier specifies the access rules for members following it until the end of the class or until another
access-specifier is encountered.
[Example 1:
class X {
int a; // X::a is private by default:class used
public:
int b; // X::b is public
int c; // X::c is public
};
—end example]
2 Any number of access specifiers is allowed and no particular order is required.
[Example 2:
struct S {
int a; // S::a is public by default:struct used
protected:
int b; // S::b is protected
private:
int c; // S::c is private
public:
int d; // S::d is public
};
—end example]
§ 11.8.2 © ISO/IEC
344

===== PAGE 356 =====

Dxxxx
3 When a member is redeclared within its class definition, the access specified at its redeclaration shall be the
same as at its initial declaration.
[Example 3:
struct S {
class A;
enum E : int;
private:
class A { }; // error: cannot change access
enum E: int { e0 }; // error: cannot change access
};
—end example]
4 [Note 1: In a derived class, the lookup of a base class name will find the injected-class-name instead of the name of
the base class in the scope in which it was declared. The injected-class-name might be less accessible than the name
of the base class in the scope in which it was declared.—end note]
[Example 4:
class A { };
class B : private A { };
class C : public B {
A* p; // error: injected-class-nameA is inaccessible
::A* q; // OK
};
—end example]
11.8.3 Accessibility of base classes and base class members [class.access.base]
1 If a class is declared to be a base class (11.7) for another class using thepublic access specifier, the public
members of the base class are accessible as public members of the derived class and protected members of the
base class are accessible as protected members of the derived class. If a class is declared to be a base class
for another class using theprotected access specifier, the public and protected members of the base class
are accessible as protected members of the derived class. If a class is declared to be a base class for another
class using theprivate access specifier, the public and protected members of the base class are accessible as
private members of the derived class.92
2 In the absence of anaccess-specifier for a base class,public is assumed when the derived class is defined
with theclass-key struct and private is assumed when the class is defined with theclass-key class.
[Example 1:
class B { /* ... */ };
class D1 : private B { /* ... */ };
class D2 : public B { /* ... */ };
class D3 : B { /* ... */ }; // B private by default
struct D4 : public B { /* ... */ };
struct D5 : private B { /* ... */ };
struct D6 : B { /* ... */ }; // B public by default
class D7 : protected B { /* ... */ };
struct D8 : protected B { /* ... */ };
Here B is a public base ofD2, D4, andD6, a private base ofD1, D3, andD5, and a protected base ofD7 and D8. —end
example]
3 [Note 1: A member of a private base class can be inaccessible as inherited, but accessible directly. Because of the
rules on pointer conversions (7.3.12) and explicit casts (7.6.1.4, 7.6.1.9, 7.6.3), a conversion from a pointer to a derived
class to a pointer to an inaccessible base class can be ill-formed if an implicit conversion is used, but well-formed if an
explicit cast is used.
[Example 2:
class B {
public:
int mi; // non-static member
static int si; // static member
};
92) As specified previously in 11.8, private members of a base class remain inaccessible even to derived classes unless friend
declarations within the base class definition are used to grant access explicitly.
§ 11.8.3 © ISO/IEC
345

===== PAGE 357 =====

Dxxxx
class D : private B {
};
class DD : public D {
void f();
};
void DD::f() {
mi = 3; // error: mi is private inD
si = 3; // error: si is private inD
::B b;
b.mi = 3; // OK (b.mi is different fromthis->mi)
b.si = 3; // OK (b.si is different fromthis->si)
::B::si = 3; // OK
::B* bp1 = this; // error: B is a private base class
::B* bp2 = (::B*)this; // OK with cast
bp2->mi = 3; // OK, access through a pointer toB.
}
—end example]
—end note]
4 A base classB of N is accessible at R, if
—(4.1) an invented public member ofB would be a public member ofN, or
—(4.2) R occurs in a direct member or friend of classN, and an invented public member ofB would be a private
or protected member ofN, or
—(4.3) R occurs in a direct member or friend of a classP derived fromN, and an invented public member ofB
would be a private or protected member ofP, or
—(4.4) there exists a classS such thatB is a base class ofS accessible atR and S is a base class ofN accessible
at R.
[Example 3:
class B {
public:
int m;
};
class S: private B {
friend class N;
};
class N: private S {
void f() {
B* p = this; // OK because classS satisfies the fourth condition above:B is a base class ofN
// accessible inf() becauseB is an accessible base class ofS and S is an accessible
// base class ofN.
}
};
—end example]
5 If a base class is accessible, one can implicitly convert a pointer to a derived class to a pointer to that base
class (7.3.12, 7.3.13).
[Note 2: It follows that members and friends of a classX can implicitly convert anX* to a pointer to a private or
protected immediate base class ofX. —end note]
An expression E that designates a memberm has a designating class that affects the access tom. This
designating class is either
—(5.1) the innermost class of whichm is directly a member ifE is asplice-expression or
—(5.2) the class in whose scope name lookup performed a search that foundm otherwise.
[Note 3: This class can be explicit, e.g., when aqualified-id is used, or implicit, e.g., when a class member access
operator (7.6.1.5) is used (including cases where an implicit “this->” is added). If both a class member access
§ 11.8.3 © ISO/IEC
346

===== PAGE 358 =====

Dxxxx
operator and aqualified-id are used to name the member (as inp->T::m), the class designating the member is the
class designated by thenested-name-specifier of thequalified-id (that is,T). —end note]
A memberm is accessible at the pointR when designated in classN if
—(5.3) m is designated by asplice-expression, or
—(5.4) m as a member ofN is public, or
—(5.5) m as a member ofN is private, andR occurs in a direct member or friend of classN, or
—(5.6) m as a member ofN is protected, andR occurs in a direct member or friend of classN, or in a member
of a classP derived fromN, wherem as a member ofP is public, private, or protected, or
—(5.7) there exists a base classB of N that is accessible atR, andm is accessible atR when designated in class
B.
[Example 4:
class B;
class A {
private:
int i;
friend void f(B*);
};
class B : public A { };
void f(B* p) {
p->i = 1; // OK,B* can be implicitly converted toA*, and f has access toi in A
}
—end example]
6 If a class member access operator, including an implicit “this->”, is used to access a non-static data member
or non-static member function, the reference is ill-formed if the left operand (considered as a pointer in the
“.” operator case) cannot be implicitly converted to a pointer to the designating class of the right operand.
[Note 4: This requirement is in addition to the requirement that the member be accessible as designated.—end note]
11.8.4 Friends [class.friend]
1 A friend of a class is a function or class that is given permission to name the private and protected members
of the class. A class specifies its friends, if any, by way of friend declarations. Such declarations give special
access rights to the friends, but they do not make the nominated friends members of the befriending class.
[Example 1: The following example illustrates the differences between members and friends:
class X {
int a;
friend void friend_set(X*, int);
public:
void member_set(int);
};
void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }
void f() {
X obj;
friend_set(&obj,10);
obj.member_set(10);
}
—end example]
2 Declaring a class to be a friend implies that private and protected members of the class granting friendship
can be named in thebase-specifiers and member declarations of the befriended class.
[Example 2:
class A {
class B { };
friend class X;
};
§ 11.8.4 © ISO/IEC
347

===== PAGE 359 =====

Dxxxx
struct X : A::B { // OK,A::B accessible to friend
A::B mx; // OK,A::B accessible to member of friend
class Y {
A::B my; // OK,A::B accessible to nested member of friend
};
};
—end example]
[Example 3:
class X {
enum { a=100 };
friend class Y;
};
class Y {
int v[X::a]; // OK,Y is a friend ofX
};
class Z {
int v[X::a]; // error: X::a is private
};
—end example]
3 A friend declaration that does not declare a function shall be afriend-type-declaration.
[Note 1: A friend declaration can be thedeclaration in atemplate-declaration (13.1, 13.7.5). —end note]
If afriend-type-specifier in a friend declaration designates a (possibly cv-qualified) class type, that class is
declared as a friend; otherwise, thefriend-type-specifier is ignored.
[Example 4:
class C;
typedef C Ct;
class E;
class X1 {
friend C; // OK,class C is a friend
};
class X2 {
friend Ct; // OK,class C is a friend
friend D; // error: D not found
friend class D; // OK, elaborated-type-specifier declares new class
};
template <typename ... Ts> class R {
friend Ts...;
};
template <class... Ts, class... Us>
class R<R<Ts...>, R<Us...>> {
friend Ts::Nested..., Us...;
};
R<C> rc; // class C is a friend ofR<C>
R<C, E> rce; // classesC and E are friends ofR<C, E>
R<int> Ri; // OK, “friend int;” is ignored
struct E { struct Nested; };
R<R<E>, R<C, int>> rr; // E::Nested and C are friends ofR<R<E>, R<C, int>>
—end example]
4 [Note 2: A friend declaration refers to an entity, not (all overloads of) a name. A member function of a classX can be
a friend of a classY.
§ 11.8.4 © ISO/IEC
348

===== PAGE 360 =====

Dxxxx
[Example 5:
class Y {
friend char* X::foo(int);
friend X::X(char); // constructors can be friends
friend X::~X(); // destructors can be friends
};
—end example]
—end note]
5 A function may be defined in a friend declaration of a class if and only if the class is a non-local class (11.6)
and the function name is unqualified.
[Example 6:
class M {
friend void f() { } // definition of globalf, a friend ofM,
// not the definition of a member function
};
—end example]
6 Such a function is implicitly an inline (9.2.8) function if it is attached to the global module.
[Note 3: If a friend function is defined outside a class, it is not in the scope of the class.—end note]
7 No storage-class-specifier shall appear in thedecl-specifier-seq of a friend declaration.
8 A member nominated by a friend declaration shall be accessible in the class containing the friend declaration.
The meaning of the friend declaration is the same whether the friend declaration appears in the private,
protected, or public (11.4) portion of the classmember-specification.
9 Friendship is neither inherited nor transitive.
[Example 7:
class A {
friend class B;
int a;
};
class B {
friend class C;
};
class C {
void f(A* p) {
p->a++; // error: C is not a friend ofA despite being a friend of a friend
}
};
class D : public B {
void f(A* p) {
p->a++; // error: D is not a friend ofA despite being derived from a friend
}
};
—end example]
10 [Note 4: A friend declaration never binds any names (9.3.4, 9.2.9.5).—end note]
[Example 8:
// Assumef and g have not yet been declared.
void h(int);
template <class T> void f2(T);
namespace A {
class X {
friend void f(X); // A::f(X) is a friend
class Y {
friend void g(); // A::g is a friend
friend void h(int); // A::h is a friend
§ 11.8.4 © ISO/IEC
349

===== PAGE 361 =====

Dxxxx
// ::h not considered
friend void f2<>(int); // ::f2<>(int) is a friend
};
};
// A::f, A::g and A::h are not visible here
X x;
void g() { f(x); } // definition ofA::g
void f(X) { /* ... */ } // definition ofA::f
void h(int) { /* ... */ } // definition ofA::h
// A::f, A::g and A::h are visible here and known to be friends
}
using A::x;
void h() {
A::f(x);
A::X::f(x); // error: f is not a member ofA::X
A::X::Y::g(); // error: g is not a member ofA::X::Y
}
—end example]
[Example 9:
class X;
void a();
void f() {
class Y;
extern void b();
class A {
friend class X; // OK, butX is a local class, not::X
friend class Y; // OK
friend class Z; // OK, introduces local classZ
friend void a(); // error,::a is not considered
friend void b(); // OK
friend void c(); // error
};
X* px; // OK, but::X is found
Z* pz; // error: noZ is found
}
—end example]
11.8.5 Protected member access [class.protected]
1 An additional access check beyond those described earlier in 11.8 is applied when a non-static data member
or non-static member function is a protected member of its designating class (11.8.3) and is not designated
by asplice-expression.93 As described earlier, access to a protected member is granted because the reference
occurs in a friend or direct member of some classC. If the access is to form a pointer to member (7.6.2.2), the
nested-name-specifier shall designateC or a class derived fromC. Otherwise, if the access involves a (possibly
implicit) object expression (7.5.5.1, 7.6.1.5), the class of the object expression shall beC or a class derived
from C.
[Example 1:
class B {
protected:
int i;
static int j;
};
class D1 : public B {
};
93) This additional check does not apply to other members, e.g., static data members or enumerator member constants.
§ 11.8.5 © ISO/IEC
350

===== PAGE 362 =====

Dxxxx
class D2 : public B {
friend void fr(B*,D1*,D2*);
void mem(B*,D1*);
};
void fr(B* pb, D1* p1, D2* p2) {
pb->i = 1; // error
p1->i = 2; // error
p2->i = 3; // OK (access through aD2)
p2->B::i = 4; // OK (access through aD2, even though designating class isB)
int B::* pmi_B = &B::i; // error
int B::* pmi_B2 = &D2::i; // OK (type of&D2::i is int B::*)
B::j = 5; // error: not a friend of designating classB
D2::j = 6; // OK (because refers to static member)
}
void D2::mem(B* pb, D1* p1) {
pb->i = 1; // error
p1->i = 2; // error
i = 3; // OK (access throughthis)
B::i = 4; // OK (access throughthis, qualification ignored)
int B::* pmi_B = &B::i; // error
int B::* pmi_B2 = &D2::i; // OK
j = 5; // OK (becausej refers to static member)
B::j = 6; // OK (becauseB::j refers to static member)
}
void g(B* pb, D1* p1, D2* p2) {
pb->i = 1; // error
p1->i = 2; // error
p2->i = 3; // error
}
—end example]
11.8.6 Access to virtual functions [class.access.virt]
1 The access rules (11.8) for a virtual function are determined by its declaration and are not affected by the
rules for a function that later overrides it.
[Example 1:
class B {
public:
virtual int f();
};
class D : public B {
private:
int f();
};
void f() {
D d;
B* pb = &d;
D* pd = &d;
pb->f(); // OK,B::f() is public,D::f() is invoked
pd->f(); // error: D::f() is private
}
—end example]
2 Access is checked at the call point using the type of the expression used to denote the object for which the
member function is called (B* in the example above). The access of the member function in the class in
which it was defined (D in the example above) is in general not known.
§ 11.8.6 © ISO/IEC
351

===== PAGE 363 =====

Dxxxx
11.8.7 Multiple access [class.paths]
1 If a declaration can be reached by several paths through a multiple inheritance graph, the access is that of
the path that gives most access.
[Example 1:
class W { public: void f(); };
class A : private virtual W { };
class B : public virtual W { };
class C : public A, public B {
void f() { W::f(); } // OK
};
Since W::f() is available toC::f() along the public path throughB, access is allowed.—end example]
11.8.8 Nested classes [class.access.nest]
1 A nested class is a member and as such has the same access rights as any other member. The members of an
enclosing class have no special access to members of a nested class; the usual access rules (11.8) shall be
obeyed.
[Example 1:
class E {
int x;
class B { };
class I {
B b; // OK,E::I can accessE::B
int y;
void f(E* p, int i) {
p->x = i; // OK,E::I can accessE::x
}
};
int g(I* p) {
return p->y; // error: I::y is private
}
};
—end example]
11.9 Initialization [class.init]
11.9.1 General [class.init.general]
1 When no initializer is specified for an object of (possibly cv-qualified) class type (or array thereof), or the
initializer has the form(), the object is initialized as specified in 9.5.
2 An object of class type (or array thereof) can be explicitly initialized; see 11.9.2 and 11.9.3.
3 When an array of class objects is initialized (either explicitly or implicitly) and the elements are initialized
by constructor, the constructor shall be called for each element of the array, following the subscript order;
see 9.3.4.5.
[Note 1: Destructors for the array elements are called in reverse order of their construction.—end note]
11.9.2 Explicit initialization [class.expl.init]
1 An object of class type can be initialized with a parenthesizedexpression-list, where the expression-list
is construed as an argument list for a constructor that is called to initialize the object. Alternatively,
a single assignment-expression can be specified as aninitializer using the = form of initialization. Either
direct-initialization semantics or copy-initialization semantics apply; see 9.5.
[Example 1:
struct complex {
complex();
complex(double);
complex(double,double);
};
§ 11.9.2 © ISO/IEC
352

===== PAGE 364 =====

Dxxxx
complex sqrt(complex,complex);
complex a(1); // initialized by callingcomplex(double) with argument1
complex b = a; // initialized as a copy ofa
complex c = complex(1,2); // initialized by callingcomplex(double,double) with arguments1 and 2
complex d = sqrt(b,c); // initialized by callingsqrt(complex,complex) with d as its result object
complex e; // initialized by callingcomplex()
complex f = 3; // initialized by callingcomplex(double) with argument3
complex g = { 1, 2 }; // initialized by callingcomplex(double, double) with arguments1 and 2
—end example]
[Note 1: Overloading of the assignment operator (12.4.3.2) has no effect on initialization.—end note]
2 An object of class type can also be initialized by abraced-init-list. List-initialization semantics apply; see 9.5
and 9.5.5.
[Example 2:
complex v[6] = { 1, complex(1,2), complex(), 2 };
Here, complex::complex(double) is called for the initialization of v[0] and v[3], complex::complex(double,
double) is called for the initialization ofv[1], complex::complex() is called for the initialization ofv[2], v[4], and
v[5]. For another example,
struct X {
int i;
float f;
complex c;
} x = { 99, 88.8, 77.7 };
Here, x.i is initialized with 99, x.f is initialized with 88.8, and complex::complex(double) is called for the
initialization ofx.c. —end example]
[Note 2: Braces can be elided in theinitializer-list for any aggregate, even if the aggregate has members of a class type
with user-defined type conversions; see 9.5.2.—end note]
3 [Note 3: If T is a class type with no default constructor, any initializing declaration of an object of typeT (or array
thereof) is ill-formed if noinitializer is explicitly specified (see 11.9 and 9.5).—end note]
4 [Note 4: The order in which objects with static or thread storage duration are initialized is described in 6.10.3.3
and 8.10. —end note]
11.9.3 Initializing bases and members [class.base.init]
1 In the definition of a constructor for a class, initializers for direct and virtual base class subobjects and
non-static data members can be specified by actor-initializer, which has the form
ctor-initializer:
: mem-initializer-list
mem-initializer-list:
mem-initializer ...opt
mem-initializer-list , mem-initializer ...opt
mem-initializer:
mem-initializer-id ( expression-listopt )
mem-initializer-id braced-init-list
mem-initializer-id:
class-or-decltype
identifier
2 Lookup for an unqualified name in amem-initializer-id ignores the constructor’s function parameter scope.
[Note 1: If the constructor’s class contains a member with the same name as a direct or virtual base class of the class,
a mem-initializer-id naming the member or base class and composed of a single identifier refers to the class member. A
mem-initializer-id for the hidden base class can be specified using a qualified name.—end note]
Unless themem-initializer-id names the constructor’s class, a direct non-static data member of the constructor’s
class, or a direct or virtual base of that class, themem-initializer is ill-formed.
3 A mem-initializer-list can initialize a base class using anyclass-or-decltype that denotes that base class type.
§ 11.9.3 © ISO/IEC
353

===== PAGE 365 =====

Dxxxx
[Example 1:
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { } // mem-initializer for baseA
—end example]
4 If amem-initializer-id is ambiguous because it designates both a direct non-virtual base class and an indirect
virtual base class, themem-initializer is ill-formed.
[Example 2:
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { } // error: whichA?
—end example]
5 A ctor-initializer may initialize a variant member of the constructor’s class. If actor-initializer specifies more
than onemem-initializer for the same member or for the same base class, thector-initializer is ill-formed.
6 A mem-initializer-list can delegate to another constructor of the constructor’s class using anyclass-or-decltype
that denotes the constructor’s class itself. If amem-initializer-id designates the constructor’s class, it shall
be the onlymem-initializer; the constructor is adelegating constructor, and the constructor selected by the
mem-initializer is thetarget constructor. The target constructor is selected by overload resolution. Once the
target constructor returns, the body of the delegating constructor is executed. If a constructor delegates to
itself directly or indirectly, the program is ill-formed, no diagnostic required.
[Example 3:
struct C {
C( int ) { } // #1: non-delegating constructor
C(): C(42) { } // #2: delegates to #1
C( char c ) : C(42.0) { } // #3: ill-formed due to recursion with #4
C( double d ) : C('a') { } // #4: ill-formed due to recursion with #3
};
—end example]
7 The expression-list or braced-init-list in amem-initializer is used to initialize the designated subobject (or, in
the case of a delegating constructor, the complete class object) according to the initialization rules of 9.5 for
direct-initialization.
[Example 4:
struct B1 { B1(int); /* ... */ };
struct B2 { B2(int); /* ... */ };
struct D : B1, B2 {
D(int);
B1 b;
const int c;
};
D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4) { /* ... */ }
D d(10);
—end example]
[Note 2: The initialization performed by eachmem-initializer constitutes a full-expression (6.10.1). Any expression in
a mem-initializer is evaluated as part of the full-expression that performs the initialization.—end note]
A mem-initializer where themem-initializer-id denotes a virtual base class is ignored during execution of a
constructor of any class that is not the most derived class.
8 A temporary expression bound to a reference member in amem-initializer is ill-formed.
[Example 5:
struct A {
A() : v(42) { } // error
§ 11.9.3 © ISO/IEC
354

===== PAGE 366 =====

Dxxxx
const int& v;
};
—end example]
9 In a non-delegating constructor other than an implicitly-defined copy/move constructor (11.4.5.3), if a given
potentially constructed subobject is not designated by amem-initializer-id (including the case where there is
no mem-initializer-list because the constructor has noctor-initializer), then
—(9.1) if the entity is a non-static data member that has a default member initializer (11.4) and either
—(9.1.1) the constructor’s class is a union (11.5), and no other variant member of that union is designated
by amem-initializer-id or
—(9.1.2) the constructor’s class is not a union, and, if the entity is a member of an anonymous union, no
other member of that union is designated by amem-initializer-id,
the entity is initialized from its default member initializer as specified in 9.5;
—(9.2) otherwise, if the entity is an anonymous union or a variant member (11.5.2), no initialization is
performed;
—(9.3) otherwise, the entity is default-initialized (9.5).
[Note 3: An abstract class (11.7.4) is never a most derived class, thus its constructors never initialize virtual base
classes, therefore the correspondingmem-initializers can be omitted.—end note]
An attempt to initialize more than one non-static data member of a union renders the program ill-formed.
[Note 4: After the call to a constructor for classX for an object with automatic or dynamic storage duration has
completed, if the constructor was not invoked as part of value-initialization and a member ofX is neither initialized
nor given a value during execution of thecompound-statement of the body of the constructor, the member has an
indeterminate or erroneous value (6.8.5).—end note]
[Example 6:
struct A {
A();
};
struct B {
B(int);
};
struct C {
C() { } // initializes members as follows:
A a; // OK, callsA::A()
const B b; // error: B has no default constructor
int i; // OK,i has indeterminate or erroneous value
int j = 5; // OK,j has the value5
};
—end example]
10 If a given non-static data member has both a default member initializer and amem-initializer, the initialization
specified by themem-initializer is performed, and the non-static data member’s default member initializer is
ignored.
[Example 7: Given
struct A {
int i = /∗ some integer expression with side effects∗/ ;
A(int arg) : i(arg) { }
// ...
};
the A(int) constructor will simply initializei to the value ofarg, and the side effects ini’s default member initializer
will not take place.—end example]
11 A temporary expression bound to a reference member from a default member initializer is ill-formed.
[Example 8:
struct A {
A() = default; // OK
§ 11.9.3 © ISO/IEC
355

===== PAGE 367 =====

Dxxxx
A(int v) : v(v) { } // OK
const int& v = 42; // OK
};
A a1; // error: ill-formed binding of temporary to reference
A a2(1); // OK, unfortunately
—end example]
12 In a non-delegating constructor, the destructor for each potentially constructed subobject of class type is
potentially invoked (11.4.7).
[Note 5: This provision ensures that destructors can be called for fully-constructed subobjects in case an exception is
thrown (14.3). —end note]
13 In a non-delegating constructor, initialization proceeds in the following order:
—(13.1) First, and only for the constructor of the most derived class (6.8.2), virtual base classes are initialized in
the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes,
where “left-to-right” is the order of appearance of the base classes in the derived classbase-specifier-list.
—(13.2) Then, direct base classes are initialized in declaration order as they appear in thebase-specifier-list
(regardless of the order of themem-initializers).
—(13.3) Then, non-static data members are initialized in the order they were declared in the class definition
(again regardless of the order of themem-initializers).
—(13.4) Finally, thecompound-statement of the constructor body is executed.
[Note 6: The declaration order is mandated to ensure that base and member subobjects are destroyed in the reverse
order of initialization. —end note]
14 [Example 9:
struct V {
V();
V(int);
};
struct A : virtual V {
A();
A(int);
};
struct B : virtual V {
B();
B(int);
};
struct C : A, B, virtual V {
C();
C(int);
};
A::A(int i) : V(i) { /* ... */ }
B::B(int i) { /* ... */ }
C::C(int i) { /* ... */ }
V v(1); // useV(int)
A a(2); // useV(int)
B b(3); // useV()
C c(4); // useV()
—end example]
15 [Note 7: The expression-list or braced-init-list of amem-initializer is in the function parameter scope of the constructor
and can usethis to refer to the object being initialized.—end note]
[Example 10:
class X {
int a;
int b;
§ 11.9.3 © ISO/IEC
356

===== PAGE 368 =====

Dxxxx
int i;
int j;
public:
const int& r;
X(int i): r(a), b(i), i(i), j(this->i) { }
};
initializes X::r to refer toX::a, initializesX::b with the value of the constructor parameteri, initializesX::i with
the value of the constructor parameteri, and initializesX::j with the value ofX::i; this takes place each time an
object of classX is created. —end example]
16 Member functions (including virtual member functions, 11.7.3) can be called for an object under construction
or destruction. Similarly, an object under construction or destruction can be the operand of thetypeid
operator (7.6.1.8) or of a dynamic_cast (7.6.1.7). However, if these operations are performed during
evaluation of
—(16.1) a ctor-initializer (or in a function called directly or indirectly from actor-initializer) before all the
mem-initializers for base classes have completed,
—(16.2) a precondition assertion of a constructor, or
—(16.3) a postcondition assertion of a destructor (9.4.1),
the program has undefined behavior.
[Example 11:
class A {
public:
A(int);
};
class B : public A {
int j;
public:
int f();
B() : A(f()), // undefined behavior: calls member function but baseA not yet initialized
j(f()) { } // well-defined: bases are all initialized
};
class C {
public:
C(int);
};
class D : public B, C {
int i;
public:
D() : C(f()), // undefined behavior: calls member function but baseC not yet initialized
i(f()) { } // well-defined: bases are all initialized
};
—end example]
17 [Note 8: 11.9.5 describes the results of virtual function calls,typeid and dynamic_casts during construction for the
well-defined cases; that is, describes the polymorphic behavior of an object under construction.—end note]
18 A mem-initializer followed by an ellipsis is a pack expansion (13.7.4) that initializes the base classes specified
by a pack expansion in thebase-specifier-list for the class.
[Example 12:
template<class... Mixins>
class X : public Mixins... {
public:
X(const Mixins&... mixins) : Mixins(mixins)... { }
};
—end example]
§ 11.9.3 © ISO/IEC
357

===== PAGE 369 =====

Dxxxx
11.9.4 Initialization by inherited constructor [class.inhctor.init]
1 When a constructor for typeB is invoked to initialize an object of a different typeD (that is, when the
constructor was inherited (9.10)), initialization proceeds as if a defaulted default constructor were used to
initialize theD object and each base class subobject from which the constructor was inherited, except that
the B subobject is initialized by the inherited constructor if the base class subobject were to be initialized
as part of theD object (11.9.3). The invocation of the inherited constructor, including the evaluation of
any arguments, is omitted if theB subobject is not to be initialized as part of theD object. The complete
initialization is considered to be a single function call; in particular, unless omitted, the initialization of the
inherited constructor’s parameters is sequenced before the initialization of any part of theD object.
[Example 1:
struct B1 {
B1(int, ...) { }
};
struct B2 {
B2(double) { }
};
int get();
struct D1 : B1 {
using B1::B1; // inheritsB1(int, ...)
int x;
int y = get();
};
void test() {
D1 d(2, 3, 4); // OK,B1 is initialized by callingB1(2, 3, 4),
// then d.x is default-initialized (no initialization is performed),
// then d.y is initialized by callingget()
D1 e; // error: D1 has no default constructor
}
struct D2 : B2 {
using B2::B2;
B1 b;
};
D2 f(1.0); // error: B1 has no default constructor
struct W { W(int); };
struct X : virtual W { using W::W; X() = delete; };
struct Y : X { using X::X; };
struct Z : Y, virtual W { using Y::Y; };
Z z(0); // OK, initialization ofY does not invoke default constructor ofX
template<class T> struct Log : T {
using T::T; // inherits all constructors from classT
~Log() { std::clog << "Destroying wrapper" << std::endl; }
};
Class templateLog wraps any class and forwards all of its constructors, while writing a message to the standard log
whenever an object of classLog is destroyed. —end example]
[Example 2:
struct V { V() = default; V(int); };
struct Q { Q(); };
struct A : virtual V, Q {
using V::V;
A() = delete;
};
int bar() { return 42; }
§ 11.9.4 © ISO/IEC
358

===== PAGE 370 =====

Dxxxx
struct B : A {
B() : A(bar()) {} // OK
};
struct C : B {};
void foo() { C c; } // bar is not invoked, because theV subobject is not initialized as part ofB
—end example]
2 If the constructor was inherited from multiple base class subobjects of typeB, the program is ill-formed.
[Example 3:
struct A { A(int); };
struct B : A { using A::A; };
struct C1 : B { using B::B; };
struct C2 : B { using B::B; };
struct D1 : C1, C2 {
using C1::C1;
using C2::C2;
};
struct V1 : virtual B { using B::B; };
struct V2 : virtual B { using B::B; };
struct D2 : V1, V2 {
using V1::V1;
using V2::V2;
};
D1 d1(0); // error: ambiguous
D2 d2(0); // OK, initializes virtualB base class, which initializes theA base class
// then initializes theV1 and V2 base classes as if by a defaulted default constructor
struct M { M(); M(int); };
struct N : M { using M::M; };
struct O : M {};
struct P : N, O { using N::N; using O::O; };
P p(0); // OK, useM(0) to initializeN’s base class,
// useM() to initializeO’s base class
—end example]
3 When an object is initialized by an inherited constructor, initialization of the object is complete when the
initialization of all subobjects is complete.
11.9.5 Construction and destruction [class.cdtor]
1 For an object with a non-trivial constructor, referring to any non-static member or base class of the object
before the constructor begins execution results in undefined behavior. For an object with a non-trivial
destructor, referring to any non-static member or base class of the object after the destructor finishes execution
results in undefined behavior.
[Example 1:
struct X { int i; };
struct Y : X { Y(); }; // non-trivial
struct A { int a; };
struct B : public A { int j; Y y; }; // non-trivial
extern B bobj;
B* pb = &bobj; // OK
int* p1 = &bobj.a; // undefined behavior: refers to base class member
int* p2 = &bobj.y.i; // undefined behavior: refers to member’s member
A* pa = &bobj; // undefined behavior: upcast to a base class type
B bobj; // definition ofbobj
§ 11.9.5 © ISO/IEC
359

===== PAGE 371 =====

Dxxxx
extern X xobj;
int* p3 = &xobj.i; // OK, all constructors ofX are trivial
X xobj;
For another example,
struct W { int j; };
struct X : public virtual W { };
struct Y {
int* p;
X x;
Y() : p(&x.j) { // undefined,x is not yet constructed
}
};
—end example]
2 During the construction of an object, if the value of any of its subobjects or any element of its object
representation is accessed through a glvalue that is not obtained, directly or indirectly, from the constructor’s
this pointer, the value thus obtained is unspecified.
[Example 2:
struct C;
void no_opt(C*);
struct C {
int c;
C() : c(0) { no_opt(this); }
};
const C cobj;
void no_opt(C* cptr) {
int i = cobj.c * 100; // value ofcobj.c is unspecified
cptr->c = 1;
cout << cobj.c * 100 // value ofcobj.c is unspecified
<< '\n';
}
extern struct D d;
struct D {
D(int a) : a(a), b(d.a) {}
int a, b;
};
D d = D(1); // value ofd.b is unspecified
—end example]
3 To explicitly or implicitly convert a pointer (a glvalue) referring to an object of classX to a pointer (reference)
to a direct or indirect base classB of X, the construction ofX and the construction of all of its direct or
indirect bases that directly or indirectly derive fromB shall have started and the destruction of these classes
shall not have completed, otherwise the conversion results in undefined behavior. To form a pointer to (or
access the value of) a direct non-static member of an objectobj, the construction ofobj shall have started
and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing
the member value) results in undefined behavior.
[Example 3:
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };
struct E : C, D, X {
E() : D(this), // undefined behavior: upcast fromE* to A* might use pathE* →D* →A*
// but D is not constructed
§ 11.9.5 © ISO/IEC
360

===== PAGE 372 =====

Dxxxx
// “D((C*)this)” would be defined:E* →C* is defined becauseE() has started,
// and C* →A* is defined becauseC is fully constructed
X(this) {} // defined: upon construction ofX, C/B/D/A sublattice is fully constructed
};
—end example]
4 Memberfunctions, includingvirtualfunctions(11.7.3), canbecalledduringconstructionordestruction(11.9.3).
When a virtual function is called directly or indirectly from a constructor or from a destructor, including
during the construction or destruction of the class’s non-static data members, or during the evaluation of a
postcondition assertion of a constructor or a precondition assertion of a destructor (9.4.1), and the object to
which the call applies is the object (call itx) under construction or destruction, the function called is the
final overrider in the constructor’s or destructor’s class and not one overriding it in a more-derived class.
If the virtual function call uses an explicit class member access (7.6.1.5) and the object expression refers
to the complete object ofx or one of that object’s base class subobjects but notx or one of its base class
subobjects, the behavior is undefined.
[Example 4:
struct V {
virtual void f();
virtual void g();
};
struct A : virtual V {
virtual void f();
};
struct B : virtual V {
virtual void g();
B(V*, A*);
};
struct D : A, B {
virtual void f();
virtual void g();
D() : B((A*)this, this) { }
};
B::B(V* v, A* a) {
f(); // calls V::f, not A::f
g(); // calls B::g, not D::g
v->g(); // v is base ofB, the call is well-defined, callsB::g
a->f(); // undefined behavior:a’s type not a base ofB
}
—end example]
5 The typeid operator (7.6.1.8) can be used during construction or destruction (11.9.3). Whentypeid is
used in a constructor (including themem-initializer or default member initializer (11.4) for a non-static
data member) or in a destructor, or used in a function called (directly or indirectly) from a constructor or
destructor, if the operand oftypeid refers to the object under construction or destruction,typeid yields the
std::type_info object representing the constructor or destructor’s class. If the operand oftypeid refers to
the object under construction or destruction and the static type of the operand is neither the constructor or
destructor’s class nor one of its bases, the behavior is undefined.
6 dynamic_casts (7.6.1.7) can be used during construction or destruction (11.9.3). When adynamic_cast is
used in a constructor (including themem-initializer or default member initializer for a non-static data member)
or in a destructor, or used in a function called (directly or indirectly) from a constructor or destructor, if the
operand of thedynamic_cast refers to the object under construction or destruction, this object is considered
to be a most derived object that has the type of the constructor or destructor’s class. If the operand of the
dynamic_cast refers to the object under construction or destruction and the static type of the operand is
not a pointer to or object of the constructor or destructor’s own class or one of its bases, thedynamic_cast
results in undefined behavior.
§ 11.9.5 © ISO/IEC
361

===== PAGE 373 =====

Dxxxx
[Example 5:
struct V {
virtual void f();
};
struct A : virtual V { };
struct B : virtual V {
B(V*, A*);
};
struct D : A, B {
D() : B((A*)this, this) { }
};
B::B(V* v, A* a) {
typeid(*this); // type_info for B
typeid(*v); // well-defined: *v has typeV, a base ofB yields type_info for B
typeid(*a); // undefined behavior: typeA not a base ofB
dynamic_cast<B*>(v); // well-defined: v of typeV*, V base of B results inB*
dynamic_cast<B*>(a); // undefined behavior:a has typeA*, A not a base ofB
}
—end example]
11.9.6 Copy/move elision [class.copy.elision]
1 When certain criteria are met, an implementation is allowed to omit the creation of a class object from
a source object of the same type (ignoring cv-qualification), even if the selected constructor and/or the
destructor for the object have side effects. In such cases, the implementation treats the source and target of
the omitted initialization as simply two different ways of referring to the same object. If the first parameter
of the selected constructor is an rvalue reference to the object’s type, the destruction of that object occurs
when the target would have been destroyed; otherwise, the destruction occurs at the later of the times when
the two objects would have been destroyed without the optimization.
[Note 1: Because only one object is destroyed instead of two, and the creation of one object is omitted, there is still
one object destroyed for each one constructed.—end note]
This elision of object creation, calledcopy elision, is permitted in the following circumstances (which may be
combined to eliminate multiple copies):
—(1.1) in areturn statement (8.8.4) in a function with a class return type, when theexpression is the name of
a non-volatile objecto with automatic storage duration (other than a function parameter or a variable
introduced by theexception-declaration of ahandler (14.4)), the copy-initialization of the result object
can be omitted by constructingo directly into the function call’s result object;
—(1.2) in athrow-expression (7.6.18), when the operand is the name of a non-volatile objecto with automatic
storage duration (other than a function parameter or a variable introduced by theexception-declaration
of ahandler) that belongs to a scope that does not contain the innermost enclosingcompound-statement
associated with atry-block (if there is one), the copy-initialization of the exception object can be
omitted by constructingo directly into the exception object;
—(1.3) in a coroutine (9.6.4), a copy of a coroutine parameter can be omitted and references to that copy
replaced with references to the corresponding parameter if the meaning of the program will be unchanged
except for the execution of a constructor and destructor for the parameter copy object;
—(1.4) when theexception-declaration of ahandler (14.4) declares an objecto, the copy-initialization ofo can
be omitted by treating theexception-declaration as an alias for the exception object if the meaning of
the program will be unchanged except for the execution of constructors and destructors for the object
declared by theexception-declaration.
[Note 2: There cannot be a move from the exception object because it is always an lvalue.—end note]
Copy elision is not permitted where an expression is evaluated in a context requiring a constant expression (7.7)
and in constant initialization (6.10.3.2).
[Note 3: It is possible that copy elision is performed if the same expression is evaluated in another context.—end
note]
§ 11.9.6 © ISO/IEC
362

===== PAGE 374 =====

Dxxxx
2 [Example 1:
class Thing {
public:
Thing();
~Thing();
Thing(const Thing&);
};
Thing f() {
Thing t;
return t;
}
Thing t2 = f();
struct A {
void *p;
constexpr A(): p(this) {}
};
constexpr A g() {
A loc;
return loc;
}
constexpr A a; // well-formed,a.p points toa
constexpr A b = g(); // error: b.p would be dangling (7.7)
void h() {
A c = g(); // well-formed,c.p can point toc or be dangling
}
Here the criteria for elision can eliminate the copying of the objectt with automatic storage duration into the result
object for the function callf(), which is the non-local objectt2. Effectively, the construction oft can be viewed as
directly initializingt2, and that object’s destruction will occur at program exit. Adding a move constructor toThing
has the same effect, but it is the move construction from the object with automatic storage duration tot2 that is
elided. —end example]
3 [Example 2:
class Thing {
public:
Thing();
~Thing();
Thing(Thing&&);
private:
Thing(const Thing&);
};
Thing f(bool b) {
Thing t;
if (b)
throw t; // OK,Thing(Thing&&) used (or elided) to throwt
return t; // OK,Thing(Thing&&) used (or elided) to returnt
}
Thing t2 = f(false); // OK, no extra copy/move performed,t2 constructed by call tof
struct Weird {
Weird();
Weird(Weird&);
};
Weird g(bool b) {
static Weird w1;
§ 11.9.6 © ISO/IEC
363

===== PAGE 375 =====

Dxxxx
Weird w2;
if (b)
return w1; // OK, usesWeird(Weird&)
else
return w2; // error: w2 in this context is an xvalue
}
int& h(bool b, int i) {
static int s;
if (b)
return s; // OK
else
return i; // error: i is an xvalue
}
decltype(auto) h2(Thing t) {
return t; // OK,t is an xvalue andh2’s return type isThing
}
decltype(auto) h3(Thing t) {
return (t); // OK,(t) is an xvalue andh3’s return type isThing&&
}
—end example]
4 [Example 3:
template<class T> void g(const T&);
template<class T> void f() {
T x;
try {
T y;
try { g(x); }
catch (...) {
if (/∗...∗/)
throw x; // does not move
throw y; // moves
}
g(y);
} catch(...) {
g(x);
g(y); // error: y is not in scope
}
}
—end example]
11.10 Comparisons [class.compare]
11.10.1 Defaulted comparison operator functions [class.compare.default]
1 A defaulted comparison operator function (12.4.3) shall be a non-template function that
—(1.1) is a non-static member or friend of some classC,
—(1.2) is defined as defaulted inC or in a context whereC is complete, and
—(1.3) either has two parameters of typeconst C& or two parameters of typeC, where the implicit object
parameter (if any) is considered to be the first parameter.
Such a comparison operator function is termed a defaulted comparison operator function for classC. Name
lookups and access checks in the implicit definition (9.6.2) of a comparison operator function are performed
from a context equivalent to itsfunction-body. A definition of a comparison operator as defaulted that
appears in a class shall be the first declaration of that function.
[Example 1:
struct S;
bool operator==(S, S) = default; // error: S is not complete
§ 11.10.1 © ISO/IEC
364

===== PAGE 376 =====

Dxxxx
struct S {
friend bool operator==(S, const S&) = default; // error: parameters of different types
};
enum E { };
bool operator==(E, E) = default; // error: not a member or friend of a class
—end example]
2 A defaulted<=> or == operator function for classC is defined as deleted if any non-static data member ofC
is of reference type orC has variant members (11.5.2).
3 A binary operator expressiona @ b is usable if either
—(3.1) a or b is of class or enumeration type and overload resolution (12.2) as applied toa @ b results in a
usable candidate, or
—(3.2) neither a nor b is of class or enumeration type anda @ b is a valid expression.
4 If the member-specification does not explicitly declare any member or friend namedoperator==, an ==
operator function is declared implicitly for each three-way comparison operator function defined as defaulted
in themember-specification, with the same access andfunction-definition and in the same class scope as the
respective three-way comparison operator function, except that the return type is replaced withbool and
the declarator-id is replaced withoperator==.
[Note 1: Such an implicitly-declared== operator for a classX is defined as defaulted in the definition ofX and has
the sameparameter-declaration-clause and trailingrequires-clause as the respective three-way comparison operator.
It is declared withfriend, virtual, constexpr, orconsteval if the three-way comparison operator function is so
declared. If the three-way comparison operator function has nonoexcept-specifier, the implicitly-declared== operator
function has an implicit exception specification (14.5) that can differ from the implicit exception specification of the
three-way comparison operator function.—end note]
[Example 2:
template<typename T> struct X {
friend constexpr std::partial_ordering operator<=>(X, X) requires (sizeof(T) != 1) = default;
// implicitly declares:friend constexpr bool operator==(X, X) requires (sizeof(T) != 1) = default;
[[nodiscard]] virtual std::strong_ordering operator<=>(const X&) const = default;
// implicitly declares:[[nodiscard]] virtual bool operator==(const X&) const = default;
};
—end example]
[Note 2: The == operator function is declared implicitly even if the defaulted three-way comparison operator function
is defined as deleted.—end note]
5 The direct base class subobjects ofC, in the order of their declaration in thebase-specifier-list of C, followed
by the non-static data members ofC, in the order of their declaration in themember-specification of C,
form a list of subobjects. In that list, any subobject of array type is recursively expanded to the sequence
of its elements, in the order of increasing subscript. Letxi be an lvalue denoting theith element in the
expanded list of subobjects for an objectx (of lengthn), wherexi is formed by a sequence of derived-to-base
conversions (12.2.4.2), class member access expressions (7.6.1.5), and array subscript expressions (7.6.1.2)
applied tox.
11.10.2 Equality operator [class.eq]
1 A defaulted equality operator function (12.4.3) shall have a declared return typebool.
2 A defaulted== operator function for a classC is defined as deleted unless, for eachxi in the expanded list of
subobjects for an objectx of typeC, xi == xi is usable (11.10.1).
3 The return value of a defaulted== operator function with parametersx and y is determined by comparing
corresponding elementsxi and yi in the expanded lists of subobjects forx and y (in increasing index order)
until the first indexiwhere xi == yi yields a result value which, when contextually converted tobool, yields
false. The return value isfalse if such an index exists andtrue otherwise.
4 [Example 1:
struct D {
int i;
friend bool operator==(const D& x, const D& y) = default;
§ 11.10.2 © ISO/IEC
365

===== PAGE 377 =====

Dxxxx
// OK, returnsx.i == y.i
};
—end example]
11.10.3 Three-way comparison [class.spaceship]
1 The synthesized three-way comparisonof typeR (17.12.2) of glvaluesa and b of the same type is defined as
follows:
—(1.1) If a <=> b is usable (11.10.1) and can be explicitly converted toR using static_cast, static_-
cast<R>(a <=> b).
—(1.2) Otherwise, if a <=> b is usable or overload resolution fora <=> b is performed and finds at least one
viable candidate, the synthesized three-way comparison is not defined.
—(1.3) Otherwise, if R is not a comparison category type, or either the expressiona == b or the expressiona
< b is not usable, the synthesized three-way comparison is not defined.
—(1.4) Otherwise, ifR is strong_ordering, then
a == b ? strong_ordering::equal :
a < b ? strong_ordering::less :
strong_ordering::greater
—(1.5) Otherwise, ifR is weak_ordering, then
a == b ? weak_ordering::equivalent :
a < b ? weak_ordering::less :
weak_ordering::greater
—(1.6) Otherwise (whenR is partial_ordering),
a == b ? partial_ordering::equivalent :
a < b ? partial_ordering::less :
b < a ? partial_ordering::greater :
partial_ordering::unordered
[Note 1: A synthesized three-way comparison is ill-formed if overload resolution finds usable candidates that do not
otherwise meet the requirements implied by the defined expression.—end note]
2 Let R be the declared return type of a defaulted three-way comparison operator function, and letxi be the
elements of the expanded list of subobjects for an objectx of typeC.
—(2.1) If R is auto, then letcvi Ri be the type of the expressionxi <=> xi. The operator function is defined
as deleted if that expression is not usable or ifRi is not a comparison category type (17.12.2.1) for any
i. The return type is deduced as the common comparison type (see below) ofR0, R1, ... , Rn−1.
—(2.2) Otherwise, R shall not contain a placeholder type. If the synthesized three-way comparison of typeR
between any objectsxi and xi is not defined, the operator function is defined as deleted.
3 The return value of typeR of the defaulted three-way comparison operator function with parametersx and y of
the same type is determined by comparing corresponding elementsxi and yi in the expanded lists of subobjects
forxandy(in increasing index order) until the first indexiwhere the synthesized three-way comparison of type
R between xi and yi yields a result valuevi where vi != 0, contextually converted tobool, yieldstrue. The
return value is a copy ofvi if such an index exists andstatic_cast<R>(std::strong_ordering::equal)
otherwise.
4 The common comparison typeU of a possibly-empty list ofn comparison category typesT0, T1, ... , Tn−1 is
defined as follows:
—(4.1) If at least oneTi is std::partial_ordering, U is std::partial_ordering (17.12.2.2).
—(4.2) Otherwise, if at least oneTi is std::weak_ordering, U is std::weak_ordering (17.12.2.3).
—(4.3) Otherwise, U is std::strong_ordering (17.12.2.4).
[Note 2: In particular, this is the result whenn is 0. —end note]
11.10.4 Secondary comparison operators [class.compare.secondary]
1 A secondary comparison operatoris a relational operator (7.6.9) or the!= operator. A defaulted operator
function (12.4.3) for a secondary comparison operator@ shall have a declared return typebool.
2 The operator function with parametersx and y is defined as deleted if
§ 11.10.4 © ISO/IEC
366

===== PAGE 378 =====

Dxxxx
—(2.1) a first overload resolution (12.2), as applied tox @ y,
—(2.1.1) does not result in a usable candidate, or
—(2.1.2) the selected candidate is not a rewritten candidate, or
—(2.2) a second overload resolution for the expression resulting from the interpretation ofx @ y using the
selected rewritten candidate (12.2.2.3) does not result in a usable candidate (for example, that expression
might be(x <=> y) @ 0), or
—(2.3) x @ y cannot be implicitly converted tobool.
In any of the two overload resolutions above, the defaulted operator function is not considered as a candidate
for the@ operator. Otherwise, the operator function yieldsx @ y.
3 [Example 1:
struct HasNoLessThan { };
struct C {
friend HasNoLessThan operator<=>(const C&, const C&);
bool operator<(const C&) const = default; // OK, function is deleted
};
—end example]
§ 11.10.4 © ISO/IEC
367

===== PAGE 379 =====

Dxxxx
12 Overloading [over]
12.1 Preamble [over.pre]
1 [Note 1: Each of two or more entities with the same name in the same scope, which must be functions or function
templates, is commonly called an “overload”.—end note]
2 When a function is designated in a call, which function declaration is being referenced and the validity of
the call are determined by comparing the types of the arguments at the point of use with the types of the
parameters in the declarations in the overload set. This function selection process is calledoverload resolution
and is defined in 12.2.
[Note 2: Overload sets are formed byid-expressions naming functions and function templates and bysplice-expressions
designating entities of the same kinds.—end note]
[Example 1:
double abs(double);
int abs(int);
abs(1); // calls abs(int);
abs(1.0); // calls abs(double);
—end example]
12.2 Overload resolution [over.match]
12.2.1 General [over.match.general]
1 Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are
to be the arguments of the call and a set ofcandidate functionsthat can be called based on the context of
the call. The selection criteria for the best function are the number of arguments, how well the arguments
match the parameter-type-list of the candidate function, how well (for non-static member functions) the
object matches the object parameter, and certain other properties of the candidate function.
[Note 1: The function selected by overload resolution is not guaranteed to be appropriate for the context. Other
restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed.—end note]
2 Overload resolution selects the function to call in seven distinct contexts within the language:
—(2.1) invocation of a function named in the function call syntax (12.2.2.2.2);
—(2.2) invocation of a function call operator, a pointer-to-function conversion function, a reference-to-pointer-
to-function conversion function, or a reference-to-function conversion function on a class object named
in the function call syntax (12.2.2.2.3);
—(2.3) invocation of the operator referenced in an expression (12.2.2.3);
—(2.4) invocation of a constructor for default- or direct-initialization (9.5) of a class object (12.2.2.4);
—(2.5) invocation of a user-defined conversion for copy-initialization (9.5) of a class object (12.2.2.5);
—(2.6) invocation of a conversion function for initialization of an object of a non-class type from an expression
of class type (12.2.2.6); and
—(2.7) invocation of a conversion function for conversion in which a reference (9.5.4) will be directly bound
(12.2.2.7).
Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way.
But, once the candidate functions and argument lists have been identified, the selection of the best function
is the same in all cases:
—(2.8) First, a subset of the candidate functions (those that have the proper number of arguments and meet
certain other conditions) is selected to form a set of viable functions (12.2.3).
—(2.9) Then the best viable function is selected based on the implicit conversion sequences (12.2.4.2) needed
to match each argument to the corresponding parameter of each viable function.
§ 12.2.1 © ISO/IEC
368

===== PAGE 380 =====

Dxxxx
3 If a best viable function exists and is unique, overload resolution succeeds and produces it as the result.
Otherwise overload resolution fails and the invocation is ill-formed. When overload resolution succeeds, and
the best viable function is not accessible (11.8) in the context in which it is used, the program is ill-formed.
4 Overload resolution results in ausable candidateif overload resolution succeeds and the selected candidate is
either not a function (12.5), or is a function that is not deleted and is accessible from the context in which
overload resolution was performed.
12.2.2 Candidate functions and argument lists [over.match.funcs]
12.2.2.1 General [over.match.funcs.general]
1 The subclauses of 12.2.2 describe the set of candidate functions and the argument list submitted to overload
resolution in each context in which overload resolution is used. The source transformations and constructions
defined in these subclauses are only for the purpose of describing the overload resolution process. An
implementation is not required to use such transformations and constructions.
2 The set of candidate functions can contain both member and non-member functions to be resolved against
the same argument list. If a member function is
—(2.1) an implicit object member function that is not a constructor, or
—(2.2) a static member function and the argument list includes an implied object argument,
it is considered to have an extra first parameter, called theimplicit object parameter, which represents the
object for which the member function has been called.
3 Similarly, when appropriate, the context can construct an argument list that contains animplied object
argument as the first argument in the list to denote the object to be operated on.
4 For implicit object member functions, the type of the implicit object parameter is
—(4.1) “lvalue reference tocv X” for functions declared without aref-qualifier or with the& ref-qualifier
—(4.2) “rvalue reference tocv X” for functions declared with the&& ref-qualifier
where X is the class of which the function is a direct member andcv is the cv-qualification on the member
function declaration.
[Example 1: For aconst member function of classX, the extra parameter is assumed to have type “lvalue reference to
const X”. —end example]
For conversion functions that are implicit object member functions, the function is considered to be a member
of the class of the implied object argument for the purpose of defining the type of the implicit object parameter.
For non-conversion functions that are implicit object member functions nominated by ausing-declaration in
a derived class, the function is considered to be a member of the derived class for the purpose of defining
the type of the implicit object parameter. For static member functions, the implicit object parameter is
considered to match any object (since if the function is selected, the object is discarded).
[Note 1: No actual type is established for the implicit object parameter of a static member function, and no attempt
will be made to determine a conversion sequence for that parameter (12.2.4).—end note]
5 During overload resolution, the implied object argument is indistinguishable from other arguments. The
implicit object parameter, however, retains its identity since no user-defined conversions can be applied to
achieve a type match with it. For implicit object member functions declared without aref-qualifier, even if
the implicit object parameter is not const-qualified, an rvalue can be bound to the parameter as long as in all
other respects the argument can be converted to the type of the implicit object parameter.
[Note 2: The fact that such an argument is an rvalue does not affect the ranking of implicit conversion sequences
(12.2.4.3). —end note]
6 Because other than in list-initialization only one user-defined conversion is allowed in an implicit conversion
sequence, special rules apply when selecting the best user-defined conversion (12.2.4, 12.2.4.2).
[Example 2:
class T {
public:
T();
};
§ 12.2.2.1 © ISO/IEC
369

===== PAGE 381 =====

Dxxxx
class C : T {
public:
C(int);
};
T a = 1; // error: no viable conversion (T(C(1)) not considered)
—end example]
7 In each case where conversion functions of a classS are considered for initializing an object or reference of
type T, the candidate functions include the result of a search for theconversion-function-id operator T in S.
[Note 3: This search can find a specialization of a conversion function template (6.5).—end note]
Each such case also defines sets ofpermissible typesfor explicit and non-explicit conversion functions; each
(non-template) conversion function that
—(7.1) is a non-hidden member ofS,
—(7.2) yields a permissible type, and,
—(7.3) for the former set, is non-explicit
is also a candidate function. If initializing an object, for any permissible typecv U, anycv2 U, cv2 U&, orcv2
U&& is also a permissible type. If the set of permissible types for explicit conversion functions is empty, any
candidates that are explicit are discarded.
8 In each case where a candidate is a function template, candidate function template specializations are
generated using template argument deduction (13.10.4, 13.10.3). If a constructor template or conversion
function template has anexplicit-specifier whose constant-expression is value-dependent (13.8.3), template
argument deduction is performed first and then, if the context admits only candidates that are not explicit and
the generated specialization is explicit (9.2.3), it will be removed from the candidate set. Those candidates
are then handled as candidate functions in the usual way.94 A given name can refer to, or a conversion
can consider, one or more function templates as well as a set of non-template functions. In such a case,
the candidate functions generated from each function template are combined with the set of non-template
candidate functions.
9 A defaulted move special member function (11.4.5.3, 11.4.6) that is defined as deleted is excluded from the
set of candidate functions in all contexts. A constructor inherited from class typeC (11.9.4) that has a
first parameter of type “reference tocv1 P” (including such a constructor instantiated from a template) is
excluded from the set of candidate functions when constructing an object of typecv2 D if the argument list
has exactly one argument andC is reference-related toP and P is reference-related toD.
[Example 3:
struct A {
A(); // #1
A(A &&); // #2
template<typename T> A(T &&); // #3
};
struct B : A {
using A::A;
B(const B &); // #4
B(B &&) = default; // #5, implicitly deleted
struct X { X(X &&) = delete; } x;
};
extern B b1;
B b2 = static_cast<B&&>(b1); // calls #4: #1 is not viable, #2, #3, and #5 are not candidates
struct C { operator B&&(); };
B b3 = C(); // calls #4
—end example]
94) The process of argument deduction fully determines the parameter types of the function template specializations, i.e.,
the parameters of function template specializations contain no template parameter types. Therefore, except where specified
otherwise, function template specializations and non-template functions (9.3.4.6) are treated equivalently for the remainder of
overload resolution.
§ 12.2.2.1 © ISO/IEC
370

===== PAGE 382 =====

Dxxxx
12.2.2.2 Function call syntax [over.match.call]
12.2.2.2.1 General [over.match.call.general]
1 In a function call (7.6.1.3)
postfix-expression ( expression-listopt )
if thepostfix-expression names at least one function or function template, overload resolution is applied as
specified in 12.2.2.2.2. If thepostfix-expression denotes an object of class type, overload resolution is applied
as specified in 12.2.2.2.3.
2 If thepostfix-expression is the address of an overload set, overload resolution is applied using that set as
described above.
[Note 1: No implied object argument is added in this case.—end note]
If the function selected by overload resolution is an implicit object member function, the program is ill-formed.
[Note 2: The resolution of the address of an overload set in other contexts is described in 12.3.—end note]
12.2.2.2.2 Call to designated function [over.call.func]
1 Of interest in 12.2.2.2.2 are only those function calls in which thepostfix-expression ultimately contains an
id-expression or splice-expression that designates one or more functions. Such apostfix-expression, perhaps
nested arbitrarily deep in parentheses, has one of the following forms:
postfix-expression:
postfix-expression . id-expression
postfix-expression . splice-expression
postfix-expression -> id-expression
postfix-expression -> splice-expression
id-expression
splice-expression
These represent two syntactic subcategories of function calls: qualified function calls and unqualified function
calls.
2 In qualified function calls, the function is designated by anid-expression or splice-expression E preceded by an
-> or . operator. Since the constructA->B is generally equivalent to(*A).B, the rest of Clause 12 assumes,
without loss of generality, that all member function calls have been normalized to the form that uses an
object and the. operator. Furthermore, Clause 12 assumes that thepostfix-expression that is the left operand
of the. operator has type “cv T” whereT denotes a class.95 The set of candidate functions either is the set
found by name lookup (6.5.2) ifE is anid-expression or is the set determined as specified in 7.5.9 ifE is a
splice-expression. The argument list is theexpression-list in the call augmented by the addition of the left
operand of the. operator in the normalized member function call as the implied object argument (12.2.2).
3 In unqualified function calls, the function is designated by anid-expression or asplice-expression E. The
set of candidate functions either is the set found by name lookup (6.5) ifE is anid-expression or is the set
determined as specified in 7.5.9 ifE is asplice-expression. The set of candidate functions consists either
entirely of non-member functions or entirely of member functions of some classT. In the former case or ifE is
either asplice-expression or the address of an overload set, the argument list is the same as theexpression-list
in the call. Otherwise, the argument list is theexpression-list in the call augmented by the addition of an
implied object argument as in a qualified function call. If the current class is, or is derived from,T, and the
keyword this (7.5.3) refers to it,
—(3.1) if the unqualified function call appears in a precondition assertion of a constructor or a postcondition
assertion of a destructor and overload resolution selects a non-static member function, the call is
ill-formed;
—(3.2) otherwise, the implied object argument is(*this).
Otherwise,
—(3.3) if overload resolution selects a non-static member function, the call is ill-formed;
—(3.4) otherwise, a contrived object of typeT becomes the implied object argument.96
95) Note that cv-qualifiers on the type of objects are significant in overload resolution for both glvalue and class prvalue objects.
96) An implied object argument is contrived to correspond to the implicit object parameter attributed to member functions
during overload resolution. It is not used in the call to the selected function. Since the member functions all have the same
implicit object parameter, the contrived object will not be the cause to select or reject a function.
§ 12.2.2.2.2 © ISO/IEC
371

===== PAGE 383 =====

Dxxxx
[Example 1:
struct C {
bool a();
void b() {
a(); // OK,(*this).a()
}
void c(this const C&); // #1
void c() &; // #2
static void c(int = 0); // #3
void d() {
c(); // error: ambiguous between #2 and #3
(C::c)(); // error: as above
(&(C::c))(); // error: cannot resolve address of overloadedthis->C::c (12.3)
(&C::c)(C{}); // selects #1
(&C::c)(*this); // error: selects #2, and is ill-formed (12.2.2.2.1)
(&C::c)(); // selects #3
}
void f(this const C&);
void g() const {
f(); // OK,(*this).f()
f(*this); // error: no viable candidate for(*this).f(*this)
this->f(); // OK
}
static void h() {
f(); // error: contrived object argument, but overload resolution
// picked a non-static member function
f(C{}); // error: no viable candidate
C{}.f(); // OK
}
void k(this int);
operator int() const;
void m(this const C& c) {
c.k(); // OK
}
C()
pre(a()) // error: impliedthis in constructor precondition
pre(this->a()) // OK
post(a()); // OK
~C()
pre(a()) // OK
post(a()) // error: impliedthis in destructor postcondition
post(this->a()); // OK
};
—end example]
12.2.2.2.3 Call to object of class type [over.call.object]
1 If thepostfix-expression E in the function call syntax evaluates to a class object of type “cv T”, then the set of
candidate functions includes at least the function call operators ofT. The function call operators ofT are the
results of a search for the nameoperator() in the scope ofT.
2 In addition, for each non-explicit conversion function declared inT of the form
operator conversion-type-id ( )cv-qualifier-seqopt ref-qualifieropt noexcept-specifieropt attribute-specifier-seqopt ;
§ 12.2.2.2.3 © ISO/IEC
372

===== PAGE 384 =====

Dxxxx
where the optionalcv-qualifier-seq is the same cv-qualification as, or a greater cv-qualification than,cv,
and whereconversion-type-id denotes the type “pointer to function of (P1,..., Pn) returningR”, or the type
“reference to pointer to function of (P1,..., Pn) returningR”, or the type “reference to function of (P1,..., Pn)
returning R”, asurrogate call functionwith the unique namecall-function and having a declaration of the
form
R call-function ( conversion-type-id F, P1 a1, ... , Pn an);
is also considered as a candidate function.
[Note 1: If a surrogate call function is selected by overload resolution, the behavior is as described in 12.4.4.—end
note]
Similarly, surrogate call functions are added to the set of candidate functions for each non-explicit conversion
function declared in a base class ofT provided the function is not hidden withinT by another intervening
declaration.97
3 The argument list submitted to overload resolution consists of the argument expressions present in the
function call syntax preceded by the implied object argument(E).
[Note 2: When comparing the call against the function call operators, the implied object argument is compared
against the object parameter of the function call operator. When comparing the call against a surrogate call function,
the implied object argument is compared against the first parameter of the surrogate call function.—end note]
[Example 1:
int f1(int);
int f2(float);
typedef int (*fp1)(int);
typedef int (*fp2)(float);
struct A {
operator fp1() { return f1; }
operator fp2() { return f2; }
} a;
int i = a(1); // calls f1 via pointer returned from conversion function
—end example]
12.2.2.3 Operators in expressions [over.match.oper]
1 If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is
assumed to be a built-in operator and interpreted according to 7.6.
[Note 1: Because ., .*, and :: cannot be overloaded, these operators are always built-in operators interpreted
according to 7.6.?: cannot be overloaded, but the rules in this subclause are used to determine the conversions to be
applied to the second and third operands when they have class or enumeration type (7.6.16).—end note]
[Example 1:
struct String {
String (const String&);
String (const char*);
operator const char* ();
};
String operator + (const String&, const String&);
void f() {
const char* p= "one" + "two"; // error: cannot add two pointers; overloadedoperator+ not considered
// because neither operand has class or enumeration type
int I = 1 + 1; // always evaluates to2 even if class or enumeration types exist
// that would perform the operation.
}
—end example]
2 If either operand has a type that is a class or an enumeration, a user-defined operator function can be declared
that implements this operator or a user-defined conversion can be necessary to convert the operand to a
type that is appropriate for a built-in operator. In this case, overload resolution is used to determine which
97) Note that this construction can yield candidate call functions that cannot be differentiated one from the other by overload
resolution because they have identical declarations or differ only in their return type. The call will be ambiguous if overload
resolution cannot select a match to the call that is uniquely better than such undifferentiable functions.
§ 12.2.2.3 © ISO/IEC
373

===== PAGE 385 =====

Dxxxx
operator function or built-in operator is to be invoked to implement the operator. Therefore, the operator
notation is first transformed to the equivalent function-call notation as summarized in Table 18 (where@
denotes one of the operators covered in the specified subclause). However, the operands are sequenced in the
order prescribed for the built-in operator (7.6).
Table 18 — Relationship between operator and function call notation [tab:over.match.oper]
Subclause Expression As member function As non-member function
12.4.2 @a (a).operator@ () operator@(a)
12.4.3 a@b (a).operator@ (b) operator@(a, b)
12.4.3.2 a=b (a).operator= (b)
12.4.5 a[b] (a).operator[](b)
12.4.6 a-> (a).operator->()
12.4.7 a@ (a).operator@ (0) operator@(a, 0)
3 For a unary operator@ with an operand of typecv1 T1, and for a binary operator@ with a left operand
of typecv1 T1 and a right operand of typecv2 T2, four sets of candidate functions, designatedmember
candidates, non-member candidates, built-in candidates, andrewritten candidates, are constructed as follows:
—(3.1) If T1 is a complete class type or a class currently being defined, the set of member candidates is the
result of a search foroperator@ in the scope ofT1; otherwise, the set of member candidates is empty.
—(3.2) For the operators=, [], or->, the set of non-member candidates is empty; otherwise, it includes the
result of unqualified lookup foroperator@ in the rewritten function call (6.5.3, 6.5.4), ignoring all
member functions. However, if no operand has a class type, only those non-member functions in the
lookup set that have a first parameter of typeT1 or “reference tocv T1”, whenT1 is an enumeration
type, or (if there is a right operand) a second parameter of typeT2 or “reference tocv T2”, whenT2 is
an enumeration type, are candidate functions.
—(3.3) For the operator,, the unary operator&, or the operator->, the built-in candidates set is empty.
For all other operators, the built-in candidates include all of the candidate operator functions defined
in 12.5 that, compared to the given operator,
—(3.3.1) have the same operator name, and
—(3.3.2) accept the same number of operands, and
—(3.3.3) accept operand types to which the given operand or operands can be converted according to
12.2.4.2, and
—(3.3.4) do not have the same parameter-type-list as any non-member candidate or rewritten non-member
candidate that is not a function template specialization.
—(3.4) The rewritten candidate set is determined as follows:
—(3.4.1) For the relational (7.6.9) operators, the rewritten candidates include all non-rewritten candidates
for the expressionx <=> y.
—(3.4.2) For the relational (7.6.9) and three-way comparison (7.6.8) operators, the rewritten candidates
also include a synthesized candidate, with the order of the two parameters reversed, for each
non-rewritten candidate for the expressiony <=> x.
—(3.4.3) For the!= operator (7.6.10), the rewritten candidates include all non-rewritten candidates for the
expression x == y that are rewrite targets with first operandx (see below).
—(3.4.4) For the equality operators, the rewritten candidates also include a synthesized candidate, with the
order of the two parameters reversed, for each non-rewritten candidate for the expressiony == x
that is a rewrite target with first operandy.
—(3.4.5) For all other operators, the rewritten candidate set is empty.
[Note 2: A candidate synthesized from a member candidate has its object parameter as the second parameter,
thus implicit conversions are considered for the first, but not for the second, parameter.—end note]
4 A non-template function or function templateF named operator== is a rewrite target with first operand
o unless a search for the nameoperator!= in the scopeS from the instantiation context of the operator
expressionfindsa functionor function templatethat would correspond(6.4.1) toFifits namewere operator==,
§ 12.2.2.3 © ISO/IEC
374

===== PAGE 386 =====

Dxxxx
where S is the scope of the class type ofo if F is a class member, and the namespace scope of whichF is a
member otherwise. A function template specialization namedoperator== is a rewrite target if its function
template is a rewrite target.
[Example 2:
struct A {};
template<typename T> bool operator==(A, T); // #1
bool a1 = 0 == A(); // OK, calls reversed #1
template<typename T> bool operator!=(A, T);
bool a2 = 0 == A(); // error, #1 is not a rewrite target
struct B {
bool operator==(const B&); // #2
};
struct C : B {
C();
C(B);
bool operator!=(const B&); // #3
};
bool c1 = B() == C(); // OK, calls #2; reversed #2 is not a candidate
// because search foroperator!= in C finds #3
bool c2 = C() == B(); // error: ambiguous between #2 found when searchingC and
// reversed #2 found when searchingB
struct D {};
template<typename T> bool operator==(D, T); // #4
inline namespace N {
template<typename T> bool operator!=(D, T); // #5
}
bool d1 = 0 == D(); // OK, calls reversed #4; #5 does not forbid #4 as a rewrite target
—end example]
5 For the first parameter of the built-in assignment operators, only standard conversion sequences (12.2.4.2.2)
are considered.
6 For all other operators, no such restrictions apply.
7 The set of candidate functions for overload resolution for some operator@ is the union of the member
candidates, the non-member candidates, the built-in candidates, and the rewritten candidates for that
operator @.
8 The argument list contains all of the operands of the operator. The best function from the set of candidate
functions is selected according to 12.2.3 and 12.2.4.98
[Example 3:
struct A {
operator int();
};
A operator+(const A&, const A&);
void m() {
A a, b;
a + b; // operator+(a, b) chosen over int(a) + int(b)
}
—end example]
9 If a rewrittenoperator<=> candidate is selected by overload resolution for an operator@, x @ y is interpreted
as 0 @ (y <=> x) if the selected candidate is a synthesized candidate with reversed order of parameters, or
(x <=> y) @ 0 otherwise, using the selected rewrittenoperator<=> candidate. Rewritten candidates for
the operator@ are not considered in the context of the resulting expression.
10 If a rewrittenoperator== candidate is selected by overload resolution for an operator@, its return type shall
be cv bool, andx @ y is interpreted as:
98) If the set of candidate functions is empty, overload resolution is unsuccessful.
§ 12.2.2.3 © ISO/IEC
375

===== PAGE 387 =====

Dxxxx
—(10.1) if @ is != and the selected candidate is a synthesized candidate with reversed order of parameters,!(y
== x),
—(10.2) otherwise, if@ is !=, !(x == y),
—(10.3) otherwise (when@ is ==), y == x,
in each case using the selected rewrittenoperator== candidate.
11 If a built-in candidate is selected by overload resolution, the operands of class type are converted to the
types of the corresponding parameters of the selected operation function, except that the second standard
conversion sequence of a user-defined conversion sequence (12.2.4.2.3) is not applied. Then the operator is
treated as the corresponding built-in operator and interpreted according to 7.6.
[Example 4:
struct X {
operator double();
};
struct Y {
operator int*();
};
int *a = Y() + 100.0; // error: pointer arithmetic requires integral operand
int *b = Y() + X(); // error: pointer arithmetic requires integral operand
—end example]
12 The second operand of operator-> is ignored in selecting anoperator-> function, and is not an argument
when theoperator-> function is called. Whenoperator-> returns, the operator-> is applied to the value
returned, with the original second operand.99
13 If the operator is the operator,, the unary operator&, or the operator->, and there are no viable functions,
then the operator is assumed to be the built-in operator and interpreted according to 7.6.
14 [Note 3: The lookup rules for operators in expressions are different than the lookup rules for operator function names
in a function call, as shown in the following example:
struct A { };
void operator + (A, A);
struct B {
void operator + (B);
void f ();
};
A a;
void B::f() {
operator+ (a,a); // error: global operator hidden by member
a + a; // OK, calls globaloperator+
}
—end note]
12.2.2.4 Initialization by constructor [over.match.ctor]
1 When objects of class type are direct-initialized (9.5), copy-initialized from an expression of the same or a
derived class type (9.5), or default-initialized (9.5), overload resolution selects the constructor. For direct-
initialization or default-initialization (including default-initialization in the context of copy-list-initialization),
the candidate functions are all the constructors of the class of the object being initialized. Otherwise,
the candidate functions are all the non-explicit constructors (11.4.8.2) of that class. The argument list
is the expression-list or assignment-expression of the initializer. For default-initialization in the context of
copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.
99) If the value returned by theoperator-> function has class type, this can result in selecting and calling anotheroperator->
function. The process repeats until anoperator-> function returns a value of non-class type.
§ 12.2.2.4 © ISO/IEC
376

===== PAGE 388 =====

Dxxxx
12.2.2.5 Copy-initialization of class by user-defined conversion [over.match.copy]
1 Under the conditions specified in 9.5, as part of a copy-initialization of an object of class type, a user-defined
conversion can be invoked to convert an initializer expression to the type of the object being initialized.
Overload resolution is used to select the user-defined conversion to be invoked.
[Note 1: The conversion performed for indirect binding to a reference to a possibly cv-qualified class type is determined
in terms of a corresponding non-reference copy-initialization.—end note]
Assuming that “cv1 T” is the type of the object being initialized, withT a class type, the candidate functions
are selected as follows:
—(1.1) The non-explicit constructors (11.4.8.2) ofT are candidate functions.
—(1.2) When the type of the initializer expression is a class type “cv S”, conversion functions are considered.
The permissible types for non-explicit conversion functions areT and any class derived fromT. When
initializing a temporary object (11.4) to be bound to the first parameter of a constructor where the
parameter is of type “reference tocv2 T” and the constructor is called with a single argument in the
context of direct-initialization of an object of type “cv3 T”, the permissible types for explicit conversion
functions are the same; otherwise there are none.
2 In both cases, the argument list has one argument, which is the initializer expression.
[Note 2: This argument will be compared against the first parameter of the constructors and against the object
parameter of the conversion functions.—end note]
12.2.2.6 Initialization by conversion function [over.match.conv]
1 Under the conditions specified in 9.5, as part of an initialization of an object of non-class type, a conversion
function can be invoked to convert an initializer expression of class type to the type of the object being
initialized. Overload resolution is used to select the conversion function to be invoked. Assuming that “cv T”
is the type of the object being initialized, the candidate functions are selected as follows:
—(1.1) The permissible types for non-explicit conversion functions are those that can be converted to typeT via
a standard conversion sequence (12.2.4.2.2). For direct-initialization, the permissible types for explicit
conversion functions are those that can be converted to typeT with a (possibly trivial) qualification
conversion (7.3.6); otherwise there are none.
2 The argument list has one argument, which is the initializer expression.
[Note 1: This argument will be compared against the object parameter of the conversion functions.—end note]
12.2.2.7 Initialization by conversion function for direct reference binding [over.match.ref]
1 Under the conditions specified in 9.5.4, a reference can be bound directly to the result of applying a conversion
function to an initializer expression. Overload resolution is used to select the conversion function to be
invoked. Assuming that “reference tocv1 T” is the type of the reference being initialized, the candidate
functions are selected as follows:
—(1.1) Let R be the set of all
—(1.1.1) lvalue reference types (when converting to an lvalue) and
—(1.1.2) non-reference types and rvalue reference types (when converting to an rvalue or an lvalue of
function type).
The permissible types for non-explicit conversion functions are the members ofR having the form
“cv T2” or “reference tocv2 T2” where “cv1 T” is reference-compatible (9.5.4) with “cv2 T2”. For
direct-initialization, the permissible types for explicit conversion functions are the members ofRhaving
the form “cv T2” or “reference tocv2 T2” whereT2 can be converted to typeT with a (possibly trivial)
qualification conversion (7.3.6); otherwise there are none.
2 The argument list has one argument, which is the initializer expression.
[Note 1: This argument will be compared against the object parameter of the conversion functions.—end note]
12.2.2.8 Initialization by list-initialization [over.match.list]
1 When objects of non-aggregate class typeT are list-initialized such that 9.5.5 specifies that overload resolution
is performed according to the rules in this subclause or when forming a list-initialization sequence according
to 12.2.4.2.6, overload resolution selects the constructor in two phases:
§ 12.2.2.8 © ISO/IEC
377

===== PAGE 389 =====

Dxxxx
—(1.1) If the initializer list is not empty orT has no default constructor, overload resolution is first performed
where the candidate functions are the initializer-list constructors (9.5.5) of the classT and the argument
list consists of the initializer list as a single argument.
—(1.2) Otherwise, or if no viable initializer-list constructor is found, overload resolution is performed again,
where the candidate functions are all the constructors of the classT and the argument list consists of
the elements of the initializer list.
In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.
[Note 1: This differs from other situations (12.2.2.4, 12.2.2.5), where only non-explicit constructors are considered for
copy-initialization. This restriction only applies if this initialization is part of the final result of overload resolution.
—end note]
12.2.2.9 Class template argument deduction [over.match.class.deduct]
1 When resolving a placeholder for a deduced class type (9.2.9.8) where thetemplate-name or splice-type-specifier
designates a primary class templateC, a set of functions and function templates, called the guides ofC, is
formed comprising:
—(1.1) If C is defined, for each constructor ofC, a function template with the following properties:
—(1.1.1) The template parameters are the template parameters ofC followed by the template parameters
(including default template arguments) of the constructor, if any.
—(1.1.2) The associated constraints (13.5.3) are the conjunction of the associated constraints ofC and the
associated constraints of the constructor, if any.
[Note 1: A constraint-expression in thetemplate-head of C is checked for satisfaction before any constraints
from thetemplate-head or trailingrequires-clause of the constructor. —end note]
—(1.1.3) The parameter-declaration-clause is that of the constructor.
—(1.1.4) The return type is the class template specialization designated byC and template arguments
corresponding to the template parameters ofC.
—(1.2) If C is not defined or does not declare any constructors, an additional function template derived as
above from a hypothetical constructorC().
—(1.3) An additional function template derived as above from a hypothetical constructorC(C), called thecopy
deduction candidate.
—(1.4) For eachdeduction-guide, a function or function template with the following properties:
—(1.4.1) The template-head, if any, andparameter-declaration-clause are those of thededuction-guide.
—(1.4.2) The return type is thesimple-template-id of thededuction-guide.
In addition, ifC is defined and its definition satisfies the conditions for an aggregate class (9.5.2) with the
assumption that any dependent base class has no virtual functions and no virtual base classes, and the
initializer is a non-emptybraced-init-list or parenthesizedexpression-list, and there are nodeduction-guides
for C, the set contains an additional function template, called theaggregate deduction candidate, defined as
follows. Letx1,...,x n be the elements of theinitializer-list or designated-initializer-list of thebraced-init-list, or
of theexpression-list. For eachxi, letei be the corresponding aggregate element ofC or of one of its (possibly
recursive) subaggregates that would be initialized byxi (9.5.2) if
—(1.5) brace elision is not considered for any aggregate element that has
—(1.5.1) a dependent non-array type,
—(1.5.2) an array type with a value-dependent bound, or
—(1.5.3) an array type with a dependent array element type andxi is a string literal; and
—(1.6) each non-trailing aggregate element that is a pack expansion is assumed to correspond to no elements
of the initializer list, and
—(1.7) a trailing aggregate element that is a pack expansion is assumed to correspond to all remaining elements
of the initializer list (if any).
If there is no such aggregate elementei for anyxi, the aggregate deduction candidate is not added to the set.
The aggregate deduction candidate is derived as above from a hypothetical constructorC(T1,..., Tn), where
—(1.8) if ei is of array type andxi is abraced-init-list, Ti is an rvalue reference to the declared type ofei, and
§ 12.2.2.9 © ISO/IEC
378

===== PAGE 390 =====

Dxxxx
—(1.9) if ei is of array type andxi is astring-literal, Ti is an lvalue reference to the const-qualified declared
type ofei, and
—(1.10) otherwise, Ti is the declared type ofei,
except that additional parameter packs of the formPj... are inserted into the parameter list in their original
aggregate element position corresponding to each non-trailing aggregate element of typePj that was skipped
because it was a parameter pack, and the trailing sequence of parameters corresponding to a trailing aggregate
element that is a pack expansion (if any) is replaced by a single parameter of the formTn.... In addition,
if C is defined and inherits constructors (9.10) from a direct base class denoted in thebase-specifier-list
by aclass-or-decltype B, letA be an alias template whose template parameter list is that ofC and whose
defining-type-id is B. If A is a deducible template (9.2.9.3), the set contains the guides ofA with the return
type R of each guide replaced withtypename CC<R>::type given a class template
template <typename> class CC;
whose primary template is not defined and with a single partial specialization whose template parameter list
is that ofA and whose template argument list is a specialization ofA with the template argument list of
A (13.8.3.2) having a member typedeftype designating a template specialization with the template argument
list ofA but withC as the template.
[Note 2: Equivalently, the template parameter list of the specialization is that ofC, the template argument list of the
specialization isB, and the member typedef namesC with the template argument list ofC. —end note]
2 [Example 1:
template <typename T> struct B {
B(T);
};
template <typename T> struct C : public B<T> {
using B<T>::B;
};
template <typename T> struct D : public B<T> {};
C c(42); // OK, deducesC<int>
D d(42); // error: deduction failed, no inherited deduction guides
B(int) -> B<char>;
C c2(42); // OK, deducesC<char>
template <typename T> struct E : public B<int> {
using B<int>::B;
};
E e(42); // error: deduction failed, arguments ofE cannot be deduced from introduced guides
template <typename T, typename U, typename V> struct F {
F(T, U, V);
};
template <typename T, typename U> struct G : F<U, T, int> {
using G::F::F;
}
G g(true, 'a', 1); // OK, deducesG<char, bool>
template<class T, std::size_t N>
struct H {
T array[N];
};
template<class T, std::size_t N>
struct I {
volatile T array[N];
};
template<std::size_t N>
struct J {
unsigned char array[N];
};
§ 12.2.2.9 © ISO/IEC
379

===== PAGE 391 =====

Dxxxx
H h = { "abc" }; // OK, deducesH<char, 4> (not T = const char)
I i = { "def" }; // OK, deducesI<char, 4>
J j = { "ghi" }; // error: cannot bind reference to array ofunsigned char to array ofchar in deduction
—end example]
3 When resolving a placeholder for a deduced class type (9.2.9.3) where thetemplate-name or splice-type-specifier
designates an alias templateA, thedefining-type-id of A must be of the form
typenameopt nested-name-specifieropt templateopt simple-template-id
as specified in 9.2.9.3. The guides ofA are the set of functions or function templates formed as follows. For
each function or function templatef in the guides of the template named by thesimple-template-id of the
defining-type-id, the template arguments of the return type off are deduced from thedefining-type-id of
A according to the process in 13.10.3.6 with the exception that deduction does not fail if not all template
arguments are deduced. If deduction fails for another reason, proceed with an empty set of deduced template
arguments. Letg denote the result of substituting these deductions intof. If substitution succeeds, form a
function or function templatef’ with the following properties and add it to the set of guides ofA:
—(3.1) The function type off’ is the function type ofg.
—(3.2) If f is a function template,f’ is a function template whose template parameter list consists of all
the template parameters ofA (including their default template arguments) that appear in the above
deductions or (recursively) in their default template arguments, followed by the template parameters of
f that were not deduced (including their default template arguments), otherwisef’ is not a function
template.
—(3.3) The associated constraints (13.5.3) are the conjunction of the associated constraints ofg and a constraint
that is satisfied if and only if the arguments ofA are deducible (see below) from the return type.
—(3.4) If f is a copy deduction candidate, thenf’ is considered to be so as well.
—(3.5) If f was generated from adeduction-guide (13.7.2.3), thenf’ is considered to be so as well.
—(3.6) The explicit-specifier of f’ is theexplicit-specifier of g (if any).
4 The arguments of a templateA are said to be deducible from a typeT if, given a class template
template <typename> class AA;
with a single partial specialization whose template parameter list is that ofA and whose template argument
list is a specialization of A with the template argument list ofA (13.8.3.2), AA<T> matches the partial
specialization.
5 Initialization and overload resolution are performed as described in 9.5 and 12.2.2.4, 12.2.2.5, or 12.2.2.8 (as
appropriate for the type of initialization performed) for an object of a hypothetical class type, where the
guides of the template named by the placeholder are considered to be the constructors of that class type for
the purpose of forming an overload set, and the initializer is provided by the context in which class template
argument deduction was performed. The following exceptions apply:
—(5.1) The first phase in 12.2.2.8 (considering initializer-list constructors) is omitted if the initializer list
consists of a single expression of typecv U, whereU is, or is derived from, a specialization of the class
template directly or indirectly named by the placeholder.
—(5.2) During template argument deduction for the aggregate deduction candidate, the number of elements in
a trailing parameter pack is only deduced from the number of remaining function arguments if it is not
otherwise deduced.
If the function or function template was generated from a constructor ordeduction-guide that had an
explicit-specifier, each such notional constructor is considered to have that sameexplicit-specifier. All such
notional constructors are considered to be public members of the hypothetical class type.
6 [Example 2:
template <class T> struct A {
explicit A(const T&, ...) noexcept; // #1
A(T&&, ...); // #2
};
int i;
A a1 = { i, i }; // error: explicit constructor #1 selected in copy-list-initialization during deduction,
// cannot deduce from non-forwarding rvalue reference in #2
§ 12.2.2.9 © ISO/IEC
380

===== PAGE 392 =====

Dxxxx
A a2{i, i}; // OK, #1 deduces toA<int> and also initializes
A a3{0, i}; // OK, #2 deduces toA<int> and also initializes
A a4 = {0, i}; // OK, #2 deduces toA<int> and also initializes
template <class T> A(const T&, const T&) -> A<T&>; // #3
template <class T> explicit A(T&&, T&&) -> A<T>; // #4
A a5 = {0, 1}; // error: explicit deduction guide #4 selected in copy-list-initialization during deduction
A a6{0,1}; // OK, #4 deduces toA<int> and #2 initializes
A a7 = {0, i}; // error: #3 deduces toA<int&>, #1 and #2 declare same constructor
A a8{0,i}; // error: #3 deduces toA<int&>, #1 and #2 declare same constructor
template <class T> struct B {
template <class U> using TA = T;
template <class U> B(U, TA<U>);
};
B b{(int*)0, (char*)0}; // OK, deducesB<char*>
template <typename T>
struct S {
T x;
T y;
};
template <typename T>
struct C {
S<T> s;
T t;
};
template <typename T>
struct D {
S<int> s;
T t;
};
C c1 = {1, 2}; // error: deduction failed
C c2 = {1, 2, 3}; // error: deduction failed
C c3 = {{1u, 2u}, 3}; // OK, deducesC<int>
D d1 = {1, 2}; // error: deduction failed
D d2 = {1, 2, 3}; // OK, braces elided, deducesD<int>
template <typename T>
struct E {
T t;
decltype(t) t2;
};
E e1 = {1, 2}; // OK, deducesE<int>
template <typename... T>
struct Types {};
template <typename... T>
struct F : Types<T...>, T... {};
struct X {};
struct Y {};
struct Z {};
struct W { operator Y(); };
§ 12.2.2.9 © ISO/IEC
381

===== PAGE 393 =====

Dxxxx
F f1 = {Types<X, Y, Z>{}, {}, {}}; // OK,F<X, Y, Z> deduced
F f2 = {Types<X, Y, Z>{}, X{}, Y{}}; // OK,F<X, Y, Z> deduced
F f3 = {Types<X, Y, Z>{}, X{}, W{}}; // error: conflicting types deduced;operator Y not considered
—end example]
7 [Example 3:
template <class T, class U> struct C {
C(T, U); // #1
};
template<class T, class U>
C(T, U) -> C<T, std::type_identity_t<U>>; // #2
template<class V> using A = C<V *, V *>;
template<std::integral W> using B = A<W>;
int i{};
double d{};
A a1(&i, &i); // deducesA<int>
A a2(i, i); // error: cannot deduceV * from i
A a3(&i, &d); // error: #1: cannot deduce(V*, V*) from (int *, double *)
// #2: cannot deduceA<V> from C<int *, double *>
B b1(&i, &i); // deducesB<int>
B b2(&d, &d); // error: cannot deduceB<W> from C<double *, double *>
Possible exposition-only implementation of the above procedure:
// The following concept ensures a specialization ofA is deduced.
template <class> class AA;
template <class V> class AA<A<V>> { };
template <class T> concept deduces_A = requires { sizeof(AA<T>); };
// f1 is formed from the constructor #1 ofC, generating the following function template
template<class T, class U>
auto f1(T, U) -> C<T, U>;
// Deducing arguments forC<T, U> from C<V *, V*> deduces T as V * and U as V *;
// f1’ is obtained by transformingf1 as described by the above procedure.
template<class V> requires deduces_A<C<V *, V *>>
auto f1_prime(V *, V*) -> C<V *, V *>;
// f2 is formed from the deduction-guide #2 ofC
template<class T, class U> auto f2(T, U) -> C<T, std::type_identity_t<U>>;
// Deducing arguments forC<T, std::type_identity_t<U>> from C<V *, V*> deduces T as V *;
// f2’ is obtained by transformingf2 as described by the above procedure.
template<class V, class U>
requires deduces_A<C<V *, std::type_identity_t<U>>>
auto f2_prime(V *, U) -> C<V *, std::type_identity_t<U>>;
// The following concept ensures a specialization ofB is deduced.
template <class> class BB;
template <class V> class BB<B<V>> { };
template <class T> concept deduces_B = requires { sizeof(BB<T>); };
// The guides forB derived from the abovef1’ and f2’ for A are as follows:
template<std::integral W>
requires deduces_A<C<W *, W *>> && deduces_B<C<W *, W *>>
auto f1_prime_for_B(W *, W *) -> C<W *, W *>;
template<std::integral W, class U>
requires deduces_A<C<W *, std::type_identity_t<U>>> &&
deduces_B<C<W *, std::type_identity_t<U>>>
auto f2_prime_for_B(W *, U) -> C<W *, std::type_identity_t<U>>;
—end example]
§ 12.2.2.9 © ISO/IEC
382

===== PAGE 394 =====

Dxxxx
12.2.3 Viable functions [over.match.viable]
1 From the set of candidate functions constructed for a given context (12.2.2), a set of viable functions is chosen,
from which the best function will be selected by comparing argument conversion sequences and associated
constraints (13.5.3) for the best fit (12.2.4). The selection of viable functions considers associated constraints,
if any, and relationships between arguments and function parameters other than the ranking of conversion
sequences.
2 First, to be a viable function, a candidate function shall have enough parameters to agree in number with
the arguments in the list.
—(2.1) If there arem arguments in the list, all candidate functions having exactlym parameters are viable.
—(2.2) A candidate function having fewer thanmparameters is viable only if it has an ellipsis in its parameter
list (9.3.4.6). For the purposes of overload resolution, any argument for which there is no corresponding
parameter is considered to “match the ellipsis” (12.2.4.2.4).
—(2.3) A candidate functionC having more thanm parameters is viable only if the set of scopesG, as defined
below, is not empty.G consists of every scopeX that satisfies all of the following:
—(2.3.1) There is a declaration ofC, whose host scope isX, considered by the overload resolution.
—(2.3.2) For everykth parameter P where k > m, there is a reachable declaration, whose host scope isX,
that specifies a default argument (9.3.4.7) forP.
If C is selected as the best viable function (12.2.4):
—(2.3.3) G shall contain exactly one scope (call itS).
—(2.3.4) If the candidates are denoted by asplice-expression, thenS shall not be a block scope.
—(2.3.5) The default arguments used in the call toC are the default arguments specified by the reachable
declarations whose host scope isS.
For the purposes of overload resolution, the parameter list is truncated on the right, so that there are
exactly m parameters.
[Example 1:
namespace A {
extern "C" void f(int, int = 5);
extern "C" void f(int = 6, int);
}
namespace B {
extern "C" void f(int, int = 7);
}
void use() {
[:^^A::f:](3, 4); // OK, default argument was not used for viability
[:^^A::f:](3); // error: default argument provided by declarations from two scopes
[:^^A::f:](); // OK, default arguments provided by declarations in the scope ofA
using A::f;
using B::f;
f(3, 4); // OK, default argument was not used for viability
f(3); // error: default argument provided by declaration from two scopes
f(); // OK, default arguments provided by declarations in the scope ofA
void g(int = 8);
g(); // OK
[:^^g:](); // error: host scope is block scope
}
void h(int = 7);
constexpr std::meta::info r = ^^h;
void poison() {
void h(int = 8);
h(); // OK, callsh(8)
[:^^h:](); // error: default argument provided by declarations from two scopes
}
§ 12.2.3 © ISO/IEC
383

===== PAGE 395 =====

Dxxxx
void call_h() {
[:^^h:](); // error: default argument provided by declarations from two scopes
[:r:](); // error: default argument provided by declarations from two scopes
}
template<typename... Ts>
int k(int = 3, Ts...);
int i = k<int>(); // error: no default argument for the second parameter
int j = k<>(); // OK
—end example]
3 Second, for a function to be viable, if it has associated constraints (13.5.3), those constraints shall be
satisfied (13.5.2).
4 Third, forFtobeaviablefunction, thereshallexistforeachargumentanimplicitconversionsequence(12.2.4.2)
that converts that argument to the corresponding parameter ofF. If the parameter has reference type, the
implicit conversion sequence includes the operation of binding the reference, and the fact that an lvalue
reference to non-const cannot bind to an rvalue and that an rvalue reference cannot bind to an lvalue can
affect the viability of the function (see 12.2.4.2.5).
12.2.4 Best viable function [over.match.best]
12.2.4.1 General [over.match.best.general]
1 Define ICSi(F) as the implicit conversion sequence that converts theith argument in the list to the type of
the ith parameter of viable functionF. 12.2.4.2 defines the implicit conversion sequences and 12.2.4.3 defines
what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion
sequence than another.
2 Given these definitions, a viable functionF1 is defined to be abetter function than another viable functionF2
if for all argumentsi, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then
—(2.1) for some argumentj, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,
—(2.2) the context is an initialization by user-defined conversion (see 9.5, 12.2.2.6, and 12.2.2.7) and the
standard conversion sequence from the result ofF1 to the destination type (i.e., the type of the entity
being initialized) is a better conversion sequence than the standard conversion sequence from the result
of F2 to the destination type
[Example 1:
struct A {
A();
operator int();
operator double();
} a;
int i = a; // a.operator int() followed by no conversion is better than
// a.operator double() followed by a conversion toint
float x = a; // ambiguous: both possibilities require conversions,
// and neither is better than the other
—end example]
or, if not that,
—(2.3) the context is an initialization by conversion function for direct reference binding (12.2.2.7) of a reference
to function type, the return type ofF1 is the same kind of reference (lvalue or rvalue) as the reference
being initialized, and the return type ofF2 is not
[Example 2:
template <class T> struct A {
operator T&(); // #1
operator T&&(); // #2
};
typedef int Fn();
A<Fn> a;
Fn& lf = a; // calls #1
Fn&& rf = a; // calls #2
—end example]
§ 12.2.4.1 © ISO/IEC
384

===== PAGE 396 =====

Dxxxx
or, if not that,
—(2.4) F1 is not a function template specialization andF2 is a function template specialization, or, if not that,
—(2.5) F1 and F2 are function template specializations, and the function template forF1 is more specialized
than the template forF2 according to the partial ordering rules described in 13.7.7.3, or, if not that,
—(2.6) F1 and F2 are non-template functions andF1 is more partial-ordering-constrained thanF2 (13.5.5)
[Example 3:
template <typename T = int>
struct S {
constexpr void f(); // #1
constexpr void f(this S&) requires true; // #2
};
void test() {
S<> s;
s.f(); // calls #2
}
—end example]
or, if not that,
—(2.7) F1 is a constructor for a classD, F2 is a constructor for a base classB of D, and for all arguments the
corresponding parameters ofF1 and F2 have the same type
[Example 4:
struct A {
A(int = 0);
};
struct B: A {
using A::A;
B();
};
int main() {
B b; // OK,B::B()
}
—end example]
or, if not that,
—(2.8) F2 is a rewritten candidate (12.2.2.3) andF1 is not
[Example 5:
struct S {
friend auto operator<=>(const S&, const S&) = default; // #1
friend bool operator<(const S&, const S&); // #2
};
bool b = S() < S(); // calls #2
—end example]
or, if not that,
—(2.9) F1 and F2 are rewritten candidates, andF2 is a synthesized candidate with reversed order of parameters
and F1 is not
[Example 6:
struct S {
friend std::weak_ordering operator<=>(const S&, int); // #1
friend std::weak_ordering operator<=>(int, const S&); // #2
};
bool b = 1 < S(); // calls #2
—end example]
§ 12.2.4.1 © ISO/IEC
385

===== PAGE 397 =====

Dxxxx
or, if not that,
—(2.10) F1 and F2 are generated from class template argument deduction (12.2.2.9) for a classD, and F2 is
generated from inheriting constructors from a base class ofD while F1 is not, and for each explicit
function argument, the corresponding parameters ofF1 and F2 are either both ellipses or have the same
type, or, if not that,
—(2.11) F1 is generated from adeduction-guide (12.2.2.9) andF2 is not, or, if not that,
—(2.12) F1 is the copy deduction candidate (12.2.2.9) andF2 is not, or, if not that,
—(2.13) F1 is generated from a non-template constructor andF2 is generated from a constructor template.
[Example 7:
template <class T> struct A {
using value_type = T;
A(value_type); // #1
A(const A&); // #2
A(T, T, int); // #3
template<class U>
A(int, T, U); // #4
// #5 is the copy deduction candidate,A(A)
};
A x(1, 2, 3); // uses #3, generated from a non-template constructor
template <class T>
A(T) -> A<T>; // #6, less specialized than #5
A a(42); // uses #6 to deduceA<int> and #1 to initialize
A b = a; // uses #5 to deduceA<int> and #2 to initialize
template <class T>
A(A<T>) -> A<A<T>>; // #7, as specialized as #5
A b2 = a; // uses #7 to deduceA<A<int>> and #1 to initialize
—end example]
3 If there is exactly one viable function that is a better function than all other viable functions, then it is the
one selected by overload resolution; otherwise the call is ill-formed.100
[Example 8:
void Fcn(const int*, short);
void Fcn(int*, int);
int i;
short s = 0;
void f() {
Fcn(&i, s); // is ambiguous because&i →int* is better than&i →const int*
// but s →short is also better thans →int
Fcn(&i, 1L); // calls Fcn(int*, int), because&i →int* is better than&i →const int*
// and 1L →short and 1L →int are indistinguishable
Fcn(&i, 'c'); // calls Fcn(int*, int), because&i →int* is better than&i →const int*
// and ’c’ →int is better than’c’ →short
}
—end example]
100) The algorithm for selecting the best viable function is linear in the number of viable functions. Run a simple tournament
to find a functionW that is not worse than any opponent it faced. Although it is possible that another functionF that W did not
face is at least as good asW, F cannot be the best function because at some point in the tournamentF encountered another
function G such thatF was not better thanG. Hence, eitherW is the best function or there is no best function. So, make a second
pass over the viable functions to verify thatW is better than all other functions.
§ 12.2.4.1 © ISO/IEC
386

===== PAGE 398 =====

Dxxxx
4 [Note 1: If the best viable function was made viable by one or more default arguments, additional requirements
apply (12.2.3). —end note]
12.2.4.2 Implicit conversion sequences [over.best.ics]
12.2.4.2.1 General [over.best.ics.general]
1 An implicit conversion sequenceis a sequence of conversions used to convert an argument in a function call
to the type of the corresponding parameter of the function being called. The sequence of conversions is an
implicit conversion as defined in 7.3, which means it is governed by the rules for initialization of an object or
reference by a single expression (9.5, 9.5.4).
2 Implicit conversion sequences are concerned only with the type, cv-qualification, and value category of the
argument and how these are converted to match the corresponding properties of the parameter.
[Note 1: Other properties, such as the lifetime, storage duration, linkage, alignment, accessibility of the argument,
whether the argument is a bit-field, and whether a function is deleted (9.6.3), are ignored. So, although an implicit
conversion sequence can be defined for a given argument-parameter pair, the conversion from the argument to the
parameter might still be ill-formed in the final analysis.—end note]
3 A well-formed implicit conversion sequence is one of the following forms:
—(3.1) a standard conversion sequence (12.2.4.2.2),
—(3.2) a user-defined conversion sequence (12.2.4.2.3), or
—(3.3) an ellipsis conversion sequence (12.2.4.2.4).
4 However, if the target is
—(4.1) the first parameter of a constructor or
—(4.2) the object parameter of a user-defined conversion function
and the constructor or user-defined conversion function is a candidate by
—(4.3) 12.2.2.4, when the argument is the temporary in the second step of a class copy-initialization,
—(4.4) 12.2.2.5, 12.2.2.6, or 12.2.2.7 (in all cases), or
—(4.5) the second phase of 12.2.2.8 when the initializer list has exactly one element that is itself an initializer
list, and the target is the first parameter of a constructor of classX, and the conversion is toX or
reference tocv X,
user-defined conversion sequences are not considered.
[Note 2: These rules prevent more than one user-defined conversion from being applied during overload resolution,
thereby avoiding infinite recursion.—end note]
[Example 1:
struct Y { Y(int); };
struct A { operator int(); };
Y y1 = A(); // error: A::operator int() is not a candidate
struct X { X(); };
struct B { operator X(); };
B b;
X x{{b}}; // error: B::operator X() is not a candidate
—end example]
5 For the case where the parameter type is a reference, see 12.2.4.2.5.
6 When the parameter type is not a reference, the implicit conversion sequence models a copy-initialization of
the parameter from the argument expression. The implicit conversion sequence is the one required to convert
the argument expression to a prvalue of the type of the parameter.
[Note 3: When the parameter has a class type, this is a conceptual conversion defined for the purposes of Clause 12;
the actual initialization is defined in terms of constructors and is not a conversion.—end note]
7 When the cv-unqualified version of the type of the argument expression is the same as the parameter type,
the implicit conversion sequence is an identity conversion. When the parameter has a class type and the
argument expression has a (possibly cv-qualified) derived class type, the implicit conversion sequence is
a derived-to-base conversion from the derived class to the base class. A derived-to-base conversion has
Conversion rank (12.2.4.2.2).
§ 12.2.4.2.1 © ISO/IEC
387

===== PAGE 399 =====

Dxxxx
[Note 4: There is no such standard conversion; this derived-to-base conversion exists only in the description of implicit
conversion sequences. —end note]
[Example 2: An implicit conversion sequence from an argument of typeconst A to a parameter of typeA can be formed,
even if overload resolution for copy-initialization ofA from the argument would not find a viable function (12.2.2.4,
12.2.3). The implicit conversion sequence for that case is the identity sequence; it contains no “conversion” from
const A to A. —end example]
8 When the parameter is the implicit object parameter of a static member function, the implicit conversion
sequence is a standard conversion sequence that is neither better nor worse than any other standard conversion
sequence.
9 In all contexts, when converting to the implicit object parameter or when converting to the left operand of
an assignment operation only standard conversion sequences are allowed.
[Note 5: When a conversion to the explicit object parameter occurs, it can include user-defined conversion sequences.
—end note]
10 If no conversions are required to match an argument to a parameter type, the implicit conversion sequence is
the standard conversion sequence consisting of the identity conversion (12.2.4.2.2).
11 If no sequence of conversions can be found to convert an argument to a parameter type, an implicit conversion
sequence cannot be formed.
12 If there are multiple well-formed implicit conversion sequences converting the argument to the parameter
type, the implicit conversion sequence associated with the parameter is defined to be the unique conversion
sequence designated theambiguous conversion sequence. For the purpose of ranking implicit conversion
sequences as described in 12.2.4.3, the ambiguous conversion sequence is treated as a user-defined conversion
sequence that is indistinguishable from any other user-defined conversion sequence.
[Note 6: This rule prevents a function from becoming non-viable because of an ambiguous conversion sequence for
one of its parameters.
[Example 3:
class B;
class A { A (B&);};
class B { operator A (); };
class C { C (B&); };
void f(A) { }
void f(C) { }
B b;
f(b); // error: ambiguous because there is a conversionb →C (via constructor)
// and an (ambiguous) conversionb →A (via constructor or conversion function)
void f(B) { }
f(b); // OK, unambiguous
—end example]
—end note]
If a function that uses the ambiguous conversion sequence is selected as the best viable function, the call will
be ill-formed because the conversion of one of the arguments in the call is ambiguous.
13 The three forms of implicit conversion sequences mentioned above are defined in the following subclauses.
12.2.4.2.2 Standard conversion sequences [over.ics.scs]
1 Table 19 summarizes the conversions defined in 7.3 and partitions them into four disjoint categories: Lvalue
Transformation, Qualification Adjustment, Promotion, and Conversion.
[Note 1: These categories are orthogonal with respect to value category, cv-qualification, and data representation:
the Lvalue Transformations do not change the cv-qualification or data representation of the type; the Qualification
Adjustments do not change the value category or data representation of the type; and the Promotions and Conversions
do not change the value category or cv-qualification of the type.—end note]
2 [Note 2: As described in 7.3, a standard conversion sequence either is the Identity conversion by itself (that is, no
conversion) or consists of one to three conversions from the other four categories. If there are two or more conversions
in the sequence, the conversions are applied in the canonical order:Lvalue Transformation, Promotion or
Conversion, Qualification Adjustment. —end note]
3 Each conversion in Table 19 also has an associated rank (Exact Match, Promotion, or Conversion). These are
used to rank standard conversion sequences (12.2.4.3). The rank of a conversion sequence is determined by
§ 12.2.4.2.2 © ISO/IEC
388

===== PAGE 400 =====

Dxxxx
considering the rank of each conversion in the sequence and the rank of any reference binding (12.2.4.2.5). If
any of those has Conversion rank, the sequence has Conversion rank; otherwise, if any of those has Promotion
rank, the sequence has Promotion rank; otherwise, the sequence has Exact Match rank.
Table 19 — Conversions [tab:over.ics.scs]
Conversion Category Rank Subclause
No conversions required Identity
Lvalue-to-rvalue conversion 7.3.2
Array-to-pointer conversion Lvalue Transformation 7.3.3
Function-to-pointer conversion Exact Match 7.3.4
Qualification conversions 7.3.6
Function pointer conversion Qualification Adjustment 7.3.14
Integral promotions 7.3.7
Floating-point promotion Promotion Promotion 7.3.8
Integral conversions 7.3.9
Floating-point conversions 7.3.10
Floating-integral conversions 7.3.11
Pointer conversions Conversion Conversion 7.3.12
Pointer-to-member conversions 7.3.13
Boolean conversions 7.3.15
12.2.4.2.3 User-defined conversion sequences [over.ics.user]
1 A user-defined conversion sequenceconsists of an initial standard conversion sequence followed by a user-
defined conversion (11.4.8) followed by a second standard conversion sequence. If the user-defined conversion
is specified by a constructor (11.4.8.2), the initial standard conversion sequence converts the source type to
the type of the first parameter of that constructor. If the user-defined conversion is specified by a conversion
function (11.4.8.3), the initial standard conversion sequence converts the source type to the type of the object
parameter of that conversion function.
2 The second standard conversion sequence converts the result of the user-defined conversion to the target type
for the sequence; any reference binding is included in the second standard conversion sequence. Since an
implicit conversion sequence is an initialization, the special rules for initialization by user-defined conversion
apply when selecting the best user-defined conversion for a user-defined conversion sequence (see 12.2.4
and 12.2.4.2).
3 If the user-defined conversion is specified by a specialization of a conversion function template, the second
standard conversion sequence shall have Exact Match rank.
4 A conversion of an expression of class type to the same class type is given Exact Match rank, and a conversion
of an expression of class type to a base class of that type is given Conversion rank, in spite of the fact that a
constructor (i.e., a user-defined conversion function) is called for those cases.
12.2.4.2.4 Ellipsis conversion sequences [over.ics.ellipsis]
1 An ellipsis conversion sequence occurs when an argument in a function call is matched with the ellipsis
parameter specification of the function called (see 7.6.1.3).
12.2.4.2.5 Reference binding [over.ics.ref]
1 When a parameter of type “reference tocv T” binds directly (9.5.4) to an argument expression:
—(1.1) If the argument expression has a typeD that is a derived class ofT, the implicit conversion sequence is
a derived-to-base conversion fromD to T (12.2.4.2).
—(1.2) Otherwise, if the type of the argument is possibly cv-qualifiedT, or ifT is an array type of unknown
bound with element typeU and the argument has an array type of known bound whose element type is
possibly cv-qualifiedU, the implicit conversion sequence is the identity conversion.
—(1.3) Otherwise, ifT is a function type, the implicit conversion sequence is a function pointer conversion.
—(1.4) Otherwise, the implicit conversion sequence is a qualification conversion.
§ 12.2.4.2.5 © ISO/IEC
389