

===== PAGE 1801 =====

Dxxxx
29.6.2.4 Element access [valarray.access]
const T& operator[](size_t n) const;
T& operator[](size_t n);
1 Hardened preconditions: n < size() is true.
2 Returns: A reference to the corresponding element of the array.
[Note 1: The expression(a[i] = q, a[i]) == q evaluates totrue for any non-constantvalarray<T> a, any
T q, and for anysize_t i such that the value ofi is less than the length ofa. —end note]
3 Remarks: The expressionaddressof(a[i + j]) == addressof(a[i]) + j evaluates totrue for all
size_t i and size_t j such thati + j < a.size().
4 The expressionaddressof(a[i]) != addressof(b[j]) evaluates totrue for any two arraysa and b
and for anysize_t i and size_t j such thati < a.size() and j < b.size().
[Note 2: This property indicates an absence of aliasing and can be used to advantage by optimizing compilers.
Compilers can take advantage of inlining, constant propagation, loop fusion, tracking of pointers obtained from
operator new, and other techniques to generate efficientvalarrays. —end note]
5 The reference returned by the subscript operator for an array shall be valid until the member function
resize(size_t, T) (29.6.2.8) is called for that array or until the lifetime of that array ends, whichever
happens first.
29.6.2.5 Subset operations [valarray.sub]
1 The memberoperator[] is overloaded to provide several ways to select sequences of elements from among
those controlled by*this. Each of these operations returns a subset of the array. The const-qualified versions
return this subset as a newvalarray object. The non-const versions return a class template object which
has reference semantics to the original array, working in conjunction with various overloads ofoperator=
and other assigning operators to allow selective replacement (slicing) of the controlled sequence. In each case
the selected element(s) shall exist.
valarray operator[](slice slicearr) const;
2 Returns: A valarray containing those elements of the controlled sequence designated byslicearr.
[Example 1:
const valarray<char> v0("abcdefghijklmnop", 16);
// v0[slice(2, 5, 3)] returns valarray<char>("cfilo", 5)
—end example]
slice_array<T> operator[](slice slicearr);
3 Returns: An object that holds references to elements of the controlled sequence selected byslicearr.
[Example 2:
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDE", 5);
v0[slice(2, 5, 3)] = v1;
// v0 == valarray<char>("abAdeBghCjkDmnEp", 16);
—end example]
valarray operator[](const gslice& gslicearr) const;
4 Returns: A valarray containing those elements of the controlled sequence designated bygslicearr.
[Example 3:
const valarray<char> v0("abcdefghijklmnop", 16);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray<size_t> len(lv, 2), str(dv, 2);
// v0[gslice(3, len, str)] returns
// valarray<char>("dfhkmo", 6)
—end example]
§ 29.6.2.5 © ISO/IEC
1790

===== PAGE 1802 =====

Dxxxx
gslice_array<T> operator[](const gslice& gslicearr);
5 Returns: An object that holds references to elements of the controlled sequence selected bygslicearr.
[Example 4:
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDEF", 6);
const size_t lv[] = { 2, 3 };
const size_t dv[] = { 7, 2 };
const valarray<size_t> len(lv, 2), str(dv, 2);
v0[gslice(3, len, str)] = v1;
// v0 == valarray<char>("abcAeBgCijDlEnFp", 16)
—end example]
valarray operator[](const valarray<bool>& boolarr) const;
6 Returns: A valarray containing those elements of the controlled sequence designated byboolarr.
[Example 5:
const valarray<char> v0("abcdefghijklmnop", 16);
const bool vb[] = { false, false, true, true, false, true };
// v0[valarray<bool>(vb, 6)] returns
// valarray<char>("cdf", 3)
—end example]
mask_array<T> operator[](const valarray<bool>& boolarr);
7 Returns: An object that holds references to elements of the controlled sequence selected byboolarr.
[Example 6:
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABC", 3);
const bool vb[] = { false, false, true, true, false, true };
v0[valarray<bool>(vb, 6)] = v1;
// v0 == valarray<char>("abABeCghijklmnop", 16)
—end example]
valarray operator[](const valarray<size_t>& indarr) const;
8 Returns: A valarray containing those elements of the controlled sequence designated byindarr.
[Example 7:
const valarray<char> v0("abcdefghijklmnop", 16);
const size_t vi[] = { 7, 5, 2, 3, 8 };
// v0[valarray<size_t>(vi, 5)] returns
// valarray<char>("hfcdi", 5)
—end example]
indirect_array<T> operator[](const valarray<size_t>& indarr);
9 Returns: An object that holds references to elements of the controlled sequence selected byindarr.
[Example 8:
valarray<char> v0("abcdefghijklmnop", 16);
valarray<char> v1("ABCDE", 5);
const size_t vi[] = { 7, 5, 2, 3, 8 };
v0[valarray<size_t>(vi, 5)] = v1;
// v0 == valarray<char>("abCDeBgAEjklmnop", 16)
—end example]
29.6.2.6 Unary operators [valarray.unary]
valarray operator+() const;
valarray operator-() const;
valarray operator~() const;
§ 29.6.2.6 © ISO/IEC
1791

===== PAGE 1803 =====

Dxxxx
valarray<bool> operator!() const;
1 Mandates: The indicated operator can be applied to operands of typeT and returns a value of type
T (bool for operator!) or which may be unambiguously implicitly converted to typeT (bool for
operator!).
2 Returns: A valarray whose length issize(). Each element of the returned array is initialized with
the result of applying the indicated operator to the corresponding element of the array.
29.6.2.7 Compound assignment [valarray.cassign]
valarray& operator*= (const valarray& v);
valarray& operator/= (const valarray& v);
valarray& operator%= (const valarray& v);
valarray& operator+= (const valarray& v);
valarray& operator-= (const valarray& v);
valarray& operator^= (const valarray& v);
valarray& operator&= (const valarray& v);
valarray& operator|= (const valarray& v);
valarray& operator<<=(const valarray& v);
valarray& operator>>=(const valarray& v);
1 Mandates: The indicated operator can be applied to two operands of typeT.
2 Preconditions: size() == v.size() is true.
The value of an element in the left-hand side of a valarray compound assignment operator does not
depend on the value of another element in that left hand side.
3 Effects: Each of these operators performs the indicated operation on each of the elements of*this and
the corresponding element ofv.
4 Returns: *this.
5 Remarks: The appearance of an array on the left-hand side of a compound assignment does not
invalidate references or pointers.
valarray& operator*= (const T& v);
valarray& operator/= (const T& v);
valarray& operator%= (const T& v);
valarray& operator+= (const T& v);
valarray& operator-= (const T& v);
valarray& operator^= (const T& v);
valarray& operator&= (const T& v);
valarray& operator|= (const T& v);
valarray& operator<<=(const T& v);
valarray& operator>>=(const T& v);
6 Mandates: The indicated operator can be applied to two operands of typeT.
7 Effects: Each of these operators applies the indicated operation to each element of*this and v.
8 Returns: *this.
9 Remarks: The appearance of an array on the left-hand side of a compound assignment does not
invalidate references or pointers to the elements of the array.
29.6.2.8 Member functions [valarray.members]
void swap(valarray& v) noexcept;
1 Effects: *this obtains the value ofv. v obtains the value of*this.
2 Complexity: Constant.
size_t size() const;
3 Returns: The number of elements in the array.
4 Complexity: Constant time.
§ 29.6.2.8 © ISO/IEC
1792

===== PAGE 1804 =====

Dxxxx
T sum() const;
5 Mandates: operator+= can be applied to operands of typeT.
6 Preconditions: size() > 0 is true.
7 Returns: The sum of all the elements of the array. If the array has length 1, returns the value of
element 0. Otherwise, the returned value is calculated by applyingoperator+= to a copy of an element
of the array and all other elements of the array in an unspecified order.
T min() const;
8 Preconditions: size() > 0 is true.
9 Returns: The minimum value contained in*this. For an array of length 1, the value of element 0 is
returned. For all other array lengths, the determination is made usingoperator<.
T max() const;
10 Preconditions: size() > 0 is true.
11 Returns: The maximum value contained in*this. For an array of length 1, the value of element 0 is
returned. For all other array lengths, the determination is made usingoperator<.
valarray shift(int n) const;
12 Returns: A valarray of length size(), each of whose elementsI is (*this)[I + n] if I + n is
non-negative and less thansize(), otherwiseT().
[Note 1: If element zero is taken as the leftmost element, a positive value ofn shifts the elements leftn places,
with zero fill. —end note]
13 [Example 1: If the argument has the value−2, the first two elements of the result will be value-initialized (9.5);
the third element of the result will be assigned the value of the first element of*this; etc. —end example]
valarray cshift(int n) const;
14 Returns: A valarray of lengthsize() that is a circular shift of*this. If element zero is taken as the
leftmost element, a non-negative value ofn shifts the elements circularly leftn places and a negative
value ofn shifts the elements circularly right−n places.
valarray apply(T func(T)) const;
valarray apply(T func(const T&)) const;
15 Returns: A valarray whose length issize(). Each element of the returned array is assigned the value
returned by applying the argument function to the corresponding element of*this.
void resize(size_t sz, T c = T());
16 Effects: Changes the length of the*this array tosz and then assigns to each element the value of the
second argument. Resizing invalidates all pointers and references to elements in the array.
29.6.3 valarray non-member operations [valarray.nonmembers]
29.6.3.1 Binary operators [valarray.binary]
template<class T> valarray<T> operator* (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&, const valarray<T>&);
1 Mandates: The indicated operator can be applied to operands of typeT and returns a value of typeT
or which can be unambiguously implicitly converted toT.
2 Preconditions: The argument arrays have the same length.
§ 29.6.3.1 © ISO/IEC
1793

===== PAGE 1805 =====

Dxxxx
3 Returns: A valarray whose length is equal to the lengths of the argument arrays. Each element of the
returned array is initialized with the result of applying the indicated operator to the corresponding
elements of the argument arrays.
template<class T> valarray<T> operator* (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator* (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator/ (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator% (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator+ (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator- (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator^ (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator& (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator| (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator<<(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator>>(const typename valarray<T>::value_type&,
const valarray<T>&);
4 Mandates: The indicated operator can be applied to operands of typeT and returns a value of typeT
or which can be unambiguously implicitly converted toT.
5 Returns: A valarray whose length is equal to the length of the array argument. Each element of the
returned array is initialized with the result of applying the indicated operator to the corresponding
element of the array argument and the non-array argument.
29.6.3.2 Logical operators [valarray.comparison]
template<class T> valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&, const valarray<T>&);
1 Mandates: The indicated operator can be applied to operands of typeT and returns a value of type
bool or which can be unambiguously implicitly converted tobool.
§ 29.6.3.2 © ISO/IEC
1794

===== PAGE 1806 =====

Dxxxx
2 Preconditions: The two array arguments have the same length.
3 Returns: A valarray<bool> whose length is equal to the length of the array arguments. Each element
of the returned array is initialized with the result of applying the indicated operator to the corresponding
elements of the argument arrays.
template<class T> valarray<bool> operator==(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator==(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator!=(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator< (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator> (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator<=(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator>=(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator&&(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator||(const typename valarray<T>::value_type&,
const valarray<T>&);
4 Mandates: The indicated operator can be applied to operands of typeT and returns a value of type
bool or which can be unambiguously implicitly converted tobool.
5 Returns: Avalarray<bool> whose length is equal to the length of the array argument. Each element of
the returned array is initialized with the result of applying the indicated operator to the corresponding
element of the array and the non-array argument.
29.6.3.3 Transcendentals [valarray.transcend]
template<class T> valarray<T> abs (const valarray<T>&);
template<class T> valarray<T> acos (const valarray<T>&);
template<class T> valarray<T> asin (const valarray<T>&);
template<class T> valarray<T> atan (const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const typename valarray<T>::value_type&);
template<class T> valarray<T> atan2(const typename valarray<T>::value_type&, const valarray<T>&);
template<class T> valarray<T> cos (const valarray<T>&);
template<class T> valarray<T> cosh (const valarray<T>&);
template<class T> valarray<T> exp (const valarray<T>&);
template<class T> valarray<T> log (const valarray<T>&);
template<class T> valarray<T> log10(const valarray<T>&);
template<class T> valarray<T> pow (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> pow (const valarray<T>&, const typename valarray<T>::value_type&);
template<class T> valarray<T> pow (const typename valarray<T>::value_type&, const valarray<T>&);
template<class T> valarray<T> sin (const valarray<T>&);
template<class T> valarray<T> sinh (const valarray<T>&);
template<class T> valarray<T> sqrt (const valarray<T>&);
§ 29.6.3.3 © ISO/IEC
1795

===== PAGE 1807 =====

Dxxxx
template<class T> valarray<T> tan (const valarray<T>&);
template<class T> valarray<T> tanh (const valarray<T>&);
1 Mandates: A unique function with the indicated name can be applied (unqualified) to an operand of
type T. This function returns a value of typeT or which can be unambiguously implicitly converted to
type T.
29.6.3.4 Specialized algorithms [valarray.special]
template<class T> void swap(valarray<T>& x, valarray<T>& y) noexcept;
1 Effects: Equivalent tox.swap(y).
29.6.4 Class slice [class.slice]
29.6.4.1 Overview [class.slice.overview]
namespace std {
class slice {
public:
slice();
slice(size_t, size_t, size_t);
slice(const slice&);
size_t start() const;
size_t size() const;
size_t stride() const;
friend bool operator==(const slice& x, const slice& y);
};
}
1 The slice class represents a BLAS-like slice from an array. Such a slice is specified by a starting index, a
length, and a stride.244
29.6.4.2 Constructors [cons.slice]
slice();
slice(size_t start, size_t length, size_t stride);
1 The default constructor is equivalent toslice(0, 0, 0). A default constructor is provided only to
permit the declaration of arrays of slices. The constructor with arguments for a slice takes a start,
length, and stride parameter.
2 [Example 1: slice(3, 8, 2) constructs a slice which selects elements3,5,7,..., 17 from an array. —end
example]
29.6.4.3 Access functions [slice.access]
size_t start() const;
size_t size() const;
size_t stride() const;
1 Returns: The start, length, or stride specified by aslice object.
2 Complexity: Constant time.
29.6.4.4 Operators [slice.ops]
friend bool operator==(const slice& x, const slice& y);
1 Effects: Equivalent to:
return x.start() == y.start() && x.size() == y.size() && x.stride() == y.stride();
244) BLAS stands forBasic Linear Algebra Subprograms. C++ programs can instantiate this class. See, for example, Dongarra,
Du Croz, Duff, and Hammerling:A set of Level 3 Basic Linear Algebra Subprograms; Technical Report MCS-P1-0888, Argonne
National Laboratory (USA), Mathematics and Computer Science Division, August, 1988.
§ 29.6.4.4 © ISO/IEC
1796

===== PAGE 1808 =====

Dxxxx
29.6.5 Class template slice_array [template.slice.array]
29.6.5.1 Overview [template.slice.array.overview]
namespace std {
template<class T> class slice_array {
public:
using value_type = T;
void operator= (const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
slice_array(const slice_array&);
~slice_array();
const slice_array& operator=(const slice_array&) const;
void operator=(const T&) const;
slice_array() = delete; // as implied by declaring copy constructor above
};
}
1 This template is a helper template used by theslice subscript operator
slice_array<T> valarray<T>::operator[](slice);
2 It has reference semantics to a subset of an array specified by aslice object.
[Example 1: The expressiona[slice(1, 5, 3)] = b; has the effect of assigning the elements ofb to a slice of the
elements ina. For the slice shown, the elements selected froma are 1,4,..., 13. —end example]
29.6.5.2 Assignment [slice.arr.assign]
void operator=(const valarray<T>&) const;
const slice_array& operator=(const slice_array&) const;
1 These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of thevalarray<T> object to which theslice_array object refers.
29.6.5.3 Compound assignment [slice.arr.comp.assign]
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
1 These compound assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of thevalarray<T> object to which theslice_array
object refers.
29.6.5.4 Fill function [slice.arr.fill]
void operator=(const T&) const;
1 This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which theslice_array object refers.
§ 29.6.5.4 © ISO/IEC
1797

===== PAGE 1809 =====

Dxxxx
29.6.6 The gslice class [class.gslice]
29.6.6.1 Overview [class.gslice.overview]
namespace std {
class gslice {
public:
gslice();
gslice(size_t s, const valarray<size_t>& l, const valarray<size_t>& d);
size_t start() const;
valarray<size_t> size() const;
valarray<size_t> stride() const;
};
}
1 This class represents a generalized slice out of an array. Agslice is defined by a starting offset (s), a set of
lengths (lj), and a set of strides (dj). The number of lengths shall equal the number of strides.
2 A gslice represents a mapping from a set of indices (ij), equal in number to the number of strides, to a
single indexk. It is useful for building multidimensional array classes using thevalarray template, which is
one-dimensional. The set of one-dimensional index values specified by agslice are
k= s+
∑
j
ijdj
where the multidimensional indicesij range in value from 0 tolij −1.
3 [Example 1: The gslice specification
start = 3
length = {2, 4, 3}
stride = {19, 4, 1}
yields the sequence of one-dimensional indices
k= 3 + (0,1) ×19 + (0,1,2,3) ×4 + (0,1,2) ×1
which are ordered as shown in the following table:
(i0, i 1, i 2, k ) =
(0, 0, 0, 3),
(0, 0, 1, 4),
(0, 0, 2, 5),
(0, 1, 0, 7),
(0, 1, 1, 8),
(0, 1, 2, 9),
(0, 2, 0, 11),
(0, 2, 1, 12),
(0, 2, 2, 13),
(0, 3, 0, 15),
(0, 3, 1, 16),
(0, 3, 2, 17),
(1, 0, 0, 22),
(1, 0, 1, 23),
...
(1, 3, 2, 36)
That is, the highest-ordered index turns fastest.—end example]
4 It is possible to have degenerate generalized slices in which an address is repeated.
5 [Example 2: If the stride parameters in the previous example are changed to {1, 1, 1}, the first few elements of the
resulting sequence of indices will be
(0, 0, 0, 3),
(0, 0, 1, 4),
(0, 0, 2, 5),
(0, 1, 0, 4),
§ 29.6.6.1 © ISO/IEC
1798

===== PAGE 1810 =====

Dxxxx
(0, 1, 1, 5),
(0, 1, 2, 6),
...
—end example]
6 If a degenerate slice is used as the argument to the non-const version ofoperator[](const gslice&), the
behavior is undefined.
29.6.6.2 Constructors [gslice.cons]
gslice();
gslice(size_t start, const valarray<size_t>& lengths,
const valarray<size_t>& strides);
1 The default constructor is equivalent togslice(0, valarray<size_t>(), valarray<size_t>()).
The constructor with arguments builds agslice based on a specification of start, lengths, and strides,
as explained in the previous subclause.
29.6.6.3 Access functions [gslice.access]
size_t start() const;
valarray<size_t> size() const;
valarray<size_t> stride() const;
1 Returns: The representation of the start, lengths, or strides specified for thegslice.
2 Complexity: start() is constant time.size() and stride() are linear in the number of strides.
29.6.7 Class template gslice_array [template.gslice.array]
29.6.7.1 Overview [template.gslice.array.overview]
namespace std {
template<class T> class gslice_array {
public:
using value_type = T;
void operator= (const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
gslice_array(const gslice_array&);
~gslice_array();
const gslice_array& operator=(const gslice_array&) const;
void operator=(const T&) const;
gslice_array() = delete; // as implied by declaring copy constructor above
};
}
1 This template is a helper template used by thegslice subscript operator
gslice_array<T> valarray<T>::operator[](const gslice&);
2 It has reference semantics to a subset of an array specified by agslice object. Thus, the expression
a[gslice(1, length, stride)] = b has the effect of assigning the elements ofb to a generalized slice of
the elements ina.
§ 29.6.7.1 © ISO/IEC
1799

===== PAGE 1811 =====

Dxxxx
29.6.7.2 Assignment [gslice.array.assign]
void operator=(const valarray<T>&) const;
const gslice_array& operator=(const gslice_array&) const;
1 These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of thevalarray<T> object to which thegslice_array refers.
29.6.7.3 Compound assignment [gslice.array.comp.assign]
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
1 These compound assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of thevalarray<T> object to which thegslice_array
object refers.
29.6.7.4 Fill function [gslice.array.fill]
void operator=(const T&) const;
1 This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which thegslice_array object refers.
29.6.8 Class template mask_array [template.mask.array]
29.6.8.1 Overview [template.mask.array.overview]
namespace std {
template<class T> class mask_array {
public:
using value_type = T;
void operator= (const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
mask_array(const mask_array&);
~mask_array();
const mask_array& operator=(const mask_array&) const;
void operator=(const T&) const;
mask_array() = delete; // as implied by declaring copy constructor above
};
}
1 This template is a helper template used by the mask subscript operator:
mask_array<T> valarray<T>::operator[](const valarray<bool>&);
2 It has reference semantics to a subset of an array specified by a boolean mask. Thus, the expressiona[mask] =
b; has the effect of assigning the elements ofb to the masked elements ina (those for which the corresponding
element inmask is true).
§ 29.6.8.1 © ISO/IEC
1800

===== PAGE 1812 =====

Dxxxx
29.6.8.2 Assignment [mask.array.assign]
void operator=(const valarray<T>&) const;
const mask_array& operator=(const mask_array&) const;
1 These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of thevalarray<T> object to which themask_array object refers.
29.6.8.3 Compound assignment [mask.array.comp.assign]
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
1 These compound assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of thevalarray<T> object to which themask_array object
refers.
29.6.8.4 Fill function [mask.array.fill]
void operator=(const T&) const;
1 This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which themask_array object refers.
29.6.9 Class template indirect_array [template.indirect.array]
29.6.9.1 Overview [template.indirect.array.overview]
namespace std {
template<class T> class indirect_array {
public:
using value_type = T;
void operator= (const valarray<T>&) const;
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
indirect_array(const indirect_array&);
~indirect_array();
const indirect_array& operator=(const indirect_array&) const;
void operator=(const T&) const;
indirect_array() = delete; // as implied by declaring copy constructor above
};
}
1 This template is a helper template used by the indirect subscript operator
indirect_array<T> valarray<T>::operator[](const valarray<size_t>&);
2 It has reference semantics to a subset of an array specified by anindirect_array. Thus, the expression
a[indirect] = b; has the effect of assigning the elements ofb to the elements ina whose indices appear in
indirect.
§ 29.6.9.1 © ISO/IEC
1801

===== PAGE 1813 =====

Dxxxx
29.6.9.2 Assignment [indirect.array.assign]
void operator=(const valarray<T>&) const;
const indirect_array& operator=(const indirect_array&) const;
1 These assignment operators have reference semantics, assigning the values of the argument array
elements to selected elements of thevalarray<T> object to which it refers.
2 If theindirect_array specifies an element in thevalarray<T> object to which it refers more than
once, the behavior is undefined.
3 [Example 1:
int addr[] = {2, 3, 1, 4, 4};
valarray<size_t> indirect(addr, 5);
valarray<double> a(0., 10), b(1., 5);
a[indirect] = b;
results in undefined behavior since element 4 is specified twice in the indirection.—end example]
29.6.9.3 Compound assignment [indirect.array.comp.assign]
void operator*= (const valarray<T>&) const;
void operator/= (const valarray<T>&) const;
void operator%= (const valarray<T>&) const;
void operator+= (const valarray<T>&) const;
void operator-= (const valarray<T>&) const;
void operator^= (const valarray<T>&) const;
void operator&= (const valarray<T>&) const;
void operator|= (const valarray<T>&) const;
void operator<<=(const valarray<T>&) const;
void operator>>=(const valarray<T>&) const;
1 These compound assignments have reference semantics, applying the indicated operation to the elements
of the argument array and selected elements of thevalarray<T> object to which theindirect_array
object refers.
2 If theindirect_array specifies an element in thevalarray<T> object to which it refers more than
once, the behavior is undefined.
29.6.9.4 Fill function [indirect.array.fill]
void operator=(const T&) const;
1 This function has reference semantics, assigning the value of its argument to the elements of the
valarray<T> object to which theindirect_array object refers.
29.6.10 Range access [valarray.range]
1 The iterator type is a type that meets the requirements of a mutableCpp17RandomAccessIterator(24.3.5.7)
andmodels contiguous_iterator(24.3.4.14). Itsvalue_typeisthe templateparameter Tandits reference
type isT&. The const_iterator type meets the requirements of a constantCpp17RandomAccessIterator
and modelscontiguous_iterator. Its value_type is the template parameterT and itsreference type is
const T&.
2 The iterators returned bybegin and end for an array are guaranteed to be valid until the member function
resize(size_t, T) (29.6.2.8) is called for that array or until the lifetime of that array ends, whichever
happens first.
iterator begin();
const_iterator begin() const;
3 Returns: An iterator referencing the first value in the array.
iterator end();
const_iterator end() const;
4 Returns: An iterator referencing one past the last value in the array.
§ 29.6.10 © ISO/IEC
1802

===== PAGE 1814 =====

Dxxxx
29.7 Mathematical functions for floating-point types [c.math]
29.7.1 Header <cmath> synopsis [cmath.syn]
#define HUGE_VAL see below
#define HUGE_VALF see below
#define HUGE_VALL see below
#define INFINITY see below
#define NAN see below
#define FP_INFINITE see below
#define FP_NAN see below
#define FP_NORMAL see below
#define FP_SUBNORMAL see below
#define FP_ZERO see below
#define FP_FAST_FMA see below
#define FP_FAST_FMAF see below
#define FP_FAST_FMAL see below
#define FP_ILOGB0 see below
#define FP_ILOGBNAN see below
#define MATH_ERRNO see below
#define MATH_ERREXCEPT see below
#define math_errhandling see below
namespace std {
using float_t = see below ;
using double_t = see below ;
constexpr floating-point-type acos(floating-point-type x);
constexpr float acosf(float x);
constexpr long double acosl(long double x);
constexpr floating-point-type asin(floating-point-type x);
constexpr float asinf(float x);
constexpr long double asinl(long double x);
constexpr floating-point-type atan(floating-point-type x);
constexpr float atanf(float x);
constexpr long double atanl(long double x);
constexpr floating-point-type atan2(floating-point-type y, floating-point-type x);
constexpr float atan2f(float y, float x);
constexpr long double atan2l(long double y, long double x);
constexpr floating-point-type cos(floating-point-type x);
constexpr float cosf(float x);
constexpr long double cosl(long double x);
constexpr floating-point-type sin(floating-point-type x);
constexpr float sinf(float x);
constexpr long double sinl(long double x);
constexpr floating-point-type tan(floating-point-type x);
constexpr float tanf(float x);
constexpr long double tanl(long double x);
constexpr floating-point-type acosh(floating-point-type x);
constexpr float acoshf(float x);
constexpr long double acoshl(long double x);
constexpr floating-point-type asinh(floating-point-type x);
constexpr float asinhf(float x);
constexpr long double asinhl(long double x);
§ 29.7.1 © ISO/IEC
1803

===== PAGE 1815 =====

Dxxxx
constexpr floating-point-type atanh(floating-point-type x);
constexpr float atanhf(float x);
constexpr long double atanhl(long double x);
constexpr floating-point-type cosh(floating-point-type x);
constexpr float coshf(float x);
constexpr long double coshl(long double x);
constexpr floating-point-type sinh(floating-point-type x);
constexpr float sinhf(float x);
constexpr long double sinhl(long double x);
constexpr floating-point-type tanh(floating-point-type x);
constexpr float tanhf(float x);
constexpr long double tanhl(long double x);
constexpr floating-point-type exp(floating-point-type x);
constexpr float expf(float x);
constexpr long double expl(long double x);
constexpr floating-point-type exp2(floating-point-type x);
constexpr float exp2f(float x);
constexpr long double exp2l(long double x);
constexpr floating-point-type expm1(floating-point-type x);
constexpr float expm1f(float x);
constexpr long double expm1l(long double x);
constexpr floating-point-type frexp(floating-point-type value, int* exp);
constexpr float frexpf(float value, int* exp);
constexpr long double frexpl(long double value, int* exp);
constexpr int ilogb(floating-point-type x);
constexpr int ilogbf(float x);
constexpr int ilogbl(long double x);
constexpr floating-point-type ldexp(floating-point-type x, int exp);
constexpr float ldexpf(float x, int exp);
constexpr long double ldexpl(long double x, int exp);
constexpr floating-point-type log(floating-point-type x);
constexpr float logf(float x);
constexpr long double logl(long double x);
constexpr floating-point-type log10(floating-point-type x);
constexpr float log10f(float x);
constexpr long double log10l(long double x);
constexpr floating-point-type log1p(floating-point-type x);
constexpr float log1pf(float x);
constexpr long double log1pl(long double x);
constexpr floating-point-type log2(floating-point-type x);
constexpr float log2f(float x);
constexpr long double log2l(long double x);
constexpr floating-point-type logb(floating-point-type x);
constexpr float logbf(float x);
constexpr long double logbl(long double x);
constexpr floating-point-type modf(floating-point-type value, floating-point-type* iptr);
constexpr float modff(float value, float* iptr);
constexpr long double modfl(long double value, long double* iptr);
§ 29.7.1 © ISO/IEC
1804

===== PAGE 1816 =====

Dxxxx
constexpr floating-point-type scalbn(floating-point-type x, int n);
constexpr float scalbnf(float x, int n);
constexpr long double scalbnl(long double x, int n);
constexpr floating-point-type scalbln(floating-point-type x, long int n);
constexpr float scalblnf(float x, long int n);
constexpr long double scalblnl(long double x, long int n);
constexpr floating-point-type cbrt(floating-point-type x);
constexpr float cbrtf(float x);
constexpr long double cbrtl(long double x);
// 29.7.2, absolute values
constexpr int abs(int j); // freestanding
constexpr long int abs(long int j); // freestanding
constexpr long long int abs(long long int j); // freestanding
constexpr floating-point-type abs(floating-point-type j); // freestanding-deleted
constexpr floating-point-type fabs(floating-point-type x);
constexpr float fabsf(float x);
constexpr long double fabsl(long double x);
constexpr floating-point-type hypot(floating-point-type x, floating-point-type y);
constexpr float hypotf(float x, float y);
constexpr long double hypotl(long double x, long double y);
// 29.7.3, three-dimensional hypotenuse
constexpr floating-point-type hypot(floating-point-type x, floating-point-type y,
floating-point-type z);
constexpr floating-point-type pow(floating-point-type x, floating-point-type y);
constexpr float powf(float x, float y);
constexpr long double powl(long double x, long double y);
constexpr floating-point-type sqrt(floating-point-type x);
constexpr float sqrtf(float x);
constexpr long double sqrtl(long double x);
constexpr floating-point-type erf(floating-point-type x);
constexpr float erff(float x);
constexpr long double erfl(long double x);
constexpr floating-point-type erfc(floating-point-type x);
constexpr float erfcf(float x);
constexpr long double erfcl(long double x);
constexpr floating-point-type lgamma(floating-point-type x);
constexpr float lgammaf(float x);
constexpr long double lgammal(long double x);
constexpr floating-point-type tgamma(floating-point-type x);
constexpr float tgammaf(float x);
constexpr long double tgammal(long double x);
constexpr floating-point-type ceil(floating-point-type x);
constexpr float ceilf(float x);
constexpr long double ceill(long double x);
constexpr floating-point-type floor(floating-point-type x);
constexpr float floorf(float x);
constexpr long double floorl(long double x);
floating-point-type nearbyint(floating-point-type x);
float nearbyintf(float x);
§ 29.7.1 © ISO/IEC
1805

===== PAGE 1817 =====

Dxxxx
long double nearbyintl(long double x);
floating-point-type rint(floating-point-type x);
float rintf(float x);
long double rintl(long double x);
long int lrint(floating-point-type x);
long int lrintf(float x);
long int lrintl(long double x);
long long int llrint(floating-point-type x);
long long int llrintf(float x);
long long int llrintl(long double x);
constexpr floating-point-type round(floating-point-type x);
constexpr float roundf(float x);
constexpr long double roundl(long double x);
constexpr long int lround(floating-point-type x);
constexpr long int lroundf(float x);
constexpr long int lroundl(long double x);
constexpr long long int llround(floating-point-type x);
constexpr long long int llroundf(float x);
constexpr long long int llroundl(long double x);
constexpr floating-point-type trunc(floating-point-type x);
constexpr float truncf(float x);
constexpr long double truncl(long double x);
constexpr floating-point-type fmod(floating-point-type x, floating-point-type y);
constexpr float fmodf(float x, float y);
constexpr long double fmodl(long double x, long double y);
constexpr floating-point-type remainder(floating-point-type x, floating-point-type y);
constexpr float remainderf(float x, float y);
constexpr long double remainderl(long double x, long double y);
constexpr floating-point-type remquo(floating-point-type x, floating-point-type y, int* quo);
constexpr float remquof(float x, float y, int* quo);
constexpr long double remquol(long double x, long double y, int* quo);
constexpr floating-point-type copysign(floating-point-type x, floating-point-type y);
constexpr float copysignf(float x, float y);
constexpr long double copysignl(long double x, long double y);
double nan(const char* tagp);
float nanf(const char* tagp);
long double nanl(const char* tagp);
constexpr floating-point-type nextafter(floating-point-type x, floating-point-type y);
constexpr float nextafterf(float x, float y);
constexpr long double nextafterl(long double x, long double y);
constexpr floating-point-type nexttoward(floating-point-type x, long double y);
constexpr float nexttowardf(float x, long double y);
constexpr long double nexttowardl(long double x, long double y);
constexpr floating-point-type nextup(floating-point-type x);
constexpr float nextupf(float x);
constexpr long double nextupl(long double x);
constexpr floating-point-type nextdown(floating-point-type x);
constexpr float nextdownf(float x);
§ 29.7.1 © ISO/IEC
1806

===== PAGE 1818 =====

Dxxxx
constexpr long double nextdownl(long double x);
constexpr floating-point-type fdim(floating-point-type x, floating-point-type y);
constexpr float fdimf(float x, float y);
constexpr long double fdiml(long double x, long double y);
constexpr floating-point-type fmax(floating-point-type x, floating-point-type y);
constexpr float fmaxf(float x, float y);
constexpr long double fmaxl(long double x, long double y);
constexpr floating-point-type fmin(floating-point-type x, floating-point-type y);
constexpr float fminf(float x, float y);
constexpr long double fminl(long double x, long double y);
constexpr floating-point-type fmaximum(floating-point-type x, floating-point-type y);
constexpr floating-point-type fmaximum_num(floating-point-type x, floating-point-type y);
constexpr floating-point-type fminimum(floating-point-type x, floating-point-type y);
constexpr floating-point-type fminimum_num(floating-point-type x, floating-point-type y);
constexpr floating-point-type fma(floating-point-type x, floating-point-type y,
floating-point-type z);
constexpr float fmaf(float x, float y, float z);
constexpr long double fmal(long double x, long double y, long double z);
// 29.7.4, linear interpolation
constexpr floating-point-type lerp(floating-point-type a, floating-point-type b,
floating-point-type t) noexcept;
// 29.7.5, classification / comparison functions
constexpr int fpclassify(floating-point-type x);
constexpr bool isfinite(floating-point-type x);
constexpr bool isinf(floating-point-type x);
constexpr bool isnan(floating-point-type x);
constexpr bool isnormal(floating-point-type x);
constexpr bool signbit(floating-point-type x);
constexpr bool isgreater(floating-point-type x, floating-point-type y);
constexpr bool isgreaterequal(floating-point-type x, floating-point-type y);
constexpr bool isless(floating-point-type x, floating-point-type y);
constexpr bool islessequal(floating-point-type x, floating-point-type y);
constexpr bool islessgreater(floating-point-type x, floating-point-type y);
constexpr bool isunordered(floating-point-type x, floating-point-type y);
// 29.7.6, mathematical special functions
// 29.7.6.2, associated Laguerre polynomials
floating-point-type assoc_laguerre(unsigned n, unsigned m, floating-point-type x);
float assoc_laguerref(unsigned n, unsigned m, float x);
long double assoc_laguerrel(unsigned n, unsigned m, long double x);
// 29.7.6.3, associated Legendre functions
floating-point-type assoc_legendre(unsigned l, unsigned m, floating-point-type x);
float assoc_legendref(unsigned l, unsigned m, float x);
long double assoc_legendrel(unsigned l, unsigned m, long double x);
// 29.7.6.4, beta function
floating-point-type beta(floating-point-type x, floating-point-type y);
float betaf(float x, float y);
long double betal(long double x, long double y);
// 29.7.6.5, complete elliptic integral of the first kind
floating-point-type comp_ellint_1(floating-point-type k);
float comp_ellint_1f(float k);
long double comp_ellint_1l(long double k);
§ 29.7.1 © ISO/IEC
1807

===== PAGE 1819 =====

Dxxxx
// 29.7.6.6, complete elliptic integral of the second kind
floating-point-type comp_ellint_2(floating-point-type k);
float comp_ellint_2f(float k);
long double comp_ellint_2l(long double k);
// 29.7.6.7, complete elliptic integral of the third kind
floating-point-type comp_ellint_3(floating-point-type k, floating-point-type nu);
float comp_ellint_3f(float k, float nu);
long double comp_ellint_3l(long double k, long double nu);
// 29.7.6.8, regular modified cylindrical Bessel functions
floating-point-type cyl_bessel_i(floating-point-type nu, floating-point-type x);
float cyl_bessel_if(float nu, float x);
long double cyl_bessel_il(long double nu, long double x);
// 29.7.6.9, cylindrical Bessel functions of the first kind
floating-point-type cyl_bessel_j(floating-point-type nu, floating-point-type x);
float cyl_bessel_jf(float nu, float x);
long double cyl_bessel_jl(long double nu, long double x);
// 29.7.6.10, irregular modified cylindrical Bessel functions
floating-point-type cyl_bessel_k(floating-point-type nu, floating-point-type x);
float cyl_bessel_kf(float nu, float x);
long double cyl_bessel_kl(long double nu, long double x);
// 29.7.6.11, cylindrical Neumann functions
// cylindrical Bessel functions of the second kind
floating-point-type cyl_neumann(floating-point-type nu, floating-point-type x);
float cyl_neumannf(float nu, float x);
long double cyl_neumannl(long double nu, long double x);
// 29.7.6.12, incomplete elliptic integral of the first kind
floating-point-type ellint_1(floating-point-type k, floating-point-type phi);
float ellint_1f(float k, float phi);
long double ellint_1l(long double k, long double phi);
// 29.7.6.13, incomplete elliptic integral of the second kind
floating-point-type ellint_2(floating-point-type k, floating-point-type phi);
float ellint_2f(float k, float phi);
long double ellint_2l(long double k, long double phi);
// 29.7.6.14, incomplete elliptic integral of the third kind
floating-point-type ellint_3(floating-point-type k, floating-point-type nu,
floating-point-type phi);
float ellint_3f(float k, float nu, float phi);
long double ellint_3l(long double k, long double nu, long double phi);
// 29.7.6.15, exponential integral
floating-point-type expint(floating-point-type x);
float expintf(float x);
long double expintl(long double x);
// 29.7.6.16, Hermite polynomials
floating-point-type hermite(unsigned n, floating-point-type x);
float hermitef(unsigned n, float x);
long double hermitel(unsigned n, long double x);
// 29.7.6.17, Laguerre polynomials
floating-point-type laguerre(unsigned n, floating-point-type x);
float laguerref(unsigned n, float x);
long double laguerrel(unsigned n, long double x);
// 29.7.6.18, Legendre polynomials
floating-point-type legendre(unsigned l, floating-point-type x);
§ 29.7.1 © ISO/IEC
1808

===== PAGE 1820 =====

Dxxxx
float legendref(unsigned l, float x);
long double legendrel(unsigned l, long double x);
// 29.7.6.19, Riemann zeta function
floating-point-type riemann_zeta(floating-point-type x);
float riemann_zetaf(float x);
long double riemann_zetal(long double x);
// 29.7.6.20, spherical Bessel functions of the first kind
floating-point-type sph_bessel(unsigned n, floating-point-type x);
float sph_besself(unsigned n, float x);
long double sph_bessell(unsigned n, long double x);
// 29.7.6.21, spherical associated Legendre functions
floating-point-type sph_legendre(unsigned l, unsigned m, floating-point-type theta);
float sph_legendref(unsigned l, unsigned m, float theta);
long double sph_legendrel(unsigned l, unsigned m, long double theta);
// 29.7.6.22, spherical Neumann functions;
// spherical Bessel functions of the second kind
floating-point-type sph_neumann(unsigned n, floating-point-type x);
float sph_neumannf(unsigned n, float x);
long double sph_neumannl(unsigned n, long double x);
}
1 The contents and meaning of the header<cmath> are a subset of the C standard library header<math.h>
and only the declarations shown in the synopsis above are present, with the addition of a three-dimensional
hypotenuse function (29.7.3), a linear interpolation function (29.7.4), and the mathematical special functions
described in 29.7.6.
[Note 1: Several functions have additional overloads in this document, but they have the same behavior as in the C
standard library (16.2). —end note]
2 For each function with at least one parameter of typefloating-point-type , the implementation provides
an overload for each cv-unqualified floating-point type (6.9.2) where all uses offloating-point-type in
the function signature are replaced with that floating-point type.
3 For each function with at least one parameter of typefloating-point-type other thanabs, the imple-
mentation also provides additional overloads sufficient to ensure that, if every argument corresponding to a
floating-point-type parameter has arithmetic type, then every such argument is effectively cast to the
floating-point type with the greatest floating-point conversion rank and greatest floating-point conversion
subrank among the types of all such arguments, where arguments of integer type are considered to have the
same floating-point conversion rank asdouble. If no such floating-point type with the greatest rank and
subrank exists, then overload resolution does not result in a usable candidate (12.2.1) from the overloads
provided by the implementation.
4 An invocation of nexttoward is ill-formed if the argument corresponding to thefloating-point-type
parameter has extended floating-point type.
See also: ISO/IEC 9899:2024, 7.12
29.7.2 Absolute values [c.math.abs]
1 [Note 1: The headers <cstdlib> (17.2.2) and <cmath> (29.7.1) declare the functions described in this subclause.
—end note]
constexpr int abs(int j);
constexpr long int abs(long int j);
constexpr long long int abs(long long int j);
2 Effects: These functions have the semantics specified in the C standard library for the functionsabs,
labs, andllabs, respectively.
3 Remarks: If abs is called with an argument of typeX for whichis_unsigned_v<X> is true and ifX
cannot be converted toint by integral promotion (7.3.7), the program is ill-formed.
[Note 2: Allowing arguments that can be promoted toint provides compatibility with C.—end note]
§ 29.7.2 © ISO/IEC
1809

===== PAGE 1821 =====

Dxxxx
constexpr floating-point-type abs(floating-point-type x);
4 Returns: The absolute value ofx.
See also: ISO/IEC 9899:2024, 7.12.8.3, 7.24.7.1
29.7.3 Three-dimensional hypotenuse [c.math.hypot3]
constexpr floating-point-type hypot(floating-point-type x, floating-point-type y,
floating-point-type z);
1 Returns:
√
x2 + y2 + z2.
29.7.4 Linear interpolation [c.math.lerp]
constexpr floating-point-type lerp(floating-point-type a, floating-point-type b,
floating-point-type t) noexcept;
1 Returns: a+ t(b−a).
2 Remarks: Let r be the value returned. Ifisfinite(a) && isfinite(b), then:
—(2.1) If t == 0, thenr == a.
—(2.2) If t == 1, thenr == b.
—(2.3) If t >= 0 && t <= 1, thenisfinite(r).
—(2.4) If isfinite(t) && a == b, thenr == a.
—(2.5) If isfinite(t) || !isnan(t) && b - a != 0, then!isnan(r).
Let CMP (x,y) be 1 if x > y, -1 if x < y, and 0 otherwise. For any t1 and t2, the product of
CMP (lerp(a, b, t2), lerp(a, b, t1)), CMP (t2, t1), andCMP (b, a) is non-negative.
29.7.5 Classification / comparison functions [c.math.fpclass]
1 The classification / comparison functions behave the same as the C macros with the corresponding names
defined in the C standard library.
See also: ISO/IEC 9899:2024, 7.12.4, 7.12.18
29.7.6 Mathematical special functions [sf.cmath]
29.7.6.1 General [sf.cmath.general]
1 If any argument value to any of the functions specified in 29.7.6 is a NaN (Not a Number), the function shall
return a NaN but it shall not report a domain error. Otherwise, the function shall report a domain error for
just those argument values for which:
—(1.1) the function description’sReturns: element explicitly specifies a domain and those argument values fall
outside the specified domain, or
—(1.2) the corresponding mathematical function value has a nonzero imaginary component, or
—(1.3) the corresponding mathematical function is not mathematically defined.245
2 Unless otherwise specified, each function is defined for all finite values, for negative infinity, and for positive
infinity.
29.7.6.2 Associated Laguerre polynomials [sf.cmath.assoc.laguerre]
floating-point-type assoc_laguerre(unsigned n, unsigned m, floating-point-type x);
float assoc_laguerref(unsigned n, unsigned m, float x);
long double assoc_laguerrel(unsigned n, unsigned m, long double x);
1 Effects: These functions compute the associated Laguerre polynomials of their respective argumentsn,
m, andx.
2 Returns: Lm
n (x), whereLm
n is given by Formula 29.22,Ln+m is given by Formula 29.37,n is n, m is m,
and x is x.
Lm
n (x) = (−1)m dm
dxm Ln+m(x) , for x≥0 (29.22)
245) A mathematical function is mathematically defined for a given set of argument values (a) if it is explicitly defined for that
set of argument values, or (b) if its limiting value exists and does not depend on the direction of approach.
§ 29.7.6.2 © ISO/IEC
1810

===== PAGE 1822 =====

Dxxxx
3 Remarks: The effect of calling each of these functions is implementation-defined ifn >= 128 or ifm >=
128.
29.7.6.3 Associated Legendre functions [sf.cmath.assoc.legendre]
floating-point-type assoc_legendre(unsigned l, unsigned m, floating-point-type x);
float assoc_legendref(unsigned l, unsigned m, float x);
long double assoc_legendrel(unsigned l, unsigned m, long double x);
1 Effects: These functions compute the associated Legendre functions of their respective argumentsl, m,
and x.
2 Returns: Pm
ℓ (x), wherePm
ℓ is given by Formula 29.23,Pℓ is given by Formula 29.38,ℓ is l, m is m, and
x is x.
Pm
ℓ (x) = (1 −x2)m/2 dm
dxm Pℓ(x) , for |x|≤ 1 (29.23)
3 Remarks: The effect of calling each of these functions is implementation-defined ifl >= 128.
29.7.6.4 Beta function [sf.cmath.beta]
floating-point-type beta(floating-point-type x, floating-point-type y);
float betaf(float x, float y);
long double betal(long double x, long double y);
1 Effects: These functions compute the beta function of their respective argumentsx and y.
2 Returns: B(x,y), whereB is given by Formula 29.24,x is x and y is y.
B(x,y) = Γ(x) Γ(y)
Γ(x+ y) , for x> 0, y >0 (29.24)
29.7.6.5 Complete elliptic integral of the first kind [sf.cmath.comp.ellint.1]
floating-point-type comp_ellint_1(floating-point-type k);
float comp_ellint_1f(float k);
long double comp_ellint_1l(long double k);
1 Effects: These functions compute the complete elliptic integral of the first kind of their respective
arguments k.
2 Returns: K(k), whereK is given by Formula 29.25 andk is k.
K(k) = F(k,π/2) , for |k|≤ 1 (29.25)
3 See also 29.7.6.12.
29.7.6.6 Complete elliptic integral of the second kind [sf.cmath.comp.ellint.2]
floating-point-type comp_ellint_2(floating-point-type k);
float comp_ellint_2f(float k);
long double comp_ellint_2l(long double k);
1 Effects: These functions compute the complete elliptic integral of the second kind of their respective
arguments k.
2 Returns: E(k), whereE is given by Formula 29.26 andk is k.
E(k) = E(k,π/2) , for |k|≤ 1 (29.26)
3 See also 29.7.6.13.
29.7.6.7 Complete elliptic integral of the third kind [sf.cmath.comp.ellint.3]
floating-point-type comp_ellint_3(floating-point-type k, floating-point-type nu);
float comp_ellint_3f(float k, float nu);
§ 29.7.6.7 © ISO/IEC
1811

===== PAGE 1823 =====

Dxxxx
long double comp_ellint_3l(long double k, long double nu);
1 Effects: These functions compute the complete elliptic integral of the third kind of their respective
arguments k and nu.
2 Returns: Π(ν,k), whereΠ is given by Formula 29.27,k is k, andν is nu.
Π(ν,k) = Π(ν,k,π/ 2) , for |k|≤ 1 (29.27)
3 See also 29.7.6.14.
29.7.6.8 Regular modified cylindrical Bessel functions [sf.cmath.cyl.bessel.i]
floating-point-type cyl_bessel_i(floating-point-type nu, floating-point-type x);
float cyl_bessel_if(float nu, float x);
long double cyl_bessel_il(long double nu, long double x);
1 Effects: These functions compute the regular modified cylindrical Bessel functions of their respective
arguments nu and x.
2 Returns: Iν(x), whereIν is given by Formula 29.28,ν is nu, andx is x.
Iν(x) = i−νJν(ix) =
∞∑
k=0
(x/2)ν+2k
k! Γ(ν+ k+ 1) , for x≥0 (29.28)
3 Remarks: The effect of calling each of these functions is implementation-defined ifnu >= 128.
4 See also 29.7.6.9.
29.7.6.9 Cylindrical Bessel functions of the first kind [sf.cmath.cyl.bessel.j]
floating-point-type cyl_bessel_j(floating-point-type nu, floating-point-type x);
float cyl_bessel_jf(float nu, float x);
long double cyl_bessel_jl(long double nu, long double x);
1 Effects: These functions compute the cylindrical Bessel functions of the first kind of their respective
arguments nu and x.
2 Returns: Jν(x), whereJν is given by Formula 29.29,ν is nu, andx is x.
Jν(x) =
∞∑
k=0
(−1)k(x/2)ν+2k
k! Γ(ν+ k+ 1) , for x≥0 (29.29)
3 Remarks: The effect of calling each of these functions is implementation-defined ifnu >= 128.
29.7.6.10 Irregular modified cylindrical Bessel functions [sf.cmath.cyl.bessel.k]
floating-point-type cyl_bessel_k(floating-point-type nu, floating-point-type x);
float cyl_bessel_kf(float nu, float x);
long double cyl_bessel_kl(long double nu, long double x);
1 Effects: These functions compute the irregular modified cylindrical Bessel functions of their respective
arguments nu and x.
2 Returns: Kν(x), whereKν is given by Formula 29.30,ν is nu, andx is x.
Kν(x) = (π/2)iν+1(Jν(ix) + iNν(ix)) =



π
2
I−ν(x) −Iν(x)
sin νπ , for x≥0 and non-integralν
π
2 lim
µ→ν
I−µ(x) −Iµ(x)
sin µπ , for x≥0 and integralν
(29.30)
3 Remarks: The effect of calling each of these functions is implementation-defined ifnu >= 128.
4 See also 29.7.6.8, 29.7.6.9, 29.7.6.11.
§ 29.7.6.10 © ISO/IEC
1812

===== PAGE 1824 =====

Dxxxx
29.7.6.11 Cylindrical Neumann functions [sf.cmath.cyl.neumann]
floating-point-type cyl_neumann(floating-point-type nu, floating-point-type x);
float cyl_neumannf(float nu, float x);
long double cyl_neumannl(long double nu, long double x);
1 Effects: These functions compute the cylindrical Neumann functions, also known as the cylindrical
Bessel functions of the second kind, of their respective argumentsnu and x.
2 Returns: Nν(x), whereNν is given by Formula 29.31,ν is nu, andx is x.
Nν(x) =



Jν(x) cosνπ−J−ν(x)
sin νπ , for x≥0 and non-integralν
lim
µ→ν
Jµ(x) cosµπ−J−µ(x)
sin µπ , for x≥0 and integralν
(29.31)
3 Remarks: The effect of calling each of these functions is implementation-defined ifnu >= 128.
4 See also 29.7.6.9.
29.7.6.12 Incomplete elliptic integral of the first kind [sf.cmath.ellint.1]
floating-point-type ellint_1(floating-point-type k, floating-point-type phi);
float ellint_1f(float k, float phi);
long double ellint_1l(long double k, long double phi);
1 Effects: These functions compute the incomplete elliptic integral of the first kind of their respective
arguments k and phi (phi measured in radians).
2 Returns: F(k,ϕ), whereF is given by Formula 29.32,k is k, andϕ is phi.
F(k,ϕ) =
∫ϕ
0
dθ√
1 −k2 sin2 θ
, for |k|≤ 1 (29.32)
29.7.6.13 Incomplete elliptic integral of the second kind [sf.cmath.ellint.2]
floating-point-type ellint_2(floating-point-type k, floating-point-type phi);
float ellint_2f(float k, float phi);
long double ellint_2l(long double k, long double phi);
1 Effects: These functions compute the incomplete elliptic integral of the second kind of their respective
arguments k and phi (phi measured in radians).
2 Returns: E(k,ϕ), whereE is given by Formula 29.33,k is k, andϕ is phi.
E(k,ϕ) =
∫ϕ
0
√
1 −k2 sin2 θdθ , for |k|≤ 1 (29.33)
29.7.6.14 Incomplete elliptic integral of the third kind [sf.cmath.ellint.3]
floating-point-type ellint_3(floating-point-type k, floating-point-type nu,
floating-point-type phi);
float ellint_3f(float k, float nu, float phi);
long double ellint_3l(long double k, long double nu, long double phi);
1 Effects: These functions compute the incomplete elliptic integral of the third kind of their respective
arguments k, nu, andphi (phi measured in radians).
2 Returns: Π(ν,k,ϕ ), whereΠ is given by Formula 29.34,ν is nu, k is k, andϕ is phi.
Π(ν,k,ϕ ) =
∫ϕ
0
dθ
(1 −ν sin2 θ)
√
1 −k2 sin2 θ
, for |k|≤ 1 (29.34)
§ 29.7.6.14 © ISO/IEC
1813

===== PAGE 1825 =====

Dxxxx
29.7.6.15 Exponential integral [sf.cmath.expint]
floating-point-type expint(floating-point-type x);
float expintf(float x);
long double expintl(long double x);
1 Effects: These functions compute the exponential integral of their respective argumentsx.
2 Returns: Ei(x), whereEi is given by Formula 29.35 andx is x.
Ei(x) = −
∫∞
−x
e−t
t dt (29.35)
29.7.6.16 Hermite polynomials [sf.cmath.hermite]
floating-point-type hermite(unsigned n, floating-point-type x);
float hermitef(unsigned n, float x);
long double hermitel(unsigned n, long double x);
1 Effects: These functions compute the Hermite polynomials of their respective argumentsn and x.
2 Returns: Hn(x), whereHn is given by Formula 29.36,n is n, andx is x.
Hn(x) = (−1)nex2 dn
dxn e−x2
(29.36)
3 Remarks: The effect of calling each of these functions is implementation-defined ifn >= 128.
29.7.6.17 Laguerre polynomials [sf.cmath.laguerre]
floating-point-type laguerre(unsigned n, floating-point-type x);
float laguerref(unsigned n, float x);
long double laguerrel(unsigned n, long double x);
1 Effects: These functions compute the Laguerre polynomials of their respective argumentsn and x.
2 Returns: Ln(x), whereLn is given by Formula 29.37,n is n, andx is x.
Ln(x) = ex
n!
dn
dxn (xne−x) , for x≥0 (29.37)
3 Remarks: The effect of calling each of these functions is implementation-defined ifn >= 128.
29.7.6.18 Legendre polynomials [sf.cmath.legendre]
floating-point-type legendre(unsigned l, floating-point-type x);
float legendref(unsigned l, float x);
long double legendrel(unsigned l, long double x);
1 Effects: These functions compute the Legendre polynomials of their respective argumentsl and x.
2 Returns: Pℓ(x), wherePℓ is given by Formula 29.38,l is l, andx is x.
Pℓ(x) = 1
2ℓℓ!
dℓ
dxℓ (x2 −1)ℓ , for |x|≤ 1 (29.38)
3 Remarks: The effect of calling each of these functions is implementation-defined ifl >= 128.
29.7.6.19 Riemann zeta function [sf.cmath.riemann.zeta]
floating-point-type riemann_zeta(floating-point-type x);
float riemann_zetaf(float x);
long double riemann_zetal(long double x);
1 Effects: These functions compute the Riemann zeta function of their respective argumentsx.
§ 29.7.6.19 © ISO/IEC
1814

===== PAGE 1826 =====

Dxxxx
2 Returns: ζ(x), whereζ is given by Formula 29.39 andx is x.
ζ(x) =



∞∑
k=1
k−x, for x> 1
1
1 −21−x
∞∑
k=1
(−1)k−1k−x, for 0 ≤x≤1
2xπx−1 sin(πx
2 ) Γ(1−x) ζ(1 −x), for x< 0
(29.39)
29.7.6.20 Spherical Bessel functions of the first kind [sf.cmath.sph.bessel]
floating-point-type sph_bessel(unsigned n, floating-point-type x);
float sph_besself(unsigned n, float x);
long double sph_bessell(unsigned n, long double x);
1 Effects: These functions compute the spherical Bessel functions of the first kind of their respective
arguments n and x.
2 Returns: jn(x), wherejn is given by Formula 29.40,n is n, andx is x.
jn(x) = (π/2x)1/2Jn+1/2(x) , for x≥0 (29.40)
3 Remarks: The effect of calling each of these functions is implementation-defined ifn >= 128.
4 See also 29.7.6.9.
29.7.6.21 Spherical associated Legendre functions [sf.cmath.sph.legendre]
floating-point-type sph_legendre(unsigned l, unsigned m, floating-point-type theta);
float sph_legendref(unsigned l, unsigned m, float theta);
long double sph_legendrel(unsigned l, unsigned m, long double theta);
1 Effects: These functions compute the spherical associated Legendre functions of their respective
arguments l, m, andtheta (theta measured in radians).
2 Returns: Ym
ℓ (θ,0), whereYm
ℓ is given by Formula 29.41,l is l, m is m, andθ is theta.
Ym
ℓ (θ,ϕ) = (−1)m
[(2ℓ+ 1)
4π
(ℓ−m)!
(ℓ+ m)!
]1/2
Pm
ℓ (cos θ)eimϕ , for |m|≤ ℓ (29.41)
3 Remarks: The effect of calling each of these functions is implementation-defined ifl >= 128.
4 See also 29.7.6.3.
29.7.6.22 Spherical Neumann functions [sf.cmath.sph.neumann]
floating-point-type sph_neumann(unsigned n, floating-point-type x);
float sph_neumannf(unsigned n, float x);
long double sph_neumannl(unsigned n, long double x);
1 Effects: These functions compute the spherical Neumann functions, also known as the spherical Bessel
functions of the second kind, of their respective argumentsn and x.
2 Returns: nn(x), wherenn is given by Formula 29.42,n is n, andx is x.
nn(x) = (π/2x)1/2Nn+1/2(x) , for x≥0 (29.42)
3 Remarks: The effect of calling each of these functions is implementation-defined ifn >= 128.
4 See also 29.7.6.11.
§ 29.7.6.22 © ISO/IEC
1815

===== PAGE 1827 =====

Dxxxx
29.8 Numbers [numbers]
29.8.1 Header <numbers> synopsis [numbers.syn]
namespace std::numbers {
template<class T> constexpr T e_v = unspecified ;
template<class T> constexpr T log2e_v = unspecified ;
template<class T> constexpr T log10e_v = unspecified ;
template<class T> constexpr T pi_v = unspecified ;
template<class T> constexpr T inv_pi_v = unspecified ;
template<class T> constexpr T inv_sqrtpi_v = unspecified ;
template<class T> constexpr T ln2_v = unspecified ;
template<class T> constexpr T ln10_v = unspecified ;
template<class T> constexpr T sqrt2_v = unspecified ;
template<class T> constexpr T sqrt3_v = unspecified ;
template<class T> constexpr T inv_sqrt3_v = unspecified ;
template<class T> constexpr T egamma_v = unspecified ;
template<class T> constexpr T phi_v = unspecified ;
template<floating_point T> constexpr T e_v<T> = see below ;
template<floating_point T> constexpr T log2e_v<T> = see below ;
template<floating_point T> constexpr T log10e_v<T> = see below ;
template<floating_point T> constexpr T pi_v<T> = see below ;
template<floating_point T> constexpr T inv_pi_v<T> = see below ;
template<floating_point T> constexpr T inv_sqrtpi_v<T> = see below ;
template<floating_point T> constexpr T ln2_v<T> = see below ;
template<floating_point T> constexpr T ln10_v<T> = see below ;
template<floating_point T> constexpr T sqrt2_v<T> = see below ;
template<floating_point T> constexpr T sqrt3_v<T> = see below ;
template<floating_point T> constexpr T inv_sqrt3_v<T> = see below ;
template<floating_point T> constexpr T egamma_v<T> = see below ;
template<floating_point T> constexpr T phi_v<T> = see below ;
inline constexpr double e = e_v<double>;
inline constexpr double log2e = log2e_v<double>;
inline constexpr double log10e = log10e_v<double>;
inline constexpr double pi = pi_v<double>;
inline constexpr double inv_pi = inv_pi_v<double>;
inline constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
inline constexpr double ln2 = ln2_v<double>;
inline constexpr double ln10 = ln10_v<double>;
inline constexpr double sqrt2 = sqrt2_v<double>;
inline constexpr double sqrt3 = sqrt3_v<double>;
inline constexpr double inv_sqrt3 = inv_sqrt3_v<double>;
inline constexpr double egamma = egamma_v<double>;
inline constexpr double phi = phi_v<double>;
}
29.8.2 Mathematical constants [math.constants]
1 The library-defined partial specializations of mathematical constant variable templates are initialized with
the nearest representable values ofe, log2 e, log10 e, π, 1
π, 1√π, ln 2, ln 10,
√
2,
√
3, 1√
3 , the Euler-Mascheroni
γ constant, and the golden ratioϕ constant 1+
√
5
2 , respectively.
2 Pursuant to 16.4.5.2.1, a program may partially or explicitly specialize a mathematical constant variable
template provided that the specialization depends on a program-defined type.
3 A program that instantiates a primary template of a mathematical constant variable template is ill-formed.
29.9 Basic linear algebra algorithms [linalg]
29.9.1 Overview [linalg.overview]
1 Subclause 29.9 defines basic linear algebra algorithms. The algorithms that access the elements of arrays
view those elements throughmdspan (23.7.3).
§ 29.9.1 © ISO/IEC
1816

===== PAGE 1828 =====

Dxxxx
29.9.2 Header <linalg> synopsis [linalg.syn]
namespace std::linalg {
// 29.9.5.1, storage order tags
struct column_major_t;
inline constexpr column_major_t column_major;
struct row_major_t;
inline constexpr row_major_t row_major;
// 29.9.5.2, triangle tags
struct upper_triangle_t;
inline constexpr upper_triangle_t upper_triangle;
struct lower_triangle_t;
inline constexpr lower_triangle_t lower_triangle;
// 29.9.5.3, diagonal tags
struct implicit_unit_diagonal_t;
inline constexpr implicit_unit_diagonal_t implicit_unit_diagonal;
struct explicit_diagonal_t;
inline constexpr explicit_diagonal_t explicit_diagonal;
// 29.9.6, class template layout_blas_packed
template<class Triangle, class StorageOrder>
class layout_blas_packed;
// 29.9.7, exposition-only helpers
// 29.9.7.5, linear algebra argument concepts
template<class T>
constexpr bool is-mdspan = see below ; // exposition only
template<class T>
concept in-vector = see below ; // exposition only
template<class T>
concept out-vector = see below ; // exposition only
template<class T>
concept inout-vector = see below ; // exposition only
template<class T>
concept in-matrix = see below ; // exposition only
template<class T>
concept out-matrix = see below ; // exposition only
template<class T>
concept inout-matrix = see below ; // exposition only
template<class T>
concept possibly-packed-out-matrix = see below ; // exposition only
template<class T>
concept in-object = see below ; // exposition only
template<class T>
concept out-object = see below ; // exposition only
template<class T>
concept inout-object = see below ; // exposition only
template<class T>
concept scalar = see below ; // exposition only
// 29.9.8, scaled in-place transformation
§ 29.9.2 © ISO/IEC
1817

===== PAGE 1829 =====

Dxxxx
// 29.9.8.2, class templatescaled_accessor
template<class ScalingFactor, class NestedAccessor>
class scaled_accessor;
// 29.9.8.3, function templatescaled
template<class ScalingFactor,
class ElementType, class Extents, class Layout, class Accessor>
constexpr auto scaled(ScalingFactor alpha, mdspan<ElementType, Extents, Layout, Accessor> x);
// 29.9.9, conjugated in-place transformation
// 29.9.9.2, class templateconjugated_accessor
template<class NestedAccessor>
class conjugated_accessor;
// 29.9.9.3, function templateconjugated
template<class ElementType, class Extents, class Layout, class Accessor>
constexpr auto conjugated(mdspan<ElementType, Extents, Layout, Accessor> a);
// 29.9.10, transpose in-place transformation
// 29.9.10.3, class templatelayout_transpose
template<class Layout>
class layout_transpose;
// 29.9.10.4, function templatetransposed
template<class ElementType, class Extents, class Layout, class Accessor>
constexpr auto transposed(mdspan<ElementType, Extents, Layout, Accessor> a);
// 29.9.11, conjugated transpose in-place transformation
template<class ElementType, class Extents, class Layout, class Accessor>
constexpr auto conjugate_transposed(mdspan<ElementType, Extents, Layout, Accessor> a);
// 29.9.13, BLAS 1 algorithms
// 29.9.13.2, Givens rotations
// 29.9.13.2.1, compute Givens rotation
template<class Real>
struct setup_givens_rotation_result {
Real c;
Real s;
Real r;
};
template<class Real>
struct setup_givens_rotation_result<complex<Real>> {
Real c;
complex<Real> s;
complex<Real> r;
};
template<class Real>
setup_givens_rotation_result<Real> setup_givens_rotation(Real a, Real b) noexcept;
template<class Real>
setup_givens_rotation_result<complex<Real>>
setup_givens_rotation(complex<Real> a, complex<Real> b) noexcept;
// 29.9.13.2.2, apply computed Givens rotation
template<inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, Real s);
§ 29.9.2 © ISO/IEC
1818

===== PAGE 1830 =====

Dxxxx
template<class ExecutionPolicy, inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(ExecutionPolicy&& exec,
InOutVec1 x, InOutVec2 y, Real c, Real s);
template<inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, complex<Real> s);
template<class ExecutionPolicy, inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(ExecutionPolicy&& exec,
InOutVec1 x, InOutVec2 y, Real c, complex<Real> s);
// 29.9.13.3, swap elements
template<inout-object InOutObj1, inout-object InOutObj2>
void swap_elements(InOutObj1 x, InOutObj2 y);
template<class ExecutionPolicy, inout-object InOutObj1, inout-object InOutObj2>
void swap_elements(ExecutionPolicy&& exec, InOutObj1 x, InOutObj2 y);
// 29.9.13.4, multiply elements by scalar
template<scalar Scalar, inout-object InOutObj>
void scale(Scalar alpha, InOutObj x);
template<class ExecutionPolicy, scalar Scalar, inout-object InOutObj>
void scale(ExecutionPolicy&& exec, Scalar alpha, InOutObj x);
// 29.9.13.5, copy elements
template<in-object InObj, out-object OutObj>
void copy(InObj x, OutObj y);
template<class ExecutionPolicy, in-object InObj, out-object OutObj>
void copy(ExecutionPolicy&& exec, InObj x, OutObj y);
// 29.9.13.6, add elementwise
template<in-object InObj1, in-object InObj2, out-object OutObj>
void add(InObj1 x, InObj2 y, OutObj z);
template<class ExecutionPolicy, in-object InObj1, in-object InObj2, out-object OutObj>
void add(ExecutionPolicy&& exec, InObj1 x, InObj2 y, OutObj z);
// 29.9.13.7, dot product of two vectors
template<in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dot(InVec1 v1, InVec2 v2, Scalar init);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dot(ExecutionPolicy&& exec, InVec1 v1, InVec2 v2, Scalar init);
template<in-vector InVec1, in-vector InVec2>
auto dot(InVec1 v1, InVec2 v2);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2>
auto dot(ExecutionPolicy&& exec, InVec1 v1, InVec2 v2);
template<in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dotc(InVec1 v1, InVec2 v2, Scalar init);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dotc(ExecutionPolicy&& exec, InVec1 v1, InVec2 v2, Scalar init);
template<in-vector InVec1, in-vector InVec2>
auto dotc(InVec1 v1, InVec2 v2);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2>
auto dotc(ExecutionPolicy&& exec, InVec1 v1, InVec2 v2);
// 29.9.13.8, Euclidean norm of a vector
template<in-vector InVec, scalar Scalar>
Scalar vector_two_norm(InVec v, Scalar init);
template<class ExecutionPolicy, in-vector InVec, scalar Scalar>
Scalar vector_two_norm(ExecutionPolicy&& exec, InVec v, Scalar init);
template<in-vector InVec>
auto vector_two_norm(InVec v);
template<class ExecutionPolicy, in-vector InVec>
auto vector_two_norm(ExecutionPolicy&& exec, InVec v);
§ 29.9.2 © ISO/IEC
1819

===== PAGE 1831 =====

Dxxxx
// 29.9.13.9, sum of absolute values of vector elements
template<in-vector InVec, scalar Scalar>
Scalar vector_abs_sum(InVec v, Scalar init);
template<class ExecutionPolicy, in-vector InVec, scalar Scalar>
Scalar vector_abs_sum(ExecutionPolicy&& exec, InVec v, Scalar init);
template<in-vector InVec>
auto vector_abs_sum(InVec v);
template<class ExecutionPolicy, in-vector InVec>
auto vector_abs_sum(ExecutionPolicy&& exec, InVec v);
// 29.9.13.10, index of maximum absolute value of vector elements
template<in-vector InVec>
typename InVec::extents_type vector_idx_abs_max(InVec v);
template<class ExecutionPolicy, in-vector InVec>
typename InVec::extents_type vector_idx_abs_max(ExecutionPolicy&& exec, InVec v);
// 29.9.13.11, Frobenius norm of a matrix
template<in-matrix InMat, scalar Scalar>
Scalar matrix_frob_norm(InMat A, Scalar init);
template<class ExecutionPolicy, in-matrix InMat, scalar Scalar>
Scalar matrix_frob_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
template<in-matrix InMat>
auto matrix_frob_norm(InMat A);
template<class ExecutionPolicy, in-matrix InMat>
auto matrix_frob_norm(ExecutionPolicy&& exec, InMat A);
// 29.9.13.12, one norm of a matrix
template<in-matrix InMat, scalar Scalar>
Scalar matrix_one_norm(InMat A, Scalar init);
template<class ExecutionPolicy, in-matrix InMat, scalar Scalar>
Scalar matrix_one_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
template<in-matrix InMat>
auto matrix_one_norm(InMat A);
template<class ExecutionPolicy, in-matrix InMat>
auto matrix_one_norm(ExecutionPolicy&& exec, InMat A);
// 29.9.13.13, infinity norm of a matrix
template<in-matrix InMat, scalar Scalar>
Scalar matrix_inf_norm(InMat A, Scalar init);
template<class ExecutionPolicy, in-matrix InMat, scalar Scalar>
Scalar matrix_inf_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
template<in-matrix InMat>
auto matrix_inf_norm(InMat A);
template<class ExecutionPolicy, in-matrix InMat>
auto matrix_inf_norm(ExecutionPolicy&& exec, InMat A);
// 29.9.14, BLAS 2 algorithms
// 29.9.14.1, general matrix-vector product
template<in-matrix InMat, in-vector InVec, out-vector OutVec>
void matrix_vector_product(InMat A, InVec x, OutVec y);
template<class ExecutionPolicy, in-matrix InMat, in-vector InVec, out-vector OutVec>
void matrix_vector_product(ExecutionPolicy&& exec, InMat A, InVec x, OutVec y);
template<in-matrix InMat, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void matrix_vector_product(InMat A, InVec1 x, InVec2 y, OutVec z);
template<class ExecutionPolicy,
in-matrix InMat, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void matrix_vector_product(ExecutionPolicy&& exec, InMat A, InVec1 x, InVec2 y, OutVec z);
// 29.9.14.2, symmetric matrix-vector product
template<in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void symmetric_matrix_vector_product(InMat A, Triangle t, InVec x, OutVec y);
§ 29.9.2 © ISO/IEC
1820

===== PAGE 1832 =====

Dxxxx
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void symmetric_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec x, OutVec y);
template<in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2,
out-vector OutVec>
void symmetric_matrix_vector_product(InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2,
out-vector OutVec>
void symmetric_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
// 29.9.14.3, Hermitian matrix-vector product
template<in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void hermitian_matrix_vector_product(InMat A, Triangle t, InVec x, OutVec y);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void hermitian_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec x, OutVec y);
template<in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2,
out-vector OutVec>
void hermitian_matrix_vector_product(InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2,
out-vector OutVec>
void hermitian_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
// 29.9.14.4, triangular matrix-vector product
// Overwriting triangular matrix-vector product
template<in-matrix InMat, class Triangle, class DiagonalStorage, in-vector InVec,
out-vector OutVec>
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d,
InVec x, OutVec y);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, in-vector InVec,
out-vector OutVec>
void triangular_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InVec x, OutVec y);
// In-place triangular matrix-vector product
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d, InOutVec y);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutVec y);
// Updating triangular matrix-vector product
template<in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec1, in-vector InVec2, out-vector OutVec>
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d,
InVec1 x, InVec2 y, OutVec z);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec1, in-vector InVec2, out-vector OutVec>
void triangular_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InVec1 x, InVec2 y, OutVec z);
// 29.9.14.5, solve a triangular linear system
§ 29.9.2 © ISO/IEC
1821

===== PAGE 1833 =====

Dxxxx
// Solve a triangular linear system, not in place
template<in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
InVec b, OutVec x, BinaryDivideOp divide);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InVec b, OutVec x, BinaryDivideOp divide);
template<in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
InVec b, OutVec x);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InVec b, OutVec x);
// Solve a triangular linear system, in place
template<in-matrix InMat, class Triangle, class DiagonalStorage,
inout-vector InOutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
InOutVec b, BinaryDivideOp divide);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
inout-vector InOutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutVec b, BinaryDivideOp divide);
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d, InOutVec b);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutVec b);
// 29.9.14.6, nonsymmetric rank-1 matrix update
// overwriting nonsymmetric rank-1 matrix update
template<in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update(InVec1 x, InVec2 y, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update(ExecutionPolicy&& exec, InVec1 x, InVec2 y, OutMat A);
template<in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update_c(InVec1 x, InVec2 y, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update_c(ExecutionPolicy&& exec, InVec1 x, InVec2 y, OutMat A);
// updating nonsymmetric rank-1 matrix update
template<in-vector InVec1, in-vector InVec2, in-matrix InMat, out-matrix OutMat>
void matrix_rank_1_update(InVec1 x, InVec2 y, InMat E, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, in-matrix InMat,
out-matrix OutMat>
void matrix_rank_1_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, InMat E, OutMat A);
template<in-vector InVec1, in-vector InVec2, in-matrix InMat, out-matrix OutMat>
void matrix_rank_1_update_c(InVec1 x, InVec2 y, InMat E, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, in-matrix InMat,
out-matrix OutMat>
void matrix_rank_1_update_c(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, InMat E, OutMat A);
§ 29.9.2 © ISO/IEC
1822

===== PAGE 1834 =====

Dxxxx
// 29.9.14.7, symmetric or Hermitian rank-1 matrix update
// overwriting symmetric rank-1 matrix update
template<scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_1_update(Scalar alpha, InVec x, OutMat A, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_1_update(ExecutionPolicy&& exec,
Scalar alpha, InVec x, OutMat A, Triangle t);
// overwriting Hermitian rank-1 matrix update
template<scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_1_update(Scalar alpha, InVec x, OutMat A, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_1_update(ExecutionPolicy&& exec,
Scalar alpha, InVec x, OutMat A, Triangle t);
// updating symmetric rank-1 matrix update
template<scalar Scalar, in-vector InVec, in-matrix InMat, possibly-packed-out-matrix OutMat,
class Triangle>
void symmetric_matrix_rank_1_update(Scalar alpha, InVec x, InMat E, OutMat A, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-vector InVec, in-matrix InMat, possibly-packed-out-matrix OutMat,
class Triangle>
void symmetric_matrix_rank_1_update(ExecutionPolicy&& exec,
Scalar alpha, InVec x, InMat E, OutMat A, Triangle t);
// updating Hermitian rank-1 matrix update
template<scalar Scalar, in-vector InVec, in-matrix InMat, possibly-packed-out-matrix OutMat,
class Triangle>
void hermitian_matrix_rank_1_update(Scalar alpha, InVec x, InMat E, OutMat A, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-vector InVec, in-matrix InMat, possibly-packed-out-matrix OutMat,
class Triangle>
void hermitian_matrix_rank_1_update(ExecutionPolicy&& exec,
Scalar alpha, InVec x, InMat E, OutMat A, Triangle t);
// 29.9.14.8, symmetric and Hermitian rank-2 matrix updates
// overwriting symmetric rank-2 matrix update
template<in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(InVec1 x, InVec2 y, OutMat A, Triangle t);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, OutMat A, Triangle t);
// overwriting Hermitian rank-2 matrix update
template<in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(InVec1 x, InVec2 y, OutMat A, Triangle t);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, OutMat A, Triangle t);
// updating symmetric rank-2 matrix update
template<in-vector InVec1, in-vector InVec2,
in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
§ 29.9.2 © ISO/IEC
1823

===== PAGE 1835 =====

Dxxxx
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2,
in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
// updating Hermitian rank-2 matrix update
template<in-vector InVec1, in-vector InVec2,
in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2,
in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
// 29.9.15, BLAS 3 algorithms
// 29.9.15.1, general matrix-matrix product
template<in-matrix InMat1, in-matrix InMat2, out-matrix OutMat>
void matrix_product(InMat1 A, InMat2 B, OutMat C);
template<class ExecutionPolicy, in-matrix InMat1, in-matrix InMat2, out-matrix OutMat>
void matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void matrix_product(InMat1 A, InMat2 B, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, InMat3 E, OutMat C);
// 29.9.15.2, symmetric, Hermitian, and triangular matrix-matrix product
template<in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, Triangle t, InMat2 B, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, InMat2 B, OutMat C);
template<in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, Triangle t, InMat2 B, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, InMat2 B, OutMat C);
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, InMat2 B, Triangle t, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, OutMat C);
§ 29.9.2 © ISO/IEC
1824

===== PAGE 1836 =====

Dxxxx
template<in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, InMat2 B, Triangle t, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
out-matrix OutMat>
void triangular_matrix_product(InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, OutMat C);
template<in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
template<in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, InMat3 E,
OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, InMat3 E,
OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
§ 29.9.2 © ISO/IEC
1825

===== PAGE 1837 =====

Dxxxx
template<in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, InMat3 E,
OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, InMat3 E,
OutMat C);
// 29.9.15.3, in-place triangular matrix-matrix product
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_left_product(InMat A, Triangle t, DiagonalStorage d, InOutMat C);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_left_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutMat C);
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_right_product(InMat A, Triangle t, DiagonalStorage d, InOutMat C);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_right_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutMat C);
// 29.9.15.4, rank-k update of a symmetric or Hermitian matrix
// overwriting rank-k symmetric matrix update
template<scalar Scalar, in-matrix InMat, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_k_update(Scalar alpha, InMat A, OutMat C, Triangle t);
template<class ExecutionPolicy, scalar Scalar,
in-matrix InMat, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_k_update(ExecutionPolicy&& exec,
Scalar alpha, InMat A, OutMat C, Triangle t);
// overwriting rank-k Hermitian matrix update
template<scalar Scalar, in-matrix InMat, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_k_update(Scalar alpha, InMat A, OutMat C, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-matrix InMat, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_k_update(ExecutionPolicy&& exec,
Scalar alpha, InMat A, OutMat C, Triangle t);
// updating rank-k symmetric matrix update
template<scalar Scalar, in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_k_update(Scalar alpha, InMat1 A, InMat2 E, OutMat C, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_k_update(ExecutionPolicy&& exec, Scalar alpha,
InMat1 A, InMat2 E, OutMat C, Triangle t);
// updating rank-k Hermitian matrix update
template<scalar Scalar, in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_k_update(Scalar alpha, InMat1 A, InMat2 E, OutMat C, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_k_update(ExecutionPolicy&& exec, Scalar alpha,
InMat1 A, InMat2 E, OutMat C, Triangle t);
§ 29.9.2 © ISO/IEC
1826

===== PAGE 1838 =====

Dxxxx
// 29.9.15.5, rank-2k update of a symmetric or Hermitian matrix
// overwriting rank-2k symmetric matrix update
template<in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(InMat1 A, InMat2 B, OutMat C, Triangle t);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, OutMat C, Triangle t);
// overwriting rank-2k Hermitian matrix update
template<in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2k_update(InMat1 A, InMat2 B, OutMat C, Triangle t);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2k_update(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, OutMat C, Triangle t);
// updating symmetric rank-2k matrix update
template<in-matrix InMat1, in-matrix InMat2, in-matrix InMat3,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(InMat1 A, InMat2 B, InMat3 E, OutMat C, Triangle t);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, in-matrix InMat3,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, InMat3 E, OutMat C, Triangle t);
// updating Hermitian rank-2k matrix update
template<in-matrix InMat1, in-matrix InMat2, in-matrix InMat3,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2k_update(InMat1 A, InMat2 B, InMat3 E, OutMat C, Triangle t);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, in-matrix InMat3,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2k_update(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, InMat3 E, OutMat C, Triangle t);
// 29.9.15.6, solve multiple triangular linear systems
// solve multiple triangular systems on the left, not-in-place
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
§ 29.9.2 © ISO/IEC
1827

===== PAGE 1839 =====

Dxxxx
InMat2 B, OutMat X);
// solve multiple triangular systems on the right, not-in-place
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X);
// solve multiple triangular systems on the left, in-place
template<in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_left_solve(InMat A, Triangle t, DiagonalStorage d,
InOutMat B);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B);
// solve multiple triangular systems on the right, in-place
template<in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_right_solve(InMat A, Triangle t, DiagonalStorage d,
InOutMat B);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B);
}
§ 29.9.2 © ISO/IEC
1828

===== PAGE 1840 =====

Dxxxx
29.9.3 General [linalg.general]
1 For the effects of all functions in 29.9, when the effects are described as “computesR= E” or “compute
R= E” (for someR and mathematical expressionE), the following apply:
—(1.1) E has the conventional mathematical meaning as written.
—(1.2) The patternxT should be read as “the transpose ofx.”
—(1.3) The patternxH should be read as “the conjugate transpose ofx.”
—(1.4) When R is the same name as a function parameter whose type is a template parameter withOut in
its name, the intent is that the result of the computation is written to the elements of the function
parameter R.
2 Some of the functions and types in 29.9 distinguish between the “rows” and the “columns” of a matrix. For a
matrix A and a multidimensional indexi, j in A.extents(),
—(2.1) row i of A is the set of elementsA[i, k1] for allk1 such thati, k1 is inA.extents(); and
—(2.2) column j of A is the set of elementsA[k0, j] for allk0 such thatk0, j is inA.extents().
3 Some of the functions in 29.9 distinguish between the “upper triangle,” “lower triangle,” and “diagonal” of a
matrix.
—(3.1) The diagonal is the set of all elements of A accessed by A[i,i] for 0 ≤i < min(A.extent(0),
A.extent(1)).
—(3.2) The upper triangleof a matrixA is the set of all elements ofA accessed byA[i,j] with i ≤j. It
includes the diagonal.
—(3.3) The lower triangleof A is the set of all elements ofA accessed byA[i,j] with i ≥j. It includes the
diagonal.
4 For any functionF that takes a parameter namedt, t applies to accesses done through the parameter
preceding t in the parameter list ofF. Let m be such an access-modified function parameter.F will only
access the triangle ofm specified by t. For accesses of diagonal elementsm[i, i], F will use the value
real-if-needed (m[i, i]) if the name of F starts with hermitian. For accesses m[i, j] outside the
triangle specified byt, F will use the value
—(4.1) conj-if-needed (m[j, i]) if the name ofF starts withhermitian,
—(4.2) m[j, i] if the name ofF starts withsymmetric, or
—(4.3) the additive identity if the name ofF starts withtriangular.
[Example 1: Small vector product accessing only specified triangle. It would not be a precondition violation for the
non-accessed matrix element to be non-zero.
template<class Triangle>
void triangular_matrix_vector_2x2_product(
mdspan<const float, extents<int, 2, 2>> m,
Triangle t,
mdspan<const float, extents<int, 2>> x,
mdspan<float, extents<int, 2>> y) {
static_assert(is_same_v<Triangle, lower_triangle_t> ||
is_same_v<Triangle, upper_triangle_t>);
if constexpr (is_same_v<Triangle, lower_triangle_t>) {
y[0] = m[0,0] * x[0]; // + 0 * x[1]
y[1] = m[1,0] * x[0] + m[1,1] * x[1];
} else { // upper_triangle_t
y[0] = m[0,0] * x[0] + m[0,1] * x[1];
y[1] = /∗ 0 ∗ x[0] +∗/ m[1,1] * x[1];
}
}
—end example]
5 For any functionF that takes a parameter namedd, d applies to accesses done through the previous-of-the-
previous parameter ofd in the parameter list ofF. Let m be such an access-modified function parameter. If
d specifies that an implicit unit diagonal is to be assumed, then
§ 29.9.3 © ISO/IEC
1829

===== PAGE 1841 =====

Dxxxx
—(5.1) F will not access the diagonal ofm; and
—(5.2) the algorithm will interpretm as if it has a unit diagonal, that is, a diagonal each of whose elements
behaves as a two-sided multiplicative identity (even ifm’s value type does not have a two-sided
multiplicative identity).
Otherwise, ifd specifies that an explicit diagonal is to be assumed, thenF will access the diagonal ofm.
6 Within all the functions in 29.9, any calls toabs, conj, imag, andreal are unqualified.
7 Twomdspan objects x and y alias each other, if they have the same extentse, and for every pack of integers
i which is a multidimensional index ine, x[i...] and y[i...] refer to the same element.
[Note 1: This means thatx and y view the same elements in the same order.—end note]
8 Twomdspan objects x and y overlap each other, if for some pack of integersi that is a multidimensional
index inx.extents(), there exists a pack of integersj that is a multidimensional index iny.extents(),
such thatx[i...] and y[j...] refer to the same element.
[Note 2: Aliasing is a special case of overlapping. Ifx and y do not overlap, then they also do not alias each other.
—end note]
29.9.4 Requirements [linalg.reqs]
29.9.4.1 Linear algebra value types [linalg.reqs.val]
1 Throughout 29.9, the following types arelinear algebra value types:
—(1.1) the value_type type alias of any input or outputmdspan parameter(s) of any function in 29.9; and
—(1.2) the Scalar template parameter (if any) of any function or class in 29.9.
2 Linear algebra value types shall modelscalar .
3 A value-initialized object of linear algebra value type shall act as the additive identity.
29.9.4.2 Algorithm and class requirements [linalg.reqs.alg]
1 29.9.4.2 lists common requirements for all algorithms and classes in 29.9.
2 All of the following statements presume that the algorithm’s asymptotic complexity requirements, if any, are
satisfied.
—(2.1) The function may make arbitrarily many objects of any linear algebra value type, value-initializing or
direct-initializing them with any existing object of that type.
—(2.2) The triangular solve algorithmsin 29.9.14.5, 29.9.15.3, 29.9.15.6, and 29.9.15.7 either have aBinaryDi-
videOp template parameter (see 29.9.12) and a binary function object parameterdivide of that type,
or they have effects equivalent to invoking such an algorithm. Triangular solve algorithms interpret
divide(a, b)as atimes the multiplicative inverse ofb. Each triangular solve algorithm uses a sequence
of evaluations of*, *=, divide, unary+, binary+, +=, unary-, binary-, -=, and= operators that
would produce the result specified by the algorithm’sEffects and Remarks when operating on elements
of a field with noncommutative multiplication. It is a precondition of the algorithm that any addend,
any subtrahend, any partial sum of addends in any order (treating any difference as a sum with the
second term negated), any factor, any partial product of factors respecting their order, any numerator
(first argument ofdivide), any denominator (second argument ofdivide), and any assignment is a
well-formed expression.
—(2.3) Each function in 29.9.13, 29.9.14, and 29.9.15 that is not a triangular solve algorithm will use a sequence
of evaluations of*, *=, +, +=, and= operators that would produce the result specified by the algorithm’s
Effects and Remarks when operating on elements of a semiring with noncommutative multiplication. It
is a precondition of the algorithm that any addend, any partial sum of addends in any order, any factor,
any partial product of factors respecting their order, and any assignment is a well-formed expression.
—(2.4) If the function has an outputmdspan, then all addends, subtrahends (for the triangular solve algorithms),
or results of thedivide parameter on intermediate terms (if the function takes adivide parameter)
are assignable and convertible to the outputmdspan’s value_type.
—(2.5) The function may reorder addends and partial sums arbitrarily.
[Note 1: Factors in each product are not reordered; multiplication is not necessarily commutative.—end note]
§ 29.9.4.2 © ISO/IEC
1830

===== PAGE 1842 =====

Dxxxx
[Note 2: The above requirements do not prohibit implementation approaches and optimization techniques which are
not user-observable. In particular, if for all input and output arguments thevalue_type is a floating-point type,
implementers are free to leverage approximations, use arithmetic operations not explicitly listed above, and compute
floating-point sums in any way that improves their accuracy.—end note]
3 [Note 3: For all functions in 29.9, suppose that all input and outputmdspan have asvalue_type a floating-point type,
and anyScalar template argument has a floating-point type. Then, functions can do all of the following:
—(3.1) compute floating-point sums in any way that improves their accuracy for arbitrary input;
—(3.2) perform additional arithmetic operations (other than those specified by the function’s wording and 29.9.4.2) in
order to improve performance or accuracy; and
—(3.3) use approximations (that might not be exact even if computing with real numbers), instead of computations
that would be exact if it were possible to compute without rounding error;
as long as
—(3.4) the function satisfies the complexity requirements; and
—(3.5) the function is logarithmically stable, as defined in Demmel 2007[16]. Strassen’s algorithm for matrix-matrix
multiply is an example of a logarithmically stable algorithm.
—end note]
29.9.5 Tag classes [linalg.tags]
29.9.5.1 Storage order tags [linalg.tags.order]
1 The storage order tags describe the order of elements in anmdspan with layout_blas_packed (29.9.6)
layout.
struct column_major_t {
explicit column_major_t() = default;
};
inline constexpr column_major_t column_major{};
struct row_major_t {
explicit row_major_t() = default;
};
inline constexpr row_major_t row_major{};
2 column_major_t indicates a column-major order, androw_major_t indicates a row-major order.
29.9.5.2 Triangle tags [linalg.tags.triangle]
struct upper_triangle_t {
explicit upper_triangle_t() = default;
};
inline constexpr upper_triangle_t upper_triangle{};
struct lower_triangle_t {
explicit lower_triangle_t() = default;
};
inline constexpr lower_triangle_t lower_triangle{};
1 These tag classes specify whether algorithms and other users of a matrix (represented as anmdspan)
access the upper triangle (upper_triangle_t) or lower triangle (lower_triangle_t) of the matrix
(see also 29.9.3). This is also subject to the restrictions ofimplicit_unit_diagonal_t if that tag is
also used as a function argument; see below.
29.9.5.3 Diagonal tags [linalg.tags.diagonal]
struct implicit_unit_diagonal_t {
explicit implicit_unit_diagonal_t() = default;
};
inline constexpr implicit_unit_diagonal_t implicit_unit_diagonal{};
struct explicit_diagonal_t {
explicit explicit_diagonal_t() = default;
};
§ 29.9.5.3 © ISO/IEC
1831

===== PAGE 1843 =====

Dxxxx
inline constexpr explicit_diagonal_t explicit_diagonal{};
1 These tag classes specify whether algorithms access the matrix’s diagonal entries, and if not, then how
algorithms interpret the matrix’s implicitly represented diagonal values.
2 The implicit_unit_diagonal_t tag indicates that an implicit unit diagonal is to be assumed (29.9.3).
3 The explicit_diagonal_t tag indicates that an explicit diagonal is used (29.9.3).
29.9.6 Layouts for packed matrix types [linalg.layout.packed]
29.9.6.1 Overview [linalg.layout.packed.overview]
1 layout_blas_packed is anmdspan layout mapping policy that represents a square matrix that stores only
the entries in one triangle, in a packed contiguous format. ItsTriangle template parameter determines
whether an mdspan with this layout stores the upper or lower triangle of the matrix. ItsStorageOrder
template parameter determines whether the layout packs the matrix’s elements in column-major or row-major
order.
2 A StorageOrder of column_major_t indicates column-major ordering. This packs matrix elements starting
with the leftmost (least column index) column, and proceeding column by column, from the top entry (least
row index).
3 A StorageOrder of row_major_t indicates row-major ordering. This packs matrix elements starting with
the topmost (least row index) row, and proceeding row by row, from the leftmost (least column index) entry.
4 [Note 1: layout_blas_packed describes the data layout used by the BLAS’ Symmetric Packed (SP), Hermitian
Packed (HP), and Triangular Packed (TP) matrix types.—end note]
namespace std::linalg {
template<class Triangle, class StorageOrder>
class layout_blas_packed {
public:
using triangle_type = Triangle;
using storage_order_type = StorageOrder;
template<class Extents>
struct mapping {
public:
using extents_type = Extents;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using layout_type = layout_blas_packed;
// 29.9.6.2, constructors
constexpr mapping() noexcept = default;
constexpr mapping(const mapping&) noexcept = default;
constexpr mapping(const extents_type&) noexcept;
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const mapping<OtherExtents>& other) noexcept;
constexpr mapping& operator=(const mapping&) noexcept = default;
// 29.9.6.3, observers
constexpr const extents_type& extents() const noexcept { return extents_; }
constexpr index_type required_span_size() const noexcept;
template<class Index0, class Index1>
constexpr index_type operator() (Index0 ind0, Index1 ind1) const noexcept;
static constexpr bool is_always_unique() noexcept {
return (extents_type::static_extent(0) != dynamic_extent &&
extents_type::static_extent(0) < 2) ||
(extents_type::static_extent(1) != dynamic_extent &&
extents_type::static_extent(1) < 2);
§ 29.9.6.1 © ISO/IEC
1832

===== PAGE 1844 =====

Dxxxx
}
static constexpr bool is_always_exhaustive() noexcept { return true; }
static constexpr bool is_always_strided() noexcept
{ return is_always_unique(); }
constexpr bool is_unique() const noexcept {
return extents_.extent(0) < 2;
}
constexpr bool is_exhaustive() const noexcept { return true; }
constexpr bool is_strided() const noexcept {
return extents_.extent(0) < 2;
}
constexpr index_type stride(rank_type) const noexcept;
template<class OtherExtents>
friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;
private:
extents_type extents_{}; // exposition only
};
};
}
5 Mandates:
—(5.1) Triangle is eitherupper_triangle_t or lower_triangle_t,
—(5.2) StorageOrder is eithercolumn_major_t or row_major_t,
—(5.3) Extents is a specialization ofstd::extents,
—(5.4) Extents::rank() equals 2,
—(5.5) one of
extents_type::static_extent(0) == dynamic_extent,
extents_type::static_extent(1) == dynamic_extent, or
extents_type::static_extent(0) == extents_type::static_extent(1)
is true, and
—(5.6) if Extents::rank_dynamic() == 0 is true, let Ns be equal to Extents::static_extent(0);
then, Ns ×(Ns + 1) is representable as a value of typeindex_type.
6 layout_blas_packed<T, SO>::mapping<E> is a trivially copyable type that modelsregular for each
T, SO, andE.
29.9.6.2 Constructors [linalg.layout.packed.cons]
constexpr mapping(const extents_type& e) noexcept;
1 Preconditions:
—(1.1) Let N be equal toe.extent(0). Then, N ×(N + 1) is representable as a value of typeindex_-
type (6.9.2).
—(1.2) e.extent(0) equals e.extent(1).
2 Effects: Direct-non-list-initializes extents_ with e.
template<class OtherExtents>
explicit(!is_convertible_v<OtherExtents, extents_type>)
constexpr mapping(const mapping<OtherExtents>& other) noexcept;
3 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
4 Preconditions: Let N be other.extents().extent(0). Then, N×(N+ 1) is representable as a value
of typeindex_type (6.9.2).
5 Effects: Direct-non-list-initializes extents_ with other.extents().
§ 29.9.6.2 © ISO/IEC
1833

===== PAGE 1845 =====

Dxxxx
29.9.6.3 Observers [linalg.layout.packed.obs]
constexpr index_type required_span_size() const noexcept;
1 Returns: extents_.extent(0) * (extents_.extent(0) + 1)/2.
[Note 1: For example, a 5 x 5 packed matrix only stores 15 matrix elements.—end note]
template<class Index0, class Index1>
constexpr index_type operator() (Index0 ind0, Index1 ind1) const noexcept;
2 Constraints:
—(2.1) is_convertible_v<Index0, index_type> is true,
—(2.2) is_convertible_v<Index1, index_type> is true,
—(2.3) is_nothrow_constructible_v<index_type, Index0> is true, and
—(2.4) is_nothrow_constructible_v<index_type, Index1> is true.
3 Let i be extents_type::index-cast (ind0), and letj be extents_type::index-cast (ind1).
4 Preconditions: i, j is a multidimensional index inextents_ (23.7.3.1).
5 Returns: Let N be extents_.extent(0). Then
—(5.1) (*this)(j, i) if i > j is true; otherwise
—(5.2) i + j * (j + 1)/2 if
is_same_v<StorageOrder, column_major_t> && is_same_v<Triangle, upper_triangle_t>
is true or
is_same_v<StorageOrder, row_major_t> && is_same_v<Triangle, lower_triangle_t>
is true; otherwise
—(5.3) j + N * i - i * (i + 1)/2.
constexpr index_type stride(rank_type r) const noexcept;
6 Preconditions:
—(6.1) is_strided() is true, and
—(6.2) r < extents_type::rank() is true.
7 Returns: 1.
template<class OtherExtents>
friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
8 Effects: Equivalent to:return x.extents() == y.extents();
29.9.7 Exposition-only helpers [linalg.helpers]
29.9.7.1 abs-if-needed [linalg.helpers.abs]
1 The nameabs-if-needed denotes an exposition-only function object. The expressionabs-if-needed (E)
for a subexpressionE whose type isT is expression-equivalent to:
—(1.1) E if T is an unsigned integer;
—(1.2) otherwise, std::abs(E) if T is an arithmetic type,
—(1.3) otherwise, abs(E), if that expression is valid, with overload resolution performed in a context that
includes the declaration
template<class U> U abs(U) = delete;
If the function selected by overload resolution does not return the absolute value of its input, the
program is ill-formed, no diagnostic required.
29.9.7.2 conj-if-needed [linalg.helpers.conj]
1 The nameconj-if-needed denotes an exposition-only function object. The expressionconj-if-needed (E)
for a subexpressionE whose type isT is expression-equivalent to:
§ 29.9.7.2 © ISO/IEC
1834

===== PAGE 1846 =====

Dxxxx
—(1.1) conj(E), ifT is not an arithmetic type and the expressionconj(E) is valid, with overload resolution
performed in a context that includes the declaration
template<class U> U conj(const U&) = delete;
If the function selected by overload resolution does not return the complex conjugate of its input, the
program is ill-formed, no diagnostic required;
—(1.2) otherwise, E.
29.9.7.3 real-if-needed [linalg.helpers.real]
1 The namereal-if-needed denotes an exposition-only function object. The expressionreal-if-needed (E)
for a subexpressionE whose type isT is expression-equivalent to:
—(1.1) real(E), ifT is not an arithmetic type and the expressionreal(E) is valid, with overload resolution
performed in a context that includes the declaration
template<class U> U real(const U&) = delete;
If the function selected by overload resolution does not return the real part of its input, the program is
ill-formed, no diagnostic required;
—(1.2) otherwise, E.
29.9.7.4 imag-if-needed [linalg.helpers.imag]
1 The nameimag-if-needed denotes an exposition-only function object. The expressionimag-if-needed (E)
for a subexpressionE whose type isT is expression-equivalent to:
—(1.1) imag(E), ifT is not an arithmetic type and the expressionimag(E) is valid, with overload resolution
performed in a context that includes the declaration
template<class U> U imag(const U&) = delete;
If the function selected by overload resolution does not return the imaginary part of its input, the
program is ill-formed, no diagnostic required;
—(1.2) otherwise, ((void)E, T{}).
29.9.7.5 Argument concepts [linalg.helpers.concepts]
1 The exposition-only concepts defined in this section constrain the algorithms in 29.9.
template<class T>
constexpr bool is-mdspan = false;
template<class ElementType, class Extents, class Layout, class Accessor>
constexpr bool is-mdspan <mdspan<ElementType, Extents, Layout, Accessor>> = true;
template<class T>
concept in-vector =
is-mdspan <T> && T::rank() == 1;
template<class T>
concept out-vector =
is-mdspan <T> && T::rank() == 1 &&
is_assignable_v<typename T::reference, typename T::element_type> && T::is_always_unique();
template<class T>
concept inout-vector =
is-mdspan <T> && T::rank() == 1 &&
is_assignable_v<typename T::reference, typename T::element_type> && T::is_always_unique();
template<class T>
concept in-matrix =
is-mdspan <T> && T::rank() == 2;
template<class T>
concept out-matrix =
is-mdspan <T> && T::rank() == 2 &&
is_assignable_v<typename T::reference, typename T::element_type> && T::is_always_unique();
§ 29.9.7.5 © ISO/IEC
1835

===== PAGE 1847 =====

Dxxxx
template<class T>
concept inout-matrix =
is-mdspan <T> && T::rank() == 2 &&
is_assignable_v<typename T::reference, typename T::element_type> && T::is_always_unique();
template<class T>
constexpr bool is-layout-blas-packed = false; // exposition only
template<class Triangle, class StorageOrder>
constexpr bool is-layout-blas-packed <layout_blas_packed<Triangle, StorageOrder>> = true;
template<class T>
concept possibly-packed-out-matrix =
is-mdspan <T> && T::rank() == 2 &&
is_assignable_v<typename T::reference, typename T::element_type> &&
(T::is_always_unique() || is-layout-blas-packed <typename T::layout_type>);
template<class T>
concept in-object =
is-mdspan <T> && (T::rank() == 1 || T::rank() == 2);
template<class T>
concept out-object =
is-mdspan <T> && (T::rank() == 1 || T::rank() == 2) &&
is_assignable_v<typename T::reference, typename T::element_type> && T::is_always_unique();
template<class T>
concept inout-object =
is-mdspan <T> && (T::rank() == 1 || T::rank() == 2) &&
is_assignable_v<typename T::reference, typename T::element_type> && T::is_always_unique();
template<class T>
concept scalar =
semiregular<T> && (!is-mdspan <T>) && (!is_execution_policy_v<T>);
2 If a function in 29.9 accesses the elements of a parameter constrained byin-vector , in-matrix , or
in-object , those accesses will not modify the elements.
3 Unless explicitly permitted, anyinout-vector , inout-matrix , inout-object , out-vector , out-matrix ,
out-object , orpossibly-packed-out-matrix parameter of a function in 29.9 shall not overlap any other
mdspan parameter of the function.
29.9.7.6 Mandates [linalg.helpers.mandates]
1 [Note 1: These exposition-only helper functions use the less constraining input concepts even for the output arguments,
because the additional constraint for assignability of elements is not necessary, and they are sometimes used in a
context where the third argument is an input type too.—end note]
template<class MDS1, class MDS2>
requires(is-mdspan <MDS1> && is-mdspan <MDS2>)
constexpr
bool compatible-static-extents (size_t r1, size_t r2) { // exposition only
return MDS1::static_extent(r1) == dynamic_extent ||
MDS2::static_extent(r2) == dynamic_extent ||
MDS1::static_extent(r1) == MDS2::static_extent(r2);
}
template<in-vector In1, in-vector In2, in-vector Out>
constexpr bool possibly-addable () { // exposition only
return compatible-static-extents <Out, In1>(0, 0) &&
compatible-static-extents <Out, In2>(0, 0) &&
compatible-static-extents <In1, In2>(0, 0);
}
§ 29.9.7.6 © ISO/IEC
1836

===== PAGE 1848 =====

Dxxxx
template<in-matrix In1, in-matrix In2, in-matrix Out>
constexpr bool possibly-addable () { // exposition only
return compatible-static-extents <Out, In1>(0, 0) &&
compatible-static-extents <Out, In1>(1, 1) &&
compatible-static-extents <Out, In2>(0, 0) &&
compatible-static-extents <Out, In2>(1, 1) &&
compatible-static-extents <In1, In2>(0, 0) &&
compatible-static-extents <In1, In2>(1, 1);
}
template<in-matrix InMat, in-vector InVec, in-vector OutVec>
constexpr bool possibly-multipliable () { // exposition only
return compatible-static-extents <OutVec, InMat>(0, 0) &&
compatible-static-extents <InMat, InVec>(1, 0);
}
template<in-vector InVec, in-matrix InMat, in-vector OutVec>
constexpr bool possibly-multipliable () { // exposition only
return compatible-static-extents <OutVec, InMat>(0, 1) &&
compatible-static-extents <InMat, InVec>(0, 0);
}
template<in-matrix InMat1, in-matrix InMat2, in-matrix OutMat>
constexpr bool possibly-multipliable () { // exposition only
return compatible-static-extents <OutMat, InMat1>(0, 0) &&
compatible-static-extents <OutMat, InMat2>(1, 1) &&
compatible-static-extents <InMat1, InMat2>(1, 0);
}
29.9.7.7 Preconditions [linalg.helpers.precond]
1 [Note 1: These exposition-only helper functions use the less constraining input concepts even for the output arguments,
because the additional constraint for assignability of elements is not necessary, and they are sometimes used in a
context where the third argument is an input type too.—end note]
constexpr bool addable ( // exposition only
const in-vector auto& in1, const in-vector auto& in2, const in-vector auto& out) {
return out.extent(0) == in1.extent(0) && out.extent(0) == in2.extent(0);
}
constexpr bool addable ( // exposition only
const in-matrix auto& in1, const in-matrix auto& in2, const in-matrix auto& out) {
return out.extent(0) == in1.extent(0) && out.extent(1) == in1.extent(1) &&
out.extent(0) == in2.extent(0) && out.extent(1) == in2.extent(1);
}
constexpr bool multipliable ( // exposition only
const in-matrix auto& in_mat, const in-vector auto& in_vec, const in-vector auto& out_vec) {
return out_vec.extent(0) == in_mat.extent(0) && in_mat.extent(1) == in_vec.extent(0);
}
constexpr bool multipliable ( // exposition only
const in-vector auto& in_vec, const in-matrix auto& in_mat, const in-vector auto& out_vec) {
return out_vec.extent(0) == in_mat.extent(1) && in_mat.extent(0) == in_vec.extent(0);
}
constexpr bool multipliable ( // exposition only
const in-matrix auto& in_mat1, const in-matrix auto& in_mat2, const in-matrix auto& out_mat) {
return out_mat.extent(0) == in_mat1.extent(0) && out_mat.extent(1) == in_mat2.extent(1) &&
in_mat1.extent(1) == in_mat2.extent(0);
}
§ 29.9.7.7 © ISO/IEC
1837

===== PAGE 1849 =====

Dxxxx
29.9.8 Scaled in-place transformation [linalg.scaled]
29.9.8.1 Introduction [linalg.scaled.intro]
1 The scaled function takes a valuealpha and an mdspan x, and returns a new read-onlymdspan that
represents the elementwise product ofalpha with each element ofx.
[Example 1:
using Vec = mdspan<double, dextents<size_t, 1>>;
// z = alpha * x + y
void z_equals_alpha_times_x_plus_y(double alpha, Vec x, Vec y, Vec z) {
add(scaled(alpha, x), y, z);
}
// z = alpha * x + beta * y
void z_equals_alpha_times_x_plus_beta_times_y(double alpha, Vec x, double beta, Vec y, Vec z) {
add(scaled(alpha, x), scaled(beta, y), z);
}
—end example]
29.9.8.2 Class template scaled_accessor [linalg.scaled.scaledaccessor]
1 The class templatescaled_accessoris anmdspanaccessor policy which upon access produces scaled elements.
It is part of the implementation ofscaled (29.9.8.3).
namespace std::linalg {
template<class ScalingFactor, class NestedAccessor>
class scaled_accessor {
public:
using element_type =
const decltype(declval<ScalingFactor>() * declval<NestedAccessor::element_type>());
using reference = remove_const_t<element_type>;
using data_handle_type = NestedAccessor::data_handle_type;
using offset_policy = scaled_accessor<ScalingFactor, NestedAccessor::offset_policy>;
constexpr scaled_accessor() = default;
template<class OtherNestedAccessor>
explicit(!is_convertible_v<OtherNestedAccessor, NestedAccessor>)
constexpr scaled_accessor(const scaled_accessor<ScalingFactor,
OtherNestedAccessor>& other);
constexpr scaled_accessor(const ScalingFactor& s, const NestedAccessor& a);
constexpr reference access(data_handle_type p, size_t i) const;
constexpr offset_policy::data_handle_type offset(data_handle_type p, size_t i) const;
constexpr const ScalingFactor& scaling_factor() const noexcept { return scaling-factor ; }
constexpr const NestedAccessor& nested_accessor() const noexcept { return nested-accessor ; }
private:
ScalingFactor scaling-factor {}; // exposition only
NestedAccessor nested-accessor {}; // exposition only
};
}
2 Mandates:
—(2.1) element_type is valid and denotes a type,
—(2.2) is_copy_constructible_v<reference> is true,
—(2.3) is_reference_v<element_type> is false,
—(2.4) ScalingFactor models semiregular, and
—(2.5) NestedAccessor meets the accessor policy requirements (23.7.3.5.2).
§ 29.9.8.2 © ISO/IEC
1838

===== PAGE 1850 =====

Dxxxx
template<class OtherNestedAccessor>
explicit(!is_convertible_v<OtherNestedAccessor, NestedAccessor>)
constexpr scaled_accessor(const scaled_accessor<ScalingFactor, OtherNestedAccessor>& other);
3 Constraints: is_constructible_v<NestedAccessor, const OtherNestedAccessor&> is true.
4 Effects:
—(4.1) Direct-non-list-initializes scaling-factor with other.scaling_factor(), and
—(4.2) direct-non-list-initializes nested-accessor with other.nested_accessor().
constexpr scaled_accessor(const ScalingFactor& s, const NestedAccessor& a);
5 Effects:
—(5.1) Direct-non-list-initializes scaling-factor with s, and
—(5.2) direct-non-list-initializes nested-accessor with a.
constexpr reference access(data_handle_type p, size_t i) const;
6 Returns:
scaling_factor() * NestedAccessor::element_type(nested-accessor .access(p, i))
constexpr offset_policy::data_handle_type offset(data_handle_type p, size_t i) const;
7 Returns: nested-accessor .offset(p, i)
29.9.8.3 Function template scaled [linalg.scaled.scaled]
1 The scaled function template takes a scaling factoralpha and anmdspan x, and returns a new read-only
mdspan with the same domain asx, that represents the elementwise product ofalpha with each element ofx.
template<class ScalingFactor,
class ElementType, class Extents, class Layout, class Accessor>
constexpr auto scaled(ScalingFactor alpha, mdspan<ElementType, Extents, Layout, Accessor> x);
2 Let SA be scaled_accessor<ScalingFactor, Accessor>.
3 Returns:
mdspan<typename SA::element_type, Extents, Layout, SA>(x.data_handle(), x.mapping(),
SA(alpha, x.accessor()))
4 [Example 1:
void test_scaled(mdspan<double, extents<int, 10>> x)
{
auto x_scaled = scaled(5.0, x);
for (int i = 0; i < x.extent(0); ++i) {
assert(x_scaled[i] == 5.0 * x[i]);
}
}
—end example]
29.9.9 Conjugated in-place transformation [linalg.conj]
29.9.9.1 Introduction [linalg.conj.intro]
1 The conjugated function takes anmdspan x, and returns a new read-onlymdspan ywith the same domain
as x, whose elements are the complex conjugates of the corresponding elements ofx.
29.9.9.2 Class template conjugated_accessor [linalg.conj.conjugatedaccessor]
1 The class templateconjugated_accessor is anmdspan accessor policy which upon access produces conjugate
elements. It is part of the implementation ofconjugated (29.9.9.3).
namespace std::linalg {
template<class NestedAccessor>
class conjugated_accessor {
public:
using element_type =
const decltype(conj-if-needed (declval<NestedAccessor::element_type>()));
§ 29.9.9.2 © ISO/IEC
1839

===== PAGE 1851 =====

Dxxxx
using reference = remove_const_t<element_type>;
using data_handle_type = NestedAccessor::data_handle_type;
using offset_policy = conjugated_accessor<NestedAccessor::offset_policy>;
constexpr conjugated_accessor() = default;
constexpr conjugated_accessor(const NestedAccessor& acc);
template<class OtherNestedAccessor>
explicit(!is_convertible_v<OtherNestedAccessor, NestedAccessor>)
constexpr conjugated_accessor(const conjugated_accessor<OtherNestedAccessor>& other);
constexpr reference access(data_handle_type p, size_t i) const;
constexpr typename offset_policy::data_handle_type
offset(data_handle_type p, size_t i) const;
constexpr const NestedAccessor& nested_accessor() const noexcept { return nested-accessor_; }
private:
NestedAccessor nested-accessor_{}; // exposition only
};
}
2 Mandates:
—(2.1) element_type is valid and denotes a type,
—(2.2) is_copy_constructible_v<reference> is true,
—(2.3) is_reference_v<element_type> is false, and
—(2.4) NestedAccessor meets the accessor policy requirements (23.7.3.5.2).
constexpr conjugated_accessor(const NestedAccessor& acc);
3 Effects: Direct-non-list-initializes nested-accessor_ with acc.
template<class OtherNestedAccessor>
explicit(!is_convertible_v<OtherNestedAccessor, NestedAccessor>)
constexpr conjugated_accessor(const conjugated_accessor<OtherNestedAccessor>& other);
4 Constraints: is_constructible_v<NestedAccessor, const OtherNestedAccessor&> is true.
5 Effects: Direct-non-list-initializes nested-accessor_ with other.nested_accessor().
constexpr reference access(data_handle_type p, size_t i) const;
6 Returns: conj-if-needed (NestedAccessor::element_type(nested-accessor_.access(p, i)))
constexpr typename offset_policy::data_handle_type offset(data_handle_type p, size_t i) const;
7 Returns: nested-accessor_.offset(p, i)
29.9.9.3 Function template conjugated [linalg.conj.conjugated]
template<class ElementType, class Extents, class Layout, class Accessor>
constexpr auto conjugated(mdspan<ElementType, Extents, Layout, Accessor> a);
1 Let A be
—(1.1) remove_cvref_t<decltype(a.accessor().nested_accessor())> if Accessor is a specializa-
tion ofconjugated_accessor;
—(1.2) otherwise, Accessor if remove_cvref_t<ElementType> is an arithmetic type;
—(1.3) otherwise, conjugated_accessor<Accessor> if the expressionconj(E) is valid for any subex-
pression E whose type isremove_cvref_t<ElementType> with overload resolution performed in a
context that includes the declarationtemplate<class U> U conj(const U&) = delete;;
—(1.4) otherwise, Accessor.
2 Returns: Let MD be mdspan<typename A::element_type, Extents, Layout, A>.
—(2.1) MD(a.data_handle(), a.mapping(), a.accessor().nested_accessor()) if Accessor is a
specialization of conjugated_accessor;
§ 29.9.9.3 © ISO/IEC
1840

===== PAGE 1852 =====

Dxxxx
—(2.2) otherwise, a, ifis_same_v<A, Accessor> is true;
—(2.3) otherwise, MD(a.data_handle(), a.mapping(), conjugated_accessor(a.accessor())).
3 [Example 1:
void test_conjugated_complex(mdspan<complex<double>, extents<int, 10>> a) {
auto a_conj = conjugated(a);
for (int i = 0; i < a.extent(0); ++i) {
assert(a_conj[i] == conj(a[i]);
}
auto a_conj_conj = conjugated(a_conj);
for (int i = 0; i < a.extent(0); ++i) {
assert(a_conj_conj[i] == a[i]);
}
}
void test_conjugated_real(mdspan<double, extents<int, 10>> a) {
auto a_conj = conjugated(a);
for (int i = 0; i < a.extent(0); ++i) {
assert(a_conj[i] == a[i]);
}
auto a_conj_conj = conjugated(a_conj);
for (int i = 0; i < a.extent(0); ++i) {
assert(a_conj_conj[i] == a[i]);
}
}
—end example]
29.9.10 Transpose in-place transformation [linalg.transp]
29.9.10.1 Introduction [linalg.transp.intro]
1 layout_transpose is anmdspan layout mapping policy that swaps the two indices, extents, and strides of
any uniquemdspan layout mapping policy.
2 The transposed function takes anmdspan representing a matrix, and returns a newmdspan representing
the transpose of the input matrix.
29.9.10.2 Exposition-only helpers for layout_transpose and transposed [linalg.transp.helpers]
1 The exposition-only transpose-extents function takes anextents object representing the extents of a
matrix, and returns a newextents object representing the extents of the transpose of the matrix.
2 The exposition-only alias templatetranspose-extents-t <InputExtents> gives the type oftranspose-ex-
tents (e) for a givenextents object e of typeInputExtents.
template<class IndexType, size_t InputExtent0, size_t InputExtent1>
constexpr extents<IndexType, InputExtent1, InputExtent0>
transpose-extents (const extents<IndexType, InputExtent0, InputExtent1>& in); // exposition only
3 Returns: extents<IndexType, InputExtent1, InputExtent0>(in.extent(1), in.extent(0))
template<class InputExtents>
using transpose-extents-t =
decltype(transpose-extents (declval<InputExtents>())); // exposition only
29.9.10.3 Class template layout_transpose [linalg.transp.layout.transpose]
1 layout_transpose is anmdspan layout mapping policy that swaps the two indices, extents, and strides of
any mdspan layout mapping policy.
namespace std::linalg {
template<class Layout>
class layout_transpose {
public:
using nested_layout_type = Layout;
§ 29.9.10.3 © ISO/IEC
1841

===== PAGE 1853 =====

Dxxxx
template<class Extents>
struct mapping {
private:
using nested-mapping-type =
Layout::template mapping<transpose-extents-t <Extents>>; // exposition only
public:
using extents_type = Extents;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using layout_type = layout_transpose;
constexpr explicit mapping(const nested-mapping-type &);
constexpr const extents_type& extents() const noexcept { return extents_; }
constexpr index_type required_span_size() const
{ return nested-mapping_.required_span_size(); }
template<class Index0, class Index1>
constexpr index_type operator()(Index0 ind0, Index1 ind1) const
{ return nested-mapping_(ind1, ind0); }
constexpr const nested-mapping-type & nested_mapping() const noexcept
{ return nested-mapping_; }
static constexpr bool is_always_unique() noexcept
{ return nested-mapping-type ::is_always_unique(); }
static constexpr bool is_always_exhaustive() noexcept
{ return nested-mapping-type ::is_always_exhaustive(); }
static constexpr bool is_always_strided() noexcept
{ return nested-mapping-type ::is_always_strided(); }
constexpr bool is_unique() const { return nested-mapping_.is_unique(); }
constexpr bool is_exhaustive() const { return nested-mapping_.is_exhaustive(); }
constexpr bool is_strided() const { return nested-mapping_.is_strided(); }
constexpr index_type stride(size_t r) const;
template<class OtherExtents>
friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y);
private:
nested-mapping-type nested-mapping_ ; // exposition only
extents_type extents_; // exposition only
};
};
}
2 Layout shall meet the layout mapping policy requirements (23.7.3.4.3).
3 Mandates:
—(3.1) Extents is a specialization ofstd::extents, and
—(3.2) Extents::rank() equals 2.
constexpr explicit mapping(const nested-mapping-type & map);
4 Effects:
—(4.1) Initializes nested-mapping_ with map, and
—(4.2) initializes extents_ with transpose-extents (map.extents()).
§ 29.9.10.3 © ISO/IEC
1842

===== PAGE 1854 =====

Dxxxx
constexpr index_type stride(size_t r) const;
5 Preconditions:
—(5.1) is_strided() is true, and
—(5.2) r < 2 is true.
6 Returns: nested-mapping_.stride(r == 0 ? 1 : 0)
template<class OtherExtents>
friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y);
7 Constraints: The expressionx.nested-mapping_ == y.nested-mapping_ is well-formed and its result
is convertible tobool.
8 Returns: x.nested-mapping_ == y.nested-mapping_.
29.9.10.4 Function template transposed [linalg.transp.transposed]
1 The transposedfunction takes a rank-2mdspanrepresenting a matrix, and returns a newmdspanrepresenting
the input matrix’s transpose. The input matrix’s data are not modified, and the returnedmdspan accesses
the input matrix’s data in place.
template<class ElementType, class Extents, class Layout, class Accessor>
constexpr auto transposed(mdspan<ElementType, Extents, Layout, Accessor> a);
2 Mandates: Extents::rank() == 2 is true.
3 Let ReturnExtents be transpose-extents-t <Extents>. LetR be mdspan<ElementType, ReturnEx-
tents, ReturnLayout, Accessor>, whereReturnLayout is:
—(3.1) layout_right if Layout is layout_left;
—(3.2) otherwise, layout_left if Layout is layout_right;
—(3.3) otherwise, layout_right_padded<PaddingValue> if Layout is
layout_left_padded<PaddingValue> for somesize_t value PaddingValue;
—(3.4) otherwise, layout_left_padded<PaddingValue> if Layout is
layout_right_padded<PaddingValue> for somesize_t value PaddingValue;
—(3.5) otherwise, layout_stride if Layout is layout_stride;
—(3.6) otherwise, layout_blas_packed<OppositeTriangle, OppositeStorageOrder>, ifLayout is
layout_blas_packed<Triangle, StorageOrder> for someTriangle and StorageOrder, where
—(3.6.1) OppositeTriangle is
conditional_t<is_same_v<Triangle, upper_triangle_t>,
lower_triangle_t, upper_triangle_t>
and
—(3.6.2) OppositeStorageOrder is
conditional_t<is_same_v<StorageOrder, column_major_t>, row_major_t, column_major_t>
—(3.7) otherwise, NestedLayout if Layout is layout_transpose<NestedLayout> for someNestedLay-
out;
—(3.8) otherwise, layout_transpose<Layout>.
4 Returns: WithReturnMapping being the typetypename ReturnLayout::template mapping<Return-
Extents>:
—(4.1) if Layout is layout_left, layout_right, or a specialization oflayout_blas_packed,
R(a.data_handle(), ReturnMapping(transpose-extents (a.mapping().extents())),
a.accessor())
—(4.2) otherwise,
R(a.data_handle(), ReturnMapping(transpose-extents (a.mapping().extents()),
a.mapping().stride(1)), a.accessor())
if Layout is layout_left_padded<PaddingValue> for somesize_t value PaddingValue;
—(4.3) otherwise,
§ 29.9.10.4 © ISO/IEC
1843

===== PAGE 1855 =====

Dxxxx
R(a.data_handle(), ReturnMapping(transpose-extents (a.mapping().extents()),
a.mapping().stride(0)), a.accessor())
if Layout is layout_right_padded<PaddingValue> for somesize_t value PaddingValue;
—(4.4) otherwise, ifLayout is layout_stride,
R(a.data_handle(), ReturnMapping(transpose-extents (a.mapping().extents()),
array{a.mapping().stride(1), a.mapping().stride(0)}), a.accessor())
—(4.5) otherwise, ifLayout is a specialization oflayout_transpose,
R(a.data_handle(), a.mapping().nested_mapping(), a.accessor())
—(4.6) otherwise,
R(a.data_handle(), ReturnMapping(a.mapping()), a.accessor())
5 [Example 1:
void test_transposed(mdspan<double, extents<size_t, 3, 4>> a) {
const auto num_rows = a.extent(0);
const auto num_cols = a.extent(1);
auto a_t = transposed(a);
assert(num_rows == a_t.extent(1));
assert(num_cols == a_t.extent(0));
assert(a.stride(0) == a_t.stride(1));
assert(a.stride(1) == a_t.stride(0));
for (size_t row = 0; row < num_rows; ++row) {
for (size_t col = 0; col < num_rows; ++col) {
assert(a[row, col] == a_t[col, row]);
}
}
auto a_t_t = transposed(a_t);
assert(num_rows == a_t_t.extent(0));
assert(num_cols == a_t_t.extent(1));
assert(a.stride(0) == a_t_t.stride(0));
assert(a.stride(1) == a_t_t.stride(1));
for (size_t row = 0; row < num_rows; ++row) {
for (size_t col = 0; col < num_rows; ++col) {
assert(a[row, col] == a_t_t[row, col]);
}
}
}
—end example]
29.9.11 Conjugate transpose in-place transform [linalg.conjtransposed]
1 The conjugate_transposed function returns a conjugate transpose view of an object. This combines the
effects oftransposed and conjugated.
template<class ElementType, class Extents, class Layout, class Accessor>
constexpr auto conjugate_transposed(mdspan<ElementType, Extents, Layout, Accessor> a);
2 Effects: Equivalent to:return conjugated(transposed(a));
3 [Example 1:
void test_conjugate_transposed(mdspan<complex<double>, extents<size_t, 3, 4>> a) {
const auto num_rows = a.extent(0);
const auto num_cols = a.extent(1);
auto a_ct = conjugate_transposed(a);
assert(num_rows == a_ct.extent(1));
assert(num_cols == a_ct.extent(0));
assert(a.stride(0) == a_ct.stride(1));
assert(a.stride(1) == a_ct.stride(0));
§ 29.9.11 © ISO/IEC
1844

===== PAGE 1856 =====

Dxxxx
for (size_t row = 0; row < num_rows; ++row) {
for (size_t col = 0; col < num_rows; ++col) {
assert(a[row, col] == conj(a_ct[col, row]));
}
}
auto a_ct_ct = conjugate_transposed(a_ct);
assert(num_rows == a_ct_ct.extent(0));
assert(num_cols == a_ct_ct.extent(1));
assert(a.stride(0) == a_ct_ct.stride(0));
assert(a.stride(1) == a_ct_ct.stride(1));
for (size_t row = 0; row < num_rows; ++row) {
for (size_t col = 0; col < num_rows; ++col) {
assert(a[row, col] == a_ct_ct[row, col]);
assert(conj(a_ct[col, row]) == a_ct_ct[row, col]);
}
}
}
—end example]
29.9.12 Algorithm requirements based on template parameter name[linalg.algs.reqs]
1 Throughout 29.9.13, 29.9.14, and 29.9.15, where the template parameters are not constrained, the names of
template parameters are used to express the following constraints.
—(1.1) is_execution_policy<ExecutionPolicy>::value is true (26.3.6.2).
—(1.2) Real is any type such thatcomplex<Real> is specified (29.4.1).
—(1.3) Triangle is eitherupper_triangle_t or lower_triangle_t.
—(1.4) DiagonalStorage is eitherimplicit_unit_diagonal_t or explicit_diagonal_t.
[Note 1: Function templates that have a template parameter namedExecutionPolicy are parallel algorithms (26.3.1).
—end note]
29.9.13 BLAS 1 algorithms [linalg.algs.blas1]
29.9.13.1 Complexity [linalg.algs.blas1.complexity]
1 Complexity: All algorithms in 29.9.13 withmdspan parameters perform a count ofmdspan array accesses and
arithmetic operations that is linear in the maximum product of extents of anymdspan parameter.
29.9.13.2 Givens rotations [linalg.algs.blas1.givens]
29.9.13.2.1 Compute Givens rotation [linalg.algs.blas1.givens.lartg]
template<class Real>
setup_givens_rotation_result<Real> setup_givens_rotation(Real a, Real b) noexcept;
template<class Real>
setup_givens_rotation_result<complex<Real>>
setup_givens_rotation(complex<Real> a, complex<Real> b) noexcept;
1 These functions compute the Givens plane rotation represented by the two valuescand ssuch that the
2 x 2 system of equations [c s
−s c
]
·
[a
b
]
=
[r
0
]
holds, wherec is always a real scalar, andc2 + |s|2 = 1. That is,c and s represent a 2 x 2 matrix, that
when multiplied by the right by the input vector whose components area and b, produces a result
vector whose first componentr is the Euclidean norm of the input vector, and whose second component
is zero.
[Note 1: These functions correspond to the LAPACK functionxLARTG[20]. —end note]
2 Returns: c, s, r, wherec and s form the Givens plane rotation corresponding to the inputa and b,
and r is the Euclidean norm of the two-component vector formed bya and b.
§ 29.9.13.2.1 © ISO/IEC
1845

===== PAGE 1857 =====

Dxxxx
29.9.13.2.2 Apply a computed Givens rotation to vectors [linalg.algs.blas1.givens.rot]
template<inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, Real s);
template<class ExecutionPolicy, inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(ExecutionPolicy&& exec,
InOutVec1 x, InOutVec2 y, Real c, Real s);
template<inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, complex<Real> s);
template<class ExecutionPolicy, inout-vector InOutVec1, inout-vector InOutVec2, class Real>
void apply_givens_rotation(ExecutionPolicy&& exec,
InOutVec1 x, InOutVec2 y, Real c, complex<Real> s);
1 [Note 1: These functions correspond to the BLAS functionxROT[17]. —end note]
2 Mandates: compatible-static-extents <InOutVec1, InOutVec2>(0, 0) is true.
3 Preconditions: x.extent(0) equals y.extent(0).
4 Effects: Applies the plane rotation specified byc and s to the input vectorsx and y, as if the rotation
were a 2 x 2 matrix and the input vectors were successive rows of a matrix with two rows.
29.9.13.3 Swap matrix or vector elements [linalg.algs.blas1.swap]
template<inout-object InOutObj1, inout-object InOutObj2>
void swap_elements(InOutObj1 x, InOutObj2 y);
template<class ExecutionPolicy, inout-object InOutObj1, inout-object InOutObj2>
void swap_elements(ExecutionPolicy&& exec, InOutObj1 x, InOutObj2 y);
1 [Note 1: These functions correspond to the BLAS functionxSWAP[17]. —end note]
2 Constraints: x.rank() equals y.rank().
3 Mandates: For allr in the range[0,x.rank()),
compatible-static-extents <InOutObj1, InOutObj2>(r, r)
is true.
4 Preconditions: x.extents() equals y.extents().
5 Effects: Swaps all corresponding elements ofx and y.
29.9.13.4 Multiply the elements of an object in place by a scalar [linalg.algs.blas1.scal]
template<scalar Scalar, inout-object InOutObj>
void scale(Scalar alpha, InOutObj x);
template<class ExecutionPolicy, scalar Scalar, inout-object InOutObj>
void scale(ExecutionPolicy&& exec, Scalar alpha, InOutObj x);
1 [Note 1: These functions correspond to the BLAS functionxSCAL[17]. —end note]
2 Effects: Overwrites x with the result of computing the elementwise multiplicationαx, where the scalar
α is alpha.
29.9.13.5 Copy elements of one matrix or vector into another [linalg.algs.blas1.copy]
template<in-object InObj, out-object OutObj>
void copy(InObj x, OutObj y);
template<class ExecutionPolicy, in-object InObj, out-object OutObj>
void copy(ExecutionPolicy&& exec, InObj x, OutObj y);
1 [Note 1: These functions correspond to the BLAS functionxCOPY[17]. —end note]
2 Constraints: x.rank() equals y.rank().
3 Mandates: For allr in the range[0,x.rank()),
compatible-static-extents <InObj, OutObj>(r, r)
is true.
4 Preconditions: x.extents() equals y.extents().
5 Effects: Assigns each element ofx to the corresponding element ofy.
§ 29.9.13.5 © ISO/IEC
1846

===== PAGE 1858 =====

Dxxxx
29.9.13.6 Add vectors or matrices elementwise [linalg.algs.blas1.add]
template<in-object InObj1, in-object InObj2, out-object OutObj>
void add(InObj1 x, InObj2 y, OutObj z);
template<class ExecutionPolicy, in-object InObj1, in-object InObj2, out-object OutObj>
void add(ExecutionPolicy&& exec,
InObj1 x, InObj2 y, OutObj z);
1 [Note 1: These functions correspond to the BLAS functionxAXPY[17]. —end note]
2 Constraints: x.rank(), y.rank(), andz.rank() are all equal.
3 Mandates: possibly-addable <InObj1, InObj2, OutObj>() is true.
4 Preconditions: addable (x,y,z) is true.
5 Effects: Computes z= x+ y.
6 Remarks: z may aliasx or y.
29.9.13.7 Dot product of two vectors [linalg.algs.blas1.dot]
1 [Note 1: The functions in this section correspond to the BLAS functionsxDOT, xDOTU, andxDOTC[17]. —end note]
2 The following elements apply to all functions in 29.9.13.7.
3 Mandates: compatible-static-extents <InVec1, InVec2>(0, 0) is true.
4 Preconditions: v1.extent(0) equals v2.extent(0).
template<in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dot(InVec1 v1, InVec2 v2, Scalar init);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dot(ExecutionPolicy&& exec,
InVec1 v1, InVec2 v2, Scalar init);
5 These functions compute a non-conjugated dot product with an explicitly specified result type.
6 Returns: Let N be v1.extent(0).
—(6.1) init if N is zero;
—(6.2) otherwise, GENERALIZED_SUM(plus<>(), init, v1[0]*v2[0], ..., v1[N-1]*v2[N-1]).
7 Remarks: If InVec1::value_type, InVec2::value_type, and Scalar are all floating-point types
or specializations of complex, and if Scalar has higher precision than InVec1::value_type or
InVec2::value_type, then intermediate terms in the sum useScalar’s precision or greater.
template<in-vector InVec1, in-vector InVec2>
auto dot(InVec1 v1, InVec2 v2);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2>
auto dot(ExecutionPolicy&& exec,
InVec1 v1, InVec2 v2);
8 These functions compute a non-conjugated dot product with a default result type.
9 Effects: Let T be decltype(declval<typename InVec1::value_type>() * declval<typename In-
Vec2::value_type>()). Then,
—(9.1) the two-parameter overload is equivalent to:
return dot(v1, v2, T{});
and
—(9.2) the three-parameter overload is equivalent to:
return dot(std::forward<ExecutionPolicy>(exec), v1, v2, T{});
template<in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dotc(InVec1 v1, InVec2 v2, Scalar init);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, scalar Scalar>
Scalar dotc(ExecutionPolicy&& exec,
InVec1 v1, InVec2 v2, Scalar init);
10 These functions compute a conjugated dot product with an explicitly specified result type.
§ 29.9.13.7 © ISO/IEC
1847

===== PAGE 1859 =====

Dxxxx
11 Effects:
—(11.1) The three-parameter overload is equivalent to:
return dot(conjugated(v1), v2, init);
and
—(11.2) the four-parameter overload is equivalent to:
return dot(std::forward<ExecutionPolicy>(exec), conjugated(v1), v2, init);
template<in-vector InVec1, in-vector InVec2>
auto dotc(InVec1 v1, InVec2 v2);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2>
auto dotc(ExecutionPolicy&& exec,
InVec1 v1, InVec2 v2);
12 These functions compute a conjugated dot product with a default result type.
13 Effects: LetTbe decltype(conj-if-needed (declval<typename InVec1::value_type>()) * decl-
val<typename InVec2::value_type>()). Then,
—(13.1) the two-parameter overload is equivalent to:
return dotc(v1, v2, T{});
and
—(13.2) the three-parameter overload is equivalent to
return dotc(std::forward<ExecutionPolicy>(exec), v1, v2, T{});
29.9.13.8 Euclidean norm of a vector [linalg.algs.blas1.nrm2]
template<in-vector InVec, scalar Scalar>
Scalar vector_two_norm(InVec v, Scalar init);
template<class ExecutionPolicy, in-vector InVec, scalar Scalar>
Scalar vector_two_norm(ExecutionPolicy&& exec, InVec v, Scalar init);
1 [Note 1: These functions correspond to the BLAS functionxNRM2[17]. —end note]
2 Mandates: InVec::value_type and Scalar are either a floating-point type, or a specialization of
complex. Let a be abs-if-needed (declval<typename InVec::value_type>()). Then, decltype(
init + a * a is convertible toScalar.
3 Returns: The square root of the sum of the square ofinit and the squares of the absolute values of
the elements ofv.
[Note 2: Forinit equal to zero, this is the Euclidean norm (also called 2-norm) of the vectorv. —end note]
4 Remarks: If Scalar has higher precision thanInVec::value_type, then intermediate terms in the
sum useScalar’s precision or greater.
template<in-vector InVec>
auto vector_two_norm(InVec v);
template<class ExecutionPolicy, in-vector InVec>
auto vector_two_norm(ExecutionPolicy&& exec, InVec v);
5 Effects: Letabe abs-if-needed (declval<typename InVec::value_type>()). LetTbe decltype(a
* a). Then,
—(5.1) the one-parameter overload is equivalent to:
return vector_two_norm(v, T{});
and
—(5.2) the two-parameter overload is equivalent to:
return vector_two_norm(std::forward<ExecutionPolicy>(exec), v, T{});
29.9.13.9 Sum of absolute values of vector elements [linalg.algs.blas1.asum]
template<in-vector InVec, scalar Scalar>
Scalar vector_abs_sum(InVec v, Scalar init);
§ 29.9.13.9 © ISO/IEC
1848

===== PAGE 1860 =====

Dxxxx
template<class ExecutionPolicy, in-vector InVec, scalar Scalar>
Scalar vector_abs_sum(ExecutionPolicy&& exec, InVec v, Scalar init);
1 [Note 1: These functions correspond to the BLAS functionsSASUM, DASUM, SCASUM, andDZASUM[17]. —end note]
2 Mandates:
decltype(init + abs-if-needed (real-if-needed (declval<typename InVec::value_type>())) +
abs-if-needed (imag-if-needed (declval<typename InVec::value_type>())))
is convertible toScalar.
3 Returns: Let N be v.extent(0).
—(3.1) init if N is zero;
—(3.2) otherwise, ifInVec::value_type is an arithmetic type,
GENERALIZED_SUM(plus<>(), init, abs-if-needed (v[0]), ..., abs-if-needed (v[N-1]))
—(3.3) otherwise,
GENERALIZED_SUM(plus<>(), init,
abs-if-needed (real-if-needed (v[0])) + abs-if-needed (imag-if-needed (v[0])),
...,
abs-if-needed (real-if-needed (v[N-1])) + abs-if-needed (imag-if-needed (v[N-1])))
4 Remarks: If InVec::value_type and Scalar are all floating-point types or specializations ofcomplex,
and if Scalar has higher precision thanInVec::value_type, then intermediate terms in the sum use
Scalar’s precision or greater.
template<in-vector InVec>
auto vector_abs_sum(InVec v);
template<class ExecutionPolicy, in-vector InVec>
auto vector_abs_sum(ExecutionPolicy&& exec, InVec v);
5 Effects: Let T be typename InVec::value_type. Then,
—(5.1) the one-parameter overload is equivalent to:
return vector_abs_sum(v, T{});
and
—(5.2) the two-parameter overload is equivalent to:
return vector_abs_sum(std::forward<ExecutionPolicy>(exec), v, T{});
29.9.13.10 Index of maximum absolute value of vector elements [linalg.algs.blas1.iamax]
template<in-vector InVec>
typename InVec::extents_type vector_idx_abs_max(InVec v);
template<class ExecutionPolicy, in-vector InVec>
typename InVec::extents_type vector_idx_abs_max(ExecutionPolicy&& exec, InVec v);
1 [Note 1: These functions correspond to the BLAS functionIxAMAX[17]. —end note]
2 Let T be
decltype(abs-if-needed (real-if-needed (declval<typename InVec::value_type>())) +
abs-if-needed (imag-if-needed (declval<typename InVec::value_type>())))
3 Mandates: declval<T>() < declval<T>() is a valid expression.
4 Returns:
—(4.1) numeric_limits<typename InVec::size_type>::max() if v has zero elements;
—(4.2) otherwise, the index of the first element ofv having largest absolute value, ifInVec::value_type
is an arithmetic type;
—(4.3) otherwise, the index of the first elementve of v for which
abs-if-needed (real-if-needed (ve)) + abs-if-needed (imag-if-needed (ve))
has the largest value.
29.9.13.11 Frobenius norm of a matrix [linalg.algs.blas1.matfrobnorm]
§ 29.9.13.11 © ISO/IEC
1849

===== PAGE 1861 =====

Dxxxx
1 [Note 1: These functions exist in the BLAS standard[21] but are not part of the reference implementation.—end
note]
template<in-matrix InMat, scalar Scalar>
Scalar matrix_frob_norm(InMat A, Scalar init);
template<class ExecutionPolicy, in-matrix InMat, scalar Scalar>
Scalar matrix_frob_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
2 Mandates: InVec::value_type and Scalar are either a floating-point type, or a specialization of
complex. Let a be abs-if-needed (declval<typename InMat::value_type>()). Then, decltype(
init + a * a) is convertible toScalar.
3 Returns: The square root of the sum of squares ofinit and the absolute values of the elements ofA.
[Note 2: Forinit equal to zero, this is the Frobenius norm of the matrixA. —end note]
4 Remarks: If Scalar has higher precision thanInMat::value_type, then intermediate terms in the
sum useScalar’s precision or greater.
template<in-matrix InMat>
auto matrix_frob_norm(InMat A);
template<class ExecutionPolicy, in-matrix InMat>
auto matrix_frob_norm(ExecutionPolicy&& exec, InMat A);
5 Effects: Letabe abs-if-needed (declval<typename InMat::value_type>()). LetTbe decltype(a
* a). Then,
—(5.1) the one-parameter overload is equivalent to:
return matrix_frob_norm(A, T{});
and
—(5.2) the two-parameter overload is equivalent to:
return matrix_frob_norm(std::forward<ExecutionPolicy>(exec), A, T{});
29.9.13.12 One norm of a matrix [linalg.algs.blas1.matonenorm]
1 [Note 1: These functions exist in the BLAS standard[21] but are not part of the reference implementation.—end
note]
template<in-matrix InMat, scalar Scalar>
Scalar matrix_one_norm(InMat A, Scalar init);
template<class ExecutionPolicy, in-matrix InMat, scalar Scalar>
Scalar matrix_one_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
2 Mandates: decltype(abs-if-needed (declval<typename InMat::value_type>())) is convertible
to Scalar.
3 Returns:
—(3.1) init if A.extent(1) is zero;
—(3.2) otherwise, the sum ofinit and the one norm of the matrixA.
[Note 2: The one norm of the matrixA is the maximum over all columns ofA, of the sum of the absolute values
of the elements of the column.—end note]
4 Remarks: If InMat::value_type and Scalar are all floating-point types or specializations ofcomplex,
and if Scalar has higher precision thanInMat::value_type, then intermediate terms in the sum use
Scalar’s precision or greater.
template<in-matrix InMat>
auto matrix_one_norm(InMat A);
template<class ExecutionPolicy, in-matrix InMat>
auto matrix_one_norm(ExecutionPolicy&& exec, InMat A);
5 Effects: Let T be decltype(abs-if-needed (declval<typename InMat::value_type>()). Then,
—(5.1) the one-parameter overload is equivalent to:
return matrix_one_norm(A, T{});
and
§ 29.9.13.12 © ISO/IEC
1850

===== PAGE 1862 =====

Dxxxx
—(5.2) the two-parameter overload is equivalent to:
return matrix_one_norm(std::forward<ExecutionPolicy>(exec), A, T{});
29.9.13.13 Infinity norm of a matrix [linalg.algs.blas1.matinfnorm]
1 [Note 1: These functions exist in the BLAS standard[21] but are not part of the reference implementation.—end
note]
template<in-matrix InMat, scalar Scalar>
Scalar matrix_inf_norm(InMat A, Scalar init);
template<class ExecutionPolicy, in-matrix InMat, scalar Scalar>
Scalar matrix_inf_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
2 Mandates: decltype(abs-if-needed (declval<typename InMat::value_type>())) is convertible
to Scalar.
3 Returns:
—(3.1) init if A.extent(0) is zero;
—(3.2) otherwise, the sum ofinit and the infinity norm of the matrixA.
[Note 2: The infinity norm of the matrixA is the maximum over all rows ofA, of the sum of the absolute values
of the elements of the row.—end note]
4 Remarks: If InMat::value_type and Scalar are all floating-point types or specializations ofcomplex,
and if Scalar has higher precision thanInMat::value_type, then intermediate terms in the sum use
Scalar’s precision or greater.
template<in-matrix InMat>
auto matrix_inf_norm(InMat A);
template<class ExecutionPolicy, in-matrix InMat>
auto matrix_inf_norm(ExecutionPolicy&& exec, InMat A);
5 Effects: Let T be decltype(abs-if-needed (declval<typename InMat::value_type>()). Then,
—(5.1) the one-parameter overload is equivalent to:
return matrix_inf_norm(A, T{});
and
—(5.2) the two-parameter overload is equivalent to:
return matrix_inf_norm(std::forward<ExecutionPolicy>(exec), A, T{});
29.9.14 BLAS 2 algorithms [linalg.algs.blas2]
29.9.14.1 General matrix-vector product [linalg.algs.blas2.gemv]
1 [Note 1: These functions correspond to the BLAS functionxGEMV. —end note]
2 The following elements apply to all functions in 29.9.14.1.
3 Mandates:
—(3.1) possibly-multipliable <decltype(A), decltype(x), decltype(y)>() is true, and
—(3.2) possibly-addable <decltype(y), decltype(y), decltype(z)>() is true for those overloads that
take az parameter.
4 Preconditions:
—(4.1) multipliable (A,x,y) is true, and
—(4.2) addable (y,y,z) is true for those overloads that take az parameter.
5 Complexity: O(A.extent(0)×x.extent(0)).
template<in-matrix InMat, in-vector InVec, out-vector OutVec>
void matrix_vector_product(InMat A, InVec x, OutVec y);
template<class ExecutionPolicy, in-matrix InMat, in-vector InVec, out-vector OutVec>
void matrix_vector_product(ExecutionPolicy&& exec, InMat A, InVec x, OutVec y);
6 These functions perform an overwriting matrix-vector product.
7 Effects: Computes y= Ax.
§ 29.9.14.1 © ISO/IEC
1851

===== PAGE 1863 =====

Dxxxx
[Example 1:
constexpr size_t num_rows = 5;
constexpr size_t num_cols = 6;
// y = 3.0 * A * x
void scaled_matvec_1(mdspan<double, extents<size_t, num_rows, num_cols>> A,
mdspan<double, extents<size_t, num_cols>> x, mdspan<double, extents<size_t, num_rows>> y) {
matrix_vector_product(scaled(3.0, A), x, y);
}
// z = 7.0 times the transpose of A, times y
void scaled_transposed_matvec(mdspan<double, extents<size_t, num_rows, num_cols>> A,
mdspan<double, extents<size_t, num_rows>> y, mdspan<double, extents<size_t, num_cols>> z) {
matrix_vector_product(scaled(7.0, transposed(A)), y, z);
}
—end example]
template<in-matrix InMat, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void matrix_vector_product(InMat A, InVec1 x, InVec2 y, OutVec z);
template<class ExecutionPolicy,
in-matrix InMat, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void matrix_vector_product(ExecutionPolicy&& exec,
InMat A, InVec1 x, InVec2 y, OutVec z);
8 These functions perform an updating matrix-vector product.
9 Effects: Computes z= y+ Ax.
10 Remarks: z may aliasy.
[Example 2:
// y = 3.0 * A * x + 2.0 * y
void scaled_matvec_2(mdspan<double, extents<size_t, num_rows, num_cols>> A,
mdspan<double, extents<size_t, num_cols>> x, mdspan<double, extents<size_t, num_rows>> y) {
matrix_vector_product(scaled(3.0, A), x, scaled(2.0, y), y);
}
—end example]
29.9.14.2 Symmetric matrix-vector product [linalg.algs.blas2.symv]
1 [Note 1: These functions correspond to the BLAS functionsxSYMV and xSPMV[18]. —end note]
2 The following elements apply to all functions in 29.9.14.2.
3 Mandates:
—(3.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the same
type as the function’sTriangle template argument;
—(3.2) compatible-static-extents <decltype(A), decltype(A)>(0, 1) is true;
—(3.3) possibly-multipliable <decltype(A), decltype(x), decltype(y)>() is true; and
—(3.4) possibly-addable <decltype(y), decltype(y), decltype(z)>() is true for those overloads that
take az parameter.
4 Preconditions:
—(4.1) A.extent(0) equals A.extent(1),
—(4.2) multipliable (A,x,y) is true, and
—(4.3) addable (y,y,z) is true for those overloads that take az parameter.
5 Complexity: O(A.extent(0)×x.extent(0)).
template<in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void symmetric_matrix_vector_product(InMat A, Triangle t, InVec x, OutVec y);
§ 29.9.14.2 © ISO/IEC
1852

===== PAGE 1864 =====

Dxxxx
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void symmetric_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec x, OutVec y);
6 These functions perform an overwriting symmetric matrix-vector product, taking into account the
Triangle parameter that applies to the symmetric matrixA (29.9.3).
7 Effects: Computes y= Ax.
template<in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void symmetric_matrix_vector_product(InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void symmetric_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
8 These functions perform an updating symmetric matrix-vector product, taking into account the
Triangle parameter that applies to the symmetric matrixA (29.9.3).
9 Effects: Computes z= y+ Ax.
10 Remarks: z may aliasy.
29.9.14.3 Hermitian matrix-vector product [linalg.algs.blas2.hemv]
1 [Note 1: These functions correspond to the BLAS functionsxHEMV and xHPMV[18]. —end note]
2 The following elements apply to all functions in 29.9.14.3.
3 Mandates:
—(3.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the same
type as the function’sTriangle template argument;
—(3.2) compatible-static-extents <decltype(A), decltype(A)>(0, 1) is true;
—(3.3) possibly-multipliable <decltype(A), decltype(x), decltype(y)>() is true; and
—(3.4) possibly-addable <decltype(y), decltype(y), decltype(z)>() is true for those overloads that
take az parameter.
4 Preconditions:
—(4.1) A.extent(0) equals A.extent(1),
—(4.2) multipliable (A, x, y) is true, and
—(4.3) addable (y, y, z) is true for those overloads that take az parameter.
5 Complexity: O(A.extent(0)×x.extent(0)).
template<in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void hermitian_matrix_vector_product(InMat A, Triangle t, InVec x, OutVec y);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec, out-vector OutVec>
void hermitian_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec x, OutVec y);
6 These functions perform an overwriting Hermitian matrix-vector product, taking into account the
Triangle parameter that applies to the Hermitian matrixA (29.9.3).
7 Effects: Computes y= Ax.
template<in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void hermitian_matrix_vector_product(InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, in-vector InVec1, in-vector InVec2, out-vector OutVec>
void hermitian_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
8 ThesefunctionsperformanupdatingHermitianmatrix-vectorproduct, takingintoaccountthe Triangle
parameter that applies to the Hermitian matrixA (29.9.3).
9 Effects: Computes z= y+ Ax.
§ 29.9.14.3 © ISO/IEC
1853

===== PAGE 1865 =====

Dxxxx
10 Remarks: z may aliasy.
29.9.14.4 Triangular matrix-vector product [linalg.algs.blas2.trmv]
1 [Note 1: These functions correspond to the BLAS functionsxTRMV and xTPMV[18]. —end note]
2 The following elements apply to all functions in 29.9.14.4.
3 Mandates:
—(3.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the same
type as the function’sTriangle template argument;
—(3.2) compatible-static-extents <decltype(A), decltype(A)>(0, 1) is true;
—(3.3) compatible-static-extents <decltype(A), decltype(y)>(0, 0) is true;
—(3.4) compatible-static-extents <decltype(A), decltype(x)>(0, 0) is true for those overloads that
take anx parameter; and
—(3.5) compatible-static-extents <decltype(A), decltype(z)>(0, 0) is true for those overloads that
take az parameter.
4 Preconditions:
—(4.1) A.extent(0) equals A.extent(1),
—(4.2) A.extent(0) equals y.extent(0),
—(4.3) A.extent(0) equals x.extent(0) for those overloads that take anx parameter, and
—(4.4) A.extent(0) equals z.extent(0) for those overloads that take az parameter.
template<in-matrix InMat, class Triangle, class DiagonalStorage, in-vector InVec,
out-vector OutVec>
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d, InVec x, OutVec y);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, in-vector InVec,
out-vector OutVec>
void triangular_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InVec x, OutVec y);
5 These functions perform an overwriting triangular matrix-vector product, taking into account the
Triangle and DiagonalStorage parameters that apply to the triangular matrixA (29.9.3).
6 Effects: Computes y= Ax.
7 Complexity: O(A.extent(0)×x.extent(0)).
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d, InOutVec y);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutVec y);
8 These functions perform an in-place triangular matrix-vector product, taking into account theTriangle
and DiagonalStorage parameters that apply to the triangular matrixA (29.9.3).
[Note 2: Performing this operation in place hinders parallelization. However, otherExecutionPolicy specific
optimizations, such as vectorization, are still possible.—end note]
9 Effects: Computes a vectory′such thaty′= Ay, and assigns each element ofy′to the corresponding
element ofy.
10 Complexity: O(A.extent(0)×y.extent(0)).
template<in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec1, in-vector InVec2, out-vector OutVec>
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d,
InVec1 x, InVec2 y, OutVec z);
§ 29.9.14.4 © ISO/IEC
1854

===== PAGE 1866 =====

Dxxxx
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec1, in-vector InVec2, out-vector OutVec>
void triangular_matrix_vector_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InVec1 x, InVec2 y, OutVec z);
11 These functions perform an updating triangular matrix-vector product, taking into account theTriangle
and DiagonalStorage parameters that apply to the triangular matrixA (29.9.3).
12 Effects: Computes z= y+ Ax.
13 Complexity: O(A.extent(0)×x.extent(0)).
14 Remarks: z may aliasy.
29.9.14.5 Solve a triangular linear system [linalg.algs.blas2.trsv]
1 [Note 1: These functions correspond to the BLAS functionsxTRSV and xTPSV[18]. —end note]
2 The following elements apply to all functions in 29.9.14.5.
3 Mandates:
—(3.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the same
type as the function’sTriangle template argument;
—(3.2) compatible-static-extents <decltype(A), decltype(A)>(0, 1) is true;
—(3.3) compatible-static-extents <decltype(A), decltype(b)>(0, 0) is true; and
—(3.4) compatible-static-extents <decltype(A), decltype(x)>(0, 0) is true for those overloads that
take anx parameter.
4 Preconditions:
—(4.1) A.extent(0) equals A.extent(1),
—(4.2) A.extent(0) equals b.extent(0), and
—(4.3) A.extent(0) equals x.extent(0) for those overloads that take anx parameter.
template<in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
InVec b, OutVec x, BinaryDivideOp divide);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InVec b, OutVec x, BinaryDivideOp divide);
5 These functions perform a triangular solve, taking into account theTriangle and DiagonalStorage
parameters that apply to the triangular matrixA (29.9.3).
6 Effects: Computes a vectorx′such thatb= Ax′, and assigns each element ofx′to the corresponding
element ofx. If no suchx′exists, then the elements ofx are valid but unspecified.
7 Complexity: O(A.extent(1)×b.extent(0)).
template<in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d, InVec b, OutVec x);
8 Effects: Equivalent to:
triangular_matrix_vector_solve(A, t, d, b, x, divides<void>{});
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
in-vector InVec, out-vector OutVec>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InVec b, OutVec x);
9 Effects: Equivalent to:
triangular_matrix_vector_solve(std::forward<ExecutionPolicy>(exec),
A, t, d, b, x, divides<void>{});
§ 29.9.14.5 © ISO/IEC
1855

===== PAGE 1867 =====

Dxxxx
template<in-matrix InMat, class Triangle, class DiagonalStorage,
inout-vector InOutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
InOutVec b, BinaryDivideOp divide);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
inout-vector InOutVec, class BinaryDivideOp>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutVec b, BinaryDivideOp divide);
10 These functions perform an in-place triangular solve, taking into account theTriangle and Diagonal-
Storage parameters that apply to the triangular matrixA (29.9.3).
[Note 2: Performing triangular solve in place hinders parallelization. However, otherExecutionPolicy specific
optimizations, such as vectorization, are still possible.—end note]
11 Effects: Computes a vectorx′such thatb= Ax′, and assigns each element ofx′to the corresponding
element ofb. If no suchx′exists, then the elements ofb are valid but unspecified.
12 Complexity: O(A.extent(1)×b.extent(0)).
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d, InOutVec b);
13 Effects: Equivalent to:
triangular_matrix_vector_solve(A, t, d, b, divides<void>{});
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-vector InOutVec>
void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutVec b);
14 Effects: Equivalent to:
triangular_matrix_vector_solve(std::forward<ExecutionPolicy>(exec),
A, t, d, b, divides<void>{});
29.9.14.6 Rank-1 (outer product) update of a matrix [linalg.algs.blas2.rank1]
1 The following elements apply to all functions in 29.9.14.6.
2 Mandates:
—(2.1) possibly-multipliable <OutMat, InVec2, InVec1>() is true, and
—(2.2) possibly-addable <OutMat, InMat, OutMat>() is true for those overloads with anE parameter.
3 Preconditions:
—(3.1) multipliable (A, y, x) is true, and
—(3.2) addable (A, E, A) is true for those overloads with anE parameter.
4 Complexity: O(x.extent(0)×y.extent(0)).
template<in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update(InVec1 x, InVec2 y, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update(ExecutionPolicy&& exec, InVec1 x, InVec2 y, OutMat A);
5 These functions perform an overwriting nonsymmetric nonconjugated rank-1 update.
[Note 1: These functions correspond to the BLAS functionsxGER (for real element types) andxGERU (for
complex element types)[18]. —end note]
6 Effects: Computes A= xyT.
template<in-vector InVec1, in-vector InVec2, in-matrix InMat, out-matrix OutMat>
void matrix_rank_1_update(InVec1 x, InVec2 y, InMat E, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, in-matrix InMat,
out-matrix OutMat>
void matrix_rank_1_update(ExecutionPolicy&& exec, InVec1 x, InVec2 y, InMat E, OutMat A);
7 These functions perform an updating nonsymmetric nonconjugated rank-1 update.
§ 29.9.14.6 © ISO/IEC
1856

===== PAGE 1868 =====

Dxxxx
[Note 2: These functions correspond to the BLAS functionsxGER (for real element types) andxGERU (for
complex element types)[18]. —end note]
8 Effects: Computes A= E+ xyT.
9 Remarks: A may aliasE.
template<in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update_c(InVec1 x, InVec2 y, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, out-matrix OutMat>
void matrix_rank_1_update_c(ExecutionPolicy&& exec, InVec1 x, InVec2 y, OutMat A);
10 These functions perform an overwriting nonsymmetric conjugated rank-1 update.
[Note 3: These functions correspond to the BLAS functionsxGER (for real element types) andxGERC (for
complex element types)[18]. —end note]
11 Effects:
—(11.1) For the overloads without anExecutionPolicy argument, equivalent to:
matrix_rank_1_update(x, conjugated(y), A);
—(11.2) otherwise, equivalent to:
matrix_rank_1_update(std::forward<ExecutionPolicy>(exec), x, conjugated(y), A);
template<in-vector InVec1, in-vector InVec2, in-matrix InMat, out-matrix OutMat>
void matrix_rank_1_update_c(InVec1 x, InVec2 y, InMat E, OutMat A);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, in-matrix InMat,
out-matrix OutMat>
void matrix_rank_1_update_c(ExecutionPolicy&& exec, InVec1 x, InVec2 y, InMat E, OutMat A);
12 These functions perform an updating nonsymmetric conjugated rank-1 update.
[Note 4: These functions correspond to the BLAS functionsxGER (for real element types) andxGERC (for
complex element types)[18]. —end note]
13 Effects:
—(13.1) For the overloads without anExecutionPolicy argument, equivalent to:
matrix_rank_1_update(x, conjugated(y), A);
—(13.2) otherwise, equivalent to:
matrix_rank_1_update(std::forward<ExecutionPolicy>(exec), x, conjugated(y), E, A);
29.9.14.7 Symmetric or Hermitian Rank-1 (outer product) update of a matrix
[linalg.algs.blas2.symherrank1]
1 [Note 1: These functions correspond to the BLAS functionsxSYR, xSPR, xHER, andxHPR[18]. They have overloads
taking a scaling factoralpha, because it would be impossible to express the updateA = A−xxT in noncomplex
arithmetic otherwise. —end note]
2 The following elements apply to all functions in 29.9.14.7.
3 For any functionF in this subclause with a parameter namedt, anInMat template parameter, and a function
parameter InMat E, t applies to accesses done through the parameterE. F only accesses the triangle ofE
specified byt. For accesses of diagonal elementsE[i, i], F only uses the valuereal-if-needed (E[i, i])
if the name ofF starts withhermitian. For accessesE[i, j] outside the triangle specified byt, F only uses
the value
—(3.1) conj-if-needed (E[j, i]) if the name of F starts withhermitian, or
—(3.2) E[j, i] if the name ofF starts withsymmetric.
4 Mandates:
—(4.1) If OutMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(4.2) compatible-static-extents <decltype(A), decltype(A)>(0, 1) is true;
—(4.3) compatible-static-extents <decltype(A), decltype(x)>(0, 0) is true; and
—(4.4) possibly-addable <decltype(A), decltype(E), decltype(A)>() is true for those overloads with
an E parameter.
§ 29.9.14.7 © ISO/IEC
1857

===== PAGE 1869 =====

Dxxxx
5 Preconditions:
—(5.1) A.extent(0) equals A.extent(1),
—(5.2) A.extent(0) equals x.extent(0), and
—(5.3) addable (A, E, A) is true for those overloads with anE parameter.
6 Complexity: O(x.extent(0)×x.extent(0)).
template<scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_1_update(Scalar alpha, InVec x, OutMat A, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_1_update(ExecutionPolicy&& exec,
Scalar alpha, InVec x, OutMat A, Triangle t);
7 These functions perform an overwriting symmetric rank-1 update of the symmetric matrixA, taking
into account theTriangle parameter that applies toA (29.9.3).
8 Effects: Computes a matrixA= αxxT, where the scalarα is alpha.
template<scalar Scalar, in-vector InVec, in-matrix InMat, possibly-packed-out-matrix OutMat,
class Triangle>
void symmetric_matrix_rank_1_update(Scalar alpha, InVec x, InMat E, OutMat A, Triangle t);
template<class ExecutionPolicy, scalar Scalar, in-vector InVec, in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_1_update(ExecutionPolicy&& exec,
Scalar alpha, InVec x, InMat E, OutMat A, Triangle t);
9 These functions perform an updating symmetric rank-1 update of the symmetric matrixA using the
symmetric matrixE, taking into account theTriangle parameter that applies toA and E (29.9.3).
10 Effects: Computes A= E+ αxxT, where the scalarα is alpha.
11 Remarks: A may aliasE.
template<scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_1_update(Scalar alpha, InVec x, OutMat A, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, in-vector InVec, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_1_update(ExecutionPolicy&& exec,
Scalar alpha, InVec x, OutMat A, Triangle t);
12 These functions perform an overwriting Hermitian rank-1 update of the Hermitian matrixA, taking
into account theTriangle parameter that applies toA (29.9.3).
13 Effects: Computes A= αxxH, where the scalarα is real-if-needed (alpha).
template<scalar Scalar, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_1_update(InVec x, OutMat A, Triangle t);
template<class ExecutionPolicy,
scalar Scalar, possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_1_update(ExecutionPolicy&& exec, InVec x, OutMat A, Triangle t);
14 These functions perform an updating Hermitian rank-1 update of the Hermitian matrixA using the
Hermitian matrixE, taking into account theTriangle parameter that applies toA and E (29.9.3).
15 Effects: Computes A= E+ αxxH, where the scalarα is real-if-needed (alpha).
16 Remarks: A may aliasE.
29.9.14.8 Symmetric and Hermitian rank-2 matrix updates [linalg.algs.blas2.rank2]
1 [Note 1: These functions correspond to the BLAS functionsxSYR2,xSPR2, xHER2 and xHPR2[18]. —end note]
2 The following elements apply to all functions in 29.9.14.8.
3 For any functionF in this subclause with a parameter namedt, anInMat template parameter, and a function
parameter InMat E, t applies to accesses done through the parameterE. F only accesses the triangle ofE
specified byt. For accesses of diagonal elementsE[i, i], F only uses the valuereal-if-needed (E[i, i])
if the name ofF starts withhermitian. For accessesE[i, j] outside the triangle specified byt, F only uses
the value
§ 29.9.14.8 © ISO/IEC
1858

===== PAGE 1870 =====

Dxxxx
—(3.1) conj-if-needed (E[j, i]) if the name of F starts withhermitian, or
—(3.2) E[j, i] if the name of F starts withsymmetric.
4 Mandates:
—(4.1) If OutMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(4.2) If the function has anInMat template parameter andInMat has layout_blas_packed layout, then the
layout’sTriangle template argument has the same type as the function’sTriangle template argument;
—(4.3) compatible-static-extents <decltype(A), decltype(A)>(0, 1) is true;
—(4.4) possibly-multipliable <decltype(A), decltype(x), decltype(y)>() is true; and
—(4.5) possibly-addable <decltype(A), decltype(E), decltype(A)>() is true for those overloads with
an E parameter.
5 Preconditions:
—(5.1) A.extent(0) equals A.extent(1),
—(5.2) multipliable (A, x, y) is true, and
—(5.3) addable (A, E, A) is true for those overloads with anE parameter.
6 Complexity: O(x.extent(0)×y.extent(0)).
template<in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(InVec1 x, InVec2 y, OutMat A, Triangle t);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, OutMat A, Triangle t);
7 These functions perform an overwriting symmetric rank-2 update of the symmetric matrixA, taking
into account theTriangle parameter that applies toA (29.9.3).
8 Effects: Computes A= xyT + yxT.
template<in-vector InVec1, in-vector InVec2, in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
9 These functions perform an updating symmetric rank-2 update of the symmetric matrixA using the
symmetric matrixE, taking into account theTriangle parameter that applies toA and E (29.9.3).
10 Effects: Computes A= E+ xyT + yxT.
11 Remarks: A may aliasE.
template<in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(InVec1 x, InVec2 y, OutMat A, Triangle t);
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, OutMat A, Triangle t);
12 These functions perform an overwriting Hermitian rank-2 update of the Hermitian matrixA, taking
into account theTriangle parameter that applies toA (29.9.3).
13 Effects: Computes A= xyH + yxH.
template<in-vector InVec1, in-vector InVec2, in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
§ 29.9.14.8 © ISO/IEC
1859

===== PAGE 1871 =====

Dxxxx
template<class ExecutionPolicy, in-vector InVec1, in-vector InVec2, in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2_update(ExecutionPolicy&& exec,
InVec1 x, InVec2 y, InMat E, OutMat A, Triangle t);
14 These functions perform an updating Hermitian rank-2 update of the Hermitian matrixA using the
Hermitian matrixE, taking into account theTriangle parameter that applies toA and E (29.9.3).
15 Effects: Computes A= E+ xyH + yxH.
16 Remarks: A may aliasE.
29.9.15 BLAS 3 algorithms [linalg.algs.blas3]
29.9.15.1 General matrix-matrix product [linalg.algs.blas3.gemm]
1 [Note 1: These functions correspond to the BLAS functionxGEMM[19]. —end note]
2 The following elements apply to all functions in 29.9.15.1 in addition to function-specific elements.
3 Mandates: possibly-multipliable <decltype(A), decltype(B), decltype(C)>() is true.
4 Preconditions: multipliable (A, B, C) is true.
5 Complexity: O(A.extent(0)×A.extent(1)×B.extent(1)).
template<in-matrix InMat1, in-matrix InMat2, out-matrix OutMat>
void matrix_product(InMat1 A, InMat2 B, OutMat C);
template<class ExecutionPolicy, in-matrix InMat1, in-matrix InMat2, out-matrix OutMat>
void matrix_product(ExecutionPolicy&& exec, InMat1 A, InMat2 B, OutMat C);
6 Effects: Computes C = AB.
template<in-matrix InMat1, in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void matrix_product(InMat1 A, InMat2 B, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void matrix_product(ExecutionPolicy&& exec, InMat1 A, InMat2 B, InMat3 E, OutMat C);
7 Mandates: possibly-addable <InMat3, InMat3, OutMat>() is true.
8 Preconditions: addable (E, E, C) is true.
9 Effects: Computes C = E+ AB.
10 Remarks: C may aliasE.
29.9.15.2 Symmetric, Hermitian, and triangular matrix-matrix product
[linalg.algs.blas3.xxmm]
1 [Note 1: These functions correspond to the BLAS functionsxSYMM, xHEMM, andxTRMM[19]. —end note]
2 The following elements apply to all functions in 29.9.15.2 in addition to function-specific elements.
3 Mandates:
—(3.1) possibly-multipliable <decltype(A), decltype(B), decltype(C)>() is true, and
—(3.2) possibly-addable <decltype(E), decltype(E), decltype(C)>() is true for those overloads that
take anE parameter.
4 Preconditions:
—(4.1) multipliable (A, B, C) is true, and
—(4.2) addable (E, E, C) is true for those overloads that take anE parameter.
5 Complexity: O(A.extent(0)×A.extent(1)×B.extent(1)).
template<in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, Triangle t, InMat2 B, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec, InMat1 A, Triangle t, InMat2 B, OutMat C);
template<in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, Triangle t, InMat2 B, OutMat C);
§ 29.9.15.2 © ISO/IEC
1860

===== PAGE 1872 =====

Dxxxx
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec, InMat1 A, Triangle t, InMat2 B, OutMat C);
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, OutMat C);
template<class ExecutionPolicy, in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, OutMat C);
6 These functions perform a matrix-matrix multiply, taking into account theTriangle and Diagonal-
Storage (if applicable) parameters that apply to the symmetric, Hermitian, or triangular (respectively)
matrix A (29.9.3).
7 Mandates:
—(7.1) If InMat1 has layout_blas_packed layout, then the layout’sTriangle template argument has
the same type as the function’sTriangle template argument; and
—(7.2) compatible-static-extents <InMat1, InMat1>(0, 1) is true.
8 Preconditions: A.extent(0) == A.extent(1) is true.
9 Effects: Computes C = AB.
template<in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, InMat2 B, Triangle t, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, InMat2 B, Triangle t, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
out-matrix OutMat>
void triangular_matrix_product(InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, OutMat C);
10 These functions perform a matrix-matrix multiply, taking into account theTriangle and Diagonal-
Storage (if applicable) parameters that apply to the symmetric, Hermitian, or triangular (respectively)
matrix B (29.9.3).
11 Mandates:
—(11.1) If InMat2 has layout_blas_packed layout, then the layout’sTriangle template argument has
the same type as the function’sTriangle template argument; and
—(11.2) compatible-static-extents <InMat2, InMat2>(0, 1) is true.
12 Preconditions: B.extent(0) == B.extent(1) is true.
13 Effects: Computes C = AB.
template<in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
§ 29.9.15.2 © ISO/IEC
1861

===== PAGE 1873 =====

Dxxxx
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
template<in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, in-matrix InMat2, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, InMat3 E,
OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, InMat3 E,
OutMat C);
14 These functions perform a potentially overwriting matrix-matrix multiply-add, taking into account the
Triangle and DiagonalStorage (if applicable) parameters that apply to the symmetric, Hermitian, or
triangular (respectively) matrixA (29.9.3).
15 Mandates:
—(15.1) If InMat1 has layout_blas_packed layout, then the layout’sTriangle template argument has
the same type as the function’sTriangle template argument; and
—(15.2) compatible-static-extents <InMat1, InMat1>(0, 1) is true.
16 Preconditions: A.extent(0) == A.extent(1) is true.
17 Effects: Computes C = E+ AB.
18 Remarks: C may aliasE.
template<in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void symmetric_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, in-matrix InMat3,
out-matrix OutMat>
void hermitian_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
template<in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, InMat3 E,
OutMat C);
§ 29.9.15.2 © ISO/IEC
1862

===== PAGE 1874 =====

Dxxxx
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2, class Triangle, class DiagonalStorage,
in-matrix InMat3, out-matrix OutMat>
void triangular_matrix_product(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, InMat3 E,
OutMat C);
19 These functions perform a potentially overwriting matrix-matrix multiply-add, taking into account the
Triangle and DiagonalStorage (if applicable) parameters that apply to the symmetric, Hermitian, or
triangular (respectively) matrixB (29.9.3).
20 Mandates:
—(20.1) If InMat2 has layout_blas_packed layout, then the layout’sTriangle template argument has
the same type as the function’sTriangle template argument; and
—(20.2) compatible-static-extents <InMat2, InMat2>(0, 1) is true.
21 Preconditions: B.extent(0) == B.extent(1) is true.
22 Effects: Computes C = E+ AB.
23 Remarks: C may aliasE.
29.9.15.3 In-place triangular matrix-matrix product [linalg.algs.blas3.trmm]
1 These functions perform an in-place matrix-matrix multiply, taking into account theTriangle and Diagonal-
Storage parameters that apply to the triangular matrixA (29.9.3).
[Note 1: These functions correspond to the BLAS functionxTRMM[19]. —end note]
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_left_product(InMat A, Triangle t, DiagonalStorage d, InOutMat C);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_left_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutMat C);
2 Mandates:
—(2.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(2.2) possibly-multipliable <InMat, InOutMat, InOutMat>() is true; and
—(2.3) compatible-static-extents <InMat, InMat>(0, 1) is true.
3 Preconditions:
—(3.1) multipliable (A, C, C) is true, and
—(3.2) A.extent(0) == A.extent(1) is true.
4 Effects: Computes a matrixC′such thatC′= AC and assigns each element ofC′to the corresponding
element ofC.
5 Complexity: O(A.extent(0)×A.extent(1)×C.extent(0)).
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_right_product(InMat A, Triangle t, DiagonalStorage d, InOutMat C);
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_right_product(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d, InOutMat C);
6 Mandates:
—(6.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(6.2) possibly-multipliable <InOutMat, InMat, InOutMat>() is true; and
—(6.3) compatible-static-extents <InMat, InMat>(0, 1) is true.
§ 29.9.15.3 © ISO/IEC
1863

===== PAGE 1875 =====

Dxxxx
7 Preconditions:
—(7.1) multipliable (C, A, C) is true, and
—(7.2) A.extent(0) == A.extent(1) is true.
8 Effects: Computes a matrixC′such thatC′= CA and assigns each element ofC′to the corresponding
element ofC.
9 Complexity: O(A.extent(0)×A.extent(1)×C.extent(0)).
29.9.15.4 Rank-k update of a symmetric or Hermitian matrix [linalg.algs.blas3.rankk]
1 [Note 1: These functions correspond to the BLAS functionsxSYRK and xHERK[19]. —end note]
2 The following elements apply to all functions in 29.9.15.4.
3 For any functionF in this subclause with a parameter namedt, anInMat2 template parameter, and a function
parameter InMat2 E, t applies to accesses done through the parameterE. F only accesses the triangle ofE
specified byt. For accesses of diagonal elementsE[i, i], F only uses the valuereal-if-needed (E[i, i])
if the name ofF starts withhermitian. For accessesE[i, j] outside the triangle specified byt, F only uses
the value
—(3.1) conj-if-needed (E[j, i]) if the name ofF starts withhermitian, or
—(3.2) E[j, i] if the name ofF starts withsymmetric.
4 Mandates:
—(4.1) If OutMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(4.2) If the function has anInMat2 template parameter and ifInMat2 has layout_blas_packed layout,
then the layout’sTriangle template argument has the same type as the function’sTriangle template
argument;
—(4.3) possibly-multipliable <decltype(A), decltype(transposed(A)), decltype(C)>()is true; and
—(4.4) possibly-addable <decltype(C), decltype(E), decltype(C)>() is true for those overloads with
an E parameter.
5 Preconditions:
—(5.1) multipliable (A, transposed(A), C) is true; and
[Note 2: This implies thatC is square. —end note]
—(5.2) addable (C, E, C) is true for those overloads with anE parameter.
6 Complexity: O(A.extent(0)×A.extent(1)×A.extent(0)).
7 Remarks: C may aliasE for those overloads with anE parameter.
template<scalar Scalar, in-matrix InMat, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_k_update(Scalar alpha, InMat A, OutMat C, Triangle t);
template<class ExecutionPolicy, scalar Scalar,
in-matrix InMat, possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_k_update(ExecutionPolicy&& exec,
Scalar alpha, InMat A, OutMat C, Triangle t);
8 Effects: Computes C = αAAT, where the scalarα is alpha.
template<scalar Scalar, in-matrix InMat, possibly-packed-out-matrix OutMat,
class Triangle>
void hermitian_matrix_rank_k_update(Scalar alpha, InMat A, OutMat C, Triangle t);
template<class ExecutionPolicy, scalar Scalar, in-matrix InMat,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_k_update(ExecutionPolicy&& exec, Scalar alpha, InMat A,
OutMat C, Triangle t);
9 Effects: Computes C = αAAH, where the scalarα is real-if-needed (alpha).
template<scalar Scalar, in-matrix InMat1, in-matrix InMat2, possibly-packed-out-matrix OutMat,
class Triangle>
void symmetric_matrix_rank_k_update(Scalar alpha, InMat1 A, InMat2 E, OutMat C, Triangle t);
§ 29.9.15.4 © ISO/IEC
1864

===== PAGE 1876 =====

Dxxxx
template<class ExecutionPolicy, scalar Scalar, in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_k_update(ExecutionPolicy&& exec, Scalar alpha, InMat1 A, InMat2 E,
OutMat C, Triangle t);
10 Effects: Computes C = E+ αAAT, where the scalarα is alpha.
template<scalar Scalar, in-matrix InMat1, in-matrix InMat2, possibly-packed-out-matrix OutMat,
class Triangle>
void hermitian_matrix_rank_k_update(Scalar alpha, InMat1 A, InMat2 E, OutMat C, Triangle t);
template<class ExecutionPolicy, scalar Scalar, in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_k_update(ExecutionPolicy&& exec, Scalar alpha, InMat1 A, InMat2 E,
OutMat C, Triangle t);
11 Effects: Computes C = E+ αAAH, where the scalarα is real-if-needed (alpha).
29.9.15.5 Rank-2k update of a symmetric or Hermitian matrix [linalg.algs.blas3.rank2k]
1 [Note 1: These functions correspond to the BLAS functionsxSYR2K and xHER2K[19]. —end note]
2 The following elements apply to all functions in 29.9.15.5.
3 For any functionF in this subclause with a parameter namedt, anInMat3 template parameter, and a function
parameter InMat3 E, t applies to accesses done through the parameterE. F only accesses the triangle ofE
specified byt. For accesses of diagonal elementsE[i, i], F only uses the valuereal-if-needed (E[i, i])
if the name ofF starts withhermitian. For accessesE[i, j] outside the triangle specified byt, F only uses
the value
—(3.1) conj-if-needed (E[j, i]) if the name ofF starts withhermitian, or
—(3.2) E[j, i] if the name ofF starts withsymmetric.
4 Mandates:
—(4.1) If OutMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(4.2) If the function has anInMat3 template parameter and ifInMat3 has layout_blas_packed layout,
then the layout’sTriangle template argument has the same type as the function’sTriangle template
argument;
—(4.3) possibly-multipliable <decltype(A), decltype(transposed(B)), decltype(C)>() is true;
—(4.4) possibly-multipliable <decltype(B), decltype(transposed(A)), decltype(C)>()is true; and
—(4.5) possibly-addable <decltype(C), decltype(E), decltype(C)>() is true for those overloads with
an E parameter.
5 Preconditions:
—(5.1) multipliable (A, transposed(B), C) is true,
—(5.2) multipliable(B, transposed(A), C) is true, and
[Note 2: This and the previous imply thatC is square. —end note]
—(5.3) addable (C, E, C) is true for those overloads with anE parameter.
6 Complexity: O(A.extent(0)×A.extent(1)×B.extent(0)).
7 Remarks: C may aliasE for those overloads with anE parameter.
template<in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(InMat1 A, InMat2 B, OutMat C, Triangle t);
template<class ExecutionPolicy, in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, OutMat C, Triangle t);
8 Effects: Computes C = ABT + BAT.
§ 29.9.15.5 © ISO/IEC
1865

===== PAGE 1877 =====

Dxxxx
template<in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2k_update(InMat1 A, InMat2 B, OutMat C, Triangle t);
template<class ExecutionPolicy,
in-matrix InMat1, in-matrix InMat2,
possibly-packed-out-matrix OutMat, class Triangle>
void hermitian_matrix_rank_2k_update(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, OutMat C, Triangle t);
9 Effects: Computes C = ABH + BAH.
template<in-matrix InMat1, in-matrix InMat2, in-matrix InMat3,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(InMat1 A, InMat2 B, InMat3 E, OutMat C, Triangle t);
template<class ExecutionPolicy, in-matrix InMat1, in-matrix InMat2, in-matrix InMat3,
possibly-packed-out-matrix OutMat, class Triangle>
void symmetric_matrix_rank_2k_update(ExecutionPolicy&& exec,
InMat1 A, InMat2 B, InMat3 E, OutMat C, Triangle t);
Computes C = E+ ABT + BAT.
template<in-matrix InMat1, in-matrix InMat2, in-matrix InMat3, possibly-packed-out-matrix OutMat,
class Triangle>
void hermitian_matrix_rank_2k_update(InMat1 A, InMat2 B, InMat3 E, OutMat C, Triangle t);
template<class ExecutionPolicy, in-matrix InMat1, in-matrix InMat2, in-matrix InMat3,
possibly-packed-out-matrix OutMat,
class Triangle>
void hermitian_matrix_rank_2k_update(ExecutionPolicy&& exec, InMat1 A, InMat2 B, InMat3 E,
OutMat C, Triangle t);
10 Effects: Computes C = E+ ABH + BAH.
29.9.15.6 Solve multiple triangular linear systems [linalg.algs.blas3.trsm]
1 [Note 1: These functions correspond to the BLAS functionxTRSM[19]. —end note]
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
2 These functions perform multiple matrix solves, taking into account theTriangleandDiagonalStorage
parameters that apply to the triangular matrixA (29.9.3).
3 Mandates:
—(3.1) If InMat1 has layout_blas_packed layout, then the layout’sTriangle template argument has
the same type as the function’sTriangle template argument;
—(3.2) possibly-multipliable <InMat1, OutMat, InMat2>() is true; and
—(3.3) compatible-static-extents <InMat1, InMat1>(0, 1) is true.
4 Preconditions:
—(4.1) multipliable (A, X, B) is true, and
—(4.2) A.extent(0) == A.extent(1) is true.
5 Effects: ComputesX′such thatAX′= B, and assigns each element ofX′to the corresponding element
of X. If no suchX′exists, then the elements ofX are valid but unspecified.
6 Complexity: O(A.extent(0)×B.extent(1)×B.extent(1)).
§ 29.9.15.6 © ISO/IEC
1866

===== PAGE 1878 =====

Dxxxx
7 [Note 2: Since the triangular matrix is on the left, the desireddivide implementation in the case of noncommutative
multiplication is mathematically equivalent toy−1x, wherex is the first argument andy is the second argument, and
y−1 denotes the multiplicative inverse ofy. —end note]
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X);
8 Effects: Equivalent to:
triangular_matrix_matrix_left_solve(A, t, d, B, X, divides<void>{});
template<class ExecutionPolicy, in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X);
9 Effects: Equivalent to:
triangular_matrix_matrix_left_solve(std::forward<ExecutionPolicy>(exec),
A, t, d, B, X, divides<void>{});
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
template<class ExecutionPolicy,
in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X, BinaryDivideOp divide);
10 These functions perform multiple matrix solves, taking into account theTriangleandDiagonalStorage
parameters that apply to the triangular matrixA (29.9.3).
11 Mandates:
—(11.1) If InMat1 has layout_blas_packed layout, then the layout’sTriangle template argument has
the same type as the function’sTriangle template argument;
—(11.2) possibly-multipliable <OutMat, InMat1, InMat2>() is true; and
—(11.3) compatible-static-extents <InMat1, InMat1>(0,1) is true.
12 Preconditions:
—(12.1) multipliable (X, A, B) is true, and
—(12.2) A.extent(0) == A.extent(1) is true.
13 Effects: ComputesX′such thatX′A= B, and assigns each element ofX′to the corresponding element
of X. If no suchX′exists, then the elements ofX are valid but unspecified.
14 Complexity: O( B.extent(0) ·B.extent(1) ·A.extent(1) )
[Note 3: Since the triangular matrix is on the right, the desired divide implementation in the case of
noncommutative multiplication is mathematically equivalent toxy−1, wherexis the first argument andy is the
second argument, andy−1 denotes the multiplicative inverse ofy. —end note]
template<in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X);
15 Effects: Equivalent to:
triangular_matrix_matrix_right_solve(A, t, d, B, X, divides<void>{});
§ 29.9.15.6 © ISO/IEC
1867

===== PAGE 1879 =====

Dxxxx
template<class ExecutionPolicy, in-matrix InMat1, class Triangle, class DiagonalStorage,
in-matrix InMat2, out-matrix OutMat>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat1 A, Triangle t, DiagonalStorage d,
InMat2 B, OutMat X);
16 Effects: Equivalent to:
triangular_matrix_matrix_right_solve(std::forward<ExecutionPolicy>(exec),
A, t, d, B, X, divides<void>{});
29.9.15.7 Solve multiple triangular linear systems in-place [linalg.algs.blas3.inplacetrsm]
1 [Note 1: These functions correspond to the BLAS functionxTRSM[19]. —end note]
template<in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
2 These functions perform multiple in-place matrix solves, taking into account the Triangle and
DiagonalStorage parameters that apply to the triangular matrixA (29.9.3).
[Note 2: This algorithm makes it possible to compute factorizations like Cholesky and LU in place. Performing
triangular solve in place hinders parallelization. However, otherExecutionPolicy specific optimizations, such
as vectorization, are still possible.—end note]
3 Mandates:
—(3.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(3.2) possibly-multipliable <InMat, InOutMat, InOutMat>() is true; and
—(3.3) compatible-static-extents <InMat, InMat>(0, 1) is true.
4 Preconditions:
—(4.1) multipliable (A, B, B) is true, and
—(4.2) A.extent(0) == A.extent(1) is true.
5 Effects: ComputesX′such thatAX′= B, and assigns each element ofX′to the corresponding element
of B. If so suchX′exists, then the elements ofB are valid but unspecified.
6 Complexity: O(B.extent(0)×A.extent(0)×A.extent(1)).
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_left_solve(InMat A, Triangle t, DiagonalStorage d,
InOutMat B);
7 Effects: Equivalent to:
triangular_matrix_matrix_left_solve(A, t, d, B, divides<void>{});
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B);
8 Effects: Equivalent to:
triangular_matrix_matrix_left_solve(std::forward<ExecutionPolicy>(exec),
A, t, d, B, divides<void>{});
§ 29.9.15.7 © ISO/IEC
1868

===== PAGE 1880 =====

Dxxxx
template<in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
template<class ExecutionPolicy, in-matrix InMat, class Triangle, class DiagonalStorage,
inout-matrix InOutMat, class BinaryDivideOp>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B, BinaryDivideOp divide);
9 These functions perform multiple in-place matrix solves, taking into account the Triangle and
DiagonalStorage parameters that apply to the triangular matrixA (29.9.3).
[Note 3: This algorithm makes it possible to compute factorizations like Cholesky and LU in place. Performing
triangular solve in place hinders parallelization. However, otherExecutionPolicy specific optimizations, such
as vectorization, are still possible.—end note]
10 Mandates:
—(10.1) If InMat has layout_blas_packed layout, then the layout’sTriangle template argument has the
same type as the function’sTriangle template argument;
—(10.2) possibly-multipliable <InOutMat, InMat, InOutMat>() is true; and
—(10.3) compatible-static-extents <InMat, InMat>(0, 1) is true.
11 Preconditions:
—(11.1) multipliable (B, A, B) is true, and
—(11.2) A.extent(0) == A.extent(1) is true.
12 Effects: ComputesX′such thatX′A= B, and assigns each element ofX′to the corresponding element
of B. If so suchX′exists, then the elements ofB are valid but unspecified.
13 Complexity: O(A.extent(0)×A.extent(1)×B.extent(1)).
template<in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_right_solve(InMat A, Triangle t, DiagonalStorage d, InOutMat B);
14 Effects: Equivalent to:
triangular_matrix_matrix_right_solve(A, t, d, B, divides<void>{});
template<class ExecutionPolicy,
in-matrix InMat, class Triangle, class DiagonalStorage, inout-matrix InOutMat>
void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
InMat A, Triangle t, DiagonalStorage d,
InOutMat B);
15 Effects: Equivalent to:
triangular_matrix_matrix_right_solve(std::forward<ExecutionPolicy>(exec),
A, t, d, B, divides<void>{});
29.10 Data-parallel types [simd]
29.10.1 General [simd.general]
1 Subclause 29.10 defines data-parallel types and operations on these types.
[Note 1: The intent is to support acceleration through data-parallel execution resources where available, such as
SIMD registers and instructions or execution units driven by a common instruction decoder. SIMD stands for “Single
Instruction Stream – Multiple Data Stream”; it is defined in Flynn 1966[22]. —end note]
2 The set ofvectorizable typescomprises
—(2.1) all standard integer types, character types, and the typesfloat and double (6.9.2);
—(2.2) std::float16_t, std::float32_t, andstd::float64_t if defined (6.9.3); and
—(2.3) complex<T> where T is a vectorizable floating-point type.
3 The term data-parallel type refers to all enabled specializations of thebasic_vec and basic_mask class
templates. A data-parallel objectis an object of data-parallel type.
§ 29.10.1 © ISO/IEC
1869

===== PAGE 1881 =====

Dxxxx
4 Each specialization ofbasic_vec or basic_mask is either enabled or disabled, as described in 29.10.7.1 and
29.10.9.1.
5 A data-parallel type consists of one or more elements of an underlying vectorizable type, called theelement
type. The number of elements is a constant for each data-parallel type and called thewidth of that type. The
elements in a data-parallel type are indexed from 0 to width−1.
6 An element-wise operationapplies a specified operation to the elements of one or more data-parallel objects.
Each such application is unsequenced with respect to the others. Aunary element-wise operationis an
element-wise operation that applies a unary operation to each element of a data-parallel object. Abinary
element-wise operationis an element-wise operation that applies a binary operation to corresponding elements
of two data-parallel objects.
7 Given a basic_mask<Bytes, Abi> object mask, the selected indices signify the integers i in the range
[0,mask.size()) for whichmask[i] is true. Given a data-parallel objectdata, theselected elementssignify
the elementsdata[i] for all selected indicesi.
8 The conversion from an arithmetic typeU to a vectorizable typeT is value-preserving if all possible values of
U can be represented with typeT.
29.10.2 Exposition-only types, variables, and concepts [simd.expos]
using simd-size-type = see below; // exposition only
template<size_t Bytes> using integer-from = see below; // exposition only
template<class T, class Abi>
constexpr simd-size-type simd-size-v = see below; // exposition only
template<class T> constexpr size_t mask-element-size = see below; // exposition only
template<class T>
concept constexpr-wrapper-like = // exposition only
convertible_to<T, decltype(T::value)> &&
equality_comparable_with<T, decltype(T::value)> &&
bool_constant<T() == T::value>::value &&
bool_constant<static_cast<decltype(T::value)>(T()) == T::value>::value;
template<class From, class To>
concept explicitly-convertible-to = // exposition only
requires {
static_cast<To>(declval<From>());
};
template<class T> using deduced-vec-t = see below; // exposition only
template<class V, class T> using make-compatible-simd-t = see below; // exposition only
template<class V>
concept simd-vec-type = // exposition only
same_as<V, basic_vec<typename V::value_type, typename V::abi_type>> &&
is_default_constructible_v<V>;
template<class V>
concept simd-mask-type = // exposition only
same_as<V, basic_mask<mask-element-size <V>, typename V::abi_type>> &&
is_default_constructible_v<V>;
template<class V>
concept simd-floating-point = // exposition only
simd-vec-type <V> && floating_point<typename V::value_type>;
template<class V>
concept simd-integral = // exposition only
simd-vec-type <V> && integral<typename V::value_type>;
template<class V>
using simd-complex-value-type = V::value_type::value_type; // exposition only
§ 29.10.2 © ISO/IEC
1870

===== PAGE 1882 =====

Dxxxx
template<class V>
concept simd-complex = // exposition only
simd-vec-type <V> && same_as<typename V::value_type, complex<simd-complex-value-type <V>>>;
template<class... Ts>
concept math-floating-point = // exposition only
(simd-floating-point<deduced-vec-t<Ts>> || ...);
template<class... Ts>
requires math-floating-point<Ts...>
using math-common-simd-t = see below; // exposition only
template<class BinaryOperation, class T>
concept reduction-binary-operation = see below; // exposition only
// 29.10.2.2,simd ABI tags
template<class T> using native-abi = see below; // exposition only
template<class T, simd-size-type N> using deduce-abi-t = see below; // exposition only
// 29.10.5, load and store flags
struct convert-flag; // exposition only
struct aligned-flag; // exposition only
template<size_t N> struct overaligned-flag; // exposition only
29.10.2.1 Exposition-only helpers [simd.expos.defn]
using simd-size-type = see below ;
1 simd-size-type is an alias for a signed integer type.
template<size_t Bytes> using integer-from = see below ;
2 integer-from <Bytes> is an alias for a signed integer typeT such thatsizeof(T) equals Bytes.
template<class T, class Abi>
constexpr simd-size-type simd-size-v = see below ;
3 simd-size-v <T, Abi> denotes the width ofbasic_vec<T, Abi> if the specializationbasic_vec<T,
Abi> is enabled, or0 otherwise.
template<class T> constexpr size_t mask-element-size = see below ;
4 mask-element-size <basic_mask<Bytes, Abi>> has the valueBytes.
template<class T> using deduced-vec-t = see below ;
5 Let x denote an lvalue of typeconst T.
6 deduced-vec-t <T> is an alias for
—(6.1) decltype(x + x), if the type ofx + x is an enabled specialization ofbasic_vec; otherwise
—(6.2) void.
template<class V, class T> using make-compatible-simd-t = see below ;
7 Let x denote an lvalue of typeconst T.
8 make-compatible-simd-t <V, T> is an alias for
—(8.1) deduced-vec-t <T>, if that type is notvoid, otherwise
—(8.2) vec<decltype(x + x), V::size()>.
template<class... Ts>
requires math-floating-point <Ts...>
using math-common-simd-t = see below ;
9 Let T0 denote Ts...[0]. Let T1 denote Ts...[1]. Let TRest denote a pack such thatT0, T1,
TRest... is equivalent toTs....
10 Let math-common-simd-t <Ts...> be an alias for
§ 29.10.2.1 © ISO/IEC
1871

===== PAGE 1883 =====

Dxxxx
—(10.1) deduced-vec-t <T0>, ifsizeof...(Ts) equals 1; otherwise
—(10.2) common_type_t<deduced-vec-t <T0>, deduced-vec-t <T1>>, if sizeof...(Ts) equals 2 and
math-floating-point <T0> && math-floating-point <T1> is true; otherwise
—(10.3) common_type_t<deduced-vec-t <T0>, T1>, if sizeof...(Ts) equals 2 and math-floating-
point <T0> is true; otherwise
—(10.4) common_type_t<T0, deduced-vec-t <T1>>, ifsizeof...(Ts) equals 2; otherwise
—(10.5) common_type_t<math-common-simd-t <T0, T1>, TRest...>, ifmath-common-simd-t <T0, T1>
is valid and denotes a type; otherwise
—(10.6) common_type_t<math-common-simd-t <TRest...>, T0, T1>.
template<class BinaryOperation, class T>
concept reduction-binary-operation =
requires (const BinaryOperation binary_op, const vec<T, 1> v) {
{ binary_op(v, v) } -> same_as<vec<T, 1>>;
};
11 Types BinaryOperation and T model reduction-binary-operation <BinaryOperation, T> only if:
—(11.1) BinaryOperation is a binary element-wise operation and the operation is commutative.
—(11.2) An object of typeBinaryOperation can be invoked with two arguments of typebasic_vec<T,
Abi>, with unspecified ABI tagAbi, returning abasic_vec<T, Abi>.
29.10.2.2 simd ABI tags [simd.expos.abi]
template<class T> using native-abi = see below ;
template<class T, simd-size-type N> using deduce-abi-t = see below ;
1 An ABI tagis a type that indicates a choice of size and binary representation for objects of data-parallel
type.
[Note 1: The intent is for the size and binary representation to depend on the target architecture and compiler
flags. The ABI tag, together with a given element type, implies the width.—end note]
2 [Note 2: The ABI tag is orthogonal to selecting the machine instruction set. The selected machine instruction
set limits the usable ABI tag types, though (see 29.10.7.1). The ABI tags enable users to safely pass objects of
data-parallel type between translation unit boundaries (e.g., function calls or I/O).—end note]
3 An implementation defines ABI tag types as necessary for the following aliases.
4 deduce-abi-t <T, N> is defined if
—(4.1) T is a vectorizable type,
—(4.2) N is greater than zero, and
—(4.3) N is not larger than an implementation-defined maximum.
The implementation-defined maximum forN is not smaller than 64 and can differ depending onT.
5 Where present,deduce-abi-t <T, N> names an ABI tag type such that
—(5.1) simd-size-v <T, deduce-abi-t <T, N>> equals N,
—(5.2) basic_vec<T, deduce-abi-t <T, N>> is enabled (29.10.7.1), and
—(5.3) basic_mask<sizeof(T), deduce-abi-t <integer-from <sizeof(T)>, N>> is enabled.
6 native-abi <T> is an implementation-defined alias for an ABI tag.basic_vec<T, native-abi <T>>
is an enabled specialization.
[Note 3: The intent is to use the ABI tag producing the most efficient data-parallel execution for the element
type T on the currently targeted system. For target architectures with ISA extensions, compiler flags can change
the type of thenative-abi <T> alias. —end note]
[Example 1: Consider a target architecture supporting the ABI tags__simd128 and __simd256, where hardware
support for__simd256 exists only for floating-point types. The implementation therefore definesnative-abi <T>
as an alias for
—(6.1) __simd256 if T is a floating-point type, and
—(6.2) __simd128 otherwise.
—end example]
§ 29.10.2.2 © ISO/IEC
1872

===== PAGE 1884 =====

Dxxxx
29.10.3 Header <simd> synopsis [simd.syn]
namespace std::simd {
// 29.10.4, type traits
template<class T, class U = typename T::value_type> struct alignment;
template<class T, class U = typename T::value_type>
constexpr size_t alignment_v = alignment<T, U>::value;
template<class T, class V> struct rebind { using type = see below ; };
template<class T, class V> using rebind_t = rebind<T, V>::type;
template<simd-size-type N, class V> struct resize { using type = see below ; };
template<simd-size-type N, class V> using resize_t = resize<N, V>::type;
// 29.10.5, load and store flags
template<class... Flags> struct flags;
inline constexpr flags<> flag_default{};
inline constexpr flags<convert-flag > flag_convert{};
inline constexpr flags<aligned-flag > flag_aligned{};
template<size_t N> requires (has_single_bit(N))
constexpr flags<overaligned-flag <N>> flag_overaligned{};
// 29.10.6, class templatesimd-iterator
template<class V>
class simd-iterator; // exposition only
// 29.10.7, class templatebasic_vec
template<class T, class Abi = native-abi <T>> class basic_vec;
template<class T, simd-size-type N = simd-size-v <T, native-abi <T>>>
using vec = basic_vec<T, deduce-abi-t <T, N>>;
// 29.10.8.5, reductions
template<class T, class Abi, class BinaryOperation = plus<>>
constexpr T reduce(const basic_vec<T, Abi>&, BinaryOperation = {});
template<class T, class Abi, class BinaryOperation = plus<>>
constexpr T reduce(
const basic_vec<T, Abi>& x, const typename basic_vec<T, Abi>::mask_type& mask,
BinaryOperation binary_op = {}, type_identity_t<T> identity_element = see below );
template<class T, class Abi>
constexpr T reduce_min(const basic_vec<T, Abi>&) noexcept;
template<class T, class Abi>
constexpr T reduce_min(const basic_vec<T, Abi>&,
const typename basic_vec<T, Abi>::mask_type&) noexcept;
template<class T, class Abi>
constexpr T reduce_max(const basic_vec<T, Abi>&) noexcept;
template<class T, class Abi>
constexpr T reduce_max(const basic_vec<T, Abi>&,
const typename basic_vec<T, Abi>::mask_type&) noexcept;
// 29.10.8.6, load and store functions
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_load(R&& r, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_load(R&& r, const typename V::mask_type& k,
flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V unchecked_load(I first, iter_difference_t<I> n,
flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V unchecked_load(I first, iter_difference_t<I> n,
const typename V::mask_type& k, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V unchecked_load(I first, S last, flags<Flags...> f = {});
§ 29.10.3 © ISO/IEC
1873

===== PAGE 1885 =====

Dxxxx
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V unchecked_load(I first, S last, const typename V::mask_type& k,
flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_load(R&& r, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_load(R&& r, const typename V::mask_type& k,
flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V partial_load(I first, iter_difference_t<I> n, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V partial_load(I first, iter_difference_t<I> n,
const typename V::mask_type& k, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V partial_load(I first, S last, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V partial_load(I first, S last, const typename V::mask_type& k,
flags<Flags...> f = {});
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, R&& r,
flags<Flags...> f = {});
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, R&& r,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first,
iter_difference_t<I> n, flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first,
iter_difference_t<I> n, const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, S last,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, S last,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void partial_store(const basic_vec<T, Abi>& v, R&& r,
flags<Flags...> f = {});
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void partial_store(const basic_vec<T, Abi>& v, R&& r,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void partial_store(
const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n, flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void partial_store(
const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n,
const typename basic_vec<T, Abi>::mask_type& mask, flags<Flags...> f = {});
§ 29.10.3 © ISO/IEC
1874

===== PAGE 1886 =====

Dxxxx
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void partial_store(const basic_vec<T, Abi>& v, I first, S last,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void partial_store(const basic_vec<T, Abi>& v, I first, S last,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
// 29.10.8.7, static permute
inline constexpr simd-size-type zero_element = implementation-defined ;
inline constexpr simd-size-type uninit_element = implementation-defined ;
template<simd-size-type N = see below , simd-vec-type V, class IdxMap>
constexpr resize_t<N, V> permute(const V& v, IdxMap&& idxmap);
template<simd-size-type N = see below , simd-mask-type M, class IdxMap>
constexpr resize_t<N, M> permute(const M& v, IdxMap&& idxmap);
// 29.10.8.8, dynamic permute
template<simd-vec-type V, simd-integral I>
constexpr resize_t<I::size(), V> permute(const V& v, const I& indices);
template<simd-mask-type M, simd-integral I>
constexpr resize_t<I::size(), M> permute(const M& v, const I& indices);
// 29.10.8.9, mask permute
template<simd-vec-type V>
constexpr V compress(const V& v, const typename V::mask_type& selector);
template<simd-mask-type M>
constexpr M compress(const M& v, const type_identity_t<M>& selector);
template<simd-vec-type V>
constexpr V compress(const V& v, const typename V::mask_type& selector,
const typename V::value_type& fill_value);
template<simd-mask-type M>
constexpr M compress(const M& v, const type_identity_t<M>& selector,
const typename M::value_type& fill_value);
template<simd-vec-type V>
constexpr V expand(const V& v, const typename V::mask_type& selector,
const V& original = {});
template<simd-mask-type M>
constexpr M expand(const M& v, const type_identity_t<M>& selector,
const M& original = {});
// 29.10.8.10, memory permute
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_gather_from(R&& in, const I& indices, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_gather_from(R&& in, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_gather_from(R&& in, const I& indices, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_gather_from(R&& in, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_scatter_to(const V& v, R&& out,
const I& indices, flags<Flags...> f = {});
§ 29.10.3 © ISO/IEC
1875

===== PAGE 1887 =====

Dxxxx
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_scatter_to(const V& v, R&& out, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void partial_scatter_to(const V& v, R&& out,
const I& indices, flags<Flags...> f = {});
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void partial_scatter_to(const V& v, R&& out, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
// 29.10.8.11, creation
template<class T, class Abi>
constexpr auto chunk(const basic_vec<typename T::value_type, Abi>& x) noexcept;
template<class T, class Abi>
constexpr auto chunk(const basic_mask<mask-element-size <T>, Abi>& x) noexcept;
template<simd-size-type N, class T, class Abi>
constexpr auto chunk(const basic_vec<T, Abi>& x) noexcept;
template<simd-size-type N, size_t Bytes, class Abi>
constexpr auto chunk(const basic_mask<Bytes, Abi>& x) noexcept;
template<class T, class... Abis>
constexpr basic_vec<T, deduce-abi-t <T, (basic_vec<T, Abis>::size() + ...)>>
cat(const basic_vec<T, Abis>&...) noexcept;
template<size_t Bytes, class... Abis>
constexpr basic_mask<Bytes, deduce-abi-t <integer-from <Bytes>,
(basic_mask<Bytes, Abis>::size() + ...)>>
cat(const basic_mask<Bytes, Abis>&...) noexcept;
// 29.10.8.12, algorithms
template<class T, class Abi>
constexpr basic_vec<T, Abi>
min(const basic_vec<T, Abi>& a, const basic_vec<T, Abi>& b) noexcept;
template<class T, class Abi>
constexpr basic_vec<T, Abi>
max(const basic_vec<T, Abi>& a, const basic_vec<T, Abi>& b) noexcept;
template<class T, class Abi>
constexpr pair<basic_vec<T, Abi>, basic_vec<T, Abi>>
minmax(const basic_vec<T, Abi>& a, const basic_vec<T, Abi>& b) noexcept;
template<class T, class Abi>
constexpr basic_vec<T, Abi>
clamp(const basic_vec<T, Abi>& v, const basic_vec<T, Abi>& lo,
const basic_vec<T, Abi>& hi);
template<class T, class U>
constexpr auto select(bool c, const T& a, const U& b)
-> remove_cvref_t<decltype(c ? a : b)>;
template<size_t Bytes, class Abi, class T, class U>
constexpr auto select(const basic_mask<Bytes, Abi>& c, const T& a, const U& b)
noexcept -> decltype(simd-select-impl (c, a, b));
// 29.10.8.13, mathematical functions
template<math-floating-point V> constexpr deduced-vec-t <V> acos(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> asin(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> atan(const V& x);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> atan2(const V0& y, const V1& x);
template<math-floating-point V> constexpr deduced-vec-t <V> cos(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> sin(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> tan(const V& x);
§ 29.10.3 © ISO/IEC
1876

===== PAGE 1888 =====

Dxxxx
template<math-floating-point V> constexpr deduced-vec-t <V> acosh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> asinh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> atanh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> cosh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> sinh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> tanh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> exp(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> exp2(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> expm1(const V& x);
template<math-floating-point V>
constexpr deduced-vec-t <V>
frexp(const V& value, rebind_t<int, deduced-vec-t <V>>* exp);
template<math-floating-point V>
constexpr rebind_t<int, deduced-vec-t <V>> ilogb(const V& x);
template<math-floating-point V>
constexpr deduced-vec-t <V> ldexp(const V& x, const rebind_t<int, deduced-vec-t <V>>& exp);
template<math-floating-point V> constexpr deduced-vec-t <V> log(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> log10(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> log1p(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> log2(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> logb(const V& x);
template<class T, class Abi>
constexpr basic_vec<T, Abi>
modf(const type_identity_t<basic_vec<T, Abi>>& value, basic_vec<T, Abi>* iptr);
template<math-floating-point V>
constexpr deduced-vec-t <V> scalbn(const V& x, const rebind_t<int, deduced-vec-t <V>>& n);
template<math-floating-point V>
constexpr deduced-vec-t <V> scalbln(
const V& x, const rebind_t<long int, deduced-vec-t <V>>& n);
template<math-floating-point V> constexpr deduced-vec-t <V> cbrt(const V& x);
template<signed_integral T, class Abi>
constexpr basic_vec<T, Abi> abs(const basic_vec<T, Abi>& j);
template<math-floating-point V> constexpr deduced-vec-t <V> abs(const V& j);
template<math-floating-point V> constexpr deduced-vec-t <V> fabs(const V& x);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> hypot(const V0& x, const V1& y);
template<class V0, class V1, class V2>
constexpr math-common-simd-t <V0, V1, V2> hypot(const V0& x, const V1& y, const V2& z);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> pow(const V0& x, const V1& y);
template<math-floating-point V> constexpr deduced-vec-t <V> sqrt(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> erf(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> erfc(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> lgamma(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> tgamma(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> ceil(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> floor(const V& x);
template<math-floating-point V> deduced-vec-t <V> nearbyint(const V& x);
template<math-floating-point V> deduced-vec-t <V> rint(const V& x);
template<math-floating-point V>
rebind_t<long int, deduced-vec-t <V>> lrint(const V& x);
template<math-floating-point V>
rebind_t<long long int, V> llrint(const deduced-vec-t <V>& x);
template<math-floating-point V>
constexpr deduced-vec-t <V> round(const V& x);
template<math-floating-point V>
constexpr rebind_t<long int, deduced-vec-t <V>> lround(const V& x);
template<math-floating-point V>
constexpr rebind_t<long long int, deduced-vec-t <V>> llround(const V& x);
template<math-floating-point V>
constexpr deduced-vec-t <V> trunc(const V& x);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fmod(const V0& x, const V1& y);
§ 29.10.3 © ISO/IEC
1877

===== PAGE 1889 =====

Dxxxx
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> remainder(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1>
remquo(const V0& x, const V1& y, rebind_t<int, math-common-simd-t <V0, V1>>* quo);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> copysign(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> nextafter(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fdim(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fmax(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fmin(const V0& x, const V1& y);
template<class V0, class V1, class V2>
constexpr math-common-simd-t <V0, V1, V2> fma(const V0& x, const V1& y, const V2& z);
template<class V0, class V1, class V2>
constexpr math-common-simd-t <V0, V1, V2>
lerp(const V0& a, const V1& b, const V2& t) noexcept;
template<math-floating-point V>
constexpr rebind_t<int, deduced-vec-t <V>> fpclassify(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isfinite(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isinf(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isnan(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isnormal(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type signbit(const V& x);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type
isgreater(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type
isgreaterequal(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type
isless(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type
islessequal(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type
islessgreater(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type
isunordered(const V0& x, const V1& y);
template<math-floating-point V>
deduced-vec-t <V> assoc_laguerre(const rebind_t<unsigned, deduced-vec-t <V>>& n,
const rebind_t<unsigned, deduced-vec-t <V>>& m, const V& x);
template<math-floating-point V>
deduced-vec-t <V> assoc_legendre(const rebind_t<unsigned, deduced-vec-t <V>>& l,
const rebind_t<unsigned, deduced-vec-t <V>>& m, const V& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> beta(const V0& x, const V1& y);
template<math-floating-point V> deduced-vec-t <V> comp_ellint_1(const V& k);
template<math-floating-point V> deduced-vec-t <V> comp_ellint_2(const V& k);
template<class V0, class V1>
math-common-simd-t <V0, V1> comp_ellint_3(const V0& k, const V1& nu);
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_bessel_i(const V0& nu, const V1& x);
§ 29.10.3 © ISO/IEC
1878

===== PAGE 1890 =====

Dxxxx
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_bessel_j(const V0& nu, const V1& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_bessel_k(const V0& nu, const V1& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_neumann(const V0& nu, const V1& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> ellint_1(const V0& k, const V1& phi);
template<class V0, class V1>
math-common-simd-t <V0, V1> ellint_2(const V0& k, const V1& phi);
template<class V0, class V1, class V2>
math-common-simd-t <V0, V1, V2> ellint_3(const V0& k, const V1& nu, const V2& phi);
template<math-floating-point V> deduced-vec-t <V> expint(const V& x);
template<math-floating-point V>
deduced-vec-t <V> hermite(const rebind_t<unsigned, deduced-vec-t <V>>& n, const V& x);
template<math-floating-point V>
deduced-vec-t <V> laguerre(const rebind_t<unsigned, deduced-vec-t <V>>& n, const V& x);
template<math-floating-point V>
deduced-vec-t <V> legendre(const rebind_t<unsigned, deduced-vec-t <V>>& l, const V& x);
template<math-floating-point V>
deduced-vec-t <V> riemann_zeta(const V& x);
template<math-floating-point V>
deduced-vec-t <V> sph_bessel(
const rebind_t<unsigned, deduced-vec-t <V>>& n, const V& x);
template<math-floating-point V>
deduced-vec-t <V> sph_legendre(const rebind_t<unsigned, deduced-vec-t <V>>& l,
const rebind_t<unsigned, deduced-vec-t <V>>& m, const V& theta);
template<math-floating-point V>
deduced-vec-t <V>
sph_neumann(const rebind_t<unsigned, deduced-vec-t <V>>& n, const V& x);
// 29.10.8.14, bit manipulation
template<simd-vec-type V> constexpr V byteswap(const V& v) noexcept;
template<simd-vec-type V> constexpr V bit_ceil(const V& v);
template<simd-vec-type V> constexpr V bit_floor(const V& v) noexcept;
template<simd-vec-type V>
constexpr typename V::mask_type has_single_bit(const V& v) noexcept;
template<simd-vec-type V0, simd-vec-type V1>
constexpr V0 rotl(const V0& v, const V1& s) noexcept;
template<simd-vec-type V>
constexpr V rotl(const V& v, int s) noexcept;
template<simd-vec-type V0, simd-vec-type V1>
constexpr V0 rotr(const V0& v, const V1& s) noexcept;
template<simd-vec-type V>
constexpr V rotr(const V& v, int s) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V>
bit_width(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V>
countl_zero(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V>
countl_one(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V>
countr_zero(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V>
countr_one(const V& v) noexcept;
§ 29.10.3 © ISO/IEC
1879

===== PAGE 1891 =====

Dxxxx
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V>
popcount(const V& v) noexcept;
// 29.10.8.15, complex math
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> real(const V&) noexcept;
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> imag(const V&) noexcept;
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> abs(const V&);
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> arg(const V&);
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> norm(const V&);
template<simd-complex V> constexpr V conj(const V&);
template<simd-complex V> constexpr V proj(const V&);
template<simd-complex V> constexpr V exp(const V& v);
template<simd-complex V> constexpr V log(const V& v);
template<simd-complex V> constexpr V log10(const V& v);
template<simd-complex V> constexpr V sqrt(const V& v);
template<simd-complex V> constexpr V sin(const V& v);
template<simd-complex V> constexpr V asin(const V& v);
template<simd-complex V> constexpr V cos(const V& v);
template<simd-complex V> constexpr V acos(const V& v);
template<simd-complex V> constexpr V tan(const V& v);
template<simd-complex V> constexpr V atan(const V& v);
template<simd-complex V> constexpr V sinh(const V& v);
template<simd-complex V> constexpr V asinh(const V& v);
template<simd-complex V> constexpr V cosh(const V& v);
template<simd-complex V> constexpr V acosh(const V& v);
template<simd-complex V> constexpr V tanh(const V& v);
template<simd-complex V> constexpr V atanh(const V& v);
template<simd-floating-point V>
rebind_t<complex<typename V::value_type>, V> polar(const V& x, const V& y = {});
template<simd-complex V> constexpr V pow(const V& x, const V& y);
// 29.10.9, class templatebasic_mask
template<size_t Bytes, class Abi = native-abi <integer-from <Bytes>>> class basic_mask;
template<class T, simd-size-type N = simd-size-v <T, native-abi <T>>>
using mask = basic_mask<sizeof(T), deduce-abi-t <T, N>>;
// 29.10.10.5, reductions
template<size_t Bytes, class Abi>
constexpr bool all_of(const basic_mask<Bytes, Abi>&) noexcept;
template<size_t Bytes, class Abi>
constexpr bool any_of(const basic_mask<Bytes, Abi>&) noexcept;
template<size_t Bytes, class Abi>
constexpr bool none_of(const basic_mask<Bytes, Abi>&) noexcept;
template<size_t Bytes, class Abi>
constexpr simd-size-type reduce_count(const basic_mask<Bytes, Abi>&) noexcept;
template<size_t Bytes, class Abi>
constexpr simd-size-type reduce_min_index(const basic_mask<Bytes, Abi>&);
template<size_t Bytes, class Abi>
constexpr simd-size-type reduce_max_index(const basic_mask<Bytes, Abi>&);
§ 29.10.3 © ISO/IEC
1880

===== PAGE 1892 =====

Dxxxx
constexpr bool all_of(same_as<bool> auto) noexcept;
constexpr bool any_of(same_as<bool> auto) noexcept;
constexpr bool none_of(same_as<bool> auto) noexcept;
constexpr simd-size-type reduce_count(same_as<bool> auto) noexcept;
constexpr simd-size-type reduce_min_index(same_as<bool> auto);
constexpr simd-size-type reduce_max_index(same_as<bool> auto);
}
namespace std {
// See 29.10.8.12, algorithms
using simd::min;
using simd::max;
using simd::minmax;
using simd::clamp;
// See 29.10.8.13, mathematical functions
using simd::acos;
using simd::asin;
using simd::atan;
using simd::atan2;
using simd::cos;
using simd::sin;
using simd::tan;
using simd::acosh;
using simd::asinh;
using simd::atanh;
using simd::cosh;
using simd::sinh;
using simd::tanh;
using simd::exp;
using simd::exp2;
using simd::expm1;
using simd::frexp;
using simd::ilogb;
using simd::ldexp;
using simd::log;
using simd::log10;
using simd::log1p;
using simd::log2;
using simd::logb;
using simd::modf;
using simd::scalbn;
using simd::scalbln;
using simd::cbrt;
using simd::abs;
using simd::fabs;
using simd::hypot;
using simd::pow;
using simd::sqrt;
using simd::erf;
using simd::erfc;
using simd::lgamma;
using simd::tgamma;
using simd::ceil;
using simd::floor;
using simd::nearbyint;
using simd::rint;
using simd::lrint;
using simd::llrint;
using simd::round;
using simd::lround;
using simd::llround;
using simd::trunc;
using simd::fmod;
§ 29.10.3 © ISO/IEC
1881

===== PAGE 1893 =====

Dxxxx
using simd::remainder;
using simd::remquo;
using simd::copysign;
using simd::nextafter;
using simd::fdim;
using simd::fmax;
using simd::fmin;
using simd::fma;
using simd::lerp;
using simd::fpclassify;
using simd::isfinite;
using simd::isinf;
using simd::isnan;
using simd::isnormal;
using simd::signbit;
using simd::isgreater;
using simd::isgreaterequal;
using simd::isless;
using simd::islessequal;
using simd::islessgreater;
using simd::isunordered;
using simd::assoc_laguerre;
using simd::assoc_legendre;
using simd::beta;
using simd::comp_ellint_1;
using simd::comp_ellint_2;
using simd::comp_ellint_3;
using simd::cyl_bessel_i;
using simd::cyl_bessel_j;
using simd::cyl_bessel_k;
using simd::cyl_neumann;
using simd::ellint_1;
using simd::ellint_2;
using simd::ellint_3;
using simd::expint;
using simd::hermite;
using simd::laguerre;
using simd::legendre;
using simd::riemann_zeta;
using simd::sph_bessel;
using simd::sph_legendre;
using simd::sph_neumann;
// See 29.10.8.14, bit manipulation
using simd::byteswap;
using simd::bit_ceil;
using simd::bit_floor;
using simd::has_single_bit;
using simd::rotl;
using simd::rotr;
using simd::bit_width;
using simd::countl_zero;
using simd::countl_one;
using simd::countr_zero;
using simd::countr_one;
using simd::popcount;
// See 29.10.8.15,vec complex math
using simd::real;
using simd::imag;
using simd::arg;
using simd::norm;
using simd::conj;
using simd::proj;
§ 29.10.3 © ISO/IEC
1882

===== PAGE 1894 =====

Dxxxx
using simd::polar;
}
29.10.4 Type traits [simd.traits]
template<class T, class U = typename T::value_type> struct alignment { see below };
1 alignment<T, U> has a membervalue if and only ifT is a specialization ofbasic_vec and U is a
vectorizable type.
2 If value is present, the typealignment<T, U> is a BinaryTypeTrait with a base characteristic of
integral_constant<size_t, N> for some unspecifiedN (29.10.7.2, 29.10.8.6).
[Note 1: value identifies the alignment restrictions on pointers used for (converting) loads and stores for the
given typeT on arrays of typeU. —end note]
3 The behavior of a program that adds specializations foralignment is undefined.
template<class T, class V> struct rebind { using type = see below ; };
4 The membertype is present if and only if
—(4.1) V is a data-parallel type,
—(4.2) T is a vectorizable type, and
—(4.3) deduce-abi-t <T, V::size()> has a member typetype.
5 If V is a specialization ofbasic_vec, letAbi1 denote an ABI tag such thatbasic_vec<T, Abi1>::
size() equals V::size(). If V is a specialization ofbasic_mask, letAbi1 denote an ABI tag such
that basic_mask<sizeof(T), Abi1>::size() equals V::size().
6 Where present, the member typedef type names basic_vec<T, Abi1> if V is a specialization of
basic_vec or basic_mask<sizeof(T), Abi1> if V is a specialization ofbasic_mask.
template<simd-size-type N, class V> struct resize { using type = see below ; };
7 Let T denote
—(7.1) typename V::value_type if V is a specialization ofbasic_vec,
—(7.2) otherwise integer-from <mask-element-size <V>> if V is a specialization ofbasic_mask.
8 The membertype is present if and only if
—(8.1) V is a data-parallel type, and
—(8.2) deduce-abi-t <T, N> has a member typetype.
9 If V is a specialization ofbasic_vec, letAbi1 denote an ABI tag such thatbasic_vec<T, Abi1>::
size() equals N. If V is a specialization of basic_mask, let Abi1 denote an ABI tag such that
basic_mask<sizeof(T), Abi1>::size() equals N.
10 Where present, the member typedef type names basic_vec<T, Abi1> if V is a specialization of
basic_vec or basic_mask<sizeof(T), Abi1> if V is a specialization ofbasic_mask.
29.10.5 Load and store flags [simd.flags]
29.10.5.1 Class template flags overview [simd.flags.overview]
namespace std::simd {
template<class... Flags> struct flags {
// 29.10.5.2,flags operators
template<class... Other>
friend consteval auto operator|(flags, flags<Other...>);
};
}
1 [Note 1: The class templateflags acts like an integer bit-flag for types.—end note]
2 Constraints: Every type in the parameter packFlags is one ofconvert-flag , aligned-flag , orover-
aligned-flag <N>.
§ 29.10.5.1 © ISO/IEC
1883

===== PAGE 1895 =====

Dxxxx
29.10.5.2 flags operators [simd.flags.oper]
template<class... Other>
friend consteval auto operator|(flags a, flags<Other...> b);
1 Returns: A default-initialized object of typeflags<Flags2...> for someFlags2 where every type in
Flags2 is present either in template parameter packFlags or in template parameter packOther, and
every type in template parameter packsFlags and Other is present inFlags2. If the packsFlags
and Other contain two different specializationsoveraligned-flag <N1> and overaligned-flag <N2>,
Flags2 is not required to contain the specializationoveraligned-flag <std::min(N1, N2)>.
29.10.6 Class template simd-iterator [simd.iterator]
namespace std::simd {
template<class V>
class simd-iterator { // exposition only
V* data_ = nullptr; // exposition only
simd-size-type offset_ = 0; // exposition only
constexpr simd-iterator(V& d, simd-size-type off) noexcept; // exposition only
public:
using value_type = V::value_type;
using iterator_category = input_iterator_tag;
using iterator_concept = random_access_iterator_tag;
using difference_type = simd-size-type ;
constexpr simd-iterator () = default;
constexpr simd-iterator (const simd-iterator &) = default;
constexpr simd-iterator & operator=(const simd-iterator &) = default;
constexpr simd-iterator (const simd-iterator <remove_const_t<V>>&) requires is_const_v<V>;
constexpr value_type operator*() const;
constexpr simd-iterator & operator++();
constexpr simd-iterator operator++(int);
constexpr simd-iterator & operator--();
constexpr simd-iterator operator--(int);
constexpr simd-iterator & operator+=(difference_type n);
constexpr simd-iterator & operator-=(difference_type n);
constexpr value_type operator[](difference_type n) const;
friend constexpr bool operator==(simd-iterator a, simd-iterator b) = default;
friend constexpr bool operator==(simd-iterator a, default_sentinel_t) noexcept;
friend constexpr auto operator<=>(simd-iterator a, simd-iterator b);
friend constexpr simd-iterator operator+(simd-iterator i, difference_type n);
friend constexpr simd-iterator operator+(difference_type n, simd-iterator i);
friend constexpr simd-iterator operator-(simd-iterator i, difference_type n);
friend constexpr difference_type operator-(simd-iterator a, simd-iterator b);
friend constexpr difference_type operator-(simd-iterator i, default_sentinel_t) noexcept;
friend constexpr difference_type operator-(default_sentinel_t, simd-iterator i) noexcept;
};
}
constexpr simd-iterator (V& d, simd-size-type off) noexcept;
1 Effects: Initializes data_ with addressof(d) and offset_ with off.
constexpr simd-iterator (const simd-iterator <remove_const_t<V>>& i) requires is_const_v<V>;
2 Effects: Initializes data_ with i.data_ and offset_ with i.offset_.
§ 29.10.6 © ISO/IEC
1884

===== PAGE 1896 =====

Dxxxx
constexpr value_type operator*() const;
3 Effects: Equivalent to:return (*data_)[offset_];
constexpr simd-iterator & operator++();
4 Effects: Equivalent to:return *this += 1;
constexpr simd-iterator operator++(int);
5 Effects: Equivalent to:
simd-iterator tmp = *this;
*this += 1;
return tmp;
constexpr simd-iterator & operator--();
6 Effects: Equivalent to:return *this -= 1;
constexpr simd-iterator operator--(int);
7 Effects: Equivalent to:
simd-iterator tmp = *this;
*this -= 1;
return tmp;
constexpr simd-iterator & operator+=(difference_type n);
8 Preconditions: offset_ + n is in the range[0,V::size()].
9 Effects: Equivalent to:
offset_ += n;
return *this;
constexpr simd-iterator & operator-=(difference_type n);
10 Preconditions: offset_ - n is in the range[0,V::size()].
11 Effects: Equivalent to:
offset_ -= n;
return *this;
constexpr value_type operator[](difference_type n) const;
12 Effects: Equivalent to:return (*data_)[offset_ + n];
friend constexpr bool operator==(simd-iterator i, default_sentinel_t) noexcept;
13 Effects: Equivalent to:return i.offset_ == V::size();
friend constexpr auto operator<=>(simd-iterator a, simd-iterator b);
14 Preconditions: a.data_ == b.data_ is true.
15 Effects: Equivalent to:return a.offset_ <=> b.offset_;
friend constexpr simd-iterator operator+(simd-iterator i, difference_type n);
friend constexpr simd-iterator operator+(difference_type n, simd-iterator i);
16 Effects: Equivalent to:return i += n;
friend constexpr simd-iterator operator-(simd-iterator i, difference_type n);
17 Effects: Equivalent to:return i -= n;
friend constexpr difference_type operator-(simd-iterator a, simd-iterator b);
18 Preconditions: a.data_ == b.data_ is true.
19 Effects: Equivalent to:return a.offset_ - b.offset_;
friend constexpr difference_type operator-(simd-iterator i, default_sentinel_t) noexcept;
20 Effects: Equivalent to:return i.offset_ - V::size();
§ 29.10.6 © ISO/IEC
1885

===== PAGE 1897 =====

Dxxxx
friend constexpr difference_type operator-(default_sentinel_t, simd-iterator i) noexcept;
21 Effects: Equivalent to:return V::size() - i.offset_;
29.10.7 Class template basic_vec [simd.class]
29.10.7.1 Overview [simd.overview]
namespace std::simd {
template<class T, class Abi> class basic_vec {
using real-type = see below ; // exposition only
public:
using value_type = T;
using mask_type = basic_mask<sizeof(T), Abi>;
using abi_type = Abi;
using iterator = simd-iterator <basic_vec>;
using const_iterator = simd-iterator <const basic_vec>;
constexpr iterator begin() noexcept { return {*this, 0}; }
constexpr const_iterator begin() const noexcept { return {*this, 0}; }
constexpr const_iterator cbegin() const noexcept { return {*this, 0}; }
constexpr default_sentinel_t end() const noexcept { return {}; }
constexpr default_sentinel_t cend() const noexcept { return {}; }
static constexpr integral_constant<simd-size-type , simd-size-v <T, Abi>> size {};
constexpr basic_vec() noexcept = default;
// 29.10.7.2,basic_vec constructors
template<class U>
constexpr explicit(see below ) basic_vec(U&& value) noexcept;
template<class U, class UAbi>
constexpr explicit(see below ) basic_vec(const basic_vec<U, UAbi>&) noexcept;
template<class G>
constexpr explicit basic_vec(G&& gen);
template<class R, class... Flags>
constexpr basic_vec(R&& range, flags<Flags...> = {});
template<class R, class... Flags>
constexpr basic_vec(R&& range, const mask_type& mask, flags<Flags...> = {});
constexpr basic_vec(const real-type & reals, const real-type & imags = {}) noexcept;
// 29.10.7.3,basic_vec subscript operators
constexpr value_type operator[](simd-size-type ) const;
template<simd-integral I>
constexpr resize_t<I::size(), basic_vec> operator[](const I& indices) const;
// 29.10.7.4,basic_vec complex accessors
constexpr real-type real() const noexcept;
constexpr real-type imag() const noexcept;
constexpr void real(const real-type & v) noexcept;
constexpr void imag(const real-type & v) noexcept;
// 29.10.7.5,basic_vec unary operators
constexpr basic_vec& operator++() noexcept;
constexpr basic_vec operator++(int) noexcept;
constexpr basic_vec& operator--() noexcept;
constexpr basic_vec operator--(int) noexcept;
constexpr mask_type operator!() const noexcept;
constexpr basic_vec operator~() const noexcept;
constexpr basic_vec operator+() const noexcept;
constexpr basic_vec operator-() const noexcept;
// 29.10.8.1,basic_vec binary operators
friend constexpr basic_vec operator+(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator-(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator*(const basic_vec&, const basic_vec&) noexcept;
§ 29.10.7.1 © ISO/IEC
1886

===== PAGE 1898 =====

Dxxxx
friend constexpr basic_vec operator/(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator%(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator&(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator|(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator^(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator<<(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator>>(const basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec operator<<(const basic_vec&, simd-size-type ) noexcept;
friend constexpr basic_vec operator>>(const basic_vec&, simd-size-type ) noexcept;
// 29.10.8.2,basic_vec compound assignment
friend constexpr basic_vec& operator+=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator-=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator*=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator/=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator%=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator&=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator|=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator^=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator<<=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator>>=(basic_vec&, const basic_vec&) noexcept;
friend constexpr basic_vec& operator<<=(basic_vec&, simd-size-type ) noexcept;
friend constexpr basic_vec& operator>>=(basic_vec&, simd-size-type ) noexcept;
// 29.10.8.3,basic_vec compare operators
friend constexpr mask_type operator==(const basic_vec&, const basic_vec&) noexcept;
friend constexpr mask_type operator!=(const basic_vec&, const basic_vec&) noexcept;
friend constexpr mask_type operator>=(const basic_vec&, const basic_vec&) noexcept;
friend constexpr mask_type operator<=(const basic_vec&, const basic_vec&) noexcept;
friend constexpr mask_type operator>(const basic_vec&, const basic_vec&) noexcept;
friend constexpr mask_type operator<(const basic_vec&, const basic_vec&) noexcept;
// 29.10.8.4,basic_vec exposition only conditional operators
friend constexpr basic_vec simd-select-impl ( // exposition only
const mask_type&, const basic_vec&, const basic_vec&) noexcept;
};
template<class R, class... Ts>
basic_vec(R&& r, Ts...) -> see below ;
template<size_t Bytes, class Abi>
basic_vec(basic_mask<Bytes, Abi>) -> see below ;
}
1 Every specialization ofbasic_vec is a complete type. The specialization ofbasic_vec<T, Abi> is
—(1.1) enabled, if T is a vectorizable type, and there exists valueN in the range[1,64], such thatAbi is
deduce-abi-t <T, N>,
—(1.2) otherwise, disabled, ifT is not a vectorizable type,
—(1.3) otherwise, it is implementation-defined if such a specialization is enabled.
If basic_vec<T, Abi>is disabled, then the specialization has a deleted default constructor, deleted destructor,
deleted copy constructor, and deleted copy assignment. In addition only thevalue_type, abi_type, and
mask_type members are present.
If basic_vec<T, Abi> is enabled, thenbasic_vec<T, Abi> is trivially copyable, default-initialization of an
object of such a type default-initializes all elements, and value-initialization value-initializes all elements (9.5.1).
2 Recommended practice: Implementations should support implicit conversions between specializations of
basic_vec and appropriate implementation-defined types.
[Note 1: Appropriate types are non-standard vector types which are available in the implementation.—end note]
3 If Tisaspecializationof complex, real-type denotesthesametypeas rebind_t<typename T::value_type,
basic_vec<T, Abi>>, otherwise an unspecified non-array object type.
§ 29.10.7.1 © ISO/IEC
1887

===== PAGE 1899 =====

Dxxxx
29.10.7.2 Constructors [simd.ctor]
template<class U> constexpr explicit(see below ) basic_vec(U&& value) noexcept;
1 Let From denote the typeremove_cvref_t<U>.
2 Constraints: U satisfies explicitly-convertible-to <value_type>.
3 Effects: Initializes each element to the value of the argument after conversion tovalue_type.
4 Remarks: The expression insideexplicit evaluates tofalse if and only ifU satisfies convertible_-
to<value_type>, and either
—(4.1) From is not an arithmetic type and does not satisfyconstexpr-wrapper-like ,
—(4.2) From is an arithmetic type and the conversion fromFrom to value_type is value-preserving
(29.10.1), or
—(4.3) Fromsatisfiesconstexpr-wrapper-like , remove_cvref_t<decltype(From::value)>is an arith-
metic type, andFrom::value is representable byvalue_type.
template<class U, class UAbi>
constexpr explicit(see below ) basic_vec(const basic_vec<U, UAbi>& x) noexcept;
5 Constraints:
—(5.1) simd-size-v <U, UAbi> == size() is true, and
—(5.2) U satisfies explicitly-convertible-to <T>.
6 Effects: Initializes theith element withstatic_cast<T>(x[i]) for alli in the range of[0,size()).
7 Remarks: The expression insideexplicit evaluates totrue if either
—(7.1) the conversion fromU to value_type is not value-preserving, or
—(7.2) both U and value_type are integral types and the integer conversion rank (6.9.6) ofU is greater
than the integer conversion rank ofvalue_type, or
—(7.3) both U and value_type are floating-point types and the floating-point conversion rank (6.9.6) of
U is greater than the floating-point conversion rank ofvalue_type.
template<class G> constexpr explicit basic_vec(G&& gen);
8 Let Fromi denote the typedecltype(gen(integral_constant<simd-size-type , i>())).
9 Constraints: Fromi satisfies convertible_to<value_type> for all i in the range of[0,size()). In
addition, for alli in the range of[0,size()), ifFromi is an arithmetic type, conversion fromFromi to
value_type is value-preserving.
10 Effects: Initializes theith element withstatic_cast<value_type>(gen(integral_constant<simd-
size-type , i>())) for alli in the range of[0,size()).
11 Remarks: gen is invoked exactly once for eachi, in increasing order ofi.
template<class R, class... Flags>
constexpr basic_vec(R&& r, flags<Flags...> = {});
template<class R, class... Flags>
constexpr basic_vec(R&& r, const mask_type& mask, flags<Flags...> = {});
12 Let mask be mask_type(true) for the overload with nomask parameter.
13 Constraints:
—(13.1) R models ranges::contiguous_range and ranges::sized_range,
—(13.2) ranges::size(r) is a constant expression,
—(13.3) ranges::size(r) is equal tosize(), and
—(13.4) ranges::range_value_t<R>is a vectorizable type and satisfiesexplicitly-convertible-to <T>.
14 Mandates: If the template parameter packFlags does not containconvert-flag , then the conversion
from ranges::range_value_t<R> to value_type is value-preserving.
15 Preconditions:
§ 29.10.7.2 © ISO/IEC
1888

===== PAGE 1900 =====

Dxxxx
—(15.1) If the template parameter packFlagscontainsaligned-flag , ranges::data(r)points to storage
aligned byalignment_v<basic_vec, ranges::range_value_t<R>>.
—(15.2) If the template parameter packFlags contains overaligned-flag <N>, ranges::data(r) points
to storage aligned byN.
16 Effects: Initializes theith element withmask[i] ? static_cast<T>(ranges::data(r)[i]) : T() for
all i in the range of[0,size()).
template<class R, class... Ts>
basic_vec(R&& r, Ts...) -> see below ;
17 Constraints:
—(17.1) R models ranges::contiguous_range and ranges::sized_range, and
—(17.2) ranges::size(r) is a constant expression.
18 Remarks: The deduced type is equivalent to
vec<ranges::range_value_t<R>, static_cast<simd-size-type >(ranges::size(r))>
template<size_t Bytes, class Abi>
basic_vec(basic_mask<Bytes, Abi> k) -> see below ;
19 Constraints: basic_mask<Bytes, Abi> is an enabled specialization ofbasic_mask and decltype(+k)
is a valid type.
20 Remarks: The deduced type is equivalent todecltype(+k).
constexpr basic_vec(const real-type & reals, const real-type & imags = {}) noexcept;
21 Constraints: simd-complex <basic_vec> is modeled.
22 Effects: Initializes the ith element with value_type(reals[i], imags[i]) for all i in the range
[0,size()).
29.10.7.3 Subscript operator [simd.subscr]
constexpr value_type operator[](simd-size-type i) const;
1 Preconditions: i >= 0 && i < size() is true.
2 Returns: The value of theith element.
3 Throws: Nothing.
template<simd-integral I>
constexpr resize_t<I::size(), basic_vec> operator[](const I& indices) const;
4 Effects: Equivalent to:return permute(*this, indices);
29.10.7.4 Complex accessors [simd.complex.access]
constexpr real-type real() const noexcept;
constexpr real-type imag() const noexcept;
1 Constraints: simd-complex <basic_vec> is modeled.
2 Returns: An object of typereal-type where theith element is initialized to the result ofcmplx-func (
operator[](i)) for alli in the range[0,size()), wherecmplx-func is the corresponding function
from <complex>.
constexpr void real(const real-type & v) noexcept;
constexpr void imag(const real-type & v) noexcept;
3 Constraints: simd-complex <basic_vec> is modeled.
4 Effects: Replaces each element of thebasic_vec object such that theith element is replaced with
value_type(v[i], operator[](i).imag()) or value_type(operator[](i).real(), v[i]) for real
and imag respectively, for alli in the range[0,size()).
29.10.7.5 Unary operators [simd.unary]
1 Effects in 29.10.7.5 are applied as unary element-wise operations.
§ 29.10.7.5 © ISO/IEC
1889

===== PAGE 1901 =====

Dxxxx
constexpr basic_vec& operator++() noexcept;
2 Constraints: requires (value_type a) { ++a; } is true.
3 Effects: Increments every element by one.
4 Returns: *this.
constexpr basic_vec operator++(int) noexcept;
5 Constraints: requires (value_type a) { a++; } is true.
6 Effects: Increments every element by one.
7 Returns: A copy of*this before incrementing.
constexpr basic_vec& operator--() noexcept;
8 Constraints: requires (value_type a) { --a; } is true.
9 Effects: Decrements every element by one.
10 Returns: *this.
constexpr basic_vec operator--(int) noexcept;
11 Constraints: requires (value_type a) { a--; } is true.
12 Effects: Decrements every element by one.
13 Returns: A copy of*this before decrementing.
constexpr mask_type operator!() const noexcept;
14 Constraints: requires (const value_type a) { !a; } is true.
15 Returns: A basic_mask object with theith element set to!operator[](i) for alli in the range of
[0,size()).
constexpr basic_vec operator~() const noexcept;
16 Constraints: requires (const value_type a) { ~a; } is true.
17 Returns: A basic_vec object with theith element set to~operator[](i) for all i in the range of
[0,size()).
constexpr basic_vec operator+() const noexcept;
18 Constraints: requires (const value_type a) { +a; } is true.
19 Returns: *this.
constexpr basic_vec operator-() const noexcept;
20 Constraints: requires (const value_type a) { -a; } is true.
21 Returns: A basic_vec object where theith element is initialized to-operator[](i) for alli in the
range of[0,size()).
29.10.8 basic_vec non-member operations [simd.nonmembers]
29.10.8.1 Binary operators [simd.binary]
friend constexpr basic_vec operator+(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator-(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator*(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator/(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator%(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator&(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator|(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator^(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator<<(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec operator>>(const basic_vec& lhs, const basic_vec& rhs) noexcept;
1 Let op be the operator.
2 Constraints: requires (value_type a, value_type b) { a op b; } is true.
§ 29.10.8.1 © ISO/IEC
1890

===== PAGE 1902 =====

Dxxxx
3 Returns: A basic_vec object initialized with the results of applyingop to lhs and rhs as a binary
element-wise operation.
friend constexpr basic_vec operator<<(const basic_vec& v, simd-size-type n) noexcept;
friend constexpr basic_vec operator>>(const basic_vec& v, simd-size-type n) noexcept;
4 Let op be the operator.
5 Constraints: requires (value_type a, simd-size-type b) { a op b; } is true.
6 Returns: A basic_vec object where theith element is initialized to the result of applyingop to v[i]
and n for alli in the range of[0,size()).
29.10.8.2 Compound assignment [simd.cassign]
friend constexpr basic_vec& operator+=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator-=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator*=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator/=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator%=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator&=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator|=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator^=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator<<=(basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr basic_vec& operator>>=(basic_vec& lhs, const basic_vec& rhs) noexcept;
1 Let op be the operator.
2 Constraints: requires (value_type a, value_type b) { a op b; } is true.
3 Effects: These operators apply the indicated operator tolhs and rhs as an element-wise operation.
4 Returns: lhs.
friend constexpr basic_vec& operator<<=(basic_vec& lhs, simd-size-type n) noexcept;
friend constexpr basic_vec& operator>>=(basic_vec& lhs, simd-size-type n) noexcept;
5 Let op be the operator.
6 Constraints: requires (value_type a, simd-size-type b) { a op b; } is true.
7 Effects: Equivalent to:return operator op (lhs, basic_vec(n));
29.10.8.3 Comparison operators [simd.comparison]
friend constexpr mask_type operator==(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr mask_type operator!=(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr mask_type operator>=(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr mask_type operator<=(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr mask_type operator>(const basic_vec& lhs, const basic_vec& rhs) noexcept;
friend constexpr mask_type operator<(const basic_vec& lhs, const basic_vec& rhs) noexcept;
1 Let op be the operator.
2 Constraints: requires (value_type a, value_type b) { a op b; } is true.
3 Returns: A basic_mask object initialized with the results of applyingop to lhs and rhs as a binary
element-wise operation.
29.10.8.4 Exposition-only conditional operators [simd.cond]
friend constexpr basic_vec
simd-select-impl (const mask_type& mask, const basic_vec& a, const basic_vec& b) noexcept;
1 Returns: A basic_vec object where theith element equalsmask[i] ? a[i] : b[i] for all i in the
range of[0,size()).
29.10.8.5 Reductions [simd.reductions]
template<class T, class Abi, class BinaryOperation = plus<>>
constexpr T reduce(const basic_vec<T, Abi>& x, BinaryOperation binary_op = {});
1 Constraints: BinaryOperation models reduction-binary-operation <T>.
§ 29.10.8.5 © ISO/IEC
1891

===== PAGE 1903 =====

Dxxxx
2 Preconditions: binary_op does not modifyx.
3 Returns: GENERALIZED_SUM(binary_op, vec<T, 1>(x[0]), ... , vec<T, 1>(x[x.size() - 1]))[
0] (26.10.2).
4 Throws: Any exception thrown frombinary_op.
template<class T, class Abi, class BinaryOperation = plus<>>
constexpr T reduce(
const basic_vec<T, Abi>& x, const typename basic_vec<T, Abi>::mask_type& mask,
BinaryOperation binary_op = {}, type_identity_t<T> identity_element = see below );
5 Constraints:
—(5.1) BinaryOperation models reduction-binary-operation <T>.
—(5.2) An argument foridentity_element is provided for the invocation, unlessBinaryOperation is
one ofplus<>, multiplies<>, bit_and<>, bit_or<>, orbit_xor<>.
6 Preconditions:
—(6.1) binary_op does not modifyx.
—(6.2) For all finite valuesy representable byT, the results ofy == binary_op(vec<T, 1>(identity-
_element), vec<T, 1>(y))[0] and y == binary_op(vec<T, 1>(y), vec<T, 1>(identity_-
element))[0] are true.
7 Returns: If none_of(mask) is true, returnsidentity_element. Otherwise, returnsGENERALIZED_-
SUM(binary_op, vec<T, 1>(x[k0]), ... , vec<T, 1>(x[kn]))[0] where k0,...,k n are the selected
indices ofmask.
8 Throws: Any exception thrown frombinary_op.
9 Remarks: The default argument foridentity_element is equal to
—(9.1) T() if BinaryOperation is plus<>,
—(9.2) T(1) if BinaryOperation is multiplies<>,
—(9.3) T(~T()) if BinaryOperation is bit_and<>,
—(9.4) T() if BinaryOperation is bit_or<>, or
—(9.5) T() if BinaryOperation is bit_xor<>.
template<class T, class Abi> constexpr T reduce_min(const basic_vec<T, Abi>& x) noexcept;
10 Constraints: T models totally_ordered.
11 Returns: The value of an element x[j] for which x[i] < x[j] is false for all i in the range of
[0,basic_vec<T, Abi>::size()).
template<class T, class Abi>
constexpr T reduce_min(
const basic_vec<T, Abi>&, const typename basic_vec<T, Abi>::mask_type&) noexcept;
12 Constraints: T models totally_ordered.
13 Returns: If none_of(mask) is true, returnsnumeric_limits<T>::max(). Otherwise, returns the value
of a selected elementx[j] for whichx[i] < x[j] is false for all selected indicesi of mask.
template<class T, class Abi> constexpr T reduce_max(const basic_vec<T, Abi>& x) noexcept;
14 Constraints: T models totally_ordered.
15 Returns: The value of an element x[j] for which x[j] < x[i] is false for all i in the range of
[0,basic_vec<T, Abi>::size()).
template<class T, class Abi>
constexpr T reduce_max(
const basic_vec<T, Abi>&, const typename basic_vec<T, Abi>::mask_type&) noexcept;
16 Constraints: T models totally_ordered.
§ 29.10.8.5 © ISO/IEC
1892

===== PAGE 1904 =====

Dxxxx
17 Returns: If none_of(mask) is true, returns numeric_limits<V::value_type>::lowest(). Other-
wise, returns the value of a selected elementx[j] for whichx[j] < x[i] is false for all selected indices
i of mask.
29.10.8.6 Load and store functions [simd.loadstore]
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_load(R&& r, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_load(R&& r, const typename V::mask_type& mask, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V unchecked_load(I first, iter_difference_t<I> n, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V unchecked_load(I first, iter_difference_t<I> n, const typename V::mask_type& mask,
flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V unchecked_load(I first, S last, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V unchecked_load(I first, S last, const typename V::mask_type& mask,
flags<Flags...> f = {});
1 Let
—(1.1) mask be V::mask_type(true) for the overloads with nomask parameter;
—(1.2) R be span<const iter_value_t<I>> for the overloads with no template parameterR;
—(1.3) r be R(first, n) for the overloads with ann parameter andR(first, last) for the overloads
with alast parameter.
2 Mandates: If ranges::size(r) is a constant expression thenranges::size(r) ≥V::size().
3 Preconditions:
—(3.1) [first,first + n) is a valid range for the overloads with ann parameter.
—(3.2) [first,last) is a valid range for the overloads with alast parameter.
—(3.3) ranges::size(r) ≥V::size()
4 Effects: Equivalent to:return partial_load<V>(r, mask, f);
5 Remarks: The default argument for template parameterV is basic_vec<ranges::range_value_t<R>>.
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_load(R&& r, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_load(R&& r, const typename V::mask_type& mask, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V partial_load(I first, iter_difference_t<I> n, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, class... Flags>
constexpr V partial_load(I first, iter_difference_t<I> n, const typename V::mask_type& mask,
flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V partial_load(I first, S last, flags<Flags...> f = {});
template<class V = see below , contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr V partial_load(I first, S last, const typename V::mask_type& mask,
flags<Flags...> f = {});
6 Let
—(6.1) mask be V::mask_type(true) for the overloads with nomask parameter;
—(6.2) R be span<const iter_value_t<I>> for the overloads with no template parameterR;
—(6.3) r be R(first, n) for the overloads with ann parameter andR(first, last) for the overloads
with alast parameter;
§ 29.10.8.6 © ISO/IEC
1893

===== PAGE 1905 =====

Dxxxx
—(6.4) T be typename V::value_type.
7 Mandates:
—(7.1) ranges::range_value_t<R>is a vectorizable type and satisfiesexplicitly-convertible-to <T>,
—(7.2) same_as<remove_cvref_t<V>, V> is true,
—(7.3) V is an enabled specialization ofbasic_vec, and
—(7.4) if the template parameter packFlags does not containconvert-flag , then the conversion from
ranges::range_value_t<R> to V::value_type is value-preserving.
8 Preconditions:
—(8.1) [first,first + n) is a valid range for the overloads with ann parameter.
—(8.2) [first,last) is a valid range for the overloads with alast parameter.
—(8.3) If the template parameter packFlagscontainsaligned-flag , ranges::data(r)points to storage
aligned byalignment_v<V, ranges::range_value_t<R>>.
—(8.4) If the template parameter packFlags contains overaligned-flag <N>, ranges::data(r) points
to storage aligned byN.
9 Returns: A basic_vec object whoseith element is initialized withmask[i] && i < ranges::size(r)
? static_cast<T>(ranges::data(r)[i]) : T() for alli in the range of[0,V::size()), whereT is
V::value_type.
10 Remarks: The default argument for template parameterV is basic_vec<ranges::range_value_t<R>>.
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, R&& r, flags<Flags...> f = {});
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, R&& r,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, S last,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, S last,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
11 Let
—(11.1) mask be basic_vec<T, Abi>::mask_type(true) for the overloads with nomask parameter;
—(11.2) R be span<iter_value_t<I>> for the overloads with no template parameterR;
—(11.3) r be R(first, n) for the overloads with ann parameter andR(first, last) for the overloads
with alast parameter.
12 Mandates: If ranges::size(r) is a constant expression thenranges::size(r) ≥simd-size-v <T,
Abi>.
13 Preconditions:
—(13.1) [first,first + n) is a valid range for the overloads with ann parameter.
—(13.2) [first,last) is a valid range for the overloads with alast parameter.
—(13.3) ranges::size(r) ≥simd-size-v <T, Abi>
14 Effects: Equivalent to:partial_store(v, r, mask, f).
§ 29.10.8.6 © ISO/IEC
1894

===== PAGE 1906 =====

Dxxxx
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void partial_store(const basic_vec<T, Abi>& v, R&& r, flags<Flags...> f = {});
template<class T, class Abi, ranges::contiguous_range R, class... Flags>
requires ranges::sized_range<R>
constexpr void partial_store(const basic_vec<T, Abi>& v, R&& r,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void partial_store(const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, class... Flags>
constexpr void partial_store(const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void partial_store(const basic_vec<T, Abi>& v, I first, S last,
flags<Flags...> f = {});
template<class T, class Abi, contiguous_iterator I, sized_sentinel_for<I> S, class... Flags>
constexpr void partial_store(const basic_vec<T, Abi>& v, I first, S last,
const typename basic_vec<T, Abi>::mask_type& mask,
flags<Flags...> f = {});
15 Let
—(15.1) mask be basic_vec<T, Abi>::mask_type(true) for the overloads with nomask parameter;
—(15.2) R be span<iter_value_t<I>> for the overloads with no template parameterR;
—(15.3) r be R(first, n) for the overloads with ann parameter andR(first, last) for the overloads
with alast parameter.
16 Constraints:
—(16.1) ranges::iterator_t<R> models indirectly_writable<ranges::range_value_t<R>>, and
—(16.2) T satisfies explicitly-convertible-to <ranges::range_value_t<R>>.
17 Mandates:
—(17.1) ranges::range_value_t<R> is a vectorizable type, and
—(17.2) if the template parameter packFlags does not containconvert-flag , then the conversion from
T to ranges::range_value_t<R> is value-preserving.
18 Preconditions:
—(18.1) [first,first + n) is a valid range for the overloads with ann parameter.
—(18.2) [first,last) is a valid range for the overloads with alast parameter.
—(18.3) If the template parameter packFlagscontainsaligned-flag , ranges::data(r)points to storage
aligned byalignment_v<basic_vec<T, Abi>, ranges::range_value_t<R>>.
—(18.4) If the template parameter packFlags contains overaligned-flag <N>, ranges::data(r) points
to storage aligned byN.
19 Effects: For all i in the range of [0,basic_vec<T, Abi>::size()), if mask[i] && i < ranges::
size(r) is true, evaluates ranges::data(r)[i] = static_cast<ranges::range_value_t<R>>(v[
i]).
29.10.8.7 Static permute [simd.permute.static]
template<simd-size-type N = see below , simd-vec-type V, class IdxMap>
constexpr resize_t<N, V> permute(const V& v, IdxMap&& idxmap);
template<simd-size-type N = see below , simd-mask-type M, class IdxMap>
constexpr resize_t<N, M> permute(const M& v, IdxMap&& idxmap);
1 Let:
—(1.1) gen-fn (i) be idxmap(i, V::size()) if that expression is well-formed, andidxmap(i) otherwise.
—(1.2) perm-fn be the following exposition-only function template:
§ 29.10.8.7 © ISO/IEC
1895

===== PAGE 1907 =====

Dxxxx
template<simd-size-type I>
typename V::value_type perm-fn () {
constexpr auto src_index = gen-fn (I);
if constexpr (src_index == zero_element) {
return typename V::value_type();
} else if constexpr (src_index == uninit_element) {
return unspecified-value ;
} else {
return v[src_index];
}
}
2 Constraints: At least one ofinvoke_result_t<IdxMap&, simd-size-type > and invoke_result_-
t<IdxMap&, simd-size-type , simd-size-type > satisfies integral.
3 Mandates: gen-fn (i) is a constant expression whose value iszero_element, uninit_element, or in
the range[0,V::size()), for alli in the range[0,N).
4 Returns: A data-parallel object where theith element is initialized to the result ofperm-fn <i>() for
all i in the range[0,N).
5 Remarks: The default argument for template parameterN is V::size().
29.10.8.8 Dynamic permute [simd.permute.dynamic]
template<simd-vec-type V, simd-integral I>
constexpr resize_t<I::size(), V> permute(const V& v, const I& indices);
template<simd-mask-type M, simd-integral I>
constexpr resize_t<I::size(), M> permute(const M& v, const I& indices);
1 Preconditions: All values inindices are in the range[0,V::size()).
2 Returns: A data-parallel object where theith element is initialized to the result ofv[indices[i]] for
all i in the range[0,I::size()).
29.10.8.9 Mask permute [simd.permute.mask]
template<simd-vec-type V>
constexpr V compress(const V& v, const typename V::mask_type& selector);
template<simd-mask-type M>
constexpr M compress(const M& v, const type_identity_t<M>& selector);
1 Let:
—(1.1) bit-index(i) be a function which returns the index of theith element ofselector that istrue.
—(1.2) select-value(i) be a function which returnsv[bit-index(i)] for i in the range[0,reduce_-
count(selector)) and a valid but unspecified value otherwise.
[Note 1: Different calls toselect-value can return different unspecified values.—end note]
2 Returns: A data-parallel object where theith element is initialized to the result ofselect-value(i)
for alli in the range[0,V::size()).
template<simd-vec-type V>
constexpr V compress(const V& v, const typename V::mask_type& selector,
const typename V::value_type& fill_value);
template<simd-mask-type M>
constexpr M compress(const M& v, const type_identity_t<M>& selector,
const typename M::value_type& fill_value);
3 Let:
—(3.1) bit-index(i) be a function which returns the index of theith element ofselector that istrue.
—(3.2) select-value(i) be a function which returnsv[bit-index(i)] for i in the range[0,reduce_-
count(selector)) and fill_value otherwise.
4 Returns: A data-parallel object where theith element is initialized to the result ofselect-value(i)
for alli in the range[0,V::size()).
§ 29.10.8.9 © ISO/IEC
1896

===== PAGE 1908 =====

Dxxxx
template<simd-vec-type V>
constexpr V expand(const V& v, const typename V::mask_type& selector, const V& original = {});
template<simd-mask-type M>
constexpr M expand(const M& v, const type_identity_t<M>& selector, const M& original = {});
5 Let:
—(5.1) set-indices be a list of the index positions oftrue elements inselector, in ascending order.
—(5.2) bit-lookup(b) be a function which returns the index whereb appears inset-indices .
—(5.3) select-value(i) be a function which returnsv[bit-lookup(i)] if selector[i] is true, other-
wise returnsoriginal[i].
6 Returns: A data-parallel object where theith element is initialized to the result ofselect-value(i)
for alli in the range[0,V::size()).
29.10.8.10 Memory permute [simd.permute.memory]
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_gather_from(R&& in, const I& indices, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V unchecked_gather_from(R&& in, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
1 Let mask be typename I::mask_type(true) for the overload with nomask parameter.
2 Preconditions: All values inselect(mask, indices, typename I::value_type()) are in the range
[0,ranges::size(in)).
3 Effects: Equivalent to:return partial_gather_from<V>(in, mask, indices, f);
4 Remarks: The default argument for template parameterV is vec<ranges::range_value_t<R>, I::
size()>.
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_gather_from(R&& in, const I& indices, flags<Flags...> f = {});
template<class V = see below , ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr V partial_gather_from(R&& in, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
5 Let:
—(5.1) mask be typename I::mask_type(true) for the overload with nomask parameter;
—(5.2) T be typename V::value_type.
6 Constraints: ranges::range_value_t<R> is a vectorizable type and satisfiesexplicitly-convert-
ible-to <T>.
7 Mandates:
—(7.1) ranges::range_value_t<R> is a vectorizable type,
—(7.2) same_as<remove_cvref_t<V>, V> is true,
—(7.3) V is an enabled specialization ofbasic_vec,
—(7.4) V::size() == I::size() is true, and
—(7.5) if the template parameter packFlags does not containconvert-flag , then the conversion from
ranges::range_value_t<R> to T is value-preserving.
8 Preconditions:
—(8.1) If the template parameter packFlags contains aligned-flag , ranges::data(in) points to
storage aligned byalignment_v<V, ranges::range_value_t<R>>.
—(8.2) If the template parameter packFlags contains overaligned-flag <N>, ranges::data(in) points
to storage aligned byN.
§ 29.10.8.10 © ISO/IEC
1897

===== PAGE 1909 =====

Dxxxx
9 Returns: A basic_vec object where theith element is initialized to the result of
mask[i] && indices[i] < ranges::size(in) ? static_cast<T>(ranges::data(in)[indices[i]]) : T()
for alli in the range[0,I::size()).
10 Remarks: The default argument for template parameterV is vec<ranges::range_value_t<R>, I::
size()>.
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_scatter_to(const V& v, R&& out, const I& indices,
flags<Flags...> f = {});
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void unchecked_scatter_to(const V& v, R&& out, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
11 Let mask be typename I::mask_type(true) for the overload with nomask parameter.
12 Preconditions: All values inselect(mask, indices, typename I::value_type()) are in the range
[0,ranges::size(out)).
13 Effects: Equivalent to:partial_scatter_to(v, out, mask, indices, f);
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void
partial_scatter_to(const V& v, R&& out, const I& indices, flags<Flags...> f = {});
template<simd-vec-type V, ranges::contiguous_range R, simd-integral I, class... Flags>
requires ranges::sized_range<R>
constexpr void partial_scatter_to(const V& v, R&& out, const typename I::mask_type& mask,
const I& indices, flags<Flags...> f = {});
14 Let mask be typename I::mask_type(true) for the overload with nomask parameter.
15 Constraints:
—(15.1) V::size() == I::size() is true,
—(15.2) ranges::iterator_t<R> models indirectly_writable<ranges::range_value_t<R>>, and
—(15.3) typename V::value_type satisfies explicitly-convertible-to <ranges::range_value_t<R
>>.
16 Mandates:
—(16.1) ranges::range_value_t<R> is a vectorizable type, and
—(16.2) if the template parameter packFlags does not containconvert-flag , then the conversion from
typename V::value_type to ranges::range_value_t<R> is value-preserving.
17 Preconditions:
—(17.1) For all selected indicesi the valuesindices[i] are unique.
—(17.2) If the template parameter packFlags contains aligned-flag , ranges::data(out) points to
storage aligned byalignment_v<V, ranges::range_value_t<R>>.
—(17.3) If the template parameter pack Flags contains overaligned-flag <N>, ranges::data(out)
points to storage aligned byN.
18 Effects: For alli in the range[0,I::size()), ifmask[i] && (indices[i] < ranges::size(out)) is
true, evaluatesranges::data(out)[indices[i]] = static_cast<ranges::range_value_t<R>>(v[
i]).
29.10.8.11 Creation [simd.creation]
template<class T, class Abi>
constexpr auto chunk(const basic_vec<typename T::value_type, Abi>& x) noexcept;
template<class T, class Abi>
constexpr auto chunk(const basic_mask<mask-element-size <T>, Abi>& x) noexcept;
1 Constraints:
§ 29.10.8.11 © ISO/IEC
1898

===== PAGE 1910 =====

Dxxxx
—(1.1) For the first overload,T is an enabled specialization ofbasic_vec. If basic_vec<typename T::
value_type, Abi>::size() % T::size() is not 0, then resize_t<basic_vec<typename T::
value_type, Abi>::size() % T::size(), T> is valid and denotes a type.
—(1.2) For the second overload,T is an enabled specialization ofbasic_mask. If basic_mask<mask-el-
ement-size <T>, Abi>::size() % T::size() is not0, thenresize_t<basic_mask<mask-ele-
ment-size <T>, Abi>::size() % T::size(), T> is valid and denotes a type.
2 Let N be x.size() / T::size().
3 Returns:
—(3.1) If x.size() % T::size() == 0is true, anarray<T, N>with theith basic_vecor basic_mask
element of thejth array element initialized to the value of the element inx with indexi + j *
T::size().
—(3.2) Otherwise, a tuple of N objects of type T and one object of type resize_t<x.size() %
T::size(), T>. The ith basic_vec or basic_mask element of thejth tuple element of typeT is
initialized to the value of the element inx with indexi + j * T::size(). The ith basic_vec or
basic_mask element of theNth tuple element is initialized to the value of the element inx with
index i + N * T::size().
template<simd-size-type N, class T, class Abi>
constexpr auto chunk(const basic_vec<T, Abi>& x) noexcept;
4 Effects: Equivalent to:return chunk<resize_t<N, basic_vec<T, Abi>>>(x);
template<simd-size-type N, size_t Bytes, class Abi>
constexpr auto chunk(const basic_mask<Bytes, Abi>& x) noexcept;
5 Effects: Equivalent to:return chunk<resize_t<N, basic_mask<Bytes, Abi>>>(x);
template<class T, class... Abis>
constexpr vec<T, (basic_vec<T, Abis>::size() + ...)>
cat(const basic_vec<T, Abis>&... xs) noexcept;
template<size_t Bytes, class... Abis>
constexpr basic_mask<Bytes, deduce-abi-t <integer-from <Bytes>,
(basic_mask<Bytes, Abis>::size() + ...)>>
cat(const basic_mask<Bytes, Abis>&... xs) noexcept;
6 Constraints:
—(6.1) For the first overloadvec<T, (basic_vec<T, Abis>::size() + ...)> is enabled.
—(6.2) For the second overloadbasic_mask<Bytes, deduce-abi-t <integer-from <Bytes>, (basic_-
mask<Bytes, Abis>::size() + ...)>> is enabled.
7 Returns: A data-parallel object initialized with the concatenated values in thexs pack of data-parallel
objects: The ith basic_vec/basic_mask element of thejth parameter in thexs pack is copied to the
return value’s element with indexi + the sum of the width of the firstj parameters in thexs pack.
29.10.8.12 Algorithms [simd.alg]
template<class T, class Abi>
constexpr basic_vec<T, Abi> min(const basic_vec<T, Abi>& a,
const basic_vec<T, Abi>& b) noexcept;
1 Constraints: T models totally_ordered.
2 Returns: The result of the element-wise application of min(a[i], b[i]) for all i in the range of
[0,basic_vec<T, Abi>::size()).
template<class T, class Abi>
constexpr basic_vec<T, Abi> max(const basic_vec<T, Abi>& a,
const basic_vec<T, Abi>& b) noexcept;
3 Constraints: T models totally_ordered.
4 Returns: The result of the element-wise application of max(a[i], b[i]) for all i in the range of
[0,basic_vec<T, Abi>::size()).
§ 29.10.8.12 © ISO/IEC
1899

===== PAGE 1911 =====

Dxxxx
template<class T, class Abi>
constexpr pair<basic_vec<T, Abi>, basic_vec<T, Abi>>
minmax(const basic_vec<T, Abi>& a, const basic_vec<T, Abi>& b) noexcept;
5 Effects: Equivalent to:return pair{min(a, b), max(a, b)};
template<class T, class Abi>
constexpr basic_vec<T, Abi> clamp(
const basic_vec<T, Abi>& v, const basic_vec<T, Abi>& lo, const basic_vec<T, Abi>& hi);
6 Constraints: T models totally_ordered.
7 Preconditions: No element inlo is greater than the corresponding element inhi.
8 Returns: The result of element-wise application ofclamp(v[i], lo[i], hi[i]) for alli in the range
of [0,basic_vec<T, Abi>::size()).
template<class T, class U>
constexpr auto select(bool c, const T& a, const U& b)
-> remove_cvref_t<decltype(c ? a : b)>;
9 Effects: Equivalent to:return c ? a : b;
template<size_t Bytes, class Abi, class T, class U>
constexpr auto select(const basic_mask<Bytes, Abi>& c, const T& a, const U& b)
noexcept -> decltype(simd-select-impl (c, a, b));
10 Effects: Equivalent to:
return simd-select-impl (c, a, b);
where simd-select-impl is found by argument-dependent lookup (6.5.4) contrary to 16.4.2.2.
29.10.8.13 Mathematical functions [simd.math]
template<math-floating-point V>
constexpr rebind_t<int, deduced-vec-t <V>> ilogb(const V& x);
template<math-floating-point V>
constexpr deduced-vec-t <V> ldexp(const V& x, const rebind_t<int, deduced-vec-t <V>>& exp);
template<math-floating-point V>
constexpr deduced-vec-t <V> scalbn(const V& x, const rebind_t<int, deduced-vec-t <V>>& n);
template<math-floating-point V>
constexpr deduced-vec-t <V>
scalbln(const V& x, const rebind_t<long int, deduced-vec-t <V>>& n);
template<signed_integral T, class Abi>
constexpr basic_vec<T, Abi> abs(const basic_vec<T, Abi>& j);
template<math-floating-point V>
constexpr deduced-vec-t <V> abs(const V& j);
template<math-floating-point V>
constexpr deduced-vec-t <V> fabs(const V& x);
template<math-floating-point V>
constexpr deduced-vec-t <V> ceil(const V& x);
template<math-floating-point V>
constexpr deduced-vec-t <V> floor(const V& x);
template<math-floating-point V>
deduced-vec-t <V> nearbyint(const V& x);
template<math-floating-point V>
deduced-vec-t <V> rint(const V& x);
template<math-floating-point V>
rebind_t<long int, deduced-vec-t <V>> lrint(const V& x);
template<math-floating-point V>
rebind_t<long long int, deduced-vec-t <V>> llrint(const V& x);
template<math-floating-point V>
constexpr deduced-vec-t <V> round(const V& x);
template<math-floating-point V>
constexpr rebind_t<long int, deduced-vec-t <V>> lround(const V& x);
template<math-floating-point V>
constexpr rebind_t<long long int, deduced-vec-t <V>> llround(const V& x);
§ 29.10.8.13 © ISO/IEC
1900

===== PAGE 1912 =====

Dxxxx
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fmod(const V0& x, const V1& y);
template<math-floating-point V>
constexpr deduced-vec-t <V> trunc(const V& x);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> remainder(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> copysign(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> nextafter(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fdim(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fmax(const V0& x, const V1& y);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> fmin(const V0& x, const V1& y);
template<class V0, class V1, class V2>
constexpr math-common-simd-t <V0, V1, V2> fma(const V0& x, const V1& y, const V2& z);
template<math-floating-point V>
constexpr rebind_t<int, deduced-vec-t <V>> fpclassify(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isfinite(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isinf(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isnan(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type isnormal(const V& x);
template<math-floating-point V>
constexpr typename deduced-vec-t <V>::mask_type signbit(const V& x);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type isgreater(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type
isgreaterequal(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type isless(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type islessequal(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type islessgreater(const V0& x, const V1& y);
template<class V0, class V1>
constexpr typename math-common-simd-t <V0, V1>::mask_type isunordered(const V0& x, const V1& y);
1 Let Ret denote the return type of the specialization of a function template with the namemath-func .
Let math-func-vec denote:
template<class... Args>
Ret math-func-vec (Args... args) {
return Ret([&](simd-size-type i) {
return math-func (make-compatible-simd-t <Ret, Args>(args)[i]...);
});
}
2 Returns: A valueret of typeRet, that is element-wise equal to the result of callingmath-func-vec
with the arguments of the above functions. If in an invocation of a scalar overload ofmath-func
for index i in math-func-vec a domain, pole, or range error would occur, the value ofret[i] is
unspecified.
3 Remarks: It is unspecified whethererrno (19.4) is accessed.
template<math-floating-point V> constexpr deduced-vec-t <V> acos(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> asin(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> atan(const V& x);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> atan2(const V0& y, const V1& x);
§ 29.10.8.13 © ISO/IEC
1901

===== PAGE 1913 =====

Dxxxx
template<math-floating-point V> constexpr deduced-vec-t <V> cos(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> sin(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> tan(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> acosh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> asinh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> atanh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> cosh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> sinh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> tanh(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> exp(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> exp2(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> expm1(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> log(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> log10(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> log1p(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> log2(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> logb(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> cbrt(const V& x);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> hypot(const V0& x, const V1& y);
template<class V0, class V1, class V2>
constexpr math-common-simd-t <V0, V1, V2> hypot(const V0& x, const V1& y, const V2& z);
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> pow(const V0& x, const V1& y);
template<math-floating-point V> constexpr deduced-vec-t <V> sqrt(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> erf(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> erfc(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> lgamma(const V& x);
template<math-floating-point V> constexpr deduced-vec-t <V> tgamma(const V& x);
template<class V0, class V1, class V2>
constexpr math-common-simd-t <V0, V1, V2> lerp(const V0& a, const V1& b, const V2& t) noexcept;
template<math-floating-point V>
deduced-vec-t <V> assoc_laguerre(const rebind_t<unsigned, deduced-vec-t <V>>& n, const
rebind_t<unsigned, deduced-vec-t <V>>& m, const V& x);
template<math-floating-point V>
deduced-vec-t <V> assoc_legendre(const rebind_t<unsigned, deduced-vec-t <V>>& l, const
rebind_t<unsigned, deduced-vec-t <V>>& m, const V& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> beta(const V0& x, const V1& y);
template<math-floating-point V> deduced-vec-t <V> comp_ellint_1(const V& k);
template<math-floating-point V> deduced-vec-t <V> comp_ellint_2(const V& k);
template<class V0, class V1>
math-common-simd-t <V0, V1> comp_ellint_3(const V0& k, const V1& nu);
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_bessel_i(const V0& nu, const V1& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_bessel_j(const V0& nu, const V1& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_bessel_k(const V0& nu, const V1& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> cyl_neumann(const V0& nu, const V1& x);
template<class V0, class V1>
math-common-simd-t <V0, V1> ellint_1(const V0& k, const V1& phi);
template<class V0, class V1>
math-common-simd-t <V0, V1> ellint_2(const V0& k, const V1& phi);
template<class V0, class V1, class V2>
math-common-simd-t <V0, V1, V2> ellint_3(const V0& k, const V1& nu, const V2& phi);
template<math-floating-point V> deduced-vec-t <V> expint(const V& x);
template<math-floating-point V> deduced-vec-t <V> hermite(const rebind_t<unsigned,
deduced-vec-t <V>>& n, const V& x);
template<math-floating-point V> deduced-vec-t <V> laguerre(const rebind_t<unsigned,
deduced-vec-t <V>>& n, const V& x);
template<math-floating-point V> deduced-vec-t <V> legendre(const rebind_t<unsigned,
deduced-vec-t <V>>& l, const V& x);
§ 29.10.8.13 © ISO/IEC
1902

===== PAGE 1914 =====

Dxxxx
template<math-floating-point V> deduced-vec-t <V> riemann_zeta(const V& x);
template<math-floating-point V> deduced-vec-t <V> sph_bessel(const rebind_t<unsigned,
deduced-vec-t <V>>& n, const V& x);
template<math-floating-point V>
deduced-vec-t <V> sph_legendre(const rebind_t<unsigned, deduced-vec-t <V>>& l,
const rebind_t<unsigned, deduced-vec-t <V>>& m,
const V& theta);
template<math-floating-point V> deduced-vec-t <V> sph_neumann(const rebind_t<unsigned,
deduced-vec-t <V>>& n, const V& x);
4 Let Ret denote the return type of the specialization of a function template with the namemath-func .
Let math-func-vec denote:
template<class... Args>
Ret math-func-vec (Args... args) {
return Ret([&](simd-size-type i) {
return math-func (make-compatible-simd-t <Ret, Args>(args)[i]...);
});
}
5 Returns: A valueret of typeRet, that is element-wise approximately equal to the result of calling
math-func-vec with the arguments of the above functions. If in an invocation of a scalar overload
of math-func for indexi in math-func-vec a domain, pole, or range error would occur, the value of
ret[i] is unspecified.
6 Remarks: It is unspecified whethererrno (19.4) is accessed.
template<math-floating-point V>
constexpr deduced-vec-t <V> frexp(const V& value, rebind_t<int, deduced-vec-t <V>>* exp);
7 Let Ret be deduced-vec-t <V>. Let frexp-vec denote:
template<class V>
pair<Ret, rebind_t<int, Ret>> frexp-vec (const V& x) {
int r1[Ret::size()];
Ret r0([&](simd-size-type i) {
return frexp(make-compatible-simd-t <Ret, V>(x)[i], &r1[i]);
});
return {r0, rebind_t<int, Ret>(r1)};
}
Let ret be a value of typepair<Ret, rebind_t<int, Ret>> that is the same value as the result of
calling frexp-vec (x).
8 Effects: Sets *exp to ret.second.
9 Returns: ret.first.
template<class V0, class V1>
constexpr math-common-simd-t <V0, V1> remquo(const V0& x, const V1& y,
rebind_t<int, math-common-simd-t <V0, V1>>* quo);
10 Let Ret be math-common-simd-t <V0, V1>. Let remquo-vec denote:
template<class V0, class V1>
pair<Ret, rebind_t<int, Ret>> remquo-vec (const V0& x, const V1& y) {
int r1[Ret::size()];
Ret r0([&](simd-size-type i) {
return remquo(make-compatible-simd-t <Ret, V0>(x)[i],
make-compatible-simd-t <Ret, V1>(y)[i], &r1[i]);
});
return {r0, rebind_t<int, Ret>(r1)};
}
Let ret be a value of typepair<Ret, rebind_t<int, Ret>> that is the same value as the result of
calling remquo-vec (x, y). If in an invocation of a scalar overload ofremquo for indexi in remquo-vec
a domain, pole, or range error would occur, the value ofret[i] is unspecified.
11 Effects: Sets *quo to ret.second.
12 Returns: ret.first.
§ 29.10.8.13 © ISO/IEC
1903

===== PAGE 1915 =====

Dxxxx
13 Remarks: It is unspecified whethererrno (19.4) is accessed.
template<class T, class Abi>
constexpr basic_vec<T, Abi> modf(const type_identity_t<basic_vec<T, Abi>>& value,
basic_vec<T, Abi>* iptr);
14 Let V be basic_vec<T, Abi>. Let modf-vec denote:
pair<V, V> modf-vec (const V& x) {
T r1[Ret::size()];
V r0([&](simd-size-type i) {
return modf(V(x)[i], &r1[i]);
});
return {r0, V(r1)};
}
Let ret be a value of typepair<V, V> that is the same value as the result of callingmodf-vec (value).
15 Effects: Sets *iptr to ret.second.
16 Returns: ret.first.
29.10.8.14 Bit manipulation [simd.bit]
template<simd-vec-type V> constexpr V byteswap(const V& v) noexcept;
1 Constraints: The typeV::value_type models integral.
2 Returns: Abasic_vec object where theith element is initialized to the result ofstd::byteswap(v[i])
for alli in the range[0,V::size()).
template<simd-vec-type V> constexpr V bit_ceil(const V& v);
3 Constraints: The typeV::value_type is an unsigned integer type (6.9.2).
4 Preconditions: For everyiin the range[0,V::size()), the smallest power of 2 greater than or equal to
v[i] is representable as a value of typeV::value_type.
5 Returns: Abasic_vec object where theith element is initialized to the result ofstd::bit_ceil(v[i])
for alli in the range[0,V::size()).
6 Remarks: A function call expression that violates the precondition in thePreconditions: element is not
a core constant expression (7.7).
template<simd-vec-type V> constexpr V bit_floor(const V& v) noexcept;
7 Constraints: The typeV::value_type is an unsigned integer type (6.9.2).
8 Returns: Abasic_vecobject where theith element is initialized to the result ofstd::bit_floor(v[i])
for alli in the range[0,V::size()).
template<simd-vec-type V>
constexpr typename V::mask_type has_single_bit(const V& v) noexcept;
9 Constraints: The typeV::value_type is an unsigned integer type (6.9.2).
10 Returns: A basic_mask object where theith element is initialized to the result ofstd::has_single_-
bit(v[i]) for alli in the range[0,V::size()).
template<simd-vec-type V0, simd-vec-type V1>
constexpr V0 rotl(const V0& v0, const V1& v1) noexcept;
template<simd-vec-type V0, simd-vec-type V1>
constexpr V0 rotr(const V0& v0, const V1& v1) noexcept;
11 Constraints:
—(11.1) The typeV0::value_type is an unsigned integer type (6.9.2),
—(11.2) the typeV1::value_type models integral,
—(11.3) V0::size() == V1::size() is true, and
—(11.4) sizeof(typename V0::value_type) == sizeof(typename V1::value_type) is true.
§ 29.10.8.14 © ISO/IEC
1904

===== PAGE 1916 =====

Dxxxx
12 Returns: A basic_vec object where theith element is initialized to the result ofbit-func (v0[i],
static_cast<int>(v1[i]))for alliin the range[0,V0::size()), wherebit-func is the corresponding
scalar function from<bit>.
template<simd-vec-type V> constexpr V rotl(const V& v, int s) noexcept;
template<simd-vec-type V> constexpr V rotr(const V& v, int s) noexcept;
13 Constraints: The typeV::value_type is an unsigned integer type (6.9.2).
14 Returns: A basic_vec object where theith element is initialized to the result ofbit-func (v[i], s)
for alli in the range[0,V::size()), wherebit-func is the corresponding scalar function from<bit>.
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V> bit_width(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V> countl_zero(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V> countl_one(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V> countr_zero(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V> countr_one(const V& v) noexcept;
template<simd-vec-type V>
constexpr rebind_t<make_signed_t<typename V::value_type>, V> popcount(const V& v) noexcept;
15 Constraints: The typeV::value_type is an unsigned integer type (6.9.2).
16 Returns: A basic_vec object where theith element is initialized to the result ofbit-func (v[i]) for
all i in the range[0,V::size()), wherebit-func is the corresponding scalar function from<bit>.
29.10.8.15 Complex math [simd.complex.math]
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> real(const V&) noexcept;
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> imag(const V&) noexcept;
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> abs(const V&);
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> arg(const V&);
template<simd-complex V>
constexpr rebind_t<simd-complex-value-type<V> , V> norm(const V&);
template<simd-complex V> constexpr V conj(const V&);
template<simd-complex V> constexpr V proj(const V&);
template<simd-complex V> constexpr V exp(const V& v);
template<simd-complex V> constexpr V log(const V& v);
template<simd-complex V> constexpr V log10(const V& v);
template<simd-complex V> constexpr V sqrt(const V& v);
template<simd-complex V> constexpr V sin(const V& v);
template<simd-complex V> constexpr V asin(const V& v);
template<simd-complex V> constexpr V cos(const V& v);
template<simd-complex V> constexpr V acos(const V& v);
template<simd-complex V> constexpr V tan(const V& v);
template<simd-complex V> constexpr V atan(const V& v);
template<simd-complex V> constexpr V sinh(const V& v);
template<simd-complex V> constexpr V asinh(const V& v);
template<simd-complex V> constexpr V cosh(const V& v);
template<simd-complex V> constexpr V acosh(const V& v);
template<simd-complex V> constexpr V tanh(const V& v);
template<simd-complex V> constexpr V atanh(const V& v);
1 Returns: Abasic_vec object ret where theith element is initialized to the result ofcmplx-func (v[i])
for alliin the range[0,V::size()), wherecmplx-func is the corresponding function from<complex>.
§ 29.10.8.15 © ISO/IEC
1905

===== PAGE 1917 =====

Dxxxx
If in an invocation ofcmplx-func for indexi a domain, pole, or range error would occur, the value of
ret[i] is unspecified.
2 Remarks: It is unspecified whethererrno (19.4) is accessed.
template<simd-floating-point V>
rebind_t<complex<typename V::value_type>, V> polar(const V& x, const V& y = {});
template<simd-complex V> constexpr V pow(const V& x, const V& y);
3 Returns: Abasic_vec object ret where theith element is initialized to the result ofcmplx-func (x[i],
y[i]) for all i in the range[0,V::size()), where cmplx-func is the corresponding function from
<complex>. If in an invocation ofcmplx-func for indexi a domain, pole, or range error would occur,
the value ofret[i] is unspecified.
4 Remarks: It is unspecified whethererrno (19.4) is accessed.
29.10.9 Class template basic_mask [simd.mask.class]
29.10.9.1 Overview [simd.mask.overview]
namespace std::simd {
template<size_t Bytes, class Abi> class basic_mask {
public:
using value_type = bool;
using abi_type = Abi;
using iterator = simd-iterator <basic_mask>;
using const_iterator = simd-iterator <const basic_mask>;
constexpr iterator begin() noexcept { return {*this, 0}; }
constexpr const_iterator begin() const noexcept { return {*this, 0}; }
constexpr const_iterator cbegin() const noexcept { return {*this, 0}; }
constexpr default_sentinel_t end() const noexcept { return {}; }
constexpr default_sentinel_t cend() const noexcept { return {}; }
static constexpr integral_constant<simd-size-type , simd-size-v <integer-from <Bytes>, Abi>>
size {};
constexpr basic_mask() noexcept = default;
// 29.10.9.2,basic_mask constructors
constexpr explicit basic_mask(same_as<value_type> auto) noexcept;
template<size_t UBytes, class UAbi>
constexpr explicit basic_mask(const basic_mask<UBytes, UAbi>&) noexcept;
template<class G>
constexpr explicit basic_mask(G&& gen);
template<same_as<bitset<size()>> T>
constexpr basic_mask(const T& b) noexcept;
template<unsigned_integral T>
requires (!same_as<T, value_type>)
constexpr explicit basic_mask(T val) noexcept;
// 29.10.9.3,basic_mask subscript operators
constexpr value_type operator[](simd-size-type ) const;
template<simd-integral I>
constexpr resize_t<I::size(), basic_mask> operator[](const I& indices) const;
// 29.10.9.4,basic_mask unary operators
constexpr basic_mask operator!() const noexcept;
constexpr see below operator+() const noexcept;
constexpr see below operator-() const noexcept;
constexpr see below operator~() const noexcept;
// 29.10.9.5,basic_mask conversions
template<class U, class A>
constexpr explicit(sizeof(U) != Bytes) operator basic_vec<U, A>() const noexcept;
constexpr bitset<size()> to_bitset() const noexcept;
§ 29.10.9.1 © ISO/IEC
1906

===== PAGE 1918 =====

Dxxxx
constexpr unsigned long long to_ullong() const;
// 29.10.10.1,basic_mask binary operators
friend constexpr basic_mask
operator&&(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator||(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator&(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator|(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator^(const basic_mask&, const basic_mask&) noexcept;
// 29.10.10.2,basic_mask compound assignment
friend constexpr basic_mask&
operator&=(basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask&
operator|=(basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask&
operator^=(basic_mask&, const basic_mask&) noexcept;
// 29.10.10.3,basic_mask comparisons
friend constexpr basic_mask
operator==(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator!=(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator>=(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator<=(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator>(const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask
operator<(const basic_mask&, const basic_mask&) noexcept;
// 29.10.10.4,basic_mask exposition only conditional operators
friend constexpr basic_mask simd-select-impl ( // exposition only
const basic_mask&, const basic_mask&, const basic_mask&) noexcept;
friend constexpr basic_mask simd-select-impl ( // exposition only
const basic_mask&, same_as<bool> auto, same_as<bool> auto) noexcept;
template<class T0, class T1>
friend constexpr vec<see below , size()>
simd-select-impl (const basic_mask&, const T0&, const T1&) noexcept; // exposition only
};
}
1 Every specialization ofbasic_mask is a complete type. The specialization ofbasic_mask<Bytes, Abi> is:
—(1.1) disabled, if there is no vectorizable typeT such thatBytes is equal tosizeof(T),
—(1.2) otherwise, enabled, if there exists a vectorizable typeT and a valueN in the range[1,64] such that
Bytes is equal tosizeof(T) and Abi is deduce-abi-t <T, N>,
—(1.3) otherwise, it is implementation-defined if such a specialization is enabled.
If basic_mask<Bytes, Abi> is disabled, the specialization has a deleted default constructor, deleted destruc-
tor, deleted copy constructor, and deleted copy assignment. In addition only thevalue_type and abi_type
members are present.
If basic_mask<Bytes, Abi> is enabled,basic_mask<Bytes, Abi> is trivially copyable.
2 Recommended practice: Implementations should support implicit conversions between specializations of
basic_mask and appropriate implementation-defined types.
[Note 1: Appropriate types are non-standard vector types which are available in the implementation.—end note]
§ 29.10.9.1 © ISO/IEC
1907

===== PAGE 1919 =====

Dxxxx
29.10.9.2 Constructors [simd.mask.ctor]
constexpr explicit basic_mask(same_as<value_type> auto) noexcept;
1 Effects: Initializes each element withx.
template<size_t UBytes, class UAbi>
constexpr explicit basic_mask(const basic_mask<UBytes, UAbi>& x) noexcept;
2 Constraints: basic_mask<UBytes, UAbi>::size() == size() is true.
3 Effects: Initializes theith element withx[i] for alli in the range of[0,size()).
template<class G> constexpr explicit basic_mask(G&& gen);
4 Constraints: The expressiongen(integral_constant<simd-size-type , i>()) is well-formed and
its type isbool for alli in the range of[0,size()).
5 Effects: Initializes theith element withgen(integral_constant<simd-size-type , i>()) for alliin
the range of[0,size()).
6 Remarks: gen is invoked exactly once for eachi, in increasing order ofi.
template<same_as<bitset<size()>> T>
constexpr basic_mask(const T& b) noexcept;
7 Effects: Initializes theith element withb[i] for alli in the range[0,size()).
template<unsigned_integral T>
requires (!same_as<T, value_type>)
constexpr explicit basic_mask(T val) noexcept;
8 Effects: Initializes the firstM elements to the corresponding bit values inval, whereM is the smaller
of size() and the number of bits in the value representation (6.9.1) of the type ofval. If M is less
than size(), the remaining elements are initialized to zero.
29.10.9.3 Subscript operator [simd.mask.subscr]
constexpr value_type operator[](simd-size-type i) const;
1 Preconditions: i >= 0 && i < size() is true.
2 Returns: The value of theith element.
3 Throws: Nothing.
template<simd-integral I>
constexpr resize_t<I::size(), basic_mask> operator[](const I& indices) const;
4 Effects: Equivalent to:return permute(*this, indices);
29.10.9.4 Unary operators [simd.mask.unary]
constexpr basic_mask operator!() const noexcept;
constexpr see below operator+() const noexcept;
constexpr see below operator-() const noexcept;
constexpr see below operator~() const noexcept;
1 Let op be the operator.
2 Returns: A data-parallel object where theith element is initialized to the results of applyingop to
operator[](i) for alli in the range of[0,size()).
3 Remarks: If there exists a vectorizable signed integer typeI such thatsizeof(I) == Bytes is true,
operator+, operator-, and operator return an enabled specializationR of basic_vec such that
R::value_type denotes integer-from <Bytes> and R::size() == size() is true. Otherwise, these
operators are defined as deleted and their return types are unspecified.
29.10.9.5 Conversions [simd.mask.conv]
template<class U, class A>
constexpr explicit(sizeof(U) != Bytes) operator basic_vec<U, A>() const noexcept;
1 Constraints: simd-size-v <U, A> == simd-size-v <T, Abi>.
§ 29.10.9.5 © ISO/IEC
1908

===== PAGE 1920 =====

Dxxxx
2 Returns: A data-parallel object where theith element is initialized tostatic_cast<U>(operator[](i)).
constexpr bitset<size()> to_bitset() const noexcept;
3 Returns: A bitset<size()> object where theith element is initialized tooperator[](i) for alli in
the range[0,size()).
constexpr unsigned long long to_ullong() const;
4 Let N be the width ofunsigned long long.
5 Preconditions:
—(5.1) size() <= N is true, or
—(5.2) for alli in the range[N,size()), operator[](i) returns false.
6 Returns: The integral value corresponding to the bits in*this.
7 Throws: Nothing.
29.10.10 basic_mask non-member operations [simd.mask.nonmembers]
29.10.10.1 Binary operators [simd.mask.binary]
friend constexpr basic_mask
operator&&(const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator||(const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator& (const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator| (const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator^ (const basic_mask& lhs, const basic_mask& rhs) noexcept;
1 Let op be the operator.
2 Returns: A basic_mask object initialized with the results of applyingop to lhs and rhs as a binary
element-wise operation.
29.10.10.2 Compound assignment [simd.mask.cassign]
friend constexpr basic_mask&
operator&=(basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask&
operator|=(basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask&
operator^=(basic_mask& lhs, const basic_mask& rhs) noexcept;
1 Let op be the operator.
2 Effects: These operators applyop to lhs and rhs as a binary element-wise operation.
3 Returns: lhs.
29.10.10.3 Comparisons [simd.mask.comparison]
friend constexpr basic_mask
operator==(const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator!=(const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator>=(const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator<=(const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator>(const basic_mask& lhs, const basic_mask& rhs) noexcept;
friend constexpr basic_mask
operator<(const basic_mask& lhs, const basic_mask& rhs) noexcept;
1 Let op be the operator.
§ 29.10.10.3 © ISO/IEC
1909

===== PAGE 1921 =====

Dxxxx
2 Returns: A basic_mask object initialized with the results of applyingop to lhs and rhs as a binary
element-wise operation.
29.10.10.4 Exposition-only conditional operators [simd.mask.cond]
friend constexpr basic_mask simd-select-impl (
const basic_mask& mask, const basic_mask& a, const basic_mask& b) noexcept;
1 Returns: A basic_mask object where theith element equalsmask[i] ? a[i] : b[i] for alli in the
range of[0,size()).
friend constexpr basic_mask
simd-select-impl (const basic_mask& mask, same_as<bool> auto a, same_as<bool> auto b) noexcept;
2 Returns: A basic_mask object where theith element equalsmask[i] ? a : b for alli in the range of
[0,size()).
template<class T0, class T1>
friend constexpr vec<see below , size()>
simd-select-impl (const basic_mask& mask, const T0& a, const T1& b) noexcept;
3 Constraints:
—(3.1) same_as<T0, T1> is true,
—(3.2) T0 is a vectorizable type, and
—(3.3) sizeof(T0) == Bytes.
4 Returns: A vec<T0, size()> object where theith element equalsmask[i] ? a : b for alli in the
range of[0,size()).
29.10.10.5 Reductions [simd.mask.reductions]
template<size_t Bytes, class Abi>
constexpr bool all_of(const basic_mask<Bytes, Abi>& k) noexcept;
1 Returns: true if all boolean elements ink are true, otherwisefalse.
template<size_t Bytes, class Abi>
constexpr bool any_of(const basic_mask<Bytes, Abi>& k) noexcept;
2 Returns: true if at least one boolean element ink is true, otherwisefalse.
template<size_t Bytes, class Abi>
constexpr bool none_of(const basic_mask<Bytes, Abi>& k) noexcept;
3 Returns: !any_of(k).
template<size_t Bytes, class Abi>
constexpr simd-size-type reduce_count(const basic_mask<Bytes, Abi>& k) noexcept;
4 Returns: The number of boolean elements ink that aretrue.
template<size_t Bytes, class Abi>
constexpr simd-size-type reduce_min_index(const basic_mask<Bytes, Abi>& k);
5 Preconditions: any_of(k) is true.
6 Returns: The lowest element indexi where k[i] is true.
template<size_t Bytes, class Abi>
constexpr simd-size-type reduce_max_index(const basic_mask<Bytes, Abi>& k);
7 Preconditions: any_of(k) is true.
8 Returns: The greatest element indexi where k[i] is true.
constexpr bool all_of(same_as<bool> auto x) noexcept;
constexpr bool any_of(same_as<bool> auto x) noexcept;
constexpr simd-size-type reduce_count(same_as<bool> auto x) noexcept;
9 Returns: x.
§ 29.10.10.5 © ISO/IEC
1910

===== PAGE 1922 =====

Dxxxx
constexpr bool none_of(same_as<bool> auto x) noexcept;
10 Returns: !x.
constexpr simd-size-type reduce_min_index(same_as<bool> auto x);
constexpr simd-size-type reduce_max_index(same_as<bool> auto x);
11 Preconditions: x is true.
12 Returns: 0.
29.11 C compatibility [numerics.c]
29.11.1 Header <stdckdint.h> synopsis [stdckdint.h.syn]
#define __STDC_VERSION_STDCKDINT_H__ 202311L
template<class type1, class type2, class type3>
bool ckd_add(type1* result, type2 a, type3 b);
template<class type1, class type2, class type3>
bool ckd_sub(type1* result, type2 a, type3 b);
template<class type1, class type2, class type3>
bool ckd_mul(type1* result, type2 a, type3 b);
1 See also: ISO/IEC 9899:2024, 7.20
29.11.2 Checked integer operations [numerics.c.ckdint]
template<class type1, class type2, class type3>
bool ckd_add(type1* result, type2 a, type3 b);
template<class type1, class type2, class type3>
bool ckd_sub(type1* result, type2 a, type3 b);
template<class type1, class type2, class type3>
bool ckd_mul(type1* result, type2 a, type3 b);
1 Mandates: Each of the typestype1, type2, andtype3 is a signed or unsigned integer type (6.9.2).
2 Remarks: Each function template has the same semantics as the corresponding type-generic macro
with the same name specified inSee also: ISO/IEC 9899:2024, 7.20.
§ 29.11.2 © ISO/IEC
1911

===== PAGE 1923 =====

Dxxxx
30 Time library [time]
30.1 General [time.general]
1 This Clause describes the chrono library (30.2) and various C functions (30.15) that provide generally useful
time utilities, as summarized in Table 130.
Table 130 — Time library summary [tab:time.summary]
Subclause Header
30.3 Cpp17Clock requirements
30.4 Time-related traits <chrono>
30.5 Class template duration
30.6 Class template time_point
30.7 Clocks
30.8 Civil calendar
30.9 Class template hh_mm_ss
30.10 12/24 hour functions
30.11 Time zones
30.12 Formatting
30.13 Parsing
30.14 Hash support
30.15 C library time utilities <ctime>
30.2 Header <chrono> synopsis [time.syn]
#include <compare> // see 17.12.1
namespace std::chrono {
// 30.5, class templateduration
template<class Rep, class Period = ratio<1>> class duration;
// 30.6, class templatetime_point
template<class Clock, class Duration = typename Clock::duration> class time_point;
}
namespace std {
// 30.4.3,common_type specializations
template<class Rep1, class Period1, class Rep2, class Period2>
struct common_type<chrono::duration<Rep1, Period1>,
chrono::duration<Rep2, Period2>>;
template<class Clock, class Duration1, class Duration2>
struct common_type<chrono::time_point<Clock, Duration1>,
chrono::time_point<Clock, Duration2>>;
}
namespace std::chrono {
// 30.4, customization traits
template<class Rep> struct treat_as_floating_point;
template<class Rep>
constexpr bool treat_as_floating_point_v = treat_as_floating_point<Rep>::value;
template<class Rep> struct duration_values;
template<class T> struct is_clock;
template<class T> constexpr bool is_clock_v = is_clock<T>::value;
§ 30.2 © ISO/IEC
1912

===== PAGE 1924 =====

Dxxxx
// 30.5.6,duration arithmetic
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period, class Rep2>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator*(const duration<Rep1, Period>& d, const Rep2& s);
template<class Rep1, class Rep2, class Period>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator*(const Rep1& s, const duration<Rep2, Period>& d);
template<class Rep1, class Period, class Rep2>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator/(const duration<Rep1, Period>& d, const Rep2& s);
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<Rep1, Rep2>
operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period, class Rep2>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator%(const duration<Rep1, Period>& d, const Rep2& s);
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
// 30.5.7,duration comparisons
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator==(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator< (const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator> (const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period1, class Rep2, class Period2>
requires see below
constexpr auto operator<=>(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
// 30.5.8, conversions
template<class ToDuration, class Rep, class Period>
constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
template<class ToDuration, class Rep, class Period>
constexpr ToDuration floor(const duration<Rep, Period>& d);
template<class ToDuration, class Rep, class Period>
constexpr ToDuration ceil(const duration<Rep, Period>& d);
template<class ToDuration, class Rep, class Period>
constexpr ToDuration round(const duration<Rep, Period>& d);
// 30.5.11,duration I/O
template<class charT, class traits, class Rep, class Period>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os,
const duration<Rep, Period>& d);
§ 30.2 © ISO/IEC
1913

===== PAGE 1925 =====

Dxxxx
template<class charT, class traits, class Rep, class Period, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
duration<Rep, Period>& d,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// convenience typedefs
using nanoseconds = duration< signed integer type of at least 64 bits , nano>;
using microseconds = duration<signed integer type of at least 55 bits , micro>;
using milliseconds = duration<signed integer type of at least 45 bits , milli>;
using seconds = duration< signed integer type of at least 35 bits >;
using minutes = duration< signed integer type of at least 29 bits , ratio< 60>>;
using hours = duration< signed integer type of at least 23 bits , ratio<3600>>;
using days = duration< signed integer type of at least 25 bits ,
ratio_multiply<ratio<24>, hours::period>>;
using weeks = duration< signed integer type of at least 22 bits ,
ratio_multiply<ratio<7>, days::period>>;
using years = duration< signed integer type of at least 17 bits ,
ratio_multiply<ratio<146097, 400>, days::period>>;
using months = duration< signed integer type of at least 20 bits ,
ratio_divide<years::period, ratio<12>>>;
// 30.6.6,time_point arithmetic
template<class Clock, class Duration1, class Rep2, class Period2>
constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template<class Rep1, class Period1, class Clock, class Duration2>
constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
template<class Clock, class Duration1, class Rep2, class Period2>
constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template<class Clock, class Duration1, class Duration2>
constexpr common_type_t<Duration1, Duration2>
operator-(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
// 30.6.7,time_point comparisons
template<class Clock, class Duration1, class Duration2>
constexpr bool operator==(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
template<class Clock, class Duration1, class Duration2>
constexpr bool operator< (const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
template<class Clock, class Duration1, class Duration2>
constexpr bool operator> (const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
template<class Clock, class Duration1, class Duration2>
constexpr bool operator<=(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
template<class Clock, class Duration1, class Duration2>
constexpr bool operator>=(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
template<class Clock, class Duration1, three_way_comparable_with<Duration1> Duration2>
constexpr auto operator<=>(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
// 30.6.8, conversions
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration>
time_point_cast(const time_point<Clock, Duration>& t);
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration>& tp);
§ 30.2 © ISO/IEC
1914

===== PAGE 1926 =====

Dxxxx
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration>& tp);
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp);
// 30.5.10, specialized algorithms
template<class Rep, class Period>
constexpr duration<Rep, Period> abs(duration<Rep, Period> d);
// 30.7.2, classsystem_clock
class system_clock;
template<class Duration>
using sys_time = time_point<system_clock, Duration>;
using sys_seconds = sys_time<seconds>;
using sys_days = sys_time<days>;
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const sys_time<Duration>& tp);
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const sys_days& dp);
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
sys_time<Duration>& tp,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.7.3, classutc_clock
class utc_clock;
template<class Duration>
using utc_time = time_point<utc_clock, Duration>;
using utc_seconds = utc_time<seconds>;
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const utc_time<Duration>& t);
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
utc_time<Duration>& tp,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
struct leap_second_info;
template<class Duration>
leap_second_info get_leap_second_info(const utc_time<Duration>& ut);
// 30.7.4, classtai_clock
class tai_clock;
template<class Duration>
using tai_time = time_point<tai_clock, Duration>;
using tai_seconds = tai_time<seconds>;
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const tai_time<Duration>& t);
§ 30.2 © ISO/IEC
1915

===== PAGE 1927 =====

Dxxxx
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
tai_time<Duration>& tp,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.7.5, classgps_clock
class gps_clock;
template<class Duration>
using gps_time = time_point<gps_clock, Duration>;
using gps_seconds = gps_time<seconds>;
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const gps_time<Duration>& t);
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
gps_time<Duration>& tp,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.7.6, typefile_clock
using file_clock = see below ;
template<class Duration>
using file_time = time_point<file_clock, Duration>;
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const file_time<Duration>& tp);
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
file_time<Duration>& tp,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.7.7, classsteady_clock
class steady_clock;
// 30.7.8, classhigh_resolution_clock
class high_resolution_clock;
// 30.7.9, local time
struct local_t {};
template<class Duration>
using local_time = time_point<local_t, Duration>;
using local_seconds = local_time<seconds>;
using local_days = local_time<days>;
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const local_time<Duration>& tp);
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
local_time<Duration>& tp,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
§ 30.2 © ISO/IEC
1916

===== PAGE 1928 =====

Dxxxx
// 30.7.10,time_point conversions
template<class DestClock, class SourceClock>
struct clock_time_conversion;
template<class DestClock, class SourceClock, class Duration>
auto clock_cast(const time_point<SourceClock, Duration>& t);
// 30.8.2, classlast_spec
struct last_spec;
// 30.8.3, classday
class day;
constexpr bool operator==(const day& x, const day& y) noexcept;
constexpr strong_ordering operator<=>(const day& x, const day& y) noexcept;
constexpr day operator+(const day& x, const days& y) noexcept;
constexpr day operator+(const days& x, const day& y) noexcept;
constexpr day operator-(const day& x, const days& y) noexcept;
constexpr days operator-(const day& x, const day& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const day& d);
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
day& d, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.8.4, classmonth
class month;
constexpr bool operator==(const month& x, const month& y) noexcept;
constexpr strong_ordering operator<=>(const month& x, const month& y) noexcept;
constexpr month operator+(const month& x, const months& y) noexcept;
constexpr month operator+(const months& x, const month& y) noexcept;
constexpr month operator-(const month& x, const months& y) noexcept;
constexpr months operator-(const month& x, const month& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month& m);
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
month& m, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.8.5, classyear
class year;
constexpr bool operator==(const year& x, const year& y) noexcept;
constexpr strong_ordering operator<=>(const year& x, const year& y) noexcept;
constexpr year operator+(const year& x, const years& y) noexcept;
constexpr year operator+(const years& x, const year& y) noexcept;
constexpr year operator-(const year& x, const years& y) noexcept;
constexpr years operator-(const year& x, const year& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year& y);
§ 30.2 © ISO/IEC
1917

===== PAGE 1929 =====

Dxxxx
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
year& y, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.8.6, classweekday
class weekday;
constexpr bool operator==(const weekday& x, const weekday& y) noexcept;
constexpr weekday operator+(const weekday& x, const days& y) noexcept;
constexpr weekday operator+(const days& x, const weekday& y) noexcept;
constexpr weekday operator-(const weekday& x, const days& y) noexcept;
constexpr days operator-(const weekday& x, const weekday& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const weekday& wd);
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
weekday& wd, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.8.7, classweekday_indexed
class weekday_indexed;
constexpr bool operator==(const weekday_indexed& x, const weekday_indexed& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const weekday_indexed& wdi);
// 30.8.8, classweekday_last
class weekday_last;
constexpr bool operator==(const weekday_last& x, const weekday_last& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const weekday_last& wdl);
// 30.8.9, classmonth_day
class month_day;
constexpr bool operator==(const month_day& x, const month_day& y) noexcept;
constexpr strong_ordering operator<=>(const month_day& x, const month_day& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_day& md);
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
month_day& md, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.8.10, classmonth_day_last
class month_day_last;
§ 30.2 © ISO/IEC
1918

===== PAGE 1930 =====

Dxxxx
constexpr bool operator==(const month_day_last& x, const month_day_last& y) noexcept;
constexpr strong_ordering operator<=>(const month_day_last& x,
const month_day_last& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_day_last& mdl);
// 30.8.11, classmonth_weekday
class month_weekday;
constexpr bool operator==(const month_weekday& x, const month_weekday& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_weekday& mwd);
// 30.8.12, classmonth_weekday_last
class month_weekday_last;
constexpr bool operator==(const month_weekday_last& x, const month_weekday_last& y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_weekday_last& mwdl);
// 30.8.13, classyear_month
class year_month;
constexpr bool operator==(const year_month& x, const year_month& y) noexcept;
constexpr strong_ordering operator<=>(const year_month& x, const year_month& y) noexcept;
constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
constexpr months operator-(const year_month& x, const year_month& y) noexcept;
constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month& ym);
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
year_month& ym, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.8.14, classyear_month_day
class year_month_day;
constexpr bool operator==(const year_month_day& x, const year_month_day& y) noexcept;
constexpr strong_ordering operator<=>(const year_month_day& x,
const year_month_day& y) noexcept;
constexpr year_month_day operator+(const year_month_day& ymd, const months& dm) noexcept;
constexpr year_month_day operator+(const months& dm, const year_month_day& ymd) noexcept;
constexpr year_month_day operator+(const year_month_day& ymd, const years& dy) noexcept;
constexpr year_month_day operator+(const years& dy, const year_month_day& ymd) noexcept;
constexpr year_month_day operator-(const year_month_day& ymd, const months& dm) noexcept;
constexpr year_month_day operator-(const year_month_day& ymd, const years& dy) noexcept;
§ 30.2 © ISO/IEC
1919

===== PAGE 1931 =====

Dxxxx
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_day& ymd);
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
year_month_day& ymd,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
// 30.8.15, classyear_month_day_last
class year_month_day_last;
constexpr bool operator==(const year_month_day_last& x,
const year_month_day_last& y) noexcept;
constexpr strong_ordering operator<=>(const year_month_day_last& x,
const year_month_day_last& y) noexcept;
constexpr year_month_day_last
operator+(const year_month_day_last& ymdl, const months& dm) noexcept;
constexpr year_month_day_last
operator+(const months& dm, const year_month_day_last& ymdl) noexcept;
constexpr year_month_day_last
operator+(const year_month_day_last& ymdl, const years& dy) noexcept;
constexpr year_month_day_last
operator+(const years& dy, const year_month_day_last& ymdl) noexcept;
constexpr year_month_day_last
operator-(const year_month_day_last& ymdl, const months& dm) noexcept;
constexpr year_month_day_last
operator-(const year_month_day_last& ymdl, const years& dy) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_day_last& ymdl);
// 30.8.16, classyear_month_weekday
class year_month_weekday;
constexpr bool operator==(const year_month_weekday& x,
const year_month_weekday& y) noexcept;
constexpr year_month_weekday
operator+(const year_month_weekday& ymwd, const months& dm) noexcept;
constexpr year_month_weekday
operator+(const months& dm, const year_month_weekday& ymwd) noexcept;
constexpr year_month_weekday
operator+(const year_month_weekday& ymwd, const years& dy) noexcept;
constexpr year_month_weekday
operator+(const years& dy, const year_month_weekday& ymwd) noexcept;
constexpr year_month_weekday
operator-(const year_month_weekday& ymwd, const months& dm) noexcept;
constexpr year_month_weekday
operator-(const year_month_weekday& ymwd, const years& dy) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_weekday& ymwd);
// 30.8.17, classyear_month_weekday_last
class year_month_weekday_last;
constexpr bool operator==(const year_month_weekday_last& x,
const year_month_weekday_last& y) noexcept;
§ 30.2 © ISO/IEC
1920

===== PAGE 1932 =====

Dxxxx
constexpr year_month_weekday_last
operator+(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
constexpr year_month_weekday_last
operator+(const months& dm, const year_month_weekday_last& ymwdl) noexcept;
constexpr year_month_weekday_last
operator+(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
constexpr year_month_weekday_last
operator+(const years& dy, const year_month_weekday_last& ymwdl) noexcept;
constexpr year_month_weekday_last
operator-(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
constexpr year_month_weekday_last
operator-(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_weekday_last& ymwdl);
// 30.8.18, civil calendar conventional syntax operators
constexpr year_month
operator/(const year& y, const month& m) noexcept;
constexpr year_month
operator/(const year& y, int m) noexcept;
constexpr month_day
operator/(const month& m, const day& d) noexcept;
constexpr month_day
operator/(const month& m, int d) noexcept;
constexpr month_day
operator/(int m, const day& d) noexcept;
constexpr month_day
operator/(const day& d, const month& m) noexcept;
constexpr month_day
operator/(const day& d, int m) noexcept;
constexpr month_day_last
operator/(const month& m, last_spec) noexcept;
constexpr month_day_last
operator/(int m, last_spec) noexcept;
constexpr month_day_last
operator/(last_spec, const month& m) noexcept;
constexpr month_day_last
operator/(last_spec, int m) noexcept;
constexpr month_weekday
operator/(const month& m, const weekday_indexed& wdi) noexcept;
constexpr month_weekday
operator/(int m, const weekday_indexed& wdi) noexcept;
constexpr month_weekday
operator/(const weekday_indexed& wdi, const month& m) noexcept;
constexpr month_weekday
operator/(const weekday_indexed& wdi, int m) noexcept;
constexpr month_weekday_last
operator/(const month& m, const weekday_last& wdl) noexcept;
constexpr month_weekday_last
operator/(int m, const weekday_last& wdl) noexcept;
constexpr month_weekday_last
operator/(const weekday_last& wdl, const month& m) noexcept;
constexpr month_weekday_last
operator/(const weekday_last& wdl, int m) noexcept;
constexpr year_month_day
operator/(const year_month& ym, const day& d) noexcept;
constexpr year_month_day
operator/(const year_month& ym, int d) noexcept;
constexpr year_month_day
operator/(const year& y, const month_day& md) noexcept;
constexpr year_month_day
operator/(int y, const month_day& md) noexcept;
§ 30.2 © ISO/IEC
1921

===== PAGE 1933 =====

Dxxxx
constexpr year_month_day
operator/(const month_day& md, const year& y) noexcept;
constexpr year_month_day
operator/(const month_day& md, int y) noexcept;
constexpr year_month_day_last
operator/(const year_month& ym, last_spec) noexcept;
constexpr year_month_day_last
operator/(const year& y, const month_day_last& mdl) noexcept;
constexpr year_month_day_last
operator/(int y, const month_day_last& mdl) noexcept;
constexpr year_month_day_last
operator/(const month_day_last& mdl, const year& y) noexcept;
constexpr year_month_day_last
operator/(const month_day_last& mdl, int y) noexcept;
constexpr year_month_weekday
operator/(const year_month& ym, const weekday_indexed& wdi) noexcept;
constexpr year_month_weekday
operator/(const year& y, const month_weekday& mwd) noexcept;
constexpr year_month_weekday
operator/(int y, const month_weekday& mwd) noexcept;
constexpr year_month_weekday
operator/(const month_weekday& mwd, const year& y) noexcept;
constexpr year_month_weekday
operator/(const month_weekday& mwd, int y) noexcept;
constexpr year_month_weekday_last
operator/(const year_month& ym, const weekday_last& wdl) noexcept;
constexpr year_month_weekday_last
operator/(const year& y, const month_weekday_last& mwdl) noexcept;
constexpr year_month_weekday_last
operator/(int y, const month_weekday_last& mwdl) noexcept;
constexpr year_month_weekday_last
operator/(const month_weekday_last& mwdl, const year& y) noexcept;
constexpr year_month_weekday_last
operator/(const month_weekday_last& mwdl, int y) noexcept;
// 30.9, class templatehh_mm_ss
template<class Duration> class hh_mm_ss;
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const hh_mm_ss<Duration>& hms);
// 30.10, 12/24 hour functions
constexpr bool is_am(const hours& h) noexcept;
constexpr bool is_pm(const hours& h) noexcept;
constexpr hours make12(const hours& h) noexcept;
constexpr hours make24(const hours& h, bool is_pm) noexcept;
// 30.11.2, time zone database
struct tzdb;
class tzdb_list;
// 30.11.2.3, time zone database access
const tzdb& get_tzdb();
tzdb_list& get_tzdb_list();
const time_zone* locate_zone(string_view tz_name);
const time_zone* current_zone();
// 30.11.2.4, remote time zone database support
const tzdb& reload_tzdb();
string remote_version();
// 30.11.3, exception classes
class nonexistent_local_time;
§ 30.2 © ISO/IEC
1922

===== PAGE 1934 =====

Dxxxx
class ambiguous_local_time;
// 30.11.4, information classes
struct sys_info;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const sys_info& si);
struct local_info;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const local_info& li);
// 30.11.5, classtime_zone
enum class choose {earliest, latest};
class time_zone;
bool operator==(const time_zone& x, const time_zone& y) noexcept;
strong_ordering operator<=>(const time_zone& x, const time_zone& y) noexcept;
// 30.11.6, class templatezoned_traits
template<class T> struct zoned_traits;
// 30.11.7, class templatezoned_time
template<class Duration, class TimeZonePtr = const time_zone*> class zoned_time;
using zoned_seconds = zoned_time<seconds>;
template<class Duration1, class Duration2, class TimeZonePtr>
bool operator==(const zoned_time<Duration1, TimeZonePtr>& x,
const zoned_time<Duration2, TimeZonePtr>& y);
template<class charT, class traits, class Duration, class TimeZonePtr>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os,
const zoned_time<Duration, TimeZonePtr>& t);
// 30.11.8, leap second support
class leap_second;
constexpr bool operator==(const leap_second& x, const leap_second& y);
constexpr strong_ordering operator<=>(const leap_second& x, const leap_second& y);
template<class Duration>
constexpr bool operator==(const leap_second& x, const sys_time<Duration>& y);
template<class Duration>
constexpr bool operator< (const leap_second& x, const sys_time<Duration>& y);
template<class Duration>
constexpr bool operator< (const sys_time<Duration>& x, const leap_second& y);
template<class Duration>
constexpr bool operator> (const leap_second& x, const sys_time<Duration>& y);
template<class Duration>
constexpr bool operator> (const sys_time<Duration>& x, const leap_second& y);
template<class Duration>
constexpr bool operator<=(const leap_second& x, const sys_time<Duration>& y);
template<class Duration>
constexpr bool operator<=(const sys_time<Duration>& x, const leap_second& y);
template<class Duration>
constexpr bool operator>=(const leap_second& x, const sys_time<Duration>& y);
template<class Duration>
constexpr bool operator>=(const sys_time<Duration>& x, const leap_second& y);
template<class Duration>
requires three_way_comparable_with<sys_seconds, sys_time<Duration>>
constexpr auto operator<=>(const leap_second& x, const sys_time<Duration>& y);
§ 30.2 © ISO/IEC
1923

===== PAGE 1935 =====

Dxxxx
// 30.11.9, classtime_zone_link
class time_zone_link;
bool operator==(const time_zone_link& x, const time_zone_link& y);
strong_ordering operator<=>(const time_zone_link& x, const time_zone_link& y);
// 30.12, formatting
template<class Duration> struct local-time-format-t ; // exposition only
template<class Duration>
local-time-format-t <Duration>
local_time_format(local_time<Duration> time, const string* abbrev = nullptr,
const seconds* offset_sec = nullptr);
}
namespace std {
template<class Rep, class Period, class charT>
struct formatter<chrono::duration<Rep, Period>, charT>;
template<class Duration, class charT>
struct formatter<chrono::sys_time<Duration>, charT>;
template<class Duration, class charT>
struct formatter<chrono::utc_time<Duration>, charT>;
template<class Duration, class charT>
struct formatter<chrono::tai_time<Duration>, charT>;
template<class Duration, class charT>
struct formatter<chrono::gps_time<Duration>, charT>;
template<class Duration, class charT>
struct formatter<chrono::file_time<Duration>, charT>;
template<class Duration, class charT>
struct formatter<chrono::local_time<Duration>, charT>;
template<class Duration, class charT>
struct formatter<chrono::local-time-format-t <Duration>, charT>;
template<class charT> struct formatter<chrono::day, charT>;
template<class charT> struct formatter<chrono::month, charT>;
template<class charT> struct formatter<chrono::year, charT>;
template<class charT> struct formatter<chrono::weekday, charT>;
template<class charT> struct formatter<chrono::weekday_indexed, charT>;
template<class charT> struct formatter<chrono::weekday_last, charT>;
template<class charT> struct formatter<chrono::month_day, charT>;
template<class charT> struct formatter<chrono::month_day_last, charT>;
template<class charT> struct formatter<chrono::month_weekday, charT>;
template<class charT> struct formatter<chrono::month_weekday_last, charT>;
template<class charT> struct formatter<chrono::year_month, charT>;
template<class charT> struct formatter<chrono::year_month_day, charT>;
template<class charT> struct formatter<chrono::year_month_day_last, charT>;
template<class charT> struct formatter<chrono::year_month_weekday, charT>;
template<class charT> struct formatter<chrono::year_month_weekday_last, charT>;
template<class Rep, class Period, class charT>
struct formatter<chrono::hh_mm_ss<duration<Rep, Period>>, charT>;
template<class charT> struct formatter<chrono::sys_info, charT>;
template<class charT> struct formatter<chrono::local_info, charT>;
template<class Duration, class TimeZonePtr, class charT>
struct formatter<chrono::zoned_time<Duration, TimeZonePtr>, charT>;
}
namespace std::chrono {
// 30.13, parsing
template<class charT, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp);
§ 30.2 © ISO/IEC
1924

===== PAGE 1936 =====

Dxxxx
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev);
template<class charT, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp, minutes& offset);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
minutes& offset);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev, minutes& offset);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev, minutes& offset);
// calendrical constants
inline constexpr last_spec last{};
inline constexpr weekday Sunday{0};
inline constexpr weekday Monday{1};
inline constexpr weekday Tuesday{2};
inline constexpr weekday Wednesday{3};
inline constexpr weekday Thursday{4};
inline constexpr weekday Friday{5};
inline constexpr weekday Saturday{6};
inline constexpr month January{1};
inline constexpr month February{2};
inline constexpr month March{3};
inline constexpr month April{4};
inline constexpr month May{5};
inline constexpr month June{6};
inline constexpr month July{7};
inline constexpr month August{8};
inline constexpr month September{9};
inline constexpr month October{10};
inline constexpr month November{11};
inline constexpr month December{12};
}
namespace std::inline literals::inline chrono_literals {
// 30.5.9, suffixes for duration literals
constexpr chrono::hours operator""h(unsigned long long);
constexpr chrono::duration<unspecified, ratio<3600, 1>> operator""h(long double);
constexpr chrono::minutes operator""min(unsigned long long);
constexpr chrono::duration<unspecified, ratio<60, 1>> operator""min(long double);
constexpr chrono::seconds operator""s(unsigned long long);
constexpr chrono::duration<unspecified > operator""s(long double);
constexpr chrono::milliseconds operator""ms(unsigned long long);
constexpr chrono::duration<unspecified, milli> operator""ms(long double);
§ 30.2 © ISO/IEC
1925

===== PAGE 1937 =====

Dxxxx
constexpr chrono::microseconds operator""us(unsigned long long);
constexpr chrono::duration<unspecified, micro> operator""us(long double);
constexpr chrono::nanoseconds operator""ns(unsigned long long);
constexpr chrono::duration<unspecified, nano> operator""ns(long double);
// 30.8.3.3, non-member functions
constexpr chrono::day operator""d(unsigned long long d) noexcept;
// 30.8.5.3, non-member functions
constexpr chrono::year operator""y(unsigned long long y) noexcept;
}
namespace std::chrono {
using namespace literals::chrono_literals;
}
namespace std {
// 30.14, hash support
template<class T> struct hash;
template<class Rep, class Period> struct hash<chrono::duration<Rep, Period>>;
template<class Clock, class Duration> struct hash<chrono::time_point<Clock, Duration>>;
template<> struct hash<chrono::day>;
template<> struct hash<chrono::month>;
template<> struct hash<chrono::year>;
template<> struct hash<chrono::weekday>;
template<> struct hash<chrono::weekday_indexed>;
template<> struct hash<chrono::weekday_last>;
template<> struct hash<chrono::month_day>;
template<> struct hash<chrono::month_day_last>;
template<> struct hash<chrono::month_weekday>;
template<> struct hash<chrono::month_weekday_last>;
template<> struct hash<chrono::year_month>;
template<> struct hash<chrono::year_month_day>;
template<> struct hash<chrono::year_month_day_last>;
template<> struct hash<chrono::year_month_weekday>;
template<> struct hash<chrono::year_month_weekday_last>;
template<class Duration, class TimeZonePtr>
struct hash<chrono::zoned_time<Duration, TimeZonePtr>>;
template<> struct hash<chrono::leap_second>;
}
30.3 Cpp17Clock requirements [time.clock.req]
1 A clock is a bundle consisting of aduration, a time_point, and a function now() to get the current
time_point. The origin of the clock’stime_point is referred to as the clock’sepoch. A clock shall meet the
requirements in Table 131.
2 In Table 131C1 and C2 denote clock types. t1 and t2 are values returned byC1::now() where the call
returning t1 happens before (6.10.2) the call returningt2 and both of these calls occur beforeC1::time_-
point::max().
[Note 1: This meansC1 did not wrap around betweent1 and t2. —end note]
Table 131 —Cpp17Clock requirements [tab:time.clock]
Expression Return type Operational semantics
C1::rep An arithmetic type or a class
emulating an arithmetic type
The representation type of
C1::duration.
C1::period a specialization ofratio The tick period of the clock in
seconds.
C1::duration chrono::duration<C1::rep,
C1::period>
The duration type of the
clock.
§ 30.3 © ISO/IEC
1926

===== PAGE 1938 =====

Dxxxx
Table 131 —Cpp17Clock requirements (continued)
Expression Return type Operational semantics
C1::time_point chrono::time_point<C1> or
chrono::time_point<C2,
C1::duration>
The time_point type of the
clock. C1 and C2 shall refer to
the same epoch.
C1::is_steady const bool true if t1 <= t2 is always
true and the time between
clock ticks is constant,
otherwise false.
C1::now() C1::time_point Returns atime_point object
representing the current point
in time.
3 [Note 2: The relative difference in durations between those reported by a given clock and the SI definition is a measure
of the quality of implementation.—end note]
4 A typeTC meets theCpp17TrivialClock requirements if
—(4.1) TC meets theCpp17Clock requirements,
—(4.2) the typesTC::rep, TC::duration, andTC::time_point meet theCpp17EqualityComparable(Table 28)
and Cpp17LessThanComparable (Table 29) and Cpp17Swappable (16.4.4.3) requirements and the
requirements of numeric types (29.2),
[Note 3: This means, in particular, that operations on these types will not throw exceptions.—end note]
—(4.3) the functionTC::now() does not throw exceptions, and
—(4.4) the typeTC::time_point::clock meets theCpp17TrivialClock requirements, recursively.
30.4 Time-related traits [time.traits]
30.4.1 treat_as_floating_point [time.traits.is.fp]
template<class Rep> struct treat_as_floating_point : is_floating_point<Rep> { };
1 The duration template uses thetreat_as_floating_point trait to help determine if aduration object
can be converted to anotherduration with a different tickperiod. If treat_as_floating_point_v<Rep> is
true, then implicit conversions are allowed amongdurations. Otherwise, the implicit convertibility depends
on the tickperiods of thedurations.
[Note 1: The intention of this trait is to indicate whether a given class behaves like a floating-point type, and thus
allows division of one value by another with acceptable loss of precision. Iftreat_as_floating_point_v<Rep> is
false, Rep will be treated as if it behaved like an integral type for the purpose of these conversions.—end note]
30.4.2 duration_values [time.traits.duration.values]
template<class Rep>
struct duration_values {
public:
static constexpr Rep zero() noexcept;
static constexpr Rep min() noexcept;
static constexpr Rep max() noexcept;
};
1 The duration template uses the duration_values trait to construct special values of the duration’s
representation (Rep). This is done because the representation can be a class type with behavior that requires
some other implementation to return these special values. In that case, the author of that class type should
specialize duration_values to return the indicated values.
static constexpr Rep zero() noexcept;
2 Returns: Rep(0).
[Note 1: Rep(0) is specified instead of Rep() because Rep() can have some other meaning, such as an
uninitialized value. —end note]
3 Remarks: The value returned shall be the additive identity.
§ 30.4.2 © ISO/IEC
1927

===== PAGE 1939 =====

Dxxxx
static constexpr Rep min() noexcept;
4 Returns: numeric_limits<Rep>::lowest().
5 Remarks: The value returned shall compare less than or equal tozero().
static constexpr Rep max() noexcept;
6 Returns: numeric_limits<Rep>::max().
7 Remarks: The value returned shall compare greater thanzero().
30.4.3 Specializations of common_type [time.traits.specializations]
template<class Rep1, class Period1, class Rep2, class Period2>
struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>> {
using type = chrono::duration<common_type_t<Rep1, Rep2>, see below >;
};
1 The period of theduration indicated by this specialization ofcommon_type is the greatest common divisor
of Period1 and Period2.
[Note 1: This can be computed by forming a ratio of the greatest common divisor ofPeriod1::num and Period2::num
and the least common multiple ofPeriod1::den and Period2::den. —end note]
2 [Note 2: The typedef name type is a synonym for theduration with the largest tickperiod possible where both
duration arguments will convert to it without requiring a division operation. The representation of this type is
intended to be able to hold any value resulting from this conversion with no truncation error, although floating-point
durations can have round-off errors.—end note]
template<class Clock, class Duration1, class Duration2>
struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>> {
using type = chrono::time_point<Clock, common_type_t<Duration1, Duration2>>;
};
3 The common type of twotime_point types is atime_point with the same clock as the two types and the
common type of their twodurations.
30.4.4 Class template is_clock [time.traits.is.clock]
template<class T> struct is_clock;
1 is_clock is a Cpp17UnaryTypeTrait (21.3.2) with a base characteristic of true_type if T meets the
Cpp17Clock requirements (30.3), otherwisefalse_type. For the purposes of the specification of this trait,
the extent to which an implementation determines that a type cannot meet theCpp17Clock requirements is
unspecified, except that as a minimum a typeT shall not qualify as aCpp17Clock unless it meets all of the
following conditions:
—(1.1) the qualified-ids T::rep, T::period, T::duration, andT::time_point are valid and each denotes a
type (13.10.3),
—(1.2) the expressionT::is_steady is well-formed when treated as an unevaluated operand (7.2.3),
—(1.3) the expressionT::now() is well-formed when treated as an unevaluated operand.
2 The behavior of a program that adds specializations foris_clock is undefined.
30.5 Class template duration [time.duration]
30.5.1 General [time.duration.general]
1 A duration type measures time between two points in time (time_points). Aduration has a representation
which holds a count of ticks and a tick period. The tick period is the amount of time which occurs from one
tick to the next, in units of seconds. It is expressed as a rational constant using the templateratio.
namespace std::chrono {
template<class Rep, class Period = ratio<1>>
class duration {
public:
using rep = Rep;
using period = Period::type;
§ 30.5.1 © ISO/IEC
1928

===== PAGE 1940 =====

Dxxxx
private:
rep rep_; // exposition only
public:
// 30.5.2, construct/copy/destroy
constexpr duration() = default;
template<class Rep2>
constexpr explicit duration(const Rep2& r);
template<class Rep2, class Period2>
constexpr duration(const duration<Rep2, Period2>& d);
~duration() = default;
duration(const duration&) = default;
duration& operator=(const duration&) = default;
// 30.5.3, observer
constexpr rep count() const;
// 30.5.4, arithmetic
constexpr common_type_t<duration> operator+() const;
constexpr common_type_t<duration> operator-() const;
constexpr duration& operator++();
constexpr duration operator++(int);
constexpr duration& operator--();
constexpr duration operator--(int);
constexpr duration& operator+=(const duration& d);
constexpr duration& operator-=(const duration& d);
constexpr duration& operator*=(const rep& rhs);
constexpr duration& operator/=(const rep& rhs);
constexpr duration& operator%=(const rep& rhs);
constexpr duration& operator%=(const duration& rhs);
// 30.5.5, special values
static constexpr duration zero() noexcept;
static constexpr duration min() noexcept;
static constexpr duration max() noexcept;
};
}
2 Rep shall be an arithmetic type or a class emulating an arithmetic type. Ifduration is instantiated with a
duration type as the argument for the template parameterRep, the program is ill-formed.
3 If Period is not a specialization ofratio, the program is ill-formed. IfPeriod::num is not positive, the
program is ill-formed.
4 Members of duration do not throw exceptions other than those thrown by the indicated operations on their
representations.
5 The defaulted copy constructor of duration shall be a constexpr function if and only if the required
initialization of the memberrep_ for copy and move, respectively, would be constexpr-suitable (9.2.6).
6 [Example 1:
duration<long, ratio<60>> d0; // holds a count of minutes using along
duration<long long, milli> d1; // holds a count of milliseconds using along long
duration<double, ratio<1, 30>> d2; // holds a count with a tick period of1
30 of a second
// (30 Hz) using adouble
—end example]
30.5.2 Constructors [time.duration.cons]
template<class Rep2>
constexpr explicit duration(const Rep2& r);
1 Constraints: is_convertible_v<const Rep2&, rep> is true and
—(1.1) treat_as_floating_point_v<rep> is true or
§ 30.5.2 © ISO/IEC
1929

===== PAGE 1941 =====

Dxxxx
—(1.2) treat_as_floating_point_v<Rep2> is false.
[Example 1:
duration<int, milli> d(3); // OK
duration<int, milli> d2(3.5); // error
—end example]
2 Effects: Initializes rep_ with r.
template<class Rep2, class Period2>
constexpr duration(const duration<Rep2, Period2>& d);
3 Constraints: is_convertible_v<const Rep2&, rep> is true. ratio_divide<typename Period2::
type, period> is a valid ratio specialization. Either:
—(3.1) treat_as_floating_point_v<rep> is true; or
—(3.2) ratio_divide<Period2, period>::den is 1 and treat_as_floating_point_v<Rep2> is false.
[Note 1: This requirement prevents implicit truncation errors when converting between integral-basedduration
types. Such a construction could easily lead to confusion about the value of theduration. —end note]
[Example 2:
duration<int, milli> ms(3);
duration<int, micro> us = ms; // OK
duration<int, milli> ms2 = us; // error
—end example]
4 Effects: Initializes rep_ with duration_cast<duration>(d).count().
30.5.3 Observer [time.duration.observer]
constexpr rep count() const;
1 Returns: rep_.
30.5.4 Arithmetic [time.duration.arithmetic]
constexpr common_type_t<duration> operator+() const;
1 Returns: common_type_t<duration>(*this).
constexpr common_type_t<duration> operator-() const;
2 Returns: common_type_t<duration>(-rep_).
constexpr duration& operator++();
3 Effects: Equivalent to:++rep_.
4 Returns: *this.
constexpr duration operator++(int);
5 Effects: Equivalent to:return duration(rep_++);
constexpr duration& operator--();
6 Effects: Equivalent to:--rep_.
7 Returns: *this.
constexpr duration operator--(int);
8 Effects: Equivalent to:return duration(rep_--);
constexpr duration& operator+=(const duration& d);
9 Effects: Equivalent to:rep_ += d.count().
10 Returns: *this.
constexpr duration& operator-=(const duration& d);
11 Effects: Equivalent to:rep_ -= d.count().
§ 30.5.4 © ISO/IEC
1930

===== PAGE 1942 =====

Dxxxx
12 Returns: *this.
constexpr duration& operator*=(const rep& rhs);
13 Effects: Equivalent to:rep_ *= rhs.
14 Returns: *this.
constexpr duration& operator/=(const rep& rhs);
15 Effects: Equivalent to:rep_ /= rhs.
16 Returns: *this.
constexpr duration& operator%=(const rep& rhs);
17 Effects: Equivalent to:rep_ %= rhs.
18 Returns: *this.
constexpr duration& operator%=(const duration& rhs);
19 Effects: Equivalent to:rep_ %= rhs.count().
20 Returns: *this.
30.5.5 Special values [time.duration.special]
static constexpr duration zero() noexcept;
1 Returns: duration(duration_values<rep>::zero()).
static constexpr duration min() noexcept;
2 Returns: duration(duration_values<rep>::min()).
static constexpr duration max() noexcept;
3 Returns: duration(duration_values<rep>::max()).
30.5.6 Non-member arithmetic [time.duration.nonmember]
1 In the function descriptions that follow, unless stated otherwise, letCD represent the return type of the
function.
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
2 Returns: CD(CD(lhs).count() + CD(rhs).count()).
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
3 Returns: CD(CD(lhs).count() - CD(rhs).count()).
template<class Rep1, class Period, class Rep2>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator*(const duration<Rep1, Period>& d, const Rep2& s);
4 Constraints: is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true.
5 Returns: CD(CD(d).count() * s).
template<class Rep1, class Rep2, class Period>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator*(const Rep1& s, const duration<Rep2, Period>& d);
6 Constraints: is_convertible_v<const Rep1&, common_type_t<Rep1, Rep2>> is true.
7 Returns: d * s.
§ 30.5.6 © ISO/IEC
1931

===== PAGE 1943 =====

Dxxxx
template<class Rep1, class Period, class Rep2>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator/(const duration<Rep1, Period>& d, const Rep2& s);
8 Constraints: is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true and Rep2 is
not a specialization ofduration.
9 Returns: CD(CD(d).count() / s).
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<Rep1, Rep2>
operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
10 Let CD be common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>.
11 Returns: CD(lhs).count() / CD(rhs).count().
template<class Rep1, class Period, class Rep2>
constexpr duration<common_type_t<Rep1, Rep2>, Period>
operator%(const duration<Rep1, Period>& d, const Rep2& s);
12 Constraints: is_convertible_v<const Rep2&, common_type_t<Rep1, Rep2>> is true and Rep2 is
not a specialization ofduration.
13 Returns: CD(CD(d).count() % s).
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
14 Returns: CD(CD(lhs).count() % CD(rhs).count()).
30.5.7 Comparisons [time.duration.comparisons]
1 In the function descriptions that follow,CT represents common_type_t<A, B>, whereA and B are the types
of the two arguments to the function.
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator==(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
2 Returns: CT(lhs).count() == CT(rhs).count().
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
3 Returns: CT(lhs).count() < CT(rhs).count().
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
4 Returns: rhs < lhs.
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
5 Returns: !(rhs < lhs).
template<class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
6 Returns: !(lhs < rhs).
template<class Rep1, class Period1, class Rep2, class Period2>
requires three_way_comparable<typename CT::rep>
constexpr auto operator<=>(const duration<Rep1, Period1>& lhs,
const duration<Rep2, Period2>& rhs);
7 Returns: CT(lhs).count() <=> CT(rhs).count().
§ 30.5.7 © ISO/IEC
1932

===== PAGE 1944 =====

Dxxxx
30.5.8 Conversions [time.duration.cast]
template<class ToDuration, class Rep, class Period>
constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
1 Constraints: ToDuration is a specialization ofduration.
2 Returns: Let CF be ratio_divide<Period, typename ToDuration::period>, and CR be common_-
type<typename ToDuration::rep, Rep, intmax_t>::type.
—(2.1) If CF::num == 1 and CF::den == 1, returns
ToDuration(static_cast<typename ToDuration::rep>(d.count()))
—(2.2) otherwise, ifCF::num != 1 and CF::den == 1, returns
ToDuration(static_cast<typename ToDuration::rep>(
static_cast<CR>(d.count()) * static_cast<CR>(CF::num)))
—(2.3) otherwise, ifCF::num == 1 and CF::den != 1, returns
ToDuration(static_cast<typename ToDuration::rep>(
static_cast<CR>(d.count()) / static_cast<CR>(CF::den)))
—(2.4) otherwise, returns
ToDuration(static_cast<typename ToDuration::rep>(
static_cast<CR>(d.count()) * static_cast<CR>(CF::num) / static_cast<CR>(CF::den)))
3 [Note 1: This function does not use any implicit conversions; all conversions are done withstatic_cast.
It avoids multiplications and divisions when it is known at compile time that one or more arguments is 1.
Intermediate computations are carried out in the widest representation and only converted to the destination
representation at the final step.—end note]
template<class ToDuration, class Rep, class Period>
constexpr ToDuration floor(const duration<Rep, Period>& d);
4 Constraints: ToDuration is a specialization ofduration.
5 Returns: The greatest resultt representable inToDuration for whicht <= d.
template<class ToDuration, class Rep, class Period>
constexpr ToDuration ceil(const duration<Rep, Period>& d);
6 Constraints: ToDuration is a specialization ofduration.
7 Returns: The least resultt representable inToDuration for whicht >= d.
template<class ToDuration, class Rep, class Period>
constexpr ToDuration round(const duration<Rep, Period>& d);
8 Constraints: ToDuration is a specialization ofduration and treat_as_floating_point_v<typename
ToDuration::rep> is false.
9 Returns: The value ofToDuration that is closest tod. If there are two closest values, then return the
value t for whicht % 2 == 0.
30.5.9 Suffixes for duration literals [time.duration.literals]
1 This subclause describes literal suffixes for constructing duration literals. The suffixesh, min, s, ms, us, ns
denote duration values of the corresponding typeshours, minutes, seconds, milliseconds, microseconds,
and nanoseconds respectively if they are applied tointeger-literals.
2 If any of these suffixes are applied to afloating-point-literal the result is achrono::duration literal with an
unspecified floating-point representation.
3 If any of these suffixes are applied to aninteger-literal and the resultingchrono::duration value cannot be
represented in the result type because of overflow, the program is ill-formed.
4 [Example 1: The following code shows some duration literals.
using namespace std::chrono_literals;
auto constexpr aday=24h;
auto constexpr lesson=45min;
auto constexpr halfanhour=0.5h;
—end example]
§ 30.5.9 © ISO/IEC
1933

===== PAGE 1945 =====

Dxxxx
constexpr chrono::hours operator""h(unsigned long long hours);
constexpr chrono::duration<unspecified, ratio<3600, 1>> operator""h(long double hours);
5 Returns: A duration literal representinghours hours.
constexpr chrono::minutes operator""min(unsigned long long minutes);
constexpr chrono::duration<unspecified, ratio<60, 1>> operator""min(long double minutes);
6 Returns: A duration literal representingminutes minutes.
constexpr chrono::seconds operator""s(unsigned long long sec);
constexpr chrono::duration<unspecified > operator""s(long double sec);
7 Returns: A duration literal representingsec seconds.
8 [Note 1: The same suffixs is used forbasic_string but there is no conflict, since duration suffixes apply to
numbers and string literal suffixes apply to character array literals.—end note]
constexpr chrono::milliseconds operator""ms(unsigned long long msec);
constexpr chrono::duration<unspecified, milli> operator""ms(long double msec);
9 Returns: A duration literal representingmsec milliseconds.
constexpr chrono::microseconds operator""us(unsigned long long usec);
constexpr chrono::duration<unspecified, micro> operator""us(long double usec);
10 Returns: A duration literal representingusec microseconds.
constexpr chrono::nanoseconds operator""ns(unsigned long long nsec);
constexpr chrono::duration<unspecified, nano> operator""ns(long double nsec);
11 Returns: A duration literal representingnsec nanoseconds.
30.5.10 Algorithms [time.duration.alg]
template<class Rep, class Period>
constexpr duration<Rep, Period> abs(duration<Rep, Period> d);
1 Constraints: numeric_limits<Rep>::is_signed is true.
2 Returns: If d >= d.zero(), returnd, otherwise return-d.
30.5.11 I/O [time.duration.io]
template<class charT, class traits, class Rep, class Period>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const duration<Rep, Period>& d);
1 Effects: Inserts the durationd onto the streamos as if it were implemented as follows:
basic_ostringstream<charT, traits> s;
s.flags(os.flags());
s.imbue(os.getloc());
s.precision(os.precision());
s << d.count() << units-suffix ;
return os << s.str();
where units-suffix depends on the typePeriod::type as follows:
—(1.1) If Period::type is atto, units-suffix is "as".
—(1.2) Otherwise, ifPeriod::type is femto, units-suffix is "fs".
—(1.3) Otherwise, ifPeriod::type is pico, units-suffix is "ps".
—(1.4) Otherwise, ifPeriod::type is nano, units-suffix is "ns".
—(1.5) Otherwise, ifPeriod::type is micro, it is implementation-defined whetherunits-suffix is "µs"
("\u00b5\u0073") or"us".
—(1.6) Otherwise, ifPeriod::type is milli, units-suffix is "ms".
—(1.7) Otherwise, ifPeriod::type is centi, units-suffix is "cs".
—(1.8) Otherwise, ifPeriod::type is deci, units-suffix is "ds".
§ 30.5.11 © ISO/IEC
1934

===== PAGE 1946 =====

Dxxxx
—(1.9) Otherwise, ifPeriod::type is ratio<1>, units-suffix is "s".
—(1.10) Otherwise, ifPeriod::type is deca, units-suffix is "das".
—(1.11) Otherwise, ifPeriod::type is hecto, units-suffix is "hs".
—(1.12) Otherwise, ifPeriod::type is kilo, units-suffix is "ks".
—(1.13) Otherwise, ifPeriod::type is mega, units-suffix is "Ms".
—(1.14) Otherwise, ifPeriod::type is giga, units-suffix is "Gs".
—(1.15) Otherwise, ifPeriod::type is tera, units-suffix is "Ts".
—(1.16) Otherwise, ifPeriod::type is peta, units-suffix is "Ps".
—(1.17) Otherwise, ifPeriod::type is exa, units-suffix is "Es".
—(1.18) Otherwise, ifPeriod::type is ratio<60>, units-suffix is "min".
—(1.19) Otherwise, ifPeriod::type is ratio<3600>, units-suffix is "h".
—(1.20) Otherwise, ifPeriod::type is ratio<86400>, units-suffix is "d".
—(1.21) Otherwise, ifPeriod::type::den == 1, units-suffix is "[num ]s".
—(1.22) Otherwise, units-suffix is "[num /den ]s".
In the list above, the use ofnum and den refers to the static data members ofPeriod::type, which
are converted to arrays ofcharT using a decimal conversion with no leading zeroes.
2 Returns: os.
template<class charT, class traits, class Rep, class Period, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
duration<Rep, Period>& d,
basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
3 Effects: Attempts to parse the input streamis into the durationd using the format flags given in the
NTCTS fmt as specified in 30.13. If the parse fails to decode a valid duration,is.setstate(ios_-
base::failbit) is called andd is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null.
4 Returns: is.
30.6 Class template time_point [time.point]
30.6.1 General [time.point.general]
namespace std::chrono {
template<class Clock, class Duration = typename Clock::duration>
class time_point {
public:
using clock = Clock;
using duration = Duration;
using rep = duration::rep;
using period = duration::period;
private:
duration d_; // exposition only
public:
// 30.6.2, construct
constexpr time_point(); // has value epoch
constexpr explicit time_point(const duration& d); // same astime_point() + d
template<class Duration2>
constexpr time_point(const time_point<clock, Duration2>& t);
// 30.6.3, observer
constexpr duration time_since_epoch() const;
§ 30.6.1 © ISO/IEC
1935

===== PAGE 1947 =====

Dxxxx
// 30.6.4, arithmetic
constexpr time_point& operator++();
constexpr time_point operator++(int);
constexpr time_point& operator--();
constexpr time_point operator--(int);
constexpr time_point& operator+=(const duration& d);
constexpr time_point& operator-=(const duration& d);
// 30.6.5, special values
static constexpr time_point min() noexcept;
static constexpr time_point max() noexcept;
};
}
1 If Duration is not a specialization ofduration, the program is ill-formed.
30.6.2 Constructors [time.point.cons]
constexpr time_point();
1 Effects: Initializes d_ with duration::zero(). Such atime_point object represents the epoch.
constexpr explicit time_point(const duration& d);
2 Effects: Initializes d_ with d. Such atime_point object represents the epoch+ d.
template<class Duration2>
constexpr time_point(const time_point<clock, Duration2>& t);
3 Constraints: is_convertible_v<Duration2, duration> is true.
4 Effects: Initializes d_ with t.time_since_epoch().
30.6.3 Observer [time.point.observer]
constexpr duration time_since_epoch() const;
1 Returns: d_.
30.6.4 Arithmetic [time.point.arithmetic]
constexpr time_point& operator++();
1 Effects: Equivalent to:++d_.
2 Returns: *this.
constexpr time_point operator++(int);
3 Effects: Equivalent to:return time_point{d_++};
constexpr time_point& operator--();
4 Effects: Equivalent to:--d_.
5 Returns: *this.
constexpr time_point operator--(int);
6 Effects: Equivalent to:return time_point{d_--};
constexpr time_point& operator+=(const duration& d);
7 Effects: Equivalent to:d_ += d.
8 Returns: *this.
constexpr time_point& operator-=(const duration& d);
9 Effects: Equivalent to:d_ -= d.
10 Returns: *this.
§ 30.6.4 © ISO/IEC
1936

===== PAGE 1948 =====

Dxxxx
30.6.5 Special values [time.point.special]
static constexpr time_point min() noexcept;
1 Returns: time_point(duration::min()).
static constexpr time_point max() noexcept;
2 Returns: time_point(duration::max()).
30.6.6 Non-member arithmetic [time.point.nonmember]
template<class Clock, class Duration1, class Rep2, class Period2>
constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
1 Returns: CT(lhs.time_since_epoch() + rhs), whereCT is the type of the return value.
template<class Rep1, class Period1, class Clock, class Duration2>
constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
2 Returns: rhs + lhs.
template<class Clock, class Duration1, class Rep2, class Period2>
constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
3 Returns: CT(lhs.time_since_epoch() - rhs), whereCT is the type of the return value.
template<class Clock, class Duration1, class Duration2>
constexpr common_type_t<Duration1, Duration2>
operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
4 Returns: lhs.time_since_epoch() - rhs.time_since_epoch().
30.6.7 Comparisons [time.point.comparisons]
template<class Clock, class Duration1, class Duration2>
constexpr bool operator==(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
1 Returns: lhs.time_since_epoch() == rhs.time_since_epoch().
template<class Clock, class Duration1, class Duration2>
constexpr bool operator<(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
2 Returns: lhs.time_since_epoch() < rhs.time_since_epoch().
template<class Clock, class Duration1, class Duration2>
constexpr bool operator>(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
3 Returns: rhs < lhs.
template<class Clock, class Duration1, class Duration2>
constexpr bool operator<=(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
4 Returns: !(rhs < lhs).
template<class Clock, class Duration1, class Duration2>
constexpr bool operator>=(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
5 Returns: !(lhs < rhs).
§ 30.6.7 © ISO/IEC
1937

===== PAGE 1949 =====

Dxxxx
template<class Clock, class Duration1,
three_way_comparable_with<Duration1> Duration2>
constexpr auto operator<=>(const time_point<Clock, Duration1>& lhs,
const time_point<Clock, Duration2>& rhs);
6 Returns: lhs.time_since_epoch() <=> rhs.time_since_epoch().
30.6.8 Conversions [time.point.cast]
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);
1 Constraints: ToDuration is a specialization ofduration.
2 Returns:
time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration>& tp);
3 Constraints: ToDuration is a specialization ofduration.
4 Returns: time_point<Clock, ToDuration>(floor<ToDuration>(tp.time_since_epoch())).
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration>& tp);
5 Constraints: ToDuration is a specialization ofduration.
6 Returns: time_point<Clock, ToDuration>(ceil<ToDuration>(tp.time_since_epoch())).
template<class ToDuration, class Clock, class Duration>
constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp);
7 Constraints: ToDurationis a specialization ofduration, andtreat_as_floating_point_v<typename
ToDuration::rep> is false.
8 Returns: time_point<Clock, ToDuration>(round<ToDuration>(tp.time_since_epoch())).
30.7 Clocks [time.clock]
30.7.1 General [time.clock.general]
1 The types defined in 30.7 meet theCpp17TrivialClock requirements (30.3) unless otherwise specified.
30.7.2 Class system_clock [time.clock.system]
30.7.2.1 Overview [time.clock.system.overview]
namespace std::chrono {
class system_clock {
public:
using rep = see below ;
using period = ratio< unspecified, unspecified >;
using duration = chrono::duration<rep, period>;
using time_point = chrono::time_point<system_clock>;
static constexpr bool is_steady = unspecified ;
static time_point now() noexcept;
// mapping to/from C typetime_t
static time_t to_time_t (const time_point& t) noexcept;
static time_point from_time_t(time_t t) noexcept;
};
}
1 Objects of typesystem_clock represent wall clock time from the system-wide realtime clock. Objects of type
sys_time<Duration> measure time since 1970-01-01 00:00:00 UTC excluding leap seconds. This measure is
commonly referred to asUnix time. This measure facilitates an efficient mapping betweensys_time and
calendar types (30.8).
§ 30.7.2.1 © ISO/IEC
1938

===== PAGE 1950 =====

Dxxxx
[Example 1:
sys_seconds{sys_days{1970y/January/1}}.time_since_epoch() is 0s.
sys_seconds{sys_days{2000y/January/1}}.time_since_epoch() is 946’684’800s, which is10’957 * 86’400s.
—end example]
30.7.2.2 Members [time.clock.system.members]
using system_clock::rep = unspecified ;
1 Constraints: system_clock::duration::min() < system_clock::duration::zero() is true.
[Note 1: This implies thatrep is a signed type.—end note]
static time_t to_time_t(const time_point& t) noexcept;
2 Returns: A time_t object that represents the same point in time ast when both values are restricted
to the coarser of the precisions oftime_t and time_point. It is implementation-defined whether values
are rounded or truncated to the required precision.
static time_point from_time_t(time_t t) noexcept;
3 Returns: A time_point object that represents the same point in time ast when both values are
restricted to the coarser of the precisions oftime_t and time_point. It is implementation-defined
whether values are rounded or truncated to the required precision.
30.7.2.3 Non-member functions [time.clock.system.nonmembers]
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const sys_time<Duration>& tp);
1 Constraints: treat_as_floating_point_v<typename Duration::rep> is false, andDuration{1} <
days{1} is true.
2 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%F %T}"), tp);
3 [Example 1:
cout << sys_seconds{0s} << '\n'; // 1970-01-01 00:00:00
cout << sys_seconds{946'684'800s} << '\n'; // 2000-01-01 00:00:00
cout << sys_seconds{946'688'523s} << '\n'; // 2000-01-01 01:02:03
—end example]
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const sys_days& dp);
4 Effects: os << year_month_day{dp}.
5 Returns: os.
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
sys_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
6 Effects: Attempts to parse the input streamis into thesys_time tpusing the format flags given in
the NTCTSfmt as specified in 30.13. If the parse fails to decode a valid date,is.setstate(ios_-
base::failbit) is called andtp is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null. Additionally, the parsed offset
will be subtracted from the successfully parsed timestamp prior to assigning that difference totp.
7 Returns: is.
§ 30.7.2.3 © ISO/IEC
1939

===== PAGE 1951 =====

Dxxxx
30.7.3 Class utc_clock [time.clock.utc]
30.7.3.1 Overview [time.clock.utc.overview]
namespace std::chrono {
class utc_clock {
public:
using rep = a signed arithmetic type ;
using period = ratio< unspecified, unspecified >;
using duration = chrono::duration<rep, period>;
using time_point = chrono::time_point<utc_clock>;
static constexpr bool is_steady = unspecified ;
static time_point now();
template<class Duration>
static sys_time<common_type_t<Duration, seconds>>
to_sys(const utc_time<Duration>& t);
template<class Duration>
static utc_time<common_type_t<Duration, seconds>>
from_sys(const sys_time<Duration>& t);
};
}
1 In contrast tosys_time, which does not take leap seconds into account,utc_clock and its associated
time_point, utc_time, count time, including leap seconds, since 1970-01-01 00:00:00 UTC.
[Note 1: The UTC time standard began on 1972-01-01 00:00:10 TAI. To measure time since this epoch instead, one
can add/subtract the constantsys_days{1972y/1/1} - sys_days{1970y/1/1} (63’072’000s) from theutc_time.
—end note]
[Example 1:
clock_cast<utc_clock>(sys_seconds{sys_days{1970y/January/1}}).time_since_epoch() is 0s.
clock_cast<utc_clock>(sys_seconds{sys_days{2000y/January/1}}).time_since_epoch() is 946’684’822s,
which is10’957 * 86’400s + 22s.
—end example]
2 utc_clock is not aCpp17TrivialClock unless the implementation can guarantee thatutc_clock::now()
does not propagate an exception.
[Note 2: noexcept(from_sys(system_clock::now())) is false. —end note]
30.7.3.2 Member functions [time.clock.utc.members]
static time_point now();
1 Returns: from_sys(system_clock::now()), or a more accurate value ofutc_time.
template<class Duration>
static sys_time<common_type_t<Duration, seconds>>
to_sys(const utc_time<Duration>& u);
2 Returns: Asys_time t, such thatfrom_sys(t) == u if such a mapping exists. Otherwiseu represents
a time_point during a positive leap second insertion, the conversion counts that leap second as not
inserted, and the last representable value ofsys_time prior to the insertion of the leap second is
returned.
template<class Duration>
static utc_time<common_type_t<Duration, seconds>>
from_sys(const sys_time<Duration>& t);
3 Returns: A utc_time u, such thatu.time_since_epoch() - t.time_since_epoch() is equal to the
sum of leap seconds that were inserted betweent and 1970-01-01. Ift is exactly the date of leap second
insertion, then the conversion counts that leap second as inserted.
[Example 1:
auto t = sys_days{July/1/2015} - 2ns;
auto u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
t += 1ns;
§ 30.7.3.2 © ISO/IEC
1940

===== PAGE 1952 =====

Dxxxx
u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 25s);
t += 1ns;
u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
t += 1ns;
u = utc_clock::from_sys(t);
assert(u.time_since_epoch() - t.time_since_epoch() == 26s);
—end example]
30.7.3.3 Non-member functions [time.clock.utc.nonmembers]
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const utc_time<Duration>& t);
1 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%F %T}"), t);
2 [Example 1:
auto t = sys_days{July/1/2015} - 500ms;
auto u = clock_cast<utc_clock>(t);
for (auto i = 0; i < 8; ++i, u += 250ms)
cout << u << " UTC\n";
Produces this output:
2015-06-30 23:59:59.500 UTC
2015-06-30 23:59:59.750 UTC
2015-06-30 23:59:60.000 UTC
2015-06-30 23:59:60.250 UTC
2015-06-30 23:59:60.500 UTC
2015-06-30 23:59:60.750 UTC
2015-07-01 00:00:00.000 UTC
2015-07-01 00:00:00.250 UTC
—end example]
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
utc_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
3 Effects: Attempts to parse the input streamis into theutc_time tpusing the format flags given in
the NTCTSfmt as specified in 30.13. If the parse fails to decode a valid date,is.setstate(ios_-
base::failbit) is called andtp is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null. Additionally, the parsed offset
will be subtracted from the successfully parsed timestamp prior to assigning that difference totp.
4 Returns: is.
struct leap_second_info {
bool is_leap_second;
seconds elapsed;
};
5 The typeleap_second_info has data members and special members specified above. It has no base
classes or members other than those specified.
template<class Duration>
leap_second_info get_leap_second_info(const utc_time<Duration>& ut);
6 Returns: Aleap_second_info lsi, wherelsi.is_leap_second is true if ut is during a positive leap
second insertion, and otherwisefalse. lsi.elapsed is the sum of leap seconds between 1970-01-01
and ut. If lsi.is_leap_second is true, the leap second referred to byut is included in the sum.
§ 30.7.3.3 © ISO/IEC
1941

===== PAGE 1953 =====

Dxxxx
30.7.4 Class tai_clock [time.clock.tai]
30.7.4.1 Overview [time.clock.tai.overview]
namespace std::chrono {
class tai_clock {
public:
using rep = a signed arithmetic type ;
using period = ratio< unspecified, unspecified >;
using duration = chrono::duration<rep, period>;
using time_point = chrono::time_point<tai_clock>;
static constexpr bool is_steady = unspecified ;
static time_point now();
template<class Duration>
static utc_time<common_type_t<Duration, seconds>>
to_utc(const tai_time<Duration>&) noexcept;
template<class Duration>
static tai_time<common_type_t<Duration, seconds>>
from_utc(const utc_time<Duration>&) noexcept;
};
}
1 The clocktai_clock measures seconds since 1958-01-01 00:00:00 and is offset 10s ahead of UTC at this
date. That is, 1958-01-01 00:00:00 TAI is equivalent to 1957-12-31 23:59:50 UTC. Leap seconds are not
inserted into TAI. Therefore every time a leap second is inserted into UTC, UTC shifts another second with
respect to TAI. For example by 2000-01-01 there had been 22 positive and 0 negative leap seconds inserted
so 2000-01-01 00:00:00 UTC is equivalent to 2000-01-01 00:00:32 TAI (22s plus the initial 10s offset).
2 tai_clock is not aCpp17TrivialClock unless the implementation can guarantee thattai_clock::now()
does not propagate an exception.
[Note 1: noexcept(from_utc(utc_clock::now())) is false. —end note]
30.7.4.2 Member functions [time.clock.tai.members]
static time_point now();
1 Returns: from_utc(utc_clock::now()), or a more accurate value oftai_time.
template<class Duration>
static utc_time<common_type_t<Duration, seconds>>
to_utc(const tai_time<Duration>& t) noexcept;
2 Returns:
utc_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} - 378691210s
[Note 1:
378691210s == sys_days{1970y/January/1} - sys_days{1958y/January/1} + 10s
—end note]
template<class Duration>
static tai_time<common_type_t<Duration, seconds>>
from_utc(const utc_time<Duration>& t) noexcept;
3 Returns:
tai_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} + 378691210s
[Note 2:
378691210s == sys_days{1970y/January/1} - sys_days{1958y/January/1} + 10s
—end note]
§ 30.7.4.2 © ISO/IEC
1942

===== PAGE 1954 =====

Dxxxx
30.7.4.3 Non-member functions [time.clock.tai.nonmembers]
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const tai_time<Duration>& t);
1 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%F %T}"), t);
2 [Example 1:
auto st = sys_days{2000y/January/1};
auto tt = clock_cast<tai_clock>(st);
cout << format("{0:%F %T %Z} == {1:%F %T %Z}\n", st, tt);
Produces this output:
2000-01-01 00:00:00 UTC == 2000-01-01 00:00:32 TAI
—end example]
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
tai_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
3 Effects: Attempts to parse the input streamis into thetai_time tpusing the format flags given in
the NTCTSfmt as specified in 30.13. If the parse fails to decode a valid date,is.setstate(ios_-
base::failbit) is called andtp is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null. Additionally, the parsed offset
will be subtracted from the successfully parsed timestamp prior to assigning that difference totp.
4 Returns: is.
30.7.5 Class gps_clock [time.clock.gps]
30.7.5.1 Overview [time.clock.gps.overview]
namespace std::chrono {
class gps_clock {
public:
using rep = a signed arithmetic type ;
using period = ratio< unspecified, unspecified >;
using duration = chrono::duration<rep, period>;
using time_point = chrono::time_point<gps_clock>;
static constexpr bool is_steady = unspecified ;
static time_point now();
template<class Duration>
static utc_time<common_type_t<Duration, seconds>>
to_utc(const gps_time<Duration>&) noexcept;
template<class Duration>
static gps_time<common_type_t<Duration, seconds>>
from_utc(const utc_time<Duration>&) noexcept;
};
}
1 The clockgps_clock measures seconds since the first Sunday of January, 1980 00:00:00 UTC. Leap seconds
are not inserted into GPS. Therefore every time a leap second is inserted into UTC, UTC shifts another
second with respect to GPS. Aside from the offset from1958y/January/1 to 1980y/January/Sunday[1],
GPS is behind TAI by 19s due to the 10s offset between 1958 and 1970 and the additional 9 leap seconds
inserted between 1970 and 1980.
2 gps_clock is not aCpp17TrivialClock unless the implementation can guarantee thatgps_clock::now()
does not propagate an exception.
[Note 1: noexcept(from_utc(utc_clock::now())) is false. —end note]
§ 30.7.5.1 © ISO/IEC
1943

===== PAGE 1955 =====

Dxxxx
30.7.5.2 Member functions [time.clock.gps.members]
static time_point now();
1 Returns: from_utc(utc_clock::now()), or a more accurate value ofgps_time.
template<class Duration>
static utc_time<common_type_t<Duration, seconds>>
to_utc(const gps_time<Duration>& t) noexcept;
2 Returns:
utc_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} + 315964809s
[Note 1:
315964809s == sys_days{1980y/January/Sunday[1]} - sys_days{1970y/January/1} + 9s
—end note]
template<class Duration>
static gps_time<common_type_t<Duration, seconds>>
from_utc(const utc_time<Duration>& t) noexcept;
3 Returns:
gps_time<common_type_t<Duration, seconds>>{t.time_since_epoch()} - 315964809s
[Note 2:
315964809s == sys_days{1980y/January/Sunday[1]} - sys_days{1970y/January/1} + 9s
—end note]
30.7.5.3 Non-member functions [time.clock.gps.nonmembers]
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const gps_time<Duration>& t);
1 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%F %T}"), t);
2 [Example 1:
auto st = sys_days{2000y/January/1};
auto gt = clock_cast<gps_clock>(st);
cout << format("{0:%F %T %Z} == {1:%F %T %Z}\n", st, gt);
Produces this output:
2000-01-01 00:00:00 UTC == 2000-01-01 00:00:13 GPS
—end example]
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
gps_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
3 Effects: Attempts to parse the input streamis into thegps_time tpusing the format flags given in
the NTCTSfmt as specified in 30.13. If the parse fails to decode a valid date,is.setstate(ios_-
base::failbit) is called andtp is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null. Additionally, the parsed offset
will be subtracted from the successfully parsed timestamp prior to assigning that difference totp.
4 Returns: is.
30.7.6 Type file_clock [time.clock.file]
30.7.6.1 Overview [time.clock.file.overview]
namespace std::chrono {
using file_clock = see below ;
}
§ 30.7.6.1 © ISO/IEC
1944

===== PAGE 1956 =====

Dxxxx
1 file_clock is an alias for a type meeting theCpp17TrivialClock requirements (30.3), and using a signed
arithmetic type for file_clock::rep. file_clock is used to create the time_point system used for
file_time_type (31.12). Its epoch is unspecified, andnoexcept(file_clock::now()) is true.
[Note 1: The type thatfile_clock denotes can be in a different namespace thanstd::chrono, such asstd::file-
system. —end note]
30.7.6.2 Member functions [time.clock.file.members]
1 The type denoted byfile_clock provides precisely one of the following two sets of static member functions:
template<class Duration>
static sys_time<see below >
to_sys(const file_time<Duration>&);
template<class Duration>
static file_time<see below >
from_sys(const sys_time<Duration>&);
or:
template<class Duration>
static utc_time<see below >
to_utc(const file_time<Duration>&);
template<class Duration>
static file_time<see below >
from_utc(const utc_time<Duration>&);
These member functions shall providetime_point conversions consistent with those specified byutc_clock,
tai_clock, andgps_clock. The Duration of the resultanttime_point is computed from theDuration of
the inputtime_point.
30.7.6.3 Non-member functions [time.clock.file.nonmembers]
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const file_time<Duration>& t);
1 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%F %T}"), t);
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
file_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
2 Effects: Attempts to parse the input streamis into thefile_time tpusing the format flags given
in the NTCTSfmt as specified in 30.13. If the parse fails to decode a valid date,is.setstate(ios_-
base::failbit) is called andtp is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null. Additionally, the parsed offset
will be subtracted from the successfully parsed timestamp prior to assigning that difference totp.
3 Returns: is.
30.7.7 Class steady_clock [time.clock.steady]
namespace std::chrono {
class steady_clock {
public:
using rep = unspecified ;
using period = ratio< unspecified, unspecified >;
using duration = chrono::duration<rep, period>;
using time_point = chrono::time_point<unspecified, duration>;
static constexpr bool is_steady = true;
static time_point now() noexcept;
};
}
§ 30.7.7 © ISO/IEC
1945

===== PAGE 1957 =====

Dxxxx
1 Objects of classsteady_clock represent clocks for which values oftime_point never decrease as physical
time advances and for which values oftime_point advance at a steady rate relative to real time. That is,
the clock may not be adjusted.
30.7.8 Class high_resolution_clock [time.clock.hires]
namespace std::chrono {
class high_resolution_clock {
public:
using rep = unspecified ;
using period = ratio< unspecified, unspecified >;
using duration = chrono::duration<rep, period>;
using time_point = chrono::time_point<unspecified, duration>;
static constexpr bool is_steady = unspecified ;
static time_point now() noexcept;
};
}
1 Objects of classhigh_resolution_clock represent clocks with the shortest tick period.high_resolution_-
clock may be a synonym forsystem_clock or steady_clock.
30.7.9 Local time [time.clock.local]
1 The family of time points denoted bylocal_time<Duration> are based on the pseudo clocklocal_t.
local_t has no member now() and thus does not meet the clock requirements. Nevertheless local_-
time<Duration> serves the vital role of representing local time with respect to a not-yet-specified time
zone. Aside from being able to get the current time, the completetime_point algebra is available for
local_time<Duration> (just as forsys_time<Duration>).
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const local_time<Duration>& lt);
2 Constraints: os << sys_time<Duration>lt.time_since_epoch() is a valid expression.
3 Effects:
os << sys_time<Duration>{lt.time_since_epoch()};
4 Returns: os.
template<class charT, class traits, class Duration, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
local_time<Duration>& tp, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
5 Effects: Attempts to parse the input streamis into thelocal_time tpusing the format flags given
in the NTCTSfmt as specified in 30.13. If the parse fails to decode a valid date,is.setstate(ios_-
base::failbit) is called andtp is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null.
6 Returns: is.
30.7.10 time_point conversions [time.clock.cast]
30.7.10.1 Class template clock_time_conversion [time.clock.conv]
namespace std::chrono {
template<class DestClock, class SourceClock>
struct clock_time_conversion {};
}
1 clock_time_conversion serves as a trait which can be used to specify how to convert a sourcetime_point of
type time_point<SourceClock, Duration> to a destinationtime_point of typetime_point<DestClock,
Duration> via a specialization: clock_time_conversion<DestClock, SourceClock>. A specialization
of clock_time_conversion<DestClock, SourceClock> shall provide a const-qualifiedoperator() that
takes a parameter of typetime_point<SourceClock, Duration> and returns atime_point<DestClock,
§ 30.7.10.1 © ISO/IEC
1946

===== PAGE 1958 =====

Dxxxx
OtherDuration> representing an equivalent point in time.OtherDuration is achrono::duration whose
specialization is computed from the inputDuration in a manner which can vary for eachclock_time_-
conversion specialization. A program may specializeclock_time_conversion if at least one of the template
parameters is a user-defined clock type.
2 Several specializations are provided by the implementation, as described in 30.7.10.2, 30.7.10.3, 30.7.10.4,
and 30.7.10.5.
30.7.10.2 Identity conversions [time.clock.cast.id]
template<class Clock>
struct clock_time_conversion<Clock, Clock> {
template<class Duration>
time_point<Clock, Duration>
operator()(const time_point<Clock, Duration>& t) const;
};
template<class Duration>
time_point<Clock, Duration>
operator()(const time_point<Clock, Duration>& t) const;
1 Returns: t.
template<>
struct clock_time_conversion<system_clock, system_clock> {
template<class Duration>
sys_time<Duration>
operator()(const sys_time<Duration>& t) const;
};
template<class Duration>
sys_time<Duration>
operator()(const sys_time<Duration>& t) const;
2 Returns: t.
template<>
struct clock_time_conversion<utc_clock, utc_clock> {
template<class Duration>
utc_time<Duration>
operator()(const utc_time<Duration>& t) const;
};
template<class Duration>
utc_time<Duration>
operator()(const utc_time<Duration>& t) const;
3 Returns: t.
30.7.10.3 Conversions between system_clock and utc_clock [time.clock.cast.sys.utc]
template<>
struct clock_time_conversion<utc_clock, system_clock> {
template<class Duration>
utc_time<common_type_t<Duration, seconds>>
operator()(const sys_time<Duration>& t) const;
};
template<class Duration>
utc_time<common_type_t<Duration, seconds>>
operator()(const sys_time<Duration>& t) const;
1 Returns: utc_clock::from_sys(t).
template<>
struct clock_time_conversion<system_clock, utc_clock> {
template<class Duration>
sys_time<common_type_t<Duration, seconds>>
operator()(const utc_time<Duration>& t) const;
};
§ 30.7.10.3 © ISO/IEC
1947

===== PAGE 1959 =====

Dxxxx
template<class Duration>
sys_time<common_type_t<Duration, seconds>>
operator()(const utc_time<Duration>& t) const;
2 Returns: utc_clock::to_sys(t).
30.7.10.4 Conversions between system_clock and other clocks [time.clock.cast.sys]
template<class SourceClock>
struct clock_time_conversion<system_clock, SourceClock> {
template<class Duration>
auto operator()(const time_point<SourceClock, Duration>& t) const
-> decltype(SourceClock::to_sys(t));
};
template<class Duration>
auto operator()(const time_point<SourceClock, Duration>& t) const
-> decltype(SourceClock::to_sys(t));
1 Constraints: SourceClock::to_sys(t) is well-formed.
2 Mandates: SourceClock::to_sys(t) returns a sys_time<Duration2> for some type Duration2
(30.6.1).
3 Returns: SourceClock::to_sys(t).
template<class DestClock>
struct clock_time_conversion<DestClock, system_clock> {
template<class Duration>
auto operator()(const sys_time<Duration>& t) const
-> decltype(DestClock::from_sys(t));
};
template<class Duration>
auto operator()(const sys_time<Duration>& t) const
-> decltype(DestClock::from_sys(t));
4 Constraints: DestClock::from_sys(t) is well-formed.
5 Mandates: DestClock::from_sys(t) returns atime_point<DestClock, Duration2> for some type
Duration2 (30.6.1).
6 Returns: DestClock::from_sys(t).
30.7.10.5 Conversions between utc_clock and other clocks [time.clock.cast.utc]
template<class SourceClock>
struct clock_time_conversion<utc_clock, SourceClock> {
template<class Duration>
auto operator()(const time_point<SourceClock, Duration>& t) const
-> decltype(SourceClock::to_utc(t));
};
template<class Duration>
auto operator()(const time_point<SourceClock, Duration>& t) const
-> decltype(SourceClock::to_utc(t));
1 Constraints: SourceClock::to_utc(t) is well-formed.
2 Mandates: SourceClock::to_utc(t) returns a utc_time<Duration2> for some type Duration2
(30.6.1).
3 Returns: SourceClock::to_utc(t).
template<class DestClock>
struct clock_time_conversion<DestClock, utc_clock> {
template<class Duration>
auto operator()(const utc_time<Duration>& t) const
-> decltype(DestClock::from_utc(t));
};
§ 30.7.10.5 © ISO/IEC
1948

===== PAGE 1960 =====

Dxxxx
template<class Duration>
auto operator()(const utc_time<Duration>& t) const
-> decltype(DestClock::from_utc(t));
4 Constraints: DestClock::from_utc(t) is well-formed.
5 Mandates: DestClock::from_utc(t) returns atime_point<DestClock, Duration2> for some type
Duration2 (30.6.1).
6 Returns: DestClock::from_utc(t).
30.7.10.6 Function template clock_cast [time.clock.cast.fn]
template<class DestClock, class SourceClock, class Duration>
auto clock_cast(const time_point<SourceClock, Duration>& t);
1 Constraints: At least one of the following clock time conversion expressions is well-formed:
—(1.1) clock_time_conversion<DestClock, SourceClock>{}(t)
—(1.2) clock_time_conversion<DestClock, system_clock>{}(
clock_time_conversion<system_clock, SourceClock>{}(t))
—(1.3) clock_time_conversion<DestClock, utc_clock>{}(
clock_time_conversion<utc_clock, SourceClock>{}(t))
—(1.4) clock_time_conversion<DestClock, utc_clock>{}(
clock_time_conversion<utc_clock, system_clock>{}(
clock_time_conversion<system_clock, SourceClock>{}(t)))
—(1.5) clock_time_conversion<DestClock, system_clock>{}(
clock_time_conversion<system_clock, utc_clock>{}(
clock_time_conversion<utc_clock, SourceClock>{}(t)))
A clock time conversion expression is considered better than another clock time conversion expression
if it involves feweroperator() calls onclock_time_conversion specializations.
2 Mandates: Among the well-formed clock time conversion expressions from the above list, there is a
unique best expression.
3 Returns: The best well-formed clock time conversion expression in the above list.
30.8 The civil calendar [time.cal]
30.8.1 General [time.cal.general]
1 The types in 30.8 describe the civil (Gregorian) calendar and its relationship tosys_days and local_days.
30.8.2 Class last_spec [time.cal.last]
namespace std::chrono {
struct last_spec {
explicit last_spec() = default;
};
}
1 The typelast_spec is used in conjunction with other calendar types to specify the last in a sequence. For
example, depending on context, it can represent the last day of a month, or the last day of the week of a
month.
30.8.3 Class day [time.cal.day]
30.8.3.1 Overview [time.cal.day.overview]
namespace std::chrono {
class day {
unsigned char d_; // exposition only
public:
day() = default;
constexpr explicit day(unsigned d) noexcept;
§ 30.8.3.1 © ISO/IEC
1949

===== PAGE 1961 =====

Dxxxx
constexpr day& operator++() noexcept;
constexpr day operator++(int) noexcept;
constexpr day& operator--() noexcept;
constexpr day operator--(int) noexcept;
constexpr day& operator+=(const days& d) noexcept;
constexpr day& operator-=(const days& d) noexcept;
constexpr explicit operator unsigned() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 day represents a day of a month. It normally holds values in the range 1 to 31, but may hold non-negative
values outside this range. It can be constructed with anyunsigned value, which will be subsequently
truncated to fit intoday’s unspecified internal storage.day meets theCpp17EqualityComparable (Table 28)
and Cpp17LessThanComparable(Table 29) requirements, and participates in basic arithmetic withdays
objects, which represent a difference between twoday objects.
2 day is a trivially copyable and standard-layout class type.
30.8.3.2 Member functions [time.cal.day.members]
constexpr explicit day(unsigned d) noexcept;
1 Effects: Initializes d_ with d. The value held is unspecified ifd is not in the range[0,255].
constexpr day& operator++() noexcept;
2 Effects: ++d_.
3 Returns: *this.
constexpr day operator++(int) noexcept;
4 Effects: ++(*this).
5 Returns: A copy of*this as it existed on entry to this member function.
constexpr day& operator--() noexcept;
6 Effects: Equivalent to:--d_.
7 Returns: *this.
constexpr day operator--(int) noexcept;
8 Effects: --(*this).
9 Returns: A copy of*this as it existed on entry to this member function.
constexpr day& operator+=(const days& d) noexcept;
10 Effects: *this = *this + d.
11 Returns: *this.
constexpr day& operator-=(const days& d) noexcept;
12 Effects: *this = *this - d.
13 Returns: *this.
constexpr explicit operator unsigned() const noexcept;
14 Returns: d_.
constexpr bool ok() const noexcept;
15 Returns: 1 <= d_ && d_ <= 31.
§ 30.8.3.2 © ISO/IEC
1950

===== PAGE 1962 =====

Dxxxx
30.8.3.3 Non-member functions [time.cal.day.nonmembers]
constexpr bool operator==(const day& x, const day& y) noexcept;
1 Returns: unsigned{x} == unsigned{y}.
constexpr strong_ordering operator<=>(const day& x, const day& y) noexcept;
2 Returns: unsigned{x} <=> unsigned{y}.
constexpr day operator+(const day& x, const days& y) noexcept;
3 Returns: day(unsigned{x} + y.count()).
constexpr day operator+(const days& x, const day& y) noexcept;
4 Returns: y + x.
constexpr day operator-(const day& x, const days& y) noexcept;
5 Returns: x + -y.
constexpr days operator-(const day& x, const day& y) noexcept;
6 Returns: days{int(unsigned{x}) - int(unsigned{y})}.
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const day& d);
7 Effects: Equivalent to:
return os << (d.ok() ?
format(STATICALLY-WIDEN <charT>("{:%d}"), d) :
format(STATICALLY-WIDEN <charT>("{:%d} is not a valid day"), d));
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
day& d, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
8 Effects: Attempts to parse the input streamis into theday dusing the format flags given in the NTCTS
fmt as specified in 30.13. If the parse fails to decode a valid day,is.setstate(ios_base::failbit)
is called andd is not modified. If%Z is used and successfully parsed, that value will be assigned to
*abbrev if abbrev is non-null. If%z (or a modified variant) is used and successfully parsed, that value
will be assigned to*offset if offset is non-null.
9 Returns: is.
constexpr chrono::day operator""d(unsigned long long d) noexcept;
10 Returns: day{static_cast<unsigned>(d)}.
30.8.4 Class month [time.cal.month]
30.8.4.1 Overview [time.cal.month.overview]
namespace std::chrono {
class month {
unsigned char m_; // exposition only
public:
month() = default;
constexpr explicit month(unsigned m) noexcept;
constexpr month& operator++() noexcept;
constexpr month operator++(int) noexcept;
constexpr month& operator--() noexcept;
constexpr month operator--(int) noexcept;
constexpr month& operator+=(const months& m) noexcept;
constexpr month& operator-=(const months& m) noexcept;
§ 30.8.4.1 © ISO/IEC
1951

===== PAGE 1963 =====

Dxxxx
constexpr explicit operator unsigned() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 month represents a month of a year. It normally holds values in the range 1 to 12, but may hold non-negative
values outside this range. It can be constructed with anyunsignedvalue, which will be subsequently truncated
to fit intomonth’s unspecified internal storage.month meets theCpp17EqualityComparable (Table 28) and
Cpp17LessThanComparable(Table 29) requirements, and participates in basic arithmetic withmonths objects,
which represent a difference between twomonth objects.
2 month is a trivially copyable and standard-layout class type.
30.8.4.2 Member functions [time.cal.month.members]
constexpr explicit month(unsigned m) noexcept;
1 Effects: Initializes m_ with m. The value held is unspecified ifm is not in the range[0,255].
constexpr month& operator++() noexcept;
2 Effects: *this += months{1}.
3 Returns: *this.
constexpr month operator++(int) noexcept;
4 Effects: ++(*this).
5 Returns: A copy of*this as it existed on entry to this member function.
constexpr month& operator--() noexcept;
6 Effects: *this -= months{1}.
7 Returns: *this.
constexpr month operator--(int) noexcept;
8 Effects: --(*this).
9 Returns: A copy of*this as it existed on entry to this member function.
constexpr month& operator+=(const months& m) noexcept;
10 Effects: *this = *this + m.
11 Returns: *this.
constexpr month& operator-=(const months& m) noexcept;
12 Effects: *this = *this - m.
13 Returns: *this.
constexpr explicit operator unsigned() const noexcept;
14 Returns: m_.
constexpr bool ok() const noexcept;
15 Returns: 1 <= m_ && m_ <= 12.
30.8.4.3 Non-member functions [time.cal.month.nonmembers]
constexpr bool operator==(const month& x, const month& y) noexcept;
1 Returns: unsigned{x} == unsigned{y}.
constexpr strong_ordering operator<=>(const month& x, const month& y) noexcept;
2 Returns: unsigned{x} <=> unsigned{y}.
constexpr month operator+(const month& x, const months& y) noexcept;
3 Returns:
month{modulo(static_cast<long long>(unsigned{x}) + (y.count() - 1), 12) + 1}
§ 30.8.4.3 © ISO/IEC
1952

===== PAGE 1964 =====

Dxxxx
where modulo(n, 12) computes the remainder ofn divided by 12 using Euclidean division.
[Note 1: Given a divisor of 12, Euclidean division truncates towards negative infinity and always produces a
remainder in the range of[0,11]. Assuming no overflow in the signed summation, this operation results in a
month holding a value in the range[1,12] even if!x.ok(). —end note]
[Example 1: February + months{11} == January. —end example]
constexpr month operator+(const months& x, const month& y) noexcept;
4 Returns: y + x.
constexpr month operator-(const month& x, const months& y) noexcept;
5 Returns: x + -y.
constexpr months operator-(const month& x, const month& y) noexcept;
6 Returns: If x.ok() == true and y.ok() == true, returns a value m in the range [months{0},
months{11}] satisfying y + m == x. Otherwise the value returned is unspecified.
[Example 2: January - February == months{11}. —end example]
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month& m);
7 Effects: Equivalent to:
return os << (m.ok() ?
format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%b}"), m) :
format(os.getloc(), STATICALLY-WIDEN <charT>("{} is not a valid month"),
static_cast<unsigned>(m)));
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
month& m, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
8 Effects: Attempts to parse the input streamis into themonth musing the format flags given in the
NTCTS fmt as specified in 30.13. If the parse fails to decode a valid month,is.setstate(ios_-
base::failbit) is called andm is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null.
9 Returns: is.
30.8.5 Class year [time.cal.year]
30.8.5.1 Overview [time.cal.year.overview]
namespace std::chrono {
class year {
short y_; // exposition only
public:
year() = default;
constexpr explicit year(int y) noexcept;
constexpr year& operator++() noexcept;
constexpr year operator++(int) noexcept;
constexpr year& operator--() noexcept;
constexpr year operator--(int) noexcept;
constexpr year& operator+=(const years& y) noexcept;
constexpr year& operator-=(const years& y) noexcept;
constexpr year operator+() const noexcept;
constexpr year operator-() const noexcept;
constexpr bool is_leap() const noexcept;
§ 30.8.5.1 © ISO/IEC
1953

===== PAGE 1965 =====

Dxxxx
constexpr explicit operator int() const noexcept;
constexpr bool ok() const noexcept;
static constexpr year min() noexcept;
static constexpr year max() noexcept;
};
}
1 year represents a year in the civil calendar. It can represent values in the range[min(),max()]. It can be
constructed with anyint value, which will be subsequently truncated to fit intoyear’s unspecified internal
storage. year meets theCpp17EqualityComparable (Table 28) andCpp17LessThanComparable(Table 29)
requirements, and participates in basic arithmetic withyears objects, which represent a difference between
two year objects.
2 year is a trivially copyable and standard-layout class type.
30.8.5.2 Member functions [time.cal.year.members]
constexpr explicit year(int y) noexcept;
1 Effects: Initializes y_ with y. The value held is unspecified ify is not in the range[-32767,32767].
constexpr year& operator++() noexcept;
2 Effects: ++y_.
3 Returns: *this.
constexpr year operator++(int) noexcept;
4 Effects: ++(*this).
5 Returns: A copy of*this as it existed on entry to this member function.
constexpr year& operator--() noexcept;
6 Effects: --y_.
7 Returns: *this.
constexpr year operator--(int) noexcept;
8 Effects: --(*this).
9 Returns: A copy of*this as it existed on entry to this member function.
constexpr year& operator+=(const years& y) noexcept;
10 Effects: *this = *this + y.
11 Returns: *this.
constexpr year& operator-=(const years& y) noexcept;
12 Effects: *this = *this - y.
13 Returns: *this.
constexpr year operator+() const noexcept;
14 Returns: *this.
constexpr year operator-() const noexcept;
15 Returns: year{-y_}.
constexpr bool is_leap() const noexcept;
16 Returns: y_ % 4 == 0 && (y_ % 100 != 0 || y_ % 400 == 0).
constexpr explicit operator int() const noexcept;
17 Returns: y_.
constexpr bool ok() const noexcept;
18 Returns: min().y_ <= y_ && y_ <= max().y_.
§ 30.8.5.2 © ISO/IEC
1954

===== PAGE 1966 =====

Dxxxx
static constexpr year min() noexcept;
19 Returns: year{-32767}.
static constexpr year max() noexcept;
20 Returns: year{32767}.
30.8.5.3 Non-member functions [time.cal.year.nonmembers]
constexpr bool operator==(const year& x, const year& y) noexcept;
1 Returns: int{x} == int{y}.
constexpr strong_ordering operator<=>(const year& x, const year& y) noexcept;
2 Returns: int{x} <=> int{y}.
constexpr year operator+(const year& x, const years& y) noexcept;
3 Returns: year{int{x} + static_cast<int>(y.count())}.
constexpr year operator+(const years& x, const year& y) noexcept;
4 Returns: y + x.
constexpr year operator-(const year& x, const years& y) noexcept;
5 Returns: x + -y.
constexpr years operator-(const year& x, const year& y) noexcept;
6 Returns: years{int{x} - int{y}}.
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year& y);
7 Effects: Equivalent to:
return os << (y.ok() ?
format(STATICALLY-WIDEN <charT>("{:%Y}"), y) :
format(STATICALLY-WIDEN <charT>("{:%Y} is not a valid year"), y));
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
year& y, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
8 Effects: Attempts to parse the input streamisinto theyeary using the format flags given in the NTCTS
fmt as specified in 30.13. If the parse fails to decode a valid year,is.setstate(ios_base::failbit)
is called andy is not modified. If%Z is used and successfully parsed, that value will be assigned to
*abbrev if abbrev is non-null. If%z (or a modified variant) is used and successfully parsed, that value
will be assigned to*offset if offset is non-null.
9 Returns: is.
constexpr chrono::year operator""y(unsigned long long y) noexcept;
10 Returns: year{static_cast<int>(y)}.
30.8.6 Class weekday [time.cal.wd]
30.8.6.1 Overview [time.cal.wd.overview]
namespace std::chrono {
class weekday {
unsigned char wd_; // exposition only
public:
weekday() = default;
constexpr explicit weekday(unsigned wd) noexcept;
constexpr weekday(const sys_days& dp) noexcept;
constexpr explicit weekday(const local_days& dp) noexcept;
§ 30.8.6.1 © ISO/IEC
1955

===== PAGE 1967 =====

Dxxxx
constexpr weekday& operator++() noexcept;
constexpr weekday operator++(int) noexcept;
constexpr weekday& operator--() noexcept;
constexpr weekday operator--(int) noexcept;
constexpr weekday& operator+=(const days& d) noexcept;
constexpr weekday& operator-=(const days& d) noexcept;
constexpr unsigned c_encoding() const noexcept;
constexpr unsigned iso_encoding() const noexcept;
constexpr bool ok() const noexcept;
constexpr weekday_indexed operator[](unsigned index) const noexcept;
constexpr weekday_last operator[](last_spec) const noexcept;
};
}
1 weekday represents a day of the week in the civil calendar. It normally holds values in the range0 to 6,
corresponding to Sunday through Saturday, but it may hold non-negative values outside this range. It can be
constructed with anyunsigned value, which will be subsequently truncated to fit intoweekday’s unspecified
internal storage.weekday meets theCpp17EqualityComparable (Table 28) requirements.
[Note 1: weekday is notCpp17LessThanComparablebecause there is no universal consensus on which day is the first
day of the week.weekday’s arithmetic operations treat the days of the week as a circular range, with no beginning
and no end. —end note]
2 weekday is a trivially copyable and standard-layout class type.
30.8.6.2 Member functions [time.cal.wd.members]
constexpr explicit weekday(unsigned wd) noexcept;
1 Effects: Initializes wd_ with wd == 7 ? 0 : wd. The value held is unspecified ifwd is not in the range
[0,255].
constexpr weekday(const sys_days& dp) noexcept;
2 Effects: Computes what day of the week corresponds to thesys_days dp, and initializes that day of
the week inwd_.
3 [Example 1: If dp represents 1970-01-01, the constructedweekday represents Thursday by storing4 in wd_.
—end example]
constexpr explicit weekday(const local_days& dp) noexcept;
4 Effects: Computes what day of the week corresponds to thelocal_days dp, and initializes that day of
the week inwd_.
5 Postconditions: The value is identical to that constructed fromsys_days{dp.time_since_epoch()}.
constexpr weekday& operator++() noexcept;
6 Effects: *this += days{1}.
7 Returns: *this.
constexpr weekday operator++(int) noexcept;
8 Effects: ++(*this).
9 Returns: A copy of*this as it existed on entry to this member function.
constexpr weekday& operator--() noexcept;
10 Effects: *this -= days{1}.
11 Returns: *this.
constexpr weekday operator--(int) noexcept;
12 Effects: --(*this).
13 Returns: A copy of*this as it existed on entry to this member function.
§ 30.8.6.2 © ISO/IEC
1956

===== PAGE 1968 =====

Dxxxx
constexpr weekday& operator+=(const days& d) noexcept;
14 Effects: *this = *this + d.
15 Returns: *this.
constexpr weekday& operator-=(const days& d) noexcept;
16 Effects: *this = *this - d.
17 Returns: *this.
constexpr unsigned c_encoding() const noexcept;
18 Returns: wd_.
constexpr unsigned iso_encoding() const noexcept;
19 Returns: wd_ == 0u ? 7u : wd_.
constexpr bool ok() const noexcept;
20 Returns: wd_ <= 6.
constexpr weekday_indexed operator[](unsigned index) const noexcept;
21 Returns: {*this, index}.
constexpr weekday_last operator[](last_spec) const noexcept;
22 Returns: weekday_last{*this}.
30.8.6.3 Non-member functions [time.cal.wd.nonmembers]
constexpr bool operator==(const weekday& x, const weekday& y) noexcept;
1 Returns: x.wd_ == y.wd_.
constexpr weekday operator+(const weekday& x, const days& y) noexcept;
2 Returns:
weekday{modulo(static_cast<long long>(x.wd_) + y.count(), 7)}
where modulo(n, 7) computes the remainder ofn divided by 7 using Euclidean division.
[Note 1: Given a divisor of 7, Euclidean division truncates towards negative infinity and always produces a
remainder in the range of[0,6]. Assuming no overflow in the signed summation, this operation results in a
weekday holding a value in the range[0,6] even if!x.ok(). —end note]
[Example 1: Monday + days{6} == Sunday. —end example]
constexpr weekday operator+(const days& x, const weekday& y) noexcept;
3 Returns: y + x.
constexpr weekday operator-(const weekday& x, const days& y) noexcept;
4 Returns: x + -y.
constexpr days operator-(const weekday& x, const weekday& y) noexcept;
5 Returns: If x.ok() == true and y.ok() == true, returns a valued in the range[days{0},days{6}]
satisfying y + d == x. Otherwise the value returned is unspecified.
[Example 2: Sunday - Monday == days{6}. —end example]
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const weekday& wd);
6 Effects: Equivalent to:
return os << (wd.ok() ?
format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%a}"), wd) :
format(os.getloc(), STATICALLY-WIDEN <charT>("{} is not a valid weekday"),
static_cast<unsigned>(wd.wd_)));
§ 30.8.6.3 © ISO/IEC
1957

===== PAGE 1969 =====

Dxxxx
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
weekday& wd, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
7 Effects: Attempts to parse the input streamis into theweekday wdusing the format flags given in
the NTCTSfmt as specified in 30.13. If the parse fails to decode a valid weekday,is.setstate(ios_-
base::failbit) is called andwd is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null.
8 Returns: is.
30.8.7 Class weekday_indexed [time.cal.wdidx]
30.8.7.1 Overview [time.cal.wdidx.overview]
namespace std::chrono {
class weekday_indexed {
chrono::weekday wd_; // exposition only
unsigned char index_; // exposition only
public:
weekday_indexed() = default;
constexpr weekday_indexed(const chrono::weekday& wd, unsigned index) noexcept;
constexpr chrono::weekday weekday() const noexcept;
constexpr unsigned index() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 weekday_indexed represents aweekday and a small index in the range 1 to 5. This class is used to represent
the first, second, third, fourth, or fifth weekday of a month.
2 [Note 1: A weekday_indexed object can be constructed by indexing aweekday with anunsigned. —end note]
[Example 1:
constexpr auto wdi = Sunday[2]; // wdi is the second Sunday of an as yet unspecified month
static_assert(wdi.weekday() == Sunday);
static_assert(wdi.index() == 2);
—end example]
3 weekday_indexed is a trivially copyable and standard-layout class type.
30.8.7.2 Member functions [time.cal.wdidx.members]
constexpr weekday_indexed(const chrono::weekday& wd, unsigned index) noexcept;
1 Effects: Initializes wd_ with wd and index_ with index. The values held are unspecified if!wd.ok()
or index is not in the range[0,7].
constexpr chrono::weekday weekday() const noexcept;
2 Returns: wd_.
constexpr unsigned index() const noexcept;
3 Returns: index_.
constexpr bool ok() const noexcept;
4 Returns: wd_.ok() && 1 <= index_ && index_ <= 5.
30.8.7.3 Non-member functions [time.cal.wdidx.nonmembers]
constexpr bool operator==(const weekday_indexed& x, const weekday_indexed& y) noexcept;
1 Returns: x.weekday() == y.weekday() && x.index() == y.index().
§ 30.8.7.3 © ISO/IEC
1958

===== PAGE 1970 =====

Dxxxx
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const weekday_indexed& wdi);
2 Effects: Equivalent to:
auto i = wdi.index();
return os << (i >= 1 && i <= 5 ?
format(os.getloc(), STATICALLY-WIDEN <charT>("{:L}[{}]"), wdi.weekday(), i) :
format(os.getloc(), STATICALLY-WIDEN <charT>("{:L}[{} is not a valid index]"),
wdi.weekday(), i));
30.8.8 Class weekday_last [time.cal.wdlast]
30.8.8.1 Overview [time.cal.wdlast.overview]
namespace std::chrono {
class weekday_last {
chrono::weekday wd_; // exposition only
public:
constexpr explicit weekday_last(const chrono::weekday& wd) noexcept;
constexpr chrono::weekday weekday() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 weekday_last represents the last weekday of a month.
2 [Note 1: A weekday_last object can be constructed by indexing aweekday with last. —end note]
[Example 1:
constexpr auto wdl = Sunday[last]; // wdl is the last Sunday of an as yet unspecified month
static_assert(wdl.weekday() == Sunday);
—end example]
3 weekday_last is a trivially copyable and standard-layout class type.
30.8.8.2 Member functions [time.cal.wdlast.members]
constexpr explicit weekday_last(const chrono::weekday& wd) noexcept;
1 Effects: Initializes wd_ with wd.
constexpr chrono::weekday weekday() const noexcept;
2 Returns: wd_.
constexpr bool ok() const noexcept;
3 Returns: wd_.ok().
30.8.8.3 Non-member functions [time.cal.wdlast.nonmembers]
constexpr bool operator==(const weekday_last& x, const weekday_last& y) noexcept;
1 Returns: x.weekday() == y.weekday().
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const weekday_last& wdl);
2 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L}[last]"), wdl.weekday());
30.8.9 Class month_day [time.cal.md]
30.8.9.1 Overview [time.cal.md.overview]
namespace std::chrono {
class month_day {
chrono::month m_; // exposition only
§ 30.8.9.1 © ISO/IEC
1959

===== PAGE 1971 =====

Dxxxx
chrono::day d_; // exposition only
public:
month_day() = default;
constexpr month_day(const chrono::month& m, const chrono::day& d) noexcept;
constexpr chrono::month month() const noexcept;
constexpr chrono::day day() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 month_day represents a specific day of a specific month, but with an unspecified year.month_day meets the
Cpp17EqualityComparable (Table 28) andCpp17LessThanComparable(Table 29) requirements.
2 month_day is a trivially copyable and standard-layout class type.
30.8.9.2 Member functions [time.cal.md.members]
constexpr month_day(const chrono::month& m, const chrono::day& d) noexcept;
1 Effects: Initializes m_ with m, andd_ with d.
constexpr chrono::month month() const noexcept;
2 Returns: m_.
constexpr chrono::day day() const noexcept;
3 Returns: d_.
constexpr bool ok() const noexcept;
4 Returns: true if m_.ok() is true, 1d <= d_, andd_ is less than or equal to the number of days in
month m_; otherwise returnsfalse. When m_ == February, the number of days is considered to be 29.
30.8.9.3 Non-member functions [time.cal.md.nonmembers]
constexpr bool operator==(const month_day& x, const month_day& y) noexcept;
1 Returns: x.month() == y.month() && x.day() == y.day().
constexpr strong_ordering operator<=>(const month_day& x, const month_day& y) noexcept;
2 Effects: Equivalent to:
if (auto c = x.month() <=> y.month(); c != 0) return c;
return x.day() <=> y.day();
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_day& md);
3 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L}/{}"),
md.month(), md.day());
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
month_day& md, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
4 Effects: Attempts to parse the input streamis into themonth_day mdusing the format flags given in the
NTCTS fmt as specified in 30.13. If the parse fails to decode a validmonth_day, is.setstate(ios_-
base::failbit) is called andmd is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null.
5 Returns: is.
§ 30.8.9.3 © ISO/IEC
1960

===== PAGE 1972 =====

Dxxxx
30.8.10 Class month_day_last [time.cal.mdlast]
namespace std::chrono {
class month_day_last {
chrono::month m_; // exposition only
public:
constexpr explicit month_day_last(const chrono::month& m) noexcept;
constexpr chrono::month month() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 month_day_last represents the last day of a month.
2 [Note 1: Amonth_day_last object can be constructed using the expressionm/last or last/m, wherem is an expression
of typemonth. —end note]
[Example 1:
constexpr auto mdl = February/last; // mdl is the last day of February of an as yet unspecified year
static_assert(mdl.month() == February);
—end example]
3 month_day_last is a trivially copyable and standard-layout class type.
constexpr explicit month_day_last(const chrono::month& m) noexcept;
4 Effects: Initializes m_ with m.
constexpr month month() const noexcept;
5 Returns: m_.
constexpr bool ok() const noexcept;
6 Returns: m_.ok().
constexpr bool operator==(const month_day_last& x, const month_day_last& y) noexcept;
7 Returns: x.month() == y.month().
constexpr strong_ordering operator<=>(const month_day_last& x, const month_day_last& y) noexcept;
8 Returns: x.month() <=> y.month().
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_day_last& mdl);
9 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L}/last"), mdl.month());
30.8.11 Class month_weekday [time.cal.mwd]
30.8.11.1 Overview [time.cal.mwd.overview]
namespace std::chrono {
class month_weekday {
chrono::month m_; // exposition only
chrono::weekday_indexed wdi_; // exposition only
public:
constexpr month_weekday(const chrono::month& m, const chrono::weekday_indexed& wdi) noexcept;
constexpr chrono::month month() const noexcept;
constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 month_weekday represents the nth weekday of a month, of an as yet unspecified year. To do this the
month_weekday stores amonth and aweekday_indexed.
§ 30.8.11.1 © ISO/IEC
1961

===== PAGE 1973 =====

Dxxxx
2 [Example 1:
constexpr auto mwd
= February/Tuesday[3]; // mwd is the third Tuesday of February of an as yet unspecified year
static_assert(mwd.month() == February);
static_assert(mwd.weekday_indexed() == Tuesday[3]);
—end example]
3 month_weekday is a trivially copyable and standard-layout class type.
30.8.11.2 Member functions [time.cal.mwd.members]
constexpr month_weekday(const chrono::month& m, const chrono::weekday_indexed& wdi) noexcept;
1 Effects: Initializes m_ with m, andwdi_ with wdi.
constexpr chrono::month month() const noexcept;
2 Returns: m_.
constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
3 Returns: wdi_.
constexpr bool ok() const noexcept;
4 Returns: m_.ok() && wdi_.ok().
30.8.11.3 Non-member functions [time.cal.mwd.nonmembers]
constexpr bool operator==(const month_weekday& x, const month_weekday& y) noexcept;
1 Returns: x.month() == y.month() && x.weekday_indexed() == y.weekday_indexed().
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_weekday& mwd);
2 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L}/{:L}"),
mwd.month(), mwd.weekday_indexed());
30.8.12 Class month_weekday_last [time.cal.mwdlast]
30.8.12.1 Overview [time.cal.mwdlast.overview]
namespace std::chrono {
class month_weekday_last {
chrono::month m_; // exposition only
chrono::weekday_last wdl_; // exposition only
public:
constexpr month_weekday_last(const chrono::month& m,
const chrono::weekday_last& wdl) noexcept;
constexpr chrono::month month() const noexcept;
constexpr chrono::weekday_last weekday_last() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 month_weekday_last represents the last weekday of a month, of an as yet unspecified year. To do this the
month_weekday_last stores amonth and aweekday_last.
2 [Example 1:
constexpr auto mwd
= February/Tuesday[last]; // mwd is the last Tuesday of February of an as yet unspecified year
static_assert(mwd.month() == February);
static_assert(mwd.weekday_last() == Tuesday[last]);
—end example]
3 month_weekday_last is a trivially copyable and standard-layout class type.
§ 30.8.12.1 © ISO/IEC
1962

===== PAGE 1974 =====

Dxxxx
30.8.12.2 Member functions [time.cal.mwdlast.members]
constexpr month_weekday_last(const chrono::month& m,
const chrono::weekday_last& wdl) noexcept;
1 Effects: Initializes m_ with m, andwdl_ with wdl.
constexpr chrono::month month() const noexcept;
2 Returns: m_.
constexpr chrono::weekday_last weekday_last() const noexcept;
3 Returns: wdl_.
constexpr bool ok() const noexcept;
4 Returns: m_.ok() && wdl_.ok().
30.8.12.3 Non-member functions [time.cal.mwdlast.nonmembers]
constexpr bool operator==(const month_weekday_last& x, const month_weekday_last& y) noexcept;
1 Returns: x.month() == y.month() && x.weekday_last() == y.weekday_last().
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const month_weekday_last& mwdl);
2 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L}/{:L}"),
mwdl.month(), mwdl.weekday_last());
30.8.13 Class year_month [time.cal.ym]
30.8.13.1 Overview [time.cal.ym.overview]
namespace std::chrono {
class year_month {
chrono::year y_; // exposition only
chrono::month m_; // exposition only
public:
year_month() = default;
constexpr year_month(const chrono::year& y, const chrono::month& m) noexcept;
constexpr chrono::year year() const noexcept;
constexpr chrono::month month() const noexcept;
constexpr year_month& operator+=(const months& dm) noexcept;
constexpr year_month& operator-=(const months& dm) noexcept;
constexpr year_month& operator+=(const years& dy) noexcept;
constexpr year_month& operator-=(const years& dy) noexcept;
constexpr bool ok() const noexcept;
};
}
1 year_month represents a specific month of a specific year, but with an unspecified day.year_month is
a field-based time point with a resolution ofmonths. year_month meets the Cpp17EqualityComparable
(Table 28) andCpp17LessThanComparable(Table 29) requirements.
2 year_month is a trivially copyable and standard-layout class type.
30.8.13.2 Member functions [time.cal.ym.members]
constexpr year_month(const chrono::year& y, const chrono::month& m) noexcept;
1 Effects: Initializes y_ with y, andm_ with m.
§ 30.8.13.2 © ISO/IEC
1963

===== PAGE 1975 =====

Dxxxx
constexpr chrono::year year() const noexcept;
2 Returns: y_.
constexpr chrono::month month() const noexcept;
3 Returns: m_.
constexpr year_month& operator+=(const months& dm) noexcept;
4 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
5 Effects: *this = *this + dm.
6 Returns: *this.
constexpr year_month& operator-=(const months& dm) noexcept;
7 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
8 Effects: *this = *this - dm.
9 Returns: *this.
constexpr year_month& operator+=(const years& dy) noexcept;
10 Effects: *this = *this + dy.
11 Returns: *this.
constexpr year_month& operator-=(const years& dy) noexcept;
12 Effects: *this = *this - dy.
13 Returns: *this.
constexpr bool ok() const noexcept;
14 Returns: y_.ok() && m_.ok().
30.8.13.3 Non-member functions [time.cal.ym.nonmembers]
constexpr bool operator==(const year_month& x, const year_month& y) noexcept;
1 Returns: x.year() == y.year() && x.month() == y.month().
constexpr strong_ordering operator<=>(const year_month& x, const year_month& y) noexcept;
2 Effects: Equivalent to:
if (auto c = x.year() <=> y.year(); c != 0) return c;
return x.month() <=> y.month();
constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
3 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
4 Returns: A year_month value z such thatz.ok() && z - ym == dm is true.
5 Complexity: O(1) with respect to the value ofdm.
constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
6 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
7 Returns: ym + dm.
constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
8 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
9 Returns: ym + -dm.
§ 30.8.13.3 © ISO/IEC
1964

===== PAGE 1976 =====

Dxxxx
constexpr months operator-(const year_month& x, const year_month& y) noexcept;
10 Returns:
x.year() - y.year() + months{static_cast<int>(unsigned{x.month()}) -
static_cast<int>(unsigned{y.month()})}
constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
11 Returns: (ym.year() + dy) / ym.month().
constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
12 Returns: ym + dy.
constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;
13 Returns: ym + -dy.
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month& ym);
14 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{}/{:L}"),
ym.year(), ym.month());
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
year_month& ym, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
15 Effects: Attempts to parse the input streamisinto theyear_monthym using the format flags given in the
NTCTS fmt as specified in 30.13. If the parse fails to decode a validyear_month, is.setstate(ios_-
base::failbit) is called andym is not modified. If%Z is used and successfully parsed, that value will
be assigned to*abbrev if abbrev is non-null. If %z (or a modified variant) is used and successfully
parsed, that value will be assigned to*offset if offset is non-null.
16 Returns: is.
30.8.14 Class year_month_day [time.cal.ymd]
30.8.14.1 Overview [time.cal.ymd.overview]
namespace std::chrono {
class year_month_day {
chrono::year y_; // exposition only
chrono::month m_; // exposition only
chrono::day d_; // exposition only
public:
year_month_day() = default;
constexpr year_month_day(const chrono::year& y, const chrono::month& m,
const chrono::day& d) noexcept;
constexpr year_month_day(const year_month_day_last& ymdl) noexcept;
constexpr year_month_day(const sys_days& dp) noexcept;
constexpr explicit year_month_day(const local_days& dp) noexcept;
constexpr year_month_day& operator+=(const months& m) noexcept;
constexpr year_month_day& operator-=(const months& m) noexcept;
constexpr year_month_day& operator+=(const years& y) noexcept;
constexpr year_month_day& operator-=(const years& y) noexcept;
constexpr chrono::year year() const noexcept;
constexpr chrono::month month() const noexcept;
constexpr chrono::day day() const noexcept;
constexpr operator sys_days() const noexcept;
constexpr explicit operator local_days() const noexcept;
§ 30.8.14.1 © ISO/IEC
1965

===== PAGE 1977 =====

Dxxxx
constexpr bool ok() const noexcept;
};
}
1 year_month_day represents a specific year, month, and day.year_month_day is a field-based time point
with a resolution ofdays.
[Note 1: year_month_day supports years- andmonths-oriented arithmetic, but notdays-oriented arithmetic. For the
latter, there is a conversion tosys_days, which efficiently supportsdays-oriented arithmetic. —end note]
year_month_day meets theCpp17EqualityComparable (Table 28) andCpp17LessThanComparable(Table 29)
requirements.
2 year_month_day is a trivially copyable and standard-layout class type.
30.8.14.2 Member functions [time.cal.ymd.members]
constexpr year_month_day(const chrono::year& y, const chrono::month& m,
const chrono::day& d) noexcept;
1 Effects: Initializes y_ with y, m_ with m, andd_ with d.
constexpr year_month_day(const year_month_day_last& ymdl) noexcept;
2 Effects: Initializes y_ with ymdl.year(), m_ with ymdl.month(), andd_ with ymdl.day().
[Note 1: This conversion fromyear_month_day_last to year_month_day can be more efficient than converting
a year_month_day_last to asys_days, and then converting thatsys_days to ayear_month_day. —end note]
constexpr year_month_day(const sys_days& dp) noexcept;
3 Effects: Constructs an object of typeyear_month_day that corresponds to the date represented bydp.
4 Remarks: For any valueymd of type year_month_day for which ymd.ok() is true, ymd == year_-
month_day{sys_days{ymd}} is true.
constexpr explicit year_month_day(const local_days& dp) noexcept;
5 Effects: Equivalent to constructing withsys_days{dp.time_since_epoch()}.
constexpr year_month_day& operator+=(const months& m) noexcept;
6 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
7 Effects: *this = *this + m.
8 Returns: *this.
constexpr year_month_day& operator-=(const months& m) noexcept;
9 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
10 Effects: *this = *this - m.
11 Returns: *this.
constexpr year_month_day& year_month_day::operator+=(const years& y) noexcept;
12 Effects: *this = *this + y.
13 Returns: *this.
constexpr year_month_day& year_month_day::operator-=(const years& y) noexcept;
14 Effects: *this = *this - y.
15 Returns: *this.
constexpr chrono::year year() const noexcept;
16 Returns: y_.
constexpr chrono::month month() const noexcept;
17 Returns: m_.
§ 30.8.14.2 © ISO/IEC
1966

===== PAGE 1978 =====

Dxxxx
constexpr chrono::day day() const noexcept;
18 Returns: d_.
constexpr operator sys_days() const noexcept;
19 Returns: If ok(), returns asys_days holding a count of days from thesys_days epoch to *this
(a negative value if*this represents a date prior to thesys_days epoch). Otherwise, if y_.ok()
&& m_.ok() is true, returns sys_days{y_/m_/1d} + (d_ - 1d). Otherwise the value returned is
unspecified.
20 Remarks: A sys_days in the range [days{-12687428},days{11248737}] which is converted to a
year_month_day has the same value when converted back to asys_days.
21 [Example 1:
static_assert(year_month_day{sys_days{2017y/January/0}} == 2016y/December/31);
static_assert(year_month_day{sys_days{2017y/January/31}} == 2017y/January/31);
static_assert(year_month_day{sys_days{2017y/January/32}} == 2017y/February/1);
—end example]
constexpr explicit operator local_days() const noexcept;
22 Returns: local_days{sys_days{*this}.time_since_epoch()}.
constexpr bool ok() const noexcept;
23 Returns: If y_.ok() is true, andm_.ok() is true, andd_ is in the range[1d,(y_/m_/last).day()],
then returnstrue; otherwise returnsfalse.
30.8.14.3 Non-member functions [time.cal.ymd.nonmembers]
constexpr bool operator==(const year_month_day& x, const year_month_day& y) noexcept;
1 Returns: x.year() == y.year() && x.month() == y.month() && x.day() == y.day().
constexpr strong_ordering operator<=>(const year_month_day& x, const year_month_day& y) noexcept;
2 Effects: Equivalent to:
if (auto c = x.year() <=> y.year(); c != 0) return c;
if (auto c = x.month() <=> y.month(); c != 0) return c;
return x.day() <=> y.day();
constexpr year_month_day operator+(const year_month_day& ymd, const months& dm) noexcept;
3 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
4 Returns: (ymd.year() / ymd.month() + dm) / ymd.day().
5 [Note 1: If ymd.day() is in the range[1d,28d], ok() will returntrue for the resultantyear_month_day. —end
note]
constexpr year_month_day operator+(const months& dm, const year_month_day& ymd) noexcept;
6 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
7 Returns: ymd + dm.
constexpr year_month_day operator-(const year_month_day& ymd, const months& dm) noexcept;
8 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
9 Returns: ymd + (-dm).
constexpr year_month_day operator+(const year_month_day& ymd, const years& dy) noexcept;
10 Returns: (ymd.year() + dy) / ymd.month() / ymd.day().
11 [Note 2: If ymd.month() is February andymd.day() is not in the range[1d,28d], ok() can returnfalse for
the resultantyear_month_day. —end note]
§ 30.8.14.3 © ISO/IEC
1967

===== PAGE 1979 =====

Dxxxx
constexpr year_month_day operator+(const years& dy, const year_month_day& ymd) noexcept;
12 Returns: ymd + dy.
constexpr year_month_day operator-(const year_month_day& ymd, const years& dy) noexcept;
13 Returns: ymd + (-dy).
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_day& ymd);
14 Effects: Equivalent to:
return os << (ymd.ok() ?
format(STATICALLY-WIDEN <charT>("{:%F}"), ymd) :
format(STATICALLY-WIDEN <charT>("{:%F} is not a valid date"), ymd));
template<class charT, class traits, class Alloc = allocator<charT>>
basic_istream<charT, traits>&
from_stream(basic_istream<charT, traits>& is, const charT* fmt,
year_month_day& ymd, basic_string<charT, traits, Alloc>* abbrev = nullptr,
minutes* offset = nullptr);
15 Effects: Attempts to parse the input streamis into theyear_month_day ymdusing the format flags
given in the NTCTSfmt as specified in 30.13. If the parse fails to decode a validyear_month_day,
is.setstate(ios_base::failbit) is called andymd is not modified. If%Z is used and successfully
parsed, that value will be assigned to*abbrev if abbrev is non-null. If%z (or a modified variant) is
used and successfully parsed, that value will be assigned to*offset if offset is non-null.
16 Returns: is.
30.8.15 Class year_month_day_last [time.cal.ymdlast]
30.8.15.1 Overview [time.cal.ymdlast.overview]
namespace std::chrono {
class year_month_day_last {
chrono::year y_; // exposition only
chrono::month_day_last mdl_; // exposition only
public:
constexpr year_month_day_last(const chrono::year& y,
const chrono::month_day_last& mdl) noexcept;
constexpr year_month_day_last& operator+=(const months& m) noexcept;
constexpr year_month_day_last& operator-=(const months& m) noexcept;
constexpr year_month_day_last& operator+=(const years& y) noexcept;
constexpr year_month_day_last& operator-=(const years& y) noexcept;
constexpr chrono::year year() const noexcept;
constexpr chrono::month month() const noexcept;
constexpr chrono::month_day_last month_day_last() const noexcept;
constexpr chrono::day day() const noexcept;
constexpr operator sys_days() const noexcept;
constexpr explicit operator local_days() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 year_month_day_last represents the last day of a specific year and month.year_month_day_last is a
field-based time point with a resolution ofdays, except that it is restricted to pointing to the last day of a
year and month.
[Note 1: year_month_day_last supports years- andmonths-oriented arithmetic, but notdays-oriented arithmetic.
For the latter, there is a conversion tosys_days, which efficiently supportsdays-oriented arithmetic. —end note]
year_month_day_last meets the Cpp17EqualityComparable (Table 28) andCpp17LessThanComparable
(Table 29) requirements.
§ 30.8.15.1 © ISO/IEC
1968

===== PAGE 1980 =====

Dxxxx
2 year_month_day_last is a trivially copyable and standard-layout class type.
30.8.15.2 Member functions [time.cal.ymdlast.members]
constexpr year_month_day_last(const chrono::year& y,
const chrono::month_day_last& mdl) noexcept;
1 Effects: Initializes y_ with y and mdl_ with mdl.
constexpr year_month_day_last& operator+=(const months& m) noexcept;
2 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
3 Effects: *this = *this + m.
4 Returns: *this.
constexpr year_month_day_last& operator-=(const months& m) noexcept;
5 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
6 Effects: *this = *this - m.
7 Returns: *this.
constexpr year_month_day_last& operator+=(const years& y) noexcept;
8 Effects: *this = *this + y.
9 Returns: *this.
constexpr year_month_day_last& operator-=(const years& y) noexcept;
10 Effects: *this = *this - y.
11 Returns: *this.
constexpr chrono::year year() const noexcept;
12 Returns: y_.
constexpr chrono::month month() const noexcept;
13 Returns: mdl_.month().
constexpr chrono::month_day_last month_day_last() const noexcept;
14 Returns: mdl_.
constexpr chrono::day day() const noexcept;
15 Returns: If ok() is true, returns aday representing the last day of the (year, month) pair represented
by *this. Otherwise, the returned value is unspecified.
16 [Note 1: This value might be computed on demand.—end note]
constexpr operator sys_days() const noexcept;
17 Returns: sys_days{year()/month()/day()}.
constexpr explicit operator local_days() const noexcept;
18 Returns: local_days{sys_days{*this}.time_since_epoch()}.
constexpr bool ok() const noexcept;
19 Returns: y_.ok() && mdl_.ok().
30.8.15.3 Non-member functions [time.cal.ymdlast.nonmembers]
constexpr bool operator==(const year_month_day_last& x, const year_month_day_last& y) noexcept;
1 Returns: x.year() == y.year() && x.month_day_last() == y.month_day_last().
§ 30.8.15.3 © ISO/IEC
1969

===== PAGE 1981 =====

Dxxxx
constexpr strong_ordering operator<=>(const year_month_day_last& x,
const year_month_day_last& y) noexcept;
2 Effects: Equivalent to:
if (auto c = x.year() <=> y.year(); c != 0) return c;
return x.month_day_last() <=> y.month_day_last();
constexpr year_month_day_last
operator+(const year_month_day_last& ymdl, const months& dm) noexcept;
3 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
4 Returns: (ymdl.year() / ymdl.month() + dm) / last.
constexpr year_month_day_last
operator+(const months& dm, const year_month_day_last& ymdl) noexcept;
5 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
6 Returns: ymdl + dm.
constexpr year_month_day_last
operator-(const year_month_day_last& ymdl, const months& dm) noexcept;
7 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
8 Returns: ymdl + (-dm).
constexpr year_month_day_last
operator+(const year_month_day_last& ymdl, const years& dy) noexcept;
9 Returns: {ymdl.year()+dy, ymdl.month_day_last()}.
constexpr year_month_day_last
operator+(const years& dy, const year_month_day_last& ymdl) noexcept;
10 Returns: ymdl + dy.
constexpr year_month_day_last
operator-(const year_month_day_last& ymdl, const years& dy) noexcept;
11 Returns: ymdl + (-dy).
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_day_last& ymdl);
12 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{}/{:L}"),
ymdl.year(), ymdl.month_day_last());
30.8.16 Class year_month_weekday [time.cal.ymwd]
30.8.16.1 Overview [time.cal.ymwd.overview]
namespace std::chrono {
class year_month_weekday {
chrono::year y_; // exposition only
chrono::month m_; // exposition only
chrono::weekday_indexed wdi_; // exposition only
public:
year_month_weekday() = default;
constexpr year_month_weekday(const chrono::year& y, const chrono::month& m,
const chrono::weekday_indexed& wdi) noexcept;
constexpr year_month_weekday(const sys_days& dp) noexcept;
constexpr explicit year_month_weekday(const local_days& dp) noexcept;
§ 30.8.16.1 © ISO/IEC
1970

===== PAGE 1982 =====

Dxxxx
constexpr year_month_weekday& operator+=(const months& m) noexcept;
constexpr year_month_weekday& operator-=(const months& m) noexcept;
constexpr year_month_weekday& operator+=(const years& y) noexcept;
constexpr year_month_weekday& operator-=(const years& y) noexcept;
constexpr chrono::year year() const noexcept;
constexpr chrono::month month() const noexcept;
constexpr chrono::weekday weekday() const noexcept;
constexpr unsigned index() const noexcept;
constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
constexpr operator sys_days() const noexcept;
constexpr explicit operator local_days() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 year_month_weekdayrepresents a specific year, month, andnth weekday of the month.year_month_weekday
is a field-based time point with a resolution ofdays.
[Note 1: year_month_weekday supports years- andmonths-oriented arithmetic, but notdays-oriented arithmetic.
For the latter, there is a conversion tosys_days, which efficiently supportsdays-oriented arithmetic. —end note]
year_month_weekday meets theCpp17EqualityComparable (Table 28) requirements.
2 year_month_weekday is a trivially copyable and standard-layout class type.
30.8.16.2 Member functions [time.cal.ymwd.members]
constexpr year_month_weekday(const chrono::year& y, const chrono::month& m,
const chrono::weekday_indexed& wdi) noexcept;
1 Effects: Initializes y_ with y, m_ with m, andwdi_ with wdi.
constexpr year_month_weekday(const sys_days& dp) noexcept;
2 Effects: Constructs an object of typeyear_month_weekday which corresponds to the date represented
by dp.
3 Remarks: For any valueymwd of type year_month_weekday for whichymwd.ok() is true, ymwd ==
year_month_weekday{sys_days{ymwd}} is true.
constexpr explicit year_month_weekday(const local_days& dp) noexcept;
4 Effects: Equivalent to constructing withsys_days{dp.time_since_epoch()}.
constexpr year_month_weekday& operator+=(const months& m) noexcept;
5 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
6 Effects: *this = *this + m.
7 Returns: *this.
constexpr year_month_weekday& operator-=(const months& m) noexcept;
8 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
9 Effects: *this = *this - m.
10 Returns: *this.
constexpr year_month_weekday& operator+=(const years& y) noexcept;
11 Effects: *this = *this + y.
12 Returns: *this.
constexpr year_month_weekday& operator-=(const years& y) noexcept;
13 Effects: *this = *this - y.
14 Returns: *this.
§ 30.8.16.2 © ISO/IEC
1971

===== PAGE 1983 =====

Dxxxx
constexpr chrono::year year() const noexcept;
15 Returns: y_.
constexpr chrono::month month() const noexcept;
16 Returns: m_.
constexpr chrono::weekday weekday() const noexcept;
17 Returns: wdi_.weekday().
constexpr unsigned index() const noexcept;
18 Returns: wdi_.index().
constexpr chrono::weekday_indexed weekday_indexed() const noexcept;
19 Returns: wdi_.
constexpr operator sys_days() const noexcept;
20 Returns: If y_.ok() && m_.ok() && wdi_.weekday().ok(), returns a sys_days that represents
the date (index() - 1) * 7 days after the firstweekday() of year()/month(). If index() is 0
the returned sys_days represents the date 7 days prior to the firstweekday() of year()/month().
Otherwise the returned value is unspecified.
constexpr explicit operator local_days() const noexcept;
21 Returns: local_days{sys_days{*this}.time_since_epoch()}.
constexpr bool ok() const noexcept;
22 Returns: If any of y_.ok(), m_.ok(), or wdi_.ok() is false, returns false. Otherwise, if *this
represents a valid date, returnstrue. Otherwise, returnsfalse.
30.8.16.3 Non-member functions [time.cal.ymwd.nonmembers]
constexpr bool operator==(const year_month_weekday& x, const year_month_weekday& y) noexcept;
1 Returns:
x.year() == y.year() && x.month() == y.month() && x.weekday_indexed() == y.weekday_indexed()
constexpr year_month_weekday operator+(const year_month_weekday& ymwd, const months& dm) noexcept;
2 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
3 Returns: (ymwd.year() / ymwd.month() + dm) / ymwd.weekday_indexed().
constexpr year_month_weekday operator+(const months& dm, const year_month_weekday& ymwd) noexcept;
4 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
5 Returns: ymwd + dm.
constexpr year_month_weekday operator-(const year_month_weekday& ymwd, const months& dm) noexcept;
6 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
7 Returns: ymwd + (-dm).
constexpr year_month_weekday operator+(const year_month_weekday& ymwd, const years& dy) noexcept;
8 Returns: {ymwd.year()+dy, ymwd.month(), ymwd.weekday_indexed()}.
constexpr year_month_weekday operator+(const years& dy, const year_month_weekday& ymwd) noexcept;
9 Returns: ymwd + dy.
constexpr year_month_weekday operator-(const year_month_weekday& ymwd, const years& dy) noexcept;
10 Returns: ymwd + (-dy).
§ 30.8.16.3 © ISO/IEC
1972

===== PAGE 1984 =====

Dxxxx
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_weekday& ymwd);
11 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{}/{:L}/{:L}"),
ymwd.year(), ymwd.month(), ymwd.weekday_indexed());
30.8.17 Class year_month_weekday_last [time.cal.ymwdlast]
30.8.17.1 Overview [time.cal.ymwdlast.overview]
namespace std::chrono {
class year_month_weekday_last {
chrono::year y_; // exposition only
chrono::month m_; // exposition only
chrono::weekday_last wdl_; // exposition only
public:
constexpr year_month_weekday_last(const chrono::year& y, const chrono::month& m,
const chrono::weekday_last& wdl) noexcept;
constexpr year_month_weekday_last& operator+=(const months& m) noexcept;
constexpr year_month_weekday_last& operator-=(const months& m) noexcept;
constexpr year_month_weekday_last& operator+=(const years& y) noexcept;
constexpr year_month_weekday_last& operator-=(const years& y) noexcept;
constexpr chrono::year year() const noexcept;
constexpr chrono::month month() const noexcept;
constexpr chrono::weekday weekday() const noexcept;
constexpr chrono::weekday_last weekday_last() const noexcept;
constexpr operator sys_days() const noexcept;
constexpr explicit operator local_days() const noexcept;
constexpr bool ok() const noexcept;
};
}
1 year_month_weekday_last represents a specific year, month, and last weekday of the month.year_month_-
weekday_last is a field-based time point with a resolution ofdays, except that it is restricted to pointing to
the last weekday of a year and month.
[Note 1: year_month_weekday_last supports years- andmonths-oriented arithmetic, but notdays-oriented arithmetic.
For the latter, there is a conversion tosys_days, which efficiently supportsdays-oriented arithmetic. —end note]
year_month_weekday_last meets theCpp17EqualityComparable (Table 28) requirements.
2 year_month_weekday_last is a trivially copyable and standard-layout class type.
30.8.17.2 Member functions [time.cal.ymwdlast.members]
constexpr year_month_weekday_last(const chrono::year& y, const chrono::month& m,
const chrono::weekday_last& wdl) noexcept;
1 Effects: Initializes y_ with y, m_ with m, andwdl_ with wdl.
constexpr year_month_weekday_last& operator+=(const months& m) noexcept;
2 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
3 Effects: *this = *this + m.
4 Returns: *this.
constexpr year_month_weekday_last& operator-=(const months& m) noexcept;
5 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
6 Effects: *this = *this - m.
§ 30.8.17.2 © ISO/IEC
1973

===== PAGE 1985 =====

Dxxxx
7 Returns: *this.
constexpr year_month_weekday_last& operator+=(const years& y) noexcept;
8 Effects: *this = *this + y.
9 Returns: *this.
constexpr year_month_weekday_last& operator-=(const years& y) noexcept;
10 Effects: *this = *this - y.
11 Returns: *this.
constexpr chrono::year year() const noexcept;
12 Returns: y_.
constexpr chrono::month month() const noexcept;
13 Returns: m_.
constexpr chrono::weekday weekday() const noexcept;
14 Returns: wdl_.weekday().
constexpr chrono::weekday_last weekday_last() const noexcept;
15 Returns: wdl_.
constexpr operator sys_days() const noexcept;
16 Returns: If ok() == true, returns asys_days that represents the lastweekday() of year()/month().
Otherwise the returned value is unspecified.
constexpr explicit operator local_days() const noexcept;
17 Returns: local_days{sys_days{*this}.time_since_epoch()}.
constexpr bool ok() const noexcept;
18 Returns: y_.ok() && m_.ok() && wdl_.ok().
30.8.17.3 Non-member functions [time.cal.ymwdlast.nonmembers]
constexpr bool operator==(const year_month_weekday_last& x,
const year_month_weekday_last& y) noexcept;
1 Returns:
x.year() == y.year() && x.month() == y.month() && x.weekday_last() == y.weekday_last()
constexpr year_month_weekday_last
operator+(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
2 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
3 Returns: (ymwdl.year() / ymwdl.month() + dm) / ymwdl.weekday_last().
constexpr year_month_weekday_last
operator+(const months& dm, const year_month_weekday_last& ymwdl) noexcept;
4 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
5 Returns: ymwdl + dm.
constexpr year_month_weekday_last
operator-(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
6 Constraints: If the argument supplied by the caller for themonths parameter is convertible toyears, its
implicit conversion sequence toyears is worse than its implicit conversion sequence tomonths (12.2.4.3).
7 Returns: ymwdl + (-dm).
§ 30.8.17.3 © ISO/IEC
1974

===== PAGE 1986 =====

Dxxxx
constexpr year_month_weekday_last
operator+(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
8 Returns: {ymwdl.year()+dy, ymwdl.month(), ymwdl.weekday_last()}.
constexpr year_month_weekday_last
operator+(const years& dy, const year_month_weekday_last& ymwdl) noexcept;
9 Returns: ymwdl + dy.
constexpr year_month_weekday_last
operator-(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
10 Returns: ymwdl + (-dy).
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const year_month_weekday_last& ymwdl);
11 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{}/{:L}/{:L}"),
ymwdl.year(), ymwdl.month(), ymwdl.weekday_last());
30.8.18 Conventional syntax operators [time.cal.operators]
1 A set of overloadedoperator/ functions provides a conventional syntax for the creation of civil calendar
dates.
2 [Note 1: The year, month, and day are accepted in any of the following 3 orders:
year /month /day
month /day /year
day /month /year
Anywhere aday is needed, any of the following can also be specified:
last
weekday [i ]
weekday [last]
—end note]
3 [Note 2: Partial-date types such asyear_month and month_day can be created by not applying the second division
operator for any of the three orders. For example:
year_month ym = 2015y/April;
month_day md1 = April/4;
month_day md2 = 4d/April;
—end note]
4 [Example 1:
auto a = 2015/4/4; // a == int(125)
auto b = 2015y/4/4; // b == year_month_day{year(2015), month(4), day(4)}
auto c = 2015y/4d/April; // error: no viableoperator/ for first /
auto d = 2015/April/4; // error: no viableoperator/ for first /
—end example]
constexpr year_month
operator/(const year& y, const month& m) noexcept;
5 Returns: {y, m}.
constexpr year_month
operator/(const year& y, int m) noexcept;
6 Returns: y / month(m).
constexpr month_day
operator/(const month& m, const day& d) noexcept;
7 Returns: {m, d}.
§ 30.8.18 © ISO/IEC
1975

===== PAGE 1987 =====

Dxxxx
constexpr month_day
operator/(const month& m, int d) noexcept;
8 Returns: m / day(d).
constexpr month_day
operator/(int m, const day& d) noexcept;
9 Returns: month(m) / d.
constexpr month_day
operator/(const day& d, const month& m) noexcept;
10 Returns: m / d.
constexpr month_day
operator/(const day& d, int m) noexcept;
11 Returns: month(m) / d.
constexpr month_day_last
operator/(const month& m, last_spec) noexcept;
12 Returns: month_day_last{m}.
constexpr month_day_last
operator/(int m, last_spec) noexcept;
13 Returns: month(m) / last.
constexpr month_day_last
operator/(last_spec, const month& m) noexcept;
14 Returns: m / last.
constexpr month_day_last
operator/(last_spec, int m) noexcept;
15 Returns: month(m) / last.
constexpr month_weekday
operator/(const month& m, const weekday_indexed& wdi) noexcept;
16 Returns: {m, wdi}.
constexpr month_weekday
operator/(int m, const weekday_indexed& wdi) noexcept;
17 Returns: month(m) / wdi.
constexpr month_weekday
operator/(const weekday_indexed& wdi, const month& m) noexcept;
18 Returns: m / wdi.
constexpr month_weekday
operator/(const weekday_indexed& wdi, int m) noexcept;
19 Returns: month(m) / wdi.
constexpr month_weekday_last
operator/(const month& m, const weekday_last& wdl) noexcept;
20 Returns: {m, wdl}.
constexpr month_weekday_last
operator/(int m, const weekday_last& wdl) noexcept;
21 Returns: month(m) / wdl.
constexpr month_weekday_last
operator/(const weekday_last& wdl, const month& m) noexcept;
22 Returns: m / wdl.
§ 30.8.18 © ISO/IEC
1976

===== PAGE 1988 =====

Dxxxx
constexpr month_weekday_last
operator/(const weekday_last& wdl, int m) noexcept;
23 Returns: month(m) / wdl.
constexpr year_month_day
operator/(const year_month& ym, const day& d) noexcept;
24 Returns: {ym.year(), ym.month(), d}.
constexpr year_month_day
operator/(const year_month& ym, int d) noexcept;
25 Returns: ym / day(d).
constexpr year_month_day
operator/(const year& y, const month_day& md) noexcept;
26 Returns: y / md.month() / md.day().
constexpr year_month_day
operator/(int y, const month_day& md) noexcept;
27 Returns: year(y) / md.
constexpr year_month_day
operator/(const month_day& md, const year& y) noexcept;
28 Returns: y / md.
constexpr year_month_day
operator/(const month_day& md, int y) noexcept;
29 Returns: year(y) / md.
constexpr year_month_day_last
operator/(const year_month& ym, last_spec) noexcept;
30 Returns: {ym.year(), month_day_last{ym.month()}}.
constexpr year_month_day_last
operator/(const year& y, const month_day_last& mdl) noexcept;
31 Returns: {y, mdl}.
constexpr year_month_day_last
operator/(int y, const month_day_last& mdl) noexcept;
32 Returns: year(y) / mdl.
constexpr year_month_day_last
operator/(const month_day_last& mdl, const year& y) noexcept;
33 Returns: y / mdl.
constexpr year_month_day_last
operator/(const month_day_last& mdl, int y) noexcept;
34 Returns: year(y) / mdl.
constexpr year_month_weekday
operator/(const year_month& ym, const weekday_indexed& wdi) noexcept;
35 Returns: {ym.year(), ym.month(), wdi}.
constexpr year_month_weekday
operator/(const year& y, const month_weekday& mwd) noexcept;
36 Returns: {y, mwd.month(), mwd.weekday_indexed()}.
constexpr year_month_weekday
operator/(int y, const month_weekday& mwd) noexcept;
37 Returns: year(y) / mwd.
§ 30.8.18 © ISO/IEC
1977

===== PAGE 1989 =====

Dxxxx
constexpr year_month_weekday
operator/(const month_weekday& mwd, const year& y) noexcept;
38 Returns: y / mwd.
constexpr year_month_weekday
operator/(const month_weekday& mwd, int y) noexcept;
39 Returns: year(y) / mwd.
constexpr year_month_weekday_last
operator/(const year_month& ym, const weekday_last& wdl) noexcept;
40 Returns: {ym.year(), ym.month(), wdl}.
constexpr year_month_weekday_last
operator/(const year& y, const month_weekday_last& mwdl) noexcept;
41 Returns: {y, mwdl.month(), mwdl.weekday_last()}.
constexpr year_month_weekday_last
operator/(int y, const month_weekday_last& mwdl) noexcept;
42 Returns: year(y) / mwdl.
constexpr year_month_weekday_last
operator/(const month_weekday_last& mwdl, const year& y) noexcept;
43 Returns: y / mwdl.
constexpr year_month_weekday_last
operator/(const month_weekday_last& mwdl, int y) noexcept;
44 Returns: year(y) / mwdl.
30.9 Class template hh_mm_ss [time.hms]
30.9.1 Overview [time.hms.overview]
namespace std::chrono {
template<class Duration> class hh_mm_ss {
public:
static constexpr unsigned fractional_width = see below ;
using precision = see below ;
constexpr hh_mm_ss() noexcept : hh_mm_ss{Duration::zero()} {}
constexpr explicit hh_mm_ss(Duration d);
constexpr bool is_negative() const noexcept;
constexpr chrono::hours hours() const noexcept;
constexpr chrono::minutes minutes() const noexcept;
constexpr chrono::seconds seconds() const noexcept;
constexpr precision subseconds() const noexcept;
constexpr explicit operator precision() const noexcept;
constexpr precision to_duration() const noexcept;
private:
bool is_neg; // exposition only
chrono::hours h; // exposition only
chrono::minutes m; // exposition only
chrono::seconds s; // exposition only
precision ss; // exposition only
};
}
1 The hh_mm_ss class template splits aduration into a multi-field time structurehours:minutes:seconds and
possibly subseconds, wheresubseconds will be a duration unit based on a non-positive power of 10. The
Duration template parameter dictates the precision to which the time is split. Ahh_mm_ss models negative
durations with a distinctis_negative getter that returnstrue when the input duration is negative. The
§ 30.9.1 © ISO/IEC
1978

===== PAGE 1990 =====

Dxxxx
individual duration fields always return non-negative durations even whenis_negative() indicates the
structure is representing a negative duration.
2 If Duration is not a specialization ofduration, the program is ill-formed.
30.9.2 Members [time.hms.members]
static constexpr unsigned fractional_width = see below ;
1 fractional_width is the number of fractional decimal digits represented byprecision. fractional_-
width has the value of the smallest possible integer in the range[0,18] such thatprecision will exactly
represent all values ofDuration. If no such value offractional_widthexists, thenfractional_width
is 6.
[Example 1: See Table 132 for some durations, the resultingfractional_width, and the formatted fractional
second output ofDuration{1}.
Table 132 — Examples forfractional_width [tab:time.hms.width]
Duration fractional_width Formatted fractional second output
hours, minutes, andseconds 0
milliseconds 3 0.001
microseconds 6 0.000001
nanoseconds 9 0.000000001
duration<int, ratio<1, 2>> 1 0.5
duration<int, ratio<1, 3>> 6 0.333333
duration<int, ratio<1, 4>> 2 0.25
duration<int, ratio<1, 5>> 1 0.2
duration<int, ratio<1, 6>> 6 0.166666
duration<int, ratio<1, 7>> 6 0.142857
duration<int, ratio<1, 8>> 3 0.125
duration<int, ratio<1, 9>> 6 0.111111
duration<int, ratio<1, 10>> 1 0.1
duration<int, ratio<756, 625>> 4 0.2096
—end example]
using precision = see below ;
2 precision is
duration<common_type_t<Duration::rep, seconds::rep>, ratio<1, 10fractional_width>>
constexpr explicit hh_mm_ss(Duration d);
3 Effects: Constructs an object of type hh_mm_ss which represents the Duration d with precision
precision.
—(3.1) Initializes is_neg with d < Duration::zero(). Let ABS_D represent -d if is_neg is true and d
otherwise.
—(3.2) Initializes h with duration_cast<chrono::hours>(ABS_D ).
—(3.3) Initializes m with duration_cast<chrono::minutes>(ABS_D - hours()).
—(3.4) Initializes s with duration_cast<chrono::seconds>(ABS_D - hours() - minutes()).
—(3.5) If treat_as_floating_point_v<precision::rep> is true, initializesss with ABS_D - hours()
- minutes() - seconds(). Otherwise, initializesss with duration_cast<precision>(ABS_D -
hours() - minutes() - seconds()).
[Note 1: When precision::rep is integral andprecision::period is ratio<1>, subseconds() always returns
a value equal to0s. —end note]
4 Postconditions: If treat_as_floating_point_v<precision::rep> is true, to_duration() returns
d, otherwiseto_duration() returns duration_cast<precision>(d).
constexpr bool is_negative() const noexcept;
5 Returns: is_neg.
§ 30.9.2 © ISO/IEC
1979

===== PAGE 1991 =====

Dxxxx
constexpr chrono::hours hours() const noexcept;
6 Returns: h.
constexpr chrono::minutes minutes() const noexcept;
7 Returns: m.
constexpr chrono::seconds seconds() const noexcept;
8 Returns: s.
constexpr precision subseconds() const noexcept;
9 Returns: ss.
constexpr precision to_duration() const noexcept;
10 Returns: If is_neg, returns-(h + m + s + ss), otherwise returnsh + m + s + ss.
constexpr explicit operator precision() const noexcept;
11 Returns: to_duration().
30.9.3 Non-members [time.hms.nonmembers]
template<class charT, class traits, class Duration>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const hh_mm_ss<Duration>& hms);
1 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%T}"), hms);
2 [Example 1:
for (auto ms : {-4083007ms, 4083007ms, 65745123ms}) {
hh_mm_ss hms{ms};
cout << hms << '\n';
}
cout << hh_mm_ss{65745s} << '\n';
Produces the output (assuming the "C" locale):
-01:08:03.007
01:08:03.007
18:15:45.123
18:15:45
—end example]
30.10 12/24 hours functions [time.12]
1 These functions aid in translating between a 12h format time of day and a 24h format time of day.
constexpr bool is_am(const hours& h) noexcept;
2 Returns: 0h <= h && h <= 11h.
constexpr bool is_pm(const hours& h) noexcept;
3 Returns: 12h <= h && h <= 23h.
constexpr hours make12(const hours& h) noexcept;
4 Returns: The 12-hour equivalent ofh in the range[1h,12h]. If h is not in the range[0h,23h], the value
returned is unspecified.
constexpr hours make24(const hours& h, bool is_pm) noexcept;
5 Returns: If is_pm is false, returns the 24-hour equivalent ofh in the range[0h,11h], assuming h
represents an ante meridiem hour. Otherwise, returns the 24-hour equivalent ofh in the range[12h,23h],
assuming h represents a post meridiem hour. Ifh is not in the range[1h,12h], the value returned is
unspecified.
§ 30.10 © ISO/IEC
1980

===== PAGE 1992 =====

Dxxxx
30.11 Time zones [time.zone]
30.11.1 General [time.zone.general]
1 30.11 describes an interface for accessing the IANA Time Zone Database[11] that interoperates withsys_time
and local_time. This interface provides time zone support to both the civil calendar types (30.8) and to
user-defined calendars.
30.11.2 Time zone database [time.zone.db]
30.11.2.1 Class tzdb [time.zone.db.tzdb]
namespace std::chrono {
struct tzdb {
string version;
vector<time_zone> zones;
vector<time_zone_link> links;
vector<leap_second> leap_seconds;
const time_zone* locate_zone(string_view tz_name) const;
const time_zone* current_zone() const;
};
}
1 Each vector in atzdb object is sorted to enable fast lookup.
const time_zone* locate_zone(string_view tz_name) const;
2 Returns:
—(2.1) If zones contains an elementtz for whichtz.name() == tz_name, a pointer totz;
—(2.2) otherwise, iflinks contains an elementtz_l for whichtz_l.name() == tz_name, then a pointer
to the elementtz of zones for whichtz.name() == tz_l.target().
[Note 1: A time_zone_link specifies an alternative name for atime_zone. —end note]
3 Throws: If a const time_zone* cannot be found as described in theReturns: element, throws a
runtime_error.
[Note 2: On non-exceptional return, the return value is always a pointer to a validtime_zone. —end note]
const time_zone* current_zone() const;
4 Returns: A pointer to the time zone which the computer has set as its local time zone.
30.11.2.2 Class tzdb_list [time.zone.db.list]
namespace std::chrono {
class tzdb_list {
public:
tzdb_list(const tzdb_list&) = delete;
tzdb_list& operator=(const tzdb_list&) = delete;
// unspecified additional constructors
class const_iterator;
const tzdb& front() const noexcept;
const_iterator erase_after(const_iterator p);
const_iterator begin() const noexcept;
const_iterator end() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;
};
}
1 The tzdb_list database is a singleton; the unique object of typetzdb_list can be accessed via the
get_tzdb_list() function.
§ 30.11.2.2 © ISO/IEC
1981

===== PAGE 1993 =====

Dxxxx
[Note 1: This access is only needed for those applications that need to have long uptimes and have a need to update
the time zone database while running. Other applications can implicitly access thefront() of this list via the
read-only namespace scope functionsget_tzdb(), locate_zone(), andcurrent_zone(). —end note]
The tzdb_list object contains a list oftzdb objects.
2 tzdb_list::const_iterator is a constant iterator which meets theCpp17ForwardIterator requirements
and has a value type oftzdb.
const tzdb& front() const noexcept;
3 Synchronization: This operation is thread-safe with respect toreload_tzdb().
[Note 2: reload_tzdb() pushes a newtzdb onto the front of this container.—end note]
4 Returns: A reference to the firsttzdb in the container.
const_iterator erase_after(const_iterator p);
5 Preconditions: The iterator followingp is dereferenceable.
6 Effects: Erases thetzdb referred to by the iterator followingp.
7 Postconditions: No pointers, references, or iterators are invalidated except those referring to the erased
tzdb.
[Note 3: It is not possible to erase thetzdb referred to bybegin(). —end note]
8 Returns: An iterator pointing to the element following the one that was erased, orend() if no such
element exists.
9 Throws: Nothing.
const_iterator begin() const noexcept;
10 Returns: An iterator referring to the firsttzdb in the container.
const_iterator end() const noexcept;
11 Returns: An iterator referring to the position one past the lasttzdb in the container.
const_iterator cbegin() const noexcept;
12 Returns: begin().
const_iterator cend() const noexcept;
13 Returns: end().
30.11.2.3 Time zone database access [time.zone.db.access]
tzdb_list& get_tzdb_list();
1 Effects: If this is the first access to the time zone database, initializes the database. If this call initializes
the database, the resulting database will be atzdb_list holding a single initializedtzdb.
2 Synchronization: It is safe to call this function from multiple threads at one time.
3 Returns: A reference to the database.
4 Throws: runtime_errorif for any reason a reference cannot be returned to a validtzdb_listcontaining
one or more validtzdbs.
const tzdb& get_tzdb();
5 Returns: get_tzdb_list().front().
const time_zone* locate_zone(string_view tz_name);
6 Returns: get_tzdb().locate_zone(tz_name).
7 [Note 1: The time zone database will be initialized if this is the first reference to the database.—end note]
const time_zone* current_zone();
8 Returns: get_tzdb().current_zone().
§ 30.11.2.3 © ISO/IEC
1982

===== PAGE 1994 =====

Dxxxx
30.11.2.4 Remote time zone database support [time.zone.db.remote]
1 The local time zone database is that supplied by the implementation when the program first accesses the
database, for example viacurrent_zone(). While the program is running, the implementation may choose
to update the time zone database. This update shall not impact the program in any way unless the program
calls the functions in this subclause. This potentially updated time zone database is referred to as theremote
time zone database.
const tzdb& reload_tzdb();
2 Effects: This function first checks the version of the remote time zone database. If the versions of the
local and remote databases are the same, there are no effects. Otherwise the remote database is pushed
to the front of thetzdb_list accessed byget_tzdb_list().
3 Synchronization: This function is thread-safe with respect toget_tzdb_list().front() and get_-
tzdb_list().erase_after().
4 Postconditions: No pointers, references, or iterators are invalidated.
5 Returns: get_tzdb_list().front().
6 Throws: runtime_error if for any reason a reference cannot be returned to a validtzdb.
string remote_version();
7 Returns: The latest remote database version.
[Note 1: This can be compared withget_tzdb().version to discover if the local and remote databases are
equivalent. —end note]
30.11.3 Exception classes [time.zone.exception]
30.11.3.1 Class nonexistent_local_time [time.zone.exception.nonexist]
namespace std::chrono {
class nonexistent_local_time : public runtime_error {
public:
template<class Duration>
nonexistent_local_time(const local_time<Duration>& tp, const local_info& i);
};
}
1 nonexistent_local_time is thrown when an attempt is made to convert a non-existentlocal_time to a
sys_time without specifyingchoose::earliest or choose::latest.
template<class Duration>
nonexistent_local_time(const local_time<Duration>& tp, const local_info& i);
2 Preconditions: i.result == local_info::nonexistent is true.
3 Effects: Initializes the base class with a sequence ofchar equivalent to that produced byos.str()
initialized as shown below:
ostringstream os;
os << tp << " is in a gap between\n"
<< local_seconds{i.first.end.time_since_epoch()} + i.first.offset << ' '
<< i.first.abbrev << " and\n"
<< local_seconds{i.second.begin.time_since_epoch()} + i.second.offset << ' '
<< i.second.abbrev
<< " which are both equivalent to\n"
<< i.first.end << " UTC";
4 [Example 1:
#include <chrono>
#include <iostream>
int main() {
using namespace std::chrono;
try {
auto zt = zoned_time{"America/New_York",
local_days{Sunday[2]/March/2016} + 2h + 30min};
§ 30.11.3.1 © ISO/IEC
1983

===== PAGE 1995 =====

Dxxxx
} catch (const nonexistent_local_time& e) {
std::cout << e.what() << '\n';
}
}
Produces the output:
2016-03-13 02:30:00 is in a gap between
2016-03-13 02:00:00 EST and
2016-03-13 03:00:00 EDT which are both equivalent to
2016-03-13 07:00:00 UTC
—end example]
30.11.3.2 Class ambiguous_local_time [time.zone.exception.ambig]
namespace std::chrono {
class ambiguous_local_time : public runtime_error {
public:
template<class Duration>
ambiguous_local_time(const local_time<Duration>& tp, const local_info& i);
};
}
1 ambiguous_local_time is thrown when an attempt is made to convert an ambiguouslocal_time to a
sys_time without specifyingchoose::earliest or choose::latest.
template<class Duration>
ambiguous_local_time(const local_time<Duration>& tp, const local_info& i);
2 Preconditions: i.result == local_info::ambiguous is true.
3 Effects: Initializes the base class with a sequence ofchar equivalent to that produced byos.str()
initialized as shown below:
ostringstream os;
os << tp << " is ambiguous. It could be\n"
<< tp << ' ' << i.first.abbrev << " == "
<< tp - i.first.offset << " UTC or\n"
<< tp << ' ' << i.second.abbrev << " == "
<< tp - i.second.offset << " UTC";
4 [Example 1:
#include <chrono>
#include <iostream>
int main() {
using namespace std::chrono;
try {
auto zt = zoned_time{"America/New_York",
local_days{Sunday[1]/November/2016} + 1h + 30min};
} catch (const ambiguous_local_time& e) {
std::cout << e.what() << '\n';
}
}
Produces the output:
2016-11-06 01:30:00 is ambiguous. It could be
2016-11-06 01:30:00 EDT == 2016-11-06 05:30:00 UTC or
2016-11-06 01:30:00 EST == 2016-11-06 06:30:00 UTC
—end example]
30.11.4 Information classes [time.zone.info]
30.11.4.1 Class sys_info [time.zone.info.sys]
namespace std::chrono {
struct sys_info {
sys_seconds begin;
§ 30.11.4.1 © ISO/IEC
1984

===== PAGE 1996 =====

Dxxxx
sys_seconds end;
seconds offset;
minutes save;
string abbrev;
};
}
1 A sys_info object can be obtained from the combination of atime_zone and either asys_time or local_-
time. It can also be obtained from azoned_time, which is effectively a pair of atime_zone and sys_time.
2 [Note 1: This type provides a low-level interface to time zone information. Typical conversions fromsys_time to
local_time will use this class implicitly, not explicitly.—end note]
3 The begin and end data members indicate that, for the associatedtime_zone and time_point, theoffset
and abbrev are in effect in the range[begin,end). This information can be used to efficiently iterate the
transitions of atime_zone.
4 The offset data member indicates the UTC offset in effect for the associatedtime_zone and time_point.
The relationship betweenlocal_time and sys_time is:
offset = local_time - sys_time
5 The save data member is extra information not normally needed for conversion betweenlocal_time and
sys_time. If save != 0min, this sys_info is said to be on “daylight saving” time, andoffset - save
suggests what offset thistime_zone might use if it were off daylight saving time. However, this information
should not be taken as authoritative. The only sure way to get such information is to query thetime_zone
with atime_point that returns asys_info where save == 0min. There is no guarantee whattime_point
might return such asys_info except that it is guaranteed not to be in the range[begin,end) (if save !=
0min for thissys_info).
6 The abbrev data member indicates the current abbreviation used for the associatedtime_zone and time_-
point. Abbreviations are not unique among thetime_zones, and so one cannot reliably map abbreviations
back to atime_zone and UTC offset.
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const sys_info& r);
7 Effects: Streams out thesys_info object r in an unspecified format.
8 Returns: os.
30.11.4.2 Class local_info [time.zone.info.local]
namespace std::chrono {
struct local_info {
static constexpr int unique = 0;
static constexpr int nonexistent = 1;
static constexpr int ambiguous = 2;
int result;
sys_info first;
sys_info second;
};
}
1 [Note 1: This type provides a low-level interface to time zone information. Typical conversions fromlocal_time to
sys_time will use this class implicitly, not explicitly.—end note]
2 Describes the result of converting alocal_time to asys_time as follows:
—(2.1) When alocal_time to sys_time conversion is unique,result == unique, first will be filled out
with the correctsys_info, andsecond will be zero-initialized.
—(2.2) If the conversion stems from a nonexistentlocal_time then result == nonexistent, first will be
filled out with thesys_info that ends just prior to thelocal_time, andsecond will be filled out with
the sys_info that begins just after thelocal_time.
—(2.3) If the conversion stems from an ambiguouslocal_time, thenresult == ambiguous, first will be
filled out with thesys_info that ends just after thelocal_time, andsecond will be filled out with
the sys_info that starts just before thelocal_time.
§ 30.11.4.2 © ISO/IEC
1985

===== PAGE 1997 =====

Dxxxx
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const local_info& r);
3 Effects: Streams out thelocal_info object r in an unspecified format.
4 Returns: os.
30.11.5 Class time_zone [time.zone.timezone]
30.11.5.1 Overview [time.zone.overview]
namespace std::chrono {
class time_zone {
public:
time_zone(time_zone&&) = default;
time_zone& operator=(time_zone&&) = default;
// unspecified additional constructors
string_view name() const noexcept;
template<class Duration> sys_info get_info(const sys_time<Duration>& st) const;
template<class Duration> local_info get_info(const local_time<Duration>& tp) const;
template<class Duration>
sys_time<common_type_t<Duration, seconds>>
to_sys(const local_time<Duration>& tp) const;
template<class Duration>
sys_time<common_type_t<Duration, seconds>>
to_sys(const local_time<Duration>& tp, choose z) const;
template<class Duration>
local_time<common_type_t<Duration, seconds>>
to_local(const sys_time<Duration>& tp) const;
};
}
1 A time_zone represents all time zone transitions for a specific geographic area.time_zone construction is
unspecified, and performed as part of database initialization.
[Note 1: const time_zone objects can be accessed via functions such aslocate_zone. —end note]
30.11.5.2 Member functions [time.zone.members]
string_view name() const noexcept;
1 Returns: The name of thetime_zone.
2 [Example 1: "America/New_York". —end example]
template<class Duration>
sys_info get_info(const sys_time<Duration>& st) const;
3 Returns: A sys_info ifor whichst is in the range[i.begin,i.end).
template<class Duration>
local_info get_info(const local_time<Duration>& tp) const;
4 Returns: A local_info for tp.
template<class Duration>
sys_time<common_type_t<Duration, seconds>>
to_sys(const local_time<Duration>& tp) const;
5 Returns: A sys_time that is at least as fine asseconds, and will be finer if the argumenttp has finer
precision. This sys_time is the UTC equivalent oftp according to the rules of thistime_zone.
6 Throws: If the conversion fromtp to asys_time is ambiguous, throwsambiguous_local_time. If the
tp represents a non-existent time between two UTCtime_points, throwsnonexistent_local_time.
§ 30.11.5.2 © ISO/IEC
1986

===== PAGE 1998 =====

Dxxxx
template<class Duration>
sys_time<common_type_t<Duration, seconds>>
to_sys(const local_time<Duration>& tp, choose z) const;
7 Returns: A sys_time that is at least as fine asseconds, and will be finer if the argumenttp has
finer precision. This sys_time is the UTC equivalent oftp according to the rules of thistime_-
zone. If the conversion fromtp to a sys_time is ambiguous, returns the earliersys_time if z ==
choose::earliest, and returns the latersys_time if z == choose::latest. If thetp represents a
non-existent time between two UTCtime_points, then the two UTCtime_points will be the same,
and that UTCtime_point will be returned.
template<class Duration>
local_time<common_type_t<Duration, seconds>>
to_local(const sys_time<Duration>& tp) const;
8 Returns: The local_time associated withtp and thistime_zone.
30.11.5.3 Non-member functions [time.zone.nonmembers]
bool operator==(const time_zone& x, const time_zone& y) noexcept;
1 Returns: x.name() == y.name().
strong_ordering operator<=>(const time_zone& x, const time_zone& y) noexcept;
2 Returns: x.name() <=> y.name().
30.11.6 Class template zoned_traits [time.zone.zonedtraits]
namespace std::chrono {
template<class T> struct zoned_traits {};
}
1 zoned_traits provides a means for customizing the behavior ofzoned_time<Duration, TimeZonePtr>
for thezoned_time default constructor, and constructors takingstring_view. A specialization forconst
time_zone* is provided by the implementation:
namespace std::chrono {
template<> struct zoned_traits<const time_zone*> {
static const time_zone* default_zone();
static const time_zone* locate_zone(string_view name);
};
}
static const time_zone* default_zone();
2 Returns: std::chrono::locate_zone("UTC").
static const time_zone* locate_zone(string_view name);
3 Returns: std::chrono::locate_zone(name).
30.11.7 Class template zoned_time [time.zone.zonedtime]
30.11.7.1 Overview [time.zone.zonedtime.overview]
namespace std::chrono {
template<class Duration, class TimeZonePtr = const time_zone*>
class zoned_time {
public:
using duration = common_type_t<Duration, seconds>;
private:
TimeZonePtr zone_; // exposition only
sys_time<duration> tp_; // exposition only
using traits = zoned_traits<TimeZonePtr>; // exposition only
public:
zoned_time();
zoned_time(const zoned_time&) = default;
§ 30.11.7.1 © ISO/IEC
1987

===== PAGE 1999 =====

Dxxxx
zoned_time& operator=(const zoned_time&) = default;
zoned_time(const sys_time<Duration>& st);
explicit zoned_time(TimeZonePtr z);
explicit zoned_time(string_view name);
template<class Duration2>
zoned_time(const zoned_time<Duration2, TimeZonePtr>& y);
zoned_time(TimeZonePtr z, const sys_time<Duration>& st);
zoned_time(string_view name, const sys_time<Duration>& st);
zoned_time(TimeZonePtr z, const local_time<Duration>& tp);
zoned_time(string_view name, const local_time<Duration>& tp);
zoned_time(TimeZonePtr z, const local_time<Duration>& tp, choose c);
zoned_time(string_view name, const local_time<Duration>& tp, choose c);
template<class Duration2, class TimeZonePtr2>
zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& y);
template<class Duration2, class TimeZonePtr2>
zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& y, choose);
template<class Duration2, class TimeZonePtr2>
zoned_time(string_view name, const zoned_time<Duration2, TimeZonePtr2>& y);
template<class Duration2, class TimeZonePtr2>
zoned_time(string_view name, const zoned_time<Duration2, TimeZonePtr2>& y, choose c);
zoned_time& operator=(const sys_time<Duration>& st);
zoned_time& operator=(const local_time<Duration>& lt);
operator sys_time<duration>() const;
explicit operator local_time<duration>() const;
TimeZonePtr get_time_zone() const;
local_time<duration> get_local_time() const;
sys_time<duration> get_sys_time() const;
sys_info get_info() const;
};
zoned_time() -> zoned_time<seconds>;
template<class Duration>
zoned_time(sys_time<Duration>)
-> zoned_time<common_type_t<Duration, seconds>>;
template<class TimeZonePtrOrName>
using time-zone-representation = // exposition only
conditional_t<is_convertible_v<TimeZonePtrOrName, string_view>,
const time_zone*,
remove_cvref_t<TimeZonePtrOrName>>;
template<class TimeZonePtrOrName>
zoned_time(TimeZonePtrOrName&&)
-> zoned_time<seconds, time-zone-representation <TimeZonePtrOrName>>;
template<class TimeZonePtrOrName, class Duration>
zoned_time(TimeZonePtrOrName&&, sys_time<Duration>)
-> zoned_time<common_type_t<Duration, seconds>,
time-zone-representation <TimeZonePtrOrName>>;
template<class TimeZonePtrOrName, class Duration>
zoned_time(TimeZonePtrOrName&&, local_time<Duration>,
choose = choose::earliest)
-> zoned_time<common_type_t<Duration, seconds>,
§ 30.11.7.1 © ISO/IEC
1988

===== PAGE 2000 =====

Dxxxx
time-zone-representation <TimeZonePtrOrName>>;
template<class Duration, class TimeZonePtrOrName, class TimeZonePtr2>
zoned_time(TimeZonePtrOrName&&, zoned_time<Duration, TimeZonePtr2>,
choose = choose::earliest)
-> zoned_time<common_type_t<Duration, seconds>,
time-zone-representation <TimeZonePtrOrName>>;
}
1 zoned_time represents a logical pairing of atime_zone and atime_point with precisionDuration. zoned_-
time<Duration> maintains the invariant that it always refers to a valid time zone and represents a point in
time that exists and is not ambiguous in that time zone.
2 If Duration is not a specialization ofchrono::duration, the program is ill-formed.
3 Every constructor ofzoned_time that accepts astring_view as its first parameter does not participate in
class template argument deduction (12.2.2.9).
30.11.7.2 Constructors [time.zone.zonedtime.ctor]
zoned_time();
1 Constraints: traits::default_zone() is a well-formed expression.
2 Effects: Initializes zone_ with traits::default_zone() and default constructstp_.
zoned_time(const sys_time<Duration>& st);
3 Constraints: traits::default_zone() is a well-formed expression.
4 Effects: Initializes zone_ with traits::default_zone() and tp_ with st.
explicit zoned_time(TimeZonePtr z);
5 Preconditions: z refers to a time zone.
6 Effects: Initializes zone_ with std::move(z) and default constructstp_.
explicit zoned_time(string_view name);
7 Constraints: traits::locate_zone(string_view{}) is a well-formed expression andzoned_time is
constructible from the return type oftraits::locate_zone(string_view{}).
8 Effects: Initializes zone_ with traits::locate_zone(name) and default constructstp_.
template<class Duration2>
zoned_time(const zoned_time<Duration2, TimeZonePtr>& y);
9 Constraints: is_convertible_v<sys_time<Duration2>, sys_time<Duration>> is true.
10 Effects: Initializes zone_ with y.zone_ and tp_ with y.tp_.
zoned_time(TimeZonePtr z, const sys_time<Duration>& st);
11 Preconditions: z refers to a time zone.
12 Effects: Initializes zone_ with std::move(z) and tp_ with st.
zoned_time(string_view name, const sys_time<Duration>& st);
13 Constraints: zoned_time is constructible from the return type oftraits::locate_zone(name) and
st.
14 Effects: Equivalent to construction with{traits::locate_zone(name), st}.
zoned_time(TimeZonePtr z, const local_time<Duration>& tp);
15 Constraints:
is_convertible_v<
decltype(declval<TimeZonePtr&>()->to_sys(local_time<Duration>{})),
sys_time<duration>>
is true.
16 Preconditions: z refers to a time zone.
§ 30.11.7.2 © ISO/IEC
1989