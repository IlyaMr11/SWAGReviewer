

===== PAGE 1001 =====

Dxxxx
template<class T, class Allocator, class U = T>
typename hive<T, Allocator>::size_type
erase(hive<T, Allocator>& c, const U& value);
template<class T, class Allocator, class Predicate>
typename hive<T, Allocator>::size_type
erase_if(hive<T, Allocator>& c, Predicate pred);
namespace pmr {
template<class T>
using hive = std::hive<T, polymorphic_allocator<T>>;
}
}
23.3.9 Class template hive [hive]
23.3.9.1 Overview [hive.overview]
1 A hive is a type of sequence container that provides constant-time insertion and erasure operations. Storage
is automatically managed in multiple memory blocks, referred to aselement blocks. Insertion (23.3.9.4)
position is determined by the container, and insertion may re-use the memory locations of erased elements.
[Note 1: Construction and assignment are not considered to involve insertion operations.—end note]
2 Element blocks which contain elements are referred to asactive blocks, those which do not are referred to as
reserved blocks. Active blocks which become empty of elements are either deallocated or become reserved
blocks. Reserved blocks become active blocks when they are used to store elements. A user can create
additional reserved blocks by callingreserve.
3 Erasures use unspecified techniques of constant time complexity to identify the memory locations of erased
elements, which are subsequently skipped during iteration, as opposed to relocating subsequent elements
during erasure.
4 Active block capacities have an implementation-defined growth factor (which need not be integral), for
example a new active block’s capacity could be equal to the summed capacities of the pre-existing active
blocks.
5 Limits can be placed on both the minimum and maximum element capacities of element blocks, both by
users and implementations.
—(5.1) The minimum limit shall be no larger than the maximum limit.
—(5.2) When limits are not specified by a user during construction, the implementation’s default limits are
used.
—(5.3) The default limits of an implementation are not guaranteed to be the same as the minimum and
maximum possible capacities for an implementation’s element blocks.
[Note 2: To allow latitude for both implementation-specific and user-directed optimization.—end note]
The latter are defined as hard limits. The maximum hard limit shall be no larger thanstd::allocator_-
traits<Allocator>::max_size().
—(5.4) If user-specified limits are not within hard limits, or if the specified minimum limit is greater than the
specified maximum limit, the behavior is undefined.
—(5.5) An element block is said to bewithin the boundsof a pair of minimum/maximum limits when its
capacity is greater-or-equal-to the minimum limit and less-than-or-equal-to the maximum limit.
6 A hive conforms to the requirements for containers (23.2.2.2), with the exception of operators== and !=. A
hive also meets the requirements of a reversible container (23.2.2.3), of an allocator-aware container (23.2.2.5),
and some of the requirements of a sequence container (23.2.4). Descriptions are provided here only for
operations onhive that are not described in that table or for operations where there is additional semantic
information.
7 The iterators of hive meet the Cpp17BidirectionalIterator requirements but also model three_way_-
comparable<strong_ordering>.
namespace std {
template<class T, class Allocator = allocator<T>>
class hive {
§ 23.3.9.1 © ISO/IEC
990

===== PAGE 1002 =====

Dxxxx
public:
// types
using value_type = T;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>; // see 23.2
using const_reverse_iterator = std::reverse_iterator<const_iterator>; // see 23.2
// 23.3.9.2, construct/copy/destroy
constexpr hive() noexcept(noexcept(Allocator())) : hive(Allocator()) {}
constexpr explicit hive(const Allocator&) noexcept;
constexpr explicit hive(hive_limits block_limits) : hive(block_limits, Allocator()) {}
constexpr hive(hive_limits block_limits, const Allocator&);
explicit hive(size_type n, const Allocator& = Allocator());
hive(size_type n, hive_limits block_limits, const Allocator& = Allocator());
hive(size_type n, const T& value, const Allocator& = Allocator());
hive(size_type n, const T& value, hive_limits block_limits, const Allocator& = Allocator());
template<class InputIterator>
hive(InputIterator first, InputIterator last, const Allocator& = Allocator());
template<class InputIterator>
hive(InputIterator first, InputIterator last, hive_limits block_limits,
const Allocator& = Allocator());
template<container-compatible-range <T> R>
hive(from_range_t, R&& rg, const Allocator& = Allocator());
template<container-compatible-range <T> R>
hive(from_range_t, R&& rg, hive_limits block_limits, const Allocator& = Allocator());
hive(const hive& x);
hive(hive&&) noexcept;
hive(const hive& x, const type_identity_t<Allocator>& alloc);
hive(hive&&, const type_identity_t<Allocator>& alloc);
hive(initializer_list<T> il, const Allocator& = Allocator());
hive(initializer_list<T> il, hive_limits block_limits, const Allocator& = Allocator());
~hive();
hive& operator=(const hive& x);
hive& operator=(hive&& x) noexcept(see below );
hive& operator=(initializer_list<T>);
template<class InputIterator>
void assign(InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
void assign_range(R&& rg);
void assign(size_type n, const T& t);
void assign(initializer_list<T>);
allocator_type get_allocator() const noexcept;
// iterators
iterator begin() noexcept;
const_iterator begin() const noexcept;
iterator end() noexcept;
const_iterator end() const noexcept;
reverse_iterator rbegin() noexcept;
const_reverse_iterator rbegin() const noexcept;
reverse_iterator rend() noexcept;
const_reverse_iterator rend() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;
const_reverse_iterator crbegin() const noexcept;
§ 23.3.9.1 © ISO/IEC
991

===== PAGE 1003 =====

Dxxxx
const_reverse_iterator crend() const noexcept;
// 23.3.9.3, capacity
bool empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;
size_type capacity() const noexcept;
void reserve(size_type n);
void shrink_to_fit();
void trim_capacity() noexcept;
void trim_capacity(size_type n) noexcept;
constexpr hive_limits block_capacity_limits() const noexcept;
static constexpr hive_limits block_capacity_default_limits() noexcept;
static constexpr hive_limits block_capacity_hard_limits() noexcept;
void reshape(hive_limits block_limits);
// 23.3.9.4, modifiers
template<class... Args> iterator emplace(Args&&... args);
template<class... Args> iterator emplace_hint(const_iterator hint, Args&&... args);
iterator insert(const T& x);
iterator insert(T&& x);
iterator insert(const_iterator hint, const T& x);
iterator insert(const_iterator hint, T&& x);
void insert(initializer_list<T> il);
template<container-compatible-range <T> R>
void insert_range(R&& rg);
template<class InputIterator>
void insert(InputIterator first, InputIterator last);
void insert(size_type n, const T& x);
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void swap(hive&) noexcept(see below );
void clear() noexcept;
// 23.3.9.5, hive operations
void splice(hive& x);
void splice(hive&& x);
template<class BinaryPredicate = equal_to<T>>
size_type unique(BinaryPredicate binary_pred = BinaryPredicate());
template<class Compare = less<T>>
void sort(Compare comp = Compare());
iterator get_iterator(const_pointer p) noexcept;
const_iterator get_iterator(const_pointer p) const noexcept;
private:
hive_limits current-limits = implementation-defined ; // exposition only
};
template<class InputIterator, class Allocator = allocator<iter-value-type <InputIterator>>>
hive(InputIterator, InputIterator, Allocator = Allocator())
-> hive<iter-value-type <InputIterator>, Allocator>;
template<class InputIterator, class Allocator = allocator<iter-value-type <InputIterator>>>
hive(InputIterator, InputIterator, hive_limits, Allocator = Allocator())
-> hive<iter-value-type <InputIterator>, Allocator>;
template<ranges::input_range R, class Allocator = allocator<ranges::range_value_t<R>>>
hive(from_range_t, R&&, Allocator = Allocator())
-> hive<ranges::range_value_t<R>, Allocator>;
§ 23.3.9.1 © ISO/IEC
992

===== PAGE 1004 =====

Dxxxx
template<ranges::input_range R, class Allocator = allocator<ranges::range_value_t<R>>>
hive(from_range_t, R&&, hive_limits, Allocator = Allocator())
-> hive<ranges::range_value_t<R>, Allocator>;
}
23.3.9.2 Constructors, copy, and assignment [hive.cons]
constexpr explicit hive(const Allocator&) noexcept;
1 Effects: Constructs an emptyhive, using the specified allocator.
2 Complexity: Constant.
constexpr hive(hive_limits block_limits, const Allocator&);
3 Effects: Constructs an emptyhive, using the specified allocator. Initializescurrent-limits with
block_limits.
4 Complexity: Constant.
explicit hive(size_type n, const Allocator& = Allocator());
hive(size_type n, hive_limits block_limits, const Allocator& = Allocator());
5 Preconditions: T is Cpp17DefaultInsertable into hive.
6 Effects: Constructs ahive with n default-inserted elements, using the specified allocator. If the second
overload is called, also initializescurrent-limits with block_limits.
7 Complexity: Linear inn.
hive(size_type n, const T& value, const Allocator& = Allocator());
hive(size_type n, const T& value, hive_limits block_limits, const Allocator& = Allocator());
8 Preconditions: T is Cpp17CopyInsertable into hive.
9 Effects: Constructs ahive with n copies of value, using the specified allocator. If the second overload
is called, also initializescurrent-limits with block_limits.
10 Complexity: Linear inn.
template<class InputIterator>
hive(InputIterator first, InputIterator last, const Allocator& = Allocator());
template<class InputIterator>
hive(InputIterator first, InputIterator last, hive_limits block_limits,
const Allocator& = Allocator());
11 Effects: Constructs ahive equal to the range[first,last), using the specified allocator. If the second
overload is called, also initializescurrent-limits with block_limits.
12 Complexity: Linear indistance(first, last).
template<container-compatible-range <T> R>
hive(from_range_t, R&& rg, const Allocator& = Allocator());
template<container-compatible-range <T> R>
hive(from_range_t, R&& rg, hive_limits block_limits, const Allocator& = Allocator());
13 Effects: Constructs ahive object equal to the rangerg, using the specified allocator. If the second
overload is called, also initializescurrent-limits with block_limits.
14 Complexity: Linear inranges::distance(rg).
hive(const hive& x);
hive(const hive& x, const type_identity_t<Allocator>& alloc);
15 Preconditions: T is Cpp17CopyInsertable into hive.
16 Effects: Constructs ahive object equal tox. If the second overload is called, usesalloc. Initializes
current-limits with x.current-limits .
17 Complexity: Linear inx.size().
hive(hive&& x) noexcept;
§ 23.3.9.2 © ISO/IEC
993

===== PAGE 1005 =====

Dxxxx
hive(hive&& x, const type_identity_t<Allocator>& alloc);
18 Preconditions: For the second overload, whenallocator_traits<alloc>::is_always_equal::value
is false, T meets theCpp17MoveInsertable requirements.
19 Effects: When the first overload is called, or the second overload is called andalloc == x.get_-
allocator() is true, current-limits is set tox.current-limits and each element block is moved
from x into *this. Pointers and references to the elements ofx now refer to those same elements but
as members of*this. Iterators referring to the elements ofx will continue to refer to their elements,
but they now behave as iterators into*this.
If the second overload is called andalloc == x.get_allocator() is false, each element inx is moved
into *this. References, pointers and iterators referring to the elements ofx, as well as the past-the-end
iterator ofx, are invalidated.
20 Postconditions: x.empty() is true. The relative order of the elements of*this is the same as that of
the elements ofx prior to the call.
21 Complexity: If the second overload is called andalloc == x.get_allocator() is false, linear in
x.size(). Otherwise constant.
hive(initializer_list<T> il, const Allocator& = Allocator());
hive(initializer_list<T> il, hive_limits block_limits, const Allocator& = Allocator());
22 Preconditions: T is Cpp17CopyInsertable into hive.
23 Effects: Constructs ahive object equal toil, using the specified allocator. If the second overload is
called, also initializescurrent-limits with block_limits.
24 Complexity: Linear inil.size().
hive& operator=(const hive& x);
25 Preconditions: T is Cpp17CopyInsertable into hive and Cpp17CopyAssignable.
26 Effects: All elements in*this are either copy-assigned to, or destroyed. All elements inx are copied
into *this, maintaining their relative order.
[Note 1: current-limits is unchanged. —end note]
27 Complexity: Linear insize() + x.size().
hive& operator=(hive&& x)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
28 Preconditions: When
(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value)
is false, T is Cpp17MoveInsertable into hive and Cpp17MoveAssignable.
29 Effects: Each element in*this is either move-assigned to, or destroyed. When
(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
get_allocator() == x.get_allocator())
is true, current-limits is set tox.current-limits and each element block is moved fromx into
*this. Pointers and references to the elements ofx now refer to those same elements but as members
of *this. Iterators referring to the elements ofx will continue to refer to their elements, but they now
behave as iterators into*this, not intox.
When
(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
get_allocator() == x.get_allocator())
is false, each element inx is moved into*this. References, pointers and iterators referring to the
elements ofx, as well as the past-the-end iterator ofx, are invalidated.
30 Postconditions: x.empty() is true. The relative order of the elements of*this is the same as that of
the elements ofx prior to this call.
31 Complexity: Linear insize(). If
§ 23.3.9.2 © ISO/IEC
994

===== PAGE 1006 =====

Dxxxx
(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
get_allocator() == x.get_allocator())
is false, also linear inx.size().
23.3.9.3 Capacity [hive.capacity]
size_type capacity() const noexcept;
1 Returns: The total number of elements that*this can hold without requiring allocation of more
element blocks.
2 Complexity: Constant.
void reserve(size_type n);
3 Effects: If n <= capacity()is true, there are no effects. Otherwise increasescapacity()by allocating
reserved blocks.
4 Postconditions: capacity() >= n is true.
5 Throws: length_error if n > max_size(), as well as any exceptions thrown by the allocator.
6 Complexity: Linear in the number of reserved blocks allocated.
7 Remarks: All references, pointers, and iterators referring to elements in*this, as well as the past-the-end
iterator, remain valid.
void shrink_to_fit();
8 Preconditions: T is Cpp17MoveInsertable into hive.
9 Effects: shrink_to_fit is a non-binding request to reducecapacity() to be closer tosize().
[Note 1: The request is non-binding to allow latitude for implementation-specific optimizations.—end note]
It does not increase capacity(), but may reduce capacity(). It may reallocate elements. If
capacity() is already equal tosize(), there are no effects. If an exception is thrown during al-
location of a new element block,capacity() may be reduced and reallocation may occur. Otherwise if
an exception is thrown, the effects are unspecified.
10 Complexity: If reallocation happens, linear in the size of the sequence.
11 Remarks: If reallocation happens, the order of the elements in*this may change and all references,
pointers, and iterators referring to the elements in*this, as well as the past-the-end iterator, are
invalidated.
void trim_capacity() noexcept;
void trim_capacity(size_type n) noexcept;
12 Effects: For the first overload, all reserved blocks are deallocated, andcapacity()is reduced accordingly.
For the second overload, ifn >= capacity() is true, there are no effects; otherwise,capacity() is
reduced to no less thann.
13 Complexity: Linear in the number of reserved blocks deallocated.
14 Remarks: All references, pointers, and iterators referring to elements in*this, as well as the past-the-end
iterator, remain valid.
constexpr hive_limits block_capacity_limits() const noexcept;
15 Returns: current-limits .
16 Complexity: Constant.
static constexpr hive_limits block_capacity_default_limits() noexcept;
17 Returns: A hive_limits struct with themin and max members set to the implementation’s default
limits.
18 Complexity: Constant.
static constexpr hive_limits block_capacity_hard_limits() noexcept;
19 Returns: A hive_limits struct with themin and max members set to the implementation’s hard limits.
§ 23.3.9.3 © ISO/IEC
995

===== PAGE 1007 =====

Dxxxx
20 Complexity: Constant.
void reshape(hive_limits block_limits);
21 Preconditions: T is Cpp17MoveInsertable into hive.
22 Effects: For any active blocks not within the bounds ofblock_limits, the elements within those
active blocks are reallocated to new or existing element blocks which are within the bounds. Any
element blocks not within the bounds ofblock_limits are deallocated. If an exception is thrown
during allocation of a new element block,capacity() may be reduced, reallocation may occur, and
current-limits may be assigned a value other thanblock_limits. Otherwise block_limits is
assigned tocurrent-limits . If any other exception is thrown the effects are unspecified.
23 Postconditions: size() is unchanged.
24 Complexity: Linear in the number of element blocks in*this. If reallocation happens, also linear in
the number of elements reallocated.
25 Remarks: This operation may changecapacity(). If reallocation happens, the order of the elements
in *this may change. Reallocation invalidates all references, pointers, and iterators referring to the
elements in*this, as well as the past-the-end iterator.
[Note 2: If no reallocation happens, they remain valid.—end note]
23.3.9.4 Modifiers [hive.modifiers]
template<class... Args> iterator emplace(Args&&... args);
template<class... Args> iterator emplace_hint(const_iterator hint, Args&&... args);
1 Preconditions: T is Cpp17EmplaceConstructible into hive from args.
2 Effects: Inserts an object of type T constructed with std::forward<Args>(args).... The hint
parameter is ignored. If an exception is thrown, there are no effects.
[Note 1: args can directly or indirectly refer to a value in*this. —end note]
3 Returns: An iterator that points to the new element.
4 Complexity: Constant. Exactly one object of typeT is constructed.
5 Remarks: Invalidates the past-the-end iterator.
iterator insert(const T& x);
iterator insert(const_iterator hint, const T& x);
iterator insert(T&& x);
iterator insert(const_iterator hint, T&& x);
6 Effects: Equivalent to:return emplace(std::forward<decltype(x)>(x));
[Note 2: The hint parameter is ignored. —end note]
void insert(initializer_list<T> rg);
template<container-compatible-range <T> R>
void insert_range(R&& rg);
7 Preconditions: T is Cpp17EmplaceInsertable into hive from *ranges::begin(rg). rg and *this do
not overlap.
8 Effects: Inserts copies of elements inrg. Each iterator in the rangerg is dereferenced exactly once.
9 Complexity: Linear in the number of elements inserted. Exactly one object of typeT is constructed for
each element inserted.
10 Remarks: If an element is inserted, invalidates the past-the-end iterator.
void insert(size_type n, const T& x);
11 Preconditions: T is Cpp17CopyInsertable into hive.
12 Effects: Inserts n copies ofx.
13 Complexity: Linear inn. Exactly one object of typeT is constructed for each element inserted.
14 Remarks: If an element is inserted, invalidates the past-the-end iterator.
§ 23.3.9.4 © ISO/IEC
996

===== PAGE 1008 =====

Dxxxx
template<class InputIterator>
void insert(InputIterator first, InputIterator last);
15 Effects: Equivalent toinsert_range(ranges::subrange(first, last)).
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
16 Complexity: Linear in the number of elements erased. Additionally, if any active blocks become empty
of elements as a result of the function call, at worst linear in the number of element blocks.
17 Remarks: Invalidates references, pointers and iterators referring to the erased elements. An erase
operation that erases the last element in*this also invalidates the past-the-end iterator.
void swap(hive& x)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
18 Effects: Exchanges the contents,capacity(), andcurrent-limits of *this with that ofx.
19 Complexity: Constant.
23.3.9.5 Operations [hive.operations]
1 In this subclause, arguments for a template parameter namedPredicate or BinaryPredicate shall meet
the corresponding requirements in 26.2. The semantics ofi + n and i - n, wherei is an iterator into the
hive and n is an integer, are the same as those ofnext(i, n) and prev(i, n), respectively. Forsort, the
definitions and requirements in 26.8 apply.
void splice(hive& x);
void splice(hive&& x);
2 Preconditions: get_allocator() == x.get_allocator() is true.
3 Effects: If addressof(x) == this is true, the behavior is erroneous and there are no effects. If an
exception is thrown, there are no effects. Otherwise, inserts the contents ofx into *this and x becomes
empty. Pointers and references to the moved elements ofx now refer to those same elements but as
members of*this. Iterators referring to the moved elements continue to refer to their elements, but
they now behave as iterators into*this, not intox.
4 Throws: length_error if any ofx’s active blocks are not within the bounds ofcurrent-limits .
5 Complexity: Linear in the sum of all element blocks inx plus all element blocks in*this.
6 Remarks: Reserved blocks inx are not transferred into*this. If addressof(x) == this is false,
invalidates the past-the-end iterator for bothx and *this.
template<class BinaryPredicate = equal_to<T>>
size_type unique(BinaryPredicate binary_pred = BinaryPredicate());
7 Preconditions: binary_pred is an equivalence relation.
8 Effects: Erases all but the first element from every consecutive group of equivalent elements. That is,
for a nonemptyhive, erases all elements referred to by the iteratori in the range[begin() + 1,end())
for whichbinary_pred(*i, *(i - 1)) is true.
9 Returns: The number of elements erased.
10 Throws: Nothing unless an exception is thrown by the predicate.
11 Complexity: If empty() is false, exactly size() - 1 applications of the corresponding predicate,
otherwise no applications of the predicate.
12 Remarks: Invalidates references, pointers, and iterators referring to the erased elements. If the last
element in*this is erased, also invalidates the past-the-end iterator.
template<class Compare = less<T>>
void sort(Compare comp = Compare());
13 Preconditions: T is Cpp17MoveInsertable into hive, Cpp17MoveAssignable, andCpp17Swappable.
14 Effects: Sorts *this according to thecomp function object. If an exception is thrown, the order of the
elements in*this is unspecified.
§ 23.3.9.5 © ISO/IEC
997

===== PAGE 1009 =====

Dxxxx
15 Complexity: O(Nlog N) comparisons, whereN is size().
16 Remarks: May allocate. References, pointers, and iterators referring to elements in*this, as well as
the past-the-end iterator, may be invalidated.
[Note 1: Not required to be stable16.4.6.8.—end note]
iterator get_iterator(const_pointer p) noexcept;
const_iterator get_iterator(const_pointer p) const noexcept;
17 Preconditions: p points to an element in*this.
18 Returns: An iterator or const_iterator pointing to the same element asp.
19 Complexity: Linear in the number of active blocks in*this.
23.3.9.6 Erasure [hive.erasure]
template<class T, class Allocator, class U = T>
typename hive<T, Allocator>::size_type
erase(hive<T, Allocator>& c, const U& value);
1 Effects: Equivalent to:
return erase_if(c, [&](const auto& elem) -> bool { return elem == value; });
template<class T, class Allocator, class Predicate>
typename hive<T, Allocator>::size_type
erase_if(hive<T, Allocator>& c, Predicate pred);
2 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(); i != c.end(); ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
23.3.10 Header <list> synopsis [list.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.3.11, class templatelist
template<class T, class Allocator = allocator<T>> class list;
template<class T, class Allocator>
constexpr bool operator==(const list<T, Allocator>& x, const list<T, Allocator>& y);
template<class T, class Allocator>
constexpr synth-three-way-result <T>
operator<=>(const list<T, Allocator>& x, const list<T, Allocator>& y);
template<class T, class Allocator>
constexpr void swap(list<T, Allocator>& x, list<T, Allocator>& y)
noexcept(noexcept(x.swap(y)));
// 23.3.11.6, erasure
template<class T, class Allocator, class U = T>
constexpr typename list<T, Allocator>::size_type
erase(list<T, Allocator>& c, const U& value);
template<class T, class Allocator, class Predicate>
constexpr typename list<T, Allocator>::size_type
erase_if(list<T, Allocator>& c, Predicate pred);
§ 23.3.10 © ISO/IEC
998

===== PAGE 1010 =====

Dxxxx
namespace pmr {
template<class T>
using list = std::list<T, polymorphic_allocator<T>>;
}
}
23.3.11 Class template list [list]
23.3.11.1 Overview [list.overview]
1 A list is a sequence container that supports bidirectional iterators and allows constant time insert and
erase operations anywhere within the sequence, with storage management handled automatically. Unlike
vectors (23.3.13) and deques (23.3.5), fast random access to list elements is not supported, but many
algorithms only need sequential access anyway.
2 A list meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), and of a sequence container, including most of the optional sequence
container requirements (23.2.4). The exceptions are theoperator[] and at member functions, which are
not provided.187 Descriptions are provided here only for operations onlist that are not described in one of
these tables or for operations where there is additional semantic information.
3 The typesiterator and const_iterator meet the constexpr iterator requirements24.3.1.
namespace std {
template<class T, class Allocator = allocator<T>>
class list {
public:
// types
using value_type = T;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
// 23.3.11.2, construct/copy/destroy
constexpr list() : list(Allocator()) { }
constexpr explicit list(const Allocator&);
constexpr explicit list(size_type n, const Allocator& = Allocator());
constexpr list(size_type n, const T& value, const Allocator& = Allocator());
template<class InputIterator>
constexpr list(InputIterator first, InputIterator last, const Allocator& = Allocator());
template<container-compatible-range <T> R>
constexpr list(from_range_t, R&& rg, const Allocator& = Allocator());
constexpr list(const list& x);
constexpr list(list&& x);
constexpr list(const list&, const type_identity_t<Allocator>&);
constexpr list(list&&, const type_identity_t<Allocator>&);
constexpr list(initializer_list<T>, const Allocator& = Allocator());
constexpr ~list();
constexpr list& operator=(const list& x);
constexpr list& operator=(list&& x)
noexcept(allocator_traits<Allocator>::is_always_equal::value);
constexpr list& operator=(initializer_list<T>);
template<class InputIterator>
constexpr void assign(InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr void assign_range(R&& rg);
187) These member functions are only provided by containers whose iterators are random access iterators.
§ 23.3.11.1 © ISO/IEC
999

===== PAGE 1011 =====

Dxxxx
constexpr void assign(size_type n, const T& t);
constexpr void assign(initializer_list<T>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// 23.3.11.3, capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
constexpr void resize(size_type sz);
constexpr void resize(size_type sz, const T& c);
// element access
constexpr reference front();
constexpr const_reference front() const;
constexpr reference back();
constexpr const_reference back() const;
// 23.3.11.4, modifiers
template<class... Args> constexpr reference emplace_front(Args&&... args);
template<class... Args> constexpr reference emplace_back(Args&&... args);
constexpr void push_front(const T& x);
constexpr void push_front(T&& x);
template<container-compatible-range <T> R>
constexpr void prepend_range(R&& rg);
constexpr void pop_front();
constexpr void push_back(const T& x);
constexpr void push_back(T&& x);
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg);
constexpr void pop_back();
template<class... Args> constexpr iterator emplace(const_iterator position, Args&&... args);
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position,
InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list<T> il);
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator position, const_iterator last);
constexpr void swap(list&) noexcept(allocator_traits<Allocator>::is_always_equal::value);
constexpr void clear() noexcept;
// 23.3.11.5, list operations
constexpr void splice(const_iterator position, list& x);
§ 23.3.11.1 © ISO/IEC
1000

===== PAGE 1012 =====

Dxxxx
constexpr void splice(const_iterator position, list&& x);
constexpr void splice(const_iterator position, list& x, const_iterator i);
constexpr void splice(const_iterator position, list&& x, const_iterator i);
constexpr void splice(const_iterator position, list& x,
const_iterator first, const_iterator last);
constexpr void splice(const_iterator position, list&& x,
const_iterator first, const_iterator last);
constexpr size_type remove(const T& value);
template<class Predicate> constexpr size_type remove_if(Predicate pred);
constexpr size_type unique();
template<class BinaryPredicate>
constexpr size_type unique(BinaryPredicate binary_pred);
constexpr void merge(list& x);
constexpr void merge(list&& x);
template<class Compare> constexpr void merge(list& x, Compare comp);
template<class Compare> constexpr void merge(list&& x, Compare comp);
constexpr void sort();
template<class Compare> constexpr void sort(Compare comp);
constexpr void reverse() noexcept;
};
template<class InputIterator, class Allocator = allocator<iter-value-type <InputIterator>>>
list(InputIterator, InputIterator, Allocator = Allocator())
-> list<iter-value-type <InputIterator>, Allocator>;
template<ranges::input_range R, class Allocator = allocator<ranges::range_value_t<R>>>
list(from_range_t, R&&, Allocator = Allocator())
-> list<ranges::range_value_t<R>, Allocator>;
}
4 An incomplete typeT may be used when instantiatinglist if the allocator meets the allocator completeness
requirements (16.4.4.6.2).T shall be complete before any member of the resulting specialization oflist is
referenced.
23.3.11.2 Constructors, copy, and assignment [list.cons]
constexpr explicit list(const Allocator&);
1 Effects: Constructs an empty list, using the specified allocator.
2 Complexity: Constant.
constexpr explicit list(size_type n, const Allocator& = Allocator());
3 Preconditions: T is Cpp17DefaultInsertable into list.
4 Effects: Constructs alist with n default-inserted elements using the specified allocator.
5 Complexity: Linear inn.
constexpr list(size_type n, const T& value, const Allocator& = Allocator());
6 Preconditions: T is Cpp17CopyInsertable into list.
7 Effects: Constructs alist with n copies ofvalue, using the specified allocator.
8 Complexity: Linear inn.
template<class InputIterator>
constexpr list(InputIterator first, InputIterator last, const Allocator& = Allocator());
9 Effects: Constructs alist equal to the range[first,last).
10 Complexity: Linear indistance(first, last).
§ 23.3.11.2 © ISO/IEC
1001

===== PAGE 1013 =====

Dxxxx
template<container-compatible-range <T> R>
constexpr list(from_range_t, R&& rg, const Allocator& = Allocator());
11 Effects: Constructs alist object with the elements of the rangerg.
12 Complexity: Linear inranges::distance(rg).
23.3.11.3 Capacity [list.capacity]
constexpr void resize(size_type sz);
1 Preconditions: T is Cpp17DefaultInsertable into list.
2 Effects: If size() < sz, appendssz - size() default-inserted elements to the sequence. Ifsz <=
size(), equivalent to:
list<T>::iterator it = begin();
advance(it, sz);
erase(it, end());
constexpr void resize(size_type sz, const T& c);
3 Preconditions: T is Cpp17CopyInsertable into list.
4 Effects: As if by:
if (sz > size())
insert(end(), sz-size(), c);
else if (sz < size()) {
iterator i = begin();
advance(i, sz);
erase(i, end());
}
else
; // do nothing
23.3.11.4 Modifiers [list.modifiers]
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position,
InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list<T>);
template<class... Args> constexpr reference emplace_front(Args&&... args);
template<class... Args> constexpr reference emplace_back(Args&&... args);
template<class... Args> constexpr iterator emplace(const_iterator position, Args&&... args);
constexpr void push_front(const T& x);
constexpr void push_front(T&& x);
template<container-compatible-range <T> R>
constexpr void prepend_range(R&& rg);
constexpr void push_back(const T& x);
constexpr void push_back(T&& x);
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg);
1 Complexity: Insertion of a single element into a list takes constant time and exactly one call to a
constructor of T. Insertion of multiple elements into a list is linear in the number of elements inserted,
and the number of calls to the copy constructor or move constructor ofT is exactly equal to the number
of elements inserted.
2 Remarks: Does not affect the validity of iterators and references. If an exception is thrown, there are
no effects.
§ 23.3.11.4 © ISO/IEC
1002

===== PAGE 1014 =====

Dxxxx
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_front();
constexpr void pop_back();
constexpr void clear() noexcept;
3 Effects: Invalidates only the iterators and references to the erased elements.
4 Throws: Nothing.
5 Complexity: Erasing a single element is a constant time operation with a single call to the destructor
of T. Erasing a range in a list is linear time in the size of the range and the number of calls to the
destructor of typeT is exactly equal to the size of the range.
23.3.11.5 Operations [list.ops]
1 Since lists allow fast insertion and erasing from the middle of a list, certain operations are provided specifically
for them.188 In this subclause, arguments for a template parameter namedPredicate or BinaryPredicate
shall meet the corresponding requirements in 26.2. The semantics ofi + n and i - n, wherei is an iterator
into the list andn is an integer, are the same as those ofnext(i, n) and prev(i, n), respectively. For
merge and sort, the definitions and requirements in 26.8 apply.
2 list provides three splice operations that destructively move elements from one list to another. The behavior
of splice operations is undefined ifget_allocator() != x.get_allocator().
constexpr void splice(const_iterator position, list& x);
constexpr void splice(const_iterator position, list&& x);
3 Preconditions: addressof(x) != this is true.
4 Effects: Inserts the contents ofx before position and x becomes empty. Pointers and references to the
moved elements ofx now refer to those same elements but as members of*this. Iterators referring
to the moved elements will continue to refer to their elements, but they now behave as iterators into
*this, not intox.
5 Throws: Nothing.
6 Complexity: Constant time.
constexpr void splice(const_iterator position, list& x, const_iterator i);
constexpr void splice(const_iterator position, list&& x, const_iterator i);
7 Preconditions: i is a valid dereferenceable iterator ofx.
8 Effects: Inserts an element pointed to byi from listx before position and removes the element from
x. The result is unchanged ifposition == i or position == ++i. Pointers and references to*i
continue to refer to this same element but as a member of*this. Iterators to*i (including i itself)
continue to refer to the same element, but now behave as iterators into*this, not intox.
9 Throws: Nothing.
10 Complexity: Constant time.
constexpr void splice(const_iterator position, list& x,
const_iterator first, const_iterator last);
constexpr void splice(const_iterator position, list&& x,
const_iterator first, const_iterator last);
11 Preconditions: [first,last) is a valid range inx. positionis not an iterator in the range[first,last).
12 Effects: Inserts elements in the range[first,last) before position and removes the elements fromx.
Pointers and references to the moved elements ofx now refer to those same elements but as members
of *this. Iterators referring to the moved elements will continue to refer to their elements, but they
now behave as iterators into*this, not intox.
13 Throws: Nothing.
14 Complexity: Constant time ifaddressof(x) == this; otherwise, linear time.
188) As specified in 16.4.4.6, the requirements in this Clause apply only to lists whose allocators compare equal.
§ 23.3.11.5 © ISO/IEC
1003

===== PAGE 1015 =====

Dxxxx
constexpr size_type remove(const T& value);
template<class Predicate> constexpr size_type remove_if(Predicate pred);
15 Effects: Erases all the elements in the list referred to by a list iteratori for which the following
conditions hold: *i == value, pred(*i) != false. Invalidates only the iterators and references to
the erased elements.
16 Returns: The number of elements erased.
17 Throws: Nothing unless an exception is thrown by*i == value or pred(*i) != false.
18 Complexity: Exactly size() applications of the corresponding predicate.
19 Remarks: Stable (16.4.6.8).
constexpr size_type unique();
template<class BinaryPredicate> constexpr size_type unique(BinaryPredicate binary_pred);
20 Let binary_pred be equal_to<>{} for the first overload.
21 Preconditions: binary_pred is an equivalence relation.
22 Effects: Erases all but the first element from every consecutive group of equivalent elements. That is,
for a nonempty list, erases all elements referred to by the iteratori in the range[begin() + 1,end())
for whichbinary_pred(*i, *(i - 1)) is true. Invalidates only the iterators and references to the
erased elements.
23 Returns: The number of elements erased.
24 Throws: Nothing unless an exception is thrown by the predicate.
25 Complexity: If empty() is false, exactly size() - 1 applications of the corresponding predicate,
otherwise no applications of the predicate.
constexpr void merge(list& x);
constexpr void merge(list&& x);
template<class Compare> constexpr void merge(list& x, Compare comp);
template<class Compare> constexpr void merge(list&& x, Compare comp);
26 Let comp be less<> for the first two overloads.
27 Preconditions: *this and x are both sorted with respect to the comparatorcomp, andget_allocator()
== x.get_allocator() is true.
28 Effects: If addressof(x) == this, there are no effects. Otherwise, merges the two sorted ranges
[begin(),end()) and [x.begin(),x.end()). The result is a range that is sorted with respect to the
comparator comp. Pointers and references to the moved elements ofx now refer to those same elements
but as members of*this. Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into*this, not intox.
29 Complexity: At mostsize() + x.size() - 1 comparisons ifaddressof(x) != this; otherwise, no
comparisons are performed.
30 Remarks: Stable (16.4.6.8). Ifaddressof(x) != this, x is empty after the merge. No elements are
copied by this operation. If an exception is thrown other than by a comparison, there are no effects.
constexpr void reverse() noexcept;
31 Effects: Reverses the order of the elements in the list. Does not affect the validity of iterators and
references.
32 Complexity: Linear time.
void sort();
template<class Compare> void sort(Compare comp);
33 Effects: Sorts the list according to theoperator< or aCompare function object. If an exception is
thrown, the order of the elements in*this is unspecified. Does not affect the validity of iterators and
references.
34 Complexity: ApproximatelyNlog N comparisons, whereN is size().
35 Remarks: Stable (16.4.6.8).
§ 23.3.11.5 © ISO/IEC
1004

===== PAGE 1016 =====

Dxxxx
23.3.11.6 Erasure [list.erasure]
template<class T, class Allocator, class U = T>
typename list<T, Allocator>::size_type
constexpr erase(list<T, Allocator>& c, const U& value);
1 Effects: Equivalent to:
return erase_if(c, [&](const auto& elem) -> bool { return elem == value; });
template<class T, class Allocator, class Predicate>
typename list<T, Allocator>::size_type
constexpr erase_if(list<T, Allocator>& c, Predicate pred);
2 Effects: Equivalent to:return c.remove_if(pred);
23.3.12 Header <vector> synopsis [vector.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.3.13, class templatevector
template<class T, class Allocator = allocator<T>> class vector;
template<class T, class Allocator>
constexpr bool operator==(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
template<class T, class Allocator>
constexpr synth-three-way-result <T>
operator<=>(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
template<class T, class Allocator>
constexpr void swap(vector<T, Allocator>& x, vector<T, Allocator>& y)
noexcept(noexcept(x.swap(y)));
// 23.3.13.6, erasure
template<class T, class Allocator, class U = T>
constexpr typename vector<T, Allocator>::size_type
erase(vector<T, Allocator>& c, const U& value);
template<class T, class Allocator, class Predicate>
constexpr typename vector<T, Allocator>::size_type
erase_if(vector<T, Allocator>& c, Predicate pred);
namespace pmr {
template<class T>
using vector = std::vector<T, polymorphic_allocator<T>>;
}
// 23.3.14, specialization ofvector for bool
// 23.3.14.1, partial class template specializationvector<bool, Allocator>
template<class Allocator>
class vector<bool, Allocator>;
template<class T>
constexpr bool is-vector-bool-reference = see below ; // exposition only
// hash support
template<class T> struct hash;
template<class Allocator> struct hash<vector<bool, Allocator>>;
// 23.3.14.2, formatter specialization forvector<bool>
template<class T, class charT> requires is-vector-bool-reference <T>
struct formatter<T, charT>;
}
§ 23.3.12 © ISO/IEC
1005

===== PAGE 1017 =====

Dxxxx
23.3.13 Class template vector [vector]
23.3.13.1 Overview [vector.overview]
1 A vector is a sequence container that supports (amortized) constant time insert and erase operations at the
end; insert and erase in the middle take linear time. Storage management is handled automatically, though
hints can be given to improve efficiency.
2 A vector meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), of a sequence container, including most of the optional sequence container
requirements (23.2.4), and, for an element type other thanbool, of a contiguous container (23.2.2.2). The
exceptions are thepush_front, prepend_range, pop_front, andemplace_front member functions, which
are not provided. Descriptions are provided here only for operations onvector that are not described in one
of these tables or for operations where there is additional semantic information.
3 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
namespace std {
template<class T, class Allocator = allocator<T>>
class vector {
public:
// types
using value_type = T;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
// 23.3.13.2, construct/copy/destroy
constexpr vector() noexcept(noexcept(Allocator())) : vector(Allocator()) { }
constexpr explicit vector(const Allocator&) noexcept;
constexpr explicit vector(size_type n, const Allocator& = Allocator());
constexpr vector(size_type n, const T& value, const Allocator& = Allocator());
template<class InputIterator>
constexpr vector(InputIterator first, InputIterator last, const Allocator& = Allocator());
template<container-compatible-range <T> R>
constexpr vector(from_range_t, R&& rg, const Allocator& = Allocator());
constexpr vector(const vector& x);
constexpr vector(vector&&) noexcept;
constexpr vector(const vector&, const type_identity_t<Allocator>&);
constexpr vector(vector&&, const type_identity_t<Allocator>&);
constexpr vector(initializer_list<T>, const Allocator& = Allocator());
constexpr ~vector();
constexpr vector& operator=(const vector& x);
constexpr vector& operator=(vector&& x)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
constexpr vector& operator=(initializer_list<T>);
template<class InputIterator>
constexpr void assign(InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr void assign_range(R&& rg);
constexpr void assign(size_type n, const T& u);
constexpr void assign(initializer_list<T>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
§ 23.3.13.1 © ISO/IEC
1006

===== PAGE 1018 =====

Dxxxx
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// 23.3.13.3, capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
constexpr size_type capacity() const noexcept;
constexpr void resize(size_type sz);
constexpr void resize(size_type sz, const T& c);
constexpr void reserve(size_type n);
constexpr void shrink_to_fit();
// element access
constexpr reference operator[](size_type n);
constexpr const_reference operator[](size_type n) const;
constexpr reference at(size_type n);
constexpr const_reference at(size_type n) const;
constexpr reference front();
constexpr const_reference front() const;
constexpr reference back();
constexpr const_reference back() const;
// 23.3.13.4, data access
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
// 23.3.13.5, modifiers
template<class... Args> constexpr reference emplace_back(Args&&... args);
constexpr void push_back(const T& x);
constexpr void push_back(T&& x);
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg);
constexpr void pop_back();
template<class... Args> constexpr iterator emplace(const_iterator position, Args&&... args);
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position,
InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list<T> il);
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(vector&)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
constexpr void clear() noexcept;
};
§ 23.3.13.1 © ISO/IEC
1007

===== PAGE 1019 =====

Dxxxx
template<class InputIterator, class Allocator = allocator<iter-value-type <InputIterator>>>
vector(InputIterator, InputIterator, Allocator = Allocator())
-> vector<iter-value-type <InputIterator>, Allocator>;
template<ranges::input_range R, class Allocator = allocator<ranges::range_value_t<R>>>
vector(from_range_t, R&&, Allocator = Allocator())
-> vector<ranges::range_value_t<R>, Allocator>;
}
4 An incomplete typeT may be used when instantiatingvector if the allocator meets the allocator completeness
requirements (16.4.4.6.2). T shall be complete before any member of the resulting specialization ofvector is
referenced.
23.3.13.2 Constructors [vector.cons]
constexpr explicit vector(const Allocator&) noexcept;
1 Effects: Constructs an emptyvector, using the specified allocator.
2 Complexity: Constant.
constexpr explicit vector(size_type n, const Allocator& = Allocator());
3 Preconditions: T is Cpp17DefaultInsertable into vector.
4 Effects: Constructs avector with n default-inserted elements using the specified allocator.
5 Complexity: Linear inn.
constexpr vector(size_type n, const T& value,
const Allocator& = Allocator());
6 Preconditions: T is Cpp17CopyInsertable into vector.
7 Effects: Constructs avector with n copies ofvalue, using the specified allocator.
8 Complexity: Linear inn.
template<class InputIterator>
constexpr vector(InputIterator first, InputIterator last,
const Allocator& = Allocator());
9 Effects: Constructs avector equal to the range[first,last), using the specified allocator.
10 Complexity: Makes onlyN calls to the copy constructor ofT (where N is the distance betweenfirst
and last) and no reallocations ifInputIterator meets theCpp17ForwardIteratorrequirements. It
makes orderN calls to the copy constructor ofT and orderlog N reallocations if they are just input
iterators.
template<container-compatible-range <T> R>
constexpr vector(from_range_t, R&& rg, const Allocator& = Allocator());
11 Effects: Constructs avector object with the elements of the rangerg, using the specified allocator.
12 Complexity: Initializes exactlyN elements from the results of dereferencing successive iterators ofrg,
where N is ranges::distance(rg).
13 Performs no reallocations if:
—(13.1) R models ranges::approximately_sized_range, andranges::distance(rg) <= ranges::re-
serve_hint(rg) is true, or
—(13.2) R models ranges::forward_range and R does not modelranges::approximately_sized_range.
Otherwise, performs orderlog N reallocations and orderN calls to the copy or move constructor ofT.
23.3.13.3 Capacity [vector.capacity]
constexpr size_type capacity() const noexcept;
1 Returns: The total number of elements that the vector can hold without requiring reallocation.
2 Complexity: Constant time.
§ 23.3.13.3 © ISO/IEC
1008

===== PAGE 1020 =====

Dxxxx
constexpr void reserve(size_type n);
3 Preconditions: T is Cpp17MoveInsertable into vector.
4 Effects: A directive that informs avector of a planned change in size, so that it can manage the storage
allocation accordingly. Afterreserve(), capacity() is greater or equal to the argument ofreserve if
reallocation happens; and equal to the previous value ofcapacity() otherwise. Reallocation happens
at this point if and only if the current capacity is less than the argument ofreserve(). If an exception
is thrown other than by the move constructor of a non-Cpp17CopyInsertable type, there are no effects.
5 Throws: length_error if n > max_size().189
6 Complexity: Linear in the size of the sequence.
7 Remarks: The size of the sequence is not changed. Reallocation invalidates all the references, pointers,
and iterators referring to the elements in the sequence, as well as the past-the-end iterator.
[Note 1: If no reallocation happens, they remain valid.—end note]
No reallocation shall take place during insertions that happen after a call toreserve() until an
insertion would make the size of the vector greater than the value ofcapacity().
constexpr void shrink_to_fit();
8 Preconditions: T is Cpp17MoveInsertable into vector.
9 Effects: shrink_to_fit is a non-binding request to reducecapacity() to size().
[Note 2: The request is non-binding to allow latitude for implementation-specific optimizations.—end note]
It does not increasecapacity(), but may reducecapacity() by causing reallocation. If an exception
is thrown other than by the move constructor of a non-Cpp17CopyInsertable T, there are no effects.
10 Complexity: If reallocation happens, linear in the size of the sequence.
11 Remarks: Reallocation invalidates all the references, pointers, and iterators referring to the elements in
the sequence as well as the past-the-end iterator.
[Note 3: If no reallocation happens, they remain valid.—end note]
constexpr void swap(vector& x)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
12 Effects: Exchanges the contents andcapacity() of *this with that ofx.
13 Complexity: Constant time.
constexpr void resize(size_type sz);
14 Preconditions: T is Cpp17MoveInsertable and Cpp17DefaultInsertable into vector.
15 Effects: If sz < size(), erases the lastsize() - sz elements from the sequence. Otherwise, appends
sz - size() default-inserted elements to the sequence.
16 Remarks: If an exception is thrown other than by the move constructor of a non-Cpp17CopyInsertable
T, there are no effects.
constexpr void resize(size_type sz, const T& c);
17 Preconditions: T is Cpp17CopyInsertable into vector.
18 Effects: If sz < size(), erases the lastsize() - sz elements from the sequence. Otherwise, appends
sz - size() copies ofc to the sequence.
19 Remarks: If an exception is thrown, there are no effects.
23.3.13.4 Data [vector.data]
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
1 Returns: A pointer such that[data(),data() + size()) is a valid range. For a non-empty vector,
data() == addressof(front()) is true.
189) reserve() uses Allocator::allocate() which can throw an appropriate exception.
§ 23.3.13.4 © ISO/IEC
1009

===== PAGE 1021 =====

Dxxxx
2 Complexity: Constant time.
23.3.13.5 Modifiers [vector.modifiers]
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position, InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list<T>);
template<class... Args> constexpr reference emplace_back(Args&&... args);
template<class... Args> constexpr iterator emplace(const_iterator position, Args&&... args);
constexpr void push_back(const T& x);
constexpr void push_back(T&& x);
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg);
1 Complexity: If reallocation happens, linear in the number of elements of the resulting vector; otherwise,
linear in the number of elements inserted plus the distance to the end of the vector.
2 Remarks: Causes reallocation if the new size is greater than the old capacity. Reallocation invalidates
all the references, pointers, and iterators referring to the elements in the sequence, as well as the past-
the-end iterator. If no reallocation happens, then references, pointers, and iterators before the insertion
point remain valid but those at or after the insertion point, including the past-the-end iterator, are
invalidated. If an exception is thrown other than by the copy constructor, move constructor, assignment
operator, or move assignment operator ofT or by anyInputIterator operation, there are no effects.
If an exception is thrown while inserting a single element at the end andT is Cpp17CopyInsertable
or is_nothrow_move_constructible_v<T> is true, there are no effects. Otherwise, if an exception is
thrown by the move constructor of a non-Cpp17CopyInsertable T, the effects are unspecified.
3 For the declarations taking a rangeR, performs at most one reallocation if:
—(3.1) R models ranges::approximately_sized_range and ranges::distance(rg) <= ranges::re-
serve_hint(rg) is true, or
—(3.2) R models ranges::forward_range and R does not modelranges::approximately_sized_range.
For the declarations taking a pair ofInputIterator, performs at most one reallocation ifInputItera-
tor meets theCpp17ForwardIteratorrequirements.
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();
4 Effects: Invalidates iterators and references at or after the point of the erase.
5 Throws: Nothing unless an exception is thrown by the assignment operator or move assignment operator
of T.
6 Complexity: The destructor ofT is called the number of times equal to the number of the elements
erased, but the assignment operator ofT is called the number of times equal to the number of elements
in the vector after the erased elements.
23.3.13.6 Erasure [vector.erasure]
template<class T, class Allocator, class U = T>
constexpr typename vector<T, Allocator>::size_type
erase(vector<T, Allocator>& c, const U& value);
1 Effects: Equivalent to:
auto it = remove(c.begin(), c.end(), value);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
§ 23.3.13.6 © ISO/IEC
1010

===== PAGE 1022 =====

Dxxxx
template<class T, class Allocator, class Predicate>
constexpr typename vector<T, Allocator>::size_type
erase_if(vector<T, Allocator>& c, Predicate pred);
2 Effects: Equivalent to:
auto it = remove_if(c.begin(), c.end(), pred);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
23.3.14 Specialization of vector for bool [vector.bool]
23.3.14.1 Partial class template specialization vector<bool, Allocator> [vector.bool.pspc]
1 To optimize space allocation, a partial specialization ofvector for bool elements is provided:
namespace std {
template<class Allocator>
class vector<bool, Allocator> {
public:
// types
using value_type = bool;
using allocator_type = Allocator;
using pointer = implementation-defined ;
using const_pointer = implementation-defined ;
using const_reference = bool;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
// bit reference
class reference {
public:
constexpr reference(const reference& x) noexcept;
constexpr ~reference();
constexpr reference& operator=(bool x) noexcept;
constexpr reference& operator=(const reference& x) noexcept;
constexpr const reference& operator=(bool x) const noexcept;
constexpr operator bool() const noexcept;
constexpr void flip() noexcept; // flips the bit
friend constexpr void swap(reference x, reference y) noexcept;
friend constexpr void swap(reference x, bool& y) noexcept;
friend constexpr void swap(bool& x, reference y) noexcept;
};
// construct/copy/destroy
constexpr vector() noexcept(noexcept(Allocator())) : vector(Allocator()) { }
constexpr explicit vector(const Allocator&) noexcept;
constexpr explicit vector(size_type n, const Allocator& = Allocator());
constexpr vector(size_type n, const bool& value, const Allocator& = Allocator());
template<class InputIterator>
constexpr vector(InputIterator first, InputIterator last, const Allocator& = Allocator());
template<container-compatible-range <bool> R>
constexpr vector(from_range_t, R&& rg, const Allocator& = Allocator());
constexpr vector(const vector& x);
constexpr vector(vector&& x) noexcept;
constexpr vector(const vector&, const type_identity_t<Allocator>&);
constexpr vector(vector&&, const type_identity_t<Allocator>&);
constexpr vector(initializer_list<bool>, const Allocator& = Allocator());
constexpr ~vector();
constexpr vector& operator=(const vector& x);
§ 23.3.14.1 © ISO/IEC
1011

===== PAGE 1023 =====

Dxxxx
constexpr vector& operator=(vector&& x)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
constexpr vector& operator=(initializer_list<bool>);
template<class InputIterator>
constexpr void assign(InputIterator first, InputIterator last);
template<container-compatible-range <bool> R>
constexpr void assign_range(R&& rg);
constexpr void assign(size_type n, const bool& t);
constexpr void assign(initializer_list<bool>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
constexpr size_type capacity() const noexcept;
constexpr void resize(size_type sz, bool c = false);
constexpr void reserve(size_type n);
constexpr void shrink_to_fit();
// element access
constexpr reference operator[](size_type n);
constexpr const_reference operator[](size_type n) const;
constexpr reference at(size_type n);
constexpr const_reference at(size_type n) const;
constexpr reference front();
constexpr const_reference front() const;
constexpr reference back();
constexpr const_reference back() const;
// modifiers
template<class... Args> constexpr reference emplace_back(Args&&... args);
constexpr void push_back(const bool& x);
template<container-compatible-range <bool> R>
constexpr void append_range(R&& rg);
constexpr void pop_back();
template<class... Args> constexpr iterator emplace(const_iterator position, Args&&... args);
constexpr iterator insert(const_iterator position, const bool& x);
constexpr iterator insert(const_iterator position, size_type n, const bool& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position,
InputIterator first, InputIterator last);
template<container-compatible-range <bool> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list<bool> il);
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
§ 23.3.14.1 © ISO/IEC
1012

===== PAGE 1024 =====

Dxxxx
constexpr void swap(vector&)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
constexpr void flip() noexcept; // flips all bits
constexpr void clear() noexcept;
};
}
2 Unless described below, all operations have the same requirements and semantics as thevector primary
template, except that operations dealing with thebool value type map to bit values in the container storage
and allocator_traits::construct (20.2.9.3) is not used to construct these values.
3 There is no requirement that the data be stored as a contiguous allocation ofbool values. A space-optimized
representation of bits is recommended instead.
4 reference is a class that simulates a reference to a single bit in the sequence.
constexpr reference::reference(const reference& x) noexcept;
5 Effects: Initializes *this to refer to the same bit asx.
constexpr reference::~reference();
6 Effects: None.
constexpr reference& reference::operator=(bool x) noexcept;
constexpr reference& reference::operator=(const reference& x) noexcept;
constexpr const reference& reference::operator=(bool x) const noexcept;
7 Effects: Sets the bit referred to by*this when bool(x) is true, and clears it otherwise.
8 Returns: *this.
constexpr void reference::flip() noexcept;
9 Effects: Equivalent to*this = !*this.
constexpr void swap(reference x, reference y) noexcept;
constexpr void swap(reference x, bool& y) noexcept;
constexpr void swap(bool& x, reference y) noexcept;
10 Effects: Exchanges the values denoted byx and y as if by:
bool b = x;
x = y;
y = b;
constexpr void flip() noexcept;
11 Effects: Replaces each element in the container with its complement.
template<class Allocator> struct hash<vector<bool, Allocator>>;
12 The specialization is enabled (22.10.19).
template<class T>
constexpr bool is-vector-bool-reference = see below ;
13 The expressionis-vector-bool-reference <T> is true if T denotes the typevector<bool, Alloc>::
reference for some typeAlloc and vector<bool, Alloc> is not a program-defined specialization.
23.3.14.2 Formatter specialization for vector<bool> [vector.bool.fmt]
namespace std {
template<class T, class charT>
requires is-vector-bool-reference <T>
struct formatter<T, charT> {
private:
formatter<bool, charT> underlying_; // exposition only
§ 23.3.14.2 © ISO/IEC
1013

===== PAGE 1025 =====

Dxxxx
public:
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
template<class FormatContext>
typename FormatContext::iterator
format(const T& ref, FormatContext& ctx) const;
};
}
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
1 Equivalent to:return underlying_.parse(ctx);
template<class FormatContext>
typename FormatContext::iterator
format(const T& ref, FormatContext& ctx) const;
2 Equivalent to:return underlying_.format(ref, ctx);
23.3.15 Header <inplace_vector> synopsis [inplace.vector.syn]
// mostly freestanding
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.3.16, class templateinplace_vector
template<class T, size_t N> class inplace_vector; // partially freestanding
// 23.3.16.6, erasure
template<class T, size_t N, class U = T>
constexpr typename inplace_vector<T, N>::size_type
erase(inplace_vector<T, N>& c, const U& value);
template<class T, size_t N, class Predicate>
constexpr typename inplace_vector<T, N>::size_type
erase_if(inplace_vector<T, N>& c, Predicate pred);
}
23.3.16 Class template inplace_vector [inplace.vector]
23.3.16.1 Overview [inplace.vector.overview]
1 An inplace_vector is a contiguous container. Its capacity is fixed and its elements are stored within the
inplace_vector object itself.
2 An inplace_vector meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3),
of a contiguous container, and of a sequence container, including most of the optional sequence container
requirements (23.2.4). The exceptions are thepush_front, prepend_range, pop_front, andemplace_front
member functions, which are not provided. Descriptions are provided here only for operations oninplace_-
vector that are not described in one of these tables or for operations where there is additional semantic
information.
3 For any N, inplace_vector<T, N>::iterator and inplace_vector<T, N>::const_iterator meet the
constexpr iterator requirements.
4 Any member function ofinplace_vector<T, N> that would cause the size to exceedN throws an exception
of typebad_alloc.
5 Let IV denote a specialization ofinplace_vector<T, N>. If N is zero, thenIV is trivially copyable and
empty, andstd::is_trivially_default_constructible_v<IV> is true. Otherwise:
—(5.1) If is_trivially_copy_constructible_v<T> is true, thenIV has a trivial copy constructor.
—(5.2) If is_trivially_move_constructible_v<T> is true, thenIV has a trivial move constructor.
§ 23.3.16.1 © ISO/IEC
1014

===== PAGE 1026 =====

Dxxxx
—(5.3) If is_trivially_destructible_v<T> is true, then:
—(5.3.1) IV has a trivial destructor.
—(5.3.2) If
is_trivially_copy_constructible_v<T> && is_trivially_copy_assignable_v<T>
is true, thenIV has a trivial copy assignment operator.
—(5.3.3) If
is_trivially_move_constructible_v<T> && is_trivially_move_assignable_v<T>
is true, thenIV has a trivial move assignment operator.
namespace std {
template<class T, size_t N>
class inplace_vector {
public:
// types:
using value_type = T;
using pointer = T*;
using const_pointer = const T*;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = size_t;
using difference_type = ptrdiff_t;
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
// 23.3.16.2, construct/copy/destroy
constexpr inplace_vector() noexcept;
constexpr explicit inplace_vector(size_type n); // freestanding-deleted
constexpr inplace_vector(size_type n, const T& value); // freestanding-deleted
template<class InputIterator>
constexpr inplace_vector(InputIterator first, InputIterator last); // freestanding-deleted
template<container-compatible-range <T> R>
constexpr inplace_vector(from_range_t, R&& rg); // freestanding-deleted
constexpr inplace_vector(const inplace_vector&);
constexpr inplace_vector(inplace_vector&&)
noexcept(N == 0 || is_nothrow_move_constructible_v<T>);
constexpr inplace_vector(initializer_list<T> il); // freestanding-deleted
constexpr ~inplace_vector();
constexpr inplace_vector& operator=(const inplace_vector& other);
constexpr inplace_vector& operator=(inplace_vector&& other)
noexcept(N == 0 || (is_nothrow_move_assignable_v<T> &&
is_nothrow_move_constructible_v<T>));
constexpr inplace_vector& operator=(initializer_list<T>); // freestanding-deleted
template<class InputIterator>
constexpr void assign(InputIterator first, InputIterator last); // freestanding-deleted
template<container-compatible-range <T> R>
constexpr void assign_range(R&& rg); // freestanding-deleted
constexpr void assign(size_type n, const T& u); // freestanding-deleted
constexpr void assign(initializer_list<T> il); // freestanding-deleted
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
§ 23.3.16.1 © ISO/IEC
1015

===== PAGE 1027 =====

Dxxxx
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// 23.3.16.3, capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
static constexpr size_type max_size() noexcept;
static constexpr size_type capacity() noexcept;
constexpr void resize(size_type sz); // freestanding-deleted
constexpr void resize(size_type sz, const T& c); // freestanding-deleted
static constexpr void reserve(size_type n); // freestanding-deleted
static constexpr void shrink_to_fit() noexcept;
// element access
constexpr reference operator[](size_type n);
constexpr const_reference operator[](size_type n) const;
constexpr reference at(size_type n); // freestanding-deleted
constexpr const_reference at(size_type n) const; // freestanding-deleted
constexpr reference front();
constexpr const_reference front() const;
constexpr reference back();
constexpr const_reference back() const;
// 23.3.16.4, data access
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
// 23.3.16.5, modifiers
template<class... Args>
constexpr reference emplace_back(Args&&... args); // freestanding-deleted
constexpr reference push_back(const T& x); // freestanding-deleted
constexpr reference push_back(T&& x); // freestanding-deleted
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg); // freestanding-deleted
constexpr void pop_back();
template<class... Args>
constexpr pointer try_emplace_back(Args&&... args);
constexpr pointer try_push_back(const T& x);
constexpr pointer try_push_back(T&& x);
template<container-compatible-range <T> R>
constexpr ranges::borrowed_iterator_t<R> try_append_range(R&& rg);
template<class... Args>
constexpr reference unchecked_emplace_back(Args&&... args);
constexpr reference unchecked_push_back(const T& x);
constexpr reference unchecked_push_back(T&& x);
template<class... Args>
constexpr iterator emplace(const_iterator position, Args&&... args); // freestanding-deleted
constexpr iterator insert(const_iterator position, const T& x); // freestanding-deleted
constexpr iterator insert(const_iterator position, T&& x); // freestanding-deleted
constexpr iterator insert(const_iterator position, size_type n, // freestanding-deleted
const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position, // freestanding-deleted
InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg); // freestanding-deleted
constexpr iterator insert(const_iterator position, // freestanding-deleted
initializer_list<T> il);
constexpr iterator erase(const_iterator position);
§ 23.3.16.1 © ISO/IEC
1016

===== PAGE 1028 =====

Dxxxx
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(inplace_vector& x)
noexcept(N == 0 || (is_nothrow_swappable_v<T> &&
is_nothrow_move_constructible_v<T>));
constexpr void clear() noexcept;
friend constexpr bool operator==(const inplace_vector& x,
const inplace_vector& y);
friend constexpr synth-three-way-result <T>
operator<=>(const inplace_vector& x, const inplace_vector& y);
friend constexpr void swap(inplace_vector& x, inplace_vector& y)
noexcept(N == 0 || (is_nothrow_swappable_v<T> &&
is_nothrow_move_constructible_v<T>))
{ x.swap(y); }
};
}
23.3.16.2 Constructors [inplace.vector.cons]
constexpr explicit inplace_vector(size_type n);
1 Preconditions: T is Cpp17DefaultInsertable into inplace_vector.
2 Effects: Constructs aninplace_vector with n default-inserted elements.
3 Complexity: Linear inn.
constexpr inplace_vector(size_type n, const T& value);
4 Preconditions: T is Cpp17CopyInsertable into inplace_vector.
5 Effects: Constructs aninplace_vector with n copies ofvalue.
6 Complexity: Linear inn.
template<class InputIterator>
constexpr inplace_vector(InputIterator first, InputIterator last);
7 Effects: Constructs aninplace_vector equal to the range[first,last).
8 Complexity: Linear indistance(first, last).
template<container-compatible-range <T> R>
constexpr inplace_vector(from_range_t, R&& rg);
9 Mandates: If ranges::size(rg) is a constant expression, thenranges::size(rg) ≤N.
10 Effects: Constructs aninplace_vector with the elements of the rangerg.
11 Complexity: Linear inranges::distance(rg).
23.3.16.3 Capacity [inplace.vector.capacity]
static constexpr size_type capacity() noexcept;
static constexpr size_type max_size() noexcept;
1 Returns: N.
constexpr void resize(size_type sz);
2 Preconditions: T is Cpp17DefaultInsertable into inplace_vector.
3 Effects: If sz < size(), erases the lastsize() - sz elements from the sequence. Otherwise, appends
sz - size() default-inserted elements to the sequence.
4 Remarks: If an exception is thrown, there are no effects on*this.
constexpr void resize(size_type sz, const T& c);
5 Preconditions: T is Cpp17CopyInsertable into inplace_vector.
6 Effects: If sz < size(), erases the lastsize() - sz elements from the sequence. Otherwise, appends
sz - size() copies ofc to the sequence.
7 Remarks: If an exception is thrown, there are no effects on*this.
§ 23.3.16.3 © ISO/IEC
1017

===== PAGE 1029 =====

Dxxxx
static constexpr void reserve(size_type n);
8 Effects: None.
9 Throws: bad_alloc if n > capacity() is true.
static constexpr void shrink_to_fit() noexcept;
10 Effects: None.
23.3.16.4 Data [inplace.vector.data]
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
1 Returns: A pointer such that[data(),data() + size()) is a valid range. For a non-emptyinplace_-
vector, data() == addressof(front()) is true.
2 Complexity: Constant time.
23.3.16.5 Modifiers [inplace.vector.modifiers]
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position, InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list<T> il);
template<class... Args>
constexpr iterator emplace(const_iterator position, Args&&... args);
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg);
1 Let n be the value ofsize() before this call for theappend_range overload, anddistance(begin,
position) otherwise.
2 Complexity: Linear in the number of elements inserted plus the distance to the end of the vector.
3 Remarks: If an exception is thrown other than by the copy constructor, move constructor, assignment
operator, or move assignment operator ofT or by anyInputIterator operation, there are no effects.
Otherwise, if an exception is thrown, thensize() ≥n and elements in the rangebegin() + [0,n) are
not modified.
constexpr reference push_back(const T& x);
constexpr reference push_back(T&& x);
template<class... Args>
constexpr reference emplace_back(Args&&... args);
4 Returns: back().
5 Throws: bad_alloc or any exception thrown by the initialization of the inserted element.
6 Complexity: Constant.
7 Remarks: If an exception is thrown, there are no effects on*this.
template<class... Args>
constexpr pointer try_emplace_back(Args&&... args);
constexpr pointer try_push_back(const T& x);
constexpr pointer try_push_back(T&& x);
8 Let vals denote a pack:
—(8.1) std::forward<Args>(args)... for the first overload,
—(8.2) x for the second overload,
—(8.3) std::move(x) for the third overload.
§ 23.3.16.5 © ISO/IEC
1018

===== PAGE 1030 =====

Dxxxx
9 Preconditions: value_type is Cpp17EmplaceConstructible into inplace_vector from vals....
10 Effects: If size() < capacity() is true, appends an object of typeT direct-non-list-initialized with
vals.... Otherwise, there are no effects.
11 Returns: nullptr if size() == capacity() is true, otherwiseaddressof(back()).
12 Throws: Nothing unless an exception is thrown by the initialization of the inserted element.
13 Complexity: Constant.
14 Remarks: If an exception is thrown, there are no effects on*this.
template<container-compatible-range <T> R>
constexpr ranges::borrowed_iterator_t<R> try_append_range(R&& rg);
15 Preconditions: value_type is Cpp17EmplaceConstructible into inplace_vector from
*ranges::begin(rg).
16 Effects: Appends copies of initial elements inrg before end(), until all elements are inserted orsize()
== capacity() is true. Each iterator in the rangerg is dereferenced at most once.
17 Returns: The first iterator in the rangeranges::begin(rg)+ [0, n) that was not inserted into*this,
where n is the number of elements inrg.
18 Complexity: Linear in the number of elements inserted.
19 Remarks: Let n be the value ofsize() prior to this call. If an exception is thrown after the insertion
of k elements, thensize() equals n+ k, elements in the rangebegin() + [0,n) are not modified, and
elements in the rangebegin() + [n,n + k) correspond to the inserted elements.
template<class... Args>
constexpr reference unchecked_emplace_back(Args&&... args);
20 Preconditions: size() < capacity() is true.
21 Effects: Equivalent to:return *try_emplace_back(std::forward<Args>(args)...);
constexpr reference unchecked_push_back(const T& x);
constexpr reference unchecked_push_back(T&& x);
22 Preconditions: size() < capacity() is true.
23 Effects: Equivalent to:return *try_push_back(std::forward<decltype(x)>(x));
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();
24 Effects: Invalidates iterators and references at or after the point of the erase.
25 Throws: Nothing unless an exception is thrown by the assignment operator or move assignment operator
of T.
26 Complexity: The destructor ofT is called the number of times equal to the number of the elements
erased, but the assignment operator ofT is called the number of times equal to the number of elements
after the erased elements.
23.3.16.6 Erasure [inplace.vector.erasure]
template<class T, size_t N, class U = T>
constexpr size_t erase(inplace_vector<T, N>& c, const U& value);
1 Effects: Equivalent to:
auto it = remove(c.begin(), c.end(), value);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
template<class T, size_t N, class Predicate>
constexpr size_t erase_if(inplace_vector<T, N>& c, Predicate pred);
2 Effects: Equivalent to:
auto it = remove_if(c.begin(), c.end(), pred);
§ 23.3.16.6 © ISO/IEC
1019

===== PAGE 1031 =====

Dxxxx
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
23.4 Associative containers [associative]
23.4.1 General [associative.general]
1 The header<map> (23.4.2) defines the class templatesmap and multimap; the header<set> (23.4.5) defines
the class templatesset and multiset.
2 The following exposition-only alias templates may appear in deduction guides for associative containers:
template<class InputIterator>
using iter-value-type = iterator_traits<InputIterator>::value_type; // exposition only
template<class InputIterator>
using iter-key-type = remove_const_t<
tuple_element_t<0, iter-value-type <InputIterator>>>; // exposition only
template<class InputIterator>
using iter-mapped-type =
tuple_element_t<1, iter-value-type <InputIterator>>; // exposition only
template<class InputIterator>
using iter-to-alloc-type = pair<
const tuple_element_t<0, iter-value-type <InputIterator>>,
tuple_element_t<1, iter-value-type <InputIterator>>>; // exposition only
template<ranges::input_range Range>
using range-key-type =
remove_const_t<typename ranges::range_value_t<Range>::first_type>; // exposition only
template<ranges::input_range Range>
using range-mapped-type = ranges::range_value_t<Range>::second_type; // exposition only
template<ranges::input_range Range>
using range-to-alloc-type =
pair<const typename ranges::range_value_t<Range>::first_type,
typename ranges::range_value_t<Range>::second_type>; // exposition only
23.4.2 Header <map> synopsis [associative.map.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.4.3, class templatemap
template<class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T>>>
class map;
template<class Key, class T, class Compare, class Allocator>
constexpr bool operator==(const map<Key, T, Compare, Allocator>& x,
const map<Key, T, Compare, Allocator>& y);
template<class Key, class T, class Compare, class Allocator>
constexpr synth-three-way-result <pair<const Key, T>>
operator<=>(const map<Key, T, Compare, Allocator>& x,
const map<Key, T, Compare, Allocator>& y);
template<class Key, class T, class Compare, class Allocator>
constexpr void swap(map<Key, T, Compare, Allocator>& x,
map<Key, T, Compare, Allocator>& y)
noexcept(noexcept(x.swap(y)));
// 23.4.3.5, erasure formap
template<class Key, class T, class Compare, class Allocator, class Predicate>
constexpr typename map<Key, T, Compare, Allocator>::size_type
erase_if(map<Key, T, Compare, Allocator>& c, Predicate pred);
§ 23.4.2 © ISO/IEC
1020

===== PAGE 1032 =====

Dxxxx
// 23.4.4, class templatemultimap
template<class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T>>>
class multimap;
template<class Key, class T, class Compare, class Allocator>
constexpr bool operator==(const multimap<Key, T, Compare, Allocator>& x,
const multimap<Key, T, Compare, Allocator>& y);
template<class Key, class T, class Compare, class Allocator>
constexpr synth-three-way-result <pair<const Key, T>>
operator<=>(const multimap<Key, T, Compare, Allocator>& x,
const multimap<Key, T, Compare, Allocator>& y);
template<class Key, class T, class Compare, class Allocator>
constexpr void swap(multimap<Key, T, Compare, Allocator>& x,
multimap<Key, T, Compare, Allocator>& y)
noexcept(noexcept(x.swap(y)));
// 23.4.4.4, erasure formultimap
template<class Key, class T, class Compare, class Allocator, class Predicate>
constexpr typename multimap<Key, T, Compare, Allocator>::size_type
erase_if(multimap<Key, T, Compare, Allocator>& c, Predicate pred);
namespace pmr {
template<class Key, class T, class Compare = less<Key>>
using map = std::map<Key, T, Compare,
polymorphic_allocator<pair<const Key, T>>>;
template<class Key, class T, class Compare = less<Key>>
using multimap = std::multimap<Key, T, Compare,
polymorphic_allocator<pair<const Key, T>>>;
}
}
23.4.3 Class template map [map]
23.4.3.1 Overview [map.overview]
1 A map is an associative container that supports unique keys (i.e., contains at most one of each key value) and
provides for fast retrieval of values of another typeT based on the keys. Themap class supports bidirectional
iterators.
2 A map meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), and of an associative container (23.2.7). Amap also provides most
operations described in 23.2.7 for unique keys. This means that amapsupports thea_uniqoperations in 23.2.7
but not thea_eq operations. For amap<Key,T> the key_type is Key and thevalue_type is pair<const
Key,T>. Descriptions are provided here only for operations onmap that are not described in one of those
tables or for operations where there is additional semantic information.
3 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
namespace std {
template<class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T>>>
class map {
public:
// types
using key_type = Key;
using mapped_type = T;
using value_type = pair<const Key, T>;
using key_compare = Compare;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
§ 23.4.3.1 © ISO/IEC
1021

===== PAGE 1033 =====

Dxxxx
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using node_type = unspecified ;
using insert_return_type = insert-return-type<iterator, node_type>;
class value_compare {
protected:
Compare comp;
constexpr value_compare(Compare c) : comp(c) {}
public:
constexpr bool operator()(const value_type& x, const value_type& y) const {
return comp(x.first, y.first);
}
};
// 23.4.3.2, construct/copy/destroy
constexpr map() : map(Compare()) { }
constexpr explicit map(const Compare& comp, const Allocator& = Allocator());
template<class InputIterator>
constexpr map(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
template<container-compatible-range <value_type> R>
constexpr map(from_range_t, R&& rg, const Compare& comp = Compare(),
const Allocator& = Allocator());
constexpr map(const map& x);
constexpr map(map&& x);
constexpr explicit map(const Allocator&);
constexpr map(const map&, const type_identity_t<Allocator>&);
constexpr map(map&&, const type_identity_t<Allocator>&);
constexpr map(initializer_list<value_type>, const Compare& = Compare(),
const Allocator& = Allocator());
template<class InputIterator>
constexpr map(InputIterator first, InputIterator last, const Allocator& a)
: map(first, last, Compare(), a) { }
template<container-compatible-range <value_type> R>
constexpr map(from_range_t, R&& rg, const Allocator& a)
: map(from_range, std::forward<R>(rg), Compare(), a) { }
constexpr map(initializer_list<value_type> il, const Allocator& a)
: map(il, Compare(), a) { }
constexpr ~map();
constexpr map& operator=(const map& x);
constexpr map& operator=(map&& x)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Compare>);
constexpr map& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
§ 23.4.3.1 © ISO/IEC
1022

===== PAGE 1034 =====

Dxxxx
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.4.3.3, element access
constexpr mapped_type& operator[](const key_type& x);
constexpr mapped_type& operator[](key_type&& x);
template<class K> constexpr mapped_type& operator[](K&& x);
constexpr mapped_type& at(const key_type& x);
constexpr const mapped_type& at(const key_type& x) const;
template<class K> constexpr mapped_type& at(const K& x);
template<class K> constexpr const mapped_type& at(const K& x) const;
// 23.4.3.4, modifiers
template<class... Args> constexpr pair<iterator, bool> emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr pair<iterator, bool> insert(const value_type& x);
constexpr pair<iterator, bool> insert(value_type&& x);
template<class P> constexpr pair<iterator, bool> insert(P&& x);
constexpr iterator insert(const_iterator position, const value_type& x);
constexpr iterator insert(const_iterator position, value_type&& x);
template<class P>
constexpr iterator insert(const_iterator position, P&&);
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> constexpr node_type extract(K&& x);
constexpr insert_return_type insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
template<class... Args>
constexpr pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
constexpr pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class K, class... Args>
constexpr pair<iterator, bool> try_emplace(K&& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
template<class K, class... Args>
constexpr iterator try_emplace(const_iterator hint, K&& k, Args&&... args);
template<class M>
constexpr pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
constexpr pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class K, class M>
constexpr pair<iterator, bool> insert_or_assign(K&& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
§ 23.4.3.1 © ISO/IEC
1023

===== PAGE 1035 =====

Dxxxx
template<class K, class M>
constexpr iterator insert_or_assign(const_iterator hint, K&& k, M&& obj);
constexpr iterator erase(iterator position);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(map&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Compare>);
constexpr void clear() noexcept;
template<class C2>
constexpr void merge(map<Key, T, C2, Allocator>& source);
template<class C2>
constexpr void merge(map<Key, T, C2, Allocator>&& source);
template<class C2>
constexpr void merge(multimap<Key, T, C2, Allocator>& source);
template<class C2>
constexpr void merge(multimap<Key, T, C2, Allocator>&& source);
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
// map operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
};
template<class InputIterator, class Compare = less<iter-key-type <InputIterator>>,
class Allocator = allocator<iter-to-alloc-type <InputIterator>>>
map(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
-> map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Compare, Allocator>;
§ 23.4.3.1 © ISO/IEC
1024

===== PAGE 1036 =====

Dxxxx
template<ranges::input_range R, class Compare = less<range-key-type <R>,
class Allocator = allocator<range-to-alloc-type <R>>>
map(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> map<range-key-type <R>, range-mapped-type <R>, Compare, Allocator>;
template<class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T>>>
map(initializer_list<pair<Key, T>>, Compare = Compare(), Allocator = Allocator())
-> map<Key, T, Compare, Allocator>;
template<class InputIterator, class Allocator>
map(InputIterator, InputIterator, Allocator)
-> map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
less<iter-key-type <InputIterator>>, Allocator>;
template<ranges::input_range R, class Allocator>
map(from_range_t, R&&, Allocator)
-> map<range-key-type <R>, range-mapped-type <R>, less<range-key-type <R>>, Allocator>;
template<class Key, class T, class Allocator>
map(initializer_list<pair<Key, T>>, Allocator) -> map<Key, T, less<Key>, Allocator>;
}
23.4.3.2 Constructors, copy, and assignment [map.cons]
constexpr explicit map(const Compare& comp, const Allocator& = Allocator());
1 Effects: Constructs an emptymap using the specified comparison object and allocator.
2 Complexity: Constant.
template<class InputIterator>
constexpr map(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
3 Effects: Constructs an emptymap using the specified comparison object and allocator, and inserts
elements from the range[first,last).
4 Complexity: Linear inN if the range[first,last) is already sorted with respect tocomp and otherwise
Nlog N, whereN is last - first.
template<container-compatible-range <value_type> R>
constexpr map(from_range_t, R&& rg, const Compare& comp = Compare(),
const Allocator& = Allocator());
5 Effects: Constructs an emptymap using the specified comparison object and allocator, and inserts
elements from the rangerg.
6 Complexity: Linear inN if rg is already sorted with respect tocomp and otherwiseNlog N, whereN
is ranges::distance(rg).
23.4.3.3 Element access [map.access]
constexpr mapped_type& operator[](const key_type& x);
1 Effects: Equivalent to:return try_emplace(x).first->second;
constexpr mapped_type& operator[](key_type&& x);
2 Effects: Equivalent to:return try_emplace(std::move(x)).first->second;
template<class K> constexpr mapped_type& operator[](K&& x);
3 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type.
4 Effects: Equivalent to:return try_emplace(std::forward<K>(x)).first->second;
constexpr mapped_type& at(const key_type& x);
constexpr const mapped_type& at(const key_type& x) const;
5 Returns: A reference to themapped_type corresponding tox in *this.
§ 23.4.3.3 © ISO/IEC
1025

===== PAGE 1037 =====

Dxxxx
6 Throws: An exception object of typeout_of_range if no such element is present.
7 Complexity: Logarithmic.
template<class K> constexpr mapped_type& at(const K& x);
template<class K> constexpr const mapped_type& at(const K& x) const;
8 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type.
9 Preconditions: The expressionfind(x) is well-formed and has well-defined behavior.
10 Returns: A reference tofind(x)->second.
11 Throws: An exception object of typeout_of_range if find(x) == end() is true.
12 Complexity: Logarithmic.
23.4.3.4 Modifiers [map.modifiers]
template<class P>
constexpr pair<iterator, bool> insert(P&& x);
template<class P>
constexpr iterator insert(const_iterator position, P&& x);
1 Constraints: is_constructible_v<value_type, P&&> is true.
2 Effects: The first form is equivalent toreturn emplace(std::forward<P>(x)). The second form is
equivalent toreturn emplace_hint(position, std::forward<P>(x)).
template<class... Args>
constexpr pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
3 Preconditions: value_type is Cpp17EmplaceConstructible into map from piecewise_construct, for-
ward_as_tuple(k), forward_as_tuple(std::forward<Args>(args)...).
4 Effects: If the map already contains an element whose key is equivalent tok, there is no effect. Otherwise
inserts an object of typevalue_type constructed withpiecewise_construct, forward_as_tuple(k),
forward_as_tuple(std::forward<Args>(args)...).
5 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
6 Complexity: The same asemplace and emplace_hint, respectively.
template<class... Args>
constexpr pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
7 Preconditions: value_type is Cpp17EmplaceConstructible into map from piecewise_construct, for-
ward_as_tuple(std::move(k)), forward_as_tuple(std::forward<Args>(args)...).
8 Effects: If the map already contains an element whose key is equivalent tok, there is no effect.
Otherwise inserts an object of typevalue_type constructed withpiecewise_construct, forward_-
as_tuple(std::move(k)), forward_as_tuple(std::forward<Args>(args)...).
9 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
10 Complexity: The same asemplace and emplace_hint, respectively.
template<class K, class... Args>
constexpr pair<iterator, bool> try_emplace(K&& k, Args&&... args);
template<class K, class... Args>
constexpr iterator try_emplace(const_iterator hint, K&& k, Args&&... args);
11 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type. For the first
overload, is_convertible_v<K&&, const_iterator> and is_convertible_v<K&&, iterator> are
both false.
§ 23.4.3.4 © ISO/IEC
1026

===== PAGE 1038 =====

Dxxxx
12 Preconditions: value_type is Cpp17EmplaceConstructible into map from piecewise_construct,
forward_as_tuple(std::forward<K>(k)), forward_as_tuple(std::forward<Args>(args)...).
13 Effects: If the map already contains an element whose key is equivalent tok, there is no effect. Other-
wise, letrbe equal_range(k). Constructs an objectuof typevalue_typewithpiecewise_construct,
forward_as_tuple(std::forward<K>(k)), forward_as_tuple(std::forward<Args>(args)...).
If equal_range(u.first) == r is false, the behavior is undefined. Insertsu into *this.
14 Returns: For the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
15 Complexity: The same asemplace and emplace_hint, respectively.
template<class M>
constexpr pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
16 Mandates: is_assignable_v<mapped_type&, M&&> is true.
17 Preconditions: value_type is Cpp17EmplaceConstructible into map from k, std::forward<M>(obj).
18 Effects: If the map already contains an elemente whose key is equivalent tok, assigns std::for-
ward<M>(obj) to e.second. Otherwise inserts an object of type value_type constructed with k,
std::forward<M>(obj).
19 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
20 Complexity: The same asemplace and emplace_hint, respectively.
template<class M>
constexpr pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
21 Mandates: is_assignable_v<mapped_type&, M&&> is true.
22 Preconditions: value_type is Cpp17EmplaceConstructible into map from std::move(k), std::for-
ward<M>(obj).
23 Effects: If the map already contains an elemente whose key is equivalent tok, assigns std::for-
ward<M>(obj) to e.second. Otherwise inserts an object of typevalue_type constructed withstd::
move(k), std::forward<M>(obj).
24 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
25 Complexity: The same asemplace and emplace_hint, respectively.
template<class K, class M>
constexpr pair<iterator, bool> insert_or_assign(K&& k, M&& obj);
template<class K, class M>
constexpr iterator insert_or_assign(const_iterator hint, K&& k, M&& obj);
26 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type.
27 Mandates: is_assignable_v<mapped_type&, M&&> is true.
28 Preconditions: value_type is Cpp17EmplaceConstructible into map from std::forward<K>(k), std::
forward<M>(obj).
29 Effects: If the map already contains an elemente whose key is equivalent tok, assignsstd::forward<M>
(obj) to e.second. Otherwise, letr be equal_range(k). Constructs an objectu of typevalue_type
with std::forward<K>(k), std::forward<M>(obj). If equal_range(u.first) == r is false, the
behavior is undefined. Insertsu into *this.
30 Returns: For the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
31 Complexity: The same asemplace and emplace_hint, respectively.
§ 23.4.3.4 © ISO/IEC
1027

===== PAGE 1039 =====

Dxxxx
23.4.3.5 Erasure [map.erasure]
template<class Key, class T, class Compare, class Allocator, class Predicate>
typename map<Key, T, Compare, Allocator>::size_type
constexpr erase_if(map<Key, T, Compare, Allocator>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
23.4.4 Class template multimap [multimap]
23.4.4.1 Overview [multimap.overview]
1 A multimap is an associative container that supports equivalent keys (i.e., possibly containing multiple copies
of the same key value) and provides for fast retrieval of values of another typeT based on the keys. The
multimap class supports bidirectional iterators.
2 A multimap meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), and of an associative container (23.2.7). Amultimap also provides most
operations described in 23.2.7 for equal keys. This means that amultimap supports thea_eq operations
in 23.2.7 but not thea_uniq operations. For amultimap<Key,T> the key_type is Key and thevalue_type is
pair<const Key,T>. Descriptions are provided here only for operations onmultimap that are not described
in one of those tables or for operations where there is additional semantic information.
3 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
namespace std {
template<class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T>>>
class multimap {
public:
// types
using key_type = Key;
using mapped_type = T;
using value_type = pair<const Key, T>;
using key_compare = Compare;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using node_type = unspecified ;
class value_compare {
protected:
Compare comp;
constexpr value_compare(Compare c) : comp(c) { }
public:
constexpr bool operator()(const value_type& x, const value_type& y) const {
return comp(x.first, y.first);
}
};
§ 23.4.4.1 © ISO/IEC
1028

===== PAGE 1040 =====

Dxxxx
// 23.4.4.2, construct/copy/destroy
constexpr multimap() : multimap(Compare()) { }
constexpr explicit multimap(const Compare& comp, const Allocator& = Allocator());
template<class InputIterator>
constexpr multimap(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
template<container-compatible-range <value_type> R>
constexpr multimap(from_range_t, R&& rg,
const Compare& comp = Compare(), const Allocator& = Allocator());
constexpr multimap(const multimap& x);
constexpr multimap(multimap&& x);
constexpr explicit multimap(const Allocator&);
constexpr multimap(const multimap&, const type_identity_t<Allocator>&);
constexpr multimap(multimap&&, const type_identity_t<Allocator>&);
constexpr multimap(initializer_list<value_type>,
const Compare& = Compare(), const Allocator& = Allocator());
template<class InputIterator>
constexpr multimap(InputIterator first, InputIterator last, const Allocator& a)
: multimap(first, last, Compare(), a) { }
template<container-compatible-range <value_type> R>
constexpr multimap(from_range_t, R&& rg, const Allocator& a)
: multimap(from_range, std::forward<R>(rg), Compare(), a) { }
constexpr multimap(initializer_list<value_type> il, const Allocator& a)
: multimap(il, Compare(), a) { }
constexpr ~multimap();
constexpr multimap& operator=(const multimap& x);
constexpr multimap& operator=(multimap&& x)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Compare>);
constexpr multimap& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.4.4.3, modifiers
template<class... Args> constexpr iterator emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr iterator insert(const value_type& x);
constexpr iterator insert(value_type&& x);
template<class P> constexpr iterator insert(P&& x);
constexpr iterator insert(const_iterator position, const value_type& x);
constexpr iterator insert(const_iterator position, value_type&& x);
template<class P> constexpr iterator insert(const_iterator position, P&& x);
§ 23.4.4.1 © ISO/IEC
1029

===== PAGE 1041 =====

Dxxxx
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> node_type extract(K&& x);
constexpr iterator insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
constexpr iterator erase(iterator position);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(multimap&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Compare>);
constexpr void clear() noexcept;
template<class C2>
constexpr void merge(multimap<Key, T, C2, Allocator>& source);
template<class C2>
constexpr void merge(multimap<Key, T, C2, Allocator>&& source);
template<class C2>
constexpr void merge(map<Key, T, C2, Allocator>& source);
template<class C2>
constexpr void merge(map<Key, T, C2, Allocator>&& source);
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
// map operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
};
§ 23.4.4.1 © ISO/IEC
1030

===== PAGE 1042 =====

Dxxxx
template<class InputIterator, class Compare = less<iter-key-type <InputIterator>>,
class Allocator = allocator<iter-to-alloc-type <InputIterator>>>
multimap(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
-> multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
Compare, Allocator>;
template<ranges::input_range R, class Compare = less<range-key-type <R>>,
class Allocator = allocator<range-to-alloc-type <R>>>
multimap(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> multimap<range-key-type <R>, range-mapped-type <R>, Compare, Allocator>;
template<class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T>>>
multimap(initializer_list<pair<Key, T>>, Compare = Compare(), Allocator = Allocator())
-> multimap<Key, T, Compare, Allocator>;
template<class InputIterator, class Allocator>
multimap(InputIterator, InputIterator, Allocator)
-> multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
less<iter-key-type <InputIterator>>, Allocator>;
template<ranges::input_range R, class Allocator>
multimap(from_range_t, R&&, Allocator)
-> multimap<range-key-type <R>, range-mapped-type <R>, less<range-key-type <R>>, Allocator>;
template<class Key, class T, class Allocator>
multimap(initializer_list<pair<Key, T>>, Allocator)
-> multimap<Key, T, less<Key>, Allocator>;
}
23.4.4.2 Constructors [multimap.cons]
constexpr explicit multimap(const Compare& comp, const Allocator& = Allocator());
1 Effects: Constructs an emptymultimap using the specified comparison object and allocator.
2 Complexity: Constant.
template<class InputIterator>
constexpr multimap(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
3 Effects: Constructs an emptymultimap using the specified comparison object and allocator, and inserts
elements from the range[first,last).
4 Complexity: Linear inN if the range[first,last) is already sorted with respect tocomp and otherwise
Nlog N, whereN is last - first.
template<container-compatible-range <value_type> R>
constexpr multimap(from_range_t, R&& rg,
const Compare& comp = Compare(), const Allocator& = Allocator());
5 Effects: Constructs an emptymultimap using the specified comparison object and allocator, and inserts
elements from the rangerg.
6 Complexity: Linear inN if rg is already sorted with respect tocomp and otherwiseNlog N, whereN
is ranges::distance(rg).
23.4.4.3 Modifiers [multimap.modifiers]
template<class P> constexpr iterator insert(P&& x);
template<class P> constexpr iterator insert(const_iterator position, P&& x);
1 Constraints: is_constructible_v<value_type, P&&> is true.
2 Effects: The first form is equivalent toreturn emplace(std::forward<P>(x)). The second form is
equivalent toreturn emplace_hint(position, std::forward<P>(x)).
§ 23.4.4.3 © ISO/IEC
1031

===== PAGE 1043 =====

Dxxxx
23.4.4.4 Erasure [multimap.erasure]
template<class Key, class T, class Compare, class Allocator, class Predicate>
typename multimap<Key, T, Compare, Allocator>::size_type
constexpr erase_if(multimap<Key, T, Compare, Allocator>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
23.4.5 Header <set> synopsis [associative.set.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.4.6, class templateset
template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
class set;
template<class Key, class Compare, class Allocator>
constexpr bool operator==(const set<Key, Compare, Allocator>& x,
const set<Key, Compare, Allocator>& y);
template<class Key, class Compare, class Allocator>
constexpr synth-three-way-result <Key>
operator<=>(const set<Key, Compare, Allocator>& x,
const set<Key, Compare, Allocator>& y);
template<class Key, class Compare, class Allocator>
constexpr void swap(set<Key, Compare, Allocator>& x,
set<Key, Compare, Allocator>& y)
noexcept(noexcept(x.swap(y)));
// 23.4.6.3, erasure forset
template<class Key, class Compare, class Allocator, class Predicate>
constexpr typename set<Key, Compare, Allocator>::size_type
erase_if(set<Key, Compare, Allocator>& c, Predicate pred);
// 23.4.7, class templatemultiset
template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
class multiset;
template<class Key, class Compare, class Allocator>
constexpr bool operator==(const multiset<Key, Compare, Allocator>& x,
const multiset<Key, Compare, Allocator>& y);
template<class Key, class Compare, class Allocator>
constexpr synth-three-way-result <Key>
operator<=>(const multiset<Key, Compare, Allocator>& x,
const multiset<Key, Compare, Allocator>& y);
template<class Key, class Compare, class Allocator>
constexpr void swap(multiset<Key, Compare, Allocator>& x,
multiset<Key, Compare, Allocator>& y)
noexcept(noexcept(x.swap(y)));
§ 23.4.5 © ISO/IEC
1032

===== PAGE 1044 =====

Dxxxx
// 23.4.7.3, erasure formultiset
template<class Key, class Compare, class Allocator, class Predicate>
constexpr typename multiset<Key, Compare, Allocator>::size_type
erase_if(multiset<Key, Compare, Allocator>& c, Predicate pred);
namespace pmr {
template<class Key, class Compare = less<Key>>
using set = std::set<Key, Compare, polymorphic_allocator<Key>>;
template<class Key, class Compare = less<Key>>
using multiset = std::multiset<Key, Compare, polymorphic_allocator<Key>>;
}
}
23.4.6 Class template set [set]
23.4.6.1 Overview [set.overview]
1 A set is an associative container that supports unique keys (i.e., contains at most one of each key value) and
provides for fast retrieval of the keys themselves. Theset class supports bidirectional iterators.
2 A set meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), and of an associative container (23.2.7). Aset also provides most
operations described in 23.2.7 for unique keys. This means that asetsupports thea_uniqoperations in 23.2.7
but not thea_eq operations. For aset<Key> both thekey_type and value_type are Key. Descriptions are
provided here only for operations onset that are not described in one of these tables and for operations
where there is additional semantic information.
3 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
namespace std {
template<class Key, class Compare = less<Key>,
class Allocator = allocator<Key>>
class set {
public:
// types
using key_type = Key;
using key_compare = Compare;
using value_type = Key;
using value_compare = Compare;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using node_type = unspecified ;
using insert_return_type = insert-return-type<iterator, node_type>;
// 23.4.6.2, construct/copy/destroy
constexpr set() : set(Compare()) { }
constexpr explicit set(const Compare& comp, const Allocator& = Allocator());
template<class InputIterator>
constexpr set(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
template<container-compatible-range <value_type> R>
constexpr set(from_range_t, R&& rg,
const Compare& comp = Compare(), const Allocator& = Allocator());
constexpr set(const set& x);
constexpr set(set&& x);
constexpr explicit set(const Allocator&);
§ 23.4.6.1 © ISO/IEC
1033

===== PAGE 1045 =====

Dxxxx
constexpr set(const set&, const type_identity_t<Allocator>&);
constexpr set(set&&, const type_identity_t<Allocator>&);
constexpr set(initializer_list<value_type>,
const Compare& = Compare(), const Allocator& = Allocator());
template<class InputIterator>
constexpr set(InputIterator first, InputIterator last, const Allocator& a)
: set(first, last, Compare(), a) { }
template<container-compatible-range <value_type> R>
constexpr set(from_range_t, R&& rg, const Allocator& a)
: set(from_range, std::forward<R>(rg), Compare(), a) { }
constexpr set(initializer_list<value_type> il, const Allocator& a)
: set(il, Compare(), a) { }
constexpr ~set();
constexpr set& operator=(const set& x);
constexpr set& operator=(set&& x)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Compare>);
constexpr set& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.4.6.4, modifiers
template<class... Args> constexpr pair<iterator, bool> emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr pair<iterator,bool> insert(const value_type& x);
constexpr pair<iterator,bool> insert(value_type&& x);
template<class K> constexpr pair<iterator, bool> insert(K&& x);
constexpr iterator insert(const_iterator position, const value_type& x);
constexpr iterator insert(const_iterator position, value_type&& x);
template<class K> constexpr iterator insert(const_iterator position, K&& x);
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> constexpr node_type extract(K&& x);
constexpr insert_return_type insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
§ 23.4.6.1 © ISO/IEC
1034

===== PAGE 1046 =====

Dxxxx
constexpr iterator erase(iterator position)
requires (!same_as<iterator, const_iterator>);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(set&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Compare>);
constexpr void clear() noexcept;
template<class C2>
constexpr void merge(set<Key, C2, Allocator>& source);
template<class C2>
constexpr void merge(set<Key, C2, Allocator>&& source);
template<class C2>
constexpr void merge(multiset<Key, C2, Allocator>& source);
template<class C2>
constexpr void merge(multiset<Key, C2, Allocator>&& source);
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
// set operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
};
template<class InputIterator,
class Compare = less<iter-value-type <InputIterator>>,
class Allocator = allocator<iter-value-type <InputIterator>>>
set(InputIterator, InputIterator,
Compare = Compare(), Allocator = Allocator())
-> set<iter-value-type <InputIterator>, Compare, Allocator>;
§ 23.4.6.1 © ISO/IEC
1035

===== PAGE 1047 =====

Dxxxx
template<ranges::input_range R, class Compare = less<ranges::range_value_t<R>>,
class Allocator = allocator<ranges::range_value_t<R>>>
set(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> set<ranges::range_value_t<R>, Compare, Allocator>;
template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
set(initializer_list<Key>, Compare = Compare(), Allocator = Allocator())
-> set<Key, Compare, Allocator>;
template<class InputIterator, class Allocator>
set(InputIterator, InputIterator, Allocator)
-> set<iter-value-type <InputIterator>,
less<iter-value-type <InputIterator>>, Allocator>;
template<ranges::input_range R, class Allocator>
set(from_range_t, R&&, Allocator)
-> set<ranges::range_value_t<R>, less<ranges::range_value_t<R>>, Allocator>;
template<class Key, class Allocator>
set(initializer_list<Key>, Allocator) -> set<Key, less<Key>, Allocator>;
}
23.4.6.2 Constructors, copy, and assignment [set.cons]
constexpr explicit set(const Compare& comp, const Allocator& = Allocator());
1 Effects: Constructs an emptyset using the specified comparison object and allocator.
2 Complexity: Constant.
template<class InputIterator>
constexpr set(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
3 Effects: Constructs an emptyset using the specified comparison object and allocator, and inserts
elements from the range[first,last).
4 Complexity: Linear inN if the range[first,last) is already sorted with respect tocomp and otherwise
Nlog N, whereN is last - first.
template<container-compatible-range <value_type> R>
constexpr set(from_range_t, R&& rg, const Compare& comp = Compare(),
const Allocator& = Allocator());
5 Effects: Constructs an emptyset using the specified comparison object and allocator, and inserts
elements from the rangerg.
6 Complexity: Linear inN if rg is already sorted with respect tocomp and otherwiseNlog N, whereN
is ranges::distance(rg).
23.4.6.3 Erasure [set.erasure]
template<class Key, class Compare, class Allocator, class Predicate>
constexpr typename set<Key, Compare, Allocator>::size_type
erase_if(set<Key, Compare, Allocator>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
§ 23.4.6.3 © ISO/IEC
1036

===== PAGE 1048 =====

Dxxxx
23.4.6.4 Modifiers [set.modifiers]
template<class K> constexpr pair<iterator, bool> insert(K&& x);
template<class K> constexpr iterator insert(const_iterator hint, K&& x);
1 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type. For the second
overload, is_convertible_v<K&&, const_iterator> and is_convertible_v<K&&, iterator> are
both false.
2 Preconditions: value_type is Cpp17EmplaceConstructible into set from std::forward<K>(x).
3 Effects: If the set already contains an element that is equivalent tox, there is no effect. Otherwise,
let r be equal_range(x). Constructs an objectu of typevalue_type with std::forward<K>(x). If
equal_range(u) == r is false, the behavior is undefined. Insertsu into *this.
4 Returns: For the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the set element that is equivalent tox.
5 Complexity: Logarithmic.
23.4.7 Class template multiset [multiset]
23.4.7.1 Overview [multiset.overview]
1 A multiset is an associative container that supports equivalent keys (i.e., possibly contains multiple copies
of the same key value) and provides for fast retrieval of the keys themselves. Themultiset class supports
bidirectional iterators.
2 A multiset meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), and of an associative container (23.2.7).multiset also provides most
operations described in 23.2.7 for duplicate keys. This means that amultiset supports thea_eq operations
in 23.2.7 but not thea_uniq operations. For amultiset<Key> both thekey_type and value_type are Key.
Descriptions are provided here only for operations onmultiset that are not described in one of these tables
and for operations where there is additional semantic information.
3 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
namespace std {
template<class Key, class Compare = less<Key>,
class Allocator = allocator<Key>>
class multiset {
public:
// types
using key_type = Key;
using key_compare = Compare;
using value_type = Key;
using value_compare = Compare;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using node_type = unspecified ;
// 23.4.7.2, construct/copy/destroy
constexpr multiset() : multiset(Compare()) { }
constexpr explicit multiset(const Compare& comp, const Allocator& = Allocator());
template<class InputIterator>
constexpr multiset(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
template<container-compatible-range <value_type> R>
constexpr multiset(from_range_t, R&& rg,
const Compare& comp = Compare(), const Allocator& = Allocator());
§ 23.4.7.1 © ISO/IEC
1037

===== PAGE 1049 =====

Dxxxx
constexpr multiset(const multiset& x);
constexpr multiset(multiset&& x);
constexpr explicit multiset(const Allocator&);
constexpr multiset(const multiset&, const type_identity_t<Allocator>&);
constexpr multiset(multiset&&, const type_identity_t<Allocator>&);
constexpr multiset(initializer_list<value_type>, const Compare& = Compare(),
const Allocator& = Allocator());
template<class InputIterator>
constexpr multiset(InputIterator first, InputIterator last, const Allocator& a)
: multiset(first, last, Compare(), a) { }
template<container-compatible-range <value_type> R>
constexpr multiset(from_range_t, R&& rg, const Allocator& a)
: multiset(from_range, std::forward<R>(rg), Compare(), a) { }
constexpr multiset(initializer_list<value_type> il, const Allocator& a)
: multiset(il, Compare(), a) { }
constexpr ~multiset();
constexpr multiset& operator=(const multiset& x);
constexpr multiset& operator=(multiset&& x)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Compare>);
constexpr multiset& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// modifiers
template<class... Args> constexpr iterator emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr iterator insert(const value_type& x);
constexpr iterator insert(value_type&& x);
constexpr iterator insert(const_iterator position, const value_type& x);
constexpr iterator insert(const_iterator position, value_type&& x);
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> constexpr node_type extract(K&& x);
constexpr iterator insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
§ 23.4.7.1 © ISO/IEC
1038

===== PAGE 1050 =====

Dxxxx
constexpr iterator erase(iterator position)
requires (!same_as<iterator, const_iterator>);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(multiset&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Compare>);
constexpr void clear() noexcept;
template<class C2>
constexpr void merge(multiset<Key, C2, Allocator>& source);
template<class C2>
constexpr void merge(multiset<Key, C2, Allocator>&& source);
template<class C2>
constexpr void merge(set<Key, C2, Allocator>& source);
template<class C2>
constexpr void merge(set<Key, C2, Allocator>&& source);
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
// set operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
};
template<class InputIterator,
class Compare = less<iter-value-type <InputIterator>>,
class Allocator = allocator<iter-value-type <InputIterator>>>
multiset(InputIterator, InputIterator,
Compare = Compare(), Allocator = Allocator())
-> multiset<iter-value-type <InputIterator>, Compare, Allocator>;
§ 23.4.7.1 © ISO/IEC
1039

===== PAGE 1051 =====

Dxxxx
template<ranges::input_range R, class Compare = less<ranges::range_value_t<R>>,
class Allocator = allocator<ranges::range_value_t<R>>>
multiset(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> multiset<ranges::range_value_t<R>, Compare, Allocator>;
template<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>
multiset(initializer_list<Key>, Compare = Compare(), Allocator = Allocator())
-> multiset<Key, Compare, Allocator>;
template<class InputIterator, class Allocator>
multiset(InputIterator, InputIterator, Allocator)
-> multiset<iter-value-type <InputIterator>,
less<iter-value-type <InputIterator>>, Allocator>;
template<ranges::input_range R, class Allocator>
multiset(from_range_t, R&&, Allocator)
-> multiset<ranges::range_value_t<R>, less<ranges::range_value_t<R>>, Allocator>;
template<class Key, class Allocator>
multiset(initializer_list<Key>, Allocator) -> multiset<Key, less<Key>, Allocator>;
}
23.4.7.2 Constructors [multiset.cons]
constexpr explicit multiset(const Compare& comp, const Allocator& = Allocator());
1 Effects: Constructs an emptymultiset using the specified comparison object and allocator.
2 Complexity: Constant.
template<class InputIterator>
constexpr multiset(InputIterator first, InputIterator last,
const Compare& comp = Compare(), const Allocator& = Allocator());
3 Effects: Constructs an emptymultiset using the specified comparison object and allocator, and inserts
elements from the range[first,last).
4 Complexity: Linear inN if the range[first,last) is already sorted with respect tocomp and otherwise
Nlog N, whereN is last - first.
template<container-compatible-range <value_type> R>
constexpr multiset(from_range_t, R&& rg, const Compare& comp = Compare(),
const Allocator& = Allocator());
5 Effects: Constructs an emptymultiset using the specified comparison object and allocator, and inserts
elements from the rangerg.
6 Complexity: Linear inN if rg is already sorted with respect tocomp and otherwiseNlog N, whereN
is ranges::distance(rg).
23.4.7.3 Erasure [multiset.erasure]
template<class Key, class Compare, class Allocator, class Predicate>
constexpr typename multiset<Key, Compare, Allocator>::size_type
erase_if(multiset<Key, Compare, Allocator>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
§ 23.4.7.3 © ISO/IEC
1040

===== PAGE 1052 =====

Dxxxx
23.5 Unordered associative containers [unord]
23.5.1 General [unord.general]
1 The header<unordered_map> (23.5.2) defines the class templatesunordered_map and unordered_multimap;
the header<unordered_set> (23.5.5) defines the class templatesunordered_set and unordered_multiset.
2 The exposition-only alias templates iter-value-type , iter-key-type , iter-mapped-type , iter-to-
-alloc-type , range-key-type , range-mapped-type , and range-to-alloc-type defined in 23.4.1 may
appear in deduction guides for unordered containers.
23.5.2 Header <unordered_map> synopsis [unord.map.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.5.3, class templateunordered_map
template<class Key,
class T,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Alloc = allocator<pair<const Key, T>>>
class unordered_map;
// 23.5.4, class templateunordered_multimap
template<class Key,
class T,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Alloc = allocator<pair<const Key, T>>>
class unordered_multimap;
template<class Key, class T, class Hash, class Pred, class Alloc>
constexpr bool operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
const unordered_map<Key, T, Hash, Pred, Alloc>& b);
template<class Key, class T, class Hash, class Pred, class Alloc>
constexpr bool operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);
template<class Key, class T, class Hash, class Pred, class Alloc>
constexpr void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
unordered_map<Key, T, Hash, Pred, Alloc>& y)
noexcept(noexcept(x.swap(y)));
template<class Key, class T, class Hash, class Pred, class Alloc>
constexpr void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
noexcept(noexcept(x.swap(y)));
// 23.5.3.5, erasure forunordered_map
template<class K, class T, class H, class P, class A, class Predicate>
constexpr typename unordered_map<K, T, H, P, A>::size_type
erase_if(unordered_map<K, T, H, P, A>& c, Predicate pred);
// 23.5.4.4, erasure forunordered_multimap
template<class K, class T, class H, class P, class A, class Predicate>
constexpr typename unordered_multimap<K, T, H, P, A>::size_type
erase_if(unordered_multimap<K, T, H, P, A>& c, Predicate pred);
namespace pmr {
template<class Key,
class T,
class Hash = hash<Key>,
class Pred = equal_to<Key>>
§ 23.5.2 © ISO/IEC
1041

===== PAGE 1053 =====

Dxxxx
using unordered_map =
std::unordered_map<Key, T, Hash, Pred,
polymorphic_allocator<pair<const Key, T>>>;
template<class Key,
class T,
class Hash = hash<Key>,
class Pred = equal_to<Key>>
using unordered_multimap =
std::unordered_multimap<Key, T, Hash, Pred,
polymorphic_allocator<pair<const Key, T>>>;
}
}
23.5.3 Class template unordered_map [unord.map]
23.5.3.1 Overview [unord.map.overview]
1 An unordered_map is an unordered associative container that supports unique keys (anunordered_map
contains at most one of each key value) and that associates values of another typemapped_type with the
keys. Theunordered_map class supports forward iterators.
2 An unordered_map meets all of the requirements of a container (23.2.2.2), of an allocator-aware container
(23.2.2.5), and of an unordered associative container (23.2.8). It provides the operations described in the
preceding requirements table for unique keys; that is, anunordered_map supports thea_uniq operations in
that table, not thea_eq operations. For anunordered_map<Key, T> the key_type is Key, themapped_type
is T, and thevalue_type is pair<const Key, T>.
3 Subclause 23.5.3 only describes operations onunordered_map that are not described in one of the requirement
tables, or for which there is additional semantic information.
4 The typesiterator, const_iterator, local_iterator, andconst_local_iterator meet the constexpr
iterator requirements (24.3.1).
namespace std {
template<class Key,
class T,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Allocator = allocator<pair<const Key, T>>>
class unordered_map {
public:
// types
using key_type = Key;
using mapped_type = T;
using value_type = pair<const Key, T>;
using hasher = Hash;
using key_equal = Pred;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using local_iterator = implementation-defined ; // see 23.2
using const_local_iterator = implementation-defined ; // see 23.2
using node_type = unspecified ;
using insert_return_type = insert-return-type<iterator, node_type>;
// 23.5.3.2, construct/copy/destroy
constexpr unordered_map();
§ 23.5.3.1 © ISO/IEC
1042

===== PAGE 1054 =====

Dxxxx
constexpr explicit unordered_map(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<class InputIterator>
constexpr unordered_map(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_map(from_range_t, R&& rg, size_type n = see below ,
const hasher& hf = hasher(), const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_map(const unordered_map&);
constexpr unordered_map(unordered_map&&);
constexpr explicit unordered_map(const Allocator&);
constexpr unordered_map(const unordered_map&, const type_identity_t<Allocator>&);
constexpr unordered_map(unordered_map&&, const type_identity_t<Allocator>&);
constexpr unordered_map(initializer_list<value_type> il, size_type n = see below ,
const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_map(size_type n, const allocator_type& a)
: unordered_map(n, hasher(), key_equal(), a) { }
constexpr unordered_map(size_type n, const hasher& hf, const allocator_type& a)
: unordered_map(n, hf, key_equal(), a) { }
template<class InputIterator>
constexpr unordered_map(InputIterator f, InputIterator l, size_type n,
const allocator_type& a)
: unordered_map(f, l, n, hasher(), key_equal(), a) { }
template<class InputIterator>
constexpr unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_map(f, l, n, hf, key_equal(), a) { }
template<container-compatible-range <value_type> R>
constexpr unordered_map(from_range_t, R&& rg, size_type n, const allocator_type& a)
: unordered_map(from_range, std::forward<R>(rg), n, hasher(), key_equal(), a) { }
template<container-compatible-range <value_type> R>
constexpr unordered_map(from_range_t, R&& rg, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_map(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }
constexpr unordered_map(initializer_list<value_type> il, size_type n,
const allocator_type& a)
: unordered_map(il, n, hasher(), key_equal(), a) { }
constexpr unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_map(il, n, hf, key_equal(), a) { }
constexpr ~unordered_map();
constexpr unordered_map& operator=(const unordered_map&);
constexpr unordered_map& operator=(unordered_map&&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Hash> &&
is_nothrow_move_assignable_v<Pred>);
constexpr unordered_map& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
§ 23.5.3.1 © ISO/IEC
1043

===== PAGE 1055 =====

Dxxxx
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.5.3.4, modifiers
template<class... Args> constexpr pair<iterator, bool> emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr pair<iterator, bool> insert(const value_type& obj);
constexpr pair<iterator, bool> insert(value_type&& obj);
template<class P> constexpr pair<iterator, bool> insert(P&& obj);
constexpr iterator insert(const_iterator hint, const value_type& obj);
constexpr iterator insert(const_iterator hint, value_type&& obj);
template<class P> constexpr iterator insert(const_iterator hint, P&& obj);
template<class InputIterator> constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> constexpr node_type extract(K&& x);
constexpr insert_return_type insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
template<class... Args>
constexpr pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
constexpr pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class K, class... Args>
constexpr pair<iterator, bool> try_emplace(K&& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
template<class K, class... Args>
constexpr iterator try_emplace(const_iterator hint, K&& k, Args&&... args);
template<class M>
constexpr pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
constexpr pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class K, class M>
constexpr pair<iterator, bool> insert_or_assign(K&& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
template<class K, class M>
constexpr iterator insert_or_assign(const_iterator hint, K&& k, M&& obj);
constexpr iterator erase(iterator position);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& k);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(unordered_map&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Hash> && is_nothrow_swappable_v<Pred>);
constexpr void clear() noexcept;
template<class H2, class P2>
constexpr void merge(unordered_map<Key, T, H2, P2, Allocator>& source);
§ 23.5.3.1 © ISO/IEC
1044

===== PAGE 1056 =====

Dxxxx
template<class H2, class P2>
constexpr void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);
template<class H2, class P2>
constexpr void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);
template<class H2, class P2>
constexpr void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);
// observers
constexpr hasher hash_function() const;
constexpr key_equal key_eq() const;
// map operations
constexpr iterator find(const key_type& k);
constexpr const_iterator find(const key_type& k) const;
template<class K>
constexpr iterator find(const K& k);
template<class K>
constexpr const_iterator find(const K& k) const;
constexpr size_type count(const key_type& k) const;
template<class K>
constexpr size_type count(const K& k) const;
constexpr bool contains(const key_type& k) const;
template<class K>
constexpr bool contains(const K& k) const;
constexpr pair<iterator, iterator> equal_range(const key_type& k);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& k);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& k) const;
// 23.5.3.3, element access
constexpr mapped_type& operator[](const key_type& k);
constexpr mapped_type& operator[](key_type&& k);
template<class K> constexpr mapped_type& operator[](K&& k);
constexpr mapped_type& at(const key_type& k);
constexpr const mapped_type& at(const key_type& k) const;
template<class K> constexpr mapped_type& at(const K& k);
template<class K> constexpr const mapped_type& at(const K& k) const;
// bucket interface
constexpr size_type bucket_count() const noexcept;
constexpr size_type max_bucket_count() const noexcept;
constexpr size_type bucket_size(size_type n) const;
constexpr size_type bucket(const key_type& k) const;
template<class K> constexpr size_type bucket(const K& k) const;
constexpr local_iterator begin(size_type n);
constexpr const_local_iterator begin(size_type n) const;
constexpr local_iterator end(size_type n);
constexpr const_local_iterator end(size_type n) const;
constexpr const_local_iterator cbegin(size_type n) const;
constexpr const_local_iterator cend(size_type n) const;
// hash policy
constexpr float load_factor() const noexcept;
constexpr float max_load_factor() const noexcept;
constexpr void max_load_factor(float z);
constexpr void rehash(size_type n);
constexpr void reserve(size_type n);
};
§ 23.5.3.1 © ISO/IEC
1045

===== PAGE 1057 =====

Dxxxx
template<class InputIterator,
class Hash = hash<iter-key-type <InputIterator>>,
class Pred = equal_to<iter-key-type <InputIterator>>,
class Allocator = allocator<iter-to-alloc-type <InputIterator>>>
unordered_map(InputIterator, InputIterator, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Hash, Pred,
Allocator>;
template<ranges::input_range R, class Hash = hash<range-key-type <R>>,
class Pred = equal_to<range-key-type <R>>,
class Allocator = allocator<range-to-alloc-type <R>>>
unordered_map(from_range_t, R&&, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_map<range-key-type <R>, range-mapped-type <R>, Hash, Pred, Allocator>;
template<class Key, class T, class Hash = hash<Key>,
class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
unordered_map(initializer_list<pair<Key, T>>,
typename see below ::size_type = see below , Hash = Hash(),
Pred = Pred(), Allocator = Allocator())
-> unordered_map<Key, T, Hash, Pred, Allocator>;
template<class InputIterator, class Allocator>
unordered_map(InputIterator, InputIterator, typename see below ::size_type, Allocator)
-> unordered_map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
hash<iter-key-type <InputIterator>>,
equal_to<iter-key-type <InputIterator>>, Allocator>;
template<class InputIterator, class Allocator>
unordered_map(InputIterator, InputIterator, Allocator)
-> unordered_map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
hash<iter-key-type <InputIterator>>,
equal_to<iter-key-type <InputIterator>>, Allocator>;
template<class InputIterator, class Hash, class Allocator>
unordered_map(InputIterator, InputIterator, typename see below ::size_type, Hash, Allocator)
-> unordered_map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Hash,
equal_to<iter-key-type <InputIterator>>, Allocator>;
template<ranges::input_range R, class Allocator>
unordered_map(from_range_t, R&&, typename see below ::size_type, Allocator)
-> unordered_map<range-key-type <R>, range-mapped-type <R>, hash<range-key-type <R>>,
equal_to<range-key-type <R>>, Allocator>;
template<ranges::input_range R, class Allocator>
unordered_map(from_range_t, R&&, Allocator)
-> unordered_map<range-key-type <R>, range-mapped-type <R>, hash<range-key-type <R>>,
equal_to<range-key-type <R>>, Allocator>;
template<ranges::input_range R, class Hash, class Allocator>
unordered_map(from_range_t, R&&, typename see below ::size_type, Hash, Allocator)
-> unordered_map<range-key-type <R>, range-mapped-type <R>, Hash,
equal_to<range-key-type <R>>, Allocator>;
template<class Key, class T, class Allocator>
unordered_map(initializer_list<pair<Key, T>>, typename see below ::size_type,
Allocator)
-> unordered_map<Key, T, hash<Key>, equal_to<Key>, Allocator>;
template<class Key, class T, class Allocator>
unordered_map(initializer_list<pair<Key, T>>, Allocator)
-> unordered_map<Key, T, hash<Key>, equal_to<Key>, Allocator>;
§ 23.5.3.1 © ISO/IEC
1046

===== PAGE 1058 =====

Dxxxx
template<class Key, class T, class Hash, class Allocator>
unordered_map(initializer_list<pair<Key, T>>, typename see below ::size_type, Hash,
Allocator)
-> unordered_map<Key, T, Hash, equal_to<Key>, Allocator>;
}
5 A size_type parameter type in anunordered_map deduction guide refers to thesize_type member type
of the type deduced by the deduction guide.
23.5.3.2 Constructors [unord.map.cnstr]
constexpr unordered_map() : unordered_map(size_type(see below )) { }
constexpr explicit unordered_map(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
1 Effects: Constructs an emptyunordered_map using the specified hash function, key equality predicate,
and allocator, and using at leastn buckets. For the default constructor, the number of buckets is
implementation-defined. max_load_factor() returns 1.0.
2 Complexity: Constant.
template<class InputIterator>
constexpr unordered_map(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_map(from_range_t, R&& rg,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_map(initializer_list<value_type> il,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
3 Effects: Constructs an emptyunordered_map using the specified hash function, key equality predicate,
and allocator, and using at leastn buckets. If n is not provided, the number of buckets is implementa-
tion-defined. Then inserts elements from the range[f,l), rg, oril, respectively.max_load_factor()
returns 1.0.
4 Complexity: Average case linear, worst case quadratic.
23.5.3.3 Element access [unord.map.elem]
constexpr mapped_type& operator[](const key_type& k);
1 Effects: Equivalent to:return try_emplace(k).first->second;
constexpr mapped_type& operator[](key_type&& k);
2 Effects: Equivalent to:return try_emplace(std::move(k)).first->second;
template<class K> constexpr mapped_type& operator[](K&& k);
3 Constraints: The qualified-ids Hash::is_transparent and Pred::is_transparent are valid and
denote types.
4 Effects: Equivalent to:return try_emplace(std::forward<K>(k)).first->second;
constexpr mapped_type& at(const key_type& k);
constexpr const mapped_type& at(const key_type& k) const;
5 Returns: A reference tox.second, wherex is the (unique) element whose key is equivalent tok.
6 Throws: An exception object of typeout_of_range if no such element is present.
template<class K> constexpr mapped_type& at(const K& k);
§ 23.5.3.3 © ISO/IEC
1047

===== PAGE 1059 =====

Dxxxx
template<class K> constexpr const mapped_type& at(const K& k) const;
7 Constraints: The qualified-ids Hash::is_transparent and Pred::is_transparent are valid and
denote types.
8 Preconditions: The expressionfind(k) is well-formed and has well-defined behavior.
9 Returns: A reference tofind(k)->second.
10 Throws: An exception object of typeout_of_range if find(k) == end() is true.
23.5.3.4 Modifiers [unord.map.modifiers]
template<class P>
constexpr pair<iterator, bool> insert(P&& obj);
1 Constraints: is_constructible_v<value_type, P&&> is true.
2 Effects: Equivalent to:return emplace(std::forward<P>(obj));
template<class P>
constexpr iterator insert(const_iterator hint, P&& obj);
3 Constraints: is_constructible_v<value_type, P&&> is true.
4 Effects: Equivalent to:return emplace_hint(hint, std::forward<P>(obj));
template<class... Args>
constexpr pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
5 Preconditions: value_type is Cpp17EmplaceConstructible into unordered_map from piecewise_con-
struct, forward_as_tuple(k), forward_as_tuple(std::forward<Args>(args)...).
6 Effects: If the map already contains an element whose key is equivalent tok, there is no effect. Otherwise
inserts an object of typevalue_type constructed withpiecewise_construct, forward_as_tuple(k),
forward_as_tuple(std::forward<Args>(args)...).
7 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
8 Complexity: The same asemplace and emplace_hint, respectively.
template<class... Args>
constexpr pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
9 Preconditions: value_type is Cpp17EmplaceConstructible into unordered_map from piecewise_con-
struct, forward_as_tuple(std::move(k)), forward_as_tuple(std::forward<Args>(args)...).
10 Effects: If the map already contains an element whose key is equivalent tok, there is no effect.
Otherwise inserts an object of typevalue_type constructed withpiecewise_construct, forward_-
as_tuple(std::move(k)), forward_as_tuple(std::forward<Args>(args)...).
11 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
12 Complexity: The same asemplace and emplace_hint, respectively.
template<class K, class... Args>
constexpr pair<iterator, bool> try_emplace(K&& k, Args&&... args);
template<class K, class... Args>
constexpr iterator try_emplace(const_iterator hint, K&& k, Args&&... args);
13 Constraints: Thequalified-idsHash::is_transparentandPred::is_transparentarevalidanddenote
types. Forthefirstoverload, is_convertible_v<K&&, const_iterator>andis_convertible_v<K&&,
iterator> are bothfalse.
14 Preconditions: value_type is Cpp17EmplaceConstructible into unordered_map from piecewise_-
construct, forward_as_tuple(std::forward<K>(k)), forward_as_tuple(std::forward<Args>
(args)...).
§ 23.5.3.4 © ISO/IEC
1048

===== PAGE 1060 =====

Dxxxx
15 Effects: If the map already contains an element whose key is equivalent tok, there is no effect. Otherwise,
let hbe hash_function()(k). Constructs an objectuof typevalue_typewith piecewise_construct,
forward_as_tuple(std::forward<K>(k)), forward_as_tuple(std::forward<Args>(args)...).
If hash_function()(u.first) != h || contains(u.first) is true, the behavior is undefined. In-
serts u into *this.
16 Returns: For the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
17 Complexity: The same asemplace and emplace_hint, respectively.
template<class M>
constexpr pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
18 Mandates: is_assignable_v<mapped_type&, M&&> is true.
19 Preconditions: value_type is Cpp17EmplaceConstructible into unordered_map from k, std::for-
ward<M>(obj).
20 Effects: If the map already contains an elemente whose key is equivalent tok, assigns std::for-
ward<M>(obj) to e.second. Otherwise inserts an object of type value_type constructed with k,
std::forward<M>(obj).
21 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
22 Complexity: The same asemplace and emplace_hint, respectively.
template<class M>
constexpr pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
23 Mandates: is_assignable_v<mapped_type&, M&&> is true.
24 Preconditions: value_type is Cpp17EmplaceConstructible into unordered_map from std::move(k),
std::forward<M>(obj).
25 Effects: If the map already contains an elemente whose key is equivalent tok, assigns std::for-
ward<M>(obj) to e.second. Otherwise inserts an object of typevalue_type constructed withstd::
move(k), std::forward<M>(obj).
26 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
27 Complexity: The same asemplace and emplace_hint, respectively.
template<class K, class M>
constexpr pair<iterator, bool> insert_or_assign(K&& k, M&& obj);
template<class K, class M>
constexpr iterator insert_or_assign(const_iterator hint, K&& k, M&& obj);
28 Constraints: The qualified-ids Hash::is_transparent and Pred::is_transparent are valid and
denote types.
29 Mandates: is_assignable_v<mapped_type&, M&&> is true.
30 Preconditions: value_type is Cpp17EmplaceConstructible into unordered_map from std::forward<K>
(k), std::forward<M>(obj).
31 Effects: If the map already contains an elemente whose key is equivalent tok, assignsstd::forward<M>
(obj) to e.second. Otherwise, leth be hash_function()(k). Constructs an objectu of typevalue_-
type with std::forward<K>(k), std::forward<M>(obj). If hash_function()(u.first) != h ||
contains(u.first) is true, the behavior is undefined. Insertsu into *this.
32 Returns: For the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
33 Complexity: The same asemplace and emplace_hint, respectively.
§ 23.5.3.4 © ISO/IEC
1049

===== PAGE 1061 =====

Dxxxx
23.5.3.5 Erasure [unord.map.erasure]
template<class K, class T, class H, class P, class A, class Predicate>
constexpr typename unordered_map<K, T, H, P, A>::size_type
erase_if(unordered_map<K, T, H, P, A>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
23.5.4 Class template unordered_multimap [unord.multimap]
23.5.4.1 Overview [unord.multimap.overview]
1 An unordered_multimap is an unordered associative container that supports equivalent keys (an instance of
unordered_multimap may contain multiple copies of each key value) and that associates values of another
type mapped_type with the keys. Theunordered_multimap class supports forward iterators.
2 An unordered_multimap meets all of the requirements of a container (23.2.2.2), of an allocator-aware
container (23.2.2.5), and of an unordered associative container (23.2.8). It provides the operations described
in the preceding requirements table for equivalent keys; that is, anunordered_multimap supports thea_eq
operations in that table, not thea_uniq operations. For anunordered_multimap<Key, T> the key_type is
Key, themapped_type is T, and thevalue_type is pair<const Key, T>.
3 Subclause 23.5.4 only describes operations onunordered_multimap that are not described in one of the
requirement tables, or for which there is additional semantic information.
4 The typesiterator, const_iterator, local_iterator, andconst_local_iterator meet the constexpr
iterator requirements (24.3.1).
namespace std {
template<class Key,
class T,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Allocator = allocator<pair<const Key, T>>>
class unordered_multimap {
public:
// types
using key_type = Key;
using mapped_type = T;
using value_type = pair<const Key, T>;
using hasher = Hash;
using key_equal = Pred;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using local_iterator = implementation-defined ; // see 23.2
using const_local_iterator = implementation-defined ; // see 23.2
using node_type = unspecified ;
// 23.5.4.2, construct/copy/destroy
constexpr unordered_multimap();
§ 23.5.4.1 © ISO/IEC
1050

===== PAGE 1062 =====

Dxxxx
constexpr explicit unordered_multimap(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<class InputIterator>
constexpr unordered_multimap(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_multimap(from_range_t, R&& rg,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_multimap(const unordered_multimap&);
constexpr unordered_multimap(unordered_multimap&&);
constexpr explicit unordered_multimap(const Allocator&);
constexpr unordered_multimap(const unordered_multimap&, const type_identity_t<Allocator>&);
constexpr unordered_multimap(unordered_multimap&&, const type_identity_t<Allocator>&);
constexpr unordered_multimap(initializer_list<value_type> il,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_multimap(size_type n, const allocator_type& a)
: unordered_multimap(n, hasher(), key_equal(), a) { }
constexpr unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)
: unordered_multimap(n, hf, key_equal(), a) { }
template<class InputIterator>
constexpr unordered_multimap(InputIterator f, InputIterator l, size_type n,
const allocator_type& a)
: unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
template<class InputIterator>
constexpr unordered_multimap(InputIterator f, InputIterator l, size_type n,
const hasher& hf, const allocator_type& a)
: unordered_multimap(f, l, n, hf, key_equal(), a) { }
template<container-compatible-range <value_type> R>
constexpr unordered_multimap(from_range_t, R&& rg, size_type n, const allocator_type& a)
: unordered_multimap(from_range, std::forward<R>(rg),
n, hasher(), key_equal(), a) { }
template<container-compatible-range <value_type> R>
constexpr unordered_multimap(from_range_t, R&& rg, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_multimap(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }
constexpr unordered_multimap(initializer_list<value_type> il, size_type n,
const allocator_type& a)
: unordered_multimap(il, n, hasher(), key_equal(), a) { }
constexpr unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_multimap(il, n, hf, key_equal(), a) { }
constexpr ~unordered_multimap();
constexpr unordered_multimap& operator=(const unordered_multimap&);
constexpr unordered_multimap& operator=(unordered_multimap&&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Hash> && is_nothrow_move_assignable_v<Pred>);
constexpr unordered_multimap& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
§ 23.5.4.1 © ISO/IEC
1051

===== PAGE 1063 =====

Dxxxx
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.5.4.3, modifiers
template<class... Args> constexpr iterator emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr iterator insert(const value_type& obj);
constexpr iterator insert(value_type&& obj);
template<class P> constexpr iterator insert(P&& obj);
constexpr iterator insert(const_iterator hint, const value_type& obj);
constexpr iterator insert(const_iterator hint, value_type&& obj);
template<class P> constexpr iterator insert(const_iterator hint, P&& obj);
template<class InputIterator> constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> constexpr node_type extract(K&& x);
constexpr iterator insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
constexpr iterator erase(iterator position);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& k);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(unordered_multimap&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Hash> && is_nothrow_swappable_v<Pred>);
constexpr void clear() noexcept;
template<class H2, class P2>
constexpr void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);
template<class H2, class P2>
constexpr void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);
template<class H2, class P2>
constexpr void merge(unordered_map<Key, T, H2, P2, Allocator>& source);
template<class H2, class P2>
constexpr void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);
// observers
constexpr hasher hash_function() const;
constexpr key_equal key_eq() const;
// map operations
constexpr iterator find(const key_type& k);
constexpr const_iterator find(const key_type& k) const;
template<class K>
constexpr iterator find(const K& k);
template<class K>
constexpr const_iterator find(const K& k) const;
constexpr size_type count(const key_type& k) const;
template<class K>
constexpr size_type count(const K& k) const;
constexpr bool contains(const key_type& k) const;
template<class K>
constexpr bool contains(const K& k) const;
constexpr pair<iterator, iterator> equal_range(const key_type& k);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
§ 23.5.4.1 © ISO/IEC
1052

===== PAGE 1064 =====

Dxxxx
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& k);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& k) const;
// bucket interface
constexpr size_type bucket_count() const noexcept;
constexpr size_type max_bucket_count() const noexcept;
constexpr size_type bucket_size(size_type n) const;
constexpr size_type bucket(const key_type& k) const;
template<class K> constexpr size_type bucket(const K& k) const;
constexpr local_iterator begin(size_type n);
constexpr const_local_iterator begin(size_type n) const;
constexpr local_iterator end(size_type n);
constexpr const_local_iterator end(size_type n) const;
constexpr const_local_iterator cbegin(size_type n) const;
constexpr const_local_iterator cend(size_type n) const;
// hash policy
constexpr float load_factor() const noexcept;
constexpr float max_load_factor() const noexcept;
constexpr void max_load_factor(float z);
constexpr void rehash(size_type n);
constexpr void reserve(size_type n);
};
template<class InputIterator,
class Hash = hash<iter-key-type <InputIterator>>,
class Pred = equal_to<iter-key-type <InputIterator>>,
class Allocator = allocator<iter-to-alloc-type <InputIterator>>>
unordered_multimap(InputIterator, InputIterator,
typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
Hash, Pred, Allocator>;
template<ranges::input_range R,
class Hash = hash<range-key-type <R>>,
class Pred = equal_to<range-key-type <R>>,
class Allocator = allocator<range-to-alloc-type <R>>>
unordered_multimap(from_range_t, R&&, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_multimap<range-key-type <R>, range-mapped-type <R>, Hash, Pred, Allocator>;
template<class Key, class T, class Hash = hash<Key>,
class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
unordered_multimap(initializer_list<pair<Key, T>>,
typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_multimap<Key, T, Hash, Pred, Allocator>;
template<class InputIterator, class Allocator>
unordered_multimap(InputIterator, InputIterator, typename see below ::size_type, Allocator)
-> unordered_multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
hash<iter-key-type <InputIterator>>,
equal_to<iter-key-type <InputIterator>>, Allocator>;
template<class InputIterator, class Allocator>
unordered_multimap(InputIterator, InputIterator, Allocator)
-> unordered_multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>,
hash<iter-key-type <InputIterator>>,
equal_to<iter-key-type <InputIterator>>, Allocator>;
§ 23.5.4.1 © ISO/IEC
1053

===== PAGE 1065 =====

Dxxxx
template<class InputIterator, class Hash, class Allocator>
unordered_multimap(InputIterator, InputIterator, typename see below ::size_type, Hash,
Allocator)
-> unordered_multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Hash,
equal_to<iter-key-type <InputIterator>>, Allocator>;
template<ranges::input_range R, class Allocator>
unordered_multimap(from_range_t, R&&, typename see below ::size_type, Allocator)
-> unordered_multimap<range-key-type <R>, range-mapped-type <R>, hash<range-key-type <R>>,
equal_to<range-key-type <R>>, Allocator>;
template<ranges::input_range R, class Allocator>
unordered_multimap(from_range_t, R&&, Allocator)
-> unordered_multimap<range-key-type <R>, range-mapped-type <R>, hash<range-key-type <R>>,
equal_to<range-key-type <R>>, Allocator>;
template<ranges::input_range R, class Hash, class Allocator>
unordered_multimap(from_range_t, R&&, typename see below ::size_type, Hash, Allocator)
-> unordered_multimap<range-key-type <R>, range-mapped-type <R>, Hash,
equal_to<range-key-type <R>>, Allocator>;
template<class Key, class T, class Allocator>
unordered_multimap(initializer_list<pair<Key, T>>, typename see below ::size_type,
Allocator)
-> unordered_multimap<Key, T, hash<Key>, equal_to<Key>, Allocator>;
template<class Key, class T, class Allocator>
unordered_multimap(initializer_list<pair<Key, T>>, Allocator)
-> unordered_multimap<Key, T, hash<Key>, equal_to<Key>, Allocator>;
template<class Key, class T, class Hash, class Allocator>
unordered_multimap(initializer_list<pair<Key, T>>, typename see below ::size_type,
Hash, Allocator)
-> unordered_multimap<Key, T, Hash, equal_to<Key>, Allocator>;
}
5 A size_type parameter type in anunordered_multimap deduction guide refers to thesize_type member
type of the type deduced by the deduction guide.
23.5.4.2 Constructors [unord.multimap.cnstr]
constexpr unordered_multimap() : unordered_multimap(size_type(see below )) { }
constexpr explicit unordered_multimap(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
1 Effects: Constructs an emptyunordered_multimap using the specified hash function, key equality
predicate, and allocator, and using at leastn buckets. For the default constructor, the number of
buckets is implementation-defined.max_load_factor() returns 1.0.
2 Complexity: Constant.
template<class InputIterator>
constexpr unordered_multimap(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_multimap(from_range_t, R&& rg,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
§ 23.5.4.2 © ISO/IEC
1054

===== PAGE 1066 =====

Dxxxx
constexpr unordered_multimap(initializer_list<value_type> il,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
3 Effects: Constructs an emptyunordered_multimap using the specified hash function, key equality
predicate, and allocator, and using at leastn buckets. If n is not provided, the number of buckets is
implementation-defined. Then inserts elements from the range[f,l), rg, oril, respectively. max_-
load_factor() returns 1.0.
4 Complexity: Average case linear, worst case quadratic.
23.5.4.3 Modifiers [unord.multimap.modifiers]
template<class P>
constexpr iterator insert(P&& obj);
1 Constraints: is_constructible_v<value_type, P&&> is true.
2 Effects: Equivalent to:return emplace(std::forward<P>(obj));
template<class P>
constexpr iterator insert(const_iterator hint, P&& obj);
3 Constraints: is_constructible_v<value_type, P&&> is true.
4 Effects: Equivalent to:return emplace_hint(hint, std::forward<P>(obj));
23.5.4.4 Erasure [unord.multimap.erasure]
template<class K, class T, class H, class P, class A, class Predicate>
constexpr typename unordered_multimap<K, T, H, P, A>::size_type
erase_if(unordered_multimap<K, T, H, P, A>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
23.5.5 Header <unordered_set> synopsis [unord.set.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.5.6, class templateunordered_set
template<class Key,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Alloc = allocator<Key>>
class unordered_set;
// 23.5.7, class templateunordered_multiset
template<class Key,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Alloc = allocator<Key>>
class unordered_multiset;
template<class Key, class Hash, class Pred, class Alloc>
constexpr bool operator==(const unordered_set<Key, Hash, Pred, Alloc>& a,
const unordered_set<Key, Hash, Pred, Alloc>& b);
§ 23.5.5 © ISO/IEC
1055

===== PAGE 1067 =====

Dxxxx
template<class Key, class Hash, class Pred, class Alloc>
constexpr bool operator==(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
const unordered_multiset<Key, Hash, Pred, Alloc>& b);
template<class Key, class Hash, class Pred, class Alloc>
constexpr void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
unordered_set<Key, Hash, Pred, Alloc>& y)
noexcept(noexcept(x.swap(y)));
template<class Key, class Hash, class Pred, class Alloc>
constexpr void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
unordered_multiset<Key, Hash, Pred, Alloc>& y)
noexcept(noexcept(x.swap(y)));
// 23.5.6.3, erasure forunordered_set
template<class K, class H, class P, class A, class Predicate>
constexpr typename unordered_set<K, H, P, A>::size_type
erase_if(unordered_set<K, H, P, A>& c, Predicate pred);
// 23.5.7.3, erasure forunordered_multiset
template<class K, class H, class P, class A, class Predicate>
constexpr typename unordered_multiset<K, H, P, A>::size_type
erase_if(unordered_multiset<K, H, P, A>& c, Predicate pred);
namespace pmr {
template<class Key,
class Hash = hash<Key>,
class Pred = equal_to<Key>>
using unordered_set = std::unordered_set<Key, Hash, Pred,
polymorphic_allocator<Key>>;
template<class Key,
class Hash = hash<Key>,
class Pred = equal_to<Key>>
using unordered_multiset = std::unordered_multiset<Key, Hash, Pred,
polymorphic_allocator<Key>>;
}
}
23.5.6 Class template unordered_set [unord.set]
23.5.6.1 Overview [unord.set.overview]
1 An unordered_set is an unordered associative container that supports unique keys (anunordered_set
contains at most one of each key value) and in which the elements’ keys are the elements themselves. The
unordered_set class supports forward iterators.
2 An unordered_set meets all of the requirements of a container (23.2.2.2), of an allocator-aware container
(23.2.2.5), and of an unordered associative container (23.2.8). It provides the operations described in the
preceding requirements table for unique keys; that is, anunordered_set supports thea_uniq operations
in that table, not thea_eq operations. For an unordered_set<Key> the key_type and the value_type
are bothKey. The iterator and const_iterator types are both constant iterator types. It is unspecified
whether they are the same type.
3 Subclause 23.5.6 only describes operations onunordered_set that are not described in one of the requirement
tables, or for which there is additional semantic information.
4 The typesiterator, const_iterator, local_iterator, andconst_local_iterator meet the constexpr
iterator requirements (24.3.1).
namespace std {
template<class Key,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Allocator = allocator<Key>>
class unordered_set {
§ 23.5.6.1 © ISO/IEC
1056

===== PAGE 1068 =====

Dxxxx
public:
// types
using key_type = Key;
using value_type = Key;
using hasher = Hash;
using key_equal = Pred;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using local_iterator = implementation-defined ; // see 23.2
using const_local_iterator = implementation-defined ; // see 23.2
using node_type = unspecified ;
using insert_return_type = insert-return-type<iterator, node_type>;
// 23.5.6.2, construct/copy/destroy
constexpr unordered_set();
constexpr explicit unordered_set(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<class InputIterator>
constexpr unordered_set(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_set(from_range_t, R&& rg,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_set(const unordered_set&);
constexpr unordered_set(unordered_set&&);
constexpr explicit unordered_set(const Allocator&);
constexpr unordered_set(const unordered_set&, const type_identity_t<Allocator>&);
constexpr unordered_set(unordered_set&&, const type_identity_t<Allocator>&);
constexpr unordered_set(initializer_list<value_type> il,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_set(size_type n, const allocator_type& a)
: unordered_set(n, hasher(), key_equal(), a) { }
constexpr unordered_set(size_type n, const hasher& hf, const allocator_type& a)
: unordered_set(n, hf, key_equal(), a) { }
template<class InputIterator>
constexpr unordered_set(InputIterator f, InputIterator l, size_type n,
const allocator_type& a)
: unordered_set(f, l, n, hasher(), key_equal(), a) { }
template<class InputIterator>
constexpr unordered_set(InputIterator f, InputIterator l, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_set(f, l, n, hf, key_equal(), a) { }
constexpr unordered_set(initializer_list<value_type> il, size_type n,
const allocator_type& a)
: unordered_set(il, n, hasher(), key_equal(), a) { }
template<container-compatible-range <value_type> R>
constexpr unordered_set(from_range_t, R&& rg, size_type n, const allocator_type& a)
: unordered_set(from_range, std::forward<R>(rg), n, hasher(), key_equal(), a) { }
§ 23.5.6.1 © ISO/IEC
1057

===== PAGE 1069 =====

Dxxxx
template<container-compatible-range <value_type> R>
constexpr unordered_set(from_range_t, R&& rg, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_set(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }
constexpr unordered_set(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_set(il, n, hf, key_equal(), a) { }
constexpr ~unordered_set();
constexpr unordered_set& operator=(const unordered_set&);
constexpr unordered_set& operator=(unordered_set&&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Hash> && is_nothrow_move_assignable_v<Pred>);
constexpr unordered_set& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.5.6.4, modifiers
template<class... Args> constexpr pair<iterator, bool> emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr pair<iterator, bool> insert(const value_type& obj);
constexpr pair<iterator, bool> insert(value_type&& obj);
template<class K> constexpr pair<iterator, bool> insert(K&& obj);
constexpr iterator insert(const_iterator hint, const value_type& obj);
constexpr iterator insert(const_iterator hint, value_type&& obj);
template<class K> constexpr iterator insert(const_iterator hint, K&& obj);
template<class InputIterator> constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> constexpr node_type extract(K&& x);
constexpr insert_return_type insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
constexpr iterator erase(iterator position)
requires (!same_as<iterator, const_iterator>);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& k);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(unordered_set&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Hash> && is_nothrow_swappable_v<Pred>);
constexpr void clear() noexcept;
template<class H2, class P2>
constexpr void merge(unordered_set<Key, H2, P2, Allocator>& source);
template<class H2, class P2>
constexpr void merge(unordered_set<Key, H2, P2, Allocator>&& source);
§ 23.5.6.1 © ISO/IEC
1058

===== PAGE 1070 =====

Dxxxx
template<class H2, class P2>
constexpr void merge(unordered_multiset<Key, H2, P2, Allocator>& source);
template<class H2, class P2>
constexpr void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);
// observers
constexpr hasher hash_function() const;
constexpr key_equal key_eq() const;
// set operations
constexpr iterator find(const key_type& k);
constexpr const_iterator find(const key_type& k) const;
template<class K>
constexpr iterator find(const K& k);
template<class K>
constexpr const_iterator find(const K& k) const;
constexpr size_type count(const key_type& k) const;
template<class K>
constexpr size_type count(const K& k) const;
constexpr bool contains(const key_type& k) const;
template<class K>
constexpr bool contains(const K& k) const;
constexpr pair<iterator, iterator> equal_range(const key_type& k);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& k);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& k) const;
// bucket interface
constexpr size_type bucket_count() const noexcept;
constexpr size_type max_bucket_count() const noexcept;
constexpr size_type bucket_size(size_type n) const;
constexpr size_type bucket(const key_type& k) const;
template<class K> constexpr size_type bucket(const K& k) const;
constexpr local_iterator begin(size_type n);
constexpr const_local_iterator begin(size_type n) const;
constexpr local_iterator end(size_type n);
constexpr const_local_iterator end(size_type n) const;
constexpr const_local_iterator cbegin(size_type n) const;
constexpr const_local_iterator cend(size_type n) const;
// hash policy
constexpr float load_factor() const noexcept;
constexpr float max_load_factor() const noexcept;
constexpr void max_load_factor(float z);
constexpr void rehash(size_type n);
constexpr void reserve(size_type n);
};
template<class InputIterator,
class Hash = hash<iter-value-type <InputIterator>>,
class Pred = equal_to<iter-value-type <InputIterator>>,
class Allocator = allocator<iter-value-type <InputIterator>>>
unordered_set(InputIterator, InputIterator, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_set<iter-value-type <InputIterator>,
Hash, Pred, Allocator>;
template<ranges::input_range R,
class Hash = hash<ranges::range_value_t<R>>,
class Pred = equal_to<ranges::range_value_t<R>>,
class Allocator = allocator<ranges::range_value_t<R>>>
unordered_set(from_range_t, R&&, typename see below ::size_type = see below ,
§ 23.5.6.1 © ISO/IEC
1059

===== PAGE 1071 =====

Dxxxx
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_set<ranges::range_value_t<R>, Hash, Pred, Allocator>;
template<class T, class Hash = hash<T>,
class Pred = equal_to<T>, class Allocator = allocator<T>>
unordered_set(initializer_list<T>, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_set<T, Hash, Pred, Allocator>;
template<class InputIterator, class Allocator>
unordered_set(InputIterator, InputIterator, typename see below ::size_type, Allocator)
-> unordered_set<iter-value-type <InputIterator>,
hash<iter-value-type <InputIterator>>,
equal_to<iter-value-type <InputIterator>>,
Allocator>;
template<class InputIterator, class Hash, class Allocator>
unordered_set(InputIterator, InputIterator, typename see below ::size_type,
Hash, Allocator)
-> unordered_set<iter-value-type <InputIterator>, Hash,
equal_to<iter-value-type <InputIterator>>,
Allocator>;
template<ranges::input_range R, class Allocator>
unordered_set(from_range_t, R&&, typename see below ::size_type, Allocator)
-> unordered_set<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
equal_to<ranges::range_value_t<R>>, Allocator>;
template<ranges::input_range R, class Allocator>
unordered_set(from_range_t, R&&, Allocator)
-> unordered_set<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
equal_to<ranges::range_value_t<R>>, Allocator>;
template<ranges::input_range R, class Hash, class Allocator>
unordered_set(from_range_t, R&&, typename see below ::size_type, Hash, Allocator)
-> unordered_set<ranges::range_value_t<R>, Hash,
equal_to<ranges::range_value_t<R>>, Allocator>;
template<class T, class Allocator>
unordered_set(initializer_list<T>, typename see below ::size_type, Allocator)
-> unordered_set<T, hash<T>, equal_to<T>, Allocator>;
template<class T, class Hash, class Allocator>
unordered_set(initializer_list<T>, typename see below ::size_type, Hash, Allocator)
-> unordered_set<T, Hash, equal_to<T>, Allocator>;
}
5 A size_type parameter type in anunordered_set deduction guide refers to thesize_type member type
of the type deduced by the deduction guide.
23.5.6.2 Constructors [unord.set.cnstr]
constexpr unordered_set() : unordered_set(size_type(see below )) { }
constexpr explicit unordered_set(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
1 Effects: Constructs an emptyunordered_set using the specified hash function, key equality predicate,
and allocator, and using at leastn buckets. For the default constructor, the number of buckets is
implementation-defined. max_load_factor() returns 1.0.
2 Complexity: Constant.
§ 23.5.6.2 © ISO/IEC
1060

===== PAGE 1072 =====

Dxxxx
template<class InputIterator>
constexpr unordered_set(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_multiset(from_range_t, R&& rg,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_set(initializer_list<value_type> il,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
3 Effects: Constructs an emptyunordered_set using the specified hash function, key equality predicate,
and allocator, and using at leastn buckets. If n is not provided, the number of buckets is implementa-
tion-defined. Then inserts elements from the range[f,l), rg, oril, respectively.max_load_factor()
returns 1.0.
4 Complexity: Average case linear, worst case quadratic.
23.5.6.3 Erasure [unord.set.erasure]
template<class K, class H, class P, class A, class Predicate>
constexpr typename unordered_set<K, H, P, A>::size_type
erase_if(unordered_set<K, H, P, A>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
23.5.6.4 Modifiers [unord.set.modifiers]
template<class K> constexpr pair<iterator, bool> insert(K&& obj);
template<class K> constexpr iterator insert(const_iterator hint, K&& obj);
1 Constraints: Thequalified-idsHash::is_transparentandPred::is_transparentarevalidanddenote
types. For the second overload,is_convertible_v<K&&, const_iterator> and is_convertible_-
v<K&&, iterator> are bothfalse.
2 Preconditions: value_type is Cpp17EmplaceConstructible into unordered_set from std::forward<K>
(obj).
3 Effects: If the set already contains an element that is equivalent toobj, there is no effect. Otherwise, leth
be hash_function()(obj). Constructs an objectu of typevalue_type with std::forward<K>(obj).
If hash_function()(u) != h || contains(u) is true, the behavior is undefined. Inserts u into
*this.
4 Returns: For the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the set element that is equivalent toobj.
5 Complexity: Average case constant, worst case linear.
23.5.7 Class template unordered_multiset [unord.multiset]
23.5.7.1 Overview [unord.multiset.overview]
1 An unordered_multiset is an unordered associative container that supports equivalent keys (an instance of
unordered_multiset may contain multiple copies of the same key value) and in which each element’s key is
the element itself. Theunordered_multiset class supports forward iterators.
§ 23.5.7.1 © ISO/IEC
1061

===== PAGE 1073 =====

Dxxxx
2 An unordered_multiset meets all of the requirements of a container (23.2.2.2), of an allocator-aware
container (23.2.2.5), and of an unordered associative container (23.2.8). It provides the operations described
in the preceding requirements table for equivalent keys; that is, anunordered_multiset supports thea_eq
operations in that table, not thea_uniq operations. For anunordered_multiset<Key> the key_type and
the value_type are bothKey. The iterator and const_iterator types are both constant iterator types.
It is unspecified whether they are the same type.
3 Subclause 23.5.7 only describes operations onunordered_multiset that are not described in one of the
requirement tables, or for which there is additional semantic information.
4 The typesiterator, const_iterator, local_iterator, andconst_local_iterator meet the constexpr
iterator requirements (24.3.1).
namespace std {
template<class Key,
class Hash = hash<Key>,
class Pred = equal_to<Key>,
class Allocator = allocator<Key>>
class unordered_multiset {
public:
// types
using key_type = Key;
using value_type = Key;
using hasher = Hash;
using key_equal = Pred;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using local_iterator = implementation-defined ; // see 23.2
using const_local_iterator = implementation-defined ; // see 23.2
using node_type = unspecified ;
// 23.5.7.2, construct/copy/destroy
constexpr unordered_multiset();
constexpr explicit unordered_multiset(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<class InputIterator>
constexpr unordered_multiset(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_multiset(from_range_t, R&& rg,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_multiset(const unordered_multiset&);
constexpr unordered_multiset(unordered_multiset&&);
constexpr explicit unordered_multiset(const Allocator&);
constexpr unordered_multiset(const unordered_multiset&, const type_identity_t<Allocator>&);
constexpr unordered_multiset(unordered_multiset&&, const type_identity_t<Allocator>&);
constexpr unordered_multiset(initializer_list<value_type> il,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_multiset(size_type n, const allocator_type& a)
: unordered_multiset(n, hasher(), key_equal(), a) { }
§ 23.5.7.1 © ISO/IEC
1062

===== PAGE 1074 =====

Dxxxx
constexpr unordered_multiset(size_type n, const hasher& hf, const allocator_type& a)
: unordered_multiset(n, hf, key_equal(), a) { }
template<class InputIterator>
constexpr unordered_multiset(InputIterator f, InputIterator l, size_type n,
const allocator_type& a)
: unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
template<class InputIterator>
constexpr unordered_multiset(InputIterator f, InputIterator l, size_type n,
const hasher& hf, const allocator_type& a)
: unordered_multiset(f, l, n, hf, key_equal(), a) { }
template<container-compatible-range <value_type> R>
constexpr unordered_multiset(from_range_t, R&& rg, size_type n, const allocator_type& a)
: unordered_multiset(from_range, std::forward<R>(rg),
n, hasher(), key_equal(), a) { }
template<container-compatible-range <value_type> R>
constexpr unordered_multiset(from_range_t, R&& rg, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_multiset(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }
constexpr unordered_multiset(initializer_list<value_type> il, size_type n,
const allocator_type& a)
: unordered_multiset(il, n, hasher(), key_equal(), a) { }
constexpr unordered_multiset(initializer_list<value_type> il, size_type n, const hasher& hf,
const allocator_type& a)
: unordered_multiset(il, n, hf, key_equal(), a) { }
constexpr ~unordered_multiset();
constexpr unordered_multiset& operator=(const unordered_multiset&);
constexpr unordered_multiset& operator=(unordered_multiset&&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_move_assignable_v<Hash> && is_nothrow_move_assignable_v<Pred>);
constexpr unordered_multiset& operator=(initializer_list<value_type>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// modifiers
template<class... Args> constexpr iterator emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr iterator insert(const value_type& obj);
constexpr iterator insert(value_type&& obj);
constexpr iterator insert(const_iterator hint, const value_type& obj);
constexpr iterator insert(const_iterator hint, value_type&& obj);
template<class InputIterator> constexpr void insert(InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
constexpr void insert(initializer_list<value_type>);
constexpr node_type extract(const_iterator position);
constexpr node_type extract(const key_type& x);
template<class K> constexpr node_type extract(K&& x);
constexpr iterator insert(node_type&& nh);
constexpr iterator insert(const_iterator hint, node_type&& nh);
§ 23.5.7.1 © ISO/IEC
1063

===== PAGE 1075 =====

Dxxxx
constexpr iterator erase(iterator position)
requires (!same_as<iterator, const_iterator>);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& k);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(unordered_multiset&)
noexcept(allocator_traits<Allocator>::is_always_equal::value &&
is_nothrow_swappable_v<Hash> && is_nothrow_swappable_v<Pred>);
constexpr void clear() noexcept;
template<class H2, class P2>
constexpr void merge(unordered_multiset<Key, H2, P2, Allocator>& source);
template<class H2, class P2>
constexpr void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);
template<class H2, class P2>
constexpr void merge(unordered_set<Key, H2, P2, Allocator>& source);
template<class H2, class P2>
constexpr void merge(unordered_set<Key, H2, P2, Allocator>&& source);
// observers
constexpr hasher hash_function() const;
constexpr key_equal key_eq() const;
// set operations
constexpr iterator find(const key_type& k);
constexpr const_iterator find(const key_type& k) const;
template<class K>
constexpr iterator find(const K& k);
template<class K>
constexpr const_iterator find(const K& k) const;
constexpr size_type count(const key_type& k) const;
template<class K>
constexpr size_type count(const K& k) const;
constexpr bool contains(const key_type& k) const;
template<class K>
constexpr bool contains(const K& k) const;
constexpr pair<iterator, iterator> equal_range(const key_type& k);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& k);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& k) const;
// bucket interface
constexpr size_type bucket_count() const noexcept;
constexpr size_type max_bucket_count() const noexcept;
constexpr size_type bucket_size(size_type n) const;
constexpr size_type bucket(const key_type& k) const;
template<class K> constexpr size_type bucket(const K& k) const;
constexpr local_iterator begin(size_type n);
constexpr const_local_iterator begin(size_type n) const;
constexpr local_iterator end(size_type n);
constexpr const_local_iterator end(size_type n) const;
constexpr const_local_iterator cbegin(size_type n) const;
constexpr const_local_iterator cend(size_type n) const;
// hash policy
constexpr float load_factor() const noexcept;
constexpr float max_load_factor() const noexcept;
constexpr void max_load_factor(float z);
constexpr void rehash(size_type n);
constexpr void reserve(size_type n);
};
§ 23.5.7.1 © ISO/IEC
1064

===== PAGE 1076 =====

Dxxxx
template<class InputIterator,
class Hash = hash<iter-value-type <InputIterator>>,
class Pred = equal_to<iter-value-type <InputIterator>>,
class Allocator = allocator<iter-value-type <InputIterator>>>
unordered_multiset(InputIterator, InputIterator, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_multiset<iter-value-type <InputIterator>,
Hash, Pred, Allocator>;
template<ranges::input_range R,
class Hash = hash<ranges::range_value_t<R>>,
class Pred = equal_to<ranges::range_value_t<R>>,
class Allocator = allocator<ranges::range_value_t<R>>>
unordered_multiset(from_range_t, R&&, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_multiset<ranges::range_value_t<R>, Hash, Pred, Allocator>;
template<class T, class Hash = hash<T>,
class Pred = equal_to<T>, class Allocator = allocator<T>>
unordered_multiset(initializer_list<T>, typename see below ::size_type = see below ,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_multiset<T, Hash, Pred, Allocator>;
template<class InputIterator, class Allocator>
unordered_multiset(InputIterator, InputIterator, typename see below ::size_type, Allocator)
-> unordered_multiset<iter-value-type <InputIterator>,
hash<iter-value-type <InputIterator>>,
equal_to<iter-value-type <InputIterator>>,
Allocator>;
template<class InputIterator, class Hash, class Allocator>
unordered_multiset(InputIterator, InputIterator, typename see below ::size_type,
Hash, Allocator)
-> unordered_multiset<iter-value-type <InputIterator>, Hash,
equal_to<iter-value-type <InputIterator>>,
Allocator>;
template<ranges::input_range R, class Allocator>
unordered_multiset(from_range_t, R&&, typename see below ::size_type, Allocator)
-> unordered_multiset<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
equal_to<ranges::range_value_t<R>>, Allocator>;
template<ranges::input_range R, class Allocator>
unordered_multiset(from_range_t, R&&, Allocator)
-> unordered_multiset<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
equal_to<ranges::range_value_t<R>>, Allocator>;
template<ranges::input_range R, class Hash, class Allocator>
unordered_multiset(from_range_t, R&&, typename see below ::size_type, Hash, Allocator)
-> unordered_multiset<ranges::range_value_t<R>, Hash, equal_to<ranges::range_value_t<R>>,
Allocator>;
template<class T, class Allocator>
unordered_multiset(initializer_list<T>, typename see below ::size_type, Allocator)
-> unordered_multiset<T, hash<T>, equal_to<T>, Allocator>;
template<class T, class Hash, class Allocator>
unordered_multiset(initializer_list<T>, typename see below ::size_type, Hash, Allocator)
-> unordered_multiset<T, Hash, equal_to<T>, Allocator>;
}
5 A size_type parameter type in anunordered_multiset deduction guide refers to thesize_type member
type of the type deduced by the deduction guide.
§ 23.5.7.1 © ISO/IEC
1065

===== PAGE 1077 =====

Dxxxx
23.5.7.2 Constructors [unord.multiset.cnstr]
constexpr unordered_multiset() : unordered_multiset(size_type(see below )) { }
constexpr explicit unordered_multiset(size_type n, const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
1 Effects: Constructs an emptyunordered_multiset using the specified hash function, key equality
predicate, and allocator, and using at leastn buckets. For the default constructor, the number of
buckets is implementation-defined.max_load_factor() returns 1.0.
2 Complexity: Constant.
template<class InputIterator>
constexpr unordered_multiset(InputIterator f, InputIterator l,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
template<container-compatible-range <value_type> R>
constexpr unordered_multiset(from_range_t, R&& rg,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
constexpr unordered_multiset(initializer_list<value_type> il,
size_type n = see below , const hasher& hf = hasher(),
const key_equal& eql = key_equal(),
const allocator_type& a = allocator_type());
3 Effects: Constructs an emptyunordered_multiset using the specified hash function, key equality
predicate, and allocator, and using at leastn buckets. If n is not provided, the number of buckets is
implementation-defined. Then inserts elements from the range[f,l), rg, oril, respectively. max_-
load_factor() returns 1.0.
4 Complexity: Average case linear, worst case quadratic.
23.5.7.3 Erasure [unord.multiset.erasure]
template<class K, class H, class P, class A, class Predicate>
constexpr typename unordered_multiset<K, H, P, A>::size_type
erase_if(unordered_multiset<K, H, P, A>& c, Predicate pred);
1 Effects: Equivalent to:
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
if (pred(*i)) {
i = c.erase(i);
} else {
++i;
}
}
return original_size - c.size();
23.6 Container adaptors [container.adaptors]
23.6.1 General [container.adaptors.general]
1 The headers<queue> (23.6.2), <stack> (23.6.5), <flat_map> (23.6.7), and<flat_set> (23.6.10) define the
container adaptorsqueue and priority_queue, stack, flat_map and flat_multimap, andflat_set and
flat_multiset, respectively.
2 Each container adaptor takes one or more template parameters namedContainer, KeyContainer, or
MappedContainer that denote the types of containers that the container adaptor adapts. Each container
adaptor has at least one constructor that takes a reference argument to one or more such template parameters.
For each constructor reference argument to a containerC, the constructor copies the container into the
container adaptor. IfC takes an allocator, then a compatible allocator may be passed in to the adaptor’s
constructor. Otherwise, normal copy or move construction is used for the container argument. For the
§ 23.6.1 © ISO/IEC
1066

===== PAGE 1078 =====

Dxxxx
container adaptors that take a single container template parameterContainer, the first template parameter
T of the container adaptor shall denote the same type asContainer::value_type.
3 For container adaptors, noswap function throws an exception unless that exception is thrown by the swap of
the adaptor’sContainer, KeyContainer, MappedContainer, orCompare object (if any).
4 A constructor template of a container adaptor shall not participate in overload resolution if it has an
InputIterator template parameter and a type that does not qualify as an input iterator is deduced for that
parameter.
5 For container adaptors that have them, theinsert, emplace, and erase members affect the validity of
iterators, references, and pointers to the adaptor’s container(s) in the same way that the containers’ respective
insert, emplace, anderase members do.
[Example 1: A call toflat_map<Key, T>::insert can invalidate all iterators to theflat_map. —end example]
6 A deduction guide for a container adaptor shall not participate in overload resolution if any of the following
are true:
—(6.1) It has anInputIterator template parameter and a type that does not qualify as an input iterator is
deduced for that parameter.
—(6.2) It has aCompare template parameter and a type that qualifies as an allocator is deduced for that
parameter.
—(6.3) It has aContainer, KeyContainer, orMappedContainer template parameter and a type that qualifies
as an allocator is deduced for that parameter.
—(6.4) It has noContainer, KeyContainer, orMappedContainertemplate parameter, and it has anAllocator
template parameter, and a type that does not qualify as an allocator is deduced for that parameter.
—(6.5) It has both Container and Allocator template parameters, and uses_allocator_v<Container,
Allocator> is false.
—(6.6) It has bothKeyContainer and Allocator template parameters, anduses_allocator_v<KeyContai-
ner, Allocator> is false.
—(6.7) It has bothKeyContainer and Compare template parameters, and
is_invocable_v<const Compare&,
const typename KeyContainer::value_type&,
const typename KeyContainer::value_type&>
is not a valid expression or isfalse.
—(6.8) It has bothMappedContainer and Allocator template parameters, anduses_allocator_v<Mapped-
Container, Allocator> is false.
7 The exposition-only alias templateiter-value-type defined in 23.3.1 and the exposition-only alias templates
iter-key-type , iter-mapped-type , range-key-type , and range-mapped-type defined in 23.4.1 may
appear in deduction guides for container adaptors.
8 The following exposition-only alias template may appear in deduction guides for container adaptors:
template<class Allocator, class T>
using alloc-rebind = allocator_traits<Allocator>::template rebind_alloc<T>; // exposition only
23.6.2 Header <queue> synopsis [queue.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.6.3, class templatequeue
template<class T, class Container = deque<T>> class queue;
template<class T, class Container>
constexpr bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
template<class T, class Container>
constexpr bool operator!=(const queue<T, Container>& x, const queue<T, Container>& y);
template<class T, class Container>
constexpr bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
§ 23.6.2 © ISO/IEC
1067

===== PAGE 1079 =====

Dxxxx
template<class T, class Container>
constexpr bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
template<class T, class Container>
constexpr bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);
template<class T, class Container>
constexpr bool operator>=(const queue<T, Container>& x, const queue<T, Container>& y);
template<class T, three_way_comparable Container>
constexpr compare_three_way_result_t<Container>
operator<=>(const queue<T, Container>& x, const queue<T, Container>& y);
template<class T, class Container>
constexpr void swap(queue<T, Container>& x, queue<T, Container>& y)
noexcept(noexcept(x.swap(y)));
template<class T, class Container, class Alloc>
struct uses_allocator<queue<T, Container>, Alloc>;
// 23.6.13, formatter specialization forqueue
template<class charT, class T, formattable<charT> Container>
struct formatter<queue<T, Container>, charT>;
template<class T, class Container>
constexpr bool enable_nonlocking_formatter_optimization<queue<T, Container>> = false;
// 23.6.4, class templatepriority_queue
template<class T, class Container = vector<T>,
class Compare = less<typename Container::value_type>>
class priority_queue;
template<class T, class Container, class Compare>
constexpr void swap(priority_queue<T, Container, Compare>& x,
priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));
template<class T, class Container, class Compare, class Alloc>
struct uses_allocator<priority_queue<T, Container, Compare>, Alloc>;
// 23.6.13, formatter specialization forpriority_queue
template<class charT, class T, formattable<charT> Container, class Compare>
struct formatter<priority_queue<T, Container, Compare>, charT>;
template<class T, class Container, class Compare>
constexpr bool
enable_nonlocking_formatter_optimization<priority_queue<T, Container, Compare>> = false;
}
23.6.3 Class template queue [queue]
23.6.3.1 Definition [queue.defn]
1 Any sequence container supporting operationsfront(), back(), push_back() and pop_front() can be used
to instantiatequeue. In particular,list (23.3.11) anddeque (23.3.5) can be used.
namespace std {
template<class T, class Container = deque<T>>
class queue {
public:
using value_type = Container::value_type;
using reference = Container::reference;
using const_reference = Container::const_reference;
using size_type = Container::size_type;
using container_type = Container;
protected:
Container c;
public:
constexpr queue() : queue(Container()) {}
constexpr explicit queue(const Container&);
§ 23.6.3.1 © ISO/IEC
1068

===== PAGE 1080 =====

Dxxxx
constexpr explicit queue(Container&&);
template<class InputIterator> constexpr queue(InputIterator first, InputIterator last);
template<container-compatible-range <T> R> constexpr queue(from_range_t, R&& rg);
template<class Alloc> constexpr explicit queue(const Alloc&);
template<class Alloc> constexpr queue(const Container&, const Alloc&);
template<class Alloc> constexpr queue(Container&&, const Alloc&);
template<class Alloc> constexpr queue(const queue&, const Alloc&);
template<class Alloc> constexpr queue(queue&&, const Alloc&);
template<class InputIterator, class Alloc>
constexpr queue(InputIterator first, InputIterator last, const Alloc&);
template<container-compatible-range <T> R, class Alloc>
constexpr queue(from_range_t, R&& rg, const Alloc&);
constexpr bool empty() const { return c.empty(); }
constexpr size_type size() const { return c.size(); }
constexpr reference front() { return c.front(); }
constexpr const_reference front() const { return c.front(); }
constexpr reference back() { return c.back(); }
constexpr const_reference back() const { return c.back(); }
constexpr void push(const value_type& x) { c.push_back(x); }
constexpr void push(value_type&& x) { c.push_back(std::move(x)); }
template<container-compatible-range <T> R> constexpr void push_range(R&& rg);
template<class... Args>
constexpr decltype(auto) emplace(Args&&... args)
{ return c.emplace_back(std::forward<Args>(args)...); }
constexpr void pop() { c.pop_front(); }
constexpr void swap(queue& q) noexcept(is_nothrow_swappable_v<Container>)
{ using std::swap; swap(c, q.c); }
};
template<class Container>
queue(Container) -> queue<typename Container::value_type, Container>;
template<class InputIterator>
queue(InputIterator, InputIterator) -> queue<iter-value-type <InputIterator>>;
template<ranges::input_range R>
queue(from_range_t, R&&) -> queue<ranges::range_value_t<R>>;
template<class Container, class Allocator>
queue(Container, Allocator) -> queue<typename Container::value_type, Container>;
template<class InputIterator, class Allocator>
queue(InputIterator, InputIterator, Allocator)
-> queue<iter-value-type <InputIterator>, deque<iter-value-type <InputIterator>,
Allocator>>;
template<ranges::input_range R, class Allocator>
queue(from_range_t, R&&, Allocator)
-> queue<ranges::range_value_t<R>, deque<ranges::range_value_t<R>, Allocator>>;
template<class T, class Container, class Alloc>
struct uses_allocator<queue<T, Container>, Alloc>
: uses_allocator<Container, Alloc>::type { };
}
23.6.3.2 Constructors [queue.cons]
constexpr explicit queue(const Container& cont);
1 Effects: Initializes c with cont.
constexpr explicit queue(Container&& cont);
2 Effects: Initializes c with std::move(cont).
§ 23.6.3.2 © ISO/IEC
1069

===== PAGE 1081 =====

Dxxxx
template<class InputIterator>
constexpr queue(InputIterator first, InputIterator last);
3 Effects: Initializes c with first as the first argument andlast as the second argument.
template<container-compatible-range <T> R>
constexpr queue(from_range_t, R&& rg);
4 Effects: Initializes c with ranges::to<Container>(std::forward<R>(rg)).
23.6.3.3 Constructors with allocators [queue.cons.alloc]
1 If uses_allocator_v<container_type, Alloc> is false the constructors in this subclause shall not par-
ticipate in overload resolution.
template<class Alloc> constexpr explicit queue(const Alloc& a);
2 Effects: Initializes c with a.
template<class Alloc> constexpr queue(const container_type& cont, const Alloc& a);
3 Effects: Initializes c with cont as the first argument anda as the second argument.
template<class Alloc> constexpr queue(container_type&& cont, const Alloc& a);
4 Effects: Initializes c with std::move(cont) as the first argument anda as the second argument.
template<class Alloc> constexpr queue(const queue& q, const Alloc& a);
5 Effects: Initializes c with q.c as the first argument anda as the second argument.
template<class Alloc> constexpr queue(queue&& q, const Alloc& a);
6 Effects: Initializes c with std::move(q.c) as the first argument anda as the second argument.
template<class InputIterator, class Alloc>
constexpr queue(InputIterator first, InputIterator last, const Alloc& alloc);
7 Effects: Initializes c with first as the first argument,last as the second argument, andalloc as the
third argument.
template<container-compatible-range <T> R, class Alloc>
constexpr queue(from_range_t, R&& rg, const Alloc& a);
8 Effects: Initializes c with ranges::to<Container>(std::forward<R>(rg), a).
23.6.3.4 Modifiers [queue.mod]
template<container-compatible-range <T> R>
constexpr void push_range(R&& rg);
1 Effects: Equivalent toc.append_range(std::forward<R>(rg)) if that is a valid expression, otherwise
ranges::copy(rg, back_inserter(c)).
23.6.3.5 Operators [queue.ops]
template<class T, class Container>
constexpr bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
1 Returns: x.c == y.c.
template<class T, class Container>
constexpr bool operator!=(const queue<T, Container>& x, const queue<T, Container>& y);
2 Returns: x.c != y.c.
template<class T, class Container>
constexpr bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
3 Returns: x.c < y.c.
template<class T, class Container>
constexpr bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
4 Returns: x.c > y.c.
§ 23.6.3.5 © ISO/IEC
1070

===== PAGE 1082 =====

Dxxxx
template<class T, class Container>
constexpr bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);
5 Returns: x.c <= y.c.
template<class T, class Container>
constexpr bool operator>=(const queue<T, Container>& x, const queue<T, Container>& y);
6 Returns: x.c >= y.c.
template<class T, three_way_comparable Container>
constexpr compare_three_way_result_t<Container>
operator<=>(const queue<T, Container>& x, const queue<T, Container>& y);
7 Returns: x.c <=> y.c.
23.6.3.6 Specialized algorithms [queue.special]
template<class T, class Container>
constexpr void swap(queue<T, Container>& x, queue<T, Container>& y)
noexcept(noexcept(x.swap(y)));
1 Constraints: is_swappable_v<Container> is true.
2 Effects: As if byx.swap(y).
23.6.4 Class template priority_queue [priority.queue]
23.6.4.1 Overview [priqueue.overview]
1 Any sequence container with random access iterator and supporting operationsfront(), push_back() and
pop_back() can be used to instantiatepriority_queue. In particular,vector (23.3.13) anddeque (23.3.5)
can be used. Instantiating priority_queue also involves supplying a function or function object for
making priority comparisons; the library assumes that the function or function object defines a strict weak
ordering (26.8).
namespace std {
template<class T, class Container = vector<T>,
class Compare = less<typename Container::value_type>>
class priority_queue {
public:
using value_type = Container::value_type;
using reference = Container::reference;
using const_reference = Container::const_reference;
using size_type = Container::size_type;
using container_type = Container;
using value_compare = Compare;
protected:
Container c;
Compare comp;
public:
constexpr priority_queue() : priority_queue(Compare()) {}
constexpr explicit priority_queue(const Compare& x) : priority_queue(x, Container()) {}
constexpr priority_queue(const Compare& x, const Container&);
constexpr priority_queue(const Compare& x, Container&&);
template<class InputIterator>
constexpr priority_queue(InputIterator first, InputIterator last,
const Compare& x = Compare());
template<class InputIterator>
constexpr priority_queue(InputIterator first, InputIterator last, const Compare& x,
const Container&);
template<class InputIterator>
constexpr priority_queue(InputIterator first, InputIterator last, const Compare& x,
Container&&);
template<container-compatible-range <T> R>
constexpr priority_queue(from_range_t, R&& rg, const Compare& x = Compare());
template<class Alloc> constexpr explicit priority_queue(const Alloc&);
§ 23.6.4.1 © ISO/IEC
1071

===== PAGE 1083 =====

Dxxxx
template<class Alloc> constexpr priority_queue(const Compare&, const Alloc&);
template<class Alloc>
constexpr priority_queue(const Compare&, const Container&, const Alloc&);
template<class Alloc> constexpr priority_queue(const Compare&, Container&&, const Alloc&);
template<class Alloc> constexpr priority_queue(const priority_queue&, const Alloc&);
template<class Alloc> constexpr priority_queue(priority_queue&&, const Alloc&);
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator, InputIterator, const Alloc&);
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator, InputIterator, const Compare&, const Alloc&);
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator, InputIterator, const Compare&, const Container&,
const Alloc&);
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator, InputIterator, const Compare&, Container&&,
const Alloc&);
template<container-compatible-range <T> R, class Alloc>
constexpr priority_queue(from_range_t, R&& rg, const Compare&, const Alloc&);
template<container-compatible-range <T> R, class Alloc>
constexpr priority_queue(from_range_t, R&& rg, const Alloc&);
constexpr bool empty() const { return c.empty(); }
constexpr size_type size() const { return c.size(); }
constexpr const_reference top() const { return c.front(); }
constexpr void push(const value_type& x);
constexpr void push(value_type&& x);
template<container-compatible-range <T> R>
constexpr void push_range(R&& rg);
template<class... Args> constexpr void emplace(Args&&... args);
constexpr void pop();
constexpr void swap(priority_queue& q)
noexcept(is_nothrow_swappable_v<Container> && is_nothrow_swappable_v<Compare>)
{ using std::swap; swap(c, q.c); swap(comp, q.comp); }
};
template<class Compare, class Container>
priority_queue(Compare, Container)
-> priority_queue<typename Container::value_type, Container, Compare>;
template<class InputIterator,
class Compare = less<iter-value-type <InputIterator>>,
class Container = vector<iter-value-type <InputIterator>>>
priority_queue(InputIterator, InputIterator, Compare = Compare(), Container = Container())
-> priority_queue<iter-value-type <InputIterator>, Container, Compare>;
template<ranges::input_range R, class Compare = less<ranges::range_value_t<R>>>
priority_queue(from_range_t, R&&, Compare = Compare())
-> priority_queue<ranges::range_value_t<R>, vector<ranges::range_value_t<R>>, Compare>;
template<class Compare, class Container, class Allocator>
priority_queue(Compare, Container, Allocator)
-> priority_queue<typename Container::value_type, Container, Compare>;
template<class InputIterator, class Allocator>
priority_queue(InputIterator, InputIterator, Allocator)
-> priority_queue<iter-value-type <InputIterator>,
vector<iter-value-type <InputIterator>, Allocator>,
less<iter-value-type <InputIterator>>>;
template<class InputIterator, class Compare, class Allocator>
priority_queue(InputIterator, InputIterator, Compare, Allocator)
-> priority_queue<iter-value-type <InputIterator>,
vector<iter-value-type <InputIterator>, Allocator>, Compare>;
§ 23.6.4.1 © ISO/IEC
1072

===== PAGE 1084 =====

Dxxxx
template<class InputIterator, class Compare, class Container, class Allocator>
priority_queue(InputIterator, InputIterator, Compare, Container, Allocator)
-> priority_queue<typename Container::value_type, Container, Compare>;
template<ranges::input_range R, class Compare, class Allocator>
priority_queue(from_range_t, R&&, Compare, Allocator)
-> priority_queue<ranges::range_value_t<R>, vector<ranges::range_value_t<R>, Allocator>,
Compare>;
template<ranges::input_range R, class Allocator>
priority_queue(from_range_t, R&&, Allocator)
-> priority_queue<ranges::range_value_t<R>, vector<ranges::range_value_t<R>, Allocator>>;
// no equality is provided
template<class T, class Container, class Compare, class Alloc>
struct uses_allocator<priority_queue<T, Container, Compare>, Alloc>
: uses_allocator<Container, Alloc>::type { };
}
23.6.4.2 Constructors [priqueue.cons]
constexpr priority_queue(const Compare& x, const Container& y);
constexpr priority_queue(const Compare& x, Container&& y);
1 Preconditions: x defines a strict weak ordering (26.8).
2 Effects: Initializes comp with x and c with y (copy constructing or move constructing as appropriate);
calls make_heap(c.begin(), c.end(), comp).
template<class InputIterator>
constexpr priority_queue(InputIterator first, InputIterator last, const Compare& x = Compare());
3 Preconditions: x defines a strict weak ordering (26.8).
4 Effects: Initializes c with first as the first argument andlast as the second argument, and initializes
comp with x; then callsmake_heap(c.begin(), c.end(), comp).
template<class InputIterator>
constexpr priority_queue(InputIterator first, InputIterator last, const Compare& x,
const Container& y);
template<class InputIterator>
constexpr priority_queue(InputIterator first, InputIterator last, const Compare& x,
Container&& y);
5 Preconditions: x defines a strict weak ordering (26.8).
6 Effects: Initializes comp with x and c with y (copy constructing or move constructing as appropriate);
calls c.insert(c.end(), first, last); and finally callsmake_heap(c.begin(), c.end(), comp).
template<container-compatible-range <T> R>
constexpr priority_queue(from_range_t, R&& rg, const Compare& x = Compare());
7 Preconditions: x defines a strict weak ordering (26.8).
8 Effects: Initializes comp with x and c with ranges::to<Container>(std::forward<R>(rg)) and
finally callsmake_heap(c.begin(), c.end(), comp).
23.6.4.3 Constructors with allocators [priqueue.cons.alloc]
1 If uses_allocator_v<container_type, Alloc> is false the constructors in this subclause shall not par-
ticipate in overload resolution.
template<class Alloc> constexpr explicit priority_queue(const Alloc& a);
2 Effects: Initializes c with a and value-initializescomp.
template<class Alloc> constexpr priority_queue(const Compare& compare, const Alloc& a);
3 Effects: Initializes c with a and initializescomp with compare.
§ 23.6.4.3 © ISO/IEC
1073

===== PAGE 1085 =====

Dxxxx
template<class Alloc>
constexpr priority_queue(const Compare& compare, const Container& cont, const Alloc& a);
4 Effects: Initializes c with cont as the first argument anda as the second argument, and initializescomp
with compare; callsmake_heap(c.begin(), c.end(), comp).
template<class Alloc>
constexpr priority_queue(const Compare& compare, Container&& cont, const Alloc& a);
5 Effects: Initializes c with std::move(cont) as the first argument anda as the second argument, and
initializes comp with compare; callsmake_heap(c.begin(), c.end(), comp).
template<class Alloc> constexpr priority_queue(const priority_queue& q, const Alloc& a);
6 Effects: Initializes c with q.c as the first argument anda as the second argument, and initializescomp
with q.comp.
template<class Alloc> constexpr priority_queue(priority_queue&& q, const Alloc& a);
7 Effects: Initializes c with std::move(q.c) as the first argument anda as the second argument, and
initializes comp with std::move(q.comp).
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator first, InputIterator last, const Alloc& a);
8 Effects: Initializes c with first as the first argument,last as the second argument, anda as the third
argument, and value-initializescomp; callsmake_heap(c.begin(), c.end(), comp).
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator first, InputIterator last,
const Compare& compare, const Alloc& a);
9 Effects: Initializes c with first as the first argument,last as the second argument, anda as the third
argument, and initializescomp with compare; callsmake_heap(c.begin(), c.end(), comp).
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator first, InputIterator last, const Compare& compare,
const Container& cont, const Alloc& a);
10 Effects: Initializes c with cont as the first argument anda as the second argument, and initializes
comp with compare; callsc.insert(c.end(), first, last); and finally callsmake_heap(c.begin(),
c.end(), comp).
template<class InputIterator, class Alloc>
constexpr priority_queue(InputIterator first, InputIterator last, const Compare& compare,
Container&& cont, const Alloc& a);
11 Effects: Initializes c with std::move(cont) as the first argument anda as the second argument,
and initializescomp with compare; callsc.insert(c.end(), first, last); and finally callsmake_-
heap(c.begin(), c.end(), comp).
template<container-compatible-range <T> R, class Alloc>
constexpr priority_queue(from_range_t, R&& rg, const Compare& compare, const Alloc& a);
12 Effects: Initializes comp with compare and c with ranges::to<Container>(std::forward<R>(rg),
a); callsmake_heap(c.begin(), c.end(), comp).
template<container-compatible-range <T> R, class Alloc>
constexpr priority_queue(from_range_t, R&& rg, const Alloc& a);
13 Effects: Initializes c with ranges::to<Container>(std::forward<R>(rg), a) and value-initializes
comp; callsmake_heap(c.begin(), c.end(), comp).
23.6.4.4 Members [priqueue.members]
constexpr void push(const value_type& x);
1 Effects: As if by:
c.push_back(x);
push_heap(c.begin(), c.end(), comp);
§ 23.6.4.4 © ISO/IEC
1074

===== PAGE 1086 =====

Dxxxx
constexpr void push(value_type&& x);
2 Effects: As if by:
c.push_back(std::move(x));
push_heap(c.begin(), c.end(), comp);
template<container-compatible-range <T> R>
constexpr void push_range(R&& rg);
3 Effects: Inserts all elements ofrg in c via c.append_range(std::forward<R>(rg)) if that is a valid
expression, orranges::copy(rg, back_inserter(c)) otherwise. Then restores the heap property as
if bymake_heap(c.begin(), c.end(), comp).
4 Postconditions: is_heap(c.begin(), c.end(), comp) is true.
template<class... Args> constexpr void emplace(Args&&... args);
5 Effects: As if by:
c.emplace_back(std::forward<Args>(args)...);
push_heap(c.begin(), c.end(), comp);
constexpr void pop();
6 Effects: As if by:
pop_heap(c.begin(), c.end(), comp);
c.pop_back();
23.6.4.5 Specialized algorithms [priqueue.special]
template<class T, class Container, class Compare>
constexpr void swap(priority_queue<T, Container, Compare>& x,
priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));
1 Constraints: is_swappable_v<Container> is true and is_swappable_v<Compare> is true.
2 Effects: As if byx.swap(y).
23.6.5 Header <stack> synopsis [stack.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.6.6, class templatestack
template<class T, class Container = deque<T>> class stack;
template<class T, class Container>
constexpr bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
template<class T, class Container>
constexpr bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
template<class T, class Container>
constexpr bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
template<class T, class Container>
constexpr bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
template<class T, class Container>
constexpr bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);
template<class T, class Container>
constexpr bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
template<class T, three_way_comparable Container>
constexpr compare_three_way_result_t<Container>
operator<=>(const stack<T, Container>& x, const stack<T, Container>& y);
template<class T, class Container>
constexpr void swap(stack<T, Container>& x, stack<T, Container>& y)
noexcept(noexcept(x.swap(y)));
template<class T, class Container, class Alloc>
struct uses_allocator<stack<T, Container>, Alloc>;
§ 23.6.5 © ISO/IEC
1075

===== PAGE 1087 =====

Dxxxx
// 23.6.13, formatter specialization forstack
template<class charT, class T, formattable<charT> Container>
struct formatter<stack<T, Container>, charT>;
template<class T, class Container>
constexpr bool enable_nonlocking_formatter_optimization<stack<T, Container>> = false;
}
23.6.6 Class template stack [stack]
23.6.6.1 General [stack.general]
1 Any sequence container supporting operationsback(), push_back() and pop_back() can be used to instan-
tiate stack. In particular,vector (23.3.13), list (23.3.11) anddeque (23.3.5) can be used.
23.6.6.2 Definition [stack.defn]
namespace std {
template<class T, class Container = deque<T>>
class stack {
public:
using value_type = Container::value_type;
using reference = Container::reference;
using const_reference = Container::const_reference;
using size_type = Container::size_type;
using container_type = Container;
protected:
Container c;
public:
constexpr stack() : stack(Container()) {}
constexpr explicit stack(const Container&);
constexpr explicit stack(Container&&);
template<class InputIterator> constexpr stack(InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr stack(from_range_t, R&& rg);
template<class Alloc> constexpr explicit stack(const Alloc&);
template<class Alloc> constexpr stack(const Container&, const Alloc&);
template<class Alloc> constexpr stack(Container&&, const Alloc&);
template<class Alloc> constexpr stack(const stack&, const Alloc&);
template<class Alloc> constexpr stack(stack&&, const Alloc&);
template<class InputIterator, class Alloc>
constexpr stack(InputIterator first, InputIterator last, const Alloc&);
template<container-compatible-range <T> R, class Alloc>
constexpr stack(from_range_t, R&& rg, const Alloc&);
constexpr bool empty() const { return c.empty(); }
constexpr size_type size() const { return c.size(); }
constexpr reference top() { return c.back(); }
constexpr const_reference top() const { return c.back(); }
constexpr void push(const value_type& x) { c.push_back(x); }
constexpr void push(value_type&& x) { c.push_back(std::move(x)); }
template<container-compatible-range <T> R>
constexpr void push_range(R&& rg);
template<class... Args>
constexpr decltype(auto) emplace(Args&&... args)
{ return c.emplace_back(std::forward<Args>(args)...); }
constexpr void pop() { c.pop_back(); }
constexpr void swap(stack& s) noexcept(is_nothrow_swappable_v<Container>)
{ using std::swap; swap(c, s.c); }
};
template<class Container>
stack(Container) -> stack<typename Container::value_type, Container>;
§ 23.6.6.2 © ISO/IEC
1076

===== PAGE 1088 =====

Dxxxx
template<class InputIterator>
stack(InputIterator, InputIterator) -> stack<iter-value-type <InputIterator>>;
template<ranges::input_range R>
stack(from_range_t, R&&) -> stack<ranges::range_value_t<R>>;
template<class Container, class Allocator>
stack(Container, Allocator) -> stack<typename Container::value_type, Container>;
template<class InputIterator, class Allocator>
stack(InputIterator, InputIterator, Allocator)
-> stack<iter-value-type <InputIterator>, deque<iter-value-type <InputIterator>,
Allocator>>;
template<ranges::input_range R, class Allocator>
stack(from_range_t, R&&, Allocator)
-> stack<ranges::range_value_t<R>, deque<ranges::range_value_t<R>, Allocator>>;
template<class T, class Container, class Alloc>
struct uses_allocator<stack<T, Container>, Alloc>
: uses_allocator<Container, Alloc>::type { };
}
23.6.6.3 Constructors [stack.cons]
constexpr explicit stack(const Container& cont);
1 Effects: Initializes c with cont.
constexpr explicit stack(Container&& cont);
2 Effects: Initializes c with std::move(cont).
template<class InputIterator>
constexpr stack(InputIterator first, InputIterator last);
3 Effects: Initializes c with first as the first argument andlast as the second argument.
template<container-compatible-range <T> R>
constexpr stack(from_range_t, R&& rg);
4 Effects: Initializes c with ranges::to<Container>(std::forward<R>(rg)).
23.6.6.4 Constructors with allocators [stack.cons.alloc]
1 If uses_allocator_v<container_type, Alloc> is false the constructors in this subclause shall not par-
ticipate in overload resolution.
template<class Alloc> constexpr explicit stack(const Alloc& a);
2 Effects: Initializes c with a.
template<class Alloc> constexpr stack(const container_type& cont, const Alloc& a);
3 Effects: Initializes c with cont as the first argument anda as the second argument.
template<class Alloc> constexpr stack(container_type&& cont, const Alloc& a);
4 Effects: Initializes c with std::move(cont) as the first argument anda as the second argument.
template<class Alloc> constexpr stack(const stack& s, const Alloc& a);
5 Effects: Initializes c with s.c as the first argument anda as the second argument.
template<class Alloc> constexpr stack(stack&& s, const Alloc& a);
6 Effects: Initializes c with std::move(s.c) as the first argument anda as the second argument.
§ 23.6.6.4 © ISO/IEC
1077

===== PAGE 1089 =====

Dxxxx
template<class InputIterator, class Alloc>
constexpr stack(InputIterator first, InputIterator last, const Alloc& alloc);
7 Effects: Initializes c with first as the first argument,last as the second argument, andalloc as the
third argument.
template<container-compatible-range <T> R, class Alloc>
constexpr stack(from_range_t, R&& rg, const Alloc& a);
8 Effects: Initializes c with ranges::to<Container>(std::forward<R>(rg), a).
23.6.6.5 Modifiers [stack.mod]
template<container-compatible-range <T> R>
constexpr void push_range(R&& rg);
1 Effects: Equivalent toc.append_range(std::forward<R>(rg)) if that is a valid expression, otherwise
ranges::copy(rg, back_inserter(c)).
23.6.6.6 Operators [stack.ops]
template<class T, class Container>
constexpr bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
1 Returns: x.c == y.c.
template<class T, class Container>
constexpr bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
2 Returns: x.c != y.c.
template<class T, class Container>
constexpr bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
3 Returns: x.c < y.c.
template<class T, class Container>
constexpr bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
4 Returns: x.c > y.c.
template<class T, class Container>
constexpr bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);
5 Returns: x.c <= y.c.
template<class T, class Container>
constexpr bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
6 Returns: x.c >= y.c.
template<class T, three_way_comparable Container>
constexpr compare_three_way_result_t<Container>
operator<=>(const stack<T, Container>& x, const stack<T, Container>& y);
7 Returns: x.c <=> y.c.
23.6.6.7 Specialized algorithms [stack.special]
template<class T, class Container>
constexpr void swap(stack<T, Container>& x, stack<T, Container>& y)
noexcept(noexcept(x.swap(y)));
1 Constraints: is_swappable_v<Container> is true.
2 Effects: As if byx.swap(y).
23.6.7 Header <flat_map> synopsis [flat.map.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
§ 23.6.7 © ISO/IEC
1078

===== PAGE 1090 =====

Dxxxx
namespace std {
// 23.6.8, class templateflat_map
template<class Key, class T, class Compare = less<Key>,
class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
class flat_map;
struct sorted_unique_t { explicit sorted_unique_t() = default; };
inline constexpr sorted_unique_t sorted_unique{};
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Allocator>
struct uses_allocator<flat_map<Key, T, Compare, KeyContainer, MappedContainer>,
Allocator>;
// 23.6.8.8, erasure forflat_map
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Predicate>
constexpr typename flat_map<Key, T, Compare, KeyContainer, MappedContainer>::size_type
erase_if(flat_map<Key, T, Compare, KeyContainer, MappedContainer>& c, Predicate pred);
// 23.6.9, class templateflat_multimap
template<class Key, class T, class Compare = less<Key>,
class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
class flat_multimap;
struct sorted_equivalent_t { explicit sorted_equivalent_t() = default; };
inline constexpr sorted_equivalent_t sorted_equivalent{};
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Allocator>
struct uses_allocator<flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>,
Allocator>;
// 23.6.9.5, erasure forflat_multimap
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Predicate>
constexpr typename flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>::size_type
erase_if(flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& c, Predicate pred);
}
23.6.8 Class template flat_map [flat.map]
23.6.8.1 Overview [flat.map.overview]
1 A flat_map is a container adaptor that provides an associative container interface that supports unique keys
(i.e., contains at most one of each key value) and provides for fast retrieval of values of another typeT based
on the keys.flat_map supports iterators that meet theCpp17InputIterator requirements and model the
random_access_iterator concept (24.3.4.13).
2 A flat_map meets all of the requirements of a container (23.2.2.2) and of a reversible container (23.2.2.3),
plus the optional container requirements (23.2.2.4).flat_map meets the requirements of an associative
container (23.2.7), except that:
—(2.1) it does not meet the requirements related to node handles (23.2.5),
—(2.2) it does not meet the requirements related to iterator invalidation, and
—(2.3) the time complexity of the operations that insert or erase a single element from the map is linear,
including the ones that take an insertion position iterator.
[Note 1: A flat_map does not meet the additional requirements of an allocator-aware container (23.2.2.5).—end
note]
3 A flat_map also provides most operations described in 23.2.7 for unique keys. This means that aflat_map
supports thea_uniqoperations in 23.2.7 but not thea_eqoperations. For aflat_map<Key, T>the key_type
is Key and thevalue_type is pair<Key, T>.
§ 23.6.8.1 © ISO/IEC
1079

===== PAGE 1091 =====

Dxxxx
4 Descriptions are provided here only for operations onflat_map that are not described in one of those sets of
requirements or for operations where there is additional semantic information.
5 A flat_map maintains the following invariants:
—(5.1) it contains the same number of keys and values;
—(5.2) the keys are sorted with respect to the comparison object; and
—(5.3) the value at offsetoff within the value container is the value associated with the key at offsetoff
within the key container.
6 If any member function in 23.6.8.2 exits via an exception the invariants of the object argument are restored.
For the move constructor and move assignment operator, the invariants of both arguments are restored.
[Note 2: This can result in theflat_map being emptied. —end note]
7 Any typeC that meets the sequence container requirements (23.2.4) can be used to instantiateflat_map,
as long asC::iterator meets theCpp17RandomAccessIteratorrequirements and invocations of member
functions C::size and C::max_size do not exit via an exception. In particular,vector (23.3.13) and
deque (23.3.5) can be used.
[Note 3: vector<bool> is not a sequence container.—end note]
8 The program is ill-formed ifKey is not the same type asKeyContainer::value_type or T is not the same
type asMappedContainer::value_type.
9 The effect of calling a constructor that takes bothkey_container_type and mapped_container_type
arguments with containers of different sizes is undefined.
10 The effect of calling a member function that takes asorted_unique_t argument with a container, containers,
or range that is not sorted with respect tokey_comp(), or that contains equal elements, is undefined.
11 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
23.6.8.2 Definition [flat.map.defn]
namespace std {
template<class Key, class T, class Compare = less<Key>,
class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
class flat_map {
public:
// types
using key_type = Key;
using mapped_type = T;
using value_type = pair<key_type, mapped_type>;
using key_compare = Compare;
using reference = pair<const key_type&, mapped_type&>;
using const_reference = pair<const key_type&, const mapped_type&>;
using size_type = size_t;
using difference_type = ptrdiff_t;
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using key_container_type = KeyContainer;
using mapped_container_type = MappedContainer;
class value_compare {
private:
key_compare comp ; // exposition only
constexpr value_compare(key_compare c) : comp (c) { } // exposition only
public:
constexpr bool operator()(const_reference x, const_reference y) const {
return comp (x.first, y.first);
}
};
§ 23.6.8.2 © ISO/IEC
1080

===== PAGE 1092 =====

Dxxxx
struct containers {
key_container_type keys;
mapped_container_type values;
};
// 23.6.8.3, constructors
constexpr flat_map() : flat_map(key_compare()) { }
constexpr flat_map(const flat_map&);
constexpr flat_map(flat_map&&);
constexpr flat_map& operator=(const flat_map&);
constexpr flat_map& operator=(flat_map&&);
constexpr explicit flat_map(const key_compare& comp)
: c (), compare (comp) { }
constexpr flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
constexpr flat_map(sorted_unique_t, key_container_type key_cont,
mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
template<class InputIterator>
constexpr flat_map(InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (), compare (comp) { insert(first, last); }
template<class InputIterator>
constexpr flat_map(sorted_unique_t, InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (), compare (comp) { insert(sorted_unique, first, last); }
template<container-compatible-range <value_type> R>
constexpr flat_map(from_range_t, R&& rg)
: flat_map(from_range, std::forward<R>(rg), key_compare()) { }
template<container-compatible-range <value_type> R>
constexpr flat_map(from_range_t, R&& rg, const key_compare& comp)
: flat_map(comp) { insert_range(std::forward<R>(rg)); }
constexpr flat_map(initializer_list<value_type> il, const key_compare& comp = key_compare())
: flat_map(il.begin(), il.end(), comp) { }
constexpr flat_map(sorted_unique_t, initializer_list<value_type> il,
const key_compare& comp = key_compare())
: flat_map(sorted_unique, il.begin(), il.end(), comp) { }
// 23.6.8.4, constructors with allocators
template<class Alloc>
constexpr explicit flat_map(const Alloc& a);
template<class Alloc>
constexpr flat_map(const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_map(const key_container_type& key_cont,
const mapped_container_type& mapped_cont,
const Alloc& a);
template<class Alloc>
constexpr flat_map(const key_container_type& key_cont,
const mapped_container_type& mapped_cont,
const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_map(sorted_unique_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const Alloc& a);
§ 23.6.8.2 © ISO/IEC
1081

===== PAGE 1093 =====

Dxxxx
template<class Alloc>
constexpr flat_map(sorted_unique_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_map(const flat_map&, const Alloc& a);
template<class Alloc>
constexpr flat_map(flat_map&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(sorted_unique_t, InputIterator first, InputIterator last,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(sorted_unique_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_map(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_map(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_map(initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_map(initializer_list<value_type> il, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_map(sorted_unique_t, initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_map(sorted_unique_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
constexpr flat_map& operator=(initializer_list<value_type>);
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// 23.6.8.5, capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.6.8.6, element access
constexpr mapped_type& operator[](const key_type& x);
constexpr mapped_type& operator[](key_type&& x);
template<class K> constexpr mapped_type& operator[](K&& x);
constexpr mapped_type& at(const key_type& x);
constexpr const mapped_type& at(const key_type& x) const;
template<class K> constexpr mapped_type& at(const K& x);
§ 23.6.8.2 © ISO/IEC
1082

===== PAGE 1094 =====

Dxxxx
template<class K> constexpr const mapped_type& at(const K& x) const;
// 23.6.8.7, modifiers
template<class... Args> constexpr pair<iterator, bool> emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr pair<iterator, bool> insert(const value_type& x)
{ return emplace(x); }
constexpr pair<iterator, bool> insert(value_type&& x)
{ return emplace(std::move(x)); }
constexpr iterator insert(const_iterator position, const value_type& x)
{ return emplace_hint(position, x); }
constexpr iterator insert(const_iterator position, value_type&& x)
{ return emplace_hint(position, std::move(x)); }
template<class P> constexpr pair<iterator, bool> insert(P&& x);
template<class P>
constexpr iterator insert(const_iterator position, P&&);
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<class InputIterator>
constexpr void insert(sorted_unique_t, InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
template<container-compatible-range <value_type> R>
constexpr void insert_range(sorted_unique_t, R&& rg);
constexpr void insert(initializer_list<value_type> il)
{ insert(il.begin(), il.end()); }
constexpr void insert(sorted_unique_t, initializer_list<value_type> il)
{ insert(sorted_unique, il.begin(), il.end()); }
constexpr containers extract() &&;
constexpr void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);
template<class... Args>
constexpr pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
constexpr pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class K, class... Args>
constexpr pair<iterator, bool> try_emplace(K&& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
template<class K, class... Args>
constexpr iterator try_emplace(const_iterator hint, K&& k, Args&&... args);
template<class M>
constexpr pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
constexpr pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class K, class M>
constexpr pair<iterator, bool> insert_or_assign(K&& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
template<class K, class M>
constexpr iterator insert_or_assign(const_iterator hint, K&& k, M&& obj);
constexpr iterator erase(iterator position);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
§ 23.6.8.2 © ISO/IEC
1083

===== PAGE 1095 =====

Dxxxx
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(flat_map& y) noexcept(see below );
constexpr void clear() noexcept;
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
constexpr const key_container_type& keys() const noexcept { return c .keys; }
constexpr const mapped_container_type& values() const noexcept { return c .values; }
// map operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K> constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
friend constexpr bool operator==(const flat_map& x, const flat_map& y);
friend constexpr synth-three-way-result <value_type>
operator<=>(const flat_map& x, const flat_map& y);
friend constexpr void swap(flat_map& x, flat_map& y) noexcept(noexcept(x.swap(y)))
{ x.swap(y); }
private:
containers c ; // exposition only
key_compare compare ; // exposition only
struct key-equiv { // exposition only
constexpr key-equiv (key_compare c) : comp(c) { }
constexpr bool operator()(const_reference x, const_reference y) const {
return !comp(x.first, y.first) && !comp(y.first, x.first);
}
key_compare comp;
};
};
§ 23.6.8.2 © ISO/IEC
1084

===== PAGE 1096 =====

Dxxxx
template<class KeyContainer, class MappedContainer,
class Compare = less<typename KeyContainer::value_type>>
flat_map(KeyContainer, MappedContainer, Compare = Compare())
-> flat_map<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Allocator>
flat_map(KeyContainer, MappedContainer, Allocator)
-> flat_map<typename KeyContainer::value_type, typename MappedContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Compare, class Allocator>
flat_map(KeyContainer, MappedContainer, Compare, Allocator)
-> flat_map<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer,
class Compare = less<typename KeyContainer::value_type>>
flat_map(sorted_unique_t, KeyContainer, MappedContainer, Compare = Compare())
-> flat_map<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Allocator>
flat_map(sorted_unique_t, KeyContainer, MappedContainer, Allocator)
-> flat_map<typename KeyContainer::value_type, typename MappedContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Compare, class Allocator>
flat_map(sorted_unique_t, KeyContainer, MappedContainer, Compare, Allocator)
-> flat_map<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class InputIterator, class Compare = less<iter-key-type <InputIterator>>>
flat_map(InputIterator, InputIterator, Compare = Compare())
-> flat_map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Compare>;
template<class InputIterator, class Compare = less<iter-key-type <InputIterator>>>
flat_map(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
-> flat_map<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Compare>;
template<ranges::input_range R, class Compare = less<range-key-type <R>>,
class Allocator = allocator<byte>>
flat_map(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> flat_map<range-key-type <R>, range-mapped-type <R>, Compare,
vector<range-key-type <R>, alloc-rebind <Allocator, range-key-type <R>>>,
vector<range-mapped-type <R>, alloc-rebind <Allocator, range-mapped-type <R>>>>;
template<ranges::input_range R, class Allocator>
flat_map(from_range_t, R&&, Allocator)
-> flat_map<range-key-type <R>, range-mapped-type <R>, less<range-key-type <R>>,
vector<range-key-type <R>, alloc-rebind <Allocator, range-key-type <R>>>,
vector<range-mapped-type <R>, alloc-rebind <Allocator, range-mapped-type <R>>>>;
template<class Key, class T, class Compare = less<Key>>
flat_map(initializer_list<pair<Key, T>>, Compare = Compare())
-> flat_map<Key, T, Compare>;
template<class Key, class T, class Compare = less<Key>>
flat_map(sorted_unique_t, initializer_list<pair<Key, T>>, Compare = Compare())
-> flat_map<Key, T, Compare>;
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Allocator>
struct uses_allocator<flat_map<Key, T, Compare, KeyContainer, MappedContainer>, Allocator>
: bool_constant<uses_allocator_v<KeyContainer, Allocator> &&
uses_allocator_v<MappedContainer, Allocator>> { };
§ 23.6.8.2 © ISO/IEC
1085

===== PAGE 1097 =====

Dxxxx
}
1 The member typecontainers has the data members and special members specified above. It has no base
classes or members other than those specified.
23.6.8.3 Constructors [flat.map.cons]
constexpr flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
1 Effects: Initializes c .keys with std::move(key_cont), c .values with std::move(mapped_cont),
and compare with comp; sorts the range[begin(),end()) with respect tovalue_comp(); and finally
erases the duplicate elements as if by:
auto zv = views::zip(c .keys, c .values);
auto it = ranges::unique(zv, key-equiv (compare )).begin();
auto dist = distance(zv.begin(), it);
c .keys.erase(c .keys.begin() + dist, c .keys.end());
c .values.erase(c .values.begin() + dist, c .values.end());
2 Complexity: Linear inN if the container arguments are already sorted with respect tovalue_comp()
and otherwiseNlog N, whereN is the value ofkey_cont.size() before this call.
constexpr flat_map(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
3 Effects: Initializes c .keys with std::move(key_cont), c .values with std::move(mapped_cont),
and compare with comp.
4 Complexity: Constant.
23.6.8.4 Constructors with allocators [flat.map.cons.alloc]
1 The constructors in this subclause shall not participate in overload resolution unlessuses_allocator_v<key_-
container_type, Alloc> is true and uses_allocator_v<mapped_container_type, Alloc> is true.
template<class Alloc>
constexpr flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,
const Alloc& a);
template<class Alloc>
constexpr flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,
const key_compare& comp, const Alloc& a);
2 Effects: Equivalent toflat_map(key_cont, mapped_cont) and flat_map(key_cont, mapped_cont,
comp), respectively, except thatc .keys and c .values are constructed with uses-allocator construction
(20.2.8.2).
3 Complexity: Same asflat_map(key_cont, mapped_cont) and flat_map(key_cont, mapped_cont,
comp), respectively.
template<class Alloc>
constexpr flat_map(sorted_unique_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const Alloc& a);
template<class Alloc>
constexpr flat_map(sorted_unique_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const key_compare& comp,
const Alloc& a);
4 Effects: Equivalent toflat_map(sorted_unique, key_cont, mapped_cont)and flat_map(sorted_-
unique, key_cont,
mapped_cont, comp), respectively, except that c .keys and c .values are constructed with uses-
allocator construction (20.2.8.2).
5 Complexity: Linear.
template<class Alloc>
constexpr explicit flat_map(const Alloc& a);
template<class Alloc>
constexpr flat_map(const key_compare& comp, const Alloc& a);
§ 23.6.8.4 © ISO/IEC
1086

===== PAGE 1098 =====

Dxxxx
template<class Alloc>
constexpr flat_map(const flat_map&, const Alloc& a);
template<class Alloc>
constexpr flat_map(flat_map&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(InputIterator first, InputIterator last, const key_compare& comp,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_map(sorted_unique_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_map(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_map(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_map(initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_map(initializer_list<value_type> il, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_map(sorted_unique_t, initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_map(sorted_unique_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
6 Effects: Equivalent to the corresponding non-allocator constructors except thatc .keys and c .values
are constructed with uses-allocator construction (20.2.8.2).
23.6.8.5 Capacity [flat.map.capacity]
constexpr size_type size() const noexcept;
1 Returns: c .keys.size().
constexpr size_type max_size() const noexcept;
2 Returns: min<size_type>(c .keys.max_size(), c .values.max_size()).
23.6.8.6 Access [flat.map.access]
constexpr mapped_type& operator[](const key_type& x);
1 Effects: Equivalent to:return try_emplace(x).first->second;
constexpr mapped_type& operator[](key_type&& x);
2 Effects: Equivalent to:return try_emplace(std::move(x)).first->second;
template<class K> constexpr mapped_type& operator[](K&& x);
3 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type.
4 Effects: Equivalent to:return try_emplace(std::forward<K>(x)).first->second;
constexpr mapped_type& at(const key_type& x);
constexpr const mapped_type& at(const key_type& x) const;
5 Returns: A reference to themapped_type corresponding tox in *this.
6 Throws: An exception object of typeout_of_range if no such element is present.
7 Complexity: Logarithmic.
template<class K> constexpr mapped_type& at(const K& x);
template<class K> constexpr const mapped_type& at(const K& x) const;
8 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type.
9 Preconditions: The expressionfind(x) is well-formed and has well-defined behavior.
§ 23.6.8.6 © ISO/IEC
1087

===== PAGE 1099 =====

Dxxxx
10 Returns: A reference to themapped_type corresponding tox in *this.
11 Throws: An exception object of typeout_of_range if no such element is present.
12 Complexity: Logarithmic.
23.6.8.7 Modifiers [flat.map.modifiers]
template<class... Args> constexpr pair<iterator, bool> emplace(Args&&... args);
1 Constraints: is_constructible_v<pair<key_type, mapped_type>, Args...> is true.
2 Effects: Initializes an objectt of typepair<key_type, mapped_type> with std::forward<Args>(
args)...; if the map already contains an element whose key is equivalent tot.first, *this is
unchanged. Otherwise, equivalent to:
auto key_it = ranges::upper_bound(c .keys, t.first, compare );
auto value_it = c .values.begin() + distance(c .keys.begin(), key_it);
c .keys.insert(key_it, std::move(t.first));
c .values.insert(value_it, std::move(t.second));
3 Returns: The bool component of the returned pair istrue if and only if the insertion took place, and
the iterator component of the pair points to the element with key equivalent tot.first.
template<class P> constexpr pair<iterator, bool> insert(P&& x);
template<class P> constexpr iterator insert(const_iterator position, P&& x);
4 Constraints: is_constructible_v<pair<key_type, mapped_type>, P> is true.
5 Effects: The first form is equivalent toreturn emplace(std::forward<P>(x));. The second form is
equivalent toreturn emplace_hint(position, std::forward<P>(x));.
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
6 Effects: Adds elements toc as if by:
for (; first != last; ++first) {
value_type value = *first;
c .keys.insert(c .keys.end(), std::move(value.first));
c .values.insert(c .values.end(), std::move(value.second));
}
Then, sorts the range of newly inserted elements with respect tovalue_comp(); merges the resulting
sorted range and the sorted range of pre-existing elements into a single sorted range; and finally erases
the duplicate elements as if by:
auto zv = views::zip(c .keys, c .values);
auto it = ranges::unique(zv, key-equiv (compare )).begin();
auto dist = distance(zv.begin(), it);
c .keys.erase(c .keys.begin() + dist, c .keys.end());
c .values.erase(c .values.begin() + dist, c .values.end());
7 Complexity: N + Mlog M, where N is size() before the operation and M is distance(first,
last).
8 Remarks: Since this operation performs an in-place merge, it may allocate memory.
template<class InputIterator>
constexpr void insert(sorted_unique_t, InputIterator first, InputIterator last);
9 Effects: Equivalent toinsert(first, last).
10 Complexity: Linear inN, whereN is size() after the operation.
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
11 Effects: Adds elements toc as if by:
ranges::for_each(rg, [&](value_type e) {
c .keys.insert(c .keys.end(), std::move(e.first));
c .values.insert(c .values.end(), std::move(e.second));
});
§ 23.6.8.7 © ISO/IEC
1088

===== PAGE 1100 =====

Dxxxx
Then, sorts the range of newly inserted elements with respect tovalue_comp(); merges the resulting
sorted range and the sorted range of pre-existing elements into a single sorted range; and finally erases
the duplicate elements as if by:
auto zv = views::zip(c .keys, c .values);
auto it = ranges::unique(zv, key-equiv (compare )).begin();
auto dist = distance(zv.begin(), it);
c .keys.erase(c .keys.begin() + dist, c .keys.end());
c .values.erase(c .values.begin() + dist, c .values.end());
12 Complexity: N + Mlog M, whereN is size() before the operation andM is ranges::distance(rg).
13 Remarks: Since this operation performs an in-place merge, it may allocate memory.
template<container-compatible-range <value_type> R>
constexpr void insert_range(sorted_unique_t, R&& rg);
14 Effects: Equivalent toinsert_range(rg).
15 Complexity: Linear inN, whereN is size() after the operation.
template<class... Args>
constexpr pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
constexpr pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template<class... Args>
constexpr iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
16 Constraints: is_constructible_v<mapped_type, Args...> is true.
17 Effects: If the map already contains an element whose key is equivalent tok, *this and args... are
unchanged. Otherwise equivalent to:
auto key_it = ranges::upper_bound(c .keys, k, compare );
auto value_it = c .values.begin() + distance(c .keys.begin(), key_it);
c .keys.insert(key_it, std::forward<decltype(k)>(k));
c .values.emplace(value_it, std::forward<Args>(args)...);
18 Returns: In the first two overloads, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
19 Complexity: The same asemplace for the first two overloads, and the same asemplace_hint for the
last two overloads.
template<class K, class... Args>
constexpr pair<iterator, bool> try_emplace(K&& k, Args&&... args);
template<class K, class... Args>
constexpr iterator try_emplace(const_iterator hint, K&& k, Args&&... args);
20 Constraints:
—(20.1) The qualified-id Compare::is_transparent is valid and denotes a type.
—(20.2) is_constructible_v<key_type, K> is true.
—(20.3) is_constructible_v<mapped_type, Args...> is true.
—(20.4) For the first overload,is_convertible_v<K&&, const_iterator> and is_convertible_v<K&&,
iterator> are bothfalse.
21 Preconditions: The conversion fromk into key_type constructs an objectu, for whichfind(k) ==
find(u) is true.
22 Effects: If the map already contains an element whose key is equivalent tok, *this and args... are
unchanged. Otherwise equivalent to:
auto key_it = upper_bound(c .keys.begin(), c .keys.end(), k, compare );
auto value_it = c .values.begin() + distance(c .keys.begin(), key_it);
c .keys.emplace(key_it, std::forward<K>(k));
c .values.emplace(value_it, std::forward<Args>(args)...);
§ 23.6.8.7 © ISO/IEC
1089

===== PAGE 1101 =====

Dxxxx
23 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
24 Complexity: The same asemplace and emplace_hint, respectively.
template<class M>
constexpr pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
constexpr pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template<class M>
constexpr iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
25 Constraints: is_assignable_v<mapped_type&, M> is true and is_constructible_v<mapped_type,
M> is true.
26 Effects: If the map already contains an elemente whose key is equivalent tok, assignsstd::forward<
M>(obj) to e.second. Otherwise, equivalent to
try_emplace(std::forward<decltype(k)>(k), std::forward<M>(obj))
for the first two overloads or
try_emplace(hint, std::forward<decltype(k)>(k), std::forward<M>(obj))
for the last two overloads.
27 Returns: In the first two overloads, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
28 Complexity: The same asemplace for the first two overloads and the same asemplace_hint for the
last two overloads.
template<class K, class M>
constexpr pair<iterator, bool> insert_or_assign(K&& k, M&& obj);
template<class K, class M>
constexpr iterator insert_or_assign(const_iterator hint, K&& k, M&& obj);
29 Constraints:
—(29.1) The qualified-id Compare::is_transparent is valid and denotes a type.
—(29.2) is_constructible_v<key_type, K> is true.
—(29.3) is_assignable_v<mapped_type&, M> is true.
—(29.4) is_constructible_v<mapped_type, M> is true.
30 Preconditions: The conversion fromk into key_type constructs an objectu, for whichfind(k) ==
find(u) is true.
31 Effects: If the map already contains an elemente whose key is equivalent tok, assignsstd::forward<
M>(obj) to e.second. Otherwise, equivalent to
try_emplace(std::forward<K>(k), std::forward<M>(obj))
for the first overload or
try_emplace(hint, std::forward<K>(k), std::forward<M>(obj))
for the second overload.
32 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the map element whose key is equivalent tok.
33 Complexity: The same asemplace and emplace_hint, respectively.
constexpr void swap(flat_map& y)
noexcept(is_nothrow_swappable_v<key_container_type> &&
is_nothrow_swappable_v<mapped_container_type> &&
is_nothrow_swappable_v<key_compare>);
34 Effects: Equivalent to:
ranges::swap(compare , y.compare );
ranges::swap(c .keys, y.c .keys);
§ 23.6.8.7 © ISO/IEC
1090

===== PAGE 1102 =====

Dxxxx
ranges::swap(c .values, y.c .values);
constexpr containers extract() &&;
35 Postconditions: *this is emptied, even if the function exits via an exception.
36 Returns: std::move(c ).
constexpr void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);
37 Preconditions: key_cont.size() == mapped_cont.size() is true, the elements of key_cont are
sorted with respect tocompare , andkey_cont contains no equal elements.
38 Effects: Equivalent to:
c .keys = std::move(key_cont);
c .values = std::move(mapped_cont);
23.6.8.8 Erasure [flat.map.erasure]
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Predicate>
constexpr typename flat_map<Key, T, Compare, KeyContainer, MappedContainer>::size_type
erase_if(flat_map<Key, T, Compare, KeyContainer, MappedContainer>& c, Predicate pred);
1 Preconditions: Key and T meet theCpp17MoveAssignable requirements.
2 Effects: Let E be bool(pred(pair<const Key&, const T&>(e))). Erases all elements e in c for
which E holds.
3 Returns: The number of elements erased.
4 Complexity: Exactly c.size() applications of the predicate.
5 Remarks: Stable (16.4.6.8). If an invocation oferase_if exits via an exception,c is in a valid but
unspecified state (3.67).
[Note 1: c still meets its invariants, but can be empty.—end note]
23.6.9 Class template flat_multimap [flat.multimap]
23.6.9.1 Overview [flat.multimap.overview]
1 A flat_multimap is a container adaptor that provides an associative container interface that supports
equivalent keys (i.e., possibly containing multiple copies of the same key value) and provides for fast
retrieval of values of another typeT based on the keys.flat_multimap supports iterators that meet the
Cpp17InputIterator requirements and model therandom_access_iterator concept (24.3.4.13).
2 A flat_multimap meets all of the requirements for a container (23.2.2.2) and for a reversible container
(23.2.2.3), plus the optional container requirements (23.2.2.4).flat_multimap meets the requirements of an
associative container (23.2.7), except that:
—(2.1) it does not meet the requirements related to node handles (23.2.5),
—(2.2) it does not meet the requirements related to iterator invalidation, and
—(2.3) the time complexity of the operations that insert or erase a single element from the map is linear,
including the ones that take an insertion position iterator.
[Note 1: A flat_multimap does not meet the additional requirements of an allocator-aware container (23.2.2.5).
—end note]
3 A flat_multimap also provides most operations described in 23.2.7 for equal keys. This means that aflat_-
multimap supports thea_eq operations in 23.2.7 but not thea_uniq operations. For aflat_multimap<Key,
T> the key_type is Key and thevalue_type is pair<Key, T>.
4 Except as otherwise noted, operations onflat_multimap are equivalent to those offlat_map, except that
flat_multimap operations do not remove or replace elements with equal keys.
[Example 1: flat_multimap constructors and emplace do not erase non-unique elements after sorting them.—end
example]
5 A flat_multimap maintains the following invariants:
—(5.1) it contains the same number of keys and values;
—(5.2) the keys are sorted with respect to the comparison object; and
§ 23.6.9.1 © ISO/IEC
1091

===== PAGE 1103 =====

Dxxxx
—(5.3) the value at offsetoff within the value container is the value associated with the key at offsetoff
within the key container.
6 If any member function in 23.6.9.2 exits via an exception, the invariants of the object argument are restored.
For the move constructor and move assignment operator, the invariants of both arguments are restored.
[Note 2: This can result in theflat_multimap being emptied. —end note]
7 Any typeCthat meets the sequence container requirements (23.2.4) can be used to instantiateflat_multimap,
as long asC::iterator meets theCpp17RandomAccessIteratorrequirements and invocations of member
functions C::size and C::max_size do not exit via an exception. In particular,vector (23.3.13) and
deque (23.3.5) can be used.
[Note 3: vector<bool> is not a sequence container.—end note]
8 The program is ill-formed ifKey is not the same type asKeyContainer::value_type or T is not the same
type asMappedContainer::value_type.
9 The effect of calling a constructor that takes bothkey_container_type and mapped_container_type
arguments with containers of different sizes is undefined.
10 The effect of calling a member function that takes asorted_equivalent_t argument with a container,
containers, or range that are not sorted with respect tokey_comp() is undefined.
11 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
23.6.9.2 Definition [flat.multimap.defn]
namespace std {
template<class Key, class T, class Compare = less<Key>,
class KeyContainer = vector<Key>, class MappedContainer = vector<T>>
class flat_multimap {
public:
// types
using key_type = Key;
using mapped_type = T;
using value_type = pair<key_type, mapped_type>;
using key_compare = Compare;
using reference = pair<const key_type&, mapped_type&>;
using const_reference = pair<const key_type&, const mapped_type&>;
using size_type = size_t;
using difference_type = ptrdiff_t;
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using key_container_type = KeyContainer;
using mapped_container_type = MappedContainer;
class value_compare {
private:
key_compare comp ; // exposition only
constexpr value_compare(key_compare c) : comp (c) { } // exposition only
public:
constexpr bool operator()(const_reference x, const_reference y) const {
return comp (x.first, y.first);
}
};
struct containers {
key_container_type keys;
mapped_container_type values;
};
// 23.6.9.3, constructors
constexpr flat_multimap() : flat_multimap(key_compare()) { }
§ 23.6.9.2 © ISO/IEC
1092

===== PAGE 1104 =====

Dxxxx
constexpr flat_multimap(const flat_multimap&);
constexpr flat_multimap(flat_multimap&&);
constexpr flat_multimap& operator=(const flat_multimap&);
constexpr flat_multimap& operator=(flat_multimap&&);
constexpr explicit flat_multimap(const key_compare& comp)
: c (), compare (comp) { }
constexpr flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
constexpr flat_multimap(sorted_equivalent_t,
key_container_type key_cont, mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
template<class InputIterator>
constexpr flat_multimap(InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (), compare (comp)
{ insert(first, last); }
template<class InputIterator>
constexpr flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (), compare (comp) { insert(sorted_equivalent, first, last); }
template<container-compatible-range <value_type> R>
constexpr flat_multimap(from_range_t, R&& rg)
: flat_multimap(from_range, std::forward<R>(rg), key_compare()) { }
template<container-compatible-range <value_type> R>
constexpr flat_multimap(from_range_t, R&& rg, const key_compare& comp)
: flat_multimap(comp) { insert_range(std::forward<R>(rg)); }
constexpr flat_multimap(initializer_list<value_type> il,
const key_compare& comp = key_compare())
: flat_multimap(il.begin(), il.end(), comp) { }
constexpr flat_multimap(sorted_equivalent_t, initializer_list<value_type> il,
const key_compare& comp = key_compare())
: flat_multimap(sorted_equivalent, il.begin(), il.end(), comp) { }
// 23.6.9.4, constructors with allocators
template<class Alloc>
constexpr explicit flat_multimap(const Alloc& a);
template<class Alloc>
constexpr flat_multimap(const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(const key_container_type& key_cont,
const mapped_container_type& mapped_cont,
const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont,
const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(const flat_multimap&, const Alloc& a);
§ 23.6.9.2 © ISO/IEC
1093

===== PAGE 1105 =====

Dxxxx
template<class Alloc>
constexpr flat_multimap(flat_multimap&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multimap(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multimap(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(initializer_list<value_type> il, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, initializer_list<value_type> il,
const Alloc& a);
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
flat_multimap& operator=(initializer_list<value_type>);
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// modifiers
template<class... Args> constexpr iterator emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr iterator insert(const value_type& x)
{ return emplace(x); }
constexpr iterator insert(value_type&& x)
{ return emplace(std::move(x)); }
constexpr iterator insert(const_iterator position, const value_type& x)
{ return emplace_hint(position, x); }
§ 23.6.9.2 © ISO/IEC
1094

===== PAGE 1106 =====

Dxxxx
constexpr iterator insert(const_iterator position, value_type&& x)
{ return emplace_hint(position, std::move(x)); }
template<class P> constexpr iterator insert(P&& x);
template<class P>
constexpr iterator insert(const_iterator position, P&&);
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<class InputIterator>
constexpr void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
template<container-compatible-range <value_type> R>
constexpr void insert_range(sorted_equivalent_t, R&& rg);
constexpr void insert(initializer_list<value_type> il)
{ insert(il.begin(), il.end()); }
constexpr void insert(sorted_equivalent_t, initializer_list<value_type> il)
{ insert(sorted_equivalent, il.begin(), il.end()); }
constexpr containers extract() &&;
constexpr void replace(key_container_type&& key_cont, mapped_container_type&& mapped_cont);
constexpr iterator erase(iterator position);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(flat_multimap&)
noexcept(is_nothrow_swappable_v<key_container_type> &&
is_nothrow_swappable_v<mapped_container_type> &&
is_nothrow_swappable_v<key_compare>);
constexpr void clear() noexcept;
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
constexpr const key_container_type& keys() const noexcept { return c .keys; }
constexpr const mapped_container_type& values() const noexcept { return c .values; }
// map operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
§ 23.6.9.2 © ISO/IEC
1095

===== PAGE 1107 =====

Dxxxx
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
friend constexpr bool operator==(const flat_multimap& x, const flat_multimap& y);
friend constexpr synth-three-way-result <value_type>
operator<=>(const flat_multimap& x, const flat_multimap& y);
friend constexpr void swap(flat_multimap& x, flat_multimap& y)
noexcept(noexcept(x.swap(y)))
{ x.swap(y); }
private:
containers c ; // exposition only
key_compare compare ; // exposition only
};
template<class KeyContainer, class MappedContainer,
class Compare = less<typename KeyContainer::value_type>>
flat_multimap(KeyContainer, MappedContainer, Compare = Compare())
-> flat_multimap<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Allocator>
flat_multimap(KeyContainer, MappedContainer, Allocator)
-> flat_multimap<typename KeyContainer::value_type, typename MappedContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Compare, class Allocator>
flat_multimap(KeyContainer, MappedContainer, Compare, Allocator)
-> flat_multimap<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer,
class Compare = less<typename KeyContainer::value_type>>
flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Compare = Compare())
-> flat_multimap<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Allocator>
flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Allocator)
-> flat_multimap<typename KeyContainer::value_type, typename MappedContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer, MappedContainer>;
template<class KeyContainer, class MappedContainer, class Compare, class Allocator>
flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Compare, Allocator)
-> flat_multimap<typename KeyContainer::value_type, typename MappedContainer::value_type,
Compare, KeyContainer, MappedContainer>;
template<class InputIterator, class Compare = less<iter-key-type <InputIterator>>>
flat_multimap(InputIterator, InputIterator, Compare = Compare())
-> flat_multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Compare>;
template<class InputIterator, class Compare = less<iter-key-type <InputIterator>>>
flat_multimap(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
-> flat_multimap<iter-key-type <InputIterator>, iter-mapped-type <InputIterator>, Compare>;
template<ranges::input_range R, class Compare = less<range-key-type <R>>,
class Allocator = allocator<byte>>
flat_multimap(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> flat_multimap<range-key-type <R>, range-mapped-type <R>, Compare,
vector<range-key-type <R>,
§ 23.6.9.2 © ISO/IEC
1096

===== PAGE 1108 =====

Dxxxx
alloc-rebind <Allocator, range-key-type <R>>>,
vector<range-mapped-type <R>,
alloc-rebind <Allocator, range-mapped-type <R>>>>;
template<ranges::input_range R, class Allocator>
flat_multimap(from_range_t, R&&, Allocator)
-> flat_multimap<range-key-type <R>, range-mapped-type <R>, less<range-key-type <R>>,
vector<range-key-type <R>,
alloc-rebind <Allocator, range-key-type <R>>>,
vector<range-mapped-type <R>,
alloc-rebind <Allocator, range-mapped-type <R>>>>;
template<class Key, class T, class Compare = less<Key>>
flat_multimap(initializer_list<pair<Key, T>>, Compare = Compare())
-> flat_multimap<Key, T, Compare>;
template<class Key, class T, class Compare = less<Key>>
flat_multimap(sorted_equivalent_t, initializer_list<pair<Key, T>>, Compare = Compare())
-> flat_multimap<Key, T, Compare>;
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Allocator>
struct uses_allocator<flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>,
Allocator>
: bool_constant<uses_allocator_v<KeyContainer, Allocator> &&
uses_allocator_v<MappedContainer, Allocator>> { };
}
1 The member typecontainers has the data members and special members specified above. It has no base
classes or members other than those specified.
23.6.9.3 Constructors [flat.multimap.cons]
constexpr flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
1 Effects: Initializes c .keys with std::move(key_cont), c .values with std::move(mapped_cont),
and compare with comp; sorts the range[begin(),end()) with respect tovalue_comp().
2 Complexity: Linear inN if the container arguments are already sorted with respect tovalue_comp()
and otherwiseNlog N, whereN is the value ofkey_cont.size() before this call.
constexpr flat_multimap(sorted_equivalent_t, key_container_type key_cont,
mapped_container_type mapped_cont,
const key_compare& comp = key_compare());
3 Effects: Initializes c .keys with std::move(key_cont), c .values with std::move(mapped_cont),
and compare with comp.
4 Complexity: Constant.
23.6.9.4 Constructors with allocators [flat.multimap.cons.alloc]
1 The constructors in this subclause shall not participate in overload resolution unlessuses_allocator_v<key_-
container_type, Alloc> is true and uses_allocator_v<mapped_container_type, Alloc> is true.
template<class Alloc>
constexpr flat_multimap(const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(const key_container_type& key_cont,
const mapped_container_type& mapped_cont,
const key_compare& comp, const Alloc& a);
2 Effects: Equivalent to flat_multimap(key_cont, mapped_cont) and flat_multimap(key_cont,
mapped_cont, comp), respectively, except that c .keys and c .values are constructed with uses-
allocator construction (20.2.8.2).
§ 23.6.9.4 © ISO/IEC
1097

===== PAGE 1109 =====

Dxxxx
3 Complexity: Same as flat_multimap(key_cont, mapped_cont) and flat_multimap(key_cont,
mapped_cont, comp), respectively.
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,
const mapped_container_type& mapped_cont, const key_compare& comp,
const Alloc& a);
4 Effects: Equivalent toflat_multimap(sorted_equivalent, key_cont, mapped_cont) and flat_-
multimap(sorted_equivalent, key_cont, mapped_cont, comp), respectively, except thatc .keys
and c .values are constructed with uses-allocator construction (20.2.8.2).
5 Complexity: Linear.
template<class Alloc>
constexpr explicit flat_multimap(const Alloc& a);
template<class Alloc>
constexpr flat_multimap(const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(const flat_multimap&, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(flat_multimap&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(InputIterator first, InputIterator last, const key_compare& comp,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multimap(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multimap(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(initializer_list<value_type> il, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_multimap(sorted_equivalent_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
6 Effects: Equivalent to the corresponding non-allocator constructors except thatc .keys and c .values
are constructed with uses-allocator construction (20.2.8.2).
23.6.9.5 Erasure [flat.multimap.erasure]
template<class Key, class T, class Compare, class KeyContainer, class MappedContainer,
class Predicate>
constexpr typename flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>::size_type
erase_if(flat_multimap<Key, T, Compare, KeyContainer, MappedContainer>& c, Predicate pred);
1 Preconditions: Key and T meet theCpp17MoveAssignable requirements.
2 Effects: Let E be bool(pred(pair<const Key&, const T&>(e))). Erases all elements e in c for
which E holds.
3 Returns: The number of elements erased.
§ 23.6.9.5 © ISO/IEC
1098

===== PAGE 1110 =====

Dxxxx
4 Complexity: Exactly c.size() applications of the predicate.
5 Remarks: Stable (16.4.6.8). If an invocation oferase_if exits via an exception,c is in a valid but
unspecified state (3.67).
[Note 1: c still meets its invariants, but can be empty.—end note]
23.6.10 Header <flat_set> synopsis [flat.set.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.6.11, class templateflat_set
template<class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
class flat_set;
struct sorted_unique_t { explicit sorted_unique_t() = default; };
inline constexpr sorted_unique_t sorted_unique{};
template<class Key, class Compare, class KeyContainer, class Allocator>
struct uses_allocator<flat_set<Key, Compare, KeyContainer>, Allocator>;
// 23.6.11.6, erasure forflat_set
template<class Key, class Compare, class KeyContainer, class Predicate>
constexpr typename flat_set<Key, Compare, KeyContainer>::size_type
erase_if(flat_set<Key, Compare, KeyContainer>& c, Predicate pred);
// 23.6.12, class templateflat_multiset
template<class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
class flat_multiset;
struct sorted_equivalent_t { explicit sorted_equivalent_t() = default; };
inline constexpr sorted_equivalent_t sorted_equivalent{};
template<class Key, class Compare, class KeyContainer, class Allocator>
struct uses_allocator<flat_multiset<Key, Compare, KeyContainer>, Allocator>;
// 23.6.12.6, erasure forflat_multiset
template<class Key, class Compare, class KeyContainer, class Predicate>
constexpr typename flat_multiset<Key, Compare, KeyContainer>::size_type
erase_if(flat_multiset<Key, Compare, KeyContainer>& c, Predicate pred);
}
23.6.11 Class template flat_set [flat.set]
23.6.11.1 Overview [flat.set.overview]
1 A flat_set is a container adaptor that provides an associative container interface that supports unique keys
(i.e., contains at most one of each key value) and provides for fast retrieval of the keys themselves.flat_set
supports iterators that model therandom_access_iterator concept (24.3.4.13).
2 A flat_set meets all of the requirements for a container (23.2.2.2) and for a reversible container (23.2.2.3),
plus the optional container requirements (23.2.2.4).flat_set meets the requirements of an associative
container (23.2.7), except that:
—(2.1) it does not meet the requirements related to node handles (23.2.5.1),
—(2.2) it does not meet the requirements related to iterator invalidation, and
—(2.3) the time complexity of the operations that insert or erase a single element from the set is linear,
including the ones that take an insertion position iterator.
[Note 1: A flat_set does not meet the additional requirements of an allocator-aware container, as described in
23.2.2.5. —end note]
3 A flat_set also provides most operations described in 23.2.7 for unique keys. This means that aflat_set
supports the a_uniq operations in 23.2.7 but not thea_eq operations. For a flat_set<Key>, both the
key_type and value_type are Key.
§ 23.6.11.1 © ISO/IEC
1099

===== PAGE 1111 =====

Dxxxx
4 Descriptions are provided here only for operations onflat_set that are not described in one of those sets of
requirements or for operations where there is additional semantic information.
5 A flat_set maintains the invariant that the keys are sorted with respect to the comparison object.
6 If any member function in 23.6.11.2 exits via an exception, the invariant of the object argument is restored.
For the move constructor and move assignment operator, the invariants of both arguments are restored.
[Note 2: This can result in theflat_set’s being emptied. —end note]
7 Any sequence container (23.2.4) supportingCpp17RandomAccessIteratorcan be used to instantiateflat_set.
In particular,vector (23.3.13) anddeque (23.3.5) can be used.
[Note 3: vector<bool> is not a sequence container.—end note]
8 The program is ill-formed ifKey is not the same type asKeyContainer::value_type.
9 The effect of calling a member function that takes asorted_unique_t argument with a range that is not
sorted with respect tokey_comp(), or that contains equal elements, is undefined.
10 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
23.6.11.2 Definition [flat.set.defn]
namespace std {
template<class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
class flat_set {
public:
// types
using key_type = Key;
using value_type = Key;
using key_compare = Compare;
using value_compare = Compare;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = KeyContainer::size_type;
using difference_type = KeyContainer::difference_type;
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using container_type = KeyContainer;
// 23.6.11.3, constructors
constexpr flat_set() : flat_set(key_compare()) { }
constexpr flat_set(const flat_set&);
constexpr flat_set(flat_set&&);
constexpr flat_set& operator=(const flat_set&);
constexpr flat_set& operator=(flat_set&&);
constexpr explicit flat_set(const key_compare& comp)
: c (), compare (comp) { }
constexpr explicit flat_set(container_type cont, const key_compare& comp = key_compare());
constexpr flat_set(sorted_unique_t, container_type cont,
const key_compare& comp = key_compare())
: c (std::move(cont)), compare (comp) { }
template<class InputIterator>
constexpr flat_set(InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (), compare (comp)
{ insert(first, last); }
§ 23.6.11.2 © ISO/IEC
1100

===== PAGE 1112 =====

Dxxxx
template<class InputIterator>
constexpr flat_set(sorted_unique_t, InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (first, last), compare (comp) { }
template<container-compatible-range <value_type> R>
constexpr flat_set(from_range_t, R&& rg)
: flat_set(from_range, std::forward<R>(rg), key_compare()) { }
template<container-compatible-range <value_type> R>
constexpr flat_set(from_range_t, R&& rg, const key_compare& comp)
: flat_set(comp)
{ insert_range(std::forward<R>(rg)); }
constexpr flat_set(initializer_list<value_type> il, const key_compare& comp = key_compare())
: flat_set(il.begin(), il.end(), comp) { }
constexpr flat_set(sorted_unique_t, initializer_list<value_type> il,
const key_compare& comp = key_compare())
: flat_set(sorted_unique, il.begin(), il.end(), comp) { }
// 23.6.11.4, constructors with allocators
template<class Alloc>
constexpr explicit flat_set(const Alloc& a);
template<class Alloc>
constexpr flat_set(const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_set(const container_type& cont, const Alloc& a);
template<class Alloc>
constexpr flat_set(const container_type& cont, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_set(sorted_unique_t, const container_type& cont, const Alloc& a);
template<class Alloc>
constexpr flat_set(sorted_unique_t, const container_type& cont,
const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_set(const flat_set&, const Alloc& a);
template<class Alloc>
constexpr flat_set(flat_set&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(sorted_unique_t, InputIterator first, InputIterator last,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(sorted_unique_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_set(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_set(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_set(initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_set(initializer_list<value_type> il, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_set(sorted_unique_t, initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_set(sorted_unique_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
§ 23.6.11.2 © ISO/IEC
1101

===== PAGE 1113 =====

Dxxxx
constexpr flat_set& operator=(initializer_list<value_type>);
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.6.11.5, modifiers
template<class... Args> constexpr pair<iterator, bool> emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr pair<iterator, bool> insert(const value_type& x)
{ return emplace(x); }
constexpr pair<iterator, bool> insert(value_type&& x)
{ return emplace(std::move(x)); }
template<class K> constexpr pair<iterator, bool> insert(K&& x);
constexpr iterator insert(const_iterator position, const value_type& x)
{ return emplace_hint(position, x); }
constexpr iterator insert(const_iterator position, value_type&& x)
{ return emplace_hint(position, std::move(x)); }
template<class K> constexpr iterator insert(const_iterator hint, K&& x);
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<class InputIterator>
constexpr void insert(sorted_unique_t, InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
template<container-compatible-range <value_type> R>
constexpr void insert_range(sorted_unique_t, R&& rg);
constexpr void insert(initializer_list<value_type> il)
{ insert(il.begin(), il.end()); }
constexpr void insert(sorted_unique_t, initializer_list<value_type> il)
{ insert(sorted_unique, il.begin(), il.end()); }
constexpr container_type extract() &&;
constexpr void replace(container_type&&);
constexpr iterator erase(iterator position) requires (!same_as<iterator, const_iterator>);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(flat_set& y) noexcept(see below );
constexpr void clear() noexcept;
§ 23.6.11.2 © ISO/IEC
1102

===== PAGE 1114 =====

Dxxxx
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
// set operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
friend constexpr bool operator==(const flat_set& x, const flat_set& y);
friend constexpr synth-three-way-result <value_type>
operator<=>(const flat_set& x, const flat_set& y);
friend constexpr void swap(flat_set& x, flat_set& y) noexcept(noexcept(x.swap(y)))
{ x.swap(y); }
private:
container_type c; // exposition only
key_compare compare; // exposition only
};
template<class KeyContainer, class Compare = less<typename KeyContainer::value_type>>
flat_set(KeyContainer, Compare = Compare())
-> flat_set<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class KeyContainer, class Allocator>
flat_set(KeyContainer, Allocator)
-> flat_set<typename KeyContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer>;
template<class KeyContainer, class Compare, class Allocator>
flat_set(KeyContainer, Compare, Allocator)
-> flat_set<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class KeyContainer, class Compare = less<typename KeyContainer::value_type>>
flat_set(sorted_unique_t, KeyContainer, Compare = Compare())
-> flat_set<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class KeyContainer, class Allocator>
flat_set(sorted_unique_t, KeyContainer, Allocator)
-> flat_set<typename KeyContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer>;
§ 23.6.11.2 © ISO/IEC
1103

===== PAGE 1115 =====

Dxxxx
template<class KeyContainer, class Compare, class Allocator>
flat_set(sorted_unique_t, KeyContainer, Compare, Allocator)
-> flat_set<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class InputIterator, class Compare = less<iter-value-type <InputIterator>>>
flat_set(InputIterator, InputIterator, Compare = Compare())
-> flat_set<iter-value-type <InputIterator>, Compare>;
template<class InputIterator, class Compare = less<iter-value-type <InputIterator>>>
flat_set(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
-> flat_set<iter-value-type <InputIterator>, Compare>;
template<ranges::input_range R, class Compare = less<ranges::range_value_t<R>>,
class Allocator = allocator<ranges::range_value_t<R>>>
flat_set(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> flat_set<ranges::range_value_t<R>, Compare,
vector<ranges::range_value_t<R>,
alloc-rebind <Allocator, ranges::range_value_t<R>>>>;
template<ranges::input_range R, class Allocator>
flat_set(from_range_t, R&&, Allocator)
-> flat_set<ranges::range_value_t<R>, less<ranges::range_value_t<R>>,
vector<ranges::range_value_t<R>,
alloc-rebind <Allocator, ranges::range_value_t<R>>>>;
template<class Key, class Compare = less<Key>>
flat_set(initializer_list<Key>, Compare = Compare())
-> flat_set<Key, Compare>;
template<class Key, class Compare = less<Key>>
flat_set(sorted_unique_t, initializer_list<Key>, Compare = Compare())
-> flat_set<Key, Compare>;
template<class Key, class Compare, class KeyContainer, class Allocator>
struct uses_allocator<flat_set<Key, Compare, KeyContainer>, Allocator>
: bool_constant<uses_allocator_v<KeyContainer, Allocator>> { };
}
23.6.11.3 Constructors [flat.set.cons]
constexpr explicit flat_set(container_type cont, const key_compare& comp = key_compare());
1 Effects: Initializes c with std::move(cont) and compare with comp, sorts the range[begin(),end())
with respect tocompare , and finally erases all but the first element from each group of consecutive
equivalent elements.
2 Complexity: Linear inN if cont is already sorted with respect tocompare and otherwiseNlog N,
where N is the value ofcont.size() before this call.
23.6.11.4 Constructors with allocators [flat.set.cons.alloc]
1 The constructors in this subclause shall not participate in overload resolution unlessuses_allocator_-
v<container_type, Alloc> is true.
template<class Alloc>
constexpr flat_set(const container_type& cont, const Alloc& a);
template<class Alloc>
constexpr flat_set(const container_type& cont, const key_compare& comp, const Alloc& a);
2 Effects: Equivalent toflat_set(cont) and flat_set(cont, comp), respectively, except thatc is
constructed with uses-allocator construction (20.2.8.2).
3 Complexity: Same asflat_set(cont) and flat_set(cont, comp), respectively.
template<class Alloc>
constexpr flat_set(sorted_unique_t, const container_type& cont, const Alloc& a);
§ 23.6.11.4 © ISO/IEC
1104

===== PAGE 1116 =====

Dxxxx
template<class Alloc>
constexpr flat_set(sorted_unique_t, const container_type& cont,
const key_compare& comp, const Alloc& a);
4 Effects: Equivalent to flat_set(sorted_unique, cont) and flat_set(sorted_unique, cont,
comp), respectively, except thatc is constructed with uses-allocator construction (20.2.8.2).
5 Complexity: Linear.
template<class Alloc>
constexpr explicit flat_set(const Alloc& a);
template<class Alloc>
constexpr flat_set(const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_set(const flat_set&, const Alloc& a);
template<class Alloc>
constexpr flat_set(flat_set&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(InputIterator first, InputIterator last, const key_compare& comp,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(sorted_unique_t, InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_set(sorted_unique_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_set(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_set(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_set(initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_set(initializer_list<value_type> il, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_set(sorted_unique_t, initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_set(sorted_unique_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
6 Effects: Equivalent to the corresponding non-allocator constructors except thatc is constructed with
uses-allocator construction (20.2.8.2).
23.6.11.5 Modifiers [flat.set.modifiers]
template<class K> constexpr pair<iterator, bool> insert(K&& x);
template<class K> constexpr iterator insert(const_iterator hint, K&& x);
1 Constraints: The qualified-id Compare::is_transparent is valid and denotes a type.is_constructi-
ble_v<value_type, K> is true.
2 Preconditions: The conversion fromx into value_type constructs an objectu, for whichfind(x) ==
find(u) is true.
3 Effects: If the set already contains an element equivalent tox, *this and x are unchanged. Otherwise,
inserts a new element as if byemplace(std::forward<K>(x)).
4 Returns: In the first overload, thebool component of the returned pair istrue if and only if the
insertion took place. The returned iterator points to the element whose key is equivalent tox.
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
5 Effects: Adds elements toc as if by:
c .insert(c .end(), first, last);
§ 23.6.11.5 © ISO/IEC
1105

===== PAGE 1117 =====

Dxxxx
Then, sorts the range of newly inserted elements with respect tocompare ; merges the resulting sorted
range and the sorted range of pre-existing elements into a single sorted range; and finally erases all but
the first element from each group of consecutive equivalent elements.
6 Complexity: N + Mlog M, where N is size() before the operation and M is distance(first,
last).
7 Remarks: Since this operation performs an in-place merge, it may allocate memory.
template<class InputIterator>
constexpr void insert(sorted_unique_t, InputIterator first, InputIterator last);
8 Effects: Equivalent toinsert(first, last).
9 Complexity: Linear.
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
10 Effects: Adds elements toc as if by:
ranges::for_each(rg, [&](auto&& e) {
c .insert(c .end(), std::forward<decltype(e)>(e));
});
Then, sorts the range of newly inserted elements with respect tocompare ; merges the resulting sorted
range and the sorted range of pre-existing elements into a single sorted range; and finally erases all but
the first element from each group of consecutive equivalent elements.
11 Complexity: N + Mlog M, whereN is size() before the operation andM is ranges::distance(rg).
12 Remarks: Since this operation performs an in-place merge, it may allocate memory.
template<container-compatible-range <value_type> R>
constexpr void insert_range(sorted_unique_t, R&& rg);
13 Effects: Equivalent toinsert_range(rg).
14 Complexity: Linear inN, whereN is size() after the operation.
constexpr void swap(flat_set& y)
noexcept(is_nothrow_swappable_v<container_type> &&
is_nothrow_swappable_v<key_compare>);
15 Effects: Equivalent to:
ranges::swap(compare , y.compare );
ranges::swap(c , y.c );
constexpr container_type extract() &&;
16 Postconditions: *this is emptied, even if the function exits via an exception.
17 Returns: std::move(c ).
constexpr void replace(container_type&& cont);
18 Preconditions: The elements ofcont are sorted with respect tocompare , andcont contains no equal
elements.
19 Effects: Equivalent to:c = std::move(cont);
23.6.11.6 Erasure [flat.set.erasure]
template<class Key, class Compare, class KeyContainer, class Predicate>
constexpr typename flat_set<Key, Compare, KeyContainer>::size_type
erase_if(flat_set<Key, Compare, KeyContainer>& c, Predicate pred);
1 Preconditions: Key meets theCpp17MoveAssignable requirements.
2 Effects: Let E be bool(pred(as_const(e))). Erases all elementse in c for whichE holds.
3 Returns: The number of elements erased.
4 Complexity: Exactly c.size() applications of the predicate.
§ 23.6.11.6 © ISO/IEC
1106

===== PAGE 1118 =====

Dxxxx
5 Remarks: Stable (16.4.6.8). If an invocation oferase_if exits via an exception,c is in a valid but
unspecified state (3.67).
[Note 1: c still meets its invariants, but can be empty.—end note]
23.6.12 Class template flat_multiset [flat.multiset]
23.6.12.1 Overview [flat.multiset.overview]
1 A flat_multiset is a container adaptor that provides an associative container interface that supports
equivalent keys (i.e., possibly containing multiple copies of the same key value) and provides for fast
retrieval of the keys themselves.flat_multiset supports iterators that model therandom_access_iterator
concept (24.3.4.13).
2 A flat_multiset meets all of the requirements for a container (23.2.2.2) and for a reversible container
(23.2.2.3), plus the optional container requirements (23.2.2.4).flat_multiset meets the requirements of an
associative container (23.2.7), except that:
—(2.1) it does not meet the requirements related to node handles (23.2.5.1),
—(2.2) it does not meet the requirements related to iterator invalidation, and
—(2.3) the time complexity of the operations that insert or erase a single element from the set is linear,
including the ones that take an insertion position iterator.
[Note 1: A flat_multiset does not meet the additional requirements of an allocator-aware container, as described in
23.2.2.5. —end note]
3 A flat_multiset also provides most operations described in 23.2.7 for equal keys. This means that aflat_-
multiset supports thea_eq operations in 23.2.7 but not thea_uniq operations. For aflat_multiset<Key>,
both thekey_type and value_type are Key.
4 Descriptions are provided here only for operations onflat_multiset that are not described in one of the
general sections or for operations where there is additional semantic information.
5 A flat_multiset maintains the invariant that the keys are sorted with respect to the comparison object.
6 If any member function in 23.6.12.2 exits via an exception, the invariant of the object argument is restored.
For the move constructor and move assignment operator, the invariants of both arguments are restored.
[Note 2: This can result in theflat_multiset’s being emptied. —end note]
7 Any sequence container (23.2.4) supportingCpp17RandomAccessIteratorcan be used to instantiateflat_-
multiset. In particular,vector (23.3.13) anddeque (23.3.5) can be used.
[Note 3: vector<bool> is not a sequence container.—end note]
8 The program is ill-formed ifKey is not the same type asKeyContainer::value_type.
9 The effect of calling a member function that takes asorted_equivalent_t argument with a range that is
not sorted with respect tokey_comp() is undefined.
10 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
23.6.12.2 Definition [flat.multiset.defn]
namespace std {
template<class Key, class Compare = less<Key>, class KeyContainer = vector<Key>>
class flat_multiset {
public:
// types
using key_type = Key;
using value_type = Key;
using key_compare = Compare;
using value_compare = Compare;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = KeyContainer::size_type;
using difference_type = KeyContainer::difference_type;
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
§ 23.6.12.2 © ISO/IEC
1107

===== PAGE 1119 =====

Dxxxx
using container_type = KeyContainer;
// 23.6.12.3, constructors
constexpr flat_multiset() : flat_multiset(key_compare()) { }
constexpr flat_multiset(const flat_multiset&);
constexpr flat_multiset(flat_multiset&&);
constexpr flat_multiset& operator=(const flat_multiset&);
constexpr flat_multiset& operator=(flat_multiset&&);
constexpr explicit flat_multiset(const key_compare& comp)
: c (), compare (comp) { }
constexpr explicit flat_multiset(container_type cont,
const key_compare& comp = key_compare());
constexpr flat_multiset(sorted_equivalent_t, container_type cont,
const key_compare& comp = key_compare())
: c (std::move(cont)), compare (comp) { }
template<class InputIterator>
constexpr flat_multiset(InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (), compare (comp)
{ insert(first, last); }
template<class InputIterator>
constexpr flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
const key_compare& comp = key_compare())
: c (first, last), compare (comp) { }
template<container-compatible-range <value_type> R>
constexpr flat_multiset(from_range_t, R&& rg)
: flat_multiset(from_range, std::forward<R>(rg), key_compare()) { }
template<container-compatible-range <value_type> R>
constexpr flat_multiset(from_range_t, R&& rg, const key_compare& comp)
: flat_multiset(comp)
{ insert_range(std::forward<R>(rg)); }
constexpr flat_multiset(initializer_list<value_type> il,
const key_compare& comp = key_compare())
: flat_multiset(il.begin(), il.end(), comp) { }
constexpr flat_multiset(sorted_equivalent_t, initializer_list<value_type> il,
const key_compare& comp = key_compare())
: flat_multiset(sorted_equivalent, il.begin(), il.end(), comp) { }
// 23.6.12.4, constructors with allocators
template<class Alloc>
constexpr explicit flat_multiset(const Alloc& a);
template<class Alloc>
constexpr flat_multiset(const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(const container_type& cont, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(const container_type& cont, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, const container_type& cont, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, const container_type& cont,
const key_compare& comp, const Alloc& a);
§ 23.6.12.2 © ISO/IEC
1108

===== PAGE 1120 =====

Dxxxx
template<class Alloc>
constexpr flat_multiset(const flat_multiset&, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(flat_multiset&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multiset(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multiset(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(initializer_list<value_type> il, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, initializer_list<value_type> il,
const Alloc& a);
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
constexpr flat_multiset& operator=(initializer_list<value_type>);
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.6.12.5, modifiers
template<class... Args> constexpr iterator emplace(Args&&... args);
template<class... Args>
constexpr iterator emplace_hint(const_iterator position, Args&&... args);
constexpr iterator insert(const value_type& x)
{ return emplace(x); }
constexpr iterator insert(value_type&& x)
{ return emplace(std::move(x)); }
§ 23.6.12.2 © ISO/IEC
1109

===== PAGE 1121 =====

Dxxxx
constexpr iterator insert(const_iterator position, const value_type& x)
{ return emplace_hint(position, x); }
constexpr iterator insert(const_iterator position, value_type&& x)
{ return emplace_hint(position, std::move(x)); }
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
template<class InputIterator>
constexpr void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
template<container-compatible-range <value_type> R>
constexpr void insert_range(R&& rg);
template<container-compatible-range <value_type> R>
constexpr void insert_range(sorted_equivalent_t, R&& rg);
constexpr void insert(initializer_list<value_type> il)
{ insert(il.begin(), il.end()); }
constexpr void insert(sorted_equivalent_t, initializer_list<value_type> il)
{ insert(sorted_equivalent, il.begin(), il.end()); }
constexpr container_type extract() &&;
constexpr void replace(container_type&&);
constexpr iterator erase(iterator position) requires (!same_as<iterator, const_iterator>);
constexpr iterator erase(const_iterator position);
constexpr size_type erase(const key_type& x);
template<class K> constexpr size_type erase(K&& x);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(flat_multiset& y) noexcept(see below );
constexpr void clear() noexcept;
// observers
constexpr key_compare key_comp() const;
constexpr value_compare value_comp() const;
// set operations
constexpr iterator find(const key_type& x);
constexpr const_iterator find(const key_type& x) const;
template<class K> constexpr iterator find(const K& x);
template<class K> constexpr const_iterator find(const K& x) const;
constexpr size_type count(const key_type& x) const;
template<class K> constexpr size_type count(const K& x) const;
constexpr bool contains(const key_type& x) const;
template<class K> constexpr bool contains(const K& x) const;
constexpr iterator lower_bound(const key_type& x);
constexpr const_iterator lower_bound(const key_type& x) const;
template<class K> constexpr iterator lower_bound(const K& x);
template<class K> constexpr const_iterator lower_bound(const K& x) const;
constexpr iterator upper_bound(const key_type& x);
constexpr const_iterator upper_bound(const key_type& x) const;
template<class K> constexpr iterator upper_bound(const K& x);
template<class K> constexpr const_iterator upper_bound(const K& x) const;
constexpr pair<iterator, iterator> equal_range(const key_type& x);
constexpr pair<const_iterator, const_iterator> equal_range(const key_type& x) const;
template<class K>
constexpr pair<iterator, iterator> equal_range(const K& x);
template<class K>
constexpr pair<const_iterator, const_iterator> equal_range(const K& x) const;
§ 23.6.12.2 © ISO/IEC
1110

===== PAGE 1122 =====

Dxxxx
friend constexpr bool operator==(const flat_multiset& x, const flat_multiset& y);
friend constexpr synth-three-way-result <value_type>
operator<=>(const flat_multiset& x, const flat_multiset& y);
friend constexpr void swap(flat_multiset& x, flat_multiset& y)
noexcept(noexcept(x.swap(y)))
{ x.swap(y); }
private:
container_type c; // exposition only
key_compare compare; // exposition only
};
template<class KeyContainer, class Compare = less<typename KeyContainer::value_type>>
flat_multiset(KeyContainer, Compare = Compare())
-> flat_multiset<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class KeyContainer, class Allocator>
flat_multiset(KeyContainer, Allocator)
-> flat_multiset<typename KeyContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer>;
template<class KeyContainer, class Compare, class Allocator>
flat_multiset(KeyContainer, Compare, Allocator)
-> flat_multiset<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class KeyContainer, class Compare = less<typename KeyContainer::value_type>>
flat_multiset(sorted_equivalent_t, KeyContainer, Compare = Compare())
-> flat_multiset<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class KeyContainer, class Allocator>
flat_multiset(sorted_equivalent_t, KeyContainer, Allocator)
-> flat_multiset<typename KeyContainer::value_type,
less<typename KeyContainer::value_type>, KeyContainer>;
template<class KeyContainer, class Compare, class Allocator>
flat_multiset(sorted_equivalent_t, KeyContainer, Compare, Allocator)
-> flat_multiset<typename KeyContainer::value_type, Compare, KeyContainer>;
template<class InputIterator, class Compare = less<iter-value-type <InputIterator>>>
flat_multiset(InputIterator, InputIterator, Compare = Compare())
-> flat_multiset<iter-value-type <InputIterator>, Compare>;
template<class InputIterator, class Compare = less<iter-value-type <InputIterator>>>
flat_multiset(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
-> flat_multiset<iter-value-type <InputIterator>, Compare>;
template<ranges::input_range R, class Compare = less<ranges::range_value_t<R>>,
class Allocator = allocator<ranges::range_value_t<R>>>
flat_multiset(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
-> flat_multiset<ranges::range_value_t<R>, Compare,
vector<ranges::range_value_t<R>,
alloc-rebind <Allocator, ranges::range_value_t<R>>>>;
template<ranges::input_range R, class Allocator>
flat_multiset(from_range_t, R&&, Allocator)
-> flat_multiset<ranges::range_value_t<R>, less<ranges::range_value_t<R>>,
vector<ranges::range_value_t<R>,
alloc-rebind <Allocator, ranges::range_value_t<R>>>>;
template<class Key, class Compare = less<Key>>
flat_multiset(initializer_list<Key>, Compare = Compare())
-> flat_multiset<Key, Compare>;
template<class Key, class Compare = less<Key>>
flat_multiset(sorted_equivalent_t, initializer_list<Key>, Compare = Compare())
-> flat_multiset<Key, Compare>;
§ 23.6.12.2 © ISO/IEC
1111

===== PAGE 1123 =====

Dxxxx
template<class Key, class Compare, class KeyContainer, class Allocator>
struct uses_allocator<flat_multiset<Key, Compare, KeyContainer>, Allocator>
: bool_constant<uses_allocator_v<KeyContainer, Allocator>> { };
}
23.6.12.3 Constructors [flat.multiset.cons]
constexpr explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());
1 Effects: Initializes c with std::move(cont) and compare with comp, and sorts the range[begin(),
end()) with respect tocompare .
2 Complexity: Linear inN if cont is already sorted with respect tocompare and otherwiseNlog N,
where N is the value ofcont.size() before this call.
23.6.12.4 Constructors with allocators [flat.multiset.cons.alloc]
1 The constructors in this subclause shall not participate in overload resolution unlessuses_allocator_-
v<container_type, Alloc> is true.
template<class Alloc>
constexpr flat_multiset(const container_type& cont, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(const container_type& cont, const key_compare& comp, const Alloc& a);
2 Effects: Equivalent toflat_multiset(cont) and flat_multiset(cont, comp), respectively, except
that c is constructed with uses-allocator construction (20.2.8.2).
3 Complexity: Same asflat_multiset(cont) and flat_multiset(cont, comp), respectively.
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, const container_type& cont, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, const container_type& cont,
const key_compare& comp, const Alloc& a);
4 Effects: Equivalent to flat_multiset(sorted_equivalent, cont) and flat_multiset(sorted_-
equivalent, cont, comp), respectively, except thatc is constructed with uses-allocator construction
(20.2.8.2).
5 Complexity: Linear.
template<class Alloc>
constexpr explicit flat_multiset(const Alloc& a);
template<class Alloc>
constexpr flat_multiset(const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(const flat_multiset&, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(flat_multiset&&, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(InputIterator first, InputIterator last, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
const Alloc& a);
template<class InputIterator, class Alloc>
constexpr flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
const key_compare& comp, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multiset(from_range_t, R&& rg, const Alloc& a);
template<container-compatible-range <value_type> R, class Alloc>
constexpr flat_multiset(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(initializer_list<value_type> il, const Alloc& a);
§ 23.6.12.4 © ISO/IEC
1112

===== PAGE 1124 =====

Dxxxx
template<class Alloc>
constexpr flat_multiset(initializer_list<value_type> il, const key_compare& comp,
const Alloc& a);
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, initializer_list<value_type> il, const Alloc& a);
template<class Alloc>
constexpr flat_multiset(sorted_equivalent_t, initializer_list<value_type> il,
const key_compare& comp, const Alloc& a);
6 Effects: Equivalent to the corresponding non-allocator constructors except thatc is constructed with
uses-allocator construction (20.2.8.2).
23.6.12.5 Modifiers [flat.multiset.modifiers]
template<class... Args> constexpr iterator emplace(Args&&... args);
1 Constraints: is_constructible_v<value_type, Args...> is true.
2 Effects: First, initializes an objectt of typevalue_type with std::forward<Args>(args)..., then
inserts t as if by:
auto it = ranges::upper_bound(c , t, compare );
c .insert(it, std::move(t));
3 Returns: An iterator that points to the inserted element.
template<class InputIterator>
constexpr void insert(InputIterator first, InputIterator last);
4 Effects: Adds elements toc as if by:
c .insert(c .end(), first, last);
Then, sorts the range of newly inserted elements with respect tocompare , and merges the resulting
sorted range and the sorted range of pre-existing elements into a single sorted range.
5 Complexity: N + Mlog M, where N is size() before the operation and M is distance(first,
last).
6 Remarks: Since this operation performs an in-place merge, it may allocate memory.
template<class InputIterator>
constexpr void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
7 Effects: Equivalent toinsert(first, last).
8 Complexity: Linear inN, whereN is size() after the operation.
template<container-compatible-range <value_type> R>
void insert_range(R&& rg);
9 Effects: Adds elements toc as if by:
ranges::for_each(rg, [&](auto&& e) {
c .insert(c .end(), std::forward<decltype(e)>(e));
});
Then, sorts the range of newly inserted elements with respect tocompare , and merges the resulting
sorted range and the sorted range of pre-existing elements into a single sorted range.
10 Complexity: N + Mlog M, whereN is size() before the operation andM is ranges::distance(rg).
11 Remarks: Since this operation performs an in-place merge, it may allocate memory.
template<container-compatible-range <value_type> R>
constexpr void insert_range(sorted_equivalent_t, R&& rg);
12 Effects: Equivalent toinsert_range(rg).
13 Complexity: Linear inN, whereN is size() after the operation.
constexpr void swap(flat_multiset& y)
noexcept(is_nothrow_swappable_v<container_type> &&
is_nothrow_swappable_v<key_compare>);
14 Effects: Equivalent to:
§ 23.6.12.5 © ISO/IEC
1113

===== PAGE 1125 =====

Dxxxx
ranges::swap(compare , y.compare );
ranges::swap(c , y.c );
constexpr container_type extract() &&;
15 Postconditions: *this is emptied, even if the function exits via an exception.
16 Returns: std::move(c ).
constexpr void replace(container_type&& cont);
17 Preconditions: The elements ofcont are sorted with respect tocompare .
18 Effects: Equivalent to:c = std::move(cont);
23.6.12.6 Erasure [flat.multiset.erasure]
template<class Key, class Compare, class KeyContainer, class Predicate>
constexpr typename flat_multiset<Key, Compare, KeyContainer>::size_type
erase_if(flat_multiset<Key, Compare, KeyContainer>& c, Predicate pred);
1 Preconditions: Key meets theCpp17MoveAssignable requirements.
2 Effects: Let E be bool(pred(as_const(e))). Erases all elementse in c for whichE holds.
3 Returns: The number of elements erased.
4 Complexity: Exactly c.size() applications of the predicate.
5 Remarks: Stable (16.4.6.8). If an invocation oferase_if exits via an exception,c is in a valid but
unspecified state (3.67).
[Note 1: c still meets its invariants, but can be empty.—end note]
23.6.13 Container adaptors formatting [container.adaptors.format]
1 For each ofqueue, priority_queue, andstack, the library provides the following formatter specialization
where adaptor-type is the name of the template:
namespace std {
template<class charT, class T, formattable<charT> Container, class... U>
struct formatter<adaptor-type <T, Container, U...>, charT> {
private:
using maybe-const-container = // exposition only
fmt-maybe-const <Container, charT>;
using maybe-const-adaptor = // exposition only
maybe-const <is_const_v<maybe-const-container >, // see 25.2
adaptor-type <T, Container, U...>>;
formatter<ranges::ref_view<maybe-const-container >, charT> underlying_; // exposition only
public:
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
template<class FormatContext>
typename FormatContext::iterator
format(maybe-const-adaptor & r, FormatContext& ctx) const;
};
}
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
2 Effects: Equivalent to:return underlying_.parse(ctx);
template<class FormatContext>
typename FormatContext::iterator
format(maybe-const-adaptor & r, FormatContext& ctx) const;
3 Effects: Equivalent to:return underlying_.format(r.c, ctx);
§ 23.6.13 © ISO/IEC
1114

===== PAGE 1126 =====

Dxxxx
23.7 Views [views]
23.7.1 General [views.general]
1 The header <span> (23.7.2.1) defines the viewspan. The header <mdspan> (23.7.3.2) defines the class
template mdspan and other facilities for interacting with these multidimensional views.
2 In addition to being available via inclusion of the<span> (23.7.2.1) header,dynamic_extent is available
when the header<mdspan> (23.7.3.2) is included.
23.7.2 Contiguous access [views.contiguous]
23.7.2.1 Header <span> synopsis [span.syn]
#include <initializer_list> // see 17.11.2
// mostly freestanding
namespace std {
// constants
inline constexpr size_t dynamic_extent = numeric_limits<size_t>::max();
template<class T>
concept integral-constant-like = // exposition only
is_integral_v<remove_cvref_t<decltype(T::value)>> &&
!is_same_v<bool, remove_cvref_t<decltype(T::value)>> &&
convertible_to<T, decltype(T::value)> &&
equality_comparable_with<T, decltype(T::value)> &&
bool_constant<T() == T::value>::value &&
bool_constant<static_cast<decltype(T::value)>(T()) == T::value>::value;
template<class T>
constexpr size_t maybe-static-ext = dynamic_extent; // exposition only
template<integral-constant-like T>
constexpr size_t maybe-static-ext <T> = {T::value};
// 23.7.2.2, class templatespan
template<class ElementType, size_t Extent = dynamic_extent>
class span; // partially freestanding
template<class ElementType, size_t Extent>
constexpr bool ranges::enable_view<span<ElementType, Extent>> = true;
template<class ElementType, size_t Extent>
constexpr bool ranges::enable_borrowed_range<span<ElementType, Extent>> = true;
// 23.7.2.3, views of object representation
template<class ElementType, size_t Extent>
span<const byte, Extent == dynamic_extent ? dynamic_extent : sizeof(ElementType) * Extent>
as_bytes(span<ElementType, Extent> s) noexcept;
template<class ElementType, size_t Extent>
span<byte, Extent == dynamic_extent ? dynamic_extent : sizeof(ElementType) * Extent>
as_writable_bytes(span<ElementType, Extent> s) noexcept;
}
23.7.2.2 Class template span [views.span]
23.7.2.2.1 Overview [span.overview]
1 A span is a view over a contiguous sequence of objects, the storage of which is owned by some other object.
2 All member functions ofspan have constant time complexity.
namespace std {
template<class ElementType, size_t Extent = dynamic_extent>
class span {
public:
// constants and types
using element_type = ElementType;
using value_type = remove_cv_t<ElementType>;
§ 23.7.2.2.1 © ISO/IEC
1115

===== PAGE 1127 =====

Dxxxx
using size_type = size_t;
using difference_type = ptrdiff_t;
using pointer = element_type*;
using const_pointer = const element_type*;
using reference = element_type&;
using const_reference = const element_type&;
using iterator = implementation-defined ; // see 23.7.2.2.7
using const_iterator = std::const_iterator<iterator>;
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::const_iterator<reverse_iterator>;
static constexpr size_type extent = Extent;
// 23.7.2.2.2, constructors, copy, and assignment
constexpr span() noexcept;
template<class It>
constexpr explicit(extent != dynamic_extent) span(It first, size_type count);
template<class It, class End>
constexpr explicit(extent != dynamic_extent) span(It first, End last);
template<size_t N>
constexpr span(type_identity_t<element_type> (&arr)[N]) noexcept;
template<class T, size_t N>
constexpr span(array<T, N>& arr) noexcept;
template<class T, size_t N>
constexpr span(const array<T, N>& arr) noexcept;
template<class R>
constexpr explicit(extent != dynamic_extent) span(R&& r);
constexpr explicit(extent != dynamic_extent) span(std::initializer_list<value_type> il);
constexpr span(const span& other) noexcept = default;
template<class OtherElementType, size_t OtherExtent>
constexpr explicit(see below ) span(const span<OtherElementType, OtherExtent>& s) noexcept;
constexpr span& operator=(const span& other) noexcept = default;
// 23.7.2.2.4, subviews
template<size_t Count>
constexpr span<element_type, Count> first() const;
template<size_t Count>
constexpr span<element_type, Count> last() const;
template<size_t Offset, size_t Count = dynamic_extent>
constexpr span<element_type, see below > subspan() const;
constexpr span<element_type, dynamic_extent> first(size_type count) const;
constexpr span<element_type, dynamic_extent> last(size_type count) const;
constexpr span<element_type, dynamic_extent> subspan(
size_type offset, size_type count = dynamic_extent) const;
// 23.7.2.2.5, observers
constexpr size_type size() const noexcept;
constexpr size_type size_bytes() const noexcept;
constexpr bool empty() const noexcept;
// 23.7.2.2.6, element access
constexpr reference operator[](size_type idx) const;
constexpr reference at(size_type idx) const; // freestanding-deleted
constexpr reference front() const;
constexpr reference back() const;
constexpr pointer data() const noexcept;
// 23.7.2.2.7, iterator support
constexpr iterator begin() const noexcept;
constexpr iterator end() const noexcept;
constexpr const_iterator cbegin() const noexcept { return begin(); }
constexpr const_iterator cend() const noexcept { return end(); }
constexpr reverse_iterator rbegin() const noexcept;
§ 23.7.2.2.1 © ISO/IEC
1116

===== PAGE 1128 =====

Dxxxx
constexpr reverse_iterator rend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept { return rbegin(); }
constexpr const_reverse_iterator crend() const noexcept { return rend(); }
private:
pointer data_; // exposition only
size_type size_; // exposition only
};
template<class It, class EndOrSize>
span(It, EndOrSize) -> span<remove_reference_t<iter_reference_t<It>>,
maybe-static-ext <EndOrSize>>;
template<class T, size_t N>
span(T (&)[N]) -> span<T, N>;
template<class T, size_t N>
span(array<T, N>&) -> span<T, N>;
template<class T, size_t N>
span(const array<T, N>&) -> span<const T, N>;
template<class R>
span(R&&) -> span<remove_reference_t<ranges::range_reference_t<R>>>;
}
3 span<ElementType, Extent> is a trivially copyable type (6.9.1).
4 ElementType is required to be a complete object type that is not an abstract class type.
5 For a span s, any operation that invalidates a pointer in the range[s.data(),s.data() + s.size())
invalidates pointers, iterators, and references to elements ofs.
23.7.2.2.2 Constructors, copy, and assignment [span.cons]
constexpr span() noexcept;
1 Constraints: Extent == dynamic_extent || Extent == 0 is true.
2 Postconditions: size() == 0 && data() == nullptr.
template<class It>
constexpr explicit(extent != dynamic_extent) span(It first, size_type count);
3 Constraints: Let U be remove_reference_t<iter_reference_t<It>>.
—(3.1) It satisfies contiguous_iterator.
—(3.2) is_convertible_v<U(*)[], element_type(*)[]> is true.
[Note 1: The intent is to allow only qualification conversions of the iterator reference type toelement_type.
—end note]
4 Preconditions:
—(4.1) [first,first + count) is a valid range.
—(4.2) It models contiguous_iterator.
5 Hardened preconditions: If extent is not equal todynamic_extent, thencount == extent is true.
6 Effects: Initializes data_ with to_address(first) and size_ with count.
7 Throws: Nothing.
template<class It, class End>
constexpr explicit(extent != dynamic_extent) span(It first, End last);
8 Constraints: Let U be remove_reference_t<iter_reference_t<It>>.
—(8.1) is_convertible_v<U(*)[], element_type(*)[]> is true.
[Note 2: The intent is to allow only qualification conversions of the iterator reference type toelement_type.
—end note]
—(8.2) It satisfies contiguous_iterator.
—(8.3) End satisfies sized_sentinel_for<It>.
—(8.4) is_convertible_v<End, size_t> is false.
§ 23.7.2.2.2 © ISO/IEC
1117

===== PAGE 1129 =====

Dxxxx
9 Preconditions:
—(9.1) [first,last) is a valid range.
—(9.2) It models contiguous_iterator.
—(9.3) End models sized_sentinel_for<It>.
10 Hardened preconditions: If extent is not equal todynamic_extent, then(last - first) == extent
is true.
11 Effects: Initializes data_ with to_address(first) and size_ with last - first.
12 Throws: When and whatlast - first throws.
template<size_t N> constexpr span(type_identity_t<element_type> (&arr)[N]) noexcept;
template<class T, size_t N> constexpr span(array<T, N>& arr) noexcept;
template<class T, size_t N> constexpr span(const array<T, N>& arr) noexcept;
13 Constraints: Let U be remove_pointer_t<decltype(std::data(arr))>.
—(13.1) extent == dynamic_extent || N == extent is true, and
—(13.2) is_convertible_v<U(*)[], element_type(*)[]> is true.
[Note 3: The intent is to allow only qualification conversions of the array element type toelement_type.
—end note]
14 Effects: Constructs aspan that is a view over the supplied array.
[Note 4: type_identity_t affects class template argument deduction.—end note]
15 Postconditions: size() == N && data() == std::data(arr) is true.
template<class R> constexpr explicit(extent != dynamic_extent) span(R&& r);
16 Constraints: Let U be remove_reference_t<ranges::range_reference_t<R>>.
—(16.1) R satisfies ranges::contiguous_range and ranges::sized_range.
—(16.2) Either R satisfies ranges::borrowed_range or is_const_v<element_type> is true.
—(16.3) remove_cvref_t<R> is not a specialization ofspan.
—(16.4) remove_cvref_t<R> is not a specialization ofarray.
—(16.5) is_array_v<remove_cvref_t<R>> is false.
—(16.6) is_convertible_v<U(*)[], element_type(*)[]> is true.
[Note 5: The intent is to allow only qualification conversions of the range reference type toelement_type.
—end note]
17 Preconditions:
—(17.1) R models ranges::contiguous_range and ranges::sized_range.
—(17.2) If is_const_v<element_type> is false, R models ranges::borrowed_range.
18 Hardened preconditions: If extentis not equal todynamic_extent, thenranges::size(r) == extent
is true.
19 Effects: Initializes data_ with ranges::data(r) and size_ with ranges::size(r).
20 Throws: What and whenranges::data(r) and ranges::size(r) throw.
constexpr explicit(extent != dynamic_extent) span(std::initializer_list<value_type> il);
21 Constraints: is_const_v<element_type> is true.
22 Hardened preconditions: If extent is not equal todynamic_extent, then il.size() == extent is
true.
23 Effects: Initializes data_ with il.data() and size_ with il.size().
constexpr span(const span& other) noexcept = default;
24 Postconditions: other.size() == size() && other.data() == data().
§ 23.7.2.2.2 © ISO/IEC
1118

===== PAGE 1130 =====

Dxxxx
template<class OtherElementType, size_t OtherExtent>
constexpr explicit(see below ) span(const span<OtherElementType, OtherExtent>& s) noexcept;
25 Constraints:
—(25.1) extent == dynamic_extent || OtherExtent == dynamic_extent || extent == OtherExtent
is true, and
—(25.2) is_convertible_v<OtherElementType(*)[], element_type(*)[]> is true.
[Note 6: The intent is to allow only qualification conversions of theOtherElementType to element_type.
—end note]
26 Hardened preconditions: If extent is not equal todynamic_extent, thens.size() == extent is true.
27 Effects: Constructs aspan that is a view over the range[s.data(),s.data() + s.size()).
28 Postconditions: size() == s.size() && data() == s.data().
29 Remarks: The expression insideexplicit is equivalent to:
extent != dynamic_extent && OtherExtent == dynamic_extent
constexpr span& operator=(const span& other) noexcept = default;
30 Postconditions: size() == other.size() && data() == other.data().
23.7.2.2.3 Deduction guides [span.deduct]
template<class It, class EndOrSize>
span(It, EndOrSize) -> span<remove_reference_t<iter_reference_t<It>>,
maybe-static-ext <EndOrSize>>;
1 Constraints: It satisfies contiguous_iterator.
template<class R>
span(R&&) -> span<remove_reference_t<ranges::range_reference_t<R>>>;
2 Constraints: R satisfies ranges::contiguous_range.
23.7.2.2.4 Subviews [span.sub]
template<size_t Count> constexpr span<element_type, Count> first() const;
1 Mandates: Count <= Extent is true.
2 Hardened preconditions: Count <= size() is true.
3 Effects: Equivalent to:return R(data(), Count); where R is the return type.
template<size_t Count> constexpr span<element_type, Count> last() const;
4 Mandates: Count <= Extent is true.
5 Hardened preconditions: Count <= size() is true.
6 Effects: Equivalent to:return R(data() + (size() - Count), Count); where R is the return type.
template<size_t Offset, size_t Count = dynamic_extent>
constexpr span<element_type, see below > subspan() const;
7 Mandates:
Offset <= Extent && (Count == dynamic_extent || Count <= Extent - Offset)
is true.
8 Hardened preconditions:
Offset <= size() && (Count == dynamic_extent || Count <= size() - Offset)
is true.
9 Effects: Equivalent to:
return span<ElementType, see below >(
data() + Offset, Count != dynamic_extent ? Count : size() - Offset);
10 Remarks: The second template argument of the returnedspan type is:
§ 23.7.2.2.4 © ISO/IEC
1119

===== PAGE 1131 =====

Dxxxx
Count != dynamic_extent ? Count
: (Extent != dynamic_extent ? Extent - Offset
: dynamic_extent)
constexpr span<element_type, dynamic_extent> first(size_type count) const;
11 Hardened preconditions: count <= size() is true.
12 Effects: Equivalent to:return R(data(), count); where R is the return type.
constexpr span<element_type, dynamic_extent> last(size_type count) const;
13 Hardened preconditions: count <= size() is true.
14 Effects: Equivalent to:return R(data() + (size() - count), count); where R is the return type.
constexpr span<element_type, dynamic_extent> subspan(
size_type offset, size_type count = dynamic_extent) const;
15 Hardened preconditions:
offset <= size() && (count == dynamic_extent || count <= size() - offset)
is true.
16 Effects: Equivalent to:
return R(data() + offset, count == dynamic_extent ? size() - offset : count);
where R is the return type.
23.7.2.2.5 Observers [span.obs]
constexpr size_type size() const noexcept;
1 Effects: Equivalent to:return size_;
constexpr size_type size_bytes() const noexcept;
2 Effects: Equivalent to:return size() * sizeof(element_type);
constexpr bool empty() const noexcept;
3 Effects: Equivalent to:return size() == 0;
23.7.2.2.6 Element access [span.elem]
constexpr reference operator[](size_type idx) const;
1 Hardened preconditions: idx < size() is true.
2 Returns: *(data() + idx).
3 Throws: Nothing.
constexpr reference at(size_type idx) const;
4 Returns: *(data() + idx).
5 Throws: out_of_range if idx >= size() is true.
constexpr reference front() const;
6 Hardened preconditions: empty() is false.
7 Returns: *data().
8 Throws: Nothing.
constexpr reference back() const;
9 Hardened preconditions: empty() is false.
10 Returns: *(data() + (size() - 1)).
11 Throws: Nothing.
constexpr pointer data() const noexcept;
12 Returns: data_.
§ 23.7.2.2.6 © ISO/IEC
1120

===== PAGE 1132 =====

Dxxxx
23.7.2.2.7 Iterator support [span.iterators]
using iterator = implementation-defined ;
1 The type modelscontiguous_iterator (24.3.4.14), meets theCpp17RandomAccessIteratorrequire-
ments (24.3.5.7), and meets the requirements for constexpr iterators (24.3.1), whose value type is
value_type and whose reference type isreference.
2 All requirements on container iterators (23.2.2.2) apply tospan::iterator as well.
constexpr iterator begin() const noexcept;
3 Returns: An iterator referring to the first element in the span. Ifempty() is true, then it returns the
same value asend().
constexpr iterator end() const noexcept;
4 Returns: An iterator which is the past-the-end value.
constexpr reverse_iterator rbegin() const noexcept;
5 Effects: Equivalent to:return reverse_iterator(end());
constexpr reverse_iterator rend() const noexcept;
6 Effects: Equivalent to:return reverse_iterator(begin());
23.7.2.3 Views of object representation [span.objectrep]
template<class ElementType, size_t Extent>
span<const byte, Extent == dynamic_extent ? dynamic_extent : sizeof(ElementType) * Extent>
as_bytes(span<ElementType, Extent> s) noexcept;
1 Constraints: is_volatile_v<ElementType> is false.
2 Effects: Equivalent to:return R{reinterpret_cast<const byte*>(s.data()), s.size_bytes()};
where R is the return type.
template<class ElementType, size_t Extent>
span<byte, Extent == dynamic_extent ? dynamic_extent : sizeof(ElementType) * Extent>
as_writable_bytes(span<ElementType, Extent> s) noexcept;
3 Constraints: is_const_v<ElementType> is false and is_volatile_v<ElementType> is false.
4 Effects: Equivalent to:return R{reinterpret_cast<byte*>(s.data()), s.size_bytes()}; where
R is the return type.
23.7.3 Multidimensional access [views.multidim]
23.7.3.1 Overview [mdspan.overview]
1 A multidimensional index spaceis a Cartesian product of integer intervals. Each interval can be represented
by a half-open range[Li,Ui), whereLi and Ui are the lower and upper bounds of theith dimension. Therank
of a multidimensional index space is the number of intervals it represents. Thesize of a multidimensional
index spaceis the product ofUi −Li for each dimensioni if its rank is greater than 0, and 1 otherwise.
2 An integerr is arank indexof an index spaceS if r is in the range[0,rank ofS).
3 A pack of integersidx is amultidimensional index in a multidimensional index spaceS (or representation
thereof) if both of the following are true:
—(3.1) sizeof...(idx) is equal to the rank ofS, and
—(3.2) for every rank indexi of S, theith value ofidx is an integer in the interval[Li,Ui) of S.
23.7.3.2 Header <mdspan> synopsis [mdspan.syn]
// mostly freestanding
namespace std {
// 23.7.3.3, class templateextents
template<class IndexType, size_t... Extents>
class extents;
§ 23.7.3.2 © ISO/IEC
1121

===== PAGE 1133 =====

Dxxxx
// 23.7.3.3.6, alias templatedextents
template<class IndexType, size_t Rank>
using dextents = see below ;
// 23.7.3.3.7, alias templatedims
template<size_t Rank, class IndexType = size_t>
using dims = see below ;
// 23.7.3.4, layout mapping
struct layout_left;
struct layout_right;
struct layout_stride;
template<size_t PaddingValue = dynamic_extent>
struct layout_left_padded;
template<size_t PaddingValue = dynamic_extent>
struct layout_right_padded;
// 23.7.3.5.3, class templatedefault_accessor
template<class ElementType>
class default_accessor;
// 23.7.3.5.4, class templatealigned_accessor
template<class ElementType, size_t ByteAlignment>
class aligned_accessor;
// 23.7.3.6, class templatemdspan
template<class ElementType, class Extents, class LayoutPolicy = layout_right,
class AccessorPolicy = default_accessor<ElementType>>
class mdspan; // partially freestanding
// 23.7.3.7,submdspan creation
template<class OffsetType, class LengthType, class StrideType>
struct strided_slice;
template<class LayoutMapping>
struct submdspan_mapping_result;
struct full_extent_t { explicit full_extent_t() = default; };
inline constexpr full_extent_t full_extent{};
template<class IndexType, size_t... Extents, class... SliceSpecifiers>
constexpr auto submdspan_extents(const extents<IndexType, Extents...>&, SliceSpecifiers...);
// 23.7.3.7.5,submdspan slice canonicalization
template<class IndexType, size_t... Extents, class... Slices>
constexpr auto submdspan_canonicalize_slices(const extents<IndexType, Extents...>& src,
Slices... slices);
// 23.7.3.7.8,submdspan function template
template<class ElementType, class Extents, class LayoutPolicy,
class AccessorPolicy, class... SliceSpecifiers>
constexpr auto submdspan(
const mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>& src,
SliceSpecifiers... slices) -> see below ;
template<class T, class IndexType>
concept index-pair-like = // exposition only
pair-like <T> &&
convertible_to<tuple_element_t<0, T>, IndexType> &&
convertible_to<tuple_element_t<1, T>, IndexType>;
}
§ 23.7.3.2 © ISO/IEC
1122

===== PAGE 1134 =====

Dxxxx
23.7.3.3 Class template extents [mdspan.extents]
23.7.3.3.1 Overview [mdspan.extents.overview]
The class templateextents represents a multidimensional index space of rank equal tosizeof...(Extents).
In 23.7,extents is used synonymously with multidimensional index space.
namespace std {
template<class IndexType, size_t... Extents>
class extents {
public:
using index_type = IndexType;
using size_type = make_unsigned_t<index_type>;
using rank_type = size_t;
// 23.7.3.3.4, observers of the multidimensional index space
static constexpr rank_type rank() noexcept { return sizeof...(Extents); }
static constexpr rank_type rank_dynamic() noexcept { return dynamic-index (rank()); }
static constexpr size_t static_extent(rank_type) noexcept;
constexpr index_type extent(rank_type) const noexcept;
// 23.7.3.3.3, constructors
constexpr extents() noexcept = default;
template<class OtherIndexType, size_t... OtherExtents>
constexpr explicit(see below )
extents(const extents<OtherIndexType, OtherExtents...>&) noexcept;
template<class... OtherIndexTypes>
constexpr explicit extents(OtherIndexTypes...) noexcept;
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
extents(span<OtherIndexType, N>) noexcept;
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
extents(const array<OtherIndexType, N>&) noexcept;
// 23.7.3.3.5, comparison operators
template<class OtherIndexType, size_t... OtherExtents>
friend constexpr bool operator==(const extents&,
const extents<OtherIndexType, OtherExtents...>&) noexcept;
// 23.7.3.3.2, exposition-only helpers
constexpr size_t fwd-prod-of-extents (rank_type) const noexcept; // exposition only
constexpr size_t rev-prod-of-extents (rank_type) const noexcept; // exposition only
template<class OtherIndexType>
static constexpr auto index-cast (OtherIndexType&&) noexcept; // exposition only
private:
static constexpr rank_type dynamic-index (rank_type) noexcept; // exposition only
static constexpr rank_type dynamic-index-inv (rank_type) noexcept; // exposition only
array<index_type, rank_dynamic()> dynamic-extents {}; // exposition only
};
template<class... Integrals>
explicit extents(Integrals...)
-> see below ;
}
1 Mandates:
—(1.1) IndexType is a signed or unsigned integer type, and
—(1.2) each element ofExtents is either equal todynamic_extent, or is representable as a value of type
IndexType.
2 Each specialization ofextents models regular and is trivially copyable.
§ 23.7.3.3.1 © ISO/IEC
1123

===== PAGE 1135 =====

Dxxxx
3 Let Er be therth element ofExtents. Er is adynamic extentif it is equal todynamic_extent, otherwiseEr
is astatic extent. Let Dr be the value ofdynamic-extents [dynamic-index (r)] if Er is a dynamic extent,
otherwise Er.
4 The rth interval of the multidimensional index space represented by anextents object is[0,Dr).
23.7.3.3.2 Exposition-only helpers [mdspan.extents.expo]
static constexpr rank_type dynamic-index (rank_type i) noexcept;
1 Preconditions: i <= rank() is true.
2 Returns: The number ofEr with r< i for whichEr is a dynamic extent.
static constexpr rank_type dynamic-index-inv (rank_type i) noexcept;
3 Preconditions: i < rank_dynamic() is true.
4 Returns: The minimum value ofr such thatdynamic-index (r + 1) == i + 1 is true.
constexpr size_t fwd-prod-of-extents (rank_type i) const noexcept;
5 Preconditions: i <= rank() is true.
6 Returns: If i > 0 is true, the product ofextent(k) for allk in the range[0,i), otherwise1.
constexpr size_t rev-prod-of-extents (rank_type i) const noexcept;
7 Preconditions: i < rank() is true.
8 Returns: If i + 1 < rank() is true, the product ofextent(k) for allk in the range[i + 1,rank()),
otherwise 1.
template<class OtherIndexType>
static constexpr auto index-cast (OtherIndexType&& i) noexcept;
9 Effects:
—(9.1) If remove_cvref_t<OtherIndexType> is an integral type other thanbool, then equivalent to
return i;,
—(9.2) otherwise, equivalent toreturn static_cast<index_type>(i);.
[Note 1: This function will always return an integral type other thanbool. Since this function’s call sites are
constrained on convertibility ofOtherIndexType to index_type, integer-class types can use thestatic_cast
branch without loss of precision.—end note]
23.7.3.3.3 Constructors [mdspan.extents.cons]
template<class OtherIndexType, size_t... OtherExtents>
constexpr explicit(see below )
extents(const extents<OtherIndexType, OtherExtents...>& other) noexcept;
1 Constraints:
—(1.1) sizeof...(OtherExtents) == rank() is true.
—(1.2) ((OtherExtents == dynamic_extent || Extents == dynamic_extent || OtherExtents ==
Extents) && ...) is true.
2 Preconditions:
—(2.1) other.extent(r) equals Er for eachr for whichEr is a static extent, and
—(2.2) either
—(2.2.1) sizeof...(OtherExtents) is zero, or
—(2.2.2) other.extent(r) is representable as a value of typeindex_type for every rank indexr of
other.
3 Postconditions: *this == other is true.
4 Remarks: The expression insideexplicit is equivalent to:
(((Extents != dynamic_extent) && (OtherExtents == dynamic_extent)) || ... ) ||
(numeric_limits<index_type>::max() < numeric_limits<OtherIndexType>::max())
§ 23.7.3.3.3 © ISO/IEC
1124

===== PAGE 1136 =====

Dxxxx
template<class... OtherIndexTypes>
constexpr explicit extents(OtherIndexTypes... exts) noexcept;
5 Let N be sizeof...(OtherIndexTypes), and letexts_arr be array<index_type, N>{static_cast<
index_type>(std::move(exts))...}.
6 Constraints:
—(6.1) (is_convertible_v<OtherIndexTypes, index_type> && ...) is true,
—(6.2) (is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...) is true, and
—(6.3) N == rank_dynamic() || N == rank() is true.
[Note 1: One can constructextents from just dynamic extents, which are all the values getting stored, or
from all the extents with a precondition.—end note]
7 Preconditions:
—(7.1) If N != rank_dynamic() is true, exts_arr[r] equals Er for each r for which Er is a static
extent, and
—(7.2) either
—(7.2.1) sizeof...(exts) == 0 is true, or
—(7.2.2) each element ofexts is representable as a nonnegative value of typeindex_type.
8 Postconditions: *this == extents(exts_arr) is true.
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
extents(span<OtherIndexType, N> exts) noexcept;
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
extents(const array<OtherIndexType, N>& exts) noexcept;
9 Constraints:
—(9.1) is_convertible_v<const OtherIndexType&, index_type> is true,
—(9.2) is_nothrow_constructible_v<index_type, const OtherIndexType&> is true, and
—(9.3) N == rank_dynamic() || N == rank() is true.
10 Preconditions:
—(10.1) If N != rank_dynamic() is true, exts[r] equals Er for eachr for whichEr is a static extent,
and
—(10.2) either
—(10.2.1) N is zero, or
—(10.2.2) exts[r] is representable as a nonnegative value of typeindex_type for every rank indexr.
11 Effects:
—(11.1) If N equals rank_dynamic(), for alld in the range[0,rank_dynamic()), direct-non-list-initializes
dynamic-extents[d] with as_const(exts[d]).
—(11.2) Otherwise, for all d in the range [0,rank_dynamic()), direct-non-list-initializes dynamic-ex-
tents[d] with as_const(exts[dynamic-index-inv(d)]).
template<class... Integrals>
explicit extents(Integrals...) -> see below ;
12 Constraints: (is_convertible_v<Integrals, size_t> && ...) is true.
13 Remarks: The deduced type isextents<size_t, maybe-static-ext <Integrals>...>.
23.7.3.3.4 Observers of the multidimensional index space [mdspan.extents.obs]
static constexpr size_t static_extent(rank_type i) noexcept;
1 Preconditions: i < rank() is true.
2 Returns: Ei.
§ 23.7.3.3.4 © ISO/IEC
1125

===== PAGE 1137 =====

Dxxxx
constexpr index_type extent(rank_type i) const noexcept;
3 Preconditions: i < rank() is true.
4 Returns: Di.
23.7.3.3.5 Comparison operators [mdspan.extents.cmp]
template<class OtherIndexType, size_t... OtherExtents>
friend constexpr bool operator==(const extents& lhs,
const extents<OtherIndexType, OtherExtents...>& rhs) noexcept;
1 Returns: true if lhs.rank() equals rhs.rank() and if lhs.extent(r) equals rhs.extent(r) for
every rank indexr of rhs, otherwisefalse.
23.7.3.3.6 Alias template dextents [mdspan.extents.dextents]
template<class IndexType, size_t Rank>
using dextents = see below ;
1 Result: A typeE that is a specialization ofextents such thatE::rank() == Rank && E::rank() ==
E::rank_dynamic() is true, andE::index_type denotes IndexType.
23.7.3.3.7 Alias template dims [mdspan.extents.dims]
template<size_t Rank, class IndexType = size_t>
using dims = see below ;
1 Result: A typeE that is a specialization ofextents such thatE::rank() == Rank && E::rank() ==
E::rank_dynamic() is true, andE::index_type denotes IndexType.
23.7.3.4 Layout mapping [mdspan.layout]
23.7.3.4.1 General [mdspan.layout.general]
1 In 23.7.3.4.2 and 23.7.3.4.3:
—(1.1) M denotes a layout mapping class.
—(1.2) m denotes a (possibly const) value of typeM.
—(1.3) iandjare packs of (possibly const) integers that are multidimensional indices inm.extents()(23.7.3.1).
[Note 1: The type of each element of the packs can be a different integer type.—end note]
—(1.4) r is a (possibly const) rank index oftypename M::extents_type.
—(1.5) dr is a pack of (possibly const) integers for whichsizeof...(dr) == M::extents_type::rank() is
true, therth element is equal to 1, and all other elements are equal to 0.
2 In 23.7.3.4.2 through 23.7.3.4.7:
—(2.1) Let is-mapping-of be the exposition-only variable template defined as follows:
template<class Layout, class Mapping>
constexpr bool is-mapping-of = // exposition only
is_same_v<typename Layout::template mapping<typename Mapping::extents_type>, Mapping>;
—(2.2) Let is-layout-left-padded-mapping-of be the exposition-only variable template defined as follows:
template<class Mapping>
constexpr bool is-layout-left-padded-mapping-of = see below ; // exposition only
where is-layout-left-padded-mapping-of <Mapping> is true if and only if Mapping denotes a
specialization of layout_left_padded<S>::mapping for some valueS of typesize_t.
—(2.3) Letis-layout-right-padded-mapping-of betheexposition-onlyvariabletemplatedefinedasfollows:
template<class Mapping>
constexpr bool is-layout-right-padded-mapping-of = see below ; // exposition only
where is-layout-right-padded-mapping-of <Mapping> is true if and only if Mapping denotes a
specialization of layout_right_padded<S>::mapping for some valueS of typesize_t.
—(2.4) For nonnegative integersx and y, letLEAST-MULTIPLE-AT-LEAST (x,y) denote
—(2.4.1) y if x is zero,
§ 23.7.3.4.1 © ISO/IEC
1126

===== PAGE 1138 =====

Dxxxx
—(2.4.2) otherwise, the least multiple ofx that is greater than or equal toy.
23.7.3.4.2 Requirements [mdspan.layout.reqmts]
1 A typeM meets thelayout mappingrequirements if
—(1.1) M models copyable and equality_comparable,
—(1.2) is_nothrow_move_constructible_v<M> is true,
—(1.3) is_nothrow_move_assignable_v<M> is true,
—(1.4) is_nothrow_swappable_v<M> is true, and
—(1.5) the following types and expressions are well-formed and have the specified semantics.
typename M::extents_type
2 Result: A type that is a specialization ofextents.
typename M::index_type
3 Result: typename M::extents_type::index_type.
typename M::rank_type
4 Result: typename M::extents_type::rank_type.
typename M::layout_type
5 Result: A type MP that meets the layout mapping policy requirements (23.7.3.4.3) and for which
is-mapping-of <MP, M> is true.
m.extents()
6 Result: const typename M::extents_type&
m(i...)
7 Result: typename M::index_type
8 Returns: A nonnegative integer less thannumeric_limits<typename M::index_type>::max() and
less than or equal tonumeric_limits<size_t>::max().
m(i...) == m(static_cast<typename M::index_type>(i)...)
9 Result: bool
10 Returns: true
m.required_span_size()
11 Result: typename M::index_type
12 Returns: If the size of the multidimensional index spacem.extents() is 0, then0, else 1 plus the
maximum value ofm(i...) for alli.
m.is_unique()
13 Result: bool
14 Returns: true only if for everyi and j where (i != j || ...) is true, m(i...) != m(j...) is true.
[Note 1: A mapping can returnfalse even if the condition is met. For certain layouts, it is possibly not feasible
to determine efficiently whether the layout is unique.—end note]
m.is_exhaustive()
15 Result: bool
16 Returns: true only if for allk in the range[0,m.required_span_size()) there exists ani such that
m(i...) equals k.
[Note 2: A mapping can returnfalse even if the condition is met. For certain layouts, it is possibly not feasible
to determine efficiently whether the layout is exhaustive.—end note]
m.is_strided()
17 Result: bool
§ 23.7.3.4.2 © ISO/IEC
1127

===== PAGE 1139 =====

Dxxxx
18 Returns: true only if for every rank indexr of m.extents() there exists an integersr such that, for all
i where (i+ dr) is a multidimensional index inm.extents() (23.7.3.1), m((i + dr)...) - m(i...)
equals sr.
[Note 3: This implies that for a strided layoutm(i0,...,i k) =m(0,..., 0) +i0 ×s0 + ··· + ik ×sk. —end note]
[Note 4: A mapping can returnfalse even if the condition is met. For certain layouts, it is possibly not feasible
to determine efficiently whether the layout is strided.—end note]
m.stride(r)
19 Preconditions: m.is_strided() is true.
20 Result: typename M::index_type
21 Returns: sr as defined inm.is_strided() above.
22 [Note 5: It is not required form.stride(r) to be well-formed ifm.extents().rank() is zero, even ifm.is_-
always_strided() is true. —end note]
M::is_always_unique()
23 Result: A constant expression (7.7) of typebool.
24 Returns: true only ifm.is_unique() is true for all possible objectsm of typeM.
[Note 6: A mapping can returnfalse even if the above condition is met. For certain layout mappings, it is
possibly not feasible to determine whether every instance is unique.—end note]
M::is_always_exhaustive()
25 Result: A constant expression (7.7) of typebool.
26 Returns: true only ifm.is_exhaustive() is true for all possible objectsm of typeM.
[Note 7: A mapping can returnfalse even if the above condition is met. For certain layout mappings, it is
possibly not feasible to determine whether every instance is exhaustive.—end note]
M::is_always_strided()
27 Result: A constant expression (7.7) of typebool.
28 Returns: true only ifm.is_strided() is true for all possible objectsm of typeM.
[Note 8: A mapping can returnfalse even if the above condition is met. For certain layout mappings, it is
possibly not feasible to determine whether every instance is strided.—end note]
23.7.3.4.3 Layout mapping policy requirements [mdspan.layout.policy.reqmts]
1 A typeMP meets thelayout mapping policyrequirements if for a typeE that is a specialization ofextents,
MP::mapping<E>is valid and denotes a typeXthat meets the layout mapping requirements (23.7.3.4.2), and for
which thequalified-id X::layout_type is valid and denotes the typeMP and thequalified-id X::extents_type
denotes E.
23.7.3.4.4 Layout mapping policies [mdspan.layout.policy.overview]
namespace std {
struct layout_left {
template<class Extents>
class mapping;
};
struct layout_right {
template<class Extents>
class mapping;
};
struct layout_stride {
template<class Extents>
class mapping;
};
template<size_t PaddingValue>
struct layout_left_padded {
template<class Extents> class mapping;
};
§ 23.7.3.4.4 © ISO/IEC
1128

===== PAGE 1140 =====

Dxxxx
template<size_t PaddingValue>
struct layout_right_padded {
template<class Extents> class mapping;
};
}
1 Each oflayout_left, layout_right, andlayout_stride, as well as each specialization oflayout_left_-
padded and layout_right_padded, meets the layout mapping policy requirements and is a trivially copyable
type. Furthermore,is_trivially_default_constructible_v<T> is true for any such typeT.
23.7.3.4.5 Class template layout_left::mapping [mdspan.layout.left]
23.7.3.4.5.1 Overview [mdspan.layout.left.overview]
1 layout_left provides a layout mapping where the leftmost extent has stride 1, and strides increase left-to-
right as the product of extents.
namespace std {
template<class Extents>
class layout_left::mapping {
public:
using extents_type = Extents;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using layout_type = layout_left;
// 23.7.3.4.5.2, constructors
constexpr mapping() noexcept = default;
constexpr mapping(const mapping&) noexcept = default;
constexpr mapping(const extents_type&) noexcept;
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const mapping<OtherExtents>&) noexcept;
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_right::mapping<OtherExtents>&) noexcept;
template<class LayoutLeftPaddedMapping>
constexpr explicit(!is_convertible_v<typename LayoutLeftPaddedMapping::extents_type,
extents_type>)
mapping(const LayoutLeftPaddedMapping&) noexcept;
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>&);
constexpr mapping& operator=(const mapping&) noexcept = default;
// 23.7.3.4.5.3, observers
constexpr const extents_type& extents() const noexcept { return extents_; }
constexpr index_type required_span_size() const noexcept;
template<class... Indices>
constexpr index_type operator()(Indices...) const noexcept;
static constexpr bool is_always_unique() noexcept { return true; }
static constexpr bool is_always_exhaustive() noexcept { return true; }
static constexpr bool is_always_strided() noexcept { return true; }
static constexpr bool is_unique() noexcept { return true; }
static constexpr bool is_exhaustive() noexcept { return true; }
static constexpr bool is_strided() noexcept { return true; }
constexpr index_type stride(rank_type) const noexcept;
§ 23.7.3.4.5 © ISO/IEC
1129

===== PAGE 1141 =====

Dxxxx
template<class OtherExtents>
friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;
private:
extents_type extents_{}; // exposition only
// 23.7.3.7.7,submdspan mapping specialization
template<class... SliceSpecifiers>
constexpr auto submdspan-mapping-impl (SliceSpecifiers...) const // exposition only
-> see below ;
template<class... SliceSpecifiers>
friend constexpr auto submdspan_mapping(
const mapping& src, SliceSpecifiers... slices) {
return src.submdspan-mapping-impl (slices...);
}
};
}
2 If Extents is not a specialization ofextents, then the program is ill-formed.
3 layout_left::mapping<E> is a trivially copyable type that modelsregular for eachE.
4 Mandates: If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space
Extents() is representable as a value of typetypename Extents::index_type.
23.7.3.4.5.2 Constructors [mdspan.layout.left.cons]
constexpr mapping(const extents_type& e) noexcept;
1 Preconditions: The size of the multidimensional index spacee is representable as a value of type
index_type (6.9.2).
2 Effects: Direct-non-list-initializes extents_ with e.
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const mapping<OtherExtents>& other) noexcept;
3 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
4 Preconditions: other.required_span_size() is representable as a value of typeindex_type (6.9.2).
5 Effects: Direct-non-list-initializes extents_ with other.extents().
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_right::mapping<OtherExtents>& other) noexcept;
6 Constraints:
—(6.1) extents_type::rank() <= 1 is true, and
—(6.2) is_constructible_v<extents_type, OtherExtents> is true.
7 Preconditions: other.required_span_size() is representable as a value of typeindex_type (6.9.2).
8 Effects: Direct-non-list-initializes extents_ with other.extents().
template<class LayoutLeftPaddedMapping>
constexpr explicit(!is_convertible_v<typename LayoutLeftPaddedMapping::extents_type,
extents_type>)
mapping(const LayoutLeftPaddedMapping&) noexcept;
9 Constraints:
—(9.1) is-layout-left-padded-mapping-of <LayoutLeftPaddedMapping> is true.
—(9.2) is_constructible_v<extents_type, typename LayoutLeftPaddedMapping::extents_type>
is true.
10 Mandates: If
—(10.1) Extents::rank() is greater than one,
§ 23.7.3.4.5 © ISO/IEC
1130

===== PAGE 1142 =====

Dxxxx
—(10.2) Extents::static_extent(0) does not equaldynamic_extent, and
—(10.3) LayoutLeftPaddedMapping::static-padding-stride does not equaldynamic_extent,
then Extents::static_extent(0) equals LayoutLeftPaddedMapping::static-padding-stride .
11 Preconditions:
—(11.1) If extents_type::rank() > 1 is true, then other.stride(1) equals other.extents().ex-
tent(0).
—(11.2) other.required_span_size() is representable as a value of typeindex_type.
12 Effects: Direct-non-list-initializes extents_ with other.extents().
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>& other);
13 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
14 Preconditions:
—(14.1) If extents_type::rank() > 0 is true, then for allr in the range[0,extents_type::rank()),
other.stride(r) equals other.extents().fwd-prod-of-extents (r), and
—(14.2) other.required_span_size() is representable as a value of typeindex_type (6.9.2).
15 Effects: Direct-non-list-initializes extents_ with other.extents().
16 Remarks: The expression insideexplicit is equivalent to:
!(extents_type::rank() == 0 && is_convertible_v<OtherExtents, extents_type>)
23.7.3.4.5.3 Observers [mdspan.layout.left.obs]
constexpr index_type required_span_size() const noexcept;
1 Returns: extents().fwd-prod-of-extents (extents_type::rank()).
template<class... Indices>
constexpr index_type operator()(Indices... i) const noexcept;
2 Constraints:
—(2.1) sizeof...(Indices) == extents_type::rank() is true,
—(2.2) (is_convertible_v<Indices, index_type> && ...) is true, and
—(2.3) (is_nothrow_constructible_v<index_type, Indices> && ...) is true.
3 Preconditions: extents_type::index-cast (i) is a multidimensional index inextents_ (23.7.3.1).
4 Effects: Let P be a parameter pack such that
is_same_v<index_sequence_for<Indices...>, index_sequence<P...>>
is true. Equivalent to:
return ((static_cast<index_type>(i) * stride(P)) + ... + 0);
constexpr index_type stride(rank_type i) const noexcept;
5 Constraints: extents_type::rank() > 0 is true.
6 Preconditions: i < extents_type::rank() is true.
7 Returns: extents().fwd-prod-of-extents (i).
template<class OtherExtents>
friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
8 Constraints: extents_type::rank() == OtherExtents::rank() is true.
9 Effects: Equivalent to:return x.extents() == y.extents();
§ 23.7.3.4.5 © ISO/IEC
1131

===== PAGE 1143 =====

Dxxxx
23.7.3.4.6 Class template layout_right::mapping [mdspan.layout.right]
23.7.3.4.6.1 Overview [mdspan.layout.right.overview]
1 layout_right provides a layout mapping where the rightmost extent is stride 1, and strides increase
right-to-left as the product of extents.
namespace std {
template<class Extents>
class layout_right::mapping {
public:
using extents_type = Extents;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using layout_type = layout_right;
// 23.7.3.4.6.2, constructors
constexpr mapping() noexcept = default;
constexpr mapping(const mapping&) noexcept = default;
constexpr mapping(const extents_type&) noexcept;
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const mapping<OtherExtents>&) noexcept;
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_left::mapping<OtherExtents>&) noexcept;
template<class LayoutRightPaddedMapping>
constexpr explicit(!is_convertible_v<typename LayoutRightPaddedMapping::extents_type,
extents_type>)
mapping(const LayoutRightPaddedMapping&) noexcept;
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>&) noexcept;
constexpr mapping& operator=(const mapping&) noexcept = default;
// 23.7.3.4.6.3, observers
constexpr const extents_type& extents() const noexcept { return extents_; }
constexpr index_type required_span_size() const noexcept;
template<class... Indices>
constexpr index_type operator()(Indices...) const noexcept;
static constexpr bool is_always_unique() noexcept { return true; }
static constexpr bool is_always_exhaustive() noexcept { return true; }
static constexpr bool is_always_strided() noexcept { return true; }
static constexpr bool is_unique() noexcept { return true; }
static constexpr bool is_exhaustive() noexcept { return true; }
static constexpr bool is_strided() noexcept { return true; }
constexpr index_type stride(rank_type) const noexcept;
template<class OtherExtents>
friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;
private:
extents_type extents_{}; // exposition only
// 23.7.3.7.7,submdspan mapping specialization
template<class... SliceSpecifiers>
constexpr auto submdspan-mapping-impl (SliceSpecifiers...) const // exposition only
-> see below ;
§ 23.7.3.4.6 © ISO/IEC
1132

===== PAGE 1144 =====

Dxxxx
template<class... SliceSpecifiers>
friend constexpr auto submdspan_mapping(
const mapping& src, SliceSpecifiers... slices) {
return src.submdspan-mapping-impl (slices...);
}
};
}
2 If Extents is not a specialization ofextents, then the program is ill-formed.
3 layout_right::mapping<E> is a trivially copyable type that modelsregular for eachE.
4 Mandates: If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space
Extents() is representable as a value of typetypename Extents::index_type.
23.7.3.4.6.2 Constructors [mdspan.layout.right.cons]
constexpr mapping(const extents_type& e) noexcept;
1 Preconditions: The size of the multidimensional index spacee is representable as a value of type
index_type (6.9.2).
2 Effects: Direct-non-list-initializes extents_ with e.
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const mapping<OtherExtents>& other) noexcept;
3 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
4 Preconditions: other.required_span_size() is representable as a value of typeindex_type (6.9.2).
5 Effects: Direct-non-list-initializes extents_ with other.extents().
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_left::mapping<OtherExtents>& other) noexcept;
6 Constraints:
—(6.1) extents_type::rank() <= 1 is true, and
—(6.2) is_constructible_v<extents_type, OtherExtents> is true.
7 Preconditions: other.required_span_size() is representable as a value of typeindex_type (6.9.2).
8 Effects: Direct-non-list-initializes extents_ with other.extents().
template<class LayoutRightPaddedMapping>
constexpr explicit(!is_convertible_v<typename LayoutRightPaddedMapping::extents_type,
extents_type>)
mapping(const LayoutRightPaddedMapping&) noexcept;
9 Constraints:
—(9.1) is-layout-right-padded-mapping-of <LayoutRightPaddedMapping> is true.
—(9.2) is_constructible_v<extents_type, typename LayoutRightPaddedMapping::extents_-
type> is true.
10 Mandates: If
—(10.1) Extents::rank() is greater than one,
—(10.2) Extents::static_extent(Extents::rank() - 1) does not equaldynamic_extent, and
—(10.3) LayoutRightPaddedMapping::static-padding-stride does not equaldynamic_extent,
then Extents::static_extent(Extents::rank() - 1) equals LayoutRightPaddedMapping::sta-
tic-padding-stride .
11 Preconditions:
—(11.1) If extents_type::rank() > 1 is true, thenother.stride(extents_type::rank() - 2)
equals other.extents().extent(extents_type::rank() - 1).
—(11.2) other.required_span_size() is representable as a value of typeindex_type.
§ 23.7.3.4.6 © ISO/IEC
1133

===== PAGE 1145 =====

Dxxxx
12 Effects: Direct-non-list-initializes extents_ with other.extents().
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>& other) noexcept;
13 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
14 Preconditions:
—(14.1) If extents_type::rank() > 0 is true, then for allr in the range[0,extents_type::rank()),
other.stride(r) equals other.extents().rev-prod-of-extents (r).
—(14.2) other.required_span_size() is representable as a value of typeindex_type (6.9.2).
15 Effects: Direct-non-list-initializes extents_ with other.extents().
16 Remarks: The expression insideexplicit is equivalent to:
!(extents_type::rank() == 0 && is_convertible_v<OtherExtents, extents_type>)
23.7.3.4.6.3 Observers [mdspan.layout.right.obs]
constexpr index_type required_span_size() const noexcept;
1 Returns: extents().fwd-prod-of-extents (extents_type::rank()).
template<class... Indices>
constexpr index_type operator()(Indices... i) const noexcept;
2 Constraints:
—(2.1) sizeof...(Indices) == extents_type::rank() is true,
—(2.2) (is_convertible_v<Indices, index_type> && ...) is true, and
—(2.3) (is_nothrow_constructible_v<index_type, Indices> && ...) is true.
3 Preconditions: extents_type::index-cast (i) is a multidimensional index inextents_ (23.7.3.1).
4 Effects: Let P be a parameter pack such that
is_same_v<index_sequence_for<Indices...>, index_sequence<P...>>
is true. Equivalent to:
return ((static_cast<index_type>(i) * stride(P)) + ... + 0);
constexpr index_type stride(rank_type i) const noexcept;
5 Constraints: extents_type::rank() > 0 is true.
6 Preconditions: i < extents_type::rank() is true.
7 Returns: extents().rev-prod-of-extents (i).
template<class OtherExtents>
friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
8 Constraints: extents_type::rank() == OtherExtents::rank() is true.
9 Effects: Equivalent to:return x.extents() == y.extents();
23.7.3.4.7 Class template layout_stride::mapping [mdspan.layout.stride]
23.7.3.4.7.1 Overview [mdspan.layout.stride.overview]
1 layout_stride provides a layout mapping where the strides are user-defined.
namespace std {
template<class Extents>
class layout_stride::mapping {
public:
using extents_type = Extents;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using layout_type = layout_stride;
§ 23.7.3.4.7 © ISO/IEC
1134

===== PAGE 1146 =====

Dxxxx
private:
static constexpr rank_type rank_ = extents_type::rank(); // exposition only
public:
// 23.7.3.4.7.3, constructors
constexpr mapping() noexcept;
constexpr mapping(const mapping&) noexcept = default;
template<class OtherIndexType>
constexpr mapping(const extents_type&, span<OtherIndexType, rank_>) noexcept;
template<class OtherIndexType>
constexpr mapping(const extents_type&, const array<OtherIndexType, rank_>&) noexcept;
template<class StridedLayoutMapping>
constexpr explicit(see below ) mapping(const StridedLayoutMapping&) noexcept;
constexpr mapping& operator=(const mapping&) noexcept = default;
// 23.7.3.4.7.4, observers
constexpr const extents_type& extents() const noexcept { return extents_; }
constexpr array<index_type, rank_> strides() const noexcept { return strides_; }
constexpr index_type required_span_size() const noexcept;
template<class... Indices>
constexpr index_type operator()(Indices...) const noexcept;
static constexpr bool is_always_unique() noexcept { return true; }
static constexpr bool is_always_exhaustive() noexcept;
static constexpr bool is_always_strided() noexcept { return true; }
static constexpr bool is_unique() noexcept { return true; }
constexpr bool is_exhaustive() const noexcept;
static constexpr bool is_strided() noexcept { return true; }
constexpr index_type stride(rank_type i) const noexcept { return strides_[i]; }
template<class OtherMapping>
friend constexpr bool operator==(const mapping&, const OtherMapping&) noexcept;
private:
extents_type extents_{}; // exposition only
array<index_type, rank_> strides_{}; // exposition only
// 23.7.3.7.7,submdspan mapping specialization
template<class... SliceSpecifiers>
constexpr auto submdspan-mapping-impl (SliceSpecifiers...) const // exposition only
-> see below ;
template<class... SliceSpecifiers>
friend constexpr auto submdspan_mapping(
const mapping& src, SliceSpecifiers... slices) {
return src.submdspan-mapping-impl (slices...);
}
};
}
2 If Extents is not a specialization ofextents, then the program is ill-formed.
3 layout_stride::mapping<E> is a trivially copyable type that modelsregular for eachE.
4 Mandates: If Extents::rank_dynamic() == 0 is true, then the size of the multidimensional index space
Extents() is representable as a value of typetypename Extents::index_type.
23.7.3.4.7.2 Exposition-only helpers [mdspan.layout.stride.expo]
1 Let REQUIRED-SPAN-SIZE (e, strides) be:
§ 23.7.3.4.7 © ISO/IEC
1135

===== PAGE 1147 =====

Dxxxx
—(1.1) 1, ife.rank() == 0 is true,
—(1.2) otherwise 0, if the size of the multidimensional index spacee is 0,
—(1.3) otherwise 1 plus the sum of products of(e.extent(r) - 1) and
extents_type::index-cast (strides[r])
for allr in the range[0,e.rank()).
2 Let OFFSET (m) be:
—(2.1) m(), ife.rank() == 0 is true,
—(2.2) otherwise 0, if the size of the multidimensional index spacee is 0,
—(2.3) otherwise m(z...) for a pack of integersz that is a multidimensional index inm.extents() and each
element ofz equals 0.
3 Let is-extents be the exposition-only variable template defined as follows:
template<class T>
constexpr bool is-extents = false; // exposition only
template<class IndexType, size_t... Args>
constexpr bool is-extents <extents<IndexType, Args...>> = true; // exposition only
4 Let layout-mapping-alike be the exposition-only concept defined as follows:
template<class M>
concept layout-mapping-alike = requires { // exposition only
requires is-extents <typename M::extents_type>;
{ M::is_always_strided() } -> same_as<bool>;
{ M::is_always_exhaustive() } -> same_as<bool>;
{ M::is_always_unique() } -> same_as<bool>;
bool_constant<M::is_always_strided()>::value;
bool_constant<M::is_always_exhaustive()>::value;
bool_constant<M::is_always_unique()>::value;
};
[Note 1: This concept checks that the functionsM::is_always_strided(), M::is_always_exhaustive(), andM::is_-
always_unique() exist, are constant expressions, and have a return type ofbool. —end note]
23.7.3.4.7.3 Constructors [mdspan.layout.stride.cons]
constexpr mapping() noexcept;
1 Preconditions: layout_right::mapping<extents_type>().required_span_size() is representable
as a value of typeindex_type (6.9.2).
2 Effects: Direct-non-list-initializesextents_ with extents_type(), and for alldin the range[0,rank_),
direct-non-list-initializes strides_[d] with layout_right::mapping<extents_type>().stride(d).
template<class OtherIndexType>
constexpr mapping(const extents_type& e, span<OtherIndexType, rank_> s) noexcept;
template<class OtherIndexType>
constexpr mapping(const extents_type& e, const array<OtherIndexType, rank_>& s) noexcept;
3 Constraints:
—(3.1) is_convertible_v<const OtherIndexType&, index_type> is true, and
—(3.2) is_nothrow_constructible_v<index_type, const OtherIndexType&> is true.
4 Preconditions:
—(4.1) The result of convertings[i] to index_type is greater than0 for alli in the range[0,rank_).
—(4.2) REQUIRED-SPAN-SIZE (e, s) is representable as a value of typeindex_type (6.9.2).
—(4.3) If rank_ is greater than 0, then there exists a permutationP of the integers in the range[0,rank_),
such thats[pi] >= s[pi−1] * e.extent(pi−1) is true for alliin the range[1,rank_), wherepi
is theith element ofP.
[Note 1: Forlayout_stride, this condition is necessary and sufficient foris_unique() to betrue. —end
note]
§ 23.7.3.4.7 © ISO/IEC
1136

===== PAGE 1148 =====

Dxxxx
5 Effects: Direct-non-list-initializes extents_ with e, and for alldin the range[0,rank_), direct-non-list-
initializes strides_[d] with as_const(s[d]).
template<class StridedLayoutMapping>
constexpr explicit(see below )
mapping(const StridedLayoutMapping& other) noexcept;
6 Constraints:
—(6.1) layout-mapping-alike <StridedLayoutMapping> is satisfied.
—(6.2) is_constructible_v<extents_type, typename StridedLayoutMapping::extents_type> is
true.
—(6.3) StridedLayoutMapping::is_always_unique() is true.
—(6.4) StridedLayoutMapping::is_always_strided() is true.
7 Preconditions:
—(7.1) StridedLayoutMapping meets the layout mapping requirements (23.7.3.4.2),
—(7.2) other.stride(r) > 0 is true for every rank indexr of extents(),
—(7.3) other.required_span_size() is representable as a value of typeindex_type (6.9.2), and
—(7.4) OFFSET (other) == 0 is true.
8 Effects: Direct-non-list-initializesextents_ with other.extents(), and for alldin the range[0,rank_),
direct-non-list-initializes strides_[d] with other.stride(d).
9 Remarks: The expression insideexplicit is equivalent to:
!(is_convertible_v<typename StridedLayoutMapping::extents_type, extents_type> &&
(is-mapping-of <layout_left, StridedLayoutMapping> ||
is-mapping-of <layout_right, StridedLayoutMapping> ||
is-layout-left-padded-mapping-of <StridedLayoutMapping> ||
is-layout-right-padded-mapping-of <StridedLayoutMapping> ||
is-mapping-of <layout_stride, StridedLayoutMapping>))
23.7.3.4.7.4 Observers [mdspan.layout.stride.obs]
constexpr index_type required_span_size() const noexcept;
1 Returns: REQUIRED-SPAN-SIZE (extents(), strides_).
template<class... Indices>
constexpr index_type operator()(Indices... i) const noexcept;
2 Constraints:
—(2.1) sizeof...(Indices) == rank_ is true,
—(2.2) (is_convertible_v<Indices, index_type> && ...) is true, and
—(2.3) (is_nothrow_constructible_v<index_type, Indices> && ...) is true.
3 Preconditions: extents_type::index-cast (i) is a multidimensional index inextents_ (23.7.3.1).
4 Effects: Let P be a parameter pack such that
is_same_v<index_sequence_for<Indices...>, index_sequence<P...>>
is true. Equivalent to:
return ((static_cast<index_type>(i) * stride(P)) + ... + 0);
static constexpr bool is_always_exhaustive() noexcept;
5 Returns: true if rank_ is 0 or if there is a rank indexr of extents() such thatextents_type::sta-
tic_extent(r) is 0, otherwisefalse.
constexpr bool is_exhaustive() const noexcept;
6 Returns:
—(6.1) true if rank_ or the size of the multidimensional index spacem.extents() is 0.
§ 23.7.3.4.7 © ISO/IEC
1137

===== PAGE 1149 =====

Dxxxx
—(6.2) Otherwise, true if there is a permutationP of the integers in the range[0,rank_) such that
stride(p0) equals 1, andstride(pi) equals stride(pi−1) * extents().extent(pi−1) for i in
the range[1,rank_), wherepi is theith element ofP.
—(6.3) Otherwise, false.
template<class OtherMapping>
friend constexpr bool operator==(const mapping& x, const OtherMapping& y) noexcept;
7 Constraints:
—(7.1) layout-mapping-alike <OtherMapping> is satisfied.
—(7.2) rank_ == OtherMapping::extents_type::rank() is true.
—(7.3) OtherMapping::is_always_strided() is true.
8 Preconditions: OtherMapping meets the layout mapping requirements (23.7.3.4.3).
9 Returns: true if x.extents() == y.extents() is true, OFFSET (y) == 0 is true, and each of
x.stride(r) == y.stride(r) is true for r in the range[0,x.extents().rank()). Otherwise, false.
23.7.3.4.8 Class template layout_left_padded::mapping [mdspan.layout.leftpad]
23.7.3.4.8.1 Overview [mdspan.layout.leftpad.overview]
1 layout_left_padded provides a layout mapping that behaves likelayout_left::mapping, except that the
padding stridestride(1) can be greater than or equal toextent(0).
namespace std {
template<size_t PaddingValue>
template<class Extents>
class layout_left_padded<PaddingValue>::mapping {
public:
static constexpr size_t padding_value = PaddingValue;
using extents_type = Extents;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using layout_type = layout_left_padded<PaddingValue>;
private:
static constexpr size_t rank_ = extents_type::rank(); // exposition only
static constexpr size_t first-static-extent = // exposition only
extents_type::static_extent(0);
// 23.7.3.4.8.2, exposition-only members
static constexpr size_t static-padding-stride = see below ; // exposition only
public:
// 23.7.3.4.8.3, constructors
constexpr mapping() noexcept : mapping(extents_type{}) {}
constexpr mapping(const mapping&) noexcept = default;
constexpr mapping(const extents_type&);
template<class OtherIndexType>
constexpr mapping(const extents_type&, OtherIndexType);
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_left::mapping<OtherExtents>&);
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>&);
template<class LayoutLeftPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutLeftPaddedMapping&);
template<class LayoutRightPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutRightPaddedMapping&) noexcept;
§ 23.7.3.4.8 © ISO/IEC
1138

===== PAGE 1150 =====

Dxxxx
constexpr mapping& operator=(const mapping&) noexcept = default;
// 23.7.3.4.8.4, observers
constexpr const extents_type& extents() const noexcept { return extents_; }
constexpr array<index_type, rank_> strides() const noexcept;
constexpr index_type required_span_size() const noexcept;
template<class... Indices>
constexpr index_type operator()(Indices...) const noexcept;
static constexpr bool is_always_unique() noexcept { return true; }
static constexpr bool is_always_exhaustive() noexcept;
static constexpr bool is_always_strided() noexcept { return true; }
static constexpr bool is_unique() noexcept { return true; }
constexpr bool is_exhaustive() const noexcept;
static constexpr bool is_strided() noexcept { return true; }
constexpr index_type stride(rank_type) const noexcept;
template<class LayoutLeftPaddedMapping>
friend constexpr bool operator==(const mapping&, const LayoutLeftPaddedMapping&) noexcept;
private:
// 23.7.3.4.8.2, exposition-only members
index_type stride-1 = static-padding-stride ; // exposition only
extents_type extents_{}; // exposition only
// 23.7.3.7.7, submdspan mapping specialization
template<class... SliceSpecifiers>
constexpr auto submdspan-mapping-impl (SliceSpecifiers...) const // exposition only
-> see below ;
template<class... SliceSpecifiers>
friend constexpr auto submdspan_mapping(const mapping& src, SliceSpecifiers... slices) {
return src.submdspan-mapping-impl (slices...);
}
};
}
2 If Extents is not a specialization ofextents, then the program is ill-formed.
3 layout_left_padded::mapping<E> is a trivially copyable type that modelsregular for eachE.
4 Throughout 23.7.3.4.8, letP_rank be the following sizerank_ parameter pack ofsize_t values:
—(4.1) the empty parameter pack, ifrank_ equals zero;
—(4.2) otherwise, 0zu, ifrank_ equals one;
—(4.3) otherwise, the parameter pack0zu, 1zu, ..., rank_- 1.
5 Mandates:
—(5.1) If rank_dynamic() == 0 is true, then the size of the multidimensional index spaceExtents() is
representable as a value of typeindex_type.
—(5.2) If padding_value is not equal todynamic_extent, thenpadding_value is representable as a value of
type index_type.
—(5.3) If
—(5.3.1) rank_ is greater than one,
—(5.3.2) padding_value does not equaldynamic_extent, and
—(5.3.3) first-static-extent does not equaldynamic_extent,
then LEAST-MULTIPLE-AT-LEAST (padding_value, first-static-extent ) is representable as a val-
ue of typesize_t, and is representable as a value of typeindex_type.
—(5.4) If
§ 23.7.3.4.8 © ISO/IEC
1139

===== PAGE 1151 =====

Dxxxx
—(5.4.1) rank_ is greater than one,
—(5.4.2) padding_value does not equaldynamic_extent, and
—(5.4.3) extents_type::static_extent(k) does not equaldynamic_extent for all k in the range[0,
extents_type::rank()),
then the product ofLEAST-MULTIPLE-AT-LEAST (padding_value, ext.static_extent(0)) and all
values ext.static_extent(k) with k in the range of[1,rank_) is representable as a value of type
size_t, and is representable as a value of typeindex_type.
23.7.3.4.8.2 Exposition-only members [mdspan.layout.leftpad.expo]
static constexpr size_t static-padding-stride = see below ;
1 The value is
—(1.1) 0, ifrank_ equals zero or one;
—(1.2) otherwise, dynamic_extent, ifpadding_valueorfirst-static-extent equalsdynamic_extent;
—(1.3) otherwise, thesize_t value which isLEAST-MULTIPLE-AT-LEAST (padding_value, first-sta-
tic-extent ).
index_type stride-1 = static-padding-stride ;
2 Recommended practice: Implementations should not store this value ifstatic-padding-stride is not
dynamic_extent.
[Note 1: Usingextents<index_type, static-padding-stride > insteadof index_type asthetypeof stride-1
would achieve this.—end note]
23.7.3.4.8.3 Constructors [mdspan.layout.leftpad.cons]
constexpr mapping(const extents_type& ext);
1 Preconditions:
—(1.1) The size of the multidimensional index spaceext is representable as a value of typeindex_type.
—(1.2) If rank_ is greater than one andpadding_valuedoes not equaldynamic_extent, thenLEAST-MUL-
TIPLE-AT-LEAST (padding_value, ext.extent(0)) is representable as a value of typeindex_-
type .
—(1.3) If rank_ is greater than one andpadding_valuedoes not equaldynamic_extent, then the product
of LEAST-MULTIPLE-AT-LEAST (padding_value, ext.extent(0)) and all valuesext.extent(k)
with k in the range of[1,rank_) is representable as a value of typeindex_type.
2 Effects:
—(2.1) Direct-non-list-initializes extents_ with ext; and
—(2.2) if rank_ is greater than one, direct-non-list-initializesstride-1
—(2.2.1) with ext.extent(0) if padding_value isdynamic_extent,
—(2.2.2) otherwise withLEAST-MULTIPLE-AT-LEAST (padding_value, ext.extent(0)).
template<class OtherIndexType>
constexpr mapping(const extents_type& ext, OtherIndexType pad);
3 Constraints:
—(3.1) is_convertible_v<OtherIndexType, index_type> is true.
—(3.2) is_nothrow_constructible_v<index_type, OtherIndexType> is true.
4 Preconditions:
—(4.1) pad is representable as a value of typeindex_type.
—(4.2) extents_type::index-cast (pad) is greater than zero.
—(4.3) If rank_ is greater than one, thenLEAST-MULTIPLE-AT-LEAST (pad, ext.extent(0)) is repre-
sentable as a value of typeindex_type.
§ 23.7.3.4.8 © ISO/IEC
1140

===== PAGE 1152 =====

Dxxxx
—(4.4) If rank_ is greater than one, then the product ofLEAST-MULTIPLE-AT-LEAST (pad, ext.extent(
0)) and all valuesext.extent(k) with k in the range of[1,rank_) is representable as a value of
type index_type.
—(4.5) If padding_value is not equal todynamic_extent, padding_value equals extents_type::in-
dex-cast (pad).
5 Effects: Direct-non-list-initializes extents_ with ext, and ifrank_ is greater than one, direct-non-list-
initializes stride-1 with LEAST-MULTIPLE-AT-LEAST (pad, ext.extent(0)).
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_left::mapping<OtherExtents>& other);
6 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
7 Mandates: If OtherExtents::rank() is greater than1, then
(static-padding-stride == dynamic_extent) ||
(OtherExtents::static_extent(0) == dynamic_extent) ||
(static-padding-stride == OtherExtents::static_extent(0))
is true.
8 Preconditions:
—(8.1) If extents_type::rank() > 1 is true and padding_value == dynamic_extent is false, then
other.stride(1) equals
LEAST-MULTIPLE-AT-LEAST (padding_value,
extents_type::index-cast (other.extents().extent(0)))
and
—(8.2) other.required_span_size() is representable as a value of typeindex_type.
9 Effects: Equivalent tomapping(other.extents()).
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>& other);
10 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
11 Preconditions:
—(11.1) If rank_ is greater than 1 and padding_value does not equal dynamic_extent, then other.
stride(1) equals
LEAST-MULTIPLE-AT-LEAST (padding_value,
extents_type::index-cast (other.extents().extent(0)))
—(11.2) If rank_ is greater than 0, thenother.stride(0) equals 1.
—(11.3) If rank_ is greater than 2, then for allr in the range[2,rank_), other.stride(r) equals
(other.extents().fwd-prod-of-extents (r) / other.extents().extent(0)) * other.stride(1)
—(11.4) other.required_span_size() is representable as a value of typeindex_type .
12 Effects:
—(12.1) Direct-non-list-initializes extents_ with other.extents() and
—(12.2) if rank_ is greater than one, direct-non-list-initializesstride-1 with other.stride(1).
13 Remarks: The expression insideexplicit is equivalent to:
!(rank_ == 0 && is_convertible_v<OtherExtents, extents_type>)
template<class LayoutLeftPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutLeftPaddedMapping& other);
14 Constraints:
—(14.1) is-layout-left-padded-mapping-of <LayoutLeftPaddedMapping> is true.
§ 23.7.3.4.8 © ISO/IEC
1141

===== PAGE 1153 =====

Dxxxx
—(14.2) is_constructible_v<extents_type, typename LayoutLeftPaddedMapping::extents_type>
is true.
15 Mandates: If rank_ is greater than 1, then
padding_value == dynamic_extent ||
LayoutLeftPaddedMapping::padding_value == dynamic_extent ||
padding_value == LayoutLeftPaddedMapping::padding_value
is true.
16 Preconditions:
—(16.1) If rank_ is greater than 1 andpadding_value does not equal dynamic_extent, then other.
stride(1) equals
LEAST-MULTIPLE-AT-LEAST (padding_value,
extents_type::index-cast (other.extent(0)))
—(16.2) other.required_span_size() is representable as a value of typeindex_type.
17 Effects:
—(17.1) Direct-non-list-initializes extents_ with other.extents() and
—(17.2) if rank_ is greater than one, direct-non-list-initializesstride-1 with other.stride(1).
18 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<typename LayoutLeftPaddedMapping::extents_type, extents_type> ||
rank_> 1 &&
(padding_value != dynamic_extent ||
LayoutLeftPaddedMapping::padding_value == dynamic_extent)
template<class LayoutRightPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutRightPaddedMapping& other) noexcept;
19 Constraints:
—(19.1) is-layout-right-padded-mapping-of <LayoutRightPaddedMapping> is true or
is-mapping-of <layout_right, LayoutRightPaddedMapping> is true.
—(19.2) rank_ equals zero or one.
—(19.3) is_constructible_v<extents_type, typename LayoutRightPaddedMapping::extents_-
type> is true.
20 Preconditions: other.required_span_size() is representable as a value of typeindex_type.
21 Effects: Direct-non-list-initializes extents_ with other.extents().
22 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<typename LayoutRightPaddedMapping::extents_type, extents_type>
[Note 1: Neither the input mapping nor the mapping to be constructed uses the padding stride in the rank-0 or
rank-1 case, so the padding stride does not affect either the constraints or the preconditions.—end note]
23.7.3.4.8.4 Observers [mdspan.layout.leftpad.obs]
constexpr array<index_type, rank_> strides() const noexcept;
1 Returns: array<index_type, rank_>({stride(P_rank)...}).
constexpr index_type required_span_size() const noexcept;
2 Returns:
—(2.1) 0 if the multidimensional index spaceextents_ is empty,
—(2.2) otherwise, (*this)(extents_.extent(P_rank) - index_type(1)...) + 1.
template<class... Indices>
constexpr size_t operator()(Indices... idxs) const noexcept;
3 Constraints:
—(3.1) sizeof...(Indices) == rank_ is true.
§ 23.7.3.4.8 © ISO/IEC
1142

===== PAGE 1154 =====

Dxxxx
—(3.2) (is_convertible_v<Indices, index_type> && ...) is true.
—(3.3) (is_nothrow_constructible_v<index_type, Indices> && ...) is true.
4 Preconditions: extents_type::index-cast (idxs)isamultidimensionalindexin extents()(23.7.3.1).
5 Returns: ((static_cast<index_type>(idxs) * stride(P_rank)) + ... + 0).
static constexpr bool is_always_exhaustive() noexcept;
6 Returns:
—(6.1) If rank_ equals zero or one, thentrue;
—(6.2) otherwise, if neitherstatic-padding-stride nor first-static-extent equal dynamic_extent,
then static-padding-stride == first-static-extent ;
—(6.3) otherwise, false.
constexpr bool is_exhaustive() const noexcept;
7 Returns: true if rank_ equals zero or one; otherwise,extents_.extent(0) == stride(1).
constexpr index_type stride(rank_type r) const noexcept;
8 Preconditions: r is smaller thanrank_.
9 Returns:
—(9.1) If r equals zero: 1;
—(9.2) otherwise, ifr equals one: stride-1;
—(9.3) otherwise, the product ofstride-1 and all valuesextents_.extent(k) with kin the range[1,r).
template<class LayoutLeftPaddedMapping>
friend constexpr bool operator==(const mapping& x, const LayoutLeftPaddedMapping& y) noexcept;
10 Constraints:
—(10.1) is-layout-left-padded-mapping-of <LayoutLeftPaddedMapping> is true.
—(10.2) LayoutLeftPaddedMapping::extents_type::rank() == rank_ is true.
11 Returns: true if x.extents() == y.extents() is true and rank_ < 2 || x.stride(1) == y.
stride(1) is true. Otherwise, false.
23.7.3.4.9 Class template layout_right_padded::mapping [mdspan.layout.rightpad]
23.7.3.4.9.1 Overview [mdspan.layout.rightpad.overview]
1 layout_right_padded provides a layout mapping that behaves likelayout_right::mapping, except that
the padding stridestride(extents_type::rank() - 2)can be greater than or equal toextents_type::ex-
tent(extents_type::rank() - 1).
namespace std {
template<size_t PaddingValue>
template<class Extents>
class layout_right_padded<PaddingValue>::mapping {
public:
static constexpr size_t padding_value = PaddingValue;
using extents_type = Extents;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using layout_type = layout_right_padded<PaddingValue>;
private:
static constexpr size_t rank_ = extents_type::rank(); // exposition only
static constexpr size_t last-static-extent = // exposition only
extents_type::static_extent(rank_ - 1);
// 23.7.3.4.9.2, exposition-only members
static constexpr size_t static-padding-stride = see below ; // exposition only
§ 23.7.3.4.9 © ISO/IEC
1143

===== PAGE 1155 =====

Dxxxx
public:
// 23.7.3.4.9.3, constructors
constexpr mapping() noexcept : mapping(extents_type{}) {}
constexpr mapping(const mapping&) noexcept = default;
constexpr mapping(const extents_type&);
template<class OtherIndexType>
constexpr mapping(const extents_type&, OtherIndexType);
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_right::mapping<OtherExtents>&);
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>&);
template<class LayoutRightPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutRightPaddedMapping&);
template<class LayoutLeftPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutLeftPaddedMapping&) noexcept;
constexpr mapping& operator=(const mapping&) noexcept = default;
// 23.7.3.4.9.4, observers
constexpr const extents_type& extents() const noexcept { return extents_; }
constexpr array<index_type, rank_> strides() const noexcept;
constexpr index_type required_span_size() const noexcept;
template<class... Indices>
constexpr index_type operator()(Indices...) const noexcept;
static constexpr bool is_always_unique() noexcept { return true; }
static constexpr bool is_always_exhaustive() noexcept;
static constexpr bool is_always_strided() noexcept { return true; }
static constexpr bool is_unique() noexcept { return true; }
constexpr bool is_exhaustive() const noexcept;
static constexpr bool is_strided() noexcept { return true; }
constexpr index_type stride(rank_type) const noexcept;
template<class LayoutRightPaddedMapping>
friend constexpr bool operator==(const mapping&, const LayoutRightPaddedMapping&) noexcept;
private:
// 23.7.3.4.9.2, exposition-only members
index_type stride-rm2 = static-padding-stride ; // exposition only
extents_type extents_{}; // exposition only
// 23.7.3.7.7, submdspan mapping specialization
template<class... SliceSpecifiers>
constexpr auto submdspan-mapping-impl (SliceSpecifiers...) const // exposition only
-> see below ;
template<class... SliceSpecifiers>
friend constexpr auto submdspan_mapping(const mapping& src, SliceSpecifiers... slices) {
return src.submdspan-mapping-impl (slices...);
}
};
}
2 If Extents is not a specialization ofextents, then the program is ill-formed.
3 layout_right_padded::mapping<E> is a trivially copyable type that modelsregular for eachE.
§ 23.7.3.4.9 © ISO/IEC
1144

===== PAGE 1156 =====

Dxxxx
4 Throughout 23.7.3.4.9, letP_rank be the following sizerank_ parameter pack ofsize_t values:
—(4.1) the empty parameter pack, ifrank_ equals zero;
—(4.2) otherwise, 0zu, ifrank_ equals one;
—(4.3) otherwise, the parameter pack0zu, 1zu, ..., rank_- 1.
5 Mandates:
—(5.1) If rank_dynamic() == 0 is true, then the size of the multidimensional index spaceExtents() is
representable as a value of typeindex_type.
—(5.2) If padding_value is not equal todynamic_extent, thenpadding_value is representable as a value of
type index_type.
—(5.3) If
—(5.3.1) rank_ is greater than one,
—(5.3.2) padding_value does not equaldynamic_extent, and
—(5.3.3) last-static-extent does not equaldynamic_extent,
then LEAST-MULTIPLE-AT-LEAST (padding_value, last-static-extent ) is representable as a value
of typesize_t, and is representable as a value of typeindex_type.
—(5.4) If
—(5.4.1) rank_ is greater than one,
—(5.4.2) padding_value does not equaldynamic_extent, and
—(5.4.3) extents_type::static_extent(k) does not equaldynamic_extent for all k in the range[0,
rank_),
then the product ofLEAST-MULTIPLE-AT-LEAST (padding_value, ext.static_extent(rank_ - 1))
and all valuesext.static_extent(k) with k in the range of[0,rank_ - 1) is representable as a value
of typesize_t, and is representable as a value of typeindex_type.
23.7.3.4.9.2 Exposition-only members [mdspan.layout.rightpad.expo]
static constexpr size_t static-padding-stride = see below ;
1 The value is
—(1.1) 0, ifrank_ equals zero or one;
—(1.2) otherwise, dynamic_extent, ifpadding_value or last-static-extent equals dynamic_extent;
—(1.3) otherwise, the size_t value which isLEAST-MULTIPLE-AT-LEAST (padding_value, last-sta-
tic-extent ).
index_type stride-rm2 = static-padding-stride ;
2 Recommended practice: Implementations should not store this value ifstatic-padding-stride is not
dynamic_extent.
[Note 1: Usingextents<index_type, static-padding-stride > instead ofindex_type as the type ofstride-
rm2 would achieve this.—end note]
23.7.3.4.9.3 Constructors [mdspan.layout.rightpad.cons]
constexpr mapping(const extents_type& ext);
1 Preconditions:
—(1.1) The size of the multidimensional index spaceext is representable as a value of typeindex_type.
—(1.2) If rank_ is greater than one andpadding_valuedoes not equaldynamic_extent, thenLEAST-MUL-
TIPLE-AT-LEAST (padding_value, ext.extent(rank_ - 1)) is representable as a value of type
index_type .
—(1.3) If rank_ is greater than one and padding_value does not equal dynamic_extent, then the
product of LEAST-MULTIPLE-AT-LEAST (padding_value, ext.extent(rank_ - 1)) and all val-
ues ext.extent(k) with k in the range of[0,rank_ - 1) is representable as a value of type
index_type.
§ 23.7.3.4.9 © ISO/IEC
1145

===== PAGE 1157 =====

Dxxxx
2 Effects:
—(2.1) Direct-non-list-initializes extents_ with ext; and
—(2.2) if rank_ is greater than one, direct-non-list-initializesstride-rm2
—(2.2.1) with ext.extent(rank_ - 1) if padding_value is dynamic_extent,
—(2.2.2) otherwise withLEAST-MULTIPLE-AT-LEAST (padding_value, ext.extent(rank_ - 1)).
template<class OtherIndexType>
constexpr mapping(const extents_type& ext, OtherIndexType pad);
3 Constraints:
—(3.1) is_convertible_v<OtherIndexType, index_type> is true.
—(3.2) is_nothrow_constructible_v<index_type, OtherIndexType> is true.
4 Preconditions:
—(4.1) pad is representable as a value of typeindex_type.
—(4.2) extents_type::index-cast (pad) is greater than zero.
—(4.3) If rank_ is greater than one, thenLEAST-MULTIPLE-AT-LEAST (pad, ext.extent(rank_ - 1))
is representable as a value of typeindex_type.
—(4.4) If rank_ is greater than one, then the product ofLEAST-MULTIPLE-AT-LEAST (pad, ext.extent(
rank_ - 1)) and all valuesext.extent(k) with k in the range of[0,rank_ - 1) is representable
as a value of typeindex_type.
—(4.5) If padding_value is not equal to dynamic_extent, padding_value equals extents_type::
index-cast (pad).
5 Effects: Direct-non-list-initializes extents_ with ext, and ifrank_ is greater than one, direct-non-list-
initializes stride-rm2 with LEAST-MULTIPLE-AT-LEAST (pad, ext.extent(rank_ - 1)).
template<class OtherExtents>
constexpr explicit(!is_convertible_v<OtherExtents, extents_type>)
mapping(const layout_right::mapping<OtherExtents>& other);
6 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
7 Mandates: If OtherExtents::rank() is greater than 1, then
(static-padding-stride == dynamic_extent) ||
(OtherExtents::static_extent(rank_ - 1) == dynamic_extent) ||
(static-padding-stride == OtherExtents::static_extent(rank_ - 1))
is true.
8 Preconditions:
—(8.1) If rank_ > 1 is true and padding_value == dynamic_extent is false, thenother.stride(
rank_ - 2) equals
LEAST-MULTIPLE-AT-LEAST (padding_value,
extents_type::index-cast (other.extents().extent(rank_ - 1)))
and
—(8.2) other.required_span_size() is representable as a value of typeindex_type.
9 Effects: Equivalent tomapping(other.extents()).
template<class OtherExtents>
constexpr explicit(see below )
mapping(const layout_stride::mapping<OtherExtents>& other);
10 Constraints: is_constructible_v<extents_type, OtherExtents> is true.
11 Preconditions:
—(11.1) If rank_ is greater than 1 andpadding_value does not equal dynamic_extent, then other.
stride(rank_ - 2) equals
LEAST-MULTIPLE-AT-LEAST (padding_value,
extents_type::index-cast (other.extents().extent(rank_ - 1)))
§ 23.7.3.4.9 © ISO/IEC
1146

===== PAGE 1158 =====

Dxxxx
—(11.2) If rank_ is greater than 0, then other.stride(rank_ - 1) equals 1.
—(11.3) If rank_ is greater than 2, then for allr in the range[0,rank_ - 2), other.stride(r) equals
(other.extents().rev-prod-of-extents (r) / other.extents().extent(rank_ - 1)) *
other.stride(rank_ - 2)
—(11.4) other.required_span_size() is representable as a value of typeindex_type.
12 Effects:
—(12.1) Direct-non-list-initializes extents_ with other.extents(); and
—(12.2) if rank_ is greater than one, direct-non-list-initializesstride-rm2 with other.stride(rank_ -
2).
13 Remarks: The expression insideexplicit is equivalent to:
!(rank_ == 0 && is_convertible_v<OtherExtents, extents_type>)
template<class LayoutRightPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutRightPaddedMapping& other);
14 Constraints:
—(14.1) is-layout-right-padded-mapping-of <LayoutRightPaddedMapping> is true.
—(14.2) is_constructible_v<extents_type, typename LayoutRightPaddedMapping::extents_-
type> is true.
15 Mandates: If rank_ is greater than 1, then
padding_value == dynamic_extent ||
LayoutRightPaddedMapping::padding_value == dynamic_extent ||
padding_value == LayoutRightPaddedMapping::padding_value
is true.
16 Preconditions:
—(16.1) If rank_ is greater than 1 andpadding_value does not equal dynamic_extent, then other.
stride(rank_ - 2) equals
LEAST-MULTIPLE-AT-LEAST (padding_value,
extents_type::index-cast (other.extent(rank_ - 1)))
—(16.2) other.required_span_size() is representable as a value of typeindex_type.
17 Effects:
—(17.1) Direct-non-list-initializes extents_ with other.extents(); and
—(17.2) if rank_ is greater than one, direct-non-list-initializesstride-rm2 with other.stride(rank_ -
2).
18 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<typename LayoutRightPaddedMapping::extents_type, extents_type> ||
rank_ > 1 &&
(padding_value != dynamic_extent ||
LayoutRightPaddedMapping::padding_value == dynamic_extent)
template<class LayoutLeftPaddedMapping>
constexpr explicit(see below )
mapping(const LayoutLeftPaddedMapping& other) noexcept;
19 Constraints:
—(19.1) is-layout-left-padded-mapping-of <LayoutLeftPaddedMapping> is true or
is-mapping-of <layout_left, LayoutLeftPaddedMapping> is true.
—(19.2) rank_ equals zero or one.
—(19.3) is_constructible_v<extents_type, typename LayoutLeftPaddedMapping::extents_type>
is true.
§ 23.7.3.4.9 © ISO/IEC
1147

===== PAGE 1159 =====

Dxxxx
20 Preconditions: other.required_span_size() is representable as a value of typeindex_type.
21 Effects: Direct-non-list-initializes extents_ with other.extents().
22 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<typename LayoutLeftPaddedMapping::extents_type, extents_type>
[Note 1: Neither the input mapping nor the mapping to be constructed uses the padding stride in the rank-0 or
rank-1 case, so the padding stride affects neither the constraints nor the preconditions.—end note]
23.7.3.4.9.4 Observers [mdspan.layout.rightpad.obs]
constexpr array<index_type, rank_> strides() const noexcept;
1 Returns: array<index_type, rank_>(stride(P_rank)...).
constexpr index_type required_span_size() const noexcept;
2 Returns: 0 if the multidimensional index spaceextents_ is empty, otherwise(*this)(extents_-
.extent(P_rank) - index_type(1)...) + 1.
template<class... Indices>
constexpr size_t operator()(Indices... idxs) const noexcept;
3 Constraints:
—(3.1) sizeof...(Indices) == rank_ is true.
—(3.2) (is_convertible_v<Indices, index_type> && ...) is true.
—(3.3) (is_nothrow_constructible_v<index_type, Indices> && ...) is true.
4 Preconditions: extents_type::index-cast (idxs)isamultidimensionalindexin extents()(23.7.3.1).
5 Returns: ((static_cast<index_type>(idxs) * stride(P_rank)) + ... + 0).
static constexpr bool is_always_exhaustive() noexcept;
6 Returns:
—(6.1) If rank_ equals zero or one, thentrue;
—(6.2) otherwise, if neitherstatic-padding-stride nor last-static-extent equal dynamic_extent,
then static-padding-stride == last-static-extent ;
—(6.3) otherwise, false.
constexpr bool is_exhaustive() const noexcept;
7 Returns: true if rank_ equals zero or one; otherwise,
extents_.extent(rank_ - 1) == stride(rank_ - 2)
constexpr index_type stride(rank_type r) const noexcept;
8 Preconditions: r is smaller thanrank_.
9 Returns:
—(9.1) If r equals rank_ - 1: 1;
—(9.2) otherwise, ifr equals rank_ - 2: stride-rm2;
—(9.3) otherwise, the product ofstride-rm2 and all valuesextents_.extent(k) with k in the range of
[r + 1,rank_ - 1).
template<class LayoutRightPaddedMapping>
friend constexpr bool operator==(const mapping& x, const LayoutRightPaddedMapping& y) noexcept;
10 Constraints:
—(10.1) is-layout-right-padded-mapping-of <LayoutRightPaddedMapping> is true.
—(10.2) LayoutRightPaddedMapping::extents_type::rank() == rank_ is true.
11 Returns: true if x.extents() == y.extents() is true and rank_ < 2 || x.stride(rank_ - 2)
== y.stride(rank_ - 2) is true. Otherwise, false.
§ 23.7.3.4.9 © ISO/IEC
1148

===== PAGE 1160 =====

Dxxxx
23.7.3.5 Accessor policy [mdspan.accessor]
23.7.3.5.1 General [mdspan.accessor.general]
1 An accessor policydefines types and operations by which a reference to a single object is created from an
abstract data handle to a number of such objects and an index.
2 A range of indices[0,N) is anaccessible rangeof a given data handle and an accessor if, for eachi in the
range, the accessor policy’saccess function produces a valid reference to an object.
3 In 23.7.3.5.2,
—(3.1) A denotes an accessor policy.
—(3.2) a denotes a value of typeA or const A.
—(3.3) p denotes a value of typeA::data_handle_type or const A::data_handle_type.
[Note 1: The typeA::data_handle_type need not be dereferenceable.—end note]
—(3.4) n, i, andj each denote values of typesize_t.
23.7.3.5.2 Requirements [mdspan.accessor.reqmts]
1 A typeA meets the accessor policy requirements if
—(1.1) A models copyable,
—(1.2) is_nothrow_move_constructible_v<A> is true,
—(1.3) is_nothrow_move_assignable_v<A> is true,
—(1.4) is_nothrow_swappable_v<A> is true, and
—(1.5) the following types and expressions are well-formed and have the specified semantics.
typename A::element_type
2 Result: A complete object type that is not an abstract class type.
typename A::data_handle_type
3 Result: A type that modelscopyable, and for whichis_nothrow_move_constructible_v<A::data_-
handle_type> is true, is_nothrow_move_assignable_v<A::data_handle_type> is true, and is_-
nothrow_swappable_v<A::data_handle_type> is true.
[Note 1: The type ofdata_handle_type need not beelement_type*. —end note]
typename A::reference
4 Result: A type that modelscommon_reference_with<A::reference&&, A::element_type&>.
[Note 2: The type ofreference need not beelement_type&. —end note]
typename A::offset_policy
5 Result: A typeOP such that:
—(5.1) OP meets the accessor policy requirements,
—(5.2) constructible_from<OP, const A&> is modeled, and
—(5.3) is_same_v<typename OP::element_type, typename A::element_type> is true.
a.access(p, i)
6 Result: A::reference
7 Remarks: The expression is equality preserving.
8 [Note 3: Concrete accessor policies can impose preconditions for theiraccess function. However, they might
not. For example, an accessor wherep is span<A::element_type, dynamic_extent> and access(p, i) returns
p[i % p.size()] does not need to impose a precondition oni. —end note]
a.offset(p, i)
9 Result: A::offset_policy::data_handle_type
10 Returns: q such that for b being A::offset_policy(a), and any integern for which [0,n) is an
accessible range ofp and a:
§ 23.7.3.5.2 © ISO/IEC
1149

===== PAGE 1161 =====

Dxxxx
—(10.1) [0,n−i) is an accessible range ofq and b; and
—(10.2) b.access(q, j) provides access to the same element asa.access(p, i + j), for everyj in the
range [0,n−i).
11 Remarks: The expression is equality-preserving.
23.7.3.5.3 Class template default_accessor [mdspan.accessor.default]
23.7.3.5.3.1 Overview [mdspan.accessor.default.overview]
namespace std {
template<class ElementType>
struct default_accessor {
using offset_policy = default_accessor;
using element_type = ElementType;
using reference = ElementType&;
using data_handle_type = ElementType*;
constexpr default_accessor() noexcept = default;
template<class OtherElementType>
constexpr default_accessor(default_accessor<OtherElementType>) noexcept;
constexpr reference access(data_handle_type p, size_t i) const noexcept;
constexpr data_handle_type offset(data_handle_type p, size_t i) const noexcept;
};
}
1 default_accessor meets the accessor policy requirements.
2 ElementType is required to be a complete object type that is neither an abstract class type nor an array type.
3 Each specialization ofdefault_accessor is a trivially copyable type that modelssemiregular.
4 [0,n) is an accessible range for an objectp of type data_handle_type and an object of typedefault_-
accessor if and only if[p,p + n) is a valid range.
23.7.3.5.3.2 Members [mdspan.accessor.default.members]
template<class OtherElementType>
constexpr default_accessor(default_accessor<OtherElementType>) noexcept {}
1 Constraints: is_convertible_v<OtherElementType(*)[], element_type(*)[]> is true.
constexpr reference access(data_handle_type p, size_t i) const noexcept;
2 Effects: Equivalent to:return p[i];
constexpr data_handle_type offset(data_handle_type p, size_t i) const noexcept;
3 Effects: Equivalent to:return p + i;
23.7.3.5.4 Class template aligned_accessor [mdspan.accessor.aligned]
23.7.3.5.4.1 Overview [mdspan.accessor.aligned.overview]
namespace std {
template<class ElementType, size_t ByteAlignment>
struct aligned_accessor {
using offset_policy = default_accessor<ElementType>;
using element_type = ElementType;
using reference = ElementType&;
using data_handle_type = ElementType*;
static constexpr size_t byte_alignment = ByteAlignment;
constexpr aligned_accessor() noexcept = default;
template<class OtherElementType, size_t OtherByteAlignment>
constexpr aligned_accessor(
aligned_accessor<OtherElementType, OtherByteAlignment>) noexcept;
template<class OtherElementType>
constexpr explicit aligned_accessor(default_accessor<OtherElementType>) noexcept;
§ 23.7.3.5.4 © ISO/IEC
1150

===== PAGE 1162 =====

Dxxxx
template<class OtherElementType>
constexpr operator default_accessor<OtherElementType>() const noexcept;
constexpr reference access(data_handle_type p, size_t i) const noexcept;
constexpr typename offset_policy::data_handle_type offset(
data_handle_type p, size_t i) const noexcept;
};
}
1 Mandates:
—(1.1) byte_alignment is a power of two, and
—(1.2) byte_alignment >= alignof(ElementType) is true.
2 aligned_accessor meets the accessor policy requirements.
3 ElementType is required to be a complete object type that is neither an abstract class type nor an array type.
4 Each specialization ofaligned_accessor is a trivially copyable type that modelssemiregular.
5 [0,n) is an accessible range for an objectp of type data_handle_type and an object of typealigned_-
accessor if and only if
—(5.1) [p,p + n) is a valid range, and,
—(5.2) if n is greater than zero, thenis_sufficiently_aligned<byte_alignment>(p) is true.
6 [Example 1: The following function compute uses is_sufficiently_aligned to check whether a givenmdspan
with default_accessor has a data handle with sufficient alignment to be used withaligned_accessor<float, 4 *
sizeof(float)>. If so, the function dispatches to a functioncompute_using_fourfold_overalignment that requires
fourfold over-alignment of arrays, but can therefore use hardware-specific instructions, such as four-wide SIMD
(Single Instruction Multiple Data) instructions. Otherwise,compute dispatches to a possibly less optimized function
compute_without_requiring_overalignment that has no over-alignment requirement.
void compute_using_fourfold_overalignment(
mdspan<float, dims<1>, layout_right, aligned_accessor<float, 4 * alignof(float)>> x);
void compute_without_requiring_overalignment(
mdspan<float, dims<1>, layout_right> x);
void compute(mdspan<float, dims<1>> x) {
constexpr auto byte_alignment = 4 * sizeof(float);
auto accessor = aligned_accessor<float, byte_alignment>{};
auto x_handle = x.data_handle();
if (is_sufficiently_aligned<byte_alignment>(x_handle)) {
compute_using_fourfold_overalignment(mdspan{x_handle, x.mapping(), accessor});
} else {
compute_without_requiring_overalignment(x);
}
}
—end example]
23.7.3.5.4.2 Members [mdspan.accessor.aligned.members]
template<class OtherElementType, size_t OtherByteAlignment>
constexpr aligned_accessor(aligned_accessor<OtherElementType, OtherByteAlignment>) noexcept;
1 Constraints:
—(1.1) is_convertible_v<OtherElementType(*)[], element_type(*)[]> is true.
—(1.2) OtherByteAlignment >= byte_alignment is true.
2 Effects: None.
template<class OtherElementType>
constexpr explicit aligned_accessor(default_accessor<OtherElementType>) noexcept;
3 Constraints: is_convertible_v<OtherElementType(*)[], element_type(*)[]> is true.
§ 23.7.3.5.4 © ISO/IEC
1151

===== PAGE 1163 =====

Dxxxx
4 Effects: None.
constexpr reference access(data_handle_type p, size_t i) const noexcept;
5 Preconditions: [0,i + 1) is an accessible range forp and *this.
6 Effects: Equivalent to:return assume_aligned<byte_alignment>(p)[i];
template<class OtherElementType>
constexpr operator default_accessor<OtherElementType>() const noexcept;
7 Constraints: is_convertible_v<element_type(*)[], OtherElementType(*)[]> is true.
8 Effects: Equivalent to:return {};
constexpr typename offset_policy::data_handle_type
offset(data_handle_type p, size_t i) const noexcept;
9 Preconditions: [0,i + 1) is an accessible range forp and *this.
10 Effects: Equivalent to:return assume_aligned<byte_alignment>(p) + i;
23.7.3.6 Class template mdspan [mdspan.mdspan]
23.7.3.6.1 Overview [mdspan.mdspan.overview]
1 mdspan is a view of a multidimensional array of elements.
namespace std {
template<class ElementType, class Extents, class LayoutPolicy = layout_right,
class AccessorPolicy = default_accessor<ElementType>>
class mdspan {
public:
using extents_type = Extents;
using layout_type = LayoutPolicy;
using accessor_type = AccessorPolicy;
using mapping_type = layout_type::template mapping<extents_type>;
using element_type = ElementType;
using value_type = remove_cv_t<element_type>;
using index_type = extents_type::index_type;
using size_type = extents_type::size_type;
using rank_type = extents_type::rank_type;
using data_handle_type = accessor_type::data_handle_type;
using reference = accessor_type::reference;
static constexpr rank_type rank() noexcept { return extents_type::rank(); }
static constexpr rank_type rank_dynamic() noexcept { return extents_type::rank_dynamic(); }
static constexpr size_t static_extent(rank_type r) noexcept
{ return extents_type::static_extent(r); }
constexpr index_type extent(rank_type r) const noexcept { return extents().extent(r); }
// 23.7.3.6.2, constructors
constexpr mdspan();
constexpr mdspan(const mdspan& rhs) = default;
constexpr mdspan(mdspan&& rhs) = default;
template<class... OtherIndexTypes>
constexpr explicit mdspan(data_handle_type ptr, OtherIndexTypes... exts);
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
mdspan(data_handle_type p, span<OtherIndexType, N> exts);
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
mdspan(data_handle_type p, const array<OtherIndexType, N>& exts);
constexpr mdspan(data_handle_type p, const extents_type& ext);
constexpr mdspan(data_handle_type p, const mapping_type& m);
constexpr mdspan(data_handle_type p, const mapping_type& m, const accessor_type& a);
§ 23.7.3.6.1 © ISO/IEC
1152

===== PAGE 1164 =====

Dxxxx
template<class OtherElementType, class OtherExtents,
class OtherLayoutPolicy, class OtherAccessorPolicy>
constexpr explicit(see below )
mdspan(const mdspan<OtherElementType, OtherExtents,
OtherLayoutPolicy, OtherAccessorPolicy>& other);
constexpr mdspan& operator=(const mdspan& rhs) = default;
constexpr mdspan& operator=(mdspan&& rhs) = default;
// 23.7.3.6.3, members
template<class... OtherIndexTypes>
constexpr reference operator[](OtherIndexTypes... indices) const;
template<class OtherIndexType>
constexpr reference operator[](span<OtherIndexType, rank()> indices) const;
template<class OtherIndexType>
constexpr reference operator[](const array<OtherIndexType, rank()>& indices) const;
template<class... OtherIndexTypes>
constexpr reference
at(OtherIndexTypes... indices) const; // freestanding-deleted
template<class OtherIndexType>
constexpr reference
at(span<OtherIndexType, rank()> indices) const; // freestanding-deleted
template<class OtherIndexType>
constexpr reference
at(const array<OtherIndexType, rank()>& indices) const; // freestanding-deleted
constexpr size_type size() const noexcept;
constexpr bool empty() const noexcept;
friend constexpr void swap(mdspan& x, mdspan& y) noexcept;
constexpr const extents_type& extents() const noexcept { return map_.extents(); }
constexpr const data_handle_type& data_handle() const noexcept { return ptr_; }
constexpr const mapping_type& mapping() const noexcept { return map_; }
constexpr const accessor_type& accessor() const noexcept { return acc_; }
static constexpr bool is_always_unique()
{ return mapping_type::is_always_unique(); }
static constexpr bool is_always_exhaustive()
{ return mapping_type::is_always_exhaustive(); }
static constexpr bool is_always_strided()
{ return mapping_type::is_always_strided(); }
constexpr bool is_unique() const
{ return map_.is_unique(); }
constexpr bool is_exhaustive() const
{ return map_.is_exhaustive(); }
constexpr bool is_strided() const
{ return map_.is_strided(); }
constexpr index_type stride(rank_type r) const
{ return map_.stride(r); }
private:
accessor_type acc_; // exposition only
mapping_type map_; // exposition only
data_handle_type ptr_; // exposition only
};
template<class CArray>
requires (is_array_v<CArray> && rank_v<CArray> == 1)
mdspan(CArray&)
-> mdspan<remove_all_extents_t<CArray>, extents<size_t, extent_v<CArray, 0>>>;
§ 23.7.3.6.1 © ISO/IEC
1153

===== PAGE 1165 =====

Dxxxx
template<class Pointer>
requires (is_pointer_v<remove_reference_t<Pointer>>)
mdspan(Pointer&&)
-> mdspan<remove_pointer_t<remove_reference_t<Pointer>>, extents<size_t>>;
template<class ElementType, class... Integrals>
requires ((is_convertible_v<Integrals, size_t> && ...) && sizeof...(Integrals) > 0)
explicit mdspan(ElementType*, Integrals...)
-> mdspan<ElementType, extents<size_t, maybe-static-ext <Integrals>...>>;
template<class ElementType, class OtherIndexType, size_t N>
mdspan(ElementType*, span<OtherIndexType, N>)
-> mdspan<ElementType, dextents<size_t, N>>;
template<class ElementType, class OtherIndexType, size_t N>
mdspan(ElementType*, const array<OtherIndexType, N>&)
-> mdspan<ElementType, dextents<size_t, N>>;
template<class ElementType, class IndexType, size_t... ExtentsPack>
mdspan(ElementType*, const extents<IndexType, ExtentsPack...>&)
-> mdspan<ElementType, extents<IndexType, ExtentsPack...>>;
template<class ElementType, class MappingType>
mdspan(ElementType*, const MappingType&)
-> mdspan<ElementType, typename MappingType::extents_type,
typename MappingType::layout_type>;
template<class MappingType, class AccessorType>
mdspan(const typename AccessorType::data_handle_type&, const MappingType&,
const AccessorType&)
-> mdspan<typename AccessorType::element_type, typename MappingType::extents_type,
typename MappingType::layout_type, AccessorType>;
}
2 Mandates:
—(2.1) ElementType is a complete object type that is neither an abstract class type nor an array type,
—(2.2) Extents is a specialization ofextents, and
—(2.3) is_same_v<ElementType, typename AccessorPolicy::element_type> is true.
3 LayoutPolicy shall meet the layout mapping policy requirements (23.7.3.4.3), andAccessorPolicy shall
meet the accessor policy requirements (23.7.3.5.2).
4 Each specializationMDS of mdspan models copyable and
—(4.1) is_nothrow_move_constructible_v<MDS> is true,
—(4.2) is_nothrow_move_assignable_v<MDS> is true, and
—(4.3) is_nothrow_swappable_v<MDS> is true.
5 A specialization of mdspan is a trivially copyable type if itsaccessor_type, mapping_type, and data_-
handle_type are trivially copyable types.
23.7.3.6.2 Constructors [mdspan.mdspan.cons]
constexpr mdspan();
1 Constraints:
—(1.1) rank_dynamic() > 0 is true.
—(1.2) is_default_constructible_v<data_handle_type> is true.
—(1.3) is_default_constructible_v<mapping_type> is true.
—(1.4) is_default_constructible_v<accessor_type> is true.
2 Preconditions: [0,map_.required_span_size()) is an accessible range ofptr_ and acc_ for the values
of map_ and acc_ after the invocation of this constructor.
§ 23.7.3.6.2 © ISO/IEC
1154

===== PAGE 1166 =====

Dxxxx
3 Effects: Value-initializesptr_, map_, andacc_.
template<class... OtherIndexTypes>
constexpr explicit mdspan(data_handle_type p, OtherIndexTypes... exts);
4 Let N be sizeof...(OtherIndexTypes).
5 Constraints:
—(5.1) (is_convertible_v<OtherIndexTypes, index_type> && ...) is true,
—(5.2) (is_nothrow_constructible<index_type, OtherIndexTypes> && ...) is true,
—(5.3) N == rank() || N == rank_dynamic() is true,
—(5.4) is_constructible_v<mapping_type, extents_type> is true, and
—(5.5) is_default_constructible_v<accessor_type> is true.
6 Preconditions: [0,map_.required_span_size()) is an accessible range ofp and acc_ for the values of
map_ and acc_ after the invocation of this constructor.
7 Effects:
—(7.1) Direct-non-list-initializes ptr_ with std::move(p),
—(7.2) direct-non-list-initializes map_ with extents_type(static_cast<index_type>(std::move(exts
))...), and
—(7.3) value-initializes acc_.
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
mdspan(data_handle_type p, span<OtherIndexType, N> exts);
template<class OtherIndexType, size_t N>
constexpr explicit(N != rank_dynamic())
mdspan(data_handle_type p, const array<OtherIndexType, N>& exts);
8 Constraints:
—(8.1) is_convertible_v<const OtherIndexType&, index_type> is true,
—(8.2) is_nothrow_constructible_v<index_type, const OtherIndexType&> is true,
—(8.3) N == rank() || N == rank_dynamic() is true,
—(8.4) is_constructible_v<mapping_type, extents_type> is true, and
—(8.5) is_default_constructible_v<accessor_type> is true.
9 Preconditions: [0,map_.required_span_size()) is an accessible range ofp and acc_ for the values of
map_ and acc_ after the invocation of this constructor.
10 Effects:
—(10.1) Direct-non-list-initializes ptr_ with std::move(p),
—(10.2) direct-non-list-initializes map_ with extents_type(exts), and
—(10.3) value-initializes acc_.
constexpr mdspan(data_handle_type p, const extents_type& ext);
11 Constraints:
—(11.1) is_constructible_v<mapping_type, const extents_type&> is true, and
—(11.2) is_default_constructible_v<accessor_type> is true.
12 Preconditions: [0,map_.required_span_size()) is an accessible range ofp and acc_ for the values of
map_ and acc_ after the invocation of this constructor.
13 Effects:
—(13.1) Direct-non-list-initializes ptr_ with std::move(p),
—(13.2) direct-non-list-initializes map_ with ext, and
—(13.3) value-initializes acc_.
§ 23.7.3.6.2 © ISO/IEC
1155

===== PAGE 1167 =====

Dxxxx
constexpr mdspan(data_handle_type p, const mapping_type& m);
14 Constraints: is_default_constructible_v<accessor_type> is true.
15 Preconditions: [0,m.required_span_size()) is an accessible range ofp and acc_ for the value of
acc_ after the invocation of this constructor.
16 Effects:
—(16.1) Direct-non-list-initializes ptr_ with std::move(p),
—(16.2) direct-non-list-initializes map_ with m, and
—(16.3) value-initializes acc_.
constexpr mdspan(data_handle_type p, const mapping_type& m, const accessor_type& a);
17 Preconditions: [0,m.required_span_size()) is an accessible range ofp and a.
18 Effects:
—(18.1) Direct-non-list-initializes ptr_ with std::move(p),
—(18.2) direct-non-list-initializes map_ with m, and
—(18.3) direct-non-list-initializes acc_ with a.
template<class OtherElementType, class OtherExtents,
class OtherLayoutPolicy, class OtherAccessor>
constexpr explicit(see below )
mdspan(const mdspan<OtherElementType, OtherExtents,
OtherLayoutPolicy, OtherAccessor>& other);
19 Constraints:
—(19.1) is_constructible_v<mapping_type, const OtherLayoutPolicy::template mapping<Oth-
erExtents>&> is true, and
—(19.2) is_constructible_v<accessor_type, const OtherAccessor&> is true.
20 Mandates:
—(20.1) is_constructible_v<data_handle_type, const OtherAccessor::data_handle_type&> is
true, and
—(20.2) is_constructible_v<extents_type, OtherExtents> is true.
21 Preconditions: [0,map_.required_span_size()) is an accessible range ofptr_ and acc_ for values of
ptr_, map_, andacc_ after the invocation of this constructor.
22 Hardened preconditions: For each rank indexr of extents_type, static_extent(r) == dynamic_-
extent || static_extent(r) == other.extent(r) is true.
23 Effects:
—(23.1) Direct-non-list-initializes ptr_ with other.ptr_,
—(23.2) direct-non-list-initializes map_ with other.map_, and
—(23.3) direct-non-list-initializes acc_ with other.acc_.
24 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<const OtherLayoutPolicy::template mapping<OtherExtents>&, mapping_type>
|| !is_convertible_v<const OtherAccessor&, accessor_type>
23.7.3.6.3 Members [mdspan.mdspan.members]
template<class... OtherIndexTypes>
constexpr reference operator[](OtherIndexTypes... indices) const;
1 Constraints:
—(1.1) (is_convertible_v<OtherIndexTypes, index_type> && ...) is true,
—(1.2) (is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...) is true, and
—(1.3) sizeof...(OtherIndexTypes) == rank() is true.
§ 23.7.3.6.3 © ISO/IEC
1156

===== PAGE 1168 =====

Dxxxx
2 Let I be extents_type::index-cast (std::move(indices)).
3 Hardened preconditions: I is a multidimensional index inextents().
[Note 1: This implies thatmap_(I) < map_.required_span_size() is true. —end note]
4 Effects: Equivalent to:
return acc_.access(ptr_, map_(static_cast<index_type>(std::move(indices))...));
template<class OtherIndexType>
constexpr reference operator[](span<OtherIndexType, rank()> indices) const;
template<class OtherIndexType>
constexpr reference operator[](const array<OtherIndexType, rank()>& indices) const;
5 Constraints:
—(5.1) is_convertible_v<const OtherIndexType&, index_type> is true, and
—(5.2) is_nothrow_constructible_v<index_type, const OtherIndexType&> is true.
6 Effects: Let P be a parameter pack such that
is_same_v<make_index_sequence<rank()>, index_sequence<P...>>
is true. Equivalent to:
return operator[](extents_type::index-cast (as_const(indices[P]))...);
template<class... OtherIndexTypes>
constexpr reference at(OtherIndexTypes... indices) const;
7 Constraints:
—(7.1) (is_convertible_v<OtherIndexTypes, index_type> && ...) is true,
—(7.2) (is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...) is true, and
—(7.3) sizeof...(OtherIndexTypes) == rank() is true.
8 Let I be extents_type::index-cast (std::move(indices)).
9 Returns: (*this)[I...].
10 Throws: out_of_range if I is not a multidimensional index inextents().
template<class OtherIndexType>
constexpr reference at(span<OtherIndexType, rank()> indices) const;
template<class OtherIndexType>
constexpr reference at(const array<OtherIndexType, rank()>& indices) const;
11 Constraints:
—(11.1) is_convertible_v<const OtherIndexType&, index_type> is true, and
—(11.2) is_nothrow_constructible_v<index_type, const OtherIndexType&> is true.
12 Effects: Let P be a parameter pack such that
is_same_v<make_index_sequence<rank()>, index_sequence<P...>>
is true. Equivalent to:
return at(extents_type::index-cast (as_const(indices[P]))...);
constexpr size_type size() const noexcept;
13 Preconditions: The size of the multidimensional index spaceextents() is representable as a value of
type size_type (6.9.2).
14 Returns: extents().fwd-prod-of-extents (rank()).
constexpr bool empty() const noexcept;
15 Returns: true if the size of the multidimensional index spaceextents() is 0, otherwisefalse.
friend constexpr void swap(mdspan& x, mdspan& y) noexcept;
16 Effects: Equivalent to:
swap(x.ptr_, y.ptr_);
§ 23.7.3.6.3 © ISO/IEC
1157

===== PAGE 1169 =====

Dxxxx
swap(x.map_, y.map_);
swap(x.acc_, y.acc_);
23.7.3.7 submdspan [mdspan.sub]
23.7.3.7.1 Overview [mdspan.sub.overview]
1 The submdspan facilities create a newmdspan viewing a subset of elements of an existing inputmdspan. The
subset viewed by the createdmdspan is determined by theSliceSpecifier arguments.
2 Given a signed or unsigned integer typeIndexType, a typeS is asubmdspan slice type forIndexType if at
least one of the following holds:
—(2.1) is_convertible_v<S, full_extent_t> is true;
—(2.2) is_convertible_v<S, IndexType> is true;
—(2.3) Sis a specialization ofstrided_sliceandis_convertible_v<X, IndexType>istrueforXdenoting
S::offset_type, S::extent_type, andS::stride_type; or
—(2.4) all of the following hold:
—(2.4.1) the declarationauto [...ls] = std::move(s); is well-formed for some objects of typeS,
—(2.4.2) sizeof...(ls) is equal to 2, and
—(2.4.3) (is_convertible_v<decltype(std::move(ls)), IndexType> && ...) is true.
3 Given a signed or unsigned integer typeIndexType, a type S is a canonical submdspan index type for
IndexType if S is eitherIndexType or constant_wrapper<v> for some valuev of typeIndexType, such that
v is greater than or equal to zero.
4 Given a signed or unsigned integer typeIndexType, a type S is a canonical submdspan slice type for
IndexType if exactly one of the following istrue:
—(4.1) S is full_extent_t;
—(4.2) S is a canonicalsubmdspan index type forIndexType; or
—(4.3) S is a specialization ofstrided_slice where all of the following hold:
—(4.3.1) S::offset_type, S::extent_type, andS::stride_type are all canonicalsubmdspan index types
for IndexType; and
—(4.3.2) if S::stride_type and S::extent_type are both specializations ofconstant_wrapper, then
S::stride_type::value is greater than zero.
5 A typeS is acollapsing slice typeif it is neitherfull_extent_t nor a specialization ofstrided_slice.
[Note 1: Each collapsing slice type insubmdspan_mapping’s parameter pack of slice specifier types reduces the rank
of the result ofsubmdspan_mapping by one. —end note]
6 A typeS is aunit-stride slice typeif
—(6.1) S is a specialization ofstrided_slice where S::stride_type is a specialization ofconstant_wrapper
and S::stride_type::value is equal to 1, or
—(6.2) S denotes full_extent_t.
7 Given an objecte of typeE that is a specialization ofextents, and an objects of typeS that is a canonical
submdspan slice type forE::index_type, thesubmdspan slice range ofs for thekth extent ofe is:
—(7.1) [0,e.extent(k)), ifS is full_extent_t;
—(7.2) [E::index_type(s.offset),E::index_type(s.offset + s.extent)), ifSis a specialization ofstri-
ded_slice; otherwise
—(7.3) [E::index_type(s),E::index_type(s)+ 1)
8 Given a typeE that is a specialization ofextents, a typeS is avalid submdspan slice type for thekth extent
of E if S is a canonical slice type forE::index_type, and forx equal toE::static_extent(k), eitherx is
equal todynamic_extent; or
—(8.1) if S is a specialization ofstrided_slice:
—(8.1.1) if S::offset_type is a specialization ofconstant_wrapper, then S::offset_type::value is
less than or equal tox;
§ 23.7.3.7.1 © ISO/IEC
1158

===== PAGE 1170 =====

Dxxxx
—(8.1.2) if S::offset_type is a specialization ofconstant_wrapper, then S::extent_type::value is
less than or equal tox; and
—(8.1.3) if both S::offset_type and S::extent_type are specializations of constant_wrapper, then
S::offset_type::value + S::extent_type::value is less than or equal tox; or
—(8.2) if S is a specialization ofconstant_wrapper, thenS::value is less thanx.
9 Given an objecte of type E that is a specialization ofextents and an object s of type S, s is a valid
submdspan slice for thekth extent ofe if
—(9.1) S is a validsubmdspan slice type for thekth extent ofE;
—(9.2) the kth interval ofe contains thesubmdspan slice range ofs for thekth extent ofe; and
—(9.3) if S is a specialization ofstrided_slice, then:
—(9.3.1) s.extent is greater than or equal to zero, and
—(9.3.2) either s.extent equals zero ors.stride is greater than zero.
23.7.3.7.2 strided_slice [mdspan.sub.strided.slice]
1 strided_slice represents a set ofextent regularly spaced integer indices. The indices start atoffset, and
increase by increments ofstride.
namespace std {
template<class OffsetType, class ExtentType, class StrideType>
struct strided_slice {
using offset_type = OffsetType;
using extent_type = ExtentType;
using stride_type = StrideType;
[[no_unique_address]] offset_type offset{};
[[no_unique_address]] extent_type extent{};
[[no_unique_address]] stride_type stride{};
};
}
2 strided_slice has the data members and special members specified above. It has no base classes or members
other than those specified.
3 Mandates: OffsetType, ExtentType, and StrideType are signed or unsigned integer types, or model
integral-constant-like .
[Note 1: strided_slice{.offset = 1, .extent = 10, .stride = 3} indicates the indices1, 4, 7, and10. Indices
are selected from the half-open interval[1,1 + 10). —end note]
23.7.3.7.3 submdspan_mapping_result [mdspan.sub.map.result]
1 Specializations of submdspan_mapping_result are returned by overloads ofsubmdspan_mapping.
namespace std {
template<class LayoutMapping>
struct submdspan_mapping_result {
[[no_unique_address]] LayoutMapping mapping = LayoutMapping();
size_t offset{};
};
}
2 submdspan_mapping_result has the data members and special members specified above. It has no base
classes or members other than those specified.
3 LayoutMapping shall meet the layout mapping requirements (23.7.3.4.3).
23.7.3.7.4 Exposition-only helpers [mdspan.sub.helpers]
1 For a packp and an integeri, letMAP_RANK (p, i) be the number of elementsp...[j] for 0 ≤j <iwhose
types are not collapsing slice types.
§ 23.7.3.7.4 © ISO/IEC
1159

===== PAGE 1171 =====

Dxxxx
template<class T>
concept is-strided-slice = see below ;
2 The concept is-strided-slice <T> is satisfied and modeled if and only ifT is a specialization of
strided_slice.
template<class IndexType, class S>
constexpr auto canonical-index (S s);
3 Mandates: If S models integral-constant-like , thenextents<IndexType>::index-cast (S::val-
ue) is representable as a value of typeIndexType.
4 Preconditions: extents<IndexType>::index-cast (std::move(s)) is representable as a value of type
IndexType.
5 Effects: Equivalent to:
—(5.1) return cw<IndexType(S::value)>; if S models integral-constant-like ;
—(5.2) return IndexType(std::move(s)); otherwise.
template<class IndexType, class S>
constexpr auto canonical-slice (S s);
6 Mandates: S is asubmdspan slice type forIndexType.
7 Effects: Equivalent to:
if constexpr (is_convertible_v<S, full_extent_t>) {
return static_cast<full_extent_t>(std::move(s));
} else if constexpr (is_convertible_v<S, IndexType>) {
return canonical-index <IndexType>(std::move(s));
} else if constexpr (is-strided-slice <S>) {
auto c_extent = canonical-index <IndexType>(std::move(s.extent));
auto c_offset = canonical-index <IndexType>(std::move(s.offset));
if constexpr (is_same_v<decltype(c_extent), constant_wrapper<IndexType(0)>>) {
return strided_slice{
.offset = c_offset,
.extent = c_extent,
.stride = cw<IndexType(1)>
};
} else {
return strided_slice{
.offset = c_offset,
.extent = c_extent,
.stride = canonical-index <IndexType>(std::move(s.stride))
};
}
} else {
auto [s_first, s_last] = std::move(s);
auto c_first = canonical-index <IndexType>(std::move(s_first));
auto c_last = canonical-index <IndexType>(std::move(s_last));
return strided_slice{
.offset = c_first,
.extent = canonical-index <IndexType>(c_last - c_first),
.stride = cw<IndexType(1)>
};
}
23.7.3.7.5 submdspan slice canonicalization [mdspan.sub.canonical]
template<class IndexType, size_t... Extents, class... SliceSpecifiers>
constexpr auto submdspan_canonicalize_slices(const extents<IndexType, Extents...>& src,
SliceSpecifiers... slices);
1 Constraints: sizeof...(SliceSpecifiers) equals sizeof...(Extents).
2 Mandates: For each rank indexk of src:
—(2.1) SliceSpecifiers...[k] is asubmdspan slice type forIndexType, and
§ 23.7.3.7.5 © ISO/IEC
1160

===== PAGE 1172 =====

Dxxxx
—(2.2) decltype(canonical-slice <IndexType>(slices...[k])) is a validsubmdspan slice type for
the kth extent ofextents<IndexType, Extents...>.
3 Preconditions: For each rank indexkof src, canonical-slice <IndexType>(slices...[k]) is a valid
submdspan slice for thekth extent ofsrc.
4 Returns: make_tuple(canonical-slice <IndexType>(slices)...).
23.7.3.7.6 submdspan_extents function [mdspan.sub.extents]
template<class IndexType, size_t... Extents, class... SliceSpecifiers>
constexpr auto submdspan_extents(const extents<IndexType, Extents...>& src,
SliceSpecifiers... raw_slices);
1 Let slices be the pack introduced by the following declaration:
auto [...slices] = submdspan_canonicalize_slices(src, raw_slices...);
2 Constraints: sizeof...(SliceSpecifiers) equals sizeof...(Extents).
3 Mandates: For each rank indexk of src:
—(3.1) SliceSpecifiers...[k] is asubmdspan slice type forIndexType, and
—(3.2) decltype(slices...[k]) is a validsubmdspan slice type for thekth extent ofextents<Index-
Type, Extents...>.
4 Preconditions: For each rank indexk of src, slices...[k] is a validsubmdspan slice for thekth
extent ofsrc.
5 Let SubExtents be a specialization ofextents such that:
—(5.1) SubExtents::rank() equals MAP_RANK (slices, Extents::rank()); and
—(5.2) for each rank indexkof Extents such that the type ofslices...[k] is not a collapsing slice type,
SubExtents::static_extent(MAP_RANK (slices, k)) equals the following, whereΣk denotes
the type ofslices...[k]:
—(5.2.1) Extents::static_extent(k) if Σk denotes thefull_extent_t; otherwise
—(5.2.2) 0, if Σk is a specialization of strided_slice and Σk::extent_type denotes constant_-
wrapper<IndexType(0)>; otherwise
—(5.2.3) 1 + ((Σk::extent_type::value - 1) / Σk::stride_type::value), if Σk is a special-
ization of strided_slice whose extent_type and stride_type denote specializations of
constant_wrapper;
—(5.2.4) otherwise, dynamic_extent.
6 Returns: A valueext of typeSubExtents such that for each rank indexk of extents<IndexType,
Extents...>, where the type of slices...[k] is not a collapsing slice type, ext.extent(MAP_-
RANK (slices, k)) equals the following, whereσk denotes slices...[k]:
—(6.1) σk.extent == 0 ? 0 : 1 + (σk.extent - 1) / σk.stride if the type ofσk is a specialization
of strided_slice,
—(6.2) otherwise, U −L, where[L,U) is thesubmdspan slice range ofσk for thekth extent ofsrc.
23.7.3.7.7 Specializations of submdspan_mapping [mdspan.sub.map]
23.7.3.7.7.1 Sliceable layout mapping requirements [mdspan.sub.map.sliceable]
1 Let:
—(1.1) M denote a layout mapping class;
—(1.2) IT denote M::extent_type::index_type;
—(1.3) m denote a value of type (possibly const)M;
—(1.4) M_rank be equal toM::extent_type::rank();
—(1.5) valid_slices denote a pack of (possibly const) objects for whichsizeof...(valid_slices) ==
M_rank is true and, for each rank indexiof m.extents(), valid_slices...[i] is a validsubmdspan
slice for theith extent ofm.extents();
§ 23.7.3.7.7 © ISO/IEC
1161

===== PAGE 1173 =====

Dxxxx
—(1.6) invalid_slices denote a pack of objects for whichsizeof...(invalid_slices) == M_rank is true
and there exists an integerk such that the cv-unqualified type ofinvalid_slices...[k] is none of
the following:
—(1.6.1) IT,
—(1.6.2) full_extent_t,
—(1.6.3) a specialization ofconstant_wrapper, or
—(1.6.4) a specialization ofstrided_slice.
2 For the purpose of this section, the meaning ofsubmdspan_mapping is established as if by performing
argument-dependent lookup only (6.5.4).
3 A typeM meets thesliceable layout mapping requirementsif
—(3.1) M meets the layout mapping requirements (23.7.3.4.3),
—(3.2) the expressionsubmdspan_mapping(m, invalid_slices...) is ill-formed, and
—(3.3) the following expression is well-formed and has the specified semantics:
submdspan_mapping(m, valid_slices...)
4 Result: A type SMR that is a specialization of type submdspan_mapping_result<SM> for some type
SM such that
—(4.1) SM meets the layout mapping requirements (23.7.3.4.3),
—(4.2) SM::extents_type is a specialization ofextents,
—(4.3) SM::extents_type::rank() equals MAP_RANK (valid_slices, M_rank), and
—(4.4) SM::extents_type::index_type denotes IT.
5 Returns: An objectsmr of typeSMR such that
—(5.1) smr.mapping.extents() == submdspan_extents(m.extents(), valid_slices...) is true;
and
—(5.2) for each integer packi which is a multidimensional index insmr.mapping.extents(),
smr.mapping(i...) + smr.offset == m(j) is true, wherej is an integer pack such that
—(5.2.1) sizeof...(j) is equal toM_rank; and
—(5.2.2) for each rank indexρ of m.extents(), j...[ρ] is equal to the sum of
—(5.2.2.1) the lower bound of the submdspan slice range ofvalid_slices...[ρ] for extentρ of
m.extents(), and
—(5.2.2.2) zero if the type ofvalid_slices...[ρ]is a collapsing slice type,i...[MAP_RANK(valid_-
slices,ρ)] otherwise.
template<class LayoutMapping>
concept sliceable-mapping = see below ;
6 Let lm be an object of type LayoutMapping and let fe denote a pack of objects of typefull_-
extent_t for which sizeof...(fe) == LayoutMapping::extents_type::rank() is true. A type
LayoutMapping satisfies sliceable-mapping if
—(6.1) the expressionsubmdspan_mapping(m, fe...) is well-formed when treated as an unevaluated
operand, and
—(6.2) the type of that expression is a specialization ofsubmdspan_mapping_result.
7 A type LayoutMapping models sliceable-mapping if LayoutMapping meets the sliceable layout
mapping requirements.
23.7.3.7.7.2 Common [mdspan.sub.map.common]
1 The following elements apply to all functions in 23.7.3.7.7.
2 Constraints: sizeof...(SpliceSpecifiers) equals extents_type::rank().
3 Mandates: For each rank indexk of extents(), SliceSpecifiers...[k] is a validsubmdspan slice type
for thekth extent ofExtents.
§ 23.7.3.7.7 © ISO/IEC
1162

===== PAGE 1174 =====

Dxxxx
4 Preconditions: For each rank indexk of extents(), slices...[k] is a valid slice for thekth extent of
extents().
5 Let sub_ext be the result ofsubmdspan_extents(extents(), slices...) and letSubExtents be decl-
type(sub_ext).
6 Let sub_strides be anarray<SubExtents::index_type, SubExtents::rank()> such that for each rank
index k of extents() for which the type ofslices...[k] is not a collapsing slice type,sub_strides[MAP_-
RANK (slices,k)] equals:
—(6.1) stride(k) * s.stride if the type ofs is a specialization ofstrided_slice and s.stride < s.ex-
tent is true, wheres is slices...[k];
—(6.2) otherwise, stride(k).
7 Let ls be a pack of values ofindex_type, where theρth element equals the lower bound of thesubmdspan
slice range ofslices...[ρ] for extentρ of extents().
8 If ls...[k] equals extents().extent(k) for any rank indexk of extents(), then letoffset be a value
of typesize_t equal torequired_span_size(). Otherwise, letoffset be a value of typesize_t equal to
operator()(ls...).
23.7.3.7.7.3 layout_left specialization of submdspan_mapping [mdspan.sub.map.left]
template<class Extents>
template<class... SliceSpecifiers>
constexpr auto layout_left::mapping<Extents>::submdspan-mapping-impl (
SliceSpecifiers... slices) const -> see below ;
1 Returns:
—(1.1) submdspan_mapping_result{*this, 0}, ifExtents::rank() == 0 is true;
—(1.2) otherwise, submdspan_mapping_result{layout_left::mapping(sub_ext), offset},
if SubExtents::rank() == 0 is true;
—(1.3) otherwise, submdspan_mapping_result{layout_left::mapping(sub_ext), offset}, if
—(1.3.1) for each k in the range [0,SubExtents::rank() - 1), SpliceSpecifiers...[k] denotes
full_extent_t; and
—(1.3.2) for k equal to SubExtents::rank() - 1, SpliceSpecifiers...[k] is a unit-stride slice
type;
[Note 1: If the above conditions are true, allSpliceSpecifiers...[k] with k larger thanSubExtents
::rank() - 1 are convertible toindex_type. —end note]
—(1.4) otherwise,
submdspan_mapping_result{layout_left_padded<S_static>::mapping(sub_ext, stride(u + 1)),
offset}
if for a valueufor whichu+1 is the smallest valueplarger than zero for whichSliceSpecifiers...
[p] is a unit-stride slice type, the following conditions are met:
—(1.4.1) SliceSpecifiers...[0] is a unit-stride slice type; and
—(1.4.2) for each k in the range [u + 1,u + SubExtents::rank() - 1), SliceSpecifiers...[k]
denotes full_extent_t; and
—(1.4.3) for k equal tou + SubExtents::rank() - 1, SliceSpecifiers...[k] is a unit-stride slice
type;
and whereS_static is:
—(1.4.4) dynamic_extent, ifstatic_extent(k) is dynamic_extent for anyk in the range[0,u + 1),
—(1.4.5) otherwise, the product of all valuesstatic_extent(k) for k in the range[0,u + 1);
—(1.5) otherwise,
submdspan_mapping_result{layout_stride::mapping(sub_ext, sub_strides), offset}
§ 23.7.3.7.7 © ISO/IEC
1163

===== PAGE 1175 =====

Dxxxx
23.7.3.7.7.4 layout_right specialization of submdspan_mapping [mdspan.sub.map.right]
template<class Extents>
template<class... SliceSpecifiers>
constexpr auto layout_right::mapping<Extents>::submdspan-mapping-impl (
SliceSpecifiers... slices) const -> see below ;
1 Returns:
—(1.1) submdspan_mapping_result{*this, 0}, ifExtents::rank() == 0 is true;
—(1.2) otherwise, submdspan_mapping_result{layout_right::mapping(sub_ext), offset},
if SubExtents::rank() == 0 is true;
—(1.3) otherwise, submdspan_mapping_result{layout_right::mapping(sub_ext), offset}, if
—(1.3.1) for eachk in the range[rank_ - SubExtents::rank() + 1,rank_),
SliceSpecifiers...[k] denotes full_extent_t; and
—(1.3.2) for k equal torank_ - SubExtents::rank(), SliceSpecifiers...[k] is a unit-stride slice
type;
[Note 1: If the above conditions are true, allSliceSpecifiers...[k] with
k< rank_ - SubExtents::rank() are convertible toindex_type. —end note]
—(1.4) otherwise,
submdspan_mapping_result{layout_right_padded<S_static>::mapping(sub_ext,
stride(rank_ - u - 2)), offset}
if for a valueu for whichrank_ −u−2 is the largest valuep smaller thanrank_ - 1 for which
SliceSpecifiers...[p] is a unit-stride slice type, the following conditions are met:
—(1.4.1) for k equal torank_ - 1, SliceSpecifiers...[k] is a unit-stride slice type; and
—(1.4.2) for eachk in the range[rank_ - SubExtents::rank() - u + 1,rank_ - u - 1),
SliceSpecifiers...[p] denotes full_extent_t; and
—(1.4.3) for k equal torank_ - SubExtents::rank() - u, SliceSpecifiers...[k] is a unit-stride
slice type;
and whereS_static is:
—(1.4.4) dynamic_extent, if static_extent(k) is dynamic_extent for anyk in the range[rank_ -
u - 1,rank_),
—(1.4.5) otherwise, the product of all valuesstatic_extent(k) for k in the range [rank_ - u -
1,rank_);
—(1.5) otherwise,
submdspan_mapping_result{layout_stride::mapping(sub_ext, sub_strides), offset}
23.7.3.7.7.5 layout_stride specialization of submdspan_mapping [mdspan.sub.map.stride]
template<class Extents>
template<class... SliceSpecifiers>
constexpr auto layout_stride::mapping<Extents>::submdspan-mapping-impl (
SliceSpecifiers... slices) const -> see below ;
1 Returns:
—(1.1) submdspan_mapping_result{*this, 0}, ifExtents::rank() == 0 is true;
—(1.2) otherwise,
submdspan_mapping_result{layout_stride::mapping(sub_ext, sub_strides), offset}
23.7.3.7.7.6 layout_left_padded specialization of submdspan_mapping[mdspan.sub.map.leftpad]
template<class Extents>
template<class... SliceSpecifiers>
constexpr auto layout_left_padded::mapping<Extents>::submdspan-mapping-impl (
SliceSpecifiers... slices) const -> see below ;
1 Returns:
§ 23.7.3.7.7 © ISO/IEC
1164

===== PAGE 1176 =====

Dxxxx
—(1.1) submdspan_mapping_result{*this, 0}, ifExtents::rank() == 0 is true;
—(1.2) otherwise, submdspan_mapping_result{layout_left::mapping(sub_ext), offset}, ifrank_-
== 1 is true or SubExtents::rank() == 0 is true;
—(1.3) otherwise, submdspan_mapping_result{layout_left::mapping(sub_ext), offset}, if
—(1.3.1) SubExtents::rank() == 1 is true and
—(1.3.2) SliceSpecifiers...[0] is a unit-stride slice type;
—(1.4) otherwise,
submdspan_mapping_result{layout_left_padded<S_static>::mapping(sub_ext, stride(u + 1)),
offset}
if for a valueu for whichu + 1 is the smallest valuep larger than zero for whichSliceSpeci-
fiers...[p] is a unit-stride slice type, the following conditions are met:
—(1.4.1) SliceSpecifiers...[0] is a unit-stride slice type; and
—(1.4.2) for each k in the range [u + 1,u + SubExtents::rank() - 1), SliceSpecifiers...[k]
denotes full_extent_t; and
—(1.4.3) for k equal tou + SubExtents::rank() - 1, SliceSpecifiers...[k] is a unit-stride slice
type;
where S_static is:
—(1.4.4) dynamic_extent, if static-padding-stride is dynamic_extent or static_extent(k) is
dynamic_extent for anyk in the range[1,u + 1),
—(1.4.5) otherwise, the product ofstatic-padding-stride and all valuesstatic_extent(k) for k
in the range[1,u + 1);
—(1.5) otherwise,
submdspan_mapping_result{layout_stride::mapping(sub_ext, sub_strides), offset}
23.7.3.7.7.7 layout_right_padded specialization of submdspan_mapping
[mdspan.sub.map.rightpad]
template<class Extents>
template<class... SliceSpecifiers>
constexpr auto layout_right_padded::mapping<Extents>::submdspan-mapping-impl (
SliceSpecifiers... slices) const -> see below ;
1 Returns:
—(1.1) submdspan_mapping_result{*this, 0}, ifrank_ == 0 is true;
—(1.2) otherwise, submdspan_mapping_result{layout_right::mapping(sub_ext), offset},
if rank_ == 1 is true or SubExtents::rank() == 0 is true;
—(1.3) otherwise, submdspan_mapping_result{layout_right::mapping(sub_ext), offset}, if
—(1.3.1) SubExtents::rank() == 1 is true and
—(1.3.2) for k equal torank_ - 1, SliceSpecifiers...[k] is a unit-stride slice type;
—(1.4) otherwise,
submdspan_mapping_result{layout_right_padded<S_static>::mapping(sub_ext,
stride(rank_ - u - 2)), offset}
if for a valueu for whichrank_ - u - 2 is the largest value p smaller thanrank_ - 1 for which
SliceSpecifiers...[p] is a unit-stride slice type, the following conditions are met:
—(1.4.1) for k equal torank_ - 1, SliceSpecifiers...[k] is a unit-stride slice type; and
—(1.4.2) for eachk in the range[rank_ - SubExtents::rank() - u + 1,rank_ - u - 1),
SliceSpecifiers...[k] denotes full_extent_t; and
—(1.4.3) for k equal torank_ - SubExtents::rank() - u, SliceSpecifiers...[k] is a unit-stride
slice type;
§ 23.7.3.7.7 © ISO/IEC
1165

===== PAGE 1177 =====

Dxxxx
and whereS_static is:
—(1.4.4) dynamic_extent if static-padding-stride is dynamic_extent or for anyk in the range
[rank_ - u - 1,rank_ - 1) static_extent(k) is dynamic_extent,
—(1.4.5) otherwise, the product ofstatic-padding-stride and all valuesstatic_extent(k) with k
in the range[rank_ - u - 1,rank_ - 1);
—(1.5) otherwise,
submdspan_mapping_result{layout_stride::mapping(sub_ext, sub_strides), offset}
23.7.3.7.8 submdspan function template [mdspan.sub.sub]
template<class ElementType, class Extents, class LayoutPolicy,
class AccessorPolicy, class... SliceSpecifiers>
constexpr auto submdspan(
const mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>& src,
SliceSpecifiers... slices) -> see below ;
1 Let index_type be typename Extents::index_type.
2 Let slices be the pack introduced by the following declaration:
auto [...slices] = submdspan_canonicalize_slices(src, raw_slices...);
3 Let sub_map_offset be the result ofsubmdspan_mapping(src.mapping(), slices...).
[Note 1: This invocation ofsubmdspan_mapping selects a function call via overload resolution on a candidate
set that includes the lookup set found by argument-dependent lookup (6.5.4).—end note]
4 Constraints:
—(4.1) sizeof...(slices) equals Extents::rank(), and
—(4.2) LayoutPolicy::mapping<Extents> models sliceable-mapping .
5 Mandates: For each rank indexk of src:
—(5.1) SliceSpecifiers...[k] is asubmdspan slice type forindex_type, and
—(5.2) decltype(slices...[k]) is a validsubmdspan slice type for thekth extent ofExtents.
6 Preconditions: For each rank indexk of src.extents(), slices...[k] is a validsubmdspan slice for
the kth extent ofsrc.extents().
7 Effects: Equivalent to:
auto sub_map_result = submdspan_mapping(src.mapping(), slices...);
return mdspan(src.accessor().offset(src.data_handle(), sub_map_result.offset),
sub_map_result.mapping,
typename AccessorPolicy::offset_policy(src.accessor()));
8 [Example 1: Given a rank-3mdspan grid3d representing a three-dimensional grid of regularly spaced points in a
rectangular prism, the functionzero_surface sets all elements on the surface of the 3-dimensional shape to zero. It
does so by reusing a functionzero_2d that takes a rank-2mdspan.
// zero out all elements in anmdspan
template<class T, class E, class L, class A>
void zero_2d(mdspan<T, E, L, A> a) {
static_assert(a.rank() == 2);
for (int i = 0; i < a.extent(0); i++)
for (int j = 0; j < a.extent(1); j++)
a[i, j] = 0;
}
// zero out just the surface
template<class T, class E, class L, class A>
void zero_surface(mdspan<T, E, L, A> grid3d) {
static_assert(grid3d.rank() == 3);
zero_2d(submdspan(grid3d, 0, full_extent, full_extent));
zero_2d(submdspan(grid3d, full_extent, 0, full_extent));
zero_2d(submdspan(grid3d, full_extent, full_extent, 0));
zero_2d(submdspan(grid3d, grid3d.extent(0) - 1, full_extent, full_extent));
zero_2d(submdspan(grid3d, full_extent, grid3d.extent(1) - 1, full_extent));
§ 23.7.3.7.8 © ISO/IEC
1166

===== PAGE 1178 =====

Dxxxx
zero_2d(submdspan(grid3d, full_extent, full_extent, grid3d.extent(2) - 1));
}
—end example]
§ 23.7.3.7.8 © ISO/IEC
1167

===== PAGE 1179 =====

Dxxxx
24 Iterators library [iterators]
24.1 General [iterators.general]
1 This Clause describes components that C++ programs may use to perform iterations over containers (Clause
23), streams (31.7), stream buffers (31.6), and other ranges (Clause 25).
2 The following subclauses describe iterator requirements, and components for iterator primitives, predefined
iterators, and stream iterators, as summarized in Table 76.
Table 76 — Iterators library summary [tab:iterators.summary]
Subclause Header
24.3 Iterator requirements <iterator>
24.4 Iterator primitives
24.5 Iterator adaptors
24.6 Stream iterators
24.7 Range access
24.2 Header <iterator> synopsis [iterator.synopsis]
#include <compare> // see 17.12.1
#include <concepts> // see 18.3
#include <initializer_list> // see 17.11.2
namespace std {
template<class T> using with-reference = T&; // exposition only
template<class T> concept can-reference // exposition only
= requires { typename with-reference<T>; };
template<class T> concept dereferenceable // exposition only
= requires(T& t) {
{ *t } -> can-reference ; // not required to be equality-preserving
};
// 24.3.2, associated types
// 24.3.2.1, incrementable traits
template<class> struct incrementable_traits; // freestanding
template<class T>
using iter_difference_t = see below ; // freestanding
// 24.3.2.2, indirectly readable traits
template<class> struct indirectly_readable_traits; // freestanding
template<class T>
using iter_value_t = see below ; // freestanding
// 24.3.2.3, iterator traits
template<class I> struct iterator_traits; // freestanding
template<class T> requires is_object_v<T> struct iterator_traits<T*>; // freestanding
template<dereferenceable T>
using iter_reference_t = decltype(*declval<T&>()); // freestanding
namespace ranges {
// 24.3.3, customization point objects
inline namespace unspecified {
// 24.3.3.1,ranges::iter_move
inline constexpr unspecified iter_move = unspecified ; // freestanding
§ 24.2 © ISO/IEC
1168

===== PAGE 1180 =====

Dxxxx
// 24.3.3.2,ranges::iter_swap
inline constexpr unspecified iter_swap = unspecified ; // freestanding
}
}
template<dereferenceable T>
requires requires(T& t) {
{ ranges::iter_move(t) } -> can-reference ;
}
using iter_rvalue_reference_t // freestanding
= decltype(ranges::iter_move(declval<T&>()));
// 24.3.4, iterator concepts
// 24.3.4.2, conceptindirectly_readable
template<class In>
concept indirectly_readable = see below ; // freestanding
// 24.3.6.2, indirect callable traits
template<indirectly_readable T>
using indirect-value-t = see below ; // exposition only
template<indirectly_readable T>
using iter_common_reference_t = // freestanding
common_reference_t<iter_reference_t<T>, indirect-value-t <T>>;
// 24.3.4.3, conceptindirectly_writable
template<class Out, class T>
concept indirectly_writable = see below ; // freestanding
// 24.3.4.4, conceptweakly_incrementable
template<class I>
concept weakly_incrementable = see below ; // freestanding
// 24.3.4.5, conceptincrementable
template<class I>
concept incrementable = see below ; // freestanding
// 24.3.4.6, conceptinput_or_output_iterator
template<class I>
concept input_or_output_iterator = see below ; // freestanding
// 24.3.4.7, conceptsentinel_for
template<class S, class I>
concept sentinel_for = see below ; // freestanding
// 24.3.4.8, conceptsized_sentinel_for
template<class S, class I>
constexpr bool disable_sized_sentinel_for = false; // freestanding
template<class S, class I>
concept sized_sentinel_for = see below ; // freestanding
// 24.3.4.9, conceptinput_iterator
template<class I>
concept input_iterator = see below ; // freestanding
// 24.3.4.10, conceptoutput_iterator
template<class I, class T>
concept output_iterator = see below ; // freestanding
// 24.3.4.11, conceptforward_iterator
template<class I>
concept forward_iterator = see below ; // freestanding
§ 24.2 © ISO/IEC
1169

===== PAGE 1181 =====

Dxxxx
// 24.3.4.12, conceptbidirectional_iterator
template<class I>
concept bidirectional_iterator = see below ; // freestanding
// 24.3.4.13, conceptrandom_access_iterator
template<class I>
concept random_access_iterator = see below ; // freestanding
// 24.3.4.14, conceptcontiguous_iterator
template<class I>
concept contiguous_iterator = see below ; // freestanding
// 24.3.6, indirect callable requirements
// 24.3.6.3, indirect callables
template<class F, class I>
concept indirectly_unary_invocable = see below ; // freestanding
template<class F, class I>
concept indirectly_regular_unary_invocable = see below ; // freestanding
template<class F, class I>
concept indirect_unary_predicate = see below ; // freestanding
template<class F, class I1, class I2>
concept indirect_binary_predicate = see below ; // freestanding
template<class F, class I1, class I2 = I1>
concept indirect_equivalence_relation = see below ; // freestanding
template<class F, class I1, class I2 = I1>
concept indirect_strict_weak_order = see below ; // freestanding
template<class F, class... Is>
requires (indirectly_readable<Is> && ...) && invocable<F, iter_reference_t<Is>...>
using indirect_result_t = invoke_result_t<F, iter_reference_t<Is>...>; // freestanding
// 24.3.6.4, projected
template<indirectly_readable I, indirectly_regular_unary_invocable<I> Proj>
using projected = see below ; // freestanding
template<indirectly_readable I, indirectly_regular_unary_invocable<I> Proj>
using projected_value_t = // freestanding
remove_cvref_t<invoke_result_t<Proj&, iter_value_t<I>&>>;
// 24.3.7, common algorithm requirements
// 24.3.7.2, conceptindirectly_movable
template<class In, class Out>
concept indirectly_movable = see below ; // freestanding
template<class In, class Out>
concept indirectly_movable_storable = see below ; // freestanding
// 24.3.7.3, conceptindirectly_copyable
template<class In, class Out>
concept indirectly_copyable = see below ; // freestanding
template<class In, class Out>
concept indirectly_copyable_storable = see below ; // freestanding
// 24.3.7.4, conceptindirectly_swappable
template<class I1, class I2 = I1>
concept indirectly_swappable = see below ; // freestanding
§ 24.2 © ISO/IEC
1170

===== PAGE 1182 =====

Dxxxx
// 24.3.7.5, conceptindirectly_comparable
template<class I1, class I2, class R, class P1 = identity, class P2 = identity>
concept indirectly_comparable = see below ; // freestanding
// 24.3.7.6, conceptpermutable
template<class I>
concept permutable = see below ; // freestanding
// 24.3.7.7, conceptmergeable
template<class I1, class I2, class Out,
class R = ranges::less, class P1 = identity, class P2 = identity>
concept mergeable = see below ; // freestanding
// 24.3.7.8, conceptsortable
template<class I, class R = ranges::less, class P = identity>
concept sortable = see below ; // freestanding
// 24.4, primitives
// 24.4.2, iterator tags
struct input_iterator_tag { }; // freestanding
struct output_iterator_tag { }; // freestanding
struct forward_iterator_tag: public input_iterator_tag { }; // freestanding
struct bidirectional_iterator_tag: public forward_iterator_tag { }; // freestanding
struct random_access_iterator_tag: public bidirectional_iterator_tag { }; // freestanding
struct contiguous_iterator_tag: public random_access_iterator_tag { }; // freestanding
// 24.4.3, iterator operations
template<class InputIterator, class Distance>
constexpr void
advance(InputIterator& i, Distance n); // freestanding
template<class InputIterator>
constexpr typename iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last); // freestanding
template<class InputIterator>
constexpr InputIterator
next(InputIterator x, // freestanding
typename iterator_traits<InputIterator>::difference_type n = 1);
template<class BidirectionalIterator>
constexpr BidirectionalIterator
prev(BidirectionalIterator x, // freestanding
typename iterator_traits<BidirectionalIterator>::difference_type n = 1);
// 24.4.4, range iterator operations
namespace ranges {
// 24.4.4.2,ranges::advance
template<input_or_output_iterator I>
constexpr void advance(I& i, iter_difference_t<I> n); // freestanding
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr void advance(I& i, S bound); // freestanding
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr iter_difference_t<I> advance(I& i, iter_difference_t<I> n, // freestanding
S bound);
// 24.4.4.3,ranges::distance
template<class I, sentinel_for<I> S>
requires (!sized_sentinel_for<S, I>)
constexpr iter_difference_t<I> distance(I first, S last); // freestanding
template<class I, sized_sentinel_for<decay_t<I>> S>
constexpr iter_difference_t<decay_t<I>> distance(I&& first, S last); // freestanding
template<range R>
constexpr range_difference_t<R> distance(R&& r); // freestanding
§ 24.2 © ISO/IEC
1171

===== PAGE 1183 =====

Dxxxx
// 24.4.4.4,ranges::next
template<input_or_output_iterator I>
constexpr I next(I x); // freestanding
template<input_or_output_iterator I>
constexpr I next(I x, iter_difference_t<I> n); // freestanding
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr I next(I x, S bound); // freestanding
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr I next(I x, iter_difference_t<I> n, S bound); // freestanding
// 24.4.4.5,ranges::prev
template<bidirectional_iterator I>
constexpr I prev(I x); // freestanding
template<bidirectional_iterator I>
constexpr I prev(I x, iter_difference_t<I> n); // freestanding
template<bidirectional_iterator I>
constexpr I prev(I x, iter_difference_t<I> n, I bound); // freestanding
}
// 24.5, predefined iterators and sentinels
// 24.5.1, reverse iterators
template<class Iterator> class reverse_iterator; // freestanding
template<class Iterator1, class Iterator2>
constexpr bool operator==( // freestanding
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator!=( // freestanding
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator<( // freestanding
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator>( // freestanding
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator<=( // freestanding
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator>=( // freestanding
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
template<class Iterator1, three_way_comparable_with<Iterator1> Iterator2>
constexpr compare_three_way_result_t<Iterator1, Iterator2>
operator<=>(const reverse_iterator<Iterator1>& x, // freestanding
const reverse_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr auto operator-( // freestanding
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
template<class Iterator>
constexpr reverse_iterator<Iterator> operator+( // freestanding
iter_difference_t<Iterator> n,
const reverse_iterator<Iterator>& x);
template<class Iterator>
constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // freestanding
§ 24.2 © ISO/IEC
1172

===== PAGE 1184 =====

Dxxxx
template<class Iterator1, class Iterator2>
requires (!sized_sentinel_for<Iterator1, Iterator2>)
constexpr bool disable_sized_sentinel_for<reverse_iterator<Iterator1>, // freestanding
reverse_iterator<Iterator2>> = true;
// 24.5.2, insert iterators
template<class Container> class back_insert_iterator; // freestanding
template<class Container>
constexpr back_insert_iterator<Container> back_inserter(Container& x); // freestanding
template<class Container> class front_insert_iterator; // freestanding
template<class Container>
constexpr front_insert_iterator<Container> front_inserter(Container& x); // freestanding
template<class Container> class insert_iterator; // freestanding
template<class Container>
constexpr insert_iterator<Container>
inserter(Container& x, ranges::iterator_t<Container> i); // freestanding
// 24.5.3, constant iterators and sentinels
// 24.5.3.2, alias templates
template<indirectly_readable I>
using iter_const_reference_t = see below ; // freestanding
template<class Iterator>
concept constant-iterator = see below ; // exposition only
template<input_iterator I>
using const_iterator = see below ; // freestanding
template<semiregular S>
using const_sentinel = see below ; // freestanding
// 24.5.3.3, class templatebasic_const_iterator
template<input_iterator Iterator>
class basic_const_iterator; // freestanding
template<class T, common_with<T> U>
requires input_iterator<common_type_t<T, U>>
struct common_type<basic_const_iterator<T>, U> { // freestanding
using type = basic_const_iterator<common_type_t<T, U>>;
};
template<class T, common_with<T> U>
requires input_iterator<common_type_t<T, U>>
struct common_type<U, basic_const_iterator<T>> { // freestanding
using type = basic_const_iterator<common_type_t<T, U>>;
};
template<class T, common_with<T> U>
requires input_iterator<common_type_t<T, U>>
struct common_type<basic_const_iterator<T>, basic_const_iterator<U>> { // freestanding
using type = basic_const_iterator<common_type_t<T, U>>;
};
template<input_iterator I>
constexpr const_iterator<I> make_const_iterator(I it) { return it; } // freestanding
template<semiregular S>
constexpr const_sentinel<S> make_const_sentinel(S s) { return s; } // freestanding
// 24.5.4, move iterators and sentinels
template<class Iterator> class move_iterator; // freestanding
template<class Iterator1, class Iterator2>
constexpr bool operator==( // freestanding
const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
§ 24.2 © ISO/IEC
1173

===== PAGE 1185 =====

Dxxxx
template<class Iterator1, class Iterator2>
constexpr bool operator<( // freestanding
const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator>( // freestanding
const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator<=( // freestanding
const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr bool operator>=( // freestanding
const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
template<class Iterator1, three_way_comparable_with<Iterator1> Iterator2>
constexpr compare_three_way_result_t<Iterator1, Iterator2>
operator<=>(const move_iterator<Iterator1>& x, // freestanding
const move_iterator<Iterator2>& y);
template<class Iterator1, class Iterator2>
constexpr auto operator-( // freestanding
const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y)
-> decltype(x.base() - y.base());
template<class Iterator>
constexpr move_iterator<Iterator>
operator+(iter_difference_t<Iterator> n, const move_iterator<Iterator>& x); // freestanding
template<class Iterator>
constexpr move_iterator<Iterator> make_move_iterator(Iterator i); // freestanding
template<class Iterator1, class Iterator2>
requires (!sized_sentinel_for<Iterator1, Iterator2>)
constexpr bool disable_sized_sentinel_for<move_iterator<Iterator1>, // freestanding
move_iterator<Iterator2>> = true;
template<semiregular S> class move_sentinel; // freestanding
// 24.5.5, common iterators
template<input_or_output_iterator I, sentinel_for<I> S>
requires (!same_as<I, S> && copyable<I>)
class common_iterator; // freestanding
template<class I, class S>
struct incrementable_traits<common_iterator<I, S>>; // freestanding
template<input_iterator I, class S>
struct iterator_traits<common_iterator<I, S>>; // freestanding
// 24.5.6, default sentinel
struct default_sentinel_t; // freestanding
inline constexpr default_sentinel_t default_sentinel{}; // freestanding
// 24.5.7, counted iterators
template<input_or_output_iterator I> class counted_iterator; // freestanding
template<input_iterator I>
requires see below
struct iterator_traits<counted_iterator<I>>; // freestanding
// 24.5.8, unreachable sentinel
struct unreachable_sentinel_t; // freestanding
inline constexpr unreachable_sentinel_t unreachable_sentinel{}; // freestanding
§ 24.2 © ISO/IEC
1174

===== PAGE 1186 =====

Dxxxx
// 24.6, stream iterators
template<class T, class charT = char, class traits = char_traits<charT>,
class Distance = ptrdiff_t>
class istream_iterator;
template<class T, class charT, class traits, class Distance>
bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
const istream_iterator<T,charT,traits,Distance>& y);
template<class T, class charT = char, class traits = char_traits<charT>>
class ostream_iterator;
template<class charT, class traits = char_traits<charT>>
class istreambuf_iterator;
template<class charT, class traits>
bool operator==(const istreambuf_iterator<charT,traits>& a,
const istreambuf_iterator<charT,traits>& b);
template<class charT, class traits = char_traits<charT>>
class ostreambuf_iterator;
// 24.7, range access
template<class C> constexpr auto
begin(C& c) noexcept(noexcept(c.begin())) -> decltype(c.begin()); // freestanding
template<class C> constexpr auto
begin(const C& c) noexcept(noexcept(c.begin())) -> decltype(c.begin()); // freestanding
template<class C> constexpr auto
end(C& c) noexcept(noexcept(c.end())) -> decltype(c.end()); // freestanding
template<class C> constexpr auto
end(const C& c) noexcept(noexcept(c.end())) -> decltype(c.end()); // freestanding
template<class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept; // freestanding
template<class T, size_t N> constexpr T* end(T (&array)[N]) noexcept; // freestanding
template<class C> constexpr auto
cbegin(const C& c) noexcept(noexcept(std::begin(c)))
-> decltype(std::begin(c)); // freestanding
template<class C> constexpr auto
cend(const C& c) noexcept(noexcept(std::end(c))) -> decltype(std::end(c)); // freestanding
template<class C> constexpr auto
rbegin(C& c) noexcept(noexcept(c.rbegin())) -> decltype(c.rbegin()); // freestanding
template<class C> constexpr auto
rbegin(const C& c) noexcept(noexcept(c.rbegin())) -> decltype(c.rbegin()); // freestanding
template<class C> constexpr auto
rend(C& c) noexcept(noexcept(c.rend())) -> decltype(c.rend()); // freestanding
template<class C> constexpr auto
rend(const C& c) noexcept(noexcept(c.rend())) -> decltype(c.rend()); // freestanding
template<class T, size_t N> constexpr reverse_iterator<T*>
rbegin(T (&array)[N]) noexcept; // freestanding
template<class T, size_t N> constexpr reverse_iterator<T*>
rend(T (&array)[N]) noexcept; // freestanding
template<class E> constexpr reverse_iterator<const E*>
rbegin(initializer_list<E> il) noexcept; // freestanding
template<class E> constexpr reverse_iterator<const E*>
rend(initializer_list<E> il) noexcept; // freestanding
template<class C> constexpr auto
crbegin(const C& c) noexcept(noexcept(std::rbegin(c)))
-> decltype(std::rbegin(c)); // freestanding
template<class C> constexpr auto
crend(const C& c) noexcept(noexcept(std::rend(c))) -> decltype(std::rend(c)); // freestanding
template<class C> constexpr auto
size(const C& c) noexcept(noexcept(c.size())) -> decltype(c.size()); // freestanding
template<class T, size_t N> constexpr size_t
size(const T (&array)[N]) noexcept; // freestanding
§ 24.2 © ISO/IEC
1175

===== PAGE 1187 =====

Dxxxx
template<class C> constexpr auto
ssize(const C& c) noexcept(noexcept(c.size()))
-> common_type_t<ptrdiff_t, make_signed_t<decltype(c.size())>>; // freestanding
template<class T, ptrdiff_t N> constexpr ptrdiff_t
ssize(const T (&array)[N]) noexcept; // freestanding
template<class C> constexpr auto
empty(const C& c) noexcept(noexcept(c.empty())) -> decltype(c.empty()); // freestanding
template<class T, size_t N> constexpr bool
empty(const T (&array)[N]) noexcept; // freestanding
template<class C> constexpr auto
data(C& c) noexcept(noexcept(c.data())) -> decltype(c.data()); // freestanding
template<class C> constexpr auto
data(const C& c) noexcept(noexcept(c.data())) -> decltype(c.data()); // freestanding
template<class T, size_t N> constexpr T* data(T (&array)[N]) noexcept; // freestanding
}
24.3 Iterator requirements [iterator.requirements]
24.3.1 General [iterator.requirements.general]
1 Iterators are a generalization of pointers that allow a C++ program to work with different data structures (for
example, containers and ranges) in a uniform manner. To be able to construct template algorithms that work
correctly and efficiently on different types of data structures, the library formalizes not just the interfaces but
also the semantics and complexity assumptions of iterators. An input iteratori supports the expression*i,
resulting in a value of some object typeT, called thevalue typeof the iterator. An output iteratori has
a non-empty set of types that arewritable to the iterator; for each such typeT, the expression*i = o is
valid whereo is a value of typeT. For every iterator typeX, there is a corresponding signed integer-like
type (24.3.4.4) called thedifference typeof the iterator.
2 Since iterators are an abstraction of pointers, their semantics are a generalization of most of the semantics of
pointers in C++. This ensures that every function template that takes iterators works as well with regular
pointers. This document defines six categories of iterators, according to the operations defined on them:input
iterators, output iterators, forward iterators, bidirectional iterators, random access iterators, andcontiguous
iterators, as shown in Table 77.
Table 77 — Relations among iterator categories [tab:iterators.relations]
Contiguous →Random Access →Bidirectional →Forward →Input
→Output
3 The six categories of iterators correspond to the iterator concepts
—(3.1) input_iterator (24.3.4.9),
—(3.2) output_iterator (24.3.4.10),
—(3.3) forward_iterator (24.3.4.11),
—(3.4) bidirectional_iterator (24.3.4.12),
—(3.5) random_access_iterator (24.3.4.13), and
—(3.6) contiguous_iterator (24.3.4.14),
respectively. The generic term iterator refers to any type that models theinput_or_output_iterator
concept (24.3.4.6).
4 Forward iterators meet all the requirements of input iterators and can be used whenever an input iterator is
specified; Bidirectional iterators also meet all the requirements of forward iterators and can be used whenever
a forward iterator is specified; Random access iterators also meet all the requirements of bidirectional
iterators and can be used whenever a bidirectional iterator is specified; Contiguous iterators also meet all the
requirements of random access iterators and can be used whenever a random access iterator is specified.
5 Iterators that further meet the requirements of output iterators are calledmutable iterators. Nonmutable
iterators are referred to asconstant iterators.
§ 24.3.1 © ISO/IEC
1176

===== PAGE 1188 =====

Dxxxx
6 In addition to the requirements in this subclause, the nestedtypedef-names specified in 24.3.2.3 shall be
provided for the iterator type.
[Note 1: Either the iterator type must provide thetypedef-names directly (in which caseiterator_traits pick them
up automatically), or aniterator_traits specialization must provide them.—end note]
7 Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of
the array, so for any iterator type there is an iterator value that points past the last element of a corresponding
sequence. Such a value is called apast-the-end value. Values of an iteratori for which the expression*i is
defined are calleddereferenceable. The library never assumes that past-the-end values are dereferenceable.
Iterators can also have singular values that are not associated with any sequence. Results of most expressions
are undefined for singular values; the only exceptions are destroying an iterator that holds a singular value,
the assignment of a non-singular value to an iterator that holds a singular value, and, for iterators that meet
the Cpp17DefaultConstructible requirements, using a value-initialized iterator as the source of a copy or move
operation.
[Note 2: This guarantee is not offered for default-initialization, although the distinction only matters for types with
trivial default constructors such as pointers or aggregates holding pointers.—end note]
In these cases the singular value is overwritten the same way as any other value. Dereferenceable values are
always non-singular.
8 Most of the library’s algorithmic templates that operate on data structures have interfaces that use ranges.
A range is an iterator and asentinel that designate the beginning and end of the computation, or an iterator
and a count that designate the beginning and the number of elements to which the computation is to be
applied.190
9 An iterator and a sentinel denoting a range are comparable. A range[i,s) is empty ifi == s; otherwise,
[i,s) refers to the elements in the data structure starting with the element pointed to byi and up to but not
including the element, if any, pointed to by the first iteratorj such thatj == s.
10 A sentinels is calledreachable froman iteratori if and only if there is a finite sequence of applications of
the expression++i that makesi == s. If s is reachable fromi, [i,s) denotes avalid range.
11 A counted rangei+ [0, n) is empty ifn == 0; otherwise, i+ [0, n) refers to then elements in the data
structure starting with the element pointed to byi and up to but not including the element, if any, pointed
to by the result ofn applications of++i. A counted rangei+ [0, n) is valid if and only ifn == 0; orn is
positive, i is dereferenceable, and++i+ [0, --n) is valid.
12 The result of the application of library functions to invalid ranges is undefined.
13 For an iteratori of a type that modelscontiguous_iterator (24.3.4.14), library functions are permitted to
replace [i,s) with [to_address(i),to_address(i + ranges::distance(i, s))), and to replacei+ [0, n)
with [to_address(i),to_address(i + n)).
[Note 3: This means a program cannot rely on any side effects of dereferencing a contiguous iteratori, because library
functions might operate on pointers obtained byto_address(i) instead of operating oni. Similarly, a program
cannot rely on any side effects of individual increments on a contiguous iteratori, because library functions might
advance i only once. —end note]
14 All the categories of iterators require only those functions that are realizable for a given category in constant
time (amortized). Therefore, requirement tables and concept definitions for the iterators do not specify
complexity.
15 Destruction of an iterator may invalidate pointers and references previously obtained from that iterator if its
type does not meet theCpp17ForwardIteratorrequirements and does not modelforward_iterator.
16 An invalid iteratoris an iterator that may be singular.191
17 Iterators meet the constexpr iterator requirements if all operations provided to meet iterator category
requirements are constexpr functions.
[Note 4: For example, the types “pointer toint” andreverse_iterator<int*> meet the constexpr iterator require-
ments. —end note]
190) The sentinel denoting the end of a range can have the same type as the iterator denoting the beginning of the range, or a
different type.
191) This definition applies to pointers, since pointers are iterators. The effect of dereferencing an iterator that has been
invalidated is undefined.
§ 24.3.1 © ISO/IEC
1177

===== PAGE 1189 =====

Dxxxx
24.3.2 Associated types [iterator.assoc.types]
24.3.2.1 Incrementable traits [incrementable.traits]
1 To implement algorithms only in terms of incrementable types, it is often necessary to determine the difference
type that corresponds to a particular incrementable type. Accordingly, it is required that ifWI is the name of
a type that models theweakly_incrementable concept (24.3.4.4), the type
iter_difference_t<WI>
be defined as the incrementable type’s difference type.
namespace std {
template<class> struct incrementable_traits { };
template<class T>
requires is_object_v<T>
struct incrementable_traits<T*> {
using difference_type = ptrdiff_t;
};
template<class I>
struct incrementable_traits<const I>
: incrementable_traits<I> { };
template<class T>
requires requires { typename T::difference_type; }
struct incrementable_traits<T> {
using difference_type = T::difference_type;
};
template<class T>
requires (!requires { typename T::difference_type; } &&
requires(const T& a, const T& b) { { a - b } -> integral; })
struct incrementable_traits<T> {
using difference_type = make_signed_t<decltype(declval<T>() - declval<T>())>;
};
template<class T>
using iter_difference_t = see below ;
}
2 Let RI be remove_cvref_t<I>. The typeiter_difference_t<I> denotes
—(2.1) incrementable_traits<RI>::difference_typeif iterator_traits<RI>names a specialization gen-
erated from the primary template, and
—(2.2) iterator_traits<RI>::difference_type otherwise.
3 Users may specializeincrementable_traits on program-defined types.
24.3.2.2 Indirectly readable traits [readable.traits]
1 To implement algorithms only in terms of indirectly readable types, it is often necessary to determine the
value type that corresponds to a particular indirectly readable type. Accordingly, it is required that ifR is
the name of a type that models theindirectly_readable concept (24.3.4.2), the type
iter_value_t<R>
be defined as the indirectly readable type’s value type.
template<class> struct cond-value-type { }; // exposition only
template<class T>
requires is_object_v<T>
struct cond-value-type <T> {
using value_type = remove_cv_t<T>;
};
template<class T>
concept has-member-value-type = requires { typename T::value_type; }; // exposition only
§ 24.3.2.2 © ISO/IEC
1178

===== PAGE 1190 =====

Dxxxx
template<class T>
concept has-member-element-type = requires { typename T::element_type; }; // exposition only
template<class> struct indirectly_readable_traits { };
template<class T>
struct indirectly_readable_traits<T*>
: cond-value-type <T> { };
template<class I>
requires is_array_v<I>
struct indirectly_readable_traits<I> {
using value_type = remove_cv_t<remove_extent_t<I>>;
};
template<class I>
struct indirectly_readable_traits<const I>
: indirectly_readable_traits<I> { };
template<has-member-value-type T>
struct indirectly_readable_traits<T>
: cond-value-type <typename T::value_type> { };
template<has-member-element-type T>
struct indirectly_readable_traits<T>
: cond-value-type <typename T::element_type> { };
template<has-member-value-type T>
requires has-member-element-type <T>
struct indirectly_readable_traits<T> { };
template<has-member-value-type T>
requires has-member-element-type <T> &&
same_as<remove_cv_t<typename T::element_type>, remove_cv_t<typename T::value_type>>
struct indirectly_readable_traits<T>
: cond-value-type <typename T::value_type> { };
template<class T> using iter_value_t = see below ;
2 Let RI be remove_cvref_t<I>. The typeiter_value_t<I> denotes
—(2.1) indirectly_readable_traits<RI>::value_type if iterator_traits<RI> names a specialization
generated from the primary template, and
—(2.2) iterator_traits<RI>::value_type otherwise.
3 Class templateindirectly_readable_traits may be specialized on program-defined types.
4 [Note 1: Some legacy output iterators define a nested type namedvalue_type that is an alias forvoid. These types
are notindirectly_readable and have no associated value types.—end note]
5 [Note 2: Smart pointers likeshared_ptr<int> are indirectly_readable and have an associated value type, but a
smart pointer likeshared_ptr<void> is notindirectly_readable and has no associated value type.—end note]
24.3.2.3 Iterator traits [iterator.traits]
1 To implement algorithms only in terms of iterators, it is sometimes necessary to determine the iterator
category that corresponds to a particular iterator type. Accordingly, it is required that ifI is the type of an
iterator, the type
iterator_traits<I>::iterator_category
be defined as the iterator’s iterator category. In addition, the types
iterator_traits<I>::pointer
iterator_traits<I>::reference
shall be defined as the iterator’s pointer and reference types; that is, for an iterator objecta of class
type, the same type asdecltype(a.operator->()) and decltype(*a), respectively. The typeiterator_-
§ 24.3.2.3 © ISO/IEC
1179

===== PAGE 1191 =====

Dxxxx
traits<I>::pointer shall be void for an iterator of class type I that does not support operator->.
Additionally, in the case of an output iterator, the types
iterator_traits<I>::value_type
iterator_traits<I>::difference_type
iterator_traits<I>::reference
may be defined asvoid.
2 The definitions in this subclause make use of the following exposition-only concepts:
template<class I>
concept cpp17-iterator =
requires(I i) {
{ *i } -> can-reference ;
{ ++i } -> same_as<I&>;
{ *i++ } -> can-reference ;
} && copyable<I>;
template<class I>
concept cpp17-input-iterator =
cpp17-iterator <I> && equality_comparable<I> && requires(I i) {
typename incrementable_traits<I>::difference_type;
typename indirectly_readable_traits<I>::value_type;
typename common_reference_t<iter_reference_t<I>&&,
typename indirectly_readable_traits<I>::value_type&>;
typename common_reference_t<decltype(*i++)&&,
typename indirectly_readable_traits<I>::value_type&>;
requires signed_integral<typename incrementable_traits<I>::difference_type>;
};
template<class I>
concept cpp17-forward-iterator =
cpp17-input-iterator <I> && constructible_from<I> &&
is_reference_v<iter_reference_t<I>> &&
same_as<remove_cvref_t<iter_reference_t<I>>,
typename indirectly_readable_traits<I>::value_type> &&
requires(I i) {
{ i++ } -> convertible_to<const I&>;
{ *i++ } -> same_as<iter_reference_t<I>>;
};
template<class I>
concept cpp17-bidirectional-iterator =
cpp17-forward-iterator <I> && requires(I i) {
{ --i } -> same_as<I&>;
{ i-- } -> convertible_to<const I&>;
{ *i-- } -> same_as<iter_reference_t<I>>;
};
template<class I>
concept cpp17-random-access-iterator =
cpp17-bidirectional-iterator <I> && totally_ordered<I> &&
requires(I i, typename incrementable_traits<I>::difference_type n) {
{ i += n } -> same_as<I&>;
{ i -= n } -> same_as<I&>;
{ i + n } -> same_as<I>;
{ n + i } -> same_as<I>;
{ i - n } -> same_as<I>;
{ i - i } -> same_as<decltype(n)>;
{ i[n] } -> convertible_to<iter_reference_t<I>>;
};
3 The members of a specializationiterator_traits<I> generated from theiterator_traits primary tem-
plate are computed as follows:
§ 24.3.2.3 © ISO/IEC
1180

===== PAGE 1192 =====

Dxxxx
—(3.1) If I has valid (13.10.3) member typesdifference_type, value_type, reference, and iterator_-
category, theniterator_traits<I> has the following publicly accessible members:
using iterator_category = I::iterator_category;
using value_type = I::value_type;
using difference_type = I::difference_type;
using pointer = see below ;
using reference = I::reference;
If thequalified-id I::pointer is valid and denotes a type, theniterator_traits<I>::pointer names
that type; otherwise, it namesvoid.
—(3.2) Otherwise, if I satisfies the exposition-only conceptcpp17-input-iterator , iterator_traits<I>
has the following publicly accessible members:
using iterator_category = see below ;
using value_type = indirectly_readable_traits<I>::value_type;
using difference_type = incrementable_traits<I>::difference_type;
using pointer = see below ;
using reference = see below ;
—(3.2.1) If the qualified-id I::pointer is valid and denotes a type,pointer names that type. Other-
wise, ifdecltype(declval<I&>().operator->()) is well-formed, thenpointer names that type.
Otherwise, pointer names void.
—(3.2.2) Ifthe qualified-id I::referenceisvalidanddenotesatype, referencenamesthattype. Otherwise,
reference names iter_reference_t<I>.
—(3.2.3) If thequalified-id I::iterator_category is valid and denotes a type,iterator_category names
that type. Otherwise,iterator_category names:
—(3.2.3.1) random_access_iterator_tag if I satisfies cpp17-random-access-iterator , or otherwise
—(3.2.3.2) bidirectional_iterator_tag if I satisfies cpp17-bidirectional-iterator , or otherwise
—(3.2.3.3) forward_iterator_tag if I satisfies cpp17-forward-iterator , or otherwise
—(3.2.3.4) input_iterator_tag.
—(3.3) Otherwise, if I satisfies the exposition-only conceptcpp17-iterator , theniterator_traits<I> has
the following publicly accessible members:
using iterator_category = output_iterator_tag;
using value_type = void;
using difference_type = see below ;
using pointer = void;
using reference = void;
If the qualified-id incrementable_traits<I>::difference_type is valid and denotes a type, then
difference_type names that type; otherwise, it namesvoid.
—(3.4) Otherwise, iterator_traits<I> has no members by any of the above names.
4 Explicit or partial specializations ofiterator_traits may have a member typeiterator_concept that is
used to indicate conformance to the iterator concepts (24.3.4).
[Example 1: To indicate conformance to theinput_iterator concept but a lack of conformance to theCpp17InputIter-
ator requirements (24.3.5.3), an iterator_traits specialization might have iterator_concept denote input_-
iterator_tag but not defineiterator_category. —end example]
5 iterator_traits is specialized for pointers as
namespace std {
template<class T>
requires is_object_v<T>
struct iterator_traits<T*> {
using iterator_concept = contiguous_iterator_tag;
using iterator_category = random_access_iterator_tag;
using value_type = remove_cv_t<T>;
using difference_type = ptrdiff_t;
using pointer = T*;
using reference = T&;
§ 24.3.2.3 © ISO/IEC
1181

===== PAGE 1193 =====

Dxxxx
};
}
6 [Example 2: To implement a genericreverse function, a C++ program can do the following:
template<class BI>
void reverse(BI first, BI last) {
typename iterator_traits<BI>::difference_type n = distance(first, last);
--n;
while (n > 0) {
typename iterator_traits<BI>::value_type tmp = *first;
*first++ = *--last;
*last = tmp;
n -= 2;
}
}
—end example]
24.3.3 Customization point objects [iterator.cust]
24.3.3.1 ranges::iter_move [iterator.cust.move]
1 The nameranges::iter_move denotes a customization point object (16.3.3.3.5). The expressionranges::-
iter_move(E) for a subexpressionE is expression-equivalent to:
—(1.1) iter_move(E), if E has class or enumeration type anditer_move(E) is a well-formed expression when
treated as an unevaluated operand, where the meaning ofiter_move is established as-if by performing
argument-dependent lookup only (6.5.4).
—(1.2) Otherwise, if the expression*E is well-formed:
—(1.2.1) if *E is an lvalue,std::move(*E);
—(1.2.2) otherwise, *E.
—(1.3) Otherwise, ranges::iter_move(E) is ill-formed.
[Note 1: This case can result in substitution failure whenranges::iter_move(E) appears in the immediate
context of a template instantiation.—end note]
2 If ranges::iter_move(E) is not equal to*E, the program is ill-formed, no diagnostic required.
24.3.3.2 ranges::iter_swap [iterator.cust.swap]
1 The nameranges::iter_swap denotes a customization point object (16.3.3.3.5) that exchanges the values
(18.4.9) denoted by its arguments.
2 Let iter-exchange-move be the exposition-only function template:
template<class X, class Y>
constexpr iter_value_t<X> iter-exchange-move (X&& x, Y&& y)
noexcept(noexcept(iter_value_t<X>(iter_move(x))) &&
noexcept(*x = iter_move(y)));
3 Effects: Equivalent to:
iter_value_t<X> old_value(iter_move(x));
*x = iter_move(y);
return old_value;
4 The expressionranges::iter_swap(E1, E2) for subexpressionsE1 and E2 is expression-equivalent to:
—(4.1) (void)iter_swap(E1, E2), if eitherE1 or E2 has class or enumeration type anditer_swap(E1, E2)
is a well-formed expression with overload resolution performed in a context that includes the declaration
template<class I1, class I2>
void iter_swap(I1, I2) = delete;
and does not include a declaration ofranges::iter_swap. If the function selected by overload resolution
does not exchange the values denoted byE1 and E2, the program is ill-formed, no diagnostic required.
[Note 1: This precludes calling unconstrainedstd::iter_swap. When the deleted overload is viable, program-
defined overloads need to be more specialized (13.7.7.3) to be selected.—end note]
§ 24.3.3.2 © ISO/IEC
1182

===== PAGE 1194 =====

Dxxxx
—(4.2) Otherwise, if the types ofE1 and E2 each modelindirectly_readable, and if the reference types of
E1 and E2 model swappable_with (18.4.9), thenranges::swap(*E1, *E2).
—(4.3) Otherwise, if the types T1 and T2 of E1 and E2 model indirectly_movable_storable<T1, T2>
and indirectly_movable_storable<T2, T1>, then(void)(*E1 = iter-exchange-move(E2, E1)),
except thatE1 is evaluated only once.
—(4.4) Otherwise, ranges::iter_swap(E1, E2) is ill-formed.
[Note 2: This case can result in substitution failure whenranges::iter_swap(E1, E2) appears in the immediate
context of a template instantiation.—end note]
24.3.4 Iterator concepts [iterator.concepts]
24.3.4.1 General [iterator.concepts.general]
1 For a typeI, letITER_TRAITS(I) denote the typeI if iterator_traits<I> names a specialization generated
from the primary template. Otherwise,ITER_TRAITS(I) denotes iterator_traits<I>.
—(1.1) If the qualified-id ITER_TRAITS(I)::iterator_concept is valid and names a type, then ITER_-
CONCEPT(I) denotes that type.
—(1.2) Otherwise, if thequalified-id ITER_TRAITS(I)::iterator_category is valid and names a type, then
ITER_CONCEPT(I) denotes that type.
—(1.3) Otherwise, if iterator_traits<I> names a specialization generated from the primary template, then
ITER_CONCEPT(I) denotes random_access_iterator_tag.
—(1.4) Otherwise, ITER_CONCEPT(I) does not denote a type.
2 [Note 1: ITER_TRAITS enables independent syntactic determination of an iterator’s category and concept.—end
note]
[Example 1:
struct I {
using value_type = int;
using difference_type = int;
int operator*() const;
I& operator++();
I operator++(int);
I& operator--();
I operator--(int);
bool operator==(I) const;
};
iterator_traits<I>::iterator_category denotes input_iterator_tag, and ITER_CONCEPT (I) denotes random_-
access_iterator_tag. —end example]
24.3.4.2 Concept indirectly_readable [iterator.concept.readable]
1 Typesthatareindirectlyreadablebyapplying operator*modelthe indirectly_readableconcept, including
pointers, smart pointers, and iterators.
template<class In>
concept indirectly-readable-impl = // exposition only
requires(const In in) {
typename iter_value_t<In>;
typename iter_reference_t<In>;
typename iter_rvalue_reference_t<In>;
{ *in } -> same_as<iter_reference_t<In>>;
{ ranges::iter_move(in) } -> same_as<iter_rvalue_reference_t<In>>;
} &&
common_reference_with<iter_reference_t<In>&&, iter_value_t<In>&> &&
common_reference_with<iter_reference_t<In>&&, iter_rvalue_reference_t<In>&&> &&
common_reference_with<iter_rvalue_reference_t<In>&&, const iter_value_t<In>&>;
template<class In>
concept indirectly_readable =
indirectly-readable-impl <remove_cvref_t<In>>;
§ 24.3.4.2 © ISO/IEC
1183

===== PAGE 1195 =====

Dxxxx
2 Given a valuei of typeI, I models indirectly_readable only if the expression*i is equality-preserving.
24.3.4.3 Concept indirectly_writable [iterator.concept.writable]
1 The indirectly_writable concept specifies the requirements for writing a value into an iterator’s referenced
object.
template<class Out, class T>
concept indirectly_writable =
requires(Out&& o, T&& t) {
*o = std::forward<T>(t); // not required to be equality-preserving
*std::forward<Out>(o) = std::forward<T>(t); // not required to be equality-preserving
const_cast<const iter_reference_t<Out>&&>(*o) =
std::forward<T>(t); // not required to be equality-preserving
const_cast<const iter_reference_t<Out>&&>(*std::forward<Out>(o)) =
std::forward<T>(t); // not required to be equality-preserving
};
2 Let E be an expression such thatdecltype((E)) is T, and leto be a dereferenceable object of typeOut. Out
and T model indirectly_writable<Out, T> only if:
—(2.1) If Out and T model indirectly_readable<Out> && same_as<iter_value_t<Out>, decay_t<T>>,
then *o after any above assignment is equal to the value ofE before the assignment.
3 After evaluating any above assignment expression,o is not required to be dereferenceable.
4 If E is an xvalue (7.2.1), the resulting state of the object it denotes is valid but unspecified (16.4.6.17).
5 [Note 1: The only valid use of anoperator* is on the left side of the assignment statement. Assignment through the
same value of the indirectly writable type happens only once.—end note]
6 [Note 2: indirectly_writable has the awkwardconst_cast expressions to reject iterators with prvalue non-proxy
reference types that permit rvalue assignment but do not also permitconst rvalue assignment. Consequently, an
iterator typeI that returnsstd::string by value does not modelindirectly_writable<I, std::string>. —end
note]
24.3.4.4 Concept weakly_incrementable [iterator.concept.winc]
1 The weakly_incrementable concept specifies the requirements on types that can be incremented with the
pre- and post-increment operators. The increment operations are not required to be equality-preserving, nor
is the type required to beequality_comparable.
template<class T>
constexpr bool is-integer-like = see below ; // exposition only
template<class T>
constexpr bool is-signed-integer-like = see below ; // exposition only
template<class I>
concept weakly_incrementable =
movable<I> &&
requires(I i) {
typename iter_difference_t<I>;
requires is-signed-integer-like <iter_difference_t<I>>;
{ ++i } -> same_as<I&>; // not required to be equality-preserving
i++; // not required to be equality-preserving
};
2 A typeI is aninteger-class typeif it is in a set of implementation-defined types that behave as integer types
do, as defined below.
[Note 1: An integer-class type is not necessarily a class type.—end note]
3 The range of representable values of an integer-class type is the continuous set of values over which it is
defined. For any integer-class type, its range of representable values is either−2N−1 to 2N−1 −1 (inclusive)
for some integerN, in which case it is asigned-integer-class type, or0 to 2N −1 (inclusive) for some integer
N, in which case it is anunsigned-integer-class type. In both cases,N is called thewidth of the integer-class
type. The width of an integer-class type is greater than that of every integral type of the same signedness.
4 A typeI other thancv bool is integer-like if it modelsintegral<I> or if it is an integer-class type. An
integer-like typeI is signed-integer-like if it modelssigned_integral<I> or if it is a signed-integer-class
§ 24.3.4.4 © ISO/IEC
1184

===== PAGE 1196 =====

Dxxxx
type. An integer-like type I is unsigned-integer-like if it models unsigned_integral<I> or if it is an
unsigned-integer-class type.
5 For every integer-class typeI, letB(I) be a unique hypothetical extended integer type of the same signedness
with the same width (6.9.2) asI.
[Note 2: The corresponding hypothetical specializationnumeric_limits<B(I)> meets the requirements onnumeric_-
limits specializations for integral types (17.3.5).—end note]
For every integral typeJ, letB(J) be the same type asJ.
6 Expressions of integer-class type are explicitly convertible to any integer-like type, and implicitly convertible
to any integer-class type of equal or greater width and the same signedness. Expressions of integral type
are both implicitly and explicitly convertible to any integer-class type. Conversions between integral and
integer-class types and between two integer-class types do not exit via an exception. The result of such a
conversion is the unique value of the destination type that is congruent to the source modulo2N, whereN is
the width of the destination type.
7 Let a be an object of integer-class typeI, letb be an object of integer-like typeI2 such that the expressionb
is implicitly convertible toI, letx and y be, respectively, objects of typeB(I) and B(I2) as described above
that represent the same values asa and b, and letc be an lvalue of any integral type.
—(7.1) The expressionsa++ and a-- shall be prvalues of typeI whose values are equal to that ofa prior to
the evaluation of the expressions. The expressiona++ shall modify the value ofa by adding1 to it.
The expressiona-- shall modify the value ofa by subtracting1 from it.
—(7.2) The expressions++a, --a, and&a shall be expression-equivalent toa += 1, a -= 1, andaddressof(a),
respectively.
—(7.3) For everyunary-operator @ other than& for which the expression@x is well-formed,@a shall also be
well-formed and have the same value, effects, and value category as@x. If @x has typebool, so too
does @a; if@x has typeB(I), then@a has typeI.
—(7.4) For every assignment operator@= for whichc @= x is well-formed,c @= a shall also be well-formed
and shall have the same value and effects asc @= x. The expressionc @= a shall be an lvalue referring
to c.
—(7.5) For every assignment operator@= for whichx @= y is well-formed,a @= b shall also be well-formed
and shall have the same effects asx @= y, except that the value that would be stored intox is stored
into a. The expressiona @= b shall be an lvalue referring toa.
—(7.6) For every non-assignment binary operator@ for whichx @ y and y @ x are well-formed,a @ b and b
@ a shall also be well-formed and shall have the same value, effects, and value category asx @ y and y
@ x, respectively. Ifx @ y or y @ x has typeB(I), thena @ b or b @ a, respectively, has typeI; if x
@ y or y @ x has typeB(I2), thena @ b or b @ a, respectively, has typeI2; ifx @ y or y @ x has
any other type, thena @ b or b @ a, respectively, has that type.
8 An expressionE of integer-class typeI is contextually convertible tobool as if bybool(E != I(0)).
9 All integer-class types modelregular (18.6) andthree_way_comparable<strong_ordering> (17.12.4).
10 A value-initialized object of integer-class type has value 0.
11 For every (possibly cv-qualified) integer-class typeI, numeric_limits<I> is specialized such that each static
data memberm has the same value asnumeric_limits<B(I)>::m, and each static member functionf returns
I(numeric_limits<B(I)>::f()).
12 For any two integer-like typesI1 and I2, at least one of which is an integer-class type,common_type_t<I1,
I2> denotes an integer-class type whose width is not less than that ofI1 or I2. If both I1 and I2 are
signed-integer-like types, thencommon_type_t<I1, I2> is also a signed-integer-like type.
13 is-integer-like <I> is true if and only ifI is an integer-like type.is-signed-integer-like <I> is true
if and only ifI is a signed-integer-like type.
14 Let i be an object of typeI. When i is in the domain of both pre- and post-increment,i is said to be
incrementable. I models weakly_incrementable<I> only if:
—(14.1) The expressions++i and i++ have the same domain.
—(14.2) If i is incrementable, then both++i and i++ advance i to the next element.
—(14.3) If i is incrementable, thenaddressof(++i) is equal toaddressof(i).
§ 24.3.4.4 © ISO/IEC
1185

===== PAGE 1197 =====

Dxxxx
15 Recommended practice: The implementation of an algorithm on a weakly incrementable type should never
attempt to pass through the same incrementable value twice; such an algorithm should be a single-pass
algorithm.
[Note 3: For weakly_incrementable types, a equals b does not imply that++a equals ++b. (Equality does not
guarantee the substitution property or referential transparency.) Such algorithms can be used with istreams as the
source of the input data through theistream_iterator class template. —end note]
24.3.4.5 Concept incrementable [iterator.concept.inc]
1 The incrementable concept specifies requirements on types that can be incremented with the pre- and
post-increment operators. The increment operations are required to be equality-preserving, and the type is
required to beequality_comparable.
[Note 1: This supersedes the “not required to be equality-preserving” comments on the increment expressions in the
definition ofweakly_incrementable. —end note]
template<class I>
concept incrementable =
regular<I> &&
weakly_incrementable<I> &&
requires(I i) {
{ i++ } -> same_as<I>;
};
2 Let a and b be incrementable objects of typeI. I models incrementable only if:
—(2.1) If bool(a == b) then bool(a++ == b).
—(2.2) If bool(a == b) then bool(((void)a++, a) == ++b).
3 [Note 2: The requirement thata equals b implies ++a equals ++b (which is not true for weakly incrementable types)
allows the use of multi-pass one-directional algorithms with types that modelincrementable. —end note]
24.3.4.6 Concept input_or_output_iterator [iterator.concept.iterator]
1 The input_or_output_iterator concept forms the basis of the iterator concept taxonomy; every iterator
models input_or_output_iterator. This concept specifies operations for dereferencing and incrementing
an iterator. Most algorithms will require additional operations to compare iterators with sentinels (24.3.4.7),
to read (24.3.4.9) or write (24.3.4.10) values, or to provide a richer set of iterator movements (24.3.4.11,
24.3.4.12, 24.3.4.13).
template<class I>
concept input_or_output_iterator =
requires(I i) {
{ *i } -> can-reference ;
} &&
weakly_incrementable<I>;
2 [Note 1: Unlike theCpp17Iterator requirements, theinput_or_output_iterator concept does not require copyability.
—end note]
24.3.4.7 Concept sentinel_for [iterator.concept.sentinel]
1 The sentinel_for concept specifies the relationship between aninput_or_output_iterator type and a
semiregular type whose values denote a range.
template<class S, class I>
concept sentinel_for =
semiregular<S> &&
input_or_output_iterator<I> &&
weakly-equality-comparable-with <S, I>; // see 18.5.4
2 Let s and i be values of type S and I such that [i,s) denotes a range. Types S and I model
sentinel_for<S, I> only if:
—(2.1) i == s is well-defined.
—(2.2) If bool(i != s) then i is dereferenceable and[++i,s) denotes a range.
—(2.3) assignable_from<I&, S> is either modeled or not satisfied.
§ 24.3.4.7 © ISO/IEC
1186

===== PAGE 1198 =====

Dxxxx
3 The domain of== is not static. Given an iteratori and sentinels such that[i,s) denotes a range andi !=
s, i and s are not required to continue to denote a range after incrementing any other iterator equal toi.
Consequently,i == s is no longer required to be well-defined.
24.3.4.8 Concept sized_sentinel_for [iterator.concept.sizedsentinel]
1 The sized_sentinel_for concept specifies requirements on aninput_or_output_iterator type I and a
corresponding sentinel_for<I> that allow the use of the- operator to compute the distance between them
in constant time.
template<class S, class I>
concept sized_sentinel_for =
sentinel_for<S, I> &&
!disable_sized_sentinel_for<remove_cv_t<S>, remove_cv_t<I>> &&
requires(const I& i, const S& s) {
{ s - i } -> same_as<iter_difference_t<I>>;
{ i - s } -> same_as<iter_difference_t<I>>;
};
2 Let i be an iterator of typeI, ands a sentinel of typeS such that[i,s) denotes a range. LetN be
the smallest number of applications of++i necessary to makebool(i == s) be true. S and I model
sized_sentinel_for<S, I> only if:
—(2.1) If N is representable byiter_difference_t<I>, thens - i is well-defined and equalsN.
—(2.2) If −N is representable byiter_difference_t<I>, theni - s is well-defined and equals−N.
template<class S, class I>
constexpr bool disable_sized_sentinel_for = false;
3 Remarks: Pursuant to 16.4.5.2.1, users may specializedisable_sized_sentinel_for for cv-unqualified
non-array object typesS and I if S and/or I is a program-defined type. Such specializations shall be
usable in constant expressions (7.7) and have typeconst bool.
4 [Note 1: disable_sized_sentinel_for allows use of sentinels and iterators with the library that satisfy but
do not in fact modelsized_sentinel_for. —end note]
5 [Example 1: The sized_sentinel_for concept is modeled by pairs ofrandom_access_iterators (24.3.4.13)
and by counted iterators and their sentinels (24.5.7.1).—end example]
24.3.4.9 Concept input_iterator [iterator.concept.input]
1 The input_iterator concept defines requirements for a type whose referenced values can be read (from the
requirement forindirectly_readable (24.3.4.2)) and which can be both pre- and post-incremented.
[Note 1: Unlike theCpp17InputIterator requirements (24.3.5.3), theinput_iterator concept does not need equality
comparison since iterators are typically compared to sentinels.—end note]
template<class I>
concept input_iterator =
input_or_output_iterator<I> &&
indirectly_readable<I> &&
requires { typename ITER_CONCEPT(I); } &&
derived_from<ITER_CONCEPT(I), input_iterator_tag>;
24.3.4.10 Concept output_iterator [iterator.concept.output]
1 The output_iterator concept defines requirements for a type that can be used to write values (from the
requirement forindirectly_writable (24.3.4.3)) and which can be both pre- and post-incremented.
[Note 1: Output iterators are not required to modelequality_comparable. —end note]
template<class I, class T>
concept output_iterator =
input_or_output_iterator<I> &&
indirectly_writable<I, T> &&
requires(I i, T&& t) {
*i++ = std::forward<T>(t); // not required to be equality-preserving
};
2 Let E be an expression such thatdecltype((E)) is T, and leti be a dereferenceable object of typeI. I and
T model output_iterator<I, T> only if*i++ = E; has effects equivalent to:
§ 24.3.4.10 © ISO/IEC
1187

===== PAGE 1199 =====

Dxxxx
*i = E;
++i;
3 Recommended practice: The implementation of an algorithm on output iterators should never attempt to
pass through the same iterator twice; such an algorithm should be a single-pass algorithm.
24.3.4.11 Concept forward_iterator [iterator.concept.forward]
1 The forward_iteratorconcept adds copyability, equality comparison, and the multi-pass guarantee, specified
below.
template<class I>
concept forward_iterator =
input_iterator<I> &&
derived_from<ITER_CONCEPT(I), forward_iterator_tag> &&
incrementable<I> &&
sentinel_for<I, I>;
2 The domain of== for forward iterators is that of iterators over the same underlying sequence. However,
value-initialized iterators of the same type may be compared and shall compare equal to other value-initialized
iterators of the same type.
[Note 1: Value-initialized iterators behave as if they refer past the end of the same empty sequence.—end note]
3 Pointers and references obtained from a forward iterator into a range[i,s) shall remain valid while[i,s)
continues to denote a range.
4 Two dereferenceable iteratorsa and b of typeX offer themulti-pass guaranteeif
—(4.1) a == b implies ++a == ++b and
—(4.2) the expression((void)[](X x){++x;}(a), *a) is equivalent to the expression*a.
5 [Note 2: The requirement thata == b implies ++a == ++b and the removal of the restrictions on the number of
assignments through a mutable iterator (which applies to output iterators) allow the use of multi-pass one-directional
algorithms with forward iterators.—end note]
24.3.4.12 Concept bidirectional_iterator [iterator.concept.bidir]
1 The bidirectional_iterator concept adds the ability to move an iterator backward as well as forward.
template<class I>
concept bidirectional_iterator =
forward_iterator<I> &&
derived_from<ITER_CONCEPT(I), bidirectional_iterator_tag> &&
requires(I i) {
{ --i } -> same_as<I&>;
{ i-- } -> same_as<I>;
};
2 Abidirectionaliterator risdecrementableifandonlyifthereexistssome qsuchthat ++q == r. Decrementable
iterators r shall be in the domain of the expressions--r and r--.
3 Let a and b be equal objects of typeI. I models bidirectional_iterator only if:
—(3.1) If a and b are decrementable, then all of the following aretrue:
—(3.1.1) addressof(--a) == addressof(a)
—(3.1.2) bool(a-- == b)
—(3.1.3) after evaluating botha-- and --b, bool(a == b) is stilltrue
—(3.1.4) bool(++(--a) == b)
—(3.2) If a and b are incrementable, thenbool(--(++a) == b).
24.3.4.13 Concept random_access_iterator [iterator.concept.random.access]
1 The random_access_iterator concept adds support for constant-time advancement with+=, +, -=, and-,
as well as the computation of distance in constant time with-. Random access iterators also support array
notation via subscripting.
§ 24.3.4.13 © ISO/IEC
1188

===== PAGE 1200 =====

Dxxxx
template<class I>
concept random_access_iterator =
bidirectional_iterator<I> &&
derived_from<ITER_CONCEPT(I), random_access_iterator_tag> &&
totally_ordered<I> &&
sized_sentinel_for<I, I> &&
requires(I i, const I j, const iter_difference_t<I> n) {
{ i += n } -> same_as<I&>;
{ j + n } -> same_as<I>;
{ n + j } -> same_as<I>;
{ i -= n } -> same_as<I&>;
{ j - n } -> same_as<I>;
{ j[n] } -> same_as<iter_reference_t<I>>;
};
2 Let a and b be valid iterators of typeI such thatb is reachable froma after n applications of++a, letD be
iter_difference_t<I>, and letn denote a value of typeD. I models random_access_iterator only if:
—(2.1) (a += n) is equal tob.
—(2.2) addressof(a += n) is equal toaddressof(a).
—(2.3) (a + n) is equal to(a += n).
—(2.4) For any two positive valuesx and y of typeD, if (a + D(x + y)) is valid, then(a + D(x + y)) is
equal to((a + x) + y).
—(2.5) (a + D(0)) is equal toa.
—(2.6) If (a + D(n - 1)) is valid, then(a + n) is equal to[](I c){ return ++c; }(a + D(n - 1)).
—(2.7) (b += D(-n)) is equal toa.
—(2.8) (b -= n) is equal toa.
—(2.9) addressof(b -= n) is equal toaddressof(b).
—(2.10) (b - n) is equal to(b -= n).
—(2.11) If b is dereferenceable, thena[n] is valid and is equal to*b.
—(2.12) bool(a <= b) is true.
24.3.4.14 Concept contiguous_iterator [iterator.concept.contiguous]
1 The contiguous_iterator concept provides a guarantee that the denoted elements are stored contiguously
in memory.
template<class I>
concept contiguous_iterator =
random_access_iterator<I> &&
derived_from<ITER_CONCEPT(I), contiguous_iterator_tag> &&
is_lvalue_reference_v<iter_reference_t<I>> &&
same_as<iter_value_t<I>, remove_cvref_t<iter_reference_t<I>>> &&
requires(const I& i) {
{ to_address(i) } -> same_as<add_pointer_t<iter_reference_t<I>>>;
};
2 Let a and b be dereferenceable iterators andc be a non-dereferenceable iterator of typeI such that b
is reachable froma and c is reachable fromb, and letD be iter_difference_t<I>. The type I models
contiguous_iterator only if
—(2.1) to_address(a) == addressof(*a),
—(2.2) to_address(b) == to_address(a) + D(b - a),
—(2.3) to_address(c) == to_address(a) + D(c - a),
—(2.4) to_address(I{}) is well-defined,
—(2.5) ranges::iter_move(a) has the same type, value category, and effects asstd::move(*a), and
—(2.6) if ranges::iter_swap(a, b) is well-formed, it has effects equivalent toranges::swap(*a, *b).
§ 24.3.4.14 © ISO/IEC
1189