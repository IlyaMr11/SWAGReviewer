

===== PAGE 1 =====

Document Number: Dxxxx
Date: 2025-12-15
Revises: N5032
Reply to: Thomas Köppe
Google DeepMind
cxxeditor@gmail.com
Working Draft
Programming Languages — C++
Note: this is an early draft. It’s known to be incomplet and incorrekt, and it has lots of bad
for matting.

===== PAGE 2 =====

Dxxxx
Contents
Foreword x
Introduction xi
1 Scope 1
2 Normative references 2
3 Terms and definitions 3
4 General principles 10
4.1 Implementation compliance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
4.2 Structure of this document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
4.3 Syntax notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
5 Lexical conventions 13
5.1 Separate translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5.2 Phases of translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
5.3 Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
5.4 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
5.5 Preprocessing tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
5.6 Header names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
5.7 Preprocessing numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.8 Operators and punctuators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.9 Alternative tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.10 Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.11 Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.12 Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
5.13 Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
6 Basics 32
6.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
6.2 Declarations and definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
6.3 One-definition rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
6.4 Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
6.5 Name lookup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
6.6 Splice specifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
6.7 Program and linkage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
6.8 Memory and objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
6.9 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
6.10 Program execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.11 Contract assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
7 Expressions 104
7.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
7.2 Properties of expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
7.3 Standard conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
7.4 Usual arithmetic conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
7.5 Primary expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
7.6 Compound expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
7.7 Constant expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
Contents © ISO/IEC
ii

===== PAGE 3 =====

Dxxxx
8 Statements 186
8.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
8.2 Label . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.3 Expression statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.4 Compound statement or block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.5 Selection statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
8.6 Iteration statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.7 Expansion statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
8.8 Jump statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
8.9 Assertion statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
8.10 Declaration statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
8.11 Ambiguity resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
9 Declarations 200
9.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
9.2 Specifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
9.3 Declarators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
9.4 Function contract specifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
9.5 Initializers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
9.6 Function definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
9.7 Structured binding declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
9.8 Enumerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
9.9 Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
9.10 The using declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
9.11 The asm declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
9.12 Linkage specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
9.13 Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
10 Modules 293
10.1 Module units and purviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
10.2 Export declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
10.3 Import declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
10.4 Global module fragment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298
10.5 Private module fragment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
10.6 Instantiation context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
10.7 Reachability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
11 Classes 305
11.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
11.2 Properties of classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
11.3 Class names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
11.4 Class members . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
11.5 Unions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
11.6 Local class declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
11.7 Derived classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
11.8 Member access control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
11.9 Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
11.10 Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364
12 Overloading 368
12.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
12.2 Overload resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
12.3 Address of an overload set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396
12.4 Overloaded operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
12.5 Built-in operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
12.6 User-defined literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
Contents © ISO/IEC
iii

===== PAGE 4 =====

Dxxxx
13 Templates 406
13.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
13.2 Template parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
13.3 Names of template specializations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
13.4 Template arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
13.5 Template constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 422
13.6 Type equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430
13.7 Template declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
13.8 Name resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
13.9 Template instantiation and specialization . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
13.10 Function template specializations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 481
14 Exception handling 503
14.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
14.2 Throwing an exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
14.3 Stack unwinding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 506
14.4 Handling an exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
14.5 Exception specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508
14.6 Special functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
15 Preprocessing directives 512
15.1 Preamble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 512
15.2 Conditional inclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
15.3 Source file inclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517
15.4 Resource inclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 518
15.5 Module directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522
15.6 Header unit importation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523
15.7 Macro replacement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524
15.8 Line control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
15.9 Diagnostic directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
15.10 Pragma directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
15.11 Null directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
15.12 Predefined macro names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
15.13 Pragma operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534
16 Library introduction 535
16.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535
16.2 The C standard library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
16.3 Method of description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
16.4 Library-wide requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544
17 Language support library 567
17.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 567
17.2 Common definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 567
17.3 Implementation properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
17.4 Arithmetic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
17.5 Startup and termination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
17.6 Dynamic memory management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588
17.7 Type identification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
17.8 Source location . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 597
17.9 Exception handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 600
17.10 Contract-violation handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
17.11 Initializer lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606
17.12 Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
17.13 Coroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 615
17.14 Other runtime support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 620
17.15 C headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 622
Contents © ISO/IEC
iv

===== PAGE 5 =====

Dxxxx
18 Concepts library 625
18.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625
18.2 Equality preservation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625
18.3 Header <concepts> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 626
18.4 Language-related concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628
18.5 Comparison concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633
18.6 Object concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636
18.7 Callable concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636
19 Diagnostics library 638
19.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 638
19.2 Exception classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 638
19.3 Assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641
19.4 Error numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 642
19.5 System error support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 643
19.6 Stacktrace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 651
19.7 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657
20 Memory management library 659
20.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659
20.2 Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659
20.3 Smart pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 680
20.4 Types for composite class design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 708
20.5 Memory resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 719
20.6 Class template scoped_allocator_adaptor . . . . . . . . . . . . . . . . . . . . . . . . . . 728
21 Metaprogramming library 733
21.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 733
21.2 Compile-time integer sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 733
21.3 Metaprogramming and type traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 734
21.4 Reflection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 766
21.5 Compile-time rational arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802
22 General utilities library 805
22.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
22.2 Utility components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
22.3 Pairs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 812
22.4 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 818
22.5 Optional objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 832
22.6 Variants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 852
22.7 Storage for any type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 863
22.8 Expected objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 869
22.9 Bitsets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 889
22.10 Function objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 896
22.11 Bit manipulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 931
22.12 Header <stdbit.h> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 935
23 Containers library 938
23.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 938
23.2 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 938
23.3 Sequence containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 973
23.4 Associative containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1020
23.5 Unordered associative containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1041
23.6 Container adaptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1066
23.7 Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1115
24 Iterators library 1168
24.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1168
24.2 Header <iterator> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1168
Contents © ISO/IEC
v

===== PAGE 6 =====

Dxxxx
24.3 Iterator requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1176
24.4 Iterator primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1197
24.5 Iterator adaptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1201
24.6 Stream iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1227
24.7 Range access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1233
25 Ranges library 1236
25.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1236
25.2 Header <ranges> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1236
25.3 Range access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1245
25.4 Range requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250
25.5 Range utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253
25.6 Range factories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1262
25.7 Range adaptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1275
25.8 Range generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1399
26 Algorithms library 1406
26.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1406
26.2 Algorithms requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1406
26.3 Parallel algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1408
26.4 Header <algorithm> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1412
26.5 Algorithm result types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1466
26.6 Non-modifying sequence operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1469
26.7 Mutating sequence operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1489
26.8 Sorting and related operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1512
26.9 Header <numeric> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1545
26.10 Generalized numeric operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1549
26.11 Specialized <memory> algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1559
26.12 Specialized <random> algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1566
26.13 C library algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1567
27 Strings library 1569
27.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1569
27.2 Character traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1569
27.3 String view classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1574
27.4 String classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1584
27.5 Null-terminated sequence utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1612
28 Text processing library 1614
28.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1614
28.2 Primitive numeric conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1614
28.3 Localization library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1616
28.4 Text encodings identification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1657
28.5 Formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1664
28.6 Regular expressions library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1692
28.7 Null-terminated sequence utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1726
29 Numerics library 1730
29.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1730
29.2 Numeric type requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1730
29.3 The floating-point environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1730
29.4 Complex numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1731
29.5 Random number generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1738
29.6 Numeric arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1784
29.7 Mathematical functions for floating-point types . . . . . . . . . . . . . . . . . . . . . . . . 1803
29.8 Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1816
29.9 Basic linear algebra algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1816
29.10 Data-parallel types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1869
29.11 C compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1911
Contents © ISO/IEC
vi

===== PAGE 7 =====

Dxxxx
30 Time library 1912
30.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1912
30.2 Header <chrono> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1912
30.3 Cpp17Clock requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1926
30.4 Time-related traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1927
30.5 Class template duration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1928
30.6 Class template time_point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1935
30.7 Clocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1938
30.8 The civil calendar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1949
30.9 Class template hh_mm_ss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1978
30.10 12/24 hours functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1980
30.11 Time zones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1981
30.12 Formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1994
30.13 Parsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1998
30.14 Hash support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2002
30.15 Header <ctime> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2002
31 Input/output library 2004
31.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2004
31.2 Iostreams requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2004
31.3 Forward declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2005
31.4 Standard iostream objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2007
31.5 Iostreams base classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2009
31.6 Stream buffers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2024
31.7 Formatting and manipulators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2032
31.8 String-based streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2060
31.9 Span-based streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2076
31.10 File-based streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2083
31.11 Synchronized output streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2096
31.12 File systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2101
31.13 C library files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2147
32 Concurrency support library 2151
32.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2151
32.2 Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2151
32.3 Stop tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2154
32.4 Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2163
32.5 Atomic operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2170
32.6 Mutual exclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2212
32.7 Condition variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2230
32.8 Semaphore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2238
32.9 Coordination types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2239
32.10 Futures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2243
32.11 Safe reclamation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2256
33 Execution control library 2263
33.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2263
33.2 Queries and queryables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2264
33.3 Asynchronous operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2264
33.4 Header <execution> synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2266
33.5 Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2273
33.6 Schedulers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2275
33.7 Receivers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2275
33.8 Operation states . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2276
33.9 Senders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2277
33.10 Completion signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2322
33.11 Queryable utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2324
33.12 Execution contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2325
33.13 Coroutine utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2328
Contents © ISO/IEC
vii

===== PAGE 8 =====

Dxxxx
33.14 Execution scope utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2338
33.15 Parallel scheduler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2344
33.16 Namespace system_context_replaceability . . . . . . . . . . . . . . . . . . . . . . . . 2345
Annex A Grammar summary 2348
A.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2348
A.2 Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2348
A.3 Lexical conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2348
A.4 Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2353
A.5 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2353
A.6 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2358
A.7 Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2359
A.8 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2366
A.9 Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2366
A.10 Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2368
A.11 Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2368
A.12 Exception handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2370
A.13 Preprocessing directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2370
Annex B Implementation quantities 2373
Annex C Compatibility 2375
C.1 C ++ and ISO C++ 2023 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2375
C.2 C ++ and ISO C++ 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2380
C.3 C ++ and ISO C++ 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2384
C.4 C ++ and ISO C++ 2014 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2392
C.5 C ++ and ISO C++ 2011 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2396
C.6 C ++ and ISO C++ 2003 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2398
C.7 C ++ and C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2404
C.8 C standard library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2414
Annex D Compatibility features 2416
D.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2416
D.2 Non-local use of TU-local entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2416
D.3 Implicit capture of *this by reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2416
D.4 Deprecated volatile types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2416
D.5 Non-comma-separated ellipsis parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . 2417
D.6 Implicit declaration of copy functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2417
D.7 Redeclaration of static constexpr data members . . . . . . . . . . . . . . . . . . . . . . 2417
D.8 Literal operator function declarations using an identifier . . . . . . . . . . . . . . . . . . . 2417
D.9 template keyword before qualified names . . . . . . . . . . . . . . . . . . . . . . . . . . . 2418
D.10 has_denorm members innumeric_limits . . . . . . . . . . . . . . . . . . . . . . . . . . . 2418
D.11 Deprecated C macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2418
D.12 Deprecated error numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2418
D.13 Deprecated type traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2419
D.14 Relational operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2420
D.15 Tuple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2420
D.16 Variant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2421
D.17 Deprecated vector<bool, Allocator> swap . . . . . . . . . . . . . . . . . . . . . . . . . 2421
D.18 Deprecated iterator class template . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2421
D.19 Deprecated move_iterator access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2422
D.20 Deprecated locale category facets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2422
D.21 Deprecated formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2422
D.22 Deprecated time formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2423
D.23 Deprecated file systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2423
D.24 Deprecated atomic operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2424
Contents © ISO/IEC
viii

===== PAGE 9 =====

Dxxxx
Annex E Conformance with UAX#31 2426
E.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2426
E.2 R1 Default identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2426
E.3 R2 Immutable identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2426
E.4 R3 Pattern_White_Space and Pattern_Syntax characters . . . . . . . . . . . . . . . . . . 2426
E.5 R4 Equivalent normalized identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2427
E.6 R5 Equivalent case-insensitive identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2427
E.7 R6 Filtered normalized identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2427
E.8 R7 Filtered case-insensitive identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2427
E.9 R8 Hashtag identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2427
Bibliography 2428
Cross-references 2429
Cross-references from ISO C++ 2017 2460
Index 2464
Index of grammar productions 2502
Index of library headers 2509
Index of library names 2511
Index of library concepts 2622
Index of implementation-defined behavior 2628
Contents © ISO/IEC
ix

===== PAGE 10 =====

Dxxxx
Foreword
[This page is intentionally left blank.]
Foreword © ISO/IEC
x

===== PAGE 11 =====

Dxxxx
Introduction
Clauses and subclauses in this document are annotated with a so-called stable name, presented in square
brackets next to the (sub)clause heading (such as “[lex.token]” for 5.10, “Tokens”). Stable names aid in the
discussion and evolution of this document by serving as stable references to subclauses across editions that
are unaffected by changes of subclause numbering.
Aspects of the language syntax of C++ are distinguished typographically by the use ofitalic, sans-serif type
or constant width type to avoid ambiguities; see 4.3.
Introduction © ISO/IEC
xi

===== PAGE 12 =====

WORKING DRAFT Dxxxx
Programming languages — C++
1 Scope [intro.scope]
1 This document specifies requirements for implementations of C++, which is a general-purpose programming
language. The first such requirement is that an implementation implements the language, so this document
also defines C++. Other requirements and relaxations of the first requirement appear at various places within
this document.
Scope © ISO/IEC
1

===== PAGE 13 =====

Dxxxx
2 Normative references [intro.refs]
1 The following documents are referred to in the text in such a way that some or all of their content constitutes
requirements of this document. For dated references, only the edition cited applies. For undated references,
the latest edition of the referenced document (including any amendments) applies.
—(1.1) ISO/IEC 2382,Information technology — Vocabulary
—(1.2) ISO 8601-1:2019,Date and time — Representations for information interchange — Part 1: Basic rules
—(1.3) ISO/IEC 9899:2024,Information technology — Programming languages — C
—(1.4) ISO/IEC/IEEE 9945:2009,Information Technology — Portable Operating System Interface (POSIX®)1
Base Specifications, Issue 7
—(1.5) ISO/IEC/IEEE 9945:2009/Cor 1:2013,Information Technology — Portable Operating System Interface
(POSIX®) Base Specifications, Issue 7 — Technical Corrigendum 1
—(1.6) ISO/IEC/IEEE 9945:2009/Cor 2:2017,Information Technology — Portable Operating System Interface
(POSIX®) Base Specifications, Issue 7 — Technical Corrigendum 2
—(1.7) ISO/IEC 60559:2020,Information technology — Microprocessor Systems — Floating-Point arithmetic
—(1.8) ISO 80000-2:2019,Quantities and units — Part 2: Mathematics
—(1.9) Ecma International,ECMAScript2 Language Specification, Standard Ecma-262, third edition, 1999.
—(1.10) The Unicode Consortium.The Unicode Standard, Version 15.1. Available from: https://www.unicode.
org/versions/Unicode15.1.0/
1) POSIX® is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc. This information is given for
the convenience of users of this document and does not constitute an endorsement by ISO or IEC of this product.
2) ECMAScript® is a registered trademark of Ecma International. This information is given for the convenience of users of
this document and does not constitute an endorsement by ISO or IEC of this product.
Normative references © ISO/IEC
2

===== PAGE 14 =====

Dxxxx
3 Terms and definitions [intro.defs]
1 For the purposes of this document, the terms and definitions given in ISO/IEC 2382, ISO 80000-2:2019, and
the following apply.
2 ISO and IEC maintain terminology databases for use in standardization at the following addresses:
—(2.1) ISO Online browsing platform: available at https://www.iso.org/obp
—(2.2) IEC Electropedia: available at https://www.electropedia.org/
3.1 [defns.access]
access
〈execution-time action〉 read or modify the value of an object
[Note 1 to entry: Only glvalues of scalar type (6.9.1) can be used to access objects. Reads of scalar objects are
described in 7.3.2 and modifications of scalar objects are described in 7.6.19, 7.6.1.6, and 7.6.2.3. Attempts to read or
modify an object of class type typically invoke a constructor (11.4.5) or assignment operator (11.4.6); such invocations
do not themselves constitute accesses, although they may involve accesses of scalar subobjects.—end note]
3.2 [defns.argument]
argument
〈function call expression〉 expression orbraced-init-list in the comma-separated list bounded by the parentheses
3.3 [defns.argument.macro]
argument
〈function-like macro〉 sequence of preprocessing tokens in the comma-separated list bounded by the parentheses
3.4 [defns.argument.throw]
argument
〈throw expression〉 operand of throw
3.5 [defns.argument.templ]
argument
〈template instantiation〉 constant-expression, type-id, orid-expression in the comma-separated list bounded by
the angle brackets
3.6 [defns.block]
block
〈execution〉 wait for some condition (other than for the implementation to execute the execution steps of the
thread of execution) to be satisfied before continuing execution past the blocking operation
3.7 [defns.block.stmt]
block
〈statement〉 compound statement
3.8 [defns.c.lib]
C standard library
library described in ISO/IEC 9899:2024, Clause 7
[Note 1 to entry: With the qualifications noted in Clause 17 through Clause 33 and in C.8, the C standard library is a
subset of the C++ standard library. —end note]
3.9 [defns.character]
character
〈library〉 object which, when treated sequentially, can represent text
[Note 1 to entry: The term does not mean onlychar, char8_t, char16_t, char32_t, andwchar_t objects (6.9.2), but
any value that can be represented by a type that provides the definitions specified in Clause 27, 28.3, Clause 31,
or 28.6. —end note]
§ 3.9 © ISO/IEC
3

===== PAGE 15 =====

Dxxxx
3.10 [defns.character.container]
character container type
〈library〉 class or a type used to represent acharacter (3.9)
[Note 1 to entry: It is used for one of the template parameters ofchar_traits and the class templates which use
that, such as the string, iostream, and regular expression class templates.—end note]
3.11 [defns.regex.collating.element]
collating element
sequence of one or morecharacters (3.9) within the current locale that collate as if they were a single character
3.12 [defns.component]
component
〈library〉 group of library entities directly related as members,parameters (3.38), or return types
[Note 1 to entry: For example, the class templatebasic_string and the non-member function templates that operate
on strings are referred to as the string component.—end note]
3.13 [defns.cond.supp]
conditionally-supported
program construct that an implementation is not required to support
[Note 1 to entry: Each implementation documents all conditionally-supported constructs that it does not support.
—end note]
3.14 [defns.const.eval]
constant evaluation
evaluation that is performed as part of evaluating an expression as a core constant expression (7.7)
3.15 [defns.const.subexpr]
constant subexpression
expression whose evaluation as subexpression of aconditional-expression CE would not preventCE from being
a core constant expression
3.16 [defns.deadlock]
deadlock
〈library〉 situation wherein one or more threads are unable to continue execution because each isblocked (3.6)
waiting for one or more of the others to satisfy some condition
3.17 [defns.default.behavior.impl]
default behavior
〈library implementation〉 specific behavior provided by the implementation, within the scope of therequired
behavior (3.48)
3.18 [defns.diagnostic]
diagnostic message
message belonging to an implementation-defined subset of the implementation’s output messages
3.19 [defns.dynamic.type]
dynamic type
〈glvalue〉 type of the most derived object to which the glvalue refers
[Example 1: If a pointer (9.3.4.2)p whose type is “pointer to classB” is pointing to a base class subobject of class
B, whose most derived object is of classD, derived fromB (11.7), the dynamic type of the expression*p is “D”.
References (9.3.4.3) are treated similarly.—end example]
3.20 [defns.dynamic.type.prvalue]
dynamic type
〈prvalue〉 static type(3.61) of the prvalue expression
§ 3.20 © ISO/IEC
4

===== PAGE 16 =====

Dxxxx
3.21 [defns.erroneous]
erroneous behavior
well-defined behavior that the implementation is recommended to diagnose
[Note 1 to entry: Erroneous behavior is always the consequence of incorrect program code. Implementations are
allowed, but not required, to diagnose it (4.1.1). Evaluation of a constant expression (7.7) never exhibits behavior
specified as erroneous in Clause 4 through Clause 15.—end note]
3.22 [defns.expression.equivalent]
expression-equivalent
〈library〉 expressions that all have the same effects, either are all potentially-throwing or are all not potentially-
throwing, and either are allconstant subexpressions (3.15) or are all not constant subexpressions
[Example 1: For a valuex of typeint and a functionf that accepts integer arguments, the expressionsf(x + 2),
f(2 + x), andf(1 + x + 1) are expression-equivalent. —end example]
3.23 [defns.regex.finite.state.machine]
finite state machine
〈regular expression〉 unspecified data structure that is used to represent aregular expression(3.46), and which
permits efficient matches against the regular expression to be obtained
3.24 [defns.regex.format.specifier]
format specifier
〈regular expression〉 sequence of one or morecharacters (3.9) that is expected to be replaced with some part
of aregular expression(3.46) match
3.25 [defns.handler]
handler function
〈library〉 non-reserved function whose definition may be provided by a C++ program
[Note 1 to entry: A C++ program may designate a handler function at various points in its execution by supplying a
pointer to the function when calling any of the library functions that install handler functions (see Clause 17).—end
note]
3.26 [defns.ill.formed]
ill-formed program
program that is not well-formed (3.68)
3.27 [defns.impl.defined]
implementation-defined behavior
behavior, for awell-formed program(3.68) construct and correct data, that depends on the implementation
and that each implementation documents
3.28 [defns.order.ptr]
implementation-defined strict total order over pointers
〈library〉 implementation-defined strict total ordering over all pointer values such that the ordering is consistent
with the partial order imposed by the built-in operators<, >, <=, >=, and<=>
3.29 [defns.impl.limits]
implementation limit
restriction imposed upon programs by the implementation
3.30 [defns.locale.specific]
locale-specific behavior
behavior that depends on local conventions of nationality, culture, and language that each implementation
documents
3.31 [defns.regex.matched]
matched
〈regular expression〉 condition when a sequence of zero or morecharacters (3.9) correspond to a sequence of
characters defined by the pattern
§ 3.31 © ISO/IEC
5

===== PAGE 17 =====

Dxxxx
3.32 [defns.modifier]
modifier function
〈library〉 class member function other than a constructor, assignment operator, or destructor that alters the
state of an object of the class
3.33 [defns.move.assign]
move assignment
〈library〉 assignment of an rvalue of some object type to a modifiable lvalue of the same type
3.34 [defns.move.constr]
move construction
〈library〉 direct-initialization of an object of some type with an rvalue of the same type
3.35 [defns.nonconst.libcall]
non-constant library call
invocation of a library function that, as part of evaluating any expressionE, preventsE from being a core
constant expression
3.36 [defns.ntcts]
NTCTS
〈library〉 sequence of values that havecharacter (3.9) type that precede the terminating null character type
value charT()
3.37 [defns.observer]
observer function
〈library〉 class member function that accesses the state of an object of the class but does not alter that state
[Note 1 to entry: Observer functions are specified asconst member functions. —end note]
3.38 [defns.parameter]
parameter
〈function or catch clause〉 object or reference declared as part of a function declaration or definition or in the
catch clause of an exception handler that acquires a value on entry to the function or handler
3.39 [defns.parameter.macro]
parameter
〈function-like macro〉 identifier from the comma-separated list bounded by the parentheses immediately
following the macro name
3.40 [defns.parameter.templ]
parameter
〈template〉 member of atemplate-parameter-list
3.41 [defns.regex.primary.equivalence.class]
primary equivalence class
〈regular expression〉 set of one or morecharacters (3.9) which share the same primary sort key: that is the
sort key weighting that depends only upon character shape, and not accents, case, or locale-specific tailorings
3.42 [defns.prog.def.spec]
program-defined specialization
〈library〉 explicit template specialization or partial specialization that is not part of the C++ standard library
and not defined by the implementation
3.43 [defns.prog.def.type]
program-defined type
〈library〉 non-closure class type or enumeration type that is not part of the C++ standard library and not
defined by the implementation, or a closure type of a non-implementation-provided lambda expression, or an
instantiation of aprogram-defined specialization(3.42)
[Note 1 to entry: Types defined by the implementation include extensions (4.1) and internal types used by the library.
—end note]
§ 3.43 © ISO/IEC
6

===== PAGE 18 =====

Dxxxx
3.44 [defns.projection]
projection
〈library〉 transformation that an algorithm applies before inspecting the values of elements
[Example 1:
std::pair<int, std::string_view> pairs[] = {{2, "foo"}, {1, "bar"}, {0, "baz"}};
std::ranges::sort(pairs, std::ranges::less{}, [](auto const& p) { return p.first; });
sorts the pairs in increasing order of theirfirst members:
{{0, "baz"}, {1, "bar"}, {2, "foo"}}
—end example]
3.45 [defns.referenceable]
referenceable type
type that is either an object type, a function type that does not have cv-qualifiers or aref-qualifier, or a
reference type
[Note 1 to entry: The term describes a type to which a reference can be created, including reference types.—end
note]
3.46 [defns.regex.regular.expression]
regular expression
pattern that selects specific strings from a set ofcharacter (3.9) strings
3.47 [defns.replacement]
replacement function
〈library〉 non-reserved function whose definition is provided by a C++ program
[Note 1 to entry: Only one definition for such a function is in effect for the duration of the program’s execution, as
the result of creating the program (5.2) and resolving the definitions of all translation units (6.7).—end note]
3.48 [defns.required.behavior]
required behavior
〈library〉 description ofreplacement function(3.47) andhandler function (3.25) semantics applicable to both
the behavior provided by the implementation and the behavior of any such function definition in the program
[Note 1 to entry: If such a function defined in a C++ program fails to meet the required behavior when it executes,
the behavior is undefined.—end note]
3.49 [defns.reserved.function]
reserved function
〈library〉 function, specified as part of the C++ standard library, that is defined by the implementation
[Note 1 to entry: If a C++ program provides a definition for any reserved function, the results are undefined.—end
note]
3.50 [defns.undefined.runtime]
runtime-undefined behavior
behavior that is undefined except when it occurs during constant evaluation
[Note 1 to entry: During constant evaluation,
— it is implementation-defined whether runtime-undefined behavior results in the expression being deemed
non-constant (as specified in 7.7) and
— runtime-undefined behavior has no other effect.
—end note]
3.51 [defns.signature]
signature
〈function〉 name, parameter-type-list, and enclosing namespace
[Note 1 to entry: Signatures are used as a basis for name mangling and linking.—end note]
§ 3.51 © ISO/IEC
7

===== PAGE 19 =====

Dxxxx
3.52 [defns.signature.friend]
signature
〈non-template friend function with trailingrequires-clause〉 name, parameter-type-list, enclosing class, and
trailing requires-clause
3.53 [defns.signature.templ]
signature
〈function template〉 name, parameter-type-list, enclosing namespace, return type,signature (3.59) of the
template-head, and trailingrequires-clause (if any)
3.54 [defns.signature.templ.friend]
signature
〈friend function template with constraint involving enclosing template parameters〉 name, parameter-type-list,
return type, enclosing class,signature (3.59) of thetemplate-head, and trailingrequires-clause (if any)
3.55 [defns.signature.spec]
signature
〈function template specialization〉 signature (3.53) of the template of which it is a specialization and its
template arguments (3.5) (whether explicitly specified or deduced)
3.56 [defns.signature.member]
signature
〈class member function〉 name, parameter-type-list, class of which the function is a member,cv-qualifiers (if
any), ref-qualifier (if any), and trailingrequires-clause (if any)
3.57 [defns.signature.member.templ]
signature
〈class member function template〉 name, parameter-type-list, class of which the function is a member,cv-
qualifiers (if any),ref-qualifier (if any), return type (if any),signature (3.59) of thetemplate-head, and trailing
requires-clause (if any)
3.58 [defns.signature.member.spec]
signature
〈class member function template specialization〉 signature (3.57) of the member function template of which it
is a specialization and its template arguments (whether explicitly specified or deduced)
3.59 [defns.signature.template.head]
signature
〈template-head〉 template parameter (3.40) list, excluding template parameter names and defaultarguments
(3.5), andrequires-clause (if any)
3.60 [defns.stable]
stable algorithm
〈library〉 algorithm that preserves, as appropriate to the particular algorithm, the order of elements
[Note 1 to entry: Requirements for stable algorithms are given in 16.4.6.8.—end note]
3.61 [defns.static.type]
static type
type of an expression resulting from analysis of the program without considering execution semantics
[Note 1 to entry: The static type of an expression depends only on the form of the program in which the expression
appears, and does not change while the program is executing.—end note]
3.62 [defns.regex.subexpression]
sub-expression
〈regular expression〉 subset of aregular expression(3.46) that has been marked by parentheses
3.63 [defns.traits]
traits class
〈library〉 class that encapsulates a set of types and functions necessary for class templates and function
templates to manipulate objects of types for which they are instantiated
§ 3.63 © ISO/IEC
8

===== PAGE 20 =====

Dxxxx
3.64 [defns.unblock]
unblock
satisfy a condition that one or moreblocked (3.6) threads of execution are waiting for
3.65 [defns.undefined]
undefined behavior
behavior for which this document imposes no requirements
[Note 1 to entry: Undefined behavior may be expected when this document omits any explicit definition of behavior or
when a program uses an incorrect construct or invalid data. Permissible undefined behavior ranges from ignoring the
situation completely with unpredictable results, to behaving during translation or program execution in a documented
manner characteristic of the environment (with or without the issuance of adiagnostic message(3.18)), to terminating
a translation or execution (with the issuance of a diagnostic message). Many incorrect program constructs do not
engender undefined behavior; they are required to be diagnosed. Evaluation of a constant expression (7.7) never
exhibits behavior explicitly specified as undefined in Clause 4 through Clause 15.—end note]
3.66 [defns.unspecified]
unspecified behavior
behavior, for awell-formed program(3.68) construct and correct data, that depends on the implementation
[Note 1 to entry: The implementation is not required to document which behavior occurs. The range of possible
behaviors is usually delineated by this document.—end note]
3.67 [defns.valid]
valid but unspecified state
〈library〉 value of an object that is not specified except that the object’s invariants are met and operations on
the object behave as specified for its type
[Example 1: If an objectx of typestd::vector<int> is in a valid but unspecified state,x.empty() can be called
unconditionally, andx.front() can be called only ifx.empty() returns false. —end example]
3.68 [defns.well.formed]
well-formed program
C++ program constructed according to the syntax and semantic rules
§ 3.68 © ISO/IEC
9

===== PAGE 21 =====

Dxxxx
4 General principles [intro]
4.1 Implementation compliance [intro.compliance]
4.1.1 General [intro.compliance.general]
1 The set ofdiagnosable rulesconsists of all syntactic and semantic rules in this document except for those
rules containing an explicit notation that “no diagnostic is required” or which are described as resulting in
“undefined behavior”.
2 Although this document states only requirements on C++ implementations, those requirements are often
easier to understand if they are phrased as requirements on programs, parts of programs, or execution of
programs. Such requirements have the following meaning:
—(2.1) If a program contains no violations of the rules in Clause 5 through Clause 33 as well as those specified
in Annex D, a conforming implementation shall accept and correctly execute3 that program, except
when the implementation’s limitations (see below) are exceeded.
—(2.2) If a program contains a violation of a rule for which no diagnostic is required, this document places no
requirement on implementations with respect to that program.
—(2.3) Otherwise, if a program contains
—(2.3.1) a violation of any diagnosable rule,
—(2.3.2) a preprocessing translation unit with a#warning preprocessing directive (15.9),
—(2.3.3) an occurrence of a construct described in this document as “conditionally-supported” when the
implementation does not support that construct, or
—(2.3.4) a contract assertion (6.11.2) evaluated with a checking semantic in a manifestly constant-evaluated
context (7.7) resulting in a contract violation,
a conforming implementation shall issue at least one diagnostic message.
[Note 1: During template argument deduction and substitution, certain constructs that in other contexts require a
diagnostic are treated differently; see 13.10.3.—end note]
Furthermore, a conforming implementation shall not accept
—(2.4) a preprocessing translation unit containing a#error preprocessing directive (15.9),
—(2.5) a translation unit with astatic_assert-declaration that fails (9.1), or
—(2.6) a contract assertion evaluated with a terminating semantic (6.11.2) in a manifestly constant-evaluated
context (7.7) resulting in a contract violation.
3 For classes and class templates, the library Clauses specify partial definitions. Private members (11.8) are not
specified, but each implementation shall supply them to complete the definitions according to the description
in the library Clauses.
4 For functions, function templates, objects, and values, the library Clauses specify declarations. Implementa-
tions shall supply definitions consistent with the descriptions in the library Clauses.
5 A C++ translation unit (5.2) obtains access to the names defined in the library by including the appropriate
standard library header or importing the appropriate standard library named header unit (16.4.3.2).
6 The templates, classes, functions, and objects in the library have external linkage (6.7). The implementation
provides definitions for standard library entities, as necessary, while combining translation units to form a
complete C++ program (5.2).
7 An implementation is either ahosted implementation or a freestanding implementation. A freestanding
implementation is one in which execution may take place without the benefit of an operating system. A hosted
implementation supports all the facilities described in this document, while a freestanding implementation
supports the entire C++ language described in Clause 5 through Clause 15 and the subset of the library
facilities described in 16.4.2.5.
3) “Correct execution” can include undefined behavior and erroneous behavior, depending on the data being processed; see
Clause 3 and 6.10.1.
§ 4.1.1 © ISO/IEC
10

===== PAGE 22 =====

Dxxxx
8 It is implementation-defined whether the implementation is ahardened implementation. If it is a hardened
implementation, violating a hardened precondition results in a contract violation (16.3.2.4).
9 An implementation is encouraged to document its limitations in the size or complexity of the programs it
can successfully process, if possible and where known. Annex B lists some quantities that can be subject to
limitations and a potential minimum supported value for each quantity.
10 A conforming implementation may use an implementation-defined version of the Unicode Standard that is a
later version than the one referenced in Clause 2.
11 A conforming implementation may have extensions (including additional library functions), provided they
do not alter the behavior of any well-formed program. Implementations are required to diagnose programs
that use such extensions that are ill-formed according to this document. Having done so, however, they can
compile and execute such programs.
12 Each implementation shall include documentation that identifies all conditionally-supported constructs that
it does not support and defines all locale-specific characteristics.4
4.1.2 Abstract machine [intro.abstract]
1 The semantic descriptions in this document define a parameterized nondeterministic abstract machine. This
document places no requirement on the structure of conforming implementations. In particular, they need
not copy or emulate the structure of the abstract machine. Rather, conforming implementations are required
to emulate (only) the observable behavior of the abstract machine as explained below.5
2 Certain aspects and operations of the abstract machine are described in this document as implementation-
defined behavior (for example,sizeof(int)). These constitute the parameters of the abstract machine. Each
implementation shall include documentation describing its characteristics and behavior in these respects.6
Such documentation shall define the instance of the abstract machine that corresponds to that implementation
(referred to as the “corresponding instance” below).
3 Certain other aspects and operations of the abstract machine are described in this document as unspecified
behavior (for example, order of evaluation of arguments in a function call (7.6.1.3)). Where possible, this
document defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract
machine. An instance of the abstract machine can thus have more than one possible execution for a given
program and a given input.
4 Certain other operations are described in this document as undefined behavior (for example, the effect of
attempting to modify a const object).
5 Certain events in the execution of a program are termedobservable checkpoints.
[Note 1: A call tostd::observable_checkpoint (22.2.9) is an observable checkpoint, as are certain parts of the
evaluation of contract assertions (6.11).—end note]
6 The defined prefixof an execution comprises the operationsO for which for every undefined operationU
there is an observable checkpointC such thatO happens beforeC and C happens beforeU.
[Note 2: The undefined behavior that arises from a data race (6.10.2.2) occurs on all participating threads.—end
note]
A conforming implementation executing a well-formed program shall produce the observable behavior of
the defined prefix of one of the possible executions of the corresponding instance of the abstract machine
with the same program and the same input. If the selected execution contains an undefined operation, the
implementation executing that program with that input may produce arbitrary additional observable behavior
afterwards. If the execution of an operation is specified as having erroneous behavior, the implementation is
permitted to issue a diagnostic and is permitted to terminate the execution of the program.
7 Recommended practice: An implementation should issue a diagnostic when such an operation is executed.
[Note 3: An implementation can issue a diagnostic if it can determine that erroneous behavior is reachable under an
implementation-specific set of assumptions about the program behavior, which can result in false positives.—end
note]
4) This documentation also defines implementation-defined behavior; see 4.1.2.
5) This provision is sometimes called the “as-if” rule, because an implementation is free to disregard any requirement of this
document as long as the result isas if the requirement had been obeyed, as far as can be determined from the observable
behavior of the program. For instance, an actual implementation need not evaluate part of an expression if it can deduce that
its value is not used and that no side effects affecting the observable behavior of the program are produced.
6) This documentation also includes conditionally-supported constructs and locale-specific behavior. See 4.1.1.
§ 4.1.2 © ISO/IEC
11

===== PAGE 23 =====

Dxxxx
8 The following specify theobservable behaviorof the program:
—(8.1) Accesses through volatile glvalues are evaluated strictly according to the rules of the abstract machine.
—(8.2) Data is delivered to the host environment to be written into files (See also: ISO/IEC 9899:2024,
7.23.3).
[Note 4: Delivering such data is followed by an observable checkpoint (31.13.1). Not all host environments
provide access to file contents before program termination.—end note]
—(8.3) The input and output dynamics of interactive devices shall take place in such a fashion that prompting
output is actually delivered before a program waits for input. What constitutes an interactive device is
implementation-defined.
[Note 5: More stringent correspondences between abstract and actual semantics can be defined by each implementation.
—end note]
4.2 Structure of this document [intro.structure]
1 Clause 5 through Clause 15 describe the C++ programming language. That description includes detailed
syntactic specifications in a form described in 4.3. For convenience, Annex A repeats all such syntactic
specifications.
2 Clause 17 through Clause 33 and Annex D (thelibrary clauses) describe the C++ standard library. That
description includes detailed descriptions of the entities and macros that constitute the library, in a form
described in Clause 16.
3 Annex B recommends lower bounds on the capacity of conforming implementations.
4 Annex C summarizes the evolution of C++ since its first published description, and explains in detail the
differences between C++ and C. Certain features of C++ exist solely for compatibility purposes; Annex D
describes those features.
4.3 Syntax notation [syntax]
1 In the syntax notation used in this document, syntactic categories are indicated byitalic, sans-serif type, and
literal words and characters inconstant widthtype. Alternatives are listed on separate lines except in a
few cases where a long set of alternatives is marked by the phrase “one of”. If the text of an alternative is
too long to fit on a line, the text is continued on subsequent lines indented from the first one. An optional
terminal or non-terminal symbol is indicated by the subscript “opt”, so
{ expressionopt }
indicates an optional expression enclosed in braces.
2 Names for syntactic categories have generally been chosen according to the following rules:
—(2.1) X-name is a use of an identifier in a context that determines its meaning (e.g.,class-name, typedef-name).
—(2.2) X-id is an identifier with no context-dependent meaning (e.g.,qualified-id).
—(2.3) X-seq is one or moreX’s without intervening delimiters (e.g.,declaration-seq is a sequence ofdeclarations).
—(2.4) X-list is one or moreX’s separated by intervening commas (e.g.,identifier-list is a sequence ofidentifiers
separated by commas).
§ 4.3 © ISO/IEC
12

===== PAGE 24 =====

Dxxxx
5 Lexical conventions [lex]
5.1 Separate translation [lex.separate]
1 The text of the program is kept in units calledsource filesin this document. A source file together with
all the headers (16.4.2.3) and source files included (15.3) via the preprocessing directive#include, less any
source lines skipped by any of the conditional inclusion (15.2) preprocessing directives, as modified by the
implementation-defined behavior of any conditionally-supported-directives (15.1) and pragmas (15.10), if any,
is called apreprocessing translation unit.
[Note 1: A C++ program need not all be translated at the same time. Translation units can be separately translated
and then later linked to produce an executable program (6.7).—end note]
5.2 Phases of translation [lex.phases]
1 The precedence among the syntax rules of translation is specified by the following phases.7
1. An implementation shall support input files that are a sequence of UTF-8 code units (UTF-8 files). It
may also support an implementation-defined set of other kinds of input files, and, if so, the kind of an
input file is determined in an implementation-defined manner that includes a means of designating
input files as UTF-8 files, independent of their content.
[Note 1: In other words, recognizing theu+feff byte order markis not sufficient. —end note]
If an input file is determined to be a UTF-8 file, then it shall be a well-formed UTF-8 code unit
sequence and it is decoded to produce a sequence of Unicode8 scalar values. A sequence of translation
character set elements (5.3.1) is then formed by mapping each Unicode scalar value to the corresponding
translation character set element. In the resulting sequence, each pair of characters in the input
sequence consisting ofu+000d carriage returnfollowed byu+000a line feed, as well as eachu+000d
carriage returnnot immediately followed by au+000a line feed, is replaced by a single new-line
character.
For any other kind of input file supported by the implementation, characters are mapped, in an imple-
mentation-defined manner, to a sequence of translation character set elements, representing end-of-line
indicators as new-line characters.
2. If the first translation character isu+feff byte order mark, it is deleted. Each sequence comprising
a backslash character (\) immediately followed by zero or more whitespace characters other than
new-line followed by a new-line character is deleted, splicing physical source lines to formlogical source
lines. Only the last backslash on any physical source line is eligible for being part of such a splice.
[Note 2: Line splicing can form auniversal-character-name (5.3.1). —end note]
A source file that is not empty and that (after splicing) does not end in a new-line character is processed
as if an additional new-line character were appended to the file.
3. The source file is decomposed into preprocessing tokens (5.5) and sequences of whitespace characters
(including comments). A source file shall not end in a partial preprocessing token or in a partial
comment.9 Each comment (5.4) is replaced by oneu+0020 space character. New-line characters are
retained. Whether each nonempty sequence of whitespace characters other than new-line is retained or
replaced by oneu+0020 space character is unspecified. As characters from the source file are consumed
to form the next preprocessing token (i.e., not being consumed as part of a comment or other forms of
whitespace), except when matching ac-char-sequence, s-char-sequence, r-char-sequence, h-char-sequence,
or q-char-sequence, universal-character-names are recognized (5.3.2) and replaced by the designated
element of the translation character set (5.3.1). The process of dividing a source file’s characters into
preprocessing tokens is context-dependent.
[Example 1: See the handling of< within a#include preprocessing directive (5.6, 15.3).—end example]
7) Implementations behave as if these separate phases occur, although in practice different phases can be folded together.
8) Unicode® is a registered trademark of Unicode, Inc. This information is given for the convenience of users of this document
and does not constitute an endorsement by ISO or IEC of this product.
9) A partial preprocessing token would arise from a source file ending in the first portion of a multi-character token that
requires a terminating sequence of characters, such as aheader-name that is missing the closing" or >. A partial comment
would arise from a source file ending with an unclosed/* comment.
§ 5.2 © ISO/IEC
13

===== PAGE 25 =====

Dxxxx
4. The source file is analyzed as apreprocessing-file (15.1). Preprocessing directives (Clause 15) are executed,
macro invocations are expanded (15.7), and_Pragma unary operator expressions are executed (15.13).
A #include preprocessing directive (15.3) causes the named header or source file to be processed
from phase 1 through phase 4, recursively. All preprocessing directives are then deleted. Whitespace
characters separating preprocessing tokens are no longer significant.
5. For a sequence of two or more adjacentstring-literal preprocessing tokens, a commonencoding-prefix
is determined as specified in 5.13.5. Each suchstring-literal preprocessing token is then considered to
have that commonencoding-prefix. Then, adjacentstring-literal preprocessing tokens are concatenated
(5.13.5).
6. Each preprocessing token is converted into a token (5.10).
7. The tokens constitute atranslation unitand are syntactically and semantically analyzed as atranslation-
unit (6.7) and translated.
[Note 3: The process of analyzing and translating the tokens can occasionally result in one token being replaced
by a sequence of other tokens (13.3).—end note]
It is implementation-defined whether the sources for module units and header units on which the
current translation unit has an interface dependency (10.1, 10.3) are required to be available.
[Note 4: Source files, translation units and translated translation units need not necessarily be stored as files,
nor need there be any one-to-one correspondence between these entities and any external representation. The
description is conceptual only, and does not specify any particular implementation.—end note]
[Note 5: Previously translated translation units can be preserved individually or in libraries. The separate
translation units of a program communicate (6.7) by (for example) calls to functions whose names have external
or module linkage, manipulation of variables whose names have external or module linkage, or manipulation of
data files. —end note]
While the tokens constituting translation units are being analyzed and translated, required instantiations
are performed.
[Note 6: This can include instantiations which have been explicitly requested (13.9.3).—end note]
The contexts from which instantiations may be performed are determined by their respective points of
instantiation (13.8.4.1).
[Note 7: Other requirements in this document can further constrain the context from which an instantiation
can be performed. For example, a constexpr function template specialization might have a point of instantiation
at the end of a translation unit, but its use in certain constant expressions could require that it be instantiated
at an earlier point (13.9.2).—end note]
Each instantiation results in new program constructs. The program is ill-formed if any instantiation
fails.
During the analysis and translation of tokens, certain expressions are evaluated (7.7). Constructs
appearing at a program pointP are analyzed in a context where each side effect of evaluating an
expression E as a full-expression is complete if and only if
—(1.1) E is the expression corresponding to aconsteval-block-declaration (9.1), and
—(1.2) either thatconsteval-block-declaration or the template definition from which it is instantiated is
reachable from (10.7)
—(1.2.1) P, or
—(1.2.2) the point immediately following theclass-specifier of the outermost class for whichP is in a
complete-class context (11.4.1).
[Example 2:
class S {
class Incomplete;
class Inner {
void fn() {
/∗ p1 ∗/ Incomplete i; // OK
}
}; /∗ p2 ∗/
§ 5.2 © ISO/IEC
14

===== PAGE 26 =====

Dxxxx
consteval {
define_aggregate(^^Incomplete, {});
}
}; /∗ p3 ∗/
Constructs atp1 are analyzed in a context where the side effect of the call todefine_aggregate is evaluated
because
—(1.3) E is the expression corresponding to a consteval block, and
—(1.4) p1 is in a complete-class context ofS and the consteval block is reachable fromp3.
—end example]
8. Translated translation units are combined, and all external entity references are resolved (6.7). Library
components are linked to satisfy external references to entities not defined in the current translation.
All such translator output is collected into a program image which contains information needed for
execution in its execution environment.
5.3 Characters [lex.char]
5.3.1 Character sets [lex.charset]
1 The translation character setconsists of the following elements:
—(1.1) each abstract character assigned a code point in the Unicode codespace as specified in the Unicode
Standard, and
—(1.2) a distinct character for each Unicode scalar value not assigned to an abstract character.
[Note 1: Unicode code points are integers in the range[0,10FFFF] (hexadecimal). A surrogate code point is a value
in the range[D800,DFFF] (hexadecimal). A Unicode scalar value is any code point that is not a surrogate code point.
—end note]
2 The basic character setis a subset of the translation character set, consisting of 99 characters as specified in
Table 1. In this document, glyphs are often used to identify elements of the basic character set.
[Note 2: Unicode short names are given only as a means to identifying the character; the numerical value has no
other meaning in this context.—end note]
3 The basic literal character setconsists of all characters of the basic character set, plus the control characters
specified in Table 2.
4 A code unit is an integer value of character type (6.9.2). Characters in acharacter-literal other than a
multicharacter or non-encodable character literal or in astring-literal are encoded as a sequence of one or
more code units, as determined by theencoding-prefix (5.13.3, 5.13.5); this is termed the respectiveliteral
encoding. The ordinary literal encodingis the encoding applied to an ordinary character or string literal. The
wide literal encodingis the encoding applied to a wide character or string literal.
5 A literal encoding or a locale-specific encoding of one of the execution character sets (16.3.3.3.4) encodes
each element of the basic literal character set as a single code unit with non-negative value, distinct from the
code unit for any other such element.
[Note 3: A character not in the basic literal character set can be encoded with more than one code unit; the value of
such a code unit can be the same as that of a code unit for an element of the basic literal character set.—end note]
The u+0000 null character is encoded as the value0. No other element of the translation character set is
encoded with a code unit of value0. The code unit value of each decimal digit character after the digit0
(u+0030) is one greater than the value of the previous. The ordinary and wide literal encodings are otherwise
implementation-defined. For a UTF-8, UTF-16, or UTF-32 literal, the implementation shall encode the
Unicode scalar value corresponding to each character of the translation character set as specified in the
Unicode Standard for the respective Unicode encoding form.
5.3.2 Universal character names [lex.universal.char]
n-char:
any member of the translation character set except theu+007d right curly bracketor new-line
character
n-char-sequence:
n-char n-char-sequenceopt
named-universal-character:
\N{ n-char-sequence }
§ 5.3.2 © ISO/IEC
15

===== PAGE 27 =====

Dxxxx
Table 1 — Basic character set [tab:lex.charset.basic]
character glyph
u+0009 character tabulation
u+000b line tabulation
u+000c form feed
u+0020 space
u+000a line feed new-line
u+0021 exclamation mark !
u+0022 quotation mark "
u+0023 number sign #
u+0024 dollar sign $
u+0025 percent sign %
u+0026 ampersand &
u+0027 apostrophe ’
u+0028 left parenthesis (
u+0029 right parenthesis )
u+002a asterisk *
u+002b plus sign +
u+002c comma ,
u+002d hyphen-minus -
u+002e full stop .
u+002f solidus /
u+0030 .. u+0039 digit zero .. nine 0 1 2 3 4 5 6 7 8 9
u+003a colon :
u+003b semicolon ;
u+003c less-than sign <
u+003d equals sign =
u+003e greater-than sign >
u+003f question mark ?
u+0040 commercial at @
u+0041 .. u+005a latin capital letter a .. z A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
u+005b left square bracket [
u+005c reverse solidus \
u+005d right square bracket ]
u+005e circumflex accent ^
u+005f low line _
u+0060 grave accent `
u+0061 .. u+007a latin small letter a .. z a b c d e f g h i j k l m
n o p q r s t u v w x y z
u+007b left curly bracket {
u+007c vertical line |
u+007d right curly bracket }
u+007e tilde ~
Table 2 — Additional control characters in the basic literal character set
[tab:lex.charset.literal]
character
u+0000 null
u+0007 alert
u+0008 backspace
u+000d carriage return
§ 5.3.2 © ISO/IEC
16

===== PAGE 28 =====

Dxxxx
hex-quad:
hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
simple-hexadecimal-digit-sequence:
hexadecimal-digit simple-hexadecimal-digit-sequenceopt
universal-character-name:
\u hex-quad
\U hex-quad hex-quad
\u{ simple-hexadecimal-digit-sequence }
named-universal-character
1 The universal-character-name construct provides a way to name any element in the translation character set
using just the basic character set. If auniversal-character-name outside thec-char-sequence or s-char-sequence
of acharacter-literal or string-literal (in either case, including within auser-defined-literal) corresponds to a
control character or to a character in the basic character set, the program is ill-formed.
[Note 1: A sequence of characters resembling auniversal-character-name in anr-char-sequence (5.13.5) does not form a
universal-character-name. —end note]
2 A universal-character-name of the form\u hex-quad, \U hex-quad hex-quad, or\u{simple-hexadecimal-digit-
sequence} designates the character in the translation character set whose Unicode scalar value is the
hexadecimal number represented by the sequence ofhexadecimal-digits in theuniversal-character-name. The
program is ill-formed if that number is not a Unicode scalar value.
3 A universal-character-name that is anamed-universal-character designates the corresponding character in the
Unicode Standard (chapter 4.8 Name) if then-char-sequence is equal to its character name or to one of its
character name aliases of type “control”, “correction”, or “alternate”; otherwise, the program is ill-formed.
[Note 2: These aliases are listed in the Unicode Character Database’sNameAliases.txt. None of these names or
aliases have leading or trailing spaces.—end note]
5.4 Comments [lex.comment]
1 The characters/* start a comment, which terminates with the characters*/. These comments do not nest.
The characters// start a comment, which terminates immediately before the next new-line character.
[Note 1: The comment characters//, /*, and*/ have no special meaning within a// comment and are treated just
like other characters. Similarly, the comment characters// and /* have no special meaning within a/* comment.
—end note]
5.5 Preprocessing tokens [lex.pptoken]
preprocessing-token:
header-name
import-keyword
module-keyword
export-keyword
identifier
pp-number
character-literal
user-defined-character-literal
string-literal
user-defined-string-literal
preprocessing-op-or-punc
each non-whitespace character that cannot be one of the above
1 A preprocessing token is the minimal lexical element of the language in translation phases 3 through 5. The
categories of preprocessing token are: header names, placeholder tokens produced by preprocessingimport
and module directives (import-keyword, module-keyword, and export-keyword), identifiers, preprocessing
numbers, character literals (including user-defined character literals), string literals (including user-defined
string literals), preprocessing operators and punctuators, and single non-whitespace characters that do not
lexically match the other preprocessing token categories. If au+0027 apostrophe, au+0022 quotation
mark, or any character not in the basic character set matches the last category, the program is ill-formed.
2 Preprocessing tokens can be separated by whitespace; this consists of comments (5.4), or whitespace characters
(u+0020 space, u+0009 character tabulation, new-line,u+000b line tabulation, andu+000c form
feed), or both.
§ 5.5 © ISO/IEC
17

===== PAGE 29 =====

Dxxxx
[Note 1: As described in Clause 15, in certain circumstances during translation phase 4, whitespace (or the absence
thereof) serves as more than preprocessing token separation. Whitespace can appear within a preprocessing token
only as part of a header name or between the quotation characters in a character literal or string literal.—end note]
3 Each preprocessing token that is converted to a token (5.10) shall have the lexical form of a keyword, an
identifier, a literal, or an operator or punctuator.
4 The import-keyword is produced by processing animport directive (15.6), themodule-keyword is produced by
preprocessing amodule directive (15.5), and theexport-keyword is produced by preprocessing either of the
previous two directives.
[Note 2: None has any observable spelling.—end note]
5 If the input stream has been parsed into preprocessing tokens up to a given character:
—(5.1) If the next character begins a sequence of characters that could be the prefix and initial double quote of
a raw string literal, such asR", the next preprocessing token shall be a raw string literal. Between the
initial and final double quote characters of the raw string, any transformations performed in phase 2
(line splicing) are reverted; this reversion is applied before anyd-char, r-char, or delimiting parenthesis
is identified. The raw string literal is defined as the shortest sequence of characters that matches the
raw-string pattern
encoding-prefixopt R raw-string
—(5.2) Otherwise, if the next three characters are<:: and the subsequent character is neither: nor >, the< is
treated as a preprocessing token by itself and not as the first character of the alternative token<:.
—(5.3) Otherwise, if the next three characters are[:: and the subsequent character is not:, or if the next
three characters are[:>, the[ is treated as a preprocessing token by itself and not as the first character
of the preprocessing token[:.
[Note 3: The tokens[: and :] cannot be composed from digraphs.—end note]
—(5.4) Otherwise, the next preprocessing token is the longest sequence of characters that could constitute a
preprocessing token, even if that would cause further lexical analysis to fail, except that
—(5.4.1) a string-literal token is never formed when aheader-name token can be formed, and
—(5.4.2) a header-name (5.6) is only formed
—(5.4.2.1) immediately after theinclude, embed, orimport preprocessing token in a#include (15.3),
#embed (15.4), orimport (15.6) directive, respectively, or
—(5.4.2.2) immediately after a preprocessing token sequence of__has_include or __has_embed imme-
diately followed by( in a#if, #elif, or#embed directive (15.2, 15.4).
6 [Example 1:
#define R "x"
const char* s = R"y"; // ill-formed raw string, not"x" "y"
—end example]
7 [Example 2: The program fragment0xe+foo is parsed as a preprocessing number token (one that is not a valid
integer-literal or floating-point-literal token), even though a parse as three preprocessing tokens0xe, +, andfoo can
produce a valid expression (for example, iffoo is a macro defined as1). Similarly, the program fragment1E1 is parsed
as a preprocessing number (one that is a validfloating-point-literal token), whether or notE is a macro name.—end
example]
8 [Example 3: The program fragmentx+++++y is parsed asx ++ ++ + y, which, ifx and y have integral types, violates
a constraint on increment operators, even though the parsex ++ + ++ y can yield a correct expression. —end
example]
5.6 Header names [lex.header]
header-name:
< h-char-sequence >
" q-char-sequence "
h-char-sequence:
h-char h-char-sequenceopt
h-char:
any member of the translation character set except new-line andu+003e greater-than sign
§ 5.6 © ISO/IEC
18

===== PAGE 30 =====

Dxxxx
q-char-sequence:
q-char q-char-sequenceopt
q-char:
any member of the translation character set except new-line andu+0022 quotation mark
1 The sequences in both forms ofheader-names are mapped in an implementation-defined manner to headers
or to external source file names as specified in 15.3.
[Note 1: Header name preprocessing tokens appear only within a#include preprocessing directive, a__has_include
preprocessing expression, or after certain occurrences of animport token (see 5.5). —end note]
2 The appearance of either of the characters’ or \ or of either of the character sequences/* or // in a
q-char-sequence or anh-char-sequence is conditionally-supported with implementation-defined semantics, as is
the appearance of the character" in anh-char-sequence.
[Note 2: Thus, a sequence of characters that resembles an escape sequence can result in an error, be interpreted
as the character corresponding to the escape sequence, or have a completely different meaning, depending on the
implementation. —end note]
5.7 Preprocessing numbers [lex.ppnumber]
pp-number:
digit
. digit
pp-number identifier-continue
pp-number ’ digit
pp-number ’ nondigit
pp-number e sign
pp-number E sign
pp-number p sign
pp-number P sign
pp-number .
1 Preprocessing number tokens lexically include allinteger-literal tokens (5.13.2) and allfloating-point-literal
tokens (5.13.4).
2 A preprocessing number does not have a type or a value; it acquires both after a successful conversion to an
integer-literal token or afloating-point-literal token.
5.8 Operators and punctuators [lex.operators]
1 The lexical representation of C++ programs includes a number of preprocessing tokens that are used in the
syntax of the preprocessor or are converted into tokens for operators and punctuators:
preprocessing-op-or-punc:
preprocessing-operator
operator-or-punctuator
preprocessing-operator: one of
# ## %: %:%:
operator-or-punctuator: one of
{ } [ ] ( ) [: :]
<% %> <: :> ; : ...
? :: . .* -> ->* ^^ ~
! + - * / % ^ & |
= += -= *= /= %= ^= &= |=
== != < > <= >= <=> && ||
<< >> <<= >>= ++ -- ,
and or xor not bitand bitor compl
and_eq or_eq xor_eq not_eq
Each operator-or-punctuator is converted to a single token in translation phase 6 (5.2).
5.9 Alternative tokens [lex.digraph]
1 Alternative token representations are provided for some operators and punctuators.10
10) These include “digraphs” and additional reserved words. The term “digraph” (token consisting of two characters) is not
perfectly descriptive, since one of the alternativepreprocessing-tokens is%:%: and of course several primary tokens contain two
characters. Nonetheless, those alternative tokens that aren’t lexical keywords are colloquially known as “digraphs”.
§ 5.9 © ISO/IEC
19

===== PAGE 31 =====

Dxxxx
2 In all respects of the language, each alternative token behaves the same, respectively, as its primary token,
except for its spelling.
[Note 1: The “stringized” values (15.7.3) of[ and <: are different, maintaining the source spelling.—end note]
The set of alternative tokens is defined in Table 3.
Table 3 — Alternative tokens [tab:lex.digraph]
Alternative Primary Alternative Primary Alternative Primary
<% { and && and_eq &=
%> } bitor | or_eq |=
<: [ or || xor_eq ^=
:> ] xor ^ not !
%: # compl ~ not_eq !=
%:%: ## bitand &
5.10 Tokens [lex.token]
token:
identifier
keyword
literal
operator-or-punctuator
1 There are five kinds of tokens: identifiers, keywords, literals, operators, and other separators.
5.11 Identifiers [lex.name]
identifier:
identifier-start
identifier identifier-continue
identifier-start:
nondigit
an element of the translation character set with the Unicode property XID_Start
identifier-continue:
digit
nondigit
an element of the translation character set with the Unicode property XID_Continue
nondigit: one of
a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z _
digit: one of
0 1 2 3 4 5 6 7 8 9
1 [Note 1: The character properties XID_Start and XID_Continue are described by UAX#44 of the Unicode
Standard.11 —end note]
The program is ill-formed if anidentifier does not conform to Normalization Form C as specified in the
Unicode Standard.
[Note 2: Identifiers are case-sensitive.—end note]
[Note 3: Annex E compares the requirements of UAX#31 of the Unicode Standard with the C++ rules for identifiers.
—end note]
[Note 4: In translation phase 4,identifier also includes thosepreprocessing-tokens (5.5) differentiated as keywords (5.12)
in the later translation phase 7 (5.10).—end note]
11) On systems in which linkers cannot accept extended characters, an encoding of theuniversal-character-name can be used
in forming valid external identifiers. For example, some otherwise unused character or sequence of characters can be used to
encode the\u in auniversal-character-name. Extended characters can produce a long external identifier, but C++ does not place
a translation limit on significant characters for external identifiers.
§ 5.11 © ISO/IEC
20

===== PAGE 32 =====

Dxxxx
2 The identifiers in Table 4 have a special meaning when appearing in a certain context. When referred to
in the grammar, these identifiers are used explicitly rather than using theidentifier grammar production.
Unless otherwise specified, any ambiguity as to whether a givenidentifier has a special meaning is resolved to
interpret the token as a regularidentifier.
Table 4 — Identifiers with special meaning [tab:lex.name.special]
final import module override post pre
3 In addition, some identifiers appearing as atoken or preprocessing-token are reserved for use by C++ imple-
mentations and shall not be used otherwise; no diagnostic is required.
—(3.1) Each identifier that contains a double underscore__ or begins with an underscore followed by an
uppercase letter, other than those specified in this document (for example,__cplusplus (15.12)), is
reserved to the implementation for any use.
—(3.2) Each identifier that begins with an underscore is reserved to the implementation for use as a name in
the global namespace.
5.12 Keywords [lex.key]
keyword:
any identifier listed in Table 5
import-keyword
module-keyword
export-keyword
1 The identifiers shown in Table 5 are reserved for use as keywords (that is, they are unconditionally treated as
keywords in phase 7) except in anattribute-token (9.13.1).
[Note 1: The register keyword is unused but is reserved for future use.—end note]
Table 5 — Keywords [tab:lex.key]
alignas
alignof
asm
auto
bool
break
case
catch
char
char8_t
char16_t
char32_t
class
concept
const
consteval
constexpr
constinit
const_cast
continue
contract_assert
co_await
co_return
co_yield
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for
friend
goto
if
inline
int
long
mutable
namespace
new
noexcept
nullptr
operator
private
protected
public
register
reinterpret_cast
requires
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while
2 Furthermore, the alternative representations shown in Table 6 for certain operators and punctuators (5.9)
are reserved and shall not be used otherwise.
Table 6 — Alternative representations [tab:lex.key.digraph]
and and_eq bitand bitor compl not
not_eq or or_eq xor xor_eq
§ 5.12 © ISO/IEC
21

===== PAGE 33 =====

Dxxxx
5.13 Literals [lex.literal]
5.13.1 Kinds of literals [lex.literal.kinds]
1 There are several kinds of literals.
literal:
integer-literal
character-literal
floating-point-literal
string-literal
boolean-literal
pointer-literal
user-defined-literal
[Note 1: When appearing as anexpression, a literal has a type and a value category (7.5.2).—end note]
5.13.2 Integer literals [lex.icon]
integer-literal:
binary-literal integer-suffixopt
octal-literal integer-suffixopt
decimal-literal integer-suffixopt
hexadecimal-literal integer-suffixopt
binary-literal:
0b binary-digit
0B binary-digit
binary-literal ’opt binary-digit
octal-literal:
0
octal-literal ’opt octal-digit
decimal-literal:
nonzero-digit
decimal-literal ’opt digit
hexadecimal-literal:
hexadecimal-prefix hexadecimal-digit-sequence
binary-digit: one of
0 1
octal-digit: one of
0 1 2 3 4 5 6 7
nonzero-digit: one of
1 2 3 4 5 6 7 8 9
hexadecimal-prefix: one of
0x 0X
hexadecimal-digit-sequence:
hexadecimal-digit
hexadecimal-digit-sequence ’opt hexadecimal-digit
hexadecimal-digit: one of
0 1 2 3 4 5 6 7 8 9
a b c d e f
A B C D E F
integer-suffix:
unsigned-suffix long-suffixopt
unsigned-suffix long-long-suffixopt
unsigned-suffix size-suffixopt
long-suffix unsigned-suffixopt
long-long-suffix unsigned-suffixopt
size-suffix unsigned-suffixopt
unsigned-suffix: one of
u U
long-suffix: one of
l L
§ 5.13.2 © ISO/IEC
22

===== PAGE 34 =====

Dxxxx
long-long-suffix: one of
ll LL
size-suffix: one of
z Z
1 In aninteger-literal, the sequence ofbinary-digits, octal-digits, digits, orhexadecimal-digits is interpreted as a
base N integer as shown in Table 7; the lexically first digit of the sequence of digits is the most significant.
[Note 1: The prefix and any optional separating single quotes are ignored when determining the value.—end note]
Table 7 — Base ofinteger-literals [tab:lex.icon.base]
Kind ofinteger-literal base N
binary-literal 2
octal-literal 8
decimal-literal 10
hexadecimal-literal 16
2 The hexadecimal-digits a through f and A through F have decimal values ten through fifteen.
[Example 1: The number twelve can be written12, 014, 0XC, or0b1100. The integer-literals 1048576, 1’048’576,
0X100000, 0x10’0000, and0’004’000’000 all have the same value.—end example]
3 The type of aninteger-literal is the first type in the list in Table 8 corresponding to its optionalinteger-suffix
in which its value can be represented.
Table 8 — Types ofinteger-literals [tab:lex.icon.type]
integer-suffix decimal-literal integer-literal other thandecimal-literal
none int int
long int unsigned int
long long int long int
unsigned long int
long long int
unsigned long long int
u or U unsigned int unsigned int
unsigned long int unsigned long int
unsigned long long int unsigned long long int
l or L long int long int
long long int unsigned long int
long long int
unsigned long long int
Both u or U unsigned long int unsigned long int
and l or L unsigned long long int unsigned long long int
ll or LL long long int long long int
unsigned long long int
Both u or U unsigned long long int unsigned long long int
and ll or LL
z or Z the signed integer type corresponding the signed integer type
to std::size_t (17.2.4) corresponding tostd::size_t
std::size_t
Both u or U std::size_t std::size_t
and z or Z
4 Except forinteger-literals containing asize-suffix, if the value of aninteger-literal cannot be represented by
any type in its list and an extended integer type (6.9.2) can represent its value, it may have that extended
integer type. If all of the types in the list for theinteger-literal are signed, the extended integer type is signed.
If all of the types in the list for theinteger-literal are unsigned, the extended integer type is unsigned. If the
§ 5.13.2 © ISO/IEC
23

===== PAGE 35 =====

Dxxxx
list contains both signed and unsigned types, the extended integer type may be signed or unsigned. If an
integer-literal cannot be represented by any of the allowed types, the program is ill-formed.
[Note 2: An integer-literal with az or Z suffix is ill-formed if it cannot be represented bystd::size_t. —end note]
5.13.3 Character literals [lex.ccon]
character-literal:
encoding-prefixopt ’ c-char-sequence ’
encoding-prefix: one of
u8 u U L
c-char-sequence:
c-char c-char-sequenceopt
c-char:
basic-c-char
escape-sequence
universal-character-name
basic-c-char:
any member of the translation character set except theu+0027 apostrophe,
u+005c reverse solidus, or new-line character
escape-sequence:
simple-escape-sequence
numeric-escape-sequence
conditional-escape-sequence
simple-escape-sequence:
\ simple-escape-sequence-char
simple-escape-sequence-char: one of
’ " ? \ a b f n r t v
numeric-escape-sequence:
octal-escape-sequence
hexadecimal-escape-sequence
simple-octal-digit-sequence:
octal-digit simple-octal-digit-sequenceopt
octal-escape-sequence:
\ octal-digit
\ octal-digit octal-digit
\ octal-digit octal-digit octal-digit
\o{ simple-octal-digit-sequence }
hexadecimal-escape-sequence:
\x simple-hexadecimal-digit-sequence
\x{ simple-hexadecimal-digit-sequence }
conditional-escape-sequence:
\ conditional-escape-sequence-char
conditional-escape-sequence-char:
any member of the basic character set that is not anoctal-digit, asimple-escape-sequence-char, or the
characters N, o, u, U, orx
1 A multicharacter literal is a character-literal whose c-char-sequence consists of more than onec-char. A
multicharacter literal shall not have anencoding-prefix. If a multicharacter literal contains ac-char that is
not encodable as a single code unit in the ordinary literal encoding, the program is ill-formed. Multicharacter
literals are conditionally-supported.
2 The kind of acharacter-literal, its type, and its associated character encoding (5.3.1) are determined by its
encoding-prefix and itsc-char-sequence as defined by Table 9.
3 In translation phase 4, the value of acharacter-literal is determined using the range of representable values of
the character-literal’s type in translation phase 7. A multicharacter literal has an implementation-defined
value. The value of any other kind ofcharacter-literal is determined as follows:
—(3.1) A character-literal with ac-char-sequence consisting of a singlebasic-c-char, simple-escape-sequence, or
universal-character-name is the code unit value of the specified character as encoded in the literal’s
§ 5.13.3 © ISO/IEC
24

===== PAGE 36 =====

Dxxxx
Table 9 — Character literals [tab:lex.ccon.literal]
Encoding Kind Type Associated char- Example
prefix acter encoding
none ordinary character literal char ordinary literal ’v’
multicharacter literal int encoding ’abcd’
L wide character literal wchar_t wide literal L’w’
encoding
u8 UTF-8 character literal char8_t UTF-8 u8’x’
u UTF-16 character literal char16_t UTF-16 u’y’
U UTF-32 character literal char32_t UTF-32 U’z’
associated character encoding. If the specified character lacks representation in the literal’s associated
character encoding or if it cannot be encoded as a single code unit, then the program is ill-formed.
—(3.2) A character-literal with ac-char-sequence consisting of a singlenumeric-escape-sequence has a value as
follows:
—(3.2.1) Let v be the integer value represented by the octal number comprising the sequence ofoctal-
digits in an octal-escape-sequence or by the hexadecimal number comprising the sequence of
hexadecimal-digits in ahexadecimal-escape-sequence.
—(3.2.2) If v does not exceed the range of representable values of thecharacter-literal’s type, then the value
is v.
—(3.2.3) Otherwise, if the character-literal’s encoding-prefix is absent or L, and v does not exceed the
range of representable values of the corresponding unsigned type for the underlying type of the
character-literal’s type, then the value is the unique value of thecharacter-literal’s typeT that is
congruent tov modulo 2N, whereN is the width ofT.
—(3.2.4) Otherwise, the program is ill-formed.
—(3.3) Acharacter-literal with ac-char-sequence consisting of a singleconditional-escape-sequence is conditionally-
supported and has an implementation-defined value.
4 The character specified by asimple-escape-sequence is specified in Table 10.
[Note 1: Using an escape sequence for a question mark is supported for compatibility with C++ 2014 and C.—end
note]
Table 10 — Simple escape sequences [tab:lex.ccon.esc]
character simple-escape-sequence
u+000a line feed \n
u+0009 character tabulation \t
u+000b line tabulation \v
u+0008 backspace \b
u+000d carriage return \r
u+000c form feed \f
u+0007 alert \a
u+005c reverse solidus \\
u+003f question mark \?
u+0027 apostrophe \’
u+0022 quotation mark \"
5.13.4 Floating-point literals [lex.fcon]
floating-point-literal:
decimal-floating-point-literal
hexadecimal-floating-point-literal
§ 5.13.4 © ISO/IEC
25

===== PAGE 37 =====

Dxxxx
decimal-floating-point-literal:
fractional-constant exponent-partopt floating-point-suffixopt
digit-sequence exponent-part floating-point-suffixopt
hexadecimal-floating-point-literal:
hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-point-suffixopt
hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-point-suffixopt
fractional-constant:
digit-sequenceopt . digit-sequence
digit-sequence .
hexadecimal-fractional-constant:
hexadecimal-digit-sequenceopt . hexadecimal-digit-sequence
hexadecimal-digit-sequence .
exponent-part:
e signopt digit-sequence
E signopt digit-sequence
binary-exponent-part:
p signopt digit-sequence
P signopt digit-sequence
sign: one of
+ -
digit-sequence:
digit
digit-sequence ’opt digit
floating-point-suffix: one of
f l f16 f32 f64 f128 bf16 F L F16 F32 F64 F128 BF16
1 The type of afloating-point-literal (6.9.2, 6.9.3) is determined by itsfloating-point-suffix as specified in Table 11.
[Note 1: The floating-point suffixes f16, f32, f64, f128, bf16, F16, F32, F64, F128, and BF16 are conditionally-
supported. See 6.9.3. —end note]
Table 11 — Types offloating-point-literals [tab:lex.fcon.type]
floating-point-suffix type
none double
f or F float
l or L long double
f16 or F16 std::float16_t
f32 or F32 std::float32_t
f64 or F64 std::float64_t
f128 or F128 std::float128_t
bf16 or BF16 std::bfloat16_t
2 The significand of afloating-point-literal is thefractional-constant or digit-sequence of adecimal-floating-point-
literal or thehexadecimal-fractional-constant or hexadecimal-digit-sequence of ahexadecimal-floating-point-literal.
In the significand, the sequence ofdigits orhexadecimal-digits and optional period are interpreted as a baseN
real numbers, whereN is 10 for adecimal-floating-point-literal and 16 for ahexadecimal-floating-point-literal.
[Note 2: Any optional separating single quotes are ignored when determining the value.—end note]
If an exponent-part or binary-exponent-part is present, the exponent e of the floating-point-literal is the
result of interpreting the sequence of an optionalsign and thedigits as a base 10 integer. Otherwise, the
exponent e is 0. The scaled value of the literal iss×10e for adecimal-floating-point-literal and s×2e for a
hexadecimal-floating-point-literal.
[Example 1: The floating-point-literals 49.625 and 0xC.68p+2 have the same value. The floating-point-literals
1.602’176’565e-19 and 1.602176565e-19 have the same value.—end example]
3 If the scaled value is not in the range of representable values for its type, the program is ill-formed. Otherwise,
the value of afloating-point-literal is the scaled value if representable, else the larger or smaller representable
value nearest the scaled value, chosen in an implementation-defined manner.
§ 5.13.4 © ISO/IEC
26

===== PAGE 38 =====

Dxxxx
5.13.5 String literals [lex.string]
string-literal:
encoding-prefixopt plain-string-literal
encoding-prefixopt R raw-string
plain-string-literal:
" s-char-sequenceopt "
s-char-sequence:
s-char s-char-sequenceopt
s-char:
basic-s-char
escape-sequence
universal-character-name
basic-s-char:
any member of the translation character set except theu+0022 quotation mark,
u+005c reverse solidus, or new-line character
raw-string:
" d-char-sequenceopt ( r-char-sequenceopt ) d-char-sequenceopt "
r-char-sequence:
r-char r-char-sequenceopt
r-char:
any member of the translation character set, except au+0029 right parenthesisfollowed by
the initiald-char-sequence (which may be empty) followed by au+0022 quotation mark
d-char-sequence:
d-char d-char-sequenceopt
d-char:
any member of the basic character set except:
u+0020 space, u+0028 left parenthesis, u+0029 right parenthesis, u+005c reverse solidus,
u+0009 character tabulation, u+000b line tabulation, u+000c form feed, and new-line
1 The kind of astring-literal, its type, and its associated character encoding (5.3.1) are determined by its
encoding prefix and sequence ofs-chars orr-chars as defined by Table 12 wheren is the number of encoded
code units that would result from an evaluation of thestring-literal (see below).
Table 12 — String literals [tab:lex.string.literal]
Enco- Kind Type Associated Examples
ding character
prefix encoding
none ordinary string literal array ofn
const char
ordinary literal
encoding
"ordinary string"
R"(ordinary raw string)"
L wide string literal array ofn
const wchar_t
wide literal
encoding
L"wide string"
LR"w(wide raw string)w"
u8 UTF-8 string literal array ofn
const char8_t
UTF-8 u8"UTF-8 string"
u8R"x(UTF-8 raw string)x"
u UTF-16 string literal array ofn
const char16_t
UTF-16 u"UTF-16 string"
uR"y(UTF-16 raw string)y"
U UTF-32 string literal array ofn
const char32_t
UTF-32 U"UTF-32 string"
UR"z(UTF-32 raw string)z"
2 A string-literal that has anR in the prefix is araw string literal. Thed-char-sequence serves as a delimiter. The
terminating d-char-sequence of araw-string is the same sequence of characters as the initiald-char-sequence.
A d-char-sequence shall consist of at most 16 characters.
3 [Note 1: The characters’(’ and ’)’ can appear in araw-string. Thus,R"delimiter((a|b))delimiter" is equivalent
to "(a|b)". —end note]
4 [Note 2: A source-file new-line in a raw string literal results in a new-line in the resulting execution string literal.
Assuming no whitespace at the beginning of lines in the following example, the assert will succeed:
§ 5.13.5 © ISO/IEC
27

===== PAGE 39 =====

Dxxxx
const char* p = R"(a\
b
c)";
assert(std::strcmp(p, "a\\\nb\nc") == 0);
—end note]
5 [Example 1: The raw string
R"a(
)\
a"
)a"
is equivalent to"\n)\\\na\"\n". The raw string
R"(x = "\"y\"")"
is equivalent to"x = \"\\\"y\\\"\"". —end example]
6 Ordinary string literals and UTF-8 string literals are also referred to asnarrow string literals.
7 The string-literals in any sequence of adjacentstring-literals shall have at most one uniqueencoding-prefix
among them. The commonencoding-prefix of the sequence is thatencoding-prefix, if any.
[Note 3: A string-literal’s rawness has no effect on the determination of the commonencoding-prefix. —end note]
8 In translation phase 5 (5.2), adjacentstring-literals are concatenated. The lexical structure and grouping of
the contents of the individualstring-literals is retained.
[Example 2:
"\xA" "B"
represents the code unit’\xA’ and the character’B’ after concatenation (and not the single code unit’\xAB’).
Similarly,
R"(\u00)" "41"
represents six characters, starting with a backslash and ending with the digit1 (and not the single character’A’
specified by auniversal-character-name).
Table 13 has some examples of valid concatenations.—end example]
Table 13 — String literal concatenations [tab:lex.string.concat]
Source Means Source Means Source Means
u"a" u"b" u"ab" U"a" U"b" U"ab" L"a" L"b" L"ab"
u"a" "b" u"ab" U"a" "b" U"ab" L"a" "b" L"ab"
"a" u"b" u"ab" "a" U"b" U"ab" "a" L"b" L"ab"
9 Evaluating astring-literal results in a string literal object with static storage duration (6.8.6).
[Note 4: String literal objects are potentially non-unique (6.8.2). Whether successive evaluations of astring-literal
yield the same or a different object is unspecified.—end note]
[Note 5: The effect of attempting to modify a string literal object is undefined.—end note]
10 String literal objects are initialized with the sequence of code unit values corresponding to thestring-literal’s
sequence ofs-chars (originally from non-raw string literals) andr-chars (originally from raw string literals),
plus a terminatingu+0000 null character, in order as follows:
—(10.1) The sequence of characters denoted by each contiguous sequence ofbasic-s-chars, r-chars, simple-escape-
sequences (5.13.3), and universal-character-names (5.3.1) is encoded to a code unit sequence using
the string-literal’s associated character encoding. If a character lacks representation in the associated
character encoding, then the program is ill-formed.
[Note 6: No character lacks representation in any Unicode encoding form.—end note]
When encoding a stateful character encoding, implementations should encode the first such sequence
beginning with the initial encoding state and encode subsequent sequences beginning with the final
encoding state of the prior sequence.
[Note 7: The encoded code unit sequence can differ from the sequence of code units that would be obtained by
encoding each character independently.—end note]
§ 5.13.5 © ISO/IEC
28

===== PAGE 40 =====

Dxxxx
—(10.2) Each numeric-escape-sequence (5.13.3) contributes a single code unit with a value as follows:
—(10.2.1) Let v be the integer value represented by the octal number comprising the sequence ofoctal-
digits in an octal-escape-sequence or by the hexadecimal number comprising the sequence of
hexadecimal-digits in ahexadecimal-escape-sequence.
—(10.2.2) If v does not exceed the range of representable values of thestring-literal’s array element type,
then the value isv.
—(10.2.3) Otherwise, if thestring-literal’s encoding-prefix is absent orL, andv does not exceed the range of
representable values of the corresponding unsigned type for the underlying type of thestring-literal’s
array element type, then the value is the unique value of thestring-literal’s array element typeT
that is congruent tov modulo 2N, whereN is the width ofT.
—(10.2.4) Otherwise, the program is ill-formed.
When encoding a stateful character encoding, these sequences should have no effect on encoding state.
—(10.3) Each conditional-escape-sequence (5.13.3) contributes an implementation-defined code unit sequence.
When encoding a stateful character encoding, it is implementation-defined what effect these sequences
have on encoding state.
5.13.6 Unevaluated strings [lex.string.uneval]
unevaluated-string:
string-literal
1 An unevaluated-string shall have noencoding-prefix.
2 Each universal-character-name and eachsimple-escape-sequence in anunevaluated-string is replaced by the
member of the translation character set it denotes. Anunevaluated-string that contains anumeric-escape-
sequence or aconditional-escape-sequence is ill-formed.
3 An unevaluated-string is never evaluated and its interpretation depends on the context in which it appears.
5.13.7 Boolean literals [lex.bool]
boolean-literal:
false
true
1 The Boolean literals are the keywordsfalse and true. Such literals have typebool.
5.13.8 Pointer literals [lex.nullptr]
pointer-literal:
nullptr
1 The pointer literal is the keywordnullptr. It has typestd::nullptr_t.
[Note 1: std::nullptr_t is a distinct type that is neither a pointer type nor a pointer-to-member type; rather, a
prvalue of this type is a null pointer constant and can be converted to a null pointer value or null member pointer
value. See 7.3.12 and 7.3.13.—end note]
5.13.9 User-defined literals [lex.ext]
user-defined-literal:
user-defined-integer-literal
user-defined-floating-point-literal
user-defined-string-literal
user-defined-character-literal
user-defined-integer-literal:
decimal-literal ud-suffix
octal-literal ud-suffix
hexadecimal-literal ud-suffix
binary-literal ud-suffix
user-defined-floating-point-literal:
fractional-constant exponent-partopt ud-suffix
digit-sequence exponent-part ud-suffix
hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part ud-suffix
hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part ud-suffix
§ 5.13.9 © ISO/IEC
29

===== PAGE 41 =====

Dxxxx
user-defined-string-literal:
string-literal ud-suffix
user-defined-character-literal:
character-literal ud-suffix
ud-suffix:
identifier
1 If a token matches bothuser-defined-literal and anotherliteral kind, it is treated as the latter.
[Example 1: 123_km is auser-defined-literal, but12LL is aninteger-literal. —end example]
The syntactic non-terminal preceding theud-suffix in auser-defined-literal is taken to be the longest sequence
of characters that could match that non-terminal.
2 A user-defined-literal is treated as a call to a literal operator or literal operator template (12.6). To determine
the form of this call for a givenuser-defined-literal L with ud-suffix X, first letS be the set of declarations
found by unqualified lookup for theliteral-operator-id whose literal suffix identifier isX (6.5.3). S shall not
be empty.
3 If L is auser-defined-integer-literal, letn be the literal without itsud-suffix. If S contains a literal operator
with parameter typeunsigned long long, the literalL is treated as a call of the form
operator ""X (n ULL)
Otherwise, S shall contain a raw literal operator or a numeric literal operator template (12.6) but not both.
If S contains a raw literal operator, the literalL is treated as a call of the form
operator ""X ("n ")
Otherwise (S contains a numeric literal operator template),L is treated as a call of the form
operator ""X <'c1', 'c2', ... 'ck'>()
where n is the source character sequencec1c2...ck.
[Note 1: The sequencec1c2...ck can only contain characters from the basic character set.—end note]
4 If L is auser-defined-floating-point-literal, let f be the literal without itsud-suffix. If S contains a literal
operator with parameter typelong double, the literalL is treated as a call of the form
operator ""X (f L)
Otherwise, S shall contain a raw literal operator or a numeric literal operator template (12.6) but not both.
If S contains a raw literal operator, theliteral L is treated as a call of the form
operator ""X ("f ")
Otherwise (S contains a numeric literal operator template),L is treated as a call of the form
operator ""X <'c1', 'c2', ... 'ck'>()
where f is the source character sequencec1c2...ck.
[Note 2: The sequencec1c2...ck can only contain characters from the basic character set.—end note]
5 If L is auser-defined-string-literal, letstr be the literal without itsud-suffix and letlen be the number of
code units instr (i.e., its length excluding the terminating null character). IfS contains a literal operator
template with a constant template parameter for whichstr is a well-formedtemplate-argument, the literalL
is treated as a call of the form
operator ""X <str >()
Otherwise, the literalL is treated as a call of the form
operator ""X (str , len )
6 If L is a user-defined-character-literal, let ch be the literal without itsud-suffix. S shall contain a literal
operator (12.6) whose only parameter has the type ofch and the literalL is treated as a call of the form
operator ""X (ch )
7 [Example 2:
long double operator ""_w(long double);
std::string operator ""_w(const char16_t*, std::size_t);
unsigned operator ""_w(const char*);
int main() {
1.2_w; // calls operator ""_w(1.2L)
§ 5.13.9 © ISO/IEC
30

===== PAGE 42 =====

Dxxxx
u"one"_w; // calls operator ""_w(u"one", 3)
12_w; // calls operator ""_w("12")
"two"_w; // error: no applicable literal operator
}
—end example]
8 In translation phase 5 (5.2), adjacentstring-literals are concatenated and user-defined-string-literals are
considered string-literals for that purpose. During concatenation,ud-suffixes are removed and ignored and the
concatenation process occurs as described in 5.13.5. At the end of phase 5, if astring-literal is the result of a
concatenation involving at least oneuser-defined-string-literal, all the participatinguser-defined-string-literals
shall have the sameud-suffix and that suffix is applied to the result of the concatenation.
9 [Example 3:
int main() {
L"A" "B" "C"_x; // OK, same asL"ABC"_x
"P"_x "Q" "R"_y; // error: two differentud-suffixes
}
—end example]
§ 5.13.9 © ISO/IEC
31

===== PAGE 43 =====

Dxxxx
6 Basics [basic]
6.1 Preamble [basic.pre]
1 [Note 1: This Clause presents the basic concepts of the C++ language. It explains the difference between an object
and a name and how they relate to the value categories for expressions. It introduces the concepts of a declaration
and a definition and presents C++’s notion of type, scope, linkage, and storage duration. The mechanisms for starting
and terminating a program are discussed. Finally, this Clause presents the fundamental types of the language and
lists the ways of constructing compound types from these.—end note]
2 [Note 2: This Clause does not cover concepts that affect only a single part of the language. Such concepts are
discussed in the relevant Clauses.—end note]
3 A name is anidentifier (5.11), conversion-function-id (11.4.8.3), operator-function-id (12.4), orliteral-operator-
id (12.6).
4 Two names arethe sameif
—(4.1) they areidentifiers composed of the same character sequence, or
—(4.2) they areconversion-function-ids formed with equivalent (13.7.7.2) types, or
—(4.3) they areoperator-function-ids formed with the same operator, or
—(4.4) they areliteral-operator-ids formed with the same literal suffix identifier.
5 Every name is introduced by adeclaration, which is a
—(5.1) name-declaration, block-declaration, ormember-declaration (9.1, 11.4),
—(5.2) init-declarator (9.3),
—(5.3) identifier in a structured binding declaration (9.7),
—(5.4) identifier in aresult-name-introducer in a postcondition assertion (9.4.2),
—(5.5) init-capture (7.5.6.3),
—(5.6) condition with adeclarator (8.1),
—(5.7) member-declarator (11.4),
—(5.8) using-declarator (9.10),
—(5.9) parameter-declaration (9.3.4.6, 13.2),
—(5.10) type-parameter (13.2),
—(5.11) type-tt-parameter (13.2),
—(5.12) variable-tt-parameter (13.2),
—(5.13) concept-tt-parameter (13.2),
—(5.14) elaborated-type-specifier that introduces a name (9.2.9.5),
—(5.15) class-specifier (11.1),
—(5.16) enum-specifier or enumerator-definition (9.8.1),
—(5.17) exception-declaration (14.1), or
—(5.18) implicit declaration of an injected-class-name (11.1).
[Note 3: The term declaration is not a synonym for the grammar non-terminaldeclaration (9.1). —end note]
[Note 4: The interpretation of afor-range-declaration produces one or more of the above (8.6.5).—end note]
6 [Note 5: Some names denote types or templates. In general, whenever a name is encountered it is necessary to look it
up (6.5) to determine whether that name denotes one of these entities before continuing to parse the program that
contains it. —end note]
7 A variable is introduced by the declaration of
—(7.1) a reference other than a non-static data member or
—(7.2) an object.
§ 6.1 © ISO/IEC
32

===== PAGE 44 =====

Dxxxx
8 An entity is a variable, structured binding, result binding, function, enumerator, type, type alias, non-static
data member, bit-field, template, namespace, namespace alias, template parameter, function parameter, or
init-capture. The underlying entityof an entity is that entity unless otherwise specified. A namedenotes the
underlying entity of the entity declared by each declaration that introduces the name.
[Note 6: Type aliases and namespace aliases have underlying entities that are distinct from themselves.—end note]
9 A local entity is a variable with automatic storage duration (6.8.6.4), a structured binding (9.7) whose
corresponding variable is such an entity, a result binding (9.4.2), or the*this object (7.5.3).
10 A name used in more than one translation unit can potentially refer to the same entity in these translation
units depending on the linkage (6.7) of the name specified in each translation unit.
6.2 Declarations and definitions [basic.def]
1 A declaration (6.1) may (re)introduce one or more names and/or entities into a translation unit. If so, the
declaration specifies the interpretation and semantic properties of these names. A declaration of an entity
X is a redeclaration ofX if another declaration ofX is reachable from it (10.7); otherwise, it is afirst
declaration.
[Note 1: A declaration can also have effects including:
—(1.1) a static assertion (9.1),
—(1.2) controlling template instantiation (13.9.3),
—(1.3) guiding template argument deduction for constructors (13.7.2.3),
—(1.4) use of attributes (9.13), and
—(1.5) nothing (in the case of anempty-declaration).
—end note]
2 Each entity declared by a declaration is alsodefined by that declaration unless:
—(2.1) it declares a function without specifying the function’s body (9.6),
—(2.2) it contains theextern specifier (9.2.2) or alinkage-specification12 (9.12) and neither aninitializer nor a
function-body,
—(2.3) it declares a non-inline static data member in a class definition (11.4, 11.4.9),
—(2.4) it declares a static data member outside a class definition and the variable was defined within the class
with theconstexpr specifier (11.4.9.3) (this usage is deprecated; see D.7),
—(2.5) it is anelaborated-type-specifier (11.3),
—(2.6) it is anopaque-enum-declaration (9.8.1),
—(2.7) it is atemplate-parameter (13.2),
—(2.8) it is aparameter-declaration (9.3.4.6) in a function declarator that is not thedeclarator of afunction-
definition,
—(2.9) it is atypedef declaration (9.2.4),
—(2.10) it is analias-declaration (9.2.4),
—(2.11) it is anamespace-alias-definition (9.9.3),
—(2.12) it is ausing-declaration (9.10),
—(2.13) it is adeduction-guide (13.7.2.3),
—(2.14) it is astatic_assert-declaration (9.1),
—(2.15) it is aconsteval-block-declaration,
—(2.16) it is anattribute-declaration (9.1),
—(2.17) it is anempty-declaration (9.1),
—(2.18) it is ausing-directive (9.9.4),
—(2.19) it is ausing-enum-declaration (9.8.2),
12) Appearing inside the brace-encloseddeclaration-seq in alinkage-specification does not affect whether a declaration is a
definition.
§ 6.2 © ISO/IEC
33

===== PAGE 45 =====

Dxxxx
—(2.20) it is atemplate-declaration (13.1) whosetemplate-head is not followed by either aconcept-definition or a
declaration that defines a function, a class, a variable, or a static data member,
—(2.21) it is an explicit instantiation declaration (13.9.3), or
—(2.22) it is an explicit specialization (13.9.4) whosedeclaration is not a definition.
A declaration is said to be adefinition of each entity that it defines.
[Example 1: All but one of the following are definitions:
int a; // definesa
extern const int c = 1; // definesc
int f(int x) { return x+a; } // definesf and definesx
struct S { int a; int b; }; // definesS, S::a, and S::b
struct X { // definesX
int x; // defines non-static data memberx
static int y; // declares static data membery
X(): x(0) { } // defines a constructor ofX
};
int X::y = 1; // definesX::y
enum { up, down }; // definesup and down
namespace N { int d; } // definesN and N::d
X anX; // definesanX
whereas these are just declarations:
extern int a; // declaresa
extern const int c; // declaresc
int f(int); // declaresf
struct S; // declaresS
typedef int Int; // declaresInt
namespace N1 = N; // declaresN1
extern X anotherX; // declaresanotherX
using N::d; // declaresd
—end example]
3 [Note 2: In some circumstances, C++ implementations implicitly define the default constructor (11.4.5.2), copy
constructor, move constructor (11.4.5.3), copy assignment operator, move assignment operator (11.4.6), or destructor
(11.4.7) member functions. —end note]
[Example 2: Given
#include <string>
struct C {
std::string s; // std::string is the standard library class (27.4)
};
int main() {
C a;
C b = a;
b = a;
}
the implementation will implicitly define functions to make the definition ofC equivalent to
struct C {
std::string s;
C() : s() { }
C(const C& x): s(x.s) { }
C(C&& x): s(static_cast<std::string&&>(x.s)) { }
// : s(std::move(x.s)) { }
C& operator=(const C& x) { s = x.s; return *this; }
C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }
// { s = std::move(x.s); return *this; }
~C() { }
};
—end example]
4 [Note 3: A class name can also be implicitly declared by anelaborated-type-specifier (9.2.9.5). —end note]
§ 6.2 © ISO/IEC
34

===== PAGE 46 =====

Dxxxx
5 In the definition of an object, the type of that object shall not be an incomplete type (6.9.1), an abstract
class type (11.7.4), or a (possibly multidimensional) array thereof.
6.3 One-definition rule [basic.def.odr]
1 Each of the following is termed adefinable item:
—(1.1) a class type (Clause 11),
—(1.2) an enumeration type (9.8.1),
—(1.3) a function (9.3.4.6),
—(1.4) a variable (6.1),
—(1.5) a templated entity (13.1),
—(1.6) a default argument for a parameter (for a function in a given scope) (9.3.4.7), or
—(1.7) a default template argument (13.2).
2 No translation unit shall contain more than one definition of any definable item.
3 An expression or conversion ispotentially evaluatedunless it is an unevaluated operand (7.2.3), a subexpression
thereof, or a conversion in an initialization or conversion sequence in such a context. The set ofpotential
results of an expressionE is defined as follows:
—(3.1) If E is anid-expression (7.5.5) or asplice-expression (7.5.9), the set contains onlyE.
—(3.2) If E is a subscripting operation (7.6.1.2) with an array operand, the set contains the potential results
of that operand.
—(3.3) If E is a class member access expression (7.6.1.5) of the formE1 . templateopt E2, whereE2 designates
a non-static data member or a direct base class relationship, the set contains the potential results ofE1.
—(3.4) If E is a class member access expression naming a static data member, the set contains theid-expression
designating the data member.
—(3.5) If E is a pointer-to-member expression (7.6.4) of the formE1 .* E2, the set contains the potential
results ofE1.
—(3.6) If E has the form(E1), the set contains the potential results ofE1.
—(3.7) If E is a glvalue conditional expression (7.6.16), the set is the union of the sets of potential results of
the second and third operands.
—(3.8) If E is a comma expression (7.6.20), the set contains the potential results of the right operand.
—(3.9) Otherwise, the set is empty.
[Note 1: This set is a (possibly-empty) set ofid-expressions and splice-expressions, each of which is eitherE or a
subexpression ofE.
[Example 1: In the following example, the set of potential results of the initializer ofn contains the firstS::x
subexpression, but not the secondS::x subexpression. The set of potential results of the initializer ofo contains the
subexpression [:^^S::x:].
struct S { static const int x = 0; };
const int &f(const int &r);
int n = b ? (1, S::x) // S::x is not odr-used here
: f(S::x); // S::x is odr-used here, so a definition is required
int o = [:^^S::x:];
—end example]
—end note]
4 A function isnamed byan expression or conversion as follows:
—(4.1) A function is named by an expression or conversion if it is the selected member of an overload set (6.5,
12.2, 12.3) in an overload resolution performed as part of forming that expression or conversion, and
either it is not a pure virtual function or the expression is anid-expression naming the function with an
explicitly qualified name that does not form a pointer to member (7.6.2.2).
[Note 2: This covers taking the address of functions (7.3.4, 7.6.2.2), calls to named functions (7.6.1.3), operator
overloading (Clause 12), user-defined conversions (11.4.8.3), allocation functions fornew-expressions (7.6.2.8), as
well as non-default initialization (9.5). A constructor selected to copy or move an object of class type is considered
§ 6.3 © ISO/IEC
35

===== PAGE 47 =====

Dxxxx
to be named by an expression or conversion even if the call is actually elided by the implementation (11.9.6).
—end note]
—(4.2) A deallocation function for a class is named by anew-expression if it is the single matching deallocation
function for the allocation function selected by overload resolution, as specified in 7.6.2.8.
—(4.3) A deallocation function for a class is named by adelete-expression if it is the selected usual deallocation
function as specified in 7.6.2.9 and 11.4.11.
5 A variable is named by an expression if the expression is anid-expression or splice-expression (7.5.9) that
designates it. A variablex that is named by a potentially-evaluated expressionN that appears at a pointP
is odr-used by N unless
—(5.1) x is a reference that is usable in constant expressions atP (7.7), or
—(5.2) N is an element of the set of potential results of an expressionE, where
—(5.2.1) E is a discarded-value expression (7.2.3) to which the lvalue-to-rvalue conversion is not applied, or
—(5.2.2) x is a non-volatile object that is usable in constant expressions atP and has no mutable subobjects,
and
—(5.2.2.1) E is a class member access expression (7.6.1.5) naming a non-static data member of reference
type and whose object expression has non-volatile-qualified type, or
—(5.2.2.2) the lvalue-to-rvalue conversion (7.3.2) is applied toEand Ehas non-volatile-qualified non-class
type.
[Example 2:
int f(int);
int g(int&);
struct A {
int x;
};
struct B {
int& r;
};
int h(bool cond) {
constexpr A a = {1};
constexpr const volatile A& r = a; // odr-usesa
int _ = f(cond ? a.x : r.x); // does not odr-usea or r
int x, y;
constexpr B b1 = {x}, b2 = {y}; // odr-usesx and y
int _ = g(cond ? b1.r : b2.r); // does not odr-useb1 or b2
int _ = ((cond ? x : y), 0); // does not odr-usex or y
return [] {
return b1.r; // error: b1 is odr-used here because the object
// referred to byb1.r is not constexpr-referenceable here
}();
}
—end example]
6 A structured binding is named by an expression if that expression is either anid-expression or a splice-
expression that designates that structured binding. A structured binding is odr-used if it is named by a
potentially-evaluated expression.
7 *this is odr-used ifthis appears as a potentially-evaluated expression (including as the result of any implicit
transformation to a class member access expression (7.5.5.1)).
8 A virtual member function is odr-used if it is not pure. A function is odr-used if it is named by a potentially-
evaluated expression or conversion. A non-placement allocation or deallocation function for a class is odr-used
by the definition of a constructor of that class. A non-placement deallocation function for a class is odr-used
by the definition of the destructor of that class, or by being selected by the lookup at the point of definition
of a virtual destructor (11.4.7).13
13) An implementation is not required to call allocation and deallocation functions from constructors or destructors; however,
this is a permissible implementation technique.
§ 6.3 © ISO/IEC
36

===== PAGE 48 =====

Dxxxx
9 An assignment operator function in a class is odr-used by an implicitly-defined copy assignment or move
assignment function for another class as specified in 11.4.6. A constructor for a class is odr-used as specified
in 9.5. A destructor for a class is odr-used if it is potentially invoked (11.4.7).
10 A local entity (6.1) isodr-usable in a scope (6.4.1) if
—(10.1) either the local entity is not*this, or an enclosing class or non-lambda function parameter scope exists
and, if the innermost such scope is a function parameter scope, it corresponds to a non-static member
function, and
—(10.2) for each intervening scope (6.4.1) between the point at which the entity is introduced and the scope
(where *this is considered to be introduced within the innermost enclosing class or non-lambda function
parameter scope), either
—(10.2.1) the intervening scope is a block scope,
—(10.2.2) the intervening scope is a contract-assertion scope (6.4.10),
—(10.2.3) the intervening scope is the function parameter scope of alambda-expression or requires-expression,
or
—(10.2.4) the intervening scope is the lambda scope of alambda-expression that has asimple-capture naming
the entity or has acapture-default, and the block scope of thelambda-expression is also an intervening
scope.
If a local entity is odr-used in a scope in which it is not odr-usable, the program is ill-formed.
[Example 3:
void f(int n) {
[] { n = 1; }; // error: n is not odr-usable due to intervening lambda-expression
struct A {
void f() { n = 2; } // error: n is not odr-usable due to intervening function parameter scope
};
void g(int = n); // error: n is not odr-usable due to intervening function parameter scope
[=](int k = n) {}; // error: n is not odr-usable due to being
// outside the block scope of thelambda-expression
[&] { [n]{ return n; }; }; // OK
}
—end example]
11 [Example 4:
void g() {
constexpr int x = 1;
auto lambda = [] <typename T, int = ((T)x, 0)> {}; // OK
lambda.operator()<int, 1>(); // OK, does not considerx at all
lambda.operator()<int>(); // OK, does not odr-usex
lambda.operator()<const int&>(); // error: odr-usesx from a context wherex is not odr-usable
}
void h() {
constexpr int x = 1;
auto lambda = [] <typename T> { (T)x; }; // OK
lambda.operator()<int>(); // OK, does not odr-usex
lambda.operator()<void>(); // OK, does not odr-usex
lambda.operator()<const int&>(); // error: odr-usesx from a context wherex is not odr-usable
}
—end example]
12 Every program shall contain at least one definition of every function or variable that is odr-used in that
program outside of a discarded statement (8.5.2); no diagnostic required. The definition can appear explicitly
in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly
defined (see 11.4.5.2, 11.4.5.3, 11.4.7, and 11.4.6).
[Example 5:
auto f() {
struct A {};
§ 6.3 © ISO/IEC
37

===== PAGE 49 =====

Dxxxx
return A{};
}
decltype(f()) g();
auto x = g();
A program containing this translation unit is ill-formed becauseg is odr-used but not defined, and cannot be defined
in any other translation unit because the local classA cannot be named outside this translation unit.—end example]
13 A definition domainis aprivate-module-fragment or the portion of a translation unit excluding itsprivate-
module-fragment (if any). A definition of an inline function or variable shall be reachable from the end of
every definition domain in which it is odr-used outside of a discarded statement.
14 A definition of a class shall be reachable in every context in which the class is used in a way that requires the
class type to be complete.
[Example 6: The following complete translation unit is well-formed, even though it never definesX:
struct X; // declareX as a struct type
struct X* x1; // useX in pointer formation
X* x2; // useX in pointer formation
—end example]
[Note 3: The rules for declarations and expressions describe in which contexts complete class types are required. A
class typeT must be complete if
—(14.1) an object of typeT is defined (6.2), or
—(14.2) a non-static class data member of typeT is declared (11.4), or
—(14.3) T is used as the allocated type or array element type in anew-expression (7.6.2.8), or
—(14.4) an lvalue-to-rvalue conversion is applied to a glvalue referring to an object of typeT (7.3.2), or
—(14.5) an expression is converted (either implicitly or explicitly) to typeT (7.3, 7.6.1.4, 7.6.1.7, 7.6.1.9, 7.6.3), or
—(14.6) anexpressionthatisnotanullpointerconstant, andhastypeotherthan cv void*, isconvertedtothetypepointer
to T or reference toT using a standard conversion (7.3), adynamic_cast (7.6.1.7) or astatic_cast (7.6.1.9), or
—(14.7) a class member access operator is applied to an expression of typeT (7.6.1.5), or
—(14.8) the typeid operator (7.6.1.8) or thesizeof operator (7.6.2.5) is applied to an operand of typeT, or
—(14.9) a function with a return type or argument type of typeT is defined (6.2) or called (7.6.1.3), or
—(14.10) a class with a base class of typeT is defined (11.7), or
—(14.11) an lvalue of typeT is assigned to (7.6.19), or
—(14.12) the typeT is the subject of analignof expression (7.6.2.6), or
—(14.13) an exception-declaration has typeT, reference toT, or pointer toT (14.4).
—end note]
15 If a definable itemD is defined in a translation unit by an injected declarationX (7.7) and another translation
unit contains a definition ofD, that definition shall be an injected declaration having the same characteristic
sequence asX; a diagnostic is required only ifD is attached to a named module and a prior definition is
reachable at the point where a later definition occurs.
16 For any other definable itemD with definitions in multiple translation units,
—(16.1) if D is a non-inline non-templated function or variable, or
—(16.2) if the definitions in different translation units do not satisfy the following requirements,
the program is ill-formed; a diagnostic is required only if the definable item is attached to a named module
and a prior definition is reachable at the point where a later definition occurs. Given such an item, for all
definitions ofD, or, ifD is an unnamed enumeration, for all definitions ofD that are reachable at any given
program point, the following requirements shall be satisfied.
—(16.3) Each such definition shall not be attached to a named module (10.1).
—(16.4) Each such definition shall consist of the same sequence of tokens, where the definition of a closure type
is considered to consist of the sequence of tokens of the correspondinglambda-expression.
—(16.5) In each such definition, corresponding names, looked up according to 6.5, shall denote the same entity,
after overload resolution (12.2) and after matching of partial template specializations (13.7.6.2), except
that a name can refer to
§ 6.3 © ISO/IEC
38

===== PAGE 50 =====

Dxxxx
—(16.5.1) a non-volatile const object with internal or no linkage if the object
—(16.5.1.1) has the same literal type in all definitions ofD,
—(16.5.1.2) is initialized with a constant expression (7.7),
—(16.5.1.3) is not odr-used in any definition ofD, and
—(16.5.1.4) has the same value in all definitions ofD,
or
—(16.5.2) a reference with internal or no linkage initialized with a constant expression such that the reference
refers to the same object or function in all definitions ofD.
—(16.6) In each such definition, except within the default arguments and default template arguments ofD,
corresponding lambda-expressions shall have the same closure type (see below).
—(16.7) In each such definition, corresponding entities shall have the same language linkage.
—(16.8) In each such definition, const objects with static or thread storage duration shall be constant-initialized
if the object is constant-initialized in any such definition.
—(16.9) In each such definition, corresponding manifestly constant-evaluated expressions that are not value-
dependent shall have the same value (7.7, 13.8.3.4).
—(16.10) In each such definition, the overloaded operators referred to, the implicit calls to conversion functions,
constructors, operator new functions and operator delete functions, shall refer to the same function.
—(16.11) In each such definition, a default argument used by an (implicit or explicit) function call or a default
templateargumentusedbyan(implicitorexplicit) template-id, simple-template-id, orsplice-specialization-
specifier is treated as if its token sequence were present in the definition ofD; that is, the default
argument or default template argument is subject to the requirements described in this paragraph
(recursively).
—(16.12) In each such definition, correspondingreflect-expressions (7.6.2.10) compute equivalent values (7.6.10).
17 For the purposes of the preceding requirements:
—(17.1) If D is a class with an implicitly-declared constructor (11.4.5.2, 11.4.5.3), it is as if the constructor was
implicitly defined in every translation unit where it is odr-used, and the implicit definition in every
translation unit shall call the same constructor for a subobject ofD.
[Example 7:
// translation unit 1:
struct X {
X(int, int);
X(int, int, int);
};
X::X(int, int = 0) { }
class D {
X x = 0;
};
D d1; // X(int, int) called byD()
// translation unit 2:
struct X {
X(int, int);
X(int, int, int);
};
X::X(int, int = 0, int = 0) { }
class D {
X x = 0;
};
D d2; // X(int, int, int) called byD();
// D()’s implicit definition violates the ODR
—end example]
—(17.2) If D is a class with a defaulted three-way comparison operator function (11.10.3), it is as if the operator
was implicitly defined in every translation unit where it is odr-used, and the implicit definition in every
translation unit shall call the same comparison operators for each subobject ofD.
§ 6.3 © ISO/IEC
39

===== PAGE 51 =====

Dxxxx
—(17.3) If D is a template and is defined in more than one translation unit, the requirements apply both to
names from the template’s enclosing scope used in the template definition, and also to dependent names
at the point of instantiation (13.8.3).
18 These requirements also apply to corresponding entities defined within each definition ofD (including the
closure types oflambda-expressions, but excluding entities defined within default arguments or default template
arguments of eitherD or an entity not defined withinD). For each such entity and forD itself, the behavior is
as if there is a single entity with a single definition, including in the application of these requirements to
other entities.
[Note 4: The entity is still declared in multiple translation units, and 6.7 still applies to these declarations. In
particular, lambda-expressions (7.5.6) appearing in the type ofD can result in the different declarations having distinct
types, and lambda-expressions appearing in a default argument ofD might still denote different types in different
translation units. —end note]
19 [Example 8:
inline void f(bool cond, void (*p)()) {
if (cond) f(false, []{});
}
inline void g(bool cond, void (*p)() = []{}) {
if (cond) g(false);
}
struct X {
void h(bool cond, void (*p)() = []{}) {
if (cond) h(false);
}
};
If the definition off appears in multiple translation units, the behavior of the program is as if there is only one
definition off. If the definition ofg appears in multiple translation units, the program is ill-formed (no diagnostic
required) because each such definition uses a default argument that refers to a distinctlambda-expression closure type.
The definition ofX can appear in multiple translation units of a valid program; thelambda-expressions defined within
the default argument ofX::h within the definition ofX denote the same closure type in each translation unit.—end
example]
20 If, at any point in the program, there is more than one reachable unnamed enumeration definition in the same
scope that have the same first enumerator name and do not have typedef names for linkage purposes (9.8.1),
those unnamed enumeration types shall be the same; no diagnostic required.
6.4 Scope [basic.scope]
6.4.1 General [basic.scope.scope]
1 The declarations in a program appear in a number ofscopesthat are in general discontiguous. Theglobal scope
contains the entire program; every other scopeS is introduced by a declaration,parameter-declaration-clause,
statement, handler, lambda-expression, or contract assertion (as described in the following subclauses of 6.4)
appearing in another scope, which thereby containsS. An enclosing scopeat a program point is any scope
that contains it; the smallest such scope is said to be theimmediate scopeat that point. A scopeintervenes
between a program pointP and a scopeS (that does not containP) if it is or containsS but does not
contain P.
2 Unless otherwise specified:
—(2.1) The smallest scope that contains a scopeS is theparent scopeof S.
—(2.2) No two declarations (re)introduce the same entity.
—(2.3) A declarationinhabits the immediate scope at its locus (6.4.2).
—(2.4) A declaration’starget scopeis the scope it inhabits.
—(2.5) Any names (re)introduced by a declaration arebound to it in its target scope.
The host scopeof a declaration is the inhabited scope if that scope is a block scope and the target scope
otherwise. An entitybelongs to a scopeS if S is the target scope of a declaration of the entity.
[Note 1: Special cases include that:
—(2.6) Template parameter scopes are parents only to other template parameter scopes (6.4.9).
—(2.7) Corresponding declarations with appropriate linkage declare the same entity (6.7).
§ 6.4.1 © ISO/IEC
40

===== PAGE 52 =====

Dxxxx
—(2.8) The declaration in atemplate-declaration inhabits the same scope as thetemplate-declaration.
—(2.9) Friend declarations and declarations of template specializations do not bind names (9.3.4); those with qualified
names target a specified scope, and other friend declarations and certainelaborated-type-specifiers (9.2.9.5)
target a larger enclosing scope.
—(2.10) Block-scope extern or function declarations target a larger enclosing scope but bind a name in their immediate
scope (9.3.4.1).
—(2.11) The names of unscoped enumerators are bound in the two innermost enclosing scopes (9.8.1).
—(2.12) A class’s name is also bound in its own scope (11.1).
—(2.13) The names of the members of an anonymous union are bound in the union’s parent scope (11.5.2).
—end note]
3 Two non-static member functions havecorresponding object parametersif
—(3.1) exactly one is an implicit object member function with noref-qualifier and the types of their object
parameters (9.3.4.6), after removing references, are the same, or
—(3.2) their object parameters have the same type.
Two non-static member function templates havecorresponding object parametersif
—(3.3) exactly one is an implicit object member function with noref-qualifier and the types of their object
parameters, after removing any references, are equivalent, or
—(3.4) the types of their object parameters are equivalent.
Two function templates havecorresponding signaturesif theirtemplate-parameter-lists have the same length,
their correspondingtemplate-parameters are equivalent, they have equivalent non-object-parameter-type-lists
and return types (if any), and, if both are non-static members, they have corresponding object parameters.
4 Two declarationscorrespond if they (re)introduce the same name, both declare constructors, or both declare
destructors, unless
—(4.1) either is ausing-declarator, or
—(4.2) one declares a type (not a type alias) and the other declares a variable, non-static data member other
than of an anonymous union (11.5.2), enumerator, function, or function template, or
—(4.3) each declares a function or function template and they do not declare corresponding overloads.
Two function or function template declarations declarecorresponding overloadsif
—(4.4) both declare functions with the same non-object-parameter-type-list,14 equivalent (13.7.7.2) trailing
requires-clauses (if any, except as specified in 13.7.5), and, if both are non-static members, they have
corresponding object parameters, or
—(4.5) both declare function templates with corresponding signatures and equivalenttemplate-heads and
trailing requires-clauses (if any).
[Note 2: Declarations can correspond even if neither binds a name.
[Example 1:
struct A {
friend void f(); // #1
};
struct B {
friend void f() {} // corresponds to, and defines, #1
};
—end example]
—end note]
[Example 2:
typedef int Int;
enum E : int { a };
void f(int); // #1
void f(Int) {} // defines #1
void f(E) {} // OK, another overload
14) An implicit object parameter (12.2.2) is not part of the parameter-type-list.
§ 6.4.1 © ISO/IEC
41

===== PAGE 53 =====

Dxxxx
struct X {
static void f();
void f() const; // error: redeclaration
void g();
void g() const; // OK
void g() &; // error: redeclaration
void h(this X&, int);
void h(int) &&; // OK, another overload
void j(this const X&);
void j() const &; // error: redeclaration
void k();
void k(this X&); // error: redeclaration
};
—end example]
5 A declaration isname-independent if its name is_ (u+005f low line) and it declares
—(5.1) a variable, other than a function parameter, with automatic storage duration,
—(5.2) a structured binding with nostorage-class-specifier and not inhabiting a namespace scope,
—(5.3) a result binding (9.4.2),
—(5.4) the variable introduced by aninit-capture, or
—(5.5) a non-static data member of other than an anonymous union.
Recommended practice: Implementations should not emit a warning that a name-independent declaration is
used or unused.
6 Two declarationspotentially conflict if they correspond and cause their shared name to denote different
entities (6.7). The program is ill-formed if, in any scope, a name is bound to two declarationsA and B that
potentially conflict andA precedes B (6.5), unlessB is name-independent.
[Note 3: An id-expression that names a unique name-independent declaration is usable until an additional declaration
of the same name is introduced in the same scope (6.5.1).—end note]
[Note 4: Overload resolution can consider potentially conflicting declarations found in multiple scopes (e.g., via
using-directives or for operator functions), in which case it is often ambiguous.—end note]
[Example 3:
void f() {
int x,y;
void x(); // error: different entity forx
int y; // error: redefinition
}
enum { f }; // error: different entity for::f
namespace A {}
namespace B = A;
namespace B = A; // OK, no effect
namespace B = B; // OK, no effect
namespace A = B; // OK, no effect
namespace B {} // error: different entity forB
void g() {
int _;
_ = 0; // OK
int _; // OK, name-independent declaration
_ = 0; // error: two non-function declarations in the lookup set
}
void h () {
int _; // #1
_ ++; // OK
static int _; // error: conflicts with #1 because static variables are not name-independent
}
—end example]
§ 6.4.1 © ISO/IEC
42

===== PAGE 54 =====

Dxxxx
7 A declaration isnominable in a class, class template, or namespaceE at a pointP if it precedesP, it does
not inhabit a block scope, and its target scope is the scope associated withE or, ifE is a namespace, any
element of the inline namespace set ofE (9.9.2).
[Example 4:
namespace A {
void f() {void g();}
inline namespace B {
struct S {
friend void h();
static int i;
};
}
}
At the end of this example, the declarations off, B, S, andh are nominable inA, but those ofg and i are not. —end
example]
8 When instantiating a templated entity (13.1), any scopeS introduced by any part of the template definition
is considered to be introduced by the instantiated entity and to contain the instantiations of any declarations
that inhabitS.
6.4.2 Point of declaration [basic.scope.pdecl]
1 The locus of a declaration (6.1) that is a declarator is immediately after the complete declarator (9.3).
[Example 1:
unsigned char x = 12;
{ unsigned char x = x; }
Here, the initialization of the secondx has undefined behavior, because the initializer accesses the secondx outside its
lifetime (6.8.4). —end example]
2 [Note 1: A name from an outer scope remains visible up to the locus of the declaration that hides it.
[Example 2:
const int i = 2;
{ int i[i]; }
declares a block-scope array of two integers.—end example]
—end note]
3 The locus of aclass-specifier is immediately after theidentifier or simple-template-id (if any) in itsclass-
head (11.1). The locus of anenum-specifier is immediately after itsenum-head; the locus of anopaque-enum-
declaration is immediately after it (9.8.1). The locus of analias-declaration is immediately after it.
4 The locus of ausing-declarator that does not name a constructor is immediately after theusing-declarator (9.10).
5 The locus of anenumerator-definition is immediately after it.
[Example 3:
const int x = 12;
{ enum { x = x }; }
Here, the enumeratorx is initialized with the value of the constantx, namely 12. —end example]
6 [Note 2: After the declaration of a class member, the member name can be found in the scope of its class even if the
class is an incomplete class.
[Example 4:
struct X {
enum E { z = 16 };
int b[X::z]; // OK
};
—end example]
—end note]
7 The locus of anelaborated-type-specifier that is a declaration (9.2.9.5) is immediately after it.
§ 6.4.2 © ISO/IEC
43

===== PAGE 55 =====

Dxxxx
8 The locus of an injected-class-name declaration (11.1) is immediately following the opening brace of the class
definition.
9 The locus of the implicit declaration of a function-local predefined variable (9.6.1) is immediately before the
function-body of its function’s definition.
10 The locus of the declaration of a structured binding (9.7) is immediately after theidentifier-list of the
structured binding declaration.
11 The locus of afor-range-declaration of a range-basedfor statement (8.6.5) is immediately after thefor-
range-initializer. The locus of afor-range-declaration of anexpansion-statement (8.7) is immediately after the
expansion-initializer.
12 The locus of atemplate-parameter is immediately after it.
[Example 5:
typedef unsigned char T;
template<class T
= T // lookup finds thetypedef-name
, T // lookup finds the template parameter
N = 0> struct A { };
—end example]
13 The locus of aresult-name-introducer (9.4.2) is immediately after it.
14 The locus of aconcept-definition is immediately after itsconcept-name (13.7.9).
[Note 3: The constraint-expression cannot use theconcept-name. —end note]
15 The locus of anamespace-definition with anidentifier is immediately after theidentifier.
[Note 4: An identifier is invented for anunnamed-namespace-definition (9.9.2.2). —end note]
16 [Note 5: Friend declarations can introduce functions or classes that belong to the nearest enclosing namespace or block
scope, but they do not bind names anywhere (11.8.4). Function declarations at block scope and variable declarations
with theextern specifier at block scope declare entities that belong to the nearest enclosing namespace, but they do
not bind names in it.—end note]
17 [Note 6: For point of instantiation of a template, see 13.8.4.1.—end note]
6.4.3 Block scope [basic.scope.block]
1 Each
—(1.1) selection, iteration, or expansion statement (8.5, 8.6, 8.7),
—(1.2) substatement of such a statement,
—(1.3) handler (14.1), or
—(1.4) compound statement (8.4) that is not thecompound-statement of ahandler
introduces ablock scopethat includes that statement orhandler.
[Note 1: A substatement that is also a block has only one scope.—end note]
A variable that belongs to a block scope is ablock variable.
[Example 1:
int i = 42;
int a[10];
for (int i = 0; i < 10; i++)
a[i] = i;
int j = i; // j = 42
—end example]
2 If a declaration that is not a name-independent declaration and that binds a name in the block scopeS of a
—(2.1) compound-statement of alambda-expression, function-body, orfunction-try-block,
—(2.2) substatement of a selection, iteration, or expansion statement that is not itself a selection, iteration, or
expansion statement, or
§ 6.4.3 © ISO/IEC
44

===== PAGE 56 =====

Dxxxx
—(2.3) handler of afunction-try-block
potentially conflicts with a declaration whose target scope is the parent scope ofS, the program is ill-formed.
[Example 2:
if (int x = f()) {
int x; // error: redeclaration ofx
}
else {
int x; // error: redeclaration ofx
}
—end example]
6.4.4 Function parameter scope [basic.scope.param]
1 A parameter-declaration-clause P introduces afunction parameter scopethat includesP.
[Note 1: A function parameter cannot be used for its value within theparameter-declaration-clause (9.3.4.7). —end
note]
—(1.1) If P is associated with adeclarator and is preceded by a (possibly-parenthesized)noptr-declarator of the
form declarator-id attribute-specifier-seqopt, its scope extends to the end of the nearest enclosinginit-
declarator, member-declarator, declarator of aparameter-declaration or anodeclspec-function-declaration,
or function-definition, but does not include the locus of the associateddeclarator.
[Note 2: In this case,P declares the parameters of a function (or a function or template parameter declared
with function type). A member function’s parameter scope is nested within its class’s scope.—end note]
—(1.2) If P is associated with alambda-declarator, its scope extends to the end of thecompound-statement of
the lambda-expression.
—(1.3) If P is associated with arequirement-parameter-list, its scope extends to the end of therequirement-body
of therequires-expression.
—(1.4) If P is associated with adeduction-guide, its scope extends to the end of thededuction-guide.
6.4.5 Lambda scope [basic.scope.lambda]
A lambda-expression E introduces alambda scopethat starts immediately after thelambda-introducer of E
and extends to the end of thecompound-statement of E.
6.4.6 Namespace scope [basic.scope.namespace]
1 Any namespace-definition for a namespaceN introduces anamespace scopethat includes thenamespace-body
for everynamespace-definition for N. For each non-friend redeclaration or specialization whose target scope is
or is contained by the scope, the portion after thedeclarator-id, class-head-name, orenum-head-name is also
included in the scope. The global scope is the namespace scope of the global namespace (9.9).
[Example 1:
namespace Q {
namespace V { void f(); }
void V::f() { // in the scope ofV
void h(); // declaresQ::V::h
}
}
—end example]
6.4.7 Class scope [basic.scope.class]
1 Any declaration of a class or class templateC introduces aclass scopethat includes themember-specification
of theclass-specifier for C (if any). For each non-friend redeclaration or specialization whose target scope is
or is contained by the scope, the portion after thedeclarator-id, class-head-name, orenum-head-name is also
included in the scope.
[Note 1: Lookup from a program point before theclass-specifier of a class will find no bindings in the class scope.
§ 6.4.7 © ISO/IEC
45

===== PAGE 57 =====

Dxxxx
[Example 1:
template<class D>
struct B {
D::type x; // #1
};
struct A { using type = int; };
struct C : A, B<C> {}; // error at #1:C::type not found
—end example]
—end note]
6.4.8 Enumeration scope [basic.scope.enum]
1 Any declaration of an enumerationE introduces anenumeration scopethat includes theenumerator-list of
the enum-specifier for E (if any).
6.4.9 Template parameter scope [basic.scope.temp]
1 Each type-tt-parameter, variable-tt-parameter, andconcept-tt-parameter introduces atemplate parameter scope
that includes thetemplate-head of thetemplate-parameter.
2 Each template-declaration D introduces a template parameter scope that extends from the beginning of its
template-parameter-list to the end of thetemplate-declaration. Any declaration outside thetemplate-parameter-
list that would inhabit that scope instead inhabits the same scope asD. The parent scope of any scopeS
that is not a template parameter scope is the smallest scope that containsS and is not a template parameter
scope.
[Note 1: Therefore, only template parameters belong to a template parameter scope, and only template parameter
scopes have a template parameter scope as a parent scope.—end note]
6.4.10 Contract-assertion scope [basic.scope.contract]
1 Each contract assertion (6.11)C introduces acontract-assertion scopethat includesC.
2 If aresult-name-introducer (9.4.2) that is not name-independent (6.4.1) and whose enclosing postcondition
assertion is associated with a functionF potentially conflicts with a declaration whose target scope is
—(2.1) the function parameter scope ofF or
—(2.2) if associated with alambda-declarator, the nearest enclosing lambda scope of the postcondition assertion
(7.5.6),
the program is ill-formed.
6.5 Name lookup [basic.lookup]
6.5.1 General [basic.lookup.general]
1 Name lookupassociates the use of a name with a set of declarations (6.2) of that name. The name lookup rules
apply uniformly to all names (includingtypedef-names (9.2.4),namespace-names (9.9), andclass-names (11.3))
wherever the grammar allows such names in the context discussed by a particular rule. Unless otherwise
specified, the program is ill-formed if no declarations are found. If the declarations found by name lookup
all denote functions or function templates, the declarations are said to form anoverload set. Otherwise,
if the declarations found by name lookup do not all denote the same entity, they areambiguous and the
program is ill-formed. Overload resolution (12.2, 12.3) takes place after name lookup has succeeded. The
access rules (11.8) are considered only once name lookup and function overload resolution (if applicable) have
succeeded. Only after name lookup, function overload resolution (if applicable) and access checking have
succeeded are the semantic properties introduced by the declarations used in further processing.
2 A program pointP is said to follow any declaration in the same translation unit whose locus (6.4.2) is before
P.
[Note 1: The declaration might appear in a scope that does not containP. —end note]
A declarationX precedesa program pointP in a translation unitL if P follows X, X inhabits a class scope
and is reachable fromP, or elseX appears in a translation unitD and
—(2.1) P follows amodule-import-declaration or module-declaration that importsD (directly or indirectly), and
§ 6.5.1 © ISO/IEC
46

===== PAGE 58 =====

Dxxxx
—(2.2) X appears after themodule-declaration in D (if any) and before theprivate-module-fragment in D (if
any), and
—(2.3) either X is exported or elseD and Lare part of the same module andX does not inhabit a namespace
with internal linkage or declare a name with internal linkage.
[Note 2: Names declared by ausing-declaration have no linkage.—end note]
[Note 3: A module-import-declaration imports both the named translation unit(s) and any modules named by exported
module-import-declarations within them, recursively.
[Example 1:
Translation unit #1:
export module Q;
export int sq(int i) { return i*i; }
Translation unit #2:
export module R;
export import Q;
Translation unit #3:
import R;
int main() { return sq(9); } // OK,sq from moduleQ
—end example]
—end note]
3 A single searchin a scopeS for a nameN from a program pointP finds all declarations that precedeP
to which any name that is the same asN (6.1) is bound inS. If any such declaration is ausing-declarator
whose terminal name (7.5.5.2) is not dependent (13.8.3.2), it is replaced by the declarations named by the
using-declarator (9.10).
4 In certain contexts, only certain kinds of declarations are included. After any such restriction, any declarations
of classes or enumerations are discarded if any other declarations are found.
[Note 4: A type (but not a type alias or template) is therefore hidden by any other entity in its scope.—end note]
However, if a lookup istype-only, only declarations of types and templates whose specializations are types are
considered; furthermore, if declarations of a type alias and of its underlying entity are found, the declaration
of the type alias is discarded instead of the type declaration.
6.5.2 Member name lookup [class.member.lookup]
1 A search in a scopeX for a nameM from a program pointP is a single search inX for M from P unless X
is the scope of a class or class templateT, in which case the following steps define the result of the search.
[Note 1: The result differs only ifM is aconversion-function-id or if the single search would find nothing.—end note]
2 The lookup setfor a nameN in a class or class templateC, calledS(N,C), consists of two component sets:
the declaration set, a set of members namedN; and thesubobject set, a set of subobjects where declarations
of these members were found (possibly viausing-declarations). In the declaration set, type declarations
(including injected-class-names) are replaced by the types they designate.S(N,C) is calculated as follows:
3 The declaration set is the result of a single search in the scope ofC for N from immediately after the
class-specifier of C if P is in a complete-class context ofC or fromP otherwise. If the resulting declaration
set is not empty, the subobject set containsC itself, and calculation is complete.
4 Otherwise (i.e.,C does not contain a declaration ofN or the resulting declaration set is empty),S(N,C) is
initially empty. Calculate the lookup set forN in each direct non-dependent (13.8.3.2) base class subobject
Bi, and merge each such lookup setS(N,Bi) in turn intoS(N,C).
[Note 2: If C is incomplete, only base classes whosebase-specifier appears before P are considered. If C is an
instantiated class, its base classes are not dependent.—end note]
5 The following steps define the result of merging lookup setS(N,Bi) into the intermediateS(N,C):
—(5.1) If each of the subobject members ofS(N,Bi) is a base class subobject of at least one of the subobject
members of S(N,C), or if S(N,Bi) is empty, S(N,C) is unchanged and the merge is complete.
Conversely, if each of the subobject members ofS(N,C) is a base class subobject of at least one of the
subobject members ofS(N,Bi), or ifS(N,C) is empty, the newS(N,C) is a copy ofS(N,Bi).
§ 6.5.2 © ISO/IEC
47

===== PAGE 59 =====

Dxxxx
—(5.2) Otherwise, if the declaration sets ofS(N,Bi) and S(N,C) differ, the merge is ambiguous: the new
S(N,C) is a lookup set with an invalid declaration set and the union of the subobject sets. In subsequent
merges, an invalid declaration set is considered different from any other.
—(5.3) Otherwise, the newS(N,C) is a lookup set with the shared set of declarations and the union of the
subobject sets.
6 The result of the search is the declaration set ofS(M,T ). If it is an invalid set, the program is ill-formed.
If it differs from the result of a search inT for M in a complete-class context (11.4) ofT, the program is
ill-formed, no diagnostic required.
[Example 1:
struct A { int x; }; // S(x,A) = { {A::x }, { A } }
struct B { float x; }; // S(x,B) = { {B::x }, { B } }
struct C: public A, public B { }; // S(x,C) = { invalid, {A in C, B in C } }
struct D: public virtual C { }; // S(x,D) = S(x,C)
struct E: public virtual C { char x; }; // S(x,E) = { {E::x }, { E } }
struct F: public D, public E { }; // S(x,F) = S(x,E)
int main() {
F f;
f.x = 0; // OK, lookup findsE::x
}
S(x,F) is unambiguous because theA and B base class subobjects ofD are also base class subobjects ofE, soS(x,D) is
discarded in the first merge step.—end example]
7 If M is a non-dependentconversion-function-id, conversion function templates that are members ofT are
considered. For each such templateF, the lookup setS(t,T) is constructed, considering a function template
declaration to have the namet only if it corresponds to a declaration ofF (6.4.1). The members of the
declaration set of each such lookup set, which shall not be an invalid set, are included in the result.
[Note 3: Overload resolution will discard those that cannot convert to the type specified byM (13.10.4). —end note]
8 [Note 4: A static member, a nested type or an enumerator defined in a base classT can unambiguously be found even
if an object has more than one base class subobject of typeT. Two base class subobjects share the non-static member
subobjects of their common virtual base classes.—end note]
[Example 2:
struct V {
int v;
};
struct A {
int a;
static int s;
enum { e };
};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void f(D* pd) {
pd->v++; // OK, only onev (virtual)
pd->s++; // OK, only ones (static)
int i = pd->e; // OK, only onee (enumerator)
pd->a++; // error: ambiguous: twoas in D
}
—end example]
9 [Note 5: When virtual base classes are used, a hidden declaration can be reached along a path through the subobject
lattice that does not pass through the hiding declaration. This is not an ambiguity. The identical use with non-virtual
base classes is an ambiguity; in that case there is no unique instance of the name that hides all the others.—end
note]
[Example 3:
struct V { int f(); int x; };
struct W { int g(); int y; };
§ 6.5.2 © ISO/IEC
48

===== PAGE 60 =====

Dxxxx
struct B : virtual V, W {
int f(); int x;
int g(); int y;
};
struct C : virtual V, W { };
struct D : B, C { void glorp(); };
W V W
B C
D
Figure 1 — Name lookup [fig:class.lookup]
As illustrated in Figure 1, the names declared inV and the left-hand instance ofW are hidden by those inB, but the
names declared in the right-hand instance ofW are not hidden at all.
void D::glorp() {
x++; // OK,B::x hides V::x
f(); // OK,B::f() hides V::f()
y++; // error: B::y and C’s W::y
g(); // error: B::g() and C’s W::g()
}
—end example]
10 An explicit or implicit conversion from a pointer to or an expression designating an object of a derived class
to a pointer or reference to one of its base classes shall unambiguously refer to a unique object representing
the base class.
[Example 4:
struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void g() {
D d;
B* pb = &d;
A* pa = &d; // error: ambiguous:C’s A or B’s A?
V* pv = &d; // OK, only oneV subobject
}
—end example]
11 [Note 6: Even if the result of name lookup is unambiguous, use of a name found in multiple subobjects might still be
ambiguous (7.3.13, 7.6.1.5, 11.8.3).—end note]
[Example 5:
struct B1 {
void f();
static void f(int);
int i;
};
struct B2 {
void f(double);
};
struct I1: B1 { };
struct I2: B1 { };
§ 6.5.2 © ISO/IEC
49

===== PAGE 61 =====

Dxxxx
struct D: I1, I2, B2 {
using B1::f;
using B2::f;
void g() {
f(); // Ambiguous conversion ofthis
f(0); // Unambiguous (static)
f(0.0); // Unambiguous (only oneB2)
int B1::* mpB1 = &D::i; // Unambiguous
int D::* mpD = &D::i; // Ambiguous conversion
}
};
—end example]
6.5.3 Unqualified name lookup [basic.lookup.unqual]
1 A using-directive is active in a scopeS at a program pointP if it precedesP and inhabits eitherS or the
scope of a namespace nominated by ausing-directive that is active inS at P.
2 An unqualified searchin a scopeS from a program pointP includes the results of searches fromP in
—(2.1) S, and
—(2.2) for any scopeU that containsP and is or is contained byS, each namespace contained byS that is
nominated by ausing-directive that is active inU at P.
If no declarations are found, the results of the unqualified search are the results of an unqualified search in
the parent scope ofS, if any, fromP.
[Note 1: When a class scope is searched, the scopes of its base classes are also searched (6.5.2). If it inherits from a
single base, it is as if the scope of the base immediately contains the scope of the derived class. Template parameter
scopes that are associated with one scope in the chain of parents are also considered (13.8.2).—end note]
3 Unqualified name lookupfrom a program point performs an unqualified search in its immediate scope.
4 An unqualified nameis a name that does not immediately follow anested-name-specifier or the. or -> in a
class member access expression (7.6.1.5), possibly after atemplate keyword or~. Unless otherwise specified,
such a name undergoes unqualified name lookup from the point where it appears.
5 An unqualified name that is a component name (7.5.5.2) of atype-specifier or ptr-operator of aconversion-
type-id is looked up in the same fashion as theconversion-function-id in which it appears. If that lookup finds
nothing, it undergoes unqualified name lookup; in each case, only names that denote types or templates
whose specializations are types are considered.
[Example 1:
struct T1 { struct U { int i; }; };
struct T2 { };
struct U1 {};
struct U2 {};
struct B {
using T = T1;
using U = U1;
operator U1 T1::*();
operator U1 T2::*();
operator U2 T1::*();
operator U2 T2::*();
};
template<class X, class T>
int g() {
using U = U2;
X().operator U T::*(); // #1, searches forT in the scope ofX first
X().operator U decltype(T())::*(); // #2
return 0;
}
int x = g<B, T2>(); // #1 callsB::operator U1 T1::*
// #2 callsB::operator U1 T2::*
§ 6.5.3 © ISO/IEC
50

===== PAGE 62 =====

Dxxxx
—end example]
6 In a friend declarationdeclarator whose declarator-id is aqualified-id whose lookup context (6.5.5) is a class or
namespace S, lookup for an unqualified name that appears after thedeclarator-id performs a search in the
scope associated withS. If that lookup finds nothing, it undergoes unqualified name lookup.
[Example 2:
using I = int;
using D = double;
namespace A {
inline namespace N {using C = char; }
using F = float;
void f(I);
void f(D);
void f(C);
void f(F);
}
struct X0 {using F = float; };
struct W {
using D = void;
struct X : X0 {
void g(I);
void g(::D);
void g(F);
};
};
namespace B {
typedef short I, F;
class Y {
friend void A::f(I); // error: novoid A::f(short)
friend void A::f(D); // OK
friend void A::f(C); // error: A::N::C not found
friend void A::f(F); // OK
friend void W::X::g(I); // error: novoid X::g(short)
friend void W::X::g(D); // OK
friend void W::X::g(F); // OK
};
}
—end example]
6.5.4 Argument-dependent name lookup [basic.lookup.argdep]
1 When thepostfix-expression in a function call (7.6.1.3) is anunqualified-id, and unqualified lookup (6.5.3) for
the name in theunqualified-id does not find any
—(1.1) declaration of a class member, or
—(1.2) function declaration inhabiting a block scope, or
—(1.3) declaration not of a function or function template
then lookup for the name also includes the result ofargument-dependent lookup in a set of associated
namespaces that depends on the types of the arguments (and for type template template arguments, the
namespace of the template argument), as specified below.
[Example 1:
namespace N {
struct S { };
void f(S);
}
void g() {
N::S s;
f(s); // OK, callsN::f
(f)(s); // error: N::f not considered; parentheses prevent argument-dependent lookup
}
§ 6.5.4 © ISO/IEC
51

===== PAGE 63 =====

Dxxxx
—end example]
2 [Note 1: For purposes of determining (during parsing) whether an expression is apostfix-expression for a function call,
the usual name lookup rules apply. In some cases a name followed by< is treated as atemplate-name even though
name lookup did not find atemplate-name (see 13.3). For example,
int h;
void g();
namespace N {
struct A {};
template <class T> int f(T);
template <class T> int g(T);
template <class T> int h(T);
}
int x = f<N::A>(N::A()); // OK, lookup off finds nothing,f treated as template name
int y = g<N::A>(N::A()); // OK, lookup ofg finds a function,g treated as template name
int z = h<N::A>(N::A()); // error: h< does not begin atemplate-id
The rules have no effect on the syntactic interpretation of an expression. For example,
typedef int f;
namespace N {
struct A {
friend void f(A &);
operator int();
void g(A a) {
int i = f(a); // f is the typedef, not the friend function: equivalent toint(a)
}
};
}
Because the expression is not a function call, argument-dependent name lookup does not apply and the friend function
f is not found. —end note]
3 For each argument typeT in the function call, there is a set of zero or moreassociated entitiesto be considered.
The set of entities is determined entirely by the types of the function arguments (and any type template
template arguments). Anytypedef-names andusing-declarations used to specify the types do not contribute
to this set. The set of entities is determined in the following way:
—(3.1) If Tisstd::meta::info(21.4.1), its associated set of entities is the singleton containing the enumeration
type std::meta::operators (21.4.5).
[Note 2: The std::meta::info type is a type alias, so an explicit rule is needed to associate calls whose
arguments are reflections with the namespacestd::meta. —end note]
—(3.2) If T is any other fundamental type, its associated set of entities is empty.
—(3.3) If T is a class type (including unions), its associated entities are: the class itself; the class of which it is
a member, if any; and, if it is a complete type, its direct and indirect base classes. Furthermore, ifT
is a class template specialization, its associated entities also include: the entities associated with the
types of the template arguments provided for template type parameters; the templates used as type
template template arguments; and the classes of which any member templates used as type template
template arguments are members.
[Note 3: Constant template arguments, variable template template arguments, and concept template arguments
do not contribute to the set of associated entities.—end note]
—(3.4) If T is an enumeration type, its associated entities areT and, if it is a class member, the member’s class.
—(3.5) If T is a pointer toU or an array ofU, its associated entities are those associated withU.
—(3.6) If T is a function type, its associated entities are those associated with the function parameter types
and those associated with the return type.
—(3.7) If T is a pointer to a member function of a classX, its associated entities are those associated with the
function parameter types and return type, together with those associated withX.
—(3.8) If T is a pointer to a data member of classX, its associated entities are those associated with the
member type together with those associated withX.
§ 6.5.4 © ISO/IEC
52

===== PAGE 64 =====

Dxxxx
In addition, if the argument is an overload set or the address of such a set, its associated entities are the union
of those associated with each of the members of the set, i.e., the entities associated with its parameter types
and return type. Additionally, if the aforementioned overload set is named with atemplate-id, its associated
entities also include its template template arguments and those associated with its type template arguments.
4 The associated namespacesfor a call are the innermost enclosing non-inline namespaces for its associated
entities as well as every element of the inline namespace set (9.9.2) of those namespaces. Argument-dependent
lookup finds all declarations of functions and function templates that
—(4.1) are found by a search of any associated namespace, or
—(4.2) are declared as a friend (11.8.4) of any class with a reachable definition in the set of associated entities,
or
—(4.3) are exported, are attached to a named moduleM (10.2), do not appear in the translation unit containing
the point of the lookup, and have the same innermost enclosing non-inline namespace scope as a
declaration of an associated entity attached toM (6.7).
If the lookup is for a dependent name (13.8.3, 13.8.4.2), the above lookup is also performed from each point in
the instantiation context (10.6) of the lookup, additionally ignoring any declaration that appears in another
translation unit, is attached to the global module, and is either discarded (10.4) or has internal linkage.
5 [Example 2:
Translation unit #1:
export module M;
namespace R {
export struct X {};
export void f(X);
}
namespace S {
export void f(R::X, R::X);
}
Translation unit #2:
export module N;
import M;
export R::X make();
namespace R { static int g(X); }
export template<typename T, typename U> void apply(T t, U u) {
f(t, u);
g(t);
}
Translation unit #3:
module Q;
import N;
namespace S {
struct Z { template<typename T> operator T(); };
}
void test() {
auto x = make(); // OK,decltype(x) is R::X in moduleM
R::f(x); // error: R and R::f are not visible here
f(x); // OK, callsR::f from interface ofM
f(x, S::Z()); // error: S::f in moduleM not considered
// even thoughS is an associated namespace
apply(x, S::Z()); // error: S::f is visible in instantiation context, but
// R::g has internal linkage and cannot be used outside TU #2
}
—end example]
6 [Note 4: The set of associated namespaces can include namespaces already considered by ordinary unqualified lookup.
—end note]
[Example 3:
§ 6.5.4 © ISO/IEC
53

===== PAGE 65 =====

Dxxxx
namespace NS {
class T { };
void f(T);
void g(T, int);
}
NS::T parm;
void g(NS::T, float);
int main() {
f(parm); // OK, callsNS::f
extern void g(NS::T, float);
g(parm, 1); // OK, callsg(NS::T, float)
}
—end example]
6.5.5 Qualified name lookup [basic.lookup.qual]
6.5.5.1 General [basic.lookup.qual.general]
1 Lookup of anidentifier followed by a:: scope resolution operator considers only namespaces, types, and
templates whose specializations are types. If a name,template-id, splice-scope-specifier, orcomputed-type-
specifier is followed by a::, it shall either be a dependentsplice-scope-specifier (13.8.3.5) or it shall designate
a namespace, class, enumeration, or dependent type, and the:: is never interpreted as a completenested-
name-specifier.
[Example 1:
class A {
public:
static int n;
};
int main() {
int A;
A::n = 42; // OK
A b; // error: A does not name a type
}
template<int> struct B : A {};
namespace N {
template<int> void B();
int f() {
return B<0>::n; // error: N::B<0> is not a type
}
}
—end example]
2 A member-qualified nameis the (unique) component name (7.5.5.2), if any, of
—(2.1) an unqualified-id or
—(2.2) a nested-name-specifier of the formtype-name :: or namespace-name ::
in theid-expression of a class member access expression (7.6.1.5). Aqualified nameis
—(2.3) a member-qualified name or
—(2.4) the terminal name of
—(2.4.1) a qualified-id,
—(2.4.2) a using-declarator,
—(2.4.3) a typename-specifier,
—(2.4.4) a qualified-namespace-specifier, or
—(2.4.5) a nested-name-specifier, reflection-name, elaborated-type-specifier, orclass-or-decltype that has a
nested-name-specifier (7.5.5.3).
The lookup contextof a member-qualified name is the type of its associated object expression (considered
dependent if the object expression is type-dependent). The lookup context of any other qualified name is the
type, template, or namespace nominated by the precedingnested-name-specifier.
§ 6.5.5.1 © ISO/IEC
54

===== PAGE 66 =====

Dxxxx
[Note 1: When parsing a class member access, the name following the-> or . is a qualified name even though it is
not yet known of which kind.—end note]
[Example 2: In
N::C::m.Base::f()
Base is a member-qualified name; the other qualified names areC, m, andf. —end example]
3 Qualified name lookupin a class, namespace, or enumeration performs a search of the scope associated with
it (6.5.2) except as specified below. Unless otherwise specified, a qualified name undergoes qualified name
lookup in its lookup context from the point where it appears unless the lookup context either is dependent
and is not the current instantiation (13.8.3.2) or is not a class or class template. If nothing is found by
qualified lookup for a member-qualified name that is the terminal name (7.5.5.2) of anested-name-specifier
and is not dependent, it undergoes unqualified lookup.
[Note 2: During lookup for a template specialization, no names are dependent.—end note]
[Example 3:
int f();
struct A {
int B, C;
template<int> using D = void;
using T = void;
void f();
};
using B = A;
template<int> using C = A;
template<int> using D = A;
template<int> using X = A;
template<class T>
void g(T *p) { // as instantiated forg<A>:
p->X<0>::f(); // error: A::X not found in((p->X) < 0) > ::f()
p->template X<0>::f(); // OK,::X found in definition context
p->B::f(); // OK, non-typeA::B ignored
p->template C<0>::f(); // error: A::C is not a template
p->template D<0>::f(); // error: A::D<0> is not a class type
p->T::f(); // error: A::T is not a class type
}
template void g(A*);
—end example]
4 If a qualified nameQ follows a~:
—(4.1) If Q is a member-qualified name, it undergoes unqualified lookup as well as qualified lookup.
—(4.2) Otherwise, itsnested-name-specifier N shall nominate a type. IfN has anothernested-name-specifier S,
Q is looked up as if its lookup context were that nominated byS.
—(4.3) Otherwise, if the terminal name ofN is a member-qualified nameM, Qis looked up as if~Qappeared
in place ofM (as above).
—(4.4) Otherwise, Q undergoes unqualified lookup.
—(4.5) Each lookup forQconsiders only types (ifQis not followed by a<) and templates whose specializations
are types. If it finds nothing or is ambiguous, it is discarded.
—(4.6) The type-name that is or containsQshall refer to its (original) lookup context (ignoring cv-qualification)
under the interpretation established by at least one (successful) lookup performed.
[Example 4:
struct C {
typedef int I;
};
typedef int I1, I2;
extern int* p;
extern int* q;
void f() {
p->C::I::~I(); // I is looked up in the scope ofC
§ 6.5.5.1 © ISO/IEC
55

===== PAGE 67 =====

Dxxxx
q->I1::~I2(); // I2 is found by unqualified lookup
}
struct A {
~A();
};
typedef A AB;
int main() {
AB* p;
p->AB::~AB(); // explicitly calls the destructor forA
}
—end example]
6.5.5.2 Class members [class.qual]
1 In a lookup for a qualified nameN whose lookup context is a classC in which function names are not
ignored,15
—(1.1) if the search finds the injected-class-name ofC (11.1), or
—(1.2) if N is dependent and is the terminal name of ausing-declarator (9.10) that names a constructor,
N is instead considered to name the constructor of classC. Such a constructor name shall be used only in
the declarator-id of a (friend) declaration of a constructor or in ausing-declaration.
[Example 1:
struct A { A(); };
struct B: public A { B(); };
A::A() { }
B::B() { }
B::A ba; // object of typeA
A::A a; // error: A::A is not a type name
struct A::A a2; // object of typeA
—end example]
6.5.5.3 Namespace members [namespace.qual]
1 Qualified name lookup in a namespaceN additionally searches every element of the inline namespace set
of N (9.9.2). If nothing is found, the results of the lookup are the results of qualified name lookup in each
namespace nominated by ausing-directive that precedes the point of the lookup and inhabitsN or an element
of N’s inline namespace set.
[Note 1: If a using-directive refers to a namespace that has already been considered, it does not affect the result.
—end note]
[Example 1:
int x;
namespace Y {
void f(float);
void h(int);
}
namespace Z {
void h(double);
}
namespace A {
using namespace Y;
void f(int);
void g(int);
int i;
}
15) Lookups in which function names are ignored include names appearing in anested-name-specifier, anelaborated-type-specifier,
or abase-specifier.
§ 6.5.5.3 © ISO/IEC
56

===== PAGE 68 =====

Dxxxx
namespace B {
using namespace Z;
void f(char);
int i;
}
namespace AB {
using namespace A;
using namespace B;
void g();
}
void h()
{
AB::g(); // g is declared directly inAB, thereforeS is {AB::g()}and AB::g() is chosen
AB::f(1); // f is not declared directly inAB so the rules are applied recursively toA and B;
// namespaceY is not searched andY::f(float) is not considered;
// S is {A::f(int),B::f(char)}and overload resolution choosesA::f(int)
AB::f('c'); // as above but resolution choosesB::f(char)
AB::x++; // x is not declared directly inAB, and is not declared inA or B, so the rules
// are applied recursively toY and Z, S is {}so the program is ill-formed
AB::i++; // i is not declared directly inAB so the rules are applied recursively toA and B,
// S is {A::i,B::i}so the use is ambiguous and the program is ill-formed
AB::h(16.8); // h is not declared directly inAB and not declared directly inA or B so the rules
// are applied recursively toY and Z, S is {Y::h(int),Z::h(double)}and
// overload resolution choosesZ::h(double)
}
—end example]
2 [Note 2: The same declaration found more than once is not an ambiguity (because it is still a unique declaration).
[Example 2:
namespace A {
int a;
}
namespace B {
using namespace A;
}
namespace C {
using namespace A;
}
namespace BC {
using namespace B;
using namespace C;
}
void f()
{
BC::a++; // OK,S is {A::a,A::a}
}
namespace D {
using A::a;
}
§ 6.5.5.3 © ISO/IEC
57

===== PAGE 69 =====

Dxxxx
namespace BD {
using namespace B;
using namespace D;
}
void g()
{
BD::a++; // OK,S is {A::a,A::a}
}
—end example]
—end note]
3 [Example 3: Because each referenced namespace is searched at most once, the following is well-defined:
namespace B {
int b;
}
namespace A {
using namespace B;
int a;
}
namespace B {
using namespace A;
}
void f()
{
A::a++; // OK,a declared directly inA, S is {A::a}
B::a++; // OK, bothA and B searched (once),S is {A::a}
A::b++; // OK, bothA and B searched (once),S is {B::b}
B::b++; // OK,b declared directly inB, S is {B::b}
}
—end example]
4 [Note 3: Class and enumeration declarations are not discarded because of other declarations found in other searches.
—end note]
[Example 4:
namespace A {
struct x { };
int x;
int y;
}
namespace B {
struct y { };
}
namespace C {
using namespace A;
using namespace B;
int i = C::x; // OK,A::x (of typeint)
int j = C::y; // ambiguous,A::y or B::y
}
—end example]
6.5.6 Elaborated type specifiers [basic.lookup.elab]
1 If theclass-key or enum keyword in anelaborated-type-specifier is followed by anidentifier that is not followed
by ::, lookup for theidentifier is type-only (6.5.1).
[Note 1: In general, the recognition of anelaborated-type-specifier depends on the following tokens. If theidentifier is
followed by::, see 6.5.5. —end note]
§ 6.5.6 © ISO/IEC
58

===== PAGE 70 =====

Dxxxx
2 If the terminal name of anelaborated-type-specifier is a qualified name, lookup for it is type-only. If the name
lookup does not find a previously declaredtype-name, theelaborated-type-specifier is ill-formed.
3 [Example 1:
struct Node {
struct Node* Next; // OK, refers to injected-class-nameNode
struct Data* Data; // OK, declares typeData at global scope and memberData
};
struct Data {
struct Node* Node; // OK, refers toNode at global scope
friend struct ::Glob; // error: Glob is not declared, cannot introduce a qualified type (9.2.9.5)
friend struct Glob; // OK, refers to (as yet) undeclaredGlob at global scope.
/* ... */
};
struct Base {
struct Data; // OK, declares nestedData
struct ::Data* thatData; // OK, refers to::Data
struct Base::Data* thisData; // OK, refers to nestedData
friend class ::Data; // OK, globalData is a friend
friend class Data; // OK, nestedData is a friend
struct Data { /* ... */ }; // Defines nestedData
};
struct Data; // OK, redeclaresData at global scope
struct ::Data; // error: cannot introduce a qualified type (9.2.9.5)
struct Base::Data; // error: cannot introduce a qualified type (9.2.9.5)
struct Base::Datum; // error: Datum undefined
struct Base::Data* pBase; // OK, refers to nestedData
—end example]
6.5.7 Using-directives and namespace aliases [basic.lookup.udir]
1 In ausing-directive or namespace-alias-definition, during the lookup for anamespace-name or for a name in a
nested-name-specifier only namespace names are considered.
6.6 Splice specifiers [basic.splice]
splice-specifier:
[: constant-expression :]
splice-specialization-specifier:
splice-specifier < template-argument-listopt >
1 The constant-expression of asplice-specifier shall be a converted constant expression of typestd::meta::info
(7.7). A splice-specifier whose convertedconstant-expression represents a constructX is said todesignate
either
—(1.1) the underlying entity ofX if X is an entity (6.1), or
—(1.2) X otherwise.
[Note 1: A splice-specifier is dependent if the convertedconstant-expression is value-dependent (13.8.3.5).—end note]
2 A non-dependentsplice-specifier of asplice-specialization-specifier shall designate a template.
3 [Note 2: A< following asplice-specifier is interpreted as the delimiter of atemplate-argument-list when thesplice-specifier
is preceded by the keywordtemplate or the keywordtypename, or when it appears in a type-only context (13.3).
[Example 1:
constexpr int v = 1;
template<int V> struct TCls {
static constexpr int s = V + 1;
};
using alias = [:^^TCls:]<([:^^v:])>;
// OK, asplice-specialization-specifier with a parenthesizedsplice-expression as a template argument
§ 6.6 © ISO/IEC
59

===== PAGE 71 =====

Dxxxx
static_assert(alias::s == 2);
auto o1 = [:^^TCls:]<([:^^v:])>(); // error: < means less than
auto o2 = typename [:^^TCls:]<([:^^v:])>(); // OK,o2 is an object of typeTCls<1>
consteval int bad_splice(std::meta::info v) {
return [:v:]; // error: v is not constant
}
—end example]
—end note]
6.7 Program and linkage [basic.link]
1 A programconsists of one or more translation units (5.2) that are translated and linked together. A translation
unit consists of a sequence of declarations.
translation-unit:
declaration-seqopt
global-module-fragmentopt module-declaration declaration-seqopt private-module-fragmentopt
2 A name hasexternal linkage, module linkage, internal linkage, or no linkage, as determined by the rules
below.
[Note 1: All declarations of an entity with a name with internal linkage appear in the same translation unit. All
declarations of an entity with module linkage are attached to the same module.—end note]
3 The name of an entity that belongs to a namespace scope (6.4.6) has internal linkage if it is the name of
—(3.1) a variable, variable template, function, or function template that is explicitly declaredstatic; or
—(3.2) a non-template variable of non-volatile const-qualified type, unless
—(3.2.1) it is declared in the purview of a module interface unit (outside theprivate-module-fragment, if
any) or module partition, or
—(3.2.2) it is explicitly declaredextern, or
—(3.2.3) it is inline, or
—(3.2.4) it was previously declared and the prior declaration did not have internal linkage; or
—(3.3) a data member of an anonymous union.
[Note 2: An instantiated variable template that has const-qualified type can have external or module linkage, even if
not declaredextern. —end note]
4 An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has
internal linkage. All other namespaces have external linkage. The name of an entity that belongs to a
namespace scope, that has not been given internal linkage above, and that is the name of
—(4.1) a variable; or
—(4.2) a function; or
—(4.3) a named class (11.1), or an unnamed class defined in a typedef declaration in which the class has the
typedef name for linkage purposes (9.2.4); or
—(4.4) a named enumeration (9.8.1), or an unnamed enumeration defined in a typedef declaration in which
the enumeration has the typedef name for linkage purposes (9.2.4); or
—(4.5) an unnamed enumeration that has an enumerator as a name for linkage purposes (9.8.1); or
—(4.6) a template
has its linkage determined as follows:
—(4.7) if the entity is a function or function template first declared in a friend declaration and that declaration
is a definition and the enclosing class is defined within anexport-declaration, the name has the same
linkage, if any, as the name of the enclosing class (11.8.4);
—(4.8) otherwise, if the entity is a function or function template declared in a friend declaration and a
corresponding non-friend declaration is reachable, the name has the linkage determined from that prior
declaration,
—(4.9) otherwise, if the enclosing namespace has internal linkage, the name has internal linkage;
§ 6.7 © ISO/IEC
60

===== PAGE 72 =====

Dxxxx
—(4.10) otherwise, if the declaration of the name is attached to a named module (10.1) and is not exported (10.2),
the name has module linkage;
—(4.11) otherwise, the name has external linkage.
5 In addition, a member function, a static data member, a named class or enumeration that inhabits a class
scope, or an unnamed class or enumeration defined in a typedef declaration that inhabits a class scope such
that the class or enumeration has the typedef name for linkage purposes (9.2.4), has the same linkage, if any,
as the name of the class of which it is a member.
6 [Example 1:
static void f();
extern "C" void h();
static int i = 0; // #1
void q() {
extern void f(); // internal linkage
extern void g(); // ::g, external linkage
extern void h(); // C language linkage
int i; // #2: i has no linkage
{
extern void f(); // internal linkage
extern int i; // #3: internal linkage
}
}
Even though the declaration at line #2 hides the declaration at line #1, the declaration at line #3 still redeclares #1
and receives internal linkage.—end example]
7 Names not covered by these rules have no linkage. Moreover, except as noted, a name declared at block
scope (6.4.3) has no linkage.
8 Two declarations of entities declare the same entity if, considering declarations of unnamed types to introduce
their names for linkage purposes, if any (9.2.4, 9.8.1), they correspond (6.4.1), have the same target scope
that is not a function or template parameter scope, neither is a name-independent declaration, and either
—(8.1) they appear in the same translation unit, or
—(8.2) they both declare type aliases or namespace aliases that have the same underlying entity, or
—(8.3) they both declare names with module linkage and are attached to the same module, or
—(8.4) they both declare names with external linkage.
[Note 3: There are other circumstances in which declarations declare the same entity (9.12, 13.6, 13.7.6).—end note]
9 If a declarationH that declares a name with internal linkage precedes a declarationD in another translation
unit U and would declare the same entity asD if it appeared inU, the program is ill-formed.
[Note 4: Such anH can appear only in a header unit.—end note]
10 If two declarations of an entity are attached to different modules, the program is ill-formed; no diagnostic is
required if neither is reachable from the other.
[Example 2:
"decls.h":
int f(); // #1, attached to the global module
int g(); // #2, attached to the global module
Module interface ofM:
module;
#include "decls.h"
export module M;
export using ::f; // OK, does not declare an entity, exports #1
int g(); // error: matches #2, but attached toM
export int h(); // #3
export int k(); // #4
Other translation unit:
import M;
§ 6.7 © ISO/IEC
61

===== PAGE 73 =====

Dxxxx
static int h(); // error: matches #3
int k(); // error: matches #4
—end example]
As a consequence of these rules, all declarations of an entity are attached to the same module; the entity is
said to beattached to that module.
11 For any two declarations of an entityE:
—(11.1) If one declaresE to be a variable or function, the other shall declareE as one of the same type.
—(11.2) If one declaresE to be an enumerator, the other shall do so.
—(11.3) If one declaresE to be a namespace, the other shall do so.
—(11.4) If one declaresE to be a type, the other shall declareE to be a type of the same kind (9.2.9.5).
—(11.5) If one declaresE to be a class template, the other shall do so with the same kind and an equivalent
template-head (13.7.7.2).
[Note 5: The declarations can supply different default template arguments.—end note]
—(11.6) If one declaresE to be a function template or a (partial specialization of a) variable template, the other
shall declareE to be one with an equivalenttemplate-head and type.
—(11.7) If one declaresE to be an alias template, the other shall declareE to be one with an equivalent
template-head and defining-type-id.
—(11.8) If one declaresE to be a concept, the other shall do so.
Types are compared after all adjustments of types (during which type aliases (9.2.4) are replaced by the types
they denote); declarations for an array object can specify array types that differ by the presence or absence
of a major array bound (9.3.4.5). No diagnostic is required if neither declaration is reachable from the other.
[Example 3:
int f(int x, int x); // error: different entities forx
void g(); // #1
void g(int); // OK, different entity from #1
int g(); // error: same entity as #1 with different type
void h(); // #2
namespace h {} // error: same entity as #2, but not a function
—end example]
12 [Note 6: Linkage to non-C++ declarations can be achieved using alinkage-specification (9.12). —end note]
13 A declarationD names an entityE if
—(13.1) D contains alambda-expression whose closure type isE,
—(13.2) D contains areflect-expression or asplice-specifier that, respectively, represents or designatesE,
—(13.3) D is an injected declaration (7.7) whose characteristic sequence contains a reflection that represents a
data member description (T, N, A, W, NUA) (11.4.1) for whichT is E,
—(13.4) E is not a function or function template andD contains anid-expression, type-specifier, nested-name-
specifier, template-name, orconcept-name denoting E, or
—(13.5) E is a function or function template andDcontains an expression that namesE (6.3) or anid-expression
that refers to a set of overloads that containsE.
[Note 7: Non-dependent names in an instantiated declaration do not refer to a set of overloads (13.8).—end
note]
14 A declaration is anexposure if it either names a TU-local entity (defined below), ignoring
—(14.1) the function-body for a non-inline function or function template (but not the deduced return type for
a (possibly instantiated) definition of a function with a declared return type that uses a placeholder
type (9.2.9.7)),
—(14.2) the initializer for a variable or variable template (but not the variable’s type),
—(14.3) friend declarations in a class definition, and
—(14.4) any reference to a non-volatile const object or reference with internal or no linkage initialized with a
constant expression that is not an odr-use (6.3),
§ 6.7 © ISO/IEC
62

===== PAGE 74 =====

Dxxxx
or defines a constexpr variable initialized to a TU-local value (defined below).
[Note 8: An inline function template can be an exposure even though certain explicit specializations of it would be
usable in other translation units.—end note]
15 An entity isTU-local if it is
—(15.1) a type, type alias, namespace, namespace alias, function, variable, or template that
—(15.1.1) has a name with internal linkage, or
—(15.1.2) does not have a name with linkage and is declared, or introduced by alambda-expression, within
the definition of a TU-local entity,
—(15.2) a type with no name that is defined outside aclass-specifier, function body, orinitializer or is introduced
by adefining-type-specifier that is used to declare only TU-local entities,
—(15.3) a specialization of a TU-local template,
—(15.4) a specialization of a template with any TU-local template argument, or
—(15.5) a specialization of a template whose (possibly instantiated) declaration is an exposure.
[Note 9: A specialization can be produced by implicit or explicit instantiation.—end note]
16 A value or object isTU-local if either
—(16.1) it is of TU-local type,
—(16.2) it is, or is a pointer to, a TU-local function or the object associated with a TU-local variable,
—(16.3) it is an object of class or array type and any of its subobjects or any of the objects or functions to which
its non-static data members of reference type refer is TU-local and is usable in constant expressions, or
—(16.4) it is a reflection value (6.9.2) that represents
—(16.4.1) an entity, value, or object that is TU-local,
—(16.4.2) an annotation (9.13.12),
—(16.4.3) a direct base class relationship(D,B) (11.7.1) for which eitherD or B is TU-local, or
—(16.4.4) a data member description(T,N,A,W, NUA) (11.4.1) for whichT is TU-local.
17 If a (possibly instantiated) declaration of, or a deduction guide for, a non-TU-local entity in a module
interface unit (outside theprivate-module-fragment, if any) or module partition (10.1) is an exposure, the
program is ill-formed. Such a declaration in any other context is deprecated (D.2).
18 If a declaration that appears in one translation unit names a TU-local entity declared in another translation
unit that is not a header unit, the program is ill-formed. A declaration instantiated for a template
specialization (13.9) appears at the point of instantiation of the specialization (13.8.4.1).
19 [Example 4:
Translation unit #1:
export module A;
static void f() {}
inline void it() { f(); } // error: is an exposure off
static inline void its() { f(); } // OK
template<int> void g() { its(); } // OK
template void g<0>();
decltype(f) *fp; // error: f (though not its type) is TU-local
auto &fr = f; // OK
constexpr auto &fr2 = fr; // error: is an exposure off
constexpr static auto fp2 = fr; // OK
struct S { void (&ref)(); } s{f}; // OK, value is TU-local
constexpr extern struct W { S &s; } wrap{s}; // OK, value is not TU-local
static auto x = []{f();}; // OK
auto x2 = x; // error: the closure type is TU-local
int y = ([]{f();}(),0); // error: the closure type is not TU-local
int y2 = (x,0); // OK
§ 6.7 © ISO/IEC
63

===== PAGE 75 =====

Dxxxx
namespace N {
struct A {};
void adl(A);
static void adl(int);
}
void adl(double);
inline void h(auto x) { adl(x); } // OK, but certain specializations are exposures
constexpr std::meta::info r1 = ^^g<0>; // OK
namespace N2 {
static constexpr std::meta::info r2 = ^^g<1>; // OK,r2 is TU-local
}
constexpr std::meta::info r3 = ^^f; // error: r3 is an exposure off
constexpr auto ctx = std::meta::access_context::current();
constexpr std::meta::info r4 =
std::meta::members_of(^^N2, ctx)[0]; // error: r4 is an exposure ofN2::r2
Translation unit #2:
module A;
void other() {
g<0>(); // OK, specialization is explicitly instantiated
g<1>(); // error: instantiation uses TU-localits
h(N::A{}); // error: overload set contains TU-localN::adl(int)
h(0); // OK, callsadl(double)
adl(N::A{}); // OK;N::adl(int) not found, callsN::adl(N::A)
fr(); // OK, callsf
constexpr auto ptr = fr; // error: fr is not usable in constant expressions here
}
—end example]
6.8 Memory and objects [basic.memobj]
6.8.1 Memory model [intro.memory]
1 The fundamental storage unit in the C++ memory model is thebyte. A byte is at least large enough to
contain the ordinary literal encoding of any element of the basic literal character set (5.3.1) and the eight-bit
code units of the Unicode UTF-8 encoding form and is composed of a contiguous sequence of bits, the number
of which is implementation-defined.
[Note 1: See the macroCHAR_BIT in the header<climits> (17.3.6). —end note]
The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte
has a unique address.
2 [Note 2: The representation of types is described in 6.9.1.—end note]
3 A memory locationis the storage occupied by the object representation of either an object of scalar type that
is not a bit-field or a maximal sequence of adjacent bit-fields all having nonzero width.
[Note 3: Various features of the language, such as references and virtual functions, might involve additional memory
locations that are not accessible to programs but are managed by the implementation.—end note]
Two or more threads of execution (6.10.2) can access separate memory locations without interfering with
each other.
4 [Note 4: Thus a bit-field and an adjacent non-bit-field are in separate memory locations, and therefore can be
concurrently updated by two threads of execution without interference. The same applies to two bit-fields, if one is
declared inside a nested struct declaration and the other is not, or if the two are separated by a zero-length bit-field
declaration, or if they are separated by a non-bit-field declaration. It is not safe to concurrently update two bit-fields
in the same struct if all fields between them are also bit-fields of nonzero width.—end note]
5 [Example 1: A class declared as
struct {
char a;
§ 6.8.1 © ISO/IEC
64

===== PAGE 76 =====

Dxxxx
int b:5,
c:11,
:0,
d:8;
struct {int ee:8;} e;
};
contains four separate memory locations: The membera and bit-fieldsd and e.ee each occupy separate memory
locations, and can be modified concurrently without interfering with each other. The bit-fieldsb and c together
occupy the fourth memory location. The bit-fieldsb and c cannot be concurrently modified, butb and a, for example,
can be. —end example]
6.8.2 Object model [intro.object]
1 The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. Anobject is
created by a definition (6.2), by anew-expression (7.6.2.8), by an operation that implicitly creates objects
(see below), when implicitly changing the active member of a union (11.5), or when a temporary object is
created (7.3.5, 6.8.7). An object occupies a region of storage in its period of construction (11.9.5), throughout
its lifetime (6.8.4), and in its period of destruction (11.9.5).
[Note 1: A function is not an object, regardless of whether or not it occupies storage in the way that objects do.
—end note]
The properties of an object are determined when the object is created. An object can have a name (6.1). An
object has a storage duration (6.8.6) which influences its lifetime (6.8.4). An object has a type (6.9).
[Note 2: Some objects are polymorphic (11.7.3); the implementation generates information associated with each such
object that makes it possible to determine that object’s type during program execution.—end note]
2 Objects can contain other objects, calledsubobjects. A subobject can be amember subobject(11.4), abase
class subobject(11.7), or an array element. An object that is not a subobject of any other object is called a
complete object. If an object is created in storage associated with a subobjecte (which may or may not be
within its lifetime), the created object is a subobject ofe’s containing object if
—(2.1) the lifetime ofe’s containing object has begun and not ended, and
—(2.2) the storage for the new object exactly overlays the storage location associated withe, and
—(2.3) e is not a potentially-overlapping subobject, and
—(2.4) the new object is of the same type ase (ignoring cv-qualification).
In this case,e and the created object arecorresponding direct subobjects.
3 If a complete object is created (7.6.2.8) in storage associated with another objecte of type “array ofN
unsigned char” or of type “array ofN std::byte” (17.2.1), that arrayprovides storagefor the created
object if
—(3.1) the lifetime ofe has begun and not ended, and
—(3.2) the storage for the new object fits entirely withine, and
—(3.3) there is no array object that satisfies these constraints nested withine.
[Note 3: If that portion of the array previously provided storage for another object, the lifetime of that object ends
because its storage was reused (6.8.4).—end note]
[Example 1:
// assumes thatsizeof(int) is equal to 4
template<typename ...T>
struct AlignedUnion {
alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
AlignedUnion<int, char> au;
int *p = new (au.data) int; // OK,au.data provides storage
char *c = new (au.data) char(); // OK, ends lifetime of*p
char *d = new (au.data + 1) char();
return *c + *d; // OK
}
§ 6.8.2 © ISO/IEC
65

===== PAGE 77 =====

Dxxxx
struct A { unsigned char a[32]; };
struct B { unsigned char b[16]; };
alignas(int) A a;
B *b = new (a.a + 8) B; // a.a provides storage for*b
int *p = new (b->b + 4) int; // b->b provides storage for*p
// a.a does not provide storage for*p (directly),
// but *p is nested withina (see below)
—end example]
4 An objecta is nested withinanother objectb if
—(4.1) a is a subobject ofb, or
—(4.2) b provides storage fora, or
—(4.3) there exists an objectc where a is nested withinc, andc is nested withinb.
5 For every objectx, there is some object called thecomplete object ofx, determined as follows:
—(5.1) If x is a complete object, then the complete object ofx is itself.
—(5.2) Otherwise, the complete object ofx is the complete object of the (unique) object that containsx.
6 If a complete object, a member subobject, or an array element is of class type, its type is considered themost
derived class, to distinguish it from the class type of any base class subobject; an object of a most derived
class type or of a non-class type is called amost derived object.
7 A potentially-overlapping subobjectis either:
—(7.1) a base class subobject, or
—(7.2) a non-static data member declared with theno_unique_address attribute (9.13.11).
8 An object has nonzero size if it
—(8.1) is not a potentially-overlapping subobject, or
—(8.2) is not of class type, or
—(8.3) is of a class type with virtual member functions or virtual base classes, or
—(8.4) has subobjects of nonzero size or unnamed bit-fields of nonzero length.
Otherwise, if the object is a base class subobject of a standard-layout class type with no non-static data
members, it has zero size. Otherwise, the circumstances under which the object has zero size are implementa-
tion-defined. Unless it is a bit-field (11.4.10), an object with nonzero size shall occupy one or more bytes of
storage, including every byte that is occupied in full or in part by any of its subobjects. An object of trivially
copyable or standard-layout type (6.9.1) shall occupy contiguous bytes of storage.
9 An object is apotentially non-unique objectif it is
—(9.1) a string literal object (5.13.5),
—(9.2) the backing array of an initializer list (9.5.4), or
—(9.3) the object introduced by a call tostd::meta::reflect_constant_array or std::meta::reflect_-
constant_string (21.4.3), or
—(9.4) a subobject thereof.
10 Unless an object is a bit-field or a subobject of zero size, the address of that object is the address of the first
byte it occupies. Two objects with overlapping lifetimes that are not bit-fields may have the same address if
—(10.1) one is nested within the other,
—(10.2) at least one is a subobject of zero size and they are not of similar types (7.3.6), or
—(10.3) they are both potentially non-unique objects;
otherwise, they have distinct addresses and occupy disjoint bytes of storage.16
[Example 2:
static const char test1 = 'x';
static const char test2 = 'x';
16) Under the “as-if” rule an implementation is allowed to store two objects at the same machine address or not store an object
at all if the program cannot observe the difference (6.10.1).
§ 6.8.2 © ISO/IEC
66

===== PAGE 78 =====

Dxxxx
const bool b = &test1 != &test2; // alwaystrue
static const char (&r) [] = "x";
static const char *s = "x";
static std::initializer_list<char> il = { 'x' };
const bool b2 = r != il.begin(); // unspecified result
const bool b3 = r != s; // unspecified result
const bool b4 = il.begin() != &test1; // alwaystrue
const bool b5 = r != &test1; // alwaystrue
—end example]
The address of a subobject of zero size is the address of an unspecified byte of storage occupied by the
complete object of that subobject.
11 The constituent valuesof an objecto are
—(11.1) if o has scalar type, the value ofo;
—(11.2) otherwise, the constituent values of any direct subobjects ofo other than inactive union members.
The constituent referencesof an objecto are
—(11.3) any direct members ofo that have reference type, and
—(11.4) the constituent references of any direct subobjects ofo other than inactive union members.
12 Some operations are described asimplicitly creating objectswithin a specified region of storage. For each
operation that is specified as implicitly creating objects, that operation implicitly creates and starts the
lifetime of zero or more objects of implicit-lifetime types (6.9.1) in its specified region of storage if doing
so would result in the program having defined behavior. If no such set of objects would give the program
defined behavior, the behavior of the program is undefined. If multiple such sets of objects would give the
program defined behavior, it is unspecified which such set of objects is created.
[Note 4: Such operations do not start the lifetimes of subobjects of such objects that are not themselves of implicit-
lifetime types. —end note]
13 Further, after implicitly creating objects within a specified region of storage, some operations are described as
producing a pointer to asuitable created object. These operations select one of the implicitly-created objects
whose address is the address of the start of the region of storage, and produce a pointer value that points
to that object, if that value would result in the program having defined behavior. If no such pointer value
would give the program defined behavior, the behavior of the program is undefined. If multiple such pointer
values would give the program defined behavior, it is unspecified which such pointer value is produced.
14 [Example 3:
#include <cstdlib>
struct X { int a, b; };
X *make_x() {
// The call tostd::malloc implicitly creates an object of typeX
// and its subobjectsa and b, and returns a pointer to thatX object
// (or an object that is pointer-interconvertible (6.9.4) with it),
// in order to give the subsequent class member access operations
// defined behavior.
X *p = (X*)std::malloc(sizeof(struct X));
p->a = 1;
p->b = 2;
return p;
}
—end example]
15 Except during constant evaluation, an operation that begins the lifetime of an array ofunsigned char or
std::byte implicitly creates objects within the region of storage occupied by the array.
[Note 5: The array object provides storage for these objects.—end note]
Except during constant evaluation, any implicit or explicit invocation of a function namedoperator new
or operator new[] implicitly creates objects in the returned region of storage and returns a pointer to a
suitable created object.
§ 6.8.2 © ISO/IEC
67

===== PAGE 79 =====

Dxxxx
[Note 6: Some functions in the C++ standard library implicitly create objects (20.2.6, 20.2.12, 20.5.2.2, 22.11.3, 27.5.1).
—end note]
6.8.3 Alignment [basic.align]
1 Object types havealignment requirements(6.9.2, 6.9.4) which place restrictions on the addresses at which an
object of that type may be allocated. Analignment is an implementation-defined integer value representing
the number of bytes between successive addresses at which a given object can be allocated. An object type
imposes an alignment requirement on every object of that type; stricter alignment can be requested using
the alignment specifier (9.13.2). Attempting to create an object (6.8.2) in storage that does not meet the
alignment requirements of the object’s type is undefined behavior.
2 A fundamental alignmentis represented by an alignment less than or equal to the greatest alignment supported
by the implementation in all contexts, which is equal toalignof(std::max_align_t) (17.2). The alignment
required for a type may be different when it is used as the type of a complete object and when it is used as
the type of a subobject.
[Example 1:
struct B { long double d; };
struct D : virtual B { char c; };
When D is the type of a complete object, it will have a subobject of typeB, so it must be aligned appropriately for a
long double. If D appears as a subobject of another object that also hasB as a virtual base class, theB subobject
might be part of a different subobject, reducing the alignment requirements on theD subobject. —end example]
The result of thealignof operator reflects the alignment requirement of the type in the complete-object case.
3 An extended alignment is represented by an alignment greater thanalignof(std::max_align_t). It is
implementation-defined whether any extended alignments are supported and the contexts in which they are
supported (9.13.2). A type having an extended alignment requirement is anover-aligned type.
[Note 1: Every over-aligned type is or contains a class type to which extended alignment applies (possibly through a
non-static data member). —end note]
A new-extended alignmentis represented by an alignment greater than__STDCPP_DEFAULT_NEW_ALIGNMENT__
(15.12).
4 Alignments are represented as values of the typestd::size_t. Valid alignments include only those values
returned by analignof expression for the fundamental types plus an additional implementation-defined set
of values, which may be empty. Every alignment value shall be a non-negative integral power of two.
5 Alignments have an order fromweaker to stronger or stricter alignments. Stricter alignments have larger
alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment
requirement.
6 The alignment requirement of a complete type can be queried using an alignof expression (7.6.2.6).
Furthermore, the narrow character types (6.9.2) shall have the weakest alignment requirement.
[Note 2: This enables the ordinary character types to be used as the underlying type for an aligned memory
area (9.13.2). —end note]
7 Comparing alignments is meaningful and provides the obvious results:
—(7.1) Two alignments are equal when their numeric values are equal.
—(7.2) Two alignments are different when their numeric values are not equal.
—(7.3) When an alignment is larger than another it represents a stricter alignment.
8 [Note 3: The runtime pointer alignment function (20.2.5) can be used to obtain an aligned pointer within a buffer; an
alignment-specifier (9.13.2) can be used to align storage explicitly.—end note]
9 If a request for a specific extended alignment in a specific context is not supported by an implementation,
the program is ill-formed.
6.8.4 Lifetime [basic.life]
1 In this subclause, “before” and “after” refer to the “happens before” relation (6.10.2).
2 The lifetime of an object or reference is a runtime property of the object or reference. A variable is said to
have vacuous initializationif it is default-initialized, no other initialization is performed, and, if it is of class
type or a (possibly multidimensional) array thereof, a trivial constructor of that class type is selected for the
default-initialization. The lifetime of an object of typeT begins when:
§ 6.8.4 © ISO/IEC
68

===== PAGE 80 =====

Dxxxx
—(2.1) storage with the proper alignment and size for typeT is obtained, and
—(2.2) its initialization (if any) is complete (including vacuous initialization) (9.5),
except that if the object is a union member or subobject thereof, its lifetime only begins if that union member
is the initialized member in the union (9.5.2, 11.9.3), or as described in 11.5, 11.4.5.3, and 11.4.6, and except
as described in 20.2.10.2. The lifetime of an objecto of typeT ends when:
—(2.3) if T is a non-class type, the object is destroyed, or
—(2.4) if T is a class type, the destructor call starts, or
—(2.5) the storage which the object occupies is released, or is reused by an object that is not nested within
o (6.8.2).
When evaluating anew-expression, storage is considered reused after it is returned from the allocation function,
but before the evaluation of thenew-initializer (7.6.2.8).
[Example 1:
struct S {
int m;
};
void f() {
S x{1};
new(&x) S(x.m); // undefined behavior
}
—end example]
3 The lifetime of a reference begins when its initialization is complete. The lifetime of a reference ends as if it
were a scalar object requiring storage.
4 [Note 1: 11.9.3 describes the lifetime of base and member subobjects.—end note]
5 The properties ascribed to objects and references throughout this document apply for a given object or
reference only during its lifetime.
[Note 2: In particular, before the lifetime of an object starts and after its lifetime ends there are significant restrictions
on the use of the object, as described below, in 11.9.3, and in 11.9.5. Also, the behavior of an object under construction
and destruction can differ from the behavior of an object whose lifetime has started and not ended. 11.9.3 and 11.9.5
describe the behavior of an object during its periods of construction and destruction.—end note]
6 A program may end the lifetime of an object of class type without invoking the destructor, by reusing or
releasing the storage as described above.
[Note 3: A delete-expression (7.6.2.9) invokes the destructor prior to releasing the storage.—end note]
In this case, the destructor is not implicitly invoked.
[Note 4: The correct behavior of a program often depends on the destructor being invoked for each object of class
type. —end note]
7 Before the lifetime of an object has started but after the storage which the object will occupy has been
allocated17 or after the lifetime of an object has ended and before the storage which the object occupied
is reused or released, any pointer that represents the address of the storage location where the object will
be or was located may be used but only in limited ways. For an object under construction or destruction,
see 11.9.5. Otherwise, such a pointer refers to allocated storage (6.8.6.5.2), and using the pointer as if the
pointer were of typevoid* is well-defined. Indirection through such a pointer is permitted but the resulting
lvalue may only be used in limited ways, as described below. The program has undefined behavior if
—(7.1) the pointer is used as the operand of adelete-expression,
—(7.2) the pointer is used to access a non-static data member or call a non-static member function of the
object, or
—(7.3) the pointer is converted (7.3.12, 7.6.1.9) to a pointer to a virtual base class or to a base class thereof, or
—(7.4) the pointer is used as the operand of adynamic_cast (7.6.1.7).
[Example 2:
#include <cstdlib>
17) For example, before the dynamic initialization of an object with static storage duration (6.10.3.3).
§ 6.8.4 © ISO/IEC
69

===== PAGE 81 =====

Dxxxx
struct B {
virtual void f();
void mutate();
virtual ~B();
};
struct D1 : B { void f(); };
struct D2 : B { void f(); };
void B::mutate() {
new (this) D2; // reuses storage — ends the lifetime of*this
f(); // undefined behavior
... = this; // OK,this points to valid memory
}
void g() {
void* p = std::malloc(sizeof(D1) + sizeof(D2));
B* pb = new (p) D1;
pb->mutate();
*pb; // OK,pb points to valid memory
void* q = pb; // OK,pb points to valid memory
pb->f(); // undefined behavior: lifetime of*pb has ended
}
—end example]
8 Similarly, before the lifetime of an object has started but after the storage which the object will occupy has
been allocated or after the lifetime of an object has ended and before the storage which the object occupied
is reused or released, any glvalue that refers to the original object may be used but only in limited ways.
For an object under construction or destruction, see 11.9.5. Otherwise, such a glvalue refers to allocated
storage (6.8.6.5.2), and using the properties of the glvalue that do not depend on its value is well-defined.
The program has undefined behavior if
—(8.1) the glvalue is used to access the object, or
—(8.2) the glvalue is used to call a non-static member function of the object, or
—(8.3) the glvalue is bound to a reference to a virtual base class (9.5.4), or
—(8.4) the glvalue is used as the operand of adynamic_cast (7.6.1.7) or as the operand oftypeid.
[Note 5: Therefore, undefined behavior results if an object that is being constructed in one thread is referenced from
another thread without adequate synchronization.—end note]
9 An objecto1 is transparently replaceableby an objecto2 if either
—(9.1) o1 and o2 are complete objects for which:
—(9.1.1) o1 is not const,
—(9.1.2) the storage thato2 occupies exactly overlays the storage thato1 occupied, and
—(9.1.3) o1 and o2 are of the same type (ignoring the top-level cv-qualifiers), or
—(9.2) o1 and o2 are corresponding direct subobjects (6.8.2) for which:
—(9.2.1) the complete object ofo1 is not const or
—(9.2.2) o1 is a mutable member subobject or a subobject thereof.
10 After the lifetime of an object has ended and before the storage which the object occupied is reused or
released, if a new object is created at the storage location which the original object occupied and the original
object was transparently replaceable by the new object, a pointer that pointed to the original object, a
reference that referred to the original object, or the name of the original object will automatically refer to the
new object and, once the lifetime of the new object has started, can be used to manipulate the new object.
[Example 3:
struct C {
int i;
void f();
const C& operator=( const C& );
};
§ 6.8.4 © ISO/IEC
70

===== PAGE 82 =====

Dxxxx
const C& C::operator=( const C& other) {
if ( this != &other ) {
this->~C(); // lifetime of*this ends
new (this) C(other); // new object of typeC created
f(); // well-defined
}
return *this;
}
C c1;
C c2;
c1 = c2; // well-defined
c1.f(); // well-defined;c1 refers to a new object of typeC
—end example]
[Note 6: If these conditions are not met, a pointer to the new object can be obtained from a pointer that represents
the address of its storage by callingstd::launder (17.6.5). —end note]
11 If a program ends the lifetime of an object of typeTwith static (6.8.6.2), thread (6.8.6.3), or automatic (6.8.6.4)
storage duration and ifT has a non-trivial destructor,18 and another object of the original type does not
occupy that same storage location when the implicit destructor call takes place, the behavior of the program
is undefined. This is true even if the block is exited with an exception.
[Example 4:
class T { };
struct B {
~B();
};
void h() {
B b;
new (&b) T;
} // undefined behavior at block exit
—end example]
12 Creating a new object within the storage that a const, complete object with static, thread, or automatic
storage duration occupies, or within the storage that such a const object used to occupy before its lifetime
ended, results in undefined behavior.
[Example 5:
struct B {
B();
~B();
};
const B b;
void h() {
b.~B();
new (const_cast<B*>(&b)) const B; // undefined behavior
}
—end example]
6.8.5 Indeterminate and erroneous values [basic.indet]
1 When storage for an object with automatic or dynamic storage duration is obtained, the bytes comprising
the storage for the object have the following initial value:
—(1.1) If the object has dynamic storage duration, or is the object associated with a variable or function
parameter whose first declaration is marked with the[[indeterminate]] attribute (9.13.6), the bytes
have indeterminate values;
18) That is, an object for which a destructor will be called implicitly—upon exit from the block for an object with automatic
storage duration, upon exit from the thread for an object with thread storage duration, or upon exit from the program for an
object with static storage duration.
§ 6.8.5 © ISO/IEC
71

===== PAGE 83 =====

Dxxxx
—(1.2) otherwise, the bytes haveerroneous values, where each value is determined by the implementation
independently of the state of the program.
If no initialization is performed for an object (including subobjects), such a byte retains its initial value until
that value is replaced (9.5.1, 7.6.19). If any bit in the value representation has an indeterminate value, the
object has an indeterminate value; otherwise, if any bit in the value representation has an erroneous value,
the object has an erroneous value.
[Note 1: Lvalue-to-rvalue conversion has undefined behavior if the erroneous value of an object is not valid for its
type (7.3.2). —end note]
[Note 2: Objects with static or thread storage duration are zero-initialized, see 6.10.3.2.—end note]
2 If any operand of a built-in operator that produces a prvalue is evaluated, is not a discarded-value expression
(7.2.3), and produces an erroneous value, then the value produced by that operator is erroneous. Except in
the following cases, if an indeterminate value is produced by an evaluation, the behavior is undefined, and if
an erroneous value is produced by an evaluation, the behavior is erroneous and the result of the evaluation is
that erroneous value:
—(2.1) If an indeterminate or erroneous value of unsigned ordinary character type (6.9.2) orstd::byte
type (17.2.1) is produced by the evaluation of:
—(2.1.1) the second or third operand of a conditional expression (7.6.16),
—(2.1.2) the right operand of a comma expression (7.6.20),
—(2.1.3) the operand of a cast or conversion (7.3.9, 7.6.1.4, 7.6.1.9, 7.6.3) to an unsigned ordinary character
type orstd::byte type (17.2.1), or
—(2.1.4) a discarded-value expression (7.2.3),
then the result of the operation is an indeterminate value or that erroneous value, respectively.
—(2.2) If an indeterminate or erroneous value of unsigned ordinary character type orstd::byte type is
produced by the evaluation of the right operand of a simple assignment operator (7.6.19) whose first
operand is an lvalue of unsigned ordinary character type orstd::byte type, an indeterminate value or
that erroneous value, respectively, replaces the value of the object referred to by the left operand.
—(2.3) If an indeterminate or erroneous value of unsigned ordinary character type is produced by the evaluation
of the initialization expression when initializing an object of unsigned ordinary character type, that
object is initialized to an indeterminate value or that erroneous value, respectively.
—(2.4) If an indeterminate value of unsigned ordinary character type orstd::byte type is produced by the
evaluation of the initialization expression when initializing an object ofstd::byte type, that object is
initialized to an indeterminate value or that erroneous value, respectively.
Converting an indeterminate or erroneous value of unsigned ordinary character type orstd::byte type
produces an indeterminate or erroneous value, respectively. In the latter case, the result of the conversion is
the value of the converted operand.
[Example 1:
int f(bool b) {
unsigned char *c = new unsigned char;
unsigned char d = *c; // OK,d has an indeterminate value
int e = d; // undefined behavior
return b ? d : 0; // undefined behavior ifb is true
}
int g(bool b) {
unsigned char c;
unsigned char d = c; // no erroneous behavior, butd has an erroneous value
assert(c == d); // holds, both integral promotions have erroneous behavior
int e = d; // erroneous behavior
return b ? d : 0; // erroneous behavior ifb is true
}
void h() {
int d1, d2;
§ 6.8.5 © ISO/IEC
72

===== PAGE 84 =====

Dxxxx
int e1 = d1; // erroneous behavior
int e2 = d1; // erroneous behavior
assert(e1 == e2); // holds
assert(e1 == d1); // holds, erroneous behavior
assert(e2 == d1); // holds, erroneous behavior
std::memcpy(&d2, &d1, sizeof(int)); // no erroneous behavior, butd2 has an erroneous value
assert(e1 == d2); // holds, erroneous behavior
assert(e2 == d2); // holds, erroneous behavior
}
—end example]
6.8.6 Storage duration [basic.stc]
6.8.6.1 General [basic.stc.general]
1 The storage durationis the property of an object that defines the minimum potential lifetime of the storage
containing the object. The storage duration is determined by the construct used to create the object and is
one of the following:
—(1.1) static storage duration
—(1.2) thread storage duration
—(1.3) automatic storage duration
—(1.4) dynamic storage duration
[Note 1: After the duration of a region of storage has ended, the use of pointers to that region of storage is
limited (6.9.4). —end note]
2 Static, thread, and automatic storage durations are associated with objects introduced by declarations (6.2)
and with temporary objects (6.8.7). The dynamic storage duration is associated with objects created by a
new-expression (7.6.2.8) or with implicitly created objects (6.8.2).
3 The storage duration categories apply to references as well.
4 The storage duration of subobjects and reference members is that of their complete object (6.8.2).
6.8.6.2 Static storage duration [basic.stc.static]
1 All variables which
—(1.1) do not have thread storage duration and
—(1.2) belong to a namespace scope (6.4.6) or are first declared with thestatic or extern keywords (9.2.2)
have static storage duration. The storage for these entities lasts for the duration of the program (6.10.3.2,
6.10.3.4).
2 If a variable with static storage duration has initialization or a destructor with side effects, it shall not be
eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated as
specified in 11.9.6.
3 [Note 1: The keywordstatic can be used to declare a block variable (6.4.3) with static storage duration; 8.10 and
6.10.3.4 describe the initialization and destruction of such variables. The keywordstatic applied to a class data
member in a class definition gives the data member static storage duration (11.4.9.3).—end note]
6.8.6.3 Thread storage duration [basic.stc.thread]
1 All variables declared with thethread_local keyword havethread storage duration. The storage for these
entities lasts for the duration of the thread in which they are created. There is a distinct object or reference
per thread, and use of the declared name refers to the entity associated with the current thread.
2 [Note 1: A variable with thread storage duration is initialized as specified in 6.10.3.2, 6.10.3.3, and 8.10 and, if
constructed, is destroyed on thread exit (6.10.3.4).—end note]
6.8.6.4 Automatic storage duration [basic.stc.auto]
1 Variables that belong to a block scope and are not explicitly declaredstatic, thread_local, orextern
haveautomatic storage duration. The storage for such variables lasts until the block in which they are created
exits.
§ 6.8.6.4 © ISO/IEC
73

===== PAGE 85 =====

Dxxxx
[Note 1: These variables are initialized and destroyed as described in 8.10.—end note]
Variables that belong to a parameter scope also have automatic storage duration. The storage for a function
parameter lasts until immediately after its destruction (7.6.1.3).
2 If a variable with automatic storage duration has initialization or a destructor with side effects, an implemen-
tation shall not destroy it before the end of its block nor eliminate it as an optimization, even if it appears to
be unused, except that a class object or its copy/move may be eliminated as specified in 11.9.6.
6.8.6.5 Dynamic storage duration [basic.stc.dynamic]
6.8.6.5.1 General [basic.stc.dynamic.general]
1 Objects can be created dynamically during program execution (6.10.1), usingnew-expressions (7.6.2.8), and
destroyed usingdelete-expressions (7.6.2.9). A C++ implementation provides access to, and management
of, dynamic storage via the globalallocation functionsoperator new and operator new[] and the global
deallocation functionsoperator delete and operator delete[].
[Note 1: The non-allocating forms described in 17.6.3.4 do not perform allocation or deallocation.—end note]
2 The library provides default definitions for the global allocation and deallocation functions. Some global
allocation and deallocation functions are replaceable (9.6.5). The following allocation and deallocation
functions (17.6) are implicitly declared in global scope in each translation unit of a program.
void* operator new(std::size_t);
void* operator new(std::size_t, std::align_val_t);
void operator delete(void*) noexcept;
void operator delete(void*, std::size_t) noexcept;
void operator delete(void*, std::align_val_t) noexcept;
void operator delete(void*, std::size_t, std::align_val_t) noexcept;
void* operator new[](std::size_t);
void* operator new[](std::size_t, std::align_val_t);
void operator delete[](void*) noexcept;
void operator delete[](void*, std::size_t) noexcept;
void operator delete[](void*, std::align_val_t) noexcept;
void operator delete[](void*, std::size_t, std::align_val_t) noexcept;
These implicit declarations introduce only the function namesoperator new, operator new[], operator
delete, andoperator delete[].
[Note 2: The implicit declarations do not introduce the namesstd, std::size_t, std::align_val_t, or any other
names that the library uses to declare these names. Thus, anew-expression, delete-expression, or function call that
refers to one of these functions without importing or including the header<new> (17.6.2) or importing a C++ library
module (16.4.2.4) is well-formed. However, referring tostd or std::size_t or std::align_val_t is ill-formed unless
a standard library declaration (17.2.1, 17.6.2, 16.4.2.4) of that name precedes (6.5.1) the use of that name.—end
note]
Allocation and/or deallocation functions may also be declared and defined for any class (11.4.11).
3 If the behavior of an allocation or deallocation function does not satisfy the semantic constraints specified
in 6.8.6.5.2 and 6.8.6.5.3, the behavior is undefined.
6.8.6.5.2 Allocation functions [basic.stc.dynamic.allocation]
1 An allocation function that is not a class member function shall belong to the global scope and not have a
name with internal linkage. The return type shall bevoid*. The first parameter shall have typestd::size_-
t (17.2). The first parameter shall not have an associated default argument (9.3.4.7). The value of the first
parameter is interpreted as the requested size of the allocation. An allocation function can be a function
template. Such a template shall declare its return type and first parameter as specified above (that is,
template parameter types shall not be used in the return type and first parameter type). Allocation function
templates shall have two or more parameters.
2 An allocation function attempts to allocate the requested amount of storage. If it is successful, it returns
the address of the start of a block of storage whose length in bytes is at least as large as the requested size.
The order, contiguity, and initial value of storage allocated by successive calls to an allocation function are
unspecified. Even if the size of the space requested is zero, the request can fail. If the request succeeds, the
value returned by a replaceable allocation function is a non-null pointer value (6.9.4)p0 different from any
§ 6.8.6.5.2 © ISO/IEC
74

===== PAGE 86 =====

Dxxxx
previously returned valuep1, unless that valuep1 was subsequently passed to a replaceable deallocation
function. Furthermore, for the library allocation functions in 17.6.3.2 and 17.6.3.3,p0 represents the address
of a block of storage disjoint from the storage for any other object accessible to the caller. The effect of
indirecting through a pointer returned from a request for zero size is undefined.19
3 For an allocation function other than a reserved placement allocation function (17.6.3.4), the pointer returned
on a successful call shall represent the address of storage that is aligned as follows:
—(3.1) If the allocation function takes an argument of typestd::align_val_t, the storage will have the
alignment specified by the value of this argument.
—(3.2) Otherwise, if the allocation function is namedoperator new[], the storage is aligned for any object
that does not have new-extended alignment (6.8.3) and is no larger than the requested size.
—(3.3) Otherwise, the storage is aligned for any object that does not have new-extended alignment and is of
the requested size.
4 An allocation function that fails to allocate storage can invoke the currently installed new-handler function
(17.6.4.3), if any.
[Note 1: A program-supplied allocation function can obtain the currently installednew_handler using thestd::get_-
new_handler function (17.6.4.5). —end note]
An allocation function that has a non-throwing exception specification (14.5) indicates failure by returning a
null pointer value. Any other allocation function never returns a null pointer value and indicates failure only by
throwing an exception (14.2) of a type that would match a handler (14.4) of typestd::bad_alloc (17.6.4.1).
5 A global allocation function is only called as the result of a new expression (7.6.2.8), or called directly using
the function call syntax (7.6.1.3), or called indirectly to allocate storage for a coroutine state (9.6.4), or called
indirectly through calls to the functions in the C++ standard library.
[Note 2: In particular, a global allocation function is not called to allocate storage for objects with static storage
duration (6.8.6.2), for objects or references with thread storage duration (6.8.6.3), for objects of typestd::type_-
info (7.6.1.8), for an object of typestd::contracts::contract_violation when a contract violation occurs (6.11.2),
or for an exception object (14.2).—end note]
6.8.6.5.3 Deallocation functions [basic.stc.dynamic.deallocation]
1 A deallocation function that is not a class member function shall belong to the global scope and not have a
name with internal linkage.
2 A deallocation function is adestroying operator deleteif it has at least two parameters and its second
parameter is of typestd::destroying_delete_t. A destroying operator delete shall be a class member
function namedoperator delete.
[Note 1: Array deletion cannot use a destroying operator delete.—end note]
3 Each deallocation function shall returnvoid. If the function is a destroying operator delete declared in class
type C, the type of its first parameter shall beC*; otherwise, the type of its first parameter shall bevoid*. A
deallocation function may have more than one parameter. Ausual deallocation functionis a deallocation
function whose parameters after the first are
—(3.1) optionally, a parameter of typestd::destroying_delete_t, then
—(3.2) optionally, a parameter of typestd::size_t,20 then
—(3.3) optionally, a parameter of typestd::align_val_t.
A destroying operator delete shall be a usual deallocation function. A deallocation function may be an
instance of a function template. Neither the first parameter nor the return type shall depend on a template
parameter. A deallocation function template shall have two or more function parameters. A template instance
is never a usual deallocation function, regardless of its signature.
4 If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the
first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation
function is one supplied in the standard library, the call has no effect.
19) The intent is to haveoperator new() implementable by callingstd::malloc() or std::calloc(), so the rules are substan-
tially the same. C++ differs from C in requiring a zero request to return a non-null pointer.
20) The globaloperator delete(void*, std::size_t) precludes use of an allocation functionvoid operator new(std::size_-
t, std::size_t) as a placement allocation function (C.5.3).
§ 6.8.6.5.3 © ISO/IEC
75

===== PAGE 87 =====

Dxxxx
5 If the argument given to a deallocation function in the standard library is a pointer that is not the null
pointer value (6.9.4), the deallocation function shall deallocate the storage referenced by the pointer, ending
the duration of the region of storage.
6.8.7 Temporary objects [class.temporary]
1 A temporary objectis an object created
—(1.1) when a prvalue is converted to an xvalue (7.3.5) and
—(1.2) when needed by the implementation to pass or return an object of suitable type (see below).
Even when the creation of the temporary object is unevaluated (7.2.3), all the semantic restrictions shall be
respected as if the temporary object had been created and later destroyed.
[Note 1: This includes accessibility (11.8) and whether it is deleted, for the constructor selected and for the destructor.
However, in the special case of the operand of adecltype-specifier (9.2.9.6), no temporary is introduced, so the foregoing
does not apply to such a prvalue.—end note]
2 The materialization of a temporary object is generally delayed as long as possible in order to avoid creating
unnecessary temporary objects.
[Note 2: Temporary objects are materialized:
—(2.1) when binding a reference to a prvalue (9.5.4, 7.6.1.4, 7.6.1.7, 7.6.1.9, 7.6.1.11, 7.6.3),
—(2.2) when performing certain member accesses on a class prvalue (7.6.1.5, 7.6.4),
—(2.3) when invoking an implicit object member function on a class prvalue (7.6.1.3),
—(2.4) when performing an array-to-pointer conversion or subscripting on an array prvalue (7.3.3, 7.6.1.2),
—(2.5) when initializing an object of typestd::initializer_list<T> from abraced-init-list (9.5.5),
—(2.6) for certain unevaluated operands (7.6.1.8, 7.6.2.5), and
—(2.7) when a prvalue that has type other thancv void appears as a discarded-value expression (7.2.3).
—end note]
[Example 1: Consider the following code:
class X {
public:
X(int);
X(const X&);
X& operator=(const X&);
~X();
};
class Y {
public:
Y(int);
Y(Y&&);
~Y();
};
X f(X);
Y g(Y);
void h() {
X a(1);
X b = f(X(2));
Y c = g(Y(3));
a = f(a);
}
X(2) is constructed in the space used to holdf()’s argument andY(3) is constructed in the space used to holdg()’s
argument. Likewise, f()’s result is constructed directly inb and g()’s result is constructed directly inc. On the
other hand, the expressiona = f(a) requires a temporary for the result off(a), which is materialized so that the
reference parameter ofX::operator=(const X&) can bind to it.—end example]
3 When an object of typeX is passed to or returned from a potentially-evaluated function call, ifX is
—(3.1) a scalar type or
§ 6.8.7 © ISO/IEC
76

===== PAGE 88 =====

Dxxxx
—(3.2) a class type that has at least one eligible copy or move constructor (11.4.4), where each such constructor
is trivial, and the destructor ofX is either trivial or deleted,
implementations are permitted to create temporary objects to hold the function parameter or result object,
as follows:
—(3.3) The first such temporary object is constructed from the function argument or return value, respectively.
—(3.4) Each successive temporary object is initialized from the previous one as if by direct-initialization ifX is
a scalar type, otherwise by using an eligible trivial constructor.
—(3.5) The function parameter or return object is initialized from the final temporary as if by direct-initialization
if X is a scalar type, otherwise by using an eligible trivial constructor.
(In all cases, the eligible constructor is used even if that constructor is inaccessible or would not be selected
by overload resolution to perform a copy or move of the object).
[Note 3: This latitude is granted to allow objects to be passed to or returned from functions in registers.—end note]
4 Temporary objects are destroyed as the last step in evaluating the full-expression (6.10.1) that (lexically)
contains the point where they were created. This is true even if that evaluation ends in throwing an exception.
The value computations and side effects of destroying a temporary object are associated only with the
full-expression, not with any specific subexpression.
5 Temporary objects are destroyed at a different point than the end of the full-expression in the following
contexts: The first context is when a default constructor is called to initialize an element of an array with no
corresponding initializer (9.5). The second context is when a copy constructor is called to copy an element of
an array while the entire array is copied (7.5.6.3, 11.4.5.3). In either case, if the constructor has one or more
default arguments, the destruction of every temporary created in a default argument is sequenced before the
construction of the next array element, if any.
6 The third context is when a reference binds to a temporary object.21 The temporary object to which the
reference is bound or the temporary object that is the complete object of a subobject to which the reference
is bound persists for the lifetime of the reference if the glvalue to which the reference is bound was obtained
through one of the following:
—(6.1) a temporary materialization conversion (7.3.5),
—(6.2) ( expression ), whereexpression is one of these expressions,
—(6.3) subscripting (7.6.1.2) of an array operand, where that operand is one of these expressions,
—(6.4) a class member access (7.6.1.5) using the. operator where the left operand is one of these expressions
and the right operand designates a non-static data member (11.4.1) of non-reference type or a direct
base class relationship (11.7.1),
—(6.5) a pointer-to-member operation (7.6.4) using the.* operator where the left operand is one of these
expressions and the right operand is a pointer to data member of non-reference type,
—(6.6) a
—(6.6.1) const_cast (7.6.1.11),
—(6.6.2) static_cast (7.6.1.9),
—(6.6.3) dynamic_cast (7.6.1.7), or
—(6.6.4) reinterpret_cast (7.6.1.10)
converting, without a user-defined conversion, a glvalue operand that is one of these expressions to a
glvalue that refers to the object designated by the operand, or to its complete object or a subobject
thereof,
—(6.7) an explicit type conversion (functional notation) (7.6.1.4) to a reference type whose initializer is a
braced-init-list where the reference is
—(6.7.1) bound directly to the glvalue result of one of these expressions (necessarily the sole element of the
braced-init-list) or
—(6.7.2) bound to the result of a temporary materialization conversion,
21) The same rules apply to initialization of aninitializer_list object (9.5.5) with its underlying temporary array.
§ 6.8.7 © ISO/IEC
77

===== PAGE 89 =====

Dxxxx
—(6.8) a conditional expression (7.6.16) that is a glvalue where the second or third operand is one of these
expressions, or
—(6.9) a comma expression (7.6.20) that is a glvalue where the right operand is one of these expressions.
[Example 2:
template<typename T> using id = T;
int i = 1;
int&& a = id<int[3]>{1, 2, 3}[i]; // temporary array has same lifetime asa
const int& b = static_cast<const int&>(0); // temporaryint has same lifetime asb
int&& c = cond ? id<int[3]>{1, 2, 3}[i] : static_cast<int&&>(0);
// exactly one of the two temporaries is lifetime-extended
—end example]
[Note 4: An explicit type conversion (7.6.1.4, 7.6.3) is interpreted as a sequence of elementary casts, covered above.
[Example 3:
const int& x = (const int&)1; // temporary for value 1 has same lifetime as x
—end example]
—end note]
[Note 5: If a temporary object has a reference member initialized by another temporary object, lifetime extension
applies recursively to such a member’s initializer.
[Example 4:
struct S {
const int& m;
};
const S& s = S{1}; // bothS and int temporaries have lifetime ofs
—end example]
—end note]
The exceptions to this lifetime rule are:
—(6.10) A temporary object bound to a reference parameter in a function call (7.6.1.3) persists until the
completion of the full-expression containing the call.
—(6.11) A temporary object bound to a reference element of an aggregate of class type initialized from a
parenthesized expression-list (9.5) persists until the completion of the full-expression containing the
expression-list.
—(6.12) A temporary bound to a reference in anew-initializer (7.6.2.8) persists until the completion of the
full-expression containing thenew-initializer.
[Note 6: This might introduce a dangling reference.—end note]
[Example 5:
struct S { int mi; const std::pair<int,int>& mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} }; // creates dangling reference
—end example]
7 The fourth context is when a temporary object is created in thefor-range-initializer of a range-basedfor
statement. If such a temporary object would otherwise be destroyed at the end of thefor-range-initializer
full-expression, the object persists for the lifetime of the reference initialized by thefor-range-initializer.
8 The fifth context is when a temporary object is created in an elementE of the expansion-init-list of an
enumerating expansion statement (8.7). If such a temporary object would otherwise be destroyed at the end
of the full-expression ofE, the object persists for the lifetime of thefor-range-declaration initialized fromE.
9 The sixth context is when a temporary object is created in theexpansion-initializer of a destructuring expansion
statement. If such a temporary object would otherwise be destroyed at the end of thatexpansion-initializer,
the object persists for the lifetime of the reference initialized by theexpansion-initializer, if any.
10 The seventh context is when a temporary object is created in a structured binding declaration (9.7). Any
temporary objects introduced by theinitializers for the variables with unique names are destroyed at the end
of the structured binding declaration.
§ 6.8.7 © ISO/IEC
78

===== PAGE 90 =====

Dxxxx
11 Let x and y each be either a temporary object whose lifetime is not extended, or a function parameter. If
the lifetimes ofx and y end at the end of the same full-expression, andx is initialized beforey, then the
destruction of y is sequenced before that ofx. If the lifetime of two or more temporaries with lifetimes
extending beyond the full-expressions in which they were created ends at the same point, these temporaries
are destroyed at that point in the reverse order of the completion of their construction. In addition, the
destruction of such temporaries shall take into account the ordering of destruction of objects with static,
thread, or automatic storage duration (6.8.6.2, 6.8.6.3, 6.8.6.4); that is, ifobj1 is an object with the same
storage duration as the temporary and created before the temporary is created the temporary shall be
destroyed beforeobj1 is destroyed; ifobj2 is an object with the same storage duration as the temporary and
created after the temporary is created the temporary shall be destroyed afterobj2 is destroyed.
12 [Example 6:
struct S {
S();
S(int);
friend S operator+(const S&, const S&);
~S();
};
S obj1;
const S& cr = S(16)+S(23);
S obj2;
The expressionS(16) + S(23) creates three temporaries: a first temporaryT1 to hold the result of the expression
S(16), a second temporaryT2 to hold the result of the expressionS(23), and a third temporaryT3 to hold the result
of the addition of these two expressions. The temporaryT3 is then bound to the referencecr. It is unspecified whether
T1 or T2 is created first. On an implementation whereT1 is created beforeT2, T2 shall be destroyed beforeT1. The
temporaries T1 and T2 are bound to the reference parameters ofoperator+; these temporaries are destroyed at the
end of the full-expression containing the call tooperator+. The temporaryT3 bound to the referencecr is destroyed
at the end ofcr’s lifetime, that is, at the end of the program. In addition, the order in whichT3 is destroyed takes
into account the destruction order of other objects with static storage duration. That is, becauseobj1 is constructed
before T3, andT3 is constructed beforeobj2, obj2 shall be destroyed beforeT3, andT3 shall be destroyed beforeobj1.
—end example]
6.9 Types [basic.types]
6.9.1 General [basic.types.general]
1 [Note 1: 6.9 and the subclauses thereof impose requirements on implementations regarding the representation of
types. There are two kinds of types: fundamental types and compound types. Types describe objects (6.8.2),
references (9.3.4.3), or functions (9.3.4.6).—end note]
2 For any object (other than a potentially-overlapping subobject) of trivially copyable typeT, whether or not
the object holds a valid value of typeT, the underlying bytes (6.8.1) making up the object can be copied into
an array ofchar, unsigned char, orstd::byte (17.2.1).22 If the content of that array is copied back into
the object, the object shall subsequently hold its original value.
[Example 1:
constexpr std::size_t N = sizeof(T);
char buf[N];
T obj; // obj initialized to its original value
std::memcpy(buf, &obj, N); // between these two calls tostd::memcpy, obj might be modified
std::memcpy(&obj, buf, N); // at this point, each subobject ofobj of scalar type holds its original value
—end example]
3 For two distinct objectsobj1 and obj2 of trivially copyable typeT, where neither obj1 nor obj2 is a
potentially-overlapping subobject, if the underlying bytes (6.8.1) making upobj1 are copied intoobj2,23
obj2 shall subsequently hold the same value asobj1.
[Example 2:
T* t1p;
T* t2p;
// provided thatt2p points to an initialized object ...
std::memcpy(t1p, t2p, sizeof(T));
22) By using, for example, the library functions (16.4.2.3)std::memcpy or std::memmove.
23) By using, for example, the library functions (16.4.2.3)std::memcpy or std::memmove.
§ 6.9.1 © ISO/IEC
79

===== PAGE 91 =====

Dxxxx
// at this point, every subobject of trivially copyable type in*t1p contains
// the same value as the corresponding subobject in*t2p
—end example]
4 The object representationof a complete object typeT is the sequence ofN unsigned char objects taken
up by a non-bit-field complete object of typeT, whereN equals sizeof(T). The value representationof a
type T is the set of bits in the object representation ofT that participate in representing a value of typeT.
The object and value representation of a non-bit-field complete object are the bytes and bits, respectively, of
the object corresponding to the object and value representation of its type. The object representation of a
bit-field object is the sequence ofN bits taken up by the object, whereN is the width of the bit-field (11.4.10).
The value representation of a bit-field object is the set of bits in the object representation that participate in
representing its value. Bits in the object representation of a type or object that are not part of the value
representation arepadding bits. For trivially copyable types, the value representation is a set of bits in the
object representation that determines avalue, which is one discrete element of an implementation-defined set
of values.24
5 A class that has been declared but not defined, an enumeration type in certain contexts (9.8.1), or an array of
unknown bound or of incomplete element type, is anincompletely-defined object type.25 Incompletely-defined
object types andcv void are incomplete types(6.9.2).
[Note 2: Objects cannot be defined to have an incomplete type (6.2).—end note]
6 A class type (such as “class X”) can be incomplete at one point in a translation unit and complete later on;
the type “class X” is the same type at both points. The declared type of an array object can be an array of
incomplete class type and therefore incomplete; if the class type is completed later on in the translation unit,
the array type becomes complete; the array type at those two points is the same type. The declared type of
an array object can be an array of unknown bound and therefore be incomplete at one point in a translation
unit and complete later on; the array types at those two points (“array of unknown bound ofT” and “array
of N T”) are different types.
[Note 3: The type of a pointer or reference to array of unknown bound permanently points to or refers to an incomplete
type. An array of unknown bound named by atypedef declaration permanently refers to an incomplete type. In
either case, the array type cannot be completed.—end note]
[Example 3:
class X; // X is an incomplete type
extern X* xp; // xp is a pointer to an incomplete type
extern int arr[]; // the type of arr is incomplete
typedef int UNKA[]; // UNKA is an incomplete type
UNKA* arrp; // arrp is a pointer to an incomplete type
UNKA** arrpp;
void foo() {
xp++; // error: X is incomplete
arrp++; // error: incomplete type
arrpp++; // OK,sizeof(UNKA*) is known
}
struct X { int i; }; // now X is a complete type
int arr[10]; // now the type ofarr is complete
X x;
void bar() {
xp = &x; // OK, type is “pointer toX”
arrp = &arr; // OK, qualification conversion (7.3.6)
xp++; // OK,X is complete
arrp++; // error: UNKA can’t be completed
}
—end example]
7 [Note 4: The rules for declarations and expressions describe in which contexts incomplete types are prohibited.—end
note]
24) The intent is that the memory model of C++ is compatible with that of the C programming language.
25) The size and layout of an instance of an incompletely-defined object type is unknown.
§ 6.9.1 © ISO/IEC
80

===== PAGE 92 =====

Dxxxx
8 An object typeis a (possibly cv-qualified) type that is not a function type, not a reference type, and not
cv void.
9 Arithmetic types (6.9.2), enumeration types, pointer types, pointer-to-member types (6.9.4),std::meta::
info, std::nullptr_t, and cv-qualified (6.9.5) versions of these types are collectively calledscalar types.
Scalar types, trivially copyable class types (11.2), arrays of such types, and cv-qualified versions of these
types are collectively calledtrivially copyable types. Scalar types, standard-layout class types (11.2), arrays of
such types, and cv-qualified versions of these types are collectively calledstandard-layout types. Scalar types,
implicit-lifetime class types (11.2), array types, and cv-qualified versions of these types are collectively called
implicit-lifetime types.
10 A type is aliteral typeif it is:
—(10.1) cv void; or
—(10.2) a scalar type; or
—(10.3) a reference type; or
—(10.4) an array of literal type; or
—(10.5) a possibly cv-qualified class type (Clause 11) that has all of the following properties:
—(10.5.1) it has a constexpr destructor (9.2.6),
—(10.5.2) all of its non-variant non-static data members and base classes are of non-volatile literal types, and
—(10.5.3) it
—(10.5.3.1) is a closure type (7.5.6.2),
—(10.5.3.2) is an aggregate union type that has either no variant members or at least one variant member
of non-volatile literal type,
—(10.5.3.3) is a non-union aggregate type for which each of its anonymous union members satisfies the
above requirements for an aggregate union type, or
—(10.5.3.4) has at least one constexpr constructor or constructor template (possibly inherited (9.10) from
a base class) that is not a copy or move constructor.
[Note 5: A literal type is one for which it might be possible to create an object within a constant expression. It is
not a guarantee that it is possible to create such an object, nor is it a guarantee that any object of that type will be
usable in a constant expression.—end note]
11 Two typescv1 T1 and cv2 T2 are layout-compatible typesif T1 and T2 are the same type, layout-compatible
enumerations (9.8.1), or layout-compatible standard-layout class types (11.4).
12 A type isconsteval-only if it is
—(12.1) std::meta::info,
—(12.2) cv T, whereT is a consteval-only type,
—(12.3) a pointer or reference to a consteval-only type,
—(12.4) an array of consteval-only type,
—(12.5) a function type having a return type or any parameter type that is consteval-only,
—(12.6) a class type with any non-static data member having consteval-only type, or
—(12.7) a type “pointer to member of classC of typeT”, where at least one ofC or T is a consteval-only type.
Every object of consteval-only type shall be
—(12.8) the object associated with a constexpr variable or a subobject thereof,
—(12.9) a template parameter object (13.2) or a subobject thereof, or
—(12.10) an object whose lifetime begins and ends during the evaluation of a core constant expression.
Every function of consteval-only type shall be an immediate function (7.7).
6.9.2 Fundamental types [basic.fundamental]
1 There are fivestandard signed integer types: “signed char”, “short int”, “int”, “long int”, and “long
long int”. In this list, each type provides at least as much storage as those preceding it in the list. There
may also be implementation-definedextended signed integer types. The standard and extended signed integer
§ 6.9.2 © ISO/IEC
81

===== PAGE 93 =====

Dxxxx
types are collectively calledsigned integer types. The range of representable values for a signed integer type
is −2N−1 to 2N−1 −1 (inclusive), whereN is called thewidth of the type.
[Note 1: Plainints are intended to have the natural width suggested by the architecture of the execution environment;
the other signed integer types are provided to meet special needs.—end note]
2 For each of the standard signed integer types, there exists a corresponding (but different)standard un-
signed integer type: “unsigned char”, “unsigned short int”, “unsigned int”, “unsigned long int”,
and “unsigned long long int”. Likewise, for each of the extended signed integer types, there exists a cor-
responding extended unsigned integer type. The standard and extended unsigned integer types are collectively
called unsigned integer types. An unsigned integer type has the same widthN as the corresponding signed
integer type. The range of representable values for the unsigned type is0 to 2N −1 (inclusive); arithmetic
for the unsigned type is performed modulo2N.
[Note 2: Unsigned arithmetic does not overflow. Overflow for signed arithmetic yields undefined behavior (7.1).
—end note]
3 An unsigned integer type has the same object representation, value representation, and alignment requirements
(6.8.3) as the corresponding signed integer type. For each valuex of a signed integer type, the value of the
corresponding unsigned integer type congruent tox modulo 2N has the same value of corresponding bits in
its value representation.26
[Example 1: The value−1 of a signed integer type has the same representation as the largest value of the corresponding
unsigned type. —end example]
Table 14 — Minimum width [tab:basic.fundamental.width]
Type Minimum width N
signed char 8
short int 16
int 16
long int 32
long long int 64
4 The width of each standard signed integer type shall not be less than the values specified in Table 14. The
value representation of a signed or unsigned integer type comprisesN bits, where N is the respective width.
Each set of values for any padding bits (6.9.1) in the object representation are alternative representations of
the value specified by the value representation.
[Note 3: Padding bits have unspecified value, but cannot cause traps. In contrast, see ISO/IEC 9899:2024 6.2.6.2.
—end note]
[Note 4: The signed and unsigned integer types satisfy the constraints given in ISO/IEC 9899:2024 5.3.5.3.2.—end
note]
Except as specified above, the width of a signed or unsigned integer type is implementation-defined.
5 Each valuex of an unsigned integer type with widthN has a unique representationx = x020 + x121 +
... + xN−12N−1, where each coefficientxi is either 0 or 1; this is called thebase-2 representationof x. The
base-2 representation of a value of signed integer type is the base-2 representation of the congruent value of
the corresponding unsigned integer type. The standard signed integer types and standard unsigned integer
types are collectively called thestandard integer types, and the extended signed integer types and extended
unsigned integer types are collectively called theextended integer types.
6 A fundamental type specified to have a signed or unsigned integer type as itsunderlying typehas the same
object representation, value representation, alignment requirements (6.8.3), and range of representable values
as the underlying type. Further, each value has the same representation in both types.
7 Type char is a distinct type that has an implementation-defined choice of “signed char” or “unsigned
char” as its underlying type. The three typeschar, signed char, andunsigned char are collectively called
ordinary character types. The ordinary character types andchar8_t are collectively callednarrow character
types. For narrow character types, each possible bit pattern of the object representation represents a distinct
value.
26) This is also known as two’s complement representation.
§ 6.9.2 © ISO/IEC
82

===== PAGE 94 =====

Dxxxx
[Note 5: This requirement does not hold for other types.—end note]
[Note 6: A bit-field of narrow character type whose width is larger than the width of that type has padding bits; see
6.9.1. —end note]
8 Type wchar_t is a distinct type that has an implementation-defined signed or unsigned integer type as its
underlying type.
9 Type char8_t denotes a distinct type whose underlying type isunsigned char. Types char16_t and
char32_tdenote distinct types whose underlying types arestd::uint_least16_tandstd::uint_least32_-
t, respectively, in<cstdint> (17.4.1).
10 Type bool is a distinct type that has the same object representation, value representation, and alignment
requirements as an implementation-defined unsigned integer type. The values of typebool are true and
false.
[Note 7: There are nosigned, unsigned, short, orlong bool types or values.—end note]
11 The typeschar, wchar_t, char8_t, char16_t, andchar32_t are collectively calledcharacter types. The
character types,bool, the signed and unsigned integer types, and cv-qualified versions (6.9.5) thereof, are
collectively termedintegral types. A synonym for integral type isinteger type.
[Note 8: Enumerations (9.8.1) are not integral; however, unscoped enumerations can be promoted to integral types as
specified in 7.3.7. —end note]
12 The three distinct typesfloat, double, andlong double can represent floating-point numbers. The type
double provides at least as much precision asfloat, and the typelong double provides at least as much
precision asdouble. The set of values of the typefloat is a subset of the set of values of the typedouble;
the set of values of the typedouble is a subset of the set of values of the typelong double. The types
float, double, andlong double, and cv-qualified versions (6.9.5) thereof, are collectively termedstandard
floating-point types. An implementation may also provide additional types that represent floating-point values
and define them (and cv-qualified versions thereof) to beextended floating-point types. The standard and
extended floating-point types are collectively termedfloating-point types.
[Note 9: Any additional implementation-specific types representing floating-point values that are not defined by the
implementation to be extended floating-point types are not considered to be floating-point types, and this document
imposes no requirements on them or their interactions with floating-point types.—end note]
Except as specified in 6.9.3, the object and value representations and accuracy of operations of floating-point
types are implementation-defined.
13 The minimum range of representable values for a floating-point type is the most negative finite floating-point
number representable in that type through the most positive finite floating-point number representable in
that type. In addition, if negative infinity is representable in a type, the range of that type is extended to
all negative real numbers; likewise, if positive infinity is representable in a type, the range of that type is
extended to all positive real numbers.
[Note 10: Since negative and positive infinity are representable in ISO/IEC 60559 formats, all real numbers lie within
the range of representable values of a floating-point type adhering to ISO/IEC 60559.—end note]
14 Integral and floating-point types are collectively termedarithmetic types.
[Note 11: Properties of the arithmetic types, such as their minimum and maximum representable value, can be queried
using the facilities in the standard library headers<limits> (17.3.3), <climits> (17.3.6), and <cfloat> (17.3.7).
—end note]
15 A typecv void is an incomplete type that cannot be completed; such a type has an empty set of values. It is
used as the return type for functions that do not return a value.
[Note 12: An expression of typecv void can be used as
—(15.1) an expression statement (8.3),
—(15.2) the expression in areturn statement (8.8.4) for a function with the return typecv void,
—(15.3) an operand of a comma expression (7.6.20),
—(15.4) the operand of a parenthesized expression (7.5.4),
—(15.5) a requirement in arequires-expression (7.5.8.1),
—(15.6) the second or third operand of?: (7.6.16),
—(15.7) the operand of atypeid expression (7.6.1.8),
—(15.8) the operand of anoexcept operator (7.6.2.7),
§ 6.9.2 © ISO/IEC
83

===== PAGE 95 =====

Dxxxx
—(15.9) the operand of adecltype specifier (9.2.9.6), or
—(15.10) the operand of an explicit conversion to typecv void (7.6.1.4, 7.6.1.9, 7.6.3).
—end note]
16 The types denoted bycv std::nullptr_t are distinct types. A prvalue of typestd::nullptr_t is a null
pointer constant (7.3.12). Such values participate in the pointer and the pointer-to-member conversions (7.3.12,
7.3.13). sizeof(std::nullptr_t) shall be equal tosizeof(void*).
17 A value of typestd::meta::info is called areflection. There exists a uniquenull reflection; every other
reflection is a representation of
—(17.1) a value of scalar type (13.2),
—(17.2) an object with static storage duration (6.8.6),
—(17.3) a variable (6.1),
—(17.4) a structured binding (9.7),
—(17.5) a function (9.3.4.6),
—(17.6) a function parameter,
—(17.7) an enumerator (9.8.1),
—(17.8) an annotation (9.13.1),
—(17.9) a type alias (9.2.4),
—(17.10) a type (6.9),
—(17.11) a class member (11.4),
—(17.12) an unnamed bit-field (11.4.10),
—(17.13) a class template (13.1),
—(17.14) a function template,
—(17.15) a variable template,
—(17.16) an alias template (13.7.8),
—(17.17) a concept (13.7.9),
—(17.18) a namespace alias (9.9.3),
—(17.19) a namespace (9.9.1),
—(17.20) a direct base class relationship (11.7.1), or
—(17.21) a data member description (11.4.1).
A reflection is said torepresent the corresponding construct.
[Note 13: A reflection of a value can be produced by library functions such asstd::meta::constant_of and
std::meta::reflect_constant. —end note]
[Example 2:
int arr[] = {1, 2, 3};
auto [a1, a2, a3] = arr;
[[=1]] void fn(int n);
enum Enum { A };
using Alias = int;
struct B {};
struct S : B {
int mem;
int : 0;
};
template<auto> struct TCls {};
template<auto> void TFn();
template<auto> int TVar;
template<auto N> using TAlias = TCls<N>;
template<auto> concept Concept = requires { true; };
namespace NS {};
namespace NSAlias = NS;
§ 6.9.2 © ISO/IEC
84

===== PAGE 96 =====

Dxxxx
constexpr auto ctx = std::meta::access_context::current();
constexpr auto r1 = std::meta::reflect_constant(42); // representsint value of 42
constexpr auto r2 = std::meta::reflect_object(arr[1]); // representsint object
constexpr auto r3 = ^^arr; // represents a variable
constexpr auto r4 = ^^a3; // represents a structured binding
constexpr auto r5 = ^^fn; // represents a function
constexpr auto r6 = std::meta::parameters_of(^^fn)[0]; // represents a function parameter
constexpr auto r7 = ^^Enum::A; // represents an enumerator
constexpr auto r8 = std::meta::annotations_of(^^fn)[0]; // represents an annotation
constexpr auto r9 = ^^Alias; // represents a type alias
constexpr auto r10 = ^^S; // represents a type
constexpr auto r11 = ^^S::mem; // represents a class member
constexpr auto r12 = std::meta::members_of(^^S, ctx)[1]; // represents an unnamed bit-field
constexpr auto r13 = ^^TCls; // represents a class template
constexpr auto r14 = ^^TFn; // represents a function template
constexpr auto r15 = ^^TVar; // represents a variable template
constexpr auto r16 = ^^TAlias; // represents an alias template
constexpr auto r17 = ^^Concept; // represents a concept
constexpr auto r18 = ^^NSAlias; // represents a namespace alias
constexpr auto r19 = ^^NS; // represents a namespace
constexpr auto r20 = std::meta::bases_of(^^S, ctx)[0]; // represents a direct base class relationship
constexpr auto r21 =
std::meta::data_member_spec(^^int, {.name="member"}); // represents a data member description
—end example]
18 Recommended practice: Implementations should not represent other constructs specified in this document,
such as using-declarators, partial template specializations, attributes, placeholder types, statements, or
expressions, as values of typestd::meta::info.
[Note 14: Future revisions of this document can specify semantics for reflections representing any such constructs.
—end note]
19 The types described in this subclause are calledfundamental types.
[Note 15: Even if the implementation defines two or more fundamental types to have the same value representation,
they are nevertheless different types.—end note]
6.9.3 Optional extended floating-point types [basic.extended.fp]
1 If the implementation supports an extended floating-point type (6.9.2) whose properties are specified by
the ISO/IEC 60559 floating-point interchange format binary16, then thetypedef-name std::float16_t is
declared in the header<stdfloat> (17.4.2) and names such a type, the macro__STDCPP_FLOAT16_T__ is
defined (15.12), and the floating-point literal suffixesf16 and F16 are supported (5.13.4).
2 If the implementation supports an extended floating-point type whose properties are specified by the ISO/IEC
60559 floating-point interchange format binary32, then thetypedef-name std::float32_t is declared in
the header <stdfloat> and names such a type, the macro__STDCPP_FLOAT32_T__ is defined, and the
floating-point literal suffixesf32 and F32 are supported.
3 If the implementation supports an extended floating-point type whose properties are specified by the ISO/IEC
60559 floating-point interchange format binary64, then thetypedef-name std::float64_t is declared in
the header <stdfloat> and names such a type, the macro__STDCPP_FLOAT64_T__ is defined, and the
floating-point literal suffixesf64 and F64 are supported.
4 If the implementation supports an extended floating-point type whose properties are specified by the ISO/IEC
60559 floating-point interchange format binary128, then thetypedef-name std::float128_t is declared in
the header <stdfloat> and names such a type, the macro__STDCPP_FLOAT128_T__ is defined, and the
floating-point literal suffixesf128 and F128 are supported.
5 If the implementation supports an extended floating-point type with the properties, as specified by ISO/IEC
60559, of radix (b) of 2, storage width in bits (k) of 16, precision in bits (p) of 8, maximum exponent (emax)
of 127, and exponent field width in bits (w) of 8, then thetypedef-name std::bfloat16_t is declared in
the header <stdfloat> and names such a type, the macro__STDCPP_BFLOAT16_T__ is defined, and the
floating-point literal suffixesbf16 and BF16 are supported.
§ 6.9.3 © ISO/IEC
85

===== PAGE 97 =====

Dxxxx
6 [Note 1: A summary of the parameters for each type is given in Table 15. The precisionp includes the implicit 1
bit at the beginning of the significand, so the storage used for the significand isp−1 bits. ISO/IEC 60559 does not
assign a name for a type having the parameters specified forstd::bfloat16_t. —end note]
Table 15 — Properties of named extended floating-point types [tab:basic.extended.fp]
Parameter float16_t float32_t float64_t float128_t bfloat16_t
ISO/IEC 60559 name binary16 binary32 binary64 binary128
k, storage width in bits 16 32 64 128 16
p, precision in bits 11 24 53 113 8
emax, maximum exponent 15 127 1023 16383 127
w, exponent field width in bits 5 8 11 15 8
7 Recommended practice: Any names that the implementation provides for the extended floating-point types
described in this subsection that are in addition to the names declared in the<stdfloat> header should
be chosen to increase compatibility and interoperability with the interchange types_Float16, _Float32,
_Float64, and_Float128 defined in ISO/IEC TS 18661-3 and with future versions of ISO/IEC 9899.
6.9.4 Compound types [basic.compound]
1 Compound types can be constructed in the following ways:
—(1.1) arrays of objects of a given type, 9.3.4.5;
—(1.2) functions, which have parameters of given types and returnvoid or a result of a given type, 9.3.4.6;
—(1.3) pointers to cv void or objects or functions (including static members of classes) of a given type, 9.3.4.2;
—(1.4) referencesto objects or functions of a given type, 9.3.4.3. There are two types of references:
—(1.4.1) lvalue reference
—(1.4.2) rvalue reference
—(1.5) classes containing a sequence of class members (Clause 11, 11.4), and a set of restrictions on the access
to these entities (11.8);
—(1.6) unions, which are classes capable of containing objects of different types at different times, 11.5;
—(1.7) enumerations, which comprise a set of named constant values, 9.8.1;
—(1.8) pointers to non-static class members,27 which identify members of a given type within objects of a
given class, 9.3.4.4. Pointers to data members and pointers to member functions are collectively called
pointer-to-member types.
2 These methods of constructing types can be applied recursively; restrictions are mentioned in 9.3.4. Con-
structing a type such that the number of bytes in its object representation exceeds the maximum value
representable in the typestd::size_t (17.2) is ill-formed.
3 The type of a pointer tocv void or a pointer to an object type is called anobject pointer type.
[Note 1: A pointer tovoid does not have a pointer-to-object type, however, becausevoid is not an object type.
—end note]
The type of a pointer that can designate a function is called afunction pointer type. A pointer to an object
of typeT is referred to as a “pointer toT”.
[Example 1: A pointer to an object of typeint is referred to as “pointer toint” and a pointer to an object of classX
is called a “pointer toX”. —end example]
Except for pointers to static members, text referring to “pointers” does not apply to pointers to members.
Pointers to incomplete types are allowed although there are restrictions on what can be done with them (6.9.1).
Every value of pointer type is one of the following:
—(3.1) a pointer toan object or function (the pointer is said topoint to the object or function), or
—(3.2) a pointer past the end ofan object (7.6.6), or
—(3.3) the null pointer valuefor that type, or
27) Static class members are objects or functions, and pointers to them are ordinary pointers to objects or functions.
§ 6.9.4 © ISO/IEC
86

===== PAGE 98 =====

Dxxxx
—(3.4) an invalid pointer value.
A value of a pointer type that is a pointer to or past the end of an objectrepresents the addressof the first
byte in memory (6.8.1) occupied by the object28 or the first byte in memory after the end of the storage
occupied by the object, respectively.
[Note 2: A pointer past the end of an object (7.6.6) is not considered to point to an unrelated object of the object’s
type, even if the unrelated object is located at that address.—end note]
For purposes of pointer arithmetic (7.6.6) and comparison (7.6.9, 7.6.10), a pointer past the end of the
last element of an arrayx of n elements is considered to be equivalent to a pointer to a hypothetical array
element n of x, and an object of typeT that is not an array element is considered to belong to an array with
one element of typeT. The value representation of pointer types is implementation-defined. Pointers to
layout-compatible types shall have the same value representation and alignment requirements (6.8.3).
[Note 3: Pointers to over-aligned types (6.8.3) have no special representation, but their range of valid values is
restricted by the extended alignment requirement.—end note]
4 A pointer valueP is valid in the context ofan evaluationE if P is a pointer to function or a null pointer
value, or if it is a pointer to or past the end of an objectO and E happens before the end of the duration
of the region of storage forO. If a pointer valueP is used in an evaluationE and P is not valid in the
context ofE, then the behavior is undefined ifE is an indirection (7.6.2.2) or an invocation of a deallocation
function (6.8.6.5.3), and implementation-defined otherwise.29
[Note 4: P can be valid in the context ofE even if it points to a type unrelated to that ofO or ifO is not within its
lifetime, although further restrictions apply to such pointer values (6.8.4, 7.2.1, 7.6.6).—end note]
5 Two objectsa and b are pointer-interconvertibleif
—(5.1) they are the same object, or
—(5.2) one is a union object and the other is a non-static data member of that object (11.5), or
—(5.3) one is a standard-layout class object and the other is the first non-static data member of that object or
any base class subobject of that object (11.4), or
—(5.4) there exists an object c such that a and c are pointer-interconvertible, and c and b are pointer-
interconvertible.
If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a
pointer to one from a pointer to the other via areinterpret_cast (7.6.1.10).
[Note 5: An array object and its first element are not pointer-interconvertible, even though they have the same
address. —end note]
6 A byte of storageb is reachable througha pointer value that points to an objectx if there is an objecty,
pointer-interconvertible withx, such thatb is within the storage occupied byy, or the immediately-enclosing
array object ify is an array element.
7 A pointer tocv void can be used to point to objects of unknown type. Such a pointer shall be able to hold
any object pointer. An object of type “pointer tocv void” shall have the same representation and alignment
requirements as an object of type “pointer tocv char”.
6.9.5 CV-qualifiers [basic.type.qualifier]
1 Each type other than a function or reference type is part of a group of four distinct, but related, types:
a cv-unqualified version, aconst-qualified version, avolatile-qualified version, and aconst-volatile-qualified
version. The types in each such group shall have the same representation and alignment requirements (6.8.3).30
A function or reference type is always cv-unqualified.
—(1.1) A const objectis an object of typeconst T or a non-mutable subobject of a const object.
—(1.2) A volatile objectis an object of typevolatile T or a subobject of a volatile object.
—(1.3) A const volatile objectis an object of typeconst volatile T, a non-mutable subobject of a const
volatile object, a const subobject of a volatile object, or a non-mutable volatile subobject of a const
object.
28) For an object that is not within its lifetime, this is the first byte in memory that it will occupy or used to occupy.
29) Some implementations might define that copying such a pointer value causes a system-generated runtime fault.
30) The same representation and alignment requirements are meant to imply interchangeability as arguments to functions,
return values from functions, and non-static data members of unions.
§ 6.9.5 © ISO/IEC
87

===== PAGE 99 =====

Dxxxx
[Note 1: The type of an object (6.8.2) includes thecv-qualifiers specified in thedecl-specifier-seq (9.2), declarator (9.3),
type-id (9.3.2), ornew-type-id (7.6.2.8) when the object is created.—end note]
2 Except for array types, a compound type (6.9.4) is not cv-qualified by the cv-qualifiers (if any) of the types
from which it is compounded.
3 An array type whose elements are cv-qualified is also considered to have the same cv-qualifications as its
elements.
[Note 2: Cv-qualifiers applied to an array type attach to the underlying element type, so the notation “cv T”, whereT
is an array type, refers to an array whose elements are so-qualified (9.3.4.5).—end note]
[Example 1:
typedef char CA[5];
typedef const char CC;
CC arr1[5] = { 0 };
const CA arr2 = { 0 };
The type of botharr1 and arr2 is “array of 5const char”, and the array type is considered to be const-qualified.
—end example]
4 [Note 3: See 9.3.4.6 and 12.2.2 regarding function types that havecv-qualifiers. —end note]
5 There is a partial ordering on cv-qualifiers, so that a type can be said to bemore cv-qualifiedthan another.
Table 16 shows the relations that constitute this ordering.
Table 16 — Relations onconst and volatile [tab:basic.type.qualifier.rel]
no cv-qualifier < const
no cv-qualifier < volatile
no cv-qualifier < const volatile
const < const volatile
volatile < const volatile
6 In this document, the notationcv (or cv1, cv2, etc.), used in the description of types, represents an arbitrary
set of cv-qualifiers, i.e., one of {const}, {volatile}, {const, volatile}, or the empty set. For a typecv T,
the top-level cv-qualifiersof that type are those denoted bycv.
[Example 2: The type corresponding to thetype-id const int& has no top-level cv-qualifiers. The type corresponding
to thetype-id volatile int * const has the top-level cv-qualifierconst. For a class typeC, the type corresponding
to thetype-id void (C::* volatile)(int) const has the top-level cv-qualifiervolatile. —end example]
6.9.6 Conversion ranks [conv.rank]
1 Every integer type has aninteger conversion rankdefined as follows:
—(1.1) No two signed integer types other thanchar and signed char (if char is signed) have the same rank,
even if they have the same representation.
—(1.2) The rank of a signed integer type is greater than the rank of any signed integer type with a smaller
width.
—(1.3) The rank oflong long int is greater than the rank oflong int, which is greater than the rank of
int, which is greater than the rank ofshort int, which is greater than the rank ofsigned char.
—(1.4) The rank of any unsigned integer type equals the rank of the corresponding signed integer type.
—(1.5) The rank of any standard integer type is greater than the rank of any extended integer type with the
same width.
—(1.6) The rank ofchar equals the rank ofsigned char and unsigned char.
—(1.7) The rank ofbool is less than the rank of all standard integer types.
—(1.8) The ranks ofchar8_t, char16_t, char32_t, andwchar_t equal the ranks of their underlying types
(6.9.2).
—(1.9) The rank of any extended signed integer type relative to another extended signed integer type with the
same width is implementation-defined, but still subject to the other rules for determining the integer
conversion rank.
§ 6.9.6 © ISO/IEC
88

===== PAGE 100 =====

Dxxxx
—(1.10) For all integer typesT1, T2, andT3, ifT1 has greater rank thanT2 and T2 has greater rank thanT3,
then T1 has greater rank thanT3.
[Note 1: The integer conversion rank is used in the definition of the integral promotions (7.3.7) and the usual
arithmetic conversions (7.4).—end note]
2 Every floating-point type has afloating-point conversion rankdefined as follows:
—(2.1) The rank of a floating-point typeT is greater than the rank of any floating-point type whose set of
values is a proper subset of the set of values ofT.
—(2.2) The rank oflong double is greater than the rank ofdouble, which is greater than the rank offloat.
—(2.3) Two extended floating-point types with the same set of values have equal ranks.
—(2.4) An extended floating-point type with the same set of values as exactly one cv-unqualified standard
floating-point type has a rank equal to the rank of that standard floating-point type.
—(2.5) An extended floating-point type with the same set of values as more than one cv-unqualified standard
floating-point type has a rank equal to the rank ofdouble.
[Note 2: The treatment ofstd::float64_t differs from that of the analogous_Float64 in C, for example on
platforms where all oflong double, double, andstd::float64_t have the same set of values (see ISO/IEC
9899:2024H.4.3). —end note]
[Note 3: The conversion ranks of floating-point typesT1 and T2 are unordered if the set of values ofT1 is neither a
subset nor a superset of the set of values ofT2. This can happen when one type has both a larger range and a lower
precision than the other.—end note]
3 Floating-point types that have equal floating-point conversion ranks are ordered by floating-point conversion
subrank. The subrank forms a total order among types with equal ranks. The typesstd::float16_t,
std::float32_t, std::float64_t, andstd::float128_t (17.4.2) have a greater conversion subrank than
any standard floating-point type with equal conversion rank. Otherwise, the conversion subrank order is
implementation-defined.
4 [Note 4: The floating-point conversion rank and subrank are used in the definition of the usual arithmetic conversions
(7.4). —end note]
6.10 Program execution [basic.exec]
6.10.1 Sequential execution [intro.execution]
1 An instance of each object with automatic storage duration (6.8.6.4) is associated with each entry into its
block. Such an object exists and retains its last-stored value during the execution of the block and while the
block is suspended (by a call of a function, suspension of a coroutine (7.6.2.4), or receipt of a signal).
2 A constituent expressionis defined as follows:
—(2.1) The constituent expression of an expression is that expression.
—(2.2) The constituent expression of a conversion is the corresponding implicit function call, if any, or the
converted expression otherwise.
—(2.3) The constituent expressions of abraced-init-list or of a (possibly parenthesized)expression-list are the
constituent expressions of the elements of the respective list.
—(2.4) The constituent expressions of abrace-or-equal-initializer of the form=initializer-clause are the constituent
expressions of theinitializer-clause.
[Example 1:
struct A { int x; };
struct B { int y; struct A a; };
B b = { 5, { 1+1 } };
The constituent expressions of theinitializer used for the initialization ofb are 5 and 1+1. —end example]
3 The immediate subexpressionsof an expressionE are
—(3.1) the constituent expressions ofE’s operands (7.2),
—(3.2) any function call thatE implicitly invokes,
—(3.3) if E is alambda-expression (7.5.6), the initialization of the entities captured by copy and the constituent
expressions of theinitializer of theinit-captures,
§ 6.10.1 © ISO/IEC
89

===== PAGE 101 =====

Dxxxx
—(3.4) if E is a function call (7.6.1.3) or implicitly invokes a function, the constituent expressions of each
default argument (9.3.4.7) used in the call, or
—(3.5) if E creates an aggregate object (9.5.2), the constituent expressions of each default member initializer
(11.4) used in the initialization.
4 A subexpression of an expressionE is an immediate subexpression ofE or a subexpression of an immediate
subexpression ofE.
[Note 1: Expressions appearing in thecompound-statement of a lambda-expression are not subexpressions of the
lambda-expression. —end note]
The potentially-evaluated subexpressionsof an expression, conversion, orinitializer E are
—(4.1) the constituent expressions ofE and
—(4.2) the subexpressions thereof that are not subexpressions of a nested unevaluated operand (7.2.3).
5 A full-expression is
—(5.1) an unevaluated operand (7.2.3),
—(5.2) a constant-expression (7.7),
—(5.3) an immediate invocation (7.7),
—(5.4) an init-declarator (9.3) (including such introduced by a structured binding (9.7)) or amem-initializer
(11.9.3), including the constituent expressions of the initializer,
—(5.5) an invocation of a destructor generated at the end of the lifetime of an object other than a temporary
object (6.8.7) whose lifetime has not been extended,
—(5.6) the predicate of a contract assertion (6.11), or
—(5.7) an expression that is not a subexpression of another expression and that is not otherwise part of a
full-expression.
If a language construct is defined to produce an implicit call of a function, a use of the language construct is
considered to be an expression for the purposes of this definition. Conversions applied to the result of an
expression in order to satisfy the requirements of the language construct in which the expression appears are
also considered to be part of the full-expression. For an initializer, performing the initialization of the entity
(including evaluating default member initializers of an aggregate) is also considered part of the full-expression.
[Example 2:
struct S {
S(int i): I(i) { } // full-expression is initialization ofI
int& v() { return I; }
~S() noexcept(false) { }
private:
int I;
};
S s1(1); // full-expression comprises call ofS::S(int)
void f() {
S s2 = 2; // full-expression comprises call ofS::S(int)
if (S(3).v()) // full-expression includes lvalue-to-rvalue andint to bool conversions,
// performed before temporary is deleted at end of full-expression
{ }
bool b = noexcept(S(4)); // exception specification of destructor ofS considered fornoexcept
// full-expression is destruction ofs2 at end of block
}
struct B {
B(S = S(0));
};
B b[2] = { B(), B() }; // full-expression is the entire initialization
// including the destruction of temporaries
—end example]
§ 6.10.1 © ISO/IEC
90

===== PAGE 102 =====

Dxxxx
6 [Note 2: The evaluation of a full-expression can include the evaluation of subexpressions that are not lexically part of
the full-expression. For example, subexpressions involved in evaluating default arguments (9.3.4.7) are considered to
be created in the expression that calls the function, not the expression that defines the default argument.—end note]
7 Reading an object designated by avolatile glvalue (7.2.1), modifying an object, producing an injected
declaration (7.7), calling a library I/O function, or calling a function that does any of those operations are
all side effects, which are changes in the state of the execution or translation environment.Evaluation of
an expression (or a subexpression) in general includes both value computations (including determining the
identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue
evaluation) and initiation of side effects. When a call to a library I/O function returns or an access through a
volatile glvalue is evaluated, the side effect is considered complete, even though some external actions implied
by the call (such as the I/O itself) or by thevolatile access may not have completed yet.
8 Sequenced beforeis an asymmetric, transitive, pair-wise relation between evaluations executed by a single
thread (6.10.2), which induces a partial order among those evaluations. Given any two evaluationsA and B,
if A is sequenced beforeB (or, equivalently,B is sequenced after A), then the execution ofA shall precede
the execution ofB. If A is not sequenced beforeB and B is not sequenced beforeA, then A and B are
unsequenced.
[Note 3: The execution of unsequenced evaluations can overlap.—end note]
Evaluations A and B are indeterminately sequencedwhen eitherA is sequenced beforeB or B is sequenced
before A, but it is unspecified which.
[Note 4: Indeterminately sequenced evaluations cannot overlap, but either can be executed first.—end note]
An expressionX is said to be sequenced before an expressionY if every value computation and every side
effect associated with the expressionX is sequenced before every value computation and every side effect
associated with the expressionY.
9 Every value computation and side effect associated with a full-expression is sequenced before every value
computation and side effect associated with the next full-expression to be evaluated.31
10 Except where noted, evaluations of operands of individual operators and of subexpressions of individual
expressions are unsequenced.
[Note 5: In an expression that is evaluated more than once during the execution of a program, unsequenced and
indeterminately sequenced evaluations of its subexpressions need not be performed consistently in different evaluations.
—end note]
The value computations of the operands of an operator are sequenced before the value computation of the
result of the operator. The behavior is undefined if
—(10.1) a side effect on a memory location (6.8.1) or
—(10.2) starting or ending the lifetime of an object in a memory location
is unsequenced relative to
—(10.3) another side effect on the same memory location,
—(10.4) starting or ending the lifetime of an object occupying storage that overlaps with the memory location,
or
—(10.5) a value computation using the value of any object in the same memory location,
and the two evaluations are not potentially concurrent (6.10.2).
[Note 6: Starting the lifetime of an object in a memory location can end the lifetime of objects in other memory
locations (6.8.4). —end note]
[Note 7: The next subclause imposes similar, but more complex restrictions on potentially concurrent computations.
—end note]
[Example 3:
void g(int i) {
i = 7, i++, i++; // i becomes9
i = i++ + 1; // the value ofi is incremented
i = i++ + i; // undefined behavior
31) As specified in 6.8.7, after a full-expression is evaluated, a sequence of zero or more invocations of destructor functions for
temporary objects takes place, usually in reverse order of the construction of each temporary object.
§ 6.10.1 © ISO/IEC
91

===== PAGE 103 =====

Dxxxx
i = i + 1; // the value ofi is incremented
union U { int x, y; } u;
(u.x = 1, 0) + (u.y = 2, 0); // undefined behavior
}
—end example]
11 When invoking a functionf (whether or not the function is inline), every argument expression and the postfix
expression designatingf are sequenced before every precondition assertion off (9.4.1), which in turn are
sequenced before every expression or statement in the body off, which in turn are sequenced before every
postcondition assertion off.
12 For each
—(12.1) function invocation,
—(12.2) evaluation of anawait-expression (7.6.2.4), or
—(12.3) evaluation of athrow-expression (7.6.18)
F, each evaluation that does not occur withinF but is evaluated on the same thread and as part of the same
signal handler (if any) is either sequenced before all evaluations that occur withinF or sequenced after all
evaluations that occur withinF;32 if F invokes or resumes a coroutine (7.6.2.4), only evaluations subsequent
to the previous suspension (if any) and prior to the next suspension (if any) are considered to occur withinF.
13 Several contexts in C++ cause evaluation of a function call, even though no corresponding function call syntax
appears in the translation unit.
[Example 4: Evaluation of anew-expression invokes one or more allocation and constructor functions; see 7.6.2.8. For
another example, invocation of a conversion function (11.4.8.3) can arise in contexts in which no function call syntax
appears. —end example]
14 The sequencing constraints on the execution of the called function (as described above) are features of the
function calls as evaluated, regardless of the syntax of the expression that calls the function.
15 If a signal handler is executed as a result of a call to thestd::raise function, then the execution of the
handler is sequenced after the invocation of thestd::raise function and before its return.
[Note 8: When a signal is received for another reason, the execution of the signal handler is usually unsequenced with
respect to the rest of the program.—end note]
16 During the evaluation of an expression as a core constant expression (7.7), evaluations of operands of
individual operators and of subexpressions of individual expressions that are otherwise either unsequenced or
indeterminately sequenced are evaluated in lexical order.
6.10.2 Multi-threaded executions and data races [intro.multithread]
6.10.2.1 General [intro.multithread.general]
1 A thread of execution(also known as athread) is a single flow of control within a program, including the initial
invocation of a specific top-level function, and recursively including every function invocation subsequently
executed by the thread.
[Note 1: When one thread creates another, the initial call to the top-level function of the new thread is executed by
the new thread, not by the creating thread.—end note]
Every thread in a program can potentially use every object and function in a program.33 Under a hosted
implementation, a C++ program can have more than one thread running concurrently. The execution of each
thread proceeds as defined by the remainder of this document. The execution of the entire program consists
of an execution of all of its threads.
[Note 2: Usually the execution can be viewed as an interleaving of all its threads. However, some kinds of atomic
operations, for example, allow executions inconsistent with a simple interleaving, as described below.—end note]
Under a freestanding implementation, it is implementation-defined whether a program can have more than
one thread of execution.
2 For a signal handler that is not executed as a result of a call to thestd::raise function, it is unspecified
which thread of execution contains the signal handler invocation.
32) In other words, function executions do not interleave with each other.
33) An object with automatic or thread storage duration (6.8.6) is associated with one specific thread, and can be accessed by
a different thread only indirectly through a pointer or reference (6.9.4).
§ 6.10.2.1 © ISO/IEC
92

===== PAGE 104 =====

Dxxxx
6.10.2.2 Data races [intro.races]
1 The value of an object visible to a threadT at a particular point is the initial value of the object, a value
assigned to the object byT, or a value assigned to the object by another thread, according to the rules below.
[Note 1: In some cases, there might instead be undefined behavior. Much of this subclause is motivated by the desire
to support atomic operations with explicit and detailed visibility constraints. However, it also implicitly supports a
simpler view for more restricted programs.—end note]
2 Two expression evaluationsconflict if one of them
—(2.1) modifies (3.1) a memory location (6.8.1) or
—(2.2) starts or ends the lifetime of an object in a memory location
and the other one
—(2.3) reads or modifies the same memory location or
—(2.4) starts or ends the lifetime of an object occupying storage that overlaps with the memory location.
[Note 2: A modification can still conflict even if it does not alter the value of any bits.—end note]
3 The library defines a number of atomic operations (32.5) and operations on mutexes (Clause 32) that are
specially identified as synchronization operations. These operations play a special role in making assignments
in one thread visible to another. A synchronization operation on one or more memory locations is either an
acquire operation, a release operation, or both an acquire and release operation. A synchronization operation
without an associated memory location is a fence and can be either an acquire fence, a release fence, or both
an acquire and release fence. In addition, there are relaxed atomic operations, which are not synchronization
operations, and atomic read-modify-write operations, which have special characteristics.
[Note 3: For example, a call that acquires a mutex will perform an acquire operation on the locations comprising the
mutex. Correspondingly, a call that releases the same mutex will perform a release operation on those same locations.
Informally, performing a release operation onA forces prior side effects on other memory locations to become visible
to other threads that later perform a consume or an acquire operation onA. “Relaxed” atomic operations are not
synchronization operations even though, like synchronization operations, they cannot contribute to data races.—end
note]
4 All modifications to a particular atomic objectM occur in some particular total order, called themodification
order of M.
[Note 4: There is a separate order for each atomic object. There is no requirement that these can be combined into a
single total order for all objects. In general this will be impossible since different threads can observe modifications to
different objects in inconsistent orders.—end note]
5 A release sequenceheaded by a release operationA on an atomic objectM is a maximal contiguous sub-
sequence of side effects in the modification order ofM, where the first operation isA, and every subsequent
operation is an atomic read-modify-write operation.
6 Certain library callssynchronize with other library calls performed by another thread. For example, an
atomic store-release synchronizes with a load-acquire that takes its value from the store (32.5.4).
[Note 5: Except in the specified cases, reading a later value does not necessarily ensure visibility as described below.
Such a requirement would sometimes interfere with efficient implementation.—end note]
[Note 6: The specifications of the synchronization operations define when one reads the value written by another. For
atomic objects, the definition is clear. All operations on a given mutex occur in a single total order. Each mutex
acquisition “reads the value written” by the last mutex release.—end note]
7 An evaluationA happens beforean evaluationB (or, equivalently,B happens afterA) if either
—(7.1) A is sequenced beforeB, or
—(7.2) A synchronizes withB, or
—(7.3) A happens beforeX and X happens beforeB.
[Note 7: An evaluation does not happen before itself.—end note]
8 An evaluationA strongly happens beforean evaluationD if, either
—(8.1) A is sequenced beforeD, or
—(8.2) A synchronizes withD, and bothA and D are sequentially consistent atomic operations (32.5.4), or
—(8.3) there are evaluationsB and C such that A is sequenced beforeB, B happens before C, and C is
sequenced beforeD, or
§ 6.10.2.2 © ISO/IEC
93

===== PAGE 105 =====

Dxxxx
—(8.4) there is an evaluationB such thatA strongly happens beforeB, andB strongly happens beforeD.
[Note 8: Informally, ifA strongly happens beforeB, thenA appears to be evaluated beforeB in all contexts. —end
note]
9 A visible side effectA on a scalar object or bit-fieldM with respect to a value computationB of M satisfies
the conditions:
—(9.1) A happens beforeB and
—(9.2) there is no other side effectX to M such thatA happens beforeX and X happens beforeB.
The value of a non-atomic scalar object or bit-fieldM, as determined by evaluationB, is the value stored by
the visible side effectA.
[Note 9: If there is ambiguity about which side effect to a non-atomic object or bit-field is visible, then the behavior
is either unspecified or undefined.—end note]
[Note 10: This states that operations on ordinary objects are not visibly reordered. This is not actually detectable
without data races, but is needed to ensure that data races, as defined below, and with suitable restrictions on the use
of atomics, correspond to data races in a simple interleaved (sequentially consistent) execution.—end note]
10 The value of an atomic objectM, as determined by evaluationB, is the value stored by some unspecified
side effectA that modifiesM, whereB does not happen beforeA.
[Note 11: The set of such side effects is also restricted by the rest of the rules described here, and in particular, by
the coherence requirements below.—end note]
11 If an operationAthat modifies an atomic objectM happens before an operationB that modifiesM, thenA
is earlier thanB in the modification order ofM.
[Note 12: This requirement is known as write-write coherence.—end note]
12 If a value computationA of an atomic objectM happens before a value computationB of M, andA takes
its value from a side effectX on M, then the value computed byB is either the value stored byX or the
value stored by a side effectY on M, whereY follows X in the modification order ofM.
[Note 13: This requirement is known as read-read coherence.—end note]
13 If a value computationA of an atomic objectM happens before an operationB that modifiesM, thenA
takes its value from a side effectX on M, whereX precedes B in the modification order ofM.
[Note 14: This requirement is known as read-write coherence.—end note]
14 If a side effectX on an atomic objectM happens before a value computationB of M, then the evaluationB
takes its value fromX or from a side effectY that followsX in the modification order ofM.
[Note 15: This requirement is known as write-read coherence.—end note]
15 [Note 16: The four preceding coherence requirements effectively disallow compiler reordering of atomic operations
to a single object, even if both operations are relaxed loads. This effectively makes the cache coherence guarantee
provided by most hardware available to C++ atomic operations. —end note]
16 [Note 17: The value observed by a load of an atomic depends on the “happens before” relation, which depends on the
values observed by loads of atomics. The intended reading is that there must exist an association of atomic loads with
modifications they observe that, together with suitably chosen modification orders and the “happens before” relation
derived as described above, satisfy the resulting constraints as imposed here.—end note]
17 Two actions arepotentially concurrentif
—(17.1) they are performed by different threads, or
—(17.2) they are unsequenced, at least one is performed by a signal handler, and they are not both performed
by the same signal handler invocation.
The execution of a program contains adata raceif it contains two potentially concurrent conflicting actions,
at least one of which is not atomic, and neither happens before the other, except for the special case for
signal handlers described below. Any such data race results in undefined behavior.
[Note 18: It can be shown that programs that correctly use mutexes andmemory_order::seq_cst operations to
prevent all data races and use no other synchronization operations behave as if the operations executed by their
constituent threads were simply interleaved, with each value computation of an object being taken from the last side
effect on that object in that interleaving. This is normally referred to as “sequential consistency”. However, this
applies only to data-race-free programs, and data-race-free programs cannot observe most program transformations
that do not change single-threaded program semantics. In fact, most single-threaded program transformations remain
possible, since any program that behaves differently as a result has undefined behavior.—end note]
§ 6.10.2.2 © ISO/IEC
94

===== PAGE 106 =====

Dxxxx
18 Two accesses to the same non-bit-field object of typevolatile std::sig_atomic_t do not result in a data
race if both occur in the same thread, even if one or more occurs in a signal handler. For each signal handler
invocation, evaluations performed by the thread invoking a signal handler can be divided into two groupsA
and B, such that no evaluations inB happen before evaluations inA, and the evaluations of suchvolatile
std::sig_atomic_t objects take values as though all evaluations inA happened before the execution of the
signal handler and the execution of the signal handler happened before all evaluations inB.
19 [Note 19: Compiler transformations that introduce assignments to a potentially shared memory location that would
not be modified by the abstract machine are generally precluded by this document, since such an assignment might
overwrite another assignment by a different thread in cases in which an abstract machine execution would not have
encountered a data race. This includes implementations of data member assignment that overwrite adjacent members
in separate memory locations. Reordering of atomic loads in cases in which the atomics in question might alias is also
generally precluded, since this could violate the coherence rules.—end note]
20 [Note 20: It is possible that transformations that introduce a speculative read of a potentially shared memory location
do not preserve the semantics of the C++ program as defined in this document, since they potentially introduce a
data race. However, they are typically valid in the context of an optimizing compiler that targets a specific machine
with well-defined semantics for data races. They would be invalid for a hypothetical machine that is not tolerant of
races or provides hardware race detection.—end note]
6.10.2.3 Forward progress [intro.progress]
1 The implementation may assume that any thread will eventually do one of the following:
—(1.1) terminate,
—(1.2) invoke the functionstd::this_thread::yield (32.4.5),
—(1.3) make a call to a library I/O function,
—(1.4) perform an access through a volatile glvalue,
—(1.5) perform an atomic or synchronization operation other than an atomic modify-write operation (32.5.4),
or
—(1.6) continue execution of a trivial infinite loop (8.6.1).
[Note 1: This is intended to allow compiler transformations such as removal, merging, and reordering of empty loops,
even when termination cannot be proven. An affordance is made for trivial infinite loops, which cannot be removed
nor reordered. —end note]
2 Executions of atomic functions that are either defined to be lock-free (32.5.10) or indicated as lock-free (32.5.5)
are lock-free executions.
—(2.1) If there is only one thread that is not blocked (3.6) in a standard library function, a lock-free execution
in that thread shall complete.
[Note 2: Concurrently executing threads might prevent progress of a lock-free execution. For example, this
situation can occur with load-locked store-conditional implementations. This property is sometimes termed
obstruction-free. —end note]
—(2.2) When one or more lock-free executions run concurrently, at least one should complete.
[Note 3: It is difficult for some implementations to provide absolute guarantees to this effect, since repeated
and particularly inopportune interference from other threads could prevent forward progress, e.g., by repeatedly
stealing a cache line for unrelated purposes between load-locked and store-conditional instructions. For
implementations that follow this recommendation and ensure that such effects cannot indefinitely delay progress
under expected operating conditions, such anomalies can therefore safely be ignored by programmers. Outside
this document, this property is sometimes termed lock-free.—end note]
3 During the execution of a thread of execution, each of the following is termed anexecution step:
—(3.1) termination of the thread of execution,
—(3.2) performing an access through a volatile glvalue,
—(3.3) completion of a call to a library I/O function, or
—(3.4) completion of an atomic or synchronization operation other than an atomic modify-write operation
(32.5.4).
4 An invocation of a standard library function that blocks (3.6) is considered to continuously execute execution
steps while waiting for the condition that it blocks on to be satisfied.
§ 6.10.2.3 © ISO/IEC
95

===== PAGE 107 =====

Dxxxx
[Example 1: A library I/O function that blocks until the I/O operation is complete can be considered to continuously
check whether the operation is complete. Each such check consists of one or more execution steps, for example using
observable behavior of the abstract machine.—end example]
5 A thread of executionmakes progresswhen an execution step occurs or a lock-free execution does not complete
because there are other concurrent threads that are not blocked in a standard library function (see above).
6 For a thread of execution providingconcurrent forward progress guarantees, the implementation ensures that
the thread will eventually make progress for as long as it has not terminated.
[Note 4: This applies regardless of whether or not other threads of execution (if any) have been or are making progress.
To eventually fulfill this requirement means that this will happen in an unspecified but finite amount of time.—end
note]
7 It is implementation-defined whether the implementation-created thread of execution that executesmain
(6.10.3.1) and the threads of execution created bystd::thread (32.4.3) orstd::jthread (32.4.4) provide
concurrent forward progress guarantees. General-purpose implementations should provide these guarantees.
8 For a thread of execution providingparallel forward progress guarantees, the implementation is not required
to ensure that the thread will eventually make progress if it has not yet executed any execution step; once
this thread has executed a step, it provides concurrent forward progress guarantees.
9 [Note 5: This does not specify a requirement for when to start this thread of execution, which will typically be specified
by the entity that creates this thread of execution. For example, a thread of execution that provides concurrent
forward progress guarantees and executes tasks from a set of tasks in an arbitrary order, one after the other, satisfies
the requirements of parallel forward progress for these tasks.—end note]
10 For a thread of execution providingweakly parallel forward progress guarantees, the implementation does not
ensure that the thread will eventually make progress.
11 [Note 6: Threads of execution providing weakly parallel forward progress guarantees cannot be expected to make
progress regardless of whether other threads make progress or not; however, blocking with forward progress guarantee
delegation, as defined below, can be used to ensure that such threads of execution make progress eventually.—end
note]
12 Concurrent forward progress guarantees are stronger than parallel forward progress guarantees, which in
turn are stronger than weakly parallel forward progress guarantees.
[Note 7: For example, some kinds of synchronization between threads of execution might only make progress if the
respective threads of execution provide parallel forward progress guarantees, but will fail to make progress under
weakly parallel guarantees.—end note]
13 When a thread of executionP is specified toblock with forward progress guarantee delegationon the completion
of a setSof threads of execution, then throughout the whole time ofP being blocked onS, the implementation
shall ensure that the forward progress guarantees provided by at least one thread of execution inS is at least
as strong asP’s forward progress guarantees.
[Note 8: It is unspecified which thread or threads of execution inS are chosen and for which number of execution
steps. The strengthening is not permanent and not necessarily in place for the rest of the lifetime of the affected
thread of execution. As long asP is blocked, the implementation has to eventually select and potentially strengthen a
thread of execution inS. —end note]
Once a thread of execution inS terminates, it is removed fromS. Once S is empty,P is unblocked.
14 [Note 9: A thread of executionB thus can temporarily provide an effectively stronger forward progress guarantee for
a certain amount of time, due to a second thread of executionA being blocked on it with forward progress guarantee
delegation. In turn, ifB then blocks with forward progress guarantee delegation onC, this can also temporarily
provide a stronger forward progress guarantee toC. —end note]
15 [Note 10: If all threads of execution inS finish executing (e.g., they terminate and do not use blocking synchronization
incorrectly), thenP’s execution of the operation that blocks with forward progress guarantee delegation will not result
in P’s progress guarantee being effectively weakened.—end note]
16 [Note 11: This does not remove any constraints regarding blocking synchronization for threads of execution providing
parallel or weakly parallel forward progress guarantees because the implementation is not required to strengthen a
particular thread of execution whose too-weak progress guarantee is preventing overall progress.—end note]
17 An implementation should ensure that the last value (in modification order) assigned by an atomic or
synchronization operation will become visible to all other threads in a finite period of time.
§ 6.10.2.3 © ISO/IEC
96

===== PAGE 108 =====

Dxxxx
6.10.3 Start and termination [basic.start]
6.10.3.1 main function [basic.start.main]
1 A program shall contain exactly one function calledmain that belongs to the global scope. Executing
a program starts a main thread of execution (6.10.2, 32.4) in which themain function is invoked. It is
implementation-defined whether a program in a freestanding environment is required to define amain
function.
[Note 1: In a freestanding environment, startup and termination is implementation-defined; startup contains the
execution of constructors for non-local objects with static storage duration; termination contains the execution of
destructors for objects with static storage duration.—end note]
2 An implementation shall not predefine themain function. Its type shall have C++ language linkage and
it shall have a declared return type of typeint, but otherwise its type is implementation-defined. An
implementation shall allow both
—(2.1) an “optionallynoexcept function of() returning int” and
—(2.2) an “optionallynoexcept function of(int, pointer to pointer tochar) returning int”
as the type ofmain (9.3.4.6). In the latter form, for purposes of exposition, the first function parameter is
called argc and the second function parameter is calledargv, whereargc shall be the number of arguments
passed to the program from the environment in which the program is run. Ifargc is nonzero these arguments
shall be supplied inargv[0] through argv[argc - 1] as pointers to the initial characters of null-terminated
multibyte strings (ntmbss) (16.3.3.3.4.3) andargv[0] shall be the pointer to the initial character of an
ntmbs that represents the name used to invoke the program or"". The value ofargc shall be non-negative.
The value ofargv[argc] shall be 0.
Recommended practice: Any further (optional) parameters should be added afterargv.
3 The functionmain shall not be named by an expression. The linkage (6.7) ofmain is implementation-defined.
A program that definesmainas deleted or that declaresmainto beinline, static, constexpr, orconsteval
is ill-formed. The functionmain shall not be a coroutine (9.6.4). Themain function shall not be declared
with alinkage-specification (9.12) other than"C++". A program that declares
—(3.1) a variablemain that belongs to the global scope, or
—(3.2) a functionmain that belongs to the global scope and is attached to a named module, or
—(3.3) a function templatemain that belongs to the global scope, or
—(3.4) an entity namedmain with C language linkage (in any namespace)
is ill-formed. The namemain is not otherwise reserved.
[Example 1: Member functions, classes, and enumerations can be calledmain, as can entities in other namespaces.
—end example]
4 Terminating the program without leaving the current block (e.g., by calling the functionstd::exit(int)
(17.5)) does not destroy any objects with automatic storage duration (11.4.7). Ifstd::exit is invoked during
the destruction of an object with static or thread storage duration, the program has undefined behavior.
5 A return statement (8.8.4) inmain has the effect of leaving themain function (destroying any objects with
automatic storage duration and evaluating any postcondition assertions ofmain) and callingstd::exit with
the return value as the argument. If control flows off the end of thecompound-statement of main, the effect
is equivalent to areturn with operand0 (see also 14.4).
6.10.3.2 Static initialization [basic.start.static]
1 Variables with static storage duration are initialized as a consequence of program initiation. Variables with
thread storage duration are initialized as a consequence of thread execution. Within each of these phases of
initiation, initialization occurs as follows.
2 Constant initializationis performed if a variable with static or thread storage duration is constant-initialized
(7.7). If constant initialization is not performed, a variable with static storage duration (6.8.6.2) or thread
storage duration (6.8.6.3) is zero-initialized (9.5). Together, zero-initialization and constant initialization are
called static initialization; all other initialization isdynamic initialization. All static initialization strongly
happens before (6.10.2.2) any dynamic initialization.
[Note 1: The dynamic initialization of non-block variables is described in 6.10.3.3; that of static block variables is
described in 8.10. —end note]
§ 6.10.3.2 © ISO/IEC
97

===== PAGE 109 =====

Dxxxx
3 An implementation is permitted to perform the initialization of a variable with static or thread storage
duration as a static initialization even if such initialization is not required to be done statically, provided that
—(3.1) the dynamic version of the initialization does not change the value of any other object of static or
thread storage duration prior to its initialization, and
—(3.2) the static version of the initialization produces the same value in the initialized variable as would be
produced by the dynamic initialization if all variables not required to be initialized statically were
initialized dynamically.
[Note 2: As a consequence, if the initialization of an objectobj1 refers to an objectobj2 potentially requiring dynamic
initialization and defined later in the same translation unit, it is unspecified whether the value ofobj2 used will be
the value of the fully initializedobj2 (because obj2 was statically initialized) or will be the value ofobj2 merely
zero-initialized. For example,
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1; // unspecified:
// either statically initialized to0.0 or
// dynamically initialized to0.0 if d1 is
// dynamically initialized, or1.0 otherwise
double d1 = fd(); // either initialized statically or dynamically to1.0
—end note]
6.10.3.3 Dynamic initialization of non-block variables [basic.start.dynamic]
1 Dynamic initialization of a non-block variable with static storage duration is unordered if the variable is an
implicitly or explicitly instantiated specialization, is partially-ordered if the variable is an inline variable that
is not an implicitly or explicitly instantiated specialization, and otherwise is ordered.
[Note 1: A non-inline explicit specialization of a templated variable has ordered initialization.—end note]
2 A declarationD is appearance-orderedbefore a declarationE if
—(2.1) D appears in the same translation unit asE, or
—(2.2) the translation unit containingE has an interface dependency on the translation unit containingD,
in either case prior toE.
3 Dynamic initialization of non-block variablesV and W with static storage duration is ordered as follows:
—(3.1) If V and W have ordered initialization and the definition ofV is appearance-ordered before the definition
of W, or ifV has partially-ordered initialization,W does not have unordered initialization, and for every
definition E of W there exists a definitionD of V such thatD is appearance-ordered beforeE, then
—(3.1.1) if the program does not start a thread (6.10.2) other than the main thread (6.10.3.1) orV and W
have ordered initialization and they are defined in the same translation unit, the initialization ofV
is sequenced before the initialization ofW;
—(3.1.2) otherwise, the initialization ofV strongly happens before the initialization ofW.
—(3.2) Otherwise, if the program starts a thread other than the main thread before eitherV or W is initialized,
it is unspecified in which threads the initializations ofV and W occur; the initializations are unsequenced
if they occur in the same thread.
—(3.3) Otherwise, the initializations ofV and W are indeterminately sequenced.
[Note 2: This definition permits initialization of a sequence of ordered variables concurrently with another sequence.
—end note]
4 A non-initialization odr-useis an odr-use (6.3) not caused directly or indirectly by the initialization of a
non-block static or thread storage duration variable.
5 It is implementation-defined whether the dynamic initialization of a non-block non-inline variable with static
storage duration is sequenced before the first statement ofmain or is deferred. If it is deferred, it strongly
happens before any non-initialization odr-use of any non-inline function or non-inline variable defined in the
same translation unit as the variable to be initialized.34 It is implementation-defined in which threads and at
which points in the program such deferred dynamic initialization occurs.
34) A non-block variable with static storage duration having initialization with side effects is initialized in this case, even if it is
not itself odr-used (6.3, 6.8.6.2).
§ 6.10.3.3 © ISO/IEC
98

===== PAGE 110 =====

Dxxxx
Recommended practice: An implementation should choose such points in a way that allows the programmer
to avoid deadlocks.
[Example 1:
// - File 1 -
#include "a.h"
#include "b.h"
B b;
A::A() {
b.Use();
}
// - File 2 -
#include "a.h"
A a;
// - File 3 -
#include "a.h"
#include "b.h"
extern A a;
extern B b;
int main() {
a.Use();
b.Use();
}
It is implementation-defined whether eithera or b is initialized beforemain is entered or whether the initializations
are delayed untila is first odr-used inmain. In particular, ifa is initialized beforemain is entered, it is not guaranteed
that b will be initialized before it is odr-used by the initialization ofa, that is, beforeA::A is called. If, however,a is
initialized at some point after the first statement ofmain, b will be initialized prior to its use inA::A. —end example]
6 It is implementation-defined whether the dynamic initialization of a non-block inline variable with static
storage duration is sequenced before the first statement ofmain or is deferred. If it is deferred, it strongly
happens before any non-initialization odr-use of that variable. It is implementation-defined in which threads
and at which points in the program such deferred dynamic initialization occurs.
7 It is implementation-defined whether the dynamic initialization of a non-block non-inline variable with thread
storage duration is sequenced before the first statement of the initial function of a thread or is deferred. If it is
deferred, the initialization associated with the entity for threadt is sequenced before the first non-initialization
odr-use byt of any non-inline variable with thread storage duration defined in the same translation unit
as the variable to be initialized. It is implementation-defined in which threads and at which points in the
program such deferred dynamic initialization occurs.
8 If the initialization of a non-block variable with static or thread storage duration exits via an exception, the
function std::terminate is called (14.6.2).
6.10.3.4 Termination [basic.start.term]
1 Constructed complete objects (9.5) with static storage duration are destroyed and functions registered with
std::atexit are called as part of a call tostd::exit (17.5). The call tostd::exit is sequenced before the
destructions and the registered functions.
[Note 1: Returning frommain invokes std::exit (6.10.3.1). —end note]
2 Constructed complete objects with thread storage duration within a given thread are destroyed as a result
of returning from the initial function of that thread and as a result of that thread callingstd::exit. The
destruction of those constructed objects is sequenced before releasing the storage for any object with thread
storage duration within that thread (6.8.6.3). The destruction of those constructed objects strongly happens
before destroying any object with static storage duration.
3 The destruction of a complete object with thread storage duration within a given thread and having constant
destruction (7.7) is sequenced after the destruction of any other complete object with thread storage duration
within the thread. The destruction of a complete object with static storage duration and having constant
destruction is sequenced after the destruction of any other complete object with static storage duration and
after any call to a function passed tostd::atexit. The sequencing rules in the remainder of this subclause
apply only to complete objects not having constant destruction.
§ 6.10.3.4 © ISO/IEC
99

===== PAGE 111 =====

Dxxxx
4 If the deemed construction (9.5.1) of a complete object with static storage duration strongly happens before
that of another, the completion of the destruction of the second is sequenced before the initiation of the
destruction of the first. If the deemed construction of a complete object with thread storage duration is
sequenced before that of another, the completion of the destruction of the second is sequenced before the
initiation of the destruction of the first. If an object is initialized statically, the object is destroyed in the
same order as if the object was dynamically initialized. If the destruction of an object with static or thread
storage duration exits via an exception, the functionstd::terminate is called (14.6.2).
[Example 1: In the following program, the elements ofa are destroyed, followed bydt, and finally by the twoBtemp
objects:
struct DTemp { ~DTemp(); };
struct Temp {
~Temp() {
static DTemp dt;
}
};
struct BTemp {
~BTemp();
};
struct A {
const BTemp &tb;
~A();
};
A a[] = { (Temp(), BTemp()), BTemp() };
int main() {}
If the arraya were an object with automatic storage duration, theBtemp temporaries would be destroyed as each
element of the array is destroyed (6.8.7).—end example]
5 If a function contains a block variable of static or thread storage duration that has been destroyed and the
function is called during the destruction of an object with static or thread storage duration, the program
has undefined behavior if the flow of control passes through the definition of the previously destroyed block
variable.
[Note 2: Likewise, the behavior is undefined if the block variable is used indirectly (e.g., through a pointer) after its
destruction. —end note]
6 If the deemed construction of a complete object with static storage duration strongly happens before a call
to std::atexit (see <cstdlib>, 17.5), the call to the function passed tostd::atexit is sequenced before
the initiation of the destruction of the object. If a call tostd::atexit strongly happens before the deemed
construction of a complete object with static storage duration, the completion of the destruction of the
object is sequenced before the call to the function passed tostd::atexit. If a call tostd::atexit strongly
happens before another call tostd::atexit, the call to the function passed to the secondstd::atexit call
is sequenced before the call to the function passed to the firststd::atexit call.
7 If there is a use of a standard library object or function not permitted within signal handlers (17.14) that does
not happen before (6.10.2) completion of destruction of objects with static storage duration and execution of
std::atexit registered functions (17.5), the program has undefined behavior.
[Note 3: If there is a use of an object with static storage duration that does not happen before the object’s destruction,
the program has undefined behavior. Terminating every thread before a call tostd::exit or the exit frommain
is sufficient, but not necessary, to satisfy these requirements. These requirements permit thread managers as
static-storage-duration objects. —end note]
8 Calling the functionstd::abort() declared in<cstdlib> (17.2.2) terminates the program without executing
any destructors and without calling the functions passed tostd::atexit() or std::at_quick_exit().
6.11 Contract assertions [basic.contract]
6.11.1 General [basic.contract.general]
1 Contract assertionsallow the programmer to specify properties of the state of the program that are expected
to hold at certain points during execution. Contract assertions are introduced byprecondition-specifiers,
postcondition-specifiers (9.4.1), andassertion-statements (8.9).
2 Each contract assertion has acontract-assertion predicate, which is an expression of typebool.
§ 6.11.1 © ISO/IEC
100

===== PAGE 112 =====

Dxxxx
[Note 1: The value of the predicate is used to identify program states that are expected.—end note]
3 An invocation of the macrova_start (17.14.2) shall not be a subexpression of the predicate of a contract
assertion, no diagnostic required.
4 [Note 2: Within the predicate of a contract assertion,id-expressions referring to variables declared outside the
contract assertion areconst (7.5.5.2), this is a pointer toconst (7.5.3), and the result object can be named if a
result-name-introducer (9.4.2) has been specified.—end note]
6.11.2 Evaluation [basic.contract.eval]
1 An evaluation of a contract assertion uses one of the following fourevaluation semantics: ignore, observe,
enforce, orquick-enforce. Observe, enforce, and quick-enforce arechecking semantics; enforce and quick-enforce
are terminating semantics.
2 It is implementation-defined which evaluation semantic is used for any given evaluation of a contract assertion.
[Note 1: The range and flexibility of available choices of evaluation semantics depends on the implementation and need
not allow all four evaluation semantics as possibilities. The evaluation semantics can differ for different evaluations of
the same contract assertion, including evaluations during constant evaluation.—end note]
3 Recommended practice: An implementation should provide the option to translate a program such that
all evaluations of contract assertions use the ignore semantic as well as the option to translate a program
such that all evaluations of contract assertions use the enforce semantic. By default, evaluations of contract
assertions should use the enforce semantic.
4 The evaluation of a contract assertion using the ignore semantic has no effect.
[Note 2: The predicate is potentially evaluated (6.3), but not evaluated.—end note]
5 The evaluationA of a contract assertion using a checking semantic determines the value of the predicate. It
is unspecified whether the predicate is evaluated. LetB be the value that would result from evaluating the
predicate.
[Note 3: To determine whether a predicate would evaluate totrue or false, an alternative evaluation that produces
the same value as the predicate but has no side effects can occur.
[Example 1:
struct S {
mutable int g = 5;
} s;
void f()
pre(( s.g++, false )); // #1
void g()
{
f(); // Increment ofs.g might not occur, even if #1 uses a checking semantic.
}
—end example]
—end note]
6 There is an observable checkpoint (4.1.2)C that happens beforeA such that any other operationO that
happens beforeA also happens beforeC.
7 A contract violationoccurs when
—(7.1) B is false,
—(7.2) the evaluation of the predicate exits via an exception, or
—(7.3) the evaluation of the predicate is performed in a context that is manifestly constant-evaluated (7.7)
and the predicate is not a core constant expression.
[Note 4: If B is true, no contract violation occurs and control flow continues normally after the point of evaluation
of the contract assertion. The evaluation of the predicate can fail to produce a value without causing a contract
violation, for example, by callinglongjmp (17.14.3) or terminating the program.—end note]
8 If a contract violation occurs in a context that is manifestly constant-evaluated (7.7), and the evaluation
semantic is a terminating semantic, the program is ill-formed.
[Note 5: A diagnostic is produced if the evaluation semantic is observe (4.1).—end note]
§ 6.11.2 © ISO/IEC
101

===== PAGE 113 =====

Dxxxx
[Note 6: Different evaluation semantics chosen for the same contract assertion in different translation units can result
in violations of the one-definition rule (6.3) when a contract assertion has side effects that alter the value produced by
a constant expression.
[Example 2:
constexpr int f(int i)
{
contract_assert((++const_cast<int&>(i), true));
return i;
}
inline void g()
{
int a[f(1)]; // size dependent on the evaluation semantic ofcontract_assert above
}
—end example]
—end note]
9 When the program iscontract-terminated, it is implementation-defined (depending on context) whether
—(9.1) std::terminate is called,
—(9.2) std::abort is called, or
—(9.3) execution is terminated.
[Note 7: No further execution steps occur (6.10.2.3).—end note]
[Note 8: Performing the actions of std::terminate or std::abort without actually making a library call is a
conforming implementation of contract-termination (4.1.2).—end note]
10 If a contract violation occurs in a context that is not manifestly constant-evaluated and the evaluation
semantic is quick-enforce, the program is contract-terminated.
11 If a contract violation occurs in a context that is not manifestly constant-evaluated and the evaluation
semantic is enforce or observe, the contract-violation handler (6.11.3) is invoked with an lvalue referring to
an objectv of typeconst std::contracts::contract_violation (17.10.3) containing information about
the contract violation. Storage forv is allocated in an unspecified manner except as noted in 6.8.6.5.2. The
lifetime ofv persists for the duration of the invocation of the contract-violation handler.
12 If the contract violation occurred because the evaluation of the predicate exited via an exception, the
contract-violation handler is invoked from within an active implicit handler for that exception (14.4). If the
contract-violation handler returns normally and the evaluation semantic is observe, that implicit handler is
no longer considered active.
[Note 9: The exception can be inspected or rethrown within the contract-violation handler.—end note]
13 If the contract-violation handler returns normally and the evaluation semantic is enforce, the program is
contract-terminated; if violation occurred as the result of an uncaught exception from the evaluation of the
predicate, the implicit handler remains active when contract termination occurs.
14 [Note 10: If the contract-violation handler returns normally and the evaluation semantic is observe, control flow
continues normally after the point of evaluation of the contract assertion.—end note]
15 There is an observable checkpoint (4.1.2)C that happens after the contract-violation handler returns normally
such that any other operationO that happens after the contract-violation handler returns also happens after
C.
16 [Note 11: The terminating semantics terminate the program if execution would otherwise continue normally past a
contract violation: the enforce semantic provides the opportunity to log information about the contract violation
before terminating the program or to throw an exception to avoid termination, and the quick-enforce semantic is
intended to terminate the program as soon as possible as well as to minimize the impact of contract checks on the
generated code size. Conversely, the observe semantic provides the opportunity to log information about the contract
violation without having to terminate the program.—end note]
17 If a contract-violation handler invoked from the evaluation of a function contract assertion (9.4.1) exits via
an exception, the behavior is as if the function body exits via that same exception.
[Note 12: A function-try-block (14.1) is the function body when present and thus does not have an opportunity to
catch the exception. If the function has a non-throwing exception specification, the functionstd::terminate is
invoked (14.6.2). —end note]
§ 6.11.2 © ISO/IEC
102

===== PAGE 114 =====

Dxxxx
[Note 13: If a contract-violation handler invoked from anassertion-statement (8.9) exits via an exception, the search
for a handler continues from the execution of that statement.—end note]
18 To evaluate in sequencea listR of contract assertions:
—(18.1) Construct a list of contract assertionsS such that
—(18.1.1) all elements ofR are inS,
—(18.1.2) each element ofR may be repeated an implementation-defined number of times withinS, and
—(18.1.3) if a contract assertionA precedes another contract assertionB in R, then the first occurrence of
A precedes the first occurrence ofB in S.
—(18.2) Evaluate each element ofS such that, if a contract assertionA precedes a contract assertionB in S,
then the evaluation ofA is sequenced before the evaluation ofB.
[Example 3:
void f(int i)
{
contract_assert(i > 0); // #1
contract_assert(i < 10); // #2
// valid sequence of evaluations: #1 #2
// valid sequence of evaluations: #1 #1 #2 #2
// valid sequence of evaluations: #1 #2 #1 #2
// valid sequence of evaluations: #1 #2 #2 #1
// invalid sequence of evaluations: #2 #1
}
—end example]
19 Recommended practice: An implementation should provide an option to perform a specified number of
repeated evaluations for contract assertions. By default, no repeated evaluations should be performed.
6.11.3 Contract-violation handler [basic.contract.handler]
1 The contract-violation handler of a program is a function named::handle_contract_violation. The
contract-violation handler shall have a single parameter of type “lvalue reference toconst std::contracts::-
contract_violation” and shall returnvoid. The contract-violation handler may have a non-throwing
exception specification. The implementation shall provide a definition of the contract-violation handler, called
the default contract-violation handler.
[Note 1: No declaration for the default contract-violation handler is provided by any standard library header.—end
note]
2 Recommended practice: The default contract-violation handler should produce diagnostic output that suitably
formats the most relevant contents of thestd::contracts::contract_violation object, rate-limited for
potentially repeated violations of observed contract assertions, and then return normally.
3 It is implementation-defined whether the contract-violation handler is replaceable (9.6.5). If the contract-
violation handler is not replaceable, a declaration of a replacement function for the contract-violation handler
is ill-formed, no diagnostic required.
§ 6.11.3 © ISO/IEC
103

===== PAGE 115 =====

Dxxxx
7 Expressions [expr]
7.1 Preamble [expr.pre]
1 [Note 1: Clause 7 defines the syntax, order of evaluation, and meaning of expressions.35 An expression is a sequence
of operators and operands that specifies a computation. An expression can result in a value and can cause side effects.
—end note]
2 [Note 2: Operators can be overloaded, that is, given meaning when applied to expressions of class type (Clause 11)
or enumeration type (9.8.1). Uses of overloaded operators are transformed into function calls as described in 12.4.
Overloaded operators obey the rules for syntax and evaluation order specified in 7.6, but the requirements of operand
type and value category are replaced by the rules for function call. Relations between operators, such as++a meaning
a += 1, are not guaranteed for overloaded operators (12.4).—end note]
3 Subclause 7.6 defines the effects of operators when applied to types for which they have not been overloaded.
Operator overloading shall not modify the rules for thebuilt-in operators, that is, for operators applied to
types for which they are defined by this Standard. However, these built-in operators participate in overload
resolution, and as part of that process user-defined conversions will be considered where necessary to convert
the operands to types appropriate for the built-in operator. If a built-in operator is selected, such conversions
will be applied to the operands before the operation is considered further according to the rules in 7.6;
see 12.2.2.3, 12.5.
4 If during the evaluation of an expression, the result is not mathematically defined or not in the range of
representable values for its type, the behavior is undefined.
[Note 3: Treatment of division by zero, forming a remainder using a zero divisor, and all floating-point exceptions
varies among machines, and is sometimes adjustable by a library function.—end note]
5 [Note 4: The implementation can regroup operators according to the usual mathematical rules only where the
operators really are associative or commutative.36 For example, in the following fragment
int a, b;
/* ... */
a = a + 32760 + b + 5;
the expression statement behaves exactly the same as
a = (((a + 32760) + b) + 5);
due to the associativity and precedence of these operators. Thus, the result of the sum(a + 32760) is next added to
b, and that result is then added to 5 which results in the value assigned toa. On a machine in which overflows produce
an exception and in which the range of values representable by anint is [-32768,+32767], the implementation cannot
rewrite this expression as
a = ((a + b) + 32765);
since if the values fora and b were, respectively,−32754 and −15, the suma + b would produce an exception while
the original expression would not; nor can the expression be rewritten as either
a = ((a + 32765) + b);
or
a = (a + (b + 32765));
since the values fora and b might have been, respectively, 4 and−8 or −17 and 12. However on a machine in which
overflows do not produce an exception and in which the results of overflows are reversible, the above expression
statement can be rewritten by the implementation in any of the above ways because the same result will occur.—end
note]
6 The values of the floating-point operands and the results of floating-point expressions may be represented in
greater precision and range than that required by the type; the types are not changed thereby.37
35) The precedence of operators is not directly specified, but it can be derived from the syntax.
36) Overloaded operators are never assumed to be associative or commutative.
37) The cast and assignment operators must still perform their specific conversions as described in 7.6.1.4, 7.6.3, 7.6.1.9
and 7.6.19.
§ 7.1 © ISO/IEC
104

===== PAGE 116 =====

Dxxxx
7.2 Properties of expressions [expr.prop]
7.2.1 Value category [basic.lval]
1 Expressions are categorized according to the taxonomy in Figure 2.
expression
glvalue rvalue
lvalue xvalue prvalue
Figure 2 — Expression category taxonomy [fig:basic.lval]
—(1.1) A glvalue is an expression whose evaluation determines the identity of an object, function, non-static
data member, or a direct base class relationship.
—(1.2) A prvalue is an expression whose evaluation initializes an object or computes the value of an operand
of an operator, as specified by the context in which it appears, or an expression that has typecv void.
—(1.3) An xvalue is a glvalue that denotes an object whose resources can be reused (usually because it is near
the end of its lifetime).
—(1.4) An lvalue is a glvalue that is not an xvalue.
—(1.5) An rvalue is a prvalue or an xvalue.
2 Every expression belongs to exactly one of the fundamental categories in this taxonomy: lvalue, xvalue, or
prvalue. This property of an expression is called itsvalue category.
[Note 1: The discussion of each built-in operator in 7.6 indicates the category of the value it yields and the value
categories of the operands it expects. For example, the built-in assignment operators expect that the left operand is an
lvalue and that the right operand is a prvalue and yield an lvalue as the result. User-defined operators are functions,
and the categories of values they expect and yield are determined by their parameter and return types.—end note]
3 [Note 2: Historically, lvalues and rvalues were so-called because they could appear on the left- and right-hand side
of an assignment (although this is no longer generally true); glvalues are “generalized” lvalues, prvalues are “pure”
rvalues, and xvalues are “eXpiring” lvalues. Despite their names, these terms apply to expressions, not values.—end
note]
4 [Note 3: An expression is an xvalue if it is:
—(4.1) a move-eligibleid-expression (7.5.5.2) orsplice-expression (7.5.9),
—(4.2) the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to
object type (7.6.1.3),
—(4.3) a cast to an rvalue reference to object type (7.6.1.4, 7.6.1.7, 7.6.1.9, 7.6.1.10, 7.6.1.11, 7.6.3),
—(4.4) a subscripting operation with an xvalue array operand (7.6.1.2),
—(4.5) a class member access expression designating a non-static data member of non-reference type in which the
object expression is an xvalue (7.6.1.5), or
—(4.6) a .* pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer
to data member (7.6.4).
In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue references
to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether named or not.—end
note]
[Example 1:
struct A {
int m;
};
A&& operator+(A, A);
A&& f();
A a;
A&& ar = static_cast<A&&>(a);
§ 7.2.1 © ISO/IEC
105

===== PAGE 117 =====

Dxxxx
The expressionsf(), f().m, static_cast<A&&>(a), anda + a are xvalues. The expressionar is an lvalue.—end
example]
5 The result of a glvalue is the entity denoted by the expression. Theresult of a prvalue is the value that the
expression stores into its context; a prvalue that has typecv void has no result. A prvalue whose result
is the valueV is sometimes said to have or name the valueV. Theresult objectof a prvalue is the object
initialized by the prvalue; a prvalue that has typecv void has no result object.
[Note 4: Except when the prvalue is the operand of adecltype-specifier, a prvalue of object type always has a result
object. For a discarded prvalue that has type other thancv void, a temporary object is materialized; see 7.2.3.—end
note]
6 Whenever a glvalue appears as an operand of an operator that requires a prvalue for that operand, the
lvalue-to-rvalue (7.3.2), array-to-pointer (7.3.3), or function-to-pointer (7.3.4) standard conversions are applied
to convert the expression to a prvalue.
[Note 5: An attempt to bind an rvalue reference to an lvalue is not such a context; see 9.5.4.—end note]
[Note 6: Because cv-qualifiers are removed from the type of an expression of non-class type when the expression is
converted to a prvalue, an lvalue of typeconst int can, for example, be used where a prvalue of typeint is required.
—end note]
[Note 7: There are no prvalue bit-fields; if a bit-field is converted to a prvalue (7.3.2), a prvalue of the type of the
bit-field is created, which might then be promoted (7.3.7).—end note]
7 Unless otherwise specified (7.6.1.10, 7.6.1.11), whenever a prvalue that is not the result of the lvalue-to-rvalue
conversion (7.3.2) appears as an operand of an operator, the temporary materialization conversion (7.3.5) is
applied to convert the expression to an xvalue.
8 [Note 8: The discussion of reference initialization in 9.5.4 and of temporaries in 6.8.7 indicates the behavior of lvalues
and rvalues in other significant contexts.—end note]
9 Unless otherwise indicated (9.2.9.6), a prvalue shall always have complete type or thevoid type; if it has a
class type or (possibly multidimensional) array of class type, that class shall not be an abstract class (11.7.4).
A glvalue shall not have typecv void.
[Note 9: A glvalue can have complete or incomplete non-void type. Class and array prvalues can have cv-qualified
types; other prvalues always have cv-unqualified types. See 7.2.2.—end note]
10 An lvalue ismodifiable unless its type is const-qualified or is a function type.
[Note 10: A program that attempts to modify an object through a nonmodifiable lvalue or through an rvalue is
ill-formed (7.6.19, 7.6.1.6, 7.6.2.3).—end note]
11 An object of dynamic typeTobj is type-accessiblethrough a glvalue of typeTref if Tref is similar (7.3.6) to:
—(11.1) Tobj,
—(11.2) a type that is the signed or unsigned type corresponding toTobj, or
—(11.3) a char, unsigned char, orstd::byte type.
If a program attempts to access (3.1) the stored value of an object through a glvalue through which it is
not type-accessible, the behavior is undefined.38 If a program invokes a defaulted copy/move constructor or
copy/move assignment operator for a union of typeU with a glvalue argument that does not denote an object
of typecv U within its lifetime, the behavior is undefined.
[Note 11: In C, an entire object of structure type can be accessed, e.g., using assignment. By contrast, C++ has no
notion of accessing an object of class type through an lvalue of class type.—end note]
7.2.2 Type [expr.type]
1 If an expression initially has the type “reference toT” (9.3.4.3, 9.5.4), the type is adjusted toT prior to any
further analysis; the value category of the expression is not altered. LetX be the object or function denoted
by the reference. If a pointer toX would be valid in the context of the evaluation of the expression (6.9.2),
the result designatesX; otherwise, the behavior is undefined.
[Note 1: Before the lifetime of the reference has started or after it has ended, the behavior is undefined (see 6.8.4).
—end note]
38) The intent of this list is to specify those circumstances in which an object can or cannot be aliased.
§ 7.2.2 © ISO/IEC
106

===== PAGE 118 =====

Dxxxx
2 If a prvalue initially has the type “cv T”, whereT is a cv-unqualified non-class, non-array type, the type of
the expression is adjusted toT prior to any further analysis.
3 The composite pointer typeof two operandsp1 and p2 having typesT1 and T2, respectively, where at least
one is a pointer or pointer-to-member type orstd::nullptr_t, is:
—(3.1) if bothp1 and p2 are null pointer constants,std::nullptr_t;
—(3.2) if eitherp1 or p2 is a null pointer constant,T2 or T1, respectively;
—(3.3) if T1 or T2 is “pointer tocv1 void” and the other type is “pointer tocv2 T”, whereT is an object type
or void, “pointer tocv12 void”, wherecv12 is the union ofcv1 and cv2;
—(3.4) if T1 or T2 is “pointer tonoexcept function” and the other type is “pointer to function”, where the
function types are otherwise the same, “pointer to function”;
—(3.5) if T1 is “pointer toC1” andT2 is “pointer toC2”, whereC1 is reference-related toC2 or C2 is reference-
related toC1 (9.5.4), the qualification-combined type (7.3.6) ofT1 and T2 or the qualification-combined
type ofT2 and T1, respectively;
—(3.6) if T1 or T2 is “pointer to member ofC1 of type function”, the other type is “pointer to member ofC2 of
type noexcept function”, andC1 is reference-related toC2 or C2 is reference-related toC1 (9.5.4), where
the function types are otherwise the same, “pointer to member ofC2 of type function” or “pointer to
member ofC1 of type function”, respectively;
—(3.7) if T1 is “pointer to member ofC1 of typecv1 U” andT2 is “pointer to member ofC2 of typecv2 U”, for
some non-function typeU, whereC1 is reference-related toC2 or C2 is reference-related toC1 (9.5.4), the
qualification-combined type ofT2 and T1 or the qualification-combined type ofT1 and T2, respectively;
—(3.8) if T1 and T2 are similar types (7.3.6), the qualification-combined type ofT1 and T2;
—(3.9) otherwise, a program that necessitates the determination of a composite pointer type is ill-formed.
[Example 1:
typedef void *p;
typedef const int *q;
typedef int **pi;
typedef const int **pci;
The composite pointer type ofp and q is “pointer toconst void”; the composite pointer type ofpi and pci is
“pointer toconst pointer toconst int”. —end example]
7.2.3 Context dependence [expr.context]
1 In some contexts,unevaluated operandsappear (7.5.8.2, 7.5.8.4, 7.6.1.8, 7.6.2.5, 7.6.2.7, 7.6.2.10, 9.2.9.6, 13.1,
13.7.9). An unevaluated operand is not evaluated.
[Note 1: In an unevaluated operand, a non-static class member can be named (7.5.5) and naming of objects or
functions does not, by itself, require that a definition be provided (6.3). An unevaluated operand is considered a
full-expression (6.10.1). —end note]
2 In some contexts, an expression only appears for its side effects. Such an expression is called adiscarded-value
expression. The array-to-pointer (7.3.3) and function-to-pointer (7.3.4) standard conversions are not applied.
The lvalue-to-rvalue conversion (7.3.2) is applied if and only if the expression is a glvalue of volatile-qualified
type and it is one of the following:
—(2.1) ( expression ), whereexpression is one of these expressions,
—(2.2) id-expression (7.5.5),
—(2.3) splice-expression (7.5.9),
—(2.4) subscripting (7.6.1.2),
—(2.5) class member access (7.6.1.5),
—(2.6) indirection (7.6.2.2),
—(2.7) pointer-to-member operation (7.6.4),
—(2.8) conditional expression (7.6.16) where both the second and the third operands are one of these expressions,
or
—(2.9) comma expression (7.6.20) where the right operand is one of these expressions.
§ 7.2.3 © ISO/IEC
107

===== PAGE 119 =====

Dxxxx
[Note 2: Using an overloaded operator causes a function call; the above covers only operators with built-in meaning.
—end note]
The temporary materialization conversion (7.3.5) is applied if the (possibly converted) expression is a prvalue
of object type.
[Note 3: If the original expression is an lvalue of class type, it must have a volatile copy constructor to initialize the
temporary object that is the result object of the temporary materialization conversion.—end note]
The expression is evaluated and its result (if any) is discarded.
7.3 Standard conversions [conv]
7.3.1 General [conv.general]
1 Standard conversions are implicit conversions with built-in meaning. 7.3 enumerates the full set of such
conversions. Astandard conversion sequenceis a sequence of standard conversions in the following order:
—(1.1) Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion,
and function-to-pointer conversion.
—(1.2) Zero or one conversion from the following set: integral promotions, floating-point promotion, integral
conversions, floating-point conversions, floating-integral conversions, pointer conversions, pointer-to-
member conversions, and boolean conversions.
—(1.3) Zero or one function pointer conversion.
—(1.4) Zero or one qualification conversion.
[Note 1: A standard conversion sequence can be empty, i.e., it can consist of no conversions.—end note]
A standard conversion sequence will be applied to an expression if necessary to convert it to an expression
having a required destination type and value category.
2 [Note 2: Expressions with a given type will be implicitly converted to other types in several contexts:
—(2.1) When used as operands of operators. The operator’s requirements for its operands dictate the destination
type (7.6).
—(2.2) When used in the condition of anif statement (8.5.2) or iteration statement (8.6). The destination type is
bool.
—(2.3) When used in the expression of aswitch statement (8.5.3). The destination type is integral.
—(2.4) When used as the source expression for an initialization (which includes use as an argument in a function call
and use as the expression in areturn statement). The type of the entity being initialized is (generally) the
destination type. See 9.5, 9.5.4.
—end note]
3 An expressionE can beimplicitly convertedto a typeT if and only if the declarationT t = E; is well-formed,
for some invented temporary variablet (9.5).
4 Certain language constructs require that an expression be converted to a Boolean value. An expressionE
appearing in such a context is said to becontextually converted tobool and is well-formed if and only if the
declaration bool t(E); is well-formed, for some invented temporary variablet (9.5).
5 Certain language constructs require conversion to a value having one of a specified set of types appropriate
to the construct. An expressionE of class typeC appearing in such a context is said to becontextually
implicitly convertedto a specified typeT and is well-formed if and only ifE can be implicitly converted to a
type T that is determined as follows:C is searched for non-explicit conversion functions whose return type is
cv T or reference tocv T such thatT is allowed by the context. There shall be exactly one suchT.
6 The effect of any implicit conversion is the same as performing the corresponding declaration and initialization
and then using the temporary variable as the result of the conversion. The result is an lvalue ifT is an lvalue
reference type or an rvalue reference to function type (9.3.4.3), an xvalue ifT is an rvalue reference to object
type, and a prvalue otherwise. The expressionE is used as a glvalue if and only if the initialization uses it as
a glvalue.
7 [Note 3: For class types, user-defined conversions are considered as well; see 11.4.8. In general, an implicit conversion
sequence (12.2.4.2) consists of a standard conversion sequence followed by a user-defined conversion followed by
another standard conversion sequence.—end note]
§ 7.3.1 © ISO/IEC
108

===== PAGE 120 =====

Dxxxx
8 [Note 4: There are some contexts where certain conversions are suppressed. For example, the lvalue-to-rvalue
conversion is not done on the operand of the unary& operator. Specific exceptions are given in the descriptions of
those operators and contexts.—end note]
7.3.2 Lvalue-to-rvalue conversion [conv.lval]
1 A glvalue (7.2.1) of a non-function, non-array typeT can be converted to a prvalue.39 If T is an incomplete
type, a program that necessitates this conversion is ill-formed. IfT is a non-class type, the type of the prvalue
is the cv-unqualified version ofT. Otherwise, the type of the prvalue isT.40
2 When an lvalue-to-rvalue conversion is applied to an expressionE, and either
—(2.1) E is not potentially evaluated, or
—(2.2) the evaluation ofE results in the evaluation of a memberEx of the set of potential results ofE, and
Ex names a variablex that is not odr-used byEx (6.3),
the value contained in the referenced object is not accessed.
[Example 1:
struct S { int n; };
auto f() {
S x { 1 };
constexpr S y { 2 };
return [&](bool b) { return (b ? y : x).n; };
}
auto g = f();
int m = g(false); // undefined behavior: access ofx.n outside its lifetime
int n = g(true); // OK, does not accessy.n
—end example]
3 The result of the conversion is determined according to the following rules:
—(3.1) If T is cv std::nullptr_t, the result is a null pointer constant (7.3.12).
[Note 1: Since the conversion does not access the object to which the glvalue refers, there is no side effect even
if T is volatile-qualified (6.10.1), and the glvalue can refer to an inactive member of a union (11.5).—end note]
—(3.2) Otherwise, ifT has a class type, the conversion copy-initializes the result object from the glvalue.
—(3.3) Otherwise, if the object to which the glvalue refers contains an invalid pointer value (6.9.4), the behavior
is implementation-defined.
—(3.4) Otherwise, if the bits in the value representation of the object to which the glvalue refers are not valid
for the object’s type, the behavior is undefined.
[Example 2:
bool f() {
bool b = true;
char c = 42;
memcpy(&b, &c, 1);
return b; // undefined behavior if42 is not a valid value representation forbool
}
—end example]
—(3.5) Otherwise, the object indicated by the glvalue is read (3.1). LetV be the value contained in the object.
If T is an integer type, the prvalue result is the value of typeT congruent (6.9.2) toV, andV otherwise.
4 [Note 2: See also 7.2.1.—end note]
7.3.3 Array-to-pointer conversion [conv.array]
1 An expressionE of type “array ofN T” or “array of unknown bound ofT” can be converted to a prvalue of
type “pointer toT”. IfE is a prvalue, the temporary materialization conversion (7.3.5) is applied. If the
result ofE (possibly converted) is an object whose type is similar to the type ofE, the result is a pointer to
the first element of the array; otherwise, the behavior is undefined.
39) For historical reasons, this conversion is called the “lvalue-to-rvalue” conversion, even though that name does not accurately
reflect the taxonomy of expressions described in 7.2.1.
40) In C++ class and array prvalues can have cv-qualified types. This differs from C, in which non-lvalues never have cv-qualified
types.
§ 7.3.3 © ISO/IEC
109

===== PAGE 121 =====

Dxxxx
7.3.4 Function-to-pointer conversion [conv.func]
1 An lvalue of function typeT can be converted to a prvalue of type “pointer toT”. The result is a pointer to
the function.41
7.3.5 Temporary materialization conversion [conv.rval]
1 A prvalue of typeT can be converted to an xvalue of typeT. This conversion initializes a temporary
object (6.8.7) of typeT from the prvalue by evaluating the prvalue with the temporary object as its result
object, and produces an xvalue denoting the temporary object.T shall be a complete type.
[Note 1: If T is a class type (or array thereof), it must have an accessible and non-deleted destructor; see 11.4.7.
—end note]
[Example 1:
struct X { int n; };
int k = X().n; // OK,X() prvalue is converted to xvalue
—end example]
7.3.6 Qualification conversions [conv.qual]
1 A qualification-decompositionof a typeT is a sequence ofcvi and Pi such thatT is
“cv0 P0 cv1 P1 ··· cvn−1 Pn−1 cvn U” forn≥0,
where eachcvi is a set of cv-qualifiers (6.9.5), and eachPi is “pointer to” (9.3.4.2), “pointer to member of
class Ci of type” (9.3.4.4), “array ofNi”, or “array of unknown bound of” (9.3.4.5). IfPi designates an array,
the cv-qualifierscvi+1 on the element type are also taken as the cv-qualifierscvi of the array.
[Example 1: The type denoted by thetype-id const int ** has three qualification-decompositions, takingU as “int”,
as “pointer toconst int”, and as “pointer to pointer toconst int”. —end example]
2 Two types T1 and T2 are similar if they have qualification-decompositions with the samen such that
corresponding Pi components are either the same or one is “array ofNi” and the other is “array of unknown
bound of”, and the types denoted byU are the same.
3 The qualification-combined typeof two typesT1 and T2 is the typeT3 similar to T1 whose qualification-
decomposition is such that:
—(3.1) for everyi> 0, cv3
i is the union ofcv1
i and cv2
i,
—(3.2) if eitherP1
i or P2
i is “array of unknown bound of”,P3
i is “array of unknown bound of”, otherwise it is
P1
i , and
—(3.3) if the resultingcv3
i is different fromcv1
i or cv2
i, or the resultingP3
i is different fromP1
i or P2
i , then
const is added to everycv3
k for 0 <k<i ,
where cvj
i and Pj
i are the components of the qualification-decomposition ofTj. A prvalue of typeT1 can be
converted to typeT2 if the qualification-combined type ofT1 and T2 is T2.
[Note 1: If a program could assign a pointer of typeT** to a pointer of typeconst T**(that is, if line #1 below were
allowed), a program could inadvertently modify a const object (as it is done on line #2). For example,
int main() {
const char c = 'c';
char* pc;
const char** pcc = &pc; // #1: not allowed
*pcc = &c;
*pc = 'C'; // #2: modifies a const object
}
—end note]
[Note 2: Given similar typesT1 and T2, this construction ensures that both can be converted to the qualification-
combined type ofT1 and T2. —end note]
4 [Note 3: A prvalue of type “pointer tocv1 T” can be converted to a prvalue of type “pointer tocv2 T” if “cv2 T”
is more cv-qualified than “cv1 T”. A prvalue of type “pointer to member ofX of typecv1 T” can be converted to a
prvalue of type “pointer to member ofX of typecv2 T” if “cv2 T” is more cv-qualified than “cv1 T”. —end note]
41) This conversion never applies to non-static member functions because an lvalue that refers to a non-static member function
cannot be obtained.
§ 7.3.6 © ISO/IEC
110

===== PAGE 122 =====

Dxxxx
5 [Note 4: Function types (including those used in pointer-to-member-function types) are never cv-qualified (9.3.4.6).
—end note]
7.3.7 Integral promotions [conv.prom]
1 For the purposes of 7.3.7, aconverted bit-fieldis a prvalue that is the result of an lvalue-to-rvalue conversion
(7.3.2) applied to a bit-field (11.4.10).
2 A prvalue that is not a converted bit-field and has an integer type other thanbool, char8_t, char16_t,
char32_t, orwchar_t whose integer conversion rank (6.9.6) is less than the rank ofint can be converted to
a prvalue of typeint if int can represent all the values of the source type; otherwise, the source prvalue can
be converted to a prvalue of typeunsigned int.
3 A prvalue of an unscoped enumeration type whose underlying type is not fixed can be converted to a prvalue
of the first of the following types that can represent all the values of the enumeration (9.8.1):int, unsigned
int, long int, unsigned long int, long long int, orunsigned long long int. If none of the types in
that list can represent all the values of the enumeration, a prvalue of an unscoped enumeration type can be
converted to a prvalue of the extended integer type with lowest integer conversion rank (6.9.6) greater than
the rank oflong long in which all the values of the enumeration can be represented. If there are two such
extended types, the signed one is chosen.
4 A prvalue of an unscoped enumeration type whose underlying type is fixed (9.8.1) can be converted to a
prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a
prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue
of the promoted underlying type.
[Note 1: A converted bit-field of enumeration type is treated as any other value of that type for promotion purposes.
—end note]
5 A converted bit-field of integral type can be converted to a prvalue of typeint if int can represent all the
values of the bit-field; otherwise, it can be converted tounsigned int if unsigned int can represent all the
values of the bit-field.
6 A prvalue of typechar8_t, char16_t, char32_t, orwchar_t (6.9.2) (including a converted bit-field that was
not already promoted toint or unsigned int according to the rules above) can be converted to a prvalue
of the first of the following types that can represent all the values of its underlying type:int, unsigned int,
long int, unsigned long int, long long int, unsigned long long int, or its underlying type.
7 A prvalue of typebool can be converted to a prvalue of typeint, with false becoming zero andtrue
becoming one.
8 These conversions are calledintegral promotions.
7.3.8 Floating-point promotion [conv.fpprom]
1 A prvalue of typefloat can be converted to a prvalue of typedouble. The value is unchanged.
2 This conversion is calledfloating-point promotion.
7.3.9 Integral conversions [conv.integral]
1 A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped
enumeration type can be converted to a prvalue of an integer type.
2 If the destination type isbool, see 7.3.15. If the source type isbool, the valuefalse is converted to zero
and the valuetrue is converted to one.
3 Otherwise, the result is the unique value of the destination type that is congruent to the source integer
modulo 2N, whereN is the width of the destination type.
4 The conversions allowed as integral promotions are excluded from the set of integral conversions.
7.3.10 Floating-point conversions [conv.double]
1 A prvalue of floating-point type can be converted to a prvalue of another floating-point type with a greater
or equal conversion rank (6.9.6). A prvalue of standard floating-point type can be converted to a prvalue of
another standard floating-point type.
2 If the source value can be exactly represented in the destination type, the result of the conversion is that exact
representation. If the source value is between two adjacent destination values, the result of the conversion is
an implementation-defined choice of either of those values. Otherwise, the behavior is undefined.
§ 7.3.10 © ISO/IEC
111

===== PAGE 123 =====

Dxxxx
3 The conversions allowed as floating-point promotions are excluded from the set of floating-point conversions.
7.3.11 Floating-integral conversions [conv.fpint]
1 A prvalue of a floating-point type can be converted to a prvalue of an integer type. The conversion truncates;
that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be represented
in the destination type.
[Note 1: If the destination type isbool, see 7.3.15. —end note]
2 A prvalue of an integer type or of an unscoped enumeration type can be converted to a prvalue of a floating-
point type. The result is exact if possible. If the value being converted is in the range of values that can be
represented but the value cannot be represented exactly, it is an implementation-defined choice of either the
next lower or higher representable value.
[Note 2: Loss of precision occurs if the integral value cannot be represented exactly as a value of the floating-point
type. —end note]
If the value being converted is outside the range of values that can be represented, the behavior is undefined.
If the source type isbool, the valuefalse is converted to zero and the valuetrue is converted to one.
7.3.12 Pointer conversions [conv.ptr]
1 A null pointer constantis an integer literal (5.13.2) with value zero or a prvalue of typestd::nullptr_t. A
null pointer constant can be converted to a pointer type; the result is the null pointer value of that type (6.9.4)
and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is
called anull pointer conversion. The conversion of a null pointer constant to a pointer to cv-qualified type is
a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (7.3.6).
A null pointer constant of integral type can be converted to a prvalue of typestd::nullptr_t.
[Note 1: The resulting prvalue is not a null pointer value.—end note]
2 A prvalue of type “pointer tocv T”, whereT is an object type, can be converted to a prvalue of type “pointer
to cv void”. The pointer value (6.9.4) is unchanged by this conversion.
3 A prvaluev of type “pointer tocv D”, whereD is a complete class type, can be converted to a prvalue of type
“pointer tocv B”, whereB is a base class (11.7) ofD. If B is an inaccessible (11.8) or ambiguous (6.5.2) base
class ofD, a program that necessitates this conversion is ill-formed. Ifv is a null pointer value, the result is a
null pointer value. Otherwise, ifB is a virtual base class ofD or is a base class of a virtual base class ofD and
v does not point to an object whose type is similar (7.3.6) toD and that is within its lifetime or within its
period of construction or destruction (11.9.5), the behavior is undefined. Otherwise, the result is a pointer to
the base class subobject of the derived class object.
7.3.13 Pointer-to-member conversions [conv.mem]
1 A null pointer constant (7.3.12) can be converted to a pointer-to-member type; the result is thenull member
pointer valueof that type and is distinguishable from any pointer to member not created from a null pointer
constant. Such a conversion is called anull member pointer conversion. The conversion of a null pointer
constant to a pointer to member of cv-qualified type is a single conversion, and not the sequence of a
pointer-to-member conversion followed by a qualification conversion (7.3.6).
2 A prvalue of type “pointer to member ofB of typecv T”, whereB is a class type, can be converted to a
prvalue of type “pointer to member ofD of typecv T”, whereD is a complete class derived (11.7) fromB. If B
is an inaccessible (11.8), ambiguous (6.5.2), or virtual (11.7.2) base class ofD, or a base class of a virtual
base class ofD, a program that necessitates this conversion is ill-formed. If classD does not contain the
original member and is not a base class of the class containing the original member, the behavior is undefined.
Otherwise, the result of the conversion refers to the same member as the pointer to member before the
conversion took place, but it refers to the base class member as if it were a member of the derived class. The
result refers to the member inD’s instance ofB. Since the result has type “pointer to member ofD of typecv
T”, indirection through it with aD object is valid. The result is the same as if indirecting through the pointer
to member ofB with theB subobject of D. The null member pointer value is converted to the null member
pointer value of the destination type.42
42) The rule for conversion of pointers to members (from pointer to member of base to pointer to member of derived) appears
inverted compared to the rule for pointers to objects (from pointer to derived to pointer to base) (7.3.12, 11.7). This inversion is
necessary to ensure type safety. Note that a pointer to member is not an object pointer or a function pointer and the rules for
conversions of such pointers do not apply to pointers to members. In particular, a pointer to member cannot be converted to a
void*.
§ 7.3.13 © ISO/IEC
112

===== PAGE 124 =====

Dxxxx
7.3.14 Function pointer conversions [conv.fctptr]
1 A prvalue of type “pointer tonoexcept function” can be converted to a prvalue of type “pointer to function”.
The result is a pointer to the function. A prvalue of type “pointer to member of typenoexcept function” can
be converted to a prvalue of type “pointer to member of type function”. The result designates the member
function.
[Example 1:
void (*p)();
void (**pp)() noexcept = &p; // error: cannot convert to pointer tonoexcept function
struct S { typedef void (*p)(); operator p(); };
void (*q)() noexcept = S(); // error: cannot convert to pointer tonoexcept function
—end example]
7.3.15 Boolean conversions [conv.bool]
1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer-to-member type can be converted to a
prvalue of typebool. A zero value, null pointer value, or null member pointer value is converted tofalse;
any other value is converted totrue.
7.4 Usual arithmetic conversions [expr.arith.conv]
1 Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield
result types in a similar way. The purpose is to yield a common type, which is also the type of the result.
This pattern is called theusual arithmetic conversions, which are defined as follows:
—(1.1) The lvalue-to-rvalue conversion (7.3.2) is applied to each operand and the resulting prvalues are used in
place of the original operands for the remainder of this section.
—(1.2) If either operand is of scoped enumeration type (9.8.1), no conversions are performed; if the other
operand does not have the same type, the expression is ill-formed.
—(1.3) Otherwise, if one operand is of enumeration type and the other operand is of a different enumeration
type or a floating-point type, the expression is ill-formed.
—(1.4) Otherwise, if either operand is of floating-point type, the following rules are applied:
—(1.4.1) If both operands have the same type, no further conversion is performed.
—(1.4.2) Otherwise, if one of the operands is of a non-floating-point type, that operand is converted to the
type of the operand with the floating-point type.
—(1.4.3) Otherwise, if the floating-point conversion ranks (6.9.6) of the types of the operands are ordered
but not equal, then the operand of the type with the lesser floating-point conversion rank is
converted to the type of the other operand.
—(1.4.4) Otherwise, if the floating-point conversion ranks of the types of the operands are equal, then the
operand with the lesser floating-point conversion subrank (6.9.6) is converted to the type of the
other operand.
—(1.4.5) Otherwise, the expression is ill-formed.
—(1.5) Otherwise, each operand is converted to a common typeC. The integral promotion rules (7.3.7) are
used to determine a typeT1 and typeT2 for each operand.43 Then the following rules are applied to
determine C:
—(1.5.1) If T1 and T2 are the same type,C is that type.
—(1.5.2) Otherwise, if T1 and T2 are both signed integer types or are both unsigned integer types,C is the
type with greater rank.
—(1.5.3) Otherwise, letU be the unsigned integer type andS be the signed integer type.
—(1.5.3.1) If U has rank greater than or equal to the rank ofS, C is U.
—(1.5.3.2) Otherwise, ifS can represent all of the values ofU, C is S.
—(1.5.3.3) Otherwise, C is the unsigned integer type corresponding toS.
43) As a consequence, operands of typebool, char8_t, char16_t, char32_t, wchar_t, or of enumeration type are converted to
some integral type.
§ 7.4 © ISO/IEC
113

===== PAGE 125 =====

Dxxxx
7.5 Primary expressions [expr.prim]
7.5.1 Grammar [expr.prim.grammar]
primary-expression:
literal
this
( expression )
id-expression
lambda-expression
fold-expression
requires-expression
splice-expression
7.5.2 Literals [expr.prim.literal]
1 The type of a literal is determined based on its form as specified in 5.13. A string-literal is an lvalue
designating a corresponding string literal object (5.13.5), auser-defined-literal has the same value category as
the corresponding operator call expression described in 5.13.9, and any otherliteral is a prvalue.
7.5.3 This [expr.prim.this]
1 The keywordthis names a pointer to the object for which an implicit object member function (11.4.3) is
invoked or a non-static data member’s initializer (11.4) is evaluated.
2 The current classat a program point is the class associated with the innermost class scope containing that
point.
[Note 1: A lambda-expression does not introduce a class scope.—end note]
3 If the expressionthis appears within the predicate of a contract assertion (6.11.1) (including as the result
of an implicit transformation (7.5.5.1) and including in the bodies of nestedlambda-expressions) and the
current class encloses the contract assertion,const is combined with thecv-qualifier-seq used to generate the
resulting type (see below).
4 If a declaration declares a member function or member function template of a classX, the expressionthis
is a prvalue of type “pointer tocv-qualifier-seq X” wherever X is the current class between the optional
cv-qualifier-seq and the end of thefunction-definition, member-declarator, ordeclarator. It shall not appear
within the declaration of a static or explicit object member function of the current class (although its type
and value category are defined within such member functions as they are within an implicit object member
function).
[Note 2: This is because declaration matching does not occur until the complete declarator is known.—end note]
[Note 3: In atrailing-return-type, the class being defined is not required to be complete for purposes of class member
access (7.6.1.5). Class members declared later are not visible.
[Example 1:
struct A {
char g();
template<class T> auto f(T t) -> decltype(t + g())
{ return t + g(); }
};
template auto A::f(int t) -> decltype(t + g());
—end example]
—end note]
5 Otherwise, if amember-declarator declares a non-static data member (11.4) of a classX, the expression
this is a prvalue of type “pointer toX” whereverX is the current class within the optional default member
initializer (11.4).
6 The expressionthis shall not appear in any other context.
[Example 2:
class Outer {
int a[sizeof(*this)]; // error: not inside a member function
unsigned int sz = sizeof(*this); // OK, in default member initializer
§ 7.5.3 © ISO/IEC
114

===== PAGE 126 =====

Dxxxx
void f() {
int b[sizeof(*this)]; // OK
struct Inner {
int c[sizeof(*this)]; // error: not inside a member function ofInner
};
}
};
—end example]
7.5.4 Parentheses [expr.prim.paren]
1 A parenthesized expression(E) is a primary expression whose type, result, and value category are identical
to those ofE. The parenthesized expression can be used in exactly the same contexts as those whereE can
be used, and with the same meaning, except as otherwise indicated.
7.5.5 Names [expr.prim.id]
7.5.5.1 General [expr.prim.id.general]
id-expression:
unqualified-id
qualified-id
pack-index-expression
1 An id-expression is a restricted form of aprimary-expression.
[Note 1: An id-expression can appear after. and -> operators (7.6.1.5). —end note]
2 If anid-expression E denotes a non-static non-type member of some classC at a point where the current
class (7.5.3) isX and
—(2.1) E is potentially evaluated orC is X or a base class ofX, and
—(2.2) E is not theid-expression of a class member access expression (7.6.1.5), and
—(2.3) E is not theid-expression of areflect-expression (7.6.2.10), and
—(2.4) if E is aqualified-id, E is not the un-parenthesized operand of the unary& operator (7.6.2.2),
the id-expression is transformed into a class member access expression using(*this) as the object expression.
If this transformation occurs in the predicate of a precondition assertion of a constructor ofXor a postcondition
assertion of a destructor ofX, the expression is ill-formed.
[Note 2: If C is notX or a base class ofX, the class member access expression is ill-formed. Also, if theid-expression
occurs within a static or explicit object member function, the class member access is ill-formed.—end note]
This transformation does not apply in the template definition context (13.8.3.2).
[Example 1:
struct C {
bool b;
C() pre(b) // error
pre(&this->b) // OK
pre(sizeof(b) > 0); // OK,b is not potentially evaluated.
};
—end example]
3 If anid-expression E denotes a memberM of an anonymous union (11.5.2)U:
—(3.1) If U is a non-static data member,E refers toM as a member of the lookup context of the terminal
name ofE (after any implicit transformation to a class member access expression).
[Example 2: o.x is interpreted aso.u.x, whereu names the anonymous union member.—end example]
—(3.2) Otherwise, E is interpreted as a class member access (7.6.1.5) that designates the member subobject
M of the anonymous union variable forU.
[Note 3: Under this interpretation,E no longer denotes a non-static data member.—end note]
[Example 3: N::x is interpreted asN::u.x, whereu names the anonymous union variable.—end example]
§ 7.5.5.1 © ISO/IEC
115

===== PAGE 127 =====

Dxxxx
4 An id-expression or splice-expression that designates a non-static data member or implicit object member
function of a class can only be used:
—(4.1) as part of a class member access (after any implicit transformation (see above)) in which the object
expression refers to the member’s class or a class derived from that class, or
—(4.2) to form a pointer to member (7.6.2.2), or
—(4.3) if that id-expression or splice-expression designates a non-static data member and it appears in an
unevaluated operand.
[Example 4:
struct S {
int m;
};
int i = sizeof(S::m); // OK
int j = sizeof(S::m + 42); // OK
int S::*k = &[:^^S::m:]; // OK
—end example]
5 A splice-expression that designates a direct base class relationship shall appear only as the second operand of
a class member access.
6 For an id-expression that denotes an overload set, overload resolution is performed to select a unique
function (12.2, 12.3).
[Note 4: A program cannot refer to a function with a trailingrequires-clause whose constraint-expression is not satisfied,
because such functions are never selected by overload resolution.
[Example 5:
template<typename T> struct A {
static void f(int) requires false;
};
void g() {
A<int>::f(0); // error: cannot callf
void (*p1)(int) = A<int>::f; // error: cannot take the address off
decltype(A<int>::f)* p2 = nullptr; // error: the typedecltype(A<int>::f) is invalid
}
In each case, the constraints off are not satisfied. In the declaration ofp2, those constraints need to be satisfied even
though f is an unevaluated operand (7.2.3).—end example]
—end note]
7.5.5.2 Unqualified names [expr.prim.id.unqual]
unqualified-id:
identifier
operator-function-id
conversion-function-id
literal-operator-id
~ type-name
~ computed-type-specifier
template-id
1 An identifier is only anid-expression if it has been suitably declared (Clause 9) or if it appears as part of a
declarator-id (9.3).
[Note 1: Foroperator-function-ids, see 12.4; forconversion-function-ids, see 11.4.8.3; forliteral-operator-ids, see 12.6; for
template-ids, see 13.3. Atype-name or computed-type-specifier prefixed by~ denotes the destructor of the type so
named; see 7.5.5.5. —end note]
2 A component nameof anunqualified-id U is
—(2.1) U if it is a name or
—(2.2) the component name of thetemplate-id or type-name of U, if any.
[Note 2: Other constructs that contain names to look up can have several component names (7.5.5.3, 9.2.9.3, 9.2.9.5,
9.3.4.4, 9.10, 13.2, 13.3, 13.8).—end note]
§ 7.5.5.2 © ISO/IEC
116

===== PAGE 128 =====

Dxxxx
The terminal nameof a construct is the component name of that construct that appears lexically last.
3 The result is the entity denoted by theunqualified-id (6.5.3).
4 If
—(4.1) the unqualified-id appears in alambda-expression at program pointP,
—(4.2) the entity is a local entity (6.1) or a variable declared by aninit-capture (7.5.6.3),
—(4.3) naming the entity within thecompound-statement of the innermost enclosinglambda-expression of P,
but not in an unevaluated operand, would refer to an entity captured by copy in some intervening
lambda-expression, and
—(4.4) P is in the function parameter scope, but not theparameter-declaration-clause, of the innermost such
lambda-expression E,
then the type of the expression is the type of a class member access expression (7.6.1.5) naming the non-static
data member that would be declared for such a capture in the object parameter (9.3.4.6) of the function call
operator ofE.
[Note 3: If E is not declaredmutable, the type of such an identifier will typically beconst qualified. —end note]
[Example 1:
void f() {
float x, &r = x;
[=]() -> decltype((x)) { // lambda returnsfloat const& because this lambda is notmutable and
// x is an lvalue
decltype(x) y1; // y1 has typefloat
decltype((x)) y2 = y1; // y2 has typefloat const&
decltype(r) r1 = y1; // r1 has typefloat&
decltype((r)) r2 = y2; // r2 has typefloat const&
return y2;
};
[=](decltype((x)) y) {
decltype((x)) z = x; // OK,y has typefloat&, z has typefloat const&
};
[=] {
[](decltype((x)) y) {}; // OK, lambda takes a parameter of typefloat const&
[x=1](decltype((x)) y) {
decltype((x)) z = x; // OK,y has typeint&, z has typeint const&
};
};
}
—end example]
5 Otherwise, if theunqualified-id names a coroutine parameter, the type of the expression is that of the copy of
the parameter (9.6.4), and the result is that copy.
6 Otherwise, if theunqualified-id names a result binding (9.4.2) attached to a function with return typeU,
—(6.1) if U is “reference toT”, then the type of the expression isconst T;
—(6.2) otherwise, the type of the expression isconst U.
7 Otherwise, if theunqualified-id appears in the predicate of a contract assertionC (6.11) and the entity is
—(7.1) a variable declared outside ofC of object typeT,
—(7.2) a variable or template parameter declared outside ofC of type “reference toT”, or
—(7.3) a structured binding of typeT whose corresponding variable is declared outside ofC,
then the type of the expression isconst T.
8 [Example 2:
int n = 0;
struct X { bool m(); };
§ 7.5.5.2 © ISO/IEC
117

===== PAGE 129 =====

Dxxxx
struct Y {
int z = 0;
void f(int i, int* p, int& r, X x, X* px)
pre (++n) // error: attempting to modify const lvalue
pre (++i) // error: attempting to modify const lvalue
pre (++(*p)) // OK
pre (++r) // error: attempting to modify const lvalue
pre (x.m()) // error: calling non-const member function
pre (px->m()) // OK
pre ([=,&i,*this] mutable {
++n; // error: attempting to modify const lvalue
++i; // error: attempting to modify const lvalue
++p; // OK, refers to member of closure type
++r; // OK, refers to non-reference member of closure type
++this->z; // OK, captured*this
++z; // OK, captured*this
int j = 17;
[&]{
int k = 34;
++i; // error: attempting to modify const lvalue
++j; // OK
++k; // OK
}();
return true;
}());
template <int N, int& R, int* P>
void g()
pre(++N) // error: attempting to modify prvalue
pre(++R) // error: attempting to modify const lvalue
pre(++(*P)); // OK
int h()
post(r : ++r) // error: attempting to modify const lvalue
post(r: [=] mutable {
++r; // OK, refers to member of closure type
return true;
}());
int& k()
post(r : ++r); // error: attempting to modify const lvalue
};
—end example]
9 Otherwise, if the entity is a template parameter object for a template parameter of typeT (13.2), the type of
the expression isconst T.
10 In all other cases, the type of the expression is the type of the entity.
11 [Note 4: The type will be adjusted as described in 7.2.2 if it is cv-qualified or is a reference type.—end note]
12 The expression is an xvalue if it is move-eligible (see below); an lvalue if the entity is a function, variable,
structured binding (9.7), result binding (9.4.2), data member, or template parameter object; and a prvalue
otherwise (7.2.1); it is a bit-field if the identifier designates a bit-field.
13 If anid-expression E appears in the predicate of a function contract assertion attached to a functionf and
denotes a function parameter off and the implementation introduces any temporary objects to hold the
value of that parameter as specified in 6.8.7,
—(13.1) if the contract assertion is a precondition assertion and the evaluation of the precondition assertion is
sequenced before the initialization of the parameter object,E refers to the most recently initialized
such temporary object, and
§ 7.5.5.2 © ISO/IEC
118

===== PAGE 130 =====

Dxxxx
—(13.2) if the contract assertion is a postcondition assertion, it is unspecified whetherE refers to one of the
temporary objects or the parameter object; the choice is consistent within a single evaluation of a
postcondition assertion.
14 If anid-expression E names a result binding in a postcondition assertion and the implementation introduces
any temporary objects to hold the result object as specified in 6.8.7, and the postcondition assertion is
sequenced before the initialization of the result object (7.6.1.3),E refers to the most recently initialized such
temporary object.
15 An implicitly movable entityis a variable with automatic storage duration that is either a non-volatile object
or an rvalue reference to a non-volatile object type. Anid-expression or splice-expression (7.5.9) ismove-eligible
if
—(15.1) it designates an implicitly movable entity,
—(15.2) it is the (possibly parenthesized) operand of areturn (8.8.4) orco_return (8.8.5) statement or of a
throw-expression (7.6.18), and
—(15.3) each intervening scope between the declaration of the entity and the innermost enclosing scope of
the expression is a block scope and, for athrow-expression, is not the block scope of atry-block or
function-try-block.
7.5.5.3 Qualified names [expr.prim.id.qual]
qualified-id:
nested-name-specifier templateopt unqualified-id
nested-name-specifier:
::
type-name ::
namespace-name ::
computed-type-specifier ::
splice-scope-specifier ::
nested-name-specifier identifier::
nested-name-specifier templateopt simple-template-id ::
splice-scope-specifier:
splice-specifier
templateopt splice-specialization-specifier
1 The component names of aqualified-id are those of itsnested-name-specifier and unqualified-id. The component
names of anested-name-specifier are itsidentifier (if any) and those of itstype-name, namespace-name, simple-
template-id, and/ornested-name-specifier.
2 A splice-specifier or splice-specialization-specifier that is not followed by:: is never interpreted as part of
a splice-scope-specifier. The keyword template may only be omitted from the formtemplateopt splice-
specialization-specifier :: when thesplice-specialization-specifier is preceded bytypename.
[Example 1:
template<int V>
struct TCls {
static constexpr int s = V;
using type = int;
};
int v1 = [:^^TCls<1>:]::s;
int v2 = template [:^^TCls:]<2>::s; // OK,template binds tosplice-scope-specifier
typename [:^^TCls:]<3>::type v3 = 3; // OK,typename binds to the qualified name
template [:^^TCls:]<3>::type v4 = 4; // OK,template binds to thesplice-scope-specifier
typename template [:^^TCls:]<3>::type v5 = 5; // OK, same asv3
[:^^TCls:]<3>::type v6 = 6; // error: unexpected<
—end example]
3 A nested-name-specifier is declarative if it is part of
—(3.1) a class-head-name (11.1),
—(3.2) an enum-head-name (9.8.1),
—(3.3) a qualified-id that is theid-expression of adeclarator-id (9.3.1),
§ 7.5.5.3 © ISO/IEC
119

===== PAGE 131 =====

Dxxxx
—(3.4) an elaborated-type-specifier of an explicit instantiation (13.9.3), or
—(3.5) a declarativenested-name-specifier.
A declarativenested-name-specifier shall not have acomputed-type-specifier or a splice-scope-specifier. A
declaration that uses a declarativenested-name-specifier shall be a friend declaration or inhabit a scope that
contains the entity being redeclared or specialized.
4 The entity designated by anested-name-specifier is determined as follows:
—(4.1) The nested-name-specifier :: designates the global namespace.
—(4.2) A nested-name-specifier with a computed-type-specifier designates the same type designated by the
computed-type-specifier, which shall be a class or enumeration type.
—(4.3) For anested-name-specifier of the formsplice-specifier ::, thesplice-specifier shall designate a class
or enumeration type or a namespace. Thenested-name-specifier designates the same entity as the
splice-specifier.
—(4.4) For anested-name-specifier of the formtemplateopt splice-specialization-specifier ::, thesplice-specifier
of thesplice-specialization-specifier shall designate a class template or an alias templateT. Letting S be
the specialization ofT corresponding to the template argument list of thesplice-specialization-specifier,
S shall either be a class template specialization or an alias template specialization that denotes a class
or enumeration type. Thenested-name-specifier designates the underlying entity ofS.
—(4.5) If anested-name-specifier N is declarative and has asimple-template-id with a template argument listA
that involves a template parameter, letT be the template nominated byN without A. T shall be a
class template.
—(4.5.1) If A is the template argument list (13.4) of the correspondingtemplate-head H (13.7.3), N
designates the primary template ofT; H shall be equivalent to thetemplate-head of T (13.7.7.2).
—(4.5.2) Otherwise, N designates the partial specialization (13.7.6) ofT whose template argument list is
equivalent toA (13.7.7.2); the program is ill-formed if no such partial specialization exists.
—(4.6) Any other nested-name-specifier designates the entity denotes by itstype-name, namespace-name,
identifier, orsimple-template-id. If thenested-name-specifier is not declarative, the entity shall not be a
template.
5 A qualified-id shall not be of the formnested-name-specifier templateopt ~ computed-type-specifier nor of the
form computed-type-specifier :: ~ type-name.
6 The result of aqualified-id Q is the entity it denotes (6.5.5).
7 If Q appears in the predicate of a contract assertionC (6.11) and the entity is
—(7.1) a variable declared outside ofC of object typeT,
—(7.2) a variable declared outside ofC of type “reference toT”, or
—(7.3) a structured binding of typeT whose corresponding variable is declared outside ofC,
then the type of the expression isconst T.
8 Otherwise, the type of the expression is the type of the result.
9 The result is an lvalue if the member is
—(9.1) a function other than a non-static member function,
—(9.2) a non-static member function ifQ is the operand of a unary& operator,
—(9.3) a variable,
—(9.4) a structured binding (9.7), or
—(9.5) a data member,
and a prvalue otherwise.
7.5.5.4 Pack indexing expression [expr.prim.pack.index]
pack-index-expression:
id-expression ... [ constant-expression ]
1 The id-expression P in apack-index-expression shall be anidentifier that denotes a pack.
§ 7.5.5.4 © ISO/IEC
120

===== PAGE 132 =====

Dxxxx
2 The constant-expression shall be a converted constant expression (7.7) of typestd::size_t whose valueV,
termed the index, is such that0 ≤V <sizeof...(P).
3 A pack-index-expression is a pack expansion (13.7.4).
4 [Note 1: A pack-index-expression denotes theVth element of the pack.—end note]
7.5.5.5 Destruction [expr.prim.id.dtor]
1 An id-expression that denotes the destructor of a typeT names the destructor ofT if T is a class type (11.4.7),
otherwise theid-expression is said to name apseudo-destructor.
2 If theid-expression names a pseudo-destructor,T shall be a scalar type and theid-expression shall appear as the
right operand of a class member access (7.6.1.5) that forms thepostfix-expression of a function call (7.6.1.3).
[Note 1: Such a call ends the lifetime of the object (7.6.1.3, 6.8.4).—end note]
3 [Example 1:
struct C { };
void f() {
C * pc = new C;
using C2 = C;
pc->C::~C2(); // OK, destroys*pc
C().C::~C(); // undefined behavior: temporary of typeC destroyed twice
using T = int;
0 .T::~T(); // OK, no effect
0.T::~T(); // error: 0.T is auser-defined-floating-point-literal (5.13.9)
}
—end example]
7.5.6 Lambda expressions [expr.prim.lambda]
7.5.6.1 General [expr.prim.lambda.general]
lambda-expression:
lambda-introducer attribute-specifier-seqopt lambda-declarator compound-statement
lambda-introducer < template-parameter-list > requires-clauseopt attribute-specifier-seqopt
lambda-declarator compound-statement
lambda-introducer:
[ lambda-captureopt ]
lambda-declarator:
lambda-specifier-seq noexcept-specifieropt attribute-specifier-seqopt trailing-return-typeopt
function-contract-specifier-seqopt
noexcept-specifier attribute-specifier-seqopt trailing-return-typeopt function-contract-specifier-seqopt
trailing-return-typeopt function-contract-specifier-seqopt
( parameter-declaration-clause ) lambda-specifier-seqopt noexcept-specifieropt attribute-specifier-seqopt
trailing-return-typeopt requires-clauseopt function-contract-specifier-seqopt
lambda-specifier:
consteval
constexpr
mutable
static
lambda-specifier-seq:
lambda-specifier lambda-specifier-seqopt
1 A lambda-expression provides a concise way to create a simple function object.
[Example 1:
#include <algorithm>
#include <cmath>
void abssort(float* x, unsigned N) {
std::sort(x, x + N, [](float a, float b) { return std::abs(a) < std::abs(b); });
}
—end example]
2 A lambda-expression is a prvalue whose result object is called theclosure object.
[Note 1: A closure object behaves like a function object (22.10).—end note]
§ 7.5.6.1 © ISO/IEC
121

===== PAGE 133 =====

Dxxxx
3 An ambiguity can arise because arequires-clause can end in anattribute-specifier-seq, which collides with the
attribute-specifier-seq in lambda-expression. In such cases, any attributes are treated asattribute-specifier-seq
in lambda-expression.
[Note 2: Such ambiguous cases cannot have valid semantics because the constraint expression would not have type
bool.
[Example 2:
auto x = []<class T> requires T::operator int [[some_attribute]] (int) { }
—end example]
—end note]
4 A lambda-specifier-seq shall contain at most one of eachlambda-specifier and shall not contain bothconstexpr
and consteval. If thelambda-declarator contains an explicit object parameter (9.3.4.6), then nolambda-
specifier in thelambda-specifier-seq shall bemutable or static. The lambda-specifier-seq shall not contain
both mutable and static. If thelambda-specifier-seq contains static, there shall be nolambda-capture.
[Note 3: The trailingrequires-clause is described in 9.3.—end note]
5 A lambda-expression’s parameter-declaration-clause is theparameter-declaration-clause of thelambda-expression’s
lambda-declarator, if any, or empty otherwise. If thelambda-declarator does not include atrailing-return-type,
it is considered to be-> auto.
[Note 4: In that case, the return type is deduced fromreturn statements as described in 9.2.9.7.—end note]
[Example 3:
auto x1 = [](int i) { return i; }; // OK, return type isint
auto x2 = []{ return { 1, 2 }; }; // error: deducing return type frombraced-init-list
int j;
auto x3 = [&]()->auto&& { return j; }; // OK, return type isint&
—end example]
6 A lambda is ageneric lambdaif thelambda-expression has any generic parameter type placeholders (9.2.9.7),
or if the lambda has atemplate-parameter-list.
[Example 4:
auto x = [](int i, auto a) { return i; }; // OK, a generic lambda
auto y = [](this auto self, int i) { return i; }; // OK, a generic lambda
auto z = []<class T>(int i) { return i; }; // OK, a generic lambda
—end example]
7.5.6.2 Closure types [expr.prim.lambda.closure]
1 The type of alambda-expression (which is also the type of the closure object) is a unique, unnamed non-union
class type, called theclosure type, whose properties are described below.
2 The closure type is incomplete until the end of its correspondingcompound-statement.
3 The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the
corresponding lambda-expression.
[Note 1: This determines the set of namespaces and classes associated with the closure type (6.5.4). The parameter
types of alambda-declarator do not affect these associated namespaces and classes.—end note]
4 The closure type is not an aggregate type (9.5.2); it is a structural type (13.2) if and only if the lambda has
no lambda-capture. An implementation may define the closure type differently from what is described below
provided this does not alter the observable behavior of the program other than by changing:
—(4.1) the size and/or alignment of the closure type,
—(4.2) whether the closure type is trivially copyable (11.2), or
—(4.3) whether the closure type is a standard-layout class (11.2).
An implementation shall not add members of rvalue reference type to the closure type.
5 The closure type for alambda-expression has a public inline function call operator (for a non-generic lambda)
or function call operator template (for a generic lambda) (12.4.4) whose parameters and return type are
those of thelambda-expression’s parameter-declaration-clause and trailing-return-type respectively, and whose
template-parameter-list consists of the specifiedtemplate-parameter-list, if any. The function call operator
§ 7.5.6.2 © ISO/IEC
122

===== PAGE 134 =====

Dxxxx
or the function call operator template are direct members of the closure type. Therequires-clause of the
function call operator template is therequires-clause immediately following< template-parameter-list >, if any.
The trailingrequires-clause of the function call operator or operator template is therequires-clause of the
lambda-declarator, if any.
[Note 2: The function call operator template for a generic lambda can be an abbreviated function template (9.3.4.6).
—end note]
[Example 1:
auto glambda = [](auto a, auto&& b) { return a < b; };
bool b = glambda(3, 3.14); // OK
auto vglambda = [](auto printer) {
return [=](auto&& ... ts) { // OK, ts is a function parameter pack
printer(std::forward<decltype(ts)>(ts)...);
return [=]() {
printer(ts ...);
};
};
};
auto p = vglambda( [](auto v1, auto v2, auto v3)
{ std::cout << v1 << v2 << v3; } );
auto q = p(1, 'a', 3.14); // OK, outputs1a3.14
q(); // OK, outputs1a3.14
auto fact = [](this auto self, int n) -> int { // OK, explicit object parameter
return (n <= 1) ? 1 : n * self(n-1);
};
std::cout << fact(5); // OK, outputs 120
—end example]
6 Given a lambda with alambda-capture, the type of the explicit object parameter, if any, of the lambda’s
function call operator (possibly instantiated from a function call operator template) shall be either:
—(6.1) the closure type,
—(6.2) a class type publicly and unambiguously derived from the closure type, or
—(6.3) a reference to a possibly cv-qualified such type.
[Example 2:
struct C {
template <typename T>
C(T);
};
void func(int i) {
int x = [=](this auto&&) { return i; }(); // OK
int y = [=](this C) { return i; }(); // error
int z = [](this C) { return 42; }(); // OK
}
—end example]
7 The function call operator or operator template is a static member function or static member function
template (11.4.9.2) if thelambda-expression’s parameter-declaration-clause is followed bystatic. Otherwise,
it is a non-static member function or member function template (11.4.3) that is declaredconst (11.4.3) if
and only if thelambda-expression’s parameter-declaration-clause is not followed bymutable and thelambda-
declarator does not contain an explicit object parameter. It is neither virtual nor declared volatile.
Any noexcept-specifier or function-contract-specifier (9.4.1) specified on alambda-expression applies to the
corresponding function call operator or operator template. Anattribute-specifier-seq in alambda-declarator
appertains to the type of the corresponding function call operator or operator template. Anattribute-
specifier-seq in alambda-expression preceding alambda-declarator appertains to the corresponding function
call operator or operator template. The function call operator or any given operator template specialization
is a constexpr function if either the correspondinglambda-expression’s parameter-declaration-clause is followed
§ 7.5.6.2 © ISO/IEC
123

===== PAGE 135 =====

Dxxxx
by constexpr or consteval, or it is constexpr-suitable (9.2.6). It is an immediate function (9.2.6) if the
corresponding lambda-expression’s parameter-declaration-clause is followed byconsteval.
[Example 3:
auto ID = [](auto a) { return a; };
static_assert(ID(3) == 3); // OK
struct NonLiteral {
NonLiteral(int n) : n(n) { }
int n;
};
static_assert(ID(NonLiteral{3}).n == 3); // error
—end example]
8 [Example 4:
auto monoid = [](auto v) { return [=] { return v; }; };
auto add = [](auto m1) constexpr {
auto ret = m1();
return [=](auto m2) mutable {
auto m1val = m1();
auto plus = [=](auto m2val) mutable constexpr
{ return m1val += m2val; };
ret = plus(m2());
return monoid(ret);
};
};
constexpr auto zero = monoid(0);
constexpr auto one = monoid(1);
static_assert(add(one)(zero)() == one()); // OK
// Sincetwo below is not declaredconstexpr, an evaluation of itsconstexpr member function call operator
// cannot perform an lvalue-to-rvalue conversion on one of its subobjects (that represents its capture)
// in a constant expression.
auto two = monoid(2);
assert(two() == 2); // OK, not a constant expression.
static_assert(add(one)(one)() == two()); // error: two() is not a constant expression
static_assert(add(one)(one)() == monoid(2)()); // OK
—end example]
9 [Note 3: The function call operator or operator template can be constrained (13.5.3) by atype-constraint (13.2), a
requires-clause (13.1), or a trailingrequires-clause (9.3).
[Example 5:
template <typename T> concept C1 = /* ... */;
template <std::size_t N> concept C2 = /* ... */;
template <typename A, typename B> concept C3 = /* ... */;
auto f = []<typename T1, C1 T2> requires C2<sizeof(T1) + sizeof(T2)>
(T1 a1, T1 b1, T2 a2, auto a3, auto a4) requires C3<decltype(a4), T2> {
// T2 is constrained by atype-constraint.
// T1 and T2 are constrained by arequires-clause, and
// T2 and the type ofa4 are constrained by a trailingrequires-clause.
};
—end example]
—end note]
10 If all potential references to a local entity implicitly captured by alambda-expression Loccur within the function
contract assertions (9.4.1) of the call operator or operator template ofL or withinassertion-statements (8.9)
within the body ofL, the program is ill-formed.
[Note 4: Adding a contract assertion to an existing C++ program cannot cause additional captures.—end note]
[Example 6:
static int i = 0;
§ 7.5.6.2 © ISO/IEC
124

===== PAGE 136 =====

Dxxxx
void test() {
auto f1 = [=] pre(i > 0) {}; // OK, no local entities are captured.
int i = 1;
auto f2 = [=] pre(i > 0) {}; // error: cannot implicitly capturei here
auto f3 = [i] pre(i > 0) {}; // OK,i is captured explicitly.
auto f4 = [=] {
contract_assert(i > 0); // error: cannot implicitly capturei here
};
auto f5 = [=] {
contract_assert(i > 0); // OK,i is referenced elsewhere.
(void)i;
};
auto f6 = [=] pre( // #1
[]{
bool x = true;
return [=]{ return x; }(); // OK, #1 captures nothing.
}()) {};
bool y = true;
auto f7 = [=] pre([=]{ return y; }()); // error: outer capture ofy is invalid.
}
—end example]
11 The closure type for a non-genericlambda-expression with nolambda-capture and no explicit object parameter
(9.3.4.6) whose constraints (if any) are satisfied has a conversion function to pointer to function with C++
language linkage (9.12) having the same parameter and return types as the closure type’s function call
operator. The conversion is to “pointer tonoexcept function” if the function call operator has a non-throwing
exception specification. If the function call operator is a static member function, then the value returned
by this conversion function is a pointer to the function call operator. Otherwise, the value returned by this
conversion function is a pointer to a functionF that, when invoked, has the same effect as invoking the
closure type’s function call operator on a default-constructed instance of the closure type.F is a constexpr
function if the function call operator is a constexpr function and is an immediate function if the function call
operator is an immediate function.
12 For a generic lambda with nolambda-capture and no explicit object parameter (9.3.4.6), the closure type
has a conversion function template to pointer to function. The conversion function template has the same
invented template parameter list, and the pointer to function has the same parameter types, as the function
call operator template. The return type of the pointer to function shall behave as if it were adecltype-specifier
denoting the return type of the corresponding function call operator template specialization.
13 [Note 5: If the generic lambda has notrailing-return-type or thetrailing-return-type contains a placeholder type, return
type deduction of the corresponding function call operator template specialization has to be done. The corresponding
specialization is that instantiation of the function call operator template with the same template arguments as those
deduced for the conversion function template. Consider the following:
auto glambda = [](auto a) { return a; };
int (*fp)(int) = glambda;
The behavior of the conversion function ofglambda above is like that of the following conversion function:
struct Closure {
template<class T> auto operator()(T t) const { /* ... */ }
template<class T> static auto lambda_call_operator_invoker(T a) {
// forwards execution tooperator()(a) and therefore has
// the same return type deduced
/* ... */
}
template<class T> using fptr_t =
decltype(lambda_call_operator_invoker(declval<T>())) (*)(T);
§ 7.5.6.2 © ISO/IEC
125

===== PAGE 137 =====

Dxxxx
template<class T> operator fptr_t<T>() const
{ return &lambda_call_operator_invoker; }
};
—end note]
[Example 7:
void f1(int (*)(int)) { }
void f2(char (*)(int)) { }
void g(int (*)(int)) { } // #1
void g(char (*)(char)) { } // #2
void h(int (*)(int)) { } // #3
void h(char (*)(int)) { } // #4
auto glambda = [](auto a) { return a; };
f1(glambda); // OK
f2(glambda); // error: ID is not convertible
g(glambda); // error: ambiguous
h(glambda); // OK, calls #3 since it is convertible from ID
int& (*fpi)(int*) = [](auto* a) -> auto& { return *a; }; // OK
—end example]
14 If the function call operator template is a static member function template, then the value returned by
any given specialization of this conversion function template is a pointer to the corresponding function call
operator template specialization. Otherwise, the value returned by any given specialization of this conversion
function template is a pointer to a functionF that, when invoked, has the same effect as invoking the generic
lambda’s corresponding function call operator template specialization on a default-constructed instance of
the closure type.F is a constexpr function if the corresponding specialization is a constexpr function andF is
an immediate function if the function call operator template specialization is an immediate function.
[Note 6: This will result in the implicit instantiation of the generic lambda’s body. The instantiated generic lambda’s
return type and parameter types need to match the return type and parameter types of the pointer to function.
—end note]
[Example 8:
auto GL = [](auto a) { std::cout << a; return a; };
int (*GL_int)(int) = GL; // OK, through conversion function template
GL_int(3); // OK, same asGL(3)
—end example]
15 The conversion function or conversion function template is public, constexpr, non-virtual, non-explicit, const,
and has a non-throwing exception specification (14.5).
[Example 9:
auto Fwd = [](int (*fp)(int), auto a) { return fp(a); };
auto C = [](auto a) { return a; };
static_assert(Fwd(C,3) == 3); // OK
// No specialization of the function call operator template can be constexpr (due to the local static).
auto NC = [](auto a) { static int s; return a; };
static_assert(Fwd(NC,3) == 3); // error
—end example]
16 The lambda-expression’s compound-statement yields thefunction-body (9.6) of the function call operator, but
it is not within the scope of the closure type.
[Example 10:
struct S1 {
int x, y;
int operator()(int);
void f() {
[=]()->int {
return operator()(this->x + y); // equivalent toS1::operator()(this->x + (*this).y)
§ 7.5.6.2 © ISO/IEC
126

===== PAGE 138 =====

Dxxxx
// this has typeS1*
};
}
};
—end example]
Unless thecompound-statement is that of aconsteval-block-declaration (9.1), a variable__func__ is implicitly
defined at the beginning of thecompound-statement of thelambda-expression, with semantics as described
in 9.6.1.
17 The closure type associated with alambda-expression has no default constructor if thelambda-expression has
a lambda-capture and a defaulted default constructor otherwise. It has a defaulted copy constructor and a
defaulted move constructor (11.4.5.3). It has a deleted copy assignment operator if thelambda-expression has
a lambda-capture and defaulted copy and move assignment operators otherwise (11.4.6).
[Note 7: These special member functions are implicitly defined as usual, which can result in them being defined as
deleted. —end note]
18 The closure type associated with alambda-expression has an implicitly-declared destructor (11.4.7).
19 A member of a closure type shall not be explicitly instantiated (13.9.3), explicitly specialized (13.9.4), or
named in a friend declaration (11.8.4).
7.5.6.3 Captures [expr.prim.lambda.capture]
lambda-capture:
capture-default
capture-list
capture-default , capture-list
capture-default:
&
=
capture-list:
capture
capture-list , capture
capture:
simple-capture
init-capture
simple-capture:
identifier ...opt
& identifier ...opt
this
* this
init-capture:
...opt identifier initializer
& ...opt identifier initializer
1 The body of alambda-expression may refer to local entities of enclosing scopes by capturing those entities, as
described below.
2 If alambda-capture includes acapture-default that is&, no identifier in asimple-capture of thatlambda-capture
shall be preceded by&. If alambda-capture includes acapture-default that is=, eachsimple-capture of that
lambda-capture shall be of the form “& identifier ...opt”, “this”, or “* this”.
[Note 1: The form[&,this] is redundant but accepted for compatibility with C++ 2014. —end note]
Ignoring appearances ininitializers ofinit-captures, an identifier orthis shall not appear more than once in a
lambda-capture.
[Example 1:
struct S2 { void f(int i); };
void S2::f(int i) {
[&, i]{ }; // OK
[&, this, i]{ }; // OK, equivalent to[&, i]
[&, &i]{ }; // error: i preceded by& when & is the default
[=, *this]{ }; // OK
§ 7.5.6.3 © ISO/IEC
127

===== PAGE 139 =====

Dxxxx
[=, this]{ }; // OK, equivalent to[=]
[i, i]{ }; // error: i repeated
[this, *this]{ }; // error: this appears twice
}
—end example]
3 A lambda-expression shall not have acapture-default or simple-capture in itslambda-introducer unless
—(3.1) its innermost enclosing scope is a block scope (6.4.3),
—(3.2) it appears within a default member initializer and its innermost enclosing scope is the corresponding
class scope (6.4.7), or
—(3.3) it appears within a contract assertion and its innermost enclosing scope is the corresponding contract-
assertion scope (6.4.10).
4 The identifier in asimple-capture shall denote a local entity (6.5.3, 6.1). Thesimple-captures this and *
this denote the local entity*this. An entity that is designated by asimple-capture is said to beexplicitly
captured.
5 If anidentifier in acapture appears as thedeclarator-id of a parameter of thelambda-declarator’s parameter-
declaration-clause or as the name of a template parameter of thelambda-expression’s template-parameter-list,
the program is ill-formed.
[Example 2:
void f() {
int x = 0;
auto g = [x](int x) { return 0; }; // error: parameter andcapture have the same name
auto h = [y = 0]<typename y>(y) { return 0; }; // error: template parameter andcapture
// have the same name
}
—end example]
6 An init-capture inhabits the lambda scope (6.4.5) of thelambda-expression. An init-capture without ellipsis
behaves as if it declares and explicitly captures a variable of the form “auto init-capture ;”, except that:
—(6.1) if the capture is by copy (see below), the non-static data member declared for the capture and the
variable are treated as two different ways of referring to the same object, which has the lifetime of the
non-static data member, and no additional copy and destruction is performed, and
—(6.2) if the capture is by reference, the variable’s lifetime ends when the closure object’s lifetime ends.
[Note 2: This enables aninit-capture like “x = std::move(x)”; the second “x” must bind to a declaration in the
surrounding context. —end note]
[Example 3:
int x = 4;
auto y = [&r = x, x = x+1]()->int {
r += 2;
return x+2;
}(); // Updates::x to 6, and initializesy to 7.
auto z = [a = 42](int a) { return 1; }; // error: parameter and conceptual local variable have the same
name
auto counter = [i=0]() mutable -> decltype(i) { // OK, returnsint
return i++;
};
—end example]
7 For the purposes of lambda capture, an expression potentially references local entities as follows:
—(7.1) An id-expression that names a local entity potentially references that entity; anid-expression that names
one or more non-static class members and does not form a pointer to member (7.6.2.2) potentially
references *this.
[Note 3: This occurs even if overload resolution selects a static member function for theid-expression. —end
note]
—(7.2) A this expression potentially references*this.
§ 7.5.6.3 © ISO/IEC
128

===== PAGE 140 =====

Dxxxx
—(7.3) A lambda-expression potentially references the local entities named by itssimple-captures.
If an expression potentially references a local entity within a scope in which it is odr-usable (6.3), and the
expression would be potentially evaluated if the effect of any enclosingtypeid expressions (7.6.1.8) were
ignored, the entity is said to beimplicitly capturedby each interveninglambda-expression with an associated
capture-default that does not explicitly capture it. The implicit capture of*this is deprecated when the
capture-default is =; see D.3.
[Example 4:
void f(int, const int (&)[2] = {}); // #1
void f(const int&, const int (&)[1]); // #2
void test() {
const int x = 17;
auto g = [](auto a) {
f(x); // OK, calls #1, does not capturex
};
auto g1 = [=](auto a) {
f(x); // OK, calls #1, capturesx
};
auto g2 = [=](auto a) {
int selector[sizeof(a) == 1 ? 1 : 2]{};
f(x, selector); // OK, capturesx, can call #1 or #2
};
auto g3 = [=](auto a) {
typeid(a + x); // capturesx regardless of whethera + x is an unevaluated operand
};
}
Within g1, an implementation can optimize away the capture ofx as it is not odr-used.—end example]
[Note 4: The set of captured entities is determined syntactically, and entities are implicitly captured even if the
expression denoting a local entity is within a discarded statement (8.5.2).
[Example 5:
template<bool B>
void f(int n) {
[=](auto a) {
if constexpr (B && sizeof(a) > 4) {
(void)n; // capturesn regardless of the value ofB and sizeof(int)
}
}(0);
}
—end example]
—end note]
8 An entity iscapturedif it is captured explicitly or implicitly. An entity captured by alambda-expression is
odr-used (6.3) by thelambda-expression.
[Note 5: As a consequence, if alambda-expression explicitly captures an entity that is not odr-usable, the program is
ill-formed (6.3). —end note]
[Example 6:
void f1(int i) {
int const N = 20;
auto m1 = [=]{
int const M = 30;
auto m2 = [i]{
int x[N][M]; // OK,N and M are not odr-used
x[0][0] = i; // OK,i is explicitly captured bym2 and implicitly captured bym1
};
};
struct s1 {
int f;
§ 7.5.6.3 © ISO/IEC
129

===== PAGE 141 =====

Dxxxx
void work(int n) {
int m = n*n;
int j = 40;
auto m3 = [this,m] {
auto m4 = [&,j] { // error: j not odr-usable due to intervening lambdam3
int x = n; // error: n is odr-used but not odr-usable due to intervening lambdam3
x += m; // OK,m implicitly captured bym4 and explicitly captured bym3
x += i; // error: i is odr-used but not odr-usable
// due to intervening function and class scopes
x += f; // OK,this captured implicitly bym4 and explicitly bym3
};
};
}
};
}
struct s2 {
double ohseven = .007;
auto f() {
return [this] {
return [*this] {
return ohseven; // OK
};
}();
}
auto g() {
return [] {
return [*this] { }; // error: *this not captured by outerlambda-expression
}();
}
};
—end example]
9 [Note 6: Because local entities are not odr-usable within a default argument (6.3), alambda-expression appearing in
a default argument cannot implicitly or explicitly capture any local entity. Such alambda-expression can still have
an init-capture if any full-expression in itsinitializer satisfies the constraints of an expression appearing in a default
argument (9.3.4.7). —end note]
[Example 7:
void f2() {
int i = 1;
void g1(int = ([i]{ return i; })()); // error
void g2(int = ([i]{ return 0; })()); // error
void g3(int = ([=]{ return i; })()); // error
void g4(int = ([=]{ return 0; })()); // OK
void g5(int = ([]{ return sizeof i; })()); // OK
void g6(int = ([x=1]{ return x; })()); // OK
void g7(int = ([x=i]{ return x; })()); // error
}
—end example]
10 An entity iscaptured by copyif
—(10.1) it is implicitly captured, thecapture-default is =, and the captured entity is not*this, or
—(10.2) it is explicitly captured with a capture that is not of the formthis, & identifier ...opt, or& ...opt
identifier initializer.
For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The
declaration order of these members is unspecified. The type of such a data member is the referenced type
if the entity is a reference to an object, an lvalue reference to the referenced function type if the entity
is a reference to a function, or the type of the corresponding captured entity otherwise. A member of an
anonymous union shall not be captured by copy.
§ 7.5.6.3 © ISO/IEC
130

===== PAGE 142 =====

Dxxxx
11 Every id-expression within thecompound-statement of alambda-expression that is an odr-use (6.3) of an entity
captured by copy is transformed into an access to the corresponding unnamed data member of the closure
type.
[Note 7: An id-expression that is not an odr-use refers to the original entity, never to a member of the closure type.
However, such anid-expression can still cause the implicit capture of the entity.—end note]
If *this is captured by copy, each expression that odr-uses*this is transformed to instead refer to the
corresponding unnamed data member of the closure type.
[Example 8:
void f(const int*);
void g() {
const int N = 10;
[=] {
int arr[N]; // OK, not an odr-use, refers to variable with automatic storage duration
f(&N); // OK, causesN to be captured;&N points to
// the corresponding member of the closure type
};
}
—end example]
12 An entity iscaptured by referenceif it is implicitly or explicitly captured but not captured by copy. It is
unspecified whether additional unnamed non-static data members are declared in the closure type for entities
captured by reference. If declared, such non-static data members shall be of literal type.
[Example 9:
// The inner closure type must be a literal type regardless of how reference captures are represented.
static_assert([](int n) { return [&n] { return ++n; }(); }(3) == 4);
—end example]
A bit-field or a member of an anonymous union shall not be captured by reference.
13 An id-expression within the compound-statement of a lambda-expression that is an odr-use of a reference
captured by reference refers to the entity to which the captured reference is bound and not to the captured
reference.
[Note 8: The validity of such captures is determined by the lifetime of the object to which the reference refers, not by
the lifetime of the reference itself.—end note]
[Example 10:
auto h(int &r) {
return [&] {
++r; // Valid afterh returns if the lifetime of the
// object to whichr is bound has not ended
};
}
—end example]
14 If a lambda-expression m2 captures an entity and that entity is captured by an immediately enclosing
lambda-expression m1, thenm2’s capture is transformed as follows:
—(14.1) If m1 captures the entity by copy,m2 captures the corresponding non-static data member ofm1’s closure
type; ifm1 is notmutable, the non-static data member is considered to be const-qualified.
—(14.2) If m1 captures the entity by reference,m2 captures the same entity captured bym1.
[Example 11: The nestedlambda-expressions and invocations below will output123234.
int a = 1, b = 1, c = 1;
auto m1 = [a, &b, &c]() mutable {
auto m2 = [a, b, &c]() mutable {
std::cout << a << b << c;
a = 4; b = 4; c = 4;
};
a = 3; b = 3; c = 3;
m2();
};
§ 7.5.6.3 © ISO/IEC
131

===== PAGE 143 =====

Dxxxx
a = 2; b = 2; c = 2;
m1();
std::cout << a << b << c;
—end example]
15 When thelambda-expression is evaluated, the entities that are captured by copy are used to direct-initialize
each corresponding non-static data member of the resulting closure object, and the non-static data members
corresponding to theinit-captures are initialized as indicated by the correspondinginitializer (which may be
copy- or direct-initialization). (For array members, the array elements are direct-initialized in increasing
subscript order.) These initializations are performed in the (unspecified) order in which the non-static data
members are declared.
[Note 9: This ensures that the destructions will occur in the reverse order of the constructions.—end note]
16 [Note 10: If a non-reference entity is implicitly or explicitly captured by reference, invoking the function call operator
of the correspondinglambda-expression after the lifetime of the entity has ended is likely to result in undefined behavior.
—end note]
17 A simple-capture containing an ellipsis is a pack expansion (13.7.4). Aninit-capture containing an ellipsis is a
pack expansion that declares aninit-capture pack (13.7.4).
[Example 12:
template<class... Args>
void f(Args... args) {
auto lm = [&, args...] { return g(args...); };
lm();
auto lm2 = [...xs=std::move(args)] { return g(xs...); };
lm2();
}
—end example]
7.5.7 Fold expressions [expr.prim.fold]
1 A fold expression performs a fold of a pack (13.7.4) over a binary operator.
fold-expression:
( cast-expression fold-operator... )
( ... fold-operator cast-expression)
( cast-expression fold-operator... fold-operator cast-expression)
fold-operator: one of
+ - * / % ^ & | << >>
+= -= *= /= %= ^= &= |= <<= >>= =
== != < > <= >= && || , .* ->*
2 An expression of the form(... op e) where op is afold-operator is called aunary left fold. An expression
of the form(e op ...) where op is afold-operator is called aunary right fold. Unary left folds and unary
right folds are collectively calledunary folds. In a unary fold, thecast-expression shall contain an unexpanded
pack (13.7.4).
3 An expression of the form(e1 op1 ... op2 e2) where op1 and op2 are fold-operators is called abinary fold.
In a binary fold,op1 and op2 shall be the samefold-operator, and eithere1 shall contain an unexpanded pack
or e2 shall contain an unexpanded pack, but not both. Ife2 contains an unexpanded pack, the expression is
called abinary left fold. If e1 contains an unexpanded pack, the expression is called abinary right fold.
[Example 1:
template<typename ...Args>
bool f(Args ...args) {
return (true && ... && args); // OK
}
template<typename ...Args>
bool f(Args ...args) {
return (args + ... + args); // error: both operands contain unexpanded packs
}
—end example]
§ 7.5.7 © ISO/IEC
132

===== PAGE 144 =====

Dxxxx
4 A fold expression is a pack expansion.
7.5.8 Requires expressions [expr.prim.req]
7.5.8.1 General [expr.prim.req.general]
1 A requires-expression provides a concise way to express requirements on template arguments that can be
checked by name lookup (6.5) or by checking properties of types and expressions.
requires-expression:
requires requirement-parameter-listopt requirement-body
requirement-parameter-list:
( parameter-declaration-clause )
requirement-body:
{ requirement-seq }
requirement-seq:
requirement requirement-seqopt
requirement:
simple-requirement
type-requirement
compound-requirement
nested-requirement
2 A requires-expression is a prvalue of typebool whose value is described below.
3 [Example 1: A common use ofrequires-expressions is to define requirements in concepts such as the one below:
template<typename T>
concept R = requires (T i) {
typename T::type;
{*i} -> std::convertible_to<const typename T::type&>;
};
A requires-expression can also be used in arequires-clause (13.1) as a way of writing ad hoc constraints on template
arguments such as the one below:
template<typename T>
requires requires (T x) { x + x; }
T add(T a, T b) { return a + b; }
The firstrequires introduces therequires-clause, and the second introduces therequires-expression. —end example]
4 A requires-expression may introduce local parameters using aparameter-declaration-clause. A local parameter
of arequires-expression shall not have a default argument. The type of such a parameter is determined as
specified for a function parameter in 9.3.4.6. These parameters have no linkage, storage, or lifetime; they
are only used as notation for the purpose of definingrequirements. The parameter-declaration-clause of a
requirement-parameter-list shall not terminate with an ellipsis.
[Example 2:
template<typename T>
concept C = requires(T t, ...) { // error: terminates with an ellipsis
t;
};
template<typename T>
concept C2 = requires(T p[2]) {
(decltype(p))nullptr; // OK,p has type “pointer toT”
};
—end example]
5 The substitution of template arguments into arequires-expression can result in the formation of invalid
types or expressions in the immediate context of itsrequirements (13.10.3.1) or the violation of the semantic
constraints of thoserequirements. In such cases, therequires-expression evaluates tofalse; it does not cause
the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and
stops when a condition that determines the result of therequires-expression is encountered. If substitution (if
any) and semantic constraint checking succeed, therequires-expression evaluates totrue.
[Note 1: If arequires-expression contains invalid types or expressions in itsrequirements, and it does not appear within
the declaration of a templated entity, then the program is ill-formed.—end note]
§ 7.5.8.1 © ISO/IEC
133

===== PAGE 145 =====

Dxxxx
If the substitution of template arguments into arequirement would always result in a substitution failure, the
program is ill-formed; no diagnostic required.
[Example 3:
template<typename T> concept C =
requires {
new decltype((void)T{}); // ill-formed, no diagnostic required
};
—end example]
7.5.8.2 Simple requirements [expr.prim.req.simple]
simple-requirement:
expression ;
1 A simple-requirement asserts the validity of anexpression. The expression is an unevaluated operand.
[Note 1: The enclosing requires-expression will evaluate tofalse if substitution of template arguments into the
expression fails. —end note]
[Example 1:
template<typename T> concept C =
requires (T a, T b) {
a + b; // C<T> is true if a + b is a valid expression
};
—end example]
2 A requirement that starts with arequires token is never interpreted as asimple-requirement.
[Note 2: This simplifies distinguishing between asimple-requirement and anested-requirement. —end note]
7.5.8.3 Type requirements [expr.prim.req.type]
type-requirement:
typename nested-name-specifieropt type-name ;
typename splice-specifier ;
typename splice-specialization-specifier ;
1 A type-requirement asserts the validity of a type. The component names of atype-requirement are those of its
nested-name-specifier (if any) andtype-name (if any).
[Note 1: The enclosingrequires-expression will evaluate tofalse if substitution of template arguments fails.—end
note]
[Example 1:
template<typename T, typename T::type = 0> struct S;
template<typename T> using Ref = T&;
template<typename T> concept C = requires {
typename T::inner; // required nested member name
typename S<T>; // required valid (13.3)template-id; fails ifT::type does not exist as a type
// to which0 can be implicitly converted
typename Ref<T>; // required alias template substitution, fails ifT is void
typename [:T::r1:]; // fails ifT::r1 is not a reflection of a type
typename [:T::r2:]<int>; // fails ifT::r2 is not a reflection of a templateZ for which Z<int> is a type
};
—end example]
2 A type-requirement that names a class template specialization does not require that type to be complete (6.9.1).
7.5.8.4 Compound requirements [expr.prim.req.compound]
compound-requirement:
{ expression } noexceptopt return-type-requirementopt ;
return-type-requirement:
-> type-constraint
1 A compound-requirement asserts properties of theexpression E. The expression is an unevaluated operand.
Substitution of template arguments (if any) and verification of semantic properties proceed in the following
order:
§ 7.5.8.4 © ISO/IEC
134

===== PAGE 146 =====

Dxxxx
—(1.1) Substitution of template arguments (if any) into theexpression is performed.
—(1.2) If thenoexcept specifier is present,E shall not be a potentially-throwing expression (14.5).
—(1.3) If thereturn-type-requirement is present, then:
—(1.3.1) Substitution of template arguments (if any) into thereturn-type-requirement is performed.
—(1.3.2) The immediately-declared constraint (13.2) of thetype-constraint for decltype((E)) shall be
satisfied.
[Example 1: Given conceptsC and D,
requires {
{ E1 } -> C;
{ E2 } -> D<A1, ···, An>;
};
is equivalent to
requires {
E1; requires C<decltype((E1))>;
E2; requires D<decltype((E2)), A1, ··· , An>;
};
(including in the case wheren is zero). —end example]
[Example 2:
template<typename T> concept C1 = requires(T x) {
{x++};
};
The compound-requirement in C1 requires thatx++ is a valid expression. It is equivalent to thesimple-requirement
x++;.
template<typename T> concept C2 = requires(T x) {
{*x} -> std::same_as<typename T::inner>;
};
The compound-requirement in C2 requires that*x is a valid expression, thattypename T::inner is a valid type, and
that std::same_as<decltype((*x)), typename T::inner> is satisfied.
template<typename T> concept C3 =
requires(T x) {
{g(x)} noexcept;
};
The compound-requirement in C3 requires that g(x) is a valid expression and thatg(x) is non-throwing. —end
example]
7.5.8.5 Nested requirements [expr.prim.req.nested]
nested-requirement:
requires constraint-expression ;
1 A nested-requirement can be used to specify additional constraints in terms of local parameters. The
constraint-expression shall be satisfied (13.5.3) by the substituted template arguments, if any. Substitution of
template arguments into anested-requirement does not result in substitution into theconstraint-expression
other than as specified in 13.5.2.
[Example 1:
template<typename U> concept C = sizeof(U) == 1;
template<typename T> concept D = requires (T t) {
requires C<decltype (+t)>;
};
D<T> is satisfied ifsizeof(decltype (+t)) == 1 (13.5.2.3). —end example]
7.5.9 Expression splicing [expr.prim.splice]
splice-expression:
splice-specifier
template splice-specifier
template splice-specialization-specifier
§ 7.5.9 © ISO/IEC
135

===== PAGE 147 =====

Dxxxx
1 A splice-specifier or splice-specialization-specifier immediately followed by:: or preceded bytypename is never
interpreted as part of asplice-expression.
[Example 1:
struct S { static constexpr int a = 1; };
template<typename> struct TCls { static constexpr int b = 2; };
constexpr int c = [:^^S:]::a; // OK,[:^^S:] is not an expression
constexpr int d = template [:^^TCls:]<int>::b; // OK,template [:^^TCls:]<int> is not an expression
template<auto V> constexpr int e = [:V:]; // OK
constexpr int f = template [:^^e:]<^^S::a>; // OK
constexpr auto g = typename [:^^int:](42); // OK,typename [:^^int:] is asplice-type-specifier
constexpr auto h = ^^g;
constexpr auto i = e<[:^^h:]>; // error: unparenthesizedsplice-expression used as template argument
constexpr auto j = e<([:^^h:])>; // OK
—end example]
2 For asplice-expression of the formsplice-specifier, letS be the construct designated bysplice-specifier.
—(2.1) The expression is ill-formed ifS is
—(2.1.1) a constructor,
—(2.1.2) a destructor,
—(2.1.3) an unnamed bit-field, or
—(2.1.4) a local entity (6.1) such that
—(2.1.4.1) there is a lambda scope that intervenes between the expression and the point at whichS was
introduced and
—(2.1.4.2) the expression would be potentially evaluated if the effect of any enclosingtypeid expressions
(7.6.1.8) were ignored.
—(2.2) Otherwise, ifS is a functionF, the expression denotes an overload set containing all declarations ofF
that precede either the expression or the point immediately following theclass-specifier of the outermost
class for which the expression is in a complete-class context; overload resolution is performed (12.2,
12.3).
—(2.3) Otherwise, ifS is an object or a non-static data member, the expression is an lvalue designatingS.
The expression has the same type as that ofS, and is a bit-field if and only ifS is a bit-field.
[Note 1: The implicit transformation whereby anid-expression denoting a non-static member becomes a class
member access (7.5.5) does not apply to asplice-expression. —end note]
—(2.4) Otherwise, ifS is a direct base class relationship(D,B), the expression is an lvalue designatingS. The
expression has the typeB.
—(2.5) Otherwise, ifS is a variable or a structured binding,S shall either have static or thread storage duration
or shall inhabit a scope enclosing the expression. The expression is an lvalue referring to the object or
function X associated with or referenced byS, has the same type as that ofS, and is a bit-field if and
only ifX is a bit-field.
[Note 2: The type of asplice-expression designating a variable or structured binding of reference type will be
adjusted to a non-reference type (7.2.2).—end note]
—(2.6) Otherwise, ifS is a value or an enumerator, the expression is a prvalue that computesS and whose
type is the same as that ofS.
—(2.7) Otherwise, the expression is ill-formed.
3 For asplice-expression of the formtemplate splice-specifier, thesplice-specifier shall designate a function
template T that is not a constructor template. The expression denotes an overload set containing all
declarations ofT that precede either the expression or the point immediately following theclass-specifier of
the outermost class for which the expression is in a complete-class context; overload resolution is performed.
[Note 3: During overload resolution, candidate function templates undergo template argument deduction and the
resulting specializations are considered as candidate functions.—end note]
§ 7.5.9 © ISO/IEC
136

===== PAGE 148 =====

Dxxxx
4 For asplice-expression of the formtemplate splice-specialization-specifier, thesplice-specifier of thesplice-
specialization-specifier shall designate a templateT.
—(4.1) If T is a function template, the expression denotes an overload set containing all declarations ofT that
precede either the expression or the point immediately following theclass-specifier of the outermost
class for which the expression is in a complete-class context; overload resolution is performed (12.2,
12.3).
—(4.2) Otherwise, ifT is a variable template, letS be the specialization ofT corresponding to the template
argument list of thesplice-specialization-specifier. The expression is an lvalue referring to the object
associated withS and has the same type as that ofS.
—(4.3) Otherwise, the expression is ill-formed.
[Note 4: Class members are accessible from any point when designated bysplice-expressions (11.8.3). A class member
access expression (7.6.1.5) whose right operand is asplice-expression is ill-formed if the left operand (considered as a
pointer) cannot be implicitly converted to a pointer to the designating class of the right operand.—end note]
7.6 Compound expressions [expr.compound]
7.6.1 Postfix expressions [expr.post]
7.6.1.1 General [expr.post.general]
1 Postfix expressions group left-to-right.
postfix-expression:
primary-expression
postfix-expression [ expression-listopt ]
postfix-expression ( expression-listopt )
simple-type-specifier ( expression-listopt )
typename-specifier ( expression-listopt )
simple-type-specifier braced-init-list
typename-specifier braced-init-list
postfix-expression . templateopt id-expression
postfix-expression . splice-expression
postfix-expression -> templateopt id-expression
postfix-expression -> splice-expression
postfix-expression ++
postfix-expression --
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
const_cast < type-id > ( expression )
typeid ( expression )
typeid ( type-id )
expression-list:
initializer-list
2 [Note 1: The > token following thetype-id in adynamic_cast, static_cast, reinterpret_cast, orconst_cast can
be the product of replacing a>> token by two consecutive> tokens (13.3). —end note]
7.6.1.2 Subscripting [expr.sub]
1 A subscript expression is a postfix expression followed by square brackets containing a possibly empty,
comma-separated list ofinitializer-clauses that constitute the arguments to the subscript operator. The
postfix-expression and the initialization of the object parameter (9.3.4.6) of any applicable subscript operator
function (12.4.5) is sequenced before each expression in theexpression-list and also before any default
argument (9.3.4.7). The initialization of a non-object parameter of a subscript operator functionS, including
every associated value computation and side effect, is indeterminately sequenced with respect to that of any
other non-object parameter ofS.
2 With the built-in subscript operator, anexpression-list shall be present, consisting of a singleassignment-
expression. One of the expressions shall be a glvalue of type “array ofT” or a prvalue of type “pointer toT”
and the other shall be a prvalue of unscoped enumeration or integral type. The result is of type “T”. The
type “T” shall be a completely-defined object type.44 The expressionE1[E2] is identical (by definition) to
44) This is true even if the subscript operator is used in the following common idiom:&x[0].
§ 7.6.1.2 © ISO/IEC
137

===== PAGE 149 =====

Dxxxx
*((E1)+(E2)), except that in the case of an array operand, the result is an lvalue if that operand is an lvalue
and an xvalue otherwise.
3 [Note 1: Despite its asymmetric appearance, subscripting is a commutative operation except for sequencing. See 7.6.2
and 7.6.6 for details of* and + and 9.3.4.5 for details of array types.—end note]
7.6.1.3 Function call [expr.call]
1 A function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated
list ofinitializer-clauses which constitute the arguments to the function.
[Note 1: If the postfix expression is a function name, the appropriate function and the validity of the call are
determined according to the rules in 12.2.—end note]
The postfix expression shall have function type or function pointer type. For a call to a non-member function
or to a static member function, the postfix expression shall be either an lvalue that refers to a function (in
which case the function-to-pointer standard conversion (7.3.4) is suppressed on the postfix expression), or a
prvalue of function pointer type.
2 If the selected function is non-virtual, or if theid-expression in the class member access expression is a
qualified-id, that function is called. Otherwise, its final overrider (11.7.3) in the dynamic type of the object
expression is called; such a call is referred to as avirtual function call.
[Note 2: The dynamic type is the type of the object referred to by the current value of the object expression.
11.9.5 describes the behavior of virtual function calls when the object expression refers to an object under construction
or destruction. —end note]
3 [Note 3: If a function name is used, and name lookup (6.5) does not find a declaration of that name, the program is
ill-formed. No function is implicitly declared by such a call.—end note]
4 If the postfix-expression names a destructor or pseudo-destructor (7.5.5.5), the type of the function call
expression isvoid; otherwise, the type of the function call expression is the return type of the statically
chosen function (i.e., ignoring thevirtual keyword), even if the type of the function actually called is
different. If thepostfix-expression names a pseudo-destructor (in which case thepostfix-expression is a possibly-
parenthesized class member access), the function call destroys the object of scalar type denoted by the object
expression of the class member access (7.6.1.5, 6.8.4).
5 A typeTcall is call-compatiblewith a function typeTfunc if Tcall is the same type asTfunc or if the type “pointer
to Tfunc” can be converted to type “pointer toTcall” via a function pointer conversion (7.3.14). Calling
a function through an expression whose function type is not call-compatible with the type of the called
function’s definition results in undefined behavior.
[Note 4: This requirement allows the case when the expression has the type of a potentially-throwing function, but
the called function has a non-throwing exception specification, and the function types are otherwise the same.—end
note]
6 When a function is called, each parameter (9.3.4.6) is initialized (9.5, 11.4.5.3) with its corresponding
argument, and each precondition assertion of the function is evaluated (9.4.1). If the function is an explicit
object member function and there is an implied object argument (12.2.2.2.2), the list of provided arguments is
preceded by the implied object argument for the purposes of this correspondence. If there is no corresponding
argument, the default argument for the parameter is used.
[Example 1:
template<typename ...T> int f(int n = 0, T ...t);
int x = f<int>(); // error: no argument for second function parameter
—end example]
If the function is an implicit object member function, the object expression of the class member access
shall be a glvalue and the implicit object parameter of the function (12.2.2) is initialized with that glvalue,
converted as if by an explicit type conversion (7.6.3).
[Note 5: There is no access or ambiguity checking on this conversion; the access checking and disambiguation are
done as part of the (possibly implicit) class member access operator. See 6.5.2, 11.8.3, and 7.6.1.5.—end note]
When a function is called, the type of any parameter shall not be a class type that is either incomplete or
abstract.
[Note 6: This still allows a parameter to be a pointer or reference to such a type. However, it prevents a passed-by-value
parameter to have an incomplete or abstract class type.—end note]
§ 7.6.1.3 © ISO/IEC
138

===== PAGE 150 =====

Dxxxx
It is implementation-defined whether a parameter is destroyed when the function in which it is defined
exits (8.8.4, 14.3, 7.6.2.4) or at the end of the enclosing full-expression; parameters are always destroyed in
the reverse order of their construction. The initialization and destruction of each parameter occurs within
the context of the full-expression (6.10.1) where the function call appears.
[Example 2: The access (11.8.1) of the constructor, conversion functions, or destructor is checked at the point of call.
If a constructor or destructor for a function parameter throws an exception, anyfunction-try-block (14.1) of the called
function with a handler that can handle the exception is not considered.—end example]
7 The postfix-expression is sequenced before eachexpression in theexpression-list and any default argument.
The initialization of a parameter or, if the implementation introduces any temporary objects to hold the
values of function parameters (6.8.7), the initialization of those temporaries, including every associated value
computation and side effect, is indeterminately sequenced with respect to that of any other parameter. These
evaluations are sequenced before the evaluation of the precondition assertions of the function, which are
evaluated in sequence (9.4.1). For any temporaries introduced to hold the values of function parameters, the
initialization of the parameter objects from those temporaries is indeterminately sequenced with respect to
the evaluation of each precondition assertion.
[Note 7: All side effects of argument evaluations are sequenced before the function is entered (see 6.10.1).—end note]
[Example 3:
void f() {
std::string s = "but I have heard it works even if you don't believe in it";
s.replace(0, 4, "").replace(s.find("even"), 4, "only").replace(s.find(" don't"), 6, "");
assert(s == "I have heard it works only if you believe in it"); // OK
}
—end example]
[Note 8: If an operator function is invoked using operator notation, argument evaluation is sequenced as specified for
the built-in operator; see 12.2.2.3.—end note]
[Example 4:
struct S {
S(int);
};
int operator<<(S, int);
int i, j;
int x = S(i=1) << (i=2);
int y = operator<<(S(j=1), j=2);
After performing the initializations, the value ofi is 2 (see 7.6.7), but it is unspecified whether the value ofj is 1 or
2. —end example]
8 The result of a function call is the result of the possibly-converted operand of thereturn statement (8.8.4)
that transferred control out of the called function (if any), except in a virtual function call if the return type
of the final overrider is different from the return type of the statically chosen function, the value returned
from the final overrider is converted to the return type of the statically chosen function.
9 When the called function exits normally (8.8.4, 7.6.2.4), all postcondition assertions of the function are
evaluated in sequence (9.4.1). If the implementation introduces any temporary objects to hold the result
value as specified in 6.8.7, the evaluation of each postcondition assertion is indeterminately sequenced with
respect to the initialization of any of those temporaries or the result object. These evaluations, in turn, are
sequenced before the destruction of any function parameters.
10 [Note 9: A function can change the values of its non-const parameters, but these changes cannot affect the values of
the arguments except where a parameter is of a reference type (9.3.4.3); if the reference is to a const-qualified type,
const_cast needs to be used to cast away the constness in order to modify the argument’s value. Where a parameter
is ofconst reference type a temporary object is introduced if needed (9.2.9, 5.13, 5.13.5, 9.3.4.5, 6.8.7). In addition, it
is possible to modify the values of non-constant objects through pointer parameters.—end note]
11 A function can be declared to accept fewer arguments (by declaring default arguments (9.3.4.7)) or more
arguments (by using the ellipsis,..., or a function parameter pack (9.3.4.6)) than the number of parameters
in the function definition (9.6).
[Note 10: This implies that, except where the ellipsis (...) or a function parameter pack is used, a parameter is
available for each argument.—end note]
§ 7.6.1.3 © ISO/IEC
139

===== PAGE 151 =====

Dxxxx
12 When there is no parameter for a given argument, the argument is passed in such a way that the receiving
function can obtain the value of the argument by invokingva_arg (17.14).
[Note 11: This paragraph does not apply to arguments passed to a function parameter pack. Function parameter
packs are expanded during template instantiation (13.7.4), thus each such argument has a corresponding parameter
when a function template specialization is actually called.—end note]
The lvalue-to-rvalue (7.3.2), array-to-pointer (7.3.3), and function-to-pointer (7.3.4) standard conversions
are performed on the argument expression. An argument that has typecv std::nullptr_t is converted
to typevoid* (7.3.12). After these conversions, if the argument does not have arithmetic, enumeration,
pointer, pointer-to-member, or class type, the program is ill-formed. Passing a potentially-evaluated argument
of a scoped enumeration type (9.8.1) or of a class type (Clause 11) having an eligible non-trivial copy
constructor (11.4.4, 11.4.5.3), an eligible non-trivial move constructor, or a non-trivial destructor (11.4.7),
with no corresponding parameter, is conditionally-supported with implementation-defined semantics. If the
argument has integral or enumeration type that is subject to the integral promotions (7.3.7), or a floating-point
type that is subject to the floating-point promotion (7.3.8), the value of the argument is converted to the
promoted type before the call. These promotions are referred to as thedefault argument promotions.
13 Recursive calls are permitted, except to themain function (6.10.3.1).
14 A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function
type, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise. If it is a
non-void prvalue, the type of the function call expression shall be complete, except as specified in 9.2.9.6.
7.6.1.4 Explicit type conversion (functional notation) [expr.type.conv]
1 A simple-type-specifier (9.2.9.3) ortypename-specifier (13.8) followed by a parenthesized optionalexpression-list
or by abraced-init-list (the initializer) constructs a value of the specified type given the initializer. If the type
is a placeholder for a deduced class type, it is replaced by the return type of the function selected by overload
resolution for class template deduction (12.2.2.9) for the remainder of this subclause. Otherwise, if the type
contains a placeholder type, it is replaced by the type determined by placeholder type deduction (9.2.9.7.2).
Let T denote the resulting type. Then:
—(1.1) If the initializer is a parenthesized single expression, the type conversion expression is equivalent to the
corresponding cast expression (7.6.3).
—(1.2) Otherwise, if T is cv void, the initializer shall be() or {} (after pack expansion, if any), and the
expression is a prvalue of typevoid that performs no initialization.
—(1.3) Otherwise, ifT is a reference type, the expression has the same effect as direct-initializing an invented
variable t of typeT from the initializer and then usingt as the result of the expression; the result is an
lvalue ifT is an lvalue reference type or an rvalue reference to function type and an xvalue otherwise.
—(1.4) Otherwise, the expression is a prvalue of typeT whose result object is direct-initialized (9.5) with the
initializer.
If the initializer is a parenthesized optionalexpression-list, T shall not be an array type.
[Example 1:
struct A {};
void f(A&); // #1
void f(A&&); // #2
A& g();
void h() {
f(g()); // calls #1
f(A(g())); // calls #2 with a temporary object
f(auto(g())); // calls #2 with a temporary object
}
—end example]
7.6.1.5 Class member access [expr.ref]
1 A postfix expression followed by a dot. or an arrow->, optionally followed by the keywordtemplate, and
then followed by anid-expression or asplice-expression, is a postfix expression.
[Note 1: If the keywordtemplate is used and followed by anid-expression, the unqualified name is considered to refer
to a template (13.3). If asimple-template-id results and is followed by a::, theid-expression is aqualified-id. —end
note]
§ 7.6.1.5 © ISO/IEC
140

===== PAGE 152 =====

Dxxxx
2 For a dot that is followed by an expression that designates a static member or an enumerator, the first
expression is a discarded-value expression (7.2.3); if the expression after the dot designates a non-static data
member (11.4.1) or a direct base class relationship (11.7.1), the first expression shall be a glvalue. A postfix
expression that is followed by an arrow shall be a prvalue having pointer type. The expressionE1->E2 is
converted to the equivalent form(*(E1)).E2; the remainder of 7.6.1.5 will address only the form using a
dot.45
3 The postfix expression before the dot is evaluated;46 the result of that evaluation, together with the
id-expression or splice-expression, determines the result of the entire postfix expression.
4 Abbreviating postfix-expression.id-expression or postfix-expression.splice-expression as E1.E2, E1 is called the
object expression. If the object expression is of scalar type,E2 shall name the pseudo-destructor of that same
type (ignoring cv-qualifications) andE1.E2 is a prvalue of type “function of () returningvoid”.
[Note 2: This value can only be used for a notional function call (7.5.5.5).—end note]
5 Otherwise, the object expression shall be of class type. The class type shall be complete unless the class
member access appears in the definition of that class.
[Note 3: The program is ill-formed if the result differs from that when the class is complete (6.5.2).—end note]
[Note 4: 6.5.5 describes how names are looked up after the. and -> operators. —end note]
6 If E2 is asplice-expression, then letT1 be the type ofE1. E2 shall designate either a member ofT1 or a direct
base class relationship(T1,B).
7 If E2 designates a bit-field,E1.E2 is a bit-field. The type and value category ofE1.E2 are determined as
follows. In the remainder of 7.6.1.5,cq represents eitherconst or the absence ofconst and vq represents
either volatile or the absence ofvolatile. cv represents an arbitrary set of cv-qualifiers, as defined in 6.9.5.
8 If E2 designates an entity that is declared to have type “reference toT”, thenE1.E2 is an lvalue of typeT.
In that case, ifE2 designates a static data member,E1.E2 designates the object or function to which the
reference is bound, otherwiseE1.E2 designates the object or function to which the corresponding reference
member ofE1 is bound. Otherwise, one of the following rules applies.
—(8.1) If E2 designates a static data member and the type ofE2 is T, thenE1.E2 is an lvalue; the expression
designates the named member of the class. The type ofE1.E2 is T.
—(8.2) Otherwise, ifE2 designates a non-static data member and the type ofE1 is “cq1 vq1 X”, and the type
of E2 is “cq2 vq2 T”, the expression designates the corresponding member subobject of the object
designated byE1. If E1 is an lvalue, thenE1.E2 is an lvalue; otherwiseE1.E2 is an xvalue. Let the
notation vq12 stand for the “union” ofvq1 and vq2; that is, ifvq1 or vq2 is volatile, thenvq12 is
volatile. Similarly, let the notationcq12 stand for the “union” ofcq1 and cq2; that is, ifcq1 or cq2
is const, thencq12 is const. If the entity designated byE2 is declared to be amutable member, then
the type ofE1.E2 is “vq12 T”. If the entity designated byE2 is not declared to be amutable member,
then the type ofE1.E2 is “cq12 vq12 T”.
—(8.3) Otherwise, if E2 denotes an overload set, the expression shall be the (possibly-parenthesized) left-hand
operand of a member function call (7.6.1.3), and function overload resolution (12.2) is used to select
the function to whichE2 refers. The type ofE1.E2 is the type ofE2 and E1.E2 refers to the function
referred to byE2.
—(8.3.1) If E2 refers to a static member function,E1.E2 is an lvalue.
—(8.3.2) Otherwise (whenE2 refers to a non-static member function),E1.E2 is a prvalue.
[Note 5: Any redundant set of parentheses surrounding the expression is ignored (7.5.4).—end note]
—(8.4) Otherwise, ifE2 designates a nested type, the expressionE1.E2 is ill-formed.
—(8.5) Otherwise, ifE2 designates a member enumerator and the type ofE2 is T, the expressionE1.E2 is a
prvalue of typeT whose value is the value of the enumerator.
—(8.6) Otherwise, ifE2 designates a direct base class relationship(D,B) and D is either the cv-unqualified
class type ofE1 or a base class thereof, letcv be the cv-qualification of the type ofE1. E1 is implicitly
converted to the type “reference tocv D” (where the reference is an lvalue reference ifE1 is an lvalue
and an rvalue reference otherwise) and the expression designates the direct base class subobject of type
45) Note that(*(E1)) is an lvalue.
46) If the class member access expression is evaluated, the subexpression evaluation happens even if the result is unnecessary to
determine the value of the entire postfix expression, for example if theid-expression denotes a static member.
§ 7.6.1.5 © ISO/IEC
141

===== PAGE 153 =====

Dxxxx
B of the object designated by the convertedE1. If E1 is an lvalue, thenE1.E2 is an lvalue; otherwise,
E1.E2 is an xvalue. The type ofE1.E2 is cv B.
[Example 1:
struct B {
int b;
};
struct C : B {
int get() const { return b; }
};
struct D : B, C { };
constexpr int f() {
D d = {1, {}};
// b unambiguously refers to the direct base class of typeB,
// not the indirect base class of typeB
B& b = d.[: std::meta::bases_of(^^D, std::meta::access_context::current())[0] :];
b.b += 10;
return 10 * b.b + d.get();
}
static_assert(f() == 110);
—end example]
—(8.7) Otherwise, the program is ill-formed.
9 If E2 designates a non-static member (possibly after overload resolution), the program is ill-formed if the
class of whichE2 designates a direct member is an ambiguous base (6.5.2) of the designating class (11.8.3) of
E2.
[Note 6: The program is also ill-formed if the naming class is an ambiguous base of the class type of the object
expression; see 11.8.3. —end note]
10 If E2 designates a non-static member (possibly after overload resolution) or direct base class relationship and
the result ofE1 is an object whose type is not similar (7.3.6) to the type ofE1, the behavior is undefined.
[Example 2:
struct A { int i; };
struct B { int j; };
struct D : A, B {};
void f() {
D d;
static_cast<B&>(d).j; // OK, object expression designates theB subobject of d
reinterpret_cast<B&>(d).j; // undefined behavior
}
—end example]
7.6.1.6 Increment and decrement [expr.post.incr]
1 The value of a postfix++ expression is the value obtained by applying the lvalue-to-rvalue conversion (7.3.2)
to its operand.
[Note 1: The value obtained is a copy of the original value.—end note]
The operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type other than
cv bool, or a pointer to a complete object type. An operand with volatile-qualified type is deprecated; see D.4.
The value of the operand object is modified (3.1) as if it were the operand of the prefix++ operator (7.6.2.3).
The value computation of the++ expression is sequenced before the modification of the operand object. With
respect to an indeterminately-sequenced function call, the operation of postfix++ is a single evaluation.
[Note 2: Therefore, a function call cannot intervene between the lvalue-to-rvalue conversion and the side effect
associated with any single postfix++ operator. —end note]
The result is a prvalue. The type of the result is the cv-unqualified version of the type of the operand.
2 The operand of postfix-- is decremented analogously to the postfix++ operator.
[Note 3: For prefix increment and decrement, see 7.6.2.3.—end note]
§ 7.6.1.6 © ISO/IEC
142

===== PAGE 154 =====

Dxxxx
7.6.1.7 Dynamic cast [expr.dynamic.cast]
1 The result of the expressiondynamic_cast<T>(v) is the result of converting the expressionv to typeT. T
shall be a pointer or reference to a complete class type, or “pointer tocv void”. Thedynamic_cast operator
shall not cast away constness (7.6.1.11).
2 If T is a pointer type,v shall be a prvalue of a pointer to complete class type, and the result is a prvalue of
type T. If T is an lvalue reference type,v shall be an lvalue of a complete class type, and the result is an
lvalue of the type referred to byT. If T is an rvalue reference type,v shall be a glvalue having a complete
class type, and the result is an xvalue of the type referred to byT.
3 If the type ofv is the same asT (ignoring cv-qualifications), the result isv (converted if necessary).
4 If T is “pointer tocv1 B” andv has type “pointer tocv2 D” such thatB is a base class ofD, the result is a
pointer to the uniqueB subobject of theD object pointed to byv, or a null pointer value ifv is a null pointer
value. Similarly, ifT is “reference tocv1 B” andv has typecv2 D such thatB is a base class ofD, the result
is the uniqueB subobject of theD object referred to byv.47 In both the pointer and reference cases, the
program is ill-formed ifB is an inaccessible or ambiguous base class ofD.
[Example 1:
struct B { };
struct D : B { };
void foo(D* dp) {
B* bp = dynamic_cast<B*>(dp); // equivalent toB* bp = dp;
}
—end example]
5 Otherwise, v shall be a pointer to or a glvalue of a polymorphic type (11.7.3).
6 If v is a null pointer value, the result is a null pointer value.
7 If v has type “pointer tocv U” andv does not point to an object whose type is similar (7.3.6) toU and that
is within its lifetime or within its period of construction or destruction (11.9.5), the behavior is undefined. If
v is a glvalue of typeU and v does not refer to an object whose type is similar toU and that is within its
lifetime or within its period of construction or destruction, the behavior is undefined.
8 If T is “pointer tocv void”, then the result is a pointer to the most derived object pointed to byv. Otherwise,
a runtime check is applied to see if the object pointed or referred to byv can be converted to the type pointed
or referred to byT.
9 Let C be the class type to whichT points or refers. The runtime check logically executes as follows:
—(9.1) If, in the most derived object pointed (referred) to byv, v points (refers) to a public base class subobject
of aC object, and if only one object of typeC is derived from the subobject pointed (referred) to byv,
the result points (refers) to thatC object.
—(9.2) Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the type
of the most derived object has a base class, of typeC, that is unambiguous and public, the result points
(refers) to theC subobject of the most derived object.
—(9.3) Otherwise, the runtime checkfails.
10 The value of a failed cast to pointer type is the null pointer value of the required result type. A failed
cast to reference type throws an exception (14.2) of a type that would match a handler (14.4) of type
std::bad_cast (17.7.4).
[Example 2:
class A { virtual void f(); };
class B { virtual void g(); };
class D : public virtual A, private B { };
void g() {
D d;
B* bp = (B*)&d; // cast needed to break protection
A* ap = &d; // public derivation, no cast needed
D& dr = dynamic_cast<D&>(*bp); // fails
ap = dynamic_cast<A*>(bp); // fails
bp = dynamic_cast<B*>(ap); // fails
47) The most derived object (6.8.2) pointed or referred to byv can contain otherB objects as base classes, but these are ignored.
§ 7.6.1.7 © ISO/IEC
143

===== PAGE 155 =====

Dxxxx
ap = dynamic_cast<A*>(&d); // succeeds
bp = dynamic_cast<B*>(&d); // ill-formed (not a runtime check)
}
class E : public D, public B { };
class F : public E, public D { };
void h() {
F f;
A* ap = &f; // succeeds: finds uniqueA
D* dp = dynamic_cast<D*>(ap); // fails: yields null;f has twoD subobjects
E* ep = (E*)ap; // error: cast from virtual base
E* ep1 = dynamic_cast<E*>(ap); // succeeds
}
—end example]
[Note 1: Subclause 11.9.5 describes the behavior of adynamic_cast applied to an object under construction or
destruction. —end note]
7.6.1.8 Type identification [expr.typeid]
1 The result of atypeid expression is an lvalue of static typeconst std::type_info(17.7.3) and dynamic type
const std::type_infoor const name where name is an implementation-defined class publicly derived from
std::type_info which preserves the behavior described in 17.7.3.48 The lifetime of the object referred to by
the lvalue extends to the end of the program. Whether or not the destructor is called for thestd::type_info
object at the end of the program is unspecified.
2 If the type of theexpression or type-id operand is a (possibly cv-qualified) class type or a reference to (possibly
cv-qualified) class type, that class shall be completely defined.
3 If anexpression operand of typeid is a possibly-parenthesizedunary-expression whose unary-operator is * and
whose operand evaluates to a null pointer value (6.9.4), thetypeid expression throws an exception (14.2) of
a type that would match a handler of typestd::bad_typeid (17.7.5).
[Note 1: In other contexts, evaluating such aunary-expression results in undefined behavior (7.6.2.2).—end note]
4 When typeid is applied to a glvalue whose type is a polymorphic class type (11.7.3), the result refers to a
std::type_info object representing the type of the most derived object (6.8.2) (that is, the dynamic type)
to which the glvalue refers.
5 When typeid is applied to an expression other than a glvalue of a polymorphic class type, the result
refers to astd::type_info object representing the static type of the expression. Lvalue-to-rvalue (7.3.2),
array-to-pointer (7.3.3), and function-to-pointer (7.3.4) conversions are not applied to the expression. If the
expression is a prvalue, the temporary materialization conversion (7.3.5) is applied. The expression is an
unevaluated operand (7.2.3).
6 When typeid is applied to atype-id, the result refers to astd::type_info object representing the type of
the type-id. If the type of thetype-id is a reference to a possibly cv-qualified type, the result of thetypeid
expression refers to astd::type_info object representing the cv-unqualified referenced type.
[Note 2: The type-id cannot denote a function type with acv-qualifier-seq or aref-qualifier (9.3.4.6). —end note]
7 If the type of the expression ortype-id is a cv-qualified type, the result of thetypeid expression refers to a
std::type_info object representing the cv-unqualified type.
[Example 1:
class D { /* ... */ };
D d1;
const D d2;
typeid(d1) == typeid(d2); // yieldstrue
typeid(D) == typeid(const D); // yieldstrue
typeid(D) == typeid(d2); // yieldstrue
typeid(D) == typeid(const D&); // yieldstrue
—end example]
48) The recommended name for such a class isextended_type_info.
§ 7.6.1.8 © ISO/IEC
144

===== PAGE 156 =====

Dxxxx
8 The typestd::type_info (17.7.3) is not predefined; if a standard library declaration (17.7.2, 16.4.2.4) of
std::type_info does not precede (6.5.1) atypeid expression, the program is ill-formed.
9 [Note 3: Subclause 11.9.5 describes the behavior oftypeid applied to an object under construction or destruction.
—end note]
7.6.1.9 Static cast [expr.static.cast]
1 The result of the expressionstatic_cast<T>(v) is the result of converting the expressionv to typeT. If T
is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; ifT is an rvalue
reference to object type, the result is an xvalue; otherwise, the result is a prvalue.
2 An lvalue of type “cv1 B”, whereB is a class type, can be cast to type “reference tocv2 D”, whereD is a
complete class derived (11.7) fromB, ifcv2 is the same cv-qualification as, or greater cv-qualification than,
cv1. If B is a virtual base class ofD or a base class of a virtual base class ofD, or if no valid standard
conversion from “pointer toD” to “pointer toB” exists (7.3.12), the program is ill-formed. An xvalue of type
“cv1 B” can be cast to type “rvalue reference tocv2 D” with the same constraints as for an lvalue of type “cv1
B”. If the object of type “cv1 B” is actually a base class subobject of an object of typeD, the result refers to
the enclosing object of typeD. Otherwise, the behavior is undefined.
[Example 1:
struct B { };
struct D : public B { };
D d;
B &br = d;
static_cast<D&>(br); // produces lvalue denoting the originald object
—end example]
3 An lvalue of typeT1 can be cast to type “rvalue reference toT2” ifT2 is reference-compatible withT1 (9.5.4).
If the value is not a bit-field, the result refers to the object or the specified base class subobject thereof;
otherwise, the lvalue-to-rvalue conversion (7.3.2) is applied to the bit-field and the resulting prvalue is used
as the operand of thestatic_cast for the remainder of this subclause. IfT2 is an inaccessible (11.8) or
ambiguous (6.5.2) base class ofT1, a program that necessitates such a cast is ill-formed.
4 Any expression can be explicitly converted to typecv void, in which case the operand is a discarded-value
expression (7.2).
[Note 1: Such astatic_cast has no result as it is a prvalue of typevoid; see 7.2.1. —end note]
[Note 2: However, if the value is in a temporary object (6.8.7), the destructor for that object is not executed until the
usual time, and the value of the object is preserved for the purpose of executing the destructor.—end note]
5 Otherwise, an expression E can be explicitly converted to a type T if there is an implicit conversion
sequence (12.2.4.2) fromE to T, if overload resolution for a direct-initialization (9.5) of an object or reference
of typeT from E would find at least one viable function (12.2.3), or ifT is an aggregate type (9.5.2) having a
first elementx and there is an implicit conversion sequence fromE to the type ofx. If T is a reference type,
the effect is the same as performing the declaration and initialization
T t(E);
for some invented temporary variablet (9.5) and then using the temporary variable as the result of the
conversion. Otherwise, the result object is direct-initialized fromE.
[Note 3: The conversion is ill-formed when attempting to convert an expression of class type to an inaccessible or
ambiguous base class. —end note]
[Note 4: If T is “array of unknown bound ofU”, this direct-initialization defines the type of the expression asU[1].
—end note]
6 Otherwise, the lvalue-to-rvalue (7.3.2), array-to-pointer (7.3.3), and function-to-pointer (7.3.4) conversions
are applied to the operand, and the conversions that can be performed usingstatic_cast are listed below.
No other conversion can be performed usingstatic_cast.
7 A value of a scoped enumeration type (9.8.1) can be explicitly converted to an integral type; the result is the
same as that of converting to the enumeration’s underlying type and then to the destination type. A value of
a scoped enumeration type can also be explicitly converted to a floating-point type; the result is the same as
that of converting from the original value to the floating-point type.
§ 7.6.1.9 © ISO/IEC
145

===== PAGE 157 =====

Dxxxx
8 A value of integral or enumeration type can be explicitly converted to a complete enumeration type. If
the enumeration type has a fixed underlying type, the value is first converted to that type by integral
promotion (7.3.7) or integral conversion (7.3.9), if necessary, and then to the enumeration type. If the
enumeration type does not have a fixed underlying type, the value is unchanged if the original value is
within the range of the enumeration values (9.8.1), and otherwise, the behavior is undefined. A value of
floating-point type can also be explicitly converted to an enumeration type. The resulting value is the same
as converting the original value to the underlying type of the enumeration (7.3.11), and subsequently to the
enumeration type.
9 A prvalue of floating-point type can be explicitly converted to any other floating-point type. If the source value
can be exactly represented in the destination type, the result of the conversion has that exact representation.
If the source value is between two adjacent destination values, the result of the conversion is an implementa-
tion-defined choice of either of those values. Otherwise, the behavior is undefined.
10 A prvalue of type “pointer tocv1 B”, whereB is a class type, can be converted to a prvalue of type “pointer
to cv2 D”, whereD is a complete class derived (11.7) fromB, ifcv2 is the same cv-qualification as, or greater
cv-qualification than,cv1. If B is a virtual base class ofD or a base class of a virtual base class ofD, or if no
valid standard conversion from “pointer toD” to “pointer toB” exists (7.3.12), the program is ill-formed.
The null pointer value (6.9.4) is converted to the null pointer value of the destination type. If the prvalue
of type “pointer tocv1 B” points to aB that is actually a base class subobject of an object of typeD, the
resulting pointer points to the enclosing object of typeD. Otherwise, the behavior is undefined.
11 A prvalue of type “pointer to member ofD of typecv1 T” can be converted to a prvalue of type “pointer to
member ofB of typecv2 T”, whereD is a complete class type andB is a base class (11.7) ofD, ifcv2 is the
same cv-qualification as, or greater cv-qualification than,cv1.
[Note 5: Function types (including those used in pointer-to-member-function types) are never cv-qualified (9.3.4.6).
—end note]
If no valid standard conversion from “pointer to member ofB of typeT” to “pointer to member ofD of type
T” exists (7.3.13), the program is ill-formed. The null member pointer value (7.3.13) is converted to the null
member pointer value of the destination type. If classB contains the original member, or is a base class of
the class containing the original member, the resulting pointer to member points to the original member.
Otherwise, the behavior is undefined.
[Note 6: Although classB need not contain the original member, the dynamic type of the object with which indirection
through the pointer to member is performed must contain the original member; see 7.6.4.—end note]
12 A prvalue of type “pointer tocv1 void” can be converted to a prvalue of type “pointer tocv2 T”, whereT is
an object type andcv2 is the same cv-qualification as, or greater cv-qualification than,cv1. If the original
pointer value represents the addressA of a byte in memory andA does not satisfy the alignment requirement
of T, then the resulting pointer value (6.9.4) is unspecified. Otherwise, if the original pointer value points to
an objecta, and there is an objectb of type similar toT that is pointer-interconvertible (6.9.4) witha, the
result is a pointer tob. Otherwise, the pointer value is unchanged by the conversion.
[Example 2:
T* p1 = new T;
const T* p2 = static_cast<const T*>(static_cast<void*>(p1));
bool b = p1 == p2; // b will have the valuetrue.
—end example]
7.6.1.10 Reinterpret cast [expr.reinterpret.cast]
1 The result of the expressionreinterpret_cast<T>(v) is the result of converting the expressionv to type
T. If T is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; ifT
is an rvalue reference to object type, the result is an xvalue; otherwise, the result is a prvalue and the
lvalue-to-rvalue (7.3.2), array-to-pointer (7.3.3), and function-to-pointer (7.3.4) standard conversions are
performed on the expressionv. Conversions that can be performed explicitly usingreinterpret_cast are
listed below. No other conversion can be performed explicitly usingreinterpret_cast.
2 The reinterpret_cast operator shall not cast away constness (7.6.1.11). An expression of integral, enumer-
ation, pointer, or pointer-to-member type can be explicitly converted to its own type; such a cast yields the
value of its operand.
3 [Note 1: The mapping performed byreinterpret_cast might, or might not, produce a representation different from
the original value.—end note]
§ 7.6.1.10 © ISO/IEC
146

===== PAGE 158 =====

Dxxxx
4 A pointer can be explicitly converted to any integral type large enough to hold all values of its type. The
mapping function is implementation-defined.
[Note 2: It is intended to be unsurprising to those who know the addressing structure of the underlying machine.
—end note]
A value of typestd::nullptr_t can be converted to an integral type; the conversion has the same meaning
and validity as a conversion of(void*)0 to the integral type.
[Note 3: A reinterpret_cast cannot be used to convert a value of any type to the typestd::nullptr_t. —end
note]
5 A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted to
an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type will
have its original value (6.9.4); mappings between pointers and integers are otherwise implementation-defined.
6 A function pointer can be explicitly converted to a function pointer of a different type. The function pointer
value is unchanged by the conversion.
[Note 4: The effect of calling a function through a pointer to a function type (9.3.4.6) that is not call-compatible with
the type used in the definition of the function is undefined (7.6.1.3).—end note]
7 An object pointer can be explicitly converted to an object pointer of a different type.49 When a prvaluev of
object pointer type is converted to the object pointer type “pointer tocv T”, the result isstatic_cast<cv
T*>(static_cast<cv void*>(v)).
[Note 5: Converting a pointer of type “pointer toT1” that points to an object of typeT1 to the type “pointer toT2”
(where T2 is an object type and the alignment requirements ofT2 are no stricter than those ofT1) and back to its
original type yields the original pointer value.—end note]
8 Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning
of such a conversion is implementation-defined, except that if an implementation supports conversions in both
directions, converting a prvalue of one type to the other type and back, possibly with different cv-qualification,
shall yield the original pointer value.
9 The null pointer value (6.9.4) is converted to the null pointer value of the destination type.
[Note 6: A null pointer constant of typestd::nullptr_t cannot be converted to a pointer type, and a null pointer
constant of integral type is not necessarily converted to a null pointer value.—end note]
10 A prvalue of type “pointer to member ofX of typeT1” can be explicitly converted to a prvalue of a different
type “pointer to member ofY of typeT2” ifT1 and T2 are both function types or both object types.50 The
null member pointer value (7.3.13) is converted to the null member pointer value of the destination type.
The result of this conversion is unspecified, except in the following cases:
—(10.1) Converting a prvalue of type “pointer to member function” to a different pointer-to-member-function
type and back to its original type yields the original pointer-to-member value.
—(10.2) Converting a prvalue of type “pointer to data member ofX of typeT1” to the type “pointer to data
member ofY of typeT2” (where the alignment requirements ofT2 are no stricter than those ofT1) and
back to its original type yields the original pointer-to-member value.
11 If v is a glvalue of typeT1, designating an object or functionx, it can be cast to the type “reference to
T2” if an expression of type “pointer toT1” can be explicitly converted to the type “pointer toT2” using a
reinterpret_cast. The result is that of*reinterpret_cast<T2 *>(p) where p is a pointer tox of type
“pointer toT1”.
[Note 7: No temporary is materialized (7.3.5) or created, no copy is made, and no constructors (11.4.5) or conversion
functions (11.4.8) are called.51 —end note]
7.6.1.11 Const cast [expr.const.cast]
1 The result of the expressionconst_cast<T>(v) is of typeT. If T is an lvalue reference to object type,
the result is an lvalue; ifT is an rvalue reference to object type, the result is an xvalue; otherwise, the
result is a prvalue and the lvalue-to-rvalue (7.3.2), array-to-pointer (7.3.3), and function-to-pointer (7.3.4)
standard conversions are performed on the expressionv. The temporary materialization conversion (7.3.5)
49) The types can have differentcv-qualifiers, subject to the overall restriction that areinterpret_cast cannot cast away
constness.
50) T1 and T2 can have differentcv-qualifiers, subject to the overall restriction that areinterpret_cast cannot cast away
constness.
51) This is sometimes referred to as a type pun when the result refers to the same object as the source glvalue.
§ 7.6.1.11 © ISO/IEC
147

===== PAGE 159 =====

Dxxxx
is not performed onv, other than as specified below. Conversions that can be performed explicitly using
const_cast are listed below. No other conversion shall be performed explicitly usingconst_cast.
2 [Note 1: Subject to the restrictions in this subclause, an expression can be cast to its own type using aconst_cast
operator. —end note]
3 For two similar object pointer or pointer to data member typesT1 and T2 (7.3.6), a prvalue of typeT1 can
be explicitly converted to the typeT2 using aconst_cast if, considering the qualification-decompositions of
both types, eachP1
i is the same asP2
i for alli. If v is a null pointer or null member pointer, the result is a
null pointer or null member pointer, respectively. Otherwise, the result points to or past the end of the same
object, or points to the same member, respectively, asv.
4 For two object typesT1 and T2, if a pointer toT1 can be explicitly converted to the type “pointer toT2”
using aconst_cast, then the following conversions can also be made:
—(4.1) an lvalue of typeT1 can be explicitly converted to an lvalue of typeT2 using the castconst_cast<T2&>;
—(4.2) a glvalue of typeT1can be explicitly converted to an xvalue of typeT2using the castconst_cast<T2&&>;
and
—(4.3) if T1 is a class or array type, a prvalue of typeT1 can be explicitly converted to an xvalue of typeT2
using the castconst_cast<T2&&>. The temporary materialization conversion is performed onv.
The result refers to the same object as the (possibly converted) operand.
[Example 1:
typedef int *A[3]; // array of 3 pointer toint
typedef const int *const CA[3]; // array of 3 const pointer toconst int
auto &&r2 = const_cast<A&&>(CA{}); // OK, temporary materialization conversion is performed
—end example]
5 [Note 2: Depending on the type of the object, a write operation through the pointer, lvalue or pointer to data member
resulting from aconst_cast that casts away a const-qualifier52 can produce undefined behavior (9.2.9.2).—end
note]
6 A conversion from a typeT1 to a type T2 casts away constness if T1 and T2 are different, there is a
qualification-decomposition (7.3.6) ofT1 yielding n such thatT2 has a qualification-decomposition of the
form
cv2
0 P2
0 cv2
1 P2
1 ··· cv2
n−1 P2
n−1 cv2
n U2,
and there is no qualification conversion that convertsT1 to
cv2
0 P1
0 cv2
1 P1
1 ··· cv2
n−1 P1
n−1 cv2
n U1.
7 Casting from an lvalue of typeT1 to an lvalue of typeT2 using an lvalue reference cast or casting from an
expression of typeT1 to an xvalue of typeT2 using an rvalue reference cast casts away constness if a cast
from a prvalue of type “pointer toT1” to the type “pointer toT2” casts away constness.
8 [Note 3: Some conversions which involve only changes in cv-qualification cannot be done usingconst_cast. For
instance, conversions between pointers to functions are not covered because such conversions lead to values whose
use causes undefined behavior. For the same reasons, conversions between pointers to member functions, and in
particular, the conversion from a pointer to a const member function to a pointer to a non-const member function,
are not covered.—end note]
7.6.2 Unary expressions [expr.unary]
7.6.2.1 General [expr.unary.general]
1 Expressions with unary operators group right-to-left.
52) const_cast is not limited to conversions that cast away a const-qualifier.
§ 7.6.2.1 © ISO/IEC
148

===== PAGE 160 =====

Dxxxx
unary-expression:
postfix-expression
unary-operator cast-expression
++ cast-expression
-- cast-expression
await-expression
sizeof unary-expression
sizeof ( type-id )
sizeof ... (identifier )
alignof ( type-id )
noexcept-expression
new-expression
delete-expression
reflect-expression
unary-operator: one of
* & + - ! ~
7.6.2.2 Unary operators [expr.unary.op]
1 The unary* operator performsindirection. Its operand shall be a prvalue of type “pointer toT”, whereT is
an object or function type. The operator yields an lvalue of typeT. If the operand points to an object or
function, the result denotes that object or function; otherwise, the behavior is undefined except as specified
in 7.6.1.8.
[Note 1: Indirection through a pointer to an out-of-lifetime object is valid (6.8.4).—end note]
[Note 2: Indirection through a pointer to an incomplete type (other thancv void) is valid. The lvalue thus obtained
can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue,
see 7.3.2. —end note]
2 Each of the following unary operators yields a prvalue.
3 The operand of the unary& operator shall be an lvalue of some typeT.
—(3.1) If the operand is aqualified-id or splice-expression designating a non-static memberm, other than an
explicit object member function,m shall be a direct member of some classC that is not an anonymous
union. The result has type “pointer to member of classC of typeT” and designatesC::m.
[Note 3: A qualified-id that names a member of a namespace-scope anonymous union is considered to be a class
member access expression (7.5.5.1) and cannot be used to form a pointer to member.—end note]
—(3.2) Otherwise, the result has type “pointer toT” and points to the designated object (6.8.1) or function
(6.9.4). If the operand designates an explicit object member function (9.3.4.6), the operand shall be a
qualified-id or asplice-expression.
[Note 4: In particular, taking the address of a variable of type “cv T” yields a pointer of type “pointer tocv T”.
—end note]
[Example 1:
struct A { int i; };
struct B : A { };
... &B::i ... // has typeint A::*
int a;
int* p1 = &a;
int* p2 = p1 + 1; // defined behavior
bool b = p2 > p1; // defined behavior, with valuetrue
—end example]
[Note 5: A pointer to member formed from amutable non-static data member (9.2.2) does not reflect themutable
specifier associated with the non-static data member.—end note]
4 A pointer to member is only formed when an explicit& is used and its operand is aqualified-id or splice-
expression not enclosed in parentheses.
[Note 6: That is, the expression&(qualified-id), where thequalified-id is enclosed in parentheses, does not form an
expression of type “pointer to member”. Neither doesqualified-id, because there is no implicit conversion from a
qualified-id for a non-static member function to the type “pointer to member function” as there is from an lvalue of
function type to the type “pointer to function” (7.3.4). Nor is&unqualified-id a pointer to member, even within
the scope of theunqualified-id’s class. —end note]
§ 7.6.2.2 © ISO/IEC
149

===== PAGE 161 =====

Dxxxx
5 If & is applied to an lvalue of incomplete class type and the complete type declaresoperator&(), it is
unspecified whether the operator has the built-in meaning or the operator function is called. The operand of
& shall not be a bit-field.
6 [Note 7: The address of an overload set (Clause 12) can be taken only in a context that uniquely determines which
function is referred to (see 12.3). Since the context can affect whether the operand is a static or non-static member
function, the context can also affect whether the expression has type “pointer to function” or “pointer to member
function”. —end note]
7 The operand of the unary+ operator shall be a prvalue of arithmetic, unscoped enumeration, or pointer type
and the result is the value of the argument. Integral promotion is performed on integral or enumeration
operands. The type of the result is the type of the promoted operand.
8 The operand of the unary- operator shall be a prvalue of arithmetic or unscoped enumeration type and the
result is the negative of its operand. Integral promotion is performed on integral or enumeration operands.
The negative of an unsigned quantity is computed by subtracting its value from2n, wherenis the number of
bits in the promoted operand. The type of the result is the type of the promoted operand.
[Note 8: The result is the two’s complement of the operand (where operand and result are considered as unsigned).
—end note]
9 The operand of the logical negation operator! is contextually converted tobool (7.3); its value istrue if
the converted operand isfalse and false otherwise. The type of the result isbool.
10 The operand of the ~ operator shall be a prvalue of integral or unscoped enumeration type. Integral
promotions are performed. The type of the result is the type of the promoted operand. Given the coefficients
xi of the base-2 representation (6.9.2) of the promoted operandx, the coefficientri of the base-2 representation
of the resultr is 1 ifxi is 0, and 0 otherwise.
[Note 9: The result is the ones’ complement of the operand (where operand and result are considered as unsigned).
—end note]
There is an ambiguity in the grammar when~ is followed by atype-name or computed-type-specifier. The
ambiguity is resolved by treating~ as the operator rather than as the start of anunqualified-id naming a
destructor.
[Note 10: Because the grammar does not permit an operator to follow the., ->, or:: tokens, a~ followed by a
type-name or computed-type-specifier in a member access expression orqualified-id is unambiguously parsed as a
destructor name. —end note]
7.6.2.3 Increment and decrement [expr.pre.incr]
1 The operand of prefix++ or -- shall not be of typecv bool. An operand with volatile-qualified type is
deprecated; see D.4. The expression++x is otherwise equivalent tox+=1 and the expression--x is otherwise
equivalent tox-=1 (7.6.19).
[Note 1: For postfix increment and decrement, see 7.6.1.6.—end note]
7.6.2.4 Await [expr.await]
1 The co_await expression is used to suspend evaluation of a coroutine (9.6.4) while awaiting completion of
the computation represented by the operand expression. Suspending the evaluation of a coroutine transfers
control to its caller or resumer.
await-expression:
co_await cast-expression
2 An await-expression shall appear only as a potentially-evaluated expression within thecompound-statement of
a function-body or lambda-expression, in either case outside of ahandler (14.1). In adeclaration-statement or in
the simple-declaration (if any) of aninit-statement, anawait-expressionshall appear only in aninitializer of that
declaration-statement or simple-declaration. Anawait-expressionshall not appear in a default argument (9.3.4.7).
An await-expression shall not appear in the initializer of a block variable with static or thread storage
duration. An await-expressionshall not be a potentially-evaluated subexpression of the predicate of a contract
assertion (6.11). A context within a function where anawait-expression can appear is called asuspension
context of the function.
3 Evaluation of anawait-expression involves the following auxiliary types, expressions, and objects:
—(3.1) p is an lvalue naming the promise object (9.6.4) of the enclosing coroutine andP is the type of that
object.
§ 7.6.2.4 © ISO/IEC
150

===== PAGE 162 =====

Dxxxx
—(3.2) Unless the await-expression was implicitly produced by ayield-expression (7.6.17), an initial await
expression, or a final await expression (9.6.4), a search is performed for the nameawait_transform
in the scope ofP (6.5.2). If this search is performed and finds at least one declaration, thena is
p.await_transform(cast-expression); otherwise,a is thecast-expression.
—(3.3) o is determined by enumerating the applicableoperator co_await functions for an argument a
(12.2.2.3), and choosing the best one through overload resolution (12.2). If overload resolution is
ambiguous, the program is ill-formed. If no viable functions are found,o is a. Otherwise, o is a call
to the selected function with the argumenta. If o would be a prvalue, the temporary materialization
conversion (7.3.5) is applied.
—(3.4) e is an lvalue referring to the result of evaluating the (possibly-converted)o.
—(3.5) h is an object of typestd::coroutine_handle<P> referring to the enclosing coroutine.
—(3.6) await-ready is the expressione.await_ready(), contextually converted tobool.
—(3.7) await-suspend is the expressione.await_suspend(h), which shall be a prvalue of typevoid, bool, or
std::coroutine_handle<Z> for some typeZ.
—(3.8) await-resume is the expressione.await_resume().
4 The await-expression has the same type and value category as theawait-resume expression.
5 The await-expression evaluates the (possibly-converted)o expression and theawait-ready expression, then:
—(5.1) If the result ofawait-ready is false, the coroutine is considered suspended. Then:
—(5.1.1) If the type ofawait-suspend is std::coroutine_handle<Z>, await-suspend.resume() is evaluated.
[Note 1: This resumes the coroutine referred to by the result ofawait-suspend. Any number of coroutines
can be successively resumed in this fashion, eventually returning control flow to the current coroutine
caller or resumer (9.6.4).—end note]
—(5.1.2) Otherwise, if the type ofawait-suspend is bool, await-suspend is evaluated, and the coroutine is
resumed if the result isfalse.
—(5.1.3) Otherwise, await-suspend is evaluated.
If the evaluation ofawait-suspend exits via an exception, the exception is caught, the coroutine is
resumed, and the exception is immediately rethrown (14.2). Otherwise, control flow returns to the
current coroutine caller or resumer (9.6.4) without exiting any scopes (8.8). The point in the coroutine
immediately prior to control returning to its caller or resumer is a coroutinesuspend point.
—(5.2) If the result ofawait-ready is true, or when the coroutine is resumed other than by rethrowing an
exception fromawait-suspend, theawait-resume expression is evaluated, and its result is the result of
the await-expression.
[Note 2: With respect to sequencing, anawait-expression is indivisible (6.10.1). —end note]
6 [Example 1:
template <typename T>
struct my_future {
/* ... */
bool await_ready();
void await_suspend(std::coroutine_handle<>);
T await_resume();
};
template <class Rep, class Period>
auto operator co_await(std::chrono::duration<Rep, Period> d) {
struct awaiter {
std::chrono::system_clock::duration duration;
/* ... */
awaiter(std::chrono::system_clock::duration d) : duration(d) {}
bool await_ready() const { return duration.count() <= 0; }
void await_resume() {}
void await_suspend(std::coroutine_handle<> h) { /* ... */ }
};
return awaiter{d};
}
§ 7.6.2.4 © ISO/IEC
151

===== PAGE 163 =====

Dxxxx
using namespace std::chrono;
my_future<int> h();
my_future<void> g() {
std::cout << "just about to go to sleep...\n";
co_await 10ms;
std::cout << "resumed\n";
co_await h();
}
auto f(int x = co_await h()); // error: await-expression outside of function suspension context
int a[] = { co_await h() }; // error: await-expression outside of function suspension context
—end example]
7.6.2.5 Sizeof [expr.sizeof]
1 The sizeof operator yields the number of bytes occupied by a non-potentially-overlapping object of the
type of its operand. The operand is either an expression, which is an unevaluated operand (7.2.3), or a
parenthesized type-id. The sizeof operator shall not be applied to an expression that has function or
incomplete type, to the parenthesized name of such types, or to a glvalue that designates a bit-field. The
result ofsizeof applied to any of the narrow character types is1. The result ofsizeof applied to any other
fundamental type (6.9.2) is implementation-defined.
[Note 1: In particular, the values ofsizeof(bool), sizeof(char16_t), sizeof(char32_t), andsizeof(wchar_t)
are implementation-defined.53 —end note]
[Note 2: See 6.8.1 for the definition of byte and 6.9.1 for the definition of object representation.—end note]
2 When applied to a reference type, the result is the size of the referenced type. When applied to a class, the
result is the number of bytes in an object of that class including any padding required for placing objects of
that type in an array. The result of applyingsizeof to a potentially-overlapping subobject is the size of the
type, not the size of the subobject.54 When applied to an array, the result is the total number of bytes in the
array. This implies that the size of an array ofn elements isn times the size of an element.
3 The lvalue-to-rvalue (7.3.2), array-to-pointer (7.3.3), and function-to-pointer (7.3.4) standard conversions
are not applied to the operand ofsizeof. If the operand is a prvalue, the temporary materialization
conversion (7.3.5) is applied.
4 The identifier in asizeof... expression shall name a pack. Thesizeof... operator yields the number of
elements in the pack (13.7.4). Asizeof... expression is a pack expansion (13.7.4).
[Example 1:
template<class... Types>
struct count {
static constexpr std::size_t value = sizeof...(Types);
};
—end example]
5 The result ofsizeof and sizeof... is a prvalue of typestd::size_t.
[Note 3: A sizeof expression is an integral constant expression (7.7). Thetypedef-name std::size_t is declared in
the standard header<cstddef> (17.2.1, 17.2.4). —end note]
7.6.2.6 Alignof [expr.alignof]
1 An alignof expression yields the alignment requirement of its operand type. The operand shall be atype-id
representing a complete object type, or an array thereof, or a reference to one of those types.
2 The result is a prvalue of typestd::size_t.
[Note 1: An alignof expression is an integral constant expression (7.7). Thetypedef-name std::size_t is declared
in the standard header<cstddef> (17.2.1, 17.2.4). —end note]
3 When alignof is applied to a reference type, the result is the alignment of the referenced type. When
alignof is applied to an array type, the result is the alignment of the element type.
53) sizeof(bool) is not required to be1.
54) The actual size of a potentially-overlapping subobject can be less than the result of applyingsizeof to the subobject, due
to virtual base classes and less strict padding requirements on potentially-overlapping subobjects.
§ 7.6.2.6 © ISO/IEC
152

===== PAGE 164 =====

Dxxxx
7.6.2.7 noexcept operator [expr.unary.noexcept]
noexcept-expression:
noexcept ( expression )
1 The operand of thenoexcept operator is an unevaluated operand (7.2.3). If the operand is a prvalue, the
temporary materialization conversion (7.3.5) is applied.
2 The result of thenoexcept operator is a prvalue of typebool. The result isfalse if the full-expression of
the operand is potentially-throwing (14.5), andtrue otherwise.
[Note 1: A noexcept-expression is an integral constant expression (7.7).—end note]
7.6.2.8 New [expr.new]
1 The new-expression attempts to create an object of thetype-id or new-type-id (9.3.2) to which it is applied.
The type of that object is theallocated type. This type shall be a complete object type (6.9.1), but not an
abstract class type (11.7.4) or array thereof (6.8.2).
[Note 1: Because references are not objects, references cannot be created bynew-expressions. —end note]
[Note 2: Thetype-id can be a cv-qualified type, in which case the object created by thenew-expression has a cv-qualified
type. —end note]
new-expression:
::opt new new-placementopt new-type-id new-initializeropt
::opt new new-placementopt ( type-id ) new-initializeropt
new-placement:
( expression-list )
new-type-id:
type-specifier-seq new-declaratoropt
new-declarator:
ptr-operator new-declaratoropt
noptr-new-declarator
noptr-new-declarator:
[ expressionopt ] attribute-specifier-seqopt
noptr-new-declarator [ constant-expression ] attribute-specifier-seqopt
new-initializer:
( expression-listopt )
braced-init-list
2 If a placeholder type (9.2.9.7) or a placeholder for a deduced class type (9.2.9.8) appears in thetype-specifier-
seq of anew-type-id or type-id of anew-expression, the allocated type is deduced as follows: Letinit be the
new-initializer, if any, andT be thenew-type-id or type-id of thenew-expression, then the allocated type is the
type deduced for the variablex in the invented declaration (9.2.9.7):
T x init ;
[Example 1:
new auto(1); // allocated type isint
auto x = new auto('a'); // allocated type ischar, x is of typechar*
template<class T> struct A { A(T, T); };
auto y = new A{1, 2}; // allocated type isA<int>
—end example]
3 The new-type-id in anew-expression is the longest possible sequence ofnew-declarators.
[Note 3: This prevents ambiguities between the declarator operators&, &&, *, and[] and their expression counterparts.
—end note]
[Example 2:
new int * i; // syntax error: parsed as(new int*) i, not as(new int)*i
The * is the pointer declarator and not the multiplication operator.—end example]
4 [Note 4: Parentheses in anew-type-id of anew-expression can have surprising effects.
[Example 3:
new int(*[10])(); // error
§ 7.6.2.8 © ISO/IEC
153

===== PAGE 165 =====

Dxxxx
is ill-formed because the binding is
(new int) (*[10])(); // error
Instead, the explicitly parenthesized version of thenew operator can be used to create objects of compound types (6.9.4):
new (int (*[10])());
allocates an array of10 pointers to functions (taking no argument and returningint). —end example]
—end note]
5 The attribute-specifier-seq in anoptr-new-declarator appertains to the associated array type.
6 Every constant-expression in anoptr-new-declarator shall be a converted constant expression (7.7) of type
std::size_t and its value shall be greater than zero.
[Example 4: Given the definition int n = 42, new float[n][5] is well-formed (becausen is the expression of a
noptr-new-declarator), butnew float[5][n] is ill-formed (becausen is not a constant expression). Furthermore,new
float[0] is well-formed (because0 is theexpression of anoptr-new-declarator, where a value of zero results in the
allocation of an array with no elements), butnew float[n][0] is ill-formed (because0 is theconstant-expression of a
noptr-new-declarator, where only values greater than zero are allowed).—end example]
7 If thetype-id or new-type-id denotes an array type of unknown bound (9.3.4.5), thenew-initializer shall not be
omitted; the allocated object is an array withn elements, wheren is determined from the number of initial
elements supplied in thenew-initializer (9.5.2, 9.5.3).
8 If theexpression in anoptr-new-declarator is present, it is implicitly converted tostd::size_t. The value of
the expression is invalid if
—(8.1) the expression is of non-class type and its value before converting tostd::size_t is less than zero;
—(8.2) the expression is of class type and its value before application of the second standard conversion
(12.2.4.2.3)55 is less than zero;
—(8.3) its value is such that the size of the allocated object would exceed the implementation-defined limit
(Annex B); or
—(8.4) the new-initializer is abraced-init-list or a parenthesizedexpression-list and the number of array elements
for which initializers are provided (including the terminating’\0’ in astring-literal (5.13.5)) exceeds
the number of elements to initialize.
If the value of theexpression is invalid after converting tostd::size_t:
—(8.5) if theexpression is a potentially-evaluated core constant expression, the program is ill-formed;
—(8.6) otherwise, an allocation function is not called; instead
—(8.6.1) if the allocation function that would have been called has a non-throwing exception specification
(14.5), the value of thenew-expression is the null pointer value of the required result type;
—(8.6.2) otherwise, thenew-expression terminates by throwing an exception of a type that would match a
handler (14.4) of typestd::bad_array_new_length (17.6.4.2).
When the value of theexpression is zero, the allocation function is called to allocate an array with no elements.
9 If the allocated type is an array, thenew-initializer is abraced-init-list or a parenthesizedexpression-list, and the
expression is potentially-evaluated and not a core constant expression, the semantic constraints of initializing
a hypothetical element of the array are checked as follows:
—(9.1) If the new-initializer is a braced-init-list, the hypothetical element is copy-initialized from an empty
initializer list (9.5.5).
—(9.2) Otherwise, the hypothetical element is value-initialized (9.5.1).
[Note 5: The array can contain more elements than there are elements in thenew-initializer, requiring initialization of
the remainder of the array elements as appropriate.—end note]
10 Objects created by anew-expression have dynamic storage duration (6.8.6.5).
[Note 6: The lifetime of such an object is not necessarily restricted to the scope in which it is created.—end note]
11 When the allocated type is “array ofN T” (that is, thenoptr-new-declarator syntax is used or thenew-type-id
or type-id denotes an array type), thenew-expression yields a prvalue of type “pointer toT” that points to the
55) If the conversion function returns a signed integer type, the second standard conversion converts to the unsigned type
std::size_t and thus thwarts any attempt to detect a negative value afterwards.
§ 7.6.2.8 © ISO/IEC
154

===== PAGE 166 =====

Dxxxx
initial element (if any) of the array. Otherwise, letT be the allocated type; thenew-expression is a prvalue of
type “pointer to T” that points to the object created.
[Note 7: Both new int and new int[10] have typeint* and the type ofnew int[i][10] is int (*)[10]. —end
note]
12 A new-expression may obtain storage for the object by calling an allocation function (6.8.6.5.2). If the
new-expression terminates by throwing an exception, it may release storage by calling a deallocation function
(6.8.6.5.3). If the allocated type is a non-array type, the allocation function’s name isoperator new and
the deallocation function’s name isoperator delete. If the allocated type is an array type, the allocation
function’s name isoperator new[] and the deallocation function’s name isoperator delete[].
[Note 8: An implementation is expected to provide default definitions for the global allocation functions (6.8.6.5,
17.6.3.2, 17.6.3.3). A C++ program can provide alternative definitions of these functions (16.4.5.6) and/or class-specific
versions (11.4.11). The set of allocation and deallocation functions that can be called by anew-expression can include
functions that do not perform allocation or deallocation; for example, see 17.6.3.4.—end note]
13 If thenew-expression does not begin with a unary:: operator and the allocated type is a class typeT or
array thereof, a search is performed for the allocation function’s name in the scope ofT (6.5.2). Otherwise,
or if nothing is found, the allocation function’s name is looked up by searching for it in the global scope.
14 An implementation is allowed to omit a call to a replaceable global allocation function (17.6.3.2, 17.6.3.3).
When it does so, the storage is instead provided by the implementation or provided by extending the allocation
of anothernew-expression.
15 During an evaluation of a constant expression, a call to a replaceable allocation function is always omitted (7.7).
16 The implementation may extend the allocation of anew-expression e1 to provide storage for anew-expression
e2 if the following would be true were the allocation not extended:
—(16.1) the evaluation ofe1 is sequenced before the evaluation ofe2, and
—(16.2) e2 is evaluated whenevere1 obtains storage, and
—(16.3) both e1 and e2 invoke the same replaceable global allocation function, and
—(16.4) if the allocation function invoked bye1 and e2 is throwing, any exceptions thrown in the evaluation of
either e1 or e2 would be first caught in the same handler, and
—(16.5) the pointer values produced bye1 and e2 are operands to evaluateddelete-expressions, and
—(16.6) the evaluation ofe2 is sequenced before the evaluation of thedelete-expression whose operand is the
pointer value produced bye1.
[Example 5:
void can_merge(int x) {
// These allocations are safe for merging:
std::unique_ptr<char[]> a{new (std::nothrow) char[8]};
std::unique_ptr<char[]> b{new (std::nothrow) char[8]};
std::unique_ptr<char[]> c{new (std::nothrow) char[x]};
g(a.get(), b.get(), c.get());
}
void cannot_merge(int x) {
std::unique_ptr<char[]> a{new char[8]};
try {
// Merging this allocation would change its catch handler.
std::unique_ptr<char[]> b{new char[x]};
} catch (const std::bad_alloc& e) {
std::cerr << "Allocation failed: " << e.what() << std::endl;
throw;
}
}
—end example]
17 When a new-expression calls an allocation function and that allocation has not been extended, thenew-
expression passes the amount of space requested to the allocation function as the first argument of type
std::size_t. That argument shall be no less than the size of the object being created; it may be greater
than the size of the object being created only if the object is an array and the allocation function is not a
§ 7.6.2.8 © ISO/IEC
155

===== PAGE 167 =====

Dxxxx
non-allocating form (17.6.3.4). For arrays ofchar, unsigned char, andstd::byte, the difference between
the result of thenew-expression and the address returned by the allocation function shall be an integral
multiple of the strictest fundamental alignment requirement (6.8.3) of any object type whose size is no greater
than the size of the array being created.
[Note 9: Because allocation functions are assumed to return pointers to storage that is appropriately aligned for
objects of any type with fundamental alignment, this constraint on array allocation overhead permits the common
idiom of allocating character arrays into which objects of other types will later be placed.—end note]
18 When anew-expression calls an allocation function and that allocation has been extended, the size argument
to the allocation call shall be no greater than the sum of the sizes for the omitted calls as specified above,
plus the size for the extended call had it not been extended, plus any padding necessary to align the allocated
objects within the allocated memory.
19 The new-placement syntax is used to supply additional arguments to an allocation function; such an expression
is called aplacement new-expression.
20 Overload resolution is performed on a function call created by assembling an argument list. The first
argument is the amount of space requested, and has typestd::size_t. If the type of the allocated object
has new-extended alignment, the next argument is the type’s alignment, and has typestd::align_val_t. If
the new-placement syntax is used, theinitializer-clauses in itsexpression-list are the succeeding arguments. If
no matching function is found then
—(20.1) if the allocated object type has new-extended alignment, the alignment argument is removed from the
argument list;
—(20.2) otherwise, an argument that is the type’s alignment and has typestd::align_val_t is added into the
argument list immediately after the first argument;
and then overload resolution is performed again.
21 [Example 6:
—(21.1) new T results in one of the following calls:
operator new(sizeof(T))
operator new(sizeof(T), std::align_val_t(alignof(T)))
—(21.2) new(2,f) T results in one of the following calls:
operator new(sizeof(T), 2, f)
operator new(sizeof(T), std::align_val_t(alignof(T)), 2, f)
—(21.3) new T[5] results in one of the following calls:
operator new[](sizeof(T) * 5 + x)
operator new[](sizeof(T) * 5 + x, std::align_val_t(alignof(T)))
—(21.4) new(2,f) T[5] results in one of the following calls:
operator new[](sizeof(T) * 5 + x, 2, f)
operator new[](sizeof(T) * 5 + x, std::align_val_t(alignof(T)), 2, f)
Here, each instance ofx is a non-negative unspecified value representing array allocation overhead; the result of
the new-expression will be offset by this amount from the value returned byoperator new[]. This overhead may
be applied in all arraynew-expressions, including those referencing a placement allocation function, except when
referencing the library functionoperator new[](std::size_t, void*). The amount of overhead may vary from one
invocation ofnew to another. —end example]
22 [Note 10: Unless an allocation function has a non-throwing exception specification (14.5), it indicates failure to
allocate storage by throwing astd::bad_alloc exception (6.8.6.5.2, Clause 14, 17.6.4.1); it returns a non-null pointer
otherwise. If the allocation function has a non-throwing exception specification, it returns null to indicate failure to
allocate storage and a non-null pointer otherwise.—end note]
If the allocation function is a non-allocating form (17.6.3.4) that returns null, the behavior is undefined.
Otherwise, if the allocation function returns null, initialization shall not be done, the deallocation function
shall not be called, and the value of thenew-expression shall be null.
23 [Note 11: When the allocation function returns a value other than null, it must be a pointer to a block of storage in
which space for the object has been reserved. The block of storage is assumed to be appropriately aligned (6.8.3) and
of the requested size. The address of the created object will not necessarily be the same as that of the block if the
object is an array.—end note]
24 A new-expression that creates an object of typeT initializes that object as follows:
§ 7.6.2.8 © ISO/IEC
156

===== PAGE 168 =====

Dxxxx
—(24.1) If thenew-initializer is omitted, the object is default-initialized (9.5).
[Note 12: If no initialization is performed, the object has an indeterminate value.—end note]
—(24.2) Otherwise, the new-initializer is interpreted according to the initialization rules of 9.5 for direct-
initialization.
25 The invocation of the allocation function is sequenced before the evaluations of expressions in thenew-initializer.
Initialization of the allocated object is sequenced before the value computation of thenew-expression.
26 If thenew-expression creates an array of objects of class type, the destructor is potentially invoked (11.4.7).
27 If any part of the object initialization described above56 terminates by throwing an exception and a suitable
deallocation function can be found, the deallocation function is called to free the memory in which the object
was being constructed, after which the exception continues to propagate in the context of thenew-expression.
If no unambiguous matching deallocation function can be found, propagating the exception does not cause
the object’s memory to be freed.
[Note 13: This is appropriate when the called allocation function does not allocate memory; otherwise, it is likely to
result in a memory leak.—end note]
28 If thenew-expression does not begin with a unary:: operator and the allocated type is a class typeT or an
array thereof, a search is performed for the deallocation function’s name in the scope ofT. Otherwise, or if
nothing is found, the deallocation function’s name is looked up by searching for it in the global scope.
29 A declaration of a placement deallocation function matches the declaration of a placement allocation function
if it has the same number of parameters and, after parameter transformations (9.3.4.6), all parameter types
except the first are identical. If the lookup finds a single matching deallocation function, that function
will be called; otherwise, no deallocation function will be called. If the lookup finds a usual deallocation
function and that function, considered as a placement deallocation function, would have been selected as a
match for the allocation function, the program is ill-formed. For a non-placement allocation function, the
normal deallocation function lookup is used to find the matching deallocation function (7.6.2.9). In any case,
the matching deallocation function (if any) shall be non-deleted and accessible from the point where the
new-expression appears.
[Example 7:
struct S {
// Placement allocation function:
static void* operator new(std::size_t, std::size_t);
// Usual (non-placement) deallocation function:
static void operator delete(void*, std::size_t);
};
S* p = new (0) S; // error: non-placement deallocation function matches
// placement allocation function
—end example]
30 If anew-expression calls a deallocation function, it passes the value returned from the allocation function
call as the first argument of typevoid*. If a placement deallocation function is called, it is passed the same
additional arguments as were passed to the placement allocation function, that is, the same arguments as
those specified with thenew-placement syntax. If the implementation is allowed to introduce a temporary
object or make a copy of any argument as part of the call to the allocation function, it is unspecified whether
the same object is used in the call to both the allocation and deallocation functions.
7.6.2.9 Delete [expr.delete]
1 The delete-expression operator destroys a most derived object (6.8.2) or array created by anew-expression.
delete-expression:
::opt delete cast-expression
::opt delete [ ]cast-expression
The first alternative is asingle-object delete expression, and the second is anarray delete expression. Whenever
the delete keyword is immediately followed by empty square brackets, it shall be interpreted as the second
56) This can include evaluating anew-initializer and/or calling a constructor.
§ 7.6.2.9 © ISO/IEC
157

===== PAGE 169 =====

Dxxxx
alternative.57 If the operand is of class type, it is contextually implicitly converted (7.3) to a pointer to
object type and the converted operand is used in place of the original operand for the remainder of this
subclause. Otherwise, it shall be a prvalue of pointer to object type. Thedelete-expression has typevoid.
2 In a single-object delete expression, the value of the operand ofdelete may be a null pointer value, a pointer
value that resulted from a previous non-arraynew-expression, or a pointer to a base class subobject of an
object created by such anew-expression. If not, the behavior is undefined. In an array delete expression, the
value of the operand ofdelete may be a null pointer value or a pointer value that resulted from a previous
array new-expression whose allocation function was not a non-allocating form (17.6.3.4).58 If not, the behavior
is undefined.
[Note 1: This means that the syntax of thedelete-expression must match the type of the object allocated bynew, not
the syntax of thenew-expression. —end note]
[Note 2: A pointer to aconst type can be the operand of adelete-expression; it is not necessary to cast away the
constness (7.6.1.11) of the pointer expression before it is used as the operand of thedelete-expression. —end note]
3 In a single-object delete expression, if the static type of the object to be deleted is not similar (7.3.6) to its
dynamic type and the selected deallocation function (see below) is not a destroying operator delete, the static
type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a
virtual destructor or the behavior is undefined. In an array delete expression, if the dynamic type of the
object to be deleted is not similar to its static type, the behavior is undefined.
4 If the object being deleted has incomplete class type at the point of deletion, the program is ill-formed.
5 If the value of the operand of thedelete-expression is not a null pointer value and the selected deallocation
function (see below) is not a destroying operator delete, evaluating thedelete-expression invokes the destructor
(if any) for the object or the elements of the array being deleted. The destructor shall be accessible from the
point where thedelete-expression appears. In the case of an array, the elements are destroyed in order of
decreasing address (that is, in reverse order of the completion of their constructor; see 11.9.3).
6 If the value of the operand of thedelete-expression is not a null pointer value, then:
—(6.1) If the allocation call for thenew-expression for the object to be deleted was not omitted and the
allocation was not extended (7.6.2.8), thedelete-expression shall call a deallocation function (6.8.6.5.3).
The value returned from the allocation call of thenew-expression shall be passed as the first argument
to the deallocation function.
—(6.2) Otherwise, if the allocation was extended or was provided by extending the allocation of another
new-expression, and thedelete-expression for every other pointer value produced by anew-expression that
had storage provided by the extendednew-expression has been evaluated, thedelete-expression shall call
a deallocation function. The value returned from the allocation call of the extendednew-expression
shall be passed as the first argument to the deallocation function.
—(6.3) Otherwise, thedelete-expression will not call a deallocation function.
[Note 3: The deallocation function is called regardless of whether the destructor for the object or some element of the
array throws an exception.—end note]
If the value of the operand of thedelete-expression is a null pointer value, it is unspecified whether a
deallocation function will be called as described above.
7 If a deallocation function is called, it isoperator delete for a single-object delete expression oroperator
delete[] for an array delete expression.
[Note 4: An implementation provides default definitions of the global deallocation functions (17.6.3.2, 17.6.3.3). A
C++ program can provide alternative definitions of these functions (16.4.5.6), and/or class-specific versions (11.4.11).
—end note]
8 If the keyworddelete in adelete-expression is not preceded by the unary:: operator and the type of the
operand is a pointer to a (possibly cv-qualified) class typeT or (possibly multidimensional) array thereof:
—(8.1) For a single-object delete expression, if the operand is a pointer tocv T and T has a virtual destructor,
the deallocation function is the one selected at the point of definition of the dynamic type’s virtual
destructor (11.4.7).
57) A lambda-expression with alambda-introducer that consists of empty square brackets can follow thedelete keyword if the
lambda-expression is enclosed in parentheses.
58) For nonzero-length arrays, this is the same as a pointer to the first element of the array created by thatnew-expression.
Zero-length arrays do not have a first element.
§ 7.6.2.9 © ISO/IEC
158

===== PAGE 170 =====

Dxxxx
—(8.2) Otherwise, a search is performed for the deallocation function’s name in the scope ofT.
Otherwise, or if nothing is found, the deallocation function’s name is looked up by searching for it in the
global scope. In any case, any declarations other than of usual deallocation functions (6.8.6.5.3) are discarded.
[Note 5: If only a placement deallocation function is found in a class, the program is ill-formed because the lookup set
is empty (6.5). —end note]
9 The deallocation function to be called is selected as follows:
—(9.1) If any of the deallocation functions is a destroying operator delete, all deallocation functions that are
not destroying operator deletes are eliminated from further consideration.
—(9.2) If the type has new-extended alignment, a function with a parameter of typestd::align_val_t is
preferred; otherwise a function without such a parameter is preferred. If any preferred functions are
found, all non-preferred functions are eliminated from further consideration.
—(9.3) If exactly one function remains, that function is selected and the selection process terminates.
—(9.4) If the deallocation functions belong to a class scope, the one without a parameter of typestd::size_t
is selected.
—(9.5) If the type is complete and if, for an array delete expression only, the operand is a pointer to a class
type with a non-trivial destructor or a (possibly multidimensional) array thereof, the function with a
parameter of typestd::size_t is selected.
—(9.6) Otherwise, it is unspecified whether a deallocation function with a parameter of typestd::size_t is
selected.
Unless the deallocation function is selected at the point of definition of the dynamic type’s virtual destructor,
the selected deallocation function shall be accessible from the point where thedelete-expression appears.
10 For a single-object delete expression, the deleted object is the objectApointed to by the operand if the static
type ofA does not have a virtual destructor, and the most-derived object ofA otherwise.
[Note 6: If the deallocation function is not a destroying operator delete and the deleted object is not the most derived
object in the former case, the behavior is undefined, as stated above.—end note]
For an array delete expression, the deleted object is the array object. When adelete-expression is executed, the
selected deallocation function shall be called with the address of the deleted object in a single-object delete
expression, or the address of the deleted object suitably adjusted for the array allocation overhead (7.6.2.8)
in an array delete expression, as its first argument.
[Note 7: Any cv-qualifiers in the type of the deleted object are ignored when forming this argument.—end note]
If a destroying operator delete is used, an unspecified value is passed as the argument corresponding to
the parameter of typestd::destroying_delete_t. If a deallocation function with a parameter of type
std::align_val_t is used, the alignment of the type of the deleted object is passed as the corresponding
argument. If a deallocation function with a parameter of typestd::size_t is used, the size of the deleted
object in a single-object delete expression, or of the array plus allocation overhead in an array delete expression,
is passed as the corresponding argument.
[Note 8: If this results in a call to a replaceable deallocation function, and either the first argument was not the
result of a prior call to a replaceable allocation function or the second or third argument was not the corresponding
argument in said call, the behavior is undefined (17.6.3.2, 17.6.3.3).—end note]
7.6.2.10 The reflection operator [expr.reflect]
reflect-expression:
^^ ::
^^ reflection-name
^^ type-id
^^ id-expression
reflection-name:
nested-name-specifieropt identifier
nested-name-specifier template identifier
1 The unary^^ operator, called thereflection operator, yields a prvalue of typestd::meta::info (6.9.2).
[Note 1: This document places no restriction on representing, by reflections, constructs not described by this document
or using the names of such constructs as operands ofreflect-expressions. —end note]
§ 7.6.2.10 © ISO/IEC
159

===== PAGE 171 =====

Dxxxx
2 The component names of areflection-name are those of itsnested-name-specifier (if any) and itsidentifier.
The terminal name of areflection-name of the formnested-name-specifier template identifier shall denote a
template.
3 A reflect-expression is parsed as the longest possible sequence of tokens that could syntactically form a
reflect-expression. An unparenthesizedreflect-expression that represents a template shall not be followed by<.
[Example 1:
static_assert(std::meta::is_type(^^int())); // ^^ applies to the type-idint()
template<bool> struct X {};
consteval bool operator<(std::meta::info, X<false>) { return false; }
consteval void g(std::meta::info r, X<false> xv) {
r == ^^int && true; // error: ^^ applies to thetype-id int&&
r == ^^int & true; // error: ^^ applies to the type-idint&
r == (^^int) && true; // OK
r == ^^int &&&& true; // error: int &&&& is not a validtype-id
^^X < xv; // error:reflect-expression that represents a template is followed by<
(^^X) < xv; // OK
^^X<true> < xv; // OK
}
—end example]
4 A reflect-expression of the form^^:: represents the global namespace.
5 If areflect-expression R matches the form^^reflection-name, it is interpreted as such; theidentifier is looked
up and the representation ofR is determined as follows:
—(5.1) If lookup finds a declaration that replaced ausing-declarator during a single search (6.5.1, 9.10),R is
ill-formed.
[Example 2:
struct A { struct S {}; };
struct B : A { using A::S; };
constexpr std::meta::info r1 = ^^B::S; // error: A::S found throughusing-declarator
struct C : virtual B { struct S {}; };
struct D : virtual B, C {};
D::S s; // OK, namesC::S per 6.5.2
constexpr std::meta::info r2 = ^^D::S; // OK, resultC::S not found throughusing-declarator
—end example]
—(5.2) Otherwise, if lookup finds a namespace alias (9.9.3),R represents that namespace alias.
—(5.3) Otherwise, if lookup finds a namespace (9.9),R represents that namespace.
—(5.4) Otherwise, if lookup finds a concept (13.7.9),R represents the denoted concept.
—(5.5) Otherwise, if lookup finds a template (13.3), the representation ofR is determined as follows:
—(5.5.1) If lookup finds an injected-class-name (11.1), then:
—(5.5.1.1) If thereflection-name is of the formnested-name-specifier template identifier, thenR repre-
sents the class template named by the injected-class-name.
—(5.5.1.2) Otherwise, the injected-class-name shall be unambiguous when considered as atype-name and
R represents the class template specialization so named.
—(5.5.2) Otherwise, if lookup finds an overload set, that overload set shall contain only declarations of a
unique function template F;R represents F.
—(5.5.3) Otherwise, if lookup finds a class template, variable template, or alias template,R represents that
template.
[Note 2: Lookup never finds a partial or explicit specialization.—end note]
—(5.6) Otherwise, if lookup finds a type aliasA, R represents the underlying entity ofA if A was introduced
by the declaration of a template parameter; otherwise,R represents A.
—(5.7) Otherwise, if lookup finds a class or an enumeration,R represents the denoted type.
§ 7.6.2.10 © ISO/IEC
160

===== PAGE 172 =====

Dxxxx
—(5.8) Otherwise, if lookup finds a class member of an anonymous union (11.5.2),R represents that class
member.
—(5.9) Otherwise, thereflection-name shall be anid-expression I and R is ^^I (see below).
6 A reflect-expression R of the form^^type-id represents an entity determined as follows:
—(6.1) If thetype-id designates a placeholder type (9.2.9.7.1),R is ill-formed.
—(6.2) Otherwise, if thetype-id is of the formnested-name-specifieropt templateopt simple-template-id and
whose terminal name is atemplate-name that names an alias template (13.7.8),R represents the type
alias so named.
—(6.3) Otherwise, R represents the type denoted by thetype-id.
7 A reflect-expression R of the form^^id-expression represents an entity determined as follows:
—(7.1) If theid-expression denotes
—(7.1.1) a variable declared by aninit-capture (7.5.6.3),
—(7.1.2) a function-local predefined variable (9.6.1),
—(7.1.3) a local parameter introduced by arequires-expression (7.5.8), or
—(7.1.4) a local entityE (6.1) for which a lambda scope intervenes between the point at whichE was
introduced andR,
then R is ill-formed.
—(7.2) Otherwise, if theid-expression denotes an overload setS, overload resolution for the expression&S with
no target shall select a unique function (12.3);R represents that function.
—(7.3) Otherwise, if theid-expression denotes a variable, structured binding, enumerator, or non-static data
member, R represents that entity.
—(7.4) Otherwise, R is ill-formed.
[Note 3: This includesunqualified-ids that name a constant template parameter andpack-index-expressions.
—end note]
The id-expression of areflect-expression is an unevaluated operand (7.2.3).
[Example 3:
template<typename T> void fn() requires (^^T != ^^int);
template<typename T> void fn() requires (^^T == ^^int);
template<typename T> void fn() requires (sizeof(T) == sizeof(int));
constexpr std::meta::info a = ^^fn<char>; // OK
constexpr std::meta::info b = ^^fn<int>; // error: ambiguous
constexpr std::meta::info c = ^^std::vector; // OK
template<typename T>
struct S {
static constexpr std::meta::info r = ^^T;
using type = T;
};
static_assert(S<int>::r == ^^int);
static_assert(^^S<int>::type != ^^int);
typedef struct X {} Y;
typedef struct Z {} Z;
constexpr std::meta::info e = ^^Y; // OK, represents the type aliasY
constexpr std::meta::info f = ^^Z; // OK, represents the type aliasZ, not the type (6.5.1)
—end example]
7.6.3 Explicit type conversion (cast notation) [expr.cast]
1 The result of the expression(T) cast-expression is of typeT. The result is an lvalue ifT is an lvalue reference
type or an rvalue reference to function type and an xvalue ifT is an rvalue reference to object type; otherwise
the result is a prvalue.
§ 7.6.3 © ISO/IEC
161

===== PAGE 173 =====

Dxxxx
[Note 1: If T is a non-class type that is cv-qualified, thecv-qualifiers are discarded when determining the type of the
resulting prvalue; see 7.2.—end note]
2 An explicit type conversion can be expressed using functional notation (7.6.1.4), a type conversion operator
(dynamic_cast, static_cast, reinterpret_cast, const_cast), or thecast notation.
cast-expression:
unary-expression
( type-id ) cast-expression
3 Any type conversion not mentioned below and not explicitly defined by the user (11.4.8) is ill-formed.
4 The conversions performed by
—(4.1) a const_cast (7.6.1.11),
—(4.2) a static_cast (7.6.1.9),
—(4.3) a static_cast followed by aconst_cast,
—(4.4) a reinterpret_cast (7.6.1.10), or
—(4.5) a reinterpret_cast followed by aconst_cast,
can be performed using the cast notation of explicit type conversion. The same semantic restrictions
and behaviors apply, with the exception that in performing astatic_cast in the following situations the
conversion is valid even if the base class is inaccessible:
—(4.6) a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly
converted to a pointer or reference to an unambiguous base class type, respectively;
—(4.7) a pointer to member of derived class type may be explicitly converted to a pointer to member of an
unambiguous non-virtual base class type;
—(4.8) a pointer to an object of an unambiguous non-virtual base class type, a glvalue of an unambiguous
non-virtual base class type, or a pointer to member of an unambiguous non-virtual base class type
may be explicitly converted to a pointer, a reference, or a pointer to member of a derived class type,
respectively.
If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears
first in the list is used, even if a cast resulting from that interpretation is ill-formed. If astatic_cast
followed by aconst_cast is used and the conversion can be interpreted in more than one way as such, the
conversion is ill-formed.
[Example 1:
struct A { };
struct I1 : A { };
struct I2 : A { };
struct D : I1, I2 { };
A* foo( D* p ) {
return (A*)( p ); // ill-formed static_cast interpretation
}
int*** ptr = 0;
auto t = (int const*const*const*)ptr; // OK,const_cast interpretation
struct S {
operator const int*();
operator volatile int*();
};
int *p = (int*)S(); // error: two possible interpretations usingstatic_cast followed by const_cast
—end example]
5 The operand of a cast using the cast notation can be a prvalue of type “pointer to incomplete class type”.
The destination type of a cast using the cast notation can be “pointer to incomplete class type”. If both the
operand and destination types are class types and one or both are incomplete, it is unspecified whether the
static_cast or thereinterpret_cast interpretation is used, even if there is an inheritance relationship
between the two classes.
§ 7.6.3 © ISO/IEC
162

===== PAGE 174 =====

Dxxxx
[Note 2: For example, if the classes were defined later in the translation unit, a multi-pass compiler could validly
interpret a cast between pointers to the classes as if the class types were complete at the point of the cast.—end
note]
7.6.4 Pointer-to-member operators [expr.mptr.oper]
1 The pointer-to-member operators->* and .* group left-to-right.
pm-expression:
cast-expression
pm-expression .* cast-expression
pm-expression ->* cast-expression
2 The binary operator.* binds its second operand, which shall be a prvalue of type “pointer to member of
T” to its first operand, which shall be a glvalue of classT or of a class of whichT is an unambiguous and
accessible base class. The result is an object or a function of the type specified by the second operand.
3 The binary operator->* binds its second operand, which shall be a prvalue of type “pointer to member
of T” to its first operand, which shall be of type “pointer toU” whereU is eitherT or a class of whichT is
an unambiguous and accessible base class. The expressionE1->*E2 is converted into the equivalent form
(*(E1)).*E2.
4 Abbreviating pm-expression.*cast-expression as E1.*E2, E1 is called theobject expression. If the result ofE1
is an object whose type is not similar to the type ofE1, or whose most derived object does not contain the
member to whichE2 refers, the behavior is undefined. The expressionE1 is sequenced before the expression
E2.
5 The restrictions on cv-qualification, and the manner in which the cv-qualifiers of the operands are combined
to produce the cv-qualifiers of the result, are the same as the rules forE1.E2 given in 7.6.1.5.
[Note 1: It is not possible to use a pointer to member that refers to amutable member to modify a const class object.
For example,
struct S {
S() : i(0) { }
mutable int i;
};
void f()
{
const S cs;
int S::* pm = &S::i; // pm refers tomutable member S::i
cs.*pm = 88; // error: cs is a const object
}
—end note]
6 If the result of.* or ->* is a function, then that result can be used only as the operand for the function call
operator ().
[Example 1:
(ptr_to_obj->*ptr_to_mfct)(10);
calls the member function denoted byptr_to_mfct for the object pointed to byptr_to_obj. —end example]
In a.* expression whose object expression is an rvalue, the program is ill-formed if the second operand is a
pointer to member function whoseref-qualifier is &, unless itscv-qualifier-seq is const. In a.* expression
whose object expression is an lvalue, the program is ill-formed if the second operand is a pointer to member
function whoseref-qualifier is &&. The result of a.* expression whose second operand is a pointer to a data
member is an lvalue if the first operand is an lvalue and an xvalue otherwise. The result of a.* expression
whose second operand is a pointer to a member function is a prvalue. If the second operand is the null
member pointer value (7.3.13), the behavior is undefined.
7.6.5 Multiplicative operators [expr.mul]
1 The multiplicative operators*, /, and% group left-to-right.
multiplicative-expression:
pm-expression
multiplicative-expression * pm-expression
multiplicative-expression / pm-expression
multiplicative-expression % pm-expression
§ 7.6.5 © ISO/IEC
163

===== PAGE 175 =====

Dxxxx
2 The operands of* and / shall have arithmetic or unscoped enumeration type; the operands of% shall have
integral or unscoped enumeration type. The usual arithmetic conversions (7.4) are performed on the operands
and determine the type of the result.
3 The binary* operator indicates multiplication.
4 The binary/ operator yields the quotient, and the binary% operator yields the remainder from the division
of the first expression by the second. If the second operand of/ or % is zero, the behavior is undefined. For
integral operands, the/ operator yields the algebraic quotient with any fractional part discarded;59 if the
quotient a/b is representable in the type of the result,(a/b)*b + a%b is equal toa; otherwise, the behavior
of botha/b and a%b is undefined.
7.6.6 Additive operators [expr.add]
1 The additive operators+ and - group left-to-right. Each operand shall be a prvalue. If both operands have
arithmetic or unscoped enumeration type, the usual arithmetic conversions (7.4) are performed. Otherwise,
if one operand has arithmetic or unscoped enumeration type, integral promotion is applied (7.3.7) to that
operand. A converted or promoted operand is used in place of the corresponding original operand for the
remainder of this section.
additive-expression:
multiplicative-expression
additive-expression + multiplicative-expression
additive-expression - multiplicative-expression
For addition, either both operands shall have arithmetic type, or one operand shall be a pointer to a
completely-defined object type and the other shall have integral type.
2 For subtraction, one of the following shall hold:
—(2.1) both operands have arithmetic type; or
—(2.2) both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-defined
object type; or
—(2.3) the left operand is a pointer to a completely-defined object type and the right operand has integral
type.
3 The result of the binary+ operator is the sum of the operands. The result of the binary- operator is the
difference resulting from the subtraction of the second operand from the first.
4 When an expressionJ that has integral type is added to or subtracted from an expressionP of pointer type,
the result has the type ofP.
—(4.1) If P evaluates to a null pointer value andJ evaluates to 0, the result is a null pointer value.
—(4.2) Otherwise, if P points to a (possibly-hypothetical) array element i of an array object x with n
elements (9.3.4.5),60 the expressionsP + J and J + P (where J has the valuej) point to the (possibly-
hypothetical) array element i+ j of x if 0 ≤i+ j ≤n and the expression P - J points to the
(possibly-hypothetical) array elementi−j of x if 0 ≤i−j ≤n.
—(4.3) Otherwise, the behavior is undefined.
[Note 1: Adding a value other than0 or 1 to a pointer to a base class subobject, a member subobject, or a complete
object results in undefined behavior.—end note]
5 The result of subtracting two pointer expressionsP and Q is a prvalue of typestd::ptrdiff_t (17.2.4).
—(5.1) If P and Q both evaluate to null pointer values, the value is 0.
—(5.2) Otherwise, if P and Q point to, respectively, array elementsi and j of the same array objectx, the
expression P - Q has the valuei−j.
[Note 2: If the valuei−j is not in the range of representable values of typestd::ptrdiff_t, the behavior is
undefined (7.1). —end note]
—(5.3) Otherwise, the behavior is undefined.
59) This is often called truncation towards zero.
60) As specified in 6.9.4, an object that is not an array element is considered to belong to a single-element array for this purpose
and a pointer past the last element of an array ofn elements is considered to be equivalent to a pointer to a hypothetical array
element n for this purpose.
§ 7.6.6 © ISO/IEC
164

===== PAGE 176 =====

Dxxxx
6 For addition or subtraction, if the expressionsP or Q have type “pointer tocv T”, whereT and the array
element type are not similar (7.3.6), the behavior is undefined.
[Example 1:
int arr[5] = {1, 2, 3, 4, 5};
unsigned int *p = reinterpret_cast<unsigned int*>(arr + 1);
unsigned int k = *p; // OK, value ofk is 2 (7.3.2)
unsigned int *q = p + 1; // undefined behavior:p points to anint, not anunsigned int object
—end example]
7.6.7 Shift operators [expr.shift]
1 The shift operators<< and >> group left-to-right.
shift-expression:
additive-expression
shift-expression << additive-expression
shift-expression >> additive-expression
The operands shall be prvalues of integral or unscoped enumeration type and integral promotions are
performed. The type of the result is that of the promoted left operand. The behavior is undefined if the right
operand is negative, or greater than or equal to the width of the promoted left operand.
2 The value ofE1 << E2 is the unique value congruent toE1×2E2 modulo 2N, whereN is the width of the
type of the result.
[Note 1: E1 is left-shiftedE2 bit positions; vacated bits are zero-filled.—end note]
3 The value ofE1 >> E2 is E1/2E2, rounded towards negative infinity.
[Note 2: E1 is right-shiftedE2 bit positions. Right-shift on signed integral types is an arithmetic right shift, which
performs sign-extension. —end note]
4 The expressionE1 is sequenced before the expressionE2.
7.6.8 Three-way comparison operator [expr.spaceship]
1 The three-way comparison operator groups left-to-right.
compare-expression:
shift-expression
compare-expression <=> shift-expression
2 The expressionp <=> q is a prvalue indicating whetherp is less than, equal to, greater than, or incomparable
with q.
3 If one of the operands is of typebool and the other is not, the program is ill-formed.
4 If both operands have arithmetic types, or one operand has integral type and the other operand has unscoped
enumeration type, the usual arithmetic conversions (7.4) are applied to the operands. Then:
—(4.1) If a narrowing conversion (9.5.5) is required, other than from an integral type to a floating-point type,
the program is ill-formed.
—(4.2) Otherwise, if the operands have integral type, the result is of typestd::strong_ordering. The
result is std::strong_ordering::equal if both operands are arithmetically equal,std::strong_-
ordering::less if the first operand is arithmetically less than the second operand, andstd::strong_-
ordering::greater otherwise.
—(4.3) Otherwise, the operands have floating-point type, and the result is of typestd::partial_ordering.
The expression a <=> b yields std::partial_ordering::less if a is less thanb, std::partial_-
ordering::greater if a is greater thanb, std::partial_ordering::equivalent if a is equivalent
to b, andstd::partial_ordering::unordered otherwise.
5 If both operands have the same enumeration typeE, the operator yields the result of converting the operands
to the underlying type ofE and applying<=> to the converted operands.
6 If at least one of the operands is of object pointer type and the other operand is of object pointer or array
type, array-to-pointer conversions (7.3.3), pointer conversions (7.3.12), and qualification conversions (7.3.6)
are performed on both operands to bring them to their composite pointer type (7.2.2). After the conversions,
the operands shall have the same type.
[Note 1: If both of the operands are arrays, array-to-pointer conversions (7.3.3) are not applied.—end note]
§ 7.6.8 © ISO/IEC
165

===== PAGE 177 =====

Dxxxx
In this case,p <=> q is of typestd::strong_ordering and the result is defined by the following rules:
—(6.1) If two pointer operandspandqcompare equal (7.6.10),p <=> qyieldsstd::strong_ordering::equal;
—(6.2) otherwise, ifp and q compare unequal,p <=> q yields std::strong_ordering::less if q compares
greater thanp and std::strong_ordering::greater if p compares greater thanq (7.6.9);
—(6.3) otherwise, the result is unspecified.
7 Otherwise, the program is ill-formed.
8 The three comparison category types (17.12.2) (the typesstd::strong_ordering, std::weak_ordering,
and std::partial_ordering) are not predefined; if a standard library declaration (17.12.1, 16.4.2.4) of such
a class type does not precede (6.5.1) a use of that type — even an implicit use in which the type is not named
(e.g., via theauto specifier (9.2.9.7) in a defaulted three-way comparison (11.10.3) or use of the built-in
operator) — the program is ill-formed.
7.6.9 Relational operators [expr.rel]
1 The relational operators group left-to-right.
[Example 1: a<b<c means (a<b)<c and not (a<b)&&(b<c). —end example]
relational-expression:
compare-expression
relational-expression < compare-expression
relational-expression > compare-expression
relational-expression <= compare-expression
relational-expression >= compare-expression
The lvalue-to-rvalue (7.3.2) and function-to-pointer (7.3.4) standard conversions are performed on the
operands. If one of the operands is a pointer, the array-to-pointer conversion (7.3.3) is performed on the
other operand.
2 The converted operands shall have arithmetic, enumeration, or pointer type. The operators< (less than),>
(greater than),<= (less than or equal to), and>= (greater than or equal to) all yieldfalse or true. The
type of the result isbool.
3 The usual arithmetic conversions (7.4) are performed on operands of arithmetic or enumeration type. If
both converted operands are pointers, pointer conversions (7.3.12), function pointer conversions (7.3.14), and
qualification conversions (7.3.6) are performed to bring them to their composite pointer type (7.2.2). After
conversions, the operands shall have the same type.
4 The result of comparing unequal pointers to objects61 is defined in terms of a partial order consistent with
the following rules:
—(4.1) If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to
the element with the higher subscript is required to compare greater.
—(4.2) If two pointers point to different non-static data members of the same object, or to subobjects of such
members, recursively, the pointer to the later declared member is required to compare greater provided
neither member is a subobject of zero size and their class is not a union.
—(4.3) Otherwise, neither pointer is required to compare greater than the other.
5 If two operandsp and q compare equal (7.6.10),p<=q and p>=q both yieldtrue and p<q and p>q both yield
false. Otherwise, if a pointer to objectp compares greater than a pointerq, p>=q, p>q, q<=p, andq<p all
yield true and p<=q, p<q, q>=p, andq>p all yieldfalse. Otherwise, the result of each of the operators is
unspecified.
[Note 1: A relational operator applied to unequal function pointers yields an unspecified result. A pointer value of
type “pointer tocv void” can point to an object (6.9.4).—end note]
6 If both operands (after conversions) are of arithmetic or enumeration type, each of the operators shall yield
true if the specified relationship is true andfalse if it is false.
61) As specified in 6.9.4, an object that is not an array element is considered to belong to a single-element array for this purpose
and a pointer past the last element of an array ofn elements is considered to be equivalent to a pointer to a hypothetical array
element n for this purpose.
§ 7.6.9 © ISO/IEC
166

===== PAGE 178 =====

Dxxxx
7.6.10 Equality operators [expr.eq]
equality-expression:
relational-expression
equality-expression == relational-expression
equality-expression != relational-expression
1 The == (equal to) and the!= (not equal to) operators group left-to-right. The lvalue-to-rvalue (7.3.2) and
function-to-pointer (7.3.4) standard conversions are performed on the operands. If one of the operands is a
pointer or a null pointer constant (7.3.12), the array-to-pointer conversion (7.3.3) is performed on the other
operand.
2 The converted operands shall have scalar type. The operators== and != both yieldtrue or false, i.e., a
result of typebool. In each case below, the operands shall have the same type after the specified conversions
have been applied.
3 If at least one of the converted operands is a pointer, pointer conversions (7.3.12), function pointer conversions
(7.3.14), and qualification conversions (7.3.6) are performed on both operands to bring them to their composite
pointer type (7.2.2). Comparing pointers is defined as follows:
—(3.1) If one pointer represents the address of a complete object, and another pointer represents the address
one past the last element of a different complete object,62 the result of the comparison is unspecified.
—(3.2) Otherwise, if the pointers are both null, both point to the same function, or both represent the same
address (6.9.4), they compare equal.
—(3.3) Otherwise, the pointers compare unequal.
4 If at least one of the operands is a pointer to member, pointer-to-member conversions (7.3.13), function
pointer conversions (7.3.14), and qualification conversions (7.3.6) are performed on both operands to bring
them to their composite pointer type (7.2.2). Comparing pointers to members is defined as follows:
—(4.1) If two pointers to members are both the null member pointer value, they compare equal.
—(4.2) If only one of two pointers to members is the null member pointer value, they compare unequal.
—(4.3) If either is a pointer to a virtual member function, the result is unspecified.
—(4.4) If one refers to a member of classC1 and the other refers to a member of a different classC2, where
neither is a base class of the other, the result is unspecified.
[Example 1:
struct A {};
struct B : A { int x; };
struct C : A { int x; };
int A::*bx = (int(A::*))&B::x;
int A::*cx = (int(A::*))&C::x;
bool b1 = (bx == cx); // unspecified
—end example]
—(4.5) If both refer to (possibly different) members of the same union (11.5), they compare equal.
—(4.6) Otherwise, two pointers to members compare equal if they would refer to the same member of the
same most derived object (6.8.2) or the same subobject if indirection with a hypothetical object of the
associated class type were performed, otherwise they compare unequal.
[Example 2:
struct B {
int f();
};
struct L : B { };
struct R : B { };
struct D : L, R { };
int (B::*pb)() = &B::f;
int (L::*pl)() = pb;
62) As specified in 6.9.4, an object that is not an array element is considered to belong to a single-element array for this purpose.
§ 7.6.10 © ISO/IEC
167

===== PAGE 179 =====

Dxxxx
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
bool x = (pdl == pdr); // false
bool y = (pb == pl); // true
—end example]
5 Two operands of typestd::nullptr_t or one operand of typestd::nullptr_t and the other a null pointer
constant compare equal.
6 If both operands are of typestd::meta::info, they compare equal if both operands
—(6.1) are null reflection values,
—(6.2) represent values that are template-argument-equivalent (13.6),
—(6.3) represent the same object,
—(6.4) represent the same entity,
—(6.5) represent the same annotation (9.13.12),
—(6.6) represent the same direct base class relationship, or
—(6.7) represent equal data member descriptions (11.4.1),
and they compare unequal otherwise.
7 If two operands compare equal, the result istrue for the== operator andfalse for the!= operator. If two
operands compare unequal, the result isfalse for the== operator andtrue for the!= operator. Otherwise,
the result of each of the operators is unspecified.
8 If both operands are of arithmetic or enumeration type, the usual arithmetic conversions (7.4) are performed
on both operands; each of the operators shall yieldtrue if the specified relationship is true andfalse if it is
false.
7.6.11 Bitwise AND operator [expr.bit.and]
and-expression:
equality-expression
and-expression & equality-expression
1 The&operator groups left-to-right. The operands shall be of integral or unscoped enumeration type. The usual
arithmetic conversions (7.4) are performed. Given the coefficientsxi and yi of the base-2 representation (6.9.2)
of the converted operandsx and y, the coefficientri of the base-2 representation of the resultr is 1 if both
xi and yi are 1, and 0 otherwise.
[Note 1: The result is the bitwiseand function of the operands.—end note]
7.6.12 Bitwise exclusive OR operator [expr.xor]
exclusive-or-expression:
and-expression
exclusive-or-expression ^ and-expression
1 The^operator groups left-to-right. The operands shall be of integral or unscoped enumeration type. The usual
arithmetic conversions (7.4) are performed. Given the coefficientsxi and yi of the base-2 representation (6.9.2)
of the converted operandsx and y, the coefficientri of the base-2 representation of the resultr is 1 if either
(but not both) ofxi and yi is 1, and 0 otherwise.
[Note 1: The result is the bitwise exclusiveor function of the operands.—end note]
7.6.13 Bitwise inclusive OR operator [expr.or]
inclusive-or-expression:
exclusive-or-expression
inclusive-or-expression | exclusive-or-expression
1 The|operator groups left-to-right. The operands shall be of integral or unscoped enumeration type. The usual
arithmetic conversions (7.4) are performed. Given the coefficientsxi and yi of the base-2 representation (6.9.2)
of the converted operandsx and y, the coefficientri of the base-2 representation of the resultr is 1 if at
least one ofxi and yi is 1, and 0 otherwise.
[Note 1: The result is the bitwise inclusiveor function of the operands.—end note]
§ 7.6.13 © ISO/IEC
168

===== PAGE 180 =====

Dxxxx
7.6.14 Logical AND operator [expr.log.and]
logical-and-expression:
inclusive-or-expression
logical-and-expression && inclusive-or-expression
1 The && operator groups left-to-right. The operands are both contextually converted tobool (7.3). The result
is true if both operands aretrue and false otherwise. Unlike &, && guarantees left-to-right evaluation: the
second operand is not evaluated if the first operand isfalse.
2 The result is abool. If the second expression is evaluated, the first expression is sequenced before the second
expression (6.10.1).
7.6.15 Logical OR operator [expr.log.or]
logical-or-expression:
logical-and-expression
logical-or-expression || logical-and-expression
1 The || operator groups left-to-right. The operands are both contextually converted tobool (7.3). The result
is true if either of its operands istrue, andfalse otherwise. Unlike|, || guarantees left-to-right evaluation;
moreover, the second operand is not evaluated if the first operand evaluates totrue.
2 The result is abool. If the second expression is evaluated, the first expression is sequenced before the second
expression (6.10.1).
7.6.16 Conditional operator [expr.cond]
conditional-expression:
logical-or-expression
logical-or-expression ? expression : assignment-expression
1 Conditional expressions group right-to-left. The first expression is contextually converted tobool (7.3). It
is evaluated and if it istrue, the result of the conditional expression is the value of the second expression,
otherwise that of the third expression. Only one of the second and third expressions is evaluated. The first
expression is sequenced before the second or third expression (6.10.1).
2 If either the second or the third operand has typevoid, one of the following shall hold:
—(2.1) The second or the third operand (but not both) is a (possibly parenthesized)throw-expression (7.6.18);
the result is of the type and value category of the other. Theconditional-expression is a bit-field if that
operand is a bit-field.
—(2.2) Both the second and the third operands have typevoid; the result is of typevoid and is a prvalue.
[Note 1: This includes the case where both operands arethrow-expressions. —end note]
3 Otherwise, if the second and third operand are glvalue bit-fields of the same value category and of typescv1
T and cv2 T, respectively, the operands are considered to be of typecv T for the remainder of this subclause,
where cv is the union ofcv1 and cv2.
4 Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class
type, or if both are glvalues of the same value category and the same type except for cv-qualification, an
attempt is made to form an implicit conversion sequence (12.2.4.2) from each of those operands to the type
of the other.
[Note 2: Properties such as access, whether an operand is a bit-field, or whether a conversion function is deleted are
ignored for that determination.—end note]
Attempts are made to form an implicit conversion sequence from an operand expressionE1 of typeT1 to a
target type related to the typeT2 of the operand expressionE2 as follows:
—(4.1) If E2 is an lvalue, the target type is “lvalue reference toT2”, but an implicit conversion sequence can
only be formed if the reference would bind directly (9.5.4) to a glvalue.
—(4.2) If E2 is an xvalue, the target type is “rvalue reference toT2”, but an implicit conversion sequence can
only be formed if the reference would bind directly.
—(4.3) If E2 is a prvalue or if neither of the conversion sequences above can be formed and at least one of the
operands has (possibly cv-qualified) class type:
—(4.3.1) if T1 and T2 are the same class type (ignoring cv-qualification):
—(4.3.1.1) if T2 is at least as cv-qualified asT1, the target type isT2,
§ 7.6.16 © ISO/IEC
169

===== PAGE 181 =====

Dxxxx
—(4.3.1.2) otherwise, no conversion sequence is formed for this operand;
—(4.3.2) otherwise, ifT2 is a base class ofT1, the target type iscv1 T2, wherecv1 denotes the cv-qualifiers
of T1;
—(4.3.3) otherwise, the target type is the type thatE2 would have after applying the lvalue-to-rvalue (7.3.2),
array-to-pointer (7.3.3), and function-to-pointer (7.3.4) standard conversions.
Using this process, it is determined whether an implicit conversion sequence can be formed from the second
operand to the target type determined for the third operand, and vice versa, with the following outcome:
—(4.4) If both sequences can be formed, or one can be formed but it is the ambiguous conversion sequence,
the program is ill-formed.
—(4.5) If no conversion sequence can be formed, the operands are left unchanged and further checking is
performed as described below.
—(4.6) Otherwise, if exactly one conversion sequence can be formed, that conversion is applied to the chosen
operand and the converted operand is used in place of the original operand for the remainder of this
subclause.
[Note 3: The conversion might be ill-formed even if an implicit conversion sequence could be formed.—end
note]
5 If the second and third operands are glvalues of the same value category and have the same type, the result
is of that type and value category and it is a bit-field if the second or the third operand is a bit-field, or if
both are bit-fields.
6 Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either
has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be
applied to the operands (12.2.2.3, 12.5). If the overload resolution fails, the program is ill-formed. Otherwise,
the conversions thus determined are applied, and the converted operands are used in place of the original
operands for the remainder of this subclause.
7 Array-to-pointer (7.3.3) and function-to-pointer (7.3.4) standard conversions are performed on the second
and third operands. After those conversions, one of the following shall hold:
—(7.1) The second and third operands have the same type; the result is of that type and the result is
copy-initialized using the selected operand.
—(7.2) The second and third operands have arithmetic or enumeration type; the usual arithmetic conversions
(7.4) are performed to bring them to a common type, and the result is of that type.
—(7.3) One or both of the second and third operands have pointer type; lvalue-to-rvalue (7.3.2), pointer (7.3.12),
function pointer (7.3.14), and qualification conversions (7.3.6) are performed to bring them to their
composite pointer type (7.2.2). The result is of the composite pointer type.
—(7.4) One or both of the second and third operands have pointer-to-member type; lvalue-to-rvalue (7.3.2),
pointer to member (7.3.13), function pointer (7.3.14), and qualification conversions (7.3.6) are performed
to bring them to their composite pointer type (7.2.2). The result is of the composite pointer type.
—(7.5) Both the second and third operands have typestd::nullptr_t or one has that type and the other is
a null pointer constant. The result is of typestd::nullptr_t.
7.6.17 Yielding a value [expr.yield]
yield-expression:
co_yield assignment-expression
co_yield braced-init-list
1 A yield-expression shall appear only within a suspension context of a function (7.6.2.4). Lete be the operand
of theyield-expression and p be an lvalue naming the promise object of the enclosing coroutine (9.6.4), then
the yield-expression is equivalent to the expressionco_await p.yield_value(e ).
[Example 1:
template <typename T>
struct my_generator {
struct promise_type {
T current_value;
§ 7.6.17 © ISO/IEC
170

===== PAGE 182 =====

Dxxxx
/* ... */
auto yield_value(T v) {
current_value = std::move(v);
return std::suspend_always{};
}
};
struct iterator { /* ... */ };
iterator begin();
iterator end();
};
my_generator<pair<int,int>> g1() {
for (int i = 0; i < 10; ++i) co_yield {i,i};
}
my_generator<pair<int,int>> g2() {
for (int i = 0; i < 10; ++i) co_yield make_pair(i,i);
}
auto f(int x = co_yield 5); // error: yield-expression outside of function suspension context
int a[] = { co_yield 1 }; // error: yield-expression outside of function suspension context
int main() {
auto r1 = g1();
auto r2 = g2();
assert(std::equal(r1.begin(), r1.end(), r2.begin(), r2.end()));
}
—end example]
7.6.18 Throwing an exception [expr.throw]
throw-expression:
throw assignment-expressionopt
1 A throw-expression is of typevoid.
2 A throw-expression with an operand throws an exception (14.2). The array-to-pointer (7.3.3) and function-
to-pointer (7.3.4) standard conversions are performed on the operand. The type of the exception object is
determined by removing any top-levelcv-qualifiers from the type of the (possibly converted) operand. The
exception object is copy-initialized (9.5.1) from the (possibly converted) operand.
3 A throw-expression with no operand rethrows the currently handled exception (14.4). If no exception is
presently being handled, the functionstd::terminate is invoked (14.6.2). Otherwise, the exception is
reactivated with the existing exception object; no new exception object is created. The exception is no longer
considered to be caught.
[Example 1: An exception handler that cannot completely handle the exception itself can be written like this:
try {
// ...
} catch (...) { // catch all exceptions
// respond (partially) to exception
throw; // pass the exception to some other handler
}
—end example]
7.6.19 Assignment and compound assignment operators [expr.assign]
1 The assignment operator (=) and the compound assignment operators all group right-to-left. All require a
modifiable lvalue as their left operand; their result is an lvalue of the type of the left operand, referring to the
left operand. The result in all cases is a bit-field if the left operand is a bit-field. In all cases, the assignment
is sequenced after the value computation of the right and left operands, and before the value computation
of the assignment expression. The right operand is sequenced before the left operand. With respect to an
indeterminately-sequenced function call, the operation of a compound assignment is a single evaluation.
[Note 1: Therefore, a function call cannot intervene between the lvalue-to-rvalue conversion and the side effect
associated with any single compound assignment operator.—end note]
§ 7.6.19 © ISO/IEC
171

===== PAGE 183 =====

Dxxxx
assignment-expression:
conditional-expression
yield-expression
throw-expression
logical-or-expression assignment-operator initializer-clause
assignment-operator: one of
= *= /= %= += -= >>= <<= &= ^= |=
2 In simple assignment (=), letV be the result of the right operand; the object referred to by the left operand is
modified (3.1) by replacing its value withV or, if the object is of integer type, with the value congruent (6.9.2)
to V.
3 If the right operand is an expression, it is implicitly converted (7.3) to the cv-unqualified type of the left
operand.
4 When the left operand of an assignment operator is a bit-field that cannot represent the value of the expression,
the resulting value of the bit-field is implementation-defined.
5 An assignment whose left operand is of a volatile-qualified type is deprecated (D.4) unless the (possibly
parenthesized) assignment is a discarded-value expression or an unevaluated operand (7.2.3).
6 The behavior of an expression of the formE1 op = E2 is equivalent toE1 = E1 op E2 except thatE1 is
evaluated only once.
[Note 2: The object designated byE1 is accessed twice. —end note]
For+=and -=, E1shall either have arithmetic type or be a pointer to a possibly cv-qualified completely-defined
object type. In all other cases,E1 shall have arithmetic type.
7 If the value being stored in an object is read via another object that overlaps in any way the storage of the
first object, then the overlap shall be exact and the two objects shall have the same type, otherwise the
behavior is undefined.
[Note 3: This restriction applies to the relationship between the left and right sides of the assignment operation; it is
not a statement about how the target of the assignment can be aliased in general. See 7.2.1.—end note]
8 A braced-init-list B may appear on the right-hand side of
—(8.1) an assignment to a scalar of typeT, in which caseB shall have at most a single element. The meaning
of x = B is x = t, wheret is an invented temporary variable declared and initialized asT t = B.
—(8.2) an assignment to an object of class type, in which caseB is passed as the argument to the assignment
operator function selected by overload resolution (12.4.3.2, 12.2).
[Example 1:
complex<double> z;
z = { 1,2 }; // meaningz.operator=({1,2})
z += { 1, 2 }; // meaningz.operator+=({1,2})
int a, b;
a = b = { 1 }; // meaninga=b=1;
a = { 1 } = b; // syntax error
—end example]
7.6.20 Comma operator [expr.comma]
1 The comma operator groups left-to-right.
expression:
assignment-expression
expression , assignment-expression
A pair of expressions separated by a comma is evaluated left-to-right; the left expression is a discarded-value
expression (7.2). The left expression is sequenced before the right expression (6.10.1). The type and value of
the result are the type and value of the right operand; the result is of the same value category as its right
operand, and is a bit-field if its right operand is a bit-field.
2 [Note 1: In contexts where the comma token is given special meaning (e.g., function calls (7.6.1.3), subscript
expressions (7.6.1.2), lists of initializers (9.5), ortemplate-argument-lists (13.3)), the comma operator as described in
this subclause can appear only in parentheses.
§ 7.6.20 © ISO/IEC
172

===== PAGE 184 =====

Dxxxx
[Example 1:
f(a, (t=3, t+2), c);
has three arguments, the second of which has the value5. —end example]
—end note]
7.7 Constant expressions [expr.const]
1 Certain contexts require expressions that satisfy additional requirements as detailed in this subclause; other
contexts have different semantics depending on whether or not an expression satisfies these requirements.
Expressions that satisfy these requirements, assuming that copy elision (11.9.6) is not performed, are called
constant expressions.
[Note 1: Constant expressions can be evaluated during translation.—end note]
constant-expression:
conditional-expression
2 The constituent values and constituent references of a variablex are defined as follows:
—(2.1) If x declares an object, the constituent values and references of that object (6.8.2) are constituent values
and references ofx.
—(2.2) If x declares a reference, that reference is a constituent reference ofx.
For any constituent referencer of a variablex, if r is bound to a temporary object or subobject thereof
whose lifetime is extended to that ofr, the constituent values and references of that temporary object are
also constituent values and references ofx, recursively.
3 An objecto is constexpr-referenceablefrom a pointP if
—(3.1) o has static storage duration, or
—(3.2) o has automatic storage duration, and, lettingv denote
—(3.2.1) the variable corresponding too’s complete object or
—(3.2.2) the variable to whose lifetime that ofo is extended,
the smallest scope enclosingv and the smallest scope enclosingP that are neither
—(3.2.3) block scopes nor
—(3.2.4) function parameter scopes associated with arequirement-parameter-list
are the same function parameter scope.
[Example 1:
struct A {
int m;
const int& r;
};
void f() {
static int sx;
thread_local int tx; // tx is never constexpr-referenceable
int ax;
A aa = {1, 2};
static A sa = {3, 4};
// The objectssx, ax, and aa.m, sa.m, and the temporaries to whichaa.r and sa.r are bound, are constexpr-
referenceable.
auto lambda = [] {
int ay;
// The objectssx, sa.m, and ay (but not ax or aa), and the
// temporary to whichsa.r is bound, are constexpr-referenceable.
};
}
—end example]
4 An object or referencex is constexpr-representable at a pointP if, for each constituent value ofx that
points to or past an object o, and for each constituent reference ofx that refers to an object o, o is
constexpr-referenceable fromP.
§ 7.7 © ISO/IEC
173

===== PAGE 185 =====

Dxxxx
5 A variablev is constant-initializable if
—(5.1) the full-expression of its initialization is a constant expression when interpreted as aconstant-expression
with all contract assertions using the ignore evaluation semantic (6.11.2),
[Note 2: Within this evaluation,std::is_constant_evaluated() (21.3.12) returnstrue. —end note]
[Note 3: The initialization, when evaluated, can still evaluate contract assertions with other evaluation semantics,
resulting in a diagnostic or ill-formed program if a contract violation occurs.—end note]
—(5.2) immediately after the initializing declaration ofv, the object or referencex declared byv is constexpr-
representable, and
—(5.3) if x has static or thread storage duration,x is constexpr-representable at the nearest point whose
immediate scope is a namespace scope that follows the initializing declaration ofv.
6 A constant-initializable variable isconstant-initialized if either it has an initializer or its type is const-default-
constructible (9.5.1).
[Example 2:
void f() {
int ax = 0; // ax is constant-initialized
thread_local int tx = 0; // tx is constant-initialized
static int sx; // sx is not constant-initialized
static int& rss = sx; // rss is constant-initialized
static int& rst = tx; // rst is not constant-initialized
static int& rsa = ax; // rsa is not constant-initialized
thread_local int& rts = sx; // rts is constant-initialized
thread_local int& rtt = tx; // rtt is not constant-initialized
thread_local int& rta = ax; // rta is not constant-initialized
int& ras = sx; // ras is constant-initialized
int& rat = tx; // rat is not constant-initialized
int& raa = ax; // raa is constant-initialized
}
—end example]
7 A variable ispotentially-constant if it is constexpr or it has reference or non-volatile const-qualified integral
or enumeration type.
8 A constant-initialized potentially-constant variableV is usable in constant expressionsat a pointP if V’s
initializing declarationD is reachable fromP and
—(8.1) V is constexpr,
—(8.2) V is not initialized to a TU-local value, or
—(8.3) P is in the same translation unit asD.
An object or reference ispotentially usable in constant expressionsat pointP if it is
—(8.4) the object or reference declared by a variable that is usable in constant expressions atP,
—(8.5) a temporary object of non-volatile const-qualified literal type whose lifetime is extended (6.8.7) to that
of a variable that is usable in constant expressions atP,
—(8.6) a template parameter object (13.2),
—(8.7) a string literal object (5.13.5),
—(8.8) a non-mutable subobject of any of the above, or
—(8.9) a reference member of any of the above.
An object or reference isusable in constant expressionsat point P if it is an object or reference that is
potentially usable in constant expressions atP and is constexpr-representable atP.
[Example 3:
struct A {
int* const & r;
};
void f(int x) {
constexpr A a = {&x};
static_assert(a.r == &x); // OK
§ 7.7 © ISO/IEC
174

===== PAGE 186 =====

Dxxxx
[&] {
static_assert(a.r != nullptr); // error: a.r is not usable in constant expressions at this point
}();
}
—end example]
9 An expressionE is acore constant expressionunless the evaluation ofE, following the rules of the abstract
machine (6.10.1), would evaluate one of the following:
—(9.1) this (7.5.3), except
—(9.1.1) in a constexpr function (9.2.6) that is being evaluated as part ofE or
—(9.1.2) when appearing as thepostfix-expression of an implicit or explicit class member access expression
(7.6.1.5);
—(9.2) a control flow that passes through a declaration of a block variable (6.4.3) with static (6.8.6.2) or
thread (6.8.6.3) storage duration, unless that variable is usable in constant expressions;
[Example 4:
constexpr char test() {
static const int x = 5;
static constexpr char c[] = "Hello World";
return *(c + x);
}
static_assert(' ' == test());
—end example]
—(9.3) an invocation of a non-constexpr function;63
—(9.4) an invocation of an undefined constexpr function;
—(9.5) an invocation of an instantiated constexpr function that is not constexpr-suitable;
—(9.6) an invocation of a virtual function (11.7.3) for an object whose dynamic type is constexpr-unknown;
—(9.7) an expression that would exceed the implementation-defined limits (see Annex B);
—(9.8) an operation that would have undefined or erroneous behavior as specified in Clause 4 through Clause
15;64
—(9.9) an lvalue-to-rvalue conversion (7.3.2) unless it is applied to
—(9.9.1) a glvalue of typecv std::nullptr_t,
—(9.9.2) a non-volatile glvalue that refers to an object that is usable in constant expressions, or
—(9.9.3) a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began within
the evaluation ofE;
—(9.10) an lvalue-to-rvalue conversion that is applied to a glvalue that refers to a non-active member of a union
or a subobject thereof;
—(9.11) an lvalue-to-rvalue conversion that is applied to an object with an indeterminate value (6.8.5);
—(9.12) an invocation of an implicitly-defined copy/move constructor or copy/move assignment operator for a
union whose active member (if any) is mutable, unless the lifetime of the union object began within the
evaluation ofE;
—(9.13) in alambda-expression, a reference tothis or to a variable with automatic storage duration defined
outside thatlambda-expression, where the reference would be an odr-use (6.3, 7.5.6);
[Example 5:
void g() {
const int n = 0;
[=] {
constexpr int i = n; // OK,n is not odr-used here
constexpr int j = *&n; // error: &n would be an odr-use ofn
63) Overload resolution (12.2) is applied as usual.
64) This includes, for example, signed integer overflow (7.1), certain pointer arithmetic (7.6.6), division by zero (7.6.5), or
certain shift operations (7.6.7).
§ 7.7 © ISO/IEC
175

===== PAGE 187 =====

Dxxxx
};
}
—end example]
[Note 4: If the odr-use occurs in an invocation of a function call operator of a closure type, it no longer refers
to this or to an enclosing variable with automatic storage duration due to the transformation (7.5.6.3) of the
id-expression into an access of the corresponding data member.
[Example 6:
auto monad = [](auto v) { return [=] { return v; }; };
auto bind = [](auto m) {
return [=](auto fvm) { return fvm(m()); };
};
// OK to capture objects with automatic storage duration created during constant expression evaluation.
static_assert(bind(monad(2))(monad)() == monad(2)());
—end example]
—end note]
—(9.14) a conversion from a prvalueP of type “pointer tocv void” to a type “cv1 pointer toT”, whereT is not
cv2 void, unlessP is a null pointer value or points to an object whose type is similar toT;
—(9.15) a reinterpret_cast (7.6.1.10);
—(9.16) pointer arithmetic (7.6.6) where one (possibly converted) operand points to the first element of an array
of unknown bound and the other (possibly converted) operand is of integral type with non-zero value;
—(9.17) a modification of an object (7.6.19, 7.6.1.6, 7.6.2.3) unless it is applied to a non-volatile lvalue of literal
type that refers to a non-volatile object whose lifetime began within the evaluation ofE;
—(9.18) an invocation of a destructor (11.4.7) or a function call whosepostfix-expression names a pseudo-
destructor (7.6.1.3), in either case for an object whose lifetime did not begin within the evaluation of
E;
—(9.19) a new-expression (7.6.2.8), unless either
—(9.19.1) the selected allocation function is a replaceable global allocation function (17.6.3.2, 17.6.3.3) and
the allocated storage is deallocated within the evaluation ofE, or
—(9.19.2) the selected allocation function is a non-allocating form (17.6.3.4) with an allocated typeT, where
—(9.19.2.1) the placement argument to thenew-expression points to an object whose type is similar to
T (7.3.6) or, ifT is an array type, to the first element of an object of a type similar toT, and
—(9.19.2.2) the placement argument points to storage whose duration began within the evaluation ofE;
—(9.20) a delete-expression (7.6.2.9), unless it deallocates a region of storage allocated within the evaluation of
E;
—(9.21) a call to an instance ofstd::allocator<T>::allocate (20.2.10.2), unless the allocated storage is
deallocated within the evaluation ofE;
—(9.22) a call to an instance ofstd::allocator<T>::deallocate (20.2.10.2), unless it deallocates a region of
storage allocated within the evaluation ofE;
—(9.23) a construction of an exception object, unless the exception object and all of its implicit copies created by
invocations ofstd::current_exception or std::rethrow_exception (17.9.7) are destroyed within
the evaluation ofE;
—(9.24) a throw-expression (7.6.18) with no operand, unless there is a currently handled exception whose
exception object was constructed within the evaluation ofE;
—(9.25) an await-expression (7.6.2.4);
—(9.26) a yield-expression (7.6.17);
—(9.27) a three-way comparison (7.6.8), relational (7.6.9), or equality (7.6.10) operator where the result is
unspecified;
—(9.28) a dynamic_cast (7.6.1.7) ortypeid (7.6.1.8) expression on a glvalue that refers to an object whose
dynamic type is constexpr-unknown;
§ 7.7 © ISO/IEC
176

===== PAGE 188 =====

Dxxxx
—(9.29) a dynamic_cast (7.6.1.7) expression,typeid (7.6.1.8) expression, ornew-expression (7.6.2.8) that
would throw an exception where no definition of the exception type is reachable;
—(9.30) an expression that would produce an injected declaration (see below), unlessE is the corresponding
expression of aconsteval-block-declaration (9.1);
—(9.31) an asm-declaration (9.11);
—(9.32) an invocation of theva_arg macro (17.14.2);
—(9.33) a non-constant library call (3.35); or
—(9.34) a goto statement (8.8.6).
[Note 5: A goto statement introduced by equivalence (Clause 8) is not in scope. For example, awhile
statement (8.6.2) can be executed during constant evaluation.—end note]
10 It is implementation-defined whetherE is a core constant expression ifE satisfies the constraints of a core
constant expression, but evaluation ofE has runtime-undefined behavior.
11 It is unspecified whetherE is a core constant expression ifE satisfies the constraints of a core constant
expression, but evaluation ofE would evaluate
—(11.1) an operation that has undefined behavior as specified in Clause 16 through Clause 33 or
—(11.2) an invocation of theva_start macro (17.14.2).
12 [Example 7:
int x; // not constant
struct A {
constexpr A(bool b) : m(b?42:x) { }
int m;
};
constexpr int v = A(true).m; // OK, constructor call initializesm with the value42
constexpr int w = A(false).m; // error: initializer form is x, which is non-constant
constexpr int f1(int k) {
constexpr int x = k; // error: x is not initialized by a constant expression
// because lifetime ofk began outside the initializer ofx
return x;
}
constexpr int f2(int k) {
int x = k; // OK, not required to be a constant expression
// becausex is not constexpr
return x;
}
constexpr int incr(int &n) {
return ++n;
}
constexpr int g(int k) {
constexpr int x = incr(k); // error: incr(k) is not a core constant expression
// because lifetime ofk began outside the expressionincr(k)
return x;
}
constexpr int h(int k) {
int x = incr(k); // OK,incr(k) is not required to be a core constant expression
return x;
}
constexpr int y = h(1); // OK, initializesy with the value2
// h(1) is a core constant expression because
// the lifetime ofk begins insideh(1)
—end example]
13 For the purposes of determining whether an expressionE is a core constant expression, the evaluation of the
body of a member function ofstd::allocator<T> as defined in 20.2.10.2, is ignored.
§ 7.7 © ISO/IEC
177

===== PAGE 189 =====

Dxxxx
14 For the purposes of determining whetherE is a core constant expression, the evaluation of a call to a trivial
copy/move constructor or copy/move assignment operator of a union is considered to copy/move the active
member of the union, if any.
[Note 6: The copy/move of the active member is trivial.—end note]
15 For the purposes of determining whetherE is a core constant expression, the evaluation of anid-expression
that names a structured bindingv (9.7) has the following semantics:
—(15.1) If v is an lvalue referring to the object bound to an invented referencer, the behavior is as ifr were
nominated.
—(15.2) Otherwise, if v names an array element or class member, the behavior is that of evaluatinge[i] or
e.m, respectively, wheree is the name of the variable initialized from the initializer of the structured
binding declaration, andi is the index of the element referred to byv or m is the name of the member
referred to byv, respectively.
[Example 8:
#include <tuple>
struct S {
mutable int m;
constexpr S(int m): m(m) {}
virtual int g() const;
};
void f(std::tuple<S&> t) {
auto [r] = t;
static_assert(r.g() >= 0); // error: dynamic type is constexpr-unknown
constexpr auto [m] = S(1);
static_assert(m == 1); // error: lvalue-to-rvalue conversion on mutable
// subobjecte.m, wheree is a constexpr object of typeS
using A = int[2];
constexpr auto [v0, v1] = A{2, 3};
static_assert(v0 + v1 == 5); // OK, equivalent toe[0] + e[1] where e is a constexpr array
}
—end example]
16 During the evaluation of an expressionE as a core constant expression, allid-expressions, splice-expressions,
and uses of*this that refer to an object or reference whose lifetime did not begin with the evaluation of
E are treated as referring to a specific instance of that object or reference whose lifetime and that of all
subobjects (including all union members) includes the entire constant evaluation. For such an object that is
not usable in constant expressions, the dynamic type of the object isconstexpr-unknown. For such a reference
that is not usable in constant expressions, the reference is treated as binding to an unspecified object of the
referenced type whose lifetime and that of all subobjects includes the entire constant evaluation and whose
dynamic type is constexpr-unknown.
[Example 9:
template <typename T, size_t N>
constexpr size_t array_size(T (&)[N]) {
return N;
}
void use_array(int const (&gold_medal_mel)[2]) {
constexpr auto gold = array_size(gold_medal_mel); // OK
}
constexpr auto olympic_mile() {
const int ledecky = 1500;
return []{ return ledecky; };
}
static_assert(olympic_mile()() == 1500); // OK
struct Swim {
constexpr int phelps() { return 28; }
virtual constexpr int lochte() { return 12; }
§ 7.7 © ISO/IEC
178

===== PAGE 190 =====

Dxxxx
int coughlin = 12;
};
constexpr int how_many(Swim& swam) {
Swim* p = &swam;
return (p + 1 - 1)->phelps();
}
void splash(Swim& swam) {
static_assert(swam.phelps() == 28); // OK
static_assert((&swam)->phelps() == 28); // OK
Swim* pswam = &swam;
static_assert(pswam->phelps() == 28); // error: lvalue-to-rvalue conversion on a pointer
// not usable in constant expressions
static_assert(how_many(swam) == 28); // OK
static_assert(Swim().lochte() == 12); // OK
static_assert(swam.lochte() == 12); // error: invoking virtual function on reference
// with constexpr-unknown dynamic type
static_assert(swam.coughlin == 12); // error: lvalue-to-rvalue conversion on an object
// not usable in constant expressions
}
extern Swim dc;
extern Swim& trident;
constexpr auto& sandeno = typeid(dc); // OK, can only betypeid(Swim)
constexpr auto& gallagher = typeid(trident); // error: constexpr-unknown dynamic type
—end example]
17 An objecta is said to haveconstant destructionif
—(17.1) it is not of class type nor (possibly multidimensional) array thereof, or
—(17.2) it is of class type or (possibly multidimensional) array thereof, that class type has a constexpr
destructor (9.2.6), and for a hypothetical expressionE whose only effect is to destroya, E would be
a core constant expression if the lifetime ofa and its non-mutable subobjects (but not its mutable
subobjects) were considered to start withinE.
18 An integral constant expressionis an expression of integral or unscoped enumeration type, implicitly converted
to a prvalue, where the converted expression is a core constant expression.
[Note 7: Such expressions can be used as bit-field lengths (11.4.10), as enumerator initializers if the underlying type is
not fixed (9.8.1), and as alignments (9.13.2).—end note]
19 If an expression of literal class type is used in a context where an integral constant expression is required,
then that expression is contextually implicitly converted (7.3) to an integral or unscoped enumeration type
and the selected conversion function shall beconstexpr.
[Example 10:
struct A {
constexpr A(int i) : val(i) { }
constexpr operator int() const { return val; }
constexpr operator long() const { return 42; }
private:
int val;
};
constexpr A a = alignof(int);
alignas(a) int n; // error: ambiguous conversion
struct B { int n : a; }; // error: ambiguous conversion
—end example]
§ 7.7 © ISO/IEC
179

===== PAGE 191 =====

Dxxxx
20 A converted constant expressionof typeT is an expression, implicitly converted to typeT, where the converted
expression is a constant expression and the implicit conversion sequence contains only
—(20.1) user-defined conversions,
—(20.2) lvalue-to-rvalue conversions (7.3.2),
—(20.3) array-to-pointer conversions (7.3.3),
—(20.4) function-to-pointer conversions (7.3.4),
—(20.5) qualification conversions (7.3.6),
—(20.6) integral promotions (7.3.7),
—(20.7) integral conversions (7.3.9) other than narrowing conversions (9.5.5),
—(20.8) floating-point promotions (7.3.8),
—(20.9) floating-point conversions (7.3.10) where the source value can be represented exactly in the destination
type,
—(20.10) null pointer conversions (7.3.12) fromstd::nullptr_t,
—(20.11) null member pointer conversions (7.3.13) fromstd::nullptr_t, and
—(20.12) function pointer conversions (7.3.14),
and where the reference binding (if any) binds directly.
[Note 8: Such expressions can be used innew expressions (7.6.2.8), as case expressions (8.5.3), as enumerator initializers
if the underlying type is fixed (9.8.1), as array bounds (9.3.4.5), as constant template arguments (13.4), and as the
constant expression of asplice-specifier (6.6). —end note]
A contextually converted constant expression of typebool is an expression, contextually converted to
bool (7.3), where the converted expression is a constant expression and the conversion sequence contains
only the conversions above.
21 A constant expressionis either
—(21.1) a glvalue core constant expressionE for which
—(21.1.1) E refers to a non-immediate function,
—(21.1.2) E designates an objecto, and if the complete object ofo is of consteval-only type then so isE,
[Example 11:
struct Base { };
struct Derived : Base { std::meta::info r; };
consteval const Base& fn(const Derived& derived) { return derived; }
constexpr Derived obj{.r=^^::}; // OK
constexpr const Derived& d = obj; // OK
constexpr const Base& b = fn(obj); // error: not a constant expression becauseDerived
// is a consteval-only type butBase is not.
—end example]
or
—(21.2) a prvalue core constant expression whose result object (7.2.1) satisfies the following constraints:
—(21.2.1) each constituent reference refers to an object or a non-immediate function,
—(21.2.2) no constituent value of scalar type is an indeterminate or erroneous value (6.8.5),
—(21.2.3) no constituent value of pointer type is a pointer to an immediate function or an invalid pointer
value (6.9.4),
—(21.2.4) no constituent value of pointer-to-member type designates an immediate function, and
—(21.2.5) unless the value is of consteval-only type,
—(21.2.5.1) no constituent value of pointer-to-member type points to a direct member of a consteval-only
class type,
—(21.2.5.2) no constituent value of pointer type points to or past an object whose complete object is of
consteval-only type, and
§ 7.7 © ISO/IEC
180

===== PAGE 192 =====

Dxxxx
—(21.2.5.3) no constituent reference refers to an object whose complete object is of consteval-only type.
[Note 9: A glvalue core constant expression that either refers to or points to an unspecified object is not a constant
expression. —end note]
[Example 12:
consteval int f() { return 42; }
consteval auto g() { return f; }
consteval int h(int (*p)() = g()) { return p(); }
constexpr int r = h(); // OK
constexpr auto e = g(); // error: a pointer to an immediate function is
// not a permitted result of a constant expression
struct S {
int x;
constexpr S() {}
};
int i() {
constexpr S s; // error: s.x has erroneous value
}
—end example]
22 Recommended practice: Implementations should provide consistent results of floating-point evaluations,
irrespective of whether the evaluation is performed during translation or during program execution.
[Note 10: Since this document imposes no restrictions on the accuracy of floating-point operations, it is unspecified
whether the evaluation of a floating-point expression during translation yields the same result as the evaluation of the
same expression (or the same operations on the same values) during program execution.
[Example 13:
bool f() {
char array[1 + int(1 + 0.2 - 0.1 - 0.1)]; // Must be evaluated during translation
int size = 1 + int(1 + 0.2 - 0.1 - 0.1); // May be evaluated at runtime
return sizeof(array) == size;
}
It is unspecified whether the value off() will betrue or false. —end example]
—end note]
23 An expression or conversion is in animmediate function contextif it is potentially evaluated and either:
—(23.1) its innermost enclosing non-block scope is a function parameter scope of an immediate function,
—(23.2) it is a subexpression of a manifestly constant-evaluated expression or conversion, or
—(23.3) its enclosing statement is enclosed (8.1) by thecompound-statement of a consteval if statement (8.5.2).
An invocation is animmediate invocationif it is a potentially-evaluated explicit or implicit invocation of an
immediate function and is not in an immediate function context. An aggregate initialization is an immediate
invocation if it evaluates a default member initializer that has a subexpression that is an immediate-escalating
expression.
24 A potentially-evaluated expression or conversion isimmediate-escalatingif it is neither initially in an immediate
function context nor a subexpression of an immediate invocation, and
—(24.1) it is anid-expression or splice-expression that designates an immediate function,
—(24.2) it is an immediate invocation that is not a constant expression, or
—(24.3) it is of consteval-only type (6.9.1).
25 An immediate-escalating function is
—(25.1) the call operator of a lambda that is not declared with theconsteval specifier,
—(25.2) a defaulted special member function that is not declared with theconsteval specifier, or
—(25.3) a function that is not a prospective destructor and that results from the instantiation of a templated
entity defined with theconstexpr specifier.
An immediate-escalating expression shall appear only in an immediate-escalating function.
26 An immediate functionis a function that is
§ 7.7 © ISO/IEC
181

===== PAGE 193 =====

Dxxxx
—(26.1) declared with theconsteval specifier,
—(26.2) an immediate-escalating function whose type is consteval-only (6.9.1), or
—(26.3) an immediate-escalating functionF whose function body contains either
—(26.3.1) an immediate-escalating expression or
—(26.3.2) a definition of a non-constexpr variable with consteval-only type
whose innermost enclosing non-block scope isF ’s function parameter scope.
[Note 11: Default member initializers used to initialize a base or member subobject (11.9.3) are considered to
be part of the function body (9.6.1).—end note]
[Example 14:
consteval int id(int i) { return i; }
constexpr char id(char c) { return c; }
template<class T>
constexpr int f(T t) {
return t + id(t);
}
auto a = &f<char>; // OK,f<char> is not an immediate function
auto b = &f<int>; // error: f<int> is an immediate function
static_assert(f(3) == 6); // OK
template<class T>
constexpr int g(T t) { // g<int> is not an immediate function
return t + id(42); // becauseid(42) is already a constant
}
template<class T, class F>
constexpr bool is_not(T t, F f) {
return not f(t);
}
consteval bool is_even(int i) { return i % 2 == 0; }
static_assert(is_not(5, is_even)); // OK
int x = 0;
template<class T>
constexpr T h(T t = id(x)) { // h<int> is not an immediate function
// id(x) is not evaluated when parsing the default argument (9.3.4.7, 13.9.2)
return t;
}
template<class T>
constexpr T hh() { // hh<int> is an immediate function because of the invocation
return h<T>(); // of the immediate functionid in the default argument ofh<int>
}
int i = hh<int>(); // error: hh<int>() is an immediate-escalating expression
// outside of an immediate-escalating function
struct A {
int x;
int y = id(x);
};
template<class T>
constexpr int k(int) { // k<int> is not an immediate function becauseA(42) is a
return A(42).y; // constant expression and thus not immediate-escalating
§ 7.7 © ISO/IEC
182

===== PAGE 194 =====

Dxxxx
}
constexpr int l(int c) pre(c >= 2) {
return (c % 2 == 0) ? c / 0 : c;
}
const int i0 = l(0); // dynamic initialization; contract violation or undefined behavior
const int i1 = l(1); // static initialization; value of1 or contract violation at compile time
const int i2 = l(2); // dynamic initialization; undefined behavior
const int i3 = l(3); // static initialization; value of3
—end example]
27 An expression or conversion ismanifestly constant-evaluatedif it is:
—(27.1) a constant-expression, or
—(27.2) the condition of a constexpr if statement (8.5.2), or
—(27.3) an immediate invocation, or
—(27.4) the result of substitution into an atomic constraint expression to determine whether it is satisfied
(13.5.2.3), or
—(27.5) the initializer of a variable that is usable in constant expressions or has constant initialization (6.10.3.2).65
[Example 15:
template<bool> struct X {};
X<std::is_constant_evaluated()> x; // typeX<true>
int y;
const int a = std::is_constant_evaluated() ? y : 1; // dynamic initialization to 1
double z[a]; // error: a is not usable
// in constant expressions
const int b = std::is_constant_evaluated() ? 2 : y; // static initialization to 2
int c = y + (std::is_constant_evaluated() ? 2 : y); // dynamic initialization toy+y
constexpr int f() {
const int n = std::is_constant_evaluated() ? 13 : 17; // n is 13
int m = std::is_constant_evaluated() ? 13 : 17; // m can be 13 or 17 (see below)
char arr[n] = {}; // char[13]
return m + sizeof(arr);
}
int p = f(); // m is 13; initialized to 26
int q = p + f(); // m is 17 for this call; initialized to 56
—end example]
[Note 12: Except for astatic_assert-message, a manifestly constant-evaluated expression is evaluated even in an
unevaluated operand (7.2.3). —end note]
28 The evaluation of an expression can introduce one or moreinjected declarations. The evaluation is said to
producethe declarations.
[Note 13: An invocation of the library function template std::meta::define_aggregate produces an injected
declaration (21.4.16). —end note]
Each such declaration has
—(28.1) an associatedsynthesized point, which follows the last non-synthesized program point in the translation
unit containing that declaration, and
—(28.2) an associatedcharacteristic sequenceof values.
[Note 14: Special rules concerning reachability apply to synthesized points (10.7).—end note]
[Note 15: The program is ill-formed if injected declarations with different characteristic sequences define the same
entity in different translation units (6.3).—end note]
29 A member of an entity defined by an injected declaration shall not have a name reserved to the implementation
(5.11); no diagnostic is required.
65) Testing this condition can involve a trial evaluation of its initializer, with evaluations of contract assertions using the ignore
evaluation semantic (6.11.2), as described above.
§ 7.7 © ISO/IEC
183

===== PAGE 195 =====

Dxxxx
30 Let C be aconsteval-block-declaration, the evaluation of whose corresponding expression produces an injected
declaration for an entityE. The program is ill-formed if either
—(30.1) C is enclosed by a scope associated withE or
—(30.2) letting P be a point whose immediate scope is that to whichE belongs, there is a function parameter
scope or class scope that encloses exactly one ofC or P.
[Example 16:
struct S0 {
consteval {
std::meta::define_aggregate(^^S0, {}); // error: scope associated withS0 encloses the consteval block
}
};
struct S1;
consteval { std::meta::define_aggregate(^^S1, {}); } // OK
template <std::meta::info R> consteval void tfn1() {
std::meta::define_aggregate(R, {});
}
struct S2;
consteval { tfn1<^^S2>(); } // OK
template <std::meta::info R> consteval void tfn2() {
consteval { std::meta::define_aggregate(R, {}); }
}
struct S3;
consteval { tfn2<^^S3>(); }
// error: function parameter scope oftfn2<^^S3> intervenes between the declaration ofS3
// and the consteval block that produces the injected declaration
template <typename> struct TCls {
struct S4;
static void sfn() requires ([] {
consteval { std::meta::define_aggregate(^^S4, {}); }
return true;
}()) { }
};
consteval { TCls<void>::sfn(); } // error: TCls<void>::S4 is not enclosed byrequires-clause lambda
struct S5;
struct Cls {
consteval { std::meta::define_aggregate(^^S5, {}); } // error: S5 is not enclosed by classCls
};
struct S6;
consteval { // #1
struct S7; // local class
std::meta::define_aggregate(^^S7, {}); // error: consteval block #1 does not enclose itself,
// but enclosesS7
struct S8; // local class
consteval { // #2
std::meta::define_aggregate(^^S6, {}); // error: consteval block #1 encloses
// consteval block #2 but notS6
std::meta::define_aggregate(^^S8, {}); // OK, consteval block #1 encloses both #2 andS8
}
}
§ 7.7 © ISO/IEC
184

===== PAGE 196 =====

Dxxxx
—end example]
31 The evaluation contextis a set of program points that determines the behavior of certain functions used for
reflection (21.4). During the evaluationV of an expressionE as a core constant expression, the evaluation
context of an evaluationX (6.10.1) consists of the following points:
—(31.1) The program pointEVAL-PT(L), whereL is the point at whichE appears, and whereEVAL-PT(P),
for a pointP, is a pointR determined as follows:
—(31.1.1) If a potentially-evaluated subexpression (6.10.1) of a default member initializerI appears atP,
and a (possibly aggregate) initialization duringV is usingI, thenR is EVAL-PT(Q) where Q is
the point at which that initialization appears.
—(31.1.2) Otherwise, if a potentially-evaluated subexpression of a default argument (9.3.4.7) appears at
P, and an invocation of a function (7.6.1.3) duringV is using that default argument, thenR is
EVAL-PT(Q) where Q is the point at which that invocation appears.
—(31.1.3) Otherwise, R is P.
—(31.2) Each synthesized point corresponding to an injected declaration produced by any evaluation sequenced
before X (6.10.1).
32 An expression or conversion ispotentially constant evaluatedif it is:
—(32.1) a manifestly constant-evaluated expression,
—(32.2) a potentially-evaluated expression (6.3),
—(32.3) an immediate subexpression of abraced-init-list,66
—(32.4) an expression of the form& cast-expression that occurs within a templated entity,67 or
—(32.5) a potentially-evaluated subexpression (6.10.1) of one of the above.
A function or variable isneeded for constant evaluationif it is:
—(32.6) a constexpr function that is named by an expression (6.3) that is potentially constant evaluated, or
—(32.7) a potentially-constant variable named by a potentially constant evaluated expression.
66) In some cases, constant evaluation is needed to determine whether a narrowing conversion is performed (9.5.5).
67) In some cases, constant evaluation is needed to determine whether such an expression is value-dependent (13.8.3.4).
§ 7.7 © ISO/IEC
185

===== PAGE 197 =====

Dxxxx
8 Statements [stmt]
8.1 Preamble [stmt.pre]
1 Except as indicated, statements are executed in sequence (6.10.1).
statement:
labeled-statement
attribute-specifier-seqopt expression-statement
attribute-specifier-seqopt compound-statement
attribute-specifier-seqopt selection-statement
attribute-specifier-seqopt iteration-statement
attribute-specifier-seqopt expansion-statement
attribute-specifier-seqopt jump-statement
attribute-specifier-seqopt assertion-statement
declaration-statement
attribute-specifier-seqopt try-block
init-statement:
expression-statement
simple-declaration
alias-declaration
condition:
expression
attribute-specifier-seqopt decl-specifier-seq declarator brace-or-equal-initializer
structured-binding-declaration initializer
for-range-declaration:
attribute-specifier-seqopt decl-specifier-seq declarator
structured-binding-declaration
for-range-initializer:
expr-or-braced-init-list
The optionalattribute-specifier-seq appertains to the respective statement. See 9.3.4 for the optionalattribute-
specifier-seq in afor-range-declaration.
2 A substatement of astatement is one of the following:
—(2.1) for alabeled-statement, itsstatement,
—(2.2) for acompound-statement, anystatement of itsstatement-seq,
—(2.3) for aselection-statement, any of itsstatements orcompound-statements (but not itsinit-statement),
—(2.4) for aniteration-statement, itsstatement (but not aninit-statement), or
—(2.5) for anexpansion-statement, itscompound-statement (but not aninit-statement).
[Note 1: The compound-statement of alambda-expression is not a substatement of thestatement (if any) in which the
lambda-expression lexically appears. —end note]
3 A statement S1 encloses a statement S2 if
—(3.1) S2 is a substatement ofS1,
—(3.2) S1 is aselection-statement, iteration-statement, orexpansion-statement, andS2 is theinit-statement of
S1,
—(3.3) S1 is atry-block and S2 is itscompound-statement or any of thecompound-statements of itshandlers, or
—(3.4) S1 encloses a statementS3 and S3 encloses S2.
A statementS1 is enclosed bya statementS2 if S2 encloses S1.
4 The rules forconditions apply both toselection-statements (8.5) and to thefor and while statements (8.6). If
a structured-binding-declaration appears in acondition, thecondition is a structured binding declaration (9.1).
A condition that is neither anexpression nor a structured binding declaration is a declaration (Clause 9). The
declarator shall not specify a function or an array. Thedecl-specifier-seq shall not define a class or enumeration.
§ 8.1 © ISO/IEC
186

===== PAGE 198 =====

Dxxxx
If theauto type-specifier appears in thedecl-specifier-seq, the type of the identifier being declared is deduced
from the initializer as described in 9.2.9.7.
5 The decision variableof acondition that is neither anexpression nor a structured binding declaration is the
declared variable. The decision variable of acondition that is a structured binding declaration is specified in
9.7.
6 The value of acondition that is not anexpression in a statement other than aswitch statement is the value
of the decision variable contextually converted tobool (7.3). If that conversion is ill-formed, the program is
ill-formed. The value of acondition that is an expression is the value of the expression, contextually converted
to bool for statements other thanswitch; if that conversion is ill-formed, the program is ill-formed. The
value of the condition will be referred to as simply “the condition” where the usage is unambiguous.
7 If acondition can be syntactically resolved as either an expression or a declaration, it is interpreted as the
latter.
8 Let D be anycondition or for-range-declaration. In thedecl-specifier-seq of D, including that of anystructured-
binding-declaration of D, eachdecl-specifier shall be either atype-specifier or constexpr.
8.2 Label [stmt.label]
1 A label can be added to a statement or used anywhere in acompound-statement.
label:
attribute-specifier-seqopt identifier :
attribute-specifier-seqopt case constant-expression :
attribute-specifier-seqopt default :
labeled-statement:
label statement
The optionalattribute-specifier-seq appertains to the label. The only use of a label with anidentifier is as the
target of agoto. No two labels in a function shall have the sameidentifier. A label can be used in agoto
statement before its introduction.
2 A labeled-statement whose label is acase or default label shall be enclosed by (8.1) aswitch statement
(8.5.3).
3 A control-flow-limited statementis a statementS for which:
—(3.1) a case or default label appearing withinS shall be associated with aswitch statement (8.5.3) within
S, and
—(3.2) a label declared inS shall only be referred to by a statement (8.8.6) inS.
4 An identifier label shall not be enclosed by anexpansion-statement (8.7).
8.3 Expression statement [stmt.expr]
1 Expression statements have the form
expression-statement:
expressionopt ;
The expression is a discarded-value expression (7.2.3). All side effects from an expression statement are
completed before the next statement is executed. An expression statement with theexpression missing is
called anull statement.
[Note 1: Most statements are expression statements — usually assignments or function calls. A null statement is
useful to supply a null body to an iteration statement such as awhile statement (8.6.2). —end note]
8.4 Compound statement or block [stmt.block]
1 A compound statement(also known as a block) groups a sequence of statements into a single statement.
compound-statement:
{ statement-seqopt label-seqopt }
statement-seq:
statement statement-seqopt
label-seq:
label label-seqopt
A label at the end of acompound-statement is treated as if it were followed by a null statement.
§ 8.4 © ISO/IEC
187

===== PAGE 199 =====

Dxxxx
2 [Note 1: A compound statement defines a block scope (6.4). A declaration is astatement (8.10). —end note]
8.5 Selection statements [stmt.select]
8.5.1 General [stmt.select.general]
1 Selection statements choose one of several flows of control.
selection-statement:
if constexpropt ( init-statementopt condition ) statement
if constexpropt ( init-statementopt condition ) statement else statement
if !opt consteval compound-statement
if !opt consteval compound-statement else statement
switch ( init-statementopt condition ) statement
See 9.3.4 for the optionalattribute-specifier-seq in a condition.
[Note 1: An init-statement ends with a semicolon.—end note]
2 [Note 2: Eachselection-statement and each substatement of aselection-statement has a block scope (6.4.3).—end
note]
8.5.2 The if statement [stmt.if]
1 If the condition (8.1) yieldstrue, the first substatement is executed. If theelsepart of the selection statement
is present and the condition yieldsfalse, the second substatement is executed. If the first substatement
is reached via a label, the condition is not evaluated and the second substatement is not executed. In the
second form ofif statement (the one includingelse), if the first substatement is also anif statement then
that innerif statement shall contain anelse part.68
2 If theif statement is of the formif constexpr, the value of the condition is contextually converted tobool
and the converted expression shall be a constant expression (7.7); this form is called aconstexpr if statement.
If the value of the converted condition isfalse, the first substatement is adiscarded statement, otherwise the
second substatement, if present, is a discarded statement. During the instantiation of an enclosing templated
entity (13.1), if the condition is not value-dependent after its instantiation, the discarded substatement (if any)
is not instantiated. Each substatement of a constexpr if statement is a control-flow-limited statement (8.2).
[Example 1:
if constexpr (sizeof(int[2])) {} // OK, narrowing allowed
—end example]
[Note 1: Odr-uses (6.3) in a discarded statement do not require an entity to be defined.—end note]
[Example 2:
template<typename T, typename ... Rest> void g(T&& p, Rest&& ...rs) {
// ... handlep
if constexpr (sizeof...(rs) > 0)
g(rs...); // never instantiated with an empty argument list
}
extern int x; // no definition ofx required
int f() {
if constexpr (true)
return 0;
else if (x)
return x;
else
return -x;
}
—end example]
3 An if statement of the form
if constexpropt ( init-statement condition) statement
is equivalent to
68) In other words, theelse is associated with the nearest un-elsedif.
§ 8.5.2 © ISO/IEC
188

===== PAGE 200 =====

Dxxxx
{
init-statement
if constexpropt ( condition ) statement
}
and anif statement of the form
if constexpropt ( init-statement condition) statement else statement
is equivalent to
{
init-statement
if constexpropt ( condition ) statement else statement
}
except that theinit-statement is in the same scope as thecondition.
4 An if statement of the formif consteval is called aconsteval if statement. The statement, if any, in a
consteval if statement shall be acompound-statement.
[Example 3:
constexpr void f(bool b) {
if (true)
if consteval { }
else ; // error: not acompound-statement; else not associated with outerif
}
—end example]
5 If a consteval if statement is evaluated in a context that is manifestly constant-evaluated (7.7), the first
substatement is executed.
[Note 2: The first substatement is an immediate function context.—end note]
Otherwise, if theelse part of the selection statement is present, then the second substatement is executed.
Each substatement of a consteval if statement is a control-flow-limited statement (8.2).
6 An if statement of the form
if ! constevalcompound-statement
is not itself a consteval if statement, but is equivalent to the consteval if statement
if consteval { } elsecompound-statement
An if statement of the form
if ! constevalcompound-statement1 else statement2
is not itself a consteval if statement, but is equivalent to the consteval if statement
if consteval statement2 else compound-statement1
8.5.3 The switch statement [stmt.switch]
1 The switch statement causes control to be transferred to one of several statements depending on the value
of a condition.
2 If thecondition is anexpression, the value of the condition is the value of theexpression; otherwise, it is the
value of the decision variable. The value of the condition shall be of integral type, enumeration type, or class
type. If of class type, the condition is contextually implicitly converted (7.3) to an integral or enumeration
type. If the (possibly converted) type is subject to integral promotions (7.3.7), the condition is converted to
the promoted type. Any statement within theswitch statement can be labeled with one or more case labels
as follows:
case constant-expression :
where theconstant-expression shall be a converted constant expression (7.7) of the adjusted type of the switch
condition. No two of the case constants in the same switch shall have the same value after conversion.
3 There shall be at most one label of the form
default :
within aswitch statement.
4 Switch statements can be nested; acase or default label is associated with the smallest switch enclosing it.
§ 8.5.3 © ISO/IEC
189