

===== PAGE 1201 =====

Dxxxx
24.3.5 C ++17 iterator requirements [iterator.cpp17]
24.3.5.1 General [iterator.cpp17.general]
1 In the following sections,a and b denote values of typeX or const X, difference_type and reference refer
to the typesiterator_traits<X>::difference_type and iterator_traits<X>::reference, respectively,
n denotes a value ofdifference_type, u, tmp, andm denote identifiers,r denotes a value ofX&, t denotes a
value of value typeT, o denotes a value of some type that is writable to the output iterator.
[Note 1: For an iterator typeX there must be an instantiation ofiterator_traits<X> (24.3.2.3). —end note]
24.3.5.2 Cpp17Iterator [iterator.iterators]
1 The Cpp17Iterator requirements form the basis of the iterator taxonomy; every iterator meets theCpp17-
Iterator requirements. This set of requirements specifies operations for dereferencing and incrementing an
iterator. Most algorithms will require additional operations to read (24.3.5.3) or write (24.3.5.4) values, or to
provide a richer set of iterator movements (24.3.5.5, 24.3.5.6, 24.3.5.7).
2 A typeX meets theCpp17Iterator requirements if
—(2.1) X meets theCpp17CopyConstructible, Cpp17CopyAssignable, Cpp17Swappable, andCpp17Destructible
requirements (16.4.4.2, 16.4.4.3), and
—(2.2) iterator_traits<X>::difference_type is a signed integer type orvoid, and
—(2.3) the expressions in Table 78 are valid and have the indicated semantics.
Table 78 —Cpp17Iterator requirements [tab:iterator]
Expression Return type Operational Assertion/note
semantics pre-/post-condition
*r unspecified Preconditions: r is
dereferenceable.
++r X&
24.3.5.3 Input iterators [input.iterators]
1 A class or pointer typeX meets the requirements of an input iterator for the value typeT if X meets the
Cpp17Iterator (24.3.5.2) and Cpp17EqualityComparable (Table 28) requirements and the expressions in
Table 79 are valid and have the indicated semantics.
2 In Table 79, the termthe domain of== is used in the ordinary mathematical sense to denote the set of values
over which== is (required to be) defined. This set can change over time. Each algorithm places additional
requirements on the domain of== for the iterator values it uses. These requirements can be inferred from
the uses that algorithm makes of== and !=.
[Example 1: The call find(a,b,x) is defined only if the value ofa has the propertyp defined as follows: b has
property p and a valuei has propertyp if (*i==x) or if (*i!=x and ++i has propertyp). —end example]
Table 79 —Cpp17InputIterator requirements (in addition toCpp17Iterator)
[tab:inputiterator]
Expression Return type Operational Assertion/note
semantics pre-/post-condition
a != b decltype(a !=
b) models
boolean-test-
able
!(a == b) Preconditions: (a,b) is in the
domain of==.
§ 24.3.5.3 © ISO/IEC
1190

===== PAGE 1202 =====

Dxxxx
Table 79 —Cpp17InputIterator requirements (in addition toCpp17Iterator) (continued)
Expression Return type Operational Assertion/note
semantics pre-/post-condition
*a reference ,
convertible toT
Preconditions: a is
dereferenceable.
The expression
(void)*a, *a is equivalent
to *a.
If a == b and (a,b) is in the
domain of== then *a is
equivalent to*b.
a->m (*a).m Preconditions: a is
dereferenceable.
++r X& Preconditions: r is
dereferenceable.
Postconditions: r is
dereferenceable orr is
past-the-end;
any copies of the previous
value ofr are no longer
required to be
dereferenceable nor to be in
the domain of==.
(void)r++ equivalent to(void)++r
*r++ convertible toT { T tmp = *r;
++r;
return tmp; }
3 Recommended practice: The implementation of an algorithm on input iterators should never attempt to pass
through the same iterator twice; such an algorithm should be a single pass algorithm.
[Note 1: For input iterators,a == b does not imply++a == ++b. (Equality does not guarantee the substitution
property or referential transparency.) Value typeT is not required to be aCpp17CopyAssignable type (Table 34).
Such an algorithm can be used with istreams as the source of the input data through theistream_iterator class
template. —end note]
24.3.5.4 Output iterators [output.iterators]
1 A class or pointer type X meets the requirements of an output iterator if X meets the Cpp17Iterator
requirements (24.3.5.2) and the expressions in Table 80 are valid and have the indicated semantics.
2 Recommended practice: The implementation of an algorithm on output iterators should never attempt to
pass through the same iterator twice; such an algorithm should be a single-pass algorithm.
[Note 1: The only valid use of anoperator* is on the left side of the assignment statement. Assignment through the
same value of the iterator happens only once. Equality and inequality are not necessarily defined.—end note]
24.3.5.5 Forward iterators [forward.iterators]
1 A class or pointer typeX meets theCpp17ForwardIteratorrequirements if
—(1.1) X meets theCpp17InputIterator requirements (24.3.5.3),
—(1.2) X meets theCpp17DefaultConstructible requirements (16.4.4.2),
—(1.3) if X is a mutable iterator,reference is a reference toT; if X is a constant iterator,reference is a
reference toconst T,
—(1.4) the expressions in Table 81 are valid and have the indicated semantics, and
—(1.5) objects of typeX offer the multi-pass guarantee, described below.
2 The domain of== for forward iterators is that of iterators over the same underlying sequence. However,
value-initialized iterators may be compared and shall compare equal to other value-initialized iterators of the
same type.
§ 24.3.5.5 © ISO/IEC
1191

===== PAGE 1203 =====

Dxxxx
Table 80 —Cpp17OutputIterator requirements (in addition toCpp17Iterator)
[tab:outputiterator]
Expression Return type Operational Assertion/note
semantics pre-/post-condition
*r = o result is not
used
Remarks: After this
operation r is not required to
be dereferenceable.
Postconditions: r is
incrementable.
++r X& addressof(r) ==
addressof(++r).
Remarks: After this
operation r is not required to
be dereferenceable.
Postconditions: r is
incrementable.
r++ convertible to
const X&
{ X tmp = r;
++r;
return tmp; }
Remarks: After this
operation r is not required to
be dereferenceable.
Postconditions: r is
incrementable.
*r++ = o result is not
used
Remarks: After this
operation r is not required to
be dereferenceable.
Postconditions: r is
incrementable.
[Note 1: Value-initialized iterators behave as if they refer past the end of the same empty sequence.—end note]
3 Two dereferenceable iteratorsa and b of typeX offer themulti-pass guaranteeif
—(3.1) a == b implies ++a == ++b and
—(3.2) X is a pointer type or the expression(void)++X(a), *a is equivalent to the expression*a.
4 [Note 2: The requirement thata == b implies ++a == ++b (which is not true for input and output iterators) and the
removal of the restrictions on the number of the assignments through a mutable iterator (which applies to output
iterators) allows the use of multi-pass one-directional algorithms with forward iterators.—end note]
Table 81 —Cpp17ForwardIterator requirements (in addition toCpp17InputIterator)
[tab:forwarditerator]
Expression Return type Operational Assertion/note
semantics pre-/post-condition
r++ convertible to
const X&
{ X tmp = r;
++r;
return tmp; }
*r++ reference
5 If a and b are equal, then eithera and b are both dereferenceable or else neither is dereferenceable.
6 If a and b are both dereferenceable, thena == b if and only if*a and *b are bound to the same object.
24.3.5.6 Bidirectional iterators [bidirectional.iterators]
1 A class or pointer typeX meets the requirements of a bidirectional iterator if, in addition to meeting the
Cpp17ForwardIteratorrequirements, the following expressions are valid as shown in Table 82.
2 [Note 1: Bidirectional iterators allow algorithms to move iterators backward as well as forward.—end note]
§ 24.3.5.6 © ISO/IEC
1192

===== PAGE 1204 =====

Dxxxx
Table 82 —Cpp17BidirectionalIterator requirements (in addition toCpp17ForwardIterator)
[tab:bidirectionaliterator]
Expression Return type Operational Assertion/note
semantics pre-/post-condition
--r X& Preconditions: there existss
such thatr == ++s.
Postconditions: r is
dereferenceable.
--(++r) == r.
--r == --s implies r == s.
addressof(r) ==
addressof(--r).
r-- convertible to
const X&
{ X tmp = r;
--r;
return tmp; }
*r-- reference
24.3.5.7 Random access iterators [random.access.iterators]
1 A class or pointer typeX meets the requirements of a random access iterator if, in addition to meeting the
Cpp17BidirectionalIterator requirements, the following expressions are valid as shown in Table 83.
Table 83 —Cpp17RandomAccessIterator requirements (in addition to
Cpp17BidirectionalIterator) [tab:randomaccessiterator]
Expression Return type Operational Assertion/note
semantics pre-/post-condition
r += n X& { difference_type m = n;
if (m >= 0)
while (m--)
++r;
else
while (m++)
--r;
return r; }
a + n
n + a
X { X tmp = a;
return tmp += n; }
a + n == n + a.
r -= n X& return r += -n; Preconditions: the absolute
value ofn is in the range of
representable values of
difference_type.
a - n X { X tmp = a;
return tmp -= n; }
b - a difference_-
type
return n; Preconditions: there exists a
value n of type
difference_type such that
a + n == b.
b == a + (b - a).
a[n] convertible to
reference
*(a + n)
a < b decltype(a <
b) models
boolean-test-
able
Effects: Equivalent to:return
b - a > 0;
< is a total ordering relation
§ 24.3.5.7 © ISO/IEC
1193

===== PAGE 1205 =====

Dxxxx
Table 83 —Cpp17RandomAccessIterator requirements (in addition to
Cpp17BidirectionalIterator) (continued)
Expression Return type Operational Assertion/note
semantics pre-/post-condition
a > b decltype(a >
b) models
boolean-test-
able
b < a > is a total ordering relation
opposite to<.
a >= b decltype(a >=
b) models
boolean-test-
able
!(a < b)
a <= b decltype(a <=
b) models
boolean-test-
able
!(a > b)
24.3.6 Indirect callable requirements [indirectcallable]
24.3.6.1 General [indirectcallable.general]
1 There are several concepts that group requirements of algorithms that take callable objects (22.10.3) as
arguments.
24.3.6.2 Indirect callable traits [indirectcallable.traits]
1 To implement algorithms taking projections, it is necessary to determine the projected type of an iterator’s
value type. For the exposition-only alias templateindirect-value-t , indirect-value-t <T> denotes
—(1.1) invoke_result_t<Proj&, indirect-value-t <I>> if T names projected<I, Proj>, and
—(1.2) iter_value_t<T>& otherwise.
24.3.6.3 Indirect callables [indirectcallable.indirectinvocable]
1 The indirect callable concepts are used to constrain those algorithms that accept callable objects (22.10.3) as
arguments.
namespace std {
template<class F, class I>
concept indirectly_unary_invocable =
indirectly_readable<I> &&
copy_constructible<F> &&
invocable<F&, indirect-value-t<I>> &&
invocable<F&, iter_reference_t<I>> &&
common_reference_with<
invoke_result_t<F&, indirect-value-t<I>>,
invoke_result_t<F&, iter_reference_t<I>>>;
template<class F, class I>
concept indirectly_regular_unary_invocable =
indirectly_readable<I> &&
copy_constructible<F> &&
regular_invocable<F&, indirect-value-t<I>> &&
regular_invocable<F&, iter_reference_t<I>> &&
common_reference_with<
invoke_result_t<F&, indirect-value-t<I>>,
invoke_result_t<F&, iter_reference_t<I>>>;
template<class F, class I>
concept indirect_unary_predicate =
indirectly_readable<I> &&
copy_constructible<F> &&
predicate<F&, indirect-value-t<I>> &&
predicate<F&, iter_reference_t<I>>;
§ 24.3.6.3 © ISO/IEC
1194

===== PAGE 1206 =====

Dxxxx
template<class F, class I1, class I2>
concept indirect_binary_predicate =
indirectly_readable<I1> && indirectly_readable<I2> &&
copy_constructible<F> &&
predicate<F&, indirect-value-t<I1>, indirect-value-t<I2>> &&
predicate<F&, indirect-value-t<I1>, iter_reference_t<I2>> &&
predicate<F&, iter_reference_t<I1>, indirect-value-t<I2>> &&
predicate<F&, iter_reference_t<I1>, iter_reference_t<I2>>;
template<class F, class I1, class I2 = I1>
concept indirect_equivalence_relation =
indirectly_readable<I1> && indirectly_readable<I2> &&
copy_constructible<F> &&
equivalence_relation<F&, indirect-value-t<I1>, indirect-value-t<I2>> &&
equivalence_relation<F&, indirect-value-t<I1>, iter_reference_t<I2>> &&
equivalence_relation<F&, iter_reference_t<I1>, indirect-value-t<I2>> &&
equivalence_relation<F&, iter_reference_t<I1>, iter_reference_t<I2>>;
template<class F, class I1, class I2 = I1>
concept indirect_strict_weak_order =
indirectly_readable<I1> && indirectly_readable<I2> &&
copy_constructible<F> &&
strict_weak_order<F&, indirect-value-t<I1>, indirect-value-t<I2>> &&
strict_weak_order<F&, indirect-value-t<I1>, iter_reference_t<I2>> &&
strict_weak_order<F&, iter_reference_t<I1>, indirect-value-t<I2>> &&
strict_weak_order<F&, iter_reference_t<I1>, iter_reference_t<I2>>;
}
24.3.6.4 Alias template projected [projected]
1 Alias templateprojectedis used to constrain algorithms that accept callable objects and projections (3.44). It
combines anindirectly_readable type I and a callable object typeProj into a newindirectly_readable
type whosereference type is the result of applyingProj to theiter_reference_t of I.
namespace std {
template<class I, class Proj>
struct projected-impl { // exposition only
struct type { // exposition only
using value_type = remove_cvref_t<indirect_result_t<Proj&, I>>;
using difference_type = iter_difference_t<I>; // present only ifI
// modelsweakly_incrementable
indirect_result_t<Proj&, I> operator*() const; // not defined
};
};
template<indirectly_readable I, indirectly_regular_unary_invocable<I> Proj>
using projected = projected-impl <I, Proj>::type ;
}
24.3.7 Common algorithm requirements [alg.req]
24.3.7.1 General [alg.req.general]
1 There are several additional iterator concepts that are commonly applied to families of algorithms. These
group together iterator requirements of algorithm families. There are three relational concepts that spec-
ify how element values are transferred betweenindirectly_readable and indirectly_writable types:
indirectly_movable, indirectly_copyable, andindirectly_swappable. There are three relational con-
cepts for rearrangements: permutable, mergeable, and sortable. There is one relational concept for
comparing values from different sequences:indirectly_comparable.
2 [Note 1: The ranges::less function object type used in the concepts below imposes constraints on the concepts’
arguments in addition to those that appear in the concepts’ bodies (22.10.9).—end note]
24.3.7.2 Concept indirectly_movable [alg.req.ind.move]
1 The indirectly_movable concept specifies the relationship between anindirectly_readable type and an
indirectly_writable type between which values may be moved.
§ 24.3.7.2 © ISO/IEC
1195

===== PAGE 1207 =====

Dxxxx
template<class In, class Out>
concept indirectly_movable =
indirectly_readable<In> &&
indirectly_writable<Out, iter_rvalue_reference_t<In>>;
2 The indirectly_movable_storable concept augmentsindirectly_movable with additional requirements
enabling the transfer to be performed through an intermediate object of theindirectly_readable type’s
value type.
template<class In, class Out>
concept indirectly_movable_storable =
indirectly_movable<In, Out> &&
indirectly_writable<Out, iter_value_t<In>> &&
movable<iter_value_t<In>> &&
constructible_from<iter_value_t<In>, iter_rvalue_reference_t<In>> &&
assignable_from<iter_value_t<In>&, iter_rvalue_reference_t<In>>;
3 Let i be a dereferenceable value of typeIn. In and Out model indirectly_movable_storable<In, Out>
only if after the initialization of the objectobj in
iter_value_t<In> obj(ranges::iter_move(i));
obj is equal to the value previously denoted by*i. If iter_rvalue_reference_t<In> is an rvalue reference
type, the resulting state of the value denoted by*i is valid but unspecified (16.4.6.17).
24.3.7.3 Concept indirectly_copyable [alg.req.ind.copy]
1 The indirectly_copyable concept specifies the relationship between anindirectly_readable type and
an indirectly_writable type between which values may be copied.
template<class In, class Out>
concept indirectly_copyable =
indirectly_readable<In> &&
indirectly_writable<Out, iter_reference_t<In>>;
2 The indirectly_copyable_storable concept augments indirectly_copyable with additional require-
ments enabling the transfer to be performed through an intermediate object of theindirectly_readable
type’s value type. It also requires the capability to make copies of values.
template<class In, class Out>
concept indirectly_copyable_storable =
indirectly_copyable<In, Out> &&
indirectly_writable<Out, iter_value_t<In>&> &&
indirectly_writable<Out, const iter_value_t<In>&> &&
indirectly_writable<Out, iter_value_t<In>&&> &&
indirectly_writable<Out, const iter_value_t<In>&&> &&
copyable<iter_value_t<In>> &&
constructible_from<iter_value_t<In>, iter_reference_t<In>> &&
assignable_from<iter_value_t<In>&, iter_reference_t<In>>;
3 Let i be a dereferenceable value of typeIn. In and Out model indirectly_copyable_storable<In, Out>
only if after the initialization of the objectobj in
iter_value_t<In> obj(*i);
obj is equal to the value previously denoted by*i. If iter_reference_t<In> is an rvalue reference type,
the resulting state of the value denoted by*i is valid but unspecified (16.4.6.17).
24.3.7.4 Concept indirectly_swappable [alg.req.ind.swap]
1 The indirectly_swappable concept specifies a swappable relationship between the values referenced by two
indirectly_readable types.
template<class I1, class I2 = I1>
concept indirectly_swappable =
indirectly_readable<I1> && indirectly_readable<I2> &&
requires(const I1 i1, const I2 i2) {
ranges::iter_swap(i1, i1);
ranges::iter_swap(i2, i2);
ranges::iter_swap(i1, i2);
ranges::iter_swap(i2, i1);
§ 24.3.7.4 © ISO/IEC
1196

===== PAGE 1208 =====

Dxxxx
};
24.3.7.5 Concept indirectly_comparable [alg.req.ind.cmp]
1 The indirectly_comparable concept specifies the common requirements of algorithms that compare values
from two different sequences.
template<class I1, class I2, class R, class P1 = identity,
class P2 = identity>
concept indirectly_comparable =
indirect_binary_predicate<R, projected<I1, P1>, projected<I2, P2>>;
24.3.7.6 Concept permutable [alg.req.permutable]
1 The permutable concept specifies the common requirements of algorithms that reorder elements in place by
moving or swapping them.
template<class I>
concept permutable =
forward_iterator<I> &&
indirectly_movable_storable<I, I> &&
indirectly_swappable<I, I>;
24.3.7.7 Concept mergeable [alg.req.mergeable]
1 The mergeable concept specifies the requirements of algorithms that merge sorted sequences into an output
sequence by copying elements.
template<class I1, class I2, class Out, class R = ranges::less,
class P1 = identity, class P2 = identity>
concept mergeable =
input_iterator<I1> &&
input_iterator<I2> &&
weakly_incrementable<Out> &&
indirectly_copyable<I1, Out> &&
indirectly_copyable<I2, Out> &&
indirect_strict_weak_order<R, projected<I1, P1>, projected<I2, P2>>;
24.3.7.8 Concept sortable [alg.req.sortable]
1 The sortable concept specifies the common requirements of algorithms that permute sequences into ordered
sequences (e.g.,sort).
template<class I, class R = ranges::less, class P = identity>
concept sortable =
permutable<I> &&
indirect_strict_weak_order<R, projected<I, P>>;
24.4 Iterator primitives [iterator.primitives]
24.4.1 General [iterator.primitives.general]
1 To simplify the use of iterators, the library provides several classes and functions.
24.4.2 Standard iterator tags [std.iterator.tags]
1 It is often desirable for a function template specialization to find out what is the most specific cate-
gory of its iterator argument, so that the function can select the most efficient algorithm at compile
time. To facilitate this, the library introducescategory tagclasses which are used as compile time tags
for algorithm selection. They are:output_iterator_tag, input_iterator_tag, forward_iterator_tag,
bidirectional_iterator_tag, random_access_iterator_tag, andcontiguous_iterator_tag. For every
iterator of typeI, iterator_traits<I>::iterator_category shall be defined to be a category tag that
describes the iterator’s behavior. Additionally,iterator_traits<I>::iterator_concept may be used to
indicate conformance to the iterator concepts (24.3.4).
namespace std {
struct output_iterator_tag { };
struct input_iterator_tag { };
struct forward_iterator_tag: public input_iterator_tag { };
struct bidirectional_iterator_tag: public forward_iterator_tag { };
§ 24.4.2 © ISO/IEC
1197

===== PAGE 1209 =====

Dxxxx
struct random_access_iterator_tag: public bidirectional_iterator_tag { };
struct contiguous_iterator_tag: public random_access_iterator_tag { };
}
2 [Example 1: A program-defined iteratorBinaryTreeIterator can be included into the bidirectional iterator category
by specializing theiterator_traits template:
template<class T> struct iterator_traits<BinaryTreeIterator<T>> {
using iterator_category = bidirectional_iterator_tag;
using difference_type = ptrdiff_t;
using value_type = T;
using pointer = T*;
using reference = T&;
};
—end example]
3 [Example 2: If evolve() is well-defined for bidirectional iterators, but can be implemented more efficiently for random
access iterators, then the implementation is as follows:
template<class BidirectionalIterator>
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {
evolve(first, last,
typename iterator_traits<BidirectionalIterator>::iterator_category());
}
template<class BidirectionalIterator>
void evolve(BidirectionalIterator first, BidirectionalIterator last,
bidirectional_iterator_tag) {
// more generic, but less efficient algorithm
}
template<class RandomAccessIterator>
void evolve(RandomAccessIterator first, RandomAccessIterator last,
random_access_iterator_tag) {
// more efficient, but less generic algorithm
}
—end example]
24.4.3 Iterator operations [iterator.operations]
1 Since only random access iterators provide+ and - operators, the library provides two function templates
advance and distance. These function templates use+ and - for random access iterators (and are, therefore,
constant time for them); for input, forward and bidirectional iterators they use++ to provide linear time
implementations.
template<class InputIterator, class Distance>
constexpr void advance(InputIterator& i, Distance n);
2 Preconditions: n is negative only for bidirectional iterators.
3 Effects: Incrementsi by n if n is non-negative, and decrementsi by -n otherwise.
template<class InputIterator>
constexpr typename iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last);
4 Preconditions: last is reachable fromfirst, orInputIterator meets theCpp17RandomAccessIterator
requirements andfirst is reachable fromlast.
5 Effects: If InputIterator meets the Cpp17RandomAccessIterator requirements, returns (last -
first); otherwise, incrementsfirst until last is reached and returns the number of increments.
template<class InputIterator>
constexpr InputIterator next(InputIterator x,
typename iterator_traits<InputIterator>::difference_type n = 1);
6 Effects: Equivalent to:advance(x, n); return x;
§ 24.4.3 © ISO/IEC
1198

===== PAGE 1210 =====

Dxxxx
template<class BidirectionalIterator>
constexpr BidirectionalIterator prev(BidirectionalIterator x,
typename iterator_traits<BidirectionalIterator>::difference_type n = 1);
7 Effects: Equivalent to:advance(x, -n); return x;
24.4.4 Range iterator operations [range.iter.ops]
24.4.4.1 General [range.iter.ops.general]
1 The library includes the function templatesranges::advance, ranges::distance, ranges::next, and
ranges::prev to manipulate iterators. These operations adapt to the set of operators provided by each
iterator category to provide the most efficient implementation possible for a concrete iterator type.
[Example 1: ranges::advance uses the+ operator to move arandom_access_iterator forward n steps in constant
time. For an iterator type that does not modelrandom_access_iterator, ranges::advance instead performs n
individual increments with the++ operator. —end example]
2 The entities defined in 24.4.4 are algorithm function objects (16.3.3.4).
24.4.4.2 ranges::advance [range.iter.op.advance]
template<input_or_output_iterator I>
constexpr void ranges::advance(I& i, iter_difference_t<I> n);
1 Preconditions: If I does not modelbidirectional_iterator, n is not negative.
2 Effects:
—(2.1) If I models random_access_iterator, equivalent toi += n.
—(2.2) Otherwise, ifn is non-negative, incrementsi by n.
—(2.3) Otherwise, decrementsi by -n.
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr void ranges::advance(I& i, S bound);
3 Preconditions: Either assignable_from<I&, S> || sized_sentinel_for<S, I> is modeled, or[i,
bound) denotes a range.
4 Effects:
—(4.1) If I and S model assignable_from<I&, S>, equivalent toi = std::move(bound).
—(4.2) Otherwise, if S and I model sized_sentinel_for<S, I>, equivalent toranges::advance(i,
bound - i).
—(4.3) Otherwise, whilebool(i != bound) is true, incrementsi.
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr iter_difference_t<I> ranges::advance(I& i, iter_difference_t<I> n, S bound);
5 Preconditions: If n > 0, [i,bound) denotes a range. If n == 0, [i,bound) or [bound,i) denotes a
range. If n < 0, [bound,i) denotes a range,I models bidirectional_iterator, andI and S model
same_as<I, S>.
6 Effects:
—(6.1) If S and I model sized_sentinel_for<S, I>:
—(6.1.1) If |n|≥| bound - i|, equivalent toranges::advance(i, bound).
—(6.1.2) Otherwise, equivalent toranges::advance(i, n).
—(6.2) Otherwise,
—(6.2.1) if n is non-negative, whilebool(i != bound) is true, incrementsi but at mostn times.
—(6.2.2) Otherwise, whilebool(i != bound) is true, decrementsi but at most-n times.
7 Returns: n - M, whereM is the difference between the ending and starting positions ofi.
§ 24.4.4.2 © ISO/IEC
1199

===== PAGE 1211 =====

Dxxxx
24.4.4.3 ranges::distance [range.iter.op.distance]
template<class I, sentinel_for<I> S>
requires (!sized_sentinel_for<S, I>)
constexpr iter_difference_t<I> ranges::distance(I first, S last);
1 Preconditions: [first,last) denotes a range.
2 Effects: Incrementsfirst until last is reached and returns the number of increments.
template<class I, sized_sentinel_for<decay_t<I>> S>
constexpr iter_difference_t<decay_t<I>> ranges::distance(I&& first, S last);
3 Effects: Equivalent to:
if constexpr (!is_array_v<remove_reference_t<I>>)
return last - first;
else
return last - static_cast<decay_t<I>>(first);
template<range R>
constexpr range_difference_t<R> ranges::distance(R&& r);
4 Effects: If R models sized_range, equivalent to:
return static_cast<range_difference_t<R>>(ranges::size(r)); // 25.3.10
Otherwise, equivalent to:
return ranges::distance(ranges::begin(r), ranges::end(r)); // 25.3
24.4.4.4 ranges::next [range.iter.op.next]
template<input_or_output_iterator I>
constexpr I ranges::next(I x);
1 Effects: Equivalent to:++x; return x;
template<input_or_output_iterator I>
constexpr I ranges::next(I x, iter_difference_t<I> n);
2 Effects: Equivalent to:ranges::advance(x, n); return x;
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr I ranges::next(I x, S bound);
3 Effects: Equivalent to:ranges::advance(x, bound); return x;
template<input_or_output_iterator I, sentinel_for<I> S>
constexpr I ranges::next(I x, iter_difference_t<I> n, S bound);
4 Effects: Equivalent to:ranges::advance(x, n, bound); return x;
24.4.4.5 ranges::prev [range.iter.op.prev]
template<bidirectional_iterator I>
constexpr I ranges::prev(I x);
1 Effects: Equivalent to:--x; return x;
template<bidirectional_iterator I>
constexpr I ranges::prev(I x, iter_difference_t<I> n);
2 Effects: Equivalent to:ranges::advance(x, -n); return x;
template<bidirectional_iterator I>
constexpr I ranges::prev(I x, iter_difference_t<I> n, I bound);
3 Effects: Equivalent to:ranges::advance(x, -n, bound); return x;
§ 24.4.4.5 © ISO/IEC
1200

===== PAGE 1212 =====

Dxxxx
24.5 Iterator adaptors [predef.iterators]
24.5.1 Reverse iterators [reverse.iterators]
24.5.1.1 General [reverse.iterators.general]
1 Class templatereverse_iterator is an iterator adaptor that iterates from the end of the sequence defined
by its underlying iterator to the beginning of that sequence.
24.5.1.2 Class template reverse_iterator [reverse.iterator]
namespace std {
template<class Iterator>
class reverse_iterator {
public:
using iterator_type = Iterator;
using iterator_concept = see below ;
using iterator_category = see below ;
using value_type = iter_value_t<Iterator>;
using difference_type = iter_difference_t<Iterator>;
using pointer = iterator_traits<Iterator>::pointer;
using reference = iter_reference_t<Iterator>;
constexpr reverse_iterator();
constexpr explicit reverse_iterator(Iterator x);
template<class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
template<class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);
constexpr Iterator base() const;
constexpr reference operator*() const;
constexpr pointer operator->() const requires see below ;
constexpr reverse_iterator& operator++();
constexpr reverse_iterator operator++(int);
constexpr reverse_iterator& operator--();
constexpr reverse_iterator operator--(int);
constexpr reverse_iterator operator+ (difference_type n) const;
constexpr reverse_iterator& operator+=(difference_type n);
constexpr reverse_iterator operator- (difference_type n) const;
constexpr reverse_iterator& operator-=(difference_type n);
constexpr unspecified operator[](difference_type n) const;
friend constexpr iter_rvalue_reference_t<Iterator>
iter_move(const reverse_iterator& i) noexcept(see below );
template<indirectly_swappable<Iterator> Iterator2>
friend constexpr void
iter_swap(const reverse_iterator& x,
const reverse_iterator<Iterator2>& y) noexcept(see below );
protected:
Iterator current;
};
}
1 The membertypedef-name iterator_concept denotes
—(1.1) random_access_iterator_tag if Iterator models random_access_iterator, and
—(1.2) bidirectional_iterator_tag otherwise.
2 The membertypedef-name iterator_category denotes
—(2.1) random_access_iterator_tag if the typeiterator_traits<Iterator>::iterator_category mod-
els derived_from<random_access_iterator_tag>, and
—(2.2) iterator_traits<Iterator>::iterator_category otherwise.
§ 24.5.1.2 © ISO/IEC
1201

===== PAGE 1213 =====

Dxxxx
24.5.1.3 Requirements [reverse.iter.requirements]
1 The template parameterIteratorshall either meet the requirements of aCpp17BidirectionalIterator(24.3.5.6)
or modelbidirectional_iterator (24.3.4.12).
2 Additionally,Iterator shall either meet the requirements of aCpp17RandomAccessIterator(24.3.5.7) or
model random_access_iterator (24.3.4.13) if the definitions of any of the members
—(2.1) operator+, operator-, operator+=, operator-= (24.5.1.7), or
—(2.2) operator[] (24.5.1.6),
or the non-member operators (24.5.1.8)
—(2.3) operator<, operator>, operator<=, operator>=, operator-, oroperator+ (24.5.1.9)
are instantiated (13.9.2).
24.5.1.4 Construction and assignment [reverse.iter.cons]
constexpr reverse_iterator();
1 Effects: Value-initializescurrent.
constexpr explicit reverse_iterator(Iterator x);
2 Effects: Initializes current with x.
template<class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
3 Constraints: is_same_v<U, Iterator> is false and const U& models convertible_to<Iterator>.
4 Effects: Initializes current with u.current.
template<class U>
constexpr reverse_iterator&
operator=(const reverse_iterator<U>& u);
5 Constraints: is_same_v<U, Iterator> is false, const U& models convertible_to<Iterator>, and
assignable_from<Iterator&, const U&> is modeled.
6 Effects: Assigns u.current to current.
7 Returns: *this.
24.5.1.5 Conversion [reverse.iter.conv]
constexpr Iterator base() const;
1 Returns: current.
24.5.1.6 Element access [reverse.iter.elem]
constexpr reference operator*() const;
1 Effects: As if by:
Iterator tmp = current;
return *--tmp;
constexpr pointer operator->() const
requires (is_pointer_v<Iterator> ||
requires(const Iterator i) { i.operator->(); });
2 Effects:
—(2.1) If Iterator is a pointer type, equivalent to:return prev(current);
—(2.2) Otherwise, equivalent to:return prev(current).operator->();
constexpr unspecified operator[](difference_type n) const;
3 Returns: current[-n - 1].
§ 24.5.1.6 © ISO/IEC
1202

===== PAGE 1214 =====

Dxxxx
24.5.1.7 Navigation [reverse.iter.nav]
constexpr reverse_iterator operator+(difference_type n) const;
1 Returns: reverse_iterator(current - n).
constexpr reverse_iterator operator-(difference_type n) const;
2 Returns: reverse_iterator(current + n).
constexpr reverse_iterator& operator++();
3 Effects: As if by:--current;
4 Returns: *this.
constexpr reverse_iterator operator++(int);
5 Effects: As if by:
reverse_iterator tmp = *this;
--current;
return tmp;
constexpr reverse_iterator& operator--();
6 Effects: As if by++current.
7 Returns: *this.
constexpr reverse_iterator operator--(int);
8 Effects: As if by:
reverse_iterator tmp = *this;
++current;
return tmp;
constexpr reverse_iterator& operator+=(difference_type n);
9 Effects: As if by:current -= n;
10 Returns: *this.
constexpr reverse_iterator& operator-=(difference_type n);
11 Effects: As if by:current += n;
12 Returns: *this.
24.5.1.8 Comparisons [reverse.iter.cmp]
template<class Iterator1, class Iterator2>
constexpr bool operator==(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
1 Constraints: x.base() == y.base() is well-formed and convertible tobool.
2 Returns: x.base() == y.base().
template<class Iterator1, class Iterator2>
constexpr bool operator!=(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
3 Constraints: x.base() != y.base() is well-formed and convertible tobool.
4 Returns: x.base() != y.base().
template<class Iterator1, class Iterator2>
constexpr bool operator<(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
5 Constraints: x.base() > y.base() is well-formed and convertible tobool.
§ 24.5.1.8 © ISO/IEC
1203

===== PAGE 1215 =====

Dxxxx
6 Returns: x.base() > y.base().
template<class Iterator1, class Iterator2>
constexpr bool operator>(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
7 Constraints: x.base() < y.base() is well-formed and convertible tobool.
8 Returns: x.base() < y.base().
template<class Iterator1, class Iterator2>
constexpr bool operator<=(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
9 Constraints: x.base() >= y.base() is well-formed and convertible tobool.
10 Returns: x.base() >= y.base().
template<class Iterator1, class Iterator2>
constexpr bool operator>=(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
11 Constraints: x.base() <= y.base() is well-formed and convertible tobool.
12 Returns: x.base() <= y.base().
template<class Iterator1, three_way_comparable_with<Iterator1> Iterator2>
constexpr compare_three_way_result_t<Iterator1, Iterator2>
operator<=>(const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y);
13 Returns: y.base() <=> x.base().
14 [Note 1: The argument order in theReturns: element is reversed because this is a reverse iterator.—end note]
24.5.1.9 Non-member functions [reverse.iter.nonmember]
template<class Iterator1, class Iterator2>
constexpr auto operator-(
const reverse_iterator<Iterator1>& x,
const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
1 Returns: y.base() - x.base().
template<class Iterator>
constexpr reverse_iterator<Iterator> operator+(
iter_difference_t<Iterator> n,
const reverse_iterator<Iterator>& x);
2 Returns: reverse_iterator<Iterator>(x.base() - n).
friend constexpr iter_rvalue_reference_t<Iterator>
iter_move(const reverse_iterator& i) noexcept(see below );
3 Effects: Equivalent to:
auto tmp = i.base();
return ranges::iter_move(--tmp);
4 Remarks: The exception specification is equivalent to:
is_nothrow_copy_constructible_v<Iterator> &&
noexcept(ranges::iter_move(--declval<Iterator&>()))
template<indirectly_swappable<Iterator> Iterator2>
friend constexpr void
iter_swap(const reverse_iterator& x,
const reverse_iterator<Iterator2>& y) noexcept(see below );
5 Effects: Equivalent to:
§ 24.5.1.9 © ISO/IEC
1204

===== PAGE 1216 =====

Dxxxx
auto xtmp = x.base();
auto ytmp = y.base();
ranges::iter_swap(--xtmp, --ytmp);
6 Remarks: The exception specification is equivalent to:
is_nothrow_copy_constructible_v<Iterator> &&
is_nothrow_copy_constructible_v<Iterator2> &&
noexcept(ranges::iter_swap(--declval<Iterator&>(), --declval<Iterator2&>()))
template<class Iterator>
constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i);
7 Returns: reverse_iterator<Iterator>(i).
24.5.2 Insert iterators [insert.iterators]
24.5.2.1 General [insert.iterators.general]
1 To make it possible to deal with insertion in the same way as writing into an array, a special kind of iterator
adaptors, calledinsert iterators, are provided in the library. With regular iterator classes,
while (first != last) *result++ = *first++;
causes a range[first,last) to be copied into a range starting with result. The same code withresult
being an insert iterator will insert corresponding elements into the container. This device allows all of the
copying algorithms in the library to work in theinsert modeinstead of theregular overwritemode.
2 An insert iterator is constructed from a container and possibly one of its iterators pointing to where
insertion takes place if it is neither at the beginning nor at the end of the container. Insert iterators
meet the requirements of output iterators.operator* returns the insert iterator itself. The assignment
operator=(const T& x) is defined on insert iterators to allow writing into them, it insertsx right before
where the insert iterator is pointing. In other words, an insert iterator is like a cursor pointing into the
container where the insertion takes place.back_insert_iterator inserts elements at the end of a container,
front_insert_iterator inserts elements at the beginning of a container, andinsert_iterator inserts
elements where the iterator points to in a container.back_inserter, front_inserter, andinserter are
three functions making the insert iterators out of a container.
24.5.2.2 Class template back_insert_iterator [back.insert.iterator]
24.5.2.2.1 General [back.insert.iter.general]
namespace std {
template<class Container>
class back_insert_iterator {
protected:
Container* container;
public:
using iterator_category = output_iterator_tag;
using value_type = void;
using difference_type = ptrdiff_t;
using pointer = void;
using reference = void;
using container_type = Container;
constexpr explicit back_insert_iterator(Container& x);
constexpr back_insert_iterator& operator=(const typename Container::value_type& value);
constexpr back_insert_iterator& operator=(typename Container::value_type&& value);
constexpr back_insert_iterator& operator*();
constexpr back_insert_iterator& operator++();
constexpr back_insert_iterator operator++(int);
};
}
§ 24.5.2.2.1 © ISO/IEC
1205

===== PAGE 1217 =====

Dxxxx
24.5.2.2.2 Operations [back.insert.iter.ops]
constexpr explicit back_insert_iterator(Container& x);
1 Effects: Initializes container with addressof(x).
constexpr back_insert_iterator& operator=(const typename Container::value_type& value);
2 Effects: As if by:container->push_back(value);
3 Returns: *this.
constexpr back_insert_iterator& operator=(typename Container::value_type&& value);
4 Effects: As if by:container->push_back(std::move(value));
5 Returns: *this.
constexpr back_insert_iterator& operator*();
6 Returns: *this.
constexpr back_insert_iterator& operator++();
constexpr back_insert_iterator operator++(int);
7 Returns: *this.
24.5.2.2.3 back_inserter [back.inserter]
template<class Container>
constexpr back_insert_iterator<Container> back_inserter(Container& x);
1 Returns: back_insert_iterator<Container>(x).
24.5.2.3 Class template front_insert_iterator [front.insert.iterator]
24.5.2.3.1 General [front.insert.iter.general]
namespace std {
template<class Container>
class front_insert_iterator {
protected:
Container* container;
public:
using iterator_category = output_iterator_tag;
using value_type = void;
using difference_type = ptrdiff_t;
using pointer = void;
using reference = void;
using container_type = Container;
constexpr explicit front_insert_iterator(Container& x);
constexpr front_insert_iterator& operator=(const typename Container::value_type& value);
constexpr front_insert_iterator& operator=(typename Container::value_type&& value);
constexpr front_insert_iterator& operator*();
constexpr front_insert_iterator& operator++();
constexpr front_insert_iterator operator++(int);
};
}
24.5.2.3.2 Operations [front.insert.iter.ops]
constexpr explicit front_insert_iterator(Container& x);
1 Effects: Initializes container with addressof(x).
constexpr front_insert_iterator& operator=(const typename Container::value_type& value);
2 Effects: As if by:container->push_front(value);
3 Returns: *this.
§ 24.5.2.3.2 © ISO/IEC
1206

===== PAGE 1218 =====

Dxxxx
constexpr front_insert_iterator& operator=(typename Container::value_type&& value);
4 Effects: As if by:container->push_front(std::move(value));
5 Returns: *this.
constexpr front_insert_iterator& operator*();
6 Returns: *this.
constexpr front_insert_iterator& operator++();
constexpr front_insert_iterator operator++(int);
7 Returns: *this.
24.5.2.3.3 front_inserter [front.inserter]
template<class Container>
constexpr front_insert_iterator<Container> front_inserter(Container& x);
1 Returns: front_insert_iterator<Container>(x).
24.5.2.4 Class template insert_iterator [insert.iterator]
24.5.2.4.1 General [insert.iter.general]
namespace std {
template<class Container>
class insert_iterator {
protected:
Container* container;
ranges::iterator_t<Container> iter;
public:
using iterator_category = output_iterator_tag;
using value_type = void;
using difference_type = ptrdiff_t;
using pointer = void;
using reference = void;
using container_type = Container;
constexpr insert_iterator(Container& x, ranges::iterator_t<Container> i);
constexpr insert_iterator& operator=(const typename Container::value_type& value);
constexpr insert_iterator& operator=(typename Container::value_type&& value);
constexpr insert_iterator& operator*();
constexpr insert_iterator& operator++();
constexpr insert_iterator& operator++(int);
};
}
24.5.2.4.2 Operations [insert.iter.ops]
constexpr insert_iterator(Container& x, ranges::iterator_t<Container> i);
1 Effects: Initializes container with addressof(x) and iter with i.
constexpr insert_iterator& operator=(const typename Container::value_type& value);
2 Effects: As if by:
iter = container->insert(iter, value);
++iter;
3 Returns: *this.
constexpr insert_iterator& operator=(typename Container::value_type&& value);
4 Effects: As if by:
iter = container->insert(iter, std::move(value));
++iter;
5 Returns: *this.
§ 24.5.2.4.2 © ISO/IEC
1207

===== PAGE 1219 =====

Dxxxx
constexpr insert_iterator& operator*();
6 Returns: *this.
constexpr insert_iterator& operator++();
constexpr insert_iterator& operator++(int);
7 Returns: *this.
24.5.2.4.3 inserter [inserter]
template<class Container>
constexpr insert_iterator<Container>
inserter(Container& x, ranges::iterator_t<Container> i);
1 Returns: insert_iterator<Container>(x, i).
24.5.3 Constant iterators and sentinels [const.iterators]
24.5.3.1 General [const.iterators.general]
1 Class template basic_const_iterator is an iterator adaptor with the same behavior as the underlying
iterator except that its indirection operator implicitly converts the value returned by the underlying iterator’s
indirection operator to a type such that the adapted iterator is a constant iterator (24.3). Some generic
algorithms can be called with constant iterators to avoid mutation.
2 Specializations of basic_const_iterator are constant iterators.
24.5.3.2 Alias templates [const.iterators.alias]
template<indirectly_readable It>
using iter_const_reference_t =
common_reference_t<const iter_value_t<It>&&, iter_reference_t<It>>;
template<class It>
concept constant-iterator = // exposition only
input_iterator<It> && same_as<iter_const_reference_t<It>, iter_reference_t<It>>;
template<input_iterator I>
using const_iterator = see below ;
1 Result: If I models constant-iterator , I. Otherwise, basic_const_iterator<I>.
template<semiregular S>
using const_sentinel = see below ;
2 Result: If S models input_iterator, const_iterator<S>. Otherwise, S.
24.5.3.3 Class template basic_const_iterator [const.iterators.iterator]
namespace std {
template<class I>
concept not-a-const-iterator = see below ; // exposition only
template<indirectly_readable I>
using iter-const-rvalue-reference-t = // exposition only
common_reference_t<const iter_value_t<I>&&, iter_rvalue_reference_t<I>>;
template<input_iterator Iterator>
class basic_const_iterator {
Iterator current_ = Iterator(); // exposition only
using reference = iter_const_reference_t<Iterator>; // exposition only
using rvalue-reference = // exposition only
iter-const-rvalue-reference-t <Iterator>;
public:
using iterator_type = Iterator;
using iterator_concept = see below ;
using iterator_category = see below ; // not always present
using value_type = iter_value_t<Iterator>;
§ 24.5.3.3 © ISO/IEC
1208

===== PAGE 1220 =====

Dxxxx
using difference_type = iter_difference_t<Iterator>;
basic_const_iterator() requires default_initializable<Iterator> = default;
constexpr basic_const_iterator(Iterator current);
template<convertible_to<Iterator> U>
constexpr basic_const_iterator(basic_const_iterator<U> current);
template<different-from <basic_const_iterator> T>
requires convertible_to<T, Iterator>
constexpr basic_const_iterator(T&& current);
constexpr const Iterator& base() const & noexcept;
constexpr Iterator base() &&;
constexpr reference operator*() const;
constexpr const auto* operator->() const
requires is_lvalue_reference_v<iter_reference_t<Iterator>> &&
same_as<remove_cvref_t<iter_reference_t<Iterator>>, value_type>;
constexpr basic_const_iterator& operator++();
constexpr void operator++(int);
constexpr basic_const_iterator operator++(int) requires forward_iterator<Iterator>;
constexpr basic_const_iterator& operator--() requires bidirectional_iterator<Iterator>;
constexpr basic_const_iterator operator--(int) requires bidirectional_iterator<Iterator>;
constexpr basic_const_iterator& operator+=(difference_type n)
requires random_access_iterator<Iterator>;
constexpr basic_const_iterator& operator-=(difference_type n)
requires random_access_iterator<Iterator>;
constexpr reference operator[](difference_type n) const
requires random_access_iterator<Iterator>;
template<sentinel_for<Iterator> S>
constexpr bool operator==(const S& s) const;
template<not-a-const-iterator CI>
requires constant-iterator <CI> && convertible_to<Iterator const&, CI>
constexpr operator CI() const &;
template<not-a-const-iterator CI>
requires constant-iterator <CI> && convertible_to<Iterator, CI>
constexpr operator CI() &&;
constexpr bool operator<(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr bool operator>(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr bool operator<=(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr bool operator>=(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr auto operator<=>(const basic_const_iterator& y) const
requires random_access_iterator<Iterator> && three_way_comparable<Iterator>;
template<different-from <basic_const_iterator> I>
constexpr bool operator<(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<different-from <basic_const_iterator> I>
constexpr bool operator>(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<different-from <basic_const_iterator> I>
constexpr bool operator<=(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
§ 24.5.3.3 © ISO/IEC
1209

===== PAGE 1221 =====

Dxxxx
template<different-from <basic_const_iterator> I>
constexpr bool operator>=(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<different-from <basic_const_iterator> I>
constexpr auto operator<=>(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I> &&
three_way_comparable_with<Iterator, I>;
template<not-a-const-iterator I>
friend constexpr bool operator<(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<not-a-const-iterator I>
friend constexpr bool operator>(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<not-a-const-iterator I>
friend constexpr bool operator<=(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<not-a-const-iterator I>
friend constexpr bool operator>=(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
friend constexpr basic_const_iterator operator+(const basic_const_iterator& i,
difference_type n)
requires random_access_iterator<Iterator>;
friend constexpr basic_const_iterator operator+(difference_type n,
const basic_const_iterator& i)
requires random_access_iterator<Iterator>;
friend constexpr basic_const_iterator operator-(const basic_const_iterator& i,
difference_type n)
requires random_access_iterator<Iterator>;
template<sized_sentinel_for<Iterator> S>
constexpr difference_type operator-(const S& y) const;
template<not-a-const-iterator S>
requires sized_sentinel_for<S, Iterator>
friend constexpr difference_type operator-(const S& x, const basic_const_iterator& y);
friend constexpr rvalue-reference iter_move(const basic_const_iterator& i)
noexcept(noexcept(static_cast<rvalue-reference >(ranges::iter_move(i.current_))))
{
return static_cast<rvalue-reference >(ranges::iter_move(i.current_));
}
};
}
1 Given some type I, the concept not-a-const-iterator is defined as false if I is a specialization of
basic_const_iterator and true otherwise.
24.5.3.4 Member types [const.iterators.types]
1 basic_const_iterator<Iterator>::iterator_concept is defined as follows:
—(1.1) If Iterator models contiguous_iterator, theniterator_concept denotes contiguous_iterator_-
tag.
—(1.2) Otherwise, if Iterator models random_access_iterator, theniterator_concept denotes random_-
access_iterator_tag.
—(1.3) Otherwise, if Iterator models bidirectional_iterator, theniterator_concept denotes bidirec-
tional_iterator_tag.
—(1.4) Otherwise, if Iterator models forward_iterator, theniterator_concept denotes forward_itera-
tor_tag.
—(1.5) Otherwise, iterator_concept denotes input_iterator_tag.
2 The membertypedef-name iterator_category is defined if and only ifIterator models forward_iterator.
In that case,basic_const_iterator<Iterator>::iterator_categorydenotes the typeiterator_traits<
Iterator>::iterator_category.
§ 24.5.3.4 © ISO/IEC
1210

===== PAGE 1222 =====

Dxxxx
24.5.3.5 Operations [const.iterators.ops]
constexpr basic_const_iterator(Iterator current);
1 Effects: Initializes current_ with std::move(current).
template<convertible_to<Iterator> U>
constexpr basic_const_iterator(basic_const_iterator<U> current);
2 Effects: Initializes current_ with std::move(current.current_).
template<different-from <basic_const_iterator> T>
requires convertible_to<T, Iterator>
constexpr basic_const_iterator(T&& current);
3 Effects: Initializes current_ with std::forward<T>(current).
constexpr const Iterator& base() const & noexcept;
4 Effects: Equivalent to:return current_;
constexpr Iterator base() &&;
5 Effects: Equivalent to:return std::move(current_);
constexpr reference operator*() const;
6 Effects: Equivalent to:return static_cast<reference >(*current_);
constexpr const auto* operator->() const
requires is_lvalue_reference_v<iter_reference_t<Iterator>> &&
same_as<remove_cvref_t<iter_reference_t<Iterator>>, value_type>;
7 Returns: If Iterator models contiguous_iterator, to_address(current_); otherwise, address-
of(*current_).
constexpr basic_const_iterator& operator++();
8 Effects: Equivalent to:
++current_;
return *this;
constexpr void operator++(int);
9 Effects: Equivalent to:++current_;
constexpr basic_const_iterator operator++(int) requires forward_iterator<Iterator>;
10 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr basic_const_iterator& operator--() requires bidirectional_iterator<Iterator>;
11 Effects: Equivalent to:
--current_;
return *this;
constexpr basic_const_iterator operator--(int) requires bidirectional_iterator<Iterator>;
12 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr basic_const_iterator& operator+=(difference_type n)
requires random_access_iterator<Iterator>;
constexpr basic_const_iterator& operator-=(difference_type n)
requires random_access_iterator<Iterator>;
13 Let op be the operator.
§ 24.5.3.5 © ISO/IEC
1211

===== PAGE 1223 =====

Dxxxx
14 Effects: Equivalent to:
current_ op n;
return *this;
constexpr reference operator[](difference_type n) const requires random_access_iterator<Iterator>
15 Effects: Equivalent to:return static_cast<reference >(current_[n]);
template<sentinel_for<Iterator> S>
constexpr bool operator==(const S& s) const;
16 Effects: Equivalent to:return current_ == s;
template<not-a-const-iterator CI>
requires constant-iterator <CI> && convertible_to<Iterator const&, CI>
constexpr operator CI() const &;
17 Returns: current_.
template<not-a-const-iterator CI>
requires constant-iterator <CI> && convertible_to<Iterator, CI>
constexpr operator CI() &&;
18 Returns: std::move(current_).
constexpr bool operator<(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr bool operator>(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr bool operator<=(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr bool operator>=(const basic_const_iterator& y) const
requires random_access_iterator<Iterator>;
constexpr auto operator<=>(const basic_const_iterator& y) const
requires random_access_iterator<Iterator> && three_way_comparable<Iterator>;
19 Let op be the operator.
20 Effects: Equivalent to:return current_ op y.current_ ;
template<different-from <basic_const_iterator> I>
constexpr bool operator<(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<different-from <basic_const_iterator> I>
constexpr bool operator>(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<different-from <basic_const_iterator> I>
constexpr bool operator<=(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<different-from <basic_const_iterator> I>
constexpr bool operator>=(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<different-from <basic_const_iterator> I>
constexpr auto operator<=>(const I& y) const
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I> &&
three_way_comparable_with<Iterator, I>;
21 Let op be the operator.
22 Effects: Equivalent to:return current_ op y;
template<not-a-const-iterator I>
friend constexpr bool operator<(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<not-a-const-iterator I>
friend constexpr bool operator>(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
§ 24.5.3.5 © ISO/IEC
1212

===== PAGE 1224 =====

Dxxxx
template<not-a-const-iterator I>
friend constexpr bool operator<=(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
template<not-a-const-iterator I>
friend constexpr bool operator>=(const I& x, const basic_const_iterator& y)
requires random_access_iterator<Iterator> && totally_ordered_with<Iterator, I>;
23 Let op be the operator.
24 Effects: Equivalent to:return x op y.current_;
friend constexpr basic_const_iterator operator+(const basic_const_iterator& i, difference_type n)
requires random_access_iterator<Iterator>;
friend constexpr basic_const_iterator operator+(difference_type n, const basic_const_iterator& i)
requires random_access_iterator<Iterator>;
25 Effects: Equivalent to:return basic_const_iterator(i.current_ + n);
friend constexpr basic_const_iterator operator-(const basic_const_iterator& i, difference_type n)
requires random_access_iterator<Iterator>;
26 Effects: Equivalent to:return basic_const_iterator(i.current_ - n);
template<sized_sentinel_for<Iterator> S>
constexpr difference_type operator-(const S& y) const;
27 Effects: Equivalent to:return current_ - y;
template<not-a-const-iterator S>
requires sized_sentinel_for<S, Iterator>
friend constexpr difference_type operator-(const S& x, const basic_const_iterator& y);
28 Effects: Equivalent to:return x - y.current_;
24.5.4 Move iterators and sentinels [move.iterators]
24.5.4.1 General [move.iterators.general]
1 Class templatemove_iterator is an iterator adaptor with the same behavior as the underlying iterator except
that its indirection operator implicitly converts the value returned by the underlying iterator’s indirection
operator to an rvalue. Some generic algorithms can be called with move iterators to replace copying with
moving.
2 [Example 1:
list<string> s;
// populate the lists
vector<string> v1(s.begin(), s.end()); // copies strings intov1
vector<string> v2(make_move_iterator(s.begin()),
make_move_iterator(s.end())); // moves strings intov2
—end example]
24.5.4.2 Class template move_iterator [move.iterator]
namespace std {
template<class Iterator>
class move_iterator {
public:
using iterator_type = Iterator;
using iterator_concept = see below ;
using iterator_category = see below ; // not always present
using value_type = iter_value_t<Iterator>;
using difference_type = iter_difference_t<Iterator>;
using pointer = Iterator;
using reference = iter_rvalue_reference_t<Iterator>;
constexpr move_iterator();
constexpr explicit move_iterator(Iterator i);
template<class U> constexpr move_iterator(const move_iterator<U>& u);
template<class U> constexpr move_iterator& operator=(const move_iterator<U>& u);
§ 24.5.4.2 © ISO/IEC
1213

===== PAGE 1225 =====

Dxxxx
constexpr const Iterator& base() const & noexcept;
constexpr Iterator base() &&;
constexpr reference operator*() const;
constexpr move_iterator& operator++();
constexpr auto operator++(int);
constexpr move_iterator& operator--();
constexpr move_iterator operator--(int);
constexpr move_iterator operator+(difference_type n) const;
constexpr move_iterator& operator+=(difference_type n);
constexpr move_iterator operator-(difference_type n) const;
constexpr move_iterator& operator-=(difference_type n);
constexpr reference operator[](difference_type n) const;
template<sentinel_for<Iterator> S>
friend constexpr bool
operator==(const move_iterator& x, const move_sentinel<S>& y);
template<sized_sentinel_for<Iterator> S>
friend constexpr iter_difference_t<Iterator>
operator-(const move_sentinel<S>& x, const move_iterator& y);
template<sized_sentinel_for<Iterator> S>
friend constexpr iter_difference_t<Iterator>
operator-(const move_iterator& x, const move_sentinel<S>& y);
friend constexpr iter_rvalue_reference_t<Iterator>
iter_move(const move_iterator& i)
noexcept(noexcept(ranges::iter_move(i.current)));
template<indirectly_swappable<Iterator> Iterator2>
friend constexpr void
iter_swap(const move_iterator& x, const move_iterator<Iterator2>& y)
noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
private:
Iterator current; // exposition only
};
}
1 The membertypedef-name iterator_concept is defined as follows:
—(1.1) If Iterator models random_access_iterator, then iterator_concept denotes random_access_-
iterator_tag.
—(1.2) Otherwise, if Iterator models bidirectional_iterator, theniterator_concept denotes bidirec-
tional_iterator_tag.
—(1.3) Otherwise, if Iterator models forward_iterator, theniterator_concept denotes forward_itera-
tor_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
2 The membertypedef-name iterator_category is defined if and only if thequalified-id iterator_traits<It-
erator>::iterator_category is valid and denotes a type. In that case,iterator_category denotes
—(2.1) random_access_iterator_tag if the typeiterator_traits<Iterator>::iterator_category mod-
els derived_from<random_access_iterator_tag>, and
—(2.2) iterator_traits<Iterator>::iterator_category otherwise.
24.5.4.3 Requirements [move.iter.requirements]
1 The template parameterIterator shall either meet theCpp17InputIterator requirements (24.3.5.3) or model
input_iterator (24.3.4.9). Additionally, if any of the bidirectional traversal functions are instantiated,
the template parameter shall either meet theCpp17BidirectionalIterator requirements (24.3.5.6) or model
bidirectional_iterator (24.3.4.12). If any of the random access traversal functions are instantiated, the
template parameter shall either meet theCpp17RandomAccessIteratorrequirements (24.3.5.7) or model
random_access_iterator (24.3.4.13).
§ 24.5.4.3 © ISO/IEC
1214

===== PAGE 1226 =====

Dxxxx
24.5.4.4 Construction and assignment [move.iter.cons]
constexpr move_iterator();
1 Effects: Value-initializescurrent.
constexpr explicit move_iterator(Iterator i);
2 Effects: Initializes current with std::move(i).
template<class U> constexpr move_iterator(const move_iterator<U>& u);
3 Constraints: is_same_v<U, Iterator> is false and const U& models convertible_to<Iterator>.
4 Effects: Initializes current with u.current.
template<class U> constexpr move_iterator& operator=(const move_iterator<U>& u);
5 Constraints: is_same_v<U, Iterator> is false, const U& models convertible_to<Iterator>, and
assignable_from<Iterator&, const U&> is modeled.
6 Effects: Assigns u.current to current.
7 Returns: *this.
24.5.4.5 Conversion [move.iter.op.conv]
constexpr const Iterator& base() const & noexcept;
1 Returns: current.
constexpr Iterator base() &&;
2 Returns: std::move(current).
24.5.4.6 Element access [move.iter.elem]
constexpr reference operator*() const;
1 Effects: Equivalent to:return ranges::iter_move(current);
constexpr reference operator[](difference_type n) const;
2 Effects: Equivalent to:return ranges::iter_move(current + n);
24.5.4.7 Navigation [move.iter.nav]
constexpr move_iterator& operator++();
1 Effects: As if by++current.
2 Returns: *this.
constexpr auto operator++(int);
3 Effects: If Iterator models forward_iterator, equivalent to:
move_iterator tmp = *this;
++current;
return tmp;
Otherwise, equivalent to++current.
constexpr move_iterator& operator--();
4 Effects: As if by--current.
5 Returns: *this.
constexpr move_iterator operator--(int);
6 Effects: As if by:
move_iterator tmp = *this;
--current;
return tmp;
§ 24.5.4.7 © ISO/IEC
1215

===== PAGE 1227 =====

Dxxxx
constexpr move_iterator operator+(difference_type n) const;
7 Returns: move_iterator(current + n).
constexpr move_iterator& operator+=(difference_type n);
8 Effects: As if by:current += n;
9 Returns: *this.
constexpr move_iterator operator-(difference_type n) const;
10 Returns: move_iterator(current - n).
constexpr move_iterator& operator-=(difference_type n);
11 Effects: As if by:current -= n;
12 Returns: *this.
24.5.4.8 Comparisons [move.iter.op.comp]
template<class Iterator1, class Iterator2>
constexpr bool operator==(const move_iterator<Iterator1>& x,
const move_iterator<Iterator2>& y);
template<sentinel_for<Iterator> S>
friend constexpr bool operator==(const move_iterator& x,
const move_sentinel<S>& y);
1 Constraints: x.base() == y.base() is well-formed and convertible tobool.
2 Returns: x.base() == y.base().
template<class Iterator1, class Iterator2>
constexpr bool operator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
3 Constraints: x.base() < y.base() is well-formed and convertible tobool.
4 Returns: x.base() < y.base().
template<class Iterator1, class Iterator2>
constexpr bool operator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
5 Constraints: y.base() < x.base() is well-formed and convertible tobool.
6 Returns: y < x.
template<class Iterator1, class Iterator2>
constexpr bool operator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
7 Constraints: y.base() < x.base() is well-formed and convertible tobool.
8 Returns: !(y < x).
template<class Iterator1, class Iterator2>
constexpr bool operator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
9 Constraints: x.base() < y.base() is well-formed and convertible tobool.
10 Returns: !(x < y).
template<class Iterator1, three_way_comparable_with<Iterator1> Iterator2>
constexpr compare_three_way_result_t<Iterator1, Iterator2>
operator<=>(const move_iterator<Iterator1>& x,
const move_iterator<Iterator2>& y);
11 Returns: x.base() <=> y.base().
24.5.4.9 Non-member functions [move.iter.nonmember]
template<class Iterator1, class Iterator2>
constexpr auto operator-(
const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y)
-> decltype(x.base() - y.base());
§ 24.5.4.9 © ISO/IEC
1216

===== PAGE 1228 =====

Dxxxx
template<sized_sentinel_for<Iterator> S>
friend constexpr iter_difference_t<Iterator>
operator-(const move_sentinel<S>& x, const move_iterator& y);
template<sized_sentinel_for<Iterator> S>
friend constexpr iter_difference_t<Iterator>
operator-(const move_iterator& x, const move_sentinel<S>& y);
1 Returns: x.base() - y.base().
template<class Iterator>
constexpr move_iterator<Iterator>
operator+(iter_difference_t<Iterator> n, const move_iterator<Iterator>& x);
2 Constraints: x.base() + n is well-formed and has typeIterator.
3 Returns: x + n.
friend constexpr iter_rvalue_reference_t<Iterator>
iter_move(const move_iterator& i)
noexcept(noexcept(ranges::iter_move(i.current)));
4 Effects: Equivalent to:return ranges::iter_move(i.current);
template<indirectly_swappable<Iterator> Iterator2>
friend constexpr void
iter_swap(const move_iterator& x, const move_iterator<Iterator2>& y)
noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
5 Effects: Equivalent to:ranges::iter_swap(x.current, y.current).
template<class Iterator>
constexpr move_iterator<Iterator> make_move_iterator(Iterator i);
6 Returns: move_iterator<Iterator>(std::move(i)).
24.5.4.10 Class template move_sentinel [move.sentinel]
1 Class templatemove_sentinel is a sentinel adaptor useful for denoting ranges together withmove_iterator.
When an input iterator typeI and sentinel typeS model sentinel_for<S, I>, move_sentinel<S> and
move_iterator<I> model sentinel_for<move_sentinel<S>, move_iterator<I>> as well.
2 [Example 1: A move_if algorithm is easily implemented withcopy_if using move_iterator and move_sentinel:
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
indirect_unary_predicate<I> Pred>
requires indirectly_movable<I, O>
void move_if(I first, S last, O out, Pred pred) {
ranges::copy_if(move_iterator<I>{std::move(first)}, move_sentinel<S>{last},
std::move(out), pred);
}
—end example]
namespace std {
template<semiregular S>
class move_sentinel {
public:
constexpr move_sentinel();
constexpr explicit move_sentinel(S s);
template<class S2>
requires convertible_to<const S2&, S>
constexpr move_sentinel(const move_sentinel<S2>& s);
template<class S2>
requires assignable_from<S&, const S2&>
constexpr move_sentinel& operator=(const move_sentinel<S2>& s);
constexpr S base() const;
private:
S last; // exposition only
§ 24.5.4.10 © ISO/IEC
1217

===== PAGE 1229 =====

Dxxxx
};
}
24.5.4.11 Operations [move.sent.ops]
constexpr move_sentinel();
1 Effects: Value-initializes last. If is_trivially_default_constructible_v<S> is true, then this
constructor is aconstexpr constructor.
constexpr explicit move_sentinel(S s);
2 Effects: Initializes last with std::move(s).
template<class S2>
requires convertible_to<const S2&, S>
constexpr move_sentinel(const move_sentinel<S2>& s);
3 Effects: Initializes last with s.last.
template<class S2>
requires assignable_from<S&, const S2&>
constexpr move_sentinel& operator=(const move_sentinel<S2>& s);
4 Effects: Equivalent to:last = s.last; return *this;
constexpr S base() const;
5 Returns: last.
24.5.5 Common iterators [iterators.common]
24.5.5.1 Class template common_iterator [common.iterator]
1 Class templatecommon_iteratoris an iterator/sentinel adaptor that is capable of representing a non-common
range of elements (where the types of the iterator and sentinel differ) as a common range (where they are the
same). It does this by holding either an iterator or a sentinel, and implementing the equality comparison
operators appropriately.
2 [Note 1: The common_iterator type is useful for interfacing with legacy code that expects the begin and end of a
range to have the same type.—end note]
3 [Example 1:
template<class ForwardIterator>
void fun(ForwardIterator begin, ForwardIterator end);
list<int> s;
// populate the lists
using CI = common_iterator<counted_iterator<list<int>::iterator>, default_sentinel_t>;
// call fun on a range of 10 ints
fun(CI(counted_iterator(s.begin(), 10)), CI(default_sentinel));
—end example]
namespace std {
template<input_or_output_iterator I, sentinel_for<I> S>
requires (!same_as<I, S> && copyable<I>)
class common_iterator {
public:
constexpr common_iterator() requires default_initializable<I> = default;
constexpr common_iterator(I i);
constexpr common_iterator(S s);
template<class I2, class S2>
requires convertible_to<const I2&, I> && convertible_to<const S2&, S>
constexpr common_iterator(const common_iterator<I2, S2>& x);
template<class I2, class S2>
requires convertible_to<const I2&, I> && convertible_to<const S2&, S> &&
assignable_from<I&, const I2&> && assignable_from<S&, const S2&>
constexpr common_iterator& operator=(const common_iterator<I2, S2>& x);
§ 24.5.5.1 © ISO/IEC
1218

===== PAGE 1230 =====

Dxxxx
constexpr decltype(auto) operator*();
constexpr decltype(auto) operator*() const
requires dereferenceable <const I>;
constexpr auto operator->() const
requires see below ;
constexpr common_iterator& operator++();
constexpr decltype(auto) operator++(int);
template<class I2, sentinel_for<I> S2>
requires sentinel_for<S, I2>
friend constexpr bool operator==(
const common_iterator& x, const common_iterator<I2, S2>& y);
template<class I2, sentinel_for<I> S2>
requires sentinel_for<S, I2> && equality_comparable_with<I, I2>
friend constexpr bool operator==(
const common_iterator& x, const common_iterator<I2, S2>& y);
template<sized_sentinel_for<I> I2, sized_sentinel_for<I> S2>
requires sized_sentinel_for<S, I2>
friend constexpr iter_difference_t<I2> operator-(
const common_iterator& x, const common_iterator<I2, S2>& y);
friend constexpr decltype(auto) iter_move(const common_iterator& i)
noexcept(noexcept(ranges::iter_move(declval<const I&>())))
requires input_iterator<I>;
template<indirectly_swappable<I> I2, class S2>
friend constexpr void iter_swap(const common_iterator& x, const common_iterator<I2, S2>& y)
noexcept(noexcept(ranges::iter_swap(declval<const I&>(), declval<const I2&>())));
private:
variant<I, S> v_; // exposition only
};
template<class I, class S>
struct incrementable_traits<common_iterator<I, S>> {
using difference_type = iter_difference_t<I>;
};
template<input_iterator I, class S>
struct iterator_traits<common_iterator<I, S>> {
using iterator_concept = see below ;
using iterator_category = see below ; // not always present
using value_type = iter_value_t<I>;
using difference_type = iter_difference_t<I>;
using pointer = see below ;
using reference = iter_reference_t<I>;
};
}
24.5.5.2 Associated types [common.iter.types]
1 The nested typedef-name iterator_category of the specialization of iterator_traits for common_-
iterator<I, S>is defined if and only ifiter_difference_t<I>is an integral type. In that case,iterator_-
category denotes forward_iterator_tag if thequalified-id iterator_traits<I>::iterator_category is
valid and denotes a type that modelsderived_from<forward_iterator_tag>; otherwise it denotesinput_-
iterator_tag.
2 The remaining nestedtypedef-names of the specialization ofiterator_traits for common_iterator<I, S>
are defined as follows:
—(2.1) iterator_concept denotes forward_iterator_tag if I models forward_iterator; otherwise it de-
notes input_iterator_tag.
§ 24.5.5.2 © ISO/IEC
1219

===== PAGE 1231 =====

Dxxxx
—(2.2) Let a denote an lvalue of typeconst common_iterator<I, S>. If the expressiona.operator->() is
well-formed, thenpointer denotes decltype(a.operator->()). Otherwise, pointer denotes void.
24.5.5.3 Constructors and conversions [common.iter.const]
constexpr common_iterator(I i);
1 Effects: Initializes v_ as if byv_{in_place_type<I>, std::move(i)}.
constexpr common_iterator(S s);
2 Effects: Initializes v_ as if byv_{in_place_type<S>, std::move(s)}.
template<class I2, class S2>
requires convertible_to<const I2&, I> && convertible_to<const S2&, S>
constexpr common_iterator(const common_iterator<I2, S2>& x);
3 Hardened preconditions: x.v_.valueless_by_exception() is false.
4 Effects: Initializes v_ as if byv_{in_place_index<i>, get<i>(x.v_)}, wherei is x.v_.index().
template<class I2, class S2>
requires convertible_to<const I2&, I> && convertible_to<const S2&, S> &&
assignable_from<I&, const I2&> && assignable_from<S&, const S2&>
constexpr common_iterator& operator=(const common_iterator<I2, S2>& x);
5 Hardened preconditions: x.v_.valueless_by_exception() is false.
6 Effects: Equivalent to:
—(6.1) If v_.index() == x.v_.index(), thenget<i>(v_) = get<i>(x.v_).
—(6.2) Otherwise, v_.emplace<i>(get<i>(x.v_)).
where i is x.v_.index().
7 Returns: *this.
24.5.5.4 Accessors [common.iter.access]
constexpr decltype(auto) operator*();
constexpr decltype(auto) operator*() const
requires dereferenceable <const I>;
1 Hardened preconditions: holds_alternative<I>(v_) is true.
2 Effects: Equivalent to:return *get<I>(v_);
constexpr auto operator->() const
requires see below ;
3 The expression in therequires-clause is equivalent to:
indirectly_readable<const I> &&
(requires(const I& i) { i.operator->(); } ||
is_reference_v<iter_reference_t<I>> ||
constructible_from<iter_value_t<I>, iter_reference_t<I>>)
4 Hardened preconditions: holds_alternative<I>(v_) is true.
5 Effects:
—(5.1) If I is a pointer type or if the expressionget<I>(v_).operator->() is well-formed, equivalent
to: return get<I>(v_);
—(5.2) Otherwise, ifiter_reference_t<I> is a reference type, equivalent to:
auto&& tmp = *get<I>(v_);
return addressof(tmp);
—(5.3) Otherwise, equivalent to: return proxy (*get<I>(v_)); where proxy is the exposition-only
class:
class proxy {
iter_value_t<I> keep_;
§ 24.5.5.4 © ISO/IEC
1220

===== PAGE 1232 =====

Dxxxx
constexpr proxy (iter_reference_t<I>&& x)
: keep_(std::move(x)) {}
public:
constexpr const iter_value_t<I>* operator->() const noexcept {
return addressof(keep_);
}
};
24.5.5.5 Navigation [common.iter.nav]
constexpr common_iterator& operator++();
1 Hardened preconditions: holds_alternative<I>(v_) is true.
2 Effects: Equivalent to++get<I>(v_).
3 Returns: *this.
constexpr decltype(auto) operator++(int);
4 Hardened preconditions: holds_alternative<I>(v_) is true.
5 Effects: If I models forward_iterator, equivalent to:
common_iterator tmp = *this;
++*this;
return tmp;
Otherwise, ifrequires(I& i) { { *i++ } -> can-reference; } is true or
indirectly_readable<I> && constructible_from<iter_value_t<I>, iter_reference_t<I>> &&
move_constructible<iter_value_t<I>>
is false, equivalent to:
return get<I>(v_)++;
Otherwise, equivalent to:
postfix-proxy p(**this);
++*this;
return p;
where postfix-proxy is the exposition-only class:
class postfix-proxy {
iter_value_t<I> keep_;
constexpr postfix-proxy (iter_reference_t<I>&& x)
: keep_(std::forward<iter_reference_t<I>>(x)) {}
public:
constexpr const iter_value_t<I>& operator*() const noexcept {
return keep_;
}
};
24.5.5.6 Comparisons [common.iter.cmp]
template<class I2, sentinel_for<I> S2>
requires sentinel_for<S, I2>
friend constexpr bool operator==(
const common_iterator& x, const common_iterator<I2, S2>& y);
1 Hardened preconditions: x.v_.valueless_by_exception() and y.v_.valueless_by_exception()
are eachfalse.
2 Returns: true if i == j, and otherwiseget<i>(x.v_) == get<j>(y.v_), where i is x.v_.index()
and j is y.v_.index().
§ 24.5.5.6 © ISO/IEC
1221

===== PAGE 1233 =====

Dxxxx
template<class I2, sentinel_for<I> S2>
requires sentinel_for<S, I2> && equality_comparable_with<I, I2>
friend constexpr bool operator==(
const common_iterator& x, const common_iterator<I2, S2>& y);
3 Hardened preconditions: x.v_.valueless_by_exception() and y.v_.valueless_by_exception()
are eachfalse.
4 Returns: true if i and j are each 1, and otherwise get<i>(x.v_) == get<j>(y.v_), where i is
x.v_.index() and j is y.v_.index().
template<sized_sentinel_for<I> I2, sized_sentinel_for<I> S2>
requires sized_sentinel_for<S, I2>
friend constexpr iter_difference_t<I2> operator-(
const common_iterator& x, const common_iterator<I2, S2>& y);
5 Hardened preconditions: x.v_.valueless_by_exception() and y.v_.valueless_by_exception()
are eachfalse.
6 Returns: 0ifiandjare each1, and otherwiseget<i>(x.v_) - get<j>(y.v_), whereiisx.v_.index()
and j is y.v_.index().
24.5.5.7 Customizations [common.iter.cust]
friend constexpr decltype(auto) iter_move(const common_iterator& i)
noexcept(noexcept(ranges::iter_move(declval<const I&>())))
requires input_iterator<I>;
1 Hardened preconditions: holds_alternative<I>(i.v_) is true.
2 Effects: Equivalent to:return ranges::iter_move(get<I>(i.v_));
template<indirectly_swappable<I> I2, class S2>
friend constexpr void iter_swap(const common_iterator& x, const common_iterator<I2, S2>& y)
noexcept(noexcept(ranges::iter_swap(declval<const I&>(), declval<const I2&>())));
3 Hardened preconditions: holds_alternative<I>(x.v_) and holds_alternative<I2>(y.v_) are each
true.
4 Effects: Equivalent toranges::iter_swap(get<I>(x.v_), get<I2>(y.v_)).
24.5.6 Default sentinel [default.sentinel]
namespace std {
struct default_sentinel_t { };
}
1 Class default_sentinel_t is an empty type used to denote the end of a range. It can be used together with
iterator types that know the bound of their range (e.g.,counted_iterator (24.5.7.1)).
24.5.7 Counted iterators [iterators.counted]
24.5.7.1 Class template counted_iterator [counted.iterator]
1 Class templatecounted_iterator is an iterator adaptor with the same behavior as the underlying iterator
except that it keeps track of the distance to the end of its range. It can be used together withdefault_-
sentinel in calls to generic algorithms to operate on a range ofN elements starting at a given position
without needing to know the end position a priori.
2 [Example 1:
list<string> s;
// populate the lists with at least 10 strings
vector<string> v;
// copies 10 strings intov:
ranges::copy(counted_iterator(s.begin(), 10), default_sentinel, back_inserter(v));
—end example]
3 Two valuesi1 and i2 of typescounted_iterator<I1> and counted_iterator<I2> refer to elements of the
same sequence if and only if there exists some integern such thatnext(i1.base(), i1.count() + n) and
next(i2.base(), i2.count() + n) refer to the same (possibly past-the-end) element.
§ 24.5.7.1 © ISO/IEC
1222

===== PAGE 1234 =====

Dxxxx
namespace std {
template<input_or_output_iterator I>
class counted_iterator {
public:
using iterator_type = I;
using value_type = iter_value_t<I>; // present only
// if I models indirectly_readable
using difference_type = iter_difference_t<I>;
using iterator_concept = I::iterator_concept; // present only
// if thequalified-id I::iterator_concept is valid and denotes a type
using iterator_category = I::iterator_category; // present only
// if thequalified-id I::iterator_category is valid and denotes a type
constexpr counted_iterator() requires default_initializable<I> = default;
constexpr counted_iterator(I x, iter_difference_t<I> n);
template<class I2>
requires convertible_to<const I2&, I>
constexpr counted_iterator(const counted_iterator<I2>& x);
template<class I2>
requires assignable_from<I&, const I2&>
constexpr counted_iterator& operator=(const counted_iterator<I2>& x);
constexpr const I& base() const & noexcept;
constexpr I base() &&;
constexpr iter_difference_t<I> count() const noexcept;
constexpr decltype(auto) operator*();
constexpr decltype(auto) operator*() const
requires dereferenceable <const I>;
constexpr auto operator->() const noexcept
requires contiguous_iterator<I>;
constexpr counted_iterator& operator++();
constexpr decltype(auto) operator++(int);
constexpr counted_iterator operator++(int)
requires forward_iterator<I>;
constexpr counted_iterator& operator--()
requires bidirectional_iterator<I>;
constexpr counted_iterator operator--(int)
requires bidirectional_iterator<I>;
constexpr counted_iterator operator+(iter_difference_t<I> n) const
requires random_access_iterator<I>;
friend constexpr counted_iterator operator+(
iter_difference_t<I> n, const counted_iterator& x)
requires random_access_iterator<I>;
constexpr counted_iterator& operator+=(iter_difference_t<I> n)
requires random_access_iterator<I>;
constexpr counted_iterator operator-(iter_difference_t<I> n) const
requires random_access_iterator<I>;
template<common_with<I> I2>
friend constexpr iter_difference_t<I2> operator-(
const counted_iterator& x, const counted_iterator<I2>& y);
friend constexpr iter_difference_t<I> operator-(
const counted_iterator& x, default_sentinel_t) noexcept;
friend constexpr iter_difference_t<I> operator-(
default_sentinel_t, const counted_iterator& y) noexcept;
constexpr counted_iterator& operator-=(iter_difference_t<I> n)
requires random_access_iterator<I>;
constexpr decltype(auto) operator[](iter_difference_t<I> n) const
requires random_access_iterator<I>;
§ 24.5.7.1 © ISO/IEC
1223

===== PAGE 1235 =====

Dxxxx
template<common_with<I> I2>
friend constexpr bool operator==(
const counted_iterator& x, const counted_iterator<I2>& y);
friend constexpr bool operator==(
const counted_iterator& x, default_sentinel_t) noexcept;
template<common_with<I> I2>
friend constexpr strong_ordering operator<=>(
const counted_iterator& x, const counted_iterator<I2>& y);
friend constexpr decltype(auto) iter_move(const counted_iterator& i)
noexcept(noexcept(ranges::iter_move(i.current)))
requires input_iterator<I>;
template<indirectly_swappable<I> I2>
friend constexpr void iter_swap(const counted_iterator& x, const counted_iterator<I2>& y)
noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
private:
I current = I(); // exposition only
iter_difference_t<I> length = 0; // exposition only
};
template<input_iterator I>
requires same_as<ITER_TRAITS (I), iterator_traits<I>> // see 24.3.4.1
struct iterator_traits<counted_iterator<I>> : iterator_traits<I> {
using pointer = conditional_t<contiguous_iterator<I>,
add_pointer_t<iter_reference_t<I>>, void>;
};
}
24.5.7.2 Constructors and conversions [counted.iter.const]
constexpr counted_iterator(I i, iter_difference_t<I> n);
1 Hardened preconditions: n >= 0 is true.
2 Effects: Initializes current with std::move(i) and length with n.
template<class I2>
requires convertible_to<const I2&, I>
constexpr counted_iterator(const counted_iterator<I2>& x);
3 Effects: Initializes current with x.current and length with x.length.
template<class I2>
requires assignable_from<I&, const I2&>
constexpr counted_iterator& operator=(const counted_iterator<I2>& x);
4 Effects: Assigns x.current to current and x.length to length.
5 Returns: *this.
24.5.7.3 Accessors [counted.iter.access]
constexpr const I& base() const & noexcept;
1 Effects: Equivalent to:return current;
constexpr I base() &&;
2 Returns: std::move(current).
constexpr iter_difference_t<I> count() const noexcept;
3 Effects: Equivalent to:return length;
24.5.7.4 Element access [counted.iter.elem]
constexpr decltype(auto) operator*();
§ 24.5.7.4 © ISO/IEC
1224

===== PAGE 1236 =====

Dxxxx
constexpr decltype(auto) operator*() const
requires dereferenceable <const I>;
1 Hardened preconditions: length > 0 is true.
2 Effects: Equivalent to:return *current;
constexpr auto operator->() const noexcept
requires contiguous_iterator<I>;
3 Effects: Equivalent to:return to_address(current);
constexpr decltype(auto) operator[](iter_difference_t<I> n) const
requires random_access_iterator<I>;
4 Hardened preconditions: n < length is true.
5 Effects: Equivalent to:return current[n];
24.5.7.5 Navigation [counted.iter.nav]
constexpr counted_iterator& operator++();
1 Hardened preconditions: length > 0 is true.
2 Effects: Equivalent to:
++current;
--length;
return *this;
constexpr decltype(auto) operator++(int);
3 Hardened preconditions: length > 0 is true.
4 Effects: Equivalent to:
--length;
try { return current++; }
catch(...) { ++length; throw; }
constexpr counted_iterator operator++(int)
requires forward_iterator<I>;
5 Effects: Equivalent to:
counted_iterator tmp = *this;
++*this;
return tmp;
constexpr counted_iterator& operator--()
requires bidirectional_iterator<I>;
6 Effects: Equivalent to:
--current;
++length;
return *this;
constexpr counted_iterator operator--(int)
requires bidirectional_iterator<I>;
7 Effects: Equivalent to:
counted_iterator tmp = *this;
--*this;
return tmp;
constexpr counted_iterator operator+(iter_difference_t<I> n) const
requires random_access_iterator<I>;
8 Effects: Equivalent to:return counted_iterator(current + n, length - n);
§ 24.5.7.5 © ISO/IEC
1225

===== PAGE 1237 =====

Dxxxx
friend constexpr counted_iterator operator+(
iter_difference_t<I> n, const counted_iterator& x)
requires random_access_iterator<I>;
9 Effects: Equivalent to:return x + n;
constexpr counted_iterator& operator+=(iter_difference_t<I> n)
requires random_access_iterator<I>;
10 Hardened preconditions: n <= length is true.
11 Effects: Equivalent to:
current += n;
length -= n;
return *this;
constexpr counted_iterator operator-(iter_difference_t<I> n) const
requires random_access_iterator<I>;
12 Effects: Equivalent to:return counted_iterator(current - n, length + n);
template<common_with<I> I2>
friend constexpr iter_difference_t<I2> operator-(
const counted_iterator& x, const counted_iterator<I2>& y);
13 Preconditions: x and y refer to elements of the same sequence (24.5.7.1).
14 Effects: Equivalent to:return y.length - x.length;
friend constexpr iter_difference_t<I> operator-(
const counted_iterator& x, default_sentinel_t) noexcept;
15 Effects: Equivalent to:return -x.length;
friend constexpr iter_difference_t<I> operator-(
default_sentinel_t, const counted_iterator& y) noexcept;
16 Effects: Equivalent to:return y.length;
constexpr counted_iterator& operator-=(iter_difference_t<I> n)
requires random_access_iterator<I>;
17 Hardened preconditions: -n <= length is true.
18 Effects: Equivalent to:
current -= n;
length += n;
return *this;
24.5.7.6 Comparisons [counted.iter.cmp]
template<common_with<I> I2>
friend constexpr bool operator==(
const counted_iterator& x, const counted_iterator<I2>& y);
1 Preconditions: x and y refer to elements of the same sequence (24.5.7.1).
2 Effects: Equivalent to:return x.length == y.length;
friend constexpr bool operator==(
const counted_iterator& x, default_sentinel_t) noexcept;
3 Effects: Equivalent to:return x.length == 0;
template<common_with<I> I2>
friend constexpr strong_ordering operator<=>(
const counted_iterator& x, const counted_iterator<I2>& y);
4 Preconditions: x and y refer to elements of the same sequence (24.5.7.1).
5 Effects: Equivalent to:return y.length <=> x.length;
6 [Note 1: The argument order in theEffects: element is reversed becauselength counts down, not up.—end
note]
§ 24.5.7.6 © ISO/IEC
1226

===== PAGE 1238 =====

Dxxxx
24.5.7.7 Customizations [counted.iter.cust]
friend constexpr decltype(auto)
iter_move(const counted_iterator& i)
noexcept(noexcept(ranges::iter_move(i.current)))
requires input_iterator<I>;
1 Hardened preconditions: i.length > 0 is true.
2 Effects: Equivalent to:return ranges::iter_move(i.current);
template<indirectly_swappable<I> I2>
friend constexpr void
iter_swap(const counted_iterator& x, const counted_iterator<I2>& y)
noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
3 Hardened preconditions: Both x.length > 0 and y.length > 0 are true.
4 Effects: Equivalent toranges::iter_swap(x.current, y.current).
24.5.8 Unreachable sentinel [unreachable.sentinel]
1 Class unreachable_sentinel_t can be used with anyweakly_incrementable type to denote the “upper
bound” of an unbounded interval.
2 [Example 1:
char* p;
// set p to point to a character buffer containing newlines
char* nl = find(p, unreachable_sentinel, '\n');
Provided a newline character really exists in the buffer, the use ofunreachable_sentinel above potentially makes
the call tofind more efficient since the loop test against the sentinel does not require a conditional branch.—end
example]
namespace std {
struct unreachable_sentinel_t {
template<weakly_incrementable I>
friend constexpr bool operator==(unreachable_sentinel_t, const I&) noexcept
{ return false; }
};
}
24.6 Stream iterators [stream.iterators]
24.6.1 General [stream.iterators.general]
1 To make it possible for algorithmic templates to work directly with input/output streams, appropriate
iterator-like class templates are provided.
[Example 1:
partial_sum(istream_iterator<double, char>(cin),
istream_iterator<double, char>(),
ostream_iterator<double, char>(cout, "\n"));
reads a file containing floating-point numbers fromcin, and prints the partial sums ontocout. —end example]
24.6.2 Class template istream_iterator [istream.iterator]
24.6.2.1 General [istream.iterator.general]
1 The class templateistream_iterator is an input iterator (24.3.5.3) that reads successive elements from the
input stream for which it was constructed.
namespace std {
template<class T, class charT = char, class traits = char_traits<charT>,
class Distance = ptrdiff_t>
class istream_iterator {
public:
using iterator_category = input_iterator_tag;
using value_type = T;
using difference_type = Distance;
using pointer = const T*;
§ 24.6.2.1 © ISO/IEC
1227

===== PAGE 1239 =====

Dxxxx
using reference = const T&;
using char_type = charT;
using traits_type = traits;
using istream_type = basic_istream<charT,traits>;
constexpr istream_iterator();
constexpr istream_iterator(default_sentinel_t);
istream_iterator(istream_type& s);
constexpr istream_iterator(const istream_iterator& x) noexcept(see below );
~istream_iterator() = default;
istream_iterator& operator=(const istream_iterator&) = default;
const T& operator*() const;
const T* operator->() const;
istream_iterator& operator++();
istream_iterator operator++(int);
friend bool operator==(const istream_iterator& i, default_sentinel_t);
private:
basic_istream<charT,traits>* in_stream; // exposition only
T value; // exposition only
};
}
2 The typeT shall meet theCpp17DefaultConstructible, Cpp17CopyConstructible, andCpp17CopyAssignable
requirements.
24.6.2.2 Constructors and destructor [istream.iterator.cons]
constexpr istream_iterator();
constexpr istream_iterator(default_sentinel_t);
1 Effects: Constructs the end-of-stream iterator, value-initializingvalue.
2 Postconditions: in_stream == nullptr is true.
3 Remarks: If the initializerT() in the declarationauto x = T(); is a constant initializer (7.7), then
these constructors areconstexpr constructors.
istream_iterator(istream_type& s);
4 Effects: Initializesin_streamwith addressof(s), value-initializesvalue, and then callsoperator++().
constexpr istream_iterator(const istream_iterator& x) noexcept(see below );
5 Effects: Initializes in_stream with x.in_stream and initializesvalue with x.value.
6 Remarks: An invocation of this constructor may be used in a core constant expression if and only if the
initialization of value from x.value is a constant subexpression (3.15). The exception specification is
equivalent tois_nothrow_copy_constructible_v<T>.
~istream_iterator() = default;
7 Remarks: If is_trivially_destructible_v<T> is true, then this destructor is trivial.
24.6.2.3 Operations [istream.iterator.ops]
const T& operator*() const;
1 Preconditions: in_stream != nullptr is true.
2 Returns: value.
const T* operator->() const;
3 Preconditions: in_stream != nullptr is true.
4 Returns: addressof(value).
§ 24.6.2.3 © ISO/IEC
1228

===== PAGE 1240 =====

Dxxxx
istream_iterator& operator++();
5 Preconditions: in_stream != nullptr is true.
6 Effects: Equivalent to:
if (!(*in_stream >> value))
in_stream = nullptr;
7 Returns: *this.
istream_iterator operator++(int);
8 Preconditions: in_stream != nullptr is true.
9 Effects: Equivalent to:
istream_iterator tmp = *this;
++*this;
return tmp;
template<class T, class charT, class traits, class Distance>
bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
const istream_iterator<T,charT,traits,Distance>& y);
10 Returns: x.in_stream == y.in_stream.
friend bool operator==(const istream_iterator& i, default_sentinel_t);
11 Returns: !i.in_stream.
24.6.3 Class template ostream_iterator [ostream.iterator]
24.6.3.1 General [ostream.iterator.general]
1 ostream_iterator writes (usingoperator<<) successive elements onto the output stream from which it was
constructed. If it was constructed withcharT* as a constructor argument, this string, called adelimiter
string, is written to the stream after everyT is written.
namespace std {
template<class T, class charT = char, class traits = char_traits<charT>>
class ostream_iterator {
public:
using iterator_category = output_iterator_tag;
using value_type = void;
using difference_type = ptrdiff_t;
using pointer = void;
using reference = void;
using char_type = charT;
using traits_type = traits;
using ostream_type = basic_ostream<charT,traits>;
ostream_iterator(ostream_type& s);
ostream_iterator(ostream_type& s, const charT* delimiter);
ostream_iterator(const ostream_iterator& x);
~ostream_iterator();
ostream_iterator& operator=(const ostream_iterator&) = default;
ostream_iterator& operator=(const T& value);
ostream_iterator& operator*();
ostream_iterator& operator++();
ostream_iterator& operator++(int);
private:
basic_ostream<charT,traits>* out_stream; // exposition only
const charT* delim; // exposition only
};
}
§ 24.6.3.1 © ISO/IEC
1229

===== PAGE 1241 =====

Dxxxx
24.6.3.2 Constructors and destructor [ostream.iterator.cons.des]
ostream_iterator(ostream_type& s);
1 Effects: Initializes out_stream with addressof(s) and delim with nullptr.
ostream_iterator(ostream_type& s, const charT* delimiter);
2 Effects: Initializes out_stream with addressof(s) and delim with delimiter.
24.6.3.3 Operations [ostream.iterator.ops]
ostream_iterator& operator=(const T& value);
1 Effects: As if by:
*out_stream << value;
if (delim)
*out_stream << delim;
return *this;
ostream_iterator& operator*();
2 Returns: *this.
ostream_iterator& operator++();
ostream_iterator& operator++(int);
3 Returns: *this.
24.6.4 Class template istreambuf_iterator [istreambuf.iterator]
24.6.4.1 General [istreambuf.iterator.general]
1 The class templateistreambuf_iterator defines an input iterator (24.3.5.3) that reads successivecharacters
from the streambuf for which it was constructed.operator* provides access to the current input character,
if any. Each timeoperator++ is evaluated, the iterator advances to the next input character. If the end
of stream is reached (streambuf_type::sgetc() returns traits::eof()), the iterator becomes equal to
the end-of-stream iterator value. The default constructor istreambuf_iterator() and the constructor
istreambuf_iterator(nullptr) both construct an end-of-stream iterator object suitable for use as an
end-of-range. All specializations ofistreambuf_iterator shall have a trivial copy constructor, aconstexpr
default constructor, and a trivial destructor.
2 The result ofoperator*()on an end-of-stream iterator is undefined. For any other iterator value achar_type
value is returned. It is impossible to assign a character via an input iterator.
namespace std {
template<class charT, class traits = char_traits<charT>>
class istreambuf_iterator {
public:
using iterator_category = input_iterator_tag;
using value_type = charT;
using difference_type = traits::off_type;
using pointer = unspecified ;
using reference = charT;
using char_type = charT;
using traits_type = traits;
using int_type = traits::int_type;
using streambuf_type = basic_streambuf<charT,traits>;
using istream_type = basic_istream<charT,traits>;
// 24.6.4.2, classistreambuf_iterator::proxy
class proxy ; // exposition only
constexpr istreambuf_iterator() noexcept;
constexpr istreambuf_iterator(default_sentinel_t) noexcept;
istreambuf_iterator(const istreambuf_iterator&) noexcept = default;
~istreambuf_iterator() = default;
istreambuf_iterator(istream_type& s) noexcept;
istreambuf_iterator(streambuf_type* s) noexcept;
§ 24.6.4.1 © ISO/IEC
1230

===== PAGE 1242 =====

Dxxxx
istreambuf_iterator(const proxy & p) noexcept;
istreambuf_iterator& operator=(const istreambuf_iterator&) noexcept = default;
charT operator*() const;
istreambuf_iterator& operator++();
proxy operator++(int);
bool equal(const istreambuf_iterator& b) const;
friend bool operator==(const istreambuf_iterator& i, default_sentinel_t s);
private:
streambuf_type* sbuf_; // exposition only
};
}
24.6.4.2 Class istreambuf_iterator::proxy [istreambuf.iterator.proxy]
1 Class istreambuf_iterator<charT,traits>::proxy is for exposition only. An implementation is per-
mitted to provide equivalent functionality without providing a class with this name. Classistreambuf_-
iterator<charT, traits>::proxy provides a temporary placeholder as the return value of the post-
increment operator (operator++). It keeps the character pointed to by the previous value of the iterator for
some possible future access to get the character.
namespace std {
template<class charT, class traits>
class istreambuf_iterator<charT, traits>::proxy { // exposition only
charT keep_;
basic_streambuf<charT,traits>* sbuf_;
proxy (charT c, basic_streambuf<charT,traits>* sbuf)
: keep_(c), sbuf_(sbuf) { }
public:
charT operator*() { return keep_; }
};
}
24.6.4.3 Constructors [istreambuf.iterator.cons]
1 For eachistreambuf_iterator constructor in this subclause, an end-of-stream iterator is constructed if and
only if the exposition-only membersbuf_ is initialized with a null pointer value.
constexpr istreambuf_iterator() noexcept;
constexpr istreambuf_iterator(default_sentinel_t) noexcept;
2 Effects: Initializes sbuf_ with nullptr.
istreambuf_iterator(istream_type& s) noexcept;
3 Effects: Initializes sbuf_ with s.rdbuf().
istreambuf_iterator(streambuf_type* s) noexcept;
4 Effects: Initializes sbuf_ with s.
istreambuf_iterator(const proxy & p) noexcept;
5 Effects: Initializes sbuf_ with p.sbuf_.
24.6.4.4 Operations [istreambuf.iterator.ops]
charT operator*() const;
1 Returns: The character obtained via thestreambuf member sbuf_->sgetc().
istreambuf_iterator& operator++();
2 Effects: As if bysbuf_->sbumpc().
3 Returns: *this.
proxy operator++(int);
4 Returns: proxy (sbuf_->sbumpc(), sbuf_).
§ 24.6.4.4 © ISO/IEC
1231

===== PAGE 1243 =====

Dxxxx
bool equal(const istreambuf_iterator& b) const;
5 Returns: true if and only if both iterators are at end-of-stream, or neither is at end-of-stream, regardless
of whatstreambuf object they use.
template<class charT, class traits>
bool operator==(const istreambuf_iterator<charT,traits>& a,
const istreambuf_iterator<charT,traits>& b);
6 Returns: a.equal(b).
friend bool operator==(const istreambuf_iterator& i, default_sentinel_t s);
7 Returns: i.equal(s).
24.6.5 Class template ostreambuf_iterator [ostreambuf.iterator]
24.6.5.1 General [ostreambuf.iterator.general]
1 The class templateostreambuf_iterator writes successivecharacters onto the output stream from which it
was constructed.
namespace std {
template<class charT, class traits = char_traits<charT>>
class ostreambuf_iterator {
public:
using iterator_category = output_iterator_tag;
using value_type = void;
using difference_type = ptrdiff_t;
using pointer = void;
using reference = void;
using char_type = charT;
using traits_type = traits;
using streambuf_type = basic_streambuf<charT,traits>;
using ostream_type = basic_ostream<charT,traits>;
ostreambuf_iterator(ostream_type& s) noexcept;
ostreambuf_iterator(streambuf_type* s) noexcept;
ostreambuf_iterator& operator=(charT c);
ostreambuf_iterator& operator*();
ostreambuf_iterator& operator++();
ostreambuf_iterator& operator++(int);
bool failed() const noexcept;
private:
streambuf_type* sbuf_; // exposition only
};
}
24.6.5.2 Constructors [ostreambuf.iter.cons]
ostreambuf_iterator(ostream_type& s) noexcept;
1 Preconditions: s.rdbuf() is not a null pointer.
2 Effects: Initializes sbuf_ with s.rdbuf().
ostreambuf_iterator(streambuf_type* s) noexcept;
3 Preconditions: s is not a null pointer.
4 Effects: Initializes sbuf_ with s.
24.6.5.3 Operations [ostreambuf.iter.ops]
ostreambuf_iterator& operator=(charT c);
1 Effects: If failed() yields false, callssbuf_->sputc(c); otherwise has no effect.
2 Returns: *this.
§ 24.6.5.3 © ISO/IEC
1232

===== PAGE 1244 =====

Dxxxx
ostreambuf_iterator& operator*();
3 Returns: *this.
ostreambuf_iterator& operator++();
ostreambuf_iterator& operator++(int);
4 Returns: *this.
bool failed() const noexcept;
5 Returns: true if in any prior use of member operator=, the call to sbuf_->sputc() returned
traits::eof(); orfalse otherwise.
24.7 Range access [iterator.range]
1 In addition to being available via inclusion of the<iterator> header, the function templates in 24.7 are
available when any of the following headers are included:
—(1.1) <array> (23.3.2)
—(1.2) <deque> (23.3.4)
—(1.3) <flat_map> (23.6.7)
—(1.4) <flat_set> (23.6.10)
—(1.5) <forward_list> (23.3.6)
—(1.6) <hive> (23.3.8)
—(1.7) <inplace_vector> (23.3.15)
—(1.8) <list> (23.3.10)
—(1.9) <map> (23.4.2)
—(1.10) <optional> (22.5.2)
—(1.11) <regex> (28.6.3)
—(1.12) <set> (23.4.5)
—(1.13) <span> (23.7.2.1)
—(1.14) <stacktrace> (19.6.2)
—(1.15) <string> (27.4.2)
—(1.16) <string_view> (27.3.2)
—(1.17) <unordered_map> (23.5.2)
—(1.18) <unordered_set> (23.5.5)
—(1.19) <valarray> (29.6.1)
—(1.20) <vector> (23.3.12)
template<class C> constexpr auto begin(C& c) noexcept(noexcept(c.begin()))
-> decltype(c.begin());
template<class C> constexpr auto begin(const C& c) noexcept(noexcept(c.begin()))
-> decltype(c.begin());
2 Returns: c.begin().
template<class C> constexpr auto end(C& c) noexcept(noexcept(c.end())) -> decltype(c.end());
template<class C> constexpr auto end(const C& c) noexcept(noexcept(c.end())) -> decltype(c.end());
3 Returns: c.end().
template<class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept;
4 Returns: array.
template<class T, size_t N> constexpr T* end(T (&array)[N]) noexcept;
5 Returns: array + N.
§ 24.7 © ISO/IEC
1233

===== PAGE 1245 =====

Dxxxx
template<class C> constexpr auto cbegin(const C& c) noexcept(noexcept(std::begin(c)))
-> decltype(std::begin(c));
6 Returns: std::begin(c).
template<class C> constexpr auto cend(const C& c) noexcept(noexcept(std::end(c)))
-> decltype(std::end(c));
7 Returns: std::end(c).
template<class C> constexpr auto rbegin(C& c) noexcept(noexcept(c.rbegin()))
-> decltype(c.rbegin());
template<class C> constexpr auto rbegin(const C& c) noexcept(noexcept(c.rbegin()))
-> decltype(c.rbegin());
8 Returns: c.rbegin().
template<class C> constexpr auto rend(C& c) noexcept(noexcept(c.rend())) -> decltype(c.rend());
template<class C> constexpr auto rend(const C& c) noexcept(noexcept(c.rend()))
-> decltype(c.rend());
9 Returns: c.rend().
template<class T, size_t N> constexpr reverse_iterator<T*> rbegin(T (&array)[N]) noexcept;
10 Returns: reverse_iterator<T*>(array + N).
template<class T, size_t N> constexpr reverse_iterator<T*> rend(T (&array)[N]) noexcept;
11 Returns: reverse_iterator<T*>(array).
template<class E> constexpr reverse_iterator<const E*> rbegin(initializer_list<E> il) noexcept;
12 Returns: reverse_iterator<const E*>(il.end()).
template<class E> constexpr reverse_iterator<const E*> rend(initializer_list<E> il) noexcept;
13 Returns: reverse_iterator<const E*>(il.begin()).
template<class C> constexpr auto crbegin(const C& c) noexcept(noexcept(std::rbegin(c)))
-> decltype(std::rbegin(c));
14 Returns: std::rbegin(c).
template<class C> constexpr auto crend(const C& c) noexcept(noexcept(c.crend()))
-> decltype(std::rend(c));
15 Returns: std::rend(c).
template<class C> constexpr auto size(const C& c) noexcept(noexcept(c.size()))
-> decltype(c.size());
16 Returns: c.size().
template<class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept;
17 Returns: N.
template<class C> constexpr auto ssize(const C& c) noexcept(noexcept(c.size()))
-> common_type_t<ptrdiff_t, make_signed_t<decltype(c.size())>>;
18 Effects: Equivalent to:
return static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(c.size())>>>(c.size());
template<class T, ptrdiff_t N> constexpr ptrdiff_t ssize(const T (&array)[N]) noexcept;
19 Returns: N.
template<class C> constexpr auto empty(const C& c) noexcept(noexcept(c.empty()))
-> decltype(c.empty());
20 Returns: c.empty().
§ 24.7 © ISO/IEC
1234

===== PAGE 1246 =====

Dxxxx
template<class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;
21 Returns: false.
template<class C> constexpr auto data(C& c) noexcept(noexcept(c.data())) -> decltype(c.data());
template<class C> constexpr auto data(const C& c) noexcept(noexcept(c.data()))
-> decltype(c.data());
22 Returns: c.data().
template<class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;
23 Returns: array.
§ 24.7 © ISO/IEC
1235

===== PAGE 1247 =====

Dxxxx
25 Ranges library [ranges]
25.1 General [ranges.general]
1 This Clause describes components for dealing with ranges of elements.
2 The following subclauses describe range and view requirements, and components for range primitives and
range generators as summarized in Table 84.
Table 84 — Ranges library summary [tab:range.summary]
Subclause Header
25.3 Range access <ranges>
25.4 Requirements
25.5 Range utilities
25.6 Range factories
25.7 Range adaptors
25.8 Range generators <generator>
25.2 Header <ranges> synopsis [ranges.syn]
// mostly freestanding
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
#include <iterator> // see 24.2
namespace std::ranges {
inline namespace unspecified {
// 25.3, range access
inline constexpr unspecified begin = unspecified ;
inline constexpr unspecified end = unspecified ;
inline constexpr unspecified cbegin = unspecified ;
inline constexpr unspecified cend = unspecified ;
inline constexpr unspecified rbegin = unspecified ;
inline constexpr unspecified rend = unspecified ;
inline constexpr unspecified crbegin = unspecified ;
inline constexpr unspecified crend = unspecified ;
inline constexpr unspecified size = unspecified ;
inline constexpr unspecified reserve_hint = unspecified ;
inline constexpr unspecified ssize = unspecified ;
inline constexpr unspecified empty = unspecified ;
inline constexpr unspecified data = unspecified ;
inline constexpr unspecified cdata = unspecified ;
}
// 25.4.2, ranges
template<class T>
concept range = see below ;
template<class T>
constexpr bool enable_borrowed_range = false;
template<class T>
concept borrowed_range = see below ;
template<class T>
using iterator_t = decltype(ranges::begin(declval<T&>()));
§ 25.2 © ISO/IEC
1236

===== PAGE 1248 =====

Dxxxx
template<range R>
using sentinel_t = decltype(ranges::end(declval<R&>()));
template<range R>
using const_iterator_t = decltype(ranges::cbegin(declval<R&>()));
template<range R>
using const_sentinel_t = decltype(ranges::cend(declval<R&>()));
template<range R>
using range_difference_t = iter_difference_t<iterator_t<R>>;
template<sized_range R>
using range_size_t = decltype(ranges::size(declval<R&>()));
template<range R>
using range_value_t = iter_value_t<iterator_t<R>>;
template<range R>
using range_reference_t = iter_reference_t<iterator_t<R>>;
template<range R>
using range_const_reference_t = iter_const_reference_t<iterator_t<R>>;
template<range R>
using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<R>>;
template<range R>
using range_common_reference_t = iter_common_reference_t<iterator_t<R>>;
// 25.4.4, sized ranges
template<class>
constexpr bool disable_sized_range = false;
template<class T>
concept approximately_sized_range = see below ;
template<class T>
concept sized_range = see below ;
// 25.4.5, views
template<class T>
constexpr bool enable_view = see below ;
struct view_base {};
template<class T>
concept view = see below ;
// 25.4.6, other range refinements
template<class R, class T>
concept output_range = see below ;
template<class T>
concept input_range = see below ;
template<class T>
concept forward_range = see below ;
template<class T>
concept bidirectional_range = see below ;
template<class T>
concept random_access_range = see below ;
template<class T>
concept contiguous_range = see below ;
template<class T>
concept common_range = see below ;
template<class T>
concept viewable_range = see below ;
§ 25.2 © ISO/IEC
1237

===== PAGE 1249 =====

Dxxxx
template<class T>
concept constant_range = see below ;
template<class T>
concept sized-random-access-range = see below; // exposition only
// 25.5.3, class templateview_interface
template<class D>
requires is_class_v<D> && same_as<D, remove_cv_t<D>>
class view_interface;
// 25.5.4, sub-ranges
enum class subrange_kind : bool { unsized, sized };
template<input_or_output_iterator I, sentinel_for<I> S = I, subrange_kind K = see below >
requires (K == subrange_kind::sized || !sized_sentinel_for<S, I>)
class subrange;
template<class I, class S, subrange_kind K>
constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;
template<size_t N, class I, class S, subrange_kind K>
requires ((N == 0 && copyable<I>) || N == 1)
constexpr auto get(const subrange<I, S, K>& r);
template<size_t N, class I, class S, subrange_kind K>
requires (N < 2)
constexpr auto get(subrange<I, S, K>&& r);
}
namespace std {
using ranges::get;
}
namespace std::ranges {
// 25.5.5, dangling iterator handling
struct dangling;
// 25.5.6, class templateelements_of
template<range R, class Allocator = allocator<byte>>
struct elements_of; // hosted
template<range R>
using borrowed_iterator_t = see below ;
template<range R>
using borrowed_subrange_t = see below ;
// 25.5.7, range conversions
template<class C, input_range R, class... Args> requires (!view<C>)
constexpr C to(R&& r, Args&&... args);
template<template<class...> class C, input_range R, class... Args>
constexpr auto to(R&& r, Args&&... args);
template<class C, class... Args> requires (!view<C>)
constexpr auto to(Args&&... args);
template<template<class...> class C, class... Args>
constexpr auto to(Args&&... args);
// 25.6.2, empty view
template<class T>
requires is_object_v<T>
class empty_view;
§ 25.2 © ISO/IEC
1238

===== PAGE 1250 =====

Dxxxx
template<class T>
constexpr bool enable_borrowed_range<empty_view<T>> = true;
namespace views {
template<class T>
constexpr empty_view<T> empty{};
}
// 25.6.3, single view
template<move_constructible T>
requires is_object_v<T>
class single_view;
namespace views { inline constexpr unspecified single = unspecified; }
template<bool Const, class T>
using maybe-const = conditional_t<Const, const T, T>; // exposition only
// 25.6.4, iota view
template<weakly_incrementable W, semiregular Bound = unreachable_sentinel_t>
requires weakly-equality-comparable-with <W, Bound> && copyable<W>
class iota_view;
template<class W, class Bound>
constexpr bool enable_borrowed_range<iota_view<W, Bound>> = true;
namespace views {
inline constexpr unspecified iota = unspecified;
inline constexpr unspecified indices = unspecified;
}
// 25.6.5, repeat view
template<move_constructible T, semiregular Bound = unreachable_sentinel_t>
requires see below
class repeat_view;
namespace views { inline constexpr unspecified repeat = unspecified; }
// 25.6.6, istream view
template<movable Val, class CharT, class Traits = char_traits<CharT>>
requires see below
class basic_istream_view; // hosted
template<class Val>
using istream_view = basic_istream_view<Val, char>; // hosted
template<class Val>
using wistream_view = basic_istream_view<Val, wchar_t>; // hosted
namespace views {
template<class T> constexpr unspecified istream = unspecified; // hosted
}
// 25.7.2, range adaptor objects
template<class D>
requires is_class_v<D> && same_as<D, remove_cv_t<D>>
class range_adaptor_closure { };
// 25.7.6, all view
namespace views {
inline constexpr unspecified all = unspecified;
template<viewable_range R>
using all_t = decltype(all(declval<R>()));
}
§ 25.2 © ISO/IEC
1239

===== PAGE 1251 =====

Dxxxx
// 25.7.6.2, ref view
template<range R>
requires is_object_v<R>
class ref_view;
template<class T>
constexpr bool enable_borrowed_range<ref_view<T>> = true;
// 25.7.6.3, owning view
template<range R>
requires see below
class owning_view;
template<class T>
constexpr bool enable_borrowed_range<owning_view<T>> =
enable_borrowed_range<T>;
// 25.7.7, as rvalue view
template<view V>
requires input_range<V>
class as_rvalue_view;
template<class T>
constexpr bool enable_borrowed_range<as_rvalue_view<T>> =
enable_borrowed_range<T>;
namespace views { inline constexpr unspecified as_rvalue = unspecified; }
// 25.7.8, filter view
template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
requires view<V> && is_object_v<Pred>
class filter_view;
namespace views { inline constexpr unspecified filter = unspecified; }
// 25.7.9, transform view
template<input_range V, move_constructible F>
requires view<V> && is_object_v<F> &&
regular_invocable<F&, range_reference_t<V>> &&
can-reference <invoke_result_t<F&, range_reference_t<V>>>
class transform_view;
namespace views { inline constexpr unspecified transform = unspecified; }
// 25.7.10, take view
template<view> class take_view;
template<class T>
constexpr bool enable_borrowed_range<take_view<T>> =
enable_borrowed_range<T>;
namespace views { inline constexpr unspecified take = unspecified; }
// 25.7.11, take while view
template<view V, class Pred>
requires input_range<V> && is_object_v<Pred> &&
indirect_unary_predicate<const Pred, iterator_t<V>>
class take_while_view;
namespace views { inline constexpr unspecified take_while = unspecified; }
// 25.7.12, drop view
template<view V>
class drop_view;
§ 25.2 © ISO/IEC
1240

===== PAGE 1252 =====

Dxxxx
template<class T>
constexpr bool enable_borrowed_range<drop_view<T>> =
enable_borrowed_range<T>;
namespace views { inline constexpr unspecified drop = unspecified; }
// 25.7.13, drop while view
template<view V, class Pred>
requires input_range<V> && is_object_v<Pred> &&
indirect_unary_predicate<const Pred, iterator_t<V>>
class drop_while_view;
template<class T, class Pred>
constexpr bool enable_borrowed_range<drop_while_view<T, Pred>> =
enable_borrowed_range<T>;
namespace views { inline constexpr unspecified drop_while = unspecified; }
// 25.7.14, join view
template<input_range V>
requires view<V> && input_range<range_reference_t<V>>
class join_view;
namespace views { inline constexpr unspecified join = unspecified; }
// 25.7.15, join with view
template<input_range V, forward_range Pattern>
requires see below
class join_with_view;
namespace views { inline constexpr unspecified join_with = unspecified; }
// 25.7.16, lazy split view
template<class R>
concept tiny-range = see below ; // exposition only
template<input_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
(forward_range<V> || tiny-range <Pattern>)
class lazy_split_view;
// 25.7.17, split view
template<forward_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to>
class split_view;
namespace views {
inline constexpr unspecified lazy_split = unspecified;
inline constexpr unspecified split = unspecified;
}
// 25.7.18, concat view
template<input_range... Views>
requires see below
class concat_view;
namespace views { inline constexpr unspecified concat = unspecified; }
// 25.7.19, counted view
namespace views { inline constexpr unspecified counted = unspecified; }
§ 25.2 © ISO/IEC
1241

===== PAGE 1253 =====

Dxxxx
// 25.7.20, common view
template<view V>
requires (!common_range<V> && copyable<iterator_t<V>>)
class common_view;
template<class T>
constexpr bool enable_borrowed_range<common_view<T>> =
enable_borrowed_range<T>;
namespace views { inline constexpr unspecified common = unspecified; }
// 25.7.21, reverse view
template<view V>
requires bidirectional_range<V>
class reverse_view;
template<class T>
constexpr bool enable_borrowed_range<reverse_view<T>> =
enable_borrowed_range<T>;
namespace views { inline constexpr unspecified reverse = unspecified; }
// 25.7.22, as const view
template<input_range R>
constexpr auto& possibly-const-range (R& r) noexcept { // exposition only
if constexpr (input_range<const R>) {
return const_cast<const R&>(r);
} else {
return r;
}
}
template<view V>
requires input_range<V>
class as_const_view;
template<class T>
constexpr bool enable_borrowed_range<as_const_view<T>> =
enable_borrowed_range<T>;
namespace views { inline constexpr unspecified as_const = unspecified; }
// 25.7.23, elements view
template<input_range V, size_t N>
requires see below
class elements_view;
template<class T, size_t N>
constexpr bool enable_borrowed_range<elements_view<T, N>> =
enable_borrowed_range<T>;
template<class R>
using keys_view = elements_view<R, 0>;
template<class R>
using values_view = elements_view<R, 1>;
namespace views {
template<size_t N>
constexpr unspecified elements = unspecified;
inline constexpr auto keys = elements<0>;
inline constexpr auto values = elements<1>;
}
§ 25.2 © ISO/IEC
1242

===== PAGE 1254 =====

Dxxxx
// 25.7.24, enumerate view
template<view V>
requires see below
class enumerate_view;
template<class View>
constexpr bool enable_borrowed_range<enumerate_view<View>> =
enable_borrowed_range<View>;
namespace views { inline constexpr unspecified enumerate = unspecified; }
// 25.7.25, zip view
template<input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0)
class zip_view;
template<class... Views>
constexpr bool enable_borrowed_range<zip_view<Views...>> =
(enable_borrowed_range<Views> && ...);
namespace views { inline constexpr unspecified zip = unspecified; }
// 25.7.26, zip transform view
template<move_constructible F, input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0) && is_object_v<F> &&
regular_invocable<F&, range_reference_t<Views>...> &&
can-reference <invoke_result_t<F&, range_reference_t<Views>...>>
class zip_transform_view;
namespace views { inline constexpr unspecified zip_transform = unspecified; }
// 25.7.27, adjacent view
template<forward_range V, size_t N>
requires view<V> && (N > 0)
class adjacent_view;
template<class V, size_t N>
constexpr bool enable_borrowed_range<adjacent_view<V, N>> =
enable_borrowed_range<V>;
namespace views {
template<size_t N>
constexpr unspecified adjacent = unspecified;
inline constexpr auto pairwise = adjacent<2>;
}
// 25.7.28, adjacent transform view
template<forward_range V, move_constructible F, size_t N>
requires see below
class adjacent_transform_view;
namespace views {
template<size_t N>
constexpr unspecified adjacent_transform = unspecified;
inline constexpr auto pairwise_transform = adjacent_transform<2>;
}
// 25.7.29, chunk view
template<view V>
requires input_range<V>
class chunk_view;
§ 25.2 © ISO/IEC
1243

===== PAGE 1255 =====

Dxxxx
template<view V>
requires forward_range<V>
class chunk_view<V>;
template<class V>
constexpr bool enable_borrowed_range<chunk_view<V>> =
forward_range<V> && enable_borrowed_range<V>;
namespace views { inline constexpr unspecified chunk = unspecified; }
// 25.7.30, slide view
template<forward_range V>
requires view<V>
class slide_view;
template<class V>
constexpr bool enable_borrowed_range<slide_view<V>> =
enable_borrowed_range<V>;
namespace views { inline constexpr unspecified slide = unspecified; }
// 25.7.31, chunk by view
template<forward_range V, indirect_binary_predicate<iterator_t<V>, iterator_t<V>> Pred>
requires view<V> && is_object_v<Pred>
class chunk_by_view;
namespace views { inline constexpr unspecified chunk_by = unspecified; }
// 25.7.32, stride view
template<input_range V>
requires view<V>
class stride_view;
template<class V>
constexpr bool enable_borrowed_range<stride_view<V>> =
enable_borrowed_range<V>;
namespace views { inline constexpr unspecified stride = unspecified; }
// 25.7.33, cartesian product view
template<input_range First, forward_range... Vs>
requires (view<First> && ... && view<Vs>)
class cartesian_product_view;
namespace views { inline constexpr unspecified cartesian_product = unspecified; }
// 25.7.34, cache latest view
template<input_range V>
requires view<V>
class cache_latest_view;
namespace views { inline constexpr unspecified cache_latest = unspecified ; }
// 25.7.35, to input view
template<input_range V>
requires view<V>
class to_input_view;
template<class V>
constexpr bool enable_borrowed_range<to_input_view<V>> =
enable_borrowed_range<V>;
namespace views { inline constexpr unspecified to_input = unspecified ; }
}
§ 25.2 © ISO/IEC
1244

===== PAGE 1256 =====

Dxxxx
namespace std {
namespace views = ranges::views;
template<class T> struct tuple_size;
template<size_t I, class T> struct tuple_element;
template<class I, class S, ranges::subrange_kind K>
struct tuple_size<ranges::subrange<I, S, K>>
: integral_constant<size_t, 2> {};
template<class I, class S, ranges::subrange_kind K>
struct tuple_element<0, ranges::subrange<I, S, K>> {
using type = I;
};
template<class I, class S, ranges::subrange_kind K>
struct tuple_element<1, ranges::subrange<I, S, K>> {
using type = S;
};
template<class I, class S, ranges::subrange_kind K>
struct tuple_element<0, const ranges::subrange<I, S, K>> {
using type = I;
};
template<class I, class S, ranges::subrange_kind K>
struct tuple_element<1, const ranges::subrange<I, S, K>> {
using type = S;
};
struct from_range_t { explicit from_range_t() = default; };
inline constexpr from_range_t from_range{};
}
1 Within this Clause, for an integer-like typeX(24.3.4.4), make-unsigned-like-t<X>denotesmake_unsigned_-
t<X> if X is an integer type; otherwise, it denotes a corresponding unspecified unsigned-integer-like type
of the same width asX. For an expressionx of typeX, to-unsigned-like(x) is x explicitly converted to
make-unsigned-like-t<X>.
2 Also within this Clause,make-signed-like-t <X> for an integer-like typeX denotes make_signed_t<X> if
X is an integer type; otherwise, it denotes a corresponding unspecified signed-integer-like type of the same
width asX.
25.3 Range access [range.access]
25.3.1 General [range.access.general]
1 In addition to being available via inclusion of the<ranges> header, the customization point objects in 25.3
are available when the header<iterator> (24.2) is included.
2 Within 25.3, thereified objectof a subexpressionE denotes
—(2.1) the same object asE if E is a glvalue, or
—(2.2) the result of applying the temporary materialization conversion (7.3.5) toE otherwise.
25.3.2 ranges::begin [range.access.begin]
1 The nameranges::begin denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::begin(E) is ill-
formed.
—(2.2) Otherwise, if T is an array type (9.3.4.5) and remove_all_extents_t<T> is an incomplete type,
ranges::begin(E) is ill-formed with no diagnostic required.
—(2.3) Otherwise, ifT is an array type,ranges::begin(E) is expression-equivalent tot + 0.
—(2.4) Otherwise, if auto(t.begin()) is a valid expression whose type modelsinput_or_output_iterator,
ranges::begin(E) is expression-equivalent toauto(t.begin()).
§ 25.3.2 © ISO/IEC
1245

===== PAGE 1257 =====

Dxxxx
—(2.5) Otherwise, ifT is a class or enumeration type andauto(begin(t)) is a valid expression whose type
models input_or_output_iterator where the meaning ofbegin is established as-if by performing
argument-dependent lookup only (6.5.4), thenranges::begin(E) is expression-equivalent to that
expression.
—(2.6) Otherwise, ranges::begin(E) is ill-formed.
3 [Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::begin(E) appears in the
immediate context of a template instantiation.—end note]
4 [Note 2: Whenever ranges::begin(E) is a valid expression, its type modelsinput_or_output_iterator. —end
note]
25.3.3 ranges::end [range.access.end]
1 The nameranges::end denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::end(E) is ill-
formed.
—(2.2) Otherwise, if T is an array type (9.3.4.5) and remove_all_extents_t<T> is an incomplete type,
ranges::end(E) is ill-formed with no diagnostic required.
—(2.3) Otherwise, ifT is an array of unknown bound,ranges::end(E) is ill-formed.
—(2.4) Otherwise, ifT is an array,ranges::end(E) is expression-equivalent tot + extent_v<T>.
—(2.5) Otherwise, ifauto(t.end()) is a valid expression whose type modelssentinel_for<iterator_t<T>>
then ranges::end(E) is expression-equivalent toauto(t.end()).
—(2.6) Otherwise, ifT is a class or enumeration type andauto(end(t)) is a valid expression whose type models
sentinel_for<iterator_t<T>> where the meaning ofend is established as-if by performing argument-
dependent lookup only (6.5.4), thenranges::end(E) is expression-equivalent to that expression.
—(2.7) Otherwise, ranges::end(E) is ill-formed.
3 [Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::end(E) appears in the
immediate context of a template instantiation.—end note]
4 [Note 2: Wheneverranges::end(E) is a valid expression, the typesS and I of ranges::end(E) and ranges::begin(E)
model sentinel_for<S, I>. —end note]
25.3.4 ranges::cbegin [range.access.cbegin]
1 The nameranges::cbegin denotes a customization point object (16.3.3.3.5). Given a subexpressionE with
type T, lett be an lvalue that denotes the reified object forE. Then:
—(1.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::cbegin(E) is
ill-formed.
—(1.2) Otherwise, letU be ranges::begin(possibly-const-range (t)). ranges::cbegin(E) is expression-
equivalent toconst_iterator<decltype(U)>(U).
2 [Note 1: Whenever ranges::cbegin(E) is a valid expression, its type models input_or_output_iterator and
constant-iterator . —end note]
25.3.5 ranges::cend [range.access.cend]
1 The nameranges::cend denotes a customization point object (16.3.3.3.5). Given a subexpressionE with
type T, lett be an lvalue that denotes the reified object forE. Then:
—(1.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::cend(E) is ill-
formed.
—(1.2) Otherwise, let U be ranges::end(possibly-const-range (t)). ranges::cend(E) is expression-
equivalent toconst_sentinel<decltype(U)>(U).
2 [Note 1: Wheneverranges::cend(E) is a valid expression, the typesS and I of the expressionsranges::cend(E) and
ranges::cbegin(E) model sentinel_for<S, I>. If S models input_iterator, thenS also modelsconstant-itera-
tor . —end note]
§ 25.3.5 © ISO/IEC
1246

===== PAGE 1258 =====

Dxxxx
25.3.6 ranges::rbegin [range.access.rbegin]
1 The nameranges::rbegin denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::rbegin(E) is
ill-formed.
—(2.2) Otherwise, if T is an array type (9.3.4.5) and remove_all_extents_t<T> is an incomplete type,
ranges::rbegin(E) is ill-formed with no diagnostic required.
—(2.3) Otherwise, ifauto(t.rbegin()) is a valid expression whose type modelsinput_or_output_iterator,
ranges::rbegin(E) is expression-equivalent toauto(t.rbegin()).
—(2.4) Otherwise, ifT is a class or enumeration type andauto(rbegin(t)) is a valid expression whose type
models input_or_output_iterator where the meaning ofrbegin is established as-if by performing
argument-dependent lookup only (6.5.4), thenranges::rbegin(E) is expression-equivalent to that
expression.
—(2.5) Otherwise, if bothranges::begin(t) and ranges::end(t) are valid expressions of the same type
which modelsbidirectional_iterator (24.3.4.12), ranges::rbegin(E) is expression-equivalent to
make_reverse_iterator(ranges::end(t)).
—(2.6) Otherwise, ranges::rbegin(E) is ill-formed.
3 [Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::rbegin(E) appears in the
immediate context of a template instantiation.—end note]
4 [Note 2: Whenever ranges::rbegin(E) is a valid expression, its type modelsinput_or_output_iterator. —end
note]
25.3.7 ranges::rend [range.access.rend]
1 The nameranges::rend denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::rend(E) is ill-
formed.
—(2.2) Otherwise, if T is an array type (9.3.4.5) and remove_all_extents_t<T> is an incomplete type,
ranges::rend(E) is ill-formed with no diagnostic required.
—(2.3) Otherwise, if auto(t.rend()) is a valid expression whose type modelssentinel_for<decltype(
ranges::rbegin(E))> then ranges::rend(E) is expression-equivalent toauto(t.rend()).
—(2.4) Otherwise, if T is a class or enumeration type andauto(rend(t)) is a valid expression whose type
models sentinel_for<decltype(ranges::rbegin(E))>where the meaning ofrendis established as-if
by performing argument-dependent lookup only (6.5.4), thenranges::rend(E) is expression-equivalent
to that expression.
—(2.5) Otherwise, if bothranges::begin(t) and ranges::end(t) are valid expressions of the same type
which modelsbidirectional_iterator (24.3.4.12), thenranges::rend(E) is expression-equivalent
to make_reverse_iterator(ranges::begin(t)).
—(2.6) Otherwise, ranges::rend(E) is ill-formed.
3 [Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::rend(E) appears in the
immediate context of a template instantiation.—end note]
4 [Note 2: Whenever ranges::rend(E) is a valid expression, the typesS and I of the expressionsranges::rend(E)
and ranges::rbegin(E) model sentinel_for<S, I>. —end note]
25.3.8 ranges::crbegin [range.access.crbegin]
1 The nameranges::crbegin denotes a customization point object (16.3.3.3.5). Given a subexpressionE with
type T, lett be an lvalue that denotes the reified object forE. Then:
—(1.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::crbegin(E) is
ill-formed.
—(1.2) Otherwise, let U be ranges::rbegin(possibly-const-range (t)). ranges::crbegin(E) is expres-
sion-equivalent toconst_iterator<decltype(U)>(U).
§ 25.3.8 © ISO/IEC
1247

===== PAGE 1259 =====

Dxxxx
2 [Note 1: Whenever ranges::crbegin(E) is a valid expression, its type modelsinput_or_output_iterator and
constant-iterator . —end note]
25.3.9 ranges::crend [range.access.crend]
1 The nameranges::crend denotes a customization point object (16.3.3.3.5). Given a subexpressionE with
type T, lett be an lvalue that denotes the reified object forE. Then:
—(1.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::crend(E) is ill-
formed.
—(1.2) Otherwise, let U be ranges::rend(possibly-const-range (t)). ranges::crend(E) is expression-
equivalent toconst_sentinel<decltype(U)>(U).
2 [Note 1: Wheneverranges::crend(E) is a valid expression, the typesS andI of the expressionsranges::crend(E) and
ranges::crbegin(E) model sentinel_for<S, I>. If S models input_iterator, thenS also modelsconstant-itera-
tor . —end note]
25.3.10 ranges::size [range.prim.size]
1 The nameranges::size denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If T is an array of unknown bound (9.3.4.5),ranges::size(E) is ill-formed.
—(2.2) Otherwise, ifT is an array type,ranges::size(E) is expression-equivalent toauto(extent_v<T>).
—(2.3) Otherwise, if disable_sized_range<remove_cv_t<T>> (25.4.4) is false and auto(t.size()) is a
valid expression of integer-like type (24.3.4.4),ranges::size(E) is expression-equivalent toauto(
t.size()).
—(2.4) Otherwise, if T is a class or enumeration type,disable_sized_range<remove_cv_t<T>> is false and
auto(size(t)) is a valid expression of integer-like type where the meaning ofsize is established as-if
by performing argument-dependent lookup only (6.5.4), thenranges::size(E) is expression-equivalent
to that expression.
—(2.5) Otherwise, if to-unsigned-like(ranges::end(t) - ranges::begin(t)) (25.2) is a valid expres-
sion and the typesI and S of ranges::begin(t) and ranges::end(t) (respectively) model both
sized_sentinel_for<S, I> (24.3.4.8) andforward_iterator<I>, thenranges::size(E) is expres-
sion-equivalent toto-unsigned-like(ranges::end(t) - ranges::begin(t)).
—(2.6) Otherwise, ranges::size(E) is ill-formed.
3 [Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::size(E) appears in the
immediate context of a template instantiation.—end note]
4 [Note 2: Wheneverranges::size(E) is a valid expression, its type is integer-like.—end note]
25.3.11 ranges::ssize [range.prim.ssize]
1 The nameranges::ssize denotes a customization point object (16.3.3.3.5).
2 Givenasubexpression Ewithtype T, lettbeanlvaluethatdenotesthereifiedobjectfor E. Ifranges::size(t)
is ill-formed,ranges::ssize(E) is ill-formed. Otherwise letD be make-signed-like-t <decltype(ranges::
size(t))>, or ptrdiff_t if it is wider than that type; ranges::ssize(E) is expression-equivalent to
static_cast<D>(ranges::size(t)).
25.3.12 ranges::reserve_hint [range.prim.size.hint]
1 The nameranges::reserve_hint denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If ranges::size(E) is a valid expression, ranges::reserve_hint(E) is expression-equivalent to
ranges::size(E).
—(2.2) Otherwise, ifauto(t.reserve_hint())is a valid expression of integer-like type (24.3.4.4),ranges::re-
serve_hint(E) is expression-equivalent toauto(t.reserve_hint()).
—(2.3) Otherwise, if T is a class or enumeration type andauto(reserve_hint(t)) is a valid expression of
integer-like type where the meaning ofreserve_hint is established as-if by performing argument-
dependent lookup only (6.5.4), thenranges::reserve_hint(E) is expression-equivalent to that ex-
pression.
§ 25.3.12 © ISO/IEC
1248

===== PAGE 1260 =====

Dxxxx
—(2.4) Otherwise, ranges::reserve_hint(E) is ill-formed.
[Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::reserve_hint(E) appears in
the immediate context of a template instantiation.—end note]
[Note 2: Wheneverranges::reserve_hint(E) is a valid expression, its type is integer-like.—end note]
25.3.13 ranges::empty [range.prim.empty]
1 The nameranges::empty denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If T is an array of unknown bound (9.3.4.5),ranges::empty(E) is ill-formed.
—(2.2) Otherwise, if bool(t.empty()) is a valid expression,ranges::empty(E) is expression-equivalent to
bool(t.empty()).
—(2.3) Otherwise, if (ranges::size(t) == 0) is a valid expression,ranges::empty(E) is expression-equiva-
lent to(ranges::size(t) == 0).
—(2.4) Otherwise, if bool(ranges::begin(t) == ranges::end(t)) is a valid expression and the type of
ranges::begin(t) models forward_iterator, ranges::empty(E) is expression-equivalent tobool(
ranges::begin(t) == ranges::end(t)).
—(2.5) Otherwise, ranges::empty(E) is ill-formed.
3 [Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::empty(E) appears in the
immediate context of a template instantiation.—end note]
4 [Note 2: Wheneverranges::empty(E) is a valid expression, it has typebool. —end note]
25.3.14 ranges::data [range.prim.data]
1 The nameranges::data denotes a customization point object (16.3.3.3.5).
2 Given a subexpressionE with typeT, lett be an lvalue that denotes the reified object forE. Then:
—(2.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::data(E) is ill-
formed.
—(2.2) Otherwise, if T is an array type (9.3.4.5) and remove_all_extents_t<T> is an incomplete type,
ranges::data(E) is ill-formed with no diagnostic required.
—(2.3) Otherwise, if auto(t.data()) is a valid expression of pointer to object type,ranges::data(E) is
expression-equivalent toauto(t.data()).
—(2.4) Otherwise, if ranges::begin(t) is a valid expression whose type models contiguous_iterator,
ranges::data(E) is expression-equivalent toto_address(ranges::begin(t)).
—(2.5) Otherwise, ranges::data(E) is ill-formed.
3 [Note 1: Diagnosable ill-formed cases above result in substitution failure whenranges::data(E) appears in the
immediate context of a template instantiation.—end note]
4 [Note 2: Wheneverranges::data(E) is a valid expression, it has pointer to object type.—end note]
25.3.15 ranges::cdata [range.prim.cdata]
template<class T>
constexpr auto as-const-pointer (const T* p) noexcept { return p; } // exposition only
1 The nameranges::cdata denotes a customization point object (16.3.3.3.5). Given a subexpressionE with
type T, lett be an lvalue that denotes the reified object forE. Then:
—(1.1) If E is an rvalue andenable_borrowed_range<remove_cv_t<T>> is false, ranges::cdata(E) is ill-
formed.
—(1.2) Otherwise, ranges::cdata(E) is expression-equivalent toas-const-pointer (ranges::data(possi-
bly-const-range (t))).
2 [Note 1: Wheneverranges::cdata(E) is a valid expression, it has pointer to constant object type.—end note]
§ 25.3.15 © ISO/IEC
1249

===== PAGE 1261 =====

Dxxxx
25.4 Range requirements [range.req]
25.4.1 General [range.req.general]
1 Ranges are an abstraction that allows a C++ program to operate on elements of data structures uniformly. Call-
ing ranges::begin on a range returns an object whose type modelsinput_or_output_iterator (24.3.4.6).
Calling ranges::end on a range returns an object whose typeS, together with the typeI of the object
returned byranges::begin, modelssentinel_for<S, I>. The library formalizes the interfaces, semantics,
and complexity of ranges to enable algorithms and range adaptors that work efficiently on different types of
sequences.
2 The range concept requires thatranges::begin and ranges::end return an iterator and a sentinel, respec-
tively. Thesized_range concept refinesrange with the requirement thatranges::size be amortizedO(1).
The view concept specifies requirements on arange type to provide operations with predictable complexity.
3 Several refinements ofrange group requirements that arise frequently in concepts and algorithms. Common
ranges are ranges for whichranges::beginand ranges::endreturn objects of the same type. Random access
ranges are ranges for whichranges::begin returns a type that modelsrandom_access_iterator (24.3.4.13).
(Contiguous, bidirectional, forward, input, and output ranges are defined similarly.) Viewable ranges can be
converted to views.
25.4.2 Ranges [range.range]
1 The range concept defines the requirements of a type that allows iteration over its elements by providing an
iterator and sentinel that denote the elements of the range.
template<class T>
concept range =
requires(T& t) {
ranges::begin(t); // sometimes equality-preserving (see below)
ranges::end(t);
};
2 Given an expressiont such thatdecltype((t)) is T&, T models range only if
—(2.1) [ranges::begin(t),ranges::end(t)) denotes a range (24.3.1),
—(2.2) both ranges::begin(t) and ranges::end(t) are amortized constant time and non-modifying,
and
—(2.3) if the type of ranges::begin(t) models forward_iterator, ranges::begin(t) is equality-
preserving.
3 [Note 1: Equality preservation of bothranges::begin and ranges::end enables passing a range whose iterator
type modelsforward_iterator to multiple algorithms and making multiple passes over the range by repeated
calls toranges::begin and ranges::end. Since ranges::begin is not required to be equality-preserving when
the return type does not modelforward_iterator, it is possible for repeated calls to not return equal values or
to not be well-defined.—end note]
template<class T>
concept borrowed_range =
range<T> && (is_lvalue_reference_v<T> || enable_borrowed_range<remove_cvref_t<T>>);
4 Let U be remove_reference_t<T> if T is an rvalue reference type, andT otherwise. Given a variableu
of typeU, T models borrowed_range only if the validity of iterators obtained fromu is not tied to the
lifetime of that variable.
5 [Note 2: Since the validity of iterators is not tied to the lifetime of a variable whose type modelsborrowed_range,
a function with a parameter of such a type can return iterators obtained from it without danger of dangling.
—end note]
template<class>
constexpr bool enable_borrowed_range = false;
6 Remarks: Pursuant to 16.4.5.2.1, users may specializeenable_borrowed_range for cv-unqualified
program-defined types. Such specializations shall be usable in constant expressions (7.7) and have type
const bool.
7 [Example 1: Each specializationS of class templatesubrange (25.5.4) modelsborrowed_range because
—(7.1) enable_borrowed_range<S> is specialized to have the valuetrue, and
§ 25.4.2 © ISO/IEC
1250

===== PAGE 1262 =====

Dxxxx
—(7.2) S’s iterators do not have validity tied to the lifetime of anS object because they are “borrowed” from
some other range.
—end example]
25.4.3 Approximately sized ranges [range.approximately.sized]
1 The approximately_sized_range concept refinesrange with the requirement that an approximation of the
number of elements in the range can be determined in amortized constant time usingranges::reserve_hint.
template<class T>
concept approximately_sized_range =
range<T> && requires(T& t) { ranges::reserve_hint(t); };
2 Given an lvaluet of typeremove_reference_t<T>, T models approximately_sized_range only if
—(2.1) ranges::reserve_hint(t) is amortizedO(1), does not modifyt, and has a value that is not
negative and is representable inrange_difference_t<T>, and
—(2.2) if iterator_t<T> models forward_iterator, ranges::reserve_hint(t) is well-defined regard-
less of the evaluation ofranges::begin(t).
[Note 1: ranges::reserve_hint(t) is otherwise not required to be well-defined after evaluatingranges::
begin(t). For example, it is possible forranges::reserve_hint(t) to be well-defined for anapproximate-
ly_sized_range whose iterator type does not modelforward_iterator only if evaluated before the first
call toranges::begin(t). —end note]
25.4.4 Sized ranges [range.sized]
1 The sized_range concept refinesapproximately_sized_range with the requirement that the number of
elements in the range can be determined in amortized constant time usingranges::size.
template<class T>
concept sized_range =
approximately_sized_range<T> && requires(T& t) { ranges::size(t); };
2 Given an lvaluet of typeremove_reference_t<T>, T models sized_range only if
—(2.1) ranges::size(t) is amortized O(1), does not modifyt, and is equal toranges::distance(
ranges::begin(t), ranges::end(t)), and
—(2.2) if iterator_t<T> models forward_iterator, ranges::size(t) is well-defined regardless of the
evaluation ofranges::begin(t).
[Note 1: ranges::size(t) is otherwise not required to be well-defined after evaluatingranges::begin(t).
For example, it is possible forranges::size(t) to be well-defined for asized_range whose iterator type
does not modelforward_iterator only if evaluated before the first call toranges::begin(t). —end
note]
template<class>
constexpr bool disable_sized_range = false;
3 Remarks: Pursuantto16.4.5.2.1, usersmayspecialize disable_sized_rangeforcv-unqualifiedprogram-
defined types. Such specializations shall be usable in constant expressions (7.7) and have typeconst
bool.
4 [Note 2: disable_sized_range allows use ofrange types with the library that satisfy but do not in fact model
sized_range. —end note]
25.4.5 Views [range.view]
1 The view concept specifies the requirements of arange type that has the semantic properties below, which
make it suitable for use in constructing range adaptor pipelines (25.7).
template<class T>
concept view =
range<T> && movable<T> && enable_view<T>;
2 T models view only if
—(2.1) T has O(1) move construction; and
§ 25.4.5 © ISO/IEC
1251

===== PAGE 1263 =====

Dxxxx
—(2.2) move assignment of an object of typeT is no more complex than destruction followed by move
construction; and
—(2.3) if N copies and/or moves are made from an object of typeT that containedM elements, then
those N objects haveO(N + M) destruction; and
—(2.4) copy_constructible<T> is false, orT has O(1) copy construction; and
—(2.5) copyable<T> is false, or copy assignment of an object of typeT is no more complex than
destruction followed by copy construction.
3 [Note 1: The constraints on copying and moving imply that a moved-from object of typeT has O(1) destruction.
—end note]
4 [Example 1: Examples of views are:
—(4.1) A range type that wraps a pair of iterators.
—(4.2) A range type that holds its elements byshared_ptr and shares ownership with all its copies.
—(4.3) A range type that generates its elements on demand.
A container such asvector<string> does not meet the semantic requirements ofview since copying the
container copies all of the elements, which cannot be done in constant time.—end example]
5 Since the difference betweenrange and view is largely semantic, the two are differentiated with the help of
enable_view.
template<class T>
constexpr bool is-derived-from-view-interface = see below; // exposition only
template<class T>
constexpr bool enable_view =
derived_from<T, view_base> || is-derived-from-view-interface <T>;
6 For a typeT, is-derived-from-view-interface <T> is true if and only ifT has exactly one public
base classview_interface<U> for some typeU and T has no base classes of typeview_interface<V>
for any other typeV.
7 Remarks: Pursuant to 16.4.5.2.1, users may specializeenable_view to true for cv-unqualified program-
defined types that modelview, andfalse for types that do not. Such specializations shall be usable in
constant expressions (7.7) and have typeconst bool.
25.4.6 Other range refinements [range.refinements]
1 Theoutput_rangeconceptspecifiesrequirementsofa rangetypeforwhich ranges::beginreturnsamodelof
output_iterator(24.3.4.10). input_range, forward_range, bidirectional_range, andrandom_access_-
range are defined similarly.
template<class R, class T>
concept output_range =
range<R> && output_iterator<iterator_t<R>, T>;
template<class T>
concept input_range =
range<T> && input_iterator<iterator_t<T>>;
template<class T>
concept forward_range =
input_range<T> && forward_iterator<iterator_t<T>>;
template<class T>
concept bidirectional_range =
forward_range<T> && bidirectional_iterator<iterator_t<T>>;
template<class T>
concept random_access_range =
bidirectional_range<T> && random_access_iterator<iterator_t<T>>;
2 contiguous_range additionally requires that theranges::data customization point object (25.3.14) is
usable with the range.
§ 25.4.6 © ISO/IEC
1252

===== PAGE 1264 =====

Dxxxx
template<class T>
concept contiguous_range =
random_access_range<T> && contiguous_iterator<iterator_t<T>> &&
requires(T& t) {
{ ranges::data(t) } -> same_as<add_pointer_t<range_reference_t<T>>>;
};
3 Given an expressiont such thatdecltype((t)) is T&, T models contiguous_range only if to_address(
ranges::begin(t)) == ranges::data(t) is true.
4 Thecommon_rangeconcept specifies requirements of arangetype for whichranges::beginandranges::end
return objects of the same type.
[Example 1: The standard containers (Clause 23) modelcommon_range. —end example]
template<class T>
concept common_range =
range<T> && same_as<iterator_t<T>, sentinel_t<T>>;
template<class R>
constexpr bool is-initializer-list = see below ; // exposition only
5 For a typeR, is-initializer-list <R> is true if and only ifremove_cvref_t<R> is a specialization
of initializer_list.
6 The viewable_range concept specifies the requirements of arange type that can be converted to a view
safely.
template<class T>
concept viewable_range =
range<T> &&
((view<remove_cvref_t<T>> && constructible_from<remove_cvref_t<T>, T>) ||
(!view<remove_cvref_t<T>> &&
(is_lvalue_reference_v<T> || (movable<remove_reference_t<T>> && !is-initializer-list <T>))));
7 The constant_range concept specifies the requirements of arange type whose elements are not modifiable.
template<class T>
concept constant_range =
input_range<T> && constant-iterator <iterator_t<T>>;
8 The exposition-only conceptsized-random-access-range specifies the requirements of arange type that
is sized and allows random access to its elements.
template<class T>
concept sized-random-access-range = // exposition only
random_access_range<T> && sized_range<T>;
[Note 1: This concept constrains some parallel algorithm overloads; see Clause 26.—end note]
25.5 Range utilities [range.utility]
25.5.1 General [range.utility.general]
1 The components in 25.5 are general utilities for representing and manipulating ranges.
25.5.2 Helper concepts [range.utility.helpers]
1 Many of the types in 25.5 are specified in terms of the following exposition-only concepts:
template<class R>
concept simple-view = // exposition only
view<R> && range<const R> &&
same_as<iterator_t<R>, iterator_t<const R>> &&
same_as<sentinel_t<R>, sentinel_t<const R>>;
template<class I>
concept has-arrow = // exposition only
input_iterator<I> && (is_pointer_v<I> || requires(const I i) { i.operator->(); });
§ 25.5.2 © ISO/IEC
1253

===== PAGE 1265 =====

Dxxxx
template<class T, class U>
concept different-from = // exposition only
!same_as<remove_cvref_t<T>, remove_cvref_t<U>>;
template<class R>
concept range-with-movable-references = // exposition only
input_range<R> && move_constructible<range_reference_t<R>> &&
move_constructible<range_rvalue_reference_t<R>>;
25.5.3 View interface [view.interface]
25.5.3.1 General [view.interface.general]
1 The class templateview_interface is a helper for defining view-like types that offer a container-like interface.
It is parameterized with the type that is derived from it.
namespace std::ranges {
template<class D>
requires is_class_v<D> && same_as<D, remove_cv_t<D>>
class view_interface {
private:
constexpr D& derived() noexcept { // exposition only
return static_cast<D&>(*this);
}
constexpr const D& derived() const noexcept { // exposition only
return static_cast<const D&>(*this);
}
public:
constexpr bool empty() requires sized_range<D> || forward_range<D> {
if constexpr (sized_range<D>)
return ranges::size(derived ()) == 0;
else
return ranges::begin(derived ()) == ranges::end(derived ());
}
constexpr bool empty() const requires sized_range<const D> || forward_range<const D> {
if constexpr (sized_range<const D>)
return ranges::size(derived ()) == 0;
else
return ranges::begin(derived ()) == ranges::end(derived ());
}
constexpr auto cbegin() requires input_range<D> {
return ranges::cbegin(derived ());
}
constexpr auto cbegin() const requires input_range<const D> {
return ranges::cbegin(derived ());
}
constexpr auto cend() requires input_range<D> {
return ranges::cend(derived ());
}
constexpr auto cend() const requires input_range<const D> {
return ranges::cend(derived ());
}
constexpr explicit operator bool()
requires requires { ranges::empty(derived ()); } {
return !ranges::empty(derived ());
}
constexpr explicit operator bool() const
requires requires { ranges::empty(derived ()); } {
return !ranges::empty(derived ());
}
§ 25.5.3.1 © ISO/IEC
1254

===== PAGE 1266 =====

Dxxxx
constexpr auto data() requires contiguous_iterator<iterator_t<D>> {
return to_address(ranges::begin(derived ()));
}
constexpr auto data() const
requires range<const D> && contiguous_iterator<iterator_t<const D>> {
return to_address(ranges::begin(derived ()));
}
constexpr auto size() requires forward_range<D> &&
sized_sentinel_for<sentinel_t<D>, iterator_t<D>> {
return to-unsigned-like (ranges::end(derived ()) - ranges::begin(derived ()));
}
constexpr auto size() const requires forward_range<const D> &&
sized_sentinel_for<sentinel_t<const D>, iterator_t<const D>> {
return to-unsigned-like (ranges::end(derived ()) - ranges::begin(derived ()));
}
constexpr decltype(auto) front() requires forward_range<D>;
constexpr decltype(auto) front() const requires forward_range<const D>;
constexpr decltype(auto) back() requires bidirectional_range<D> && common_range<D>;
constexpr decltype(auto) back() const
requires bidirectional_range<const D> && common_range<const D>;
template<random_access_range R = D>
constexpr decltype(auto) operator[](range_difference_t<R> n) {
return ranges::begin(derived ())[n];
}
template<random_access_range R = const D>
constexpr decltype(auto) operator[](range_difference_t<R> n) const {
return ranges::begin(derived ())[n];
}
};
}
2 The template parameterD for view_interface may be an incomplete type. Before any member of the
resulting specialization ofview_interface other than special member functions is referenced,D shall be
complete, and model bothderived_from<view_interface<D>> and view.
25.5.3.2 Members [view.interface.members]
constexpr decltype(auto) front() requires forward_range<D>;
constexpr decltype(auto) front() const requires forward_range<const D>;
1 Hardened preconditions: !empty() is true.
2 Effects: Equivalent to:return *ranges::begin(derived ());
constexpr decltype(auto) back() requires bidirectional_range<D> && common_range<D>;
constexpr decltype(auto) back() const
requires bidirectional_range<const D> && common_range<const D>;
3 Hardened preconditions: !empty() is true.
4 Effects: Equivalent to:return *ranges::prev(ranges::end(derived ()));
25.5.4 Sub-ranges [range.subrange]
25.5.4.1 General [range.subrange.general]
1 The subrange class template combines together an iterator and a sentinel into a single object that models
the view concept. Additionally, it models thesized_range concept when the final template parameter is
subrange_kind::sized.
namespace std::ranges {
template<class From, class To>
concept uses-nonqualification-pointer-conversion = // exposition only
is_pointer_v<From> && is_pointer_v<To> &&
!convertible_to<remove_pointer_t<From>(*)[], remove_pointer_t<To>(*)[]>;
§ 25.5.4.1 © ISO/IEC
1255

===== PAGE 1267 =====

Dxxxx
template<class From, class To>
concept convertible-to-non-slicing = // exposition only
convertible_to<From, To> &&
!uses-nonqualification-pointer-conversion <decay_t<From>, decay_t<To>>;
template<class T, class U, class V>
concept pair-like-convertible-from = // exposition only
!range<T> && !is_reference_v<T> && pair-like <T> &&
constructible_from<T, U, V> &&
convertible-to-non-slicing <U, tuple_element_t<0, T>> &&
convertible_to<V, tuple_element_t<1, T>>;
template<input_or_output_iterator I, sentinel_for<I> S = I, subrange_kind K =
sized_sentinel_for<S, I> ? subrange_kind::sized : subrange_kind::unsized>
requires (K == subrange_kind::sized || !sized_sentinel_for<S, I>)
class subrange : public view_interface<subrange<I, S, K>> {
private:
static constexpr bool StoreSize = // exposition only
K == subrange_kind::sized && !sized_sentinel_for<S, I>;
I begin_ = I(); // exposition only
S end_ = S(); // exposition only
make-unsigned-like-t<iter_difference_t<I>> size_ = 0; // exposition only; present only
// if StoreSize is true
public:
subrange() requires default_initializable<I> = default;
constexpr subrange(convertible-to-non-slicing <I> auto i, S s) requires (!StoreSize );
constexpr subrange(convertible-to-non-slicing <I> auto i, S s,
make-unsigned-like-t<iter_difference_t<I>> n)
requires (K == subrange_kind::sized);
template<different-from <subrange> R>
requires borrowed_range<R> &&
convertible-to-non-slicing <iterator_t<R>, I> &&
convertible_to<sentinel_t<R>, S>
constexpr subrange(R&& r) requires (!StoreSize || sized_range<R>);
template<borrowed_range R>
requires convertible-to-non-slicing <iterator_t<R>, I> &&
convertible_to<sentinel_t<R>, S>
constexpr subrange(R&& r, make-unsigned-like-t<iter_difference_t<I>> n)
requires (K == subrange_kind::sized)
: subrange{ranges::begin(r), ranges::end(r), n} {}
template<different-from <subrange> PairLike>
requires pair-like-convertible-from <PairLike, const I&, const S&>
constexpr operator PairLike() const;
constexpr I begin() const requires copyable<I>;
constexpr I begin() requires (!copyable<I>);
constexpr S end() const;
constexpr bool empty() const;
constexpr make-unsigned-like-t<iter_difference_t<I>> size() const
requires (K == subrange_kind::sized);
constexpr subrange next(iter_difference_t<I> n = 1) const &
requires forward_iterator<I>;
constexpr subrange next(iter_difference_t<I> n = 1) &&;
constexpr subrange prev(iter_difference_t<I> n = 1) const
requires bidirectional_iterator<I>;
constexpr subrange& advance(iter_difference_t<I> n);
};
§ 25.5.4.1 © ISO/IEC
1256

===== PAGE 1268 =====

Dxxxx
template<input_or_output_iterator I, sentinel_for<I> S>
subrange(I, S) -> subrange<I, S>;
template<input_or_output_iterator I, sentinel_for<I> S>
subrange(I, S, make-unsigned-like-t<iter_difference_t<I>>) ->
subrange<I, S, subrange_kind::sized>;
template<borrowed_range R>
subrange(R&&) ->
subrange<iterator_t<R>, sentinel_t<R>,
(sized_range<R> || sized_sentinel_for<sentinel_t<R>, iterator_t<R>>)
? subrange_kind::sized : subrange_kind::unsized>;
template<borrowed_range R>
subrange(R&&, make-unsigned-like-t<range_difference_t<R>>) ->
subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;
}
25.5.4.2 Constructors and conversions [range.subrange.ctor]
constexpr subrange(convertible-to-non-slicing <I> auto i, S s) requires (!StoreSize );
1 Preconditions: [i,s) is a valid range.
2 Effects: Initializes begin_ with std::move(i) and end_ with s.
constexpr subrange(convertible-to-non-slicing <I> auto i, S s,
make-unsigned-like-t<iter_difference_t<I>> n)
requires (K == subrange_kind::sized);
3 Preconditions: [i,s) is a valid range, andn == to-unsigned-like(ranges::distance(i, s)) is
true.
4 Effects: Initializes begin_ with std::move(i) and end_ with s. If StoreSize is true, initializes
size_ with n.
5 [Note 1: Accepting the length of the range and storing it to later return fromsize() enables subrange to model
sized_range even when it stores an iterator and sentinel that do not modelsized_sentinel_for. —end note]
template<different-from <subrange> R>
requires borrowed_range<R> &&
convertible-to-non-slicing <iterator_t<R>, I> &&
convertible_to<sentinel_t<R>, S>
constexpr subrange(R&& r) requires (!StoreSize || sized_range<R>);
6 Effects: Equivalent to:
—(6.1) If StoreSize is true, subrange(r, static_cast<decltype(size_)>(ranges::size(r))).
—(6.2) Otherwise, subrange(ranges::begin(r), ranges::end(r)).
template<different-from <subrange> PairLike>
requires pair-like-convertible-from <PairLike, const I&, const S&>
constexpr operator PairLike() const;
7 Effects: Equivalent to:return PairLike(begin_, end_);
25.5.4.3 Accessors [range.subrange.access]
constexpr I begin() const requires copyable<I>;
1 Effects: Equivalent to:return begin_;
constexpr I begin() requires (!copyable<I>);
2 Effects: Equivalent to:return std::move(begin_);
constexpr S end() const;
3 Effects: Equivalent to:return end_;
§ 25.5.4.3 © ISO/IEC
1257

===== PAGE 1269 =====

Dxxxx
constexpr bool empty() const;
4 Effects: Equivalent to:return begin_ == end_;
constexpr make-unsigned-like-t<iter_difference_t<I>> size() const
requires (K == subrange_kind::sized);
5 Effects:
—(5.1) If StoreSize is true, equivalent to:return size_;
—(5.2) Otherwise, equivalent to:return to-unsigned-like(end_ - begin_);
constexpr subrange next(iter_difference_t<I> n = 1) const &
requires forward_iterator<I>;
6 Effects: Equivalent to:
auto tmp = *this;
tmp.advance(n);
return tmp;
constexpr subrange next(iter_difference_t<I> n = 1) &&;
7 Effects: Equivalent to:
advance(n);
return std::move(*this);
constexpr subrange prev(iter_difference_t<I> n = 1) const
requires bidirectional_iterator<I>;
8 Effects: Equivalent to:
auto tmp = *this;
tmp.advance(-n);
return tmp;
constexpr subrange& advance(iter_difference_t<I> n);
9 Effects: Equivalent to:
if constexpr (bidirectional_iterator<I>) {
if (n < 0) {
ranges::advance(begin_, n);
if constexpr (StoreSize )
size_ += to-unsigned-like(-n);
return *this;
}
}
auto d = n - ranges::advance(begin_, n, end_);
if constexpr (StoreSize )
size_ -= to-unsigned-like(d);
return *this;
template<size_t N, class I, class S, subrange_kind K>
requires ((N == 0 && copyable<I>) || N == 1)
constexpr auto get(const subrange<I, S, K>& r);
template<size_t N, class I, class S, subrange_kind K>
requires (N < 2)
constexpr auto get(subrange<I, S, K>&& r);
10 Effects: Equivalent to:
if constexpr (N == 0)
return r.begin();
else
return r.end();
§ 25.5.4.3 © ISO/IEC
1258

===== PAGE 1270 =====

Dxxxx
25.5.5 Dangling iterator handling [range.dangling]
1 The type dangling is used together with the template aliases borrowed_iterator_t and borrowed_-
subrange_t. When an algorithm that typically returns an iterator into, or a subrange of, a range argument
is called with an rvalue range argument that does not modelborrowed_range (25.4.2), the return value
possibly refers to a range whose lifetime has ended. In such cases, the typedangling is returned instead of
an iterator or subrange.
namespace std::ranges {
struct dangling {
constexpr dangling() noexcept = default;
constexpr dangling(auto&&...) noexcept {}
};
}
2 [Example 1:
vector<int> f();
auto result1 = ranges::find(f(), 42); // #1
static_assert(same_as<decltype(result1), ranges::dangling>);
auto vec = f();
auto result2 = ranges::find(vec, 42); // #2
static_assert(same_as<decltype(result2), vector<int>::iterator>);
auto result3 = ranges::find(ranges::subrange{vec}, 42); // #3
static_assert(same_as<decltype(result3), vector<int>::iterator>);
The call toranges::find at #1 returnsranges::dangling since f() is an rvaluevector; it is possible for thevector
to be destroyed before a returned iterator is dereferenced. However, the calls at #2 and #3 both return iterators
since the lvaluevec and specializations ofsubrange model borrowed_range. —end example]
3 For a typeR that modelsrange:
—(3.1) if Rmodels borrowed_range, thenborrowed_iterator_t<R>denotes iterator_t<R>, andborrowed_-
subrange_t<R> denotes subrange<iterator_t<R>>;
—(3.2) otherwise, bothborrowed_iterator_t<R> and borrowed_subrange_t<R> denote dangling.
25.5.6 Class template elements_of [range.elementsof]
Specializations of elements_of encapsulate a range and act as a tag in overload sets to disambiguate when a
range should be treated as a sequence rather than a single value.
[Example 1:
template<bool YieldElements>
generator<any> f(ranges::input_range auto&& r) {
if constexpr (YieldElements)
co_yield ranges::elements_of(r); // yield each element ofr
else
co_yield r; // yield r as a single value
}
—end example]
namespace std::ranges {
template<range R, class Allocator = allocator<byte>>
struct elements_of {
[[no_unique_address]] R range;
[[no_unique_address]] Allocator allocator = Allocator();
};
template<class R, class Allocator = allocator<byte>>
elements_of(R&&, Allocator = Allocator()) -> elements_of<R&&, Allocator>;
}
25.5.7 Range conversions [range.utility.conv]
25.5.7.1 General [range.utility.conv.general]
1 The range conversion functions construct an object (usually a container) from a range, by using a constructor
taking a range, afrom_range_t tagged constructor, or a constructor taking a pair of iterators, or by inserting
each element of the range into the default-constructed object.
§ 25.5.7.1 © ISO/IEC
1259

===== PAGE 1271 =====

Dxxxx
2 ranges::to is applied recursively, allowing the conversion of a range of ranges.
[Example 1:
string_view str = "the quick brown fox";
auto words = views::split(str, ' ') | to<vector<string>>();
// words is vector<string>{"the", "quick", "brown", "fox"}
—end example]
3 Let reservable-container be defined as follows:
template<class Container>
constexpr bool reservable-container = // exposition only
sized_range<Container> &&
requires(Container& c, range_size_t<Container> n) {
c.reserve(n);
{ c.capacity() } -> same_as<decltype(n)>;
{ c.max_size() } -> same_as<decltype(n)>;
};
4 Let container-appendable be defined as follows:
template<class Container, class Ref>
constexpr bool container-appendable = // exposition only
requires(Container& c, Ref&& ref) {
requires (requires { c.emplace_back(std::forward<Ref>(ref)); } ||
requires { c.push_back(std::forward<Ref>(ref)); } ||
requires { c.emplace(c.end(), std::forward<Ref>(ref)); } ||
requires { c.insert(c.end(), std::forward<Ref>(ref)); });
};
5 Let container-append be defined as follows:
template<class Container>
constexpr auto container-append (Container& c) { // exposition only
return [&c]<class Ref>(Ref&& ref) {
if constexpr (requires { c.emplace_back(declval<Ref>()); })
c.emplace_back(std::forward<Ref>(ref));
else if constexpr (requires { c.push_back(declval<Ref>()); })
c.push_back(std::forward<Ref>(ref));
else if constexpr (requires { c.emplace(c.end(), declval<Ref>()); })
c.emplace(c.end(), std::forward<Ref>(ref));
else
c.insert(c.end(), std::forward<Ref>(ref));
};
}
25.5.7.2 ranges::to [range.utility.conv.to]
template<class C, input_range R, class... Args> requires (!view<C>)
constexpr C to(R&& r, Args&&... args);
1 Mandates: C is a cv-unqualified class type.
2 Returns: An object of typeC constructed from the elements ofr in the following manner:
—(2.1) If C does not satisfyinput_range or convertible_to<range_reference_t<R>, range_value_-
t<C>> is true:
—(2.1.1) If constructible_from<C, R, Args...> is true:
C(std::forward<R>(r), std::forward<Args>(args)...)
—(2.1.2) Otherwise, ifconstructible_from<C, from_range_t, R, Args...> is true:
C(from_range, std::forward<R>(r), std::forward<Args>(args)...)
—(2.1.3) Otherwise, if
—(2.1.3.1) common_range<R> is true,
—(2.1.3.2) the qualified-id iterator_traits<iterator_t<R>>::iterator_category is valid and
denotes a type that modelsderived_from<input_iterator_tag>, and
§ 25.5.7.2 © ISO/IEC
1260

===== PAGE 1272 =====

Dxxxx
—(2.1.3.3) constructible_from<C, iterator_t<R>, sentinel_t<R>, Args...> is true:
C(ranges::begin(r), ranges::end(r), std::forward<Args>(args)...)
—(2.1.4) Otherwise, if
—(2.1.4.1) constructible_from<C, Args...> is true, and
—(2.1.4.2) container-appendable <C, range_reference_t<R>> is true:
C c(std::forward<Args>(args)...);
if constexpr (approximately_sized_range<R> && reservable-container <C>)
c.reserve(static_cast<range_size_t<C>>(ranges::reserve_hint(r)));
ranges::for_each(r, container-append (c));
—(2.1.5) Otherwise, the program is ill-formed.
—(2.2) Otherwise, ifinput_range<range_reference_t<R>> is true:
to<C>(ref_view(r) | views::transform([](auto&& elem) {
return to<range_value_t<C>>(std::forward<decltype(elem)>(elem));
}), std::forward<Args>(args)...);
—(2.3) Otherwise, the program is ill-formed.
template<template<class...> class C, input_range R, class... Args>
constexpr auto to(R&& r, Args&&... args);
3 Let input-iterator be an exposition-only type:
struct input-iterator { // exposition only
using iterator_category = input_iterator_tag;
using value_type = range_value_t<R>;
using difference_type = ptrdiff_t;
using pointer = add_pointer_t<range_reference_t<R>>;
using reference = range_reference_t<R>;
reference operator*() const;
pointer operator->() const;
input-iterator & operator++();
input-iterator operator++(int);
bool operator==(const input-iterator &) const;
};
[Note 1: input-iterator meets the syntactic requirements ofCpp17InputIterator. —end note]
4 Let DEDUCE_EXPR be defined as follows:
—(4.1) C(declval<R>(), declval<Args>()...) if that is a valid expression,
—(4.2) otherwise, C(from_range, declval<R>(), declval<Args>()...) if that is a valid expression,
—(4.3) otherwise,
C(declval<input-iterator >(), declval<input-iterator >(), declval<Args>()...)
if that is a valid expression,
—(4.4) otherwise, the program is ill-formed.
5 Returns: to<decltype(DEDUCE_EXPR )>(std::forward<R>(r), std::forward<Args>(args)...).
25.5.7.3 ranges::to adaptors [range.utility.conv.adaptors]
template<class C, class... Args> requires (!view<C>)
constexpr auto to(Args&&... args);
template<template<class...> class C, class... Args>
constexpr auto to(Args&&... args);
1 Mandates: For the first overload,C is a cv-unqualified class type.
2 Returns: A range adaptor closure object (25.7.2)f that is a perfect forwarding call wrapper (22.10.4)
with the following properties:
—(2.1) It has no target object.
—(2.2) Its bound argument entitiesbound_args consist of objects of typesdecay_t<Args>... direct-non-
list-initialized withstd::forward<Args>(args)..., respectively.
§ 25.5.7.3 © ISO/IEC
1261

===== PAGE 1273 =====

Dxxxx
—(2.3) Its call pattern isto<C>(r, bound_args...), wherer is the argument used in a function call
expression off.
25.6 Range factories [range.factories]
25.6.1 General [range.factories.general]
1 Subclause 25.6 definesrange factories, which are utilities to create a view.
2 Range factories are declared in namespacestd::ranges::views.
25.6.2 Empty view [range.empty]
25.6.2.1 Overview [range.empty.overview]
1 empty_view produces a view of no elements of a particular type.
2 [Example 1:
auto e = views::empty<int>;
static_assert(ranges::empty(e));
static_assert(0 == e.size());
—end example]
25.6.2.2 Class template empty_view [range.empty.view]
namespace std::ranges {
template<class T>
requires is_object_v<T>
class empty_view : public view_interface<empty_view<T>> {
public:
static constexpr T* begin() noexcept { return nullptr; }
static constexpr T* end() noexcept { return nullptr; }
static constexpr T* data() noexcept { return nullptr; }
static constexpr size_t size() noexcept { return 0; }
static constexpr bool empty() noexcept { return true; }
};
}
25.6.3 Single view [range.single]
25.6.3.1 Overview [range.single.overview]
1 single_view produces a view that contains exactly one element of a specified value.
2 The nameviews::single denotes a customization point object (16.3.3.3.5). Given a subexpressionE, the
expression views::single(E) is expression-equivalent tosingle_view<decay_t<decltype((E))>>(E).
3 [Example 1:
for (int i : views::single(4))
cout << i; // prints4
—end example]
25.6.3.2 Class template single_view [range.single.view]
namespace std::ranges {
template<move_constructible T>
requires is_object_v<T>
class single_view : public view_interface<single_view<T>> {
private:
movable-box<T> value_; // exposition only (see 25.7.3)
public:
single_view() requires default_initializable<T> = default;
constexpr explicit single_view(const T& t) requires copy_constructible<T>;
constexpr explicit single_view(T&& t);
template<class... Args>
requires constructible_from<T, Args...>
constexpr explicit single_view(in_place_t, Args&&... args);
§ 25.6.3.2 © ISO/IEC
1262

===== PAGE 1274 =====

Dxxxx
constexpr T* begin() noexcept;
constexpr const T* begin() const noexcept;
constexpr T* end() noexcept;
constexpr const T* end() const noexcept;
static constexpr bool empty() noexcept;
static constexpr size_t size() noexcept;
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
};
template<class T>
single_view(T) -> single_view<T>;
}
constexpr explicit single_view(const T& t) requires copy_constructible<T>;
1 Effects: Initializes value_ with t.
constexpr explicit single_view(T&& t);
2 Effects: Initializes value_ with std::move(t).
template<class... Args>
requires constructible_from<T, Args...>
constexpr explicit single_view(in_place_t, Args&&... args);
3 Effects: Initializes value_ as if byvalue_{in_place, std::forward<Args>(args)...}.
constexpr T* begin() noexcept;
constexpr const T* begin() const noexcept;
4 Effects: Equivalent to:return data();
constexpr T* end() noexcept;
constexpr const T* end() const noexcept;
5 Effects: Equivalent to:return data() + 1;
static constexpr bool empty() noexcept;
6 Effects: Equivalent to:return false;
static constexpr size_t size() noexcept;
7 Effects: Equivalent to:return 1;
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
8 Effects: Equivalent to:return value_.operator->();
25.6.4 Iota view [range.iota]
25.6.4.1 Overview [range.iota.overview]
1 iota_view generates a sequence of elements by repeatedly incrementing an initial value.
2 The nameviews::iota denotes a customization point object (16.3.3.3.5). Given subexpressionsE and F,
the expressionsviews::iota(E) and views::iota(E, F) are expression-equivalent toiota_view<decay_-
t<decltype((E))>>(E) and iota_view(E, F), respectively.
3 [Example 1:
for (int i : views::iota(1, 10))
cout << i << ' '; // prints1 2 3 4 5 6 7 8 9
—end example]
4 The nameviews::indices denotes a customization point object (16.3.3.3.5). Given subexpressionE, letT
be remove_cvref_t<decltype((E))>. views::indices(E) is expression-equivalent toviews::iota(T(0),
E) if is-integer-like <T> is true, and ill-formed otherwise.
§ 25.6.4.1 © ISO/IEC
1263

===== PAGE 1275 =====

Dxxxx
25.6.4.2 Class template iota_view [range.iota.view]
namespace std::ranges {
template<class I>
concept decrementable = see below; // exposition only
template<class I>
concept advanceable = see below; // exposition only
template<weakly_incrementable W, semiregular Bound = unreachable_sentinel_t>
requires weakly-equality-comparable-with <W, Bound> && copyable<W>
class iota_view : public view_interface<iota_view<W, Bound>> {
private:
// 25.6.4.3, classiota_view::iterator
struct iterator; // exposition only
// 25.6.4.4, classiota_view::sentinel
struct sentinel; // exposition only
W value_ = W(); // exposition only
Bound bound_ = Bound(); // exposition only
public:
iota_view() requires default_initializable<W> = default;
constexpr explicit iota_view(W value);
constexpr explicit iota_view(type_identity_t<W> value, type_identity_t<Bound> bound);
constexpr explicit iota_view(iterator first, see below last);
constexpr iterator begin() const;
constexpr auto end() const;
constexpr iterator end() const requires same_as<W, Bound>;
constexpr bool empty() const;
constexpr auto size() const requires see below ;
};
template<class W, class Bound>
requires (!is-integer-like <W> || !is-integer-like <Bound> ||
(is-signed-integer-like <W> == is-signed-integer-like <Bound>))
iota_view(W, Bound) -> iota_view<W, Bound>;
}
1 Let IOTA-DIFF-T(W) be defined as follows:
—(1.1) If W is not an integral type, or if it is an integral type andsizeof(iter_difference_t<W>) is greater
than sizeof(W), thenIOTA-DIFF-T(W) denotes iter_difference_t<W>.
—(1.2) Otherwise, IOTA-DIFF-T(W) is a signed integer type of width greater than the width ofW if such a type
exists.
—(1.3) Otherwise, IOTA-DIFF-T(W) is an unspecified signed-integer-like type (24.3.4.4) of width not less than
the width ofW.
[Note 1: It is unspecified whether this type satisfiesweakly_incrementable. —end note]
2 The exposition-onlydecrementable concept is equivalent to:
template<class I>
concept decrementable = // exposition only
incrementable<I> && requires(I i) {
{ --i } -> same_as<I&>;
{ i-- } -> same_as<I>;
};
3 When an object is in the domain of both pre- and post-decrement, the object is said to bedecrementable.
4 Let a and b be equal objects of typeI. I models decrementable only if
—(4.1) If a and b are decrementable, then the following are all true:
§ 25.6.4.2 © ISO/IEC
1264

===== PAGE 1276 =====

Dxxxx
—(4.1.1) addressof(--a) == addressof(a)
—(4.1.2) bool(a-- == b)
—(4.1.3) bool(((void)a--, a) == --b)
—(4.1.4) bool(++(--a) == b).
—(4.2) If a and b are incrementable, thenbool(--(++a) == b).
5 The exposition-onlyadvanceable concept is equivalent to:
template<class I>
concept advanceable = // exposition only
decrementable <I> && totally_ordered<I> &&
requires(I i, const I j, const IOTA-DIFF-T(I) n) {
{ i += n } -> same_as<I&>;
{ i -= n } -> same_as<I&>;
I(j + n);
I(n + j);
I(j - n);
{ j - j } -> convertible_to<IOTA-DIFF-T(I)>;
};
Let D be IOTA-DIFF-T(I). Leta and b be objects of typeI such thatb is reachable froma after n applications
of ++a, for some valuen of typeD. I models advanceable only if
—(5.1) (a += n) is equal tob.
—(5.2) addressof(a += n) is equal toaddressof(a).
—(5.3) I(a + n) is equal to(a += n).
—(5.4) For any two positive valuesx and y of typeD, ifI(a + D(x + y)) is well-defined, thenI(a + D(x +
y)) is equal toI(I(a + x) + y).
—(5.5) I(a + D(0)) is equal toa.
—(5.6) If I(a + D(n - 1)) is well-defined, thenI(a + n) is equal to[](I c) { return ++c; }(I(a + D(n
- 1))).
—(5.7) (b += -n) is equal toa.
—(5.8) (b -= n) is equal toa.
—(5.9) addressof(b -= n) is equal toaddressof(b).
—(5.10) I(b - n) is equal to(b -= n).
—(5.11) D(b - a) is equal ton.
—(5.12) D(a - b) is equal toD(-n).
—(5.13) bool(a <= b) is true.
constexpr explicit iota_view(W value);
6 Preconditions: Bound denotes unreachable_sentinel_t or Bound() is reachable fromvalue. When W
and Bound model totally_ordered_with, thenbool(value <= Bound()) is true.
7 Effects: Initializes value_ with value.
constexpr explicit iota_view(type_identity_t<W> value, type_identity_t<Bound> bound);
8 Preconditions: Bound denotes unreachable_sentinel_t or bound is reachable fromvalue. When W
and Bound model totally_ordered_with, thenbool(value <= bound) is true.
9 Effects: Initializes value_ with value and bound_ with bound.
constexpr explicit iota_view(iterator first, see below last);
10 Effects: Equivalent to:
—(10.1) If same_as<W, Bound> is true, iota_view(first.value_, last.value_).
—(10.2) Otherwise, ifBound denotes unreachable_sentinel_t, iota_view(first.value_, last).
—(10.3) Otherwise, iota_view(first.value_, last.bound_).
§ 25.6.4.2 © ISO/IEC
1265

===== PAGE 1277 =====

Dxxxx
11 Remarks: The type oflast is:
—(11.1) If same_as<W, Bound> is true, iterator .
—(11.2) Otherwise, ifBound denotes unreachable_sentinel_t, Bound.
—(11.3) Otherwise, sentinel .
constexpr iterator begin() const;
12 Effects: Equivalent to:return iterator {value_};
constexpr auto end() const;
13 Effects: Equivalent to:
if constexpr (same_as<Bound, unreachable_sentinel_t>)
return unreachable_sentinel;
else
return sentinel {bound_};
constexpr iterator end() const requires same_as<W, Bound>;
14 Effects: Equivalent to:return iterator {bound_};
constexpr bool empty() const;
15 Effects: Equivalent to:return value_ == bound_;
constexpr auto size() const requires see below ;
16 Effects: Equivalent to:
if constexpr (is-integer-like <W> && is-integer-like <Bound>)
return (value_ < 0)
? ((bound_ < 0)
? to-unsigned-like(-value_) - to-unsigned-like(-bound_)
: to-unsigned-like(bound_) + to-unsigned-like(-value_))
: to-unsigned-like(bound_) - to-unsigned-like(value_);
else
return to-unsigned-like(bound_ - value_);
17 Remarks: The expression in therequires-clause is equivalent to:
(same_as<W, Bound> && advanceable <W>) || (is-integer-like <W> && is-integer-like <Bound>) ||
sized_sentinel_for<Bound, W>
25.6.4.3 Class iota_view::iterator [range.iota.iterator]
namespace std::ranges {
template<weakly_incrementable W, semiregular Bound>
requires weakly-equality-comparable-with <W, Bound> && copyable<W>
struct iota_view<W, Bound>::iterator {
private:
W value_ = W(); // exposition only
public:
using iterator_concept = see below ;
using iterator_category = input_iterator_tag; // present only ifW models incrementable and
// IOTA-DIFF-T(W) is an integral type
using value_type = W;
using difference_type = IOTA-DIFF-T(W);
iterator () requires default_initializable<W> = default;
constexpr explicit iterator (W value);
constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v<W>);
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires incrementable<W>;
§ 25.6.4.3 © ISO/IEC
1266

===== PAGE 1278 =====

Dxxxx
constexpr iterator & operator--() requires decrementable <W>;
constexpr iterator operator--(int) requires decrementable <W>;
constexpr iterator & operator+=(difference_type n)
requires advanceable <W>;
constexpr iterator & operator-=(difference_type n)
requires advanceable <W>;
constexpr W operator[](difference_type n) const
requires advanceable <W>;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<W>;
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires totally_ordered<W>;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires totally_ordered<W>;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires totally_ordered<W>;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires totally_ordered<W>;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires totally_ordered<W> && three_way_comparable<W>;
friend constexpr iterator operator+(iterator i, difference_type n)
requires advanceable <W>;
friend constexpr iterator operator+(difference_type n, iterator i)
requires advanceable <W>;
friend constexpr iterator operator-(iterator i, difference_type n)
requires advanceable <W>;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires advanceable <W>;
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If W models advanceable , theniterator_concept is random_access_iterator_tag.
—(1.2) Otherwise, ifW models decrementable , theniterator_concept is bidirectional_iterator_tag.
—(1.3) Otherwise, ifW models incrementable, theniterator_concept is forward_iterator_tag.
—(1.4) Otherwise, iterator_concept is input_iterator_tag.
2 [Note 1: Overloads foriter_move and iter_swap are omitted intentionally.—end note]
constexpr explicit iterator (W value);
3 Effects: Initializes value_ with value.
constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v<W>);
4 Effects: Equivalent to:return value_;
5 [Note 2: The noexcept clause is needed by the defaultiter_move implementation. —end note]
constexpr iterator & operator++();
6 Effects: Equivalent to:
++value_;
return *this;
constexpr void operator++(int);
7 Effects: Equivalent to++*this.
constexpr iterator operator++(int) requires incrementable<W>;
8 Effects: Equivalent to:
§ 25.6.4.3 © ISO/IEC
1267

===== PAGE 1279 =====

Dxxxx
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires decrementable <W>;
9 Effects: Equivalent to:
--value_;
return *this;
constexpr iterator operator--(int) requires decrementable <W>;
10 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type n)
requires advanceable <W>;
11 Effects: Equivalent to:
if constexpr (is-integer-like <W> && !is-signed-integer-like <W>) {
if (n >= difference_type(0))
value_ += static_cast<W>(n);
else
value_ -= static_cast<W>(-n);
} else {
value_ += n;
}
return *this;
constexpr iterator & operator-=(difference_type n)
requires advanceable <W>;
12 Effects: Equivalent to:
if constexpr (is-integer-like <W> && !is-signed-integer-like <W>) {
if (n >= difference_type(0))
value_ -= static_cast<W>(n);
else
value_ += static_cast<W>(-n);
} else {
value_ -= n;
}
return *this;
constexpr W operator[](difference_type n) const
requires advanceable <W>;
13 Effects: Equivalent to:return W(value_ + n);
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<W>;
14 Effects: Equivalent to:return x.value_ == y.value_;
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires totally_ordered<W>;
15 Effects: Equivalent to:return x.value_ < y.value_;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires totally_ordered<W>;
16 Effects: Equivalent to:return y < x;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires totally_ordered<W>;
17 Effects: Equivalent to:return !(y < x);
§ 25.6.4.3 © ISO/IEC
1268

===== PAGE 1280 =====

Dxxxx
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires totally_ordered<W>;
18 Effects: Equivalent to:return !(x < y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires totally_ordered<W> && three_way_comparable<W>;
19 Effects: Equivalent to:return x.value_ <=> y.value_;
friend constexpr iterator operator+(iterator i, difference_type n)
requires advanceable <W>;
20 Effects: Equivalent to:
i += n;
return i;
friend constexpr iterator operator+(difference_type n, iterator i)
requires advanceable <W>;
21 Effects: Equivalent to:return i + n;
friend constexpr iterator operator-(iterator i, difference_type n)
requires advanceable <W>;
22 Effects: Equivalent to:
i -= n;
return i;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires advanceable <W>;
23 Effects: Equivalent to:
using D = difference_type;
if constexpr (is-integer-like <W>) {
if constexpr (is-signed-integer-like <W>)
return D(D(x.value_) - D(y.value_));
else
return (y.value_ > x.value_)
? D(-D(y.value_ - x.value_))
: D(x.value_ - y.value_);
} else {
return x.value_ - y.value_;
}
25.6.4.4 Class iota_view::sentinel [range.iota.sentinel]
namespace std::ranges {
template<weakly_incrementable W, semiregular Bound>
requires weakly-equality-comparable-with <W, Bound> && copyable<W>
struct iota_view<W, Bound>::sentinel {
private:
Bound bound_ = Bound(); // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (Bound bound);
friend constexpr bool operator==(const iterator & x, const sentinel & y);
friend constexpr iter_difference_t<W> operator-(const iterator & x, const sentinel & y)
requires sized_sentinel_for<Bound, W>;
friend constexpr iter_difference_t<W> operator-(const sentinel & x, const iterator & y)
requires sized_sentinel_for<Bound, W>;
};
}
§ 25.6.4.4 © ISO/IEC
1269

===== PAGE 1281 =====

Dxxxx
constexpr explicit sentinel (Bound bound);
1 Effects: Initializes bound_ with bound.
friend constexpr bool operator==(const iterator & x, const sentinel & y);
2 Effects: Equivalent to:return x.value_ == y.bound_;
friend constexpr iter_difference_t<W> operator-(const iterator & x, const sentinel & y)
requires sized_sentinel_for<Bound, W>;
3 Effects: Equivalent to:return x.value_ - y.bound_;
friend constexpr iter_difference_t<W> operator-(const sentinel & x, const iterator & y)
requires sized_sentinel_for<Bound, W>;
4 Effects: Equivalent to:return -(y - x);
25.6.5 Repeat view [range.repeat]
25.6.5.1 Overview [range.repeat.overview]
1 repeat_view generates a sequence of elements by repeatedly producing the same value.
2 The nameviews::repeat denotes a customization point object (16.3.3.3.5). Given subexpressionsE and
F, the expressions views::repeat(E) and views::repeat(E, F) are expression-equivalent torepeat_-
view<decay_t<decltype((E))>>(E) and repeat_view(E, F), respectively.
3 [Example 1:
for (int i : views::repeat(17, 4))
cout << i << ' ';
// prints17 17 17 17
—end example]
25.6.5.2 Class template repeat_view [range.repeat.view]
namespace std::ranges {
template<class T>
concept integer-like-with-usable-difference-type = // exposition only
is-signed-integer-like <T> || (is-integer-like <T> && weakly_incrementable<T>);
template<move_constructible T, semiregular Bound = unreachable_sentinel_t>
requires (is_object_v<T> && same_as<T, remove_cv_t<T>> &&
(integer-like-with-usable-difference-type <Bound> ||
same_as<Bound, unreachable_sentinel_t>))
class repeat_view : public view_interface<repeat_view<T, Bound>> {
private:
// 25.6.5.3, classrepeat_view::iterator
struct iterator; // exposition only
movable-box<T> value_; // exposition only, see 25.7.3
Bound bound_ = Bound(); // exposition only
public:
repeat_view() requires default_initializable<T> = default;
constexpr explicit repeat_view(const T& value, Bound bound = Bound())
requires copy_constructible<T>;
constexpr explicit repeat_view(T&& value, Bound bound = Bound());
template<class... TArgs, class... BoundArgs>
requires constructible_from<T, TArgs...> &&
constructible_from<Bound, BoundArgs...>
constexpr explicit repeat_view(piecewise_construct_t,
tuple<TArgs...> value_args, tuple<BoundArgs...> bound_args = tuple<>{});
constexpr iterator begin() const;
constexpr iterator end() const requires (!same_as<Bound, unreachable_sentinel_t>);
constexpr unreachable_sentinel_t end() const noexcept;
§ 25.6.5.2 © ISO/IEC
1270

===== PAGE 1282 =====

Dxxxx
constexpr auto size() const requires (!same_as<Bound, unreachable_sentinel_t>);
};
template<class T, class Bound = unreachable_sentinel_t>
repeat_view(T, Bound = Bound()) -> repeat_view<T, Bound>;
}
constexpr explicit repeat_view(const T& value, Bound bound = Bound())
requires copy_constructible<T>;
1 Preconditions: If Bound is notunreachable_sentinel_t, bound ≥0.
2 Effects: Initializes value_ with value and bound_ with bound.
constexpr explicit repeat_view(T&& value, Bound bound = Bound());
3 Preconditions: If Bound is notunreachable_sentinel_t, bound ≥0.
4 Effects: Initializes value_ with std::move(value) and bound_ with bound.
template<class... TArgs, class... BoundArgs>
requires constructible_from<T, TArgs...> &&
constructible_from<Bound, BoundArgs...>
constexpr explicit repeat_view(piecewise_construct_t,
tuple<TArgs...> value_args, tuple<BoundArgs...> bound_args = tuple<>{});
5 Effects: Initializes value_ with make_from_tuple<T>(std::move(value_args)) and initializes
bound_ withmake_from_tuple<Bound>(std::move(bound_args)). Thebehaviorisundefinedif Bound
is notunreachable_sentinel_t and bound_ is negative.
constexpr iterator begin() const;
6 Effects: Equivalent to:return iterator (addressof(*value_));
constexpr iterator end() const requires (!same_as<Bound, unreachable_sentinel_t>);
7 Effects: Equivalent to:return iterator (addressof(*value_), bound_);
constexpr unreachable_sentinel_t end() const noexcept;
8 Effects: Equivalent to:return unreachable_sentinel;
constexpr auto size() const requires (!same_as<Bound, unreachable_sentinel_t>);
9 Effects: Equivalent to:return to-unsigned-like (bound_);
25.6.5.3 Class repeat_view::iterator [range.repeat.iterator]
namespace std::ranges {
template<move_constructible T, semiregular Bound>
requires (is_object_v<T> && same_as<T, remove_cv_t<T>> &&
(integer-like-with-usable-difference-type <Bound> ||
same_as<Bound, unreachable_sentinel_t>))
class repeat_view<T, Bound>::iterator {
private:
using index-type = // exposition only
conditional_t<same_as<Bound, unreachable_sentinel_t>, ptrdiff_t, Bound>;
const T* value_ = nullptr; // exposition only
index-type current_ = index-type(); // exposition only
constexpr explicit iterator (const T* value, index-type b = index-type()); // exposition only
public:
using iterator_concept = random_access_iterator_tag;
using iterator_category = random_access_iterator_tag;
using value_type = T;
using difference_type = see below ;
iterator () = default;
constexpr const T& operator*() const noexcept;
§ 25.6.5.3 © ISO/IEC
1271

===== PAGE 1283 =====

Dxxxx
constexpr iterator & operator++();
constexpr iterator operator++(int);
constexpr iterator & operator--();
constexpr iterator operator--(int);
constexpr iterator & operator+=(difference_type n);
constexpr iterator & operator-=(difference_type n);
constexpr const T& operator[](difference_type n) const noexcept;
friend constexpr bool operator==(const iterator & x, const iterator & y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y);
friend constexpr iterator operator+(iterator i, difference_type n);
friend constexpr iterator operator+(difference_type n, iterator i);
friend constexpr iterator operator-(iterator i, difference_type n);
friend constexpr difference_type operator-(const iterator & x, const iterator & y);
};
}
1 If is-signed-integer-like <index-type > is true, the membertypedef-name difference_type denotes
index-type . Otherwise, it denotesIOTA-DIFF-T(index-type ) (25.6.4.2).
constexpr explicit iterator (const T* value, index-type b = index-type ());
2 Preconditions: If Bound is notunreachable_sentinel_t, b ≥0.
3 Effects: Initializes value_ with value and current_ with b.
constexpr const T& operator*() const noexcept;
4 Effects: Equivalent to:return *value_;
constexpr iterator & operator++();
5 Effects: Equivalent to:
++current_;
return *this;
constexpr iterator operator++(int);
6 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--();
7 Preconditions: If Bound is notunreachable_sentinel_t, current_ >0.
8 Effects: Equivalent to:
--current_;
return *this;
constexpr iterator operator--(int);
9 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type n);
10 Preconditions: If Bound is notunreachable_sentinel_t, current_ + n ≥0.
11 Effects: Equivalent to:
current_ += n;
return *this;
§ 25.6.5.3 © ISO/IEC
1272

===== PAGE 1284 =====

Dxxxx
constexpr iterator & operator-=(difference_type n);
12 Preconditions: If Bound is notunreachable_sentinel_t, current_ −n ≥0.
13 Effects: Equivalent to:
current_ -= n;
return *this;
constexpr const T& operator[](difference_type n) const noexcept;
14 Effects: Equivalent to:return *(*this + n);
friend constexpr bool operator==(const iterator & x, const iterator & y);
15 Effects: Equivalent to:return x.current_ == y.current_;
friend constexpr auto operator<=>(const iterator & x, const iterator & y);
16 Effects: Equivalent to:return x.current_ <=> y.current_;
friend constexpr iterator operator+(iterator i, difference_type n);
friend constexpr iterator operator+(difference_type n, iterator i);
17 Effects: Equivalent to:
i += n;
return i;
friend constexpr iterator operator-(iterator i, difference_type n);
18 Effects: Equivalent to:
i -= n;
return i;
friend constexpr difference_type operator-(const iterator & x, const iterator & y);
19 Effects: Equivalent to:
return static_cast<difference_type>(x.current_) - static_cast<difference_type>(y.current_);
25.6.6 Istream view [range.istream]
25.6.6.1 Overview [range.istream.overview]
1 basic_istream_view models input_range and reads (using operator>>) successive elements from its
corresponding input stream.
2 The name views::istream<T> denotes a customization point object (16.3.3.3.5). Given a typeT and a
subexpression E of typeU, ifU models derived_from<basic_istream<typename U::char_type, typename
U::traits_type>>, thentheexpression views::istream<T>(E)isexpression-equivalentto basic_istream_-
view<T, typename U::char_type, typename U::traits_type>(E); otherwise,views::istream<T>(E)is
ill-formed.
3 [Example 1:
auto ints = istringstream{"0 1 2 3 4"};
ranges::copy(views::istream<int>(ints), ostream_iterator<int>{cout, "-"});
// prints0-1-2-3-4-
—end example]
25.6.6.2 Class template basic_istream_view [range.istream.view]
namespace std::ranges {
template<class Val, class CharT, class Traits>
concept stream-extractable = // exposition only
requires(basic_istream<CharT, Traits>& is, Val& t) {
is >> t;
};
§ 25.6.6.2 © ISO/IEC
1273

===== PAGE 1285 =====

Dxxxx
template<movable Val, class CharT, class Traits = char_traits<CharT>>
requires default_initializable<Val> &&
stream-extractable <Val, CharT, Traits>
class basic_istream_view : public view_interface<basic_istream_view<Val, CharT, Traits>> {
public:
constexpr explicit basic_istream_view(basic_istream<CharT, Traits>& stream);
constexpr auto begin() {
*stream_ >> value_;
return iterator {*this};
}
constexpr default_sentinel_t end() const noexcept;
private:
// 25.6.6.3, classbasic_istream_view::iterator
struct iterator; // exposition only
basic_istream<CharT, Traits>* stream_; // exposition only
Val value_ = Val(); // exposition only
};
}
constexpr explicit basic_istream_view(basic_istream<CharT, Traits>& stream);
1 Effects: Initializes stream_ with addressof(stream).
constexpr default_sentinel_t end() const noexcept;
2 Effects: Equivalent to:return default_sentinel;
25.6.6.3 Class basic_istream_view::iterator [range.istream.iterator]
namespace std::ranges {
template<movable Val, class CharT, class Traits>
requires default_initializable<Val> &&
stream-extractable <Val, CharT, Traits>
class basic_istream_view<Val, CharT, Traits>::iterator {
public:
using iterator_concept = input_iterator_tag;
using difference_type = ptrdiff_t;
using value_type = Val;
constexpr explicit iterator (basic_istream_view& parent) noexcept;
iterator (const iterator &) = delete;
iterator (iterator &&) = default;
iterator & operator=(const iterator &) = delete;
iterator & operator=(iterator &&) = default;
iterator & operator++();
void operator++(int);
Val& operator*() const;
friend bool operator==(const iterator & x, default_sentinel_t);
private:
basic_istream_view* parent_; // exposition only
};
}
constexpr explicit iterator (basic_istream_view& parent) noexcept;
1 Effects: Initializes parent_ with addressof(parent).
§ 25.6.6.3 © ISO/IEC
1274

===== PAGE 1286 =====

Dxxxx
iterator & operator++();
2 Effects: Equivalent to:
*parent_->stream_ >> parent_->value_;
return *this;
void operator++(int);
3 Effects: Equivalent to++*this.
Val& operator*() const;
4 Effects: Equivalent to:return parent_->value_;
friend bool operator==(const iterator & x, default_sentinel_t);
5 Effects: Equivalent to:return !*x.parent_->stream_;
25.7 Range adaptors [range.adaptors]
25.7.1 General [range.adaptors.general]
1 Subclause 25.7 definesrange adaptors, which are utilities that transform a range into a view with custom
behaviors. These adaptors can be chained to create pipelines of range transformations that evaluate lazily as
the resulting view is iterated.
2 Range adaptors are declared in namespacestd::ranges::views.
3 The bitwiseor operator is overloaded for the purpose of creating adaptor chain pipelines. The adaptors also
support function call syntax with equivalent semantics.
4 [Example 1:
vector<int> ints{0,1,2,3,4,5};
auto even = [](int i) { return 0 == i % 2; };
auto square = [](int i) { return i * i; };
for (int i : ints | views::filter(even) | views::transform(square)) {
cout << i << ' '; // prints0 4 16
}
assert(ranges::equal(ints | views::filter(even), views::filter(ints, even)));
—end example]
25.7.2 Range adaptor objects [range.adaptor.object]
1 A range adaptor closure objectis a unary function object that accepts a range argument. For a range adaptor
closure objectC and an expressionR such thatdecltype((R)) models range, the following expressions are
equivalent:
C(R)
R | C
Given an additional range adaptor closure objectD, the expressionC | D produces another range adaptor
closure objectE. E is a perfect forwarding call wrapper (22.10.4) with the following properties:
—(1.1) Its target object is an objectd of typedecay_t<decltype((D))> direct-non-list-initialized withD.
—(1.2) It has one bound argument entity, an objectc of type decay_t<decltype((C))> direct-non-list-
initialized withC.
—(1.3) Its call pattern isd(c(arg)), wherearg is the argument used in a function call expression ofE.
The expressionC | Dis well-formed if and only if the initializations of the state entities ofEare all well-formed.
2 Given an objectt of typeT, where
—(2.1) t is a unary function object that accepts a range argument,
—(2.2) T models derived_from<range_adaptor_closure<T>>,
—(2.3) T has no other base classes of typerange_adaptor_closure<U> for any other typeU, and
—(2.4) T does not modelrange
then the implementation ensures thatt is a range adaptor closure object.
§ 25.7.2 © ISO/IEC
1275

===== PAGE 1287 =====

Dxxxx
3 The template parameterD for range_adaptor_closure may be an incomplete type. If an expression of
type cv D is used as an operand to the| operator, D shall be complete and modelderived_from<range_-
adaptor_closure<D>>. The behavior of an expression involving an object of typecv D as an operand to the
| operator is undefined if overload resolution selects a program-definedoperator| function.
4 If an expression of typecv U is used as an operand to the| operator, where U has a base class of type
range_adaptor_closure<T> for some typeT other thanU, the behavior is undefined.
5 The behavior of a program that adds a specialization forrange_adaptor_closure is undefined.
6 A range adaptor objectis a customization point object (16.3.3.3.5) that accepts aviewable_range as its
first argument and returns a view.
7 If a range adaptor object accepts only one argument, then it is a range adaptor closure object.
8 If a range adaptor objectadaptor accepts more than one argument, then letrange be an expression such
that decltype((range)) models viewable_range, let args... be arguments such thatadaptor(range,
args...) is a well-formed expression as specified in the rest of subclause 25.7, and letBoundArgs be a
pack that denotesdecay_t<decltype((args))>.... The expressionadaptor(args...) produces a range
adaptor closure objectf that is a perfect forwarding call wrapper (22.10.4) with the following properties:
—(8.1) Its target object is a copy ofadaptor.
—(8.2) Its bound argument entitiesbound_args consist of objects of typesBoundArgs... direct-non-list-
initialized withstd::forward<decltype((args))>(args)..., respectively.
—(8.3) Its call pattern is adaptor(r, bound_args...), where r is the argument used in a function call
expression off.
The expression adaptor(args...) is well-formed if and only if the initialization of the bound argument
entities of the result, as specified above, are all well-formed.
25.7.3 Movable wrapper [range.move.wrap]
1 Many types in this subclause are specified in terms of an exposition-only class templatemovable-box .
movable-box <T> behaves exactly likeoptional<T> with the following differences:
—(1.1) movable-box <T> constrains its type parameterT with move_constructible<T> && is_object_v<T>.
—(1.2) The default constructor ofmovable-box <T> is equivalent to:
constexpr movable-box () noexcept(is_nothrow_default_constructible_v<T>)
requires default_initializable<T>
: movable-box {in_place} {}
—(1.3) If copyable<T> is not modeled, the copy assignment operator is equivalent to:
constexpr movable-box & operator=(const movable-box & that)
noexcept(is_nothrow_copy_constructible_v<T>)
requires copy_constructible<T> {
if (this != addressof(that)) {
if (that) emplace(*that);
else reset();
}
return *this;
}
—(1.4) If movable<T> is not modeled, the move assignment operator is equivalent to:
constexpr movable-box & operator=(movable-box && that)
noexcept(is_nothrow_move_constructible_v<T>) {
if (this != addressof(that)) {
if (that) emplace(std::move(*that));
else reset();
}
return *this;
}
2 Recommended practice:
—(2.1) If copy_constructible<T>is true, movable-box <T>should store only aTif eitherTmodels copyable,
or is_nothrow_move_constructible_v<T> && is_nothrow_copy_constructible_v<T> is true.
§ 25.7.3 © ISO/IEC
1276

===== PAGE 1288 =====

Dxxxx
—(2.2) Otherwise, movable-box <T> should store only aT if eitherT models movable or is_nothrow_move_-
constructible_v<T> is true.
25.7.4 Non-propagating cache [range.nonprop.cache]
1 Some types in 25.7 are specified in terms of an exposition-only class templatenon-propagating-cache .
non-propagating-cache <T> behaves exactly likeoptional<T> with the following differences:
—(1.1) non-propagating-cache <T> constrains its type parameterT with is_object_v<T>.
—(1.2) The copy constructor is equivalent to:
constexpr non-propagating-cache (const non-propagating-cache &) noexcept {}
—(1.3) The move constructor is equivalent to:
constexpr non-propagating-cache (non-propagating-cache && other) noexcept {
other.reset();
}
—(1.4) The copy assignment operator is equivalent to:
constexpr non-propagating-cache & operator=(const non-propagating-cache & other) noexcept {
if (addressof(other) != this)
reset();
return *this;
}
—(1.5) The move assignment operator is equivalent to:
constexpr non-propagating-cache & operator=(non-propagating-cache && other) noexcept {
reset();
other.reset();
return *this;
}
—(1.6) non-propagating-cache <T> has an additional member function template specified as follows:
template<class I>
constexpr T& emplace-deref (const I& i); // exposition only
Mandates: The declarationT t(*i); is well-formed for some invented variablet.
[Note 1: If *i is a prvalue of typecv T, there is no requirement that it is movable (9.5.1).—end note]
Effects: Calls reset(). Then direct-non-list-initializes the contained value with*i.
Postconditions: *this contains a value.
Returns: A reference to the new contained value.
Throws: Any exception thrown by the initialization of the contained value.
Remarks: If an exception is thrown during the initialization ofT, *this does not contain a value,
and the previous value (if any) has been destroyed.
2 [Note 2: non-propagating-cache enables an input view to temporarily cache values as it is iterated over.—end
note]
25.7.5 Range adaptor helpers [range.adaptor.helpers]
namespace std::ranges {
template<class F, class Tuple>
constexpr auto tuple-transform (F&& f, Tuple&& t) { // exposition only
return apply([&]<class... Ts>(Ts&&... elements) {
return tuple<invoke_result_t<F&, Ts>...>(invoke(f, std::forward<Ts>(elements))...);
}, std::forward<Tuple>(t));
}
template<class F, class Tuple>
constexpr void tuple-for-each (F&& f, Tuple&& t) { // exposition only
apply([&]<class... Ts>(Ts&&... elements) {
(static_cast<void>(invoke(f, std::forward<Ts>(elements))), ...);
}, std::forward<Tuple>(t));
}
§ 25.7.5 © ISO/IEC
1277

===== PAGE 1289 =====

Dxxxx
template<class T>
constexpr T& as-lvalue (T&& t) { // exposition only
return static_cast<T&>(t);
}
template<bool Const, class... Views>
concept all-random-access = // exposition only
(random_access_range<maybe-const <Const, Views>> && ...);
template<bool Const, class... Views>
concept all-bidirectional = // exposition only
(bidirectional_range<maybe-const <Const, Views>> && ...);
template<bool Const, class... Views>
concept all-forward = // exposition only
(forward_range<maybe-const <Const, Views>> && ...);
}
25.7.6 All view [range.all]
25.7.6.1 General [range.all.general]
1 views::all returns a view that includes all elements of its range argument.
2 The nameviews::all denotes a range adaptor object (25.7.2). Given a subexpressionE, the expression
views::all(E) is expression-equivalent to:
—(2.1) decay-copy(E) if the decayed type ofE models view.
—(2.2) Otherwise, ref_view{E} if that expression is well-formed.
—(2.3) Otherwise, owning_view{E}.
25.7.6.2 Class template ref_view [range.ref.view]
1 ref_view is a view of the elements of some other range.
namespace std::ranges {
template<range R>
requires is_object_v<R>
class ref_view : public view_interface<ref_view<R>> {
private:
R* r_; // exposition only
public:
template<different-from <ref_view> T>
requires see below
constexpr ref_view(T&& t);
constexpr R& base() const { return *r_; }
constexpr iterator_t<R> begin() const { return ranges::begin(*r_); }
constexpr sentinel_t<R> end() const { return ranges::end(*r_); }
constexpr bool empty() const
requires requires { ranges::empty(*r_); }
{ return ranges::empty(*r_); }
constexpr auto size() const requires sized_range<R>
{ return ranges::size(*r_); }
constexpr auto reserve_hint() const requires approximately_sized_range<R>
{ return ranges::reserve_hint(*r_); }
constexpr auto data() const requires contiguous_range<R>
{ return ranges::data(*r_); }
};
§ 25.7.6.2 © ISO/IEC
1278

===== PAGE 1290 =====

Dxxxx
template<class R>
ref_view(R&) -> ref_view<R>;
}
template<different-from <ref_view> T>
requires see below
constexpr ref_view(T&& t);
2 Effects: Initializes r_ with addressof(static_cast<R&>(std::forward<T>(t))).
3 Remarks: Let FUN denote the exposition-only functions
void FUN (R&);
void FUN (R&&) = delete;
The expression in therequires-clause is equivalent to:
convertible_to<T, R&> && requires { FUN (declval<T>()); }
25.7.6.3 Class template owning_view [range.owning.view]
1 owning_view is a move-only view of the elements of some other range.
namespace std::ranges {
template<range R>
requires movable<R> && (!is-initializer-list <R>) // see 25.4.6
class owning_view : public view_interface<owning_view<R>> {
private:
R r_ = R(); // exposition only
public:
owning_view() requires default_initializable<R> = default;
constexpr owning_view(R&& t);
owning_view(owning_view&&) = default;
owning_view& operator=(owning_view&&) = default;
constexpr R& base() & noexcept { return r_; }
constexpr const R& base() const & noexcept { return r_; }
constexpr R&& base() && noexcept { return std::move(r_); }
constexpr const R&& base() const && noexcept { return std::move(r_); }
constexpr iterator_t<R> begin() { return ranges::begin(r_); }
constexpr sentinel_t<R> end() { return ranges::end(r_); }
constexpr auto begin() const requires range<const R>
{ return ranges::begin(r_); }
constexpr auto end() const requires range<const R>
{ return ranges::end(r_); }
constexpr bool empty() requires requires { ranges::empty(r_); }
{ return ranges::empty(r_); }
constexpr bool empty() const requires requires { ranges::empty(r_); }
{ return ranges::empty(r_); }
constexpr auto size() requires sized_range<R>
{ return ranges::size(r_); }
constexpr auto size() const requires sized_range<const R>
{ return ranges::size(r_); }
constexpr auto reserve_hint() requires approximately_sized_range<R>
{ return ranges::reserve_hint(r_); }
constexpr auto reserve_hint() const requires approximately_sized_range<const R>
{ return ranges::reserve_hint(r_); }
constexpr auto data() requires contiguous_range<R>
{ return ranges::data(r_); }
§ 25.7.6.3 © ISO/IEC
1279

===== PAGE 1291 =====

Dxxxx
constexpr auto data() const requires contiguous_range<const R>
{ return ranges::data(r_); }
};
}
constexpr owning_view(R&& t);
2 Effects: Initializes r_ with std::move(t).
25.7.7 As rvalue view [range.as.rvalue]
25.7.7.1 Overview [range.as.rvalue.overview]
1 as_rvalue_view presents a view of an underlying sequence with the same behavior as the underlying sequence
except that its elements are rvalues. Some generic algorithms can be called with anas_rvalue_view to
replace copying with moving.
2 The nameviews::as_rvalue denotes a range adaptor object (25.7.2). LetE be an expression and letT be
decltype((E)). The expressionviews::as_rvalue(E) is expression-equivalent to:
—(2.1) views::all(E) if T models input_range and same_as<range_rvalue_reference_t<T>, range_-
reference_t<T>> is true.
—(2.2) Otherwise, as_rvalue_view(E).
3 [Example 1:
vector<string> words = {"the", "quick", "brown", "fox", "ate", "a", "pterodactyl"};
vector<string> new_words;
ranges::copy(words | views::as_rvalue, back_inserter(new_words));
// moves each string fromwords into new_words
—end example]
25.7.7.2 Class template as_rvalue_view [range.as.rvalue.view]
namespace std::ranges {
template<view V>
requires input_range<V>
class as_rvalue_view : public view_interface<as_rvalue_view<V>> {
V base_ = V(); // exposition only
public:
as_rvalue_view() requires default_initializable<V> = default;
constexpr explicit as_rvalue_view(V base);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>)
{ return move_iterator(ranges::begin(base_)); }
constexpr auto begin() const requires range<const V>
{ return move_iterator(ranges::begin(base_)); }
constexpr auto end() requires (!simple-view <V>) {
if constexpr (common_range<V>) {
return move_iterator(ranges::end(base_));
} else {
return move_sentinel(ranges::end(base_));
}
}
constexpr auto end() const requires range<const V> {
if constexpr (common_range<const V>) {
return move_iterator(ranges::end(base_));
} else {
return move_sentinel(ranges::end(base_));
}
}
§ 25.7.7.2 © ISO/IEC
1280

===== PAGE 1292 =====

Dxxxx
constexpr auto size() requires sized_range<V> { return ranges::size(base_); }
constexpr auto size() const requires sized_range<const V> { return ranges::size(base_); }
constexpr auto reserve_hint() requires approximately_sized_range<V>
{ return ranges::reserve_hint(base_); }
constexpr auto reserve_hint() const requires approximately_sized_range<const V>
{ return ranges::reserve_hint(base_); }
};
template<class R>
as_rvalue_view(R&&) -> as_rvalue_view<views::all_t<R>>;
}
constexpr explicit as_rvalue_view(V base);
1 Effects: Initializes base_ with std::move(base).
25.7.8 Filter view [range.filter]
25.7.8.1 Overview [range.filter.overview]
1 filter_view presents a view of the elements of an underlying sequence that satisfy a predicate.
2 The name views::filter denotes a range adaptor object (25.7.2). Given subexpressionsE and P, the
expression views::filter(E, P) is expression-equivalent tofilter_view(E, P).
3 [Example 1:
vector<int> is{ 0, 1, 2, 3, 4, 5, 6 };
auto evens = views::filter(is, [](int i) { return 0 == i % 2; });
for (int i : evens)
cout << i << ' '; // prints0 2 4 6
—end example]
25.7.8.2 Class template filter_view [range.filter.view]
namespace std::ranges {
template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
requires view<V> && is_object_v<Pred>
class filter_view : public view_interface<filter_view<V, Pred>> {
private:
V base_ = V(); // exposition only
movable-box<Pred> pred_; // exposition only
// 25.7.8.3, classfilter_view::iterator
class iterator ; // exposition only
// 25.7.8.4, classfilter_view::sentinel
class sentinel ; // exposition only
public:
filter_view() requires default_initializable<V> && default_initializable<Pred> = default;
constexpr explicit filter_view(V base, Pred pred);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr const Pred& pred() const;
constexpr iterator begin();
constexpr auto end() {
if constexpr (common_range<V>)
return iterator {*this, ranges::end(base_)};
else
return sentinel {*this};
}
};
§ 25.7.8.2 © ISO/IEC
1281

===== PAGE 1293 =====

Dxxxx
template<class R, class Pred>
filter_view(R&&, Pred) -> filter_view<views::all_t<R>, Pred>;
}
constexpr explicit filter_view(V base, Pred pred);
1 Effects: Initializes base_ with std::move(base) and initializespred_ with std::move(pred).
constexpr const Pred& pred() const;
2 Effects: Equivalent to:return *pred_;
constexpr iterator begin();
3 Preconditions: pred_.has_value() is true.
4 Returns: {*this, ranges::find_if(base_, ref(*pred_))}.
5 Remarks: In order to provide the amortized constant time complexity required by therange concept
when filter_view models forward_range, this function caches the result within thefilter_view for
use on subsequent calls.
25.7.8.3 Class filter_view::iterator [range.filter.iterator]
namespace std::ranges {
template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
requires view<V> && is_object_v<Pred>
class filter_view<V, Pred>::iterator {
private:
iterator_t<V> current_ = iterator_t<V>(); // exposition only
filter_view* parent_ = nullptr; // exposition only
public:
using iterator_concept = see below;
using iterator_category = see below; // not always present
using value_type = range_value_t<V>;
using difference_type = range_difference_t<V>;
iterator () requires default_initializable<iterator_t<V>> = default;
constexpr iterator (filter_view& parent, iterator_t<V> current);
constexpr const iterator_t<V>& base() const & noexcept;
constexpr iterator_t<V> base() &&;
constexpr range_reference_t<V> operator*() const;
constexpr iterator_t<V> operator->() const
requires has-arrow <iterator_t<V>> && copyable<iterator_t<V>>;
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires forward_range<V>;
constexpr iterator & operator--() requires bidirectional_range<V>;
constexpr iterator operator--(int) requires bidirectional_range<V>;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<V>>;
friend constexpr range_rvalue_reference_t<V> iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<V>>;
};
}
1 Modification of the element a filter_view::iterator denotes is permitted, but results in undefined
behavior if the resulting value does not satisfy the filter predicate.
§ 25.7.8.3 © ISO/IEC
1282

===== PAGE 1294 =====

Dxxxx
2 iterator ::iterator_concept is defined as follows:
—(2.1) If V models bidirectional_range, theniterator_concept denotes bidirectional_iterator_tag.
—(2.2) Otherwise, ifV models forward_range, theniterator_concept denotes forward_iterator_tag.
—(2.3) Otherwise, iterator_concept denotes input_iterator_tag.
3 The membertypedef-name iterator_category is defined if and only ifV models forward_range. In that
case, iterator ::iterator_category is defined as follows:
—(3.1) Let C denote the typeiterator_traits<iterator_t<V>>::iterator_category.
—(3.2) If C models derived_from<bidirectional_iterator_tag>, then iterator_category denotes bi-
directional_iterator_tag.
—(3.3) Otherwise, if C models derived_from<forward_iterator_tag>, then iterator_category denotes
forward_iterator_tag.
—(3.4) Otherwise, iterator_category denotes C.
constexpr iterator (filter_view& parent, iterator_t<V> current);
4 Effects: Initializes current_ with std::move(current) and parent_ with addressof(parent).
constexpr const iterator_t<V>& base() const & noexcept;
5 Effects: Equivalent to:return current_;
constexpr iterator_t<V> base() &&;
6 Effects: Equivalent to:return std::move(current_);
constexpr range_reference_t<V> operator*() const;
7 Effects: Equivalent to:return *current_;
constexpr iterator_t<V> operator->() const
requires has-arrow <iterator_t<V>> && copyable<iterator_t<V>>;
8 Effects: Equivalent to:return current_;
constexpr iterator & operator++();
9 Effects: Equivalent to:
current_ = ranges::find_if(std::move(++current_), ranges::end(parent_->base_),
ref(*parent_->pred_));
return *this;
constexpr void operator++(int);
10 Effects: Equivalent to++*this.
constexpr iterator operator++(int) requires forward_range<V>;
11 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<V>;
12 Effects: Equivalent to:
do
--current_;
while (!invoke(*parent_->pred_, *current_));
return *this;
constexpr iterator operator--(int) requires bidirectional_range<V>;
13 Effects: Equivalent to:
auto tmp = *this;
--*this;
§ 25.7.8.3 © ISO/IEC
1283

===== PAGE 1295 =====

Dxxxx
return tmp;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<V>>;
14 Effects: Equivalent to:return x.current_ == y.current_;
friend constexpr range_rvalue_reference_t<V> iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
15 Effects: Equivalent to:return ranges::iter_move(i.current_);
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<V>>;
16 Effects: Equivalent toranges::iter_swap(x.current_, y.current_).
25.7.8.4 Class filter_view::sentinel [range.filter.sentinel]
namespace std::ranges {
template<input_range V, indirect_unary_predicate<iterator_t<V>> Pred>
requires view<V> && is_object_v<Pred>
class filter_view<V, Pred>::sentinel {
private:
sentinel_t<V> end_ = sentinel_t<V>(); // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (filter_view& parent);
constexpr sentinel_t<V> base() const;
friend constexpr bool operator==(const iterator & x, const sentinel & y);
};
}
constexpr explicit sentinel (filter_view& parent);
1 Effects: Initializes end_ with ranges::end(parent.base_).
constexpr sentinel_t<V> base() const;
2 Effects: Equivalent to:return end_;
friend constexpr bool operator==(const iterator & x, const sentinel & y);
3 Effects: Equivalent to:return x.current_ == y.end_;
25.7.9 Transform view [range.transform]
25.7.9.1 Overview [range.transform.overview]
1 transform_view presents a view of an underlying sequence after applying a transformation function to each
element.
2 The nameviews::transform denotes a range adaptor object (25.7.2). Given subexpressionsE and F, the
expression views::transform(E, F) is expression-equivalent totransform_view(E, F).
3 [Example 1:
vector<int> is{ 0, 1, 2, 3, 4 };
auto squares = views::transform(is, [](int i) { return i * i; });
for (int i : squares)
cout << i << ' '; // prints0 1 4 9 16
—end example]
25.7.9.2 Class template transform_view [range.transform.view]
namespace std::ranges {
template<input_range V, move_constructible F>
requires view<V> && is_object_v<F> &&
§ 25.7.9.2 © ISO/IEC
1284

===== PAGE 1296 =====

Dxxxx
regular_invocable<F&, range_reference_t<V>> &&
can-reference <invoke_result_t<F&, range_reference_t<V>>>
class transform_view : public view_interface<transform_view<V, F>> {
private:
// 25.7.9.3, class templatetransform_view::iterator
template<bool> struct iterator ; // exposition only
// 25.7.9.4, class templatetransform_view::sentinel
template<bool> struct sentinel ; // exposition only
V base_ = V(); // exposition only
movable-box<F> fun_; // exposition only
public:
transform_view() requires default_initializable<V> && default_initializable<F> = default;
constexpr explicit transform_view(V base, F fun);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr iterator <false> begin();
constexpr iterator <true> begin() const
requires range<const V> &&
regular_invocable<const F&, range_reference_t<const V>>;
constexpr sentinel <false> end();
constexpr iterator <false> end() requires common_range<V>;
constexpr sentinel <true> end() const
requires range<const V> &&
regular_invocable<const F&, range_reference_t<const V>>;
constexpr iterator <true> end() const
requires common_range<const V> &&
regular_invocable<const F&, range_reference_t<const V>>;
constexpr auto size() requires sized_range<V> { return ranges::size(base_); }
constexpr auto size() const requires sized_range<const V>
{ return ranges::size(base_); }
constexpr auto reserve_hint() requires approximately_sized_range<V>
{ return ranges::reserve_hint(base_); }
constexpr auto reserve_hint() const requires approximately_sized_range<const V>
{ return ranges::reserve_hint(base_); }
};
template<class R, class F>
transform_view(R&&, F) -> transform_view<views::all_t<R>, F>;
}
constexpr explicit transform_view(V base, F fun);
1 Effects: Initializes base_ with std::move(base) and fun_ with std::move(fun).
constexpr iterator <false> begin();
2 Effects: Equivalent to:
return iterator <false>{*this, ranges::begin(base_)};
constexpr iterator <true> begin() const
requires range<const V> &&
regular_invocable<const F&, range_reference_t<const V>>;
3 Effects: Equivalent to:
return iterator <true>{*this, ranges::begin(base_)};
§ 25.7.9.2 © ISO/IEC
1285

===== PAGE 1297 =====

Dxxxx
constexpr sentinel <false> end();
4 Effects: Equivalent to:
return sentinel <false>{ranges::end(base_)};
constexpr iterator <false> end() requires common_range<V>;
5 Effects: Equivalent to:
return iterator <false>{*this, ranges::end(base_)};
constexpr sentinel <true> end() const
requires range<const V> &&
regular_invocable<const F&, range_reference_t<const V>>;
6 Effects: Equivalent to:
return sentinel <true>{ranges::end(base_)};
constexpr iterator <true> end() const
requires common_range<const V> &&
regular_invocable<const F&, range_reference_t<const V>>;
7 Effects: Equivalent to:
return iterator <true>{*this, ranges::end(base_)};
25.7.9.3 Class template transform_view::iterator [range.transform.iterator]
namespace std::ranges {
template<input_range V, move_constructible F>
requires view<V> && is_object_v<F> &&
regular_invocable<F&, range_reference_t<V>> &&
can-reference <invoke_result_t<F&, range_reference_t<V>>>
template<bool Const>
class transform_view<V, F>::iterator {
private:
using Parent = maybe-const<Const, transform_view>; // exposition only
using Base = maybe-const<Const, V>; // exposition only
iterator_t<Base> current_ = iterator_t<Base>(); // exposition only
Parent* parent_ = nullptr; // exposition only
public:
using iterator_concept = see below;
using iterator_category = see below; // not always present
using value_type =
remove_cvref_t<invoke_result_t<maybe-const<Const, F>&, range_reference_t<Base >>>;
using difference_type = range_difference_t< Base >;
iterator () requires default_initializable<iterator_t<Base >> = default;
constexpr iterator (Parent & parent, iterator_t<Base > current);
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
constexpr const iterator_t<Base >& base() const & noexcept;
constexpr iterator_t<Base > base() &&;
constexpr decltype(auto) operator*() const
noexcept(noexcept(invoke(*parent_->fun_, *current_))) {
return invoke(*parent_->fun_, *current_);
}
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires forward_range<Base >;
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
§ 25.7.9.3 © ISO/IEC
1286

===== PAGE 1298 =====

Dxxxx
constexpr iterator & operator+=(difference_type n)
requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type n)
requires random_access_range<Base >;
constexpr decltype(auto) operator[](difference_type n) const
requires random_access_range<Base > {
return invoke(*parent_->fun_, current_[n]);
}
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<Base >>;
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<iterator_t<Base >>;
friend constexpr iterator operator+(iterator i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, iterator i)
requires random_access_range<Base >;
friend constexpr iterator operator-(iterator i, difference_type n)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If Base models random_access_range, theniterator_concept denotes random_access_iterator_-
tag.
—(1.2) Otherwise, ifBase models bidirectional_range, theniterator_concept denotes bidirectional_-
iterator_tag.
—(1.3) Otherwise, if Base models forward_range, theniterator_concept denotes forward_iterator_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
2 The member typedef-name iterator_category is defined if and only if Base models forward_range.
In that case, iterator ::iterator_category is defined as follows: Let C denote the type iterator_-
traits<iterator_t<Base >>::iterator_category.
—(2.1) If is_reference_v<invoke_result_t<maybe-const<Const, F>&, range_reference_t<Base >>> is
true, then
—(2.1.1) if C models derived_from<contiguous_iterator_tag>, iterator_category denotes random_-
access_iterator_tag;
—(2.1.2) otherwise, iterator_category denotes C.
—(2.2) Otherwise, iterator_category denotes input_iterator_tag.
constexpr iterator (Parent & parent, iterator_t<Base > current);
3 Effects: Initializes current_ with std::move(current) and parent_ with addressof(parent).
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
4 Effects: Initializes current_ with std::move(i.current_) and parent_ with i.parent_.
§ 25.7.9.3 © ISO/IEC
1287

===== PAGE 1299 =====

Dxxxx
constexpr const iterator_t<Base >& base() const & noexcept;
5 Effects: Equivalent to:return current_;
constexpr iterator_t<Base > base() &&;
6 Effects: Equivalent to:return std::move(current_);
constexpr iterator & operator++();
7 Effects: Equivalent to:
++current_;
return *this;
constexpr void operator++(int);
8 Effects: Equivalent to++current_.
constexpr iterator operator++(int) requires forward_range<Base >;
9 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
10 Effects: Equivalent to:
--current_;
return *this;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
11 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type n)
requires random_access_range<Base >;
12 Effects: Equivalent to:
current_ += n;
return *this;
constexpr iterator & operator-=(difference_type n)
requires random_access_range<Base >;
13 Effects: Equivalent to:
current_ -= n;
return *this;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<Base >>;
14 Effects: Equivalent to:return x.current_ == y.current_;
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
15 Effects: Equivalent to:return x.current_ < y.current_;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
16 Effects: Equivalent to:return y < x;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
17 Effects: Equivalent to:return !(y < x);
§ 25.7.9.3 © ISO/IEC
1288

===== PAGE 1300 =====

Dxxxx
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
18 Effects: Equivalent to:return !(x < y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<iterator_t<Base >>;
19 Effects: Equivalent to:return x.current_ <=> y.current_;
friend constexpr iterator operator+(iterator i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, iterator i)
requires random_access_range<Base >;
20 Effects: Equivalent to:return iterator {*i.parent_, i.current_ + n};
friend constexpr iterator operator-(iterator i, difference_type n)
requires random_access_range<Base >;
21 Effects: Equivalent to:return iterator {*i.parent_, i.current_ - n};
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
22 Effects: Equivalent to:return x.current_ - y.current_;
25.7.9.4 Class template transform_view::sentinel [range.transform.sentinel]
namespace std::ranges {
template<input_range V, move_constructible F>
requires view<V> && is_object_v<F> &&
regular_invocable<F&, range_reference_t<V>> &&
can-reference <invoke_result_t<F&, range_reference_t<V>>>
template<bool Const>
class transform_view<V, F>::sentinel {
private:
using Parent = maybe-const <Const, transform_view>; // exposition only
using Base = maybe-const <Const, V>; // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (sentinel_t<Base > end);
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
constexpr sentinel_t<Base > base() const;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & y, const iterator <OtherConst>& x);
};
}
constexpr explicit sentinel (sentinel_t<Base > end);
1 Effects: Initializes end_ with end.
§ 25.7.9.4 © ISO/IEC
1289

===== PAGE 1301 =====

Dxxxx
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(i.end_).
constexpr sentinel_t<Base > base() const;
3 Effects: Equivalent to:return end_;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
4 Effects: Equivalent to:return x.current_ == y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
5 Effects: Equivalent to:return x.current_ - y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & y, const iterator <OtherConst>& x);
6 Effects: Equivalent to:return y.end_ - x.current_;
25.7.10 Take view [range.take]
25.7.10.1 Overview [range.take.overview]
1 take_view produces a view of the firstN elements from another view, or all the elements if the adapted
view contains fewer thanN.
2 The nameviews::take denotes a range adaptor object (25.7.2). LetE and F be expressions, letT be remove_-
cvref_t<decltype((E))>, and letDbe range_difference_t<decltype((E))>. If decltype((F))does not
model convertible_to<D>, views::take(E, F) is ill-formed. Otherwise, the expressionviews::take(E,
F) is expression-equivalent to:
—(2.1) If T is a specialization ofempty_view (25.6.2.2), then((void)F, decay-copy(E)), except that the
evaluations ofE and F are indeterminately sequenced.
—(2.2) Otherwise, if T is a specialization ofoptional and T models view, then(static_cast<D>(F) == D()
? ((void)E, T()) : decay-copy(E)).
—(2.3) Otherwise, if T models random_access_range and sized_range and is a specialization of span
(23.7.2.2), basic_string_view (27.3), orsubrange (25.5.4), thenU(ranges::begin(E), ranges::be-
gin(E) + std::min<D>(ranges::distance(E), F)), except thatE is evaluated only once, whereU
is a type determined as follows:
—(2.3.1) if T is a specialization ofspan, thenU is span<typename T::element_type>;
—(2.3.2) otherwise, ifT is a specialization ofbasic_string_view, thenU is T;
—(2.3.3) otherwise, T is a specialization ofsubrange, andU is subrange<iterator_t<T>>;
—(2.4) otherwise, if T is a specialization of iota_view (25.6.4.2) that models random_access_range and
sized_range, then iota_view(*ranges::begin(E), *(ranges::begin(E) + std::
min<D>(ranges::distance(E), F))), except thatE is evaluated only once.
—(2.5) Otherwise, ifT is a specialization ofrepeat_view (25.6.5.2):
—(2.5.1) if T models sized_range, then
views::repeat(*E.value_, std::min<D>(ranges::distance(E), F))
except thatE is evaluated only once;
—(2.5.2) otherwise, views::repeat(*E.value_, static_cast<D>(F)).
—(2.6) Otherwise, take_view(E, F).
§ 25.7.10.1 © ISO/IEC
1290

===== PAGE 1302 =====

Dxxxx
3 [Example 1:
vector<int> is{0,1,2,3,4,5,6,7,8,9};
for (int i : is | views::take(5))
cout << i << ' '; // prints0 1 2 3 4
—end example]
25.7.10.2 Class template take_view [range.take.view]
namespace std::ranges {
template<view V>
class take_view : public view_interface<take_view<V>> {
private:
V base_ = V(); // exposition only
range_difference_t<V> count_ = 0; // exposition only
// 25.7.10.3, class templatetake_view::sentinel
template<bool> class sentinel ; // exposition only
public:
take_view() requires default_initializable<V> = default;
constexpr explicit take_view(V base, range_difference_t<V> count);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>) {
if constexpr (sized_range<V>) {
if constexpr (random_access_range<V>) {
return ranges::begin(base_);
} else {
auto sz = range_difference_t<V>(size());
return counted_iterator(ranges::begin(base_), sz);
}
} else if constexpr (sized_sentinel_for<sentinel_t<V>, iterator_t<V>>) {
auto it = ranges::begin(base_);
auto sz = std::min(count_, ranges::end(base_) - it);
return counted_iterator(std::move(it), sz);
} else {
return counted_iterator(ranges::begin(base_), count_);
}
}
constexpr auto begin() const requires range<const V> {
if constexpr (sized_range<const V>) {
if constexpr (random_access_range<const V>) {
return ranges::begin(base_);
} else {
auto sz = range_difference_t<const V>(size());
return counted_iterator(ranges::begin(base_), sz);
}
} else if constexpr (sized_sentinel_for<sentinel_t<const V>, iterator_t<const V>>) {
auto it = ranges::begin(base_);
auto sz = std::min(count_, ranges::end(base_) - it);
return counted_iterator(std::move(it), sz);
} else {
return counted_iterator(ranges::begin(base_), count_);
}
}
constexpr auto end() requires (!simple-view <V>) {
if constexpr (sized_range<V>) {
if constexpr (random_access_range<V>)
return ranges::begin(base_) + range_difference_t<V>(size());
§ 25.7.10.2 © ISO/IEC
1291

===== PAGE 1303 =====

Dxxxx
else
return default_sentinel;
} else if constexpr (sized_sentinel_for<sentinel_t<V>, iterator_t<V>>) {
return default_sentinel;
} else {
return sentinel <false>{ranges::end(base_)};
}
}
constexpr auto end() const requires range<const V> {
if constexpr (sized_range<const V>) {
if constexpr (random_access_range<const V>)
return ranges::begin(base_) + range_difference_t<const V>(size());
else
return default_sentinel;
} else if constexpr (sized_sentinel_for<sentinel_t<const V>, iterator_t<const V>>) {
return default_sentinel;
} else {
return sentinel <true>{ranges::end(base_)};
}
}
constexpr auto size() requires sized_range<V> {
auto n = ranges::size(base_);
return ranges::min(n, static_cast<decltype(n)>(count_));
}
constexpr auto size() const requires sized_range<const V> {
auto n = ranges::size(base_);
return ranges::min(n, static_cast<decltype(n)>(count_));
}
constexpr auto reserve_hint() {
if constexpr (approximately_sized_range<V>) {
auto n = static_cast<range_difference_t<V>>(ranges::reserve_hint(base_));
return to-unsigned-like (ranges::min(n, count_));
}
return to-unsigned-like (count_);
}
constexpr auto reserve_hint() const {
if constexpr (approximately_sized_range<const V>) {
auto n = static_cast<range_difference_t<const V>>(ranges::reserve_hint(base_));
return to-unsigned-like (ranges::min(n, count_));
}
return to-unsigned-like (count_);
}
};
template<class R>
take_view(R&&, range_difference_t<R>)
-> take_view<views::all_t<R>>;
}
constexpr explicit take_view(V base, range_difference_t<V> count);
1 Preconditions: count >= 0 is true.
2 Effects: Initializes base_ with std::move(base) and count_ with count.
25.7.10.3 Class template take_view::sentinel [range.take.sentinel]
namespace std::ranges {
template<view V>
template<bool Const>
class take_view<V>::sentinel {
§ 25.7.10.3 © ISO/IEC
1292

===== PAGE 1304 =====

Dxxxx
private:
using Base = maybe-const <Const, V>; // exposition only
template<bool OtherConst>
using CI = counted_iterator<iterator_t<maybe-const <OtherConst, V>>>; // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (sentinel_t<Base > end);
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
constexpr sentinel_t<Base > base() const;
friend constexpr bool operator==(const CI <Const>& y, const sentinel & x);
template<bool OtherConst = !Const>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const CI <OtherConst>& y, const sentinel & x);
};
}
constexpr explicit sentinel (sentinel_t<Base > end);
1 Effects: Initializes end_ with end.
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(s.end_).
constexpr sentinel_t<Base > base() const;
3 Effects: Equivalent to:return end_;
friend constexpr bool operator==(const CI <Const>& y, const sentinel & x);
template<bool OtherConst = !Const>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const CI <OtherConst>& y, const sentinel & x);
4 Effects: Equivalent to:return y.count() == 0 || y.base() == x.end_;
25.7.11 Take while view [range.take.while]
25.7.11.1 Overview [range.take.while.overview]
1 Given a unary predicatepred and a viewr, take_while_view produces a view of the range[ranges::be-
gin(r),ranges::find_if_not(r, pred)).
2 The nameviews::take_while denotes a range adaptor object (25.7.2). Given subexpressionsE and F, the
expression views::take_while(E, F) is expression-equivalent totake_while_view(E, F).
3 [Example 1:
auto input = istringstream{"0 1 2 3 4 5 6 7 8 9"};
auto small = [](const auto x) noexcept { return x < 5; };
auto small_ints = views::istream<int>(input) | views::take_while(small);
for (const auto i : small_ints) {
cout << i << ' '; // prints0 1 2 3 4
}
auto i = 0;
input >> i;
cout << i; // prints6
—end example]
25.7.11.2 Class template take_while_view [range.take.while.view]
namespace std::ranges {
template<view V, class Pred>
§ 25.7.11.2 © ISO/IEC
1293

===== PAGE 1305 =====

Dxxxx
requires input_range<V> && is_object_v<Pred> &&
indirect_unary_predicate<const Pred, iterator_t<V>>
class take_while_view : public view_interface<take_while_view<V, Pred>> {
// 25.7.11.3, class templatetake_while_view::sentinel
template<bool> class sentinel; // exposition only
V base_ = V(); // exposition only
movable-box<Pred> pred_; // exposition only
public:
take_while_view() requires default_initializable<V> && default_initializable<Pred> = default;
constexpr explicit take_while_view(V base, Pred pred);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr const Pred& pred() const;
constexpr auto begin() requires (!simple-view <V>)
{ return ranges::begin(base_); }
constexpr auto begin() const
requires range<const V> &&
indirect_unary_predicate<const Pred, iterator_t<const V>>
{ return ranges::begin(base_); }
constexpr auto end() requires (!simple-view <V>)
{ return sentinel <false>(ranges::end(base_), addressof(*pred_)); }
constexpr auto end() const
requires range<const V> &&
indirect_unary_predicate<const Pred, iterator_t<const V>>
{ return sentinel <true>(ranges::end(base_), addressof(*pred_)); }
};
template<class R, class Pred>
take_while_view(R&&, Pred) -> take_while_view<views::all_t<R>, Pred>;
}
constexpr explicit take_while_view(V base, Pred pred);
1 Effects: Initializes base_ with std::move(base) and pred_ with std::move(pred).
constexpr const Pred& pred() const;
2 Effects: Equivalent to:return *pred_;
25.7.11.3 Class template take_while_view::sentinel [range.take.while.sentinel]
namespace std::ranges {
template<view V, class Pred>
requires input_range<V> && is_object_v<Pred> &&
indirect_unary_predicate<const Pred, iterator_t<V>>
template<bool Const>
class take_while_view<V, Pred>::sentinel {
using Base = maybe-const<Const, V>; // exposition only
sentinel_t<Base> end_ = sentinel_t<Base>(); // exposition only
const Pred* pred_ = nullptr; // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (sentinel_t<Base > end, const Pred* pred);
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
§ 25.7.11.3 © ISO/IEC
1294

===== PAGE 1306 =====

Dxxxx
constexpr sentinel_t<Base > base() const { return end_; }
friend constexpr bool operator==(const iterator_t<Base >& x, const sentinel & y);
template<bool OtherConst = !Const>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator_t<maybe-const <OtherConst, V>>& x,
const sentinel & y);
};
}
constexpr explicit sentinel (sentinel_t<Base > end, const Pred* pred);
1 Effects: Initializes end_ with end and pred_ with pred.
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(s.end_) and pred_ with s.pred_.
friend constexpr bool operator==(const iterator_t<Base >& x, const sentinel & y);
template<bool OtherConst = !Const>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator_t<maybe-const <OtherConst, V>>& x,
const sentinel & y);
3 Effects: Equivalent to:return y.end_ == x || !invoke(*y.pred_, *x);
25.7.12 Drop view [range.drop]
25.7.12.1 Overview [range.drop.overview]
1 drop_view produces a view excluding the firstN elements from another view, or an empty range if the
adapted view contains fewer thanN elements.
2 The nameviews::drop denotes a range adaptor object (25.7.2). LetE and F be expressions, letT be remove_-
cvref_t<decltype((E))>, and letDbe range_difference_t<decltype((E))>. If decltype((F))does not
model convertible_to<D>, views::drop(E, F) is ill-formed. Otherwise, the expressionviews::drop(E,
F) is expression-equivalent to:
—(2.1) If T is a specialization ofempty_view (25.6.2.2), then((void)F, decay-copy(E)), except that the
evaluations ofE and F are indeterminately sequenced.
—(2.2) Otherwise, if T is a specialization ofoptional and T models view, then(static_cast<D>(F) == D()
? decay-copy(E) : ((void)E, T())).
—(2.3) Otherwise, ifT models random_access_range and sized_range and is
—(2.3.1) a specialization ofspan (23.7.2.2),
—(2.3.2) a specialization ofbasic_string_view (27.3),
—(2.3.3) a specialization ofiota_view (25.6.4.2), or
—(2.3.4) a specialization ofsubrange (25.5.4) whereT::StoreSize is false,
then U(ranges::begin(E) + std::min<D>(ranges::distance(E), F), ranges::end(E)), except
that E is evaluated only once, whereU is span<typename T::element_type> if T is a specialization of
span and T otherwise.
—(2.4) Otherwise, ifT is a specialization ofsubrange that modelsrandom_access_range and sized_range,
then T(ranges::begin(E) + std::min<D>(ranges::distance(E), F), ranges::
end(E), to-unsigned-like (ranges::distance(E) - std::min<D>(ranges::distance(E), F))),
except thatE and F are each evaluated only once.
—(2.5) Otherwise, ifT is a specialization ofrepeat_view (25.6.5.2):
—(2.5.1) if T models sized_range, then
views::repeat(*E.value_, ranges::distance(E) - std::min<D>(ranges::distance(E), F))
except thatE is evaluated only once;
§ 25.7.12.1 © ISO/IEC
1295

===== PAGE 1307 =====

Dxxxx
—(2.5.2) otherwise, ((void)F, decay-copy(E)), except that the evaluations ofEand Fare indeterminately
sequenced.
—(2.6) Otherwise, drop_view(E, F).
3 [Example 1:
auto ints = views::iota(0) | views::take(10);
for (auto i : ints | views::drop(5)) {
cout << i << ' '; // prints5 6 7 8 9
}
—end example]
25.7.12.2 Class template drop_view [range.drop.view]
namespace std::ranges {
template<view V>
class drop_view : public view_interface<drop_view<V>> {
public:
drop_view() requires default_initializable<V> = default;
constexpr explicit drop_view(V base, range_difference_t<V> count);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin()
requires (!(simple-view <V> &&
random_access_range<const V> && sized_range<const V>));
constexpr auto begin() const
requires random_access_range<const V> && sized_range<const V>;
constexpr auto end() requires (!simple-view <V>)
{ return ranges::end(base_); }
constexpr auto end() const requires range<const V>
{ return ranges::end(base_); }
constexpr auto size() requires sized_range<V> {
const auto s = ranges::size(base_);
const auto c = static_cast<decltype(s)>(count_);
return s < c ? 0 : s - c;
}
constexpr auto size() const requires sized_range<const V> {
const auto s = ranges::size(base_);
const auto c = static_cast<decltype(s)>(count_);
return s < c ? 0 : s - c;
}
constexpr auto reserve_hint() requires approximately_sized_range<V> {
const auto s = static_cast<range_difference_t<V>>(ranges::reserve_hint(base_));
return to-unsigned-like (s < count_ ? 0 : s - count_);
}
constexpr auto reserve_hint() const requires approximately_sized_range<const V> {
const auto s = static_cast<range_difference_t<const V>>(ranges::reserve_hint(base_));
return to-unsigned-like (s < count_ ? 0 : s - count_);
}
private:
V base_ = V(); // exposition only
range_difference_t<V> count_ = 0; // exposition only
};
§ 25.7.12.2 © ISO/IEC
1296

===== PAGE 1308 =====

Dxxxx
template<class R>
drop_view(R&&, range_difference_t<R>) -> drop_view<views::all_t<R>>;
}
constexpr explicit drop_view(V base, range_difference_t<V> count);
1 Preconditions: count >= 0 is true.
2 Effects: Initializes base_ with std::move(base) and count_ with count.
constexpr auto begin()
requires (!(simple-view <V> &&
random_access_range<const V> && sized_range<const V>));
constexpr auto begin() const
requires random_access_range<const V> && sized_range<const V>;
3 Returns: ranges::next(ranges::begin(base_), count_, ranges::end(base_)).
4 Remarks: In order to provide the amortized constant-time complexity required by therange concept
when drop_view models forward_range, the first overload caches the result within thedrop_view for
use on subsequent calls.
[Note 1: Without this, applying areverse_view over adrop_view would have quadratic iteration complexity.
—end note]
25.7.13 Drop while view [range.drop.while]
25.7.13.1 Overview [range.drop.while.overview]
1 Given a unary predicatepred and a viewr, drop_while_view produces a view of the range[ranges::find_-
if_not(r, pred),ranges::end(r)).
2 The nameviews::drop_while denotes a range adaptor object (25.7.2). Given subexpressionsE and F, the
expression views::drop_while(E, F) is expression-equivalent todrop_while_view(E, F).
3 [Example 1:
constexpr auto source = " \t \t \t hello there"sv;
auto is_invisible = [](const auto x) { return x == ' ' || x == '\t'; };
auto skip_ws = views::drop_while(source, is_invisible);
for (auto c : skip_ws) {
cout << c; // printshello there with no leading space
}
—end example]
25.7.13.2 Class template drop_while_view [range.drop.while.view]
namespace std::ranges {
template<view V, class Pred>
requires input_range<V> && is_object_v<Pred> &&
indirect_unary_predicate<const Pred, iterator_t<V>>
class drop_while_view : public view_interface<drop_while_view<V, Pred>> {
public:
drop_while_view() requires default_initializable<V> && default_initializable<Pred> = default;
constexpr explicit drop_while_view(V base, Pred pred);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr const Pred& pred() const;
constexpr auto begin();
constexpr auto end() { return ranges::end(base_); }
private:
V base_ = V(); // exposition only
movable-box <Pred> pred_; // exposition only
};
§ 25.7.13.2 © ISO/IEC
1297

===== PAGE 1309 =====

Dxxxx
template<class R, class Pred>
drop_while_view(R&&, Pred) -> drop_while_view<views::all_t<R>, Pred>;
}
constexpr explicit drop_while_view(V base, Pred pred);
1 Effects: Initializes base_ with std::move(base) and pred_ with std::move(pred).
constexpr const Pred& pred() const;
2 Effects: Equivalent to:return *pred_;
constexpr auto begin();
3 Preconditions: pred_.has_value() is true.
4 Returns: ranges::find_if_not(base_, cref(*pred_)).
5 Remarks: In order to provide the amortized constant-time complexity required by therange concept
when drop_while_viewmodels forward_range, the first call caches the result within thedrop_while_-
view for use on subsequent calls.
[Note 1: Without this, applying a reverse_view over a drop_while_view would have quadratic iteration
complexity. —end note]
25.7.14 Join view [range.join]
25.7.14.1 Overview [range.join.overview]
1 join_view flattens a view of ranges into a view.
2 The nameviews::join denotes a range adaptor object (25.7.2). Given a subexpressionE, the expression
views::join(E) is expression-equivalent tojoin_view<views::all_t<decltype((E))>>{E}.
3 [Example 1:
vector<string> ss{"hello", " ", "world", "!"};
for (char ch : ss | views::join)
cout << ch; // printshello world!
—end example]
25.7.14.2 Class template join_view [range.join.view]
namespace std::ranges {
template<input_range V>
requires view<V> && input_range<range_reference_t<V>>
class join_view : public view_interface<join_view<V>> {
private:
using InnerRng = range_reference_t<V>; // exposition only
// 25.7.14.3, class templatejoin_view::iterator
template<bool Const>
struct iterator; // exposition only
// 25.7.14.4, class templatejoin_view::sentinel
template<bool Const>
struct sentinel; // exposition only
V base_ = V(); // exposition only
non-propagating-cache<iterator_t<V>> outer_; // exposition only, present only
// when !forward_range<V>
non-propagating-cache<remove_cv_t<InnerRng>> inner_; // exposition only, present only
// if is_reference_v<InnerRng > is false
public:
join_view() requires default_initializable<V> = default;
constexpr explicit join_view(V base);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
§ 25.7.14.2 © ISO/IEC
1298

===== PAGE 1310 =====

Dxxxx
constexpr auto begin() {
if constexpr (forward_range<V>) {
constexpr bool use_const = simple-view <V> &&
is_reference_v<InnerRng >;
return iterator <use_const>{*this, ranges::begin(base_)};
} else {
outer_ = ranges::begin(base_);
return iterator <false>{*this};
}
}
constexpr auto begin() const
requires forward_range<const V> &&
is_reference_v<range_reference_t<const V>> &&
input_range<range_reference_t<const V>>
{ return iterator <true>{*this, ranges::begin(base_)}; }
constexpr auto end() {
if constexpr (forward_range<V> &&
is_reference_v<InnerRng > && forward_range<InnerRng > &&
common_range<V> && common_range<InnerRng >)
return iterator <simple-view <V>>{*this, ranges::end(base_)};
else
return sentinel <simple-view <V>>{*this};
}
constexpr auto end() const
requires forward_range<const V> &&
is_reference_v<range_reference_t<const V>> &&
input_range<range_reference_t<const V>> {
if constexpr (forward_range<range_reference_t<const V>> &&
common_range<const V> &&
common_range<range_reference_t<const V>>)
return iterator <true>{*this, ranges::end(base_)};
else
return sentinel <true>{*this};
}
};
template<class R>
explicit join_view(R&&) -> join_view<views::all_t<R>>;
}
constexpr explicit join_view(V base);
1 Effects: Initializes base_ with std::move(base).
25.7.14.3 Class template join_view::iterator [range.join.iterator]
namespace std::ranges {
template<input_range V>
requires view<V> && input_range<range_reference_t<V>>
template<bool Const>
struct join_view<V>::iterator {
private:
using Parent = maybe-const<Const, join_view>; // exposition only
using Base = maybe-const<Const, V>; // exposition only
using OuterIter = iterator_t<Base>; // exposition only
using InnerIter = iterator_t<range_reference_t<Base>>; // exposition only
static constexpr bool ref-is-glvalue = // exposition only
is_reference_v<range_reference_t<Base>>;
OuterIter outer_ = OuterIter(); // exposition only, present only
§ 25.7.14.3 © ISO/IEC
1299

===== PAGE 1311 =====

Dxxxx
// if Base models forward_range
optional<InnerIter> inner_; // exposition only
Parent* parent_ = nullptr; // exposition only
constexpr void satisfy(); // exposition only
constexpr OuterIter& outer(); // exposition only
constexpr const OuterIter& outer() const; // exposition only
constexpr iterator(Parent& parent, OuterIter outer)
requires forward_range<Base>; // exposition only
constexpr explicit iterator(Parent& parent)
requires (!forward_range<Base>); // exposition only
public:
using iterator_concept = see below ;
using iterator_category = see below ; // not always present
using value_type = range_value_t<range_reference_t< Base >>;
using difference_type = see below ;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const &&
convertible_to<iterator_t<V>, OuterIter > &&
convertible_to<iterator_t<InnerRng >, InnerIter >;
constexpr decltype(auto) operator*() const { return **inner_; }
constexpr InnerIter operator->() const
requires has-arrow <InnerIter > && copyable<InnerIter >;
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int)
requires ref-is-glvalue && forward_range<Base > &&
forward_range<range_reference_t<Base >>;
constexpr iterator & operator--()
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional_range<range_reference_t<Base >> &&
common_range<range_reference_t<Base >>;
constexpr iterator operator--(int)
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional_range<range_reference_t<Base >> &&
common_range<range_reference_t<Base >>;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires ref-is-glvalue && forward_range<Base > &&
equality_comparable<iterator_t<range_reference_t<Base >>>;
friend constexpr decltype(auto) iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(*i.inner_))) {
return ranges::iter_move(*i.inner_);
}
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(*x.inner_, *y.inner_)))
requires indirectly_swappable<InnerIter >;
};
}
1 iterator ::iterator_concept is defined as follows:
§ 25.7.14.3 © ISO/IEC
1300

===== PAGE 1312 =====

Dxxxx
—(1.1) If ref-is-glvalue is true, Base models bidirectional_range, and range_reference_t<Base >
models bothbidirectional_range and common_range, theniterator_concept denotes bidirectio-
nal_iterator_tag.
—(1.2) Otherwise, if ref-is-glvalue is true and Base and range_reference_t<Base > each model for-
ward_range, theniterator_concept denotes forward_iterator_tag.
—(1.3) Otherwise, iterator_concept denotes input_iterator_tag.
2 Themember typedef-name iterator_categoryisdefinedifandonlyif ref-is-glvalue istrue, Base models
forward_range, andrange_reference_t<Base > models forward_range. In that case,iterator ::iter-
ator_category is defined as follows:
—(2.1) LetOUTERC denoteiterator_traits<iterator_t<Base >>::iterator_category, and letINNERC
denote iterator_traits<iterator_t<range_reference_t<Base >>>::iterator_category.
—(2.2) If OUTERC and INNERC each modelderived_from<bidirectional_iterator_tag> and range_-
reference_t<Base >models common_range, iterator_categorydenotes bidirectional_iterator_-
tag.
—(2.3) Otherwise, if OUTERC and INNERC each model derived_from<forward_iterator_tag>, iter-
ator_category denotes forward_iterator_tag.
—(2.4) Otherwise, iterator_category denotes input_iterator_tag.
3 iterator ::difference_type denotes the type:
common_type_t<
range_difference_t<Base >,
range_difference_t<range_reference_t<Base >>>
4 join_view iterators use thesatisfy function to skip over empty inner ranges.
constexpr OuterIter & outer ();
constexpr const OuterIter & outer () const;
5 Returns: outer_ if Base models forward_range; otherwise,*parent_->outer_.
constexpr void satisfy ();
6 Effects: Equivalent to:
auto update_inner = [this](const iterator_t<Base >& x) -> auto&& {
if constexpr (ref-is-glvalue ) // *x is a reference
return *x;
else
return parent_->inner_.emplace-deref (x);
};
for (; outer () != ranges::end(parent_->base_); ++outer ()) {
auto&& inner = update_inner(outer ());
inner_ = ranges::begin(inner);
if (*inner_ != ranges::end(inner))
return;
}
if constexpr (ref-is-glvalue )
inner_.reset();
constexpr iterator (Parent & parent, OuterIter outer)
requires forward_range<Base >;
7 Effects: Initializes outer_ with std::move(outer) and parent_ with addressof(parent); then calls
satisfy ().
constexpr explicit iterator (Parent & parent)
requires (!forward_range<Base >);
8 Effects: Initializes parent_ with addressof(parent); then callssatisfy ().
§ 25.7.14.3 © ISO/IEC
1301

===== PAGE 1313 =====

Dxxxx
constexpr iterator (iterator <!Const> i)
requires Const &&
convertible_to<iterator_t<V>, OuterIter > &&
convertible_to<iterator_t<InnerRng >, InnerIter >;
9 Effects: Initializes outer_ with std::move(i.outer_), inner_ with std::move(i.inner_), and
parent_ with i.parent_.
10 [Note 1: Const can only betrue when Base models forward_range. —end note]
constexpr InnerIter operator->() const
requires has-arrow <InnerIter > && copyable<InnerIter >;
11 Effects: Equivalent to:return *inner_;
constexpr iterator & operator++();
12 Let inner-range be:
—(12.1) If ref-is-glvalue is true, *outer ().
—(12.2) Otherwise, *parent_->inner_.
13 Effects: Equivalent to:
if (++*inner_ == ranges::end(as-lvalue (inner-range ))) {
++outer ();
satisfy ();
}
return *this;
constexpr void operator++(int);
14 Effects: Equivalent to:++*this.
constexpr iterator operator++(int)
requires ref-is-glvalue && forward_range<Base > &&
forward_range<range_reference_t<Base >>;
15 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--()
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional_range<range_reference_t<Base >> &&
common_range<range_reference_t<Base >>;
16 Effects: Equivalent to:
if (outer_ == ranges::end(parent_->base_))
inner_ = ranges::end(as-lvalue (*--outer_));
while (*inner_ == ranges::begin(as-lvalue (*outer_)))
*inner_ = ranges::end(as-lvalue (*--outer_));
--*inner_;
return *this;
constexpr iterator operator--(int)
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional_range<range_reference_t<Base >> &&
common_range<range_reference_t<Base >>;
17 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
§ 25.7.14.3 © ISO/IEC
1302

===== PAGE 1314 =====

Dxxxx
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires ref-is-glvalue && forward_range<Base > &&
equality_comparable<iterator_t<range_reference_t<Base >>>;
18 Effects: Equivalent to:return x.outer_ == y.outer_ && x.inner_ == y.inner_;
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(*x.inner_, *y.inner_)))
requires indirectly_swappable<InnerIter >;
19 Effects: Equivalent to:ranges::iter_swap(*x.inner_, *y.inner_);
25.7.14.4 Class template join_view::sentinel [range.join.sentinel]
namespace std::ranges {
template<input_range V>
requires view<V> && input_range<range_reference_t<V>>
template<bool Const>
struct join_view<V>::sentinel {
private:
using Parent = maybe-const <Const, join_view>; // exposition only
using Base = maybe-const <Const, V>; // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (Parent & parent);
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
};
}
constexpr explicit sentinel (Parent & parent);
1 Effects: Initializes end_ with ranges::end(parent.base_).
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(s.end_).
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
3 Effects: Equivalent to:return x.outer () == y.end_;
25.7.15 Join with view [range.join.with]
25.7.15.1 Overview [range.join.with.overview]
1 join_with_view takes a view and a delimiter, and flattens the view, inserting every element of the delimiter
in between elements of the view. The delimiter can be a single element or a view of elements.
2 The nameviews::join_with denotes a range adaptor object (25.7.2). Given subexpressionsE and F, the
expression views::join_with(E, F) is expression-equivalent tojoin_with_view(E, F).
3 [Example 1:
vector<string> vs = {"the", "quick", "brown", "fox"};
for (char c : vs | views::join_with('-')) {
cout << c;
}
// The above printsthe-quick-brown-fox
—end example]
§ 25.7.15.1 © ISO/IEC
1303

===== PAGE 1315 =====

Dxxxx
25.7.15.2 Class template join_with_view [range.join.with.view]
namespace std::ranges {
template<class R>
concept bidirectional-common = bidirectional_range<R> && common_range<R>; // exposition only
template<input_range V, forward_range Pattern>
requires view<V> && input_range<range_reference_t<V>>
&& view<Pattern>
&& concatable <range_reference_t<V>, Pattern>
class join_with_view : public view_interface<join_with_view<V, Pattern>> {
using InnerRng = range_reference_t<V>; // exposition only
V base_ = V(); // exposition only
non-propagating-cache <iterator_t<V>> outer_it_; // exposition only, present only
// when !forward_range<V>
non-propagating-cache <remove_cv_t<InnerRng >> inner_; // exposition only, present only
// if is_reference_v<InnerRng > is false
Pattern pattern_ = Pattern(); // exposition only
// 25.7.15.3, class templatejoin_with_view::iterator
template<bool Const> struct iterator ; // exposition only
// 25.7.15.4, class templatejoin_with_view::sentinel
template<bool Const> struct sentinel ; // exposition only
public:
join_with_view()
requires default_initializable<V> && default_initializable<Pattern> = default;
constexpr explicit join_with_view(V base, Pattern pattern);
template<input_range R>
requires constructible_from<V, views::all_t<R>> &&
constructible_from<Pattern, single_view<range_value_t<InnerRng >>>
constexpr explicit join_with_view(R&& r, range_value_t<InnerRng > e);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() {
if constexpr (forward_range<V>) {
constexpr bool use_const =
simple-view <V> && is_reference_v<InnerRng > && simple-view <Pattern>;
return iterator <use_const>{*this, ranges::begin(base_)};
}
else {
outer_it_ = ranges::begin(base_);
return iterator <false>{*this};
}
}
constexpr auto begin() const
requires forward_range<const V> &&
forward_range<const Pattern> &&
is_reference_v<range_reference_t<const V>> &&
input_range<range_reference_t<const V>> &&
concatable <range_reference_t<const V>, const Pattern> {
return iterator <true>{*this, ranges::begin(base_)};
}
constexpr auto end() {
if constexpr (forward_range<V> &&
is_reference_v<InnerRng > && forward_range<InnerRng > &&
common_range<V> && common_range<InnerRng >)
return iterator <simple-view <V> && simple-view <Pattern>>{*this, ranges::end(base_)};
§ 25.7.15.2 © ISO/IEC
1304

===== PAGE 1316 =====

Dxxxx
else
return sentinel <simple-view <V> && simple-view <Pattern>>{*this};
}
constexpr auto end() const
requires forward_range<const V> && forward_range<const Pattern> &&
is_reference_v<range_reference_t<const V>> &&
input_range<range_reference_t<const V>> &&
concatable <range_reference_t<const V>, const Pattern> {
using InnerConstRng = range_reference_t<const V>;
if constexpr (forward_range<InnerConstRng> &&
common_range<const V> && common_range<InnerConstRng>)
return iterator <true>{*this, ranges::end(base_)};
else
return sentinel <true>{*this};
}
};
template<class R, class P>
join_with_view(R&&, P&&) -> join_with_view<views::all_t<R>, views::all_t<P>>;
template<input_range R>
join_with_view(R&&, range_value_t<range_reference_t<R>>)
-> join_with_view<views::all_t<R>, single_view<range_value_t<range_reference_t<R>>>>;
}
constexpr explicit join_with_view(V base, Pattern pattern);
1 Effects: Initializes base_ with std::move(base) and pattern_ with std::move(pattern).
template<input_range R>
requires constructible_from<V, views::all_t<R>> &&
constructible_from<Pattern, single_view<range_value_t<InnerRng >>>
constexpr explicit join_with_view(R&& r, range_value_t<InnerRng > e);
2 Effects: Initializes base_ with views::all(std::forward<R>(r)) and pattern_ with views::sin-
gle(std::move(e)).
25.7.15.3 Class template join_with_view::iterator [range.join.with.iterator]
namespace std::ranges {
template<input_range V, forward_range Pattern>
requires view<V> && input_range<range_reference_t<V>>
&& view<Pattern> && concatable <range_reference_t<V>, Pattern>
template<bool Const>
class join_with_view<V, Pattern>::iterator {
using Parent = maybe-const <Const, join_with_view>; // exposition only
using Base = maybe-const <Const, V>; // exposition only
using InnerBase = range_reference_t<Base >; // exposition only
using PatternBase = maybe-const <Const, Pattern>; // exposition only
using OuterIter = iterator_t<Base >; // exposition only
using InnerIter = iterator_t<InnerBase >; // exposition only
using PatternIter = iterator_t<PatternBase >; // exposition only
static constexpr bool ref-is-glvalue = is_reference_v<InnerBase >; // exposition only
Parent * parent_ = nullptr; // exposition only
OuterIter outer_it_ = OuterIter (); // exposition only, present only
// if Base models forward_range
variant<PatternIter , InnerIter > inner_it_; // exposition only
constexpr iterator (Parent & parent, OuterIter outer)
requires forward_range<Base >; // exposition only
constexpr explicit iterator (Parent & parent)
requires (!forward_range<Base >); // exposition only
constexpr OuterIter & outer (); // exposition only
§ 25.7.15.3 © ISO/IEC
1305

===== PAGE 1317 =====

Dxxxx
constexpr const OuterIter & outer () const; // exposition only
constexpr auto& update-inner (); // exposition only
constexpr auto& get-inner (); // exposition only
constexpr void satisfy (); // exposition only
public:
using iterator_concept = see below ;
using iterator_category = see below ; // not always present
using value_type = see below ;
using difference_type = see below ;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, OuterIter > &&
convertible_to<iterator_t<InnerRng >, InnerIter > &&
convertible_to<iterator_t<Pattern>, PatternIter >;
constexpr decltype(auto) operator*() const;
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int)
requires ref-is-glvalue && forward_iterator<OuterIter > &&
forward_iterator<InnerIter >;
constexpr iterator & operator--()
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional-common <InnerBase > && bidirectional-common <PatternBase >;
constexpr iterator operator--(int)
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional-common <InnerBase > && bidirectional-common <PatternBase >;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires ref-is-glvalue && forward_range<Base > &&
equality_comparable<InnerIter >;
friend constexpr decltype(auto) iter_move(const iterator & x) {
using rvalue_reference = common_reference_t<
iter_rvalue_reference_t<InnerIter >,
iter_rvalue_reference_t<PatternIter >>;
return visit<rvalue_reference>(ranges::iter_move, x.inner_it_);
}
friend constexpr void iter_swap(const iterator & x, const iterator & y)
requires indirectly_swappable<InnerIter , PatternIter > {
visit(ranges::iter_swap, x.inner_it_, y.inner_it_);
}
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If ref-is-glvalue is true, Base models bidirectional_range, andInnerBase and PatternBase
each modelbidirectional-common , theniterator_concept denotes bidirectional_iterator_tag.
—(1.2) Otherwise, if ref-is-glvalue is true and Base and InnerBase each modelforward_range, then
iterator_concept denotes forward_iterator_tag.
—(1.3) Otherwise, iterator_concept denotes input_iterator_tag.
2 The membertypedef-name iterator_category is defined if and only ifref-is-glvalue is true, andBase
and InnerBase each model forward_range. In that case, iterator ::iterator_category is defined as
follows:
§ 25.7.15.3 © ISO/IEC
1306

===== PAGE 1318 =====

Dxxxx
—(2.1) Let OUTERC denote iterator_traits<OuterIter >::iterator_category, let INNERC denote
iterator_traits<InnerIter >::iterator_category, and let PATTERNC denote iterator_-
traits<PatternIter >::iterator_category.
—(2.2) If
is_reference_v<common_reference_t<iter_reference_t<InnerIter >,
iter_reference_t<PatternIter >>>
is false, iterator_category denotes input_iterator_tag.
—(2.3) Otherwise, if OUTERC, INNERC, and PATTERNC each model derived_from<bidirectional_-
iterator_tag> and InnerBase and PatternBase each model common_range, iterator_category
denotes bidirectional_iterator_tag.
—(2.4) Otherwise, ifOUTERC, INNERC, andPATTERNC each modelderived_from<forward_iterator_-
tag>, iterator_category denotes forward_iterator_tag.
—(2.5) Otherwise, iterator_category denotes input_iterator_tag.
3 iterator ::value_type denotes the type:
common_type_t<iter_value_t<InnerIter >, iter_value_t<PatternIter >>
4 iterator ::difference_type denotes the type:
common_type_t<
iter_difference_t<OuterIter >,
iter_difference_t<InnerIter >,
iter_difference_t<PatternIter >>
constexpr OuterIter & outer ();
constexpr const OuterIter & outer () const;
5 Returns: outer_it_ if Base models forward_range; otherwise,*parent_->outer_it_.
constexpr auto& update-inner ();
6 Effects: Equivalent to:
if constexpr (ref-is-glvalue )
return as-lvalue (*outer ());
else
return parent_->inner_.emplace-deref (outer ());
constexpr auto& get-inner ();
7 Effects: Equivalent to:
if constexpr (ref-is-glvalue )
return as-lvalue (*outer ());
else
return *parent_->inner_;
constexpr void satisfy ();
8 Effects: Equivalent to:
while (true) {
if (inner_it_.index() == 0) {
if (std::get<0>(inner_it_) != ranges::end(parent_->pattern_))
break;
inner_it_.template emplace<1>(ranges::begin(update-inner ()));
} else {
if (std::get<1>(inner_it_) != ranges::end(get-inner ()))
break;
if (++outer () == ranges::end(parent_->base_)) {
if constexpr (ref-is-glvalue )
inner_it_.template emplace<0>();
break;
}
inner_it_.template emplace<0>(ranges::begin(parent_->pattern_));
}
}
§ 25.7.15.3 © ISO/IEC
1307

===== PAGE 1319 =====

Dxxxx
[Note 1: join_with_view iterators use thesatisfy function to skip over empty inner ranges.—end note]
constexpr iterator (Parent & parent, OuterIter outer)
requires forward_range<Base >;
constexpr explicit iterator (Parent & parent)
requires (!forward_range<Base >);
9 Effects: Initializes parent_ with addressof(parent). For the first overload, also initializesouter_-
it_ with std::move(outer). Then, equivalent to:
if (outer () != ranges::end(parent_->base_)) {
inner_it_.template emplace<1>(ranges::begin(update-inner ()));
satisfy();
}
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, OuterIter > &&
convertible_to<iterator_t<InnerRng >, InnerIter > &&
convertible_to<iterator_t<Pattern>, PatternIter >;
10 Effects: Initializes outer_it_ with std::move(i.outer_it_) and parent_ with i.parent_. Then,
equivalent to:
if (i.inner_it_.index() == 0)
inner_it_.template emplace<0>(std::get<0>(std::move(i.inner_it_)));
else
inner_it_.template emplace<1>(std::get<1>(std::move(i.inner_it_)));
11 [Note 2: Const can only betrue when Base models forward_range. —end note]
constexpr decltype(auto) operator*() const;
12 Effects: Equivalent to:
using reference =
common_reference_t<iter_reference_t<InnerIter >, iter_reference_t<PatternIter >>;
return visit([](auto& it) -> reference { return *it; }, inner_it_);
constexpr iterator & operator++();
13 Effects: Equivalent to:
visit([](auto& it){ ++it; }, inner_it_);
satisfy();
return *this;
constexpr void operator++(int);
14 Effects: Equivalent to++*this.
constexpr iterator operator++(int)
requires ref-is-glvalue && forward_iterator<OuterIter > && forward_iterator<InnerIter >;
15 Effects: Equivalent to:
iterator tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--()
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional-common <InnerBase > && bidirectional-common <PatternBase >;
16 Effects: Equivalent to:
if (outer_it_ == ranges::end(parent_->base_)) {
auto&& inner = *--outer_it_;
inner_it_.template emplace<1>(ranges::end(inner));
}
while (true) {
if (inner_it_.index() == 0) {
auto& it = std::get<0>(inner_it_);
§ 25.7.15.3 © ISO/IEC
1308

===== PAGE 1320 =====

Dxxxx
if (it == ranges::begin(parent_->pattern_)) {
auto&& inner = *--outer_it_;
inner_it_.template emplace<1>(ranges::end(inner));
} else {
break;
}
} else {
auto& it = std::get<1>(inner_it_);
auto&& inner = *outer_it_;
if (it == ranges::begin(inner)) {
inner_it_.template emplace<0>(ranges::end(parent_->pattern_));
} else {
break;
}
}
}
visit([](auto& it){ --it; }, inner_it_);
return *this;
constexpr iterator operator--(int)
requires ref-is-glvalue && bidirectional_range<Base > &&
bidirectional-common <InnerBase > && bidirectional-common <PatternBase >;
17 Effects: Equivalent to:
iterator tmp = *this;
--*this;
return tmp;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires ref-is-glvalue && forward_range<Base > &&
equality_comparable<InnerIter >;
18 Effects: Equivalent to:
return x.outer_it_ == y.outer_it_ && x.inner_it_ == y.inner_it_;
25.7.15.4 Class template join_with_view::sentinel [range.join.with.sentinel]
namespace std::ranges {
template<input_range V, forward_range Pattern>
requires view<V> && input_range<range_reference_t<V>>
&& view<Pattern> && concatable <range_reference_t<V>, Pattern>
template<bool Const>
class join_with_view<V, Pattern>::sentinel {
using Parent = maybe-const <Const, join_with_view>; // exposition only
using Base = maybe-const <Const, V>; // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
constexpr explicit sentinel (Parent & parent); // exposition only
public:
sentinel () = default;
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
};
}
constexpr explicit sentinel (Parent & parent);
1 Effects: Initializes end_ with ranges::end(parent.base_).
§ 25.7.15.4 © ISO/IEC
1309

===== PAGE 1321 =====

Dxxxx
constexpr sentinel (sentinel <!Const> s)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(s.end_).
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
3 Effects: Equivalent to:return x.outer () == y.end_;
25.7.16 Lazy split view [range.lazy.split]
25.7.16.1 Overview [range.lazy.split.overview]
1 lazy_split_view takes a view and a delimiter, and splits the view into subranges on the delimiter. The
delimiter can be a single element or a view of elements.
2 The nameviews::lazy_split denotes a range adaptor object (25.7.2). Given subexpressionsE and F, the
expression views::lazy_split(E, F) is expression-equivalent tolazy_split_view(E, F).
3 [Example 1:
string str{"the quick brown fox"};
for (auto word : str | views::lazy_split(' ')) {
for (char ch : word)
cout << ch;
cout << '*';
}
// The above printsthe*quick*brown*fox*
—end example]
25.7.16.2 Class template lazy_split_view [range.lazy.split.view]
namespace std::ranges {
template<auto> struct require-constant; // exposition only
template<class R>
concept tiny-range = // exposition only
sized_range<R> &&
requires { typename require-constant <remove_reference_t<R>::size()>; } &&
(remove_reference_t<R>::size() <= 1);
template<input_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
(forward_range<V> || tiny-range <Pattern>)
class lazy_split_view : public view_interface<lazy_split_view<V, Pattern>> {
private:
V base_ = V(); // exposition only
Pattern pattern_ = Pattern(); // exposition only
non-propagating-cache<iterator_t<V>> current_; // exposition only, present only
// if forward_range<V> is false
// 25.7.16.3, class templatelazy_split_view::outer-iterator
template<bool> struct outer-iterator; // exposition only
// 25.7.16.5, class templatelazy_split_view::inner-iterator
template<bool> struct inner-iterator; // exposition only
public:
lazy_split_view()
requires default_initializable<V> && default_initializable<Pattern> = default;
constexpr explicit lazy_split_view(V base, Pattern pattern);
§ 25.7.16.2 © ISO/IEC
1310

===== PAGE 1322 =====

Dxxxx
template<input_range R>
requires constructible_from<V, views::all_t<R>> &&
constructible_from<Pattern, single_view<range_value_t<R>>>
constexpr explicit lazy_split_view(R&& r, range_value_t<R> e);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() {
if constexpr (forward_range<V>) {
return outer-iterator <simple-view <V> && simple-view <Pattern>>
{*this, ranges::begin(base_)};
} else {
current_ = ranges::begin(base_);
return outer-iterator <false>{*this};
}
}
constexpr auto begin() const requires forward_range<V> && forward_range<const V> {
return outer-iterator <true>{*this, ranges::begin(base_)};
}
constexpr auto end() requires forward_range<V> && common_range<V> {
return outer-iterator <simple-view <V> && simple-view <Pattern>>
{*this, ranges::end(base_)};
}
constexpr auto end() const {
if constexpr (forward_range<V> && forward_range<const V> && common_range<const V>)
return outer-iterator <true>{*this, ranges::end(base_)};
else
return default_sentinel;
}
};
template<class R, class P>
lazy_split_view(R&&, P&&) -> lazy_split_view<views::all_t<R>, views::all_t<P>>;
template<input_range R>
lazy_split_view(R&&, range_value_t<R>)
-> lazy_split_view<views::all_t<R>, single_view<range_value_t<R>>>;
}
constexpr explicit lazy_split_view(V base, Pattern pattern);
1 Effects: Initializes base_ with std::move(base), andpattern_ with std::move(pattern).
template<input_range R>
requires constructible_from<V, views::all_t<R>> &&
constructible_from<Pattern, single_view<range_value_t<R>>>
constexpr explicit lazy_split_view(R&& r, range_value_t<R> e);
2 Effects: Initializes base_ with views::all(std::forward<R>(r)), and pattern_ with views::
single(std::move(e)).
25.7.16.3 Class template lazy_split_view::outer-iterator [range.lazy.split.outer]
namespace std::ranges {
template<input_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
(forward_range<V> || tiny-range <Pattern>)
template<bool Const>
struct lazy_split_view<V, Pattern>::outer-iterator {
private:
using Parent = maybe-const<Const, lazy_split_view>; // exposition only
§ 25.7.16.3 © ISO/IEC
1311

===== PAGE 1323 =====

Dxxxx
using Base = maybe-const<Const, V>; // exposition only
Parent* parent_ = nullptr; // exposition only
iterator_t<Base> current_ = iterator_t<Base>(); // exposition only, present only
// if V models forward_range
bool trailing_empty_ = false; // exposition only
public:
using iterator_concept =
conditional_t<forward_range<Base >, forward_iterator_tag, input_iterator_tag>;
using iterator_category = input_iterator_tag; // present only ifBase
// modelsforward_range
// 25.7.16.4, classlazy_split_view::outer-iterator ::value_type
struct value_type;
using difference_type = range_difference_t< Base >;
outer-iterator () = default;
constexpr explicit outer-iterator (Parent & parent)
requires (!forward_range<Base >);
constexpr outer-iterator (Parent & parent, iterator_t<Base > current)
requires forward_range<Base >;
constexpr outer-iterator (outer-iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
constexpr value_type operator*() const;
constexpr outer-iterator & operator++();
constexpr decltype(auto) operator++(int) {
if constexpr (forward_range<Base >) {
auto tmp = *this;
++*this;
return tmp;
} else
++*this;
}
friend constexpr bool operator==(const outer-iterator & x, const outer-iterator & y)
requires forward_range<Base >;
friend constexpr bool operator==(const outer-iterator & x, default_sentinel_t);
};
}
1 Many of the specifications in 25.7.16 refer to the notional membercurrent of outer-iterator . current is
equivalent tocurrent_ if V models forward_range, and*parent_->current_ otherwise.
constexpr explicit outer-iterator (Parent & parent)
requires (!forward_range<Base >);
2 Effects: Initializes parent_ with addressof(parent).
constexpr outer-iterator (Parent & parent, iterator_t<Base > current)
requires forward_range<Base >;
3 Effects: Initializes parent_ with addressof(parent) and current_ with std::move(current).
constexpr outer-iterator (outer-iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
4 Effects: Initializesparent_ with i.parent_, current_ with std::move(i.current_), andtrailing_-
empty_ with i.trailing_empty_.
§ 25.7.16.3 © ISO/IEC
1312

===== PAGE 1324 =====

Dxxxx
constexpr value_type operator*() const;
5 Effects: Equivalent to:return value_type{*this};
constexpr outer-iterator & operator++();
6 Effects: Equivalent to:
const auto end = ranges::end(parent_->base_);
if (current == end) {
trailing_empty_ = false;
return *this;
}
const auto [pbegin, pend] = subrange{parent_->pattern_};
if (pbegin == pend) ++current ;
else if constexpr (tiny-range <Pattern>) {
current = ranges::find(std::move(current ), end, *pbegin);
if (current != end) {
++current ;
if (current == end)
trailing_empty_ = true;
}
}
else {
do {
auto [b, p] = ranges::mismatch(current , end, pbegin, pend);
if (p == pend) {
current = b;
if (current == end)
trailing_empty_ = true;
break; // The pattern matched; skip it
}
} while (++current != end);
}
return *this;
friend constexpr bool operator==(const outer-iterator & x, const outer-iterator & y)
requires forward_range<Base >;
7 Effects: Equivalent to:
return x.current_ == y.current_ && x.trailing_empty_ == y.trailing_empty_;
friend constexpr bool operator==(const outer-iterator & x, default_sentinel_t);
8 Effects: Equivalent to:
return x.current == ranges::end(x.parent_->base_) && !x.trailing_empty_;
25.7.16.4 Class lazy_split_view::outer-iterator::value_type [range.lazy.split.outer.value]
namespace std::ranges {
template<input_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
(forward_range<V> || tiny-range <Pattern>)
template<bool Const>
struct lazy_split_view<V, Pattern>::outer-iterator <Const>::value_type
: view_interface<value_type> {
private:
outer-iterator i_ = outer-iterator (); // exposition only
constexpr explicit value_type(outer-iterator i); // exposition only
public:
constexpr inner-iterator <Const> begin() const;
constexpr default_sentinel_t end() const noexcept;
};
}
§ 25.7.16.4 © ISO/IEC
1313

===== PAGE 1325 =====

Dxxxx
constexpr explicit value_type(outer-iterator i);
1 Effects: Initializes i_ with std::move(i).
constexpr inner-iterator <Const> begin() const;
2 Effects: Equivalent to:return inner-iterator <Const>{i_};
constexpr default_sentinel_t end() const noexcept;
3 Effects: Equivalent to:return default_sentinel;
25.7.16.5 Class template lazy_split_view::inner-iterator [range.lazy.split.inner]
namespace std::ranges {
template<input_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
(forward_range<V> || tiny-range <Pattern>)
template<bool Const>
struct lazy_split_view<V, Pattern>::inner-iterator {
private:
using Base = maybe-const<Const, V>; // exposition only
outer-iterator<Const> i_ = outer-iterator<Const>(); // exposition only
bool incremented_ = false; // exposition only
public:
using iterator_concept = outer-iterator <Const>::iterator_concept;
using iterator_category = see below; // present only ifBase
// modelsforward_range
using value_type = range_value_t< Base >;
using difference_type = range_difference_t< Base >;
inner-iterator () = default;
constexpr explicit inner-iterator (outer-iterator <Const> i);
constexpr const iterator_t<Base >& base() const & noexcept;
constexpr iterator_t<Base > base() && requires forward_range<V>;
constexpr decltype(auto) operator*() const { return *i_.current ; }
constexpr inner-iterator & operator++();
constexpr decltype(auto) operator++(int) {
if constexpr (forward_range<Base >) {
auto tmp = *this;
++*this;
return tmp;
} else
++*this;
}
friend constexpr bool operator==(const inner-iterator & x, const inner-iterator & y)
requires forward_range<Base >;
friend constexpr bool operator==(const inner-iterator & x, default_sentinel_t);
friend constexpr decltype(auto) iter_move(const inner-iterator & i)
noexcept(noexcept(ranges::iter_move(i.i_.current))) {
return ranges::iter_move(i.i_.current);
}
friend constexpr void iter_swap(const inner-iterator & x, const inner-iterator & y)
noexcept(noexcept(ranges::iter_swap(x.i_.current, y.i_.current)))
requires indirectly_swappable<iterator_t<Base >>;
};
}
§ 25.7.16.5 © ISO/IEC
1314

===== PAGE 1326 =====

Dxxxx
1 If Base does not modelforward_range there is no memberiterator_category. Otherwise, thetypedef-
name iterator_category denotes:
—(1.1) forward_iterator_tag if iterator_traits<iterator_t<Base >>::iterator_category models
derived_from<forward_iterator_tag>;
—(1.2) otherwise, iterator_traits<iterator_t<Base >>::iterator_category.
constexpr explicit inner-iterator (outer-iterator <Const> i);
2 Effects: Initializes i_ with std::move(i).
constexpr const iterator_t<Base >& base() const & noexcept;
3 Effects: Equivalent to:return i_.current ;
constexpr iterator_t<Base > base() && requires forward_range<V>;
4 Effects: Equivalent to:return std::move(i_.current );
constexpr inner-iterator & operator++();
5 Effects: Equivalent to:
incremented_ = true;
if constexpr (!forward_range<Base >) {
if constexpr (Pattern::size() == 0) {
return *this;
}
}
++i_.current ;
return *this;
friend constexpr bool operator==(const inner-iterator & x, const inner-iterator & y)
requires forward_range<Base >;
6 Effects: Equivalent to:return x.i_.current == y.i_.current ;
friend constexpr bool operator==(const inner-iterator & x, default_sentinel_t);
7 Effects: Equivalent to:
auto [pcur, pend] = subrange{x.i_.parent_->pattern_};
auto end = ranges::end(x.i_.parent_->base_);
if constexpr (tiny-range <Pattern>) {
const auto & cur = x.i_.current ;
if (cur == end) return true;
if (pcur == pend) return x.incremented_;
return *cur == *pcur;
} else {
auto cur = x.i_.current ;
if (cur == end) return true;
if (pcur == pend) return x.incremented_;
do {
if (*cur != *pcur) return false;
if (++pcur == pend) return true;
} while (++cur != end);
return false;
}
friend constexpr void iter_swap(const inner-iterator & x, const inner-iterator & y)
noexcept(noexcept(ranges::iter_swap(x.i_.current, y.i_.current)))
requires indirectly_swappable<iterator_t<Base >>;
8 Effects: Equivalent toranges::iter_swap(x.i_.current, y.i_.current).
25.7.17 Split view [range.split]
25.7.17.1 Overview [range.split.overview]
1 split_view takes a view and a delimiter, and splits the view intosubranges on the delimiter. The delimiter
can be a single element or a view of elements.
§ 25.7.17.1 © ISO/IEC
1315

===== PAGE 1327 =====

Dxxxx
2 The name views::split denotes a range adaptor object (25.7.2). Given subexpressions E and F, the
expression views::split(E, F) is expression-equivalent tosplit_view(E, F).
3 [Example 1:
string str{"the quick brown fox"};
for (auto word : views::split(str, ' ')) {
cout << string_view(word) << '*';
}
// The above printsthe*quick*brown*fox*
—end example]
25.7.17.2 Class template split_view [range.split.view]
namespace std::ranges {
template<forward_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to>
class split_view : public view_interface<split_view<V, Pattern>> {
private:
V base_ = V(); // exposition only
Pattern pattern_ = Pattern(); // exposition only
// 25.7.17.3, classsplit_view::iterator
struct iterator ; // exposition only
// 25.7.17.4, classsplit_view::sentinel
struct sentinel ; // exposition only
public:
split_view()
requires default_initializable<V> && default_initializable<Pattern> = default;
constexpr explicit split_view(V base, Pattern pattern);
template<forward_range R>
requires constructible_from<V, views::all_t<R>> &&
constructible_from<Pattern, single_view<range_value_t<R>>>
constexpr explicit split_view(R&& r, range_value_t<R> e);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr iterator begin();
constexpr auto end() {
if constexpr (common_range<V>) {
return iterator {*this, ranges::end(base_), {}};
} else {
return sentinel {*this};
}
}
constexpr subrange<iterator_t<V>> find-next (iterator_t<V>); // exposition only
};
template<class R, class P>
split_view(R&&, P&&) -> split_view<views::all_t<R>, views::all_t<P>>;
template<forward_range R>
split_view(R&&, range_value_t<R>)
-> split_view<views::all_t<R>, single_view<range_value_t<R>>>;
}
constexpr explicit split_view(V base, Pattern pattern);
1 Effects: Initializes base_ with std::move(base), andpattern_ with std::move(pattern).
§ 25.7.17.2 © ISO/IEC
1316

===== PAGE 1328 =====

Dxxxx
template<forward_range R>
requires constructible_from<V, views::all_t<R>> &&
constructible_from<Pattern, single_view<range_value_t<R>>>
constexpr explicit split_view(R&& r, range_value_t<R> e);
2 Effects: Initializes base_ with views::all(std::forward<R>(r)), and pattern_ with views::
single(std::move(e)).
constexpr iterator begin();
3 Returns: {*this, ranges::begin(base_), find-next (ranges::begin(base_))}.
4 Remarks: In order to provide the amortized constant time complexity required by therange concept,
this function caches the result within thesplit_view for use on subsequent calls.
constexpr subrange<iterator_t<V>> find-next (iterator_t<V> it);
5 Effects: Equivalent to:
auto [b, e] = ranges::search(subrange(it, ranges::end(base_)), pattern_);
if (b != ranges::end(base_) && ranges::empty(pattern_)) {
++b;
++e;
}
return {b, e};
25.7.17.3 Class split_view::iterator [range.split.iterator]
namespace std::ranges {
template<forward_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to>
class split_view<V, Pattern>::iterator {
private:
split_view* parent_ = nullptr; // exposition only
iterator_t<V> cur_ = iterator_t<V>(); // exposition only
subrange<iterator_t<V>> next_ = subrange<iterator_t<V>>(); // exposition only
bool trailing_empty_ = false; // exposition only
public:
using iterator_concept = forward_iterator_tag;
using iterator_category = input_iterator_tag;
using value_type = subrange<iterator_t<V>>;
using difference_type = range_difference_t<V>;
iterator () = default;
constexpr iterator (split_view& parent, iterator_t<V> current, subrange<iterator_t<V>> next);
constexpr iterator_t<V> base() const;
constexpr value_type operator*() const;
constexpr iterator & operator++();
constexpr iterator operator++(int);
friend constexpr bool operator==(const iterator & x, const iterator & y);
};
}
constexpr iterator (split_view& parent, iterator_t<V> current, subrange<iterator_t<V>> next);
1 Effects: Initializes parent_ with addressof(parent), cur_ with std::move(current), andnext_-
with std::move(next).
constexpr iterator_t<V> base() const;
2 Effects: Equivalent to:return cur_;
constexpr value_type operator*() const;
3 Effects: Equivalent to:return {cur_, next_.begin()};
§ 25.7.17.3 © ISO/IEC
1317

===== PAGE 1329 =====

Dxxxx
constexpr iterator & operator++();
4 Effects: Equivalent to:
cur_ = next_.begin();
if (cur_ != ranges::end(parent_->base_)) {
cur_ = next_.end();
if (cur_ == ranges::end(parent_->base_)) {
trailing_empty_ = true;
next_ = {cur_, cur_};
} else {
next_ = parent_->find-next (cur_);
}
} else {
trailing_empty_ = false;
}
return *this;
constexpr iterator operator++(int);
5 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
friend constexpr bool operator==(const iterator & x, const iterator & y);
6 Effects: Equivalent to:
return x.cur_ == y.cur_ && x.trailing_empty_ == y.trailing_empty_;
25.7.17.4 Class split_view::sentinel [range.split.sentinel]
namespace std::ranges {
template<forward_range V, forward_range Pattern>
requires view<V> && view<Pattern> &&
indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to>
struct split_view<V, Pattern>::sentinel {
private:
sentinel_t<V> end_ = sentinel_t<V>(); // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (split_view& parent);
friend constexpr bool operator==(const iterator & x, const sentinel & y);
};
}
constexpr explicit sentinel (split_view& parent);
1 Effects: Initializes end_ with ranges::end(parent.base_).
friend constexpr bool operator==(const iterator & x, const sentinel & y);
2 Effects: Equivalent to:return x.cur_ == y.end_ && !x.trailing_empty_;
25.7.18 Concat view [range.concat]
25.7.18.1 Overview [range.concat.overview]
1 concat_view presents a view that concatenates all the underlying ranges.
2 The nameviews::concat denotes a customization point object (16.3.3.3.5). Given a pack of subexpressions
Es..., the expressionviews::concat(Es...) is expression-equivalent to
—(2.1) views::all(Es...) if Es is a pack with only one element whose type modelsinput_range,
—(2.2) otherwise, concat_view(Es...).
§ 25.7.18.1 © ISO/IEC
1318

===== PAGE 1330 =====

Dxxxx
[Example 1:
vector<int> v1{1, 2, 3}, v2{4, 5}, v3{};
array a{6, 7, 8};
auto s = views::single(9);
for (auto&& i : views::concat(v1, v2, v3, a, s)) {
print("{} ", i); // prints1 2 3 4 5 6 7 8 9
}
—end example]
25.7.18.2 Class template concat_view [range.concat.view]
namespace std::ranges {
template<class... Rs>
using concat-reference-t = common_reference_t<range_reference_t<Rs>...>; // exposition only
template<class... Rs>
using concat-value-t = common_type_t<range_value_t<Rs>...>; // exposition only
template<class... Rs>
using concat-rvalue-reference-t = // exposition only
common_reference_t<range_rvalue_reference_t<Rs>...>;
template<class... Rs>
concept concat-indirectly-readable = see below ; // exposition only
template<class... Rs>
concept concatable = see below ; // exposition only
template<bool Const, class... Rs>
concept concat-is-random-access = see below ; // exposition only
template<bool Const, class... Rs>
concept concat-is-bidirectional = see below ; // exposition only
template<input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0) &&
concatable <Views...>
class concat_view : public view_interface<concat_view<Views...>> {
tuple<Views...> views_; // exposition only
// 25.7.18.3, class templateconcat_view::iterator
template<bool> class iterator; // exposition only
public:
constexpr concat_view() = default;
constexpr explicit concat_view(Views... views);
constexpr iterator <false> begin() requires (!(simple-view <Views> && ...));
constexpr iterator <true> begin() const
requires (range<const Views> && ...) && concatable <const Views...>;
constexpr auto end() requires (!(simple-view <Views> && ...));
constexpr auto end() const
requires (range<const Views> && ...) && concatable <const Views...>;
constexpr auto size() requires (sized_range<Views> && ...);
constexpr auto size() const requires (sized_range<const Views> && ...);
};
template<class... R>
concat_view(R&&...) -> concat_view<views::all_t<R>...>;
}
template<class... Rs>
concept concat-indirectly-readable = see below ; // exposition only
1 The exposition-onlyconcat-indirectly-readable concept is equivalent to:
§ 25.7.18.2 © ISO/IEC
1319

===== PAGE 1331 =====

Dxxxx
template<class Ref, class RRef, class It>
concept concat-indirectly-readable-impl = // exposition only
requires (const It it) {
{ *it } -> convertible_to<Ref>;
{ ranges::iter_move(it) } -> convertible_to<RRef>;
};
template<class... Rs>
concept concat-indirectly-readable = // exposition only
common_reference_with<concat-reference-t <Rs...>&&,
concat-value-t <Rs...>&> &&
common_reference_with<concat-reference-t <Rs...>&&,
concat-rvalue-reference-t <Rs...>&&> &&
common_reference_with<concat-rvalue-reference-t <Rs...>&&,
concat-value-t <Rs...> const&> &&
(concat-indirectly-readable-impl <concat-reference-t <Rs...>,
concat-rvalue-reference-t <Rs...>,
iterator_t<Rs>> && ...);
template<class... Rs>
concept concatable = see below ; // exposition only
2 The exposition-onlyconcatable concept is equivalent to:
template<class... Rs>
concept concatable = requires { // exposition only
typename concat-reference-t <Rs...>;
typename concat-value-t <Rs...>;
typename concat-rvalue-reference-t <Rs...>;
} && concat-indirectly-readable <Rs...>;
template<bool Const, class... Rs>
concept concat-is-random-access = see below ; // exposition only
3 Let Fs be the pack that consists of all elements ofRs except the last element, thenconcat-is-ran-
dom-access is equivalent to:
template<bool Const, class... Rs>
concept concat-is-random-access = // exposition only
all-random-access <Const, Rs...> &&
(common_range<maybe-const <Const, Fs>> && ...);
template<bool Const, class... Rs>
concept concat-is-bidirectional = see below ; // exposition only
4 Let Fs be the pack that consists of all elements ofRs except the last element, thenconcat-is-bidirec-
tional is equivalent to:
template<bool Const, class... Rs>
concept concat-is-bidirectional = // exposition only
all-bidirectional <Const, Rs...> &&
(common_range<maybe-const <Const, Fs>> && ...);
constexpr explicit concat_view(Views... views);
5 Effects: Initializes views_ with std::move(views)....
constexpr iterator <false> begin() requires (!(simple-view <Views> && ...));
constexpr iterator <true> begin() const
requires (range<const Views> && ...) && concatable <const Views...>;
6 Effects: Let is-const be true for the const-qualified overload, andfalse otherwise. Equivalent to:
iterator <is-const > it(this, in_place_index<0>, ranges::begin(std::get<0>(views_)));
it.template satisfy <0>();
return it;
constexpr auto end() requires (!(simple-view <Views> && ...));
§ 25.7.18.2 © ISO/IEC
1320

===== PAGE 1332 =====

Dxxxx
constexpr auto end() const
requires (range<const Views> && ...) && concatable <const Views...>;
7 Effects: Let is-const be true for the const-qualified overload, andfalse otherwise. Equivalent to:
constexpr auto N = sizeof...(Views);
if constexpr (all-forward <is-const , Views...> &&
common_range<maybe-const <is-const , Views...[N - 1]>>) {
return iterator <is-const >(this, in_place_index<N - 1>,
ranges::end(std::get<N - 1>(views_)));
} else {
return default_sentinel;
}
constexpr auto size() requires (sized_range<Views> && ...);
constexpr auto size() const requires (sized_range<const Views> && ...);
8 Effects: Equivalent to:
return apply(
[](auto... sizes) {
using CT = make-unsigned-like-t <common_type_t<decltype(sizes)...>>;
return (CT(sizes) + ...);
},
tuple-transform (ranges::size, views_));
25.7.18.3 Class concat_view::iterator [range.concat.iterator]
namespace std::ranges {
template<input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0) &&
concatable <Views...>
template<bool Const>
class concat_view<Views...>::iterator {
public:
using iterator_category = see below ; // not always present
using iterator_concept = see below ;
using value_type = concat-value-t <maybe-const <Const, Views>...>;
using difference_type = common_type_t<range_difference_t<maybe-const <Const, Views>>...>;
private:
using base-iter = // exposition only
variant<iterator_t<maybe-const <Const, Views>>...>;
maybe-const <Const, concat_view>* parent_ = nullptr; // exposition only
base-iter it_ ; // exposition only
template<size_t N>
constexpr void satisfy (); // exposition only
template<size_t N>
constexpr void prev (); // exposition only
template<size_t N>
constexpr void advance-fwd (difference_type offset, // exposition only
difference_type steps);
template<size_t N>
constexpr void advance-bwd (difference_type offset, // exposition only
difference_type steps);
template<class... Args>
constexpr explicit iterator (maybe-const <Const, concat_view>* parent, // exposition only
Args&&... args)
requires constructible_from<base-iter , Args&&...>;
public:
iterator () = default;
§ 25.7.18.3 © ISO/IEC
1321

===== PAGE 1333 =====

Dxxxx
constexpr iterator (iterator <!Const> i)
requires Const && (convertible_to<iterator_t<Views>, iterator_t<const Views>> && ...);
constexpr decltype(auto) operator*() const;
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int)
requires all-forward <Const, Views...>;
constexpr iterator & operator--()
requires concat-is-bidirectional <Const, Views...>;
constexpr iterator operator--(int)
requires concat-is-bidirectional <Const, Views...>;
constexpr iterator & operator+=(difference_type n)
requires concat-is-random-access <Const, Views...>;
constexpr iterator & operator-=(difference_type n)
requires concat-is-random-access <Const, Views...>;
constexpr decltype(auto) operator[](difference_type n) const
requires concat-is-random-access <Const, Views...>;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires (equality_comparable<iterator_t<maybe-const <Const, Views>>> && ...);
friend constexpr bool operator==(const iterator & it, default_sentinel_t);
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires (all-random-access <Const, Views...> &&
(three_way_comparable<iterator_t<maybe-const <Const, Views>>> && ...));
friend constexpr iterator operator+(const iterator & it, difference_type n)
requires concat-is-random-access <Const, Views...>;
friend constexpr iterator operator+(difference_type n, const iterator & it)
requires concat-is-random-access <Const, Views...>;
friend constexpr iterator operator-(const iterator & it, difference_type n)
requires concat-is-random-access <Const, Views...>;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires concat-is-random-access <Const, Views...>;
friend constexpr difference_type operator-(const iterator & x, default_sentinel_t)
requires see below ;
friend constexpr difference_type operator-(default_sentinel_t, const iterator & x)
requires see below ;
friend constexpr decltype(auto) iter_move(const iterator & it) noexcept(see below );
friend constexpr void iter_swap(const iterator & x, const iterator & y) noexcept(see below )
requires see below ;
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If concat-is-random-access <Const, Views...> is modeled, theniterator_concept denotes ran-
dom_access_iterator_tag.
—(1.2) Otherwise, if concat-is-bidirectional <Const, Views...> is modeled, then iterator_concept
denotes bidirectional_iterator_tag.
—(1.3) Otherwise, if all-forward <Const, Views...> is modeled, then iterator_concept denotes for-
ward_iterator_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
2 The membertypedef-name iterator_category is defined if and only ifall-forward <Const, Views...>
is modeled. In that case,iterator ::iterator_category is defined as follows:
§ 25.7.18.3 © ISO/IEC
1322

===== PAGE 1334 =====

Dxxxx
—(2.1) If is_reference_v<concat-reference-t <maybe-const <Const, Views>...>> is false, theniter-
ator_category denotes input_iterator_tag.
—(2.2) Otherwise, let Cs denote the pack of types iterator_traits<iterator_t<maybe-const <Const,
Views>>>::iterator_category....
—(2.2.1) If (derived_from<Cs, random_access_iterator_tag> && ...) && concat-is-random-ac-
cess <Const, Views...> is true, iterator_category denotes random_access_iterator_tag.
—(2.2.2) Otherwise, if (derived_from<Cs, bidirectional_iterator_tag> && ...) && concat-is-
bidirectional <Const, Views...> is true, iterator_category denotes bidirectional_iter-
ator_tag.
—(2.2.3) Otherwise, if (derived_from<Cs, forward_iterator_tag> && ...) is true, iterator_cate-
gory denotes forward_iterator_tag.
—(2.2.4) Otherwise, iterator_category denotes input_iterator_tag.
template<size_t N>
constexpr void satisfy ();
3 Effects: Equivalent to:
if constexpr (N < (sizeof...(Views) - 1)) {
if (std::get<N>(it_) == ranges::end(std::get<N>(parent_->views_))) {
it_.template emplace<N + 1>(ranges::begin(std::get<N + 1>(parent_->views_)));
satisfy <N + 1>();
}
}
template<size_t N>
constexpr void prev ();
4 Effects: Equivalent to:
if constexpr (N == 0) {
--std::get<0>(it_);
} else {
if (std::get<N>(it_) == ranges::begin(std::get<N>(parent_->views_))) {
it_.template emplace<N - 1>(ranges::end(std::get<N - 1>(parent_->views_)));
prev <N - 1>();
} else {
--std::get<N>(it_);
}
}
template<size_t N>
constexpr void advance-fwd (difference_type offset, difference_type steps);
5 Effects: Equivalent to:
using underlying_diff_type = iter_difference_t<variant_alternative_t<N, base-iter >>;
if constexpr (N == sizeof...(Views) - 1) {
std::get<N>(it_) += static_cast<underlying_diff_type>(steps);
} else {
auto n_size = ranges::distance(std::get<N>(parent_->views_));
if (offset + steps < n_size) {
std::get<N>(it_) += static_cast<underlying_diff_type>(steps);
} else {
it_.template emplace<N + 1>(ranges::begin(std::get<N + 1>(parent_->views_)));
advance-fwd <N + 1>(0, offset + steps - n_size);
}
}
template<size_t N>
constexpr void advance-bwd (difference_type offset, difference_type steps);
6 Effects: Equivalent to:
using underlying_diff_type = iter_difference_t<variant_alternative_t<N, base-iter >>;
§ 25.7.18.3 © ISO/IEC
1323

===== PAGE 1335 =====

Dxxxx
if constexpr (N == 0) {
std::get<N>(it_) -= static_cast<underlying_diff_type>(steps);
} else {
if (offset >= steps) {
std::get<N>(it_) -= static_cast<underlying_diff_type>(steps);
} else {
auto prev_size = ranges::distance(std::get<N - 1>(parent_->views_));
it_.template emplace<N - 1>(ranges::end(std::get<N - 1>(parent_->views_)));
advance-bwd <N - 1>(prev_size, steps - offset);
}
}
template<class... Args>
constexpr explicit iterator (maybe-const <Const, concat_view>* parent,
Args&&... args)
requires constructible_from<base-iter , Args&&...>;
7 Effects: Initializes parent_ with parent, and initializesit_ with std::forward<Args>(args)....
constexpr iterator (iterator <!Const> it)
requires Const &&
(convertible_to<iterator_t<Views>, iterator_t<const Views>> && ...);
8 Preconditions: it.it_.valueless_by_exception() is false.
9 Effects: Initializes parent_ with it.parent_, and let i be it.it_.index(), initializes it_ with
base-iter (in_place_index<i>, std::get<i>(std::move(it.it_))).
constexpr decltype(auto) operator*() const;
10 Preconditions: it_.valueless_by_exception() is false.
11 Effects: Equivalent to:
using reference = concat-reference-t <maybe-const <Const, Views>...>;
return std::visit([](auto&& it) -> reference { return *it; },
it_);
constexpr iterator & operator++();
12 Preconditions: it_.valueless_by_exception() is false.
13 Effects: Let i be it_.index(). Equivalent to:
++std::get<i>(it_);
satisfy <i>();
return *this;
constexpr void operator++(int);
14 Effects: Equivalent to:
++*this;
constexpr iterator operator++(int)
requires all-forward <Const, Views...>;
15 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--()
requires concat-is-bidirectional <Const, Views...>;
16 Preconditions: it_.valueless_by_exception() is false.
17 Effects: Let i be it_.index(). Equivalent to:
prev <i>();
return *this;
§ 25.7.18.3 © ISO/IEC
1324

===== PAGE 1336 =====

Dxxxx
constexpr iterator operator--(int)
requires concat-is-bidirectional <Const, Views...>;
18 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type n)
requires concat-is-random-access <Const, Views...>;
19 Preconditions: it_.valueless_by_exception() is false.
20 Effects: Let i be it_.index(). Equivalent to:
if (n > 0) {
advance-fwd <i>(std::get<i>(it_) - ranges::begin(std::get<i>(parent_->views_)), n);
} else if (n < 0) {
advance-bwd <i>(std::get<i>(it_) - ranges::begin(std::get<i>(parent_->views_)), -n);
}
return *this;
constexpr iterator & operator-=(difference_type n)
requires concat-is-random-access <Const, Views...>;
21 Effects: Equivalent to:
*this += -n;
return *this;
constexpr decltype(auto) operator[](difference_type n) const
requires concat-is-random-access <Const, Views...>;
22 Effects: Equivalent to:
return *((*this) + n);
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires (equality_comparable<iterator_t<maybe-const <Const, Views>>> && ...);
23 Preconditions: x.it_.valueless_by_exception() and y.it_.valueless_by_exception() are each
false.
24 Effects: Equivalent to:
return x.it_ == y.it_;
friend constexpr bool operator==(const iterator & it, default_sentinel_t);
25 Preconditions: it.it_.valueless_by_exception() is false.
26 Effects: Equivalent to:
constexpr auto last_idx = sizeof...(Views) - 1;
return it.it_.index() == last_idx &&
std::get<last_idx>(it.it_) == ranges::end(std::get<last_idx>(it.parent_->views_));
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires (all-random-access <Const, Views...> &&
(three_way_comparable<iterator_t<maybe-const <Const, Views>>> && ...));
27 Preconditions: x.it_.valueless_by_exception() and y.it_.valueless_by_exception() are each
false.
28 Let op be the operator.
§ 25.7.18.3 © ISO/IEC
1325

===== PAGE 1337 =====

Dxxxx
29 Effects: Equivalent to:
return x.it_ op y.it_;
friend constexpr iterator operator+(const iterator & it, difference_type n)
requires concat-is-random-access <Const, Views...>;
30 Effects: Equivalent to:
auto temp = it;
temp += n;
return temp;
friend constexpr iterator operator+(difference_type n, const iterator & it)
requires concat-is-random-access <Const, Views...>;
31 Effects: Equivalent to:
return it + n;
friend constexpr iterator operator-(const iterator & it, difference_type n)
requires concat-is-random-access <Const, Views...>;
32 Effects: Equivalent to:
auto temp = it;
temp -= n;
return temp;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires concat-is-random-access <Const, Views...>;
33 Preconditions: x.it_.valueless_by_exception() and y.it_.valueless_by_exception() are each
false.
34 Effects: Let ix denote x.it_.index() and iy denote y.it_.index().
—(34.1) If ix > iy, letdy be ranges::distance(std::get<iy>(y.it_), ranges::end(std::get<iy>(y.
parent_->views_))), dx be ranges::distance(ranges::begin(std::get<ix>(x.parent_->
views_)), std::get<ix>(x.it_)). Letsdenote the sum of the sizes of all the rangesstd::get<
i>(x.parent_->views_) for every integeriin the range[iy + 1,ix) if there is any, and0 otherwise,
of typedifference_type, equivalent to:
return dy + s + dx;
—(34.2) otherwise, ifix < iy is true, equivalent to:
return -(y - x);
—(34.3) otherwise, equivalent to:
return std::get<ix>(x.it_) - std::get<iy>(y.it_);
friend constexpr difference_type operator-(const iterator & x, default_sentinel_t)
requires see below ;
35 Preconditions: x.it_.valueless_by_exception() is false.
36 Effects: Let ix denote x.it_.index(), dx be ranges::distance(std::get<ix>(x.it_), ranges::
end(std::get<ix>(x.parent_->views_))). Let s denote the sum of the sizes of all the ranges
std::get<i>(x.parent_->views_) for every integer i in the range [ix + 1,sizeof...(Views)) if
there is any, and0 otherwise, of type difference_type, equivalent to:
return -(dx + s);
37 Remarks: Let Fs be the pack that consists of all elements ofViews except the first element, the
expression in therequires-clause is equivalent to:
(sized_sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <Const, Views>>> && ...) &&
(sized_range<maybe-const <Const, Fs>> && ...)
friend constexpr difference_type operator-(default_sentinel_t, const iterator & x)
requires see below ;
38 Effects: Equivalent to:
§ 25.7.18.3 © ISO/IEC
1326

===== PAGE 1338 =====

Dxxxx
return -(x - default_sentinel);
39 Remarks: Let Fs be the pack that consists of all elements ofViews except the first element, the
expression in therequires-clause is equivalent to:
(sized_sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <Const, Views>>> && ...) &&
(sized_range<maybe-const <Const, Fs>> && ...)
friend constexpr decltype(auto) iter_move(const iterator & it) noexcept(see below );
40 Preconditions: it.it_.valueless_by_exception() is false.
41 Effects: Equivalent to:
return std::visit([](const auto& i)
-> concat-rvalue-reference-t <maybe-const <Const, Views>...> {
return ranges::iter_move(i);
},
it.it_);
42 Remarks: The exception specification is equivalent to:
((is_nothrow_invocable_v<decltype(ranges::iter_move),
const iterator_t<maybe-const <Const, Views>>&> &&
is_nothrow_convertible_v<range_rvalue_reference_t<maybe-const <Const, Views>>,
concat-rvalue-reference-t <maybe-const <Const, Views>...>>) &&
...)
friend constexpr void iter_swap(const iterator & x, const iterator & y) noexcept(see below )
requires see below ;
43 Preconditions: x.it_.valueless_by_exception() and y.it_.valueless_by_exception() are each
false.
44 Effects: Equivalent to:
std::visit([&](const auto& it1, const auto& it2) {
if constexpr (is_same_v<decltype(it1), decltype(it2)>) {
ranges::iter_swap(it1, it2);
} else {
ranges::swap(*x, *y);
}
},
x.it_, y.it_);
45 Remarks: The exception specification is equivalent to
(noexcept(ranges::swap(*x, *y)) && ... && noexcept(ranges::iter_swap(its, its)))
where its is a pack of lvalues of typeconst iterator_t<maybe-const <Const, Views>> respectively.
The expression in therequires-clause is equivalent to
swappable_with<iter_reference_t<iterator >, iter_reference_t<iterator >> &&
(... && indirectly_swappable<iterator_t<maybe-const <Const, Views>>>)
25.7.19 Counted view [range.counted]
1 A counted view presents a view of the elements of the counted range (24.3.1)i+ [0, n) for an iteratori and
non-negative integern.
2 The nameviews::counted denotes a customization point object (16.3.3.3.5). LetE and F be expressions, let
T be decay_t<decltype((E))>, and letD be iter_difference_t<T>. If decltype((F)) does not model
convertible_to<D>, views::counted(E, F) is ill-formed.
[Note 1: This case can result in substitution failure whenviews::counted(E, F) appears in the immediate context
of a template instantiation.—end note]
Otherwise, views::counted(E, F) is expression-equivalent to:
—(2.1) If T models contiguous_iterator, then span(to_address(E), static_cast<size_t>(static_-
cast<D>(F))).
§ 25.7.19 © ISO/IEC
1327

===== PAGE 1339 =====

Dxxxx
—(2.2) Otherwise, ifT models random_access_iterator, thensubrange(E, E + static_cast<D>(F)), ex-
cept thatE is evaluated only once.
—(2.3) Otherwise, subrange(counted_iterator(E, F), default_sentinel).
25.7.20 Common view [range.common]
25.7.20.1 Overview [range.common.overview]
1 common_view takes a view which has different types for its iterator and sentinel and turns it into a view of
the same elements with an iterator and sentinel of the same type.
2 [Note 1: common_view is useful for calling legacy algorithms that expect a range’s iterator and sentinel types to be
the same. —end note]
3 The nameviews::common denotes a range adaptor object (25.7.2). Given a subexpressionE, the expression
views::common(E) is expression-equivalent to:
—(3.1) views::all(E), ifdecltype((E)) models common_range and views::all(E) is a well-formed expres-
sion.
—(3.2) Otherwise, common_view{E}.
4 [Example 1:
// Legacy algorithm:
template<class ForwardIterator>
size_t count(ForwardIterator first, ForwardIterator last);
template<forward_range R>
void my_algo(R&& r) {
auto&& common = views::common(r);
auto cnt = count(common.begin(), common.end());
// ...
}
—end example]
25.7.20.2 Class template common_view [range.common.view]
namespace std::ranges {
template<view V>
requires (!common_range<V> && copyable<iterator_t<V>>)
class common_view : public view_interface<common_view<V>> {
private:
V base_ = V(); // exposition only
public:
common_view() requires default_initializable<V> = default;
constexpr explicit common_view(V r);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>) {
if constexpr (random_access_range<V> && sized_range<V>)
return ranges::begin(base_);
else
return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::begin(base_));
}
constexpr auto begin() const requires range<const V> {
if constexpr (random_access_range<const V> && sized_range<const V>)
return ranges::begin(base_);
else
return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::begin(base_));
}
§ 25.7.20.2 © ISO/IEC
1328

===== PAGE 1340 =====

Dxxxx
constexpr auto end() requires (!simple-view <V>) {
if constexpr (random_access_range<V> && sized_range<V>)
return ranges::begin(base_) + ranges::distance(base_);
else
return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::end(base_));
}
constexpr auto end() const requires range<const V> {
if constexpr (random_access_range<const V> && sized_range<const V>)
return ranges::begin(base_) + ranges::distance(base_);
else
return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::end(base_));
}
constexpr auto size() requires sized_range<V> {
return ranges::size(base_);
}
constexpr auto size() const requires sized_range<const V> {
return ranges::size(base_);
}
constexpr auto reserve_hint() requires approximately_sized_range<V> {
return ranges::reserve_hint(base_);
}
constexpr auto reserve_hint() const requires approximately_sized_range<const V> {
return ranges::reserve_hint(base_);
}
};
template<class R>
common_view(R&&) -> common_view<views::all_t<R>>;
}
constexpr explicit common_view(V base);
1 Effects: Initializes base_ with std::move(base).
25.7.21 Reverse view [range.reverse]
25.7.21.1 Overview [range.reverse.overview]
1 reverse_view takes a bidirectional view and produces another view that iterates the same elements in
reverse order.
2 The nameviews::reverse denotes a range adaptor object (25.7.2). Given a subexpressionE, the expression
views::reverse(E) is expression-equivalent to:
—(2.1) If the type ofE is a (possibly cv-qualified) specialization ofreverse_view, thenE.base().
—(2.2) Otherwise, ifE is a specialization ofoptional and E models view, thendecay-copy(E).
—(2.3) Otherwise, if the type ofE is cv subrange<reverse_iterator<I>, reverse_iterator<I>, K> for
some iterator typeI and valueK of typesubrange_kind,
—(2.3.1) if Kissubrange_kind::sized, thensubrange<I, I, K>(E.end().base(), E.begin().base(),
E.size());
—(2.3.2) otherwise, subrange<I, I, K>(E.end().base(), E.begin().base()).
However, in either caseE is evaluated only once.
—(2.4) Otherwise, reverse_view{E}.
3 [Example 1:
vector<int> is {0,1,2,3,4};
for (int i : is | views::reverse)
cout << i << ' '; // prints4 3 2 1 0
—end example]
§ 25.7.21.1 © ISO/IEC
1329

===== PAGE 1341 =====

Dxxxx
25.7.21.2 Class template reverse_view [range.reverse.view]
namespace std::ranges {
template<view V>
requires bidirectional_range<V>
class reverse_view : public view_interface<reverse_view<V>> {
private:
V base_ = V(); // exposition only
public:
reverse_view() requires default_initializable<V> = default;
constexpr explicit reverse_view(V r);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr reverse_iterator<iterator_t<V>> begin();
constexpr reverse_iterator<iterator_t<V>> begin() requires common_range<V>;
constexpr auto begin() const requires common_range<const V>;
constexpr reverse_iterator<iterator_t<V>> end();
constexpr auto end() const requires common_range<const V>;
constexpr auto size() requires sized_range<V> {
return ranges::size(base_);
}
constexpr auto size() const requires sized_range<const V> {
return ranges::size(base_);
}
constexpr auto reserve_hint() requires approximately_sized_range<V> {
return ranges::reserve_hint(base_);
}
constexpr auto reserve_hint() const requires approximately_sized_range<const V> {
return ranges::reserve_hint(base_);
}
};
template<class R>
reverse_view(R&&) -> reverse_view<views::all_t<R>>;
}
constexpr explicit reverse_view(V base);
1 Effects: Initializes base_ with std::move(base).
constexpr reverse_iterator<iterator_t<V>> begin();
2 Returns:
make_reverse_iterator(ranges::next(ranges::begin(base_), ranges::end(base_)))
3 Remarks: In order to provide the amortized constant time complexity required by therange concept,
this function caches the result within thereverse_view for use on subsequent calls.
constexpr reverse_iterator<iterator_t<V>> begin() requires common_range<V>;
constexpr auto begin() const requires common_range<const V>;
4 Effects: Equivalent to:return make_reverse_iterator(ranges::end(base_));
constexpr reverse_iterator<iterator_t<V>> end();
constexpr auto end() const requires common_range<const V>;
5 Effects: Equivalent to:return make_reverse_iterator(ranges::begin(base_));
§ 25.7.21.2 © ISO/IEC
1330

===== PAGE 1342 =====

Dxxxx
25.7.22 As const view [range.as.const]
25.7.22.1 Overview [range.as.const.overview]
1 as_const_view presents a view of an underlying sequence as constant. That is, the elements of anas_-
const_view cannot be modified.
2 The name views::as_const denotes a range adaptor object (25.7.2). LetE be an expression, letT be
decltype((E)), and let U be remove_cvref_t<T>. The expression views::as_const(E) is expression-
equivalent to:
—(2.1) If views::all_t<T> models constant_range, thenviews::all(E).
—(2.2) Otherwise, ifU denotes empty_view<X> for some typeX, thenauto(views::empty<const X>).
—(2.3) Otherwise, ifU denotes optional<X&> for some typeX, thenoptional<const X&>(E).
—(2.4) Otherwise, if U denotes span<X, Extent> for some typeX and some extentExtent, thenspan<const
X, Extent>(E).
—(2.5) Otherwise, if U denotes ref_view<X> for some typeX and const X models constant_range, then
ref_view(static_cast<const X&>(E.base())).
—(2.6) Otherwise, if E is an lvalue, const U models constant_range, and U does not model view, then
ref_view(static_cast<const U&>(E)).
—(2.7) Otherwise, as_const_view(E).
3 [Example 1:
template<constant_range R>
void cant_touch_this(R&&);
vector<char> hammer = {'m', 'c'};
span<char> beat = hammer;
cant_touch_this(views::as_const(beat)); // will not modify the elements ofhammer
—end example]
25.7.22.2 Class template as_const_view [range.as.const.view]
namespace std::ranges {
template<view V>
requires input_range<V>
class as_const_view : public view_interface<as_const_view<V>> {
V base_ = V(); // exposition only
public:
as_const_view() requires default_initializable<V> = default;
constexpr explicit as_const_view(V base);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>) { return ranges::cbegin(base_); }
constexpr auto begin() const requires range<const V> { return ranges::cbegin(base_); }
constexpr auto end() requires (!simple-view <V>) { return ranges::cend(base_); }
constexpr auto end() const requires range<const V> { return ranges::cend(base_); }
constexpr auto size() requires sized_range<V> { return ranges::size(base_); }
constexpr auto size() const requires sized_range<const V> { return ranges::size(base_); }
constexpr auto reserve_hint() requires approximately_sized_range<V>
{ return ranges::reserve_hint(base_); }
constexpr auto reserve_hint() const requires approximately_sized_range<const V>
{ return ranges::reserve_hint(base_); }
};
§ 25.7.22.2 © ISO/IEC
1331

===== PAGE 1343 =====

Dxxxx
template<class R>
as_const_view(R&&) -> as_const_view<views::all_t<R>>;
}
constexpr explicit as_const_view(V base);
1 Effects: Initializes base_ with std::move(base).
25.7.23 Elements view [range.elements]
25.7.23.1 Overview [range.elements.overview]
1 elements_view takes a view of tuple-like values and asize_t, and produces a view with a value-type of the
Nth element of the adapted view’s value-type.
2 The name views::elements<N> denotes a range adaptor object (25.7.2). Given a subexpressionE and
constant expression N, the expression views::elements<N>(E) is expression-equivalent to elements_-
view<views::all_t<decltype((E))>, N>{E}.
[Example 1:
auto historical_figures = map{
pair{"Lovelace"sv, 1815},
{"Turing"sv, 1912},
{"Babbage"sv, 1791},
{"Hamilton"sv, 1936}
};
auto names = historical_figures | views::elements<0>;
for (auto&& name : names) {
cout << name << ' '; // printsBabbage Hamilton Lovelace Turing
}
auto birth_years = historical_figures | views::elements<1>;
for (auto&& born : birth_years) {
cout << born << ' '; // prints1791 1936 1815 1912
}
—end example]
3 keys_view is an alias forelements_view<R, 0>, and is useful for extracting keys from associative containers.
[Example 2:
auto names = historical_figures | views::keys;
for (auto&& name : names) {
cout << name << ' '; // printsBabbage Hamilton Lovelace Turing
}
—end example]
4 values_view is an alias forelements_view<R, 1>, and is useful for extracting values from associative
containers.
[Example 3:
auto is_even = [](const auto x) { return x % 2 == 0; };
cout << ranges::count_if(historical_figures | views::values, is_even); // prints2
—end example]
25.7.23.2 Class template elements_view [range.elements.view]
namespace std::ranges {
template<class T, size_t N>
concept has-tuple-element = // exposition only
tuple-like <T> && N < tuple_size_v<T>;
template<class T, size_t N>
concept returnable-element = // exposition only
is_reference_v<T> || move_constructible<tuple_element_t<N, T>>;
§ 25.7.23.2 © ISO/IEC
1332

===== PAGE 1344 =====

Dxxxx
template<input_range V, size_t N>
requires view<V> && has-tuple-element <range_value_t<V>, N> &&
has-tuple-element <remove_reference_t<range_reference_t<V>>, N> &&
returnable-element <range_reference_t<V>, N>
class elements_view : public view_interface<elements_view<V, N>> {
public:
elements_view() requires default_initializable<V> = default;
constexpr explicit elements_view(V base);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>)
{ return iterator <false>(ranges::begin(base_)); }
constexpr auto begin() const requires range<const V>
{ return iterator <true>(ranges::begin(base_)); }
constexpr auto end() requires (!simple-view <V> && !common_range<V>)
{ return sentinel <false>{ranges::end(base_)}; }
constexpr auto end() requires (!simple-view <V> && common_range<V>)
{ return iterator <false>{ranges::end(base_)}; }
constexpr auto end() const requires range<const V>
{ return sentinel <true>{ranges::end(base_)}; }
constexpr auto end() const requires common_range<const V>
{ return iterator <true>{ranges::end(base_)}; }
constexpr auto size() requires sized_range<V>
{ return ranges::size(base_); }
constexpr auto size() const requires sized_range<const V>
{ return ranges::size(base_); }
constexpr auto reserve_hint() requires approximately_sized_range<V>
{ return ranges::reserve_hint(base_); }
constexpr auto reserve_hint() const requires approximately_sized_range<const V>
{ return ranges::reserve_hint(base_); }
private:
// 25.7.23.3, class templateelements_view::iterator
template<bool> class iterator ; // exposition only
// 25.7.23.4, class templateelements_view::sentinel
template<bool> class sentinel ; // exposition only
V base_ = V(); // exposition only
};
}
constexpr explicit elements_view(V base);
1 Effects: Initializes base_ with std::move(base).
25.7.23.3 Class template elements_view::iterator [range.elements.iterator]
namespace std::ranges {
template<input_range V, size_t N>
requires view<V> && has-tuple-element <range_value_t<V>, N> &&
has-tuple-element <remove_reference_t<range_reference_t<V>>, N> &&
returnable-element <range_reference_t<V>, N>
template<bool Const>
§ 25.7.23.3 © ISO/IEC
1333

===== PAGE 1345 =====

Dxxxx
class elements_view<V, N>::iterator {
using Base = maybe-const <Const, V>; // exposition only
iterator_t<Base > current_ = iterator_t<Base >(); // exposition only
static constexpr decltype(auto) get-element (const iterator_t<Base >& i); // exposition only
public:
using iterator_concept = see below ;
using iterator_category = see below ; // not always present
using value_type = remove_cvref_t<tuple_element_t<N, range_value_t<Base >>>;
using difference_type = range_difference_t<Base >;
iterator () requires default_initializable<iterator_t<Base >> = default;
constexpr explicit iterator (iterator_t<Base > current);
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
constexpr const iterator_t<Base >& base() const & noexcept;
constexpr iterator_t<Base > base() &&;
constexpr decltype(auto) operator*() const
{ return get-element (current_); }
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires forward_range<Base >;
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
constexpr decltype(auto) operator[](difference_type n) const
requires random_access_range<Base >
{ return get-element (current_ + n); }
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<Base >>;
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<iterator_t<Base >>;
friend constexpr iterator operator+(const iterator & x, difference_type y)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type x, const iterator & y)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & x, difference_type y)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
};
}
§ 25.7.23.3 © ISO/IEC
1334

===== PAGE 1346 =====

Dxxxx
1 The membertypedef-name iterator_concept is defined as follows:
—(1.1) If Base models random_access_range, theniterator_concept denotes random_access_iterator_-
tag.
—(1.2) Otherwise, ifBase models bidirectional_range, theniterator_concept denotes bidirectional_-
iterator_tag.
—(1.3) Otherwise, if Base models forward_range, theniterator_concept denotes forward_iterator_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
2 The membertypedef-name iterator_category is defined if and only ifBase models forward_range. In
that case,iterator_category is defined as follows: LetC denote the typeiterator_traits<iterator_-
t<Base >>::iterator_category.
—(2.1) If std::get<N>(*current_) is an rvalue,iterator_category denotes input_iterator_tag.
—(2.2) Otherwise, ifC models derived_from<random_access_iterator_tag>, iterator_category denotes
random_access_iterator_tag.
—(2.3) Otherwise, iterator_category denotes C.
static constexpr decltype(auto) get-element (const iterator_t<Base >& i);
3 Effects: Equivalent to:
if constexpr (is_reference_v<range_reference_t<Base >>) {
return std::get<N>(*i);
} else {
using E = remove_cv_t<tuple_element_t<N, range_reference_t<Base >>>;
return static_cast<E>(std::get<N>(*i));
}
constexpr explicit iterator (iterator_t<Base > current);
4 Effects: Initializes current_ with std::move(current).
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
5 Effects: Initializes current_ with std::move(i.current_).
constexpr const iterator_t<Base >& base() const & noexcept;
6 Effects: Equivalent to:return current_;
constexpr iterator_t<Base > base() &&;
7 Effects: Equivalent to:return std::move(current_);
constexpr iterator & operator++();
8 Effects: Equivalent to:
++current_;
return *this;
constexpr void operator++(int);
9 Effects: Equivalent to:++current_.
constexpr iterator operator++(int) requires forward_range<Base >;
10 Effects: Equivalent to:
auto temp = *this;
++current_;
return temp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
11 Effects: Equivalent to:
--current_;
return *this;
§ 25.7.23.3 © ISO/IEC
1335

===== PAGE 1347 =====

Dxxxx
constexpr iterator operator--(int) requires bidirectional_range<Base >;
12 Effects: Equivalent to:
auto temp = *this;
--current_;
return temp;
constexpr iterator & operator+=(difference_type n)
requires random_access_range<Base >;
13 Effects: Equivalent to:
current_ += n;
return *this;
constexpr iterator & operator-=(difference_type n)
requires random_access_range<Base >;
14 Effects: Equivalent to:
current_ -= n;
return *this;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<Base >;
15 Effects: Equivalent to:return x.current_ == y.current_;
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
16 Effects: Equivalent to:return x.current_ < y.current_;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
17 Effects: Equivalent to:return y < x;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
18 Effects: Equivalent to:return !(y < x);
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
19 Effects: Equivalent to:return !(x < y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<iterator_t<Base >>;
20 Effects: Equivalent to:return x.current_ <=> y.current_;
friend constexpr iterator operator+(const iterator & x, difference_type y)
requires random_access_range<Base >;
21 Effects: Equivalent to:return iterator {x} += y;
friend constexpr iterator operator+(difference_type x, const iterator & y)
requires random_access_range<Base >;
22 Effects: Equivalent to:return y + x;
friend constexpr iterator operator-(const iterator & x, difference_type y)
requires random_access_range<Base >;
23 Effects: Equivalent to:return iterator {x} -= y;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
24 Effects: Equivalent to:return x.current_ - y.current_;
§ 25.7.23.3 © ISO/IEC
1336

===== PAGE 1348 =====

Dxxxx
25.7.23.4 Class template elements_view::sentinel [range.elements.sentinel]
namespace std::ranges {
template<input_range V, size_t N>
requires view<V> && has-tuple-element <range_value_t<V>, N> &&
has-tuple-element <remove_reference_t<range_reference_t<V>>, N> &&
returnable-element <range_reference_t<V>, N>
template<bool Const>
class elements_view<V, N>::sentinel {
private:
using Base = maybe-const <Const, V>; // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
public:
sentinel () = default;
constexpr explicit sentinel (sentinel_t<Base > end);
constexpr sentinel (sentinel <!Const> other)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
constexpr sentinel_t<Base > base() const;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & x, const iterator <OtherConst>& y);
};
}
constexpr explicit sentinel (sentinel_t<Base > end);
1 Effects: Initializes end_ with end.
constexpr sentinel (sentinel <!Const> other)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(other.end_).
constexpr sentinel_t<Base > base() const;
3 Effects: Equivalent to:return end_;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
4 Effects: Equivalent to:return x.current_ == y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
5 Effects: Equivalent to:return x.current_ - y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & x, const iterator <OtherConst>& y);
6 Effects: Equivalent to:return x.end_ - y.current_;
§ 25.7.23.4 © ISO/IEC
1337

===== PAGE 1349 =====

Dxxxx
25.7.24 Enumerate view [range.enumerate]
25.7.24.1 Overview [range.enumerate.overview]
1 enumerate_view is a view whose elements represent both the position and value from a sequence of elements.
2 The nameviews::enumeratedenotes a range adaptor object (25.7.2). Given a subexpressionE, the expression
views::enumerate(E) is expression-equivalent toenumerate_view<views::all_t<decltype((E))>>(E).
[Example 1:
vector<int> vec{ 1, 2, 3 };
for (auto [index, value] : views::enumerate(vec))
cout << index << ":" << value << ' '; // prints0:1 1:2 2:3
—end example]
25.7.24.2 Class template enumerate_view [range.enumerate.view]
namespace std::ranges {
template<view V>
requires range-with-movable-references <V>
class enumerate_view : public view_interface<enumerate_view<V>> {
V base_ = V(); // exposition only
// 25.7.24.3, class templateenumerate_view::iterator
template<bool Const>
class iterator; // exposition only
// 25.7.24.4, class templateenumerate_view::sentinel
template<bool Const>
class sentinel; // exposition only
public:
constexpr enumerate_view() requires default_initializable<V> = default;
constexpr explicit enumerate_view(V base);
constexpr auto begin() requires (!simple-view <V>)
{ return iterator <false>(ranges::begin(base_), 0); }
constexpr auto begin() const requires range-with-movable-references <const V>
{ return iterator <true>(ranges::begin(base_), 0); }
constexpr auto end() requires (!simple-view <V>) {
if constexpr (forward_range<V> && common_range<V> && sized_range<V>)
return iterator <false>(ranges::end(base_), ranges::distance(base_));
else
return sentinel <false>(ranges::end(base_));
}
constexpr auto end() const requires range-with-movable-references <const V> {
if constexpr (forward_range<const V> && common_range<const V> && sized_range<const V>)
return iterator <true>(ranges::end(base_), ranges::distance(base_));
else
return sentinel <true>(ranges::end(base_));
}
constexpr auto size() requires sized_range<V>
{ return ranges::size(base_); }
constexpr auto size() const requires sized_range<const V>
{ return ranges::size(base_); }
constexpr auto reserve_hint() requires approximately_sized_range<V>
{ return ranges::reserve_hint(base_); }
constexpr auto reserve_hint() const requires approximately_sized_range<const V>
{ return ranges::reserve_hint(base_); }
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
};
§ 25.7.24.2 © ISO/IEC
1338

===== PAGE 1350 =====

Dxxxx
template<class R>
enumerate_view(R&&) -> enumerate_view<views::all_t<R>>;
}
constexpr explicit enumerate_view(V base);
1 Effects: Initializes base_ with std::move(base).
25.7.24.3 Class template enumerate_view::iterator [range.enumerate.iterator]
namespace std::ranges {
template<view V>
requires range-with-movable-references <V>
template<bool Const>
class enumerate_view<V>::iterator {
using Base = maybe-const<Const, V>; // exposition only
public:
using iterator_category = input_iterator_tag;
using iterator_concept = see below ;
using difference_type = range_difference_t<Base >;
using value_type = tuple<difference_type, range_value_t<Base >>;
private:
using reference-type = // exposition only
tuple<difference_type, range_reference_t<Base >>;
iterator_t<Base> current_ = iterator_t<Base>(); // exposition only
difference_type pos_ = 0; // exposition only
constexpr explicit
iterator(iterator_t<Base> current, difference_type pos); // exposition only
public:
iterator () requires default_initializable<iterator_t<Base >> = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
constexpr const iterator_t<Base >& base() const & noexcept;
constexpr iterator_t<Base > base() &&;
constexpr difference_type index() const noexcept;
constexpr auto operator*() const {
return reference-type (pos_, *current_);
}
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires forward_range<Base >;
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
constexpr auto operator[](difference_type n) const
requires random_access_range<Base >
{ return reference-type (pos_ + n, current_[n]); }
friend constexpr bool operator==(const iterator & x, const iterator & y) noexcept;
friend constexpr strong_ordering operator<=>(const iterator & x, const iterator & y) noexcept;
§ 25.7.24.3 © ISO/IEC
1339

===== PAGE 1351 =====

Dxxxx
friend constexpr iterator operator+(const iterator & x, difference_type y)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type x, const iterator & y)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & x, difference_type y)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y) noexcept;
friend constexpr auto iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)) &&
is_nothrow_move_constructible_v<range_rvalue_reference_t<Base >>) {
return tuple<difference_type,
range_rvalue_reference_t<Base >>(i.pos_, ranges::iter_move(i.current_));
}
};
}
1 The membertypedef-name iterator ::iterator_concept is defined as follows:
—(1.1) If Base models random_access_range, theniterator_concept denotes random_access_iterator_-
tag.
—(1.2) Otherwise, ifBase models bidirectional_range, theniterator_concept denotes bidirectional_-
iterator_tag.
—(1.3) Otherwise, if Base models forward_range, theniterator_concept denotes forward_iterator_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
constexpr explicit iterator (iterator_t<Base > current, difference_type pos);
2 Effects: Initializes current_ with std::move(current) and pos_ with pos.
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
3 Effects: Initializes current_ with std::move(i.current_) and pos_ with i.pos_.
constexpr const iterator_t<Base >& base() const & noexcept;
4 Effects: Equivalent to:return current_;
constexpr iterator_t<Base > base() &&;
5 Effects: Equivalent to:return std::move(current_);
constexpr difference_type index() const noexcept;
6 Effects: Equivalent to:return pos_;
constexpr iterator & operator++();
7 Effects: Equivalent to:
++current_;
++pos_;
return *this;
constexpr void operator++(int);
8 Effects: Equivalent to++*this.
constexpr iterator operator++(int) requires forward_range<Base >;
9 Effects: Equivalent to:
auto temp = *this;
++*this;
return temp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
10 Effects: Equivalent to:
--current_;
§ 25.7.24.3 © ISO/IEC
1340

===== PAGE 1352 =====

Dxxxx
--pos_;
return *this;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
11 Effects: Equivalent to:
auto temp = *this;
--*this;
return temp;
constexpr iterator & operator+=(difference_type n)
requires random_access_range<Base >;
12 Effects: Equivalent to:
current_ += n;
pos_ += n;
return *this;
constexpr iterator & operator-=(difference_type n)
requires random_access_range<Base >;
13 Effects: Equivalent to:
current_ -= n;
pos_ -= n;
return *this;
friend constexpr bool operator==(const iterator & x, const iterator & y) noexcept;
14 Effects: Equivalent to:return x.pos_ == y.pos_;
friend constexpr strong_ordering operator<=>(const iterator & x, const iterator & y) noexcept;
15 Effects: Equivalent to:return x.pos_ <=> y.pos_;
friend constexpr iterator operator+(const iterator & x, difference_type y)
requires random_access_range<Base >;
16 Effects: Equivalent to:
auto temp = x;
temp += y;
return temp;
friend constexpr iterator operator+(difference_type x, const iterator & y)
requires random_access_range<Base >;
17 Effects: Equivalent to:return y + x;
friend constexpr iterator operator-(const iterator & x, difference_type y)
requires random_access_range<Base >;
18 Effects: Equivalent to:
auto temp = x;
temp -= y;
return temp;
friend constexpr difference_type operator-(const iterator & x, const iterator & y) noexcept;
19 Effects: Equivalent to:return x.pos_ - y.pos_;
25.7.24.4 Class template enumerate_view::sentinel [range.enumerate.sentinel]
namespace std::ranges {
template<view V>
requires range-with-movable-references <V>
template<bool Const>
class enumerate_view<V>::sentinel {
using Base = maybe-const<Const, V>; // exposition only
sentinel_t<Base> end_ = sentinel_t<Base>(); // exposition only
constexpr explicit sentinel(sentinel_t<Base> end); // exposition only
§ 25.7.24.4 © ISO/IEC
1341

===== PAGE 1353 =====

Dxxxx
public:
sentinel () = default;
constexpr sentinel (sentinel <!Const> other)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
constexpr sentinel_t<Base > base() const;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & x, const iterator <OtherConst>& y);
};
}
constexpr explicit sentinel (sentinel_t<Base > end);
1 Effects: Initializes end_ with std::move(end).
constexpr sentinel (sentinel <!Const> other)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(other.end_).
constexpr sentinel_t<Base > base() const;
3 Effects: Equivalent to:return end_;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
4 Effects: Equivalent to:return x.current_ == y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
5 Effects: Equivalent to:return x.current_ - y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & x, const iterator <OtherConst>& y);
6 Effects: Equivalent to:return x.end_ - y.current_;
25.7.25 Zip view [range.zip]
25.7.25.1 Overview [range.zip.overview]
1 zip_view takes any number of views and produces a view of tuples of references to the corresponding elements
of the constituent views.
2 The nameviews::zip denotes a customization point object (16.3.3.3.5). Given a pack of subexpressions
Es..., the expressionviews::zip(Es...) is expression-equivalent to
—(2.1) auto(views::empty<tuple<>>) if Es is an empty pack,
—(2.2) otherwise, zip_view<views::all_t<decltype((Es))>...>(Es...).
§ 25.7.25.1 © ISO/IEC
1342

===== PAGE 1354 =====

Dxxxx
[Example 1:
vector v = {1, 2};
list l = {'a', 'b', 'c'};
auto z = views::zip(v, l);
range_reference_t<decltype(z)> f = z.front(); // f is atuple<int&, char&>
// that refers to the first element ofv and l
for (auto&& [x, y] : z) {
cout << '(' << x << ", " << y << ") "; // prints(1, a) (2, b)
}
—end example]
25.7.25.2 Class template zip_view [range.zip.view]
namespace std::ranges {
template<class... Rs>
concept zip-is-common = // exposition only
(sizeof...(Rs) == 1 && (common_range<Rs> && ...)) ||
(!(bidirectional_range<Rs> && ...) && (common_range<Rs> && ...)) ||
((random_access_range<Rs> && ...) && (sized_range<Rs> && ...));
template<input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0)
class zip_view : public view_interface<zip_view<Views...>> {
tuple<Views...> views_; // exposition only
// 25.7.25.3, class templatezip_view::iterator
template<bool> class iterator; // exposition only
// 25.7.25.4, class templatezip_view::sentinel
template<bool> class sentinel; // exposition only
public:
zip_view() = default;
constexpr explicit zip_view(Views... views);
constexpr auto begin() requires (!(simple-view <Views> && ...)) {
return iterator <false>(tuple-transform (ranges::begin, views_));
}
constexpr auto begin() const requires (range<const Views> && ...) {
return iterator <true>(tuple-transform (ranges::begin, views_));
}
constexpr auto end() requires (!(simple-view <Views> && ...)) {
if constexpr (!zip-is-common <Views...>) {
return sentinel <false>(tuple-transform (ranges::end, views_));
} else if constexpr ((random_access_range<Views> && ...)) {
return begin() + iter_difference_t<iterator <false>>(size());
} else {
return iterator <false>(tuple-transform (ranges::end, views_));
}
}
constexpr auto end() const requires (range<const Views> && ...) {
if constexpr (!zip-is-common <const Views...>) {
return sentinel <true>(tuple-transform (ranges::end, views_));
} else if constexpr ((random_access_range<const Views> && ...)) {
return begin() + iter_difference_t<iterator <true>>(size());
} else {
return iterator <true>(tuple-transform (ranges::end, views_));
}
}
§ 25.7.25.2 © ISO/IEC
1343

===== PAGE 1355 =====

Dxxxx
constexpr auto size() requires (sized_range<Views> && ...);
constexpr auto size() const requires (sized_range<const Views> && ...);
};
template<class... Rs>
zip_view(Rs&&...) -> zip_view<views::all_t<Rs>...>;
}
1 Two zip_view objects have the same underlying sequence if and only if the corresponding elements of
views_ are equal (18.2) and have the same underlying sequence.
[Note 1: In particular, comparison of iterators obtained fromzip_view objects that do not have the same underlying
sequence is not required to produce meaningful results (24.3.4.11).—end note]
constexpr explicit zip_view(Views... views);
2 Effects: Initializes views_ with std::move(views)....
constexpr auto size() requires (sized_range<Views> && ...);
constexpr auto size() const requires (sized_range<const Views> && ...);
3 Effects: Equivalent to:
return apply([](auto... sizes) {
using CT = make-unsigned-like-t <common_type_t<decltype(sizes)...>>;
return ranges::min({CT(sizes)...});
}, tuple-transform (ranges::size, views_));
25.7.25.3 Class template zip_view::iterator [range.zip.iterator]
namespace std::ranges {
template<input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0)
template<bool Const>
class zip_view<Views...>::iterator {
tuple<iterator_t<maybe-const<Const, Views>>...> current_; // exposition only
constexpr explicit iterator(tuple<iterator_t<maybe-const<Const, Views>>...>);
// exposition only
public:
using iterator_category = input_iterator_tag; // not always present
using iterator_concept = see below ;
using value_type = tuple<range_value_t<maybe-const <Const, Views>>...>;
using difference_type = common_type_t<range_difference_t<maybe-const <Const, Views>>...>;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const && (convertible_to<iterator_t<Views>, iterator_t<const Views>> && ...);
constexpr auto operator*() const;
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires all-forward <Const, Views...>;
constexpr iterator & operator--() requires all-bidirectional <Const, Views...>;
constexpr iterator operator--(int) requires all-bidirectional <Const, Views...>;
constexpr iterator & operator+=(difference_type x)
requires all-random-access <Const, Views...>;
constexpr iterator & operator-=(difference_type x)
requires all-random-access <Const, Views...>;
constexpr auto operator[](difference_type n) const
requires all-random-access <Const, Views...>;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires (equality_comparable<iterator_t<maybe-const <Const, Views>>> && ...);
§ 25.7.25.3 © ISO/IEC
1344

===== PAGE 1356 =====

Dxxxx
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires all-random-access <Const, Views...>;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires all-random-access <Const, Views...>;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires all-random-access <Const, Views...>;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires (sized_sentinel_for<iterator_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <Const, Views>>> && ...);
friend constexpr auto iter_move(const iterator & i) noexcept(see below );
friend constexpr void iter_swap(const iterator & l, const iterator & r) noexcept(see below )
requires (indirectly_swappable<iterator_t<maybe-const <Const, Views>>> && ...);
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If all-random-access <Const, Views...> is modeled, then iterator_concept denotes random_-
access_iterator_tag.
—(1.2) Otherwise, if all-bidirectional <Const, Views...> is modeled, theniterator_concept denotes
bidirectional_iterator_tag.
—(1.3) Otherwise, if all-forward <Const, Views...> is modeled, then iterator_concept denotes for-
ward_iterator_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
2 iterator ::iterator_category is present if and only ifall-forward <Const, Views...> is modeled.
3 If the invocation of any non-const member function ofiterator exits via an exception, the iterator acquires
a singular value.
constexpr explicit iterator (tuple<iterator_t<maybe-const <Const, Views>>...> current);
4 Effects: Initializes current_ with std::move(current).
constexpr iterator (iterator <!Const> i)
requires Const && (convertible_to<iterator_t<Views>, iterator_t<const Views>> && ...);
5 Effects: Initializes current_ with std::move(i.current_).
constexpr auto operator*() const;
6 Effects: Equivalent to:
return tuple-transform ([](auto& i) -> decltype(auto) { return *i; }, current_);
constexpr iterator & operator++();
7 Effects: Equivalent to:
tuple-for-each ([](auto& i) { ++i; }, current_);
return *this;
constexpr void operator++(int);
8 Effects: Equivalent to++*this.
constexpr iterator operator++(int) requires all-forward <Const, Views...>;
9 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
§ 25.7.25.3 © ISO/IEC
1345

===== PAGE 1357 =====

Dxxxx
constexpr iterator & operator--() requires all-bidirectional <Const, Views...>;
10 Effects: Equivalent to:
tuple-for-each ([](auto& i) { --i; }, current_);
return *this;
constexpr iterator operator--(int) requires all-bidirectional <Const, Views...>;
11 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type x)
requires all-random-access <Const, Views...>;
12 Effects: Equivalent to:
tuple-for-each ([&]<class I>(I& i) { i += iter_difference_t<I>(x); }, current_);
return *this;
constexpr iterator & operator-=(difference_type x)
requires all-random-access <Const, Views...>;
13 Effects: Equivalent to:
tuple-for-each ([&]<class I>(I& i) { i -= iter_difference_t<I>(x); }, current_);
return *this;
constexpr auto operator[](difference_type n) const
requires all-random-access <Const, Views...>;
14 Effects: Equivalent to:
return tuple-transform ([&]<class I>(I& i) -> decltype(auto) {
return i[iter_difference_t<I>(n)];
}, current_);
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires (equality_comparable<iterator_t<maybe-const <Const, Views>>> && ...);
15 Returns:
—(15.1) x.current_ == y.current_ if all-bidirectional <Const, Views...> is true.
—(15.2) Otherwise, true if there exists an integer0 ≤i <sizeof...(Views) such that bool(std::
get<i>(x.current_) == std::get<i>(y.current_)) is true.
[Note 1: This allowszip_view to modelcommon_range when all constituent views modelcommon_range.
—end note]
—(15.3) Otherwise, false.
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires all-random-access <Const, Views...>;
16 Returns: x.current_ <=> y.current_.
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires all-random-access <Const, Views...>;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires all-random-access <Const, Views...>;
17 Effects: Equivalent to:
auto r = i;
r += n;
return r;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires all-random-access <Const, Views...>;
18 Effects: Equivalent to:
auto r = i;
§ 25.7.25.3 © ISO/IEC
1346

===== PAGE 1358 =====

Dxxxx
r -= n;
return r;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires (sized_sentinel_for<iterator_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <Const, Views>>> && ...);
19 Let DIST (i) be difference_type(std::get<i>(x.current_) - std::get<i>(y.current_)).
20 Returns: The value with the smallest absolute value among DIST (n) for all integers 0 ≤ n <
sizeof...(Views).
friend constexpr auto iter_move(const iterator & i) noexcept(see below );
21 Effects: Equivalent to:
return tuple-transform (ranges::iter_move, i.current_);
22 Remarks: The exception specification is equivalent to:
(noexcept(ranges::iter_move(declval<const iterator_t<maybe-const <Const,
Views>>&>())) && ...) &&
(is_nothrow_move_constructible_v<range_rvalue_reference_t<maybe-const <Const,
Views>>> && ...)
friend constexpr void iter_swap(const iterator & l, const iterator & r) noexcept(see below )
requires (indirectly_swappable<iterator_t<maybe-const <Const, Views>>> && ...);
23 Effects: For every integer0 ≤i< sizeof...(Views), performs:
ranges::iter_swap(std::get<i>(l.current_), std::get<i>(r.current_))
24 Remarks: The exception specification is equivalent to the logicaland of the following expressions:
noexcept(ranges::iter_swap(std::get<i>(l.current_), std::get<i>(r.current_)))
for every integer0 ≤i< sizeof...(Views).
25.7.25.4 Class template zip_view::sentinel [range.zip.sentinel]
namespace std::ranges {
template<input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0)
template<bool Const>
class zip_view<Views...>::sentinel {
tuple<sentinel_t<maybe-const<Const, Views>>...> end_; // exposition only
constexpr explicit sentinel(tuple<sentinel_t<maybe-const<Const, Views>>...> end);
// exposition only
public:
sentinel () = default;
constexpr sentinel (sentinel <!Const> i)
requires Const && (convertible_to<sentinel_t<Views>, sentinel_t<const Views>> && ...);
template<bool OtherConst>
requires (sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <OtherConst, Views>>> && ...)
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires (sized_sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <OtherConst, Views>>> && ...)
friend constexpr common_type_t<range_difference_t<maybe-const <OtherConst, Views>>...>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires (sized_sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <OtherConst, Views>>> && ...)
friend constexpr common_type_t<range_difference_t<maybe-const <OtherConst, Views>>...>
operator-(const sentinel & y, const iterator <OtherConst>& x);
};
}
§ 25.7.25.4 © ISO/IEC
1347

===== PAGE 1359 =====

Dxxxx
constexpr explicit sentinel (tuple<sentinel_t<maybe-const <Const, Views>>...> end);
1 Effects: Initializes end_ with end.
constexpr sentinel (sentinel <!Const> i)
requires Const && (convertible_to<sentinel_t<Views>, sentinel_t<const Views>> && ...);
2 Effects: Initializes end_ with std::move(i.end_).
template<bool OtherConst>
requires (sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <OtherConst, Views>>> && ...)
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
3 Returns: true if there exists an integer0 ≤i <sizeof...(Views) such thatbool(std::get<i>(x.
current_) == std::get<i>(y.end_)) is true. Otherwise, false.
template<bool OtherConst>
requires (sized_sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <OtherConst, Views>>> && ...)
friend constexpr common_type_t<range_difference_t<maybe-const <OtherConst, Views>>...>
operator-(const iterator <OtherConst>& x, const sentinel & y);
4 Let D be the return type. LetDIST (i) be D(std::get<i>(x.current_) - std::get<i>(y.end_)).
5 Returns: The value with the smallest absolute value among DIST (n) for all integers 0 ≤ n <
sizeof...(Views).
template<bool OtherConst>
requires (sized_sentinel_for<sentinel_t<maybe-const <Const, Views>>,
iterator_t<maybe-const <OtherConst, Views>>> && ...)
friend constexpr common_type_t<range_difference_t<maybe-const <OtherConst, Views>>...>
operator-(const sentinel & y, const iterator <OtherConst>& x);
6 Effects: Equivalent to:return -(x - y);
25.7.26 Zip transform view [range.zip.transform]
25.7.26.1 Overview [range.zip.transform.overview]
1 zip_transform_view takes an invocable object and any number of views and produces a view whoseMth
element is the result of applying the invocable object to theMth elements of all views.
2 The nameviews::zip_transformdenotes a customization point object (16.3.3.3.5). LetFbe a subexpression,
and letEs... be a pack of subexpressions.
—(2.1) If Es is an empty pack, letFD be decay_t<decltype((F))>.
—(2.1.1) If move_constructible<FD> && regular_invocable<FD&> is false, or if decay_t<invoke_-
result_t<FD&>> is not an object type,views::zip_transform(F, Es...) is ill-formed.
—(2.1.2) Otherwise, the expressionviews::zip_transform(F, Es...) is expression-equivalent to
((void)F, auto(views::empty<decay_t<invoke_result_t<FD&>>>))
—(2.2) Otherwise, the expressionviews::zip_transform(F, Es...) is expression-equivalent tozip_trans-
form_view(F, Es...).
3 [Example 1:
vector v1 = {1, 2};
vector v2 = {4, 5, 6};
for (auto i : views::zip_transform(plus(), v1, v2)) {
cout << i << ' '; // prints5 7
}
—end example]
25.7.26.2 Class template zip_transform_view [range.zip.transform.view]
namespace std::ranges {
template<move_constructible F, input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0) && is_object_v<F> &&
§ 25.7.26.2 © ISO/IEC
1348

===== PAGE 1360 =====

Dxxxx
regular_invocable<F&, range_reference_t<Views>...> &&
can-reference <invoke_result_t<F&, range_reference_t<Views>...>>
class zip_transform_view : public view_interface<zip_transform_view<F, Views...>> {
movable-box<F> fun_; // exposition only
zip_view<Views...> zip_; // exposition only
using InnerView = zip_view<Views...>; // exposition only
template<bool Const>
using ziperator = iterator_t<maybe-const<Const, InnerView>>; // exposition only
template<bool Const>
using zentinel = sentinel_t<maybe-const<Const, InnerView>>; // exposition only
// 25.7.26.3, class templatezip_transform_view::iterator
template<bool> class iterator; // exposition only
// 25.7.26.4, class templatezip_transform_view::sentinel
template<bool> class sentinel; // exposition only
public:
zip_transform_view() = default;
constexpr explicit zip_transform_view(F fun, Views... views);
constexpr auto begin() { return iterator <false>(*this, zip_.begin()); }
constexpr auto begin() const
requires range<const InnerView > &&
regular_invocable<const F&, range_reference_t<const Views>...> {
return iterator <true>(*this, zip_.begin());
}
constexpr auto end() {
if constexpr (common_range<InnerView >) {
return iterator <false>(*this, zip_.end());
} else {
return sentinel <false>(zip_.end());
}
}
constexpr auto end() const
requires range<const InnerView > &&
regular_invocable<const F&, range_reference_t<const Views>...> {
if constexpr (common_range<const InnerView >) {
return iterator <true>(*this, zip_.end());
} else {
return sentinel <true>(zip_.end());
}
}
constexpr auto size() requires sized_range<InnerView > {
return zip_.size();
}
constexpr auto size() const requires sized_range<const InnerView > {
return zip_.size();
}
};
template<class F, class... Rs>
zip_transform_view(F, Rs&&...) -> zip_transform_view<F, views::all_t<Rs>...>;
}
constexpr explicit zip_transform_view(F fun, Views... views);
1 Effects: Initializes fun_ with std::move(fun) and zip_ with std::move(views)....
§ 25.7.26.2 © ISO/IEC
1349

===== PAGE 1361 =====

Dxxxx
25.7.26.3 Class template zip_transform_view::iterator [range.zip.transform.iterator]
namespace std::ranges {
template<move_constructible F, input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0) && is_object_v<F> &&
regular_invocable<F&, range_reference_t<Views>...> &&
can-reference <invoke_result_t<F&, range_reference_t<Views>...>>
template<bool Const>
class zip_transform_view<F, Views...>::iterator {
using Parent = maybe-const<Const, zip_transform_view>; // exposition only
using Base = maybe-const<Const, InnerView>; // exposition only
Parent* parent_ = nullptr; // exposition only
ziperator <Const> inner_; // exposition only
constexpr iterator (Parent & parent, ziperator <Const> inner); // exposition only
public:
using iterator_category = see below; // not always present
using iterator_concept = ziperator <Const>::iterator_concept;
using value_type =
remove_cvref_t<invoke_result_t<maybe-const <Const, F>&,
range_reference_t<maybe-const <Const, Views>>...>>;
using difference_type = range_difference_t<Base >;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<ziperator <false>, ziperator <Const>>;
constexpr decltype(auto) operator*() const noexcept(see below );
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires forward_range<Base >;
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type x) requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type x) requires random_access_range<Base >;
constexpr decltype(auto) operator[](difference_type n) const
requires random_access_range<Base >;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<ziperator <Const>>;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<ziperator <Const>, ziperator <Const>>;
};
}
1 The membertypedef-name iterator ::iterator_category is defined if and only ifBase models forward_-
range. In that case,iterator ::iterator_category is defined as follows:
—(1.1) If
invoke_result_t<maybe-const <Const, F>&, range_reference_t<maybe-const <Const, Views>>...>
is not a reference,iterator_category denotes input_iterator_tag.
§ 25.7.26.3 © ISO/IEC
1350

===== PAGE 1362 =====

Dxxxx
—(1.2) Otherwise, let Cs denote the pack of types iterator_traits<iterator_t<maybe-const <Const,
Views>>>::iterator_category....
—(1.2.1) If (derived_from<Cs, random_access_iterator_tag> && ...) is true, iterator_category
denotes random_access_iterator_tag.
—(1.2.2) Otherwise, if (derived_from<Cs, bidirectional_iterator_tag> && ...) is true, iterator-
_category denotes bidirectional_iterator_tag.
—(1.2.3) Otherwise, if (derived_from<Cs, forward_iterator_tag> && ...) is true, iterator_cate-
gory denotes forward_iterator_tag.
—(1.2.4) Otherwise, iterator_category denotes input_iterator_tag.
constexpr iterator (Parent & parent, ziperator <Const> inner);
2 Effects: Initializes parent_ with addressof(parent) and inner_ with std::move(inner).
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<ziperator <false>, ziperator <Const>>;
3 Effects: Initializes parent_ with i.parent_ and inner_ with std::move(i.inner_).
constexpr decltype(auto) operator*() const noexcept(see below );
4 Effects: Equivalent to:
return apply([&](const auto&... iters) -> decltype(auto) {
return invoke(*parent_->fun_, *iters...);
}, inner_.current_);
5 Remarks: Let Is be the pack0, 1, ..., (sizeof...(Views) - 1). The exception specification is
equivalent to:noexcept(invoke(*parent_->fun_, *std::get<Is>(inner_.current_)...)).
constexpr iterator & operator++();
6 Effects: Equivalent to:
++inner_;
return *this;
constexpr void operator++(int);
7 Effects: Equivalent to:++*this.
constexpr iterator operator++(int) requires forward_range<Base >;
8 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
9 Effects: Equivalent to:
--inner_;
return *this;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
10 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
11 Effects: Equivalent to:
inner_ += x;
return *this;
§ 25.7.26.3 © ISO/IEC
1351

===== PAGE 1363 =====

Dxxxx
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
12 Effects: Equivalent to:
inner_ -= x;
return *this;
constexpr decltype(auto) operator[](difference_type n) const
requires random_access_range<Base >;
13 Effects: Equivalent to:
return apply([&]<class... Is>(const Is&... iters) -> decltype(auto) {
return invoke(*parent_->fun_, iters[iter_difference_t<Is>(n)]...);
}, inner_.current_);
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<ziperator <Const>>;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
14 Let op be the operator.
15 Effects: Equivalent to:return x.inner_ op y.inner_;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
16 Effects: Equivalent to:return iterator (*i.parent_, i.inner_ + n);
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
17 Effects: Equivalent to:return iterator (*i.parent_, i.inner_ - n);
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<ziperator <Const>, ziperator <Const>>;
18 Effects: Equivalent to:return x.inner_ - y.inner_;
25.7.26.4 Class template zip_transform_view::sentinel [range.zip.transform.sentinel]
namespace std::ranges {
template<move_constructible F, input_range... Views>
requires (view<Views> && ...) && (sizeof...(Views) > 0) && is_object_v<F> &&
regular_invocable<F&, range_reference_t<Views>...> &&
can-reference <invoke_result_t<F&, range_reference_t<Views>...>>
template<bool Const>
class zip_transform_view<F, Views...>::sentinel {
zentinel<Const> inner_; // exposition only
constexpr explicit sentinel(zentinel<Const> inner); // exposition only
public:
sentinel () = default;
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<zentinel <false>, zentinel <Const>>;
template<bool OtherConst>
requires sentinel_for<zentinel <Const>, ziperator <OtherConst>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<zentinel <Const>, ziperator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const iterator <OtherConst>& x, const sentinel & y);
§ 25.7.26.4 © ISO/IEC
1352

===== PAGE 1364 =====

Dxxxx
template<bool OtherConst>
requires sized_sentinel_for<zentinel <Const>, ziperator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const sentinel & x, const iterator <OtherConst>& y);
};
}
constexpr explicit sentinel (zentinel <Const> inner);
1 Effects: Initializes inner_ with inner.
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<zentinel <false>, zentinel <Const>>;
2 Effects: Initializes inner_ with std::move(i.inner_).
template<bool OtherConst>
requires sentinel_for<zentinel <Const>, ziperator <OtherConst>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
3 Effects: Equivalent to:return x.inner_ == y.inner_;
template<bool OtherConst>
requires sized_sentinel_for<zentinel <Const>, ziperator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<zentinel <Const>, ziperator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const sentinel & x, const iterator <OtherConst>& y);
4 Effects: Equivalent to:return x.inner_ - y.inner_;
25.7.27 Adjacent view [range.adjacent]
25.7.27.1 Overview [range.adjacent.overview]
1 adjacent_view takes a view and produces a view whoseMth element is a tuple of references to theMth
through (M + N −1)th elements of the original view. If the original view has fewer thanN elements, the
resulting view is empty.
2 The nameviews::adjacent<N> denotes a range adaptor object (25.7.2). Given a subexpressionE and a
constant expressionN, the expressionviews::adjacent<N>(E) is expression-equivalent to
—(2.1) ((void)E, auto(views::empty<tuple<>>)) if N is equal to0 and decltype((E)) models forward_-
range,
—(2.2) otherwise, adjacent_view<views::all_t<decltype((E))>, N>(E).
[Example 1:
vector v = {1, 2, 3, 4};
for (auto i : v | views::adjacent<2>) {
cout << "(" << std::get<0>(i) << ", " << std::get<1>(i) << ") "; // prints(1, 2) (2, 3) (3, 4)
}
—end example]
3 Define REPEAT (T, N) as a pack ofN types, each of which denotes the same type asT.
25.7.27.2 Class template adjacent_view [range.adjacent.view]
namespace std::ranges {
template<forward_range V, size_t N>
requires view<V> && (N > 0)
class adjacent_view : public view_interface<adjacent_view<V, N>> {
V base_ = V(); // exposition only
// 25.7.27.3, class templateadjacent_view::iterator
template<bool> class iterator; // exposition only
§ 25.7.27.2 © ISO/IEC
1353

===== PAGE 1365 =====

Dxxxx
// 25.7.27.4, class templateadjacent_view::sentinel
template<bool> class sentinel; // exposition only
struct as-sentinel{}; // exposition only
public:
adjacent_view() requires default_initializable<V> = default;
constexpr explicit adjacent_view(V base);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>) {
return iterator <false>(ranges::begin(base_), ranges::end(base_));
}
constexpr auto begin() const requires range<const V> {
return iterator <true>(ranges::begin(base_), ranges::end(base_));
}
constexpr auto end() requires (!simple-view <V>) {
if constexpr (common_range<V>) {
return iterator <false>(as-sentinel {}, ranges::begin(base_), ranges::end(base_));
} else {
return sentinel <false>(ranges::end(base_));
}
}
constexpr auto end() const requires range<const V> {
if constexpr (common_range<const V>) {
return iterator <true>(as-sentinel {}, ranges::begin(base_), ranges::end(base_));
} else {
return sentinel <true>(ranges::end(base_));
}
}
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
};
}
constexpr explicit adjacent_view(V base);
1 Effects: Initializes base_ with std::move(base).
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
2 Effects: Equivalent to:
using ST = decltype(ranges::size(base_));
using CT = common_type_t<ST, size_t>;
auto sz = static_cast<CT>(ranges::size(base_));
sz -= std::min<CT>(sz, N - 1);
return static_cast<ST>(sz);
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
3 Effects: Equivalent to:
using DT = range_difference_t<decltype((base_))>;
using CT = common_type_t<DT, size_t>;
auto sz = static_cast<CT>(ranges::reserve_hint(base_));
§ 25.7.27.2 © ISO/IEC
1354

===== PAGE 1366 =====

Dxxxx
sz -= std::min<CT>(sz, N - 1);
return to-unsigned-like (sz);
25.7.27.3 Class template adjacent_view::iterator [range.adjacent.iterator]
namespace std::ranges {
template<forward_range V, size_t N>
requires view<V> && (N > 0)
template<bool Const>
class adjacent_view<V, N>::iterator {
using Base = maybe-const<Const, V>; // exposition only
array<iterator_t<Base>, N> current_ = array<iterator_t<Base>, N>(); // exposition only
constexpr iterator(iterator_t<Base> first, sentinel_t<Base> last); // exposition only
constexpr iterator(as-sentinel, iterator_t<Base> first, iterator_t<Base> last);
// exposition only
public:
using iterator_category = input_iterator_tag;
using iterator_concept = see below ;
using value_type = tuple<REPEAT (range_value_t<Base >, N)...>;
using difference_type = range_difference_t<Base >;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
constexpr auto operator*() const;
constexpr iterator & operator++();
constexpr iterator operator++(int);
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
constexpr auto operator[](difference_type n) const
requires random_access_range<Base >;
friend constexpr bool operator==(const iterator & x, const iterator & y);
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > &&
three_way_comparable<iterator_t<Base >>;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
friend constexpr auto iter_move(const iterator & i) noexcept(see below );
friend constexpr void iter_swap(const iterator & l, const iterator & r) noexcept(see below )
requires indirectly_swappable<iterator_t<Base >>;
§ 25.7.27.3 © ISO/IEC
1355

===== PAGE 1367 =====

Dxxxx
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If Base models random_access_range, theniterator_concept denotes random_access_iterator_-
tag.
—(1.2) Otherwise, ifBase models bidirectional_range, theniterator_concept denotes bidirectional_-
iterator_tag.
—(1.3) Otherwise, iterator_concept denotes forward_iterator_tag.
2 If the invocation of any non-const member function ofiterator exits via an exception, theiterator
acquires a singular value.
constexpr iterator (iterator_t<Base > first, sentinel_t<Base > last);
3 Postconditions: current_[0] == first is true, and for every integer1 ≤i <N, current_[i] ==
ranges::next(current_[i-1], 1, last) is true.
constexpr iterator (as-sentinel , iterator_t<Base > first, iterator_t<Base > last);
4 Postconditions: If Base does not modelbidirectional_range, each element ofcurrent_ is equal to
last . Otherwise,current_[N-1] == last is true, and for every integer0 ≤i< (N−1), current_[i]
== ranges::prev(current_[i+1], 1, first) is true.
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
5 Effects: Initializes each element ofcurrent_ with the corresponding element ofi.current_ as an
xvalue.
constexpr auto operator*() const;
6 Effects: Equivalent to:
return tuple-transform ([](auto& i) -> decltype(auto) { return *i; }, current_);
constexpr iterator & operator++();
7 Preconditions: current_.back() is incrementable.
8 Postconditions: Each element ofcurrent_ is equal toranges::next(i), wherei is the value of that
element before the call.
9 Returns: *this.
constexpr iterator operator++(int);
10 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
11 Preconditions: current_.front() is decrementable.
12 Postconditions: Each element ofcurrent_ is equal toranges::prev(i), wherei is the value of that
element before the call.
13 Returns: *this.
constexpr iterator operator--(int) requires bidirectional_range<Base >;
14 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
§ 25.7.27.3 © ISO/IEC
1356

===== PAGE 1368 =====

Dxxxx
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
15 Preconditions: current_.back() + x has well-defined behavior.
16 Postconditions: Each element ofcurrent_ is equal toi + x, where i is the value of that element
before the call.
17 Returns: *this.
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
18 Preconditions: current_.front() - x has well-defined behavior.
19 Postconditions: Each element ofcurrent_ is equal toi - x, where i is the value of that element
before the call.
20 Returns: *this.
constexpr auto operator[](difference_type n) const
requires random_access_range<Base >;
21 Effects: Equivalent to:
return tuple-transform ([&](auto& i) -> decltype(auto) { return i[n]; }, current_);
friend constexpr bool operator==(const iterator & x, const iterator & y);
22 Returns: x.current_.back() == y.current_.back().
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
23 Returns: x.current_.back() < y.current_.back().
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
24 Effects: Equivalent to:return y < x;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
25 Effects: Equivalent to:return !(y < x);
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
26 Effects: Equivalent to:return !(x < y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > &&
three_way_comparable<iterator_t<Base >>;
27 Returns: x.current_.back() <=> y.current_.back().
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
28 Effects: Equivalent to:
auto r = i;
r += n;
return r;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
29 Effects: Equivalent to:
auto r = i;
r -= n;
§ 25.7.27.3 © ISO/IEC
1357

===== PAGE 1369 =====

Dxxxx
return r;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
30 Effects: Equivalent to:return x.current_.back() - y.current_.back();
friend constexpr auto iter_move(const iterator & i) noexcept(see below );
31 Effects: Equivalent to:return tuple-transform (ranges::iter_move, i.current_);
32 Remarks: The exception specification is equivalent to:
noexcept(ranges::iter_move(declval<const iterator_t<Base >&>())) &&
is_nothrow_move_constructible_v<range_rvalue_reference_t<Base >>
friend constexpr void iter_swap(const iterator & l, const iterator & r) noexcept(see below )
requires indirectly_swappable<iterator_t<Base >>;
33 Preconditions: None of the iterators inl.current_ is equal to an iterator inr.current_.
34 Effects: For every integer0 ≤i< N, performsranges::iter_swap(l.current_[i], r.current_[i]).
35 Remarks: The exception specification is equivalent to:
noexcept(ranges::iter_swap(declval<iterator_t<Base >>(), declval<iterator_t<Base >>()))
25.7.27.4 Class template adjacent_view::sentinel [range.adjacent.sentinel]
namespace std::ranges {
template<forward_range V, size_t N>
requires view<V> && (N > 0)
template<bool Const>
class adjacent_view<V, N>::sentinel {
using Base = maybe-const <Const, V>; // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
constexpr explicit sentinel (sentinel_t<Base > end); // exposition only
public:
sentinel () = default;
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & y, const iterator <OtherConst>& x);
};
}
constexpr explicit sentinel (sentinel_t<Base > end);
1 Effects: Initializes end_ with end.
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<sentinel_t<V>, sentinel_t<Base >>;
2 Effects: Initializes end_ with std::move(i.end_).
§ 25.7.27.4 © ISO/IEC
1358

===== PAGE 1370 =====

Dxxxx
template<bool OtherConst>
requires sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
3 Effects: Equivalent to:return x.current_.back() == y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const iterator <OtherConst>& x, const sentinel & y);
4 Effects: Equivalent to:return x.current_.back() - y.end_;
template<bool OtherConst>
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<maybe-const <OtherConst, V>>>
friend constexpr range_difference_t<maybe-const <OtherConst, V>>
operator-(const sentinel & y, const iterator <OtherConst>& x);
5 Effects: Equivalent to:return y.end_ - x.current_.back();
25.7.28 Adjacent transform view [range.adjacent.transform]
25.7.28.1 Overview [range.adjacent.transform.overview]
1 adjacent_transform_view takes an invocable object and a view and produces a view whoseMth element is
the result of applying the invocable object to theMth through (M + N −1)th elements of the original view.
If the original view has fewer thanN elements, the resulting view is empty.
2 The nameviews::adjacent_transform<N> denotes a range adaptor object (25.7.2). Given subexpressions
E and F and a constant expressionN:
—(2.1) If N is equal to0 and decltype((E)) models forward_range, views::adjacent_transform<N>(E,
F) is expression-equivalent to((void)E, views::zip_transform(F)), except that the evaluations of
E and F are indeterminately sequenced.
—(2.2) Otherwise, the expressionviews::adjacent_transform<N>(E, F) is expression-equivalent toadja-
cent_transform_view<views::all_t<decltype((E))>, decay_t<decltype((F))>, N>(E, F).
3 [Example 1:
vector v = {1, 2, 3, 4};
for (auto i : v | views::adjacent_transform<2>(std::multiplies())) {
cout << i << ' '; // prints2 6 12
}
—end example]
25.7.28.2 Class template adjacent_transform_view [range.adjacent.transform.view]
namespace std::ranges {
template<forward_range V, move_constructible F, size_t N>
requires view<V> && (N > 0) && is_object_v<F> &&
regular_invocable<F&, REPEAT (range_reference_t<V>, N)...> &&
can-reference <invoke_result_t<F&, REPEAT (range_reference_t<V>, N)...>>
class adjacent_transform_view : public view_interface<adjacent_transform_view<V, F, N>> {
movable-box<F> fun_; // exposition only
adjacent_view<V, N> inner_; // exposition only
using InnerView = adjacent_view<V, N>; // exposition only
template<bool Const>
using inner-iterator = iterator_t<maybe-const <Const, InnerView >>; // exposition only
template<bool Const>
using inner-sentinel = sentinel_t<maybe-const <Const, InnerView >>; // exposition only
// 25.7.28.3, class templateadjacent_transform_view::iterator
template<bool> class iterator; // exposition only
// 25.7.28.4, class templateadjacent_transform_view::sentinel
template<bool> class sentinel; // exposition only
§ 25.7.28.2 © ISO/IEC
1359

===== PAGE 1371 =====

Dxxxx
public:
adjacent_transform_view() = default;
constexpr explicit adjacent_transform_view(V base, F fun);
constexpr V base() const & requires copy_constructible<V> { return inner_.base(); }
constexpr V base() && { return std::move(inner_).base(); }
constexpr auto begin() {
return iterator <false>(*this, inner_.begin());
}
constexpr auto begin() const
requires range<const InnerView > &&
regular_invocable<const F&, REPEAT (range_reference_t<const V>, N)...> {
return iterator <true>(*this, inner_.begin());
}
constexpr auto end() {
if constexpr (common_range<InnerView >) {
return iterator <false>(*this, inner_.end());
} else {
return sentinel <false>(inner_.end());
}
}
constexpr auto end() const
requires range<const InnerView > &&
regular_invocable<const F&, REPEAT (range_reference_t<const V>, N)...> {
if constexpr (common_range<const InnerView >) {
return iterator <true>(*this, inner_.end());
} else {
return sentinel <true>(inner_.end());
}
}
constexpr auto size() requires sized_range<InnerView > {
return inner_.size();
}
constexpr auto size() const requires sized_range<const InnerView > {
return inner_.size();
}
constexpr auto reserve_hint() requires approximately_sized_range<InnerView > {
return inner_.reserve_hint();
}
constexpr auto reserve_hint() const requires approximately_sized_range<const InnerView > {
return inner_.reserve_hint();
}
};
}
constexpr explicit adjacent_transform_view(V base, F fun);
1 Effects: Initializes fun_ with std::move(fun) and inner_ with std::move(base).
25.7.28.3 Class template adjacent_transform_view::iterator
[range.adjacent.transform.iterator]
namespace std::ranges {
template<forward_range V, move_constructible F, size_t N>
requires view<V> && (N > 0) && is_object_v<F> &&
regular_invocable<F&, REPEAT (range_reference_t<V>, N)...> &&
can-reference <invoke_result_t<F&, REPEAT (range_reference_t<V>, N)...>>
§ 25.7.28.3 © ISO/IEC
1360

===== PAGE 1372 =====

Dxxxx
template<bool Const>
class adjacent_transform_view<V, F, N>::iterator {
using Parent = maybe-const<Const, adjacent_transform_view>; // exposition only
using Base = maybe-const<Const, V>; // exposition only
Parent* parent_ = nullptr; // exposition only
inner-iterator<Const> inner_; // exposition only
constexpr iterator(Parent& parent, inner-iterator<Const> inner); // exposition only
public:
using iterator_category = see below ;
using iterator_concept = inner-iterator <Const>::iterator_concept;
using value_type =
remove_cvref_t<invoke_result_t<maybe-const <Const, F>&,
REPEAT (range_reference_t<Base >, N)...>>;
using difference_type = range_difference_t<Base >;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<inner-iterator <false>, inner-iterator <Const>>;
constexpr decltype(auto) operator*() const noexcept(see below );
constexpr iterator & operator++();
constexpr iterator operator++(int);
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type x) requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type x) requires random_access_range<Base >;
constexpr decltype(auto) operator[](difference_type n) const
requires random_access_range<Base >;
friend constexpr bool operator==(const iterator & x, const iterator & y);
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<inner-iterator <Const>>;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<inner-iterator <Const>, inner-iterator <Const>>;
};
}
1 The membertypedef-name iterator ::iterator_category is defined as follows:
—(1.1) If invoke_result_t<maybe-const <Const, F>&, REPEAT (range_reference_t<Base >, N)...> is
not a reference,iterator_category denotes input_iterator_tag.
—(1.2) Otherwise, letC denote the typeiterator_traits<iterator_t<Base >>::iterator_category.
—(1.2.1) If derived_from<C, random_access_iterator_tag> is true, iterator_category denotes ran-
dom_access_iterator_tag.
§ 25.7.28.3 © ISO/IEC
1361

===== PAGE 1373 =====

Dxxxx
—(1.2.2) Otherwise, if derived_from<C, bidirectional_iterator_tag> is true, iterator_category
denotes bidirectional_iterator_tag.
—(1.2.3) Otherwise, ifderived_from<C, forward_iterator_tag> is true, iterator_category denotes
forward_iterator_tag.
—(1.2.4) Otherwise, iterator_category denotes input_iterator_tag.
constexpr iterator (Parent & parent, inner-iterator <Const> inner);
2 Effects: Initializes parent_ with addressof(parent) and inner_ with std::move(inner).
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<inner-iterator <false>, inner-iterator <Const>>;
3 Effects: Initializes parent_ with i.parent_ and inner_ with std::move(i.inner_).
constexpr decltype(auto) operator*() const noexcept(see below );
4 Effects: Equivalent to:
return apply([&](const auto&... iters) -> decltype(auto) {
return invoke(*parent_->fun_, *iters...);
}, inner_.current_);
5 Remarks: Let Is be the pack0, 1, ..., (N - 1). The exception specification is equivalent to:
noexcept(invoke(*parent_->fun_, *std::get<Is>(inner_.current_)...))
constexpr iterator & operator++();
6 Effects: Equivalent to:
++inner_;
return *this;
constexpr iterator operator++(int);
7 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
8 Effects: Equivalent to:
--inner_;
return *this;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
9 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type x) requires random_access_range<Base >;
10 Effects: Equivalent to:
inner_ += x;
return *this;
constexpr iterator & operator-=(difference_type x) requires random_access_range<Base >;
11 Effects: Equivalent to:
inner_ -= x;
return *this;
constexpr decltype(auto) operator[](difference_type n) const
requires random_access_range<Base >;
12 Effects: Equivalent to:
§ 25.7.28.3 © ISO/IEC
1362

===== PAGE 1374 =====

Dxxxx
return apply([&](const auto&... iters) -> decltype(auto) {
return invoke(*parent_->fun_, iters[n]...);
}, inner_.current_);
friend constexpr bool operator==(const iterator & x, const iterator & y);
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<inner-iterator <Const>>;
13 Let op be the operator.
14 Effects: Equivalent to:return x.inner_ op y.inner_;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
15 Effects: Equivalent to:return iterator (*i.parent_, i.inner_ + n);
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
16 Effects: Equivalent to:return iterator (*i.parent_, i.inner_ - n);
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<inner-iterator <Const>, inner-iterator <Const>>;
17 Effects: Equivalent to:return x.inner_ - y.inner_;
25.7.28.4 Class template adjacent_transform_view::sentinel
[range.adjacent.transform.sentinel]
namespace std::ranges {
template<forward_range V, move_constructible F, size_t N>
requires view<V> && (N > 0) && is_object_v<F> &&
regular_invocable<F&, REPEAT (range_reference_t<V>, N)...> &&
can-reference <invoke_result_t<F&, REPEAT (range_reference_t<V>, N)...>>
template<bool Const>
class adjacent_transform_view<V, F, N>::sentinel {
inner-sentinel<Const> inner_; // exposition only
constexpr explicit sentinel(inner-sentinel<Const> inner); // exposition only
public:
sentinel () = default;
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<inner-sentinel <false>, inner-sentinel <Const>>;
template<bool OtherConst>
requires sentinel_for<inner-sentinel <Const>, inner-iterator <OtherConst>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<inner-sentinel <Const>, inner-iterator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<inner-sentinel <Const>, inner-iterator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const sentinel & x, const iterator <OtherConst>& y);
§ 25.7.28.4 © ISO/IEC
1363

===== PAGE 1375 =====

Dxxxx
};
}
constexpr explicit sentinel (inner-sentinel <Const> inner);
1 Effects: Initializes inner_ with inner.
constexpr sentinel (sentinel <!Const> i)
requires Const && convertible_to<inner-sentinel <false>, inner-sentinel <Const>>;
2 Effects: Initializes inner_ with std::move(i.inner_).
template<bool OtherConst>
requires sentinel_for<inner-sentinel <Const>, inner-iterator <OtherConst>>
friend constexpr bool operator==(const iterator <OtherConst>& x, const sentinel & y);
3 Effects: Equivalent to:return x.inner_ == y.inner_;
template<bool OtherConst>
requires sized_sentinel_for<inner-sentinel <Const>, inner-iterator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const iterator <OtherConst>& x, const sentinel & y);
template<bool OtherConst>
requires sized_sentinel_for<inner-sentinel <Const>, inner-iterator <OtherConst>>
friend constexpr range_difference_t<maybe-const <OtherConst, InnerView >>
operator-(const sentinel & x, const iterator <OtherConst>& y);
4 Effects: Equivalent to:return x.inner_ - y.inner_;
25.7.29 Chunk view [range.chunk]
25.7.29.1 Overview [range.chunk.overview]
1 chunk_view takes a view and a numberN and produces a range of views that areN-sized non-overlapping
successive chunks of the elements of the original view, in order. The last view in the range can have fewer
than N elements.
2 The name views::chunk denotes a range adaptor object (25.7.2). Given subexpressions E and N, the
expression views::chunk(E, N) is expression-equivalent tochunk_view(E, N).
[Example 1:
vector v = {1, 2, 3, 4, 5};
for (auto r : v | views::chunk(2)) {
cout << '[';
auto sep = "";
for (auto i : r) {
cout << sep << i;
sep = ", ";
}
cout << "] ";
}
// The above prints[1, 2] [3, 4] [5]
—end example]
25.7.29.2 Class template chunk_view for input ranges [range.chunk.view.input]
namespace std::ranges {
template<class I>
constexpr I div-ceil(I num, I denom) { // exposition only
I r = num / denom;
if (num % denom)
++r;
return r;
}
§ 25.7.29.2 © ISO/IEC
1364

===== PAGE 1376 =====

Dxxxx
template<view V>
requires input_range<V>
class chunk_view : public view_interface<chunk_view<V>> {
V base_; // exposition only
range_difference_t<V> n_; // exposition only
range_difference_t<V> remainder_ = 0; // exposition only
non-propagating-cache <iterator_t<V>> current_; // exposition only
// 25.7.29.3, classchunk_view::outer-iterator
class outer-iterator ; // exposition only
// 25.7.29.5, classchunk_view::inner-iterator
class inner-iterator ; // exposition only
public:
constexpr explicit chunk_view(V base, range_difference_t<V> n);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr outer-iterator begin();
constexpr default_sentinel_t end() const noexcept;
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
};
template<class R>
chunk_view(R&&, range_difference_t<R>) -> chunk_view<views::all_t<R>>;
}
constexpr explicit chunk_view(V base, range_difference_t<V> n);
1 Preconditions: n > 0 is true.
2 Effects: Initializes base_ with std::move(base) and n_ with n.
constexpr outer-iterator begin();
3 Effects: Equivalent to:
current_ = ranges::begin(base_);
remainder_ = n_;
return outer-iterator (*this);
constexpr default_sentinel_t end() const noexcept;
4 Returns: default_sentinel.
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
5 Effects: Equivalent to:
return to-unsigned-like (div-ceil(ranges::distance(base_), n_));
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
6 Effects: Equivalent to:
auto s = static_cast<range_difference_t<decltype((base_))>>(ranges::reserve_hint(base_));
return to-unsigned-like(div-ceil(s, n_));
§ 25.7.29.2 © ISO/IEC
1365

===== PAGE 1377 =====

Dxxxx
25.7.29.3 Class chunk_view::outer-iterator [range.chunk.outer.iter]
namespace std::ranges {
template<view V>
requires input_range<V>
class chunk_view<V>::outer-iterator {
chunk_view* parent_; // exposition only
constexpr explicit outer-iterator (chunk_view& parent); // exposition only
public:
using iterator_concept = input_iterator_tag;
using difference_type = range_difference_t<V>;
// 25.7.29.4, classchunk_view::outer-iterator ::value_type
struct value_type;
outer-iterator (outer-iterator &&) = default;
outer-iterator & operator=(outer-iterator &&) = default;
constexpr value_type operator*() const;
constexpr outer-iterator & operator++();
constexpr void operator++(int);
friend constexpr bool operator==(const outer-iterator & x, default_sentinel_t);
friend constexpr difference_type operator-(default_sentinel_t y, const outer-iterator & x)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
friend constexpr difference_type operator-(const outer-iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
};
}
constexpr explicit outer-iterator (chunk_view& parent);
1 Effects: Initializes parent_ with addressof(parent).
constexpr value_type operator*() const;
2 Preconditions: *this == default_sentinel is false.
3 Returns: value_type(*parent_).
constexpr outer-iterator & operator++();
4 Preconditions: *this == default_sentinel is false.
5 Effects: Equivalent to:
ranges::advance(*parent_->current_, parent_->remainder_, ranges::end(parent_->base_));
parent_->remainder_ = parent_->n_;
return *this;
constexpr void operator++(int);
6 Effects: Equivalent to++*this.
friend constexpr bool operator==(const outer-iterator & x, default_sentinel_t);
7 Effects: Equivalent to:
return *x.parent_->current_ == ranges::end(x.parent_->base_) && x.parent_->remainder_ != 0;
friend constexpr difference_type operator-(default_sentinel_t y, const outer-iterator & x)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
8 Effects: Equivalent to:
const auto dist = ranges::end(x.parent_->base_) - *x.parent_->current_;
if (dist < x.parent_->remainder_) {
return dist == 0 ? 0 : 1;
}
§ 25.7.29.3 © ISO/IEC
1366

===== PAGE 1378 =====

Dxxxx
return div-ceil(dist - x.parent_->remainder_, x.parent_->n_) + 1;
friend constexpr difference_type operator-(const outer-iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
9 Effects: Equivalent to:return -(y - x);
25.7.29.4 Class chunk_view::outer-iterator::value_type [range.chunk.outer.value]
namespace std::ranges {
template<view V>
requires input_range<V>
struct chunk_view<V>::outer-iterator ::value_type : view_interface<value_type> {
private:
chunk_view* parent_; // exposition only
constexpr explicit value_type(chunk_view& parent); // exposition only
public:
constexpr inner-iterator begin() const noexcept;
constexpr default_sentinel_t end() const noexcept;
constexpr auto size() const
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
constexpr auto reserve_hint() const noexcept;
};
}
constexpr explicit value_type(chunk_view& parent);
1 Effects: Initializes parent_ with addressof(parent).
constexpr inner-iterator begin() const noexcept;
2 Returns: inner-iterator (*parent_).
constexpr default_sentinel_t end() const noexcept;
3 Returns: default_sentinel.
constexpr auto size() const
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
4 Effects: Equivalent to:
return to-unsigned-like (ranges::min(parent_->remainder_,
ranges::end(parent_->base_) - *parent_->current_));
constexpr auto reserve_hint() const noexcept;
5 Effects: Equivalent to:
return to-unsigned-like (parent_->remainder_);
25.7.29.5 Class chunk_view::inner-iterator [range.chunk.inner.iter]
namespace std::ranges {
template<view V>
requires input_range<V>
class chunk_view<V>::inner-iterator {
chunk_view* parent_; // exposition only
constexpr explicit inner-iterator (chunk_view& parent) noexcept; // exposition only
public:
using iterator_concept = input_iterator_tag;
using difference_type = range_difference_t<V>;
using value_type = range_value_t<V>;
§ 25.7.29.5 © ISO/IEC
1367

===== PAGE 1379 =====

Dxxxx
inner-iterator (inner-iterator &&) = default;
inner-iterator & operator=(inner-iterator &&) = default;
constexpr const iterator_t<V>& base() const &;
constexpr range_reference_t<V> operator*() const;
constexpr inner-iterator & operator++();
constexpr void operator++(int);
friend constexpr bool operator==(const inner-iterator & x, default_sentinel_t);
friend constexpr difference_type operator-(default_sentinel_t y, const inner-iterator & x)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
friend constexpr difference_type operator-(const inner-iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
friend constexpr range_rvalue_reference_t<V> iter_move(const inner-iterator & i)
noexcept(noexcept(ranges::iter_move(*i.parent_->current_)));
friend constexpr void iter_swap(const inner-iterator & x, const inner-iterator & y)
noexcept(noexcept(ranges::iter_swap(*x.parent_->current_, *y.parent_->current_)))
requires indirectly_swappable<iterator_t<V>>;
};
}
constexpr explicit inner-iterator (chunk_view& parent) noexcept;
1 Effects: Initializes parent_ with addressof(parent).
constexpr const iterator_t<V>& base() const &;
2 Effects: Equivalent to:return *parent_->current_;
constexpr range_reference_t<V> operator*() const;
3 Preconditions: *this == default_sentinel is false.
4 Effects: Equivalent to:return **parent_->current_;
constexpr inner-iterator & operator++();
5 Preconditions: *this == default_sentinel is false.
6 Effects: Equivalent to:
++*parent_->current_;
if (*parent_->current_ == ranges::end(parent_->base_))
parent_->remainder_ = 0;
else
--parent_->remainder_;
return *this;
constexpr void operator++(int);
7 Effects: Equivalent to++*this.
friend constexpr bool operator==(const inner-iterator & x, default_sentinel_t);
8 Returns: x.parent_->remainder_ == 0.
friend constexpr difference_type operator-(default_sentinel_t y, const inner-iterator & x)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
9 Effects: Equivalent to:
return ranges::min(x.parent_->remainder_,
ranges::end(x.parent_->base_) - *x.parent_->current_);
friend constexpr difference_type operator-(const inner-iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
10 Effects: Equivalent to:return -(y - x);
§ 25.7.29.5 © ISO/IEC
1368

===== PAGE 1380 =====

Dxxxx
friend constexpr range_rvalue_reference_t<V> iter_move(const inner-iterator & i)
noexcept(noexcept(ranges::iter_move(*i.parent_->current_)));
11 Effects: Equivalent to:return ranges::iter_move(*i.parent_->current_);
friend constexpr void iter_swap(const inner-iterator & x, const inner-iterator & y)
noexcept(noexcept(ranges::iter_swap(*x.parent_->current_, *y.parent_->current_)))
requires indirectly_swappable<iterator_t<V>>;
12 Effects: Equivalent to:ranges::iter_swap(*x.parent_->current_, *y.parent_->current_);
25.7.29.6 Class template chunk_view for forward ranges [range.chunk.view.fwd]
namespace std::ranges {
template<view V>
requires forward_range<V>
class chunk_view<V> : public view_interface<chunk_view<V>> {
V base_; // exposition only
range_difference_t<V> n_; // exposition only
// 25.7.29.7, class templatechunk_view::iterator
template<bool> class iterator ; // exposition only
public:
constexpr explicit chunk_view(V base, range_difference_t<V> n);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>) {
return iterator <false>(this, ranges::begin(base_));
}
constexpr auto begin() const requires forward_range<const V> {
return iterator <true>(this, ranges::begin(base_));
}
constexpr auto end() requires (!simple-view <V>) {
if constexpr (common_range<V> && sized_range<V>) {
auto missing = (n_ - ranges::distance(base_) % n_) % n_;
return iterator <false>(this, ranges::end(base_), missing);
} else if constexpr (common_range<V> && !bidirectional_range<V>) {
return iterator <false>(this, ranges::end(base_));
} else {
return default_sentinel;
}
}
constexpr auto end() const requires forward_range<const V> {
if constexpr (common_range<const V> && sized_range<const V>) {
auto missing = (n_ - ranges::distance(base_) % n_) % n_;
return iterator <true>(this, ranges::end(base_), missing);
} else if constexpr (common_range<const V> && !bidirectional_range<const V>) {
return iterator <true>(this, ranges::end(base_));
} else {
return default_sentinel;
}
}
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
};
}
§ 25.7.29.6 © ISO/IEC
1369

===== PAGE 1381 =====

Dxxxx
constexpr explicit chunk_view(V base, range_difference_t<V> n);
1 Preconditions: n > 0 is true.
2 Effects: Initializes base_ with std::move(base) and n_ with n.
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
3 Effects: Equivalent to:
return to-unsigned-like (div-ceil (ranges::distance(base_), n_));
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
4 Effects: Equivalent to:
auto s = static_cast<range_difference_t<decltype((base_))>>(ranges::reserve_hint(base_));
return to-unsigned-like (div-ceil (s, n_));
25.7.29.7 Class template chunk_view::iterator for forward ranges [range.chunk.fwd.iter]
namespace std::ranges {
template<view V>
requires forward_range<V>
template<bool Const>
class chunk_view<V>::iterator {
using Parent = maybe-const <Const, chunk_view>; // exposition only
using Base = maybe-const <Const, V>; // exposition only
iterator_t<Base > current_ = iterator_t<Base >(); // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
range_difference_t<Base > n_ = 0; // exposition only
range_difference_t<Base > missing_ = 0; // exposition only
constexpr iterator (Parent * parent, iterator_t<Base > current, // exposition only
range_difference_t<Base > missing = 0);
public:
using iterator_category = input_iterator_tag;
using iterator_concept = see below ;
using value_type = decltype(views::take(subrange(current_, end_), n_));
using difference_type = range_difference_t<Base >;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>
&& convertible_to<sentinel_t<V>, sentinel_t<Base >>;
constexpr iterator_t<Base > base() const;
constexpr value_type operator*() const;
constexpr iterator & operator++();
constexpr iterator operator++(int);
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
constexpr value_type operator[](difference_type n) const
requires random_access_range<Base >;
§ 25.7.29.7 © ISO/IEC
1370

===== PAGE 1382 =====

Dxxxx
friend constexpr bool operator==(const iterator & x, const iterator & y);
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > &&
three_way_comparable<iterator_t<Base >>;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
friend constexpr difference_type operator-(default_sentinel_t y, const iterator & x)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
friend constexpr difference_type operator-(const iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If Base models random_access_range, theniterator_concept denotes random_access_iterator_-
tag.
—(1.2) Otherwise, ifBase models bidirectional_range, theniterator_concept denotes bidirectional_-
iterator_tag.
—(1.3) Otherwise, iterator_concept denotes forward_iterator_tag.
constexpr iterator (Parent * parent, iterator_t<Base > current,
range_difference_t<Base > missing = 0);
2 Effects: Initializescurrent_ with current, end_ with ranges::end(parent->base_), n_ with parent
->n_, andmissing_ with missing.
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>
&& convertible_to<sentinel_t<V>, sentinel_t<Base >>;
3 Effects: Initializes current_ with std::move(i.current_), end_ with std::move(i.end_), n_ with
i.n_, andmissing_ with i.missing_.
constexpr iterator_t<Base > base() const;
4 Returns: current_.
constexpr value_type operator*() const;
5 Preconditions: current_ != end_ is true.
6 Returns: views::take(subrange(current_, end_), n_).
constexpr iterator & operator++();
7 Preconditions: current_ != end_ is true.
8 Effects: Equivalent to:
missing_ = ranges::advance(current_, n_, end_);
§ 25.7.29.7 © ISO/IEC
1371

===== PAGE 1383 =====

Dxxxx
return *this;
constexpr iterator operator++(int);
9 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
10 Effects: Equivalent to:
ranges::advance(current_, missing_ - n_);
missing_ = 0;
return *this;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
11 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
12 Preconditions: If x is positive,ranges::distance(current_, end_) > n_ * (x - 1) is true.
[Note 1: If x is negative, theEffects paragraph implies a precondition.—end note]
13 Effects: Equivalent to:
if (x > 0) {
ranges::advance(current_, n_ * (x - 1));
missing_ = ranges::advance(current_, n_, end_);
} else if (x < 0) {
ranges::advance(current_, n_ * x + missing_);
missing_ = 0;
}
return *this;
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
14 Effects: Equivalent to:return *this += -x;
constexpr value_type operator[](difference_type n) const
requires random_access_range<Base >;
15 Returns: *(*this + n).
friend constexpr bool operator==(const iterator & x, const iterator & y);
16 Returns: x.current_ == y.current_.
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
17 Returns: x.current_ == x.end_.
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
18 Returns: x.current_ < y.current_.
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
19 Effects: Equivalent to:return y < x;
§ 25.7.29.7 © ISO/IEC
1372

===== PAGE 1384 =====

Dxxxx
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
20 Effects: Equivalent to:return !(y < x);
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
21 Effects: Equivalent to:return !(x < y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > &&
three_way_comparable<iterator_t<Base >>;
22 Returns: x.current_ <=> y.current_.
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
23 Effects: Equivalent to:
auto r = i;
r += n;
return r;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
24 Effects: Equivalent to:
auto r = i;
r -= n;
return r;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
25 Returns: (x.current_ - y.current_ + x.missing_ - y.missing_) / x.n_.
friend constexpr difference_type operator-(default_sentinel_t y, const iterator & x)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
26 Returns: div-ceil (x.end_ - x.current_, x.n_).
friend constexpr difference_type operator-(const iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
27 Effects: Equivalent to:return -(y - x);
25.7.30 Slide view [range.slide]
25.7.30.1 Overview [range.slide.overview]
1 slide_view takes a view and a numberN and produces a view whoseMth element is a view over theMth
through (M + N −1)th elements of the original view. If the original view has fewer thanN elements, the
resulting view is empty.
2 The name views::slide denotes a range adaptor object (25.7.2). Given subexpressions E and N, the
expression views::slide(E, N) is expression-equivalent toslide_view(E, N).
[Example 1:
vector v = {1, 2, 3, 4};
for (auto i : v | views::slide(2)) {
cout << '[' << i[0] << ", " << i[1] << "] "; // prints[1, 2] [2, 3] [3, 4]
}
—end example]
§ 25.7.30.1 © ISO/IEC
1373

===== PAGE 1385 =====

Dxxxx
25.7.30.2 Class template slide_view [range.slide.view]
namespace std::ranges {
template<class V>
concept slide-caches-nothing = random_access_range<V> && sized_range<V>; // exposition only
template<class V>
concept slide-caches-last = // exposition only
!slide-caches-nothing <V> && bidirectional_range<V> && common_range<V>;
template<class V>
concept slide-caches-first = // exposition only
!slide-caches-nothing <V> && !slide-caches-last <V>;
template<forward_range V>
requires view<V>
class slide_view : public view_interface<slide_view<V>> {
V base_; // exposition only
range_difference_t<V> n_; // exposition only
// 25.7.30.3, class templateslide_view::iterator
template<bool> class iterator ; // exposition only
// 25.7.30.4, classslide_view::sentinel
class sentinel ; // exposition only
public:
constexpr explicit slide_view(V base, range_difference_t<V> n);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin()
requires (!(simple-view <V> && slide-caches-nothing <const V>));
constexpr auto begin() const requires slide-caches-nothing <const V>;
constexpr auto end()
requires (!(simple-view <V> && slide-caches-nothing <const V>));
constexpr auto end() const requires slide-caches-nothing <const V>;
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
};
template<class R>
slide_view(R&&, range_difference_t<R>) -> slide_view<views::all_t<R>>;
}
constexpr explicit slide_view(V base, range_difference_t<V> n);
1 Preconditions: n > 0 is true.
2 Effects: Initializes base_ with std::move(base) and n_ with n.
constexpr auto begin()
requires (!(simple-view <V> && slide-caches-nothing <const V>));
3 Returns:
—(3.1) If V models slide-caches-first ,
iterator <false>(ranges::begin(base_),
ranges::next(ranges::begin(base_), n_ - 1, ranges::end(base_)), n_)
—(3.2) Otherwise, iterator <false>(ranges::begin(base_), n_).
§ 25.7.30.2 © ISO/IEC
1374

===== PAGE 1386 =====

Dxxxx
4 Remarks: In order to provide the amortized constant-time complexity required by therange concept,
this function caches the result within theslide_view for use on subsequent calls whenV models
slide-caches-first .
constexpr auto begin() const requires slide-caches-nothing <const V>;
5 Returns: iterator <true>(ranges::begin(base_), n_).
constexpr auto end()
requires (!(simple-view <V> && slide-caches-nothing <const V>));
6 Returns:
—(6.1) If V models slide-caches-nothing ,
iterator <false>(ranges::begin(base_) + range_difference_t<V>(size()), n_)
—(6.2) Otherwise, ifV models slide-caches-last ,
iterator <false>(ranges::prev(ranges::end(base_), n_ - 1, ranges::begin(base_)), n_)
—(6.3) Otherwise, ifV models common_range,
iterator <false>(ranges::end(base_), ranges::end(base_), n_)
—(6.4) Otherwise, sentinel (ranges::end(base_)).
7 Remarks: In order to provide the amortized constant-time complexity required by therange concept,
this function caches the result within theslide_view for use on subsequent calls whenV models
slide-caches-last .
constexpr auto end() const requires slide-caches-nothing <const V>;
8 Returns: begin() + range_difference_t<const V>(size()).
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
9 Effects: Equivalent to:
auto sz = ranges::distance(base_) - n_ + 1;
if (sz < 0) sz = 0;
return to-unsigned-like (sz);
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
10 Effects: Equivalent to:
auto sz = static_cast<range_difference_t<decltype((base_))>>(ranges::reserve_hint(base_)) -
n_ + 1;
if (sz < 0) sz = 0;
return to-unsigned-like (sz);
25.7.30.3 Class template slide_view::iterator [range.slide.iterator]
namespace std::ranges {
template<forward_range V>
requires view<V>
template<bool Const>
class slide_view<V>::iterator {
using Base = maybe-const <Const, V>; // exposition only
iterator_t<Base > current_ = iterator_t<Base >(); // exposition only
iterator_t<Base > last_ele_ = iterator_t<Base >(); // exposition only,
// present only ifBase models slide-caches-first
range_difference_t<Base > n_ = 0; // exposition only
constexpr iterator (iterator_t<Base > current, range_difference_t<Base > n) // exposition only
requires (!slide-caches-first <Base >);
constexpr iterator (iterator_t<Base > current, iterator_t<Base > last_ele, // exposition only
range_difference_t<Base > n)
requires slide-caches-first <Base >;
§ 25.7.30.3 © ISO/IEC
1375

===== PAGE 1387 =====

Dxxxx
public:
using iterator_category = input_iterator_tag;
using iterator_concept = see below ;
using value_type = decltype(views::counted(current_, n_));
using difference_type = range_difference_t<Base >;
iterator () = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
constexpr auto operator*() const;
constexpr iterator & operator++();
constexpr iterator operator++(int);
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
constexpr auto operator[](difference_type n) const
requires random_access_range<Base >;
friend constexpr bool operator==(const iterator & x, const iterator & y);
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > &&
three_way_comparable<iterator_t<Base >>;
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If Base models random_access_range, theniterator_concept denotes random_access_iterator_-
tag.
—(1.2) Otherwise, ifBase models bidirectional_range, theniterator_concept denotes bidirectional_-
iterator_tag.
—(1.3) Otherwise, iterator_concept denotes forward_iterator_tag.
2 If the invocation of any non-const member function ofiterator exits via an exception, theiterator
acquires a singular value.
constexpr iterator (iterator_t<Base > current, range_difference_t<Base > n)
requires (!slide-caches-first <Base >);
3 Effects: Initializes current_ with current and n_ with n.
§ 25.7.30.3 © ISO/IEC
1376

===== PAGE 1388 =====

Dxxxx
constexpr iterator (iterator_t<Base > current, iterator_t<Base > last_ele,
range_difference_t<Base > n)
requires slide-caches-first <Base >;
4 Effects: Initializes current_ with current, last_ele_ with last_ele, andn_ with n.
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
5 Effects: Initializes current_ with std::move(i.current_) and n_ with i.n_.
[Note 1: iterator <true> can only be formed when Base models slide-caches-nothing , in which case
last_ele_ is not present. —end note]
constexpr auto operator*() const;
6 Returns: views::counted(current_, n_).
constexpr iterator & operator++();
7 Preconditions: current_ and last_ele_ (if present) are incrementable.
8 Postconditions: current_ and last_ele_ (if present) are each equal toranges::next(i), wherei is
the value of that data member before the call.
9 Returns: *this.
constexpr iterator operator++(int);
10 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
11 Preconditions: current_ and last_ele_ (if present) are decrementable.
12 Postconditions: current_ and last_ele_ (if present) are each equal toranges::prev(i), wherei is
the value of that data member before the call.
13 Returns: *this.
constexpr iterator operator--(int) requires bidirectional_range<Base >;
14 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type x)
requires random_access_range<Base >;
15 Preconditions: current_ + x and last_ele_ + x (if last_ele_ is present) have well-defined behavior.
16 Postconditions: current_ and last_ele_ (if present) are each equal toi + x, wherei is the value of
that data member before the call.
17 Returns: *this.
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
18 Preconditions: current_ - x and last_ele_ - x (if last_ele_ is present) have well-defined behavior.
19 Postconditions: current_ and last_ele_ (if present) are each equal toi - x, wherei is the value of
that data member before the call.
20 Returns: *this.
constexpr auto operator[](difference_type n) const
requires random_access_range<Base >;
21 Effects: Equivalent to:return views::counted(current_ + n, n_);
§ 25.7.30.3 © ISO/IEC
1377

===== PAGE 1389 =====

Dxxxx
friend constexpr bool operator==(const iterator & x, const iterator & y);
22 Returns: If last_ele_ is present,x.last_ele_ == y.last_ele_; otherwise,x.current_ == y.cur-
rent_.
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
23 Returns: x.current_ < y.current_.
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
24 Effects: Equivalent to:return y < x;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
25 Effects: Equivalent to:return !(y < x);
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
26 Effects: Equivalent to:return !(x < y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > &&
three_way_comparable<iterator_t<Base >>;
27 Returns: x.current_ <=> y.current_.
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
28 Effects: Equivalent to:
auto r = i;
r += n;
return r;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
29 Effects: Equivalent to:
auto r = i;
r -= n;
return r;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
30 Returns: If last_ele_ is present, x.last_ele_ - y.last_ele_; otherwise, x.current_ - y.cur-
rent_.
25.7.30.4 Class slide_view::sentinel [range.slide.sentinel]
namespace std::ranges {
template<forward_range V>
requires view<V>
class slide_view<V>::sentinel {
sentinel_t<V> end_ = sentinel_t<V>(); // exposition only
constexpr explicit sentinel (sentinel_t<V> end); // exposition only
public:
sentinel () = default;
friend constexpr bool operator==(const iterator <false>& x, const sentinel & y);
§ 25.7.30.4 © ISO/IEC
1378

===== PAGE 1390 =====

Dxxxx
friend constexpr range_difference_t<V>
operator-(const iterator <false>& x, const sentinel & y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
friend constexpr range_difference_t<V>
operator-(const sentinel & y, const iterator <false>& x)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
};
}
1 [Note 1: sentinel is used only whenslide-caches-first <V> is true. —end note]
constexpr explicit sentinel (sentinel_t<V> end);
2 Effects: Initializes end_ with end.
friend constexpr bool operator==(const iterator <false>& x, const sentinel & y);
3 Returns: x.last_ele_ == y.end_.
friend constexpr range_difference_t<V>
operator-(const iterator <false>& x, const sentinel & y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
4 Returns: x.last_ele_ - y.end_.
friend constexpr range_difference_t<V>
operator-(const sentinel & y, const iterator <false>& x)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
5 Returns: y.end_ - x.last_ele_.
25.7.31 Chunk by view [range.chunk.by]
25.7.31.1 Overview [range.chunk.by.overview]
1 chunk_by_view takes a view and a predicate, and splits the view intosubranges between each pair of
adjacent elements for which the predicate returnsfalse.
2 The nameviews::chunk_by denotes a range adaptor object (25.7.2). Given subexpressionsE and F, the
expression views::chunk_by(E, F) is expression-equivalent tochunk_by_view(E, F).
[Example 1:
vector v = {1, 2, 2, 3, 0, 4, 5, 2};
for (auto r : v | views::chunk_by(ranges::less_equal{})) {
cout << '[';
auto sep = "";
for (auto i : r) {
cout << sep << i;
sep = ", ";
}
cout << "] ";
}
// The above prints[1, 2, 2, 3] [0, 4, 5] [2]
—end example]
25.7.31.2 Class template chunk_by_view [range.chunk.by.view]
namespace std::ranges {
template<forward_range V, indirect_binary_predicate<iterator_t<V>, iterator_t<V>> Pred>
requires view<V> && is_object_v<Pred>
class chunk_by_view : public view_interface<chunk_by_view<V, Pred>> {
V base_ = V(); // exposition only
movable-box<Pred> pred_; // exposition only
// 25.7.31.3, classchunk_by_view::iterator
class iterator; // exposition only
§ 25.7.31.2 © ISO/IEC
1379

===== PAGE 1391 =====

Dxxxx
public:
chunk_by_view() requires default_initializable<V> && default_initializable<Pred> = default;
constexpr explicit chunk_by_view(V base, Pred pred);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr const Pred& pred() const;
constexpr iterator begin();
constexpr auto end();
constexpr iterator_t<V> find-next(iterator_t<V>); // exposition only
constexpr iterator_t<V> find-prev(iterator_t<V>) // exposition only
requires bidirectional_range<V>;
};
template<class R, class Pred>
chunk_by_view(R&&, Pred) -> chunk_by_view<views::all_t<R>, Pred>;
}
constexpr explicit chunk_by_view(V base, Pred pred);
1 Effects: Initializes base_ with std::move(base) and pred_ with std::move(pred).
constexpr const Pred& pred() const;
2 Effects: Equivalent to:return *pred_;
constexpr iterator begin();
3 Preconditions: pred_.has_value() is true.
4 Returns: iterator (*this, ranges::begin(base_), find-next (ranges::begin(base_))).
5 Remarks: In order to provide the amortized constant-time complexity required by therange concept,
this function caches the result within thechunk_by_view for use on subsequent calls.
constexpr auto end();
6 Effects: Equivalent to:
if constexpr (common_range<V>) {
return iterator (*this, ranges::end(base_), ranges::end(base_));
} else {
return default_sentinel;
}
constexpr iterator_t<V> find-next (iterator_t<V> current);
7 Preconditions: pred_.has_value() is true.
8 Returns:
ranges::next(ranges::adjacent_find(current, ranges::end(base_), not_fn(ref(*pred_))),
1, ranges::end(base_))
constexpr iterator_t<V> find-prev (iterator_t<V> current) requires bidirectional_range<V>;
9 Preconditions:
—(9.1) current is not equal toranges::begin(base_).
—(9.2) pred_.has_value() is true.
10 Returns: An iteratori in the range[ranges::begin(base_),current) such that:
—(10.1) ranges::adjacent_find(i, current, not_fn(ref(*pred_))) is equal tocurrent; and
—(10.2) if i is not equal to ranges::begin(base_), then bool(invoke(*pred_, *ranges::prev(i),
*i)) is false.
§ 25.7.31.2 © ISO/IEC
1380

===== PAGE 1392 =====

Dxxxx
25.7.31.3 Class chunk_by_view::iterator [range.chunk.by.iter]
namespace std::ranges {
template<forward_range V, indirect_binary_predicate<iterator_t<V>, iterator_t<V>> Pred>
requires view<V> && is_object_v<Pred>
class chunk_by_view<V, Pred>::iterator {
chunk_by_view* parent_ = nullptr; // exposition only
iterator_t<V> current_ = iterator_t<V>(); // exposition only
iterator_t<V> next_ = iterator_t<V>(); // exposition only
constexpr iterator (chunk_by_view& parent, iterator_t<V> current, // exposition only
iterator_t<V> next);
public:
using value_type = subrange<iterator_t<V>>;
using difference_type = range_difference_t<V>;
using iterator_category = input_iterator_tag;
using iterator_concept = see below ;
iterator () = default;
constexpr value_type operator*() const;
constexpr iterator & operator++();
constexpr iterator operator++(int);
constexpr iterator & operator--() requires bidirectional_range<V>;
constexpr iterator operator--(int) requires bidirectional_range<V>;
friend constexpr bool operator==(const iterator & x, const iterator & y);
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If V models bidirectional_range, theniterator_concept denotes bidirectional_iterator_tag.
—(1.2) Otherwise, iterator_concept denotes forward_iterator_tag.
constexpr iterator (chunk_by_view& parent, iterator_t<V> current, iterator_t<V> next);
2 Effects: Initializes parent_ with addressof(parent), current_ with current, andnext_ with next.
constexpr value_type operator*() const;
3 Preconditions: current_ is not equal tonext_.
4 Returns: subrange(current_, next_).
constexpr iterator & operator++();
5 Preconditions: current_ is not equal tonext_.
6 Effects: Equivalent to:
current_ = next_;
next_ = parent_->find-next (current_);
return *this;
constexpr iterator operator++(int);
7 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<V>;
8 Effects: Equivalent to:
next_ = current_;
current_ = parent_->find-prev (next_);
§ 25.7.31.3 © ISO/IEC
1381

===== PAGE 1393 =====

Dxxxx
return *this;
constexpr iterator operator--(int) requires bidirectional_range<V>;
9 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
friend constexpr bool operator==(const iterator & x, const iterator & y);
10 Returns: x.current_ == y.current_.
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
11 Returns: x.current_ == x.next_.
25.7.32 Stride view [range.stride]
25.7.32.1 Overview [range.stride.overview]
1 stride_view presents a view of an underlying sequence, advancing overn elements at a time, as opposed to
the usual single-step succession.
2 The name views::stride denotes a range adaptor object (25.7.2). Given subexpressionsE and N, the
expression views::stride(E, N) is expression-equivalent tostride_view(E, N).
3 [Example 1:
auto input = views::iota(0, 12) | views::stride(3);
ranges::copy(input, ostream_iterator<int>(cout, " ")); // prints0 3 6 9
ranges::copy(input | views::reverse, ostream_iterator<int>(cout, " ")); // prints9 6 3 0
—end example]
25.7.32.2 Class template stride_view [range.stride.view]
namespace std::ranges {
template<input_range V>
requires view<V>
class stride_view : public view_interface<stride_view<V>> {
V base_; // exposition only
range_difference_t<V> stride_; // exposition only
// 25.7.32.3, class templatestride_view::iterator
template<bool> class iterator ; // exposition only
public:
constexpr explicit stride_view(V base, range_difference_t<V> stride);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr range_difference_t<V> stride() const noexcept;
constexpr auto begin() requires (!simple-view <V>) {
return iterator <false>(this, ranges::begin(base_));
}
constexpr auto begin() const requires range<const V> {
return iterator <true>(this, ranges::begin(base_));
}
constexpr auto end() requires (!simple-view <V>) {
if constexpr (common_range<V> && sized_range<V> && forward_range<V>) {
auto missing = (stride_ - ranges::distance(base_) % stride_) % stride_;
return iterator <false>(this, ranges::end(base_), missing);
} else if constexpr (common_range<V> && !bidirectional_range<V>) {
return iterator <false>(this, ranges::end(base_));
} else {
return default_sentinel;
}
§ 25.7.32.2 © ISO/IEC
1382

===== PAGE 1394 =====

Dxxxx
}
constexpr auto end() const requires range<const V> {
if constexpr (common_range<const V> && sized_range<const V> && forward_range<const V>) {
auto missing = (stride_ - ranges::distance(base_) % stride_) % stride_;
return iterator <true>(this, ranges::end(base_), missing);
} else if constexpr (common_range<const V> && !bidirectional_range<const V>) {
return iterator <true>(this, ranges::end(base_));
} else {
return default_sentinel;
}
}
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
};
template<class R>
stride_view(R&&, range_difference_t<R>) -> stride_view<views::all_t<R>>;
}
constexpr stride_view(V base, range_difference_t<V> stride);
1 Preconditions: stride > 0 is true.
2 Effects: Initializes base_ with std::move(base) and stride_ with stride.
constexpr range_difference_t<V> stride() const noexcept;
3 Returns: stride_.
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
4 Effects: Equivalent to:
return to-unsigned-like (div-ceil (ranges::distance(base_), stride_));
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
5 Effects: Equivalent to:
auto s = static_cast<range_difference_t<decltype((base_))>>(ranges::reserve_hint(base_));
return to-unsigned-like (div-ceil (s, stride_));
25.7.32.3 Class template stride_view::iterator [range.stride.iterator]
namespace std::ranges {
template<input_range V>
requires view<V>
template<bool Const>
class stride_view<V>::iterator {
using Parent = maybe-const <Const, stride_view>; // exposition only
using Base = maybe-const <Const, V>; // exposition only
iterator_t<Base > current_ = iterator_t<Base >(); // exposition only
sentinel_t<Base > end_ = sentinel_t<Base >(); // exposition only
range_difference_t<Base > stride_ = 0; // exposition only
range_difference_t<Base > missing_ = 0; // exposition only
constexpr iterator (Parent * parent, iterator_t<Base > current, // exposition only
range_difference_t<Base > missing = 0);
public:
using difference_type = range_difference_t<Base >;
using value_type = range_value_t<Base >;
§ 25.7.32.3 © ISO/IEC
1383

===== PAGE 1395 =====

Dxxxx
using iterator_concept = see below ;
using iterator_category = see below ; // not always present
iterator () requires default_initializable<iterator_t<Base >> = default;
constexpr iterator (iterator <!Const> other)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>
&& convertible_to<sentinel_t<V>, sentinel_t<Base >>;
constexpr iterator_t<Base > base() &&;
constexpr const iterator_t<Base >& base() const & noexcept;
constexpr decltype(auto) operator*() const { return *current_; }
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires forward_range<Base >;
constexpr iterator & operator--() requires bidirectional_range<Base >;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
constexpr iterator & operator+=(difference_type n) requires random_access_range<Base >;
constexpr iterator & operator-=(difference_type n) requires random_access_range<Base >;
constexpr decltype(auto) operator[](difference_type n) const
requires random_access_range<Base >
{ return *(*this + n); }
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<Base >>;
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<iterator_t<Base >>;
friend constexpr iterator operator+(const iterator & x, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & x)
requires random_access_range<Base >;
friend constexpr iterator operator-(const iterator & x, difference_type n)
requires random_access_range<Base >;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
friend constexpr difference_type operator-(default_sentinel_t y, const iterator & x)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
friend constexpr difference_type operator-(const iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
friend constexpr range_rvalue_reference_t<Base > iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
§ 25.7.32.3 © ISO/IEC
1384

===== PAGE 1396 =====

Dxxxx
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<Base >>;
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If Base models random_access_range, theniterator_concept denotes random_access_iterator_-
tag.
—(1.2) Otherwise, ifBase models bidirectional_range, theniterator_concept denotes bidirectional_-
iterator_tag.
—(1.3) Otherwise, if Base models forward_range, theniterator_concept denotes forward_iterator_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
2 The membertypedef-name iterator_category is defined if and only ifBase models forward_range. In
that case,iterator ::iterator_category is defined as follows:
—(2.1) Let C denote the typeiterator_traits<iterator_t<Base >>::iterator_category.
—(2.2) If C models derived_from<random_access_iterator_tag>, then iterator_category denotes ran-
dom_access_iterator_tag.
—(2.3) Otherwise, iterator_category denotes C.
constexpr iterator (Parent * parent, iterator_t<Base > current,
range_difference_t<Base > missing = 0);
3 Effects: Initializes current_ with std::move(current), end_ with ranges::end(parent->base_),
stride_ with parent->stride_, andmissing_ with missing.
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>
&& convertible_to<sentinel_t<V>, sentinel_t<Base >>;
4 Effects: Initializescurrent_ with std::move(i.current_), end_ with std::move(i.end_), stride_-
with i.stride_, andmissing_ with i.missing_.
constexpr iterator_t<Base > base() &&;
5 Returns: std::move(current_).
constexpr const iterator_t<Base >& base() const & noexcept;
6 Returns: current_.
constexpr iterator & operator++();
7 Preconditions: current_ != end_ is true.
8 Effects: Equivalent to:
missing_ = ranges::advance(current_, stride_, end_);
return *this;
constexpr void operator++(int);
9 Effects: Equivalent to++*this;
constexpr iterator operator++(int) requires forward_range<Base >;
10 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--() requires bidirectional_range<Base >;
11 Effects: Equivalent to:
ranges::advance(current_, missing_ - stride_);
missing_ = 0;
§ 25.7.32.3 © ISO/IEC
1385

===== PAGE 1397 =====

Dxxxx
return *this;
constexpr iterator operator--(int) requires bidirectional_range<Base >;
12 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type n) requires random_access_range<Base >;
13 Preconditions: If n is positive,ranges::distance(current_, end_) > stride_ * (n - 1) is true.
[Note 1: If n is negative, theEffects paragraph implies a precondition.—end note]
14 Effects: Equivalent to:
if (n > 0) {
ranges::advance(current_, stride_ * (n - 1));
missing_ = ranges::advance(current_, stride_, end_);
} else if (n < 0) {
ranges::advance(current_, stride_ * n + missing_);
missing_ = 0;
}
return *this;
constexpr iterator & operator-=(difference_type x)
requires random_access_range<Base >;
15 Effects: Equivalent to:return *this += -x;
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
16 Returns: x.current_ == x.end_.
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<Base >>;
17 Returns: x.current_ == y.current_.
friend constexpr bool operator<(const iterator & x, const iterator & y)
requires random_access_range<Base >;
18 Returns: x.current_ < y.current_.
friend constexpr bool operator>(const iterator & x, const iterator & y)
requires random_access_range<Base >;
19 Effects: Equivalent to:return y < x;
friend constexpr bool operator<=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
20 Effects: Equivalent to:return !(y < x);
friend constexpr bool operator>=(const iterator & x, const iterator & y)
requires random_access_range<Base >;
21 Effects: Equivalent to:return !(x < y);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires random_access_range<Base > && three_way_comparable<iterator_t<Base >>;
22 Returns: x.current_ <=> y.current_.
friend constexpr iterator operator+(const iterator & i, difference_type n)
requires random_access_range<Base >;
friend constexpr iterator operator+(difference_type n, const iterator & i)
requires random_access_range<Base >;
23 Effects: Equivalent to:
auto r = i;
r += n;
§ 25.7.32.3 © ISO/IEC
1386

===== PAGE 1398 =====

Dxxxx
return r;
friend constexpr iterator operator-(const iterator & i, difference_type n)
requires random_access_range<Base >;
24 Effects: Equivalent to:
auto r = i;
r -= n;
return r;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires sized_sentinel_for<iterator_t<Base >, iterator_t<Base >>;
25 Returns: Let N be (x.current_ - y.current_).
—(25.1) If Base models forward_range, (N + x.missing_ - y.missing_) / x.stride_.
—(25.2) Otherwise, ifN is negative,-div-ceil (-N, x.stride_).
—(25.3) Otherwise, div-ceil (N, x.stride_).
friend constexpr difference_type operator-(default_sentinel_t y, const iterator & x)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
26 Returns: div-ceil (x.end_ - x.current_, x.stride_).
friend constexpr difference_type operator-(const iterator & x, default_sentinel_t y)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
27 Effects: Equivalent to:return -(y - x);
friend constexpr range_rvalue_reference_t<Base > iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
28 Effects: Equivalent to:return ranges::iter_move(i.current_);
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<Base >>;
29 Effects: Equivalent to:ranges::iter_swap(x.current_, y.current_);
25.7.33 Cartesian product view [range.cartesian]
25.7.33.1 Overview [range.cartesian.overview]
1 cartesian_product_view takes any non-zero number of rangesn and produces a view of tuples calculated
by then-ary cartesian product of the provided ranges.
2 The nameviews::cartesian_product denotes a customization point object (16.3.3.3.5). Given a pack of
subexpressions Es, the expressionviews::cartesian_product(Es...) is expression-equivalent to
—(2.1) views::single(tuple()) if Es is an empty pack,
—(2.2) otherwise, cartesian_product_view<views::all_t<decltype((Es))>...>(Es...).
3 [Example 1:
vector<int> v { 0, 1, 2 };
for (auto&& [a, b, c] : views::cartesian_product(v, v, v)) {
cout << a << ' ' << b << ' ' << c << '\n';
}
// The above prints
// 0 0 0
// 0 0 1
// 0 0 2
// 0 1 0
// 0 1 1
// ...
—end example]
§ 25.7.33.1 © ISO/IEC
1387

===== PAGE 1399 =====

Dxxxx
25.7.33.2 Class template cartesian_product_view [range.cartesian.view]
namespace std::ranges {
template<bool Const, class First, class... Vs>
concept cartesian-product-is-random-access = // exposition only
(random_access_range<maybe-const <Const, First>> && ... &&
(random_access_range<maybe-const <Const, Vs>>
&& sized_range<maybe-const <Const, Vs>>));
template<class R>
concept cartesian-product-common-arg = // exposition only
common_range<R> || (sized_range<R> && random_access_range<R>);
template<bool Const, class First, class... Vs>
concept cartesian-product-is-bidirectional = // exposition only
(bidirectional_range<maybe-const <Const, First>> && ... &&
(bidirectional_range<maybe-const <Const, Vs>>
&& cartesian-product-common-arg <maybe-const <Const, Vs>>));
template<class First, class...>
concept cartesian-product-is-common = // exposition only
cartesian-product-common-arg <First>;
template<class... Vs>
concept cartesian-product-is-sized = // exposition only
(sized_range<Vs> && ...);
template<bool Const, template<class> class FirstSent, class First, class... Vs>
concept cartesian-is-sized-sentinel = // exposition only
(sized_sentinel_for<FirstSent<maybe-const <Const, First>>,
iterator_t<maybe-const <Const, First>>> && ...
&& (sized_range<maybe-const <Const, Vs>>
&& sized_sentinel_for<iterator_t<maybe-const <Const, Vs>>,
iterator_t<maybe-const <Const, Vs>>>));
template<cartesian-product-common-arg R>
constexpr auto cartesian-common-arg-end (R& r) { // exposition only
if constexpr (common_range<R>) {
return ranges::end(r);
} else {
return ranges::begin(r) + ranges::distance(r);
}
}
template<input_range First, forward_range... Vs>
requires (view<First> && ... && view<Vs>)
class cartesian_product_view : public view_interface<cartesian_product_view<First, Vs...>> {
private:
tuple<First, Vs...> bases_; // exposition only
// 25.7.33.3, class templatecartesian_product_view::iterator
template<bool Const> class iterator ; // exposition only
public:
constexpr cartesian_product_view() = default;
constexpr explicit cartesian_product_view(First first_base, Vs... bases);
constexpr iterator <false> begin()
requires (!simple-view <First> || ... || !simple-view <Vs>);
constexpr iterator <true> begin() const
requires (range<const First> && ... && range<const Vs>);
constexpr iterator <false> end()
requires ((!simple-view <First> || ... || !simple-view <Vs>) &&
cartesian-product-is-common <First, Vs...>);
§ 25.7.33.2 © ISO/IEC
1388

===== PAGE 1400 =====

Dxxxx
constexpr iterator <true> end() const
requires cartesian-product-is-common <const First, const Vs...>;
constexpr default_sentinel_t end() const noexcept;
constexpr see below size()
requires cartesian-product-is-sized <First, Vs...>;
constexpr see below size() const
requires cartesian-product-is-sized <const First, const Vs...>;
};
template<class... Vs>
cartesian_product_view(Vs&&...) -> cartesian_product_view<views::all_t<Vs>...>;
}
constexpr explicit cartesian_product_view(First first_base, Vs... bases);
1 Effects: Initializes bases_ with std::move(first_base), std::move(bases)....
constexpr iterator <false> begin()
requires (!simple-view <First> || ... || !simple-view <Vs>);
2 Effects: Equivalent to:
return iterator <false>(*this, tuple-transform (ranges::begin, bases_));
constexpr iterator <true> begin() const
requires (range<const First> && ... && range<const Vs>);
3 Effects: Equivalent to:
return iterator <true>(*this, tuple-transform (ranges::begin, bases_));
constexpr iterator <false> end()
requires ((!simple-view <First> || ... || !simple-view <Vs>)
&& cartesian-product-is-common <First, Vs...>);
constexpr iterator <true> end() const
requires cartesian-product-is-common <const First, const Vs...>;
4 Let:
—(4.1) is-const be true for the const-qualified overload, andfalse otherwise;
—(4.2) is-empty be trueiftheexpression ranges::empty(rng)istrueforany rngamongtheunderlying
ranges except the first one andfalse otherwise; and
—(4.3) begin-or-first-end (rng) be expression-equivalent tois-empty ? ranges::begin(rng) :
cartesian-common-arg-end (rng) if rng is the first underlying range andranges::begin(rng)
otherwise.
5 Effects: Equivalent to:
iterator <is-const > it(*this, tuple-transform (
[](auto& rng){ return begin-or-first-end (rng); }, bases_));
return it;
constexpr default_sentinel_t end() const noexcept;
6 Returns: default_sentinel.
constexpr see below size()
requires cartesian-product-is-sized <First, Vs...>;
constexpr see below size() const
requires cartesian-product-is-sized <const First, const Vs...>;
7 The return type is an implementation-defined unsigned-integer-like type.
8 Recommended practice: The return type should be the smallest unsigned-integer-like type that is
sufficiently wide to store the product of the maximum sizes of all the underlying ranges, if such a type
exists.
9 Let p be the product of the sizes of all the ranges inbases_.
10 Preconditions: p can be represented by the return type.
§ 25.7.33.2 © ISO/IEC
1389