

===== PAGE 801 =====

Dxxxx
// does not include base
static_assert( // all of the above,
members_of(^^S, access_context::unchecked()).size() == 8); // as well as a reflection
// representingS::I
—end example]
consteval vector<info> bases_of(info type, access_context ctx);
7 Returns: Let C be the class represented bydealias(type). A vector containing the reflections of all
the direct base class relationshipsB, if any, ofC such thatis_accessible(^^B, ctx) is true. The
direct base class relationships appear in the order in which the corresponding base classes appear in
the base-specifier-list of C.
8 Throws: meta::exception unless dealias(type) represents a class type that is complete from some
point in the evaluation context.
consteval vector<info> static_data_members_of(info type, access_context ctx);
9 Returns: A vector containing each elemente of members_of(type, ctx) such thatis_variable(e)
is true, preserving their order.
10 Throws: meta::exception unless dealias(type) represents a class type that is complete from some
point in the evaluation context.
consteval vector<info> nonstatic_data_members_of(info type, access_context ctx);
11 Returns: A vector containing each elemente of members_of(type, ctx) such thatis_nonstatic_-
data_member(e) is true, preserving their order.
12 Throws: meta::exception unless dealias(type) represents a class type that is complete from some
point in the evaluation context.
consteval vector<info> subobjects_of(info type, access_context ctx);
13 Returns: A vector containing each element ofbases_of(type, ctx) followed by each element of
nonstatic_data_members_of(type, ctx), preserving their order.
14 Throws: meta::exception unless dealias(type) represents a class type that is complete from some
point in the evaluation context.
consteval vector<info> enumerators_of(info type_enum);
15 Returns: A vector containing the reflections of each enumerator of the enumeration represented by
dealias(type_enum), in the order in which they are declared.
16 Throws: meta::exception unless dealias(type_enum) represents an enumeration type, andis_-
enumerable_type(type_enum) is true.
21.4.11 Reflection layout queries [meta.reflection.layout]
struct member_offset {
ptrdiff_t bytes;
ptrdiff_t bits;
constexpr ptrdiff_t total_bits() const;
auto operator<=>(const member_offset&) const = default;
};
constexpr ptrdiff_t member_offset::total_bits() const;
1 Returns: bytes * CHAR_BIT + bits.
consteval member_offset offset_of(info r);
2 Let V be the offset in bits from the beginning of a complete object of the type represented by
parent_of(r) to the subobject associated with the construct represented byr.
3 Returns: {V / CHAR_BIT, V % CHAR_BIT}.
4 Throws: meta::exception unless r represents a non-static data member, unnamed bit-field, or direct
base class relationship(D,B) for which eitherB is not a virtual base class orD is not an abstract class.
§ 21.4.11 © ISO/IEC
790

===== PAGE 802 =====

Dxxxx
consteval size_t size_of(info r);
5 Returns: If
—(5.1) r represents a non-static data member of typeT or a data member description(T,N,A,W, NUA)
or
—(5.2) dealias(r) represents a typeT,
then sizeof(T) if T is not a reference type andsize_of(add_pointer(^^T)) otherwise. Otherwise,
size_of(type_of(r)).
[Note 1: It is possible that whilesizeof(char) == size_of(^^char) is true, thatsizeof(char&) == size_-
of(^^char&) is false. If b represents a direct base class relationship of an empty base class, thensize_of(b)
> 0 is true. —end note]
6 Throws: meta::exception unless all of the following conditions are met:
—(6.1) dealias(r) is a reflection of a type, object, value, variable of non-reference type, non-static
data member that is not a bit-field, direct base class relationship, or data member description
(T,N,A,W, NUA) (11.4.1) whereW is ⊥.
—(6.2) If dealias(r) represents a type, thenis_complete_type(r) is true.
consteval size_t alignment_of(info r);
7 Returns:
—(7.1) If dealias(r) represents a typeT, thenalignment_of(add_pointer(r)) if T is a reference type
and the alignment requirement ofT otherwise.
—(7.2) Otherwise, ifdealias(r) represents a variable or object, then the alignment requirement of the
variable or object.
—(7.3) Otherwise, ifr represents a direct base class relationship, thenalignment_of(type_of(r)).
—(7.4) Otherwise, ifr represents a non-static data memberM of a classC, then the alignment of the
direct member subobject corresponding toM of a complete object of typeC.
—(7.5) Otherwise, r represents a data member description(T,N,A,W, NUA) (11.4.1). IfAis not⊥, then
the valueA. Otherwise, alignment_of(^^T).
8 Throws: meta::exception unless all of the following conditions are met:
—(8.1) dealias(r) is a reflection of a type, object, variable of non-reference type, non-static data member
that is not a bit-field, direct base class relationship, or data member description(T,N,A,W, NUA)
(11.4.1) whereW is ⊥.
—(8.2) If dealias(r) represents a type, thenis_complete_type(r) is true.
consteval size_t bit_size_of(info r);
9 Returns:
—(9.1) If r represents an unnamed bit-field or a non-static data member that is a bit-field with widthW,
then W.
—(9.2) Otherwise, if r represents a data member description(T,N,A,W, NUA) (11.4.1) andW is not⊥,
then W.
—(9.3) Otherwise, CHAR_BIT * size_of(r).
10 Throws: meta::exception unless all of the following conditions are met:
—(10.1) dealias(r) is a reflection of a type, object, value, variable of non-reference type, non-static data
member, unnamed bit-field, direct base class relationship, or data member description.
—(10.2) If dealias(r) represents a type, thenis_complete_type(r) is true.
21.4.12 Annotation reflection [meta.reflection.annotation]
consteval vector<info> annotations_of(info item);
1 Let E be
—(1.1) the correspondingbase-specifier if item represents a direct base class relationship,
§ 21.4.12 © ISO/IEC
791

===== PAGE 803 =====

Dxxxx
—(1.2) otherwise, the entity represented byitem.
2 Returns: A vector containing all of the reflectionsR representing each annotation applying to each
declaration ofE that precedes either some point in the evaluation context (7.7) or a point immediately
following theclass-specifier of the outermost class for which such a point is in a complete-class context.
For any two reflectionsR1 and R2 in the returnedvector, if the annotation represented byR1 precedes
the annotation represented byR2, thenR1 appears before R2. If R1 and R2 represent annotations
from the same translation unitT, any element in the returnedvector between R1 and R2 represents
an annotation fromT.
[Note 1: The order in which two annotations appear is otherwise unspecified.—end note]
3 Throws: meta::exception unless item represents a type, type alias, variable, function, namespace,
enumerator, direct base class relationship, or non-static data member.
4 [Example 1:
[[=1]] void f();
[[=2, =3]] void g();
void g [[=4]] ();
static_assert(annotations_of(^^f).size() == 1);
static_assert(annotations_of(^^g).size() == 3);
static_assert([: constant_of(annotations_of(^^g)[0]) :] == 2);
static_assert(extract<int>(annotations_of(^^g)[1]) == 3);
static_assert(extract<int>(annotations_of(^^g)[2]) == 4);
struct Option { bool value; };
struct C {
[[=Option{true}]] int a;
[[=Option{false}]] int b;
};
static_assert(extract<Option>(annotations_of(^^C::a)[0]).value);
static_assert(!extract<Option>(annotations_of(^^C::b)[0]).value);
template<class T>
struct [[=42]] D { };
constexpr std::meta::info a1 = annotations_of(^^D<int>)[0];
constexpr std::meta::info a2 = annotations_of(^^D<char>)[0];
static_assert(a1 != a2);
static_assert(constant_of(a1) == constant_of(a2));
[[=1]] int x, y;
static_assert(annotations_of(^^x)[0] == annotations_of(^^y)[0]);
—end example]
consteval vector<info> annotations_of_with_type(info item, info type);
5 Returns: A vector containing each elemente of annotations_of(item) where
remove_const(type_of(e)) == remove_const(type)
is true, preserving their order.
6 Throws: meta::exception unless
—(6.1) the evaluation ofannotations_of(item) would not exit via an exception and
—(6.2) dealias(type) represents a type andis_complete_type(type) is true.
21.4.13 Value extraction [meta.reflection.extract]
1 The extract function template may be used to extract a value out of a reflection when its type is known.
2 The following are defined for exposition only to aid in the specification ofextract.
§ 21.4.13 © ISO/IEC
792

===== PAGE 804 =====

Dxxxx
template<class T>
consteval T extract-ref (info r); // exposition only
3 [Note 1: T is a reference type.—end note]
4 Returns: If r represents an objectO, then a reference toO. Otherwise, a reference to the object
declared, or referred to, by the variable represented byr.
5 Throws: meta::exception unless
—(5.1) r represents a variable or object of typeU,
—(5.2) is_convertible_v<remove_reference_t<U>(*)[], remove_reference_t<T>(*)[]> is true,
and
[Note 2: The intent is to allow only qualification conversion fromU to T. —end note]
—(5.3) If r represents a variable, then either that variable is usable in constant expressions or its lifetime
began within the core constant expression currently under evaluation.
template<class T>
consteval T extract-member-or-function (info r); // exposition only
6 Returns:
—(6.1) If T is a pointer type, then a pointer value pointing to the function represented byr.
—(6.2) Otherwise, a pointer-to-member value designating the non-static data member or function repre-
sented byr.
7 Throws: meta::exception unless
—(7.1) r represents a non-static data member with typeX, that is not a bit-field, that is a direct member
of classC, T and X C::* are similar types (7.3.6), andis_convertible_v<X C::*, T> is true;
—(7.2) r represents an implicit object member function with typeF or F noexcept that is a direct member
of a classC, andT is F C::*; or
—(7.3) r represents a non-member function, static member function, or explicit object member function
of function typeF or F noexcept, andT is F*.
template<class T>
consteval T extract-value (info r); // exposition only
8 Let U be the type of the value or object thatr represents.
9 Returns: static_cast<T>([:R:]), whereR is a constant expression of typeinfo such thatR == r
is true.
10 Throws: meta::exception unless
—(10.1) U is a pointer type,T and U are either similar (7.3.6) or both function pointer types, andis_-
convertible_v<U, T> is true,
—(10.2) U is not a pointer type and the cv-unqualified types ofT and U are the same,
—(10.3) U is an array type,T is a pointer type,remove_extent_t<U>* and T are similar types, and the
value r represents is convertible toT, or
—(10.4) U is a closure type,T is a function pointer type, and the value thatr represents is convertible toT.
template<class T>
consteval T extract(info r);
11 Let U be remove_cv_t<T>.
12 Effects: Equivalent to:
if constexpr (is_reference_type(^^T)) {
return extract-ref <T>(r);
} else if (is_nonstatic_data_member(r) || is_function(r)) {
return extract-member-or-function <U>(r);
} else {
return extract-value <U>(constant_of(r));
}
§ 21.4.13 © ISO/IEC
793

===== PAGE 805 =====

Dxxxx
21.4.14 Reflection substitution [meta.reflection.substitute]
1 Let TARG-SPLICE (x) be:
—(1.1) template [: x :] if is_template(x) is true, otherwise
—(1.2) typename [: x :] if is_type(x) is true, otherwise
—(1.3) ([: x :]).
template<class R>
concept reflection_range =
ranges::input_range<R> &&
same_as<ranges::range_value_t<R>, info> &&
same_as<remove_cvref_t<ranges::range_reference_t<R>>, info>;
template<reflection_range R = initializer_list<info>>
consteval bool can_substitute(info templ, R&& arguments);
2 Let Z be the template represented by templ and let Args... be a sequence of prvalue constant
expressions that compute the reflections held by the elements ofarguments, in order.
3 Returns: true if Z<TARG-SPLICE (Args)...> is a validtemplate-id (13.3) that does not name a function
whose type contains an undeduced placeholder type. Otherwise,false.
4 Throws: meta::exception unless templ represents a template, and every reflection inarguments
represents a construct usable as a template argument (13.4).
5 [Note 1: If formingZ<TARG-SPLICE (Args)...> leads to a failure outside of the immediate context, the program
is ill-formed. —end note]
template<reflection_range R = initializer_list<info>>
consteval info substitute(info templ, R&& arguments);
6 Let Z be the template represented by templ and let Args... be a sequence of prvalue constant
expressions that compute the reflections held by the elements ofarguments, in order.
7 Returns: ^^Z<TARG-SPLICE (Args)...>.
8 Throws: meta::exception unless can_substitute(templ, arguments) is true.
9 [Note 2: If formingZ<TARG-SPLICE (Args)...> leads to a failure outside of the immediate context, the program
is ill-formed. —end note]
10 [Example 1:
template<class T>
auto fn1();
static_assert(!can_substitute(^^fn1, {^^int})); // OK
constexpr info r1 = substitute(^^fn1, {^^int}); // error: fn1<int> contains an undeduced
// placeholder type for its return type
template<class T>
auto fn2() {
static_assert(^^T != ^^int); // static assertion failed during instantiation offn2<int>
return 0;
}
constexpr bool r2 = can_substitute(^^fn2, {^^int}); // error: instantiation of body offn2<int>
// is needed to deduce return type
—end example]
11 [Example 2:
consteval info to_integral_constant(unsigned i) {
return substitute(^^integral_constant, {^^unsigned, reflect_constant(i)});
}
constexpr info r = to_integral_constant(2); // OK,r represents the type
// integral_constant<unsigned, 2>
—end example]
§ 21.4.14 © ISO/IEC
794

===== PAGE 806 =====

Dxxxx
21.4.15 Expression result reflection [meta.reflection.result]
template<class T>
consteval info reflect_constant(T expr);
1 Mandates: is_copy_constructible_v<T> is true and T is a cv-unqualified structural type (13.2) that
is not a reference type.
2 Let V be:
—(2.1) if T is a class type, then an object that is template-argument-equivalent to the value ofexpr;
—(2.2) otherwise, the value ofexpr.
3 Let TCls be the invented template:
template<T P> struct TCls;
4 Returns: template_arguments_of(^^TCls<V>)[0].
[Note 1: This is a reflection of an object for class types, and a reflection of a value otherwise.—end note]
5 Throws: meta::exception unless thetemplate-id TCls<V> would be valid.
6 [Example 1:
template<auto D>
struct A { };
struct N { int x; };
struct K { char const* p; };
constexpr info r1 = reflect_constant(42);
static_assert(is_value(r1));
static_assert(r1 == template_arguments_of(^^A<42>)[0]);
constexpr info r2 = reflect_constant(N{42});
static_assert(is_object(r2));
static_assert(r2 == template_arguments_of(^^A<N{42}>)[0]);
constexpr info r3 = reflect_constant(K{nullptr}); // OK
constexpr info r4 = reflect_constant(K{"ebab"}); // error: constituent pointer
// points to string literal
—end example]
template<class T>
consteval info reflect_object(T& expr);
7 Mandates: T is an object type.
8 Returns: A reflection of the object designated byexpr.
9 Throws: meta::exception if E is not suitable for use as a constant template argument for a constant
template parameter of typeT& (13.4.3), whereE is an lvalue constant expression that computes the
object thatexpr refers to.
template<class T>
consteval info reflect_function(T& fn);
10 Mandates: T is a function type.
11 Returns: A reflection of the function designated byfn.
12 Throws: meta::exception if F is not suitable for use as a constant template argument for a constant
template parameter of typeT& (13.4.3), whereF is an lvalue constant expression that computes the
function thatfn refers to.
21.4.16 Reflection class definition generation [meta.reflection.define.aggregate]
namespace std::meta {
struct data_member_options {
struct name-type { // exposition only
template<class T>
requires constructible_from<u8string, T>
§ 21.4.16 © ISO/IEC
795

===== PAGE 807 =====

Dxxxx
consteval name-type (T&&);
template<class T>
requires constructible_from<string, T>
consteval name-type (T&&);
private:
variant<u8string, string> contents; // exposition only
};
optional<name-type > name;
optional<int> alignment;
optional<int> bit_width;
bool no_unique_address = false;
};
}
1 The classesdata_member_options and data_member_options::name-type are consteval-only types (6.9.1),
and are not structural types (13.2).
template<class T>
requires constructible_from<u8string, T>
consteval name-type (T&& value);
2 Effects: Initializes contents with u8string(std::forward<T>(value)).
template<class T>
requires constructible_from<string, T>
consteval name-type (T&& value);
3 Effects: Initializes contents with string(std::forward<T>(value)).
[Note 1: The classname-type allows the functiondata_member_spec to accept an ordinary string literal (or
string_view, string, etc.) or a UTF-8 string literal (oru8string_view, u8string, etc.) equally well.
[Example 1:
consteval void fn() {
data_member_options o1 = {.name = "ordinary_literal_encoding"};
data_member_options o2 = {.name = u8"utf8_encoding"};
}
—end example]
—end note]
consteval info data_member_spec(info type, data_member_options options);
4 Returns: A reflection of a data member description(T,N,A,W, NUA) (11.4.1) where
—(4.1) T is the type represented bydealias(type),
—(4.2) N is either the identifier encoded byoptions.name or ⊥if options.name does not contain a
value,
—(4.3) Ais either the alignment value held byoptions.alignment or ⊥if options.alignment does not
contain a value,
—(4.4) W is either the value held byoptions.bit_width or ⊥if options.bit_width does not contain
a value, and
—(4.5) NUA is the value held byoptions.no_unique_address.
[Note 2: The returned reflection value is primarily useful in conjunction withdefine_aggregate; it can also be
queried by certain other functions instd::meta (e.g., type_of, identifier_of). —end note]
5 Throws: meta::exception unless the following conditions are met:
—(5.1) dealias(type) represents either an object type or a reference type;
—(5.2) if options.name contains a value, then:
§ 21.4.16 © ISO/IEC
796

===== PAGE 808 =====

Dxxxx
—(5.2.1) holds_alternative<u8string>(options.name->contents ) is true and get<u8string>(
options.name->contents ) contains the spelling of a validtoken that is anidentifier (5.11)
when interpreted with UTF-8, or
—(5.2.2) holds_alternative<string>(options.name->contents ) is true and get<string>(opt-
ions.name->contents ) contains the spelling of a validtoken that is anidentifier (5.11) when
interpreted with the ordinary literal encoding;
[Note 3: Lexical constructs like universal-character-names (5.3.2) are not processed. For example,
R"(\u03B1)" is an invalid identifier and is not interpreted as"α". —end note]
—(5.3) if options.name does not contain a value, thenoptions.bit_width contains a value;
—(5.4) if options.bit_width contains a valueV, then
—(5.4.1) is_integral_type(type) || is_enum_type(type) is true,
—(5.4.2) options.alignment does not contain a value,
—(5.4.3) options.no_unique_address is false,
—(5.4.4) V is not negative, and
—(5.4.5) if V equals 0, thenoptions.name does not contain a value; and
—(5.5) if options.alignment contains a value, it is an alignment value (6.8.3) not less thanalignment_-
of(type).
consteval bool is_data_member_spec(info r);
6 Returns: true if r represents a data member description. Otherwise,false.
template<reflection_range R = initializer_list<info>>
consteval info define_aggregate(info class_type, R&& mdescrs);
7 Let C be the type represented byclass_type and rK be the Kth reflection value inmdescrs. For
every rK in mdescrs, let(TK,NK,AK,WK,NUAK) be the corresponding data member description
represented byrK.
8 Constant When:
—(8.1) class_type represents a cv-unqualified class type;
—(8.2) C is incomplete from every point in the evaluation context;
[Note 4: C can be a class template specialization for which there is a reachable definition of the class
template. In this case, the injected declaration is an explicit specialization.—end note]
—(8.3) is_data_member_spec(rK) is true for everyrK;
—(8.4) is_complete_type(TK) is true for everyrK; and
—(8.5) for every pair(rK,rL) where K <L, ifNK is not⊥and NL is not⊥, then either:
—(8.5.1) NK is not the same identifier asNL or
—(8.5.2) NK is the identifier_ (u+005f low line).
[Note 5: Every provided identifier is unique or"_". —end note]
9 Effects: Produces an injected declarationD (7.7) that definesC and has properties as follows:
—(9.1) The target scope ofD is the scope to whichC belongs (6.4.1).
—(9.2) The locus ofD follows immediately after the core constant expression currently under evaluation.
—(9.3) The characteristic sequence ofD (7.7) is the sequence of reflection valuesrK.
—(9.4) If C is a specialization of a templated classT, andC is not a local class, thenD is an explicit
specialization ofT.
—(9.5) For eachrK, there is a corresponding entityMK with public access belonging to the class scope of
D with the following properties:
—(9.5.1) If NK is ⊥, MK is an unnamed bit-field. Otherwise,MK is a non-static data member whose
name is the identifierNK.
—(9.5.2) The type ofMK is TK.
—(9.5.3) MK is declared with the attribute[[no_unique_address]] if and only ifNUAK is true.
§ 21.4.16 © ISO/IEC
797

===== PAGE 809 =====

Dxxxx
—(9.5.4) If WK is not⊥, MK is a bit-field whose width is that value. Otherwise,MK is not a bit-field.
—(9.5.5) If AK is not ⊥, MK has the alignment-specifier alignas(AK). Otherwise, MK has no
alignment-specifier.
—(9.6) For everyrL in mdescrs such that K < L, the declaration corresponding torK precedes the
declaration corresponding torL.
10 Returns: class_type.
11 Remarks: If C is a specialization of a templated class and it has not been instantiated,C is treated as
an explicit specialization.
21.4.17 Reflection type traits [meta.reflection.traits]
1 This subclause specifiesconsteval functions to query the properties of types (21.3.6), query the relationships
between types (21.3.8), or transform types (21.3.9), during program translation. Eachconsteval function
declared in this class has an associated class template declared elsewhere in this document.
2 Every function and function template declared in this subclause throws an exception of typemeta::exception
unless the following conditions are met:
—(2.1) For every parameterp of typeinfo, is_type(p) is true.
—(2.2) For every parameterrwhose type is constrained onreflection_range, ranges::all_of(r, is_type)
is true.
// associated with 21.3.6.2, primary type categories
consteval bool is_void_type(info type);
consteval bool is_null_pointer_type(info type);
consteval bool is_integral_type(info type);
consteval bool is_floating_point_type(info type);
consteval bool is_array_type(info type);
consteval bool is_pointer_type(info type);
consteval bool is_lvalue_reference_type(info type);
consteval bool is_rvalue_reference_type(info type);
consteval bool is_member_object_pointer_type(info type);
consteval bool is_member_function_pointer_type(info type);
consteval bool is_enum_type(info type);
consteval bool is_union_type(info type);
consteval bool is_class_type(info type);
consteval bool is_function_type(info type);
consteval bool is_reflection_type(info type);
// associated with 21.3.6.3, composite type categories
consteval bool is_reference_type(info type);
consteval bool is_arithmetic_type(info type);
consteval bool is_fundamental_type(info type);
consteval bool is_object_type(info type);
consteval bool is_scalar_type(info type);
consteval bool is_compound_type(info type);
consteval bool is_member_pointer_type(info type);
// associated with 21.3.6.4, type properties
consteval bool is_const_type(info type);
consteval bool is_volatile_type(info type);
consteval bool is_trivially_copyable_type(info type);
consteval bool is_standard_layout_type(info type);
consteval bool is_empty_type(info type);
consteval bool is_polymorphic_type(info type);
consteval bool is_abstract_type(info type);
consteval bool is_final_type(info type);
consteval bool is_aggregate_type(info type);
consteval bool is_consteval_only_type(info type);
consteval bool is_signed_type(info type);
consteval bool is_unsigned_type(info type);
consteval bool is_bounded_array_type(info type);
consteval bool is_unbounded_array_type(info type);
§ 21.4.17 © ISO/IEC
798

===== PAGE 810 =====

Dxxxx
consteval bool is_scoped_enum_type(info type);
template<reflection_range R = initializer_list<info>>
consteval bool is_constructible_type(info type, R&& type_args);
consteval bool is_default_constructible_type(info type);
consteval bool is_copy_constructible_type(info type);
consteval bool is_move_constructible_type(info type);
consteval bool is_assignable_type(info type_dst, info type_src);
consteval bool is_copy_assignable_type(info type);
consteval bool is_move_assignable_type(info type);
consteval bool is_swappable_with_type(info type1, info type2);
consteval bool is_swappable_type(info type);
consteval bool is_destructible_type(info type);
template<reflection_range R = initializer_list<info>>
consteval bool is_trivially_constructible_type(info type, R&& type_args);
consteval bool is_trivially_default_constructible_type(info type);
consteval bool is_trivially_copy_constructible_type(info type);
consteval bool is_trivially_move_constructible_type(info type);
consteval bool is_trivially_assignable_type(info type_dst, info type_src);
consteval bool is_trivially_copy_assignable_type(info type);
consteval bool is_trivially_move_assignable_type(info type);
consteval bool is_trivially_destructible_type(info type);
template<reflection_range R = initializer_list<info>>
consteval bool is_nothrow_constructible_type(info type, R&& type_args);
consteval bool is_nothrow_default_constructible_type(info type);
consteval bool is_nothrow_copy_constructible_type(info type);
consteval bool is_nothrow_move_constructible_type(info type);
consteval bool is_nothrow_assignable_type(info type_dst, info type_src);
consteval bool is_nothrow_copy_assignable_type(info type);
consteval bool is_nothrow_move_assignable_type(info type);
consteval bool is_nothrow_swappable_with_type(info type1, info type2);
consteval bool is_nothrow_swappable_type(info type);
consteval bool is_nothrow_destructible_type(info type);
consteval bool is_implicit_lifetime_type(info type);
consteval bool has_virtual_destructor(info type);
consteval bool has_unique_object_representations(info type);
consteval bool reference_constructs_from_temporary(info type_dst, info type_src);
consteval bool reference_converts_from_temporary(info type_dst, info type_src);
// associated with 21.3.8, type relations
consteval bool is_same_type(info type1, info type2);
consteval bool is_base_of_type(info type_base, info type_derived);
consteval bool is_virtual_base_of_type(info type_base, info type_derived);
consteval bool is_convertible_type(info type_src, info type_dst);
consteval bool is_nothrow_convertible_type(info type_src, info type_dst);
consteval bool is_layout_compatible_type(info type1, info type2);
consteval bool is_pointer_interconvertible_base_of_type(info type_base, info type_derived);
template<reflection_range R = initializer_list<info>>
consteval bool is_invocable_type(info type, R&& type_args);
§ 21.4.17 © ISO/IEC
799

===== PAGE 811 =====

Dxxxx
template<reflection_range R = initializer_list<info>>
consteval bool is_invocable_r_type(info type_result, info type, R&& type_args);
template<reflection_range R = initializer_list<info>>
consteval bool is_nothrow_invocable_type(info type, R&& type_args);
template<reflection_range R = initializer_list<info>>
consteval bool is_nothrow_invocable_r_type(info type_result, info type, R&& type_args);
// associated with 21.3.9.2, const-volatile modifications
consteval info remove_const(info type);
consteval info remove_volatile(info type);
consteval info remove_cv(info type);
consteval info add_const(info type);
consteval info add_volatile(info type);
consteval info add_cv(info type);
// associated with 21.3.9.3, reference modifications
consteval info remove_reference(info type);
consteval info add_lvalue_reference(info type);
consteval info add_rvalue_reference(info type);
// associated with 21.3.9.4, sign modifications
consteval info make_signed(info type);
consteval info make_unsigned(info type);
// associated with 21.3.9.5, array modifications
consteval info remove_extent(info type);
consteval info remove_all_extents(info type);
// associated with 21.3.9.6, pointer modifications
consteval info remove_pointer(info type);
consteval info add_pointer(info type);
// associated with 21.3.9.7, other transformations
consteval info remove_cvref(info type);
consteval info decay(info type);
template<reflection_range R = initializer_list<info>>
consteval info common_type(R&& type_args);
template<reflection_range R = initializer_list<info>>
consteval info common_reference(R&& type_args);
consteval info underlying_type(info type);
template<reflection_range R = initializer_list<info>>
consteval info invoke_result(info type, R&& type_args);
consteval info unwrap_reference(info type);
consteval info unwrap_ref_decay(info type);
3 For a function or function templateF defined in this subclause, letC be its associated class template. For
the evaluation of a call toF, letS be the specialization ofC in terms of which the call is specified.
—(3.1) If
—(3.1.1) the template arguments ofS violate a condition specified in aMandates element in the specification
of C;
—(3.1.2) the call is specified to produce a reflection of a type, butS would have no member namedtype; or
—(3.1.3) the call is specified to returnS::value, but that expression would not be a valid converted
constant expression of typeR, whereR is the return type ofF;
then an exception of typemeta::exception is thrown.
[Note 1: For the first case,S is not instantiated. —end note]
—(3.2) Otherwise, if the instantiation ofS would result in undefined behavior due to dependence on an
incomplete type (21.3.2), then the call is not a constant subexpression.
§ 21.4.17 © ISO/IEC
800

===== PAGE 812 =====

Dxxxx
—(3.3) Otherwise, if the template arguments ofS do not meet the preconditions ofC, then it is unspecified
whether the call is a constant subexpression. If it is, the call produces the result that would be produced
if C had no preconditions.
4 Each function or function template declared above has the following behavior based on the signature and
return type of that function or function template.
[Note 2: The associated class template need not be instantiated.—end note]
Table 64 — Reflection type traits [tab:meta.reflection.traits]
Signature and Return Type Returns
bool meta::UNARY (info type);
bool meta::UNARY _type(info
type);
std::UNARY <T>::value, whereT is the type or type alias
represented bytype
bool meta::BINARY (info t1,
info t2);
bool meta::BINARY _type(info t1,
info t2);
std::BINARY <T1, T2>::value, whereT1 and T2 are the types
or type aliases represented byt1 and t2, respectively
template<reflection_range R>
bool meta::VARIADIC _type(info
type, R&& args);
std::VARIADIC <T, U...>::value, whereT is the type or
type alias represented bytype and U... is the pack of types or
type aliases whose elements are represented by the
corresponding elements ofargs
template<reflection_range R>
bool meta::VARIADIC _type(info
t1, info t2, R&& args);
std::VARIADIC <T1, T2, U...>::value, whereT1 and T2 are
the types or type aliases represented byt1 and t2, respectively,
and U... is the pack of types or type aliases whose elements
are represented by the corresponding elements ofargs
info meta::UNARY (info type); A reflection representing the type denoted by
std::UNARY <T>::type, whereT is the type or type alias
represented bytype
template<reflection_range R>
info meta::VARIADIC (R&& args);
A reflection representing the type denoted by
std::VARIADIC <T...>::type, whereT... is the pack of
types or type aliases whose elements are represented by the
corresponding elements ofargs
template<reflection_range R>
info meta::VARIADIC (info type,
R&& args);
A reflection representing the type denoted by
std::VARIADIC <T, U...>::type, whereT is the type or
type alias represented bytype and U... is the pack of types or
type aliases whose elements are represented by the
corresponding elements ofargs
5 [Note 3: For those functions or function templates which return a reflection, that reflection always represents a type
and never a type alias.—end note]
6 [Note 4: If t is a reflection of the typeint and u is a reflection of an alias to the typeint, thent == u is false but
is_same_type(t, u) is true. Also, t == dealias(u) is true. —end note]
consteval size_t rank(info type);
7 Returns: std::rank<T>::value, whereT is the type represented bydealias(type).
consteval size_t extent(info type, unsigned i = 0);
8 Returns: std::extent<T, I>::value, whereT is the type represented bydealias(type) and I is a
constant equal toi.
consteval size_t tuple_size(info type);
9 Returns: std::tuple_size<T>::value, whereT is the type represented bydealias(type).
consteval info tuple_element(size_t index, info type);
10 Returns: A reflection representing the type denoted bystd::tuple_element<I, T>::type, whereT
is the type represented bydealias(type) and I is a constant equal toindex.
§ 21.4.17 © ISO/IEC
801

===== PAGE 813 =====

Dxxxx
consteval size_t variant_size(info type);
11 Returns: std::variant_size<T>::value, whereT is the type represented bydealias(type).
consteval info variant_alternative(size_t index, info type);
12 Returns: A reflection representing the type denoted bystd::variant_alternative<I, T>::type,
where T is the type represented bydealias(type) and I is a constant equal toindex.
consteval strong_ordering type_order(info t1, info t2);
13 Returns: std::type_order<T1, T2>::value, whereT1 and T2 are the types represented bydealias(
t1) and dealias(t2), respectively.
21.5 Compile-time rational arithmetic [ratio]
21.5.1 General [ratio.general]
1 Subclause 21.5 describes the ratio library. It provides a class templateratio which exactly represents any
finite rational number with a numerator and denominator representable by compile-time constants of type
intmax_t.
2 Throughout subclause 21.5, the names of template parameters are used to express type requirements. If
a template parameter is namedR1 or R2, and the template argument is not a specialization of theratio
template, the program is ill-formed.
21.5.2 Header <ratio> synopsis [ratio.syn]
// all freestanding
namespace std {
// 21.5.3, class templateratio
template<intmax_t N, intmax_t D = 1> class ratio;
// 21.5.4, ratio arithmetic
template<class R1, class R2> using ratio_add = see below ;
template<class R1, class R2> using ratio_subtract = see below ;
template<class R1, class R2> using ratio_multiply = see below ;
template<class R1, class R2> using ratio_divide = see below ;
// 21.5.5, ratio comparison
template<class R1, class R2> struct ratio_equal;
template<class R1, class R2> struct ratio_not_equal;
template<class R1, class R2> struct ratio_less;
template<class R1, class R2> struct ratio_less_equal;
template<class R1, class R2> struct ratio_greater;
template<class R1, class R2> struct ratio_greater_equal;
template<class R1, class R2>
constexpr bool ratio_equal_v = ratio_equal<R1, R2>::value;
template<class R1, class R2>
constexpr bool ratio_not_equal_v = ratio_not_equal<R1, R2>::value;
template<class R1, class R2>
constexpr bool ratio_less_v = ratio_less<R1, R2>::value;
template<class R1, class R2>
constexpr bool ratio_less_equal_v = ratio_less_equal<R1, R2>::value;
template<class R1, class R2>
constexpr bool ratio_greater_v = ratio_greater<R1, R2>::value;
template<class R1, class R2>
constexpr bool ratio_greater_equal_v = ratio_greater_equal<R1, R2>::value;
// 21.5.6, convenience SI typedefs
using quecto = ratio<1, 1'000'000'000'000'000'000'000'000'000'000>; // see below
using ronto = ratio<1, 1 '000'000'000'000'000'000'000'000'000>; // see below
using yocto = ratio<1, 1 '000'000'000'000'000'000'000'000>; // see below
using zepto = ratio<1, 1 '000'000'000'000'000'000'000>; // see below
using atto = ratio<1, 1 '000'000'000'000'000'000>;
using femto = ratio<1, 1 '000'000'000'000'000>;
using pico = ratio<1, 1 '000'000'000'000>;
§ 21.5.2 © ISO/IEC
802

===== PAGE 814 =====

Dxxxx
using nano = ratio<1, 1 '000'000'000>;
using micro = ratio<1, 1 '000'000>;
using milli = ratio<1, 1 '000>;
using centi = ratio<1, 100>;
using deci = ratio<1, 10>;
using deca = ratio< 10, 1>;
using hecto = ratio< 100, 1>;
using kilo = ratio< 1 '000, 1>;
using mega = ratio< 1 '000'000, 1>;
using giga = ratio< 1 '000'000'000, 1>;
using tera = ratio< 1 '000'000'000'000, 1>;
using peta = ratio< 1 '000'000'000'000'000, 1>;
using exa = ratio< 1 '000'000'000'000'000'000, 1>;
using zetta = ratio< 1 '000'000'000'000'000'000'000, 1>; // see below
using yotta = ratio< 1 '000'000'000'000'000'000'000'000, 1>; // see below
using ronna = ratio< 1 '000'000'000'000'000'000'000'000'000, 1>; // see below
using quetta = ratio<1'000'000'000'000'000'000'000'000'000'000, 1>; // see below
}
21.5.3 Class template ratio [ratio.ratio]
namespace std {
template<intmax_t N, intmax_t D = 1> class ratio {
public:
static constexpr intmax_t num;
static constexpr intmax_t den;
using type = ratio<num, den>;
};
}
1 If the template argumentD is zero or the absolute values of either of the template argumentsN and D is not
representable by typeintmax_t, the program is ill-formed.
[Note 1: These rules ensure that infinite ratios are avoided and that for any negative input, there exists a representable
value of its absolute value which is positive. This excludes the most negative value.—end note]
2 The static data membersnum and den shall have the following values, wheregcd represents the greatest
common divisor of the absolute values ofN and D:
—(2.1) num shall have the valuesgn(N) * sgn(D) * abs(N) / gcd.
—(2.2) den shall have the valueabs(D) / gcd.
21.5.4 Arithmetic on ratios [ratio.arithmetic]
1 Each of the alias templatesratio_add, ratio_subtract, ratio_multiply, andratio_divide denotes the
result of an arithmetic computation on tworatios R1 and R2. With X and Y computed (in the absence of
arithmetic overflow) as specified by Table 65, each alias denotes aratio<U, V> such thatU is the same as
ratio<X, Y>::num and V is the same asratio<X, Y>::den.
2 If it is not possible to representUor Vwith intmax_t, the program is ill-formed. Otherwise, an implementation
should yield correct values ofU and V. If it is not possible to representX or Y with intmax_t, the program is
ill-formed unless the implementation yields correct values ofU and V.
Table 65 — Expressions used to perform ratio arithmetic [tab:ratio.arithmetic]
Type Value of X Value ofY
ratio_add<R1, R2> R1::num * R2::den + R1::den * R2::den
R2::num * R1::den
ratio_subtract<R1, R2> R1::num * R2::den - R1::den * R2::den
R2::num * R1::den
ratio_multiply<R1, R2> R1::num * R2::num R1::den * R2::den
ratio_divide<R1, R2> R1::num * R2::den R1::den * R2::num
§ 21.5.4 © ISO/IEC
803

===== PAGE 815 =====

Dxxxx
3 [Example 1:
static_assert(ratio_add<ratio<1, 3>, ratio<1, 6>>::num == 1, "1/3+1/6 == 1/2");
static_assert(ratio_add<ratio<1, 3>, ratio<1, 6>>::den == 2, "1/3+1/6 == 1/2");
static_assert(ratio_multiply<ratio<1, 3>, ratio<3, 2>>::num == 1, "1/3*3/2 == 1/2");
static_assert(ratio_multiply<ratio<1, 3>, ratio<3, 2>>::den == 2, "1/3*3/2 == 1/2");
// The following cases may cause the program to be ill-formed under some implementations
static_assert(ratio_add<ratio<1, INT_MAX>, ratio<1, INT_MAX>>::num == 2,
"1/MAX+1/MAX == 2/MAX");
static_assert(ratio_add<ratio<1, INT_MAX>, ratio<1, INT_MAX>>::den == INT_MAX,
"1/MAX+1/MAX == 2/MAX");
static_assert(ratio_multiply<ratio<1, INT_MAX>, ratio<INT_MAX, 2>>::num == 1,
"1/MAX * MAX/2 == 1/2");
static_assert(ratio_multiply<ratio<1, INT_MAX>, ratio<INT_MAX, 2>>::den == 2,
"1/MAX * MAX/2 == 1/2");
—end example]
21.5.5 Comparison of ratios [ratio.comparison]
template<class R1, class R2>
struct ratio_equal : bool_constant<R1::num == R2::num && R1::den == R2::den> { };
template<class R1, class R2>
struct ratio_not_equal : bool_constant<!ratio_equal_v<R1, R2>> { };
template<class R1, class R2>
struct ratio_less : bool_constant<see below > { };
1 If R1::num ×R2::den is less thanR2::num ×R1::den, ratio_less<R1, R2> shall be derived from
bool_constant<true>; otherwise it shall be derived frombool_constant<false>. Implementations
may use other algorithms to compute this relationship to avoid overflow. If overflow occurs, the program
is ill-formed.
template<class R1, class R2>
struct ratio_less_equal : bool_constant<!ratio_less_v<R2, R1>> { };
template<class R1, class R2>
struct ratio_greater : bool_constant<ratio_less_v<R2, R1>> { };
template<class R1, class R2>
struct ratio_greater_equal : bool_constant<!ratio_less_v<R1, R2>> { };
21.5.6 SI types for ratio [ratio.si]
1 For each of thetypedef-names quecto, ronto, yocto, zepto, zetta, yotta, ronna, andquetta, if both of
the constants used in its specification are representable byintmax_t, the typedef is defined; if either of the
constants is not representable byintmax_t, the typedef is not defined.
§ 21.5.6 © ISO/IEC
804

===== PAGE 816 =====

Dxxxx
22 General utilities library [utilities]
22.1 General [utilities.general]
1 This Clause describes utilities that are generally useful in C++ programs; some of these utilities are used by
other elements of the C++ standard library. These utilities are summarized in Table 66.
Table 66 — General utilities library summary [tab:utilities.summary]
Subclause Header
22.2 Utility components <utility>
22.3 Pairs
22.4 Tuples <tuple>
22.5 Optional objects <optional>
22.6 Variants <variant>
22.7 Storage for any type <any>
22.8 Expected objects <expected>
22.9 Fixed-size sequences of bits <bitset>
22.10 Function objects <functional>
22.11 Bit manipulation <bit>
22.2 Utility components [utility]
22.2.1 Header <utility> synopsis [utility.syn]
1 The header<utility> contains some basic function and class templates that are used throughout the rest of
the library.
// all freestanding
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 22.2.2, swap
template<class T>
constexpr void swap(T& a, T& b) noexcept(see below );
template<class T, size_t N>
constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
// 22.2.3, exchange
template<class T, class U = T>
constexpr T exchange(T& obj, U&& new_val) noexcept(see below );
// 22.2.4, forward/move
template<class T>
constexpr T&& forward(remove_reference_t<T>& t) noexcept;
template<class T>
constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
template<class T, class U>
constexpr auto forward_like(U&& x) noexcept -> see below ;
template<class T>
constexpr remove_reference_t<T>&& move(T&&) noexcept;
template<class T>
constexpr conditional_t<
!is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>, const T&, T&&>
move_if_noexcept(T& x) noexcept;
§ 22.2.1 © ISO/IEC
805

===== PAGE 817 =====

Dxxxx
// 22.2.5,as_const
template<class T>
constexpr add_const_t<T>& as_const(T& t) noexcept;
template<class T>
void as_const(const T&&) = delete;
// 22.2.6, declval
template<class T>
add_rvalue_reference_t<T> declval() noexcept; // as unevaluated operand
// 22.2.7, integer comparison functions
template<class T, class U>
constexpr bool cmp_equal(T t, U u) noexcept;
template<class T, class U>
constexpr bool cmp_not_equal(T t, U u) noexcept;
template<class T, class U>
constexpr bool cmp_less(T t, U u) noexcept;
template<class T, class U>
constexpr bool cmp_greater(T t, U u) noexcept;
template<class T, class U>
constexpr bool cmp_less_equal(T t, U u) noexcept;
template<class T, class U>
constexpr bool cmp_greater_equal(T t, U u) noexcept;
template<class R, class T>
constexpr bool in_range(T t) noexcept;
// 22.2.8,to_underlying
template<class T>
constexpr underlying_type_t<T> to_underlying(T value) noexcept;
// 22.2.9, undefined behavior
[[noreturn]] void unreachable();
void observable_checkpoint() noexcept;
// 21.2, compile-time integer sequences
template<class T, T...>
struct integer_sequence;
template<size_t... I>
using index_sequence = integer_sequence<size_t, I...>;
template<class T, T N>
using make_integer_sequence = integer_sequence<T, see below >;
template<size_t N>
using make_index_sequence = make_integer_sequence<size_t, N>;
template<class... T>
using index_sequence_for = make_index_sequence<sizeof...(T)>;
// 21.2.4, structured binding support
template<class T> struct tuple_size;
template<size_t I, class T> struct tuple_element;
template<class T, T... Values>
struct tuple_size<integer_sequence<T, Values...>>;
template<size_t I, class T, T... Values>
struct tuple_element<I, integer_sequence<T, Values...>>;
template<size_t I, class T, T... Values>
struct tuple_element<I, const integer_sequence<T, Values...>>;
template<size_t I, class T, T... Values>
constexpr T get(integer_sequence<T, Values...>) noexcept;
§ 22.2.1 © ISO/IEC
806

===== PAGE 818 =====

Dxxxx
// 22.3, class templatepair
template<class T1, class T2>
struct pair;
template<class T1, class T2, class U1, class U2,
template<class> class TQual, template<class> class UQual>
requires requires { typename pair<common_reference_t<TQual<T1>, UQual<U1>>,
common_reference_t<TQual<T2>, UQual<U2>>>; }
struct basic_common_reference<pair<T1, T2>, pair<U1, U2>, TQual, UQual> {
using type = pair<common_reference_t<TQual<T1>, UQual<U1>>,
common_reference_t<TQual<T2>, UQual<U2>>>;
};
template<class T1, class T2, class U1, class U2>
requires requires { typename pair<common_type_t<T1, U1>, common_type_t<T2, U2>>; }
struct common_type<pair<T1, T2>, pair<U1, U2>> {
using type = pair<common_type_t<T1, U1>, common_type_t<T2, U2>>;
};
// 22.3.3, pair specialized algorithms
template<class T1, class T2, class U1, class U2>
constexpr bool operator==(const pair<T1, T2>&, const pair<U1, U2>&);
template<class T1, class T2, class U1, class U2>
constexpr common_comparison_category_t<synth-three-way-result <T1, U1>,
synth-three-way-result <T2, U2>>
operator<=>(const pair<T1, T2>&, const pair<U1, U2>&);
template<class T1, class T2>
constexpr void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
template<class T1, class T2>
constexpr void swap(const pair<T1, T2>& x, const pair<T1, T2>& y)
noexcept(noexcept(x.swap(y)));
template<class T1, class T2>
constexpr see below make_pair(T1&&, T2&&);
// 22.3.4, tuple-like access to pair
template<class T1, class T2> struct tuple_size<pair<T1, T2>>;
template<size_t I, class T1, class T2> struct tuple_element<I, pair<T1, T2>>;
template<size_t I, class T1, class T2>
constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>&) noexcept;
template<size_t I, class T1, class T2>
constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&&) noexcept;
template<size_t I, class T1, class T2>
constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>&) noexcept;
template<size_t I, class T1, class T2>
constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&&) noexcept;
template<class T1, class T2>
constexpr T1& get(pair<T1, T2>& p) noexcept;
template<class T1, class T2>
constexpr const T1& get(const pair<T1, T2>& p) noexcept;
template<class T1, class T2>
constexpr T1&& get(pair<T1, T2>&& p) noexcept;
template<class T1, class T2>
constexpr const T1&& get(const pair<T1, T2>&& p) noexcept;
template<class T2, class T1>
constexpr T2& get(pair<T1, T2>& p) noexcept;
template<class T2, class T1>
constexpr const T2& get(const pair<T1, T2>& p) noexcept;
template<class T2, class T1>
constexpr T2&& get(pair<T1, T2>&& p) noexcept;
template<class T2, class T1>
constexpr const T2&& get(const pair<T1, T2>&& p) noexcept;
§ 22.2.1 © ISO/IEC
807

===== PAGE 819 =====

Dxxxx
// 22.3.5, pair piecewise construction
struct piecewise_construct_t {
explicit piecewise_construct_t() = default;
};
inline constexpr piecewise_construct_t piecewise_construct{};
template<class... Types> class tuple; // defined in<tuple> (22.4.2)
// in-place construction
struct in_place_t {
explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};
template<class T>
struct in_place_type_t {
explicit in_place_type_t() = default;
};
template<class T> constexpr in_place_type_t<T> in_place_type{};
template<size_t I>
struct in_place_index_t {
explicit in_place_index_t() = default;
};
template<size_t I> constexpr in_place_index_t<I> in_place_index{};
// constant_arg argument tag
template<auto V>
struct constant_arg_t {
explicit constant_arg_t() = default;
};
template<auto V> constexpr constant_arg_t<V> constant_arg{};
// 22.6.8, classmonostate
struct monostate;
// 22.6.9,monostate relational operators
constexpr bool operator==(monostate, monostate) noexcept;
constexpr strong_ordering operator<=>(monostate, monostate) noexcept;
// 22.6.12, hash support
template<class T> struct hash;
template<> struct hash<monostate>;
}
22.2.2 swap [utility.swap]
template<class T>
constexpr void swap(T& a, T& b) noexcept(see below );
1 Constraints: is_move_constructible_v<T> is true and is_move_assignable_v<T> is true.
2 Preconditions: Type T meets the Cpp17MoveConstructible (Table 31) and Cpp17MoveAssignable
(Table 33) requirements.
3 Effects: Exchanges values stored in two locations.
4 Remarks: The exception specification is equivalent to:
is_nothrow_move_constructible_v<T> && is_nothrow_move_assignable_v<T>
template<class T, size_t N>
constexpr void swap(T (&a)[N], T (&b)[N]) noexcept(is_nothrow_swappable_v<T>);
5 Constraints: is_swappable_v<T> is true.
6 Preconditions: a[i] is swappable with (16.4.4.3)b[i] for alli in the range[0,N).
7 Effects: As if byswap_ranges(a, a + N, b).
§ 22.2.2 © ISO/IEC
808

===== PAGE 820 =====

Dxxxx
22.2.3 exchange [utility.exchange]
template<class T, class U = T>
constexpr T exchange(T& obj, U&& new_val) noexcept(see below );
1 Effects: Equivalent to:
T old_val = std::move(obj);
obj = std::forward<U>(new_val);
return old_val;
2 Remarks: The exception specification is equivalent to:
is_nothrow_move_constructible_v<T> && is_nothrow_assignable_v<T&, U>
22.2.4 Forward/move helpers [forward]
1 The library provides templated helper functions to simplify applying move semantics to an lvalue and to
simplify the implementation of forwarding functions. All functions specified in this subclause are signal-
safe (17.14.5).
template<class T> constexpr T&& forward(remove_reference_t<T>& t) noexcept;
template<class T> constexpr T&& forward(remove_reference_t<T>&& t) noexcept;
2 Mandates: For the second overload,is_lvalue_reference_v<T> is false.
3 Returns: static_cast<T&&>(t).
4 [Example 1:
template<class T, class A1, class A2>
shared_ptr<T> factory(A1&& a1, A2&& a2) {
return shared_ptr<T>(new T(std::forward<A1>(a1), std::forward<A2>(a2)));
}
struct A {
A(int&, const double&);
};
void g() {
shared_ptr<A> sp1 = factory<A>(2, 1.414); // error: 2 will not bind toint&
int i = 2;
shared_ptr<A> sp2 = factory<A>(i, 1.414); // OK
}
In the first call tofactory, A1 is deduced asint, so 2 is forwarded toA’s constructor as an rvalue. In the
second call tofactory, A1 is deduced asint&, soi is forwarded toA’s constructor as an lvalue. In both cases,
A2 is deduced asdouble, so 1.414 is forwarded toA’s constructor as an rvalue.—end example]
template<class T, class U>
constexpr auto forward_like(U&& x) noexcept -> see below ;
5 Mandates: T is a referenceable type (3.45).
—(5.1) Let COPY_CONST (A, B) be const B if A is a const type, otherwiseB.
—(5.2) LetOVERRIDE_REF (A, B)be remove_reference_t<B>&&if Ais an rvalue reference type, otherwise
B&.
—(5.3) Let V be
OVERRIDE_REF (T&&, COPY_CONST (remove_reference_t<T>, remove_reference_t<U>))
6 Returns: static_cast<V>(x).
7 Remarks: The return type isV.
8 [Example 2:
struct accessor {
vector<string>* container;
decltype(auto) operator[](this auto&& self, size_t i) {
return std::forward_like<decltype(self)>((*container)[i]);
}
};
§ 22.2.4 © ISO/IEC
809

===== PAGE 821 =====

Dxxxx
void g() {
vector v{"a"s, "b"s};
accessor a{&v};
string& x = a[0]; // OK, binds to lvalue reference
string&& y = std::move(a)[0]; // OK, is rvalue reference
string const&& z = std::move(as_const(a))[1]; // OK, isconst&&
string& w = as_const(a)[1]; // error: will not bind to non-const
}
—end example]
template<class T> constexpr remove_reference_t<T>&& move(T&& t) noexcept;
9 Returns: static_cast<remove_reference_t<T>&&>(t).
10 [Example 3:
template<class T, class A1>
shared_ptr<T> factory(A1&& a1) {
return shared_ptr<T>(new T(std::forward<A1>(a1)));
}
struct A {
A();
A(const A&); // copies from lvalues
A(A&&); // moves from rvalues
};
void g() {
A a;
shared_ptr<A> sp1 = factory<A>(a); // “a” binds toA(const A&)
shared_ptr<A> sp2 = factory<A>(std::move(a)); // “a” binds toA(A&&)
}
In the first call tofactory, A1 is deduced asA&, soa is forwarded as a non-const lvalue. This binds to the
constructor A(const A&), which copies the value froma. In the second call tofactory, because of the call
std::move(a), A1 is deduced asA, soa is forwarded as an rvalue. This binds to the constructorA(A&&), which
moves the value froma. —end example]
template<class T> constexpr conditional_t<
!is_nothrow_move_constructible_v<T> && is_copy_constructible_v<T>, const T&, T&&>
move_if_noexcept(T& x) noexcept;
11 Returns: std::move(x).
22.2.5 Function template as_const [utility.as.const]
template<class T> constexpr add_const_t<T>& as_const(T& t) noexcept;
1 Returns: t.
22.2.6 Function template declval [declval]
1 The library provides the function templatedeclval to simplify the definition of expressions which occur as
unevaluated operands (7.2.3).
template<class T> add_rvalue_reference_t<T> declval() noexcept; // as unevaluated operand
2 Mandates: This function is not odr-used (6.3).
3 Remarks: The template parameterT of declval may be an incomplete type.
4 [Example 1:
template<class To, class From> decltype(static_cast<To>(declval<From>())) convert(From&&);
declares a function templateconvert which only participates in overload resolution if the typeFrom can be
explicitly converted to typeTo. For another example see class templatecommon_type (21.3.9.7). —end example]
§ 22.2.6 © ISO/IEC
810

===== PAGE 822 =====

Dxxxx
22.2.7 Integer comparison functions [utility.intcmp]
template<class T, class U>
constexpr bool cmp_equal(T t, U u) noexcept;
1 Mandates: Each ofT and U is a signed or unsigned integer type (6.9.2).
2 Effects: Equivalent to:
using UT = make_unsigned_t<T>;
using UU = make_unsigned_t<U>;
if constexpr (is_signed_v<T> == is_signed_v<U>)
return t == u;
else if constexpr (is_signed_v<T>)
return t < 0 ? false : UT(t) == u;
else
return u < 0 ? false : t == UU(u);
template<class T, class U>
constexpr bool cmp_not_equal(T t, U u) noexcept;
3 Effects: Equivalent to:return !cmp_equal(t, u);
template<class T, class U>
constexpr bool cmp_less(T t, U u) noexcept;
4 Mandates: Each ofT and U is a signed or unsigned integer type (6.9.2).
5 Effects: Equivalent to:
using UT = make_unsigned_t<T>;
using UU = make_unsigned_t<U>;
if constexpr (is_signed_v<T> == is_signed_v<U>)
return t < u;
else if constexpr (is_signed_v<T>)
return t < 0 ? true : UT(t) < u;
else
return u < 0 ? false : t < UU(u);
template<class T, class U>
constexpr bool cmp_greater(T t, U u) noexcept;
6 Effects: Equivalent to:return cmp_less(u, t);
template<class T, class U>
constexpr bool cmp_less_equal(T t, U u) noexcept;
7 Effects: Equivalent to:return !cmp_greater(t, u);
template<class T, class U>
constexpr bool cmp_greater_equal(T t, U u) noexcept;
8 Effects: Equivalent to:return !cmp_less(t, u);
template<class R, class T>
constexpr bool in_range(T t) noexcept;
9 Mandates: Each ofT and U is a signed or unsigned integer type (6.9.2).
10 Effects: Equivalent to:
return cmp_greater_equal(t, numeric_limits<R>::min()) &&
cmp_less_equal(t, numeric_limits<R>::max());
11 [Note 1: These function templates cannot be used to comparebyte, char, char8_t, char16_t, char32_t, wchar_t,
and bool. —end note]
22.2.8 Function template to_underlying [utility.underlying]
template<class T>
constexpr underlying_type_t<T> to_underlying(T value) noexcept;
1 Returns: static_cast<underlying_type_t<T>>(value).
§ 22.2.8 © ISO/IEC
811

===== PAGE 823 =====

Dxxxx
22.2.9 Undefined behavior [utility.undefined]
[[noreturn]] void unreachable();
1 Preconditions: false is true.
[Note 1: This precondition cannot be satisfied, thus the behavior of callingunreachable is undefined. —end
note]
2 [Example 1:
int f(int x) {
switch (x) {
case 0:
case 1:
return x;
default:
std::unreachable();
}
}
int a = f(1); // OK,a has value1
int b = f(3); // undefined behavior
—end example]
void observable_checkpoint() noexcept;
3 Effects: Establishes an observable checkpoint (4.1.2).
22.3 Pairs [pairs]
22.3.1 General [pairs.general]
1 The library provides a template for heterogeneous pairs of values. The library also provides a matching
function template to simplify their construction and several templates that provide access topair objects as
if they weretuple objects (see 22.4.7 and 22.4.8).
22.3.2 Class template pair [pairs.pair]
namespace std {
template<class T1, class T2>
struct pair {
using first_type = T1;
using second_type = T2;
T1 first;
T2 second;
pair(const pair&) = default;
pair(pair&&) = default;
constexpr explicit(see below ) pair();
constexpr explicit(see below ) pair(const T1& x, const T2& y);
template<class U1 = T1, class U2 = T2>
constexpr explicit(see below ) pair(U1&& x, U2&& y);
template<class U1, class U2>
constexpr explicit(see below ) pair(pair<U1, U2>& p);
template<class U1, class U2>
constexpr explicit(see below ) pair(const pair<U1, U2>& p);
template<class U1, class U2>
constexpr explicit(see below ) pair(pair<U1, U2>&& p);
template<class U1, class U2>
constexpr explicit(see below ) pair(const pair<U1, U2>&& p);
template<pair-like P>
constexpr explicit(see below ) pair(P&& p);
template<class... Args1, class... Args2>
constexpr pair(piecewise_construct_t,
tuple<Args1...> first_args, tuple<Args2...> second_args);
§ 22.3.2 © ISO/IEC
812

===== PAGE 824 =====

Dxxxx
constexpr pair& operator=(const pair& p);
constexpr const pair& operator=(const pair& p) const;
template<class U1, class U2>
constexpr pair& operator=(const pair<U1, U2>& p);
template<class U1, class U2>
constexpr const pair& operator=(const pair<U1, U2>& p) const;
constexpr pair& operator=(pair&& p) noexcept(see below );
constexpr const pair& operator=(pair&& p) const;
template<class U1, class U2>
constexpr pair& operator=(pair<U1, U2>&& p);
template<class U1, class U2>
constexpr const pair& operator=(pair<U1, U2>&& p) const;
template<pair-like P>
constexpr pair& operator=(P&& p);
template<pair-like P>
constexpr const pair& operator=(P&& p) const;
constexpr void swap(pair& p) noexcept(see below );
constexpr void swap(const pair& p) const noexcept(see below );
};
template<class T1, class T2>
pair(T1, T2) -> pair<T1, T2>;
}
1 Member functions ofpair do not throw exceptions unless one of the element-wise operations specified to be
called for that operation throws an exception.
2 The defaulted move and copy constructor, respectively, ofpair is a constexpr function if and only if all
required element-wise initializations for move and copy, respectively, would be constexpr-suitable (9.2.6).
3 If (is_trivially_destructible_v<T1> && is_trivially_destructible_v<T2>) is true, then the de-
structor ofpair is trivial.
4 pair<T, U> is a structural type (13.2) ifT and U are both structural types. Two valuesp1 and p2 of type
pair<T, U> are template-argument-equivalent (13.6) if and only ifp1.first and p2.first are template-
argument-equivalent andp1.second and p2.second are template-argument-equivalent.
constexpr explicit(see below ) pair();
5 Constraints:
—(5.1) is_default_constructible_v<T1> is true and
—(5.2) is_default_constructible_v<T2> is true.
6 Effects: Value-initializesfirst and second.
7 Remarks: The expression inside explicit evaluates to true if and only if eitherT1 or T2 is not
implicitly default-constructible.
[Note 1: This behavior can be implemented with a trait that checks whether aconst T1& or aconst T2& can
be initialized with{}. —end note]
constexpr explicit(see below ) pair(const T1& x, const T2& y);
8 Constraints:
—(8.1) is_copy_constructible_v<T1> is true and
—(8.2) is_copy_constructible_v<T2> is true.
9 Effects: Initializes first with x and second with y.
10 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<const T1&, T1> || !is_convertible_v<const T2&, T2>
template<class U1 = T1, class U2 = T2> constexpr explicit(see below ) pair(U1&& x, U2&& y);
11 Constraints:
—(11.1) is_constructible_v<T1, U1> is true and
§ 22.3.2 © ISO/IEC
813

===== PAGE 825 =====

Dxxxx
—(11.2) is_constructible_v<T2, U2> is true.
12 Effects: Initializes first with std::forward<U1>(x) and second with std::forward<U2>(y).
13 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<U1, T1> || !is_convertible_v<U2, T2>
This constructor is defined as deleted if reference_constructs_from_temporary_v<first_type,
U1&&> is true or reference_constructs_from_temporary_v<second_type, U2&&> is true.
template<class U1, class U2> constexpr explicit(see below ) pair(pair<U1, U2>& p);
template<class U1, class U2> constexpr explicit(see below ) pair(const pair<U1, U2>& p);
template<class U1, class U2> constexpr explicit(see below ) pair(pair<U1, U2>&& p);
template<class U1, class U2> constexpr explicit(see below ) pair(const pair<U1, U2>&& p);
template<pair-like P> constexpr explicit(see below ) pair(P&& p);
14 Let FWD (u) be static_cast<decltype(u)>(u).
15 Constraints:
—(15.1) For the last overload,remove_cvref_t<P> is not a specialization ofranges::subrange,
—(15.2) is_constructible_v<T1, decltype(get<0>(FWD (p)))> is true, and
—(15.3) is_constructible_v<T2, decltype(get<1>(FWD (p)))> is true.
16 Effects: Initializes first with get<0>(FWD (p)) and second with get<1>(FWD (p)).
17 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<decltype(get<0>(FWD (p))), T1> ||
!is_convertible_v<decltype(get<1>(FWD (p))), T2>
The constructor is defined as deleted if
reference_constructs_from_temporary_v<first_type, decltype(get<0>(FWD (p)))> ||
reference_constructs_from_temporary_v<second_type, decltype(get<1>(FWD (p)))>
is true.
template<class... Args1, class... Args2>
constexpr pair(piecewise_construct_t,
tuple<Args1...> first_args, tuple<Args2...> second_args);
18 Mandates:
—(18.1) is_constructible_v<T1, Args1...> is true and
—(18.2) is_constructible_v<T2, Args2...> is true.
19 Effects: Initializes first with arguments of typesArgs1... obtained by forwarding the elements of
first_args and initializes second with arguments of typesArgs2... obtained by forwarding the
elements of second_args. (Here, forwarding an elementx of type U within a tuple object means
calling std::forward<U>(x).) This form of construction, whereby constructor arguments forfirst
and second are each provided in a separatetuple object, is calledpiecewise construction.
[Note 2: If a data member ofpair is of reference type and its initialization binds it to a temporary object, the
program is ill-formed (11.9.3).—end note]
constexpr pair& operator=(const pair& p);
20 Effects: Assigns p.first to first and p.second to second.
21 Returns: *this.
22 Remarks: This operator is defined as deleted unlessis_copy_assignable_v<T1> is true and is_-
copy_assignable_v<T2> is true.
constexpr const pair& operator=(const pair& p) const;
23 Constraints:
—(23.1) is_copy_assignable_v<const T1> is true and
—(23.2) is_copy_assignable_v<const T2> is true.
§ 22.3.2 © ISO/IEC
814

===== PAGE 826 =====

Dxxxx
24 Effects: Assigns p.first to first and p.second to second.
25 Returns: *this.
template<class U1, class U2> constexpr pair& operator=(const pair<U1, U2>& p);
26 Constraints:
—(26.1) is_assignable_v<T1&, const U1&> is true and
—(26.2) is_assignable_v<T2&, const U2&> is true.
27 Effects: Assigns p.first to first and p.second to second.
28 Returns: *this.
template<class U1, class U2> constexpr const pair& operator=(const pair<U1, U2>& p) const;
29 Constraints:
—(29.1) is_assignable_v<const T1&, const U1&> is true, and
—(29.2) is_assignable_v<const T2&, const U2&> is true.
30 Effects: Assigns p.first to first and p.second to second.
31 Returns: *this.
constexpr pair& operator=(pair&& p) noexcept(see below );
32 Constraints:
—(32.1) is_move_assignable_v<T1> is true and
—(32.2) is_move_assignable_v<T2> is true.
33 Effects: Assignsstd::forward<T1>(p.first)tofirstandstd::forward<T2>(p.second)tosecond.
34 Returns: *this.
35 Remarks: The exception specification is equivalent to:
is_nothrow_move_assignable_v<T1> && is_nothrow_move_assignable_v<T2>
constexpr const pair& operator=(pair&& p) const;
36 Constraints:
—(36.1) is_assignable_v<const T1&, T1> is true and
—(36.2) is_assignable_v<const T2&, T2> is true.
37 Effects: Assignsstd::forward<T1>(p.first)tofirstandstd::forward<T2>(p.second)tosecond.
38 Returns: *this.
template<class U1, class U2> constexpr pair& operator=(pair<U1, U2>&& p);
39 Constraints:
—(39.1) is_assignable_v<T1&, U1> is true and
—(39.2) is_assignable_v<T2&, U2> is true.
40 Effects: Assigns std::forward<U1>(p.first) firstand std::forward<U2>(p.second) to second.
41 Returns: *this.
template<pair-like P> constexpr pair& operator=(P&& p);
42 Constraints:
—(42.1) different-from <P, pair> (25.5.2) istrue,
—(42.2) remove_cvref_t<P> is not a specialization ofranges::subrange,
—(42.3) is_assignable_v<T1&, decltype(get<0>(std::forward<P>(p)))> is true, and
—(42.4) is_assignable_v<T2&, decltype(get<1>(std::forward<P>(p)))> is true.
43 Effects: Assigns get<0>(std::forward<P>(p)) to first and get<1>(std::forward<P>(p)) to sec-
ond.
§ 22.3.2 © ISO/IEC
815

===== PAGE 827 =====

Dxxxx
44 Returns: *this.
template<pair-like P> constexpr const pair& operator=(P&& p) const;
45 Constraints:
—(45.1) different-from <P, pair> (25.5.2) istrue,
—(45.2) remove_cvref_t<P> is not a specialization ofranges::subrange,
—(45.3) is_assignable_v<const T1&, decltype(get<0>(std::forward<P>(p)))> is true, and
—(45.4) is_assignable_v<const T2&, decltype(get<1>(std::forward<P>(p)))> is true.
46 Effects: Assigns get<0>(std::forward<P>(p)) to first and get<1>(std::forward<P>(p)) to sec-
ond.
47 Returns: *this.
template<class U1, class U2> constexpr const pair& operator=(pair<U1, U2>&& p) const;
48 Constraints:
—(48.1) is_assignable_v<const T1&, U1> is true, and
—(48.2) is_assignable_v<const T2&, U2> is true.
49 Effects: Assignsstd::forward<U1>(p.first)tofirstandstd::forward<U2>(u.second)tosecond.
50 Returns: *this.
constexpr void swap(pair& p) noexcept(see below );
constexpr void swap(const pair& p) const noexcept(see below );
51 Mandates:
—(51.1) For the first overload,is_swappable_v<T1> is true and is_swappable_v<T2> is true.
—(51.2) For the second overload,is_swappable_v<const T1> is true and is_swappable_v<const T2>
is true.
52 Preconditions: first is swappable with (16.4.4.3)p.first and second is swappable withp.second.
53 Effects: Swapsfirst with p.first and second with p.second.
54 Remarks: The exception specification is equivalent to:
—(54.1) is_nothrow_swappable_v<T1> && is_nothrow_swappable_v<T2> for the first overload, and
—(54.2) is_nothrow_swappable_v<const T1> && is_nothrow_swappable_v<const T2> for the second
overload.
22.3.3 Specialized algorithms [pairs.spec]
template<class T1, class T2, class U1, class U2>
constexpr bool operator==(const pair<T1, T2>& x, const pair<U1, U2>& y);
1 Constraints: x.first == y.first and x.second == y.second are valid expressions and each of
decltype(x.first == y.first) and decltype(x.second == y.second) models boolean-
testable .
2 Returns: x.first == y.first && x.second == y.second.
template<class T1, class T2, class U1, class U2>
constexpr common_comparison_category_t<synth-three-way-result <T1, U1>,
synth-three-way-result <T2, U2>>
operator<=>(const pair<T1, T2>& x, const pair<U1, U2>& y);
3 Effects: Equivalent to:
if (auto c = synth-three-way(x.first, y.first); c != 0) return c;
return synth-three-way(x.second, y.second);
template<class T1, class T2>
constexpr void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
§ 22.3.3 © ISO/IEC
816

===== PAGE 828 =====

Dxxxx
template<class T1, class T2>
constexpr void swap(const pair<T1, T2>& x, const pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
4 Constraints:
—(4.1) For the first overload,is_swappable_v<T1> is true and is_swappable_v<T2> is true.
—(4.2) For the second overload,is_swappable_v<const T1> is true and is_swappable_v<const T2>
is true.
5 Effects: Equivalent tox.swap(y).
template<class T1, class T2>
constexpr pair<unwrap_ref_decay_t<T1>, unwrap_ref_decay_t<T2>> make_pair(T1&& x, T2&& y);
6 Returns:
pair<unwrap_ref_decay_t<T1>,
unwrap_ref_decay_t<T2>>(std::forward<T1>(x), std::forward<T2>(y))
7 [Example 1: In place of:
return pair<int, double>(5, 3.1415926); // explicit types
a C++ program may contain:
return make_pair(5, 3.1415926); // types are deduced
—end example]
22.3.4 Tuple-like access to pair [pair.astuple]
template<class T1, class T2>
struct tuple_size<pair<T1, T2>> : integral_constant<size_t, 2> { };
template<size_t I, class T1, class T2>
struct tuple_element<I, pair<T1, T2>> {
using type = see below ;
};
1 Mandates: I <2.
2 Result: The typeT1 if I is 0, otherwise the typeT2.
template<size_t I, class T1, class T2>
constexpr tuple_element_t<I, pair<T1, T2>>& get(pair<T1, T2>& p) noexcept;
template<size_t I, class T1, class T2>
constexpr const tuple_element_t<I, pair<T1, T2>>& get(const pair<T1, T2>& p) noexcept;
template<size_t I, class T1, class T2>
constexpr tuple_element_t<I, pair<T1, T2>>&& get(pair<T1, T2>&& p) noexcept;
template<size_t I, class T1, class T2>
constexpr const tuple_element_t<I, pair<T1, T2>>&& get(const pair<T1, T2>&& p) noexcept;
3 Mandates: I <2.
4 Returns:
—(4.1) If I is 0, returns a reference top.first.
—(4.2) If I is 1, returns a reference top.second.
template<class T1, class T2>
constexpr T1& get(pair<T1, T2>& p) noexcept;
template<class T1, class T2>
constexpr const T1& get(const pair<T1, T2>& p) noexcept;
template<class T1, class T2>
constexpr T1&& get(pair<T1, T2>&& p) noexcept;
template<class T1, class T2>
constexpr const T1&& get(const pair<T1, T2>&& p) noexcept;
5 Mandates: T1 and T2 are distinct types.
6 Returns: A reference top.first.
§ 22.3.4 © ISO/IEC
817

===== PAGE 829 =====

Dxxxx
template<class T2, class T1>
constexpr T2& get(pair<T1, T2>& p) noexcept;
template<class T2, class T1>
constexpr const T2& get(const pair<T1, T2>& p) noexcept;
template<class T2, class T1>
constexpr T2&& get(pair<T1, T2>&& p) noexcept;
template<class T2, class T1>
constexpr const T2&& get(const pair<T1, T2>&& p) noexcept;
7 Mandates: T1 and T2 are distinct types.
8 Returns: A reference top.second.
22.3.5 Piecewise construction [pair.piecewise]
struct piecewise_construct_t {
explicit piecewise_construct_t() = default;
};
inline constexpr piecewise_construct_t piecewise_construct{};
1 Thestructpiecewise_construct_t isanemptyclasstypeusedasauniquetypetodisambiguateconstructor
and function overloading. Specifically,pair has a constructor withpiecewise_construct_t as the first
argument, immediately followed by twotuple (22.4) arguments used for piecewise construction of the
elements of thepair object.
22.4 Tuples [tuple]
22.4.1 General [tuple.general]
1 Subclause 22.4 describes the tuple library that provides a tuple type as the class templatetuple that can be
instantiated with any number of arguments. Each template argument specifies the type of an element in the
tuple. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation oftuple
with two arguments is similar to an instantiation ofpair with the same two arguments. See 22.3.
2 In addition to being available via inclusion of the<tuple> header, ignore (22.4.2) is available when
<utility> (22.2) is included.
22.4.2 Header <tuple> synopsis [tuple.syn]
// all freestanding
#include <compare> // see 17.12.1
namespace std {
// 22.4.4, class templatetuple
template<class... Types>
class tuple;
// 22.4.3, concepttuple-like
template<class T>
concept tuple-like = see below; // exposition only
template<class T>
concept pair-like = // exposition only
tuple-like <T> && tuple_size_v<remove_cvref_t<T>> == 2;
// 22.4.10,common_reference related specializations
template<tuple-like TTuple, tuple-like UTuple,
template<class> class TQual, template<class> class UQual>
struct basic_common_reference<TTuple, UTuple, TQual, UQual>;
template<tuple-like TTuple, tuple-like UTuple>
struct common_type<TTuple, UTuple>;
// ignore
struct ignore-type { // exposition only
constexpr const ignore-type &
operator=(const auto &) const noexcept { return *this; }
};
inline constexpr ignore-type ignore;
§ 22.4.2 © ISO/IEC
818

===== PAGE 830 =====

Dxxxx
// 22.4.5, tuple creation functions
template<class... TTypes>
constexpr tuple<unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&...);
template<class... TTypes>
constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&...) noexcept;
template<class... TTypes>
constexpr tuple<TTypes&...> tie(TTypes&...) noexcept;
template<tuple-like... Tuples>
constexpr tuple<CTypes...> tuple_cat(Tuples&&...);
// 22.4.6, calling a function with a tuple of arguments
template<class F, tuple-like Tuple>
constexpr apply_result_t<F, Tuple> apply(F&& f, Tuple&& t)
noexcept(is_nothrow_applicable_v<F, Tuple>);
template<class T, tuple-like Tuple>
constexpr T make_from_tuple(Tuple&& t);
// 22.4.7, tuple helper classes
template<class T> struct tuple_size; // not defined
template<class T> struct tuple_size<const T>;
template<class... Types> struct tuple_size<tuple<Types...>>;
template<size_t I, class T> struct tuple_element; // not defined
template<size_t I, class T> struct tuple_element<I, const T>;
template<size_t I, class... Types>
struct tuple_element<I, tuple<Types...>>;
template<size_t I, class T>
using tuple_element_t = tuple_element<I, T>::type;
// 22.4.8, element access
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>& get(tuple<Types...>&) noexcept;
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&& get(tuple<Types...>&&) noexcept;
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>& get(const tuple<Types...>&) noexcept;
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>&& get(const tuple<Types...>&&) noexcept;
template<class T, class... Types>
constexpr T& get(tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr T&& get(tuple<Types...>&& t) noexcept;
template<class T, class... Types>
constexpr const T& get(const tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr const T&& get(const tuple<Types...>&& t) noexcept;
// 22.4.9, relational operators
template<class... TTypes, class... UTypes>
constexpr bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
template<class... TTypes, tuple-like UTuple>
constexpr bool operator==(const tuple<TTypes...>&, const UTuple&);
template<class... TTypes, class... UTypes>
constexpr common_comparison_category_t<synth-three-way-result<TTypes, UTypes>...>
operator<=>(const tuple<TTypes...>&, const tuple<UTypes...>&);
template<class... TTypes, tuple-like UTuple>
constexpr see below operator<=>(const tuple<TTypes...>&, const UTuple&);
§ 22.4.2 © ISO/IEC
819

===== PAGE 831 =====

Dxxxx
// 22.4.11, allocator-related traits
template<class... Types, class Alloc>
struct uses_allocator<tuple<Types...>, Alloc>;
// 22.4.12, specialized algorithms
template<class... Types>
constexpr void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below );
template<class... Types>
constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(see below );
// 22.4.7, tuple helper classes
template<class T>
constexpr size_t tuple_size_v = tuple_size<T>::value;
}
22.4.3 Concept tuple-like [tuple.like]
template<class T>
concept tuple-like = see below; // exposition only
1 A type T models and satisfies the exposition-only concepttuple-like if remove_cvref_t<T> is a
specialization of array, complex, pair, tuple, orranges::subrange.
22.4.4 Class template tuple [tuple.tuple]
22.4.4.1 General [tuple.tuple.general]
namespace std {
template<class... Types>
class tuple {
public:
// 22.4.4.2,tuple construction
constexpr explicit(see below ) tuple();
constexpr explicit(see below ) tuple(const Types&...) // only ifsizeof...(Types) >= 1
noexcept(see below );
template<class... UTypes>
constexpr explicit(see below ) tuple(UTypes&&...) // only ifsizeof...(Types) >= 1
noexcept(see below );
tuple(const tuple&) = default;
tuple(tuple&&) = default;
template<class... UTypes>
constexpr explicit(see below ) tuple(tuple<UTypes...>&);
template<class... UTypes>
constexpr explicit(see below ) tuple(const tuple<UTypes...>&);
template<class... UTypes>
constexpr explicit(see below ) tuple(tuple<UTypes...>&&);
template<class... UTypes>
constexpr explicit(see below ) tuple(const tuple<UTypes...>&&);
template<class U1, class U2>
constexpr explicit(see below ) tuple(pair<U1, U2>&); // only ifsizeof...(Types) == 2
template<class U1, class U2>
constexpr explicit(see below ) tuple(const pair<U1, U2>&); // only ifsizeof...(Types) == 2
template<class U1, class U2>
constexpr explicit(see below ) tuple(pair<U1, U2>&&); // only ifsizeof...(Types) == 2
template<class U1, class U2>
constexpr explicit(see below ) tuple(const pair<U1, U2>&&); // only ifsizeof...(Types) == 2
template<tuple-like UTuple>
constexpr explicit(see below ) tuple(UTuple&&);
§ 22.4.4.1 © ISO/IEC
820

===== PAGE 832 =====

Dxxxx
// allocator-extended constructors
template<class Alloc>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a);
template<class Alloc>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const Types&...);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
template<class Alloc>
constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
template<class Alloc>
constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);
template<class Alloc, tuple-like UTuple>
constexpr explicit(see below ) tuple(allocator_arg_t, const Alloc& a, UTuple&&);
// 22.4.4.3,tuple assignment
constexpr tuple& operator=(const tuple&);
constexpr const tuple& operator=(const tuple&) const;
constexpr tuple& operator=(tuple&&) noexcept(see below );
constexpr const tuple& operator=(tuple&&) const;
template<class... UTypes>
constexpr tuple& operator=(const tuple<UTypes...>&);
template<class... UTypes>
constexpr const tuple& operator=(const tuple<UTypes...>&) const;
template<class... UTypes>
constexpr tuple& operator=(tuple<UTypes...>&&);
template<class... UTypes>
constexpr const tuple& operator=(tuple<UTypes...>&&) const;
template<class U1, class U2>
constexpr tuple& operator=(const pair<U1, U2>&); // only ifsizeof...(Types) == 2
template<class U1, class U2>
constexpr const tuple& operator=(const pair<U1, U2>&) const;
// only ifsizeof...(Types) == 2
template<class U1, class U2>
constexpr tuple& operator=(pair<U1, U2>&&); // only ifsizeof...(Types) == 2
§ 22.4.4.1 © ISO/IEC
821

===== PAGE 833 =====

Dxxxx
template<class U1, class U2>
constexpr const tuple& operator=(pair<U1, U2>&&) const; // only ifsizeof...(Types) == 2
template<tuple-like UTuple>
constexpr tuple& operator=(UTuple&&);
template<tuple-like UTuple>
constexpr const tuple& operator=(UTuple&&) const;
// 22.4.4.4,tuple swap
constexpr void swap(tuple&) noexcept(see below );
constexpr void swap(const tuple&) const noexcept(see below );
};
template<class... UTypes>
tuple(UTypes...) -> tuple<UTypes...>;
template<class T1, class T2>
tuple(pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;
template<class Alloc, class T1, class T2>
tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, tuple<UTypes...>) -> tuple<UTypes...>;
}
1 If a program declares an explicit or partial specialization oftuple, the program is ill-formed, no diagnostic
required.
22.4.4.2 Construction [tuple.cnstr]
1 In the descriptions that follow, leti be in the range[0,sizeof...(Types)) in order,Ti be theith type in
Types, andUi be theith type in a template parameter pack namedUTypes, where indexing is zero-based.
2 For eachtuple constructor, an exception is thrown only if the construction of one of the types inTypes
throws an exception.
3 The defaulted move and copy constructor, respectively, oftuple is a constexpr function if and only if all
required element-wise initializations for move and copy, respectively, would be constexpr-suitable (9.2.6). The
defaulted move and copy constructor oftuple<> are constexpr functions.
4 If is_trivially_destructible_v<Ti> is true for allTi, then the destructor oftuple is trivial.
5 The default constructor oftuple<> is trivial.
constexpr explicit(see below ) tuple();
6 Constraints: is_default_constructible_v<Ti> is true for alli.
7 Effects: Value-initializes each element.
8 Remarks: The expression insideexplicit evaluates totrue if and only ifTi is not copy-list-initializable
from an empty list for at least onei.
[Note 1: This behavior can be implemented with a trait that checks whether aconst Ti& can be initialized
with {}. —end note]
constexpr explicit(see below ) tuple(const Types&...)
noexcept((is_nothrow_copy_constructible_v<Types> && ...));
9 Constraints: sizeof...(Types) ≥1 and is_copy_constructible_v<Ti> is true for alli.
10 Effects: Initializes each element with the value of the corresponding parameter.
11 Remarks: The expression insideexplicit is equivalent to:
!conjunction_v<is_convertible<const Types&, Types>...>
template<class... UTypes> constexpr explicit(see below ) tuple(UTypes&&... u)
noexcept((is_nothrow_constructible_v<Types, UTypes> && ...));
12 Let disambiguating-constraint be:
—(12.1) negation<is_same<remove_cvref_t<U0>, tuple>> if sizeof...(Types) is 1;
§ 22.4.4.2 © ISO/IEC
822

===== PAGE 834 =====

Dxxxx
—(12.2) otherwise, bool_constant<!is_same_v<remove_cvref_t<U0>, allocator_arg_t> || is_-
same_v<remove_cvref_t<T0>, allocator_arg_t>> if sizeof...(Types) is 2 or 3;
—(12.3) otherwise, true_type.
13 Constraints:
—(13.1) sizeof...(Types) equals sizeof...(UTypes),
—(13.2) sizeof...(Types) ≥1, and
—(13.3) conjunction_v<disambiguating-constraint , is_constructible<Types, UTypes>...> is
true.
14 Effects: Initializes the elements in the tuple with the corresponding value instd::forward<UTypes>(u).
15 Remarks: The expression insideexplicit is equivalent to:
!conjunction_v<is_convertible<UTypes, Types>...>
This constructor is defined as deleted if
(reference_constructs_from_temporary_v<Types, UTypes&&> || ...)
is true.
tuple(const tuple& u) = default;
16 Mandates: is_copy_constructible_v<Ti> is true for alli.
17 Effects: Initializes each element of*this with the corresponding element ofu.
tuple(tuple&& u) = default;
18 Constraints: is_move_constructible_v<Ti> is true for alli.
19 Effects: For alli, initializes theith element of*this with std::forward<Ti>(get<i>(u)).
template<class... UTypes> constexpr explicit(see below ) tuple(tuple<UTypes...>& u);
template<class... UTypes> constexpr explicit(see below ) tuple(const tuple<UTypes...>& u);
template<class... UTypes> constexpr explicit(see below ) tuple(tuple<UTypes...>&& u);
template<class... UTypes> constexpr explicit(see below ) tuple(const tuple<UTypes...>&& u);
20 Let I be the pack0, 1, ... , (sizeof...(Types) - 1).
Let FWD (u) be static_cast<decltype(u)>(u).
21 Constraints:
—(21.1) sizeof...(Types) equals sizeof...(UTypes), and
—(21.2) (is_constructible_v<Types, decltype(get<I>(FWD (u)))> && ...) is true, and
—(21.3) either sizeof...(Types) is not 1, or (whenTypes... expands toT and UTypes... expands toU)
is_convertible_v<decltype(u), T>, is_constructible_v<T, decltype(u)>, andis_same_-
v<T, U> are allfalse.
22 Effects: For alli, initializes theith element of*this with get<i>(FWD (u)).
23 Remarks: The expression insideexplicit is equivalent to:
!(is_convertible_v<decltype(get<I>(FWD (u))), Types> && ...)
The constructor is defined as deleted if
(reference_constructs_from_temporary_v<Types, decltype(get<I>(FWD (u)))> || ...)
is true.
template<class U1, class U2> constexpr explicit(see below ) tuple(pair<U1, U2>& u);
template<class U1, class U2> constexpr explicit(see below ) tuple(const pair<U1, U2>& u);
template<class U1, class U2> constexpr explicit(see below ) tuple(pair<U1, U2>&& u);
template<class U1, class U2> constexpr explicit(see below ) tuple(const pair<U1, U2>&& u);
24 Let FWD (u) be static_cast<decltype(u)>(u).
25 Constraints:
—(25.1) sizeof...(Types) is 2,
—(25.2) is_constructible_v<T0, decltype(get<0>(FWD (u)))> is true, and
§ 22.4.4.2 © ISO/IEC
823

===== PAGE 835 =====

Dxxxx
—(25.3) is_constructible_v<T1, decltype(get<1>(FWD (u)))> is true.
26 Effects: Initializes the first element withget<0>(FWD (u)) and the second element withget<1>(FWD (
u)).
27 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<decltype(get<0>(FWD (u))), T0> ||
!is_convertible_v<decltype(get<1>(FWD (u))), T1>
The constructor is defined as deleted if
reference_constructs_from_temporary_v<T0, decltype(get<0>(FWD (u)))> ||
reference_constructs_from_temporary_v<T1, decltype(get<1>(FWD (u)))>
is true.
template<tuple-like UTuple>
constexpr explicit(see below ) tuple(UTuple&& u);
28 Let I be the pack0, 1, ... , (sizeof...(Types) - 1).
29 Constraints:
—(29.1) different-from <UTuple, tuple> (25.5.2) istrue,
—(29.2) remove_cvref_t<UTuple> is not a specialization ofranges::subrange,
—(29.3) sizeof...(Types) equals tuple_size_v<remove_cvref_t<UTuple>>,
—(29.4) (is_constructible_v<Types, decltype(get<I>(std::forward<UTuple>(u)))> && ...) is
true, and
—(29.5) either sizeof...(Types) is not 1, or (whenTypes... expands toT) is_convertible_v<UTuple,
T> and is_constructible_v<T, UTuple> are bothfalse.
30 Effects: For alli, initializes theith element of*this with get<i>(std::forward<UTuple>(u)).
31 Remarks: The expression insideexplicit is equivalent to:
!(is_convertible_v<decltype(get<I>(std::forward<UTuple>(u))), Types> && ...)
The constructor is defined as deleted if
(reference_constructs_from_temporary_v<Types, decltype(get<I>(std::forward<UTuple>(u)))>
|| ...)
is true.
template<class Alloc>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a);
template<class Alloc>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const Types&...);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
template<class Alloc>
constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
template<class Alloc>
constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
template<class Alloc, class... UTypes>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);
§ 22.4.4.2 © ISO/IEC
824

===== PAGE 836 =====

Dxxxx
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
template<class Alloc, class U1, class U2>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);
template<class Alloc, tuple-like UTuple>
constexpr explicit(see below )
tuple(allocator_arg_t, const Alloc& a, UTuple&&);
32 Preconditions: Alloc meets theCpp17Allocator requirements (16.4.4.6.1).
33 Effects: Equivalent to the preceding constructors except that each element is constructed with uses-
allocator construction (20.2.8.2).
22.4.4.3 Assignment [tuple.assign]
1 For eachtupleassignment operator, an exception is thrown only if the assignment of one of the types inTypes
throws an exception. In the function descriptions that follow, leti be in the range[0,sizeof...(Types))
in order,Ti be theith type inTypes, andUi be theith type in a template parameter pack namedUTypes,
where indexing is zero-based.
constexpr tuple& operator=(const tuple& u);
2 Effects: Assigns each element ofu to the corresponding element of*this.
3 Returns: *this.
4 Remarks: This operator is defined as deleted unlessis_copy_assignable_v<Ti> is true for alli.
constexpr const tuple& operator=(const tuple& u) const;
5 Constraints: (is_copy_assignable_v<const Types> && ...) is true.
6 Effects: Assigns each element ofu to the corresponding element of*this.
7 Returns: *this.
constexpr tuple& operator=(tuple&& u) noexcept(see below );
8 Constraints: is_move_assignable_v<Ti> is true for alli.
9 Effects: For alli, assignsstd::forward<Ti>(get<i>(u)) to get<i>(*this).
10 Returns: *this.
11 Remarks: The exception specification is equivalent to the logicaland of the following expressions:
is_nothrow_move_assignable_v<Ti>
where Ti is theith type inTypes.
constexpr const tuple& operator=(tuple&& u) const;
12 Constraints: (is_assignable_v<const Types&, Types> && ...) is true.
13 Effects: For alli, assignsstd::forward<Ti>(get<i>(u)) to get<i>(*this).
14 Returns: *this.
template<class... UTypes> constexpr tuple& operator=(const tuple<UTypes...>& u);
15 Constraints:
—(15.1) sizeof...(Types) equals sizeof...(UTypes) and
—(15.2) is_assignable_v<Ti&, const Ui&> is true for alli.
16 Effects: Assigns each element ofu to the corresponding element of*this.
17 Returns: *this.
§ 22.4.4.3 © ISO/IEC
825

===== PAGE 837 =====

Dxxxx
template<class... UTypes> constexpr const tuple& operator=(const tuple<UTypes...>& u) const;
18 Constraints:
—(18.1) sizeof...(Types) equals sizeof...(UTypes) and
—(18.2) (is_assignable_v<const Types&, const UTypes&> && ...) is true.
19 Effects: Assigns each element ofu to the corresponding element of*this.
20 Returns: *this.
template<class... UTypes> constexpr tuple& operator=(tuple<UTypes...>&& u);
21 Constraints:
—(21.1) sizeof...(Types) equals sizeof...(UTypes) and
—(21.2) is_assignable_v<Ti&, Ui> is true for alli.
22 Effects: For alli, assignsstd::forward<Ui>(get<i>(u)) to get<i>(*this).
23 Returns: *this.
template<class... UTypes> constexpr const tuple& operator=(tuple<UTypes...>&& u) const;
24 Constraints:
—(24.1) sizeof...(Types) equals sizeof...(UTypes) and
—(24.2) (is_assignable_v<const Types&, UTypes> && ...) is true.
25 Effects: For alli, assignsstd::forward<Ui>(get<i>(u)) to get<i>(*this).
26 Returns: *this.
template<class U1, class U2> constexpr tuple& operator=(const pair<U1, U2>& u);
27 Constraints:
—(27.1) sizeof...(Types) is 2 and
—(27.2) is_assignable_v<T0&, const U1&> is true, and
—(27.3) is_assignable_v<T1&, const U2&> is true.
28 Effects: Assigns u.first to the first element of*this and u.second to the second element of*this.
29 Returns: *this.
template<class U1, class U2> constexpr const tuple& operator=(const pair<U1, U2>& u) const;
30 Constraints:
—(30.1) sizeof...(Types) is 2,
—(30.2) is_assignable_v<const T0&, const U1&> is true, and
—(30.3) is_assignable_v<const T1&, const U2&> is true.
31 Effects: Assigns u.first to the first element andu.second to the second element.
32 Returns: *this.
template<class U1, class U2> constexpr tuple& operator=(pair<U1, U2>&& u);
33 Constraints:
—(33.1) sizeof...(Types) is 2 and
—(33.2) is_assignable_v<T0&, U1> is true, and
—(33.3) is_assignable_v<T1&, U2> is true.
34 Effects: Assigns std::forward<U1>(u.first) to the first element of*this and
std::forward<U2>(u.second) to the second element of*this.
35 Returns: *this.
template<class U1, class U2> constexpr const tuple& operator=(pair<U1, U2>&& u) const;
36 Constraints:
§ 22.4.4.3 © ISO/IEC
826

===== PAGE 838 =====

Dxxxx
—(36.1) sizeof...(Types) is 2,
—(36.2) is_assignable_v<const T0&, U1> is true, and
—(36.3) is_assignable_v<const T1&, U2> is true.
37 Effects: Assigns std::forward<U1>(u.first) to the first element and
std::forward<U2>(u.second) to the second element.
38 Returns: *this.
template<tuple-like UTuple>
constexpr tuple& operator=(UTuple&& u);
39 Constraints:
—(39.1) different-from <UTuple, tuple> (25.5.2) istrue,
—(39.2) remove_cvref_t<UTuple> is not a specialization ofranges::subrange,
—(39.3) sizeof...(Types) equals tuple_size_v<remove_cvref_t<UTuple>>, and
—(39.4) is_assignable_v<Ti&, decltype(get<i>(std::forward<UTuple>(u)))> is true for alli.
40 Effects: For alli, assignsget<i>(std::forward<UTuple>(u)) to get<i>(*this).
41 Returns: *this.
template<tuple-like UTuple>
constexpr const tuple& operator=(UTuple&& u) const;
42 Constraints:
—(42.1) different-from <UTuple, tuple> (25.5.2) istrue,
—(42.2) remove_cvref_t<UTuple> is not a specialization ofranges::subrange,
—(42.3) sizeof...(Types) equals tuple_size_v<remove_cvref_t<UTuple>>, and
—(42.4) is_assignable_v<const Ti&, decltype(get<i>(std::forward<UTuple>(u)))> is true for all
i.
43 Effects: For alli, assignsget<i>(std::forward<UTuple>(u)) to get<i>(*this).
44 Returns: *this.
22.4.4.4 swap [tuple.swap]
constexpr void swap(tuple& rhs) noexcept(see below );
constexpr void swap(const tuple& rhs) const noexcept(see below );
1 Let i be in the range[0,sizeof...(Types)) in order.
2 Mandates:
—(2.1) For the first overload,(is_swappable_v<Types> && ...) is true.
—(2.2) For the second overload,(is_swappable_v<const Types> && ...) is true.
3 Preconditions: For alli, get<i>(*this) is swappable with (16.4.4.3)get<i>(rhs).
4 Effects: For eachi, callsswap for get<i>(*this) and get<i>(rhs).
5 Throws: Nothing unless one of the element-wiseswap calls throws an exception.
6 Remarks: The exception specification is equivalent to
—(6.1) (is_nothrow_swappable_v<Types> && ...) for the first overload and
—(6.2) (is_nothrow_swappable_v<const Types> && ...) for the second overload.
22.4.5 Tuple creation functions [tuple.creation]
template<class... TTypes>
constexpr tuple<unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&... t);
1 Returns: tuple<unwrap_ref_decay_t<TTypes>...>(std::forward<TTypes>(t)...).
§ 22.4.5 © ISO/IEC
827

===== PAGE 839 =====

Dxxxx
2 [Example 1:
int i; float j;
make_tuple(1, ref(i), cref(j));
creates a tuple of typetuple<int, int&, const float&>. —end example]
template<class... TTypes>
constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&... t) noexcept;
3 Effects: Constructs a tuple of references to the arguments int suitable for forwarding as arguments to
a function. Because the result may contain references to temporary objects, a program shall ensure
that the return value of this function does not outlive any of its arguments (e.g., the program should
typically not store the result in a named variable).
4 Returns: tuple<TTypes&&...>(std::forward<TTypes>(t)...).
template<class... TTypes>
constexpr tuple<TTypes&...> tie(TTypes&... t) noexcept;
5 Returns: tuple<TTypes&...>(t...).
6 [Example 2: tie functions allow one to create tuples that unpack tuples into variables.ignore can be used for
elements that are not needed:
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// i == 42, s == "C++"
—end example]
template<tuple-like ... Tuples>
constexpr tuple<CTypes...> tuple_cat(Tuples&&... tpls);
7 Let n be sizeof...(Tuples). For every integer0 ≤i<n :
—(7.1) Let Ti be theith type inTuples.
—(7.2) Let Ui be remove_cvref_t<Ti>.
—(7.3) Let tpi be theith element in the function parameter packtpls.
—(7.4) Let Si be tuple_size_v<Ui>.
—(7.5) Let Ek
i be tuple_element_t<k, Ui>.
—(7.6) Let ek
i be get<k>(std::forward<Ti>(tpi)).
—(7.7) Let Elemsi be a pack of the typesE0
i,...,E Si−1
i .
—(7.8) Let elemsi be a pack of the expressionse0
i,...,e Si−1
i .
The types inCTypes are equal to the ordered sequence of the expanded packs of typesElems0...,
Elems1..., ..., Elemsn−1.... Let celems be the ordered sequence of the expanded packs of expres-
sions elems0..., ..., elemsn−1....
8 Mandates: (is_constructible_v<CTypes, decltype(celems)> && ...) is true.
9 Returns: tuple<CTypes...>(celems...).
22.4.6 Calling a function with atuple of arguments [tuple.apply]
template<class F, tuple-like Tuple>
constexpr apply_result_t<F, Tuple> apply(F&& f, Tuple&& t)
noexcept(is_nothrow_applicable_v<F, Tuple>);
1 Effects: Given the exposition-only function template:
namespace std {
template<class F, tuple-like Tuple, size_t... I>
constexpr decltype(auto) apply-impl(F&& f, Tuple&& t, index_sequence<I...>) {
// exposition only
return INVOKE(std::forward<F>(f), get<I>(std::forward<Tuple>(t))...); // see 22.10.4
}
}
§ 22.4.6 © ISO/IEC
828

===== PAGE 840 =====

Dxxxx
Equivalent to:
return apply-impl(std::forward<F>(f), std::forward<Tuple>(t),
make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
template<class T, tuple-like Tuple>
constexpr T make_from_tuple(Tuple&& t);
2 Mandates: Iftuple_size_v<remove_reference_t<Tuple>>is1, thenreference_constructs_from_-
temporary_v<T, decltype(get<0>(declval<Tuple>()))> is false.
3 Effects: Given the exposition-only function template:
namespace std {
template<class T, tuple-like Tuple, size_t... I>
requires is_constructible_v<T, decltype(get<I>(declval<Tuple>()))...>
constexpr T make-from-tuple-impl(Tuple&& t, index_sequence<I...>) { // exposition only
return T(get<I>(std::forward<Tuple>(t))...);
}
}
Equivalent to:
return make-from-tuple-impl<T>(
std::forward<Tuple>(t),
make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
[Note 1: The type ofT must be supplied as an explicit template parameter, as it cannot be deduced from the
argument list. —end note]
22.4.7 Tuple helper classes [tuple.helper]
template<class T> struct tuple_size;
1 Except where specified otherwise, all specializations oftuple_size meet theCpp17UnaryTypeTrait
requirements (21.3.2) with a base characteristic ofintegral_constant<size_t, N> for someN.
template<class... Types>
struct tuple_size<tuple<Types...>> : integral_constant<size_t, sizeof...(Types)> { };
template<size_t I, class... Types>
struct tuple_element<I, tuple<Types...>> {
using type = TI;
};
2 Mandates: I <sizeof...(Types).
3 Result: TI is the type of theIth element ofTypes, where indexing is zero-based.
template<class T> struct tuple_size<const T>;
4 Let TS denote tuple_size<T> of the cv-unqualified typeT. If the expressionTS::value is well-formed
when treated as an unevaluated operand (7.2.3), then each specialization of the template meets the
Cpp17UnaryTypeTraitrequirements (21.3.2) with a base characteristic of
integral_constant<size_t, TS::value>
Otherwise, it has no membervalue.
5 Access checking is performed as if in a context unrelated toTS and T. Only the validity of the immediate
context of the expression is considered.
[Note 1: The compilation of the expression can result in side effects such as the instantiation of class template
specializations and function template specializations, the generation of implicitly-defined functions, and so on.
Such side effects are not in the “immediate context” and can result in the program being ill-formed.—end
note]
6 In addition to being available via inclusion of the<tuple> header, the template is available when
any of the headers<array> (23.3.2), <complex> (29.4.2), <ranges> (25.2), or<utility> (22.2.1) are
included.
§ 22.4.7 © ISO/IEC
829

===== PAGE 841 =====

Dxxxx
template<size_t I, class T> struct tuple_element<I, const T>;
7 Let TE denote tuple_element_t<I, T> of the cv-unqualified typeT. Then each specialization of the
template meets theCpp17TransformationTraitrequirements (21.3.2) with a member typedeftype that
names the typeconst TE.
8 In addition to being available via inclusion of the<tuple> header, the template is available when
any of the headers<array> (23.3.2), <complex> (29.4.2), <ranges> (25.2), or<utility> (22.2.1) are
included.
22.4.8 Element access [tuple.elem]
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&
get(tuple<Types...>& t) noexcept;
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&&
get(tuple<Types...>&& t) noexcept; // #1
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>&
get(const tuple<Types...>& t) noexcept; // #2
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>&& get(const tuple<Types...>&& t) noexcept;
1 Mandates: I <sizeof...(Types).
2 Returns: A reference to theIth element oft, where indexing is zero-based.
3 [Note 1: For the overload marked #1, if a typeT in Types is some reference typeX&, the return type isX&, not
X&&. However, if the element type is a non-reference typeT, the return type isT&&. —end note]
4 [Note 2: Constness is shallow. For the overload marked #2, if a typeT in Types is some reference typeX&,
the return type isX&, notconst X&. However, if the element type is a non-reference typeT, the return type is
const T&. This is consistent with how constness is defined to work for non-static data members of reference
type. —end note]
template<class T, class... Types>
constexpr T& get(tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr T&& get(tuple<Types...>&& t) noexcept;
template<class T, class... Types>
constexpr const T& get(const tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr const T&& get(const tuple<Types...>&& t) noexcept;
5 Mandates: The typeT occurs exactly once inTypes.
6 Returns: A reference to the element oft corresponding to the typeT in Types.
7 [Example 1:
const tuple<int, const int, double, double> t(1, 2, 3.4, 5.6);
const int& i1 = get<int>(t); // OK,i1 has value1
const int& i2 = get<const int>(t); // OK,i2 has value2
const double& d = get<double>(t); // error: typedouble is not unique withint
—end example]
8 [Note 3: The reason get is a non-member function is that if this functionality had been provided as a member
function, code where the type depended on a template parameter would have required using thetemplate keyword.
—end note]
22.4.9 Relational operators [tuple.rel]
template<class... TTypes, class... UTypes>
constexpr bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
template<class... TTypes, tuple-like UTuple>
constexpr bool operator==(const tuple<TTypes...>& t, const UTuple& u);
1 For the first overload letUTuple be tuple<UTypes...>.
§ 22.4.9 © ISO/IEC
830

===== PAGE 842 =====

Dxxxx
2 Constraints: For alli, where0 ≤i < sizeof...(TTypes), get<i>(t) == get<i>(u) is a valid ex-
pression anddecltype(get<i>(t) == get<i>(u)) models boolean-testable . sizeof...(TTypes)
equals tuple_size_v<UTuple>.
3 Returns: true if get<i>(t) == get<i>(u) for alli, otherwisefalse.
[Note 1: If sizeof...(TTypes) equals zero, returnstrue. —end note]
4 Remarks:
—(4.1) The elementary comparisons are performed in order from the zeroth index upwards. No comparisons
or element accesses are performed after the first equality comparison that evaluates tofalse.
—(4.2) The second overload is to be found via argument-dependent lookup (6.5.4) only.
template<class... TTypes, class... UTypes>
constexpr common_comparison_category_t<synth-three-way-result <TTypes, UTypes>...>
operator<=>(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
template<class... TTypes, tuple-like UTuple>
constexpr common_comparison_category_t<synth-three-way-result <TTypes, Elems>...>
operator<=>(const tuple<TTypes...>& t, const UTuple& u);
5 For the second overload,Elems denotes the pack of typestuple_element_t<0, UTuple>, tuple_-
element_t<1, UTuple>, ..., tuple_element_t<tuple_size_v<UTuple> - 1, UTuple>.
6 Effects: Performs a lexicographical comparison betweent and u. If sizeof...(TTypes) equals zero,
returns strong_ordering::equal. Otherwise, equivalent to:
if (auto c = synth-three-way (get<0>(t), get<0>(u)); c != 0) return c;
return ttail <=> utail;
where rtail for somer is a tuple containing all but the first element ofr.
7 Remarks: The second overload is to be found via argument-dependent lookup (6.5.4) only.
8 [Note 2: The above definition does not requirettail (or utail) to be constructed. It might not even be possible, ast
and u are not required to be copy constructible. Also, all comparison operator functions are short circuited; they do
not perform element accesses beyond what is needed to determine the result of the comparison.—end note]
22.4.10 common_reference related specializations [tuple.common.ref]
1 In the descriptions that follow:
—(1.1) Let TTypes be a pack formed by the sequence oftuple_element_t<i, TTuple> for every integer
0 ≤i< tuple_size_v<TTuple>.
—(1.2) Let UTypes be a pack formed by the sequence oftuple_element_t<i, UTuple> for every integer
0 ≤i< tuple_size_v<UTuple>.
template<tuple-like TTuple, tuple-like UTuple,
template<class> class TQual, template<class> class UQual>
struct basic_common_reference<TTuple, UTuple, TQual, UQual> {
using type = see below ;
};
2 Constraints:
—(2.1) TTuple is a specialization oftuple or UTuple is a specialization oftuple.
—(2.2) is_same_v<TTuple, decay_t<TTuple>> is true.
—(2.3) is_same_v<UTuple, decay_t<UTuple>> is true.
—(2.4) tuple_size_v<TTuple> equals tuple_size_v<UTuple>.
—(2.5) tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...> denotes a type.
3 Result: Themember typedef-name typedenotesthetype tuple<common_reference_t<TQual<TTypes>,
UQual<UTypes>>...>.
template<tuple-like TTuple, tuple-like UTuple>
struct common_type<TTuple, UTuple> {
using type = see below ;
};
4 Constraints:
§ 22.4.10 © ISO/IEC
831

===== PAGE 843 =====

Dxxxx
—(4.1) TTuple is a specialization oftuple or UTuple is a specialization oftuple.
—(4.2) is_same_v<TTuple, decay_t<TTuple>> is true.
—(4.3) is_same_v<UTuple, decay_t<UTuple>> is true.
—(4.4) tuple_size_v<TTuple> equals tuple_size_v<UTuple>.
—(4.5) tuple<common_type_t<TTypes, UTypes>...> denotes a type.
5 Result: The membertypedef-name type denotes the type
tuple<common_type_t<TTypes, UTypes>...>.
22.4.11 Tuple traits [tuple.traits]
template<class... Types, class Alloc>
struct uses_allocator<tuple<Types...>, Alloc> : true_type { };
1 Preconditions: Alloc meets theCpp17Allocator requirements (16.4.4.6.1).
2 [Note 1: Specialization of this trait informs other library components thattuple can be constructed with an
allocator, even though it does not have a nestedallocator_type. —end note]
22.4.12 Tuple specialized algorithms [tuple.special]
template<class... Types>
constexpr void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(see below );
template<class... Types>
constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(see below );
1 Constraints:
—(1.1) For the first overload,(is_swappable_v<Types> && ...) is true.
—(1.2) For the second overload,(is_swappable_v<const Types> && ...) is true.
2 Effects: As if byx.swap(y).
3 Remarks: The exception specification is equivalent to:
noexcept(x.swap(y))
22.5 Optional objects [optional]
22.5.1 General [optional.general]
1 Subclause 22.5 describes class templateoptional that represents optional objects. Anoptional objectis an
object that contains the storage for another object and manages the lifetime of this contained object, if any.
The contained object may be initialized after the optional object has been initialized, and may be destroyed
before the optional object has been destroyed. The initialization state of the contained object is tracked by
the optional object.
22.5.2 Header <optional> synopsis [optional.syn]
// mostly freestanding
#include <compare> // see 17.12.1
namespace std {
// 22.5.3, class templateoptional
template<class T>
class optional; // partially freestanding
// 22.5.4, partial specialization ofoptional for lvalue reference types
template<class T>
class optional<T&>; // partially freestanding
template<class T>
constexpr bool ranges::enable_view<optional<T>> = true;
template<class T>
constexpr auto format_kind<optional<T>> = range_format::disabled;
template<class T>
constexpr bool ranges::enable_borrowed_range<optional<T&>> = true;
§ 22.5.2 © ISO/IEC
832

===== PAGE 844 =====

Dxxxx
template<class T>
concept is-derived-from-optional = requires(const T& t) { // exposition only
[]<class U>(const optional<U>&){ }(t);
};
// 22.5.5, no-value state indicator
struct nullopt_t{see below };
inline constexpr nullopt_t nullopt(unspecified );
// 22.5.6, classbad_optional_access
class bad_optional_access;
// 22.5.7, relational operators
template<class T, class U>
constexpr bool operator==(const optional<T>&, const optional<U>&);
template<class T, class U>
constexpr bool operator!=(const optional<T>&, const optional<U>&);
template<class T, class U>
constexpr bool operator<(const optional<T>&, const optional<U>&);
template<class T, class U>
constexpr bool operator>(const optional<T>&, const optional<U>&);
template<class T, class U>
constexpr bool operator<=(const optional<T>&, const optional<U>&);
template<class T, class U>
constexpr bool operator>=(const optional<T>&, const optional<U>&);
template<class T, three_way_comparable_with<T> U>
constexpr compare_three_way_result_t<T, U>
operator<=>(const optional<T>&, const optional<U>&);
// 22.5.8, comparison withnullopt
template<class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
template<class T>
constexpr strong_ordering operator<=>(const optional<T>&, nullopt_t) noexcept;
// 22.5.9, comparison withT
template<class T, class U> constexpr bool operator==(const optional<T>&, const U&);
template<class T, class U> constexpr bool operator==(const T&, const optional<U>&);
template<class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
template<class T, class U> constexpr bool operator!=(const T&, const optional<U>&);
template<class T, class U> constexpr bool operator<(const optional<T>&, const U&);
template<class T, class U> constexpr bool operator<(const T&, const optional<U>&);
template<class T, class U> constexpr bool operator>(const optional<T>&, const U&);
template<class T, class U> constexpr bool operator>(const T&, const optional<U>&);
template<class T, class U> constexpr bool operator<=(const optional<T>&, const U&);
template<class T, class U> constexpr bool operator<=(const T&, const optional<U>&);
template<class T, class U> constexpr bool operator>=(const optional<T>&, const U&);
template<class T, class U> constexpr bool operator>=(const T&, const optional<U>&);
template<class T, class U>
requires (!is-derived-from-optional <U>) && three_way_comparable_with<T, U>
constexpr compare_three_way_result_t<T, U>
operator<=>(const optional<T>&, const U&);
// 22.5.10, specialized algorithms
template<class T>
constexpr void swap(optional<T>&, optional<T>&) noexcept(see below );
template<class T>
constexpr optional<decay_t<T>> make_optional(T&&);
template<class T, class... Args>
constexpr optional<T> make_optional(Args&&... args);
template<class T, class U, class... Args>
constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);
§ 22.5.2 © ISO/IEC
833

===== PAGE 845 =====

Dxxxx
// 22.5.11, hash support
template<class T> struct hash;
template<class T> struct hash<optional<T>>;
}
22.5.3 Class template optional [optional.optional]
22.5.3.1 General [optional.optional.general]
namespace std {
template<class T>
class optional {
public:
using value_type = T;
using iterator = implementation-defined; // see 22.5.3.6
using const_iterator = implementation-defined; // see 22.5.3.6
// 22.5.3.2, constructors
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
constexpr optional(const optional&);
constexpr optional(optional&&) noexcept(see below );
template<class... Args>
constexpr explicit optional(in_place_t, Args&&...);
template<class U, class... Args>
constexpr explicit optional(in_place_t, initializer_list<U>, Args&&...);
template<class U = remove_cv_t<T>>
constexpr explicit(see below ) optional(U&&);
template<class U>
constexpr explicit(see below ) optional(const optional<U>&);
template<class U>
constexpr explicit(see below ) optional(optional<U>&&);
// 22.5.3.3, destructor
constexpr ~optional();
// 22.5.3.4, assignment
constexpr optional& operator=(nullopt_t) noexcept;
constexpr optional& operator=(const optional&);
constexpr optional& operator=(optional&&) noexcept(see below );
template<class U = remove_cv_t<T>> constexpr optional& operator=(U&&);
template<class U> constexpr optional& operator=(const optional<U>&);
template<class U> constexpr optional& operator=(optional<U>&&);
template<class... Args> constexpr T& emplace(Args&&...);
template<class U, class... Args> constexpr T& emplace(initializer_list<U>, Args&&...);
// 22.5.3.5, swap
constexpr void swap(optional&) noexcept(see below );
// 22.5.3.6, iterator support
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
// 22.5.3.7, observers
constexpr const T* operator->() const noexcept;
constexpr T* operator->() noexcept;
constexpr const T& operator*() const & noexcept;
constexpr T& operator*() & noexcept;
constexpr T&& operator*() && noexcept;
constexpr const T&& operator*() const && noexcept;
constexpr explicit operator bool() const noexcept;
constexpr bool has_value() const noexcept;
constexpr const T& value() const &; // freestanding-deleted
§ 22.5.3.1 © ISO/IEC
834

===== PAGE 846 =====

Dxxxx
constexpr T& value() &; // freestanding-deleted
constexpr T&& value() &&; // freestanding-deleted
constexpr const T&& value() const &&; // freestanding-deleted
template<class U = remove_cv_t<T>> constexpr T value_or(U&&) const &;
template<class U = remove_cv_t<T>> constexpr T value_or(U&&) &&;
// 22.5.3.8, monadic operations
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &;
template<class F> constexpr auto and_then(F&& f) const &&;
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &;
template<class F> constexpr auto transform(F&& f) const &&;
template<class F> constexpr optional or_else(F&& f) &&;
template<class F> constexpr optional or_else(F&& f) const &;
// 22.5.3.9, modifiers
constexpr void reset() noexcept;
private:
union {
remove_cv_t<T> val; // exposition only
};
};
template<class T>
optional(T) -> optional<T>;
}
1 An instance ofoptional<T> is said tocontain a valuewhen and only when its memberval is active (11.5.1);
val is referred to as itscontained value. An optional object’s contained value is nested within (6.8.2) the
optional object.
2 A type X is a valid contained typefor optional if X is an lvalue reference type or a complete non-array
object type, andremove_cvref_t<X> is a type other thanin_place_t or nullopt_t. If a specialization
of optional is instantiated with a typeT that is not a valid contained type foroptional, the program is
ill-formed. If T is an object type,T shall meet theCpp17Destructible requirements (Table 35).
22.5.3.2 Constructors [optional.ctor]
1 The exposition-only variable templateconverts-from-any-cvref is used by some constructors foroptional.
template<class T, class W>
constexpr bool converts-from-any-cvref = // exposition only
disjunction_v<is_constructible<T, W&>, is_convertible<W&, T>,
is_constructible<T, W>, is_convertible<W, T>,
is_constructible<T, const W&>, is_convertible<const W&, T>,
is_constructible<T, const W>, is_convertible<const W, T>>;
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
2 Postconditions: *this does not contain a value.
3 Remarks: No contained value is initialized. For every object typeT these constructors are constexpr
constructors (9.2.6).
constexpr optional(const optional& rhs);
4 Effects: If rhs contains a value, direct-non-list-initializesval with rhs.val .
5 Postconditions: rhs.has_value() == this->has_value().
6 Throws: Any exception thrown by the selected constructor ofT.
§ 22.5.3.2 © ISO/IEC
835

===== PAGE 847 =====

Dxxxx
7 Remarks: This constructor is defined as deleted unlessis_copy_constructible_v<T> is true. If
is_trivially_copy_constructible_v<T> is true, this constructor is trivial.
constexpr optional(optional&& rhs) noexcept(see below );
8 Constraints: is_move_constructible_v<T> is true.
9 Effects: If rhs contains a value, direct-non-list-initializesval with std::move(rhs.val ). rhs.has_-
value() is unchanged.
10 Postconditions: rhs.has_value() == this->has_value().
11 Throws: Any exception thrown by the selected constructor ofT.
12 Remarks: The exception specification is equivalent tois_nothrow_move_constructible_v<T>. If
is_trivially_move_constructible_v<T> is true, this constructor is trivial.
template<class... Args> constexpr explicit optional(in_place_t, Args&&... args);
13 Constraints: is_constructible_v<T, Args...> is true.
14 Effects: Direct-non-list-initializes val with std::forward<Args>(args)....
15 Postconditions: *this contains a value.
16 Throws: Any exception thrown by the selected constructor ofT.
17 Remarks: If T’s constructor selected for the initialization is a constexpr constructor, this constructor is
a constexpr constructor.
template<class U, class... Args>
constexpr explicit optional(in_place_t, initializer_list<U> il, Args&&... args);
18 Constraints: is_constructible_v<T, initializer_list<U>&, Args...> is true.
19 Effects: Direct-non-list-initializes val with il, std::forward<Args>(args)....
20 Postconditions: *this contains a value.
21 Throws: Any exception thrown by the selected constructor ofT.
22 Remarks: If T’s constructor selected for the initialization is a constexpr constructor, this constructor is
a constexpr constructor.
template<class U = remove_cv_t<T>> constexpr explicit(see below ) optional(U&& v);
23 Constraints:
—(23.1) is_constructible_v<T, U> is true,
—(23.2) is_same_v<remove_cvref_t<U>, in_place_t> is false,
—(23.3) is_same_v<remove_cvref_t<U>, optional> is false, and
—(23.4) if T is cv bool, remove_cvref_t<U> is not a specialization ofoptional.
24 Effects: Direct-non-list-initializes val with std::forward<U>(v).
25 Postconditions: *this contains a value.
26 Throws: Any exception thrown by the selected constructor ofT.
27 Remarks: If T’s selected constructor is a constexpr constructor, this constructor is a constexpr
constructor. The expression insideexplicit is equivalent to:
!is_convertible_v<U, T>
template<class U> constexpr explicit(see below ) optional(const optional<U>& rhs);
28 Constraints:
—(28.1) is_constructible_v<T, const U&> is true, and
—(28.2) if T is notcv bool, converts-from-any-cvref <T, optional<U>> is false.
29 Effects: If rhs contains a value, direct-non-list-initializesval with rhs.operator*().
30 Postconditions: rhs.has_value() == this->has_value().
31 Throws: Any exception thrown by the selected constructor ofT.
§ 22.5.3.2 © ISO/IEC
836

===== PAGE 848 =====

Dxxxx
32 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<const U&, T>
template<class U> constexpr explicit(see below ) optional(optional<U>&& rhs);
33 Constraints:
—(33.1) is_constructible_v<T, U> is true, and
—(33.2) if T is notcv bool, converts-from-any-cvref <T, optional<U>> is false.
34 Effects: If rhs contains a value, direct-non-list-initializesval with std::move(rhs).operator*().
rhs.has_value() is unchanged.
35 Postconditions: rhs.has_value() == this->has_value().
36 Throws: Any exception thrown by the selected constructor ofT.
37 Remarks: The expression insideexplicit is equivalent to:
!is_convertible_v<U, T>
22.5.3.3 Destructor [optional.dtor]
constexpr ~optional();
1 Effects: Ifis_trivially_destructible_v<T>isfalseand*thiscontains a value, callsval .T::~T().
2 Remarks: If is_trivially_destructible_v<T> is true, then this destructor is trivial.
22.5.3.4 Assignment [optional.assign]
constexpr optional<T>& operator=(nullopt_t) noexcept;
1 Effects: If *this contains a value, callsval .T::~T() to destroy the contained value; otherwise no
effect.
2 Postconditions: *this does not contain a value.
3 Returns: *this.
constexpr optional<T>& operator=(const optional& rhs);
4 Effects: See Table 67.
Table 67 —optional::operator=(const optional&) effects [tab:optional.assign.copy]
*this contains a value *this does not contain a
value
rhs contains a
value assigns rhs.val to val direct-non-list-initializes val
with rhs.val
rhs does not
contain a value
destroys the contained value
by callingval .T::~T() no effect
5 Postconditions: rhs.has_value() == this->has_value().
6 Returns: *this.
7 Remarks: If any exception is thrown, the result of the expressionthis->has_value() remains un-
changed. If an exception is thrown during the call toT’s copy constructor, no effect. If an exception
is thrown during the call toT’s copy assignment, the state of its contained value is as defined by the
exception safety guarantee ofT’s copy assignment. This operator is defined as deleted unlessis_-
copy_constructible_v<T> is true and is_copy_assignable_v<T> is true. If is_trivially_copy_-
constructible_v<T> && is_trivially_copy_assignable_v<T> && is_trivially_destructible_-
v<T> is true, this assignment operator is trivial.
constexpr optional& operator=(optional&& rhs) noexcept(see below );
8 Constraints: is_move_constructible_v<T> is true and is_move_assignable_v<T> is true.
9 Effects: See Table 68. The result of the expressionrhs.has_value() remains unchanged.
§ 22.5.3.4 © ISO/IEC
837

===== PAGE 849 =====

Dxxxx
Table 68 —optional::operator=(optional&&) effects [tab:optional.assign.move]
*this contains a value *this does not contain a
value
rhs contains a
value
assigns std::move(rhs.val )
to val
direct-non-list-initializes val
with std::move(rhs.val )
rhs does not
contain a value
destroys the contained value
by callingval .T::~T() no effect
10 Postconditions: rhs.has_value() == this->has_value().
11 Returns: *this.
12 Remarks: The exception specification is equivalent to:
is_nothrow_move_assignable_v<T> && is_nothrow_move_constructible_v<T>
13 If any exception is thrown, the result of the expressionthis->has_value() remains unchanged. If an
exception is thrown during the call toT’s move constructor, the state ofrhs.val is determined by the
exception safety guarantee ofT’s move constructor. If an exception is thrown during the call toT’s move
assignment, the states ofval and rhs.val are determined by the exception safety guarantee ofT’s move
assignment. If is_trivially_move_constructible_v<T> && is_trivially_move_assignable_v<T>
&& is_trivially_destructible_v<T>is true, this assignment operator is trivial.
template<class U = remove_cv_t<T>> constexpr optional& operator=(U&& v);
14 Constraints:
—(14.1) is_same_v<remove_cvref_t<U>, optional> is false,
—(14.2) conjunction_v<is_scalar<T>, is_same<T, decay_t<U>>> is false,
—(14.3) is_constructible_v<T, U> is true, and
—(14.4) is_assignable_v<T&, U> is true.
15 Effects: If *this contains a value, assignsstd::forward<U>(v) to val ; otherwise direct-non-list-
initializes val with std::forward<U>(v).
16 Postconditions: *this contains a value.
17 Returns: *this.
18 Remarks: If any exception is thrown, the result of the expressionthis->has_value() remains un-
changed. If an exception is thrown during the call toT’s constructor, the state ofv is determined
by the exception safety guarantee ofT’s constructor. If an exception is thrown during the call toT’s
assignment, the states ofval and v are determined by the exception safety guarantee ofT’s assignment.
template<class U> constexpr optional<T>& operator=(const optional<U>& rhs);
19 Constraints:
—(19.1) is_constructible_v<T, const U&> is true,
—(19.2) is_assignable_v<T&, const U&> is true,
—(19.3) converts-from-any-cvref <T, optional<U>> is false,
—(19.4) is_assignable_v<T&, optional<U>&> is false,
—(19.5) is_assignable_v<T&, optional<U>&&> is false,
—(19.6) is_assignable_v<T&, const optional<U>&> is false, and
—(19.7) is_assignable_v<T&, const optional<U>&&> is false.
20 Effects: See Table 69.
21 Postconditions: rhs.has_value() == this->has_value().
22 Returns: *this.
23 Remarks: If any exception is thrown, the result of the expressionthis->has_value() remains un-
changed. If an exception is thrown during the call toT’s constructor, the state ofrhs.val is determined
§ 22.5.3.4 © ISO/IEC
838

===== PAGE 850 =====

Dxxxx
Table 69 —optional::operator=(const optional<U>&) effects [tab:optional.assign.copy.templ]
*this contains a value *this does not contain a
value
rhs contains a
value
assigns rhs.operator*() to
val
direct-non-list-initializes val
with rhs.operator*()
rhs does not
contain a value
destroys the contained value
by callingval .T::~T() no effect
by the exception safety guarantee ofT’s constructor. If an exception is thrown during the call toT’s
assignment, the states ofval and rhs.val are determined by the exception safety guarantee ofT’s
assignment.
template<class U> constexpr optional<T>& operator=(optional<U>&& rhs);
24 Constraints:
—(24.1) is_constructible_v<T, U> is true,
—(24.2) is_assignable_v<T&, U> is true,
—(24.3) converts-from-any-cvref <T, optional<U>> is false,
—(24.4) is_assignable_v<T&, optional<U>&> is false,
—(24.5) is_assignable_v<T&, optional<U>&&> is false,
—(24.6) is_assignable_v<T&, const optional<U>&> is false, and
—(24.7) is_assignable_v<T&, const optional<U>&&> is false.
25 Effects: See Table 70. The result of the expressionrhs.has_value() remains unchanged.
Table 70 —optional::operator=(optional<U>&&) effects [tab:optional.assign.move.templ]
*this contains a value *this does not contain a
value
rhs contains a
value
assigns std::move(rhs).op-
erator*() to val
direct-non-list-initializes val
with std::move(rhs).opera-
tor*()
rhs does not
contain a value
destroys the contained value
by callingval .T::~T() no effect
26 Postconditions: rhs.has_value() == this->has_value().
27 Returns: *this.
28 Remarks: If any exception is thrown, the result of the expressionthis->has_value() remains un-
changed. If an exception is thrown during the call toT’s constructor, the state ofrhs.val is determined
by the exception safety guarantee ofT’s constructor. If an exception is thrown during the call toT’s
assignment, the states ofval and rhs.val are determined by the exception safety guarantee ofT’s
assignment.
template<class... Args> constexpr T& emplace(Args&&... args);
29 Mandates: is_constructible_v<T, Args...> is true.
30 Effects: Calls *this = nullopt. Then direct-non-list-initializesval with std::forward<Args>(args
)....
31 Postconditions: *this contains a value.
32 Returns: val .
33 Throws: Any exception thrown by the selected constructor ofT.
§ 22.5.3.4 © ISO/IEC
839

===== PAGE 851 =====

Dxxxx
34 Remarks: If an exception is thrown during the call toT’s constructor,*this does not contain a value,
and the previousval (if any) has been destroyed.
template<class U, class... Args> constexpr T& emplace(initializer_list<U> il, Args&&... args);
35 Constraints: is_constructible_v<T, initializer_list<U>&, Args...> is true.
36 Effects: Calls *this = nullopt. Then direct-non-list-initializesval with il, std::forward<Args>(
args)....
37 Postconditions: *this contains a value.
38 Returns: val .
39 Throws: Any exception thrown by the selected constructor ofT.
40 Remarks: If an exception is thrown during the call toT’s constructor,*this does not contain a value,
and the previousval (if any) has been destroyed.
22.5.3.5 Swap [optional.swap]
constexpr void swap(optional& rhs) noexcept(see below );
1 Mandates: is_move_constructible_v<T> is true.
2 Preconditions: T meets theCpp17Swappable requirements (16.4.4.3).
3 Effects: See Table 71.
Table 71 —optional::swap(optional&) effects [tab:optional.swap]
*this contains a value *this does not contain a
value
rhs contains a
value calls swap(val , rhs.val )
direct-non-list-
initializes val with
std::move(rhs.val ), fol-
lowed by rhs.val .T::~T();
postcondition is that *this
contains a value andrhs does
not contain a value
rhs does not
contain a value
direct-non-list-initializes
rhs.val with
std::move(val ), followed by
val .T::~T(); postcondition
is that*this does not contain
a value and rhs contains a
value
no effect
4 Throws: Any exceptions thrown by the operations in the relevant part of Table 71.
5 Remarks: The exception specification is equivalent to:
is_nothrow_move_constructible_v<T> && is_nothrow_swappable_v<T>
6 If any exception is thrown, the results of the expressionsthis->has_value() and rhs.has_value()
remain unchanged. If an exception is thrown during the call to functionswap, the states ofval and
rhs.val are determined by the exception safety guarantee ofswap for lvalues ofT. If an exception is
thrown during the call toT’s move constructor, the states ofval and rhs.val are determined by the
exception safety guarantee ofT’s move constructor.
22.5.3.6 Iterator support [optional.iterators]
using iterator = implementation-defined ;
using const_iterator = implementation-defined ;
1 These types modelcontiguous_iterator (24.3.4.14), meet theCpp17RandomAccessIteratorrequire-
ments (24.3.5.7), and meet the requirements for constexpr iterators (24.3.1), with value typeremove_-
cv_t<T>. The reference type isT& for iterator and const T& for const_iterator.
§ 22.5.3.6 © ISO/IEC
840

===== PAGE 852 =====

Dxxxx
2 All requirements on container iterators (23.2.2.2) apply tooptional::iterator and optional::
const_iterator as well.
3 Any operation that initializes or destroys the contained value of an optional object invalidates all
iterators into that object.
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
4 Returns: If has_value() is true, an iterator referring to the contained value. Otherwise, a past-the-end
iterator value.
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
5 Returns: begin() + has_value().
22.5.3.7 Observers [optional.observe]
constexpr const T* operator->() const noexcept;
constexpr T* operator->() noexcept;
1 Hardened preconditions: has_value() is true.
2 Returns: addressof(val ).
3 Remarks: These functions are constexpr functions.
constexpr const T& operator*() const & noexcept;
constexpr T& operator*() & noexcept;
4 Hardened preconditions: has_value() is true.
5 Returns: val .
6 Remarks: These functions are constexpr functions.
constexpr T&& operator*() && noexcept;
constexpr const T&& operator*() const && noexcept;
7 Hardened preconditions: has_value() is true.
8 Effects: Equivalent to:return std::move(val );
constexpr explicit operator bool() const noexcept;
9 Returns: true if and only if*this contains a value.
10 Remarks: This function is a constexpr function.
constexpr bool has_value() const noexcept;
11 Returns: true if and only if*this contains a value.
12 Remarks: This function is a constexpr function.
constexpr const T& value() const &;
constexpr T& value() &;
13 Effects: Equivalent to:
return has_value() ? val : throw bad_optional_access();
constexpr T&& value() &&;
constexpr const T&& value() const &&;
14 Effects: Equivalent to:
return has_value() ? std::move(val ) : throw bad_optional_access();
template<class U = remove_cv_t<T>> constexpr T value_or(U&& v) const &;
15 Mandates: is_copy_constructible_v<T> && is_convertible_v<U&&, T> is true.
16 Effects: Equivalent to:
return has_value() ? val : static_cast<T>(std::forward<U>(v));
§ 22.5.3.7 © ISO/IEC
841

===== PAGE 853 =====

Dxxxx
template<class U = remove_cv_t<T>> constexpr T value_or(U&& v) &&;
17 Mandates: is_move_constructible_v<T> && is_convertible_v<U&&, T> is true.
18 Effects: Equivalent to:
return has_value() ? std::move(val ) : static_cast<T>(std::forward<U>(v));
22.5.3.8 Monadic operations [optional.monadic]
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) const &;
1 Let U be invoke_result_t<F, decltype((val ))>.
2 Mandates: remove_cvref_t<U> is a specialization ofoptional.
3 Effects: Equivalent to:
if (*this) {
return invoke(std::forward<F>(f), val );
} else {
return remove_cvref_t<U>();
}
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &&;
4 Let U be invoke_result_t<F, decltype(std::move(val ))>.
5 Mandates: remove_cvref_t<U> is a specialization ofoptional.
6 Effects: Equivalent to:
if (*this) {
return invoke(std::forward<F>(f), std::move(val ));
} else {
return remove_cvref_t<U>();
}
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) const &;
7 Let U be remove_cv_t<invoke_result_t<F, decltype((val ))>>.
8 Mandates: U is a valid contained type foroptional. The declaration
U u(invoke(std::forward<F>(f), val ));
is well-formed for some invented variableu.
[Note 1: There is no requirement thatU is movable (9.5.1).—end note]
9 Returns: If *this contains a value, anoptional<U> object whose contained value is direct-non-list-
initialized withinvoke(std::forward<F>(f), val ); otherwise,optional<U>().
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &&;
10 Let U be remove_cv_t<invoke_result_t<F, decltype(std::move(val ))>>.
11 Mandates: U is a valid contained type foroptional. The declaration
U u(invoke(std::forward<F>(f), std::move(val )));
is well-formed for some invented variableu.
[Note 2: There is no requirement thatU is movable (9.5.1).—end note]
12 Returns: If *this contains a value, anoptional<U> object whose contained value is direct-non-list-
initialized withinvoke(std::forward<F>(f), std::move(val )); otherwise,optional<U>().
template<class F> constexpr optional or_else(F&& f) const &;
13 Constraints: F models invocable and T models copy_constructible.
14 Mandates: is_same_v<remove_cvref_t<invoke_result_t<F>>, optional> is true.
15 Effects: Equivalent to:
§ 22.5.3.8 © ISO/IEC
842

===== PAGE 854 =====

Dxxxx
if (*this) {
return *this;
} else {
return std::forward<F>(f)();
}
template<class F> constexpr optional or_else(F&& f) &&;
16 Constraints: F models invocable and T models move_constructible.
17 Mandates: is_same_v<remove_cvref_t<invoke_result_t<F>>, optional> is true.
18 Effects: Equivalent to:
if (*this) {
return std::move(*this);
} else {
return std::forward<F>(f)();
}
22.5.3.9 Modifiers [optional.mod]
constexpr void reset() noexcept;
1 Effects: If *this contains a value, callsval .T::~T() to destroy the contained value; otherwise no
effect.
2 Postconditions: *this does not contain a value.
22.5.4 Partial specialization of optional for reference types [optional.optional.ref]
22.5.4.1 General [optional.optional.ref.general]
namespace std {
template<class T>
class optional<T&> {
public:
using value_type = T;
using iterator = implementation-defined; // present only ifT is an object type other than an array
// of unknown bound; see 22.5.4.5
public:
// 22.5.4.2, constructors
constexpr optional() noexcept = default;
constexpr optional(nullopt_t) noexcept : optional() {}
constexpr optional(const optional& rhs) noexcept = default;
template<class Arg>
constexpr explicit optional(in_place_t, Arg&& arg);
template<class U>
constexpr explicit(see below ) optional(U&& u) noexcept(see below );
template<class U>
constexpr explicit(see below ) optional(optional<U>& rhs) noexcept(see below );
template<class U>
constexpr explicit(see below ) optional(const optional<U>& rhs) noexcept(see below );
template<class U>
constexpr explicit(see below ) optional(optional<U>&& rhs) noexcept(see below );
template<class U>
constexpr explicit(see below ) optional(const optional<U>&& rhs) noexcept(see below );
constexpr ~optional() = default;
// 22.5.4.3, assignment
constexpr optional& operator=(nullopt_t) noexcept;
constexpr optional& operator=(const optional& rhs) noexcept = default;
template<class U> constexpr T& emplace(U&& u) noexcept(see below );
§ 22.5.4.1 © ISO/IEC
843

===== PAGE 855 =====

Dxxxx
// 22.5.4.4, swap
constexpr void swap(optional& rhs) noexcept;
// 22.5.4.5, iterator support
constexpr auto begin() const noexcept;
constexpr auto end() const noexcept;
// 22.5.4.6, observers
constexpr T* operator->() const noexcept;
constexpr T& operator*() const noexcept;
constexpr explicit operator bool() const noexcept;
constexpr bool has_value() const noexcept;
constexpr T& value() const; // freestanding-deleted
template<class U = remove_cv_t<T>>
constexpr remove_cv_t<T> value_or(U&& u) const;
// 22.5.4.7, monadic operations
template<class F> constexpr auto and_then(F&& f) const;
template<class F> constexpr optional<invoke_result_t<F, T&>> transform(F&& f) const;
template<class F> constexpr optional or_else(F&& f) const;
// 22.5.4.8, modifiers
constexpr void reset() noexcept;
private:
T* val = nullptr; // exposition only
// 22.5.4.9, exposition only helper functions
template<class U>
constexpr void convert-ref-init-val(U&& u); // exposition only
};
}
1 An object of type optional<T&> contains a value if and only if val != nullptr is true. When an
optional<T&> contains a value, thecontained valueis a reference to*val .
2 Each typeoptional<T&> is a trivially copyable class (11.2).
22.5.4.2 Constructors [optional.ref.ctor]
template<class Arg>
constexpr explicit optional(in_place_t, Arg&& arg);
1 Constraints:
—(1.1) is_constructible_v<T&, Arg> is true, and
—(1.2) reference_constructs_from_temporary_v<T&, Arg> is false.
2 Effects: Equivalent to:convert-ref-init-val (std::forward<Arg>(arg)).
3 Postconditions: *this contains a value.
template<class U>
constexpr explicit(!is_convertible_v<U, T&>)
optional(U&& u) noexcept(is_nothrow_constructible_v<T&, U>);
4 Constraints:
—(4.1) is_same_v<remove_cvref_t<U>, optional> is false,
—(4.2) is_same_v<remove_cvref_t<U>, in_place_t> is false, and
—(4.3) is_constructible_v<T&, U> is true.
5 Effects: Equivalent to:convert-ref-init-val (std::forward<U>(u)).
6 Postconditions: *this contains a value.
7 Remarks: This constructor is defined as deleted if
reference_constructs_from_temporary_v<T&, U>
§ 22.5.4.2 © ISO/IEC
844

===== PAGE 856 =====

Dxxxx
is true.
template<class U>
constexpr explicit(!is_convertible_v<U&, T&>)
optional(optional<U>& rhs) noexcept(is_nothrow_constructible_v<T&, U&>);
8 Constraints:
—(8.1) is_same_v<remove_cv_t<T>, optional<U>> is false,
—(8.2) is_same_v<T&, U> is false, and
—(8.3) is_constructible_v<T&, U&> is true.
9 Effects: Equivalent to:
if (rhs.has_value()) convert-ref-init-val (rhs.operator*());
10 Remarks: This constructor is defined as deleted if
reference_constructs_from_temporary_v<T&, U&>
is true.
template<class U>
constexpr explicit(!is_convertible_v<const U&, T&>)
optional(const optional<U>& rhs) noexcept(is_nothrow_constructible_v<T&, const U&>);
11 Constraints:
—(11.1) is_same_v<remove_cv_t<T>, optional<U>> is false,
—(11.2) is_same_v<T&, U> is false, and
—(11.3) is_constructible_v<T&, const U&> is true.
12 Effects: Equivalent to:
if (rhs.has_value()) convert-ref-init-val (rhs.operator*());
13 Remarks: This constructor is defined as deleted if
reference_constructs_from_temporary_v<T&, const U&>
is true.
template<class U>
constexpr explicit(!is_convertible_v<U, T&>)
optional(optional<U>&& rhs) noexcept(is_nothrow_constructible_v<T&, U>);
14 Constraints:
—(14.1) is_same_v<remove_cv_t<T>, optional<U>> is false,
—(14.2) is_same_v<T&, U> is false, and
—(14.3) is_constructible_v<T&, U> is true.
15 Effects: Equivalent to:
if (rhs.has_value()) convert-ref-init-val (std::move(rhs).operator*());
16 Remarks: This constructor is defined as deleted if
reference_constructs_from_temporary_v<T&, U>
is true.
template<class U>
constexpr explicit(!is_convertible_v<const U, T&>)
optional(const optional<U>&& rhs) noexcept(is_nothrow_constructible_v<T&, const U>);
17 Constraints:
—(17.1) is_same_v<remove_cv_t<T>, optional<U>> is false,
—(17.2) is_same_v<T&, U> is false, and
—(17.3) is_constructible_v<T&, const U> is true.
18 Effects: Equivalent to:
§ 22.5.4.2 © ISO/IEC
845

===== PAGE 857 =====

Dxxxx
if (rhs.has_value()) convert-ref-init-val (std::move(rhs).operator*());
19 Remarks: This constructor is defined as deleted if
reference_constructs_from_temporary_v<T&, const U>
is true.
22.5.4.3 Assignment [optional.ref.assign]
constexpr optional& operator=(nullopt_t) noexcept;
1 Effects: Assigns nullptr to val .
2 Postconditions: *this does not contain a value.
3 Returns: *this.
template<class U>
constexpr T& emplace(U&& u) noexcept(is_nothrow_constructible_v<T&, U>);
4 Constraints:
—(4.1) is_constructible_v<T&, U> is true, and
—(4.2) reference_constructs_from_temporary_v<T&, U> is false.
5 Effects: Equivalent to:convert-ref-init-val (std::forward<U>(u)).
6 Returns: *val .
22.5.4.4 Swap [optional.ref.swap]
constexpr void swap(optional& rhs) noexcept;
1 Effects: Equivalent to:std::swap(val , rhs.val ).
22.5.4.5 Iterator support [optional.ref.iterators]
using iterator = implementation-defined; // present only ifT is an object type other than an array
// of unknown bound
1 This type modelscontiguous_iterator (24.3.4.14), meets theCpp17RandomAccessIteratorrequire-
ments (24.3.5.7), and meets the requirements for constexpr iterators (24.3.1), with value typeremove_-
cv_t<T>. The reference type isT& for iterator.
2 All requirements on container iterators (23.2.2.2) apply tooptional::iterator.
constexpr auto begin() const noexcept;
3 Constraints: T is an object type other than an array of unknown bound.
4 Returns: An objecti of typeiterator, such thati is an iterator referring to*val if has_value() is
true, and a past-the-end iterator value otherwise.
constexpr auto end() const noexcept;
5 Constraints: T is an object type other than an array of unknown bound.
6 Returns: begin() + has_value().
22.5.4.6 Observers [optional.ref.observe]
constexpr T* operator->() const noexcept;
1 Hardened preconditions: has_value() is true.
2 Returns: val .
constexpr T& operator*() const noexcept;
3 Hardened preconditions: has_value() is true.
4 Returns: *val .
constexpr explicit operator bool() const noexcept;
5 Returns: val != nullptr.
§ 22.5.4.6 © ISO/IEC
846

===== PAGE 858 =====

Dxxxx
constexpr bool has_value() const noexcept;
6 Returns: val != nullptr.
constexpr T& value() const;
7 Effects: Equivalent to:
return has_value() ? *val : throw bad_optional_access();
template<class U = remove_cv_t<T>> constexpr remove_cv_t<T> value_or(U&& u) const;
8 Constraints: T is a non-array object type.
9 Let X be remove_cv_t<T>.
10 Mandates: is_constructible_v<X, T&> && is_convertible_v<U, X> is true.
11 Effects: Equivalent to:
return has_value() ? *val : static_cast<X>(std::forward<U>(u));
12 Remarks: The return type is unspecified ifT is an array type or a non-object type.
[Note 1: This is to avoid the declaration being ill-formed.—end note]
22.5.4.7 Monadic operations [optional.ref.monadic]
template<class F> constexpr auto and_then(F&& f) const;
1 Let U be invoke_result_t<F, T&>.
2 Mandates: remove_cvref_t<U> is a specialization ofoptional.
3 Effects: Equivalent to:
if (has_value()) {
return invoke(std::forward<F>(f), *val );
} else {
return remove_cvref_t<U>();
}
template<class F>
constexpr optional<remove_cv_t<invoke_result_t<F, T&>>> transform(F&& f) const;
4 Let U be remove_cv_t<invoke_result_t<F, T&>>.
5 Mandates: U is a valid contained type foroptional. The declaration
U u(invoke(std::forward<F>(f), *val ));
is well-formed for some invented variableu.
[Note 1: There is no requirement thatU is movable (9.5.1).—end note]
6 Returns: If *this contains a value, anoptional<U> object whose contained value is direct-non-list-
initialized withinvoke(std::forward<F>(f), *val ); otherwise,optional<U>().
template<class F> constexpr optional or_else(F&& f) const;
7 Constraints: F models invocable.
8 Mandates: is_same_v<remove_cvref_t<invoke_result_t<F>>, optional> is true.
9 Effects: Equivalent to:
if (has_value()) {
return *val ;
} else {
return std::forward<F>(f)();
}
22.5.4.8 Modifiers [optional.ref.mod]
constexpr void reset() noexcept;
1 Effects: Assigns nullptr to val .
2 Postconditions: *this does not contain a value.
§ 22.5.4.8 © ISO/IEC
847

===== PAGE 859 =====

Dxxxx
22.5.4.9 Exposition only helper functions [optional.ref.expos]
template<class U>
constexpr void convert-ref-init-val (U&& u); // exposition only
1 Effects: Creates a variable r as if by T& r(std::forward<U>(u)); and then initializes val with
addressof(r).
22.5.5 No-value state indicator [optional.nullopt]
struct nullopt_t{see below };
inline constexpr nullopt_t nullopt(unspecified );
1 The structnullopt_t is an empty class type used as a unique type to indicate the state of not containing
a value foroptional objects. In particular, optional<T> has a constructor withnullopt_t as a single
argument; this indicates that an optional object not containing a value shall be constructed.
2 Type nullopt_t shall not have a default constructor or an initializer-list constructor, and shall not be an
aggregate.
22.5.6 Class bad_optional_access [optional.bad.access]
namespace std {
class bad_optional_access : public exception {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 The classbad_optional_access defines the type of objects thrown as exceptions to report the situation
where an attempt is made to access the value of an optional object that does not contain a value.
constexpr const char* what() const noexcept override;
2 Returns: An implementation-defined ntbs, which during constant evaluation is encoded with the
ordinary literal encoding (5.13.3).
22.5.7 Relational operators [optional.relops]
template<class T, class U> constexpr bool operator==(const optional<T>& x, const optional<U>& y);
1 Constraints: The expression*x == *y is well-formed and its result is convertible tobool.
[Note 1: T need not beCpp17EqualityComparable. —end note]
2 Returns: If x.has_value() != y.has_value(), false; otherwise ifx.has_value() == false, true;
otherwise *x == *y.
3 Remarks: Specializations of this function template for which*x == *y is a core constant expression
are constexpr functions.
template<class T, class U> constexpr bool operator!=(const optional<T>& x, const optional<U>& y);
4 Constraints: The expression*x != *y is well-formed and its result is convertible tobool.
5 Returns: If x.has_value() != y.has_value(), true; otherwise, ifx.has_value() == false, false;
otherwise *x != *y.
6 Remarks: Specializations of this function template for which*x != *y is a core constant expression
are constexpr functions.
template<class T, class U> constexpr bool operator<(const optional<T>& x, const optional<U>& y);
7 Constraints: *x < *y is well-formed and its result is convertible tobool.
8 Returns: If !y, false; otherwise, if!x, true; otherwise*x < *y.
9 Remarks: Specializations of this function template for which*x < *y is a core constant expression are
constexpr functions.
§ 22.5.7 © ISO/IEC
848

===== PAGE 860 =====

Dxxxx
template<class T, class U> constexpr bool operator>(const optional<T>& x, const optional<U>& y);
10 Constraints: The expression*x > *y is well-formed and its result is convertible tobool.
11 Returns: If !x, false; otherwise, if!y, true; otherwise*x > *y.
12 Remarks: Specializations of this function template for which*x > *y is a core constant expression are
constexpr functions.
template<class T, class U> constexpr bool operator<=(const optional<T>& x, const optional<U>& y);
13 Constraints: The expression*x <= *y is well-formed and its result is convertible tobool.
14 Returns: If !x, true; otherwise, if!y, false; otherwise*x <= *y.
15 Remarks: Specializations of this function template for which*x <= *y is a core constant expression
are constexpr functions.
template<class T, class U> constexpr bool operator>=(const optional<T>& x, const optional<U>& y);
16 Constraints: The expression*x >= *y is well-formed and its result is convertible tobool.
17 Returns: If !y, true; otherwise, if!x, false; otherwise*x >= *y.
18 Remarks: Specializations of this function template for which*x >= *y is a core constant expression
are constexpr functions.
template<class T, three_way_comparable_with<T> U>
constexpr compare_three_way_result_t<T, U>
operator<=>(const optional<T>& x, const optional<U>& y);
19 Returns: If x && y, *x <=> *y; otherwisex.has_value() <=> y.has_value().
20 Remarks: Specializations of this function template for which*x <=> *y is a core constant expression
are constexpr functions.
22.5.8 Comparison with nullopt [optional.nullops]
template<class T> constexpr bool operator==(const optional<T>& x, nullopt_t) noexcept;
1 Returns: !x.
template<class T> constexpr strong_ordering operator<=>(const optional<T>& x, nullopt_t) noexcept;
2 Returns: x.has_value() <=> false.
22.5.9 Comparison with T [optional.comp.with.t]
template<class T, class U> constexpr bool operator==(const optional<T>& x, const U& v);
1 Constraints: U is not a specialization ofoptional. The expression *x == v is well-formed and its
result is convertible tobool.
[Note 1: T need not beCpp17EqualityComparable. —end note]
2 Effects: Equivalent to:
if (x.has_value())
return *x == v;
return false;
template<class T, class U> constexpr bool operator==(const T& v, const optional<U>& x);
3 Constraints: T is not a specialization ofoptional. The expression v == *x is well-formed and its
result is convertible tobool.
4 Effects: Equivalent to:
if (x.has_value())
return v == *x;
return false;
template<class T, class U> constexpr bool operator!=(const optional<T>& x, const U& v);
5 Constraints: U is not a specialization ofoptional. The expression *x != v is well-formed and its
result is convertible tobool.
§ 22.5.9 © ISO/IEC
849

===== PAGE 861 =====

Dxxxx
6 Effects: Equivalent to:
if (x.has_value())
return *x != v;
return true;
template<class T, class U> constexpr bool operator!=(const T& v, const optional<U>& x);
7 Constraints: T is not a specialization ofoptional. The expression v != *x is well-formed and its
result is convertible tobool.
8 Effects: Equivalent to:
if (x.has_value())
return v != *x;
return true;
template<class T, class U> constexpr bool operator<(const optional<T>& x, const U& v);
9 Constraints: U is not a specialization ofoptional. The expression*x < v is well-formed and its result
is convertible tobool.
10 Effects: Equivalent to:
if (x.has_value())
return *x < v;
return true;
template<class T, class U> constexpr bool operator<(const T& v, const optional<U>& x);
11 Constraints: T is not a specialization ofoptional. The expressionv < *x is well-formed and its result
is convertible tobool.
12 Effects: Equivalent to:
if (x.has_value())
return v < *x;
return false;
template<class T, class U> constexpr bool operator>(const optional<T>& x, const U& v);
13 Constraints: U is not a specialization ofoptional. The expression*x > v is well-formed and its result
is convertible tobool.
14 Effects: Equivalent to:
if (x.has_value())
return *x > v;
return false;
template<class T, class U> constexpr bool operator>(const T& v, const optional<U>& x);
15 Constraints: T is not a specialization ofoptional. The expressionv > *x is well-formed and its result
is convertible tobool.
16 Effects: Equivalent to:
if (x.has_value())
return v > *x;
return true;
template<class T, class U> constexpr bool operator<=(const optional<T>& x, const U& v);
17 Constraints: U is not a specialization ofoptional. The expression *x <= v is well-formed and its
result is convertible tobool.
18 Effects: Equivalent to:
if (x.has_value())
return *x <= v;
return true;
template<class T, class U> constexpr bool operator<=(const T& v, const optional<U>& x);
19 Constraints: T is not a specialization ofoptional. The expression v <= *x is well-formed and its
result is convertible tobool.
§ 22.5.9 © ISO/IEC
850

===== PAGE 862 =====

Dxxxx
20 Effects: Equivalent to:
if (x.has_value())
return v <= *x;
return false;
template<class T, class U> constexpr bool operator>=(const optional<T>& x, const U& v);
21 Constraints: U is not a specialization ofoptional. The expression *x >= v is well-formed and its
result is convertible tobool.
22 Effects: Equivalent to:
if (x.has_value())
return *x >= v;
return false;
template<class T, class U> constexpr bool operator>=(const T& v, const optional<U>& x);
23 Constraints: T is not a specialization ofoptional. The expression v >= *x is well-formed and its
result is convertible tobool.
24 Effects: Equivalent to:
if (x.has_value())
return v >= *x;
return true;
template<class T, class U>
requires (!is-derived-from-optional <U>) && three_way_comparable_with<T, U>
constexpr compare_three_way_result_t<T, U>
operator<=>(const optional<T>& x, const U& v);
25 Effects: Equivalent to:return x.has_value() ? *x <=> v : strong_ordering::less;
22.5.10 Specialized algorithms [optional.specalg]
template<class T>
constexpr void swap(optional<T>& x, optional<T>& y) noexcept(noexcept(x.swap(y)));
1 Constraints:
is_reference_v<T> || (is_move_constructible_v<T> && is_swappable_v<T>)
is true.
2 Effects: Calls x.swap(y).
template<class T> constexpr optional<decay_t<T>> make_optional(T&& v);
3 Constraints: The call tomake_optional does not use an explicittemplate-argument-list that begins
with a typetemplate-argument.
4 Effects: Equivalent to:return optional<decay_t<T>>(std::forward<T>(v));
template<class T, class...Args>
constexpr optional<T> make_optional(Args&&... args);
5 Effects: Equivalent to:return optional<T>(in_place, std::forward<Args>(args)...);
template<class T, class U, class... Args>
constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);
6 Effects: Equivalent to:return optional<T>(in_place, il, std::forward<Args>(args)...);
22.5.11 Hash support [optional.hash]
template<class T> struct hash<optional<T>>;
1 The specializationhash<optional<T>> is enabled (22.10.19) if and only ifhash<remove_const_t<T>>
is enabled. When enabled, for an objecto of type optional<T>, if o.has_value() == true, then
hash<optional<T>>()(o)evaluates to the same value ashash<remove_const_t<T>>()(*o); otherwise
it evaluates to an unspecified value. The member functions are not guaranteed to benoexcept.
§ 22.5.11 © ISO/IEC
851

===== PAGE 863 =====

Dxxxx
22.6 Variants [variant]
22.6.1 General [variant.general]
1 A variant object holds and manages the lifetime of a value. If thevariant holds a value, that value’s
type has to be one of the template argument types given tovariant. These template arguments are called
alternatives.
2 In 22.6,GET denotes a set of exposition-only function templates (22.6.5).
22.6.2 Header <variant> synopsis [variant.syn]
// mostly freestanding
#include <compare> // see 17.12.1
namespace std {
// 22.6.3, class templatevariant
template<class... Types>
class variant;
// 22.6.4, variant helper classes
template<class T> struct variant_size; // not defined
template<class T> struct variant_size<const T>;
template<class T>
constexpr size_t variant_size_v = variant_size<T>::value;
template<class... Types>
struct variant_size<variant<Types...>>;
template<size_t I, class T> struct variant_alternative; // not defined
template<size_t I, class T> struct variant_alternative<I, const T>;
template<size_t I, class T>
using variant_alternative_t = variant_alternative<I, T>::type;
template<size_t I, class... Types>
struct variant_alternative<I, variant<Types...>>;
inline constexpr size_t variant_npos = -1;
// 22.6.5, value access
template<class T, class... Types>
constexpr bool holds_alternative(const variant<Types...>&) noexcept;
template<size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>&
get(variant<Types...>&); // freestanding-deleted
template<size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>&&
get(variant<Types...>&&); // freestanding-deleted
template<size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>&
get(const variant<Types...>&); // freestanding-deleted
template<size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>&&
get(const variant<Types...>&&); // freestanding-deleted
template<class T, class... Types>
constexpr T& get(variant<Types...>&); // freestanding-deleted
template<class T, class... Types>
constexpr T&& get(variant<Types...>&&); // freestanding-deleted
template<class T, class... Types>
constexpr const T& get(const variant<Types...>&); // freestanding-deleted
template<class T, class... Types>
constexpr const T&& get(const variant<Types...>&&); // freestanding-deleted
§ 22.6.2 © ISO/IEC
852

===== PAGE 864 =====

Dxxxx
template<size_t I, class... Types>
constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
get_if(variant<Types...>*) noexcept;
template<size_t I, class... Types>
constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
get_if(const variant<Types...>*) noexcept;
template<class T, class... Types>
constexpr add_pointer_t<T>
get_if(variant<Types...>*) noexcept;
template<class T, class... Types>
constexpr add_pointer_t<const T>
get_if(const variant<Types...>*) noexcept;
// 22.6.6, relational operators
template<class... Types>
constexpr bool operator==(const variant<Types...>&, const variant<Types...>&);
template<class... Types>
constexpr bool operator!=(const variant<Types...>&, const variant<Types...>&);
template<class... Types>
constexpr bool operator<(const variant<Types...>&, const variant<Types...>&);
template<class... Types>
constexpr bool operator>(const variant<Types...>&, const variant<Types...>&);
template<class... Types>
constexpr bool operator<=(const variant<Types...>&, const variant<Types...>&);
template<class... Types>
constexpr bool operator>=(const variant<Types...>&, const variant<Types...>&);
template<class... Types> requires (three_way_comparable<Types> && ...)
constexpr common_comparison_category_t<compare_three_way_result_t<Types>...>
operator<=>(const variant<Types...>&, const variant<Types...>&);
// 22.6.7, visitation
template<class Visitor, class... Variants>
constexpr see below visit(Visitor&&, Variants&&...);
template<class R, class Visitor, class... Variants>
constexpr R visit(Visitor&&, Variants&&...);
// 22.6.8, classmonostate
struct monostate;
// 22.6.9,monostate relational operators
constexpr bool operator==(monostate, monostate) noexcept;
constexpr strong_ordering operator<=>(monostate, monostate) noexcept;
// 22.6.10, specialized algorithms
template<class... Types>
constexpr void swap(variant<Types...>&, variant<Types...>&) noexcept(see below );
// 22.6.11, classbad_variant_access
class bad_variant_access;
// 22.6.12, hash support
template<class T> struct hash;
template<class... Types> struct hash<variant<Types...>>;
template<> struct hash<monostate>;
}
22.6.3 Class template variant [variant.variant]
22.6.3.1 General [variant.variant.general]
namespace std {
template<class... Types>
class variant {
public:
§ 22.6.3.1 © ISO/IEC
853

===== PAGE 865 =====

Dxxxx
// 22.6.3.2, constructors
constexpr variant() noexcept(see below );
constexpr variant(const variant&) noexcept(see below );
constexpr variant(variant&&) noexcept(see below );
template<class T>
constexpr variant(T&&) noexcept(see below );
template<class T, class... Args>
constexpr explicit variant(in_place_type_t<T>, Args&&...);
template<class T, class U, class... Args>
constexpr explicit variant(in_place_type_t<T>, initializer_list<U>, Args&&...);
template<size_t I, class... Args>
constexpr explicit variant(in_place_index_t<I>, Args&&...);
template<size_t I, class U, class... Args>
constexpr explicit variant(in_place_index_t<I>, initializer_list<U>, Args&&...);
// 22.6.3.3, destructor
constexpr ~variant();
// 22.6.3.4, assignment
constexpr variant& operator=(const variant&);
constexpr variant& operator=(variant&&) noexcept(see below );
template<class T> constexpr variant& operator=(T&&) noexcept(see below );
// 22.6.3.5, modifiers
template<class T, class... Args>
constexpr T& emplace(Args&&...);
template<class T, class U, class... Args>
constexpr T& emplace(initializer_list<U>, Args&&...);
template<size_t I, class... Args>
constexpr variant_alternative_t<I, variant<Types...>>& emplace(Args&&...);
template<size_t I, class U, class... Args>
constexpr variant_alternative_t<I, variant<Types...>>&
emplace(initializer_list<U>, Args&&...);
// 22.6.3.6, value status
constexpr bool valueless_by_exception() const noexcept;
constexpr size_t index() const noexcept;
// 22.6.3.7, swap
constexpr void swap(variant&) noexcept(see below );
// 22.6.7, visitation
template<class Self, class Visitor>
constexpr decltype(auto) visit(this Self&&, Visitor&&);
template<class R, class Self, class Visitor>
constexpr R visit(this Self&&, Visitor&&);
};
}
1 Any instance ofvariant at any given time either holds a value of one of its alternative types or holds no
value. When an instance ofvariant holds a value of alternative typeT, it means that a value of typeT,
referred to as thevariant object’s contained value, is nested within (6.8.2) thevariant object.
2 All types inTypes shall meet theCpp17Destructible requirements (Table 35).
3 A program that instantiates the definition ofvariant with no template arguments is ill-formed.
4 If a program declares an explicit or partial specialization ofvariant, the program is ill-formed, no diagnostic
required.
§ 22.6.3.1 © ISO/IEC
854

===== PAGE 866 =====

Dxxxx
22.6.3.2 Constructors [variant.ctor]
1 In the descriptions that follow, leti be in the range[0,sizeof...(Types)), andTi be theith type inTypes.
constexpr variant() noexcept(see below );
2 Constraints: is_default_constructible_v<T0> is true.
3 Effects: Constructs avariant holding a value-initialized value of typeT0.
4 Postconditions: valueless_by_exception() is false and index() is 0.
5 Throws: Any exception thrown by the value-initialization ofT0.
6 Remarks: This function isconstexpr if and only if the value-initialization of the alternative typeT0
would be constexpr-suitable (9.2.6). The exception specification is equivalent tois_nothrow_default_-
constructible_v<T0>.
[Note 1: See also classmonostate. —end note]
constexpr variant(const variant& w) noexcept(see below );
7 Effects: If w holds a value, initializes thevariant to hold the same alternative asw and direct-initializes
the contained value withGET <j>(w), wherej is w.index(). Otherwise, initializes thevariant to not
hold a value.
8 Throws: Any exception thrown by direct-initializing anyTi for alli.
9 Remarks: This constructor is defined as deleted unlessis_copy_constructible_v<Ti> is true for
all i. If is_trivially_copy_constructible_v<Ti> is true for alli, this constructor is trivial. The
exception specification is equivalent to the logicaland of is_nothrow_copy_constructible_v<Ti> for
all i.
constexpr variant(variant&& w) noexcept(see below );
10 Constraints: is_move_constructible_v<Ti> is true for alli.
11 Effects: If w holds a value, initializes thevariant to hold the same alternative asw and direct-initializes
the contained value withGET <j>(std::move(w)), wherej is w.index(). Otherwise, initializes the
variant to not hold a value.
12 Throws: Any exception thrown by move-constructing anyTi for alli.
13 Remarks: The exception specification is equivalent to the logical and of is_nothrow_move_con-
structible_v<Ti> for all i. If is_trivially_move_constructible_v<Ti> is true for all i, this
constructor is trivial.
template<class T> constexpr variant(T&& t) noexcept(see below );
14 Let Tj be a type that is determined as follows: build an imaginary functionFUN(Ti) for each alternative
type Ti for whichTi x[] = {std::forward<T>(t)};is well-formed for some invented variablex. The
overload FUN(Tj) selected by overload resolution for the expressionFUN(std::forward<T>(t)) defines
the alternativeTj which is the type of the contained value after construction.
15 Constraints:
—(15.1) sizeof...(Types) is nonzero,
—(15.2) is_same_v<remove_cvref_t<T>, variant> is false,
—(15.3) remove_cvref_t<T> is neither a specialization ofin_place_type_t nor a specialization ofin_-
place_index_t,
—(15.4) is_constructible_v<Tj, T> is true, and
—(15.5) the expressionFUN(std::forward<T>(t)) (with FUN being the above-mentioned set of imaginary
functions) is well-formed.
[Note 2:
variant<string, string> v("abc");
is ill-formed, as both alternative types have an equally viable constructor for the argument.—end note]
16 Effects: Initializes *this to hold the alternative typeTj and direct-non-list-initializes the contained
value withstd::forward<T>(t).
§ 22.6.3.2 © ISO/IEC
855

===== PAGE 867 =====

Dxxxx
17 Postconditions: holds_alternative<Tj>(*this) is true.
18 Throws: Any exception thrown by the initialization of the selected alternativeTj.
19 Remarks: The exception specification is equivalent tois_nothrow_constructible_v<Tj, T>. If Tj’s
selected constructor is a constexpr constructor, this constructor is a constexpr constructor.
template<class T, class... Args> constexpr explicit variant(in_place_type_t<T>, Args&&... args);
20 Constraints:
—(20.1) There is exactly one occurrence ofT in Types... and
—(20.2) is_constructible_v<T, Args...> is true.
21 Effects: Direct-non-list-initializes the contained value of typeT with std::forward<Args>(args)....
22 Postconditions: holds_alternative<T>(*this) is true.
23 Throws: Any exception thrown by calling the selected constructor ofT.
24 Remarks: If T’s selected constructor is a constexpr constructor, this constructor is a constexpr
constructor.
template<class T, class U, class... Args>
constexpr explicit variant(in_place_type_t<T>, initializer_list<U> il, Args&&... args);
25 Constraints:
—(25.1) There is exactly one occurrence ofT in Types... and
—(25.2) is_constructible_v<T, initializer_list<U>&, Args...> is true.
26 Effects: Direct-non-list-initializes the contained value of type T with il, std::forward<Args>(
args)....
27 Postconditions: holds_alternative<T>(*this) is true.
28 Throws: Any exception thrown by calling the selected constructor ofT.
29 Remarks: If T’s selected constructor is a constexpr constructor, this constructor is a constexpr
constructor.
template<size_t I, class... Args> constexpr explicit variant(in_place_index_t<I>, Args&&... args);
30 Constraints:
—(30.1) I is less thansizeof...(Types) and
—(30.2) is_constructible_v<TI, Args...> is true.
31 Effects: Direct-non-list-initializes the contained value of typeTI with std::forward<Args>(args)....
32 Postconditions: index() is I.
33 Throws: Any exception thrown by calling the selected constructor ofTI.
34 Remarks: If TI’s selected constructor is a constexpr constructor, this constructor is a constexpr
constructor.
template<size_t I, class U, class... Args>
constexpr explicit variant(in_place_index_t<I>, initializer_list<U> il, Args&&... args);
35 Constraints:
—(35.1) I is less thansizeof...(Types) and
—(35.2) is_constructible_v<TI, initializer_list<U>&, Args...> is true.
36 Effects: Direct-non-list-initializes the contained value of type TI with il, std::forward<Args>(
args)....
37 Postconditions: index() is I.
38 Remarks: If TI’s selected constructor is a constexpr constructor, this constructor is a constexpr
constructor.
§ 22.6.3.2 © ISO/IEC
856

===== PAGE 868 =====

Dxxxx
22.6.3.3 Destructor [variant.dtor]
constexpr ~variant();
1 Effects: If valueless_by_exception() is false, destroys the currently contained value.
2 Remarks: If is_trivially_destructible_v<Ti> is true for allTi, then this destructor is trivial.
22.6.3.4 Assignment [variant.assign]
constexpr variant& operator=(const variant& rhs);
1 Let j be rhs.index().
2 Effects:
—(2.1) If neither*this nor rhs holds a value, there is no effect.
—(2.2) Otherwise, if*this holds a value butrhs does not, destroys the value contained in*this and
sets *this to not hold a value.
—(2.3) Otherwise, ifindex() == j, assigns the value contained inrhs to the value contained in*this.
—(2.4) Otherwise, if eitheris_nothrow_copy_constructible_v<Tj> is true or is_nothrow_move_con-
structible_v<Tj> is false, equivalent toemplace<j>(GET <j>(rhs)).
—(2.5) Otherwise, equivalent tooperator=(variant(rhs)).
3 Postconditions: index() == rhs.index().
4 Returns: *this.
5 Remarks: This operator is defined as deleted unlessis_copy_constructible_v<Ti> && is_copy_-
assignable_v<Ti>istrueforall i. Ifis_trivially_copy_constructible_v<Ti> &&is_trivially_-
copy_assignable_v<Ti> && is_trivially_destructible_v<Ti> is true for all i, this assignment
operator is trivial.
constexpr variant& operator=(variant&& rhs) noexcept(see below );
6 Let j be rhs.index().
7 Constraints: is_move_constructible_v<Ti> && is_move_assignable_v<Ti> is true for alli.
8 Effects:
—(8.1) If neither*this nor rhs holds a value, there is no effect.
—(8.2) Otherwise, if*this holds a value butrhs does not, destroys the value contained in*this and
sets *this to not hold a value.
—(8.3) Otherwise, ifindex() == j, assignsGET <j>(std::move(rhs)) to the value contained in*this.
—(8.4) Otherwise, equivalent toemplace<j>(GET <j>(std::move(rhs))).
9 Returns: *this.
10 Remarks: If is_trivially_move_constructible_v<Ti> && is_trivially_move_assignable_v<Ti>
&& is_trivially_destructible_v<Ti> is true for all i, this assignment operator is trivial. The
exception specification is equivalent tois_nothrow_move_constructible_v<Ti> && is_nothrow_-
move_assignable_v<Ti> for alli.
—(10.1) If an exception is thrown during the call toTj’s move construction (withj being rhs.index()),
the variant will hold no value.
—(10.2) If an exception is thrown during the call toTj’s move assignment, the state of the contained value
is as defined by the exception safety guarantee ofTj’s move assignment;index() will bej.
template<class T> constexpr variant& operator=(T&& t) noexcept(see below );
11 Let Tj be a type that is determined as follows: build an imaginary functionFUN(Ti) for each alternative
type Ti for whichTi x[] = {std::forward<T>(t)};is well-formed for some invented variablex. The
overload FUN(Tj) selected by overload resolution for the expressionFUN(std::forward<T>(t)) defines
the alternativeTj which is the type of the contained value after assignment.
12 Constraints:
—(12.1) is_same_v<remove_cvref_t<T>, variant> is false,
§ 22.6.3.4 © ISO/IEC
857

===== PAGE 869 =====

Dxxxx
—(12.2) is_assignable_v<Tj&, T> && is_constructible_v<Tj, T> is true, and
—(12.3) the expressionFUN(std::forward<T>(t)) (with FUN being the above-mentioned set of imaginary
functions) is well-formed.
[Note 1:
variant<string, string> v;
v = "abc";
is ill-formed, as both alternative types have an equally viable constructor for the argument.—end note]
13 Effects:
—(13.1) If *this holds aTj, assignsstd::forward<T>(t) to the value contained in*this.
—(13.2) Otherwise, if is_nothrow_constructible_v<Tj, T> || !is_nothrow_move_constructible_-
v<Tj> is true, equivalent toemplace<j>(std::forward<T>(t)).
—(13.3) Otherwise, equivalent toemplace<j>(Tj(std::forward<T>(t))).
14 Postconditions: holds_alternative<Tj>(*this) is true, withTj selected by the imaginary function
overload resolution described above.
15 Returns: *this.
16 Remarks: The exception specification is equivalent to:
is_nothrow_assignable_v<Tj&, T> && is_nothrow_constructible_v<Tj, T>
—(16.1) If an exception is thrown during the assignment ofstd::forward<T>(t) to the value contained
in *this, the state of the contained value andt are as defined by the exception safety guarantee
of the assignment expression;valueless_by_exception() will befalse.
—(16.2) If an exception is thrown during the initialization of the contained value, thevariant object is
permitted to not hold a value.
22.6.3.5 Modifiers [variant.mod]
template<class T, class... Args> constexpr T& emplace(Args&&... args);
1 Constraints: is_constructible_v<T, Args...> is true, andT occurs exactly once inTypes.
2 Effects: Equivalent to:
return emplace<I>(std::forward<Args>(args)...);
where I is the zero-based index ofT in Types.
template<class T, class U, class... Args>
constexpr T& emplace(initializer_list<U> il, Args&&... args);
3 Constraints: is_constructible_v<T, initializer_list<U>&, Args...> is true, andT occurs ex-
actly once inTypes.
4 Effects: Equivalent to:
return emplace<I>(il, std::forward<Args>(args)...);
where I is the zero-based index ofT in Types.
template<size_t I, class... Args>
constexpr variant_alternative_t<I, variant<Types...>>& emplace(Args&&... args);
5 Mandates: I <sizeof...(Types).
6 Constraints: is_constructible_v<TI, Args...> is true.
7 Effects: Destroys the currently contained value ifvalueless_by_exception() is false. Then direct-
non-list-initializes the contained value of typeTI with the argumentsstd::forward<Args>(args)....
8 Postconditions: index() is I.
9 Returns: A reference to the new contained value.
10 Throws: Any exception thrown during the initialization of the contained value.
11 Remarks: If an exception is thrown during the initialization of the contained value, thevariant is
permitted to not hold a value.
§ 22.6.3.5 © ISO/IEC
858

===== PAGE 870 =====

Dxxxx
template<size_t I, class U, class... Args>
constexpr variant_alternative_t<I, variant<Types...>>&
emplace(initializer_list<U> il, Args&&... args);
12 Mandates: I <sizeof...(Types).
13 Constraints: is_constructible_v<TI, initializer_list<U>&, Args...> is true.
14 Effects: Destroys the currently contained value ifvalueless_by_exception() is false. Then direct-
non-list-initializes the contained value of typeTI with il, std::forward<Args>(args)....
15 Postconditions: index() is I.
16 Returns: A reference to the new contained value.
17 Throws: Any exception thrown during the initialization of the contained value.
18 Remarks: If an exception is thrown during the initialization of the contained value, thevariant is
permitted to not hold a value.
22.6.3.6 Value status [variant.status]
constexpr bool valueless_by_exception() const noexcept;
1 Effects: Returns false if and only if thevariant holds a value.
2 [Note 1: It is possible for avariant to hold no value if an exception is thrown during a type-changing assignment
or emplacement. The latter means that even avariant<float, int> can becomevalueless_by_exception(),
for instance by
struct S { operator int() { throw 42; }};
variant<float, int> v{12.f};
v.emplace<1>(S());
—end note]
constexpr size_t index() const noexcept;
3 Effects: If valueless_by_exception() is true, returnsvariant_npos. Otherwise, returns the zero-
based index of the alternative of the contained value.
22.6.3.7 Swap [variant.swap]
constexpr void swap(variant& rhs) noexcept(see below );
1 Mandates: is_move_constructible_v<Ti> is true for alli.
2 Preconditions: EachTi meets theCpp17Swappable requirements (16.4.4.3).
3 Effects:
—(3.1) If valueless_by_exception() && rhs.valueless_by_exception() no effect.
—(3.2) Otherwise, if index() == rhs.index(), callsswap(GET <i>(*this), GET <i>(rhs)) where i is
index().
—(3.3) Otherwise, exchanges values ofrhs and *this.
4 Throws: If index() == rhs.index(), any exception thrown byswap(GET <i>(*this), GET <i>(rhs))
with i being index(). Otherwise, any exception thrown by the move constructor ofTi or Tj with i
being index() and j being rhs.index().
5 Remarks: If an exception is thrown during the call to functionswap(GET <i>(*this), GET <i>(rhs)),
the states of the contained values of*this and ofrhs are determined by the exception safety guarantee
of swap for lvalues ofTi with i being index(). If an exception is thrown during the exchange of the
values of*this and rhs, the states of the values of*this and of rhs are determined by the exception
safety guarantee ofvariant’s move constructor. The exception specification is equivalent to the logical
and of is_nothrow_move_constructible_v<Ti> && is_nothrow_swappable_v<Ti> for alli.
22.6.4 variant helper classes [variant.helper]
template<class T> struct variant_size;
1 All specializations ofvariant_size meet theCpp17UnaryTypeTraitrequirements (21.3.2) with a base
characteristic ofintegral_constant<size_t, N> for someN.
§ 22.6.4 © ISO/IEC
859

===== PAGE 871 =====

Dxxxx
template<class T> struct variant_size<const T>;
2 Let VS denote variant_size<T> of the cv-unqualified typeT. Then each specialization of the tem-
plate meets theCpp17UnaryTypeTraitrequirements (21.3.2) with a base characteristic ofintegral_-
constant<size_t, VS::value>.
template<class... Types>
struct variant_size<variant<Types...>> : integral_constant<size_t, sizeof...(Types)> { };
template<size_t I, class T> struct variant_alternative<I, const T>;
3 Let VA denote variant_alternative<I, T> of the cv-unqualified typeT. Then each specialization of
the template meets theCpp17TransformationTraitrequirements (21.3.2) with a member typedeftype
that names the typeconst VA::type.
variant_alternative<I, variant<Types...>>::type
4 Mandates: I <sizeof...(Types).
5 Result: The typeTI.
22.6.5 Value access [variant.get]
template<class T, class... Types>
constexpr bool holds_alternative(const variant<Types...>& v) noexcept;
1 Mandates: The typeT occurs exactly once inTypes.
2 Returns: true if index() is equal to the zero-based index ofT in Types.
template<size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>&
GET (variant<Types...>& v); // exposition only
template<size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>&&
GET (variant<Types...>&& v); // exposition only
template<size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>&
GET (const variant<Types...>& v); // exposition only
template<size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>&&
GET (const variant<Types...>&& v); // exposition only
3 Mandates: I <sizeof...(Types).
4 Preconditions: v.index() is I.
5 Returns: A reference to the object stored in thevariant.
template<size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v);
template<size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>&& get(variant<Types...>&& v);
template<size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>& v);
template<size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>&& get(const variant<Types...>&& v);
6 Mandates: I <sizeof...(Types).
7 Effects: If v.index() is I, returns a reference to the object stored in thevariant. Otherwise, throws
an exception of typebad_variant_access.
template<class T, class... Types> constexpr T& get(variant<Types...>& v);
template<class T, class... Types> constexpr T&& get(variant<Types...>&& v);
template<class T, class... Types> constexpr const T& get(const variant<Types...>& v);
template<class T, class... Types> constexpr const T&& get(const variant<Types...>&& v);
8 Mandates: The typeT occurs exactly once inTypes.
9 Effects: If v holds a value of typeT, returns a reference to that value. Otherwise, throws an exception
of typebad_variant_access.
§ 22.6.5 © ISO/IEC
860

===== PAGE 872 =====

Dxxxx
template<size_t I, class... Types>
constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
get_if(variant<Types...>* v) noexcept;
template<size_t I, class... Types>
constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
get_if(const variant<Types...>* v) noexcept;
10 Mandates: I <sizeof...(Types).
11 Returns: A pointer to the value stored in the variant, if v != nullptr and v->index() == I.
Otherwise, returnsnullptr.
template<class T, class... Types>
constexpr add_pointer_t<T>
get_if(variant<Types...>* v) noexcept;
template<class T, class... Types>
constexpr add_pointer_t<const T>
get_if(const variant<Types...>* v) noexcept;
12 Mandates: The typeT occurs exactly once inTypes.
13 Effects: Equivalent to:return get_if<i>(v); with i being the zero-based index ofT in Types.
22.6.6 Relational operators [variant.relops]
template<class... Types>
constexpr bool operator==(const variant<Types...>& v, const variant<Types...>& w);
1 Constraints: GET <i>(v) == GET <i>(w) is a valid expression that is convertible tobool, for alli.
2 Returns: If v.index() != w.index(), false; otherwise ifv.valueless_by_exception(), true; oth-
erwise GET <i>(v) == GET <i>(w) with i being v.index().
template<class... Types>
constexpr bool operator!=(const variant<Types...>& v, const variant<Types...>& w);
3 Constraints: GET <i>(v) != GET <i>(w) is a valid expression that is convertible tobool, for alli.
4 Returns: If v.index() != w.index(), true; otherwise ifv.valueless_by_exception(), false; oth-
erwise GET <i>(v) != GET <i>(w) with i being v.index().
template<class... Types>
constexpr bool operator<(const variant<Types...>& v, const variant<Types...>& w);
5 Constraints: GET <i>(v) < GET <i>(w) is a valid expression that is convertible tobool, for alli.
6 Returns: If w.valueless_by_exception(), false; otherwise ifv.valueless_by_exception(), true;
otherwise, if v.index() < w.index(), true; otherwise ifv.index() > w.index(), false; otherwise
GET <i>(v) < GET <i>(w) with i being v.index().
template<class... Types>
constexpr bool operator>(const variant<Types...>& v, const variant<Types...>& w);
7 Constraints: GET <i>(v) > GET <i>(w) is a valid expression that is convertible tobool, for alli.
8 Returns: If v.valueless_by_exception(), false; otherwise ifw.valueless_by_exception(), true;
otherwise, if v.index() > w.index(), true; otherwise ifv.index() < w.index(), false; otherwise
GET <i>(v) > GET <i>(w) with i being v.index().
template<class... Types>
constexpr bool operator<=(const variant<Types...>& v, const variant<Types...>& w);
9 Constraints: GET <i>(v) <= GET <i>(w) is a valid expression that is convertible tobool, for alli.
10 Returns: If v.valueless_by_exception(), true; otherwise ifw.valueless_by_exception(), false;
otherwise, if v.index() < w.index(), true; otherwise ifv.index() > w.index(), false; otherwise
GET <i>(v) <= GET <i>(w) with i being v.index().
template<class... Types>
constexpr bool operator>=(const variant<Types...>& v, const variant<Types...>& w);
11 Constraints: GET <i>(v) >= GET <i>(w) is a valid expression that is convertible tobool, for alli.
§ 22.6.6 © ISO/IEC
861

===== PAGE 873 =====

Dxxxx
12 Returns: If w.valueless_by_exception(), true; otherwise ifv.valueless_by_exception(), false;
otherwise, if v.index() > w.index(), true; otherwise ifv.index() < w.index(), false; otherwise
GET <i>(v) >= GET <i>(w) with i being v.index().
template<class... Types> requires (three_way_comparable<Types> && ...)
constexpr common_comparison_category_t<compare_three_way_result_t<Types>...>
operator<=>(const variant<Types...>& v, const variant<Types...>& w);
13 Effects: Equivalent to:
if (v.valueless_by_exception() && w.valueless_by_exception())
return strong_ordering::equal;
if (v.valueless_by_exception()) return strong_ordering::less;
if (w.valueless_by_exception()) return strong_ordering::greater;
if (auto c = v.index() <=> w.index(); c != 0) return c;
return GET <i>(v) <=> GET <i>(w);
with i being v.index().
22.6.7 Visitation [variant.visit]
template<class Visitor, class... Variants>
constexpr see below visit(Visitor&& vis, Variants&&... vars);
template<class R, class Visitor, class... Variants>
constexpr R visit(Visitor&& vis, Variants&&... vars);
1 Let as-variant denote the following exposition-only function templates:
template<class... Ts>
constexpr auto&& as-variant (variant<Ts...>& var) { return var; }
template<class... Ts>
constexpr auto&& as-variant (const variant<Ts...>& var) { return var; }
template<class... Ts>
constexpr auto&& as-variant (variant<Ts...>&& var) { return std::move(var); }
template<class... Ts>
constexpr auto&& as-variant (const variant<Ts...>&& var) { return std::move(var); }
Let n be sizeof...(Variants). For each0 ≤i<n , letVi denote the type
decltype(as-variant (std::forward<Variantsi>(varsi))).
2 Constraints: Vi is a valid type for all0 ≤i<n .
3 Let V denote the pack of typesVi.
4 Let m be a pack ofn values of typesize_t. Such a pack is valid if
0 ≤mi <variant_size_v<remove_reference_t<Vi>> for all0 ≤i < n. For each valid packm, let
e(m) denote the expression:
INVOKE (std::forward<Visitor>(vis), GET <m>(std::forward<V>(vars))...) // see 22.10.4
for the first form and
INVOKE <R>(std::forward<Visitor>(vis), GET <m>(std::forward<V>(vars))...) // see 22.10.4
for the second form.
5 Mandates: For each valid packm, e(m) is a valid expression. All such expressions are of the same type
and value category.
6 Returns: e(m), wherem is the pack for whichmi is as-variant (varsi).index() for all0 ≤i < n.
The return type isdecltype(e(m)) for the first form.
7 Throws: bad_variant_access if (as-variant (vars).valueless_by_exception() || ...) is true.
8 Complexity: Forn≤1, the invocation of the callable object is implemented in constant time, i.e., for
n= 1, it does not depend on the number of alternative types ofV0. Forn> 1, the invocation of the
callable object has no complexity requirements.
template<class Self, class Visitor>
constexpr decltype(auto) visit(this Self&& self, Visitor&& vis);
9 Let V be OVERRIDE_REF (Self&&, COPY_CONST (remove_reference_t<Self>, variant)) (22.2.4).
§ 22.6.7 © ISO/IEC
862

===== PAGE 874 =====

Dxxxx
10 Constraints: The call tovisit does not use an explicittemplate-argument-list that begins with a type
template-argument.
11 Effects: Equivalent to:return std::visit(std::forward<Visitor>(vis), (V)self);
template<class R, class Self, class Visitor>
constexpr R visit(this Self&& self, Visitor&& vis);
12 Let V be OVERRIDE_REF (Self&&, COPY_CONST (remove_reference_t<Self>, variant)) (22.2.4).
13 Effects: Equivalent to:return std::visit<R>(std::forward<Visitor>(vis), (V)self);
22.6.8 Class monostate [variant.monostate]
struct monostate{};
1 The class monostate can serve as a first alternative type for avariant to make thevariant type
default constructible.
22.6.9 monostate relational operators [variant.monostate.relops]
constexpr bool operator==(monostate, monostate) noexcept { return true; }
constexpr strong_ordering operator<=>(monostate, monostate) noexcept
{ return strong_ordering::equal; }
1 [Note 1: monostate objects have only a single state; they thus always compare equal.—end note]
22.6.10 Specialized algorithms [variant.specalg]
template<class... Types>
constexpr void swap(variant<Types...>& v, variant<Types...>& w) noexcept(see below );
1 Constraints: is_move_constructible_v<Ti> && is_swappable_v<Ti> is true for alli.
2 Effects: Equivalent tov.swap(w).
3 Remarks: The exception specification is equivalent tonoexcept(v.swap(w)).
22.6.11 Class bad_variant_access [variant.bad.access]
namespace std {
class bad_variant_access : public exception {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 Objects of typebad_variant_access are thrown to report invalid accesses to the value of avariant object.
constexpr const char* what() const noexcept override;
2 Returns: An implementation-defined ntbs, which during constant evaluation is encoded with the
ordinary literal encoding (5.13.3).
22.6.12 Hash support [variant.hash]
template<class... Types> struct hash<variant<Types...>>;
1 The specializationhash<variant<Types...>> is enabled (22.10.19) if and only if every specialization
in hash<remove_const_t<Types>>... is enabled. The member functions are not guaranteed to be
noexcept.
template<> struct hash<monostate>;
2 The specialization is enabled (22.10.19).
22.7 Storage for any type [any]
22.7.1 General [any.general]
1 Subclause 22.7 describes components that C++ programs may use to perform operations on objects of a
discriminated type.
§ 22.7.1 © ISO/IEC
863

===== PAGE 875 =====

Dxxxx
2 [Note 1: The discriminated type can contain values of different types but does not attempt conversion between
them, i.e.,5 is held strictly as anint and is not implicitly convertible either to"5" or to5.0. This indifference to
interpretation but awareness of type effectively allows safe, generic containers of single values, with no scope for
surprises from ambiguous conversions.—end note]
22.7.2 Header <any> synopsis [any.synop]
#include <initializer_list> // see 17.11.2
#include <typeinfo> // see 17.7.2
namespace std {
// 22.7.3, classbad_any_cast
class bad_any_cast;
// 22.7.4, classany
class any;
// 22.7.5, non-member functions
void swap(any& x, any& y) noexcept;
template<class T, class... Args>
any make_any(Args&&... args);
template<class T, class U, class... Args>
any make_any(initializer_list<U> il, Args&&... args);
template<class T>
T any_cast(const any& operand);
template<class T>
T any_cast(any& operand);
template<class T>
T any_cast(any&& operand);
template<class T>
const T* any_cast(const any* operand) noexcept;
template<class T>
T* any_cast(any* operand) noexcept;
}
22.7.3 Class bad_any_cast [any.bad.any.cast]
namespace std {
class bad_any_cast : public bad_cast {
public:
// see 17.9.3 for the specification of the special member functions
const char* what() const noexcept override;
};
}
1 Objects of typebad_any_cast are thrown by a failedany_cast (22.7.5).
const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
22.7.4 Class any [any.class]
22.7.4.1 General [any.class.general]
namespace std {
class any {
public:
// 22.7.4.2, construction and destruction
constexpr any() noexcept;
any(const any& other);
any(any&& other) noexcept;
§ 22.7.4.1 © ISO/IEC
864

===== PAGE 876 =====

Dxxxx
template<class T>
any(T&& value);
template<class T, class... Args>
explicit any(in_place_type_t<T>, Args&&...);
template<class T, class U, class... Args>
explicit any(in_place_type_t<T>, initializer_list<U>, Args&&...);
~any();
// 22.7.4.3, assignments
any& operator=(const any& rhs);
any& operator=(any&& rhs) noexcept;
template<class T>
any& operator=(T&& rhs);
// 22.7.4.4, modifiers
template<class T, class... Args>
decay_t<T>& emplace(Args&&...);
template<class T, class U, class... Args>
decay_t<T>& emplace(initializer_list<U>, Args&&...);
void reset() noexcept;
void swap(any& rhs) noexcept;
// 22.7.4.5, observers
bool has_value() const noexcept;
const type_info& type() const noexcept;
};
}
1 An object of classany stores an instance of any type that meets the constructor requirements or it has no
value, and this is referred to as thestate of the classany object. The stored instance is called thecontained
value. Two states are equivalent if either they both have no value, or they both have a value and the contained
values are equivalent.
2 The non-memberany_cast functions provide type-safe access to the contained value.
3 Implementations should avoid the use of dynamically allocated memory for a small contained value. How-
ever, any such small-object optimization shall only be applied to typesT for which is_nothrow_move_-
constructible_v<T> is true.
[Example 1: A contained value of typeint could be stored in an internal buffer, not in separately-allocated memory.
—end example]
22.7.4.2 Construction and destruction [any.cons]
constexpr any() noexcept;
1 Postconditions: has_value() is false.
any(const any& other);
2 Effects: If other.has_value() is false, constructs an object that has no value. Otherwise, equivalent
to any(in_place_type<T>, any_cast<const T&>(other)) where T is the type of the contained value.
3 Throws: Any exceptions arising from calling the selected constructor for the contained value.
any(any&& other) noexcept;
4 Effects: If other.has_value() is false, constructs an object that has no value. Otherwise, constructs
an object of typeany that contains either the contained value ofother, or contains an object of the
same type constructed from the contained value ofother considering that contained value as an rvalue.
template<class T>
any(T&& value);
5 Let VT be decay_t<T>.
§ 22.7.4.2 © ISO/IEC
865

===== PAGE 877 =====

Dxxxx
6 Constraints: VT is not the same type asany, VT is not a specialization ofin_place_type_t, and
is_copy_constructible_v<VT> is true.
7 Preconditions: VT meets theCpp17CopyConstructible requirements.
8 Effects: Constructs an object of typeany that contains an object of typeVT direct-initialized with
std::forward<T>(value).
9 Throws: Any exception thrown by the selected constructor ofVT.
template<class T, class... Args>
explicit any(in_place_type_t<T>, Args&&... args);
10 Let VT be decay_t<T>.
11 Constraints: is_copy_constructible_v<VT> is true and is_constructible_v<VT, Args...> is
true.
12 Preconditions: VT meets theCpp17CopyConstructible requirements.
13 Effects: Direct-non-list-initializes the contained value of typeVT with std::forward<Args>(args)....
14 Postconditions: *this contains a value of typeVT.
15 Throws: Any exception thrown by the selected constructor ofVT.
template<class T, class U, class... Args>
explicit any(in_place_type_t<T>, initializer_list<U> il, Args&&... args);
16 Let VT be decay_t<T>.
17 Constraints: is_copy_constructible_v<VT> is true and is_constructible_v<VT, initializer_-
list<U>&, Args...> is true.
18 Preconditions: VT meets theCpp17CopyConstructible requirements.
19 Effects: Direct-non-list-initializes the contained value of typeVT with il, std::forward<Args>(
args)....
20 Postconditions: *this contains a value.
21 Throws: Any exception thrown by the selected constructor ofVT.
~any();
22 Effects: As if byreset().
22.7.4.3 Assignment [any.assign]
any& operator=(const any& rhs);
1 Effects: As if byany(rhs).swap(*this). No effects if an exception is thrown.
2 Returns: *this.
3 Throws: Any exceptions arising from the copy constructor for the contained value.
any& operator=(any&& rhs) noexcept;
4 Effects: As if byany(std::move(rhs)).swap(*this).
5 Postconditions: The state of*this is equivalent to the original state ofrhs.
6 Returns: *this.
template<class T>
any& operator=(T&& rhs);
7 Let VT be decay_t<T>.
8 Constraints: VT is not the same type asany and is_copy_constructible_v<VT> is true.
9 Preconditions: VT meets theCpp17CopyConstructible requirements.
10 Effects: Constructs an objecttmp of typeany that contains an object of typeVT direct-initialized with
std::forward<T>(rhs), andtmp.swap(*this). No effects if an exception is thrown.
11 Returns: *this.
§ 22.7.4.3 © ISO/IEC
866

===== PAGE 878 =====

Dxxxx
12 Throws: Any exception thrown by the selected constructor ofVT.
22.7.4.4 Modifiers [any.modifiers]
template<class T, class... Args>
decay_t<T>& emplace(Args&&... args);
1 Let VT be decay_t<T>.
2 Constraints: is_copy_constructible_v<VT> is true and is_constructible_v<VT, Args...> is
true.
3 Preconditions: VT meets theCpp17CopyConstructible requirements.
4 Effects: Calls reset(). Then direct-non-list-initializes the contained value of typeVT with std::for-
ward<Args>(args)....
5 Postconditions: *this contains a value.
6 Returns: A reference to the new contained value.
7 Throws: Any exception thrown by the selected constructor ofVT.
8 Remarks: If an exception is thrown during the call toVT’s constructor,*this does not contain a value,
and any previously contained value has been destroyed.
template<class T, class U, class... Args>
decay_t<T>& emplace(initializer_list<U> il, Args&&... args);
9 Let VT be decay_t<T>.
10 Constraints: is_copy_constructible_v<VT> is true and is_constructible_v<VT, initializer_-
list<U>&, Args...> is true.
11 Preconditions: VT meets theCpp17CopyConstructible requirements.
12 Effects: Calls reset(). Then direct-non-list-initializes the contained value of type VT with il,
std::forward<Args>(args)....
13 Postconditions: *this contains a value.
14 Returns: A reference to the new contained value.
15 Throws: Any exception thrown by the selected constructor ofVT.
16 Remarks: If an exception is thrown during the call toVT’s constructor,*this does not contain a value,
and any previously contained value has been destroyed.
void reset() noexcept;
17 Effects: If has_value() is true, destroys the contained value.
18 Postconditions: has_value() is false.
void swap(any& rhs) noexcept;
19 Effects: Exchanges the states of*this and rhs.
22.7.4.5 Observers [any.observers]
bool has_value() const noexcept;
1 Returns: true if *this contains an object, otherwisefalse.
const type_info& type() const noexcept;
2 Returns: typeid(T) if *this has a contained value of typeT, otherwisetypeid(void).
3 [Note 1: Useful for querying against types known either at compile time or only at runtime.—end note]
22.7.5 Non-member functions [any.nonmembers]
void swap(any& x, any& y) noexcept;
1 Effects: Equivalent tox.swap(y).
§ 22.7.5 © ISO/IEC
867

===== PAGE 879 =====

Dxxxx
template<class T, class... Args>
any make_any(Args&&... args);
2 Effects: Equivalent to:return any(in_place_type<T>, std::forward<Args>(args)...);
template<class T, class U, class... Args>
any make_any(initializer_list<U> il, Args&&... args);
3 Effects: Equivalent to:return any(in_place_type<T>, il, std::forward<Args>(args)...);
template<class T>
T any_cast(const any& operand);
template<class T>
T any_cast(any& operand);
template<class T>
T any_cast(any&& operand);
4 Let U be the typeremove_cvref_t<T>.
5 Mandates: For the first overload,is_constructible_v<T, const U&>istrue. For the second overload,
is_constructible_v<T, U&> is true. For the third overload,is_constructible_v<T, U> is true.
6 Returns: For the first and second overload,static_cast<T>(*any_cast<U>(&operand)). For the
third overload,static_cast<T>(std::move(*any_cast<U>(&operand))).
7 Throws: bad_any_cast if operand.type() != typeid(remove_reference_t<T>).
8 [Example 1:
any x(5); // x holds int
assert(any_cast<int>(x) == 5); // cast to value
any_cast<int&>(x) = 10; // cast to reference
assert(any_cast<int>(x) == 10);
x = "Meow"; // x holds const char*
assert(strcmp(any_cast<const char*>(x), "Meow") == 0);
any_cast<const char*&>(x) = "Harry";
assert(strcmp(any_cast<const char*>(x), "Harry") == 0);
x = string("Meow"); // x holds string
string s, s2("Jane");
s = move(any_cast<string&>(x)); // move fromany
assert(s == "Meow");
any_cast<string&>(x) = move(s2); // move toany
assert(any_cast<const string&>(x) == "Jane");
string cat("Meow");
const any y(cat); // const y holds string
assert(any_cast<const string&>(y) == cat);
any_cast<string&>(y); // error: cannotany_cast away const
—end example]
template<class T>
const T* any_cast(const any* operand) noexcept;
template<class T>
T* any_cast(any* operand) noexcept;
9 Mandates: is_void_v<T> is false.
10 Returns: Ifoperand != nullptr && operand->type() == typeid(T)is true, a pointer to the object
contained byoperand; otherwise,nullptr.
11 [Example 2:
bool is_string(const any& operand) {
return any_cast<string>(&operand) != nullptr;
}
—end example]
§ 22.7.5 © ISO/IEC
868

===== PAGE 880 =====

Dxxxx
22.8 Expected objects [expected]
22.8.1 General [expected.general]
1 Subclause 22.8 describes the class templateexpected that represents expected objects. Anexpected<T, E>
object holds an object of typeT or an object of typeE and manages the lifetime of the contained objects.
22.8.2 Header <expected> synopsis [expected.syn]
// mostly freestanding
namespace std {
// 22.8.3, class templateunexpected
template<class E> class unexpected;
// 22.8.4, class templatebad_expected_access
template<class E> class bad_expected_access;
// 22.8.5, specialization forvoid
template<> class bad_expected_access<void>;
// in-place construction of unexpected values
struct unexpect_t {
explicit unexpect_t() = default;
};
inline constexpr unexpect_t unexpect{};
// 22.8.6, class templateexpected
template<class T, class E> class expected; // partially freestanding
// 22.8.7, partial specialization ofexpected for void types
template<class T, class E> requires is_void_v<T> class expected<T, E>; // partially freestanding
}
22.8.3 Class template unexpected [expected.unexpected]
22.8.3.1 General [expected.un.general]
1 Subclause 22.8.3 describes the class templateunexpected that represents unexpected objects stored in
expected objects.
namespace std {
template<class E>
class unexpected {
public:
// 22.8.3.2, constructors
constexpr unexpected(const unexpected&) = default;
constexpr unexpected(unexpected&&) = default;
template<class Err = E>
constexpr explicit unexpected(Err&&);
template<class... Args>
constexpr explicit unexpected(in_place_t, Args&&...);
template<class U, class... Args>
constexpr explicit unexpected(in_place_t, initializer_list<U>, Args&&...);
constexpr unexpected& operator=(const unexpected&) = default;
constexpr unexpected& operator=(unexpected&&) = default;
constexpr const E& error() const & noexcept;
constexpr E& error() & noexcept;
constexpr const E&& error() const && noexcept;
constexpr E&& error() && noexcept;
constexpr void swap(unexpected& other) noexcept(see below );
template<class E2>
friend constexpr bool operator==(const unexpected&, const unexpected<E2>&);
§ 22.8.3.1 © ISO/IEC
869

===== PAGE 881 =====

Dxxxx
friend constexpr void swap(unexpected& x, unexpected& y) noexcept(noexcept(x.swap(y)));
private:
E unex; // exposition only
};
template<class E> unexpected(E) -> unexpected<E>;
}
2 A program that instantiates the definition ofunexpected for a non-object type, an array type, a specialization
of unexpected, or a cv-qualified type is ill-formed.
22.8.3.2 Constructors [expected.un.cons]
template<class Err = E>
constexpr explicit unexpected(Err&& e);
1 Constraints:
—(1.1) is_same_v<remove_cvref_t<Err>, unexpected> is false; and
—(1.2) is_same_v<remove_cvref_t<Err>, in_place_t> is false; and
—(1.3) is_constructible_v<E, Err> is true.
2 Effects: Direct-non-list-initializes unex with std::forward<Err>(e).
3 Throws: Any exception thrown by the initialization ofunex .
template<class... Args>
constexpr explicit unexpected(in_place_t, Args&&... args);
4 Constraints: is_constructible_v<E, Args...> is true.
5 Effects: Direct-non-list-initializes unex with std::forward<Args>(args)....
6 Throws: Any exception thrown by the initialization ofunex .
template<class U, class... Args>
constexpr explicit unexpected(in_place_t, initializer_list<U> il, Args&&... args);
7 Constraints: is_constructible_v<E, initializer_list<U>&, Args...> is true.
8 Effects: Direct-non-list-initializes unex with il, std::forward<Args>(args)....
9 Throws: Any exception thrown by the initialization ofunex .
22.8.3.3 Observers [expected.un.obs]
constexpr const E& error() const & noexcept;
constexpr E& error() & noexcept;
1 Returns: unex .
constexpr E&& error() && noexcept;
constexpr const E&& error() const && noexcept;
2 Returns: std::move(unex ).
22.8.3.4 Swap [expected.un.swap]
constexpr void swap(unexpected& other) noexcept(is_nothrow_swappable_v<E>);
1 Mandates: is_swappable_v<E> is true.
2 Effects: Equivalent to:using std::swap; swap(unex , other.unex );
friend constexpr void swap(unexpected& x, unexpected& y) noexcept(noexcept(x.swap(y)));
3 Constraints: is_swappable_v<E> is true.
4 Effects: Equivalent tox.swap(y).
§ 22.8.3.4 © ISO/IEC
870

===== PAGE 882 =====

Dxxxx
22.8.3.5 Equality operator [expected.un.eq]
template<class E2>
friend constexpr bool operator==(const unexpected& x, const unexpected<E2>& y);
1 Mandates: The expression x.error() == y.error() is well-formed and its result is convertible to
bool.
2 Returns: x.error() == y.error().
22.8.4 Class template bad_expected_access [expected.bad]
namespace std {
template<class E>
class bad_expected_access : public bad_expected_access<void> {
public:
constexpr explicit bad_expected_access(E);
constexpr const char* what() const noexcept override;
constexpr E& error() & noexcept;
constexpr const E& error() const & noexcept;
constexpr E&& error() && noexcept;
constexpr const E&& error() const && noexcept;
private:
E unex; // exposition only
};
}
1 The class templatebad_expected_access defines the type of objects thrown as exceptions to report the
situation where an attempt is made to access the value of anexpected<T, E> object for whichhas_value()
is false.
constexpr explicit bad_expected_access(E e);
2 Effects: Initializes unex with std::move(e).
constexpr const E& error() const & noexcept;
constexpr E& error() & noexcept;
3 Returns: unex .
constexpr E&& error() && noexcept;
constexpr const E&& error() const && noexcept;
4 Returns: std::move(unex ).
constexpr const char* what() const noexcept override;
5 Returns: An implementation-defined ntbs, which during constant evaluation is encoded with the
ordinary literal encoding (5.13.3).
22.8.5 Class template specialization bad_expected_access<void> [expected.bad.void]
namespace std {
template<>
class bad_expected_access<void> : public exception {
protected:
constexpr bad_expected_access() noexcept;
constexpr bad_expected_access(const bad_expected_access&) noexcept;
constexpr bad_expected_access(bad_expected_access&&) noexcept;
constexpr bad_expected_access& operator=(const bad_expected_access&) noexcept;
constexpr bad_expected_access& operator=(bad_expected_access&&) noexcept;
constexpr ~bad_expected_access();
public:
constexpr const char* what() const noexcept override;
};
}
§ 22.8.5 © ISO/IEC
871

===== PAGE 883 =====

Dxxxx
constexpr const char* what() const noexcept override;
1 Returns: An implementation-defined ntbs, which during constant evaluation is encoded with the
ordinary literal encoding (5.13.3).
22.8.6 Class template expected [expected.expected]
22.8.6.1 General [expected.object.general]
namespace std {
template<class T, class E>
class expected {
public:
using value_type = T;
using error_type = E;
using unexpected_type = unexpected<E>;
template<class U>
using rebind = expected<U, error_type>;
// 22.8.6.2, constructors
constexpr expected();
constexpr expected(const expected&);
constexpr expected(expected&&) noexcept(see below );
template<class U, class G>
constexpr explicit(see below ) expected(const expected<U, G>&);
template<class U, class G>
constexpr explicit(see below ) expected(expected<U, G>&&);
template<class U = remove_cv_t<T>>
constexpr explicit(see below ) expected(U&& v);
template<class G>
constexpr explicit(see below ) expected(const unexpected<G>&);
template<class G>
constexpr explicit(see below ) expected(unexpected<G>&&);
template<class... Args>
constexpr explicit expected(in_place_t, Args&&...);
template<class U, class... Args>
constexpr explicit expected(in_place_t, initializer_list<U>, Args&&...);
template<class... Args>
constexpr explicit expected(unexpect_t, Args&&...);
template<class U, class... Args>
constexpr explicit expected(unexpect_t, initializer_list<U>, Args&&...);
// 22.8.6.3, destructor
constexpr ~expected();
// 22.8.6.4, assignment
constexpr expected& operator=(const expected&);
constexpr expected& operator=(expected&&) noexcept(see below );
template<class U = remove_cv_t<T>> constexpr expected& operator=(U&&);
template<class G>
constexpr expected& operator=(const unexpected<G>&);
template<class G>
constexpr expected& operator=(unexpected<G>&&);
template<class... Args>
constexpr T& emplace(Args&&...) noexcept;
template<class U, class... Args>
constexpr T& emplace(initializer_list<U>, Args&&...) noexcept;
// 22.8.6.5, swap
constexpr void swap(expected&) noexcept(see below );
friend constexpr void swap(expected& x, expected& y) noexcept(noexcept(x.swap(y)));
§ 22.8.6.1 © ISO/IEC
872

===== PAGE 884 =====

Dxxxx
// 22.8.6.6, observers
constexpr const T* operator->() const noexcept;
constexpr T* operator->() noexcept;
constexpr const T& operator*() const & noexcept;
constexpr T& operator*() & noexcept;
constexpr const T&& operator*() const && noexcept;
constexpr T&& operator*() && noexcept;
constexpr explicit operator bool() const noexcept;
constexpr bool has_value() const noexcept;
constexpr const T& value() const &; // freestanding-deleted
constexpr T& value() &; // freestanding-deleted
constexpr const T&& value() const &&; // freestanding-deleted
constexpr T&& value() &&; // freestanding-deleted
constexpr const E& error() const & noexcept;
constexpr E& error() & noexcept;
constexpr const E&& error() const && noexcept;
constexpr E&& error() && noexcept;
template<class U = remove_cv_t<T>> constexpr T value_or(U&&) const &;
template<class U = remove_cv_t<T>> constexpr T value_or(U&&) &&;
template<class G = E> constexpr E error_or(G&&) const &;
template<class G = E> constexpr E error_or(G&&) &&;
// 22.8.6.7, monadic operations
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &;
template<class F> constexpr auto and_then(F&& f) const &&;
template<class F> constexpr auto or_else(F&& f) &;
template<class F> constexpr auto or_else(F&& f) &&;
template<class F> constexpr auto or_else(F&& f) const &;
template<class F> constexpr auto or_else(F&& f) const &&;
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &;
template<class F> constexpr auto transform(F&& f) const &&;
template<class F> constexpr auto transform_error(F&& f) &;
template<class F> constexpr auto transform_error(F&& f) &&;
template<class F> constexpr auto transform_error(F&& f) const &;
template<class F> constexpr auto transform_error(F&& f) const &&;
// 22.8.6.8, equality operators
template<class T2, class E2> requires (!is_void_v<T2>)
friend constexpr bool operator==(const expected& x, const expected<T2, E2>& y);
template<class T2>
friend constexpr bool operator==(const expected&, const T2&);
template<class E2>
friend constexpr bool operator==(const expected&, const unexpected<E2>&);
private:
bool has_val ; // exposition only
union {
T val ; // exposition only
E unex ; // exposition only
};
};
}
1 Any object of typeexpected<T, E> either contains a value of typeT or a value of typeE nested within (6.8.2)
it. Member has_val indicates whether theexpected<T, E> object contains an object of typeT.
2 A typeT is avalid value type forexpected, if remove_cv_t<T> is void or a complete non-array object type
that is notin_place_t, unexpect_t, or a specialization ofunexpected. A program which instantiates class
template expected<T, E> with an argumentT that is not a valid value type forexpected is ill-formed. A
§ 22.8.6.1 © ISO/IEC
873

===== PAGE 885 =====

Dxxxx
program that instantiates the definition of the templateexpected<T, E> with a type for theE parameter
that is not a valid template argument forunexpected is ill-formed.
3 When T is not cv void, it shall meet theCpp17Destructible requirements (Table 35). E shall meet the
Cpp17Destructible requirements.
22.8.6.2 Constructors [expected.object.cons]
1 The exposition-only variable template converts-from-any-cvref defined in 22.5.3.2 is used by some
constructors forexpected.
constexpr expected();
2 Constraints: is_default_constructible_v<T> is true.
3 Effects: Value-initializesval .
4 Postconditions: has_value() is true.
5 Throws: Any exception thrown by the initialization ofval .
constexpr expected(const expected& rhs);
6 Effects: If rhs.has_value() is true, direct-non-list-initializesval with *rhs. Otherwise, direct-non-
list-initializes unex with rhs.error().
7 Postconditions: rhs.has_value() == this->has_value().
8 Throws: Any exception thrown by the initialization ofval or unex .
9 Remarks: This constructor is defined as deleted unless
—(9.1) is_copy_constructible_v<T> is true and
—(9.2) is_copy_constructible_v<E> is true.
10 This constructor is trivial if
—(10.1) is_trivially_copy_constructible_v<T> is true and
—(10.2) is_trivially_copy_constructible_v<E> is true.
constexpr expected(expected&& rhs) noexcept(see below );
11 Constraints:
—(11.1) is_move_constructible_v<T> is true and
—(11.2) is_move_constructible_v<E> is true.
12 Effects: If rhs.has_value() is true, direct-non-list-initializesval with std::move(*rhs). Otherwise,
direct-non-list-initializes unex with std::move(rhs.error()).
13 Postconditions: rhs.has_value() is unchanged;rhs.has_value() == this->has_value() is true.
14 Throws: Any exception thrown by the initialization ofval or unex .
15 Remarks: The exception specification is equivalent tois_nothrow_move_constructible_v<T> &&
is_nothrow_move_constructible_v<E>.
16 This constructor is trivial if
—(16.1) is_trivially_move_constructible_v<T> is true and
—(16.2) is_trivially_move_constructible_v<E> is true.
template<class U, class G>
constexpr explicit(see below ) expected(const expected<U, G>& rhs);
template<class U, class G>
constexpr explicit(see below ) expected(expected<U, G>&& rhs);
17 Let:
—(17.1) UF be const U& for the first overload andU for the second overload.
—(17.2) GF be const G& for the first overload andG for the second overload.
18 Constraints:
—(18.1) is_constructible_v<T, UF> is true; and
§ 22.8.6.2 © ISO/IEC
874

===== PAGE 886 =====

Dxxxx
—(18.2) is_constructible_v<E, GF> is true; and
—(18.3) if T is notcv bool, converts-from-any-cvref <T, expected<U, G>> is false; and
—(18.4) is_constructible_v<unexpected<E>, expected<U, G>&> is false; and
—(18.5) is_constructible_v<unexpected<E>, expected<U, G>> is false; and
—(18.6) is_constructible_v<unexpected<E>, const expected<U, G>&> is false; and
—(18.7) is_constructible_v<unexpected<E>, const expected<U, G>> is false.
19 Effects: Ifrhs.has_value(), direct-non-list-initializesval with std::forward<UF>(*rhs). Otherwise,
direct-non-list-initializes unex with std::forward<GF>(rhs.error()).
20 Postconditions: rhs.has_value() is unchanged;rhs.has_value() == this->has_value() is true.
21 Throws: Any exception thrown by the initialization ofval or unex .
22 Remarks: The expression inside explicit is equivalent to !is_convertible_v<UF, T> || !is_-
convertible_v<GF, E>.
template<class U = remove_cv_t<T>>
constexpr explicit(!is_convertible_v<U, T>) expected(U&& v);
23 Constraints:
—(23.1) is_same_v<remove_cvref_t<U>, in_place_t> is false; and
—(23.2) is_same_v<remove_cvref_t<U>, expected> is false; and
—(23.3) is_same_v<remove_cvref_t<U>, unexpect_t> is false; and
—(23.4) remove_cvref_t<U> is not a specialization ofunexpected; and
—(23.5) is_constructible_v<T, U> is true; and
—(23.6) if T is cv bool, remove_cvref_t<U> is not a specialization ofexpected.
24 Effects: Direct-non-list-initializes val with std::forward<U>(v).
25 Postconditions: has_value() is true.
26 Throws: Any exception thrown by the initialization ofval .
template<class G>
constexpr explicit(!is_convertible_v<const G&, E>) expected(const unexpected<G>& e);
template<class G>
constexpr explicit(!is_convertible_v<G, E>) expected(unexpected<G>&& e);
27 Let GF be const G& for the first overload andG for the second overload.
28 Constraints: is_constructible_v<E, GF> is true.
29 Effects: Direct-non-list-initializes unex with std::forward<GF>(e.error()).
30 Postconditions: has_value() is false.
31 Throws: Any exception thrown by the initialization ofunex .
template<class... Args>
constexpr explicit expected(in_place_t, Args&&... args);
32 Constraints: is_constructible_v<T, Args...> is true.
33 Effects: Direct-non-list-initializes val with std::forward<Args>(args)....
34 Postconditions: has_value() is true.
35 Throws: Any exception thrown by the initialization ofval .
template<class U, class... Args>
constexpr explicit expected(in_place_t, initializer_list<U> il, Args&&... args);
36 Constraints: is_constructible_v<T, initializer_list<U>&, Args...> is true.
37 Effects: Direct-non-list-initializes val with il, std::forward<Args>(args)....
38 Postconditions: has_value() is true.
39 Throws: Any exception thrown by the initialization ofval .
§ 22.8.6.2 © ISO/IEC
875

===== PAGE 887 =====

Dxxxx
template<class... Args>
constexpr explicit expected(unexpect_t, Args&&... args);
40 Constraints: is_constructible_v<E, Args...> is true.
41 Effects: Direct-non-list-initializes unex with std::forward<Args>(args)....
42 Postconditions: has_value() is false.
43 Throws: Any exception thrown by the initialization ofunex .
template<class U, class... Args>
constexpr explicit expected(unexpect_t, initializer_list<U> il, Args&&... args);
44 Constraints: is_constructible_v<E, initializer_list<U>&, Args...> is true.
45 Effects: Direct-non-list-initializes unex with il, std::forward<Args>(args)....
46 Postconditions: has_value() is false.
47 Throws: Any exception thrown by the initialization ofunex .
22.8.6.3 Destructor [expected.object.dtor]
constexpr ~expected();
1 Effects: If has_value() is true, destroysval , otherwise destroysunex .
2 Remarks: If is_trivially_destructible_v<T> is true, andis_trivially_destructible_v<E> is
true, then this destructor is a trivial destructor.
22.8.6.4 Assignment [expected.object.assign]
1 This subclause makes use of the following exposition-only function template:
template<class T, class U, class... Args>
constexpr void reinit-expected (T& newval, U& oldval, Args&&... args) { // exposition only
if constexpr (is_nothrow_constructible_v<T, Args...>) {
destroy_at(addressof(oldval));
construct_at(addressof(newval), std::forward<Args>(args)...);
} else if constexpr (is_nothrow_move_constructible_v<T>) {
T tmp(std::forward<Args>(args)...);
destroy_at(addressof(oldval));
construct_at(addressof(newval), std::move(tmp));
} else {
U tmp(std::move(oldval));
destroy_at(addressof(oldval));
try {
construct_at(addressof(newval), std::forward<Args>(args)...);
} catch (...) {
construct_at(addressof(oldval), std::move(tmp));
throw;
}
}
}
constexpr expected& operator=(const expected& rhs);
2 Effects:
—(2.1) If this->has_value() && rhs.has_value() is true, equivalent toval = *rhs.
—(2.2) Otherwise, ifthis->has_value() is true, equivalent to:
reinit-expected (unex , val , rhs.error())
—(2.3) Otherwise, ifrhs.has_value() is true, equivalent to:
reinit-expected (val , unex , *rhs)
—(2.4) Otherwise, equivalent tounex = rhs.error().
Then, if no exception was thrown, equivalent to:has_val = rhs.has_value(); return *this;
3 Returns: *this.
§ 22.8.6.4 © ISO/IEC
876

===== PAGE 888 =====

Dxxxx
4 Remarks: This operator is defined as deleted unless:
—(4.1) is_copy_assignable_v<T> is true and
—(4.2) is_copy_constructible_v<T> is true and
—(4.3) is_copy_assignable_v<E> is true and
—(4.4) is_copy_constructible_v<E> is true and
—(4.5) is_nothrow_move_constructible_v<T> || is_nothrow_move_constructible_v<E> is true.
constexpr expected& operator=(expected&& rhs) noexcept(see below );
5 Constraints:
—(5.1) is_move_constructible_v<T> is true and
—(5.2) is_move_assignable_v<T> is true and
—(5.3) is_move_constructible_v<E> is true and
—(5.4) is_move_assignable_v<E> is true and
—(5.5) is_nothrow_move_constructible_v<T> || is_nothrow_move_constructible_v<E> is true.
6 Effects:
—(6.1) If this->has_value() && rhs.has_value() is true, equivalent toval = std::move(*rhs).
—(6.2) Otherwise, ifthis->has_value() is true, equivalent to:
reinit-expected (unex , val , std::move(rhs.error()))
—(6.3) Otherwise, ifrhs.has_value() is true, equivalent to:
reinit-expected (val , unex , std::move(*rhs))
—(6.4) Otherwise, equivalent tounex = std::move(rhs.error()).
Then, if no exception was thrown, equivalent to:has_val = rhs.has_value(); return *this;
7 Returns: *this.
8 Remarks: The exception specification is equivalent to:
is_nothrow_move_assignable_v<T> && is_nothrow_move_constructible_v<T> &&
is_nothrow_move_assignable_v<E> && is_nothrow_move_constructible_v<E>
template<class U = remove_cv_t<T>>
constexpr expected& operator=(U&& v);
9 Constraints:
—(9.1) is_same_v<expected, remove_cvref_t<U>> is false; and
—(9.2) remove_cvref_t<U> is not a specialization ofunexpected; and
—(9.3) is_constructible_v<T, U> is true; and
—(9.4) is_assignable_v<T&, U> is true; and
—(9.5) is_nothrow_constructible_v<T, U> || is_nothrow_move_constructible_v<T> ||
is_nothrow_move_constructible_v<E> is true.
10 Effects:
—(10.1) If has_value() is true, equivalent to:val = std::forward<U>(v);
—(10.2) Otherwise, equivalent to:
reinit-expected (val , unex , std::forward<U>(v));
has_val = true;
11 Returns: *this.
template<class G>
constexpr expected& operator=(const unexpected<G>& e);
template<class G>
constexpr expected& operator=(unexpected<G>&& e);
12 Let GF be const G& for the first overload andG for the second overload.
§ 22.8.6.4 © ISO/IEC
877

===== PAGE 889 =====

Dxxxx
13 Constraints:
—(13.1) is_constructible_v<E, GF> is true; and
—(13.2) is_assignable_v<E&, GF> is true; and
—(13.3) is_nothrow_constructible_v<E, GF> || is_nothrow_move_constructible_v<T> ||
is_nothrow_move_constructible_v<E> is true.
14 Effects:
—(14.1) If has_value() is true, equivalent to:
reinit-expected (unex , val , std::forward<GF>(e.error()));
has_val = false;
—(14.2) Otherwise, equivalent to:unex = std::forward<GF>(e.error());
15 Returns: *this.
template<class... Args>
constexpr T& emplace(Args&&... args) noexcept;
16 Constraints: is_nothrow_constructible_v<T, Args...> is true.
17 Effects: Equivalent to:
if (has_value()) {
destroy_at(addressof(val ));
} else {
destroy_at(addressof(unex ));
has_val = true;
}
return *construct_at(addressof(val ), std::forward<Args>(args)...);
template<class U, class... Args>
constexpr T& emplace(initializer_list<U> il, Args&&... args) noexcept;
18 Constraints: is_nothrow_constructible_v<T, initializer_list<U>&, Args...> is true.
19 Effects: Equivalent to:
if (has_value()) {
destroy_at(addressof(val ));
} else {
destroy_at(addressof(unex ));
has_val = true;
}
return *construct_at(addressof(val ), il, std::forward<Args>(args)...);
22.8.6.5 Swap [expected.object.swap]
constexpr void swap(expected& rhs) noexcept(see below );
1 Constraints:
—(1.1) is_swappable_v<T> is true and
—(1.2) is_swappable_v<E> is true and
—(1.3) is_move_constructible_v<T> && is_move_constructible_v<E> is true, and
—(1.4) is_nothrow_move_constructible_v<T> || is_nothrow_move_constructible_v<E> is true.
2 Effects: See Table 72.
Table 72 —swap(expected&) effects [tab:expected.object.swap]
this->has_value() !this->has_value()
rhs.has_value() equivalent to:using std::swap;
swap(val , rhs.val );
calls rhs.swap(*this)
!rhs.has_value() see below equivalent to:using std::swap;
swap(unex , rhs.unex );
§ 22.8.6.5 © ISO/IEC
878

===== PAGE 890 =====

Dxxxx
For the case whererhs.has_value() is false and this->has_value() is true, equivalent to:
if constexpr (is_nothrow_move_constructible_v<E>) {
E tmp(std::move(rhs.unex ));
destroy_at(addressof(rhs.unex ));
try {
construct_at(addressof(rhs.val ), std::move(val ));
destroy_at(addressof(val ));
construct_at(addressof(unex ), std::move(tmp));
} catch(...) {
construct_at(addressof(rhs.unex ), std::move(tmp));
throw;
}
} else {
T tmp(std::move(val ));
destroy_at(addressof(val ));
try {
construct_at(addressof(unex ), std::move(rhs.unex ));
destroy_at(addressof(rhs.unex ));
construct_at(addressof(rhs.val ), std::move(tmp));
} catch (...) {
construct_at(addressof(val ), std::move(tmp));
throw;
}
}
has_val = false;
rhs.has_val = true;
3 Throws: Any exception thrown by the expressions in theEffects.
4 Remarks: The exception specification is equivalent to:
is_nothrow_move_constructible_v<T> && is_nothrow_swappable_v<T> &&
is_nothrow_move_constructible_v<E> && is_nothrow_swappable_v<E>
friend constexpr void swap(expected& x, expected& y) noexcept(noexcept(x.swap(y)));
5 Effects: Equivalent tox.swap(y).
22.8.6.6 Observers [expected.object.obs]
constexpr const T* operator->() const noexcept;
constexpr T* operator->() noexcept;
1 Hardened preconditions: has_value() is true.
2 Returns: addressof(val ).
constexpr const T& operator*() const & noexcept;
constexpr T& operator*() & noexcept;
3 Hardened preconditions: has_value() is true.
4 Returns: val .
constexpr T&& operator*() && noexcept;
constexpr const T&& operator*() const && noexcept;
5 Hardened preconditions: has_value() is true.
6 Returns: std::move(val ).
constexpr explicit operator bool() const noexcept;
constexpr bool has_value() const noexcept;
7 Returns: has_val .
constexpr const T& value() const &;
constexpr T& value() &;
8 Mandates: is_copy_constructible_v<E> is true.
9 Returns: val , ifhas_value() is true.
§ 22.8.6.6 © ISO/IEC
879

===== PAGE 891 =====

Dxxxx
10 Throws: bad_expected_access(as_const(error())) if has_value() is false.
constexpr T&& value() &&;
constexpr const T&& value() const &&;
11 Mandates: is_copy_constructible_v<E> is true and is_constructible_v<E, decltype(std::
move(error()))> is true.
12 Returns: std::move(val ), ifhas_value() is true.
13 Throws: bad_expected_access(std::move(error())) if has_value() is false.
constexpr const E& error() const & noexcept;
constexpr E& error() & noexcept;
14 Hardened preconditions: has_value() is false.
15 Returns: unex .
constexpr E&& error() && noexcept;
constexpr const E&& error() const && noexcept;
16 Hardened preconditions: has_value() is false.
17 Returns: std::move(unex ).
template<class U = remove_cv_t<T>> constexpr T value_or(U&& v) const &;
18 Mandates: is_copy_constructible_v<T> is true and is_convertible_v<U, T> is true.
19 Returns: has_value() ? **this : static_cast<T>(std::forward<U>(v)).
template<class U = remove_cv_t<T>> constexpr T value_or(U&& v) &&;
20 Mandates: is_move_constructible_v<T> is true and is_convertible_v<U, T> is true.
21 Returns: has_value() ? std::move(**this) : static_cast<T>(std::forward<U>(v)).
template<class G = E> constexpr E error_or(G&& e) const &;
22 Mandates: is_copy_constructible_v<E> is true and is_convertible_v<G, E> is true.
23 Returns: std::forward<G>(e) if has_value() is true, error() otherwise.
template<class G = E> constexpr E error_or(G&& e) &&;
24 Mandates: is_move_constructible_v<E> is true and is_convertible_v<G, E> is true.
25 Returns: std::forward<G>(e) if has_value() is true, std::move(error()) otherwise.
22.8.6.7 Monadic operations [expected.object.monadic]
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) const &;
1 Let U be remove_cvref_t<invoke_result_t<F, decltype((val ))>>.
2 Constraints: is_constructible_v<E, decltype(error())> is true.
3 Mandates: U is a specialization ofexpected and is_same_v<typename U::error_type, E> is true.
4 Effects: Equivalent to:
if (has_value())
return invoke(std::forward<F>(f), val );
else
return U(unexpect, error());
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &&;
5 Let U be remove_cvref_t<invoke_result_t<F, decltype(std::move(val ))>>.
6 Constraints: is_constructible_v<E, decltype(std::move(error()))> is true.
7 Mandates: U is a specialization ofexpected and is_same_v<typename U::error_type, E> is true.
8 Effects: Equivalent to:
§ 22.8.6.7 © ISO/IEC
880

===== PAGE 892 =====

Dxxxx
if (has_value())
return invoke(std::forward<F>(f), std::move(val ));
else
return U(unexpect, std::move(error()));
template<class F> constexpr auto or_else(F&& f) &;
template<class F> constexpr auto or_else(F&& f) const &;
9 Let G be remove_cvref_t<invoke_result_t<F, decltype(error())>>.
10 Constraints: is_constructible_v<T, decltype((val ))> is true.
11 Mandates: G is a specialization ofexpected and is_same_v<typename G::value_type, T> is true.
12 Effects: Equivalent to:
if (has_value())
return G(in_place, val );
else
return invoke(std::forward<F>(f), error());
template<class F> constexpr auto or_else(F&& f) &&;
template<class F> constexpr auto or_else(F&& f) const &&;
13 Let G be remove_cvref_t<invoke_result_t<F, decltype(std::move(error()))>>.
14 Constraints: is_constructible_v<T, decltype(std::move(val ))> is true.
15 Mandates: G is a specialization ofexpected and is_same_v<typename G::value_type, T> is true.
16 Effects: Equivalent to:
if (has_value())
return G(in_place, std::move(val ));
else
return invoke(std::forward<F>(f), std::move(error()));
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) const &;
17 Let U be remove_cv_t<invoke_result_t<F, decltype((val ))>>.
18 Constraints: is_constructible_v<E, decltype(error())> is true.
19 Mandates: U is a valid value type forexpected. If is_void_v<U> is false, the declaration
U u(invoke(std::forward<F>(f), val ));
is well-formed.
20 Effects:
—(20.1) If has_value() is false, returnsexpected<U, E>(unexpect, error()).
—(20.2) Otherwise, ifis_void_v<U> is false, returns anexpected<U, E> object whosehas_val member
is true and val member is direct-non-list-initialized withinvoke(std::forward<F>(f), val ).
—(20.3) Otherwise, evaluatesinvoke(std::forward<F>(f), val ) and then returnsexpected<U, E>().
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &&;
21 Let U be remove_cv_t<invoke_result_t<F, decltype(std::move(val ))>>.
22 Constraints: is_constructible_v<E, decltype(std::move(error()))> is true.
23 Mandates: U is a valid value type forexpected. If is_void_v<U> is false, the declaration
U u(invoke(std::forward<F>(f), std::move(val )));
is well-formed.
24 Effects:
—(24.1) If has_value() is false, returnsexpected<U, E>(unexpect, std::move(error())).
—(24.2) Otherwise, ifis_void_v<U> is false, returns anexpected<U, E> object whosehas_val mem-
ber is true and val member is direct-non-list-initialized withinvoke(std::forward<F>(f),
std::move(val )).
§ 22.8.6.7 © ISO/IEC
881

===== PAGE 893 =====

Dxxxx
—(24.3) Otherwise, evaluates invoke(std::forward<F>(f), std::move(val )) and then returns ex-
pected<U, E>().
template<class F> constexpr auto transform_error(F&& f) &;
template<class F> constexpr auto transform_error(F&& f) const &;
25 Let G be remove_cv_t<invoke_result_t<F, decltype(error())>>.
26 Constraints: is_constructible_v<T, decltype((val ))> is true.
27 Mandates: G is a valid template argument forunexpected (22.8.3.1) and the declaration
G g(invoke(std::forward<F>(f), error()));
is well-formed.
28 Returns: If has_value() is true, expected<T, G>(in_place, val ); otherwise, an expected<T,
G> object whose has_val member is false and unex member is direct-non-list-initialized with
invoke(std::forward<F>(f), error()).
template<class F> constexpr auto transform_error(F&& f) &&;
template<class F> constexpr auto transform_error(F&& f) const &&;
29 Let G be remove_cv_t<invoke_result_t<F, decltype(std::move(error()))>>.
30 Constraints: is_constructible_v<T, decltype(std::move(val ))> is true.
31 Mandates: G is a valid template argument forunexpected (22.8.3.1) and the declaration
G g(invoke(std::forward<F>(f), std::move(error())));
is well-formed.
32 Returns: If has_value() is true, expected<T, G>(in_place, std::move(val )); otherwise, an
expected<T, G>object whosehas_val member isfalseand unex member is direct-non-list-initialized
with invoke(std::forward<F>(f), std::move(error())).
22.8.6.8 Equality operators [expected.object.eq]
template<class T2, class E2> requires (!is_void_v<T2>)
friend constexpr bool operator==(const expected& x, const expected<T2, E2>& y);
1 Constraints: The expressions*x == *yand x.error() == y.error()are well-formed and their results
are convertible tobool.
2 Returns: If x.has_value() does not equal y.has_value(), false; otherwise if x.has_value() is
true, *x == *y; otherwisex.error() == y.error().
template<class T2> friend constexpr bool operator==(const expected& x, const T2& v);
3 Constraints: T2 is not a specialization ofexpected. The expression*x == v is well-formed and its
result is convertible tobool.
[Note 1: T need not beCpp17EqualityComparable. —end note]
4 Returns: If x.has_value() is true, *x == v; otherwisefalse.
template<class E2> friend constexpr bool operator==(const expected& x, const unexpected<E2>& e);
5 Constraints: The expressionx.error() == e.error() is well-formed and its result is convertible to
bool.
6 Returns: If x.has_value() is true, x.error() == e.error(); otherwisefalse.
22.8.7 Partial specialization of expected for void types [expected.void]
22.8.7.1 General [expected.void.general]
template<class T, class E> requires is_void_v<T>
class expected<T, E> {
public:
using value_type = T;
using error_type = E;
using unexpected_type = unexpected<E>;
§ 22.8.7.1 © ISO/IEC
882

===== PAGE 894 =====

Dxxxx
template<class U>
using rebind = expected<U, error_type>;
// 22.8.7.2, constructors
constexpr expected() noexcept;
constexpr expected(const expected&);
constexpr expected(expected&&) noexcept(see below );
template<class U, class G>
constexpr explicit(see below ) expected(const expected<U, G>&);
template<class U, class G>
constexpr explicit(see below ) expected(expected<U, G>&&);
template<class G>
constexpr explicit(see below ) expected(const unexpected<G>&);
template<class G>
constexpr explicit(see below ) expected(unexpected<G>&&);
constexpr explicit expected(in_place_t) noexcept;
template<class... Args>
constexpr explicit expected(unexpect_t, Args&&...);
template<class U, class... Args>
constexpr explicit expected(unexpect_t, initializer_list<U>, Args&&...);
// 22.8.7.3, destructor
constexpr ~expected();
// 22.8.7.4, assignment
constexpr expected& operator=(const expected&);
constexpr expected& operator=(expected&&) noexcept(see below );
template<class G>
constexpr expected& operator=(const unexpected<G>&);
template<class G>
constexpr expected& operator=(unexpected<G>&&);
constexpr void emplace() noexcept;
// 22.8.7.5, swap
constexpr void swap(expected&) noexcept(see below );
friend constexpr void swap(expected& x, expected& y) noexcept(noexcept(x.swap(y)));
// 22.8.7.6, observers
constexpr explicit operator bool() const noexcept;
constexpr bool has_value() const noexcept;
constexpr void operator*() const noexcept;
constexpr void value() const &; // freestanding-deleted
constexpr void value() &&; // freestanding-deleted
constexpr const E& error() const & noexcept;
constexpr E& error() & noexcept;
constexpr const E&& error() const && noexcept;
constexpr E&& error() && noexcept;
template<class G = E> constexpr E error_or(G&&) const &;
template<class G = E> constexpr E error_or(G&&) &&;
// 22.8.7.7, monadic operations
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &;
template<class F> constexpr auto and_then(F&& f) const &&;
template<class F> constexpr auto or_else(F&& f) &;
template<class F> constexpr auto or_else(F&& f) &&;
template<class F> constexpr auto or_else(F&& f) const &;
template<class F> constexpr auto or_else(F&& f) const &&;
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) &&;
§ 22.8.7.1 © ISO/IEC
883

===== PAGE 895 =====

Dxxxx
template<class F> constexpr auto transform(F&& f) const &;
template<class F> constexpr auto transform(F&& f) const &&;
template<class F> constexpr auto transform_error(F&& f) &;
template<class F> constexpr auto transform_error(F&& f) &&;
template<class F> constexpr auto transform_error(F&& f) const &;
template<class F> constexpr auto transform_error(F&& f) const &&;
// 22.8.7.8, equality operators
template<class T2, class E2> requires is_void_v<T2>
friend constexpr bool operator==(const expected& x, const expected<T2, E2>& y);
template<class E2>
friend constexpr bool operator==(const expected&, const unexpected<E2>&);
private:
bool has_val ; // exposition only
union {
E unex ; // exposition only
};
};
1 Any object of typeexpected<T, E> either represents a value of typeT, or contains a value of typeE nested
within (6.8.2) it. Memberhas_val indicates whether theexpected<T, E> object represents a value of type
T.
2 A program that instantiates the definition of the templateexpected<T, E> with a type for theE parameter
that is not a valid template argument forunexpected is ill-formed.
3 E shall meet the requirements ofCpp17Destructible (Table 35).
22.8.7.2 Constructors [expected.void.cons]
constexpr expected() noexcept;
1 Postconditions: has_value() is true.
constexpr expected(const expected& rhs);
2 Effects: If rhs.has_value() is false, direct-non-list-initializesunex with rhs.error().
3 Postconditions: rhs.has_value() == this->has_value().
4 Throws: Any exception thrown by the initialization ofunex .
5 Remarks: This constructor is defined as deleted unlessis_copy_constructible_v<E> is true.
6 This constructor is trivial ifis_trivially_copy_constructible_v<E> is true.
constexpr expected(expected&& rhs) noexcept(is_nothrow_move_constructible_v<E>);
7 Constraints: is_move_constructible_v<E> is true.
8 Effects: If rhs.has_value() is false, direct-non-list-initializesunex with std::move(rhs.error()).
9 Postconditions: rhs.has_value() is unchanged;rhs.has_value() == this->has_value() is true.
10 Throws: Any exception thrown by the initialization ofunex .
11 Remarks: This constructor is trivial ifis_trivially_move_constructible_v<E> is true.
template<class U, class G>
constexpr explicit(!is_convertible_v<const G&, E>) expected(const expected<U, G>& rhs);
template<class U, class G>
constexpr explicit(!is_convertible_v<G, E>) expected(expected<U, G>&& rhs);
12 Let GF be const G& for the first overload andG for the second overload.
13 Constraints:
—(13.1) is_void_v<U> is true; and
—(13.2) is_constructible_v<E, GF> is true; and
—(13.3) is_constructible_v<unexpected<E>, expected<U, G>&> is false; and
—(13.4) is_constructible_v<unexpected<E>, expected<U, G>> is false; and
§ 22.8.7.2 © ISO/IEC
884

===== PAGE 896 =====

Dxxxx
—(13.5) is_constructible_v<unexpected<E>, const expected<U, G>&> is false; and
—(13.6) is_constructible_v<unexpected<E>, const expected<U, G>> is false.
14 Effects: If rhs.has_value()is false, direct-non-list-initializesunex with std::forward<GF>(rhs.er-
ror()).
15 Postconditions: rhs.has_value() is unchanged;rhs.has_value() == this->has_value() is true.
16 Throws: Any exception thrown by the initialization ofunex .
template<class G>
constexpr explicit(!is_convertible_v<const G&, E>) expected(const unexpected<G>& e);
template<class G>
constexpr explicit(!is_convertible_v<G, E>) expected(unexpected<G>&& e);
17 Let GF be const G& for the first overload andG for the second overload.
18 Constraints: is_constructible_v<E, GF> is true.
19 Effects: Direct-non-list-initializes unex with std::forward<GF>(e.error()).
20 Postconditions: has_value() is false.
21 Throws: Any exception thrown by the initialization ofunex .
constexpr explicit expected(in_place_t) noexcept;
22 Postconditions: has_value() is true.
template<class... Args>
constexpr explicit expected(unexpect_t, Args&&... args);
23 Constraints: is_constructible_v<E, Args...> is true.
24 Effects: Direct-non-list-initializes unex with std::forward<Args>(args)....
25 Postconditions: has_value() is false.
26 Throws: Any exception thrown by the initialization ofunex .
template<class U, class... Args>
constexpr explicit expected(unexpect_t, initializer_list<U> il, Args&&... args);
27 Constraints: is_constructible_v<E, initializer_list<U>&, Args...> is true.
28 Effects: Direct-non-list-initializes unex with il, std::forward<Args>(args)....
29 Postconditions: has_value() is false.
30 Throws: Any exception thrown by the initialization ofunex .
22.8.7.3 Destructor [expected.void.dtor]
constexpr ~expected();
1 Effects: If has_value() is false, destroysunex .
2 Remarks: If is_trivially_destructible_v<E> is true, then this destructor is a trivial destructor.
22.8.7.4 Assignment [expected.void.assign]
constexpr expected& operator=(const expected& rhs);
1 Effects:
—(1.1) If this->has_value() && rhs.has_value() is true, no effects.
—(1.2) Otherwise, if this->has_value() is true, equivalent to: construct_at(addressof(unex ),
rhs.unex ); has_val = false;
—(1.3) Otherwise, ifrhs.has_value() is true, destroysunex and setshas_val to true.
—(1.4) Otherwise, equivalent tounex = rhs.error().
2 Returns: *this.
3 Remarks: This operator is defined as deleted unlessis_copy_assignable_v<E> is true and is_copy_-
constructible_v<E> is true.
§ 22.8.7.4 © ISO/IEC
885

===== PAGE 897 =====

Dxxxx
constexpr expected& operator=(expected&& rhs) noexcept(see below );
4 Constraints: is_move_constructible_v<E> is true and is_move_assignable_v<E> is true.
5 Effects:
—(5.1) If this->has_value() && rhs.has_value() is true, no effects.
—(5.2) Otherwise, ifthis->has_value() is true, equivalent to:
construct_at(addressof(unex ), std::move(rhs.unex ));
has_val = false;
—(5.3) Otherwise, ifrhs.has_value() is true, destroysunex and setshas_val to true.
—(5.4) Otherwise, equivalent tounex = std::move(rhs.error()).
6 Returns: *this.
7 Remarks: The exception specification is equivalent tois_nothrow_move_constructible_v<E> &&
is_nothrow_move_assignable_v<E>.
template<class G>
constexpr expected& operator=(const unexpected<G>& e);
template<class G>
constexpr expected& operator=(unexpected<G>&& e);
8 Let GF be const G& for the first overload andG for the second overload.
9 Constraints: is_constructible_v<E, GF> is true and is_assignable_v<E&, GF> is true.
10 Effects:
—(10.1) If has_value() is true, equivalent to:
construct_at(addressof(unex ), std::forward<GF>(e.error()));
has_val = false;
—(10.2) Otherwise, equivalent to:unex = std::forward<GF>(e.error());
11 Returns: *this.
constexpr void emplace() noexcept;
12 Effects: If has_value() is false, destroysunex and setshas_val to true.
22.8.7.5 Swap [expected.void.swap]
constexpr void swap(expected& rhs) noexcept(see below );
1 Constraints: is_swappable_v<E> is true and is_move_constructible_v<E> is true.
2 Effects: See Table 73.
Table 73 —swap(expected&) effects [tab:expected.void.swap]
this->has_value() !this->has_value()
rhs.has_value() no effects calls rhs.swap(*this)
!rhs.has_value() see below equivalent to:using std::swap;
swap(unex , rhs.unex );
For the case whererhs.has_value() is false and this->has_value() is true, equivalent to:
construct_at(addressof(unex ), std::move(rhs.unex ));
destroy_at(addressof(rhs.unex ));
has_val = false;
rhs.has_val = true;
3 Throws: Any exception thrown by the expressions in theEffects.
4 Remarks: The exception specification is equivalent tois_nothrow_move_constructible_v<E> &&
is_nothrow_swappable_v<E>.
§ 22.8.7.5 © ISO/IEC
886

===== PAGE 898 =====

Dxxxx
friend constexpr void swap(expected& x, expected& y) noexcept(noexcept(x.swap(y)));
5 Effects: Equivalent tox.swap(y).
22.8.7.6 Observers [expected.void.obs]
constexpr explicit operator bool() const noexcept;
constexpr bool has_value() const noexcept;
1 Returns: has_val .
constexpr void operator*() const noexcept;
2 Hardened preconditions: has_value() is true.
constexpr void value() const &;
3 Mandates: is_copy_constructible_v<E> is true.
4 Throws: bad_expected_access(error()) if has_value() is false.
constexpr void value() &&;
5 Mandates: is_copy_constructible_v<E> is true and is_move_constructible_v<E> is true.
6 Throws: bad_expected_access(std::move(error())) if has_value() is false.
constexpr const E& error() const & noexcept;
constexpr E& error() & noexcept;
7 Hardened preconditions: has_value() is false.
8 Returns: unex .
constexpr E&& error() && noexcept;
constexpr const E&& error() const && noexcept;
9 Hardened preconditions: has_value() is false.
10 Returns: std::move(unex ).
template<class G = E> constexpr E error_or(G&& e) const &;
11 Mandates: is_copy_constructible_v<E> is true and is_convertible_v<G, E> is true.
12 Returns: std::forward<G>(e) if has_value() is true, error() otherwise.
template<class G = E> constexpr E error_or(G&& e) &&;
13 Mandates: is_move_constructible_v<E> is true and is_convertible_v<G, E> is true.
14 Returns: std::forward<G>(e) if has_value() is true, std::move(error()) otherwise.
22.8.7.7 Monadic operations [expected.void.monadic]
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) const &;
1 Let U be remove_cvref_t<invoke_result_t<F>>.
2 Constraints: is_constructible_v<E, decltype(error())>> is true.
3 Mandates: U is a specialization ofexpected and is_same_v<typename U::error_type, E> is true.
4 Effects: Equivalent to:
if (has_value())
return invoke(std::forward<F>(f));
else
return U(unexpect, error());
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &&;
5 Let U be remove_cvref_t<invoke_result_t<F>>.
6 Constraints: is_constructible_v<E, decltype(std::move(error()))> is true.
§ 22.8.7.7 © ISO/IEC
887

===== PAGE 899 =====

Dxxxx
7 Mandates: U is a specialization ofexpected and is_same_v<typename U::error_type, E> is true.
8 Effects: Equivalent to:
if (has_value())
return invoke(std::forward<F>(f));
else
return U(unexpect, std::move(error()));
template<class F> constexpr auto or_else(F&& f) &;
template<class F> constexpr auto or_else(F&& f) const &;
9 Let G be remove_cvref_t<invoke_result_t<F, decltype(error())>>.
10 Mandates: G is a specialization ofexpected and is_same_v<typename G::value_type, T> is true.
11 Effects: Equivalent to:
if (has_value())
return G();
else
return invoke(std::forward<F>(f), error());
template<class F> constexpr auto or_else(F&& f) &&;
template<class F> constexpr auto or_else(F&& f) const &&;
12 Let G be remove_cvref_t<invoke_result_t<F, decltype(std::move(error()))>>.
13 Mandates: G is a specialization ofexpected and is_same_v<typename G::value_type, T> is true.
14 Effects: Equivalent to:
if (has_value())
return G();
else
return invoke(std::forward<F>(f), std::move(error()));
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) const &;
15 Let U be remove_cv_t<invoke_result_t<F>>.
16 Constraints: is_constructible_v<E, decltype(error())> is true.
17 Mandates: U is a valid value type forexpected. If is_void_v<U> is false, the declaration
U u(invoke(std::forward<F>(f)));
is well-formed.
18 Effects:
—(18.1) If has_value() is false, returnsexpected<U, E>(unexpect, error()).
—(18.2) Otherwise, ifis_void_v<U> is false, returns anexpected<U, E> object whosehas_val member
is true and val member is direct-non-list-initialized withinvoke(std::forward<F>(f)).
—(18.3) Otherwise, evaluatesinvoke(std::forward<F>(f)) and then returnsexpected<U, E>().
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &&;
19 Let U be remove_cv_t<invoke_result_t<F>>.
20 Constraints: is_constructible_v<E, decltype(std::move(error()))> is true.
21 Mandates: U is a valid value type forexpected. If is_void_v<U> is false, the declaration
U u(invoke(std::forward<F>(f)));
is well-formed.
22 Effects:
—(22.1) If has_value() is false, returnsexpected<U, E>(unexpect, std::move(error())).
—(22.2) Otherwise, ifis_void_v<U> is false, returns anexpected<U, E> object whosehas_val member
is true and val member is direct-non-list-initialized withinvoke(std::forward<F>(f)).
§ 22.8.7.7 © ISO/IEC
888

===== PAGE 900 =====

Dxxxx
—(22.3) Otherwise, evaluatesinvoke(std::forward<F>(f)) and then returnsexpected<U, E>().
template<class F> constexpr auto transform_error(F&& f) &;
template<class F> constexpr auto transform_error(F&& f) const &;
23 Let G be remove_cv_t<invoke_result_t<F, decltype(error())>>.
24 Mandates: G is a valid template argument forunexpected (22.8.3.1) and the declaration
G g(invoke(std::forward<F>(f), error()));
is well-formed.
25 Returns: If has_value() is true, expected<T, G>(); otherwise, anexpected<T, G> object whose
has_val member is false and unex member is direct-non-list-initialized withinvoke(std::for-
ward<F>(f), error()).
template<class F> constexpr auto transform_error(F&& f) &&;
template<class F> constexpr auto transform_error(F&& f) const &&;
26 Let G be remove_cv_t<invoke_result_t<F, decltype(std::move(error()))>>.
27 Mandates: G is a valid template argument forunexpected (22.8.3.1) and the declaration
G g(invoke(std::forward<F>(f), std::move(error())));
is well-formed.
28 Returns: If has_value() is true, expected<T, G>(); otherwise, anexpected<T, G> object whose
has_val member is false and unex member is direct-non-list-initialized withinvoke(std::for-
ward<F>(f), std::move(error())).
22.8.7.8 Equality operators [expected.void.eq]
template<class T2, class E2> requires is_void_v<T2>
friend constexpr bool operator==(const expected& x, const expected<T2, E2>& y);
1 Constraints: The expressionx.error() == y.error() is well-formed and its result is convertible to
bool.
2 Returns: If x.has_value() does not equal y.has_value(), false; otherwise if x.has_value() is
true, true; otherwisex.error() == y.error().
template<class E2>
friend constexpr bool operator==(const expected& x, const unexpected<E2>& e);
3 Constraints: The expressionx.error() == e.error() is well-formed and its result is convertible to
bool.
4 Returns: If !x.has_value() is true, x.error() == e.error(); otherwisefalse.
22.9 Bitsets [bitset]
22.9.1 Header <bitset> synopsis [bitset.syn]
1 The header<bitset> defines a class template and several related functions for representing and manipulating
fixed-size sequences of bits.
#include <string> // see 27.4.2
#include <iosfwd> // for istream (31.7.1), ostream (31.7.2), see 31.3.1
namespace std {
template<size_t N> class bitset;
// 22.9.4, bitset operators
template<size_t N>
constexpr bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;
template<size_t N>
constexpr bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;
template<size_t N>
constexpr bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;
§ 22.9.1 © ISO/IEC
889

===== PAGE 901 =====

Dxxxx
template<class charT, class traits, size_t N>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
template<class charT, class traits, size_t N>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
}
22.9.2 Class template bitset [template.bitset]
22.9.2.1 General [template.bitset.general]
namespace std {
template<size_t N> class bitset {
public:
// bit reference
class reference {
public:
constexpr reference(const reference& x) noexcept;
constexpr ~reference();
constexpr reference& operator=(bool x) noexcept; // for b[i] = x;
constexpr reference& operator=(const reference& x) noexcept; // for b[i] = b[j];
constexpr const reference& operator=(bool x) const noexcept;
constexpr operator bool() const noexcept; // for x = b[i];
constexpr bool operator~() const noexcept; // flips the bit
constexpr reference& flip() noexcept; // for b[i].flip();
friend constexpr void swap(reference x, reference y) noexcept;
friend constexpr void swap(reference x, bool& y) noexcept;
friend constexpr void swap(bool& x, reference y) noexcept;
};
// 22.9.2.2, constructors
constexpr bitset() noexcept;
constexpr bitset(unsigned long long val) noexcept;
template<class charT, class traits, class Allocator>
constexpr explicit bitset(
const basic_string<charT, traits, Allocator>& str,
typename basic_string<charT, traits, Allocator>::size_type pos = 0,
typename basic_string<charT, traits, Allocator>::size_type n
= basic_string<charT, traits, Allocator>::npos,
charT zero = charT('0'),
charT one = charT('1'));
template<class charT, class traits>
constexpr explicit bitset(
basic_string_view<charT, traits> str,
typename basic_string_view<charT, traits>::size_type pos = 0,
typename basic_string_view<charT, traits>::size_type n
= basic_string_view<charT, traits>::npos,
charT zero = charT('0'),
charT one = charT('1'));
template<class charT>
constexpr explicit bitset(
const charT* str,
typename basic_string_view<charT>::size_type n = basic_string_view<charT>::npos,
charT zero = charT('0'),
charT one = charT('1'));
// 22.9.2.3, bitset operations
constexpr bitset& operator&=(const bitset& rhs) noexcept;
constexpr bitset& operator|=(const bitset& rhs) noexcept;
constexpr bitset& operator^=(const bitset& rhs) noexcept;
constexpr bitset& operator<<=(size_t pos) noexcept;
constexpr bitset& operator>>=(size_t pos) noexcept;
constexpr bitset operator<<(size_t pos) const noexcept;
§ 22.9.2.1 © ISO/IEC
890

===== PAGE 902 =====

Dxxxx
constexpr bitset operator>>(size_t pos) const noexcept;
constexpr bitset& set() noexcept;
constexpr bitset& set(size_t pos, bool val = true);
constexpr bitset& reset() noexcept;
constexpr bitset& reset(size_t pos);
constexpr bitset operator ~() const noexcept;
constexpr bitset& flip() noexcept;
constexpr bitset& flip(size_t pos);
// element access
constexpr bool operator[](size_t pos) const;
constexpr reference operator[](size_t pos);
constexpr unsigned long to_ulong() const;
constexpr unsigned long long to_ullong() const;
template<class charT = char,
class traits = char_traits<charT>,
class Allocator = allocator<charT>>
constexpr basic_string<charT, traits, Allocator>
to_string(charT zero = charT('0'), charT one = charT('1')) const;
// observers
constexpr size_t count() const noexcept;
constexpr size_t size() const noexcept;
constexpr bool operator==(const bitset& rhs) const noexcept;
constexpr bool test(size_t pos) const;
constexpr bool all() const noexcept;
constexpr bool any() const noexcept;
constexpr bool none() const noexcept;
};
// 22.9.3, hash support
template<class T> struct hash;
template<size_t N> struct hash<bitset<N>>;
}
1 The class templatebitset<N> describes an object that can store a sequence consisting of a fixed number of
bits, N.
2 Each bit represents either the value zero (reset) or one (set). Totoggle a bit is to change the value zero to
one, or the value one to zero. Each bit has a non-negative positionpos. When converting between an object
of typebitset<N> and a value of some integral type, bit positionpos corresponds to thebit value1 << pos.
The integral value corresponding to two or more bits is the sum of their bit values.
3 reference is a class that simulates a reference to a single bit in the sequence.
constexpr reference::reference(const reference& x) noexcept;
4 Effects: Initializes *this to refer to the same bit asx.
constexpr reference::~reference();
5 Effects: None.
constexpr reference& reference::operator=(bool x) noexcept;
constexpr reference& reference::operator=(const reference& x) noexcept;
constexpr const reference& reference::operator=(bool x) const noexcept;
6 Effects: Sets the bit referred to by*this if bool(x) is true, and clears it otherwise.
7 Returns: *this.
constexpr void swap(reference x, reference y) noexcept;
constexpr void swap(reference x, bool& y) noexcept;
constexpr void swap(bool& x, reference y) noexcept;
8 Effects: Exchanges the values denoted byx and y as if by:
bool b = x;
§ 22.9.2.1 © ISO/IEC
891

===== PAGE 903 =====

Dxxxx
x = y;
y = b;
constexpr reference& reference::flip() noexcept;
9 Effects: Equivalent to*this = !*this.
10 Returns: *this.
11 The functions described in 22.9.2 can report three kinds of errors, each associated with a distinct exception:
—(11.1) an invalid-argument error is associated with exceptions of typeinvalid_argument (19.2.5);
—(11.2) an out-of-range error is associated with exceptions of typeout_of_range (19.2.7);
—(11.3) an overflow error is associated with exceptions of typeoverflow_error (19.2.10).
22.9.2.2 Constructors [bitset.cons]
constexpr bitset() noexcept;
1 Effects: Initializes all bits in*this to zero.
constexpr bitset(unsigned long long val) noexcept;
2 Effects: Initializes the firstM bit positions to the corresponding bit values inval. M is the smaller of
N and the number of bits in the value representation (6.9.1) ofunsigned long long. If M < N, the
remaining bit positions are initialized to zero.
template<class charT, class traits, class Allocator>
constexpr explicit bitset(
const basic_string<charT, traits, Allocator>& str,
typename basic_string<charT, traits, Allocator>::size_type pos = 0,
typename basic_string<charT, traits, Allocator>::size_type n
= basic_string<charT, traits, Allocator>::npos,
charT zero = charT(’0’),
charT one = charT(’1’));
template<class charT, class traits>
constexpr explicit bitset(
basic_string_view<charT, traits> str,
typename basic_string_view<charT, traits>::size_type pos = 0,
typename basic_string_view<charT, traits>::size_type n
= basic_string_view<charT, traits>::npos,
charT zero = charT(’0’),
charT one = charT(’1’));
3 Effects: Determines the effective lengthrlenof the initializing string as the smaller ofnand str.size()
- pos. Initializes the firstM bit positions to values determined from the corresponding characters in the
string str. M is the smaller ofN and rlen.
4 An element of the constructed object has value zero if the corresponding character instr, beginning
at positionpos, iszero. Otherwise, the element has the value one. Character positionpos + M - 1
corresponds to bit position zero. Subsequent decreasing character positions correspond to increasing
bit positions.
5 If M < N, remaining bit positions are initialized to zero.
6 The function usestraits::eq to compare the character values.
7 Throws: out_of_range if pos > str.size() or invalid_argument if any of therlen characters in
str beginning at positionpos is other thanzero or one.
template<class charT>
constexpr explicit bitset(
const charT* str,
typename basic_string_view<charT>::size_type n = basic_string_view<charT>::npos,
charT zero = charT(’0’),
charT one = charT(’1’));
8 Constraints:
—(8.1) is_array_v<charT> is false,
§ 22.9.2.2 © ISO/IEC
892

===== PAGE 904 =====

Dxxxx
—(8.2) is_trivially_copyable_v<charT> is true,
—(8.3) is_standard_layout_v<charT> is true, and
—(8.4) is_trivially_default_constructible_v<charT> is true.
9 Effects: As if by:
bitset(n == basic_string_view<charT>::npos
? basic_string_view<charT>(str)
: basic_string_view<charT>(str, n),
0, n, zero, one)
22.9.2.3 Members [bitset.members]
constexpr bitset& operator&=(const bitset& rhs) noexcept;
1 Effects: Clears each bit in*this for which the corresponding bit inrhs is clear, and leaves all other
bits unchanged.
2 Returns: *this.
constexpr bitset& operator|=(const bitset& rhs) noexcept;
3 Effects: Sets each bit in*this for which the corresponding bit inrhs is set, and leaves all other bits
unchanged.
4 Returns: *this.
constexpr bitset& operator^=(const bitset& rhs) noexcept;
5 Effects: Toggles each bit in*this for which the corresponding bit inrhs is set, and leaves all other
bits unchanged.
6 Returns: *this.
constexpr bitset& operator<<=(size_t pos) noexcept;
7 Effects: Replaces each bit at positionI in *this with a value determined as follows:
—(7.1) If I < pos, the new value is zero;
—(7.2) If I >= pos, the new value is the previous value of the bit at positionI - pos.
8 Returns: *this.
constexpr bitset& operator>>=(size_t pos) noexcept;
9 Effects: Replaces each bit at positionI in *this with a value determined as follows:
—(9.1) If pos >= N - I, the new value is zero;
—(9.2) If pos < N - I, the new value is the previous value of the bit at positionI + pos.
10 Returns: *this.
constexpr bitset operator<<(size_t pos) const noexcept;
11 Returns: bitset(*this) <<= pos.
constexpr bitset operator>>(size_t pos) const noexcept;
12 Returns: bitset(*this) >>= pos.
constexpr bitset& set() noexcept;
13 Effects: Sets all bits in*this.
14 Returns: *this.
constexpr bitset& set(size_t pos, bool val = true);
15 Effects: Stores a new value in the bit at positionpos in *this. If val is true, the stored value is one,
otherwise it is zero.
16 Returns: *this.
17 Throws: out_of_range if pos does not correspond to a valid bit position.
§ 22.9.2.3 © ISO/IEC
893

===== PAGE 905 =====

Dxxxx
constexpr bitset& reset() noexcept;
18 Effects: Resets all bits in*this.
19 Returns: *this.
constexpr bitset& reset(size_t pos);
20 Effects: Resets the bit at positionpos in *this.
21 Returns: *this.
22 Throws: out_of_range if pos does not correspond to a valid bit position.
constexpr bitset operator~() const noexcept;
23 Effects: Constructs an objectx of classbitset and initializes it with*this.
24 Returns: x.flip().
constexpr bitset& flip() noexcept;
25 Effects: Toggles all bits in*this.
26 Returns: *this.
constexpr bitset& flip(size_t pos);
27 Effects: Toggles the bit at positionpos in *this.
28 Returns: *this.
29 Throws: out_of_range if pos does not correspond to a valid bit position.
constexpr bool operator[](size_t pos) const;
30 Hardened preconditions: pos < size() is true.
31 Returns: true if the bit at positionpos in *this has the value one, otherwisefalse.
32 Throws: Nothing.
constexpr bitset::reference operator[](size_t pos);
33 Hardened preconditions: pos < size() is true.
34 Returns: An object of typebitset::reference such that(*this)[pos] == this->test(pos), and
such that(*this)[pos] = val is equivalent tothis->set(pos, val).
35 Throws: Nothing.
36 Remarks: For the purpose of determining the presence of a data race (6.10.2), any access or update
through the resulting reference potentially accesses or modifies, respectively, the entire underlying
bitset.
constexpr unsigned long to_ulong() const;
37 Returns: x.
38 Throws: overflow_errorif the integral valuexcorresponding to the bits in*thiscannot be represented
as typeunsigned long.
constexpr unsigned long long to_ullong() const;
39 Returns: x.
40 Throws: overflow_errorif the integral valuexcorresponding to the bits in*thiscannot be represented
as typeunsigned long long.
template<class charT = char,
class traits = char_traits<charT>,
class Allocator = allocator<charT>>
constexpr basic_string<charT, traits, Allocator>
to_string(charT zero = charT(’0’), charT one = charT(’1’)) const;
41 Effects: Constructs a string object of the appropriate type and initializes it to a string of length
N characters. Each character is determined by the value of its corresponding bit position in*this.
Character positionN - 1 corresponds to bit position zero. Subsequent decreasing character positions
§ 22.9.2.3 © ISO/IEC
894

===== PAGE 906 =====

Dxxxx
correspond to increasing bit positions. Bit value zero becomes the characterzero, bit value one becomes
the characterone.
42 Returns: The created object.
constexpr size_t count() const noexcept;
43 Returns: A count of the number of bits set in*this.
constexpr size_t size() const noexcept;
44 Returns: N.
constexpr bool operator==(const bitset& rhs) const noexcept;
45 Returns: true if the value of each bit in*this equals the value of the corresponding bit inrhs.
constexpr bool test(size_t pos) const;
46 Returns: true if the bit at positionpos in *this has the value one.
47 Throws: out_of_range if pos does not correspond to a valid bit position.
constexpr bool all() const noexcept;
48 Returns: count() == size().
constexpr bool any() const noexcept;
49 Returns: count() != 0.
constexpr bool none() const noexcept;
50 Returns: count() == 0.
22.9.3 bitset hash support [bitset.hash]
template<size_t N> struct hash<bitset<N>>;
1 The specialization is enabled (22.10.19).
22.9.4 bitset operators [bitset.operators]
template<size_t N>
constexpr bitset<N> operator&(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
1 Returns: bitset<N>(lhs) &= rhs.
template<size_t N>
constexpr bitset<N> operator|(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
2 Returns: bitset<N>(lhs) |= rhs.
template<size_t N>
constexpr bitset<N> operator^(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
3 Returns: bitset<N>(lhs) ^= rhs.
template<class charT, class traits, size_t N>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
4 A formatted input function (31.7.5.3).
5 Effects: Extracts up toN characters fromis. Stores these characters in a temporary objectstr of type
basic_string<charT, traits>, then evaluates the expressionx = bitset<N>(str). Characters are
extracted and stored until any of the following occurs:
—(5.1) N characters have been extracted and stored;
—(5.2) end-of-file occurs on the input sequence;
—(5.3) the next input character is neitheris.widen(’0’) nor is.widen(’1’) (in which case the input
character is not extracted).
§ 22.9.4 © ISO/IEC
895

===== PAGE 907 =====

Dxxxx
6 If N > 0 and no characters are stored instr, ios_base::failbit is set in the input function’s local
error state beforesetstate is called.
7 Returns: is.
template<class charT, class traits, size_t N>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
8 Returns:
os << x.template to_string<charT, traits, allocator<charT>>(
use_facet<ctype<charT>>(os.getloc()).widen('0'),
use_facet<ctype<charT>>(os.getloc()).widen('1'))
(see 31.7.6.3).
22.10 Function objects [function.objects]
22.10.1 General [function.objects.general]
1 A function object typeis an object type (6.9.1) that can be the type of thepostfix-expression in a function
call (7.6.1.3, 12.2.2.2).185 A function objectis an object of a function object type. In the places where one
would expect to pass a pointer to a function to an algorithmic template (Clause 26), the interface is specified
to accept a function object. This not only makes algorithmic templates work with pointers to functions, but
also enables them to work with arbitrary function objects.
22.10.2 Header <functional> synopsis [functional.syn]
#include <initializer_list> // see 17.11.2
#include <typeinfo> // see 17.7.2
namespace std {
// 22.10.5, invoke
template<class F, class... Args>
constexpr invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) // freestanding
noexcept(is_nothrow_invocable_v<F, Args...>);
template<class R, class F, class... Args>
constexpr R invoke_r(F&& f, Args&&... args) // freestanding
noexcept(is_nothrow_invocable_r_v<R, F, Args...>);
// 22.10.6,reference_wrapper
template<class T> class reference_wrapper; // freestanding
template<class T> constexpr reference_wrapper<T> ref(T&) noexcept; // freestanding
template<class T> constexpr reference_wrapper<const T> cref(const T&) noexcept; // freestanding
template<class T> void ref(const T&&) = delete; // freestanding
template<class T> void cref(const T&&) = delete; // freestanding
template<class T>
constexpr reference_wrapper<T> ref(reference_wrapper<T>) noexcept; // freestanding
template<class T>
constexpr reference_wrapper<const T> cref(reference_wrapper<T>) noexcept; // freestanding
// 22.10.6.8,common_reference related specializations
template<class R, class T, template<class> class RQual, template<class> class TQual>
requires see below
struct basic_common_reference<R, T, RQual, TQual>;
template<class T, class R, template<class> class TQual, template<class> class RQual>
requires see below
struct basic_common_reference<T, R, TQual, RQual>;
185) Such a type is a function pointer or a class type which has a memberoperator() or a class type which has a conversion to
a pointer to function.
§ 22.10.2 © ISO/IEC
896

===== PAGE 908 =====

Dxxxx
// 22.10.7, arithmetic operations
template<class T = void> struct plus; // freestanding
template<class T = void> struct minus; // freestanding
template<class T = void> struct multiplies; // freestanding
template<class T = void> struct divides; // freestanding
template<class T = void> struct modulus; // freestanding
template<class T = void> struct negate; // freestanding
template<> struct plus<void>; // freestanding
template<> struct minus<void>; // freestanding
template<> struct multiplies<void>; // freestanding
template<> struct divides<void>; // freestanding
template<> struct modulus<void>; // freestanding
template<> struct negate<void>; // freestanding
// 22.10.8, comparisons
template<class T = void> struct equal_to; // freestanding
template<class T = void> struct not_equal_to; // freestanding
template<class T = void> struct greater; // freestanding
template<class T = void> struct less; // freestanding
template<class T = void> struct greater_equal; // freestanding
template<class T = void> struct less_equal; // freestanding
template<> struct equal_to<void>; // freestanding
template<> struct not_equal_to<void>; // freestanding
template<> struct greater<void>; // freestanding
template<> struct less<void>; // freestanding
template<> struct greater_equal<void>; // freestanding
template<> struct less_equal<void>; // freestanding
// 22.10.8.8, classcompare_three_way
struct compare_three_way; // freestanding
// 22.10.10, logical operations
template<class T = void> struct logical_and; // freestanding
template<class T = void> struct logical_or; // freestanding
template<class T = void> struct logical_not; // freestanding
template<> struct logical_and<void>; // freestanding
template<> struct logical_or<void>; // freestanding
template<> struct logical_not<void>; // freestanding
// 22.10.11, bitwise operations
template<class T = void> struct bit_and; // freestanding
template<class T = void> struct bit_or; // freestanding
template<class T = void> struct bit_xor; // freestanding
template<class T = void> struct bit_not; // freestanding
template<> struct bit_and<void>; // freestanding
template<> struct bit_or<void>; // freestanding
template<> struct bit_xor<void>; // freestanding
template<> struct bit_not<void>; // freestanding
// 22.10.12, identity
struct identity; // freestanding
// 22.10.13, function templatenot_fn
template<class F> constexpr unspecified not_fn(F&& f); // freestanding
template<auto f> constexpr unspecified not_fn() noexcept; // freestanding
// 22.10.14, function templatesbind_front and bind_back
template<class F, class... Args>
constexpr unspecified bind_front(F&&, Args&&...); // freestanding
template<auto f, class... Args>
constexpr unspecified bind_front(Args&&...); // freestanding
template<class F, class... Args>
constexpr unspecified bind_back(F&&, Args&&...); // freestanding
§ 22.10.2 © ISO/IEC
897

===== PAGE 909 =====

Dxxxx
template<auto f, class... Args>
constexpr unspecified bind_back(Args&&...); // freestanding
// 22.10.15, bind
template<class T> struct is_bind_expression; // freestanding
template<class T>
constexpr bool is_bind_expression_v = // freestanding
is_bind_expression<T>::value;
template<class T> struct is_placeholder; // freestanding
template<class T>
constexpr int is_placeholder_v = // freestanding
is_placeholder<T>::value;
template<class F, class... BoundArgs>
constexpr unspecified bind(F&&, BoundArgs&&...); // freestanding
template<class R, class F, class... BoundArgs>
constexpr unspecified bind(F&&, BoundArgs&&...); // freestanding
namespace placeholders {
// M is the implementation-defined number of placeholders
see below _1; // freestanding
see below _2; // freestanding
...
see below _M; // freestanding
}
// 22.10.16, member function adaptors
template<class R, class T>
constexpr unspecified mem_fn(R T::*) noexcept; // freestanding
// 22.10.17, polymorphic function wrappers
// 22.10.17.2, classbad_function_call
class bad_function_call;
// 22.10.17.3, class templatefunction
template<class> class function; // not defined
template<class R, class... ArgTypes> class function<R(ArgTypes...)>;
// 22.10.17.3.8,function specialized algorithms
template<class R, class... ArgTypes>
void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;
// 22.10.17.3.7,function null pointer comparison operator functions
template<class R, class... ArgTypes>
bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
// 22.10.17.4, move-only wrapper
template<class... S> class move_only_function; // not defined
template<class R, class... ArgTypes>
class move_only_function<R(ArgTypes...) cv ref noexcept(noex)>; // see below
// 22.10.17.5, copyable wrapper
template<class... S> class copyable_function; // not defined
template<class R, class... ArgTypes>
class copyable_function<R(ArgTypes...) cv ref noexcept(noex)>; // see below
// 22.10.17.6, non-owning wrapper
template<class... S> class function_ref; // freestanding, not defined
template<class R, class... ArgTypes>
class function_ref<R(ArgTypes...) cv noexcept(noex)>; // freestanding,see below
§ 22.10.2 © ISO/IEC
898

===== PAGE 910 =====

Dxxxx
// 22.10.18, searchers
template<class ForwardIterator1, class BinaryPredicate = equal_to<>>
class default_searcher; // freestanding
template<class RandomAccessIterator,
class Hash = hash<typename iterator_traits<RandomAccessIterator>::value_type>,
class BinaryPredicate = equal_to<>>
class boyer_moore_searcher;
template<class RandomAccessIterator,
class Hash = hash<typename iterator_traits<RandomAccessIterator>::value_type>,
class BinaryPredicate = equal_to<>>
class boyer_moore_horspool_searcher;
// 22.10.19, class templatehash
template<class T>
struct hash; // freestanding
namespace ranges {
// 22.10.9, concept-constrained comparisons
struct equal_to; // freestanding
struct not_equal_to; // freestanding
struct greater; // freestanding
struct less; // freestanding
struct greater_equal; // freestanding
struct less_equal; // freestanding
}
template<class Fn, class... Args>
concept callable = // exposition only
requires (Fn&& fn, Args&&... args) {
std::forward<Fn>(fn)(std::forward<Args>(args)...);
};
template<class Fn, class... Args>
concept nothrow-callable = // exposition only
callable <Fn, Args...> &&
requires (Fn&& fn, Args&&... args) {
{ std::forward<Fn>(fn)(std::forward<Args>(args)...) } noexcept;
};
template<class Fn, class... Args>
using call-result-t = decltype(declval<Fn>()(declval<Args>()...)); // exposition only
template<const auto& T>
using decayed-typeof = decltype(auto(T)); // exposition only
}
1 [Example 1: If a C++ program wants to have a by-element addition of two vectorsa and b containing double and put
the result intoa, it can do:
transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
—end example]
2 [Example 2: To negate every element ofa:
transform(a.begin(), a.end(), a.begin(), negate<double>());
—end example]
22.10.3 Definitions [func.def]
1 The following definitions apply to this Clause:
2 A call signatureis the name of a return type followed by a parenthesized comma-separated list of zero or
more argument types.
3 A callable typeis a function object type (22.10) or a pointer to member.
§ 22.10.3 © ISO/IEC
899

===== PAGE 911 =====

Dxxxx
4 A callable objectis an object of a callable type.
5 A call wrapper typeis a type that holds a callable object and supports a call operation that forwards to that
object.
6 A call wrapperis an object of a call wrapper type.
7 A target objectis the callable object held by a call wrapper.
8 A call wrapper type may additionally hold a sequence of objects and references that may be passed as
arguments to the target object. These entities are collectively referred to asbound argument entities.
9 The target object and bound argument entities of the call wrapper are collectively referred to asstate entities.
22.10.4 Requirements [func.require]
1 Define INVOKE(f, t1, t2, ... , tN) as follows:
—(1.1) (t1.*f)(t2, ... , tN) when f is a pointer to a member function of a classT and is_same_v<T,
remove_cvref_t<decltype(t1)>> || is_base_of_v<T, remove_cvref_t<decltype(t1)>> is true;
—(1.2) (t1.get().*f)(t2, ... , tN) when f is a pointer to a member function of a classT and remove_-
cvref_t<decltype(t1)> is a specialization ofreference_wrapper;
—(1.3) ((*t1).*f)(t2, ... , tN) when f is a pointer to a member function of a classT and t1 does not
satisfy the previous two items;
—(1.4) t1.*f when N = 1 and f is a pointer to data member of a classT and is_same_v<T, remove_cvref_-
t<decltype(t1)>> || is_base_of_v<T, remove_cvref_t<decltype(t1)>> is true;
—(1.5) t1.get().*f when N = 1 and f is a pointer to data member of a classT and remove_cvref_-
t<decltype(t1)> is a specialization ofreference_wrapper;
—(1.6) (*t1).*f when N = 1 and f is a pointer to data member of a classT and t1 does not satisfy the
previous two items;
—(1.7) f(t1, t2, ... , tN) in all other cases.
2 Define INVOKE<R>(f, t1, t2, ... , tN) as static_cast<void>(INVOKE(f, t1, t2, ... , tN)) if R is
cv void, otherwiseINVOKE(f, t1, t2, ... , tN) implicitly converted toR. If reference_converts_from_-
temporary_v<R, decltype(INVOKE(f, t1, t2, ... , tN))>is true, INVOKE<R>(f, t1, t2, ... , tN)is
ill-formed.
3 Every call wrapper (22.10.3) meets theCpp17MoveConstructible and Cpp17Destructible requirements. An
argument forwarding call wrapperis a call wrapper that can be called with an arbitrary argument list and
delivers the arguments to the target object as references. This forwarding step delivers rvalue arguments as
rvalue references and lvalue arguments as lvalue references.
[Note 1: In a typical implementation, argument forwarding call wrappers have an overloaded function call operator of
the form
template<class... UnBoundArgs>
constexpr R operator()(UnBoundArgs&&... unbound_args) cv-qual ;
—end note]
4 A perfect forwarding call wrapperis an argument forwarding call wrapper that forwards its state entities
to the underlying call expression. This forwarding step delivers a state entity of typeT as cv T& when the
call is performed on an lvalue of the call wrapper type and ascv T&& otherwise, wherecv represents the
cv-qualifiers of the call wrapper and wherecv shall be neithervolatile nor const volatile.
5 A call patterndefines the semantics of invoking a perfect forwarding call wrapper. A postfix call performed
on a perfect forwarding call wrapper is expression-equivalent (3.22) to an expressione determined from its
call patterncp by replacing all occurrences of the arguments of the call wrapper and its state entities with
references as described in the corresponding forwarding steps.
6 A simple call wrapperis a perfect forwarding call wrapper that meets theCpp17CopyConstructible and
Cpp17CopyAssignable requirements and whose copy constructor, move constructor, and assignment operators
are constexpr functions that do not throw exceptions.
7 The copy/move constructor of an argument forwarding call wrapper has the same apparent semantics as if
memberwise copy/move of its state entities were performed (11.4.5.3).
§ 22.10.4 © ISO/IEC
900

===== PAGE 912 =====

Dxxxx
[Note 2: This implies that each of the copy/move constructors has the same exception-specification as the corresponding
implicit definition and is declared asconstexpr if the corresponding implicit definition would be considered to be
constexpr. —end note]
8 Argument forwarding call wrappers returned by a given standard library function template have the same
type if the types of their corresponding state entities are the same.
22.10.5 invoke functions [func.invoke]
template<class F, class... Args>
constexpr invoke_result_t<F, Args...> invoke(F&& f, Args&&... args)
noexcept(is_nothrow_invocable_v<F, Args...>);
1 Constraints: is_invocable_v<F, Args...> is true.
2 Returns: INVOKE(std::forward<F>(f), std::forward<Args>(args)...) (22.10.4).
template<class R, class F, class... Args>
constexpr R invoke_r(F&& f, Args&&... args)
noexcept(is_nothrow_invocable_r_v<R, F, Args...>);
3 Constraints: is_invocable_r_v<R, F, Args...> is true.
4 Returns: INVOKE<R>(std::forward<F>(f), std::forward<Args>(args)...) (22.10.4).
22.10.6 Class template reference_wrapper [refwrap]
22.10.6.1 General [refwrap.general]
namespace std {
template<class T> class reference_wrapper {
public:
// types
using type = T;
// 22.10.6.2, constructors
template<class U>
constexpr reference_wrapper(U&&) noexcept(see below );
constexpr reference_wrapper(const reference_wrapper& x) noexcept;
// 22.10.6.3, assignment
constexpr reference_wrapper& operator=(const reference_wrapper& x) noexcept;
// 22.10.6.4, access
constexpr operator T& () const noexcept;
constexpr T& get() const noexcept;
// 22.10.6.5, invocation
template<class... ArgTypes>
constexpr invoke_result_t<T&, ArgTypes...> operator()(ArgTypes&&...) const
noexcept(is_nothrow_invocable_v<T&, ArgTypes...>);
// 22.10.6.6, comparisons
friend constexpr bool operator==(reference_wrapper, reference_wrapper);
friend constexpr bool operator==(reference_wrapper, const T&);
friend constexpr bool operator==(reference_wrapper, reference_wrapper<const T>);
friend constexpr auto operator<=>(reference_wrapper, reference_wrapper);
friend constexpr auto operator<=>(reference_wrapper, const T&);
friend constexpr auto operator<=>(reference_wrapper, reference_wrapper<const T>);
};
template<class T>
reference_wrapper(T&) -> reference_wrapper<T>;
}
1 reference_wrapper<T> is aCpp17CopyConstructible and Cpp17CopyAssignable wrapper around a reference
to an object or function of typeT.
§ 22.10.6.1 © ISO/IEC
901

===== PAGE 913 =====

Dxxxx
2 reference_wrapper<T> is a trivially copyable type (6.9.1).
3 The template parameterT of reference_wrapper may be an incomplete type.
[Note 1: Using the comparison operators described in 22.10.6.6 withT being an incomplete type can lead to an
ill-formed program with no diagnostic required (13.8.4.1, 13.5.2.3).—end note]
22.10.6.2 Constructors [refwrap.const]
template<class U>
constexpr reference_wrapper(U&& u) noexcept(see below );
1 Let FUN denote the exposition-only functions
void FUN(T&) noexcept;
void FUN(T&&) = delete;
2 Constraints: The expressionFUN(declval<U>()) is well-formed andis_same_v<remove_cvref_t<U>,
reference_wrapper> is false.
3 Effects: Creates a variabler as if byT& r = std::forward<U>(u), then constructs areference_-
wrapper object that stores a reference tor.
4 Remarks: The exception specification is equivalent tonoexcept(FUN(declval<U>())).
constexpr reference_wrapper(const reference_wrapper& x) noexcept;
5 Effects: Constructs areference_wrapper object that stores a reference tox.get().
22.10.6.3 Assignment [refwrap.assign]
constexpr reference_wrapper& operator=(const reference_wrapper& x) noexcept;
1 Postconditions: *this stores a reference tox.get().
22.10.6.4 Access [refwrap.access]
constexpr operator T& () const noexcept;
1 Returns: The stored reference.
constexpr T& get() const noexcept;
2 Returns: The stored reference.
22.10.6.5 Invocation [refwrap.invoke]
template<class... ArgTypes>
constexpr invoke_result_t<T&, ArgTypes...>
operator()(ArgTypes&&... args) const noexcept(is_nothrow_invocable_v<T&, ArgTypes...>);
1 Mandates: T is a complete type.
2 Returns: INVOKE(get(), std::forward<ArgTypes>(args)...) (22.10.4).
22.10.6.6 Comparisons [refwrap.comparisons]
friend constexpr bool operator==(reference_wrapper x, reference_wrapper y);
1 Constraints: The expressionx.get() == y.get() is well-formed and its result is convertible tobool.
2 Returns: x.get() == y.get().
friend constexpr bool operator==(reference_wrapper x, const T& y);
3 Constraints: The expressionx.get() == y is well-formed and its result is convertible tobool.
4 Returns: x.get() == y.
friend constexpr bool operator==(reference_wrapper x, reference_wrapper<const T> y);
5 Constraints: is_const_v<T> is false and the expressionx.get() == y.get() is well-formed and its
result is convertible tobool.
6 Returns: x.get() == y.get().
§ 22.10.6.6 © ISO/IEC
902

===== PAGE 914 =====

Dxxxx
friend constexpr auto operator<=>(reference_wrapper x, reference_wrapper y);
7 Constraints: The expressionsynth-three-way (x.get(), y.get()) is well-formed.
8 Returns: synth-three-way (x.get(), y.get()).
friend constexpr auto operator<=>(reference_wrapper x, const T& y);
9 Constraints: The expressionsynth-three-way (x.get(), y) is well-formed.
10 Returns: synth-three-way (x.get(), y).
friend constexpr auto operator<=>(reference_wrapper x, reference_wrapper<const T> y);
11 Constraints: is_const_v<T> is false. The expression synth-three-way (x.get(), y.get()) is
well-formed.
12 Returns: synth-three-way (x.get(), y.get()).
22.10.6.7 Helper functions [refwrap.helpers]
1 The template parameterT of the followingref and cref function templates may be an incomplete type.
template<class T> constexpr reference_wrapper<T> ref(T& t) noexcept;
2 Returns: reference_wrapper<T>(t).
template<class T> constexpr reference_wrapper<T> ref(reference_wrapper<T> t) noexcept;
3 Returns: t.
template<class T> constexpr reference_wrapper<const T> cref(const T& t) noexcept;
4 Returns: reference_wrapper<const T>(t).
template<class T> constexpr reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;
5 Returns: t.
22.10.6.8 common_reference related specializations [refwrap.common.ref]
namespace std {
template<class T>
constexpr bool is-ref-wrapper = false; // exposition only
template<class T>
constexpr bool is-ref-wrapper <reference_wrapper<T>> = true;
template<class R, class T, class RQ, class TQ>
concept ref-wrap-common-reference-exists-with = // exposition only
is-ref-wrapper <R> &&
requires { typename common_reference_t<typename R::type&, TQ>; } &&
convertible_to<RQ, common_reference_t<typename R::type&, TQ>>;
template<class R, class T, template<class> class RQual, template<class> class TQual>
requires (ref-wrap-common-reference-exists-with <R, T, RQual<R>, TQual<T>> &&
!ref-wrap-common-reference-exists-with <T, R, TQual<T>, RQual<R>>)
struct basic_common_reference<R, T, RQual, TQual> {
using type = common_reference_t<typename R::type&, TQual<T>>;
};
template<class T, class R, template<class> class TQual, template<class> class RQual>
requires (ref-wrap-common-reference-exists-with <R, T, RQual<R>, TQual<T>> &&
!ref-wrap-common-reference-exists-with <T, R, TQual<T>, RQual<R>>)
struct basic_common_reference<T, R, TQual, RQual> {
using type = common_reference_t<typename R::type&, TQual<T>>;
};
}
§ 22.10.6.8 © ISO/IEC
903

===== PAGE 915 =====

Dxxxx
22.10.7 Arithmetic operations [arithmetic.operations]
22.10.7.1 General [arithmetic.operations.general]
1 The library provides basic function object classes for all of the arithmetic operators in the language (7.6.5,
7.6.6).
22.10.7.2 Class template plus [arithmetic.operations.plus]
template<class T = void> struct plus {
constexpr T operator()(const T& x, const T& y) const;
};
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x + y.
template<> struct plus<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) + std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) + std::forward<U>(u));
2 Returns: std::forward<T>(t) + std::forward<U>(u).
22.10.7.3 Class template minus [arithmetic.operations.minus]
template<class T = void> struct minus {
constexpr T operator()(const T& x, const T& y) const;
};
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x - y.
template<> struct minus<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) - std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) - std::forward<U>(u));
2 Returns: std::forward<T>(t) - std::forward<U>(u).
22.10.7.4 Class template multiplies [arithmetic.operations.multiplies]
template<class T = void> struct multiplies {
constexpr T operator()(const T& x, const T& y) const;
};
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x * y.
template<> struct multiplies<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) * std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) * std::forward<U>(u));
2 Returns: std::forward<T>(t) * std::forward<U>(u).
§ 22.10.7.4 © ISO/IEC
904

===== PAGE 916 =====

Dxxxx
22.10.7.5 Class template divides [arithmetic.operations.divides]
template<class T = void> struct divides {
constexpr T operator()(const T& x, const T& y) const;
};
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x / y.
template<> struct divides<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) / std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) / std::forward<U>(u));
2 Returns: std::forward<T>(t) / std::forward<U>(u).
22.10.7.6 Class template modulus [arithmetic.operations.modulus]
template<class T = void> struct modulus {
constexpr T operator()(const T& x, const T& y) const;
};
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x % y.
template<> struct modulus<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) % std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) % std::forward<U>(u));
2 Returns: std::forward<T>(t) % std::forward<U>(u).
22.10.7.7 Class template negate [arithmetic.operations.negate]
template<class T = void> struct negate {
constexpr T operator()(const T& x) const;
};
constexpr T operator()(const T& x) const;
1 Returns: -x.
template<> struct negate<void> {
template<class T> constexpr auto operator()(T&& t) const
-> decltype(-std::forward<T>(t));
using is_transparent = unspecified ;
};
template<class T> constexpr auto operator()(T&& t) const
-> decltype(-std::forward<T>(t));
2 Returns: -std::forward<T>(t).
§ 22.10.7.7 © ISO/IEC
905

===== PAGE 917 =====

Dxxxx
22.10.8 Comparisons [comparisons]
22.10.8.1 General [comparisons.general]
1 The library provides basic function object classes for all of the comparison operators in the language (7.6.9,
7.6.10).
2 For templatesless, greater, less_equal, and greater_equal, the specializations for any pointer type
yield a result consistent with the implementation-defined strict total order over pointers (3.28).
[Note 1: If a < b is well-defined for pointersa and b of type P, then (a < b) == less<P>()(a, b), (a > b) ==
greater<P>()(a, b), and so forth.—end note]
For template specializationsless<void>, greater<void>, less_equal<void>, andgreater_equal<void>,
if the call operator calls a built-in operator comparing pointers, the call operator yields a result consistent
with the implementation-defined strict total order over pointers.
22.10.8.2 Class template equal_to [comparisons.equal.to]
template<class T = void> struct equal_to {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x == y.
template<> struct equal_to<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) == std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) == std::forward<U>(u));
2 Returns: std::forward<T>(t) == std::forward<U>(u).
22.10.8.3 Class template not_equal_to [comparisons.not.equal.to]
template<class T = void> struct not_equal_to {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x != y.
template<> struct not_equal_to<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) != std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) != std::forward<U>(u));
2 Returns: std::forward<T>(t) != std::forward<U>(u).
22.10.8.4 Class template greater [comparisons.greater]
template<class T = void> struct greater {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x > y.
§ 22.10.8.4 © ISO/IEC
906

===== PAGE 918 =====

Dxxxx
template<> struct greater<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) > std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) > std::forward<U>(u));
2 Returns: std::forward<T>(t) > std::forward<U>(u).
22.10.8.5 Class template less [comparisons.less]
template<class T = void> struct less {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x < y.
template<> struct less<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) < std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) < std::forward<U>(u));
2 Returns: std::forward<T>(t) < std::forward<U>(u).
22.10.8.6 Class template greater_equal [comparisons.greater.equal]
template<class T = void> struct greater_equal {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x >= y.
template<> struct greater_equal<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) >= std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) >= std::forward<U>(u));
2 Returns: std::forward<T>(t) >= std::forward<U>(u).
22.10.8.7 Class template less_equal [comparisons.less.equal]
template<class T = void> struct less_equal {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x <= y.
template<> struct less_equal<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) <= std::forward<U>(u));
§ 22.10.8.7 © ISO/IEC
907

===== PAGE 919 =====

Dxxxx
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) <= std::forward<U>(u));
2 Returns: std::forward<T>(t) <= std::forward<U>(u).
22.10.8.8 Class compare_three_way [comparisons.three.way]
namespace std {
struct compare_three_way {
template<class T, class U>
constexpr auto operator()(T&& t, U&& u) const;
using is_transparent = unspecified ;
};
}
template<class T, class U>
constexpr auto operator()(T&& t, U&& u) const;
1 Constraints: T and U satisfy three_way_comparable_with.
2 Preconditions: If the expressionstd::forward<T>(t) <=> std::forward<U>(u) results in a call to a
built-in operator<=> comparing pointers of typeP, the conversion sequences from bothT and U to P
are equality-preserving (18.2); otherwise,T and U model three_way_comparable_with.
3 Effects:
—(3.1) If the expressionstd::forward<T>(t) <=> std::forward<U>(u) results in a call to a built-in
operator <=> comparing pointers of typeP, returnsstrong_ordering::less if (the converted
value of) t precedes u in the implementation-defined strict total order over pointers (3.28),
strong_ordering::greater if u precedes t, and otherwisestrong_ordering::equal.
—(3.2) Otherwise, equivalent to:return std::forward<T>(t) <=> std::forward<U>(u);
22.10.9 Concept-constrained comparisons [range.cmp]
struct ranges::equal_to {
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
using is_transparent = unspecified;
};
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
1 Constraints: T and U satisfy equality_comparable_with.
2 Preconditions: If the expressionstd::forward<T>(t) == std::forward<U>(u) results in a call to a
built-in operator== comparing pointers of typeP, the conversion sequences from bothT and U to P are
equality-preserving (18.2); otherwise,T and U model equality_comparable_with.
3 Effects:
—(3.1) If the expressionstd::forward<T>(t) == std::forward<U>(u) results in a call to a built-in
operator == comparing pointers: returnsfalse if either (the converted value of)t precedes u or
u precedes t in the implementation-defined strict total order over pointers (3.28) and otherwise
true.
—(3.2) Otherwise, equivalent to:return std::forward<T>(t) == std::forward<U>(u);
struct ranges::not_equal_to {
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
using is_transparent = unspecified;
};
§ 22.10.9 © ISO/IEC
908

===== PAGE 920 =====

Dxxxx
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
4 Constraints: T and U satisfy equality_comparable_with.
5 Effects: Equivalent to:
return !ranges::equal_to{}(std::forward<T>(t), std::forward<U>(u));
struct ranges::greater {
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
using is_transparent = unspecified;
};
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
6 Constraints: T and U satisfy totally_ordered_with.
7 Effects: Equivalent to:
return ranges::less{}(std::forward<U>(u), std::forward<T>(t));
struct ranges::less {
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
using is_transparent = unspecified;
};
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
8 Constraints: T and U satisfy totally_ordered_with.
9 Preconditions: If the expressionstd::forward<T>(t) < std::forward<U>(u) results in a call to a
built-in operator< comparing pointers of typeP, the conversion sequences from bothT and U to P are
equality-preserving (18.2); otherwise,T and U model totally_ordered_with. For any expressionsET
and EU such thatdecltype((ET)) is T and decltype((EU)) is U, exactly one ofranges::less{}(ET,
EU), ranges::less{}(EU, ET), orranges::equal_to{}(ET, EU) is true.
10 Effects:
—(10.1) If the expression std::forward<T>(t) < std::forward<U>(u) results in a call to a built-in
operator < comparing pointers: returns true if (the converted value of)t precedes u in the
implementation-defined strict total order over pointers (3.28) and otherwisefalse.
—(10.2) Otherwise, equivalent to:return std::forward<T>(t) < std::forward<U>(u);
struct ranges::greater_equal {
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
using is_transparent = unspecified;
};
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
11 Constraints: T and U satisfy totally_ordered_with.
12 Effects: Equivalent to:
return !ranges::less{}(std::forward<T>(t), std::forward<U>(u));
struct ranges::less_equal {
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
using is_transparent = unspecified;
};
§ 22.10.9 © ISO/IEC
909

===== PAGE 921 =====

Dxxxx
template<class T, class U>
constexpr bool operator()(T&& t, U&& u) const;
13 Constraints: T and U satisfy totally_ordered_with.
14 Effects: Equivalent to:
return !ranges::less{}(std::forward<U>(u), std::forward<T>(t));
22.10.10 Logical operations [logical.operations]
22.10.10.1 General [logical.operations.general]
1 The library provides basic function object classes for all of the logical operators in the language (7.6.14,
7.6.15, 7.6.2.2).
22.10.10.2 Class template logical_and [logical.operations.and]
template<class T = void> struct logical_and {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x && y.
template<> struct logical_and<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) && std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) && std::forward<U>(u));
2 Returns: std::forward<T>(t) && std::forward<U>(u).
22.10.10.3 Class template logical_or [logical.operations.or]
template<class T = void> struct logical_or {
constexpr bool operator()(const T& x, const T& y) const;
};
constexpr bool operator()(const T& x, const T& y) const;
1 Returns: x || y.
template<> struct logical_or<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) || std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) || std::forward<U>(u));
2 Returns: std::forward<T>(t) || std::forward<U>(u).
22.10.10.4 Class template logical_not [logical.operations.not]
template<class T = void> struct logical_not {
constexpr bool operator()(const T& x) const;
};
constexpr bool operator()(const T& x) const;
1 Returns: !x.
§ 22.10.10.4 © ISO/IEC
910

===== PAGE 922 =====

Dxxxx
template<> struct logical_not<void> {
template<class T> constexpr auto operator()(T&& t) const
-> decltype(!std::forward<T>(t));
using is_transparent = unspecified ;
};
template<class T> constexpr auto operator()(T&& t) const
-> decltype(!std::forward<T>(t));
2 Returns: !std::forward<T>(t).
22.10.11 Bitwise operations [bitwise.operations]
22.10.11.1 General [bitwise.operations.general]
1 The library provides basic function object classes for all of the bitwise operators in the language (7.6.11,
7.6.13, 7.6.12, 7.6.2.2).
22.10.11.2 Class template bit_and [bitwise.operations.and]
template<class T = void> struct bit_and {
constexpr T operator()(const T& x, const T& y) const;
};
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x & y.
template<> struct bit_and<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) & std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) & std::forward<U>(u));
2 Returns: std::forward<T>(t) & std::forward<U>(u).
22.10.11.3 Class template bit_or [bitwise.operations.or]
template<class T = void> struct bit_or {
constexpr T operator()(const T& x, const T& y) const;
};
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x | y.
template<> struct bit_or<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) | std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) | std::forward<U>(u));
2 Returns: std::forward<T>(t) | std::forward<U>(u).
22.10.11.4 Class template bit_xor [bitwise.operations.xor]
template<class T = void> struct bit_xor {
constexpr T operator()(const T& x, const T& y) const;
};
§ 22.10.11.4 © ISO/IEC
911

===== PAGE 923 =====

Dxxxx
constexpr T operator()(const T& x, const T& y) const;
1 Returns: x ^ y.
template<> struct bit_xor<void> {
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) ^ std::forward<U>(u));
using is_transparent = unspecified ;
};
template<class T, class U> constexpr auto operator()(T&& t, U&& u) const
-> decltype(std::forward<T>(t) ^ std::forward<U>(u));
2 Returns: std::forward<T>(t) ^ std::forward<U>(u).
22.10.11.5 Class template bit_not [bitwise.operations.not]
template<class T = void> struct bit_not {
constexpr T operator()(const T& x) const;
};
constexpr T operator()(const T& x) const;
1 Returns: ~x.
template<> struct bit_not<void> {
template<class T> constexpr auto operator()(T&& t) const
-> decltype(~std::forward<T>(t));
using is_transparent = unspecified ;
};
template<class T> constexpr auto operator()(T&& t) const
-> decltype(~std::forward<T>(t));
2 Returns: ~std::forward<T>(t).
22.10.12 Class identity [func.identity]
struct identity {
template<class T>
constexpr T&& operator()(T&& t) const noexcept;
using is_transparent = unspecified ;
};
template<class T>
constexpr T&& operator()(T&& t) const noexcept;
1 Effects: Equivalent to:return std::forward<T>(t);
22.10.13 Function template not_fn [func.not.fn]
template<class F> constexpr unspecified not_fn(F&& f);
1 In the text that follows:
—(1.1) g is a value of the result of anot_fn invocation,
—(1.2) FD is the typedecay_t<F>,
—(1.3) fd is the target object ofg (22.10.3) of typeFD, direct-non-list-initialized withstd::forward<F
>(f),
—(1.4) call_args is an argument pack used in a function call expression (7.6.1.3) ofg.
2 Mandates: is_constructible_v<FD, F> && is_move_constructible_v<FD> is true.
3 Preconditions: FD meets theCpp17MoveConstructible requirements.
4 Returns: A perfect forwarding call wrapper (22.10.4)g with call pattern!invoke(fd, call_args...).
§ 22.10.13 © ISO/IEC
912

===== PAGE 924 =====

Dxxxx
5 Throws: Any exception thrown by the initialization offd.
template<auto f> constexpr unspecified not_fn() noexcept;
6 In the text that follows:
—(6.1) F is the type off,
—(6.2) g is a value of the result of anot_fn invocation,
—(6.3) call_args is an argument pack used in a function call expression (7.6.1.3) ofg.
7 Mandates: If is_pointer_v<F> || is_member_pointer_v<F> is true, thenf != nullptr is true.
8 Returns: A perfect forwarding call wrapper (22.10.4)g that does not have state entities, and has the
call pattern!invoke(f, call_args...).
22.10.14 Function templates bind_front and bind_back [func.bind.partial]
template<class F, class... Args>
constexpr unspecified bind_front(F&& f, Args&&... args);
template<class F, class... Args>
constexpr unspecified bind_back(F&& f, Args&&... args);
1 Within this subclause:
—(1.1) g is a value of the result of abind_front or bind_back invocation,
—(1.2) FD is the typedecay_t<F>,
—(1.3) fd is the target object ofg (22.10.3) of typeFD, direct-non-list-initialized withstd::forward<F
>(f),
—(1.4) BoundArgs is a pack that denotesdecay_t<Args>...,
—(1.5) bound_args is a pack of bound argument entities ofg (22.10.3) of typesBoundArgs..., direct-
non-list-initialized withstd::forward<Args>(args)..., respectively, and
—(1.6) call_args is an argument pack used in a function call expression (7.6.1.3) ofg.
2 Mandates:
is_constructible_v<FD, F> &&
is_move_constructible_v<FD> &&
(is_constructible_v<BoundArgs, Args> && ...) &&
(is_move_constructible_v<BoundArgs> && ...)
is true.
3 Preconditions: FD meets theCpp17MoveConstructible requirements. For eachTi in BoundArgs, ifTi is
an object type,Ti meets theCpp17MoveConstructible requirements.
4 Returns: A perfect forwarding call wrapper (22.10.4)g with call pattern:
—(4.1) invoke(fd, bound_args..., call_args...) for abind_front invocation, or
—(4.2) invoke(fd, call_args..., bound_args...) for abind_back invocation.
5 Throws: Any exception thrown by the initialization of the state entities ofg (22.10.3).
template<auto f, class... Args>
constexpr unspecified bind_front(Args&&... args);
template<auto f, class... Args>
constexpr unspecified bind_back(Args&&... args);
6 Within this subclause:
—(6.1) F is the type off,
—(6.2) g is a value of the result of abind_front or bind_back invocation,
—(6.3) BoundArgs is a pack that denotesdecay_t<Args>...,
—(6.4) bound_args is a pack of bound argument entities ofg (22.10.3) of typesBoundArgs..., direct-
non-list-initialized withstd::forward<Args>(args)..., respectively, and
—(6.5) call_args is an argument pack used in a function call expression (7.6.1.3) ofg.
§ 22.10.14 © ISO/IEC
913

===== PAGE 925 =====

Dxxxx
7 Mandates:
—(7.1) (is_constructible_v<BoundArgs, Args> && ...) is true, and
—(7.2) (is_move_constructible_v<BoundArgs> && ...) is true, and
—(7.3) if is_pointer_v<F> || is_member_pointer_v<F> is true, thenf != nullptr is true.
8 Preconditions: For eachTi in BoundArgs, Ti meets theCpp17MoveConstructible requirements.
9 Returns: A perfect forwarding call wrapper (22.10.4)g that does not have a target object, and has the
call pattern:
—(9.1) invoke(f, bound_args..., call_args...) for abind_front invocation, or
—(9.2) invoke(f, call_args..., bound_args...) for abind_back invocation.
10 Throws: Any exception thrown by the initialization ofbound_args.
22.10.15 Function object binders [func.bind]
22.10.15.1 General [func.bind.general]
1 Subclause 22.10.15 describes a uniform mechanism for binding arguments of callable objects.
22.10.15.2 Class template is_bind_expression [func.bind.isbind]
namespace std {
template<class T> struct is_bind_expression; // see below
}
1 The class templateis_bind_expression can be used to detect function objects generated bybind. The
function templatebind uses is_bind_expression to detect subexpressions.
2 Specializations of theis_bind_expression template shall meet theCpp17UnaryTypeTraitrequirements
(21.3.2). The implementation provides a definition that has a base characteristic oftrue_type if T is a type
returned frombind, otherwise it has a base characteristic offalse_type. A program may specialize this
template for a program-defined typeT to have a base characteristic oftrue_type to indicate thatT should
be treated as a subexpression in abind call.
22.10.15.3 Class template is_placeholder [func.bind.isplace]
namespace std {
template<class T> struct is_placeholder; // see below
}
1 The class templateis_placeholder can be used to detect the standard placeholders_1, _2, and so on
(22.10.15.5). The function templatebind uses is_placeholder to detect placeholders.
2 Specializations of theis_placeholder template shall meet theCpp17UnaryTypeTraitrequirements (21.3.2).
The implementation provides a definition that has the base characteristic ofintegral_constant<int, J > if
T is the type ofstd::placeholders::_J , otherwise it has a base characteristic ofintegral_constant<int,
0>. A program may specialize this template for a program-defined typeT to have a base characteristic of
integral_constant<int, N> with N > 0 to indicate thatT should be treated as a placeholder type.
22.10.15.4 Function template bind [func.bind.bind]
1 In the text that follows:
—(1.1) g is a value of the result of abind invocation,
—(1.2) FD is the typedecay_t<F>,
—(1.3) fd is an lvalue that is a target object of g (22.10.3) of type FD direct-non-list-initialized with
std::forward<F>(f),
—(1.4) Ti is theith type in the template parameter packBoundArgs,
—(1.5) TDi is the typedecay_t<Ti>,
—(1.6) ti is theith argument in the function parameter packbound_args,
—(1.7) tdi is a bound argument entity ofg (22.10.3) of typeTDi direct-non-list-initialized withstd::forward<
Ti>(ti),
—(1.8) Uj is thejth deduced type of theUnBoundArgs&&... parameter of the argument forwarding call wrapper,
and
§ 22.10.15.4 © ISO/IEC
914

===== PAGE 926 =====

Dxxxx
—(1.9) uj is thejth argument associated withUj.
template<class F, class... BoundArgs>
constexpr unspecified bind(F&& f, BoundArgs&&... bound_args);
template<class R, class F, class... BoundArgs>
constexpr unspecified bind(F&& f, BoundArgs&&... bound_args);
2 Mandates: is_constructible_v<FD, F> is true. For each Ti in BoundArgs, is_constructible_-
v<TDi, Ti> is true.
3 Preconditions: FD and eachTDi meet theCpp17MoveConstructible and Cpp17Destructible requirements.
INVOKE(fd, w1, w2, ... , wN) (22.10.4) is a valid expression for some valuesw1, w2, ... , wN, where
N has the valuesizeof...(bound_args).
4 Returns: An argument forwarding call wrapperg (22.10.4). A program that attempts to invoke a
volatile-qualified g is ill-formed. Wheng is not volatile-qualified, invocation ofg(u1, u2, ... , uM) is
expression-equivalent (3.22) to
INVOKE(static_cast<Vfd>(vfd),
static_cast<V1>(v1), static_cast<V2>(v2), ... , static_cast<VN >(vN ))
for the first overload, and
INVOKE<R>(static_cast<Vfd>(vfd),
static_cast<V1>(v1), static_cast<V2>(v2), ... , static_cast<VN >(vN ))
for the second overload, where the values and types of the target argumentvfd and of the bound
arguments v1, v2, ... , vN are determined as specified below.
5 Throws: Any exception thrown by the initialization of the state entities ofg.
6 [Note 1: If all ofFD and TDi meet the requirements ofCpp17CopyConstructible, then the return type meets the
requirements ofCpp17CopyConstructible. —end note]
7 The values of thebound argumentsv1, v2, ... , vN and their corresponding typesV1, V2, ... , VN depend on
the typesTDi derived from the call tobind and the cv-qualifierscv of the call wrapperg as follows:
—(7.1) if TDi is reference_wrapper<T>, the argument istdi.get() and its typeVi is T&;
—(7.2) if the value ofis_bind_expression_v<TDi> is true, the argument is
static_cast<cv TDi&>(tdi)(std::forward<Uj>(uj)...)
and its typeVi is invoke_result_t<cv TDi&, Uj...>&&;
—(7.3) if the valuej of is_placeholder_v<TDi> is not zero, the argument isstd::forward<Uj>(uj) and its
type Vi is Uj&&;
—(7.4) otherwise, the value istdi and its typeVi is cv TDi&.
8 The value of the target argumentvfd is fd and its corresponding typeVfd is cv FD&.
22.10.15.5 Placeholders [func.bind.place]
namespace std::placeholders {
// M is the number of placeholders
see below _1;
see below _2;
...
see below _M;
}
1 The numberM of placeholders is implementation-defined.
2 All placeholder types meet theCpp17DefaultConstructible and Cpp17CopyConstructible requirements, and
their default constructors and copy/move constructors are constexpr functions that do not throw exceptions.
It is implementation-defined whether placeholder types meet theCpp17CopyAssignable requirements, but if
so, their copy assignment operators are constexpr functions that do not throw exceptions.
3 Placeholders should be defined as:
inline constexpr unspecified _1{};
If they are not, they are declared as:
extern unspecified _1;
§ 22.10.15.5 © ISO/IEC
915

===== PAGE 927 =====

Dxxxx
4 Placeholders are freestanding items (16.3.3.7).
22.10.16 Function template mem_fn [func.memfn]
template<class R, class T> constexpr unspecified mem_fn(R T::* pm) noexcept;
1 Returns: A simple call wrapper (22.10.4)fn with call patterninvoke(pmd, call_args...), where
pmd is the target object offn of typeR T::* direct-non-list-initialized withpm, andcall_args is an
argument pack used in a function call expression (7.6.1.3) offn.
22.10.17 Polymorphic function wrappers [func.wrap]
22.10.17.1 General [func.wrap.general]
1 Subclause 22.10.17 describes polymorphic wrapper classes that encapsulate arbitrary callable objects.
2 Let t be an object of a type that is a specialization offunction, copyable_function, or move_only_-
function, such that the target objectx of t has a type that is a specialization offunction, copyable_-
function, ormove_only_function. Each argument of the invocation ofx evaluated as part of the invocation
of t may alias an argument in the same position in the invocation oft that has the same type, even if the
corresponding parameter is not of reference type.
[Example 1:
move_only_function<void(T)> f{copyable_function<void(T)>{[](T) {}}};
T t;
f(t); // it is unspecified how many copies ofT are made
—end example]
3 Recommended practice: Implementations should avoid double wrapping when constructing polymorphic
wrappers from one another.
22.10.17.2 Class bad_function_call [func.wrap.badcall]
1 An exception of typebad_function_call is thrown byfunction::operator() (22.10.17.3.5) when the
function wrapper object has no target.
namespace std {
class bad_function_call : public exception {
public:
// see 17.9.3 for the specification of the special member functions
const char* what() const noexcept override;
};
}
const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
22.10.17.3 Class template function [func.wrap.func]
22.10.17.3.1 General [func.wrap.func.general]
namespace std {
template<class R, class... ArgTypes>
class function<R(ArgTypes...)> {
public:
using result_type = R;
// 22.10.17.3.2, construct/copy/destroy
function() noexcept;
function(nullptr_t) noexcept;
function(const function&);
function(function&&) noexcept;
template<class F> function(F&&);
function& operator=(const function&);
function& operator=(function&&);
function& operator=(nullptr_t) noexcept;
template<class F> function& operator=(F&&);
template<class F> function& operator=(reference_wrapper<F>) noexcept;
§ 22.10.17.3.1 © ISO/IEC
916

===== PAGE 928 =====

Dxxxx
~function();
// 22.10.17.3.3, function modifiers
void swap(function&) noexcept;
// 22.10.17.3.4, function capacity
explicit operator bool() const noexcept;
// 22.10.17.3.5, function invocation
R operator()(ArgTypes...) const;
// 22.10.17.3.6, function target access
const type_info& target_type() const noexcept;
template<class T> T* target() noexcept;
template<class T> const T* target() const noexcept;
};
template<class R, class... ArgTypes>
function(R(*)(ArgTypes...)) -> function<R(ArgTypes...)>;
template<class F> function(F) -> function<see below >;
}
1 The function class template provides polymorphic wrappers that generalize the notion of a function pointer.
Wrappers can store, copy, and call arbitrary callable objects (22.10.3), given a call signature (22.10.3).
2 The function class template is a call wrapper (22.10.3) whose call signature (22.10.3) isR(ArgTypes...).
3 [Note 1: The types deduced by the deduction guides forfunction might change in future revisions of C++. —end
note]
22.10.17.3.2 Constructors and destructor [func.wrap.func.con]
function() noexcept;
1 Postconditions: !*this.
function(nullptr_t) noexcept;
2 Postconditions: !*this.
function(const function& f);
3 Postconditions: !*this if !f; otherwise, the target object of*this is a copy of the target object off.
4 Throws: Nothing iff’s target is a specialization ofreference_wrapperor a function pointer. Otherwise,
may throwbad_alloc or any exception thrown by the copy constructor of the stored callable object.
5 Recommended practice: Implementations should avoid the use of dynamically allocated memory for
small callable objects, for example, wheref’s target is an object holding only a pointer or reference to
an object and a member function pointer.
function(function&& f) noexcept;
6 Postconditions: If !f, *this has no target; otherwise, the target of*this is equivalent to the target of
f before the construction, andf is in a valid state with an unspecified value.
7 Recommended practice: Implementations should avoid the use of dynamically allocated memory for
small callable objects, for example, wheref’s target is an object holding only a pointer or reference to
an object and a member function pointer.
template<class F> function(F&& f);
8 Let FD be decay_t<F>.
9 Constraints:
—(9.1) is_same_v<remove_cvref_t<F>, function> is false, and
—(9.2) is_invocable_r_v<R, FD&, ArgTypes...> is true.
§ 22.10.17.3.2 © ISO/IEC
917

===== PAGE 929 =====

Dxxxx
10 Mandates:
—(10.1) is_copy_constructible_v<FD> is true, and
—(10.2) is_constructible_v<FD, F> is true.
11 Preconditions: FD meets theCpp17CopyConstructible requirements.
12 Postconditions: !*this is true if any of the following hold:
—(12.1) f is a null function pointer value.
—(12.2) f is a null member pointer value.
—(12.3) remove_cvref_t<F> is a specialization of thefunction class template, and!f is true.
13 Otherwise, *this has a target object of typeFD direct-non-list-initialized withstd::forward<F>(f).
14 Throws: Nothing ifFD is a specialization ofreference_wrapper or a function pointer type. Otherwise,
may throwbad_alloc or any exception thrown by the initialization of the target object.
15 Recommended practice: Implementations should avoid the use of dynamically allocated memory for
small callable objects, for example, wheref refers to an object holding only a pointer or reference to an
object and a member function pointer.
template<class F> function(F) -> function<see below >;
16 Constraints: &F::operator() is well-formed when treated as an unevaluated operand and either
—(16.1) F::operator() is a non-static member function anddecltype(&F::operator()) is either of the
form R(G::*)(A...) cv &opt noexceptopt or of the formR(*)(G, A...) noexceptopt for a type
G, or
—(16.2) F::operator() is a static member function and decltype(&F::operator()) is of the form
R(*)(A...) noexceptopt.
17 Remarks: The deduced type isfunction<R(A...)>.
18 [Example 1:
void f() {
int i{5};
function g = [&](double) { return i; }; // deducesfunction<int(double)>
}
—end example]
function& operator=(const function& f);
19 Effects: As if byfunction(f).swap(*this);
20 Returns: *this.
function& operator=(function&& f);
21 Effects: Replaces the target of*this with the target off.
22 Returns: *this.
function& operator=(nullptr_t) noexcept;
23 Effects: If *this != nullptr, destroys the target ofthis.
24 Postconditions: !(*this).
25 Returns: *this.
template<class F> function& operator=(F&& f);
26 Constraints: is_invocable_r_v<R, decay_t<F>&, ArgTypes...> is true.
27 Effects: As if by:function(std::forward<F>(f)).swap(*this);
28 Returns: *this.
template<class F> function& operator=(reference_wrapper<F> f) noexcept;
29 Effects: As if by:function(f).swap(*this);
30 Returns: *this.
§ 22.10.17.3.2 © ISO/IEC
918

===== PAGE 930 =====

Dxxxx
~function();
31 Effects: If *this != nullptr, destroys the target ofthis.
22.10.17.3.3 Modifiers [func.wrap.func.mod]
void swap(function& other) noexcept;
1 Effects: Interchanges the target objects of*this and other.
22.10.17.3.4 Capacity [func.wrap.func.cap]
explicit operator bool() const noexcept;
1 Returns: true if *this has a target, otherwisefalse.
22.10.17.3.5 Invocation [func.wrap.func.inv]
R operator()(ArgTypes... args) const;
1 Returns: INVOKE<R>(f, std::forward<ArgTypes>(args)...) (22.10.4), wheref is the target object
(22.10.3) of*this.
2 Throws: bad_function_call if !*this; otherwise, any exception thrown by the target object.
22.10.17.3.6 Target access [func.wrap.func.targ]
const type_info& target_type() const noexcept;
1 Returns: If *this has a target of typeT, typeid(T); otherwise,typeid(void).
template<class T> T* target() noexcept;
template<class T> const T* target() const noexcept;
2 Returns: If target_type() == typeid(T) a pointer to the stored function target; otherwise a null
pointer.
22.10.17.3.7 Null pointer comparison operator functions [func.wrap.func.nullptr]
template<class R, class... ArgTypes>
bool operator==(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;
1 Returns: !f.
22.10.17.3.8 Specialized algorithms [func.wrap.func.alg]
template<class R, class... ArgTypes>
void swap(function<R(ArgTypes...)>& f1, function<R(ArgTypes...)>& f2) noexcept;
1 Effects: As if by:f1.swap(f2);
22.10.17.4 Move-only wrapper [func.wrap.move]
22.10.17.4.1 General [func.wrap.move.general]
1 The header provides partial specializations ofmove_only_function for each combination of the possible
replacements of the placeholderscv, ref, andnoex where
—(1.1) cv is either const or empty,
—(1.2) ref is either&, &&, or empty, and
—(1.3) noex is eithertrue or false.
2 For each of the possible combinations of the placeholders mentioned above, there is a placeholderinv-quals
defined as follows:
—(2.1) If ref is empty, letinv-quals be cv&,
—(2.2) otherwise, letinv-quals be cv ref.
§ 22.10.17.4.1 © ISO/IEC
919

===== PAGE 931 =====

Dxxxx
22.10.17.4.2 Class template move_only_function [func.wrap.move.class]
namespace std {
template<class R, class... ArgTypes>
class move_only_function<R(ArgTypes...) cv ref noexcept(noex )> {
public:
using result_type = R;
// 22.10.17.4.3, constructors, assignments, and destructor
move_only_function() noexcept;
move_only_function(nullptr_t) noexcept;
move_only_function(move_only_function&&) noexcept;
template<class F> move_only_function(F&&);
template<class T, class... Args>
explicit move_only_function(in_place_type_t<T>, Args&&...);
template<class T, class U, class... Args>
explicit move_only_function(in_place_type_t<T>, initializer_list<U>, Args&&...);
move_only_function& operator=(move_only_function&&);
move_only_function& operator=(nullptr_t) noexcept;
template<class F> move_only_function& operator=(F&&);
~move_only_function();
// 22.10.17.4.4, invocation
explicit operator bool() const noexcept;
R operator()(ArgTypes...) cv ref noexcept(noex );
// 22.10.17.4.5, utility
void swap(move_only_function&) noexcept;
friend void swap(move_only_function&, move_only_function&) noexcept;
friend bool operator==(const move_only_function&, nullptr_t) noexcept;
private:
template<class VT>
static constexpr bool is-callable-from = see below ; // exposition only
};
}
1 The move_only_function class template provides polymorphic wrappers that generalize the notion of a
callable object (22.10.3). These wrappers can store, move, and call arbitrary callable objects, given a call
signature.
2 Recommended practice: Implementations should avoid the use of dynamically allocated memory for a small
contained value.
[Note 1: Such small-object optimization can only be applied to a typeT for whichis_nothrow_move_constructible_-
v<T> is true. —end note]
22.10.17.4.3 Constructors, assignments, and destructor [func.wrap.move.ctor]
template<class VT>
static constexpr bool is-callable-from = see below ;
1 If noex is true, is-callable-from <VT> is equal to:
is_nothrow_invocable_r_v<R, VT cv ref , ArgTypes...> &&
is_nothrow_invocable_r_v<R, VT inv-quals , ArgTypes...>
Otherwise, is-callable-from <VT> is equal to:
is_invocable_r_v<R, VT cv ref , ArgTypes...> &&
is_invocable_r_v<R, VT inv-quals , ArgTypes...>
move_only_function() noexcept;
move_only_function(nullptr_t) noexcept;
2 Postconditions: *this has no target object.
§ 22.10.17.4.3 © ISO/IEC
920

===== PAGE 932 =====

Dxxxx
move_only_function(move_only_function&& f) noexcept;
3 Postconditions: The target object of*this is the target objectf had before construction, andf is in a
valid state with an unspecified value.
template<class F> move_only_function(F&& f);
4 Let VT be decay_t<F>.
5 Constraints:
—(5.1) remove_cvref_t<F> is not the same type asmove_only_function, and
—(5.2) remove_cvref_t<F> is not a specialization ofin_place_type_t, and
—(5.3) is-callable-from <VT> is true.
6 Mandates: is_constructible_v<VT, F> is true.
7 Preconditions: VT meets theCpp17Destructible requirements, and ifis_move_constructible_v<VT>
is true, VT meets theCpp17MoveConstructible requirements.
8 Postconditions: *this has no target object if any of the following hold:
—(8.1) f is a null function pointer value,
—(8.2) f is a null member pointer value, or
—(8.3) remove_cvref_t<F> is a specialization of themove_only_function or copyable_function class
template, andf has no target object.
Otherwise, *this has a target object of typeVT direct-non-list-initialized withstd::forward<F>(f).
9 Throws: Any exception thrown by the initialization of the target object. May throwbad_alloc unless
VT is a function pointer or a specialization ofreference_wrapper.
template<class T, class... Args>
explicit move_only_function(in_place_type_t<T>, Args&&... args);
10 Let VT be decay_t<T>.
11 Constraints:
—(11.1) is_constructible_v<VT, Args...> is true, and
—(11.2) is-callable-from <VT> is true.
12 Mandates: VT is the same type asT.
13 Preconditions: VT meets theCpp17Destructible requirements, and ifis_move_constructible_v<VT>
is true, VT meets theCpp17MoveConstructible requirements.
14 Postconditions: *thishasatargetobjectoftype VTdirect-non-list-initializedwith std::forward<Args>
(args)....
15 Throws: Any exception thrown by the initialization of the target object. May throwbad_alloc unless
VT is a function pointer or a specialization ofreference_wrapper.
template<class T, class U, class... Args>
explicit move_only_function(in_place_type_t<T>, initializer_list<U> ilist, Args&&... args);
16 Let VT be decay_t<T>.
17 Constraints:
—(17.1) is_constructible_v<VT, initializer_list<U>&, Args...> is true, and
—(17.2) is-callable-from <VT> is true.
18 Mandates: VT is the same type asT.
19 Preconditions: VT meets theCpp17Destructible requirements, and ifis_move_constructible_v<VT>
is true, VT meets theCpp17MoveConstructible requirements.
20 Postconditions: *this has a target object of typeVT direct-non-list-initialized withilist, std::for-
ward<Args>(args)....
21 Throws: Any exception thrown by the initialization of the target object. May throwbad_alloc unless
VT is a function pointer or a specialization ofreference_wrapper.
§ 22.10.17.4.3 © ISO/IEC
921

===== PAGE 933 =====

Dxxxx
move_only_function& operator=(move_only_function&& f);
22 Effects: Equivalent to:move_only_function(std::move(f)).swap(*this);
23 Returns: *this.
move_only_function& operator=(nullptr_t) noexcept;
24 Effects: Destroys the target object of*this, if any.
25 Returns: *this.
template<class F> move_only_function& operator=(F&& f);
26 Effects: Equivalent to:move_only_function(std::forward<F>(f)).swap(*this);
27 Returns: *this.
~move_only_function();
28 Effects: Destroys the target object of*this, if any.
22.10.17.4.4 Invocation [func.wrap.move.inv]
explicit operator bool() const noexcept;
1 Returns: true if *this has a target object, otherwisefalse.
R operator()(ArgTypes... args) cv ref noexcept(noex );
2 Preconditions: *this has a target object.
3 Effects: Equivalent to:
return INVOKE <R>(static_cast<F inv-quals >(f), std::forward<ArgTypes>(args)...);
where f is an lvalue designating the target object of*this and F is the type off.
22.10.17.4.5 Utility [func.wrap.move.util]
void swap(move_only_function& other) noexcept;
1 Effects: Exchanges the target objects of*this and other.
friend void swap(move_only_function& f1, move_only_function& f2) noexcept;
2 Effects: Equivalent tof1.swap(f2).
friend bool operator==(const move_only_function& f, nullptr_t) noexcept;
3 Returns: true if f has no target object, otherwisefalse.
22.10.17.5 Copyable wrapper [func.wrap.copy]
22.10.17.5.1 General [func.wrap.copy.general]
1 The header provides partial specializations ofcopyable_function for each combination of the possible
replacements of the placeholderscv, ref, andnoex where
—(1.1) cv is either const or empty,
—(1.2) ref is either&, &&, or empty, and
—(1.3) noex is eithertrue or false.
2 For each of the possible combinations of the placeholders mentioned above, there is a placeholderinv-quals
defined as follows:
—(2.1) If ref is empty, letinv-quals be cv&,
—(2.2) otherwise, letinv-quals be cv ref.
22.10.17.5.2 Class template copyable_function [func.wrap.copy.class]
namespace std {
template<class R, class... ArgTypes>
class copyable_function<R(ArgTypes...) cv ref noexcept(noex )> {
public:
using result_type = R;
§ 22.10.17.5.2 © ISO/IEC
922

===== PAGE 934 =====

Dxxxx
// 22.10.17.5.3, constructors, assignments, and destructor
copyable_function() noexcept;
copyable_function(nullptr_t) noexcept;
copyable_function(const copyable_function&);
copyable_function(copyable_function&&) noexcept;
template<class F> copyable_function(F&&);
template<class T, class... Args>
explicit copyable_function(in_place_type_t<T>, Args&&...);
template<class T, class U, class... Args>
explicit copyable_function(in_place_type_t<T>, initializer_list<U>, Args&&...);
copyable_function& operator=(const copyable_function&);
copyable_function& operator=(copyable_function&&);
copyable_function& operator=(nullptr_t) noexcept;
template<class F> copyable_function& operator=(F&&);
~copyable_function();
// 22.10.17.5.4, invocation
explicit operator bool() const noexcept;
R operator()(ArgTypes...) cv ref noexcept(noex );
// 22.10.17.5.5, utility
void swap(copyable_function&) noexcept;
friend void swap(copyable_function&, copyable_function&) noexcept;
friend bool operator==(const copyable_function&, nullptr_t) noexcept;
private:
template<class VT>
static constexpr bool is-callable-from = see below ; // exposition only
};
}
1 The copyable_function class template provides polymorphic wrappers that generalize the notion of a
callable object (22.10.3). These wrappers can store, copy, move, and call arbitrary callable objects, given a
call signature.
2 Recommended practice: Implementations should avoid the use of dynamically allocated memory for a small
contained value.
[Note 1: Such small-object optimization can only be applied to a typeT for whichis_nothrow_move_constructible_-
v<T> is true. —end note]
22.10.17.5.3 Constructors, assignments, and destructor [func.wrap.copy.ctor]
template<class VT>
static constexpr bool is-callable-from = see below ;
1 If noex is true, is-callable-from <VT> is equal to:
is_nothrow_invocable_r_v<R, VT cv ref , ArgTypes...> &&
is_nothrow_invocable_r_v<R, VT inv-quals , ArgTypes...>
Otherwise, is-callable-from <VT> is equal to:
is_invocable_r_v<R, VT cv ref , ArgTypes...> &&
is_invocable_r_v<R, VT inv-quals , ArgTypes...>
copyable_function() noexcept;
copyable_function(nullptr_t) noexcept;
2 Postconditions: *this has no target object.
copyable_function(const copyable_function& f);
3 Postconditions: *this has no target object iff had no target object. Otherwise, the target object of
*this is a copy of the target object off.
4 Throws: Any exception thrown by the initialization of the target object. May throwbad_alloc.
§ 22.10.17.5.3 © ISO/IEC
923

===== PAGE 935 =====

Dxxxx
copyable_function(copyable_function&& f) noexcept;
5 Postconditions: The target object of*this is the target objectf had before construction, andf is in a
valid state with an unspecified value.
template<class F> copyable_function(F&& f);
6 Let VT be decay_t<F>.
7 Constraints:
—(7.1) remove_cvref_t<F> is not the same type ascopyable_function, and
—(7.2) remove_cvref_t<F> is not a specialization ofin_place_type_t, and
—(7.3) is-callable-from <VT> is true.
8 Mandates:
—(8.1) is_constructible_v<VT, F> is true, and
—(8.2) is_copy_constructible_v<VT> is true.
9 Preconditions: VT meets theCpp17Destructible and Cpp17CopyConstructible requirements.
10 Postconditions: *this has no target object if any of the following hold:
—(10.1) f is a null function pointer value, or
—(10.2) f is a null member pointer value, or
—(10.3) remove_cvref_t<F> is a specialization of thecopyable_function class template, andf has no
target object.
Otherwise, *this has a target object of typeVT direct-non-list-initialized withstd::forward<F>(f).
11 Throws: Any exception thrown by the initialization of the target object. May throwbad_alloc unless
VT is a function pointer or a specialization ofreference_wrapper.
template<class T, class... Args>
explicit copyable_function(in_place_type_t<T>, Args&&... args);
12 Let VT be decay_t<T>.
13 Constraints:
—(13.1) is_constructible_v<VT, Args...> is true, and
—(13.2) is-callable-from <VT> is true.
14 Mandates:
—(14.1) VT is the same type asT, and
—(14.2) is_copy_constructible_v<VT> is true.
15 Preconditions: VT meets theCpp17Destructible and Cpp17CopyConstructible requirements.
16 Postconditions: *thishasatargetobjectoftype VTdirect-non-list-initializedwith std::forward<Args>
(args)....
17 Throws: Any exception thrown by the initialization of the target object. May throwbad_alloc unless
VT is a pointer or a specialization ofreference_wrapper.
template<class T, class U, class... Args>
explicit copyable_function(in_place_type_t<T>, initializer_list<U> ilist, Args&&... args);
18 Let VT be decay_t<T>.
19 Constraints:
—(19.1) is_constructible_v<VT, initializer_list<U>&, Args...> is true, and
—(19.2) is-callable-from <VT> is true.
20 Mandates:
—(20.1) VT is the same type asT, and
—(20.2) is_copy_constructible_v<VT> is true.
§ 22.10.17.5.3 © ISO/IEC
924

===== PAGE 936 =====

Dxxxx
21 Preconditions: VT meets theCpp17Destructible and Cpp17CopyConstructible requirements.
22 Postconditions: *this has a target object of typeVT direct-non-list-initialized withilist, std::for-
ward<Args>(args)....
23 Throws: Any exception thrown by the initialization of the target object. May throwbad_alloc unless
VT is a pointer or a specialization ofreference_wrapper.
copyable_function& operator=(const copyable_function& f);
24 Effects: Equivalent to:copyable_function(f).swap(*this);
25 Returns: *this.
copyable_function& operator=(copyable_function&& f);
26 Effects: Equivalent to:copyable_function(std::move(f)).swap(*this);
27 Returns: *this.
copyable_function& operator=(nullptr_t) noexcept;
28 Effects: Destroys the target object of*this, if any.
29 Returns: *this.
template<class F> copyable_function& operator=(F&& f);
30 Effects: Equivalent to:copyable_function(std::forward<F>(f)).swap(*this);
31 Returns: *this.
~copyable_function();
32 Effects: Destroys the target object of*this, if any.
22.10.17.5.4 Invocation [func.wrap.copy.inv]
explicit operator bool() const noexcept;
1 Returns: true if *this has a target object, otherwisefalse.
R operator()(ArgTypes... args) cv ref noexcept(noex );
2 Preconditions: *this has a target object.
3 Effects: Equivalent to:
return INVOKE <R>(static_cast<F inv-quals >(f), std::forward<ArgTypes>(args)...);
where f is an lvalue designating the target object of*this and F is the type off.
22.10.17.5.5 Utility [func.wrap.copy.util]
void swap(copyable_function& other) noexcept;
1 Effects: Exchanges the target objects of*this and other.
friend void swap(copyable_function& f1, copyable_function& f2) noexcept;
2 Effects: Equivalent tof1.swap(f2).
friend bool operator==(const copyable_function& f, nullptr_t) noexcept;
3 Returns: true if f has no target object, otherwisefalse.
22.10.17.6 Non-owning wrapper [func.wrap.ref]
22.10.17.6.1 General [func.wrap.ref.general]
1 The header provides partial specializations offunction_reffor each combination of the possible replacements
of the placeholderscv and noex where:
—(1.1) cv is either const or empty, and
—(1.2) noex is eithertrue or false.
§ 22.10.17.6.1 © ISO/IEC
925

===== PAGE 937 =====

Dxxxx
22.10.17.6.2 Class template function_ref [func.wrap.ref.class]
namespace std {
template<class R, class... ArgTypes>
class function_ref<R(ArgTypes...) cv noexcept(noex )> {
public:
// 22.10.17.6.3, constructors and assignment operators
template<class F> function_ref(F*) noexcept;
template<class F> constexpr function_ref(F&&) noexcept;
template<auto f> constexpr function_ref(constant_arg_t<f>) noexcept;
template<auto f, class U> constexpr function_ref(constant_arg_t<f>, U&&) noexcept;
template<auto f, class T> constexpr function_ref(constant_arg_t<f>, cv T*) noexcept;
constexpr function_ref(const function_ref&) noexcept = default;
constexpr function_ref& operator=(const function_ref&) noexcept = default;
template<class T> function_ref& operator=(T) = delete;
// 22.10.17.6.4, invocation
R operator()(ArgTypes...) const noexcept(noex );
private:
template<class... T>
static constexpr bool is-invocable-using = see below; // exposition only
R (*thunk-ptr)(BoundEntityType, ArgTypes&&...) noexcept(noex); // exposition only
BoundEntityType bound-entity; // exposition only
};
// 22.10.17.6.5, deduction guides
template<class F>
function_ref(F*) -> function_ref<F>;
template<auto f>
function_ref(constant_arg_t<f>) -> function_ref<see below >;
template<auto f, class T>
function_ref(constant_arg_t<f>, T&&) -> function_ref<see below >;
}
1 An object of classfunction_ref<R(Args...) cv noexcept(noex )> stores a pointer to functionthunk-ptr
and an object bound-entity . The object bound-entity has an unspecified trivially copyable type
BoundEntityType , that modelscopyable and is capable of storing a pointer to object value or a pointer to
function value. The type ofthunk-ptr is R(*)(BoundEntityType, Args&&...) noexcept(noex ).
2 Each specialization offunction_ref is a trivially copyable type (6.9.1) that modelscopyable.
3 Within subclause 22.10.17.6,call-args is an argument pack with elements such that
decltype((call-args ))...
denote ArgTypes&&... respectively.
22.10.17.6.3 Constructors and assignment operators [func.wrap.ref.ctor]
template<class... T>
static constexpr bool is-invocable-using = see below ;
1 If noex is true, is-invocable-using <T...> is equal to:
is_nothrow_invocable_r_v<R, T..., ArgTypes...>
Otherwise, is-invocable-using <T...> is equal to:
is_invocable_r_v<R, T..., ArgTypes...>
template<class F> function_ref(F* f) noexcept;
2 Constraints:
—(2.1) is_function_v<F> is true, and
—(2.2) is-invocable-using <F> is true.
§ 22.10.17.6.3 © ISO/IEC
926

===== PAGE 938 =====

Dxxxx
3 Preconditions: f is not a null pointer.
4 Effects: Initializes bound-entity with f, and thunk-ptr with the address of a function thunk
such thatthunk (bound-entity , call-args...) is expression-equivalent (3.22) toinvoke_r<R>(f,
call-args...).
template<class F> constexpr function_ref(F&& f) noexcept;
5 Let T be remove_reference_t<F>.
6 Constraints:
—(6.1) remove_cvref_t<F> is not the same type asfunction_ref,
—(6.2) is_member_pointer_v<T> is false, and
—(6.3) is-invocable-using <cv T&> is true.
7 Effects: Initializes bound-entity with addressof(f), andthunk-ptr with the address of a function
thunk such thatthunk (bound-entity , call-args...) is expression-equivalent (3.22) toinvoke_-
r<R>(static_cast<cv T&>(f), call-args...).
template<auto f> constexpr function_ref(constant_arg_t<f>) noexcept;
8 Let F be decltype(f).
9 Constraints: is-invocable-using <const F&> is true.
10 Mandates: If is_pointer_v<F> || is_member_pointer_v<F> is true, thenf != nullptr is true.
11 Effects: Initializes bound-entity with a pointer to an unspecified object or null pointer value, and
thunk-ptr with the address of a functionthunk such thatthunk (bound-entity , call-args...)
is expression-equivalent (3.22) toinvoke_r<R>(f, call-args...).
template<auto f, class U>
constexpr function_ref(constant_arg_t<f>, U&& obj) noexcept;
12 Let T be remove_reference_t<U> and F be decltype(f).
13 Constraints:
—(13.1) is_rvalue_reference_v<U&&> is false, and
—(13.2) is-invocable-using <const F&, cv T&> is true.
14 Mandates: If is_pointer_v<F> || is_member_pointer_v<F> is true, thenf != nullptr is true.
15 Effects: Initializesbound-entity with addressof(obj), andthunk-ptr with the address of a function
thunk such thatthunk (bound-entity , call-args...) is expression-equivalent (3.22) toinvoke_-
r<R>(f, static_cast<cv T&>(obj), call-args...).
template<auto f, class T>
constexpr function_ref(constant_arg_t<f>, cv T* obj) noexcept;
16 Let F be decltype(f).
17 Constraints: is-invocable-using <const F&, cv T*> is true.
18 Mandates: If is_pointer_v<F> || is_member_pointer_v<F> is true, thenf != nullptr is true.
19 Preconditions: If is_member_pointer_v<F> is true, obj is not a null pointer.
20 Effects: Initializes bound-entity with obj, andthunk-ptr with the address of a functionthunk such
that thunk (bound-entity , call-args...) is expression-equivalent (3.22) toinvoke_r<R>(f, obj,
call-args...).
template<class T> function_ref& operator=(T) = delete;
21 Constraints:
—(21.1) T is not the same type asfunction_ref,
—(21.2) is_pointer_v<T> is false, and
—(21.3) T is not a specialization ofconstant_arg_t.
§ 22.10.17.6.3 © ISO/IEC
927

===== PAGE 939 =====

Dxxxx
22.10.17.6.4 Invocation [func.wrap.ref.inv]
R operator()(ArgTypes... args) const noexcept(noex );
1 Effects: Equivalent to:return thunk-ptr (bound-entity , std::forward<ArgTypes>(args)...);
22.10.17.6.5 Deduction guides [func.wrap.ref.deduct]
template<class F>
function_ref(F*) -> function_ref<F>;
1 Constraints: is_function_v<F> is true.
template<auto f>
function_ref(constant_arg_t<f>) -> function_ref<see below >;
2 Let F be remove_pointer_t<decltype(f)>.
3 Constraints: is_function_v<F> is true.
4 Remarks: The deduced type isfunction_ref<F>.
template<auto f, class T>
function_ref(constant_arg_t<f>, T&&) -> function_ref<see below >;
5 Let F be decltype(f).
6 Constraints:
—(6.1) F is of the formR(G::*)(A...) cv &opt noexcept(E) for a typeG, or
—(6.2) Fisoftheform M G::*foratype Gandanobjecttype M, inwhichcaselet Rbe invoke_result_t<F,
T&>, A... be an empty pack, andE be true, or
—(6.3) F is of the formR(*)(G, A...) noexcept(E) for a typeG.
7 Remarks: The deduced type isfunction_ref<R(A...) noexcept(E)>.
22.10.18 Searchers [func.search]
22.10.18.1 General [func.search.general]
1 Subclause 22.10.18 provides function object types (22.10) for operations that search for a sequence[pat_first,
pat_last) in another sequence[first,last) that is provided to the object’s function call operator. The
first sequence (the pattern to be searched for) is provided to the object’s constructor, and the second (the
sequence to be searched) is provided to the function call operator.
2 Each specialization of a class template specified in 22.10.18 shall meet theCpp17CopyConstructible and
Cpp17CopyAssignable requirements. Template parameters named
—(2.1) ForwardIterator,
—(2.2) ForwardIterator1,
—(2.3) ForwardIterator2,
—(2.4) RandomAccessIterator,
—(2.5) RandomAccessIterator1,
—(2.6) RandomAccessIterator2, and
—(2.7) BinaryPredicate
of templates specified in 22.10.18 shall meet the same requirements and semantics as specified in 26.1.
Template parameters namedHash shall meet theCpp17Hash requirements (Table 37).
3 The Boyer-Moore searcher implements the Boyer-Moore search algorithm. The Boyer-Moore-Horspool
searcher implements the Boyer-Moore-Horspool search algorithm. In general, the Boyer-Moore searcher will
use more memory and give better runtime performance than Boyer-Moore-Horspool.
22.10.18.2 Class template default_searcher [func.search.default]
namespace std {
template<class ForwardIterator1, class BinaryPredicate = equal_to<>>
class default_searcher {
public:
§ 22.10.18.2 © ISO/IEC
928

===== PAGE 940 =====

Dxxxx
constexpr default_searcher(ForwardIterator1 pat_first, ForwardIterator1 pat_last,
BinaryPredicate pred = BinaryPredicate());
template<class ForwardIterator2>
constexpr pair<ForwardIterator2, ForwardIterator2>
operator()(ForwardIterator2 first, ForwardIterator2 last) const;
private:
ForwardIterator1 pat_first_; // exposition only
ForwardIterator1 pat_last_; // exposition only
BinaryPredicate pred_; // exposition only
};
}
constexpr default_searcher(ForwardIterator1 pat_first, ForwardIterator1 pat_last,
BinaryPredicate pred = BinaryPredicate());
1 Effects: Constructs adefault_searcher object, initializingpat_first_ with pat_first, pat_last_
with pat_last, andpred_ with pred.
2 Throws: Any exception thrown by the copy constructor ofBinaryPredicate or ForwardIterator1.
template<class ForwardIterator2>
constexpr pair<ForwardIterator2, ForwardIterator2>
operator()(ForwardIterator2 first, ForwardIterator2 last) const;
3 Effects: Returns a pair of iteratorsi and j such that
—(3.1) i == search(first, last, pat_first_, pat_last_, pred_), and
—(3.2) if i == last, thenj == last, otherwisej == next(i, distance(pat_first_, pat_last_)).
22.10.18.3 Class template boyer_moore_searcher [func.search.bm]
namespace std {
template<class RandomAccessIterator1,
class Hash = hash<typename iterator_traits<RandomAccessIterator1>::value_type>,
class BinaryPredicate = equal_to<>>
class boyer_moore_searcher {
public:
boyer_moore_searcher(RandomAccessIterator1 pat_first,
RandomAccessIterator1 pat_last,
Hash hf = Hash(),
BinaryPredicate pred = BinaryPredicate());
template<class RandomAccessIterator2>
pair<RandomAccessIterator2, RandomAccessIterator2>
operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
private:
RandomAccessIterator1 pat_first_; // exposition only
RandomAccessIterator1 pat_last_; // exposition only
Hash hash_; // exposition only
BinaryPredicate pred_; // exposition only
};
}
boyer_moore_searcher(RandomAccessIterator1 pat_first,
RandomAccessIterator1 pat_last,
Hash hf = Hash(),
BinaryPredicate pred = BinaryPredicate());
1 Preconditions: The value type of RandomAccessIterator1 meets the Cpp17DefaultConstructible,
Cpp17CopyConstructible, andCpp17CopyAssignable requirements.
2 Let V be iterator_traits<RandomAccessIterator1>::value_type. For any two valuesA and B of
type V, ifpred(A, B) == true, thenhf(A) == hf(B) is true.
§ 22.10.18.3 © ISO/IEC
929

===== PAGE 941 =====

Dxxxx
3 Effects: Initializespat_first_ with pat_first, pat_last_ with pat_last, hash_ with hf, andpred_
with pred.
4 Throws: Any exception thrown by the copy constructor ofRandomAccessIterator1, or by the default
constructor, copy constructor, or the copy assignment operator of the value type ofRandomAccess-
Iterator1, orthecopyconstructoror operator()of BinaryPredicateorHash. Maythrow bad_alloc
if additional memory needed for internal data structures cannot be allocated.
template<class RandomAccessIterator2>
pair<RandomAccessIterator2, RandomAccessIterator2>
operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
5 Mandates: RandomAccessIterator1 and RandomAccessIterator2 have the same value type.
6 Effects: Finds a subsequence of equal values in a sequence.
7 Returns: A pair of iteratorsi and j such that
—(7.1) i is the first iterator in the range[first,last - (pat_last_ - pat_first_)) such that for
every non-negative integern less thanpat_last_ - pat_first_ the following condition holds:
pred(*(i + n), *(pat_first_ + n)) != false, and
—(7.2) j == next(i, distance(pat_first_, pat_last_)).
Returns make_pair(first, first) if [pat_first_,pat_last_) is empty, otherwise returnsmake_-
pair(last, last) if no such iterator is found.
8 Complexity: At most(last - first) * (pat_last_ - pat_first_) applications of the predicate.
22.10.18.4 Class template boyer_moore_horspool_searcher [func.search.bmh]
namespace std {
template<class RandomAccessIterator1,
class Hash = hash<typename iterator_traits<RandomAccessIterator1>::value_type>,
class BinaryPredicate = equal_to<>>
class boyer_moore_horspool_searcher {
public:
boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
RandomAccessIterator1 pat_last,
Hash hf = Hash(),
BinaryPredicate pred = BinaryPredicate());
template<class RandomAccessIterator2>
pair<RandomAccessIterator2, RandomAccessIterator2>
operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
private:
RandomAccessIterator1 pat_first_; // exposition only
RandomAccessIterator1 pat_last_; // exposition only
Hash hash_; // exposition only
BinaryPredicate pred_; // exposition only
};
}
boyer_moore_horspool_searcher(RandomAccessIterator1 pat_first,
RandomAccessIterator1 pat_last,
Hash hf = Hash(),
BinaryPredicate pred = BinaryPredicate());
1 Preconditions: The value type of RandomAccessIterator1 meets the Cpp17DefaultConstructible,
Cpp17CopyConstructible, andCpp17CopyAssignable requirements.
2 Let V be iterator_traits<RandomAccessIterator1>::value_type. For any two valuesA and B of
type V, ifpred(A, B) == true, thenhf(A) == hf(B) is true.
3 Effects: Initializespat_first_ with pat_first, pat_last_ with pat_last, hash_ with hf, andpred_
with pred.
4 Throws: Any exception thrown by the copy constructor ofRandomAccessIterator1, or by the default
constructor, copy constructor, or the copy assignment operator of the value type ofRandomAccess-
§ 22.10.18.4 © ISO/IEC
930

===== PAGE 942 =====

Dxxxx
Iterator1, orthecopyconstructoror operator()of BinaryPredicateorHash. Maythrow bad_alloc
if additional memory needed for internal data structures cannot be allocated.
template<class RandomAccessIterator2>
pair<RandomAccessIterator2, RandomAccessIterator2>
operator()(RandomAccessIterator2 first, RandomAccessIterator2 last) const;
5 Mandates: RandomAccessIterator1 and RandomAccessIterator2 have the same value type.
6 Effects: Finds a subsequence of equal values in a sequence.
7 Returns: A pair of iteratorsi and j such that
—(7.1) i is the first iterator in the range[first,last - (pat_last_ - pat_first_)) such that for
every non-negative integern less thanpat_last_ - pat_first_ the following condition holds:
pred(*(i + n), *(pat_first_ + n)) != false, and
—(7.2) j == next(i, distance(pat_first_, pat_last_)).
Returns make_pair(first, first) if [pat_first_,pat_last_) is empty, otherwise returnsmake_-
pair(last, last) if no such iterator is found.
8 Complexity: At most(last - first) * (pat_last_ - pat_first_) applications of the predicate.
22.10.19 Class template hash [unord.hash]
1 The unordered associative containers defined in 23.5 use specializations of the class templatehash (22.10.2)
as the default hash function.
2 Each specialization ofhash is either enabled or disabled, as described below.
[Note 1: Enabled specializations meet theCpp17Hash requirements, and disabled specializations do not.—end note]
Each header that declares the templatehash provides enabled specializations ofhash for nullptr_t and all
cv-unqualified arithmetic, enumeration, and pointer types. For any typeKey for which neither the library
nor the user provides an explicit or partial specialization of the class templatehash, hash<Key> is disabled.
3 If the library provides an explicit or partial specialization ofhash<Key>, that specialization is enabled except
as noted otherwise, and its member functions arenoexcept except as noted otherwise.
4 If H is a disabled specialization ofhash, these values arefalse: is_default_constructible_v<H>, is_-
copy_constructible_v<H>, is_move_constructible_v<H>, is_copy_assignable_v<H>, and is_move_-
assignable_v<H>. Disabled specializations ofhash are not function object types (22.10).
[Note 2: This means that the specialization ofhash exists, but any attempts to use it as aCpp17Hash will be
ill-formed. —end note]
5 An enabled specializationhash<Key> will:
—(5.1) meet the Cpp17Hash requirements (Table 37), withKey as the function call argument type, the
Cpp17DefaultConstructible requirements (Table 30), theCpp17CopyAssignable requirements (Table 34),
the Cpp17Swappable requirements (16.4.4.3),
—(5.2) meet the requirement that ifk1 == k2 is true, h(k1) == h(k2) is alsotrue, whereh is an object of
type hash<Key> and k1 and k2 are objects of typeKey;
—(5.3) meet the requirement that the expressionh(k), whereh is an object of typehash<Key> and k is an
object of typeKey, shall not throw an exception unlesshash<Key> is a program-defined specialization.
22.11 Bit manipulation [bit]
22.11.1 General [bit.general]
1 The header <bit> provides components to access, manipulate and process both individual bits and bit
sequences.
22.11.2 Header <bit> synopsis [bit.syn]
// all freestanding
namespace std {
// 22.11.3,bit_cast
template<class To, class From>
constexpr To bit_cast(const From& from) noexcept;
§ 22.11.2 © ISO/IEC
931

===== PAGE 943 =====

Dxxxx
// 22.11.4,byteswap
template<class T>
constexpr T byteswap(T value) noexcept;
// 22.11.5, integral powers of 2
template<class T>
constexpr bool has_single_bit(T x) noexcept;
template<class T>
constexpr T bit_ceil(T x);
template<class T>
constexpr T bit_floor(T x) noexcept;
template<class T>
constexpr int bit_width(T x) noexcept;
// 22.11.6, rotating
template<class T>
constexpr T rotl(T x, int s) noexcept;
template<class T>
constexpr T rotr(T x, int s) noexcept;
// 22.11.7, counting
template<class T>
constexpr int countl_zero(T x) noexcept;
template<class T>
constexpr int countl_one(T x) noexcept;
template<class T>
constexpr int countr_zero(T x) noexcept;
template<class T>
constexpr int countr_one(T x) noexcept;
template<class T>
constexpr int popcount(T x) noexcept;
// 22.11.8, endian
enum class endian {
little = see below ,
big = see below ,
native = see below
};
}
22.11.3 Function template bit_cast [bit.cast]
template<class To, class From>
constexpr To bit_cast(const From& from) noexcept;
1 Constraints:
—(1.1) sizeof(To) == sizeof(From) is true;
—(1.2) is_trivially_copyable_v<To> is true; and
—(1.3) is_trivially_copyable_v<From> is true.
2 Mandates: Neither To nor From are consteval-only types (6.9.1).
3 Constant When: To, From, and the types of all subobjects ofTo and From are typesT such that:
—(3.1) is_union_v<T> is false;
—(3.2) is_pointer_v<T> is false;
—(3.3) is_member_pointer_v<T> is false;
—(3.4) is_volatile_v<T> is false; and
—(3.5) T has no non-static data members of reference type.
4 Returns: An object of typeTo. Implicitly creates objects nested within the result (6.8.2). Each bit
of the value representation of the result is equal to the corresponding bit in the object representation
of from. Padding bits of the result are unspecified. For the result and each object created within
§ 22.11.3 © ISO/IEC
932

===== PAGE 944 =====

Dxxxx
it, if there is no value of the object’s type corresponding to the value representation produced, the
behavior is undefined. If there are multiple such values, which value is produced is unspecified. A bit
in the value representation of the result is indeterminate if it does not correspond to a bit in the value
representation offrom or corresponds to a bit for which the smallest enclosing object is not within
its lifetime or has an indeterminate value (6.8.5). A bit in the value representation of the result is
erroneous if it corresponds to a bit for which the smallest enclosing object has an erroneous value. For
each bitb in the value representation of the result that is indeterminate or erroneous, letu be the
smallest object containing that bit enclosingb:
—(4.1) If u is of unsigned ordinary character type orstd::byte type, u has an indeterminate value if
any of the bits in its value representation are indeterminate, or otherwise has an erroneous value.
—(4.2) Otherwise, ifb is indeterminate, the behavior is undefined.
—(4.3) Otherwise, the behavior is erroneous, and the result is as specified above.
The result does not otherwise contain any indeterminate or erroneous values.
22.11.4 byteswap [bit.byteswap]
template<class T>
constexpr T byteswap(T value) noexcept;
1 Constraints: T models integral.
2 Mandates: T does not have padding bits (6.9.1).
3 Let the sequenceR comprise the bytes of the object representation ofvalue in reverse order.
4 Returns: An objectv of typeT such that each byte in the object representation ofv is equal to the
byte in the corresponding position inR.
22.11.5 Integral powers of 2 [bit.pow.two]
template<class T>
constexpr bool has_single_bit(T x) noexcept;
1 Constraints: T is an unsigned integer type (6.9.2).
2 Returns: true if x is an integral power of two;false otherwise.
template<class T>
constexpr T bit_ceil(T x);
3 Let N be the smallest power of 2 greater than or equal tox.
4 Constraints: T is an unsigned integer type (6.9.2).
5 Preconditions: N is representable as a value of typeT.
6 Returns: N.
7 Throws: Nothing.
8 Remarks: A function call expression that violates the precondition in thePreconditions: element is not
a core constant expression (7.7).
template<class T>
constexpr T bit_floor(T x) noexcept;
9 Constraints: T is an unsigned integer type (6.9.2).
10 Returns: If x == 0, 0; otherwise the maximal valuey such thathas_single_bit(y) is true and y <=
x.
template<class T>
constexpr int bit_width(T x) noexcept;
11 Constraints: T is an unsigned integer type (6.9.2).
12 Returns: If x == 0, 0; otherwise one plus the base-2 logarithm ofx, with any fractional part discarded.
§ 22.11.5 © ISO/IEC
933

===== PAGE 945 =====

Dxxxx
22.11.6 Rotating [bit.rotate]
1 In the following descriptions, letN denote numeric_limits<T>::digits.
template<class T>
constexpr T rotl(T x, int s) noexcept;
2 Constraints: T is an unsigned integer type (6.9.2).
3 Let r be s % N.
4 Returns: If r is 0, x; ifr is positive,(x << r) | (x >> (N - r)); ifr is negative,rotr(x, -r).
template<class T>
constexpr T rotr(T x, int s) noexcept;
5 Constraints: T is an unsigned integer type (6.9.2).
6 Let r be s % N.
7 Returns: If r is 0, x; ifr is positive,(x >> r) | (x << (N - r)); ifr is negative,rotl(x, -r).
22.11.7 Counting [bit.count]
1 In the following descriptions, letN denote numeric_limits<T>::digits.
template<class T>
constexpr int countl_zero(T x) noexcept;
2 Constraints: T is an unsigned integer type (6.9.2).
3 Returns: The number of consecutive0 bits in the value ofx, starting from the most significant bit.
[Note 1: Returns N if x == 0. —end note]
template<class T>
constexpr int countl_one(T x) noexcept;
4 Constraints: T is an unsigned integer type (6.9.2).
5 Returns: The number of consecutive1 bits in the value ofx, starting from the most significant bit.
[Note 2: Returns N if x == numeric_limits<T>::max(). —end note]
template<class T>
constexpr int countr_zero(T x) noexcept;
6 Constraints: T is an unsigned integer type (6.9.2).
7 Returns: The number of consecutive0 bits in the value ofx, starting from the least significant bit.
[Note 3: Returns N if x == 0. —end note]
template<class T>
constexpr int countr_one(T x) noexcept;
8 Constraints: T is an unsigned integer type (6.9.2).
9 Returns: The number of consecutive1 bits in the value ofx, starting from the least significant bit.
[Note 4: Returns N if x == numeric_limits<T>::max(). —end note]
template<class T>
constexpr int popcount(T x) noexcept;
10 Constraints: T is an unsigned integer type (6.9.2).
11 Returns: The number of1 bits in the value ofx.
22.11.8 Endian [bit.endian]
1 Two common methods of byte ordering in multibyte scalar types are big-endian and little-endian in the
execution environment. Big-endian is a format for storage of binary data in which the most significant byte
is placed first, with the rest in descending order. Little-endian is a format for storage of binary data in
which the least significant byte is placed first, with the rest in ascending order. This subclause describes the
endianness of the scalar types of the execution environment.
§ 22.11.8 © ISO/IEC
934

===== PAGE 946 =====

Dxxxx
enum class endian {
little = see below ,
big = see below ,
native = see below
};
2 If all scalar types have size 1 byte, then all ofendian::little, endian::big, andendian::native
have the same value. Otherwise,endian::littleis not equal toendian::big. If all scalar types are big-
endian, endian::native is equal toendian::big. If all scalar types are little-endian,endian::native
is equal to endian::little. Otherwise, endian::native is not equal to either endian::big or
endian::little.
22.12 Header <stdbit.h> synopsis [stdbit.h.syn]
// all freestanding
#define __STDC_VERSION_STDBIT_H__ 202311L
#define __STDC_ENDIAN_BIG__ see below
#define __STDC_ENDIAN_LITTLE__ see below
#define __STDC_ENDIAN_NATIVE__ see below
unsigned int stdc_leading_zeros_uc(unsigned char value);
unsigned int stdc_leading_zeros_us(unsigned short value);
unsigned int stdc_leading_zeros_ui(unsigned int value);
unsigned int stdc_leading_zeros_ul(unsigned long int value);
unsigned int stdc_leading_zeros_ull(unsigned long long int value);
template<class T> see below stdc_leading_zeros(T value);
unsigned int stdc_leading_ones_uc(unsigned char value);
unsigned int stdc_leading_ones_us(unsigned short value);
unsigned int stdc_leading_ones_ui(unsigned int value);
unsigned int stdc_leading_ones_ul(unsigned long int value);
unsigned int stdc_leading_ones_ull(unsigned long long int value);
template<class T> see below stdc_leading_ones(T value);
unsigned int stdc_trailing_zeros_uc(unsigned char value);
unsigned int stdc_trailing_zeros_us(unsigned short value);
unsigned int stdc_trailing_zeros_ui(unsigned int value);
unsigned int stdc_trailing_zeros_ul(unsigned long int value);
unsigned int stdc_trailing_zeros_ull(unsigned long long int value);
template<class T> see below stdc_trailing_zeros(T value);
unsigned int stdc_trailing_ones_uc(unsigned char value);
unsigned int stdc_trailing_ones_us(unsigned short value);
unsigned int stdc_trailing_ones_ui(unsigned int value);
unsigned int stdc_trailing_ones_ul(unsigned long int value);
unsigned int stdc_trailing_ones_ull(unsigned long long int value);
template<class T> see below stdc_trailing_ones(T value);
unsigned int stdc_first_leading_zero_uc(unsigned char value);
unsigned int stdc_first_leading_zero_us(unsigned short value);
unsigned int stdc_first_leading_zero_ui(unsigned int value);
unsigned int stdc_first_leading_zero_ul(unsigned long int value);
unsigned int stdc_first_leading_zero_ull(unsigned long long int value);
template<class T> see below stdc_first_leading_zero(T value);
unsigned int stdc_first_leading_one_uc(unsigned char value);
unsigned int stdc_first_leading_one_us(unsigned short value);
unsigned int stdc_first_leading_one_ui(unsigned int value);
unsigned int stdc_first_leading_one_ul(unsigned long int value);
unsigned int stdc_first_leading_one_ull(unsigned long long int value);
template<class T> see below stdc_first_leading_one(T value);
§ 22.12 © ISO/IEC
935

===== PAGE 947 =====

Dxxxx
unsigned int stdc_first_trailing_zero_uc(unsigned char value);
unsigned int stdc_first_trailing_zero_us(unsigned short value);
unsigned int stdc_first_trailing_zero_ui(unsigned int value);
unsigned int stdc_first_trailing_zero_ul(unsigned long int value);
unsigned int stdc_first_trailing_zero_ull(unsigned long long int value);
template<class T> see below stdc_first_trailing_zero(T value);
unsigned int stdc_first_trailing_one_uc(unsigned char value);
unsigned int stdc_first_trailing_one_us(unsigned short value);
unsigned int stdc_first_trailing_one_ui(unsigned int value);
unsigned int stdc_first_trailing_one_ul(unsigned long int value);
unsigned int stdc_first_trailing_one_ull(unsigned long long int value);
template<class T> see below stdc_first_trailing_one(T value);
unsigned int stdc_count_zeros_uc(unsigned char value);
unsigned int stdc_count_zeros_us(unsigned short value);
unsigned int stdc_count_zeros_ui(unsigned int value);
unsigned int stdc_count_zeros_ul(unsigned long int value);
unsigned int stdc_count_zeros_ull(unsigned long long int value);
template<class T> see below stdc_count_zeros(T value);
unsigned int stdc_count_ones_uc(unsigned char value);
unsigned int stdc_count_ones_us(unsigned short value);
unsigned int stdc_count_ones_ui(unsigned int value);
unsigned int stdc_count_ones_ul(unsigned long int value);
unsigned int stdc_count_ones_ull(unsigned long long int value);
template<class T> see below stdc_count_ones(T value);
bool stdc_has_single_bit_uc(unsigned char value);
bool stdc_has_single_bit_us(unsigned short value);
bool stdc_has_single_bit_ui(unsigned int value);
bool stdc_has_single_bit_ul(unsigned long int value);
bool stdc_has_single_bit_ull(unsigned long long int value);
template<class T> bool stdc_has_single_bit(T value);
unsigned int stdc_bit_width_uc(unsigned char value);
unsigned int stdc_bit_width_us(unsigned short value);
unsigned int stdc_bit_width_ui(unsigned int value);
unsigned int stdc_bit_width_ul(unsigned long int value);
unsigned int stdc_bit_width_ull(unsigned long long int value);
template<class T> see below stdc_bit_width(T value);
unsigned char stdc_bit_floor_uc(unsigned char value);
unsigned short stdc_bit_floor_us(unsigned short value);
unsigned int stdc_bit_floor_ui(unsigned int value);
unsigned long int stdc_bit_floor_ul(unsigned long int value);
unsigned long long int stdc_bit_floor_ull(unsigned long long int value);
template<class T> T stdc_bit_floor(T value);
unsigned char stdc_bit_ceil_uc(unsigned char value);
unsigned short stdc_bit_ceil_us(unsigned short value);
unsigned int stdc_bit_ceil_ui(unsigned int value);
unsigned long int stdc_bit_ceil_ul(unsigned long int value);
unsigned long long int stdc_bit_ceil_ull(unsigned long long int value);
template<class T> T stdc_bit_ceil(T value);
1 For a function template whose return type is not specified above, the return type is an implementation-defined
unsigned integer type large enough to represent all possible result values. Each function template has the
same semantics as the corresponding type-generic function with the same name specified inSee also:
ISO/IEC 9899:2024, 7.18.
2 Mandates: T is an unsigned integer type.
3 Otherwise, the contents and meaning of the header<stdbit.h> are the same as the C standard library
header <stdbit.h>.
§ 22.12 © ISO/IEC
936

===== PAGE 948 =====

Dxxxx
See also: ISO/IEC 9899:2024, 7.18
§ 22.12 © ISO/IEC
937

===== PAGE 949 =====

Dxxxx
23 Containers library [containers]
23.1 General [containers.general]
1 This Clause describes components that C++ programs may use to organize collections of information.
2 The following subclauses describe container requirements, and components for sequence containers and
associative containers, as summarized in Table 74.
Table 74 — Containers library summary [tab:containers.summary]
Subclause Header
23.2 Requirements
23.3 Sequence containers <array>, <deque>, <forward_list>, <hive>,
<inplace_vector>, <list>, <vector>
23.4 Associative containers <map>, <set>
23.5 Unordered associative containers <unordered_map>, <unordered_set>
23.6 Container adaptors <queue>, <stack>, <flat_map>, <flat_set>
23.7 Views <span>, <mdspan>
23.2 Requirements [container.requirements]
23.2.1 Preamble [container.requirements.pre]
1 Containers are objects that store other objects. They control allocation and deallocation of these objects
through constructors, destructors, insert and erase operations.
2 All of the complexity requirements in this Clause are stated solely in terms of the number of operations on
the contained objects.
[Example 1: The copy constructor of typevector<vector<int>> has linear complexity, even though the complexity
of copying each containedvector<int> is itself linear. —end example]
3 Allocator-aware containers (23.2.2.5) other than basic_string construct elements using the function
allocator_traits<allocator_type>::rebind_traits<U>::construct and destroy elements using the
function allocator_traits<allocator_type>::rebind_traits<U>::destroy (20.2.9.3), whereU is either
allocator_type::value_type or an internal type used by the container. These functions are called only
for the container’s element type, not for internal types used by the container.
[Note 1: This means, for example, that a node-based container would need to construct nodes containing aligned
buffers and callconstruct to place the element into the buffer.—end note]
23.2.2 General containers [container.requirements.general]
23.2.2.1 Introduction [container.intro.reqmts]
1 In 23.2.2,
—(1.1) X denotes a container class containing objects of typeT,
—(1.2) a denotes a value of typeX,
—(1.3) b and c denote values of type (possibly const)X,
—(1.4) i and j denote values of type (possibly const)X::iterator,
—(1.5) u denotes an identifier,
—(1.6) v denotes an lvalue of type (possibly const)X or an rvalue of typeconst X,
—(1.7) s and t denote non-const lvalues of typeX, and
—(1.8) rv denotes a non-const rvalue of typeX.
2 The following exposition-only concept is used in the definition of containers:
§ 23.2.2.1 © ISO/IEC
938

===== PAGE 950 =====

Dxxxx
template<class R, class T>
concept container-compatible-range = // exposition only
ranges::input_range<R> && convertible_to<ranges::range_reference_t<R>, T>;
23.2.2.2 Container requirements [container.reqmts]
1 A typeX meets thecontainer requirements if the following types, statements, and expressions are well-formed
and have the specified semantics.
typename X::value_type
2 Result: T
3 Preconditions: T is Cpp17Erasable from X (see 23.2.2.5, below).
typename X::reference
4 Result: T&
typename X::const_reference
5 Result: const T&
typename X::iterator
6 Result: A type that meets the forward iterator requirements (24.3.5.5) with value typeT. The type
X::iterator is convertible toX::const_iterator.
typename X::const_iterator
7 Result: A type that meets the requirements of a constant iterator and those of a forward iterator with
value typeT.
typename X::difference_type
8 Result: A signed integer type, identical to the difference type ofX::iterator and X::const_iterator.
typename X::size_type
9 Result: An unsigned integer type that can represent any non-negative value ofX::difference_type.
X u;
X u = X();
10 Postconditions: u.empty()
11 Complexity: Constant.
X u(v);
X u = v;
12 Preconditions: T is Cpp17CopyInsertable into X (see below).
13 Postconditions: u == v.
14 Complexity: Linear.
X u(rv);
X u = rv;
15 Postconditions: u is equal to the value thatrv had before this construction.
16 Complexity: Linear forarray and inplace_vector and constant for all other standard containers.
t = v
17 Result: X&.
18 Postconditions: t == v.
19 Complexity: Linear.
t = rv
20 Result: X&.
21 Effects: All existing elements oft are either move assigned to or destroyed.
§ 23.2.2.2 © ISO/IEC
939

===== PAGE 951 =====

Dxxxx
22 Postconditions: If t and rv do not refer to the same object,t is equal to the value thatrv had before
this assignment.
23 Complexity: Linear.
a.~X()
24 Result: void.
25 Effects: Destroys every element ofa; any memory obtained is deallocated.
26 Complexity: Linear.
b.begin()
27 Result: iterator; const_iterator for constantb.
28 Returns: An iterator referring to the first element in the container.
29 Complexity: Constant.
b.end()
30 Result: iterator; const_iterator for constantb.
31 Returns: An iterator which is the past-the-end value for the container.
32 Complexity: Constant.
b.cbegin()
33 Result: const_iterator.
34 Returns: const_cast<X const&>(b).begin()
35 Complexity: Constant.
b.cend()
36 Result: const_iterator.
37 Returns: const_cast<X const&>(b).end()
38 Complexity: Constant.
i <=> j
39 Result: strong_ordering.
40 Constraints: X::iterator meets the random access iterator requirements.
41 Complexity: Constant.
c == b
42 Preconditions: T meets theCpp17EqualityComparable requirements.
43 Result: bool.
44 Returns: equal(c.begin(), c.end(), b.begin(), b.end())
[Note 1: The algorithmequal is defined in 26.6.13.—end note]
45 Complexity: Constant ifc.size() != b.size(), linear otherwise.
46 Remarks: == is an equivalence relation.
c != b
47 Effects: Equivalent to!(c == b).
t.swap(s)
48 Result: void.
49 Effects: Exchanges the contents oft and s.
50 Complexity: Linear forarray and inplace_vector, and constant for all other standard containers.
§ 23.2.2.2 © ISO/IEC
940

===== PAGE 952 =====

Dxxxx
swap(t, s)
51 Effects: Equivalent tot.swap(s).
c.size()
52 Result: size_type.
53 Returns: distance(c.begin(), c.end()), i.e., the number of elements in the container.
54 Complexity: Constant.
55 Remarks: The number of elements is defined by the rules of constructors, inserts, and erases.
c.max_size()
56 Result: size_type.
57 Returns: distance(begin(), end()) for the largest possible container.
58 Complexity: Constant.
c.empty()
59 Result: bool.
60 Returns: c.begin() == c.end()
61 Complexity: Constant.
62 Remarks: If the container is empty, thenc.empty() is true.
63 In the expressions
i == j
i != j
i < j
i <= j
i >= j
i > j
i <=> j
i - j
where i and j denote objects of a container’siterator type, either or both may be replaced by an object of
the container’sconst_iterator type referring to the same element with no change in semantics.
64 Unless otherwise specified, all containers defined in this Clause obtain memory using an allocator (see 16.4.4.6).
[Note 2: In particular, containers and iterators do not store references to allocated elements other than through the
allocator’s pointer type, i.e., as objects of typeP or pointer_traits<P>::template rebind<unspecified >, whereP
is allocator_traits<allocator_type>::pointer. —end note]
Copy constructors for these container types obtain an allocator by callingallocator_traits<allocator_-
type>::select_on_container_copy_constructionon the allocator belonging to the container being copied.
Move constructors obtain an allocator by move construction from the allocator belonging to the container
being moved. Such move construction of the allocator shall not exit via an exception. All other constructors
for these container types take aconst allocator_type& argument.
[Note 3: If an invocation of a constructor uses the default value of an optional allocator argument, then the allocator
type must support value-initialization.—end note]
A copy of this allocator is used for any memory allocation and element construction performed, by these
constructors and by all other member functions, during the lifetime of each container object or until the
allocator is replaced. The allocator may be replaced only via assignment orswap(). Allocator replacement is
performed by copy assignment, move assignment, or swapping of the allocator only if
—(64.1) allocator_traits<allocator_type>::propagate_on_container_copy_assignment::value,
—(64.2) allocator_traits<allocator_type>::propagate_on_container_move_assignment::value, or
—(64.3) allocator_traits<allocator_type>::propagate_on_container_swap::value
is true within the implementation of the corresponding container operation. In all container types defined in
this Clause, the memberget_allocator() returns a copy of the allocator used to construct the container or,
if that allocator has been replaced, a copy of the most recent replacement.
§ 23.2.2.2 © ISO/IEC
941

===== PAGE 953 =====

Dxxxx
65 The expression a.swap(b), for containers a and b of a standard container type other thanarray and
inplace_vector, shall exchange the values ofa and b without invoking any move, copy, or swap operations
on the individual container elements. AnyCompare, Pred, orHash types belonging toa and b shall meet the
Cpp17Swappable requirements and shall be exchanged by callingswap as described in 16.4.4.3. Ifallocator_-
traits<allocator_type>::propagate_on_container_swap::value is true, then allocator_type shall
meet theCpp17Swappable requirements and the allocators ofa and b shall also be exchanged by callingswap
as described in 16.4.4.3. Otherwise, the allocators shall not be swapped, and the behavior is undefined unless
a.get_allocator() == b.get_allocator(). Every iterator referring to an element in one container before
the swap shall refer to the same element in the other container after the swap. It is unspecified whether an
iterator with valuea.end() before the swap will have valueb.end() after the swap.
66 Unless otherwise specified (see 23.2.7.2, 23.2.8.2, 23.3.5.4, 23.3.16.5, and 23.3.13.5) all container types defined
in this Clause meet the following additional requirements:
—(66.1) If an exception is thrown by aninsert() or emplace() function while inserting a single element, that
function has no effects.
—(66.2) If an exception is thrown by apush_back(), push_front(), emplace_back(), oremplace_front()
function, that function has no effects.
—(66.3) No erase(), clear(), pop_back() or pop_front() function throws an exception.
—(66.4) No copy constructor or assignment operator of a returned iterator throws an exception.
—(66.5) No swap() function throws an exception.
—(66.6) No swap() function invalidates any references, pointers, or iterators referring to the elements of the
containers being swapped.
[Note 4: The end() iterator does not refer to any element, so it can be invalidated.—end note]
67 Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a
container member function or passing a container as an argument to a library function shall not invalidate
iterators to, or change the values of, objects within that container.
68 A contiguous container is a container whose member types iterator and const_iterator meet the
Cpp17RandomAccessIteratorrequirements (24.3.5.7) and modelcontiguous_iterator (24.3.4.14).
69 The behavior of certain container member functions and deduction guides depends on whether types qualify
as input iterators or allocators. The extent to which an implementation determines that a type cannot be an
input iterator is unspecified, except that as a minimum integral types shall not qualify as input iterators.
Likewise, the extent to which an implementation determines that a type cannot be an allocator is unspecified,
except that as a minimum a typeA shall not qualify as an allocator unless it meets both of the following
conditions:
—(69.1) The qualified-id A::value_type is valid and denotes a type (13.10.3).
—(69.2) The expressiondeclval<A&>().allocate(size_t{}) is well-formed when treated as an unevaluated
operand.
23.2.2.3 Reversible container requirements [container.rev.reqmts]
1 A typeX meets thereversible containerrequirements ifX meets the container requirements, the iterator type
of X belongs to the bidirectional or random access iterator categories (24.3), and the following types and
expressions are well-formed and have the specified semantics.
typename X::reverse_iterator
2 Result: The typereverse_iterator<X::iterator>, an iterator type whose value type isT.
typename X::const_reverse_iterator
3 Result: The typereverse_iterator<X::const_iterator>, a constant iterator type whose value type
is T.
a.rbegin()
4 Result: reverse_iterator; const_reverse_iterator for constanta.
5 Returns: reverse_iterator(end())
6 Complexity: Constant.
§ 23.2.2.3 © ISO/IEC
942

===== PAGE 954 =====

Dxxxx
a.rend()
7 Result: reverse_iterator; const_reverse_iterator for constanta.
8 Returns: reverse_iterator(begin())
9 Complexity: Constant.
a.crbegin()
10 Result: const_reverse_iterator.
11 Returns: const_cast<X const&>(a).rbegin()
12 Complexity: Constant.
a.crend()
13 Result: const_reverse_iterator.
14 Returns: const_cast<X const&>(a).rend()
15 Complexity: Constant.
23.2.2.4 Optional container requirements [container.opt.reqmts]
1 The following operations are provided for some types of containers but not others. Those containers for which
the listed operations are provided shall implement the semantics as described unless otherwise stated. If the
iterators passed tolexicographical_compare_three_way meet the constexpr iterator requirements (24.3.1)
then the operations described below are implemented by constexpr functions.
a <=> b
2 Result: synth-three-way-result <X::value_type>.
3 Preconditions: Either T models three_way_comparable, or< is defined for values of type (possibly
const) T and < is a total ordering relationship.
4 Returns: lexicographical_compare_three_way(a.begin(), a.end(), b.begin(), b.end(),
synth-three-way)
[Note 1: The algorithmlexicographical_compare_three_way is defined in Clause 26.—end note]
5 Complexity: Linear.
23.2.2.5 Allocator-aware containers [container.alloc.reqmts]
1 Except forarray and inplace_vector, all of the containers defined in Clause 23, 19.6.4, 27.4.3, and 28.6.9
meet the additional requirements of anallocator-aware container, as described below.
2 Given an allocator typeAand given a container typeXhaving avalue_typeidentical toTand anallocator_-
type identical toallocator_traits<A>::rebind_alloc<T> and given an lvaluem of typeA, a pointerp of
type T*, an expressionv that denotes an lvalue of typeT or const T or an rvalue of typeconst T, and
an rvaluerv of typeT, the following terms are defined. IfX is not allocator-aware or is a specialization of
basic_string, the terms below are defined as ifA were allocator<T> — no allocator object needs to be
created and user specializations ofallocator<T> are not instantiated:
—(2.1) T is Cpp17DefaultInsertable intoX means that the following expression is well-formed:
allocator_traits<A>::construct(m, p)
—(2.2) An element ofX is default-inserted if it is initialized by evaluation of the expression
allocator_traits<A>::construct(m, p)
where p is the address of the uninitialized storage for the element allocated withinX.
—(2.3) T is Cpp17MoveInsertable intoX means that the following expression is well-formed:
allocator_traits<A>::construct(m, p, rv)
and its evaluation causes the following postcondition to hold: The value of*p is equivalent to the value
of rv before the evaluation.
[Note 1: rv remains a valid object. Its state is unspecified.—end note]
§ 23.2.2.5 © ISO/IEC
943

===== PAGE 955 =====

Dxxxx
—(2.4) T is Cpp17CopyInsertable intoX means that, in addition toT being Cpp17MoveInsertable into X, the
following expression is well-formed:
allocator_traits<A>::construct(m, p, v)
and its evaluation causes the following postcondition to hold: The value ofv is unchanged and is
equivalent to*p.
—(2.5) T is Cpp17EmplaceConstructible intoX from args, for zero or more argumentsargs, means that the
following expression is well-formed:
allocator_traits<A>::construct(m, p, args)
—(2.6) T is Cpp17Erasable fromX means that the following expression is well-formed:
allocator_traits<A>::destroy(m, p)
[Note 2: A container calls allocator_traits<A>::construct(m, p, args) to construct an element atp using
args, withm == get_allocator(). The default construct in allocator will call::new((void*)p) T(args), but
specialized allocators can choose a different definition.—end note]
3 In this subclause,
—(3.1) X denotes an allocator-aware container class with avalue_type of T using an allocator of typeA,
—(3.2) u denotes a variable,
—(3.3) a and b denote non-const lvalues of typeX,
—(3.4) c denotes an lvalue of typeconst X,
—(3.5) t denotes an lvalue or a const rvalue of typeX,
—(3.6) rv denotes a non-const rvalue of typeX, and
—(3.7) m is a value of typeA.
A typeX meets the allocator-aware container requirements ifX meets the container requirements and the
following types, statements, and expressions are well-formed and have the specified semantics.
typename X::allocator_type
4 Result: A
5 Mandates: allocator_type::value_type is the same asX::value_type.
c.get_allocator()
6 Result: A
7 Complexity: Constant.
X u;
X u = X();
8 Preconditions: A meets theCpp17DefaultConstructible requirements.
9 Postconditions: u.empty() returns true, u.get_allocator() == A().
10 Complexity: Constant.
X u(m);
11 Postconditions: u.empty() returns true, u.get_allocator() == m.
12 Complexity: Constant.
X u(t, m);
13 Preconditions: T is Cpp17CopyInsertable into X.
14 Postconditions: u == t, u.get_allocator() == m.
15 Complexity: Linear.
X u(rv);
16 Postconditions: u has the same elements asrv had before this construction; the value ofu.get_-
allocator() is the same as the value ofrv.get_allocator() before this construction.
17 Complexity: Constant.
§ 23.2.2.5 © ISO/IEC
944

===== PAGE 956 =====

Dxxxx
X u(rv, m);
18 Preconditions: T is Cpp17MoveInsertable into X.
19 Postconditions: u has the same elements, or copies of the elements, thatrv had before this construction,
u.get_allocator() == m.
20 Complexity: Constant ifm == rv.get_allocator(), otherwise linear.
a = t
21 Result: X&.
22 Preconditions: T is Cpp17CopyInsertable into X and Cpp17CopyAssignable.
23 Postconditions: a == t is true.
24 Complexity: Linear.
a = rv
25 Result: X&.
26 Preconditions: If allocator_traits<allocator_type>::propagate_on_container_move_assign-
ment::value is false, T is Cpp17MoveInsertable into X and Cpp17MoveAssignable.
27 Effects: All existing elements ofa are either move assigned to or destroyed.
28 Postconditions: If a and rv do not refer to the same object,a is equal to the value thatrv had before
this assignment.
29 Complexity: Linear.
a.swap(b)
30 Result: void
31 Effects: Exchanges the contents ofa and b.
32 Complexity: Constant.
23.2.3 Container data races [container.requirements.dataraces]
1 For purposes of avoiding data races (16.4.6.10), implementations shall consider the following functions to be
const: begin, end, rbegin, rend, front, back, data, find, lower_bound, upper_bound, equal_range, at
and, except in associative or unordered associative containers,operator[].
2 Notwithstanding 16.4.6.10, implementations are required to avoid data races when the contents of the contained
object in different elements in the same container, exceptingvector<bool>, are modified concurrently.
3 [Note 1: For a vector<int> x with a size greater than one, x[1] = 5 and *x.begin() = 10 can be executed
concurrently without a data race, butx[0] = 5 and *x.begin() = 10 executed concurrently can result in a data race.
As an exception to the general rule, for avector<bool> y, y[0] = true can race withy[1] = true. —end note]
23.2.4 Sequence containers [sequence.reqmts]
1 A sequence container organizes a finite set of objects, all of the same type, into a strictly linear arrangement.
The library provides the following basic kinds of sequence containers:vector, inplace_vector, forward_-
list, list, and deque. In addition, array and hive are provided as sequence containers which provide
limited sequence operations, in array’s case because it has a fixed number of elements, and inhive’s
case because insertion order is unspecified. The library also provides container adaptors that make it
easy to construct abstract data types, such asstacks, queues, flat_maps, flat_multimaps, flat_sets,
or flat_multisets, out of the basic sequence container kinds (or out of other program-defined sequence
containers).
2 In this subclause,
—(2.1) X denotes a sequence container class,
—(2.2) a denotes a value of typeX containing elements of typeT,
—(2.3) u denotes the name of a variable being declared,
—(2.4) A denotes X::allocator_type if the qualified-id X::allocator_type is valid and denotes a type
(13.10.3) andallocator<T> if it doesn’t,
§ 23.2.4 © ISO/IEC
945

===== PAGE 957 =====

Dxxxx
—(2.5) i and j denote iterators that meet theCpp17InputIterator requirements and refer to elements implicitly
convertible tovalue_type,
—(2.6) [i,j) denotes a valid range,
—(2.7) rg denotes a value of a typeR that modelscontainer-compatible-range <T>,
—(2.8) il designates an object of typeinitializer_list<value_type>,
—(2.9) n denotes a value of typeX::size_type,
—(2.10) p denotes a valid constant iterator toa,
—(2.11) q denotes a valid dereferenceable constant iterator toa,
—(2.12) [q1,q2) denotes a valid range of constant iterators ina,
—(2.13) t denotes an lvalue or a const rvalue ofX::value_type, and
—(2.14) rv denotes a non-const rvalue ofX::value_type.
—(2.15) Args denotes a template parameter pack;
—(2.16) args denotes a function parameter pack with the patternArgs&&.
3 The complexities of the expressions are sequence dependent.
4 A typeX meets thesequence containerrequirements ifX meets the container requirements and the following
statements and expressions are well-formed and have the specified semantics.
X u(n, t);
5 Preconditions: T is Cpp17CopyInsertable into X.
6 Effects: Constructs a sequence container withn copies oft.
7 Postconditions: distance(u.begin(), u.end()) == n is true.
X u(i, j);
8 Preconditions: T is Cpp17EmplaceConstructible into X from *i. Forvector, if the iterator does not
meet theCpp17ForwardIteratorrequirements (24.3.5.5),T is alsoCpp17MoveInsertable into X.
9 Effects: Constructs a sequence container equal to the range[i,j). Each iterator in the range[i,j) is
dereferenced exactly once.
10 Postconditions: distance(u.begin(), u.end()) == distance(i, j) is true.
X(from_range, rg)
11 Preconditions: TisCpp17EmplaceConstructibleintoXfrom *ranges::begin(rg). Forvector, ifRmod-
elsranges::approximately_sized_rangebut notranges::sized_rangeor modelsranges::input_-
range but notranges::forward_range, T is alsoCpp17MoveInsertable into X.
12 Effects: Constructs a sequence container equal to the rangerg. Each iterator in the range rg is
dereferenced exactly once.
13 Recommended practice: If R models ranges::approximately_sized_range and ranges::distance(
rg) <= ranges::reserve_hint(rg) is true, an implementation should not perform more than a
single reallocation.
14 Postconditions: distance(begin(), end()) == ranges::distance(rg) is true.
X(il)
15 Effects: Equivalent toX(il.begin(), il.end()).
a = il
16 Result: X&.
17 Preconditions: T is Cpp17CopyInsertable into X and Cpp17CopyAssignable.
18 Effects: Assigns the range[il.begin(),il.end()) into a. All existing elements ofa are either assigned
to or destroyed.
19 Returns: *this.
§ 23.2.4 © ISO/IEC
946

===== PAGE 958 =====

Dxxxx
a.emplace(p, args)
20 Result: iterator.
21 Preconditions: T is Cpp17EmplaceConstructible into X from args. Forvector, inplace_vector, and
deque, T is alsoCpp17MoveInsertable into X and Cpp17MoveAssignable.
22 Effects: Inserts an object of typeT constructed withstd::forward<Args>(args)... before p.
[Note 1: args can directly or indirectly refer to a value ina. —end note]
23 Returns: An iterator that points to the new element.
a.insert(p, t)
24 Result: iterator.
25 Preconditions: T is Cpp17CopyInsertable into X. Forvector, inplace_vector, anddeque, T is also
Cpp17CopyAssignable.
26 Effects: Inserts a copy oft before p.
27 Returns: An iterator that points to the copy oft inserted intoa.
a.insert(p, rv)
28 Result: iterator.
29 Preconditions: T is Cpp17MoveInsertable into X. Forvector, inplace_vector, anddeque, T is also
Cpp17MoveAssignable.
30 Effects: Inserts a copy ofrv before p.
31 Returns: An iterator that points to the copy ofrv inserted intoa.
a.insert(p, n, t)
32 Result: iterator.
33 Preconditions: T is Cpp17CopyInsertable into X and Cpp17CopyAssignable.
34 Effects: Inserts n copies oft before p.
35 Returns: An iterator that points to the copy of the first element inserted intoa, orp if n == 0.
a.insert(p, i, j)
36 Result: iterator.
37 Preconditions: T is Cpp17EmplaceConstructible into X from *i. For vector, inplace_vector, and
deque, T is alsoCpp17MoveInsertable into X, andT meets theCpp17MoveConstructible, Cpp17MoveAs-
signable, andCpp17Swappable (16.4.4.3) requirements. Neitheri nor j are iterators intoa.
38 Effects: Inserts copies of elements in[i,j) before p. Each iterator in the range[i,j) shall be dereferenced
exactly once.
39 Returns: An iterator that points to the copy of the first element inserted intoa, orp if i == j.
a.insert_range(p, rg)
40 Result: iterator.
41 Preconditions: T is Cpp17EmplaceConstructible into X from *ranges::begin(rg). For vector,
inplace_vector, and deque, T is also Cpp17MoveInsertable into X, and T meets the Cpp17Move-
Constructible, Cpp17MoveAssignable, andCpp17Swappable (16.4.4.3) requirements.rg and a do not
overlap.
42 Effects: Inserts copies of elements inrg before p. Each iterator in the rangerg is dereferenced exactly
once.
43 Returns: An iterator that points to the copy of the first element inserted intoa, orp if rg is empty.
a.insert(p, il)
44 Effects: Equivalent toa.insert(p, il.begin(), il.end()).
§ 23.2.4 © ISO/IEC
947

===== PAGE 959 =====

Dxxxx
a.erase(q)
45 Result: iterator.
46 Preconditions: Forvector, inplace_vector, anddeque, T is Cpp17MoveAssignable.
47 Effects: Erases the element pointed to byq.
48 Returns: An iterator that points to the element immediately followingq prior to the element being
erased. If no such element exists,a.end() is returned.
a.erase(q1, q2)
49 Result: iterator.
50 Preconditions: Forvector, inplace_vector, anddeque, T is Cpp17MoveAssignable.
51 Effects: Erases the elements in the range[q1,q2).
52 Returns: An iterator that points to the element pointed to byq2 prior to any elements being erased. If
no such element exists,a.end() is returned.
a.clear()
53 Result: void
54 Effects: Destroys all elements ina. Invalidates all references, pointers, and iterators referring to the
elements ofa and may invalidate the past-the-end iterator.
55 Postconditions: a.empty() is true.
56 Complexity: Linear.
a.assign(i, j)
57 Result: void
58 Preconditions: T is Cpp17EmplaceConstructible into X from *i and assignable from*i. Forvector, if
the iterator does not meet the forward iterator requirements (24.3.5.5),T is alsoCpp17MoveInsertable
into X. Neither i nor j are iterators intoa.
59 Effects: Replaces elements ina with a copy of[i,j). Invalidates all references, pointers and iterators
referring to the elements ofa. Forvector and deque, also invalidates the past-the-end iterator. Each
iterator in the range[i,j) is dereferenced exactly once.
a.assign_range(rg)
60 Result: void
61 Mandates: assignable_from<T&, ranges::range_reference_t<R>> is modeled. For inplace_-
vector, ifranges::size(rg) is a constant expression, thenranges::size(rg) ≤a.max_size().
62 Preconditions: TisCpp17EmplaceConstructibleintoXfrom *ranges::begin(rg). Forvector, ifRmod-
elsranges::approximately_sized_rangebut notranges::sized_rangeor modelsranges::input_-
range but notranges::forward_range, T is alsoCpp17MoveInsertable into X. rg and a do not overlap.
63 Effects: Replaces elements ina with a copy of each element inrg. Invalidates all references, pointers,
and iterators referring to the elements ofa. Forvector and deque, also invalidates the past-the-end
iterator. Each iterator in the rangerg is dereferenced exactly once.
64 Recommended practice: If R models ranges::approximately_sized_range and ranges::distance(
rg) <= ranges::reserve_hint(rg) is true, an implementation should not perform any reallocation.
a.assign(il)
65 Effects: Equivalent toa.assign(il.begin(), il.end()).
a.assign(n, t)
66 Result: void
67 Preconditions: T is Cpp17CopyInsertable into X and Cpp17CopyAssignable. t is not a reference intoa.
68 Effects: Replaces elements ina with n copies of t. Invalidates all references, pointers and iterators
referring to the elements ofa. Forvector and deque, also invalidates the past-the-end iterator.
§ 23.2.4 © ISO/IEC
948

===== PAGE 960 =====

Dxxxx
69 For every sequence container defined in this Clause and in Clause 27:
—(69.1) If the constructor
template<class InputIterator>
X(InputIterator first, InputIterator last,
const allocator_type& alloc = allocator_type());
is called with a typeInputIterator that does not qualify as an input iterator, then the constructor
shall not participate in overload resolution.
—(69.2) If the member functions of the forms:
template<class InputIterator>
return-type F(const_iterator p,
InputIterator first, InputIterator last); // such asinsert
template<class InputIterator>
return-type F(InputIterator first, InputIterator last); // such asappend, assign
template<class InputIterator>
return-type F(const_iterator i1, const_iterator i2,
InputIterator first, InputIterator last); // such asreplace
are called with a typeInputIterator that does not qualify as an input iterator, then these functions
shall not participate in overload resolution.
—(69.3) A deduction guide for a sequence container shall not participate in overload resolution if it has an
InputIterator template parameter and a type that does not qualify as an input iterator is deduced
for that parameter, or if it has anAllocator template parameter and a type that does not qualify as
an allocator is deduced for that parameter.
70 The following operations are provided for some types of sequence containers but not others. Operations other
than prepend_range and append_range are implemented so as to take amortized constant time.
a.front()
71 Result: reference; const_reference for constanta.
72 Hardened preconditions: a.empty() is false.
73 Returns: *a.begin()
74 Remarks: Required for basic_string, array, deque, forward_list, inplace_vector, list, and
vector.
a.back()
75 Result: reference; const_reference for constanta.
76 Hardened preconditions: a.empty() is false.
77 Effects: Equivalent to:
auto tmp = a.end();
--tmp;
return *tmp;
78 Remarks: Required forbasic_string, array, deque, inplace_vector, list, andvector.
a.emplace_front(args)
79 Result: reference
80 Preconditions: T is Cpp17EmplaceConstructible into X from args.
81 Effects: Prepends an object of typeT constructed withstd::forward<Args>(args)....
82 Returns: a.front().
83 Remarks: Required fordeque, forward_list, andlist.
a.emplace_back(args)
84 Result: reference
§ 23.2.4 © ISO/IEC
949

===== PAGE 961 =====

Dxxxx
85 Preconditions: T is Cpp17EmplaceConstructible into X from args. Forvector, T is alsoCpp17MoveIn-
sertable into X.
86 Effects: Appends an object of typeT constructed withstd::forward<Args>(args)....
87 Returns: a.back().
88 Remarks: Required fordeque, inplace_vector, list, andvector.
a.push_front(t)
89 Result: void
90 Preconditions: T is Cpp17CopyInsertable into X.
91 Effects: Prepends a copy oft.
92 Remarks: Required fordeque, forward_list, andlist.
a.push_front(rv)
93 Result: void
94 Preconditions: T is Cpp17MoveInsertable into X.
95 Effects: Prepends a copy ofrv.
96 Remarks: Required fordeque, forward_list, andlist.
a.prepend_range(rg)
97 Result: void
98 Preconditions: T is Cpp17EmplaceConstructible into X from *ranges::begin(rg). Fordeque, T is also
Cpp17MoveInsertable into X, andT meets theCpp17MoveConstructible, Cpp17MoveAssignable, and
Cpp17Swappable (16.4.4.3) requirements.
99 Effects: Inserts copies of elements inrg before begin(). Each iterator in the rangerg is dereferenced
exactly once.
[Note 2: The order of elements inrg is not reversed. —end note]
100 Remarks: Required fordeque, forward_list, andlist.
a.push_back(t)
101 Result: void
102 Preconditions: T is Cpp17CopyInsertable into X.
103 Effects: Appends a copy oft.
104 Remarks: Required forbasic_string, deque, inplace_vector, list, andvector.
a.push_back(rv)
105 Result: void
106 Preconditions: T is Cpp17MoveInsertable into X.
107 Effects: Appends a copy ofrv.
108 Remarks: Required forbasic_string, deque, inplace_vector, list, andvector.
a.append_range(rg)
109 Result: void
110 Preconditions: T is Cpp17EmplaceConstructible into X from *ranges::begin(rg). For vector, T is
also Cpp17MoveInsertable into X.
111 Effects: Inserts copies of elements inrg before end(). Each iterator in the rangerg is dereferenced
exactly once.
112 Remarks: Required fordeque, inplace_vector, list, andvector.
a.pop_front()
113 Result: void
§ 23.2.4 © ISO/IEC
950

===== PAGE 962 =====

Dxxxx
114 Hardened preconditions: a.empty() is false.
115 Effects: Destroys the first element.
116 Remarks: Required fordeque, forward_list, andlist.
a.pop_back()
117 Result: void
118 Hardened preconditions: a.empty() is false.
119 Effects: Destroys the last element.
120 Remarks: Required forbasic_string, deque, inplace_vector, list, andvector.
a[n]
121 Result: reference; const_reference for constanta.
122 Hardened preconditions: n < a.size() is true.
123 Effects: Equivalent to:return *(a.begin() + n);
124 Remarks: Required forbasic_string, array, deque, inplace_vector, andvector.
a.at(n)
125 Result: reference; const_reference for constanta.
126 Returns: *(a.begin() + n)
127 Throws: out_of_range if n >= a.size().
128 Remarks: Required forbasic_string, array, deque, inplace_vector, andvector.
23.2.5 Node handles [container.node]
23.2.5.1 Overview [container.node.overview]
1 A node handleis an object that accepts ownership of a single element from an associative container (23.2.7)
or an unordered associative container (23.2.8). It may be used to transfer that ownership to another container
with compatible nodes. Containers with compatible nodes have the same node handle type. Elements may
be transferred in either direction between container types in the same row of Table 75.
Table 75 — Container types with compatible nodes [tab:container.node.compat]
map<K, T, C1, A> map<K, T, C2, A>
map<K, T, C1, A> multimap<K, T, C2, A>
set<K, C1, A> set<K, C2, A>
set<K, C1, A> multiset<K, C2, A>
unordered_map<K, T, H1, E1, A> unordered_map<K, T, H2, E2, A>
unordered_map<K, T, H1, E1, A> unordered_multimap<K, T, H2, E2, A>
unordered_set<K, H1, E1, A> unordered_set<K, H2, E2, A>
unordered_set<K, H1, E1, A> unordered_multiset<K, H2, E2, A>
2 If a node handle is not empty, then it contains an allocator that is equal to the allocator of the container
when the element was extracted. If a node handle is empty, it contains no allocator.
3 Class node-handle is for exposition only.
4 If a user-defined specialization ofpair exists forpair<const Key, T> or pair<Key, T>, whereKey is the
container’s key_type and T is the container’smapped_type, the behavior of operations involving node handles
is undefined.
template<unspecified>
class node-handle {
public:
// These type declarations are described in 23.2.7 and 23.2.8.
using value_type = see below; // not present for map containers
using key_type = see below; // not present for set containers
using mapped_type = see below; // not present for set containers
§ 23.2.5.1 © ISO/IEC
951

===== PAGE 963 =====

Dxxxx
using allocator_type = see below;
private:
using container-node-type = unspecified; // exposition only
using ator-traits = allocator_traits<allocator_type>; // exposition only
typename ator-traits ::template
rebind_traits<container-node-type >::pointer ptr_; // exposition only
optional<allocator_type> alloc_; // exposition only
public:
// 23.2.5.2, constructors, copy, and assignment
constexpr node-handle() noexcept : ptr_(), alloc_() {}
constexpr node-handle(node-handle&&) noexcept;
constexpr node-handle& operator=(node-handle&&);
// 23.2.5.3, destructor
constexpr ~node-handle();
// 23.2.5.4, observers
constexpr value_type& value() const; // not present for map containers
key_type& key() const; // not present for set containers
constexpr mapped_type& mapped() const; // not present for set containers
constexpr allocator_type get_allocator() const;
constexpr explicit operator bool() const noexcept;
constexpr bool empty() const noexcept;
// 23.2.5.5, modifiers
constexpr void swap(node-handle&)
noexcept(ator-traits ::propagate_on_container_swap::value ||
ator-traits ::is_always_equal::value);
friend constexpr void swap(node-handle& x, node-handle& y) noexcept(noexcept(x.swap(y))) {
x.swap(y);
}
};
23.2.5.2 Constructors, copy, and assignment [container.node.cons]
constexpr node-handle(node-handle&& nh) noexcept;
1 Effects: Constructs anode-handle object initializingptr_ with nh.ptr_. Move constructsalloc_ with
nh.alloc_. Assigns nullptr to nh.ptr_ and assignsnullopt to nh.alloc_.
constexpr node-handle& operator=(node-handle&& nh);
2 Preconditions: Either !alloc_ is true, or ator-traits::propagate_on_container_move_assign-
ment::value is true, oralloc_ == nh.alloc_ is true.
3 Effects:
—(3.1) If ptr_ != nullptr is true, destroys thevalue_type subobject in thecontainer-node-type
object pointed to byptr_ by callingator-traits ::destroy, then deallocatesptr_ by calling
ator-traits ::template rebind_traits<container-node-type >::deallocate.
—(3.2) Assigns nh.ptr_ to ptr_.
—(3.3) If !alloc_ is true or ator-traits ::propagate_on_container_move_assignment::value is
true,
move assignsnh.alloc_ to alloc_.
—(3.4) Assigns nullptr to nh.ptr_ and assignsnullopt to nh.alloc_.
4 Returns: *this.
5 Throws: Nothing.
§ 23.2.5.2 © ISO/IEC
952

===== PAGE 964 =====

Dxxxx
23.2.5.3 Destructor [container.node.dtor]
constexpr ~node-handle();
1 Effects: If ptr_ != nullptr is true, destroys thevalue_type subobject in thecontainer-node-type
object pointed to byptr_ by callingator-traits ::destroy, then deallocatesptr_ by callingator--
traits ::template rebind_traits<container-node-type >::deallocate.
23.2.5.4 Observers [container.node.observers]
constexpr value_type& value() const;
1 Preconditions: empty() == false.
2 Returns: A reference to thevalue_type subobject in thecontainer-node-type object pointed to by
ptr_.
3 Throws: Nothing.
key_type& key() const;
4 Preconditions: empty() == false.
5 Returns: A non-const reference to thekey_type member of thevalue_type subobject in thecontain-
er-node-type object pointed to byptr_.
6 Throws: Nothing.
7 Remarks: Modifying the key through the returned reference is permitted.
constexpr mapped_type& mapped() const;
8 Preconditions: empty() == false.
9 Returns: A reference to themapped_type member of thevalue_type subobject in thecontainer--
node-type object pointed to byptr_.
10 Throws: Nothing.
constexpr allocator_type get_allocator() const;
11 Preconditions: empty() == false.
12 Returns: *alloc_.
13 Throws: Nothing.
constexpr explicit operator bool() const noexcept;
14 Returns: ptr_ != nullptr.
constexpr bool empty() const noexcept;
15 Returns: ptr_ == nullptr.
23.2.5.5 Modifiers [container.node.modifiers]
constexpr void swap(node-handle& nh)
noexcept(ator-traits ::propagate_on_container_swap::value ||
ator-traits ::is_always_equal::value);
1 Preconditions: !alloc_ istrue, or!nh.alloc_, orator-traits ::propagate_on_container_swap::-
value is true, oralloc_ == nh.alloc_ is true.
2 Effects: Calls swap(ptr_, nh.ptr_). If !alloc_ is true, or!nh.alloc_ is true, orator-traits ::-
propagate_on_container_swap::value is true calls swap(alloc_, nh.alloc_).
23.2.6 Insert return type [container.insert.return]
1 The associative containers with unique keys and the unordered containers with unique keys have a member
function insert that returns a nested typeinsert_return_type. That return type is a specialization of
the template specified in this subclause.
§ 23.2.6 © ISO/IEC
953

===== PAGE 965 =====

Dxxxx
template<class Iterator, class NodeType>
struct insert-return-type
{
Iterator position;
bool inserted;
NodeType node;
};
2 The nameinsert-return-type is for exposition only.insert-return-type has the template parameters,
data members, and special members specified above. It has no base classes or members other than those
specified.
23.2.7 Associative containers [associative.reqmts]
23.2.7.1 General [associative.reqmts.general]
1 Associative containers provide fast retrieval of data based on keys. The library provides four basic kinds
of associative containers:set, multiset, map and multimap. The library also provides container adaptors
that make it easy to construct abstract data types, such asflat_maps, flat_multimaps, flat_sets, or
flat_multisets, out of the basic sequence container kinds (or out of other program-defined sequence
containers).
2 Each associative container is parameterized onKey and an ordering relationCompare that induces a strict
weak ordering (26.8) on elements ofKey. In addition,map and multimap associate an arbitrarymapped type
T with theKey. The object of typeCompare is called thecomparison objectof a container.
3 The phrase “equivalence of keys” means the equivalence relation imposed by the comparison object. That
is, two keysk1 and k2 are considered to be equivalent if for the comparison objectcomp, comp(k1, k2) ==
false && comp(k2, k1) == false.
[Note 1: This is not necessarily the same as the result ofk1 == k2. —end note]
For any two keysk1 and k2 in the same container, callingcomp(k1, k2) shall always return the same value.
4 An associative container supportsunique keysif it may contain at most one element for each key. Otherwise,
it supports equivalent keys. The set and map classes support unique keys; themultiset and multimap
classes support equivalent keys. Formultiset and multimap, insert, emplace, and erase preserve the
relative ordering of equivalent elements.
5 For set and multiset the value type is the same as the key type. Formap and multimap it is equal to
pair<const Key, T>.
6 iterator of an associative container is of the bidirectional iterator category. For associative containers where
the value type is the same as the key type, bothiterator and const_iterator are constant iterators. It is
unspecified whether or notiterator and const_iterator are the same type.
[Note 2: iterator and const_iterator have identical semantics in this case, anditerator is convertible toconst_-
iterator. Users can avoid violating the one-definition rule by always usingconst_iterator in their function
parameter lists. —end note]
7 In this subclause,
—(7.1) X denotes an associative container class,
—(7.2) a denotes a value of typeX,
—(7.3) a2 denotes a value of a type with nodes compatible with typeX (Table 75),
—(7.4) b denotes a value of typeX or const X,
—(7.5) u denotes the name of a variable being declared,
—(7.6) a_uniq denotes a value of typeX when X supports unique keys,
—(7.7) a_eq denotes a value of typeX when X supports equivalent keys,
—(7.8) a_tran denotes a value of typeX or const X when thequalified-id X::key_compare::is_transparent
is valid and denotes a type (13.10.3),
—(7.9) i and j meet the Cpp17InputIterator requirements and refer to elements implicitly convertible to
value_type,
—(7.10) [i,j) denotes a valid range,
§ 23.2.7.1 © ISO/IEC
954

===== PAGE 966 =====

Dxxxx
—(7.11) rg denotes a value of a typeR that modelscontainer-compatible-range <value_type>,
—(7.12) p denotes a valid constant iterator toa,
—(7.13) q denotes a valid dereferenceable constant iterator toa,
—(7.14) r denotes a valid dereferenceable iterator toa,
—(7.15) [q1,q2) denotes a valid range of constant iterators ina,
—(7.16) il designates an object of typeinitializer_list<value_type>,
—(7.17) t denotes a value of typeX::value_type,
—(7.18) k denotes a value of typeX::key_type, and
—(7.19) c denotes a value of typeX::key_compare or const X::key_compare;
—(7.20) kl is a value such thata is partitioned (26.8) with respect toc(x, kl), withx the key value ofe and
e in a;
—(7.21) ku is a value such thata is partitioned with respect to!c(ku, x), withx the key value ofe and e in a;
—(7.22) ke is a value such thata is partitioned with respect toc(x, ke) and !c(ke, x), with c(x, ke)
implying !c(ke, x) and withx the key value ofe and e in a;
—(7.23) kx is a value such that
—(7.23.1) a is partitioned with respect toc(x, kx) and !c(kx, x), withc(x, kx) implying !c(kx, x)
and withx the key value ofe and e in a, and
—(7.23.2) kx is not convertible to eitheriterator or const_iterator; and
—(7.24) A denotes the storage allocator used byX, if any, orallocator<X::value_type> otherwise,
—(7.25) m denotes an allocator of a type convertible toA, andnh denotes a non-const rvalue of typeX::node_-
type.
8 A typeX meets theassociative containerrequirements ifX meets all the requirements of an allocator-aware
container (23.2.2.5) and the following types, statements, and expressions are well-formed and have the
specified semantics, except that formap and multimap, the requirements placed onvalue_type in 23.2.2.2
apply instead tokey_type and mapped_type.
[Note 3: For example, in some caseskey_type and mapped_type need to beCpp17CopyAssignable even though the
associated value_type, pair<const key_type, mapped_type>, is notCpp17CopyAssignable. —end note]
typename X::key_type
9 Result: Key.
typename X::mapped_type
10 Result: T.
11 Remarks: Formap and multimap only.
typename X::value_type
12 Result: Key for set and multiset only; pair<const Key, T> for map and multimap only.
13 Preconditions: X::value_type is Cpp17Erasable from X.
typename X::key_compare
14 Result: Compare.
15 Preconditions: key_compare is Cpp17CopyConstructible.
typename X::value_compare
16 Result: A binary predicate type. It is the same askey_compare for set and multiset; is an ordering
relation on pairs induced by the first component (i.e.,Key) formap and multimap.
typename X::node_type
17 Result: A specialization of thenode-handle class template (23.2.5), such that the public nested types
are the same types as the corresponding types inX.
§ 23.2.7.1 © ISO/IEC
955

===== PAGE 967 =====

Dxxxx
X(c)
18 Effects: Constructs an empty container. Uses a copy ofc as a comparison object.
19 Complexity: Constant.
X u = X();
X u;
20 Preconditions: key_compare meets theCpp17DefaultConstructible requirements.
21 Effects: Constructs an empty container. UsesCompare() as a comparison object.
22 Complexity: Constant.
X(i, j, c)
23 Preconditions: value_type is Cpp17EmplaceConstructible into X from *i.
24 Effects: Constructs an empty container and inserts elements from the range[i,j) into it; usesc as a
comparison object.
25 Complexity: Nlog N in general, whereN has the valuedistance(i, j); linear if[i,j) is sorted with
respect tovalue_comp().
X(i, j)
26 Preconditions: key_compare meets the Cpp17DefaultConstructible requirements. value_type is
Cpp17EmplaceConstructible into X from *i.
27 Effects: Constructs an empty container and inserts elements from the range[i,j) into it; usesCompare()
as a comparison object.
28 Complexity: Nlog N in general, whereN has the valuedistance(i, j); linear if[i,j) is sorted with
respect tovalue_comp().
X(from_range, rg, c)
29 Preconditions: value_type is Cpp17EmplaceConstructible into X from *ranges::begin(rg).
30 Effects: Constructs an empty container and inserts each element fromrg into it. Uses c as the
comparison object.
31 Complexity: Nlog N in general, whereN has the valueranges::distance(rg); linear ifrg is sorted
with respect tovalue_comp().
X(from_range, rg)
32 Preconditions: key_compare meets the Cpp17DefaultConstructible requirements. value_type is
Cpp17EmplaceConstructible into X from *ranges::begin(rg).
33 Effects: Constructs an empty container and inserts each element fromrg into it. UsesCompare() as
the comparison object.
34 Complexity: Same asX(from_range, rg, c).
X(il, c)
35 Effects: Equivalent toX(il.begin(), il.end(), c).
X(il)
36 Effects: Equivalent toX(il.begin(), il.end()).
a = il
37 Result: X&
38 Preconditions: value_type is Cpp17CopyInsertable into X and Cpp17CopyAssignable.
39 Effects: Assigns the range[il.begin(),il.end()) into a. All existing elements ofa are either assigned
to or destroyed.
40 Complexity: Nlog N in general, whereN has the valueil.size() + a.size(); linear if[il.begin(),
il.end()) is sorted with respect tovalue_comp().
§ 23.2.7.1 © ISO/IEC
956

===== PAGE 968 =====

Dxxxx
b.key_comp()
41 Result: X::key_compare
42 Returns: The comparison object out of whichb was constructed.
43 Complexity: Constant.
b.value_comp()
44 Result: X::value_compare
45 Returns: An object ofvalue_compare constructed out of the comparison object.
46 Complexity: Constant.
a_uniq.emplace(args)
47 Result: pair<iterator, bool>
48 Preconditions: value_type is Cpp17EmplaceConstructible into X from args.
49 Effects: Inserts avalue_type object t constructed withstd::forward<Args>(args)... if and only
if there is no element in the container with key equivalent to the key oft.
50 Returns: The bool component of the returned pair istrue if and only if the insertion takes place, and
the iterator component of the pair points to the element with key equivalent to the key oft.
51 Complexity: Logarithmic.
a_eq.emplace(args)
52 Result: iterator
53 Preconditions: value_type is Cpp17EmplaceConstructible into X from args.
54 Effects: Inserts avalue_type object t constructed withstd::forward<Args>(args).... If a range
containing elements equivalent tot exists ina_eq, t is inserted at the end of that range.
55 Returns: An iterator pointing to the newly inserted element.
56 Complexity: Logarithmic.
a.emplace_hint(p, args)
57 Result: iterator
58 Effects: Equivalent toa.emplace(std::forward<Args>(args)...), except that the element is inserted
as close as possible to the position just prior top.
59 Returns: The iterator returned byemplace.
60 Complexity: Logarithmic in general, but amortized constant if the element is inserted right beforep.
a_uniq.insert(t)
61 Result: pair<iterator, bool>
62 Preconditions: If t is a non-const rvalue, value_type is Cpp17MoveInsertable into X; otherwise,
value_type is Cpp17CopyInsertable into X.
63 Effects: Inserts t if and only if there is no element in the container with key equivalent to the key oft.
64 Returns: The bool component of the returned pair istrue if and only if the insertion takes place, and
the iterator component of the pair points to the element with key equivalent to the key oft.
65 Complexity: Logarithmic.
a_eq.insert(t)
66 Result: iterator
67 Preconditions: If t is a non-const rvalue, value_type is Cpp17MoveInsertable into X; otherwise,
value_type is Cpp17CopyInsertable into X.
68 Effects: Inserts t and returns the iterator pointing to the newly inserted element. If a range containing
elements equivalent tot exists ina_eq, t is inserted at the end of that range.
69 Complexity: Logarithmic.
§ 23.2.7.1 © ISO/IEC
957

===== PAGE 969 =====

Dxxxx
a.insert(p, t)
70 Result: iterator
71 Preconditions: If t is a non-const rvalue, value_type is Cpp17MoveInsertable into X; otherwise,
value_type is Cpp17CopyInsertable into X.
72 Effects: Inserts t if and only if there is no element with key equivalent to the key oft in containers
with unique keys; always insertst in containers with equivalent keys.t is inserted as close as possible
to the position just prior top.
73 Returns: An iterator pointing to the element with key equivalent to the key oft.
74 Complexity: Logarithmic in general, but amortized constant ift is inserted right beforep.
a.insert(i, j)
75 Result: void
76 Preconditions: value_type is Cpp17EmplaceConstructible into X from *i. Neither i nor j are iterators
into a.
77 Effects: Inserts each element from the range[i,j) if and only if there is no element with key equivalent
to the key of that element in containers with unique keys; always inserts that element in containers
with equivalent keys.
78 Complexity: Nlog(a.size()+ N), whereN has the valuedistance(i, j).
a.insert_range(rg)
79 Result: void
80 Preconditions: value_type is Cpp17EmplaceConstructible into X from *ranges::begin(rg). rg and a
do not overlap.
81 Effects: Inserts each element fromrg if and only if there is no element with key equivalent to the key of
that element in containers with unique keys; always inserts that element in containers with equivalent
keys.
82 Complexity: Nlog(a.size()+ N), whereN has the valueranges::distance(rg).
a.insert(il)
83 Effects: Equivalent toa.insert(il.begin(), il.end()).
a_uniq.insert(nh)
84 Result: insert_return_type
85 Preconditions: nh is empty ora_uniq.get_allocator() == nh.get_allocator() is true.
86 Effects: If nh is empty, has no effect. Otherwise, inserts the element owned bynh if and only if there is
no element in the container with a key equivalent tonh.key().
87 Returns: If nh is empty,inserted is false, position is end(), andnode is empty. Otherwise if the
insertion took place,inserted is true, position points to the inserted element, andnode is empty; if
the insertion failed,inserted is false, node has the previous value ofnh, andposition points to an
element with a key equivalent tonh.key().
88 Complexity: Logarithmic.
a_eq.insert(nh)
89 Result: iterator
90 Preconditions: nh is empty ora_eq.get_allocator() == nh.get_allocator() is true.
91 Effects: If nh is empty, has no effect and returnsa_eq.end(). Otherwise, inserts the element owned by
nh and returns an iterator pointing to the newly inserted element. If a range containing elements with
keys equivalent tonh.key() exists ina_eq, the element is inserted at the end of that range.
92 Postconditions: nh is empty.
93 Complexity: Logarithmic.
§ 23.2.7.1 © ISO/IEC
958

===== PAGE 970 =====

Dxxxx
a.insert(p, nh)
94 Result: iterator
95 Preconditions: nh is empty ora.get_allocator() == nh.get_allocator() is true.
96 Effects: If nh is empty, has no effect and returnsa.end(). Otherwise, inserts the element owned by
nh if and only if there is no element with key equivalent tonh.key() in containers with unique keys;
always inserts the element owned bynh in containers with equivalent keys. The element is inserted as
close as possible to the position just prior top.
97 Postconditions: nh is empty if insertion succeeds, unchanged if insertion fails.
98 Returns: An iterator pointing to the element with key equivalent tonh.key().
99 Complexity: Logarithmic in general, but amortized constant if the element is inserted right beforep.
a.extract(k)
100 Result: node_type
101 Effects: Removes the first element in the container with key equivalent tok.
102 Returns: A node_type owning the element if found, otherwise an emptynode_type.
103 Complexity: log(a.size())
a_tran.extract(kx)
104 Result: node_type
105 Effects: Removes the first element in the container with keyr such that!c(r, kx) && !c(kx, r) is
true.
106 Returns: A node_type owning the element if found, otherwise an emptynode_type.
107 Complexity: log(a_tran.size())
a.extract(q)
108 Result: node_type
109 Effects: Removes the element pointed to byq.
110 Returns: A node_type owning that element.
111 Complexity: Amortized constant.
a.merge(a2)
112 Result: void
113 Preconditions: a.get_allocator() == a2.get_allocator() is true.
114 Effects: Attempts to extract each element ina2 and insert it intoa using the comparison object ofa.
In containers with unique keys, if there is an element ina with key equivalent to the key of an element
from a2, then that element is not extracted froma2.
115 Postconditions: Pointers and references to the transferred elements ofa2 refer to those same elements
but as members ofa. If a.begin() and a2.begin() have the same type, iterators referring to the
transferred elements will continue to refer to their elements, but they now behave as iterators intoa,
not intoa2.
116 Throws: Nothing unless the comparison object throws.
117 Complexity: Nlog(a.size()+N), whereN has the valuea2.size().
a.erase(k)
118 Result: size_type
119 Effects: Erases all elements in the container with key equivalent tok.
120 Returns: The number of erased elements.
121 Complexity: log(a.size()) + a.count(k)
§ 23.2.7.1 © ISO/IEC
959

===== PAGE 971 =====

Dxxxx
a_tran.erase(kx)
122 Result: size_type
123 Effects: Erases all elements in the container with keyr such that!c(r, kx) && !c(kx, r) is true.
124 Returns: The number of erased elements.
125 Complexity: log(a_tran.size())+ a_tran.count(kx)
a.erase(q)
126 Result: iterator
127 Effects: Erases the element pointed to byq.
128 Returns: An iterator pointing to the element immediately followingq prior to the element being erased.
If no such element exists, returnsa.end().
129 Complexity: Amortized constant.
a.erase(r)
130 Result: iterator
131 Effects: Erases the element pointed to byr.
132 Returns: An iterator pointing to the element immediately followingr prior to the element being erased.
If no such element exists, returnsa.end().
133 Complexity: Amortized constant.
a.erase(q1, q2)
134 Result: iterator
135 Effects: Erases all the elements in the range[q1,q2).
136 Returns: An iterator pointing to the element pointed to byq2 prior to any elements being erased. If no
such element exists,a.end() is returned.
137 Complexity: log(a.size()) + N, whereN has the valuedistance(q1, q2).
a.clear()
138 Effects: Equivalent toa.erase(a.begin(), a.end()).
139 Postconditions: a.empty() is true.
140 Complexity: Linear ina.size().
b.find(k)
141 Result: iterator; const_iterator for constantb.
142 Returns: An iterator pointing to an element with the key equivalent tok, orb.end() if such an element
is not found.
143 Complexity: Logarithmic.
a_tran.find(ke)
144 Result: iterator; const_iterator for constanta_tran.
145 Returns: An iterator pointing to an element with keyr such that!c(r, ke) && !c(ke, r) is true,
or a_tran.end() if such an element is not found.
146 Complexity: Logarithmic.
b.count(k)
147 Result: size_type
148 Returns: The number of elements with key equivalent tok.
149 Complexity: log(b.size()) + b.count(k)
a_tran.count(ke)
150 Result: size_type
§ 23.2.7.1 © ISO/IEC
960

===== PAGE 972 =====

Dxxxx
151 Returns: The number of elements with keyr such that!c(r, ke) && !c(ke, r).
152 Complexity: log(a_tran.size()) + a_tran.count(ke)
b.contains(k)
153 Result: bool
154 Effects: Equivalent to:return b.find(k) != b.end();
a_tran.contains(ke)
155 Result: bool
156 Effects: Equivalent to:return a_tran.find(ke) != a_tran.end();
b.lower_bound(k)
157 Result: iterator; const_iterator for constantb.
158 Returns: An iterator pointing to the first element with key not less thank, or b.end() if such an
element is not found.
159 Complexity: Logarithmic.
a_tran.lower_bound(kl)
160 Result: iterator; const_iterator for constanta_tran.
161 Returns: An iterator pointing to the first element with keyr such that!c(r, kl), ora_tran.end() if
such an element is not found.
162 Complexity: Logarithmic.
b.upper_bound(k)
163 Result: iterator; const_iterator for constantb.
164 Returns: An iterator pointing to the first element with key greater thank, or b.end() if such an
element is not found.
165 Complexity: Logarithmic.
a_tran.upper_bound(ku)
166 Result: iterator; const_iterator for constanta_tran.
167 Returns: An iterator pointing to the first element with keyr such thatc(ku, r), ora_tran.end() if
such an element is not found.
168 Complexity: Logarithmic.
b.equal_range(k)
169 Result: pair<iterator, iterator>; pair<const_iterator, const_iterator> for constantb.
170 Effects: Equivalent to:return make_pair(b.lower_bound(k), b.upper_bound(k));
171 Complexity: Logarithmic.
a_tran.equal_range(ke)
172 Result: pair<iterator, iterator>; pair<const_iterator, const_iterator> for constanta_tran.
173 Effects: Equivalent to:return make_pair(a_tran.lower_bound(ke), a_tran.upper_bound(ke));
174 Complexity: Logarithmic.
175 The insert, insert_range, andemplace members shall not affect the validity of iterators and references to
the container, and theerase members shall invalidate only iterators and references to the erased elements.
176 The extract members invalidate only iterators to the removed element; pointers and references to the
removed element remain valid. However, accessing the element through such pointers and references while
the element is owned by anode_type is undefined behavior. References and pointers to an element obtained
while it is owned by anode_type are invalidated if the element is successfully inserted.
177 The fundamental property of iterators of associative containers is that they iterate through the containers
in the non-descending order of keys where non-descending is defined by the comparison that was used to
§ 23.2.7.1 © ISO/IEC
961

===== PAGE 973 =====

Dxxxx
construct them. For any two dereferenceable iteratorsi and j such that distance fromi to j is positive, the
following condition holds:
value_comp(*j, *i) == false
178 For associative containers with unique keys the stronger condition holds:
value_comp(*i, *j) != false
179 When an associative container is constructed by passing a comparison object the container shall not store a
pointer or reference to the passed object, even if that object is passed by reference. When an associative
container is copied, through either a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been passed
to the target container in its constructor.
180 The member function templatesfind, count, contains, lower_bound, upper_bound, equal_range, erase,
and extract shall not participate in overload resolution unless thequalified-id Compare::is_transparent is
valid and denotes a type (13.10.3). Additionally, the member function templatesextract and erase shall
not participate in overload resolution ifis_convertible_v<K&&, iterator> || is_convertible_v<K&&,
const_iterator> is true, whereK is the type substituted as the first template argument.
181 A deduction guide for an associative container shall not participate in overload resolution if any of the
following are true:
—(181.1) It has anInputIterator template parameter and a type that does not qualify as an input iterator is
deduced for that parameter.
—(181.2) It has anAllocator template parameter and a type that does not qualify as an allocator is deduced
for that parameter.
—(181.3) It has aCompare template parameter and a type that qualifies as an allocator is deduced for that
parameter.
23.2.7.2 Exception safety guarantees [associative.reqmts.except]
1 For associative containers, noclear() function throws an exception.erase(k) does not throw an exception
unless that exception is thrown by the container’sCompare object (if any).
2 For associative containers, if an exception is thrown by any operation from within aninsert or emplace
function inserting a single element, the insertion has no effect.
3 For associative containers, noswap function throws an exception unless that exception is thrown by the swap
of the container’sCompare object (if any).
23.2.8 Unordered associative containers [unord.req]
23.2.8.1 General [unord.req.general]
1 Unordered associative containers provide an ability for fast retrieval of data based on keys. The worst-case
complexity for most operations is linear, but the average case is much faster. The library provides four
unordered associative containers:unordered_set, unordered_map, unordered_multiset, andunordered_-
multimap.
2 Unordered associative containers conform to the requirements for Containers (23.2), except that the expressions
a == b and a != b have different semantics than for the other container types.
3 Each unordered associative container is parameterized byKey, by a function object typeHash that meets the
Cpp17Hash requirements (16.4.4.5) and acts as a hash function for argument values of typeKey, and by a
binary predicatePredthat induces an equivalence relation on values of typeKey. Additionally,unordered_map
and unordered_multimap associate an arbitrarymapped typeT with theKey.
4 The container’s object of typeHash — denoted byhash — is called thehash functionof the container. The
container’s object of typePred — denoted bypred — is called thekey equality predicateof the container.
5 Two valuesk1 and k2 are considered equivalent if the container’s key equality predicatepred(k1, k2) is
valid and returnstrue when passed those values. Ifk1 and k2 are equivalent, the container’s hash function
shall return the same value for both.
[Note 1: Thus, when an unordered associative container is instantiated with a non-defaultPred parameter it usually
needs a non-defaultHash parameter as well. —end note]
§ 23.2.8.1 © ISO/IEC
962

===== PAGE 974 =====

Dxxxx
For any two keysk1 and k2 in the same container, callingpred(k1, k2) shall always return the same value.
For any keyk in a container, callinghash(k) shall always return the same value.
6 An unordered associative container supportsunique keys if it may contain at most one element for each
key. Otherwise, it supports equivalent keys. unordered_set and unordered_map support unique keys.
unordered_multiset and unordered_multimap support equivalent keys. In containers that support equiva-
lent keys, elements with equivalent keys are adjacent to each other in the iteration order of the container.
Thus, although the absolute order of elements in an unordered container is not specified, its elements are
grouped intoequivalent-key groupssuch that all elements of each group have equivalent keys. Mutating
operations on unordered containers shall preserve the relative order of elements within each equivalent-key
group unless otherwise specified.
7 Forunordered_setand unordered_multisetthe value type is the same as the key type. Forunordered_map
and unordered_multimap it ispair<const Key, T>.
8 For unordered containers where the value type is the same as the key type, bothiterator and const_-
iterator are constant iterators. It is unspecified whether or notiterator and const_iterator are the
same type.
[Note 2: iterator and const_iterator have identical semantics in this case, anditerator is convertible toconst_-
iterator. Users can avoid violating the one-definition rule by always usingconst_iterator in their function
parameter lists. —end note]
9 The elements of an unordered associative container are organized intobuckets. Keys with the same hash
code appear in the same bucket. The number of buckets is automatically increased as elements are added
to an unordered associative container, so that the average number of elements per bucket is kept below
a bound. Rehashing invalidates iterators, changes ordering between elements, and changes which buckets
elements appear in, but does not invalidate pointers or references to elements. Forunordered_multiset and
unordered_multimap, rehashing preserves the relative ordering of equivalent elements.
10 In this subclause,
—(10.1) X denotes an unordered associative container class,
—(10.2) a denotes a value of typeX,
—(10.3) a2 denotes a value of a type with nodes compatible with typeX (Table 75),
—(10.4) b denotes a value of typeX or const X,
—(10.5) a_uniq denotes a value of typeX when X supports unique keys,
—(10.6) a_eq denotes a value of typeX when X supports equivalent keys,
—(10.7) a_tran denotes a value of typeX or const X when thequalified-ids X::key_equal::is_transparent
and X::hasher::is_transparent are both valid and denote types (13.10.3),
—(10.8) i and j denote input iterators that refer tovalue_type,
—(10.9) [i,j) denotes a valid range,
—(10.10) rg denotes a value of a typeR that modelscontainer-compatible-range <value_type>,
—(10.11) p and q2 denote valid constant iterators toa,
—(10.12) q and q1 denote valid dereferenceable constant iterators toa,
—(10.13) r denotes a valid dereferenceable iterator toa,
—(10.14) [q1,q2) denotes a valid range ina,
—(10.15) il denotes a value of typeinitializer_list<value_type>,
—(10.16) t denotes a value of typeX::value_type,
—(10.17) k denotes a value of typekey_type,
—(10.18) hf denotes a value of typehasher or const hasher,
—(10.19) eq denotes a value of typekey_equal or const key_equal,
—(10.20) ke is a value such that
—(10.20.1) eq(r1, ke) == eq(ke, r1),
—(10.20.2) hf(r1) == hf(ke) if eq(r1, ke) is true, and
§ 23.2.8.1 © ISO/IEC
963

===== PAGE 975 =====

Dxxxx
—(10.20.3) if any two ofeq(r1, ke), eq(r2, ke), andeq(r1, r2) are true, then all three aretrue,
where r1 and r2 are keys of elements ina_tran,
—(10.21) kx is a value such that
—(10.21.1) eq(r1, kx) == eq(kx, r1),
—(10.21.2) hf(r1) == hf(kx) if eq(r1, kx) is true,
—(10.21.3) if any two ofeq(r1, kx), eq(r2, kx), andeq(r1, r2) are true, then all three aretrue, and
—(10.21.4) kx is not convertible to eitheriterator or const_iterator,
where r1 and r2 are keys of elements ina_tran,
—(10.22) n denotes a value of typesize_type,
—(10.23) z denotes a value of typefloat, and
—(10.24) nh denotes an rvalue of typeX::node_type.
11 A type X meets the unordered associative containerrequirements if X meets all the requirements of an
allocator-aware container (23.2.2.5) and the following types, statements, and expressions are well-formed and
have the specified semantics, except that forunordered_map and unordered_multimap, the requirements
placed onvalue_type in 23.2.2.2 apply instead tokey_type and mapped_type.
[Note 3: For example, key_type and mapped_type sometimes need to beCpp17CopyAssignable even though the
associated value_type, pair<const key_type, mapped_type>, is notCpp17CopyAssignable. —end note]
typename X::key_type
12 Result: Key.
typename X::mapped_type
13 Result: T.
14 Remarks: Forunordered_map and unordered_multimap only.
typename X::value_type
15 Result: Key for unordered_set and unordered_multiset only; pair<const Key, T> for unordered_-
map and unordered_multimap only.
16 Preconditions: value_type is Cpp17Erasable from X.
typename X::hasher
17 Result: Hash.
18 Preconditions: Hash is a unary function object type such that the expressionhf(k) has typesize_t.
typename X::key_equal
19 Result: Pred.
20 Preconditions: Pred meets theCpp17CopyConstructible requirements. Pred is a binary predicate that
takes two arguments of typeKey. Pred is an equivalence relation.
typename X::local_iterator
21 Result: An iterator type whose category, value type, difference type, and pointer and reference types
are the same asX::iterator’s.
[Note 4: A local_iterator object can be used to iterate through a single bucket, but cannot be used to iterate
across buckets. —end note]
typename X::const_local_iterator
22 Result: An iterator type whose category, value type, difference type, and pointer and reference types
are the same asX::const_iterator’s.
[Note 5: A const_local_iterator object can be used to iterate through a single bucket, but cannot be used
to iterate across buckets.—end note]
§ 23.2.8.1 © ISO/IEC
964

===== PAGE 976 =====

Dxxxx
typename X::node_type
23 Result: A specialization of anode-handle class template (23.2.5), such that the public nested types
are the same types as the corresponding types inX.
X(n, hf, eq)
24 Effects: Constructs an empty container with at leastn buckets, usinghf as the hash function andeq
as the key equality predicate.
25 Complexity: O(n)
X(n, hf)
26 Preconditions: key_equal meets theCpp17DefaultConstructible requirements.
27 Effects: Constructs an empty container with at leastn buckets, usinghf as the hash function and
key_equal() as the key equality predicate.
28 Complexity: O(n)
X(n)
29 Preconditions: hasher and key_equal meet theCpp17DefaultConstructible requirements.
30 Effects: Constructs an empty container with at leastn buckets, usinghasher() as the hash function
and key_equal() as the key equality predicate.
31 Complexity: O(n)
X a = X();
X a;
32 Preconditions: hasher and key_equal meet theCpp17DefaultConstructible requirements.
33 Effects: Constructs an empty container with an unspecified number of buckets, usinghasher() as the
hash function andkey_equal() as the key equality predicate.
34 Complexity: Constant.
X(i, j, n, hf, eq)
35 Preconditions: value_type is Cpp17EmplaceConstructible into X from *i.
36 Effects: Constructs an empty container with at leastn buckets, usinghf as the hash function andeq
as the key equality predicate, and inserts elements from[i,j) into it.
37 Complexity: Average caseO(N) (N is distance(i, j)), worst caseO(N2).
X(i, j, n, hf)
38 Preconditions: key_equal meets theCpp17DefaultConstructible requirements. value_type is Cpp17-
EmplaceConstructible into X from *i.
39 Effects: Constructs an empty container with at leastn buckets, usinghf as the hash function and
key_equal() as the key equality predicate, and inserts elements from[i,j) into it.
40 Complexity: Average caseO(N) (N is distance(i, j)), worst caseO(N2).
X(i, j, n)
41 Preconditions: hasher and key_equal meet theCpp17DefaultConstructible requirements. value_type
is Cpp17EmplaceConstructible into X from *i.
42 Effects: Constructs an empty container with at leastn buckets, usinghasher() as the hash function
and key_equal() as the key equality predicate, and inserts elements from[i,j) into it.
43 Complexity: Average caseO(N) (N is distance(i, j)), worst caseO(N2).
X(i, j)
44 Preconditions: hasher and key_equal meet theCpp17DefaultConstructible requirements. value_type
is Cpp17EmplaceConstructible into X from *i.
45 Effects: Constructs an empty container with an unspecified number of buckets, usinghasher() as the
hash function andkey_equal() as the key equality predicate, and inserts elements from[i,j) into it.
§ 23.2.8.1 © ISO/IEC
965

===== PAGE 977 =====

Dxxxx
46 Complexity: Average caseO(N) (N is distance(i, j)), worst caseO(N2).
X(from_range, rg, n, hf, eq)
47 Preconditions: value_type is Cpp17EmplaceConstructible into X from *ranges::begin(rg).
48 Effects: Constructs an empty container with at leastn buckets, usinghf as the hash function andeq
as the key equality predicate, and inserts elements fromrg into it.
49 Complexity: Average caseO(N) (N is ranges::distance(rg)), worst caseO(N2).
X(from_range, rg, n, hf)
50 Preconditions: key_equal meets theCpp17DefaultConstructible requirements. value_type is Cpp17-
EmplaceConstructible into X from *ranges::begin(rg).
51 Effects: Constructs an empty container with at leastn buckets, usinghf as the hash function and
key_equal() as the key equality predicate, and inserts elements fromrg into it.
52 Complexity: Average caseO(N) (N is ranges::distance(rg)), worst caseO(N2).
X(from_range, rg, n)
53 Preconditions: hasher and key_equal meet theCpp17DefaultConstructible requirements. value_type
is Cpp17EmplaceConstructible into X from *ranges::begin(rg).
54 Effects: Constructs an empty container with at leastn buckets, usinghasher() as the hash function
and key_equal() as the key equality predicate, and inserts elements fromrg into it.
55 Complexity: Average caseO(N) (N is ranges::distance(rg)), worst caseO(N2).
X(from_range, rg)
56 Preconditions: hasher and key_equal meet theCpp17DefaultConstructible requirements. value_type
is Cpp17EmplaceConstructible into X from *ranges::begin(rg).
57 Effects: Constructs an empty container with an unspecified number of buckets, usinghasher() as the
hash function andkey_equal() as the key equality predicate, and inserts elements fromrg into it.
58 Complexity: Average caseO(N) (N is ranges::distance(rg)), worst caseO(N2).
X(il)
59 Effects: Equivalent toX(il.begin(), il.end()).
X(il, n)
60 Effects: Equivalent toX(il.begin(), il.end(), n).
X(il, n, hf)
61 Effects: Equivalent toX(il.begin(), il.end(), n, hf).
X(il, n, hf, eq)
62 Effects: Equivalent toX(il.begin(), il.end(), n, hf, eq).
X(b)
63 Effects: In addition to the container requirements (23.2.2.2), copies the hash function, predicate, and
maximum load factor.
64 Complexity: Average case linear inb.size(), worst case quadratic.
a = b
65 Result: X&
66 Effects: In addition to the container requirements, copies the hash function, predicate, and maximum
load factor.
67 Complexity: Average case linear inb.size(), worst case quadratic.
a = il
68 Result: X&
§ 23.2.8.1 © ISO/IEC
966

===== PAGE 978 =====

Dxxxx
69 Preconditions: value_type is Cpp17CopyInsertable into X and Cpp17CopyAssignable.
70 Effects: Assigns the range[il.begin(),il.end()) into a. All existing elements ofa are either assigned
to or destroyed.
71 Complexity: Average case linear inil.size(), worst case quadratic.
b.hash_function()
72 Result: hasher
73 Returns: b’s hash function.
74 Complexity: Constant.
b.key_eq()
75 Result: key_equal
76 Returns: b’s key equality predicate.
77 Complexity: Constant.
a_uniq.emplace(args)
78 Result: pair<iterator, bool>
79 Preconditions: value_type is Cpp17EmplaceConstructible into X from args.
80 Effects: Inserts avalue_type object t constructed withstd::forward<Args>(args)... if and only
if there is no element in the container with key equivalent to the key oft.
81 Returns: The bool component of the returned pair istrue if and only if the insertion takes place, and
the iterator component of the pair points to the element with key equivalent to the key oft.
82 Complexity: Average caseO(1), worst caseO(a_uniq.size()).
a_eq.emplace(args)
83 Result: iterator
84 Preconditions: value_type is Cpp17EmplaceConstructible into X from args.
85 Effects: Inserts avalue_type object t constructed withstd::forward<Args>(args)....
86 Returns: An iterator pointing to the newly inserted element.
87 Complexity: Average caseO(1), worst caseO(a_eq.size()).
a.emplace_hint(p, args)
88 Result: iterator
89 Effects: Equivalent toa.emplace(std::forward<Args>(args)...), except that theconst_iterator
p is a hint pointing to where the search should start. Implementations are permitted to ignore the hint.
90 Returns: The iterator returned byemplace.
a_uniq.insert(t)
91 Result: pair<iterator, bool>
92 Preconditions: If t is a non-const rvalue, value_type is Cpp17MoveInsertable into X; otherwise,
value_type is Cpp17CopyInsertable into X.
93 Effects: Inserts t if and only if there is no element in the container with key equivalent to the key oft.
94 Returns: The bool component of the returned pair indicates whether the insertion takes place, and the
iterator component points to the element with key equivalent to the key oft.
95 Complexity: Average caseO(1), worst caseO(a_uniq.size()).
a_eq.insert(t)
96 Result: iterator
97 Preconditions: If t is a non-const rvalue, value_type is Cpp17MoveInsertable into X; otherwise,
value_type is Cpp17CopyInsertable into X.
98 Effects: Inserts t.
§ 23.2.8.1 © ISO/IEC
967

===== PAGE 979 =====

Dxxxx
99 Returns: An iterator pointing to the newly inserted element.
100 Complexity: Average caseO(1), worst caseO(a_eq.size()).
a.insert(p, t)
101 Result: iterator
102 Preconditions: If t is a non-const rvalue, value_type is Cpp17MoveInsertable into X; otherwise,
value_type is Cpp17CopyInsertable into X.
103 Effects: Equivalent toa.insert(t). The iteratorp is a hint pointing to where the search should start.
Implementations are permitted to ignore the hint.
104 Returns: An iterator pointing to the element with the key equivalent to that oft.
105 Complexity: Average caseO(1), worst caseO(a.size()).
a.insert(i, j)
106 Result: void
107 Preconditions: value_type is Cpp17EmplaceConstructible into X from *i. Neither i nor j are iterators
into a.
108 Effects: Equivalent toa.insert(t) for each element in[i,j).
109 Complexity: Average caseO(N), whereN is distance(i, j), worst caseO(N(a.size()+ 1)).
a.insert_range(rg)
110 Result: void
111 Preconditions: value_type is Cpp17EmplaceConstructible into X from *ranges::begin(rg). rg and a
do not overlap.
112 Effects: Equivalent toa.insert(t) for each elementt in rg.
113 Complexity: Average caseO(N), whereN is ranges::distance(rg), worst caseO(N(a.size()+ 1)).
a.insert(il)
114 Effects: Equivalent toa.insert(il.begin(), il.end()).
a_uniq.insert(nh)
115 Result: insert_return_type
116 Preconditions: nh is empty ora_uniq.get_allocator() == nh.get_allocator() is true.
117 Effects: If nh is empty, has no effect. Otherwise, inserts the element owned bynh if and only if there is
no element in the container with a key equivalent tonh.key().
118 Postconditions: If nh is empty,inserted is false, position is end(), andnode is empty. Otherwise
if the insertion took place,inserted is true, position points to the inserted element, andnode is
empty; if the insertion failed,inserted is false, node has the previous value ofnh, andposition
points to an element with a key equivalent tonh.key().
119 Complexity: Average caseO(1), worst caseO(a_uniq.size()).
a_eq.insert(nh)
120 Result: iterator
121 Preconditions: nh is empty ora_eq.get_allocator() == nh.get_allocator() is true.
122 Effects: If nh is empty, has no effect and returnsa_eq.end(). Otherwise, inserts the element owned by
nh and returns an iterator pointing to the newly inserted element.
123 Postconditions: nh is empty.
124 Complexity: Average caseO(1), worst caseO(a_eq.size()).
a.insert(q, nh)
125 Result: iterator
126 Preconditions: nh is empty ora.get_allocator() == nh.get_allocator() is true.
§ 23.2.8.1 © ISO/IEC
968

===== PAGE 980 =====

Dxxxx
127 Effects: If nh is empty, has no effect and returnsa.end(). Otherwise, inserts the element owned by
nh if and only if there is no element with key equivalent tonh.key() in containers with unique keys;
always inserts the element owned bynh in containers with equivalent keys. The iteratorq is a hint
pointing to where the search should start. Implementations are permitted to ignore the hint.
128 Postconditions: nh is empty if insertion succeeds, unchanged if insertion fails.
129 Returns: An iterator pointing to the element with key equivalent tonh.key().
130 Complexity: Average caseO(1), worst caseO(a.size()).
a.extract(k)
131 Result: node_type
132 Effects: Removes an element in the container with key equivalent tok.
133 Returns: A node_type owning the element if found, otherwise an emptynode_type.
134 Complexity: Average caseO(1), worst caseO(a.size()).
a_tran.extract(kx)
135 Result: node_type
136 Effects: Removes an element in the container with key equivalent tokx.
137 Returns: A node_type owning the element if found, otherwise an emptynode_type.
138 Complexity: Average caseO(1), worst caseO(a_tran.size()).
a.extract(q)
139 Result: node_type
140 Effects: Removes the element pointed to byq.
141 Returns: A node_type owning that element.
142 Complexity: Average caseO(1), worst caseO(a.size()).
a.merge(a2)
143 Result: void
144 Preconditions: a.get_allocator() == a2.get_allocator().
145 Effects: Attempts to extract each element ina2 and insert it intoa using the hash function and key
equality predicate ofa. In containers with unique keys, if there is an element ina with key equivalent
to the key of an element froma2, then that element is not extracted froma2.
146 Postconditions: Pointers and references to the transferred elements ofa2 refer to those same elements
but as members ofa. Iterators referring to the transferred elements and all iterators referring toa will
be invalidated, but iterators to elements remaining ina2 will remain valid.
147 Complexity: Average caseO(N), whereN is a2.size(), worst caseO(N*a.size() + N).
a.erase(k)
148 Result: size_type
149 Effects: Erases all elements with key equivalent tok.
150 Returns: The number of elements erased.
151 Complexity: Average caseO(a.count(k)), worst caseO(a.size()).
a_tran.erase(kx)
152 Result: size_type
153 Effects: Erases all elements with key equivalent tokx.
154 Returns: The number of elements erased.
155 Complexity: Average caseO(a_tran.count(kx)), worst caseO(a_tran.size()).
a.erase(q)
156 Result: iterator
§ 23.2.8.1 © ISO/IEC
969

===== PAGE 981 =====

Dxxxx
157 Effects: Erases the element pointed to byq.
158 Returns: The iterator immediately followingq prior to the erasure.
159 Complexity: Average caseO(1), worst caseO(a.size()).
a.erase(r)
160 Result: iterator
161 Effects: Erases the element pointed to byr.
162 Returns: The iterator immediately followingr prior to the erasure.
163 Complexity: Average caseO(1), worst caseO(a.size()).
a.erase(q1, q2)
164 Result: iterator
165 Effects: Erases all elements in the range[q1,q2).
166 Returns: The iterator immediately following the erased elements prior to the erasure.
167 Complexity: Average case linear indistance(q1, q2), worst caseO(a.size()).
a.clear()
168 Result: void
169 Effects: Erases all elements in the container.
170 Postconditions: a.empty() is true.
171 Complexity: Linear ina.size().
b.find(k)
172 Result: iterator; const_iterator for constantb.
173 Returns: An iterator pointing to an element with key equivalent tok, orb.end() if no such element
exists.
174 Complexity: Average caseO(1), worst caseO(b.size()).
a_tran.find(ke)
175 Result: iterator; const_iterator for constanta_tran.
176 Returns: An iterator pointing to an element with key equivalent toke, ora_tran.end() if no such
element exists.
177 Complexity: Average caseO(1), worst caseO(a_tran.size()).
b.count(k)
178 Result: size_type
179 Returns: The number of elements with key equivalent tok.
180 Complexity: Average caseO(b.count(k)), worst caseO(b.size()).
a_tran.count(ke)
181 Result: size_type
182 Returns: The number of elements with key equivalent toke.
183 Complexity: Average caseO(a_tran.count(ke)), worst caseO(a_tran.size()).
b.contains(k)
184 Effects: Equivalent tob.find(k) != b.end().
a_tran.contains(ke)
185 Effects: Equivalent toa_tran.find(ke) != a_tran.end().
b.equal_range(k)
186 Result: pair<iterator, iterator>; pair<const_iterator, const_iterator> for constantb.
§ 23.2.8.1 © ISO/IEC
970

===== PAGE 982 =====

Dxxxx
187 Returns: A range containing all elements with keys equivalent tok. Returns make_pair(b.end(),
b.end()) if no such elements exist.
188 Complexity: Average caseO(b.count(k)), worst caseO(b.size()).
a_tran.equal_range(ke)
189 Result: pair<iterator, iterator>; pair<const_iterator, const_iterator> for constanta_tran.
190 Returns: Arangecontainingallelementswithkeysequivalentto ke. Returnsmake_pair(a_tran.end(),
a_tran.end()) if no such elements exist.
191 Complexity: Average caseO(a_tran.count(ke)), worst caseO(a_tran.size()).
b.bucket_count()
192 Result: size_type
193 Returns: The number of buckets thatb contains.
194 Complexity: Constant.
b.max_bucket_count()
195 Result: size_type
196 Returns: An upper bound on the number of buckets thatb can ever contain.
197 Complexity: Constant.
b.bucket(k)
198 Result: size_type
199 Preconditions: b.bucket_count() > 0.
200 Returns: The index of the bucket in which elements with keys equivalent tok would be found, if any
such element existed. The return value is in the range[0,b.bucket_count()).
201 Complexity: Constant.
a_tran.bucket(ke)
202 Result: size_type
203 Preconditions: a_tran.bucket_count() > 0.
204 Postconditions: The return value is in the range[0,a_tran.bucket_count()).
205 Returns: The index of the bucket in which elements with keys equivalent toke would be found, if any
such element existed.
206 Complexity: Constant.
b.bucket_size(n)
207 Result: size_type
208 Preconditions: n shall be in the range[0,b.bucket_count()).
209 Returns: The number of elements in thenth bucket.
210 Complexity: O(b.bucket_size(n))
b.begin(n)
211 Result: local_iterator; const_local_iterator for constantb.
212 Preconditions: n is in the range[0,b.bucket_count()).
213 Returns: An iterator referring to the first element in the bucket. If the bucket is empty, thenb.begin(n)
== b.end(n).
214 Complexity: Constant.
b.end(n)
215 Result: local_iterator; const_local_iterator for constantb.
216 Preconditions: n is in the range[0,b.bucket_count()).
§ 23.2.8.1 © ISO/IEC
971

===== PAGE 983 =====

Dxxxx
217 Returns: An iterator which is the past-the-end value for the bucket.
218 Complexity: Constant.
b.cbegin(n)
219 Result: const_local_iterator
220 Preconditions: n shall be in the range[0,b.bucket_count()).
221 Returns: An iterator referring to the first element in the bucket. If the bucket is empty, then
b.cbegin(n) == b.cend(n).
222 Complexity: Constant.
b.cend(n)
223 Result: const_local_iterator
224 Preconditions: n is in the range[0,b.bucket_count()).
225 Returns: An iterator which is the past-the-end value for the bucket.
226 Complexity: Constant.
b.load_factor()
227 Result: float
228 Returns: The average number of elements per bucket.
229 Complexity: Constant.
b.max_load_factor()
230 Result: float
231 Returns: A positive number that the container attempts to keep the load factor less than or equal to.
The container automatically increases the number of buckets as necessary to keep the load factor below
this number.
232 Complexity: Constant.
a.max_load_factor(z)
233 Result: void
234 Preconditions: z is positive. May change the container’s maximum load factor, usingz as a hint.
235 Complexity: Constant.
a.rehash(n)
236 Result: void
237 Postconditions: a.bucket_count() >= a.size() / a.max_load_factor() and a.bucket_count()
>= n.
238 Complexity: Average case linear ina.size(), worst case quadratic.
a.reserve(n)
239 Effects: Equivalent toa.rehash(ceil(n / a.max_load_factor())).
240 Two unordered containersa and b compare equal if a.size() == b.size() and, for every equivalent-
key group[Ea1,Ea2) obtained froma.equal_range(Ea1), there exists an equivalent-key group[Eb1,Eb2)
obtained fromb.equal_range(Ea1), such thatis_permutation(Ea1, Ea2, Eb1, Eb2) returns true. For
unordered_set and unordered_map, the complexity ofoperator== (i.e., the number of calls to the==
operator of thevalue_type, to the predicate returned bykey_eq(), and to the hasher returned byhash_-
function()) is proportional toN in the average case and toN2 in the worst case, whereN is a.size(). For
unordered_multiset and unordered_multimap, the complexity ofoperator== is proportional to∑ E2
i in
the average case and toN2 in the worst case, whereN is a.size(), andEi is the size of theith equivalent-key
group ina. However, if the respective elements of each corresponding pair of equivalent-key groupsEai and
Ebi are arranged in the same order (as is commonly the case, e.g., ifa and b are unmodified copies of the same
container), then the average-case complexity forunordered_multiset and unordered_multimap becomes
proportional toN (but worst-case complexity remainsO(N2), e.g., for a pathologically bad hash function).
§ 23.2.8.1 © ISO/IEC
972

===== PAGE 984 =====

Dxxxx
The behavior of a program that usesoperator== or operator!= on unordered containers is undefined unless
the Pred function object has the same behavior for both containers and the equality comparison function for
Key is a refinement186 of the partition into equivalent-key groups produced byPred.
241 The iterator typesiterator and const_iterator of an unordered associative container are of at least the
forward iterator category. For unordered associative containers where the key type and value type are the
same, bothiterator and const_iterator are constant iterators.
242 The insert, insert_range, andemplace members shall not affect the validity of references to container
elements, but may invalidate all iterators to the container. Theerase members shall invalidate only iterators
and references to the erased elements, and preserve the relative order of the elements that are not erased.
243 The insert, insert_range, andemplace members shall not affect the validity of iterators if(N + n) <= z
* B, whereN is the number of elements in the container prior to the insert operation,n is the number of
elements inserted,B is the container’s bucket count, andz is the container’s maximum load factor.
244 The extract members invalidate only iterators to the removed element, and preserve the relative order of
the elements that are not erased; pointers and references to the removed element remain valid. However,
accessing the element through such pointers and references while the element is owned by anode_type is
undefined behavior. References and pointers to an element obtained while it is owned by anode_type are
invalidated if the element is successfully inserted.
245 The member function templatesfind, count, equal_range, contains, extract, erase, andbucketshall not
participate in overload resolution unless thequalified-ids Pred::is_transparentand Hash::is_transparent
are both valid and denote types (13.10.3). Additionally, the member function templatesextract and erase
shall not participate in overload resolution ifis_convertible_v<K&&, iterator> || is_convertible_-
v<K&&, const_iterator> is true, whereK is the type substituted as the first template argument.
246 A deduction guide for an unordered associative container shall not participate in overload resolution if any of
the following are true:
—(246.1) It has anInputIterator template parameter and a type that does not qualify as an input iterator is
deduced for that parameter.
—(246.2) It has anAllocator template parameter and a type that does not qualify as an allocator is deduced
for that parameter.
—(246.3) It has aHash template parameter and an integral type or a type that qualifies as an allocator is deduced
for that parameter.
—(246.4) It has aPred template parameter and a type that qualifies as an allocator is deduced for that parameter.
23.2.8.2 Exception safety guarantees [unord.req.except]
1 For unordered associative containers, noclear() function throws an exception.erase(k) does not throw an
exception unless that exception is thrown by the container’sHash or Pred object (if any).
2 For unordered associative containers, if an exception is thrown by any operation other than the container’s
hash function from within aninsert or emplace function inserting a single element, the insertion has no
effect.
3 For unordered associative containers, noswap function throws an exception unless that exception is thrown
by the swap of the container’sHash or Pred object (if any).
4 For unordered associative containers, if an exception is thrown from within arehash() function other than
by the container’s hash function or comparison function, therehash() function has no effect.
23.3 Sequence containers [sequences]
23.3.1 General [sequences.general]
1 The headers <array> (23.3.2), <deque> (23.3.4), <forward_list> (23.3.6), <hive> (23.3.8), <inplace_-
vector>(23.3.15), <list>(23.3.10), and<vector>(23.3.12) define class templates that meet the requirements
for sequence containers.
2 The following exposition-only alias template may appear in deduction guides for sequence containers:
template<class InputIterator>
using iter-value-type = iterator_traits<InputIterator>::value_type; // exposition only
186) Equality comparison is a refinement of partitioning if no two objects that compare equal fall into different partitions.
§ 23.3.1 © ISO/IEC
973

===== PAGE 985 =====

Dxxxx
23.3.2 Header <array> synopsis [array.syn]
// mostly freestanding
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.3.3, class templatearray
template<class T, size_t N> struct array; // partially freestanding
template<class T, size_t N>
constexpr bool operator==(const array<T, N>& x, const array<T, N>& y);
template<class T, size_t N>
constexpr synth-three-way-result <T>
operator<=>(const array<T, N>& x, const array<T, N>& y);
// 23.3.3.4, specialized algorithms
template<class T, size_t N>
constexpr void swap(array<T, N>& x, array<T, N>& y) noexcept(noexcept(x.swap(y)));
// 23.3.3.6, array creation functions
template<class T, size_t N>
constexpr array<remove_cv_t<T>, N> to_array(T (&a)[N]);
template<class T, size_t N>
constexpr array<remove_cv_t<T>, N> to_array(T (&&a)[N]);
// 23.3.3.7, tuple interface
template<class T> struct tuple_size;
template<size_t I, class T> struct tuple_element;
template<class T, size_t N>
struct tuple_size<array<T, N>>;
template<size_t I, class T, size_t N>
struct tuple_element<I, array<T, N>>;
template<size_t I, class T, size_t N>
constexpr T& get(array<T, N>&) noexcept;
template<size_t I, class T, size_t N>
constexpr T&& get(array<T, N>&&) noexcept;
template<size_t I, class T, size_t N>
constexpr const T& get(const array<T, N>&) noexcept;
template<size_t I, class T, size_t N>
constexpr const T&& get(const array<T, N>&&) noexcept;
}
23.3.3 Class template array [array]
23.3.3.1 Overview [array.overview]
1 The header <array> defines a class template for storing fixed-size sequences of objects. Anarray is a
contiguous container (23.2.2.2). An instance ofarray<T, N> stores N elements of typeT, so thatsize() ==
N is an invariant.
2 An array is an aggregate (9.5.2) that can be list-initialized with up toN elements whose types are convertible
to T.
3 An array meets all of the requirements of a container (23.2.2.2) and of a reversible container (23.2.2.3), except
that a default constructedarray object is not empty ifN >0. An array meets some of the requirements
of a sequence container (23.2.4). Descriptions are provided here only for operations onarray that are not
described in one of these tables and for operations where there is additional semantic information.
4 array<T, N> is a structural type (13.2) ifT is a structural type. Two valuesa1 and a2 of typearray<T, N>
are template-argument-equivalent (13.6) if and only if each pair of corresponding elements ina1 and a2 are
template-argument-equivalent.
5 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
§ 23.3.3.1 © ISO/IEC
974

===== PAGE 986 =====

Dxxxx
namespace std {
template<class T, size_t N>
struct array {
// types
using value_type = T;
using pointer = T*;
using const_pointer = const T*;
using reference = T&;
using const_reference = const T&;
using size_type = size_t;
using difference_type = ptrdiff_t;
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
// no explicit construct/copy/destroy for aggregate type
constexpr void fill(const T& u);
constexpr void swap(array&) noexcept(is_nothrow_swappable_v<T>);
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
constexpr size_type max_size() const noexcept;
// element access
constexpr reference operator[](size_type n);
constexpr const_reference operator[](size_type n) const;
constexpr reference at(size_type n); // freestanding-deleted
constexpr const_reference at(size_type n) const; // freestanding-deleted
constexpr reference front();
constexpr const_reference front() const;
constexpr reference back();
constexpr const_reference back() const;
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
};
template<class T, class... U>
array(T, U...) -> array<T, 1 + sizeof...(U)>;
}
23.3.3.2 Constructors, copy, and assignment [array.cons]
1 An array relies on the implicitly-declared special member functions (11.4.5.2, 11.4.7, 11.4.5.3) to conform
to the container requirements table in 23.2. In addition to the requirements specified in the container
§ 23.3.3.2 © ISO/IEC
975

===== PAGE 987 =====

Dxxxx
requirements table, the implicitly-declared move constructor and move assignment operator forarray require
that T be Cpp17MoveConstructible or Cpp17MoveAssignable, respectively.
template<class T, class... U>
array(T, U...) -> array<T, 1 + sizeof...(U)>;
2 Mandates: (is_same_v<T, U> && ...) is true.
23.3.3.3 Member functions [array.members]
constexpr size_type size() const noexcept;
1 Returns: N.
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
2 Returns: A pointer such that[data(),data() + size()) is a valid range. For a non-empty array,
data() == addressof(front()) is true.
constexpr void fill(const T& u);
3 Effects: As if byfill_n(begin(), N, u).
constexpr void swap(array& y) noexcept(is_nothrow_swappable_v<T>);
4 Effects: Equivalent toswap_ranges(begin(), end(), y.begin()).
5 [Note 1: Unlike theswap function for other containers,array::swap takes linear time, can exit via an exception,
and does not cause iterators to become associated with the other container.—end note]
23.3.3.4 Specialized algorithms [array.special]
template<class T, size_t N>
constexpr void swap(array<T, N>& x, array<T, N>& y) noexcept(noexcept(x.swap(y)));
1 Constraints: N == 0 or is_swappable_v<T> is true.
2 Effects: As if byx.swap(y).
3 Complexity: Linear inN.
23.3.3.5 Zero-sized arrays [array.zero]
1 array shall provide support for the special caseN == 0.
2 In the case thatN == 0, begin() == end() == unique value. The return value ofdata() is unspecified.
3 Member functionswap() shall have a non-throwing exception specification.
23.3.3.6 Array creation functions [array.creation]
template<class T, size_t N>
constexpr array<remove_cv_t<T>, N> to_array(T (&a)[N]);
1 Mandates: is_array_v<T> is false and is_constructible_v<remove_cv_t<T>, T&> is true.
2 Preconditions: T meets theCpp17CopyConstructible requirements.
3 Returns: {{ a[0], ... , a[N - 1] }}.
template<class T, size_t N>
constexpr array<remove_cv_t<T>, N> to_array(T (&&a)[N]);
4 Mandates: is_array_v<T> is false and is_constructible_v<remove_cv_t<T>, T> is true.
5 Preconditions: T meets theCpp17MoveConstructible requirements.
6 Returns: {{ std::move(a[0]), ... , std::move(a[N - 1]) }}.
23.3.3.7 Tuple interface [array.tuple]
template<class T, size_t N>
struct tuple_size<array<T, N>> : integral_constant<size_t, N> { };
§ 23.3.3.7 © ISO/IEC
976

===== PAGE 988 =====

Dxxxx
template<size_t I, class T, size_t N>
struct tuple_element<I, array<T, N>> {
using type = T;
};
1 Mandates: I < N is true.
template<size_t I, class T, size_t N>
constexpr T& get(array<T, N>& a) noexcept;
template<size_t I, class T, size_t N>
constexpr T&& get(array<T, N>&& a) noexcept;
template<size_t I, class T, size_t N>
constexpr const T& get(const array<T, N>& a) noexcept;
template<size_t I, class T, size_t N>
constexpr const T&& get(const array<T, N>&& a) noexcept;
2 Mandates: I < N is true.
3 Returns: A reference to theIth element ofa, where indexing is zero-based.
23.3.4 Header <deque> synopsis [deque.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.3.5, class templatedeque
template<class T, class Allocator = allocator<T>> class deque;
template<class T, class Allocator>
constexpr bool operator==(const deque<T, Allocator>& x, const deque<T, Allocator>& y);
template<class T, class Allocator>
constexpr synth-three-way-result <T>
operator<=>(const deque<T, Allocator>& x, const deque<T, Allocator>& y);
template<class T, class Allocator>
constexpr void swap(deque<T, Allocator>& x, deque<T, Allocator>& y)
noexcept(noexcept(x.swap(y)));
// 23.3.5.5, erasure
template<class T, class Allocator, class U = T>
constexpr typename deque<T, Allocator>::size_type
erase(deque<T, Allocator>& c, const U& value);
template<class T, class Allocator, class Predicate>
constexpr typename deque<T, Allocator>::size_type
erase_if(deque<T, Allocator>& c, Predicate pred);
namespace pmr {
template<class T>
using deque = std::deque<T, polymorphic_allocator<T>>;
}
}
23.3.5 Class template deque [deque]
23.3.5.1 Overview [deque.overview]
1 A deque is a sequence container that supports random access iterators (24.3.5.7). In addition, it supports
constant time insert and erase operations at the beginning or the end; insert and erase in the middle take
linear time. That is, a deque is especially optimized for pushing and popping elements at the beginning and
end. Storage management is handled automatically.
2 A deque meets all of the requirements of a container (23.2.2.2), of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), and of a sequence container, including the optional sequence container
requirements (23.2.4). Descriptions are provided here only for operations ondeque that are not described in
one of these tables or for operations where there is additional semantic information.
3 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
§ 23.3.5.1 © ISO/IEC
977

===== PAGE 989 =====

Dxxxx
namespace std {
template<class T, class Allocator = allocator<T>>
class deque {
public:
// types
using value_type = T;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
// 23.3.5.2, construct/copy/destroy
constexpr deque() : deque(Allocator()) { }
constexpr explicit deque(const Allocator&);
constexpr explicit deque(size_type n, const Allocator& = Allocator());
constexpr deque(size_type n, const T& value, const Allocator& = Allocator());
template<class InputIterator>
constexpr deque(InputIterator first, InputIterator last, const Allocator& = Allocator());
template<container-compatible-range <T> R>
constexpr deque(from_range_t, R&& rg, const Allocator& = Allocator());
constexpr deque(const deque& x);
constexpr deque(deque&&);
constexpr deque(const deque&, const type_identity_t<Allocator>&);
constexpr deque(deque&&, const type_identity_t<Allocator>&);
constexpr deque(initializer_list<T>, const Allocator& = Allocator());
constexpr ~deque();
constexpr deque& operator=(const deque& x);
constexpr deque& operator=(deque&& x)
noexcept(allocator_traits<Allocator>::is_always_equal::value);
constexpr deque& operator=(initializer_list<T>);
template<class InputIterator>
constexpr void assign(InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr void assign_range(R&& rg);
constexpr void assign(size_type n, const T& t);
constexpr void assign(initializer_list<T>);
constexpr allocator_type get_allocator() const noexcept;
// iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// 23.3.5.3, capacity
constexpr bool empty() const noexcept;
constexpr size_type size() const noexcept;
§ 23.3.5.1 © ISO/IEC
978

===== PAGE 990 =====

Dxxxx
constexpr size_type max_size() const noexcept;
constexpr void resize(size_type sz);
constexpr void resize(size_type sz, const T& c);
constexpr void shrink_to_fit();
// element access
constexpr reference operator[](size_type n);
constexpr const_reference operator[](size_type n) const;
constexpr reference at(size_type n);
constexpr const_reference at(size_type n) const;
constexpr reference front();
constexpr const_reference front() const;
constexpr reference back();
constexpr const_reference back() const;
// 23.3.5.4, modifiers
template<class... Args> constexpr reference emplace_front(Args&&... args);
template<class... Args> constexpr reference emplace_back(Args&&... args);
template<class... Args> constexpr iterator emplace(const_iterator position, Args&&... args);
constexpr void push_front(const T& x);
constexpr void push_front(T&& x);
template<container-compatible-range <T> R>
constexpr void prepend_range(R&& rg);
constexpr void push_back(const T& x);
constexpr void push_back(T&& x);
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg);
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position,
InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list<T>);
constexpr void pop_front();
constexpr void pop_back();
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void swap(deque&)
noexcept(allocator_traits<Allocator>::is_always_equal::value);
constexpr void clear() noexcept;
};
template<class InputIterator, class Allocator = allocator<iter-value-type <InputIterator>>>
deque(InputIterator, InputIterator, Allocator = Allocator())
-> deque<iter-value-type <InputIterator>, Allocator>;
template<ranges::input_range R, class Allocator = allocator<ranges::range_value_t<R>>>
deque(from_range_t, R&&, Allocator = Allocator())
-> deque<ranges::range_value_t<R>, Allocator>;
}
23.3.5.2 Constructors, copy, and assignment [deque.cons]
constexpr explicit deque(const Allocator&);
1 Effects: Constructs an emptydeque, using the specified allocator.
2 Complexity: Constant.
§ 23.3.5.2 © ISO/IEC
979

===== PAGE 991 =====

Dxxxx
constexpr explicit deque(size_type n, const Allocator& = Allocator());
3 Preconditions: T is Cpp17DefaultInsertable into deque.
4 Effects: Constructs adeque with n default-inserted elements using the specified allocator.
5 Complexity: Linear inn.
constexpr deque(size_type n, const T& value, const Allocator& = Allocator());
6 Preconditions: T is Cpp17CopyInsertable into deque.
7 Effects: Constructs adeque with n copies ofvalue, using the specified allocator.
8 Complexity: Linear inn.
template<class InputIterator>
constexpr deque(InputIterator first, InputIterator last, const Allocator& = Allocator());
9 Effects: Constructs adeque equal to the range[first,last), using the specified allocator.
10 Complexity: Linear indistance(first, last).
template<container-compatible-range <T> R>
constexpr deque(from_range_t, R&& rg, const Allocator& = Allocator());
11 Effects: Constructs adeque with the elements of the rangerg, using the specified allocator.
12 Complexity: Linear inranges::distance(rg).
23.3.5.3 Capacity [deque.capacity]
constexpr void resize(size_type sz);
1 Preconditions: T is Cpp17MoveInsertable and Cpp17DefaultInsertable into deque.
2 Effects: If sz < size(), erases the lastsize() - sz elements from the sequence. Otherwise, appends
sz - size() default-inserted elements to the sequence.
constexpr void resize(size_type sz, const T& c);
3 Preconditions: T is Cpp17CopyInsertable into deque.
4 Effects: If sz < size(), erases the lastsize() - sz elements from the sequence. Otherwise, appends
sz - size() copies ofc to the sequence.
constexpr void shrink_to_fit();
5 Preconditions: T is Cpp17MoveInsertable into deque.
6 Effects: shrink_to_fit is a non-binding request to reduce memory use but does not change the size of
the sequence.
[Note 1: The request is non-binding to allow latitude for implementation-specific optimizations.—end note]
If the size is equal to the old capacity, or if an exception is thrown other than by the move constructor
of a non-Cpp17CopyInsertable T, then there are no effects.
7 Complexity: If the size is not equal to the old capacity, linear in the size of the sequence; otherwise
constant.
8 Remarks: If the size is not equal to the old capacity, then invalidates all the references, pointers, and
iterators referring to the elements in the sequence, as well as the past-the-end iterator.
23.3.5.4 Modifiers [deque.modifiers]
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert(const_iterator position,
InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr iterator insert_range(const_iterator position, R&& rg);
§ 23.3.5.4 © ISO/IEC
980

===== PAGE 992 =====

Dxxxx
constexpr iterator insert(const_iterator position, initializer_list<T>);
template<class... Args> constexpr reference emplace_front(Args&&... args);
template<class... Args> constexpr reference emplace_back(Args&&... args);
template<class... Args> constexpr iterator emplace(const_iterator position, Args&&... args);
constexpr void push_front(const T& x);
constexpr void push_front(T&& x);
template<container-compatible-range <T> R>
constexpr void prepend_range(R&& rg);
constexpr void push_back(const T& x);
constexpr void push_back(T&& x);
template<container-compatible-range <T> R>
constexpr void append_range(R&& rg);
1 Effects: An insertion in the middle of the deque invalidates all the iterators and references to elements
of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has
no effect on the validity of references to elements of the deque.
2 Complexity: The complexity is linear in the number of elements inserted plus the lesser of the distances
to the beginning and end of the deque. Inserting a single element at either the beginning or end of a
deque always takes constant time and causes a single call to a constructor ofT.
3 Remarks: If an exception is thrown other than by the copy constructor, move constructor, assignment
operator, or move assignment operator ofT, there are no effects. If an exception is thrown while
inserting a single element at either end, there are no effects. Otherwise, if an exception is thrown by
the move constructor of a non-Cpp17CopyInsertable T, the effects are unspecified.
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_front();
constexpr void pop_back();
4 Effects: An erase operation that erases the last element of a deque invalidates only the past-the-end
iterator and all iterators and references to the erased elements. An erase operation that erases the
first element of a deque but not the last element invalidates only iterators and references to the erased
elements. An erase operation that erases neither the first element nor the last element of a deque
invalidates the past-the-end iterator and all iterators and references to all the elements of the deque.
[Note 1: pop_front and pop_back are erase operations. —end note]
5 Throws: Nothing unless an exception is thrown by the assignment operator ofT.
6 Complexity: The number of calls to the destructor ofT is the same as the number of elements erased,
but the number of calls to the assignment operator ofT is no more than the lesser of the number of
elements before the erased elements and the number of elements after the erased elements.
23.3.5.5 Erasure [deque.erasure]
template<class T, class Allocator, class U = T>
constexpr typename deque<T, Allocator>::size_type
erase(deque<T, Allocator>& c, const U& value);
1 Effects: Equivalent to:
auto it = remove(c.begin(), c.end(), value);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
template<class T, class Allocator, class Predicate>
constexpr typename deque<T, Allocator>::size_type
erase_if(deque<T, Allocator>& c, Predicate pred);
2 Effects: Equivalent to:
auto it = remove_if(c.begin(), c.end(), pred);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
§ 23.3.5.5 © ISO/IEC
981

===== PAGE 993 =====

Dxxxx
23.3.6 Header <forward_list> synopsis [forward.list.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 23.3.7, class templateforward_list
template<class T, class Allocator = allocator<T>> class forward_list;
template<class T, class Allocator>
constexpr bool operator==(const forward_list<T, Allocator>& x,
const forward_list<T, Allocator>& y);
template<class T, class Allocator>
constexpr synth-three-way-result <T>
operator<=>(const forward_list<T, Allocator>& x,
const forward_list<T, Allocator>& y);
template<class T, class Allocator>
constexpr void swap(forward_list<T, Allocator>& x, forward_list<T, Allocator>& y)
noexcept(noexcept(x.swap(y)));
// 23.3.7.7, erasure
template<class T, class Allocator, class U = T>
constexpr typename forward_list<T, Allocator>::size_type
erase(forward_list<T, Allocator>& c, const U& value);
template<class T, class Allocator, class Predicate>
constexpr typename forward_list<T, Allocator>::size_type
erase_if(forward_list<T, Allocator>& c, Predicate pred);
namespace pmr {
template<class T>
using forward_list = std::forward_list<T, polymorphic_allocator<T>>;
}
}
23.3.7 Class template forward_list [forward.list]
23.3.7.1 Overview [forward.list.overview]
1 A forward_list is a container that supports forward iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled automatically. Fast random
access to list elements is not supported.
[Note 1: It is intended thatforward_list have zero space or time overhead relative to a hand-written C-style singly
linked list. Features that would conflict with that goal have been omitted.—end note]
2 A forward_list meets all of the requirements of a container (23.2.2.2), except that thesize() member
function is not provided andoperator== has linear complexity. A forward_list also meets all of the
requirements for an allocator-aware container (23.2.2.5). In addition, aforward_list provides theassign
member functions and several of the optional sequence container requirements (23.2.4). Descriptions are
provided here only for operations onforward_list that are not described in that table or for operations
where there is additional semantic information.
3 [Note 2: Modifying any list requires access to the element preceding the first element of interest, but in aforward_list
there is no constant-time way to access a preceding element. For this reason,erase_after and splice_after take
fully-open ranges, not semi-open ranges.—end note]
4 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
namespace std {
template<class T, class Allocator = allocator<T>>
class forward_list {
public:
// types
using value_type = T;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
§ 23.3.7.1 © ISO/IEC
982

===== PAGE 994 =====

Dxxxx
using reference = value_type&;
using const_reference = const value_type&;
using size_type = implementation-defined ; // see 23.2
using difference_type = implementation-defined ; // see 23.2
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
// 23.3.7.2, construct/copy/destroy
constexpr forward_list() : forward_list(Allocator()) { }
constexpr explicit forward_list(const Allocator&);
constexpr explicit forward_list(size_type n, const Allocator& = Allocator());
constexpr forward_list(size_type n, const T& value, const Allocator& = Allocator());
template<class InputIterator>
constexpr forward_list(InputIterator first, InputIterator last,
const Allocator& = Allocator());
template<container-compatible-range <T> R>
constexpr forward_list(from_range_t, R&& rg, const Allocator& = Allocator());
constexpr forward_list(const forward_list& x);
constexpr forward_list(forward_list&& x);
constexpr forward_list(const forward_list& x, const type_identity_t<Allocator>&);
constexpr forward_list(forward_list&& x, const type_identity_t<Allocator>&);
constexpr forward_list(initializer_list<T>, const Allocator& = Allocator());
constexpr ~forward_list();
constexpr forward_list& operator=(const forward_list& x);
constexpr forward_list& operator=(forward_list&& x)
noexcept(allocator_traits<Allocator>::is_always_equal::value);
constexpr forward_list& operator=(initializer_list<T>);
template<class InputIterator>
constexpr void assign(InputIterator first, InputIterator last);
template<container-compatible-range <T> R>
constexpr void assign_range(R&& rg);
constexpr void assign(size_type n, const T& t);
constexpr void assign(initializer_list<T>);
constexpr allocator_type get_allocator() const noexcept;
// 23.3.7.3, iterators
constexpr iterator before_begin() noexcept;
constexpr const_iterator before_begin() const noexcept;
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cbefore_begin() const noexcept;
constexpr const_iterator cend() const noexcept;
// capacity
constexpr bool empty() const noexcept;
constexpr size_type max_size() const noexcept;
// 23.3.7.4, element access
constexpr reference front();
constexpr const_reference front() const;
// 23.3.7.5, modifiers
template<class... Args> constexpr reference emplace_front(Args&&... args);
constexpr void push_front(const T& x);
constexpr void push_front(T&& x);
template<container-compatible-range <T> R>
constexpr void prepend_range(R&& rg);
constexpr void pop_front();
§ 23.3.7.1 © ISO/IEC
983

===== PAGE 995 =====

Dxxxx
template<class... Args>
constexpr iterator emplace_after(const_iterator position, Args&&... args);
constexpr iterator insert_after(const_iterator position, const T& x);
constexpr iterator insert_after(const_iterator position, T&& x);
constexpr iterator insert_after(const_iterator position, size_type n, const T& x);
template<class InputIterator>
constexpr iterator insert_after(const_iterator position,
InputIterator first, InputIterator last);
constexpr iterator insert_after(const_iterator position, initializer_list<T> il);
template<container-compatible-range <T> R>
constexpr iterator insert_range_after(const_iterator position, R&& rg);
constexpr iterator erase_after(const_iterator position);
constexpr iterator erase_after(const_iterator position, const_iterator last);
constexpr void swap(forward_list&)
noexcept(allocator_traits<Allocator>::is_always_equal::value);
constexpr void resize(size_type sz);
constexpr void resize(size_type sz, const value_type& c);
constexpr void clear() noexcept;
// 23.3.7.6,forward_list operations
constexpr void splice_after(const_iterator position, forward_list& x);
constexpr void splice_after(const_iterator position, forward_list&& x);
constexpr void splice_after(const_iterator position, forward_list& x, const_iterator i);
constexpr void splice_after(const_iterator position, forward_list&& x, const_iterator i);
constexpr void splice_after(const_iterator position, forward_list& x,
const_iterator first, const_iterator last);
constexpr void splice_after(const_iterator position, forward_list&& x,
const_iterator first, const_iterator last);
constexpr size_type remove(const T& value);
template<class Predicate> constexpr size_type remove_if(Predicate pred);
size_type unique();
template<class BinaryPredicate> constexpr size_type unique(BinaryPredicate binary_pred);
constexpr void merge(forward_list& x);
constexpr void merge(forward_list&& x);
template<class Compare> constexpr void merge(forward_list& x, Compare comp);
template<class Compare> constexpr void merge(forward_list&& x, Compare comp);
constexpr void sort();
template<class Compare> constexpr void sort(Compare comp);
constexpr void reverse() noexcept;
};
template<class InputIterator, class Allocator = allocator<iter-value-type <InputIterator>>>
forward_list(InputIterator, InputIterator, Allocator = Allocator())
-> forward_list<iter-value-type <InputIterator>, Allocator>;
template<ranges::input_range R, class Allocator = allocator<ranges::range_value_t<R>>>
forward_list(from_range_t, R&&, Allocator = Allocator())
-> forward_list<ranges::range_value_t<R>, Allocator>;
}
5 An incomplete typeT may be used when instantiatingforward_list if the allocator meets the allocator
completeness requirements (16.4.4.6.2).T shall be complete before any member of the resulting specialization
of forward_list is referenced.
§ 23.3.7.1 © ISO/IEC
984

===== PAGE 996 =====

Dxxxx
23.3.7.2 Constructors, copy, and assignment [forward.list.cons]
constexpr explicit forward_list(const Allocator&);
1 Effects: Constructs an emptyforward_list object using the specified allocator.
2 Complexity: Constant.
constexpr explicit forward_list(size_type n, const Allocator& = Allocator());
3 Preconditions: T is Cpp17DefaultInsertable into forward_list.
4 Effects: Constructs aforward_list object withn default-inserted elements using the specified allocator.
5 Complexity: Linear inn.
constexpr forward_list(size_type n, const T& value, const Allocator& = Allocator());
6 Preconditions: T is Cpp17CopyInsertable into forward_list.
7 Effects: Constructs aforward_list object withn copies ofvalue using the specified allocator.
8 Complexity: Linear inn.
template<class InputIterator>
constexpr forward_list(InputIterator first, InputIterator last, const Allocator& = Allocator());
9 Effects: Constructs aforward_list object equal to the range[first,last).
10 Complexity: Linear indistance(first, last).
template<container-compatible-range <T> R>
constexpr forward_list(from_range_t, R&& rg, const Allocator& = Allocator());
11 Effects: Constructs aforward_list object with the elements of the rangerg.
12 Complexity: Linear inranges::distance(rg).
23.3.7.3 Iterators [forward.list.iter]
constexpr iterator before_begin() noexcept;
constexpr const_iterator before_begin() const noexcept;
constexpr const_iterator cbefore_begin() const noexcept;
1 Effects: cbefore_begin() is equivalent to const_cast<forward_list const&>(*this).before_-
begin().
2 Returns: A non-dereferenceable iterator that, when incremented, is equal to the iterator returned by
begin().
3 Remarks: before_begin() == end() shall equalfalse.
23.3.7.4 Element access [forward.list.access]
constexpr reference front();
constexpr const_reference front() const;
1 Returns: *begin()
23.3.7.5 Modifiers [forward.list.modifiers]
1 The member functions in this subclause do not affect the validity of iterators and references when inserting
elements, and when erasing elements invalidate iterators and references to the erased elements only. If an
exception is thrown by any of these member functions there is no effect on the container. Insertingn elements
into aforward_list is linear inn, and the number of calls to the copy or move constructor ofT is exactly
equal ton. Erasing n elements from aforward_list is linear inn and the number of calls to the destructor
of typeT is exactly equal ton.
template<class... Args> constexpr reference emplace_front(Args&&... args);
2 Effects: Inserts an object of typevalue_type constructed withvalue_type(std::forward<Args>(
args)...) at the beginning of the list.
§ 23.3.7.5 © ISO/IEC
985

===== PAGE 997 =====

Dxxxx
constexpr void push_front(const T& x);
constexpr void push_front(T&& x);
3 Effects: Inserts a copy ofx at the beginning of the list.
template<container-compatible-range <T> R>
constexpr void prepend_range(R&& rg);
4 Effects: Inserts a copy of each element ofrg at the beginning of the list.
[Note 1: The order of elements is not reversed.—end note]
constexpr void pop_front();
5 Effects: As if byerase_after(before_begin()).
constexpr iterator insert_after(const_iterator position, const T& x);
6 Preconditions: T is Cpp17CopyInsertable into forward_list. position is before_begin() or is a
dereferenceable iterator in the range[begin(),end()).
7 Effects: Inserts a copy ofx after position.
8 Returns: An iterator pointing to the copy ofx.
constexpr iterator insert_after(const_iterator position, T&& x);
9 Preconditions: T is Cpp17MoveInsertable into forward_list. position is before_begin() or is a
dereferenceable iterator in the range[begin(),end()).
10 Effects: Inserts a copy ofx after position.
11 Returns: An iterator pointing to the copy ofx.
constexpr iterator insert_after(const_iterator position, size_type n, const T& x);
12 Preconditions: T is Cpp17CopyInsertable into forward_list. position is before_begin() or is a
dereferenceable iterator in the range[begin(),end()).
13 Effects: Inserts n copies ofx after position.
14 Returns: An iterator pointing to the last inserted copy ofx, orposition if n == 0 is true.
template<class InputIterator>
constexpr iterator insert_after(const_iterator position,
InputIterator first, InputIterator last);
15 Preconditions: T is Cpp17EmplaceConstructible intoforward_list from *first. position is before_-
begin() or is a dereferenceable iterator in the range[begin(),end()). Neither first nor last are
iterators in*this.
16 Effects: Inserts copies of elements in[first,last) after position.
17 Returns: An iterator pointing to the last inserted element, orposition if first == last is true.
template<container-compatible-range <T> R>
constexpr iterator insert_range_after(const_iterator position, R&& rg);
18 Preconditions: T is Cpp17EmplaceConstructible into forward_list from *ranges::begin(rg). posi-
tion is before_begin() or is a dereferenceable iterator in the range[begin(),end()). rg and *this
do not overlap.
19 Effects: Inserts copies of elements in the rangerg after position.
20 Returns: An iterator pointing to the last inserted element, orposition if rg is empty.
constexpr iterator insert_after(const_iterator position, initializer_list<T> il);
21 Effects: Equivalent to:return insert_after(position, il.begin(), il.end());
template<class... Args>
constexpr iterator emplace_after(const_iterator position, Args&&... args);
22 Preconditions: T is Cpp17EmplaceConstructible into forward_list from std::forward<Args>(
args).... position is before_begin() or is a dereferenceable iterator in the range[begin(),end()).
§ 23.3.7.5 © ISO/IEC
986

===== PAGE 998 =====

Dxxxx
23 Effects: Inserts an object of typevalue_type direct-non-list-initialized withstd::forward<Args>(
args)... after position.
24 Returns: An iterator pointing to the new object.
constexpr iterator erase_after(const_iterator position);
25 Preconditions: The iterator followingposition is dereferenceable.
26 Effects: Erases the element pointed to by the iterator followingposition.
27 Returns: An iterator pointing to the element following the one that was erased, orend() if no such
element exists.
28 Throws: Nothing.
constexpr iterator erase_after(const_iterator position, const_iterator last);
29 Preconditions: All iterators in the range(position,last) are dereferenceable.
30 Effects: Erases the elements in the range(position,last).
31 Returns: last.
32 Throws: Nothing.
constexpr void resize(size_type sz);
33 Preconditions: T is Cpp17DefaultInsertable into forward_list.
34 Effects: If sz < distance(begin(), end()), erases the lastdistance(begin(), end()) - sz ele-
ments from the list. Otherwise, insertssz - distance(begin(), end()) default-inserted elements at
the end of the list.
constexpr void resize(size_type sz, const value_type& c);
35 Preconditions: T is Cpp17CopyInsertable into forward_list.
36 Effects: If sz < distance(begin(), end()), erases the lastdistance(begin(), end()) - sz ele-
ments from the list. Otherwise, insertssz - distance(begin(), end()) copies ofc at the end of the
list.
constexpr void clear() noexcept;
37 Effects: Erases all elements in the range[begin(),end()).
38 Remarks: Does not invalidate past-the-end iterators.
23.3.7.6 Operations [forward.list.ops]
1 In this subclause, arguments for a template parameter namedPredicate or BinaryPredicate shall meet
the corresponding requirements in 26.2. The semantics ofi + n, wherei is an iterator into the list andn is
an integer, are the same as those ofnext(i, n). The expressioni - n, wherei is an iterator into the list
and n is an integer, means an iteratorj such thatj + n == i is true. Formerge and sort, the definitions
and requirements in 26.8 apply.
constexpr void splice_after(const_iterator position, forward_list& x);
constexpr void splice_after(const_iterator position, forward_list&& x);
2 Preconditions: position is before_begin() or is a dereferenceable iterator in the range[begin(),
end()). get_allocator() == x.get_allocator() is true. addressof(x) != this is true.
3 Effects: Inserts the contents ofx after position, andx becomes empty. Pointers and references to the
moved elements ofx now refer to those same elements but as members of*this. Iterators referring
to the moved elements will continue to refer to their elements, but they now behave as iterators into
*this, not intox.
4 Throws: Nothing.
5 Complexity: O(distance(x.begin(), x.end()))
constexpr void splice_after(const_iterator position, forward_list& x, const_iterator i);
§ 23.3.7.6 © ISO/IEC
987

===== PAGE 999 =====

Dxxxx
constexpr void splice_after(const_iterator position, forward_list&& x, const_iterator i);
6 Preconditions: position is before_begin() or is a dereferenceable iterator in the range[begin(),
end()). The iterator following i is a dereferenceable iterator inx. get_allocator() == x.get_-
allocator() is true.
7 Effects: Inserts the element followingi into *this, followingposition, and removes it fromx. The
result is unchanged ifposition == i or position == ++i. Pointers and references to*++i continue
to refer to the same element but as a member of*this. Iterators to*++i continue to refer to the same
element, but now behave as iterators into*this, not intox.
8 Throws: Nothing.
9 Complexity: O(1)
constexpr void splice_after(const_iterator position, forward_list& x,
const_iterator first, const_iterator last);
constexpr void splice_after(const_iterator position, forward_list&& x,
const_iterator first, const_iterator last);
10 Preconditions: position is before_begin() or is a dereferenceable iterator in the range[begin(),
end()). (first,last) is a valid range inx, and all iterators in the range(first,last) are deref-
erenceable. position is not an iterator in the range(first,last). get_allocator() == x.get_-
allocator() is true.
11 Effects: Inserts elements in the range(first,last) after position and removes the elements fromx.
Pointers and references to the moved elements ofx now refer to those same elements but as members
of *this. Iterators referring to the moved elements will continue to refer to their elements, but they
now behave as iterators into*this, not intox.
12 Complexity: O(distance(first, last))
constexpr size_type remove(const T& value);
template<class Predicate> constexpr size_type remove_if(Predicate pred);
13 Effects: Erases all the elements in the list referred to by a list iteratori for which the following
conditions hold: *i == value (for remove()), pred(*i) is true (for remove_if()). Invalidates only
the iterators and references to the erased elements.
14 Returns: The number of elements erased.
15 Throws: Nothing unless an exception is thrown by the equality comparison or the predicate.
16 Complexity: Exactly distance(begin(), end()) applications of the corresponding predicate.
17 Remarks: Stable (16.4.6.8).
constexpr size_type unique();
template<class BinaryPredicate> constexpr size_type unique(BinaryPredicate binary_pred);
18 Let binary_pred be equal_to<>{} for the first overload.
19 Preconditions: binary_pred is an equivalence relation.
20 Effects: Erases all but the first element from every consecutive group of equivalent elements. That is,
for a nonempty list, erases all elements referred to by the iteratori in the range[begin() + 1,end())
for whichbinary_pred(*i, *(i - 1)) is true. Invalidates only the iterators and references to the
erased elements.
21 Returns: The number of elements erased.
22 Throws: Nothing unless an exception is thrown by the predicate.
23 Complexity: If empty() is false, exactlydistance(begin(), end()) - 1 applications of the corre-
sponding predicate, otherwise no applications of the predicate.
constexpr void merge(forward_list& x);
constexpr void merge(forward_list&& x);
template<class Compare> constexpr void merge(forward_list& x, Compare comp);
template<class Compare> constexpr void merge(forward_list&& x, Compare comp);
24 Let comp be less<> for the first two overloads.
§ 23.3.7.6 © ISO/IEC
988

===== PAGE 1000 =====

Dxxxx
25 Preconditions: *this and x are both sorted with respect to the comparatorcomp, andget_allocator()
== x.get_allocator() is true.
26 Effects: If addressof(x) == this, there are no effects. Otherwise, merges the two sorted ranges
[begin(),end()) and [x.begin(),x.end()). The result is a range that is sorted with respect to the
comparator comp. Pointers and references to the moved elements ofx now refer to those same elements
but as members of*this. Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into*this, not intox.
27 Complexity: At mostdistance(begin(), end()) + distance(x.begin(), x.end()) - 1 compar-
isons ifaddressof(x) != this; otherwise, no comparisons are performed.
28 Remarks: Stable (16.4.6.8). Ifaddressof(x) != this, x is empty after the merge. No elements are
copied by this operation. If an exception is thrown other than by a comparison, there are no effects.
constexpr void sort();
template<class Compare> constexpr void sort(Compare comp);
29 Effects: Sorts the list according to theoperator< or the comp function object. If an exception is
thrown, the order of the elements in*this is unspecified. Does not affect the validity of iterators and
references.
30 Complexity: ApproximatelyNlog N comparisons, whereN is distance(begin(), end()).
31 Remarks: Stable (16.4.6.8).
constexpr void reverse() noexcept;
32 Effects: Reverses the order of the elements in the list. Does not affect the validity of iterators and
references.
33 Complexity: Linear time.
23.3.7.7 Erasure [forward.list.erasure]
template<class T, class Allocator, class U = T>
constexpr typename forward_list<T, Allocator>::size_type
erase(forward_list<T, Allocator>& c, const U& value);
1 Effects: Equivalent to:
return erase_if(c, [&](const auto& elem) -> bool { return elem == value; });
template<class T, class Allocator, class Predicate>
constexpr typename forward_list<T, Allocator>::size_type
erase_if(forward_list<T, Allocator>& c, Predicate pred);
2 Effects: Equivalent to:return c.remove_if(pred);
23.3.8 Header <hive> synopsis [hive.syn]
#include <initializer_list> // see 17.11.2
#include <compare> // see 17.12.1
namespace std {
struct hive_limits {
size_t min;
size_t max;
constexpr hive_limits(size_t minimum, size_t maximum) noexcept
: min(minimum), max(maximum) {}
};
// 23.3.9, class templatehive
template<class T, class Allocator = allocator<T>> class hive;
template<class T, class Allocator>
void swap(hive<T, Allocator>& x, hive<T, Allocator>& y)
noexcept(noexcept(x.swap(y)));
§ 23.3.8 © ISO/IEC
989