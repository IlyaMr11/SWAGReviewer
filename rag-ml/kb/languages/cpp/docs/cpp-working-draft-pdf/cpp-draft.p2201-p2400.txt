

===== PAGE 2201 =====

Dxxxx
};
}
1 The template argument forT shall meet theCpp17CopyConstructible and Cpp17CopyAssignable requirements.
The program is ill-formed if any of
—(1.1) is_trivially_copyable_v<T>,
—(1.2) is_copy_constructible_v<T>,
—(1.3) is_move_constructible_v<T>,
—(1.4) is_copy_assignable_v<T>,
—(1.5) is_move_assignable_v<T>, or
—(1.6) is_same_v<T, remove_cv_t<T>>,
is false.
[Note 1: Type arguments that are not also statically initializable can be difficult to use.—end note]
2 The specializationatomic<bool> is a standard-layout struct. It has a trivial destructor.
3 [Note 2: The representation of an atomic specialization need not have the same size and alignment requirement as its
corresponding argument type. —end note]
32.5.8.2 Operations on atomic types [atomics.types.operations]
constexpr atomic() noexcept(is_nothrow_default_constructible_v<T>);
1 Constraints: is_default_constructible_v<T> is true.
2 Effects: Initializes the atomic object with the value ofT(). Initialization is not an atomic operation
(6.10.2).
constexpr atomic(T desired) noexcept;
3 Effects: Initializes the object with the valuedesired. Initialization is not an atomic operation (6.10.2).
[Note 1: It is possible to have an access to an atomic objectA race with its construction, for example by
communicating the address of the just-constructed objectA to another thread viamemory_order::relaxed
operations on a suitable atomic pointer variable, and then immediately accessingA in the receiving thread. This
results in undefined behavior.—end note]
static constexpr bool is_always_lock_free = implementation-defined ;
4 The static data memberis_always_lock_free is true if the atomic type’s operations are always
lock-free, andfalse otherwise.
[Note 2: The value ofis_always_lock_free is consistent with the value of the correspondingATOMIC_..._-
LOCK_FREE macro, if defined. —end note]
bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
5 Returns: true if the object’s operations are lock-free,false otherwise.
[Note 3: The return value of theis_lock_free member function is consistent with the value ofis_always_-
lock_free for the same type.—end note]
void store(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr void store(T desired, memory_order order = memory_order::seq_cst) noexcept;
6 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
7 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
8 Effects: Atomically replaces the value pointed to bythis with the value ofdesired. Memory is
affected according to the value oforder.
T operator=(T desired) volatile noexcept;
constexpr T operator=(T desired) noexcept;
9 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
10 Effects: Equivalent tostore(desired).
§ 32.5.8.2 © ISO/IEC
2190

===== PAGE 2202 =====

Dxxxx
11 Returns: desired.
T load(memory_order order = memory_order::seq_cst) const volatile noexcept;
constexpr T load(memory_order order = memory_order::seq_cst) const noexcept;
12 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
13 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
14 Effects: Memory is affected according to the value oforder.
15 Returns: Atomically returns the value pointed to bythis.
operator T() const volatile noexcept;
constexpr operator T() const noexcept;
16 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
17 Effects: Equivalent to:return load();
T exchange(T desired, memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr T exchange(T desired, memory_order order = memory_order::seq_cst) noexcept;
18 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
19 Effects: Atomically replaces the value pointed to bythis with desired. Memory is affected according
to the value oforder. These operations are atomic read-modify-write operations (6.10.2).
20 Returns: Atomically returns the value pointed to bythis immediately before the effects.
bool compare_exchange_weak(T& expected, T desired,
memory_order success, memory_order failure) volatile noexcept;
constexpr bool compare_exchange_weak(T& expected, T desired,
memory_order success, memory_order failure) noexcept;
bool compare_exchange_strong(T& expected, T desired,
memory_order success, memory_order failure) volatile noexcept;
constexpr bool compare_exchange_strong(T& expected, T desired,
memory_order success, memory_order failure) noexcept;
bool compare_exchange_weak(T& expected, T desired,
memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_weak(T& expected, T desired,
memory_order order = memory_order::seq_cst) noexcept;
bool compare_exchange_strong(T& expected, T desired,
memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_strong(T& expected, T desired,
memory_order order = memory_order::seq_cst) noexcept;
21 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
22 Preconditions: failure is memory_order::relaxed, memory_order::acquire, or memory_order::
seq_cst.
23 Effects: Retrieves the value inexpected. It then atomically compares the value representation of
the value pointed to bythis for equality with that previously retrieved fromexpected, and if true,
replaces the value pointed to bythis with that indesired. If and only if the comparison istrue,
memory is affected according to the value ofsuccess, and if the comparison is false, memory is affected
according to the value offailure. When only onememory_order argument is supplied, the value of
success is order, and the value offailure is order except that a value ofmemory_order::acq_rel
shall be replaced by the valuememory_order::acquire and a value ofmemory_order::release shall
be replaced by the valuememory_order::relaxed. If and only if the comparison is false then, after
the atomic operation, the value inexpected is replaced by the value pointed to bythis during the
atomic comparison. If the operation returns true, these operations are atomic read-modify-write
operations (6.10.2) on the memory pointed to bythis. Otherwise, these operations are atomic load
operations on that memory.
24 Returns: The result of the comparison.
25 [Note 4: For example, the effect ofcompare_exchange_strong on objects without padding bits (6.9.1) is
§ 32.5.8.2 © ISO/IEC
2191

===== PAGE 2203 =====

Dxxxx
if (memcmp(this, &expected, sizeof(*this)) == 0)
memcpy(this, &desired, sizeof(*this));
else
memcpy(&expected, this, sizeof(*this));
—end note]
[Example 1: The expected use of the compare-and-exchange operations is as follows. The compare-and-exchange
operations will updateexpected when another iteration of the loop is needed.
expected = current.load();
do {
desired = function(expected);
} while (!current.compare_exchange_weak(expected, desired));
—end example]
[Example 2: Because the expected value is updated only on failure, code releasing the memory containing
the expected value on success will work. For example, list head insertion will act atomically and would not
introduce a data race in the following code:
do {
p->next = head; // make new list node point to the current head
} while (!head.compare_exchange_weak(p->next, p)); // try to insert
—end example]
26 Implementations should ensure that weak compare-and-exchange operations do not consistently return
false unless either the atomic object has value different fromexpected or there are concurrent
modifications to the atomic object.
27 Remarks: A weak compare-and-exchange operation may fail spuriously. That is, even when the contents
of memory referred to byexpected and this are equal, it may returnfalse and store back toexpected
the same memory contents that were originally there.
[Note 5: This spurious failure enables implementation of compare-and-exchange on a broader class of machines,
e.g., load-locked store-conditional machines. A consequence of spurious failure is that nearly all uses of weak
compare-and-exchange will be in a loop. When a compare-and-exchange is in a loop, the weak version will yield
better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong
one would not, the strong one is preferable.—end note]
28 [Note 6: Under cases where thememcpy and memcmp semantics of the compare-and-exchange operations apply,
the comparisons can fail for values that compare equal withoperator== if the value representation has trap
bits or alternate representations of the same value. Notably, on implementations conforming to ISO/IEC 60559,
floating-point -0.0 and +0.0 will not compare equal withmemcmp but will compare equal withoperator==, and
NaNs with the same payload will compare equal withmemcmp but will not compare equal withoperator==.
—end note]
[Note 7: Because compare-and-exchange acts on an object’s value representation, padding bits that never
participate in the object’s value representation are ignored. As a consequence, the following code is guaranteed
to avoid spurious failure:
struct padded {
char clank = 0x42;
// Padding here.
unsigned biff = 0xC0DEFEFE;
};
atomic<padded> pad = {};
bool zap() {
padded expected, desired{0, 0};
return pad.compare_exchange_strong(expected, desired);
}
—end note]
[Note 8: For a union with bits that participate in the value representation of some members but not others,
compare-and-exchange might always fail. This is because such padding bits have an indeterminate value when
they do not participate in the value representation of the active member. As a consequence, the following code
is not guaranteed to ever succeed:
union pony {
double celestia = 0.;
§ 32.5.8.2 © ISO/IEC
2192

===== PAGE 2204 =====

Dxxxx
short luna; // padded
};
atomic<pony> princesses = {};
bool party(pony desired) {
pony expected;
return princesses.compare_exchange_strong(expected, desired);
}
—end note]
void wait(T old, memory_order order = memory_order::seq_cst) const volatile noexcept;
constexpr void wait(T old, memory_order order = memory_order::seq_cst) const noexcept;
29 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
30 Effects: Repeatedly performs the following steps, in order:
—(30.1) Evaluates load(order) and compares its value representation for equality against that ofold.
—(30.2) If they compare unequal, returns.
—(30.3) Blocks until it is unblocked by an atomic notifying operation or is unblocked spuriously.
31 Remarks: This function is an atomic waiting operation (32.5.6).
void notify_one() volatile noexcept;
constexpr void notify_one() noexcept;
32 Effects: Unblocks the execution of at least one atomic waiting operation that is eligible to be unblocked
(32.5.6) by this call, if any such atomic waiting operations exist.
33 Remarks: This function is an atomic notifying operation (32.5.6).
void notify_all() volatile noexcept;
constexpr void notify_all() noexcept;
34 Effects: Unblocks the execution of all atomic waiting operations that are eligible to be unblocked (32.5.6)
by this call.
35 Remarks: This function is an atomic notifying operation (32.5.6).
32.5.8.3 Specializations for integers [atomics.types.int]
1 There are specializations of the atomic class template for each character type (6.9.2), each standard
integer type, and any other types needed by the typedefs in the header<cstdint> (17.4.1). For each such
type integral-type , the specializationatomic<integral-type > provides additional atomic operations
appropriate to integral types.
[Note 1: The specializationatomic<bool> uses the primary template (32.5.8).—end note]
namespace std {
template<> struct atomic<integral-type > {
using value_type = integral-type ;
using difference_type = value_type;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
constexpr atomic() noexcept;
constexpr atomic(integral-type) noexcept;
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
atomic& operator=(const atomic&) volatile = delete;
void store(integral-type, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store(integral-type, memory_order = memory_order::seq_cst) noexcept;
integral-type operator=(integral-type) volatile noexcept;
constexpr integral-type operator=(integral-type) noexcept;
integral-type load(memory_order = memory_order::seq_cst) const volatile noexcept;
§ 32.5.8.3 © ISO/IEC
2193

===== PAGE 2205 =====

Dxxxx
constexpr integral-type load(memory_order = memory_order::seq_cst) const noexcept;
operator integral-type() const volatile noexcept;
constexpr operator integral-type() const noexcept;
integral-type exchange(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type exchange(integral-type,
memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_weak(integral-type &, integral-type,
memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_weak(integral-type &, integral-type,
memory_order, memory_order) noexcept;
bool compare_exchange_strong(integral-type &, integral-type,
memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_strong(integral-type &, integral-type,
memory_order, memory_order) noexcept;
bool compare_exchange_weak(integral-type &, integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_weak(integral-type &, integral-type,
memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_strong(integral-type &, integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_strong(integral-type &, integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type fetch_add(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_add(integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type fetch_sub(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_sub(integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type fetch_and(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_and(integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type fetch_or(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_or(integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type fetch_xor(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_xor(integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type fetch_max(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_max(integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type fetch_min(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_min(integral-type,
memory_order = memory_order::seq_cst) noexcept;
void store_add(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_add(integral-type,
memory_order = memory_order::seq_cst) noexcept;
void store_sub(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_sub(integral-type,
memory_order = memory_order::seq_cst) noexcept;
void store_and(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
§ 32.5.8.3 © ISO/IEC
2194

===== PAGE 2206 =====

Dxxxx
constexpr void store_and(integral-type,
memory_order = memory_order::seq_cst) noexcept;
void store_or(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_or(integral-type,
memory_order = memory_order::seq_cst) noexcept;
void store_xor(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_xor(integral-type,
memory_order = memory_order::seq_cst) noexcept;
void store_max(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_max(integral-type,
memory_order = memory_order::seq_cst) noexcept;
void store_min(integral-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_min(integral-type,
memory_order = memory_order::seq_cst) noexcept;
integral-type operator++(int) volatile noexcept;
constexpr integral-type operator++(int) noexcept;
integral-type operator--(int) volatile noexcept;
constexpr integral-type operator--(int) noexcept;
integral-type operator++() volatile noexcept;
constexpr integral-type operator++() noexcept;
integral-type operator--() volatile noexcept;
constexpr integral-type operator--() noexcept;
integral-type operator+=(integral-type) volatile noexcept;
constexpr integral-type operator+=(integral-type) noexcept;
integral-type operator-=(integral-type) volatile noexcept;
constexpr integral-type operator-=(integral-type) noexcept;
integral-type operator&=(integral-type) volatile noexcept;
constexpr integral-type operator&=(integral-type) noexcept;
integral-type operator|=(integral-type) volatile noexcept;
constexpr integral-type operator|=(integral-type) noexcept;
integral-type operator^=(integral-type) volatile noexcept;
constexpr integral-type operator^=(integral-type) noexcept;
void wait(integral-type, memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr void wait(integral-type, memory_order = memory_order::seq_cst) const noexcept;
void notify_one() volatile noexcept;
constexpr void notify_one() noexcept;
void notify_all() volatile noexcept;
constexpr void notify_all() noexcept;
};
}
2 The atomic integral specializations are standard-layout structs. They each have a trivial destructor.
3 Descriptions are provided below only for members that differ from the primary template.
4 The following operations perform arithmetic computations. The correspondence among key, operator, and
computation is specified in Table 155.
Table 155 — Atomic arithmetic computations [tab:atomic.types.int.comp]
key Op Computation key Op Computation
add + addition and & bitwise and
sub - subtraction or | bitwise inclusive or
max maximum xor ^ bitwise exclusive or
min minimum
§ 32.5.8.3 © ISO/IEC
2195

===== PAGE 2207 =====

Dxxxx
integral-type fetch_key(integral-type operand,
memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr integral-type fetch_key(integral-type operand,
memory_order order = memory_order::seq_cst) noexcept;
5 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
6 Effects: Atomically replaces the value pointed to bythis with the result of the computation applied
to the value pointed to bythis and the givenoperand. Memory is affected according to the value of
order. These operations are atomic read-modify-write operations (6.10.2).
7 Returns: Atomically, the value pointed to bythis immediately before the effects.
8 Remarks: Except forfetch_max and fetch_min, for signed integer types the result is as if the object
value and parameters were converted to their corresponding unsigned types, the computation performed
on those types, and the result converted back to the signed type.
[Note 2: There are no undefined results arising from the computation.—end note]
9 Forfetch_max and fetch_min, the maximum and minimum computation is performed as if bymax and
min algorithms (26.8.9), respectively, with the object value and the first parameter as the arguments.
void store_key(integral-type operand,
memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr void store_key(integral-type operand,
memory_order order = memory_order::seq_cst) noexcept;
10 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
11 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
12 Effects: Atomically replaces the value pointed to bythis with the result of the computation applied
to the value pointed to bythis and the givenoperand. Memory is affected according to the value of
order. These operations are atomic modify-write operations (32.5.4).
13 Remarks: Except for store_max and store_min, for signed integer types, the result is as if the
value pointed to bythis and parameters were converted to their corresponding unsigned types, the
computation performed on those types, and the result converted back to the signed type.
[Note 3: There are no undefined results arising from the computation.—end note]
For store_max and store_min, the maximum and minimum computation is performed as if bymax
and min algorithms (26.8.9), respectively, with the value pointed to bythis and the first parameter as
the arguments.
integral-type operator op =(integral-type operand) volatile noexcept;
constexpr integral-type operator op =(integral-type operand) noexcept;
14 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
15 Effects: Equivalent to:return fetch_key (operand) op operand;
32.5.8.4 Specializations for floating-point types [atomics.types.float]
1 There are specializations of theatomic class template for all cv-unqualified floating-point types. For each
such type floating-point-type, the specializationatomic<floating-point-type > provides additional
atomic operations appropriate to floating-point types.
namespace std {
template<> struct atomic<floating-point-type > {
using value_type = floating-point-type;
using difference_type = value_type;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
constexpr atomic() noexcept;
constexpr atomic(floating-point-type ) noexcept;
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
§ 32.5.8.4 © ISO/IEC
2196

===== PAGE 2208 =====

Dxxxx
atomic& operator=(const atomic&) volatile = delete;
void store(floating-point-type, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store(floating-point-type, memory_order = memory_order::seq_cst) noexcept;
floating-point-type operator=(floating-point-type ) volatile noexcept;
constexpr floating-point-type operator=(floating-point-type ) noexcept;
floating-point-type load(memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type load(memory_order = memory_order::seq_cst) noexcept;
operator floating-point-type() volatile noexcept;
constexpr operator floating-point-type() noexcept;
floating-point-type exchange(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type exchange(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_weak(floating-point-type &, floating-point-type,
memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_weak(floating-point-type &, floating-point-type,
memory_order, memory_order) noexcept;
bool compare_exchange_strong(floating-point-type &, floating-point-type,
memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_strong(floating-point-type &, floating-point-type,
memory_order, memory_order) noexcept;
bool compare_exchange_weak(floating-point-type &, floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_weak(floating-point-type &, floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_strong(floating-point-type &, floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_strong(floating-point-type &, floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_add(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_add(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_sub(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_sub(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_max(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_max(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_min(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-poin-typet fetch_min(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_fmaximum(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_fmaximum(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_fminimum(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_fminimum(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_fmaximum_num(
floating-point-type, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_fmaximum_num(
floating-point-type, memory_order = memory_order::seq_cst) noexcept;
floating-point-type fetch_fminimum_num(
floating-point-type, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_fminimum_num(
floating-point-type, memory_order = memory_order::seq_cst) noexcept;
§ 32.5.8.4 © ISO/IEC
2197

===== PAGE 2209 =====

Dxxxx
void store_add(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_add(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
void store_sub(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_sub(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
void store_max(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_max(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
void store_min(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_min(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
void store_fmaximum(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_fmaximum(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
void store_fminimum(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_fminimum(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
void store_fmaximum_num(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_fmaximum_num(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
void store_fminimum_num(floating-point-type,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_fminimum_num(floating-point-type,
memory_order = memory_order::seq_cst) noexcept;
floating-point-type operator+=(floating-point-type ) volatile noexcept;
constexpr floating-point-type operator+=(floating-point-type ) noexcept;
floating-point-type operator-=(floating-point-type ) volatile noexcept;
constexpr floating-point-type operator-=(floating-point-type ) noexcept;
void wait(floating-point-type, memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr void wait(floating-point-type,
memory_order = memory_order::seq_cst) const noexcept;
void notify_one() volatile noexcept;
constexpr void notify_one() noexcept;
void notify_all() volatile noexcept;
constexpr void notify_all() noexcept;
};
}
2 The atomic floating-point specializations are standard-layout structs. They each have a trivial destructor.
3 Descriptions are provided below only for members that differ from the primary template.
4 The following operations perform arithmetic addition and subtraction computations. The correspondence
among key, operator, and computation is specified in Table 155, except for the keysmax, min, fmaximum,
fminimum, fmaximum_num, andfminimum_num, which are specified below.
floating-point-type fetch_key(floating-point-type operand,
memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr floating-point-type fetch_key(floating-point-type operand,
memory_order order = memory_order::seq_cst) noexcept;
5 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
6 Effects: Atomically replaces the value pointed to bythis with the result of the computation applied
to the value pointed to bythis and the givenoperand. Memory is affected according to the value of
order. These operations are atomic read-modify-write operations (6.10.2).
§ 32.5.8.4 © ISO/IEC
2198

===== PAGE 2210 =====

Dxxxx
7 Returns: Atomically, the value pointed to bythis immediately before the effects.
8 Remarks: If the result is not a representable value for its type (7.1) the result is unspecified, but the op-
erations otherwise have no undefined behavior. Atomic arithmetic operations onfloating-point-type
should conform to the std::numeric_limits<floating-point-type > traits associated with the
floating-point type (17.3.3). The floating-point environment (29.3) for atomic arithmetic operations on
floating-point-type may be different than the calling thread’s floating-point environment.
—(8.1) Forfetch_fmaximumand fetch_fminimum, the maximum and minimum computation is performed
as if byfmaximum and fminimum, respectively, with the value pointed to bythis and the first
parameter as the arguments.
—(8.2) Forfetch_fmaximum_num and fetch_fminimum_num, the maximum and minimum computation
is performed as if byfmaximum_num and fminimum_num, respectively, with the value pointed to by
this and the first parameter as the arguments.
—(8.3) Forfetch_max and fetch_min, the maximum and minimum computation is performed as if by
fmaximum_num and fminimum_num, respectively, with the value pointed to bythis and the first
parameter as the arguments, except that:
—(8.3.1) If both arguments are NaN, an unspecified NaN value replaces the value pointed to bythis.
—(8.3.2) If exactly one argument is a NaN, either the other argument or an unspecified NaN value
replaces the value pointed to bythis; it is unspecified which.
—(8.3.3) If the arguments are differently signed zeros, which of these values replaces the value pointed
to by this is unspecified.
9 Recommended practice: The implementation offetch_max and fetch_min should treat negative zero
as smaller than positive zero.
void store_key(floating-point-type operand,
memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr void store_key(floating-point-type operand,
memory_order order = memory_order::seq_cst) noexcept;
10 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
11 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
12 Effects: Atomically replaces the value pointed to bythis with the result of the computation applied
to the value pointed to bythis and the given operand. Memory is affected according to the value of
order. These operations are atomic modify-write operations (32.5.4).
13 Remarks: If the result is not a representable value for its type (7.1) the result is unspecified, but the op-
erations otherwise have no undefined behavior. Atomic arithmetic operations onfloating-point-type
should conform to thenumeric_limits<floating-point-type > traits associated with the floating-
point type (17.3.3). The floating-point environment (29.3) for atomic arithmetic operations on
floating-point-type may be different than the calling thread’s floating-point environment. The
arithmetic rules of floating-point atomic modify-write operations may be different from operations on
floating-point types or atomic floating-point types.
[Note 1: Tree reductions are permitted for atomic modify-write operations.—end note]
—(13.1) Forstore_fmaximumand store_fminimum, the maximum and minimum computation is performed
as if byfmaximum and fminimum, respectively, with the value pointed to bythis and the first
parameter as the arguments.
—(13.2) Forstore_fmaximum_num and store_fminimum_num, the maximum and minimum computation
is performed as if byfmaximum_num and fminimum_num, respectively, with the value pointed to by
this and the first parameter as the arguments.
—(13.3) Forstore_max and store_min, the maximum and minimum computation is performed as if by
fmaximum_num and fminimum_num, respectively, with the value pointed to bythis and the first
parameter as the arguments, except that:
—(13.3.1) If both arguments are NaN, an unspecified NaN value replaces the value pointed to bythis.
—(13.3.2) If exactly one argument is a NaN, either the other argument or an unspecified NaN value
replaces the value pointed to bythis; it is unspecified which.
§ 32.5.8.4 © ISO/IEC
2199

===== PAGE 2211 =====

Dxxxx
—(13.3.3) If the arguments are differently signed zeros, which of these values replaces the value pointed
to bythis is unspecified.
14 Recommended practice: The implementation ofstore_max and store_min should treat negative zero
as smaller than positive zero.
floating-point-type operator op =(floating-point-type operand) volatile noexcept;
constexpr floating-point-type operator op =(floating-point-type operand) noexcept;
15 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
16 Effects: Equivalent to:return fetch_key (operand) op operand;
17 Remarks: If the result is not a representable value for its type (7.1) the result is unspecified, but the op-
erations otherwise have no undefined behavior. Atomic arithmetic operations onfloating-point-type
should conform to the std::numeric_limits<floating-point-type > traits associated with the
floating-point type (17.3.3). The floating-point environment (29.3) for atomic arithmetic operations on
floating-point-type may be different than the calling thread’s floating-point environment.
32.5.8.5 Partial specialization for pointers [atomics.types.pointer]
namespace std {
template<class T> struct atomic<T*> {
using value_type = T*;
using difference_type = ptrdiff_t;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
constexpr atomic() noexcept;
constexpr atomic(T*) noexcept;
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
atomic& operator=(const atomic&) volatile = delete;
void store(T*, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store(T*, memory_order = memory_order::seq_cst) noexcept;
T* operator=(T*) volatile noexcept;
constexpr T* operator=(T*) noexcept;
T* load(memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr T* load(memory_order = memory_order::seq_cst) const noexcept;
operator T*() const volatile noexcept;
constexpr operator T*() const noexcept;
T* exchange(T*, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr T* exchange(T*, memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_weak(T*&, T*, memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_weak(T*&, T*, memory_order, memory_order) noexcept;
bool compare_exchange_strong(T*&, T*, memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_strong(T*&, T*, memory_order, memory_order) noexcept;
bool compare_exchange_weak(T*&, T*,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_weak(T*&, T*,
memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_strong(T*&, T*,
memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_strong(T*&, T*,
memory_order = memory_order::seq_cst) noexcept;
T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr T* fetch_add(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr T* fetch_sub(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
T* fetch_max(T*, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr T* fetch_max(T*, memory_order = memory_order::seq_cst) noexcept;
§ 32.5.8.5 © ISO/IEC
2200

===== PAGE 2212 =====

Dxxxx
T* fetch_min(T*, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr T* fetch_min(T*, memory_order = memory_order::seq_cst) noexcept;
void store_add(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_add(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
void store_sub(ptrdiff_t, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_sub(ptrdiff_t, memory_order = memory_order::seq_cst) noexcept;
void store_max(T*, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_max(T*, memory_order = memory_order::seq_cst) noexcept;
void store_min(T*, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store_min(T*, memory_order = memory_order::seq_cst) noexcept;
T* operator++(int) volatile noexcept;
constexpr T* operator++(int) noexcept;
T* operator--(int) volatile noexcept;
constexpr T* operator--(int) noexcept;
T* operator++() volatile noexcept;
constexpr T* operator++() noexcept;
T* operator--() volatile noexcept;
constexpr T* operator--() noexcept;
T* operator+=(ptrdiff_t) volatile noexcept;
constexpr T* operator+=(ptrdiff_t) noexcept;
T* operator-=(ptrdiff_t) volatile noexcept;
constexpr T* operator-=(ptrdiff_t) noexcept;
void wait(T*, memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr void wait(T*, memory_order = memory_order::seq_cst) const noexcept;
void notify_one() volatile noexcept;
constexpr void notify_one() noexcept;
void notify_all() volatile noexcept;
constexpr void notify_all() noexcept;
};
}
1 There is a partial specialization of theatomic class template for pointers. Specializations of this partial
specialization are standard-layout structs. They each have a trivial destructor.
2 Descriptions are provided below only for members that differ from the primary template.
3 The following operations perform pointer arithmetic. The correspondence among key, operator, and compu-
tation is specified in Table 156.
Table 156 — Atomic pointer computations [tab:atomic.types.pointer.comp]
key Op Computation key Op Computation
add + addition sub - subtraction
max maximum min minimum
T* fetch_key(see above operand, memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr T* fetch_key(see above operand, memory_order order = memory_order::seq_cst) noexcept;
4 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
5 Mandates: T is a complete object type.
[Note 1: Pointer arithmetic onvoid* or function pointers is ill-formed.—end note]
6 Effects: Atomically replaces the value pointed to bythis with the result of the computation applied
to the value pointed to bythis and the givenoperand. Memory is affected according to the value of
order. These operations are atomic read-modify-write operations (6.10.2).
7 Returns: Atomically, the value pointed to bythis immediately before the effects.
8 Remarks: The result may be an undefined address, but the operations otherwise have no undefined
behavior.
§ 32.5.8.5 © ISO/IEC
2201

===== PAGE 2213 =====

Dxxxx
9 Forfetch_max and fetch_min, the maximum and minimum computation is performed as if bymax and
min algorithms (26.8.9), respectively, with the object value and the first parameter as the arguments.
[Note 2: If the pointers point to different complete objects (or subobjects thereof), the< operator does not
establish a strict weak ordering (Table 29, 7.6.9).—end note]
void store_key(see above operand, memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr void store_key(see above operand, memory_order order = memory_order::seq_cst) noexcept;
10 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
11 Mandates: T is a complete object type.
[Note 3: Pointer arithmetic onvoid* or function pointers is ill-formed.—end note]
12 Effects: Atomically replaces the value pointed to bythis with the result of the computation applied
to the value pointed to bythis and the givenoperand. Memory is affected according to the value of
order. These operations are atomic modify-write operations (32.5.4).
13 Remarks: The result may be an undefined address, but the operations otherwise have no undefined
behavior. Forstore_max and store_min, the maximum and minimum computation is performed as
if bymax and min algorithms (26.8.9), respectively, with the value pointed to bythis and the first
parameter as the arguments.
[Note 4: If the pointers point to different complete objects (or subobjects thereof), the< operator does not
establish a strict weak ordering (Table 29, 7.6.9).—end note]
T* operator op =(ptrdiff_t operand) volatile noexcept;
constexpr T* operator op =(ptrdiff_t operand) noexcept;
14 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
15 Effects: Equivalent to:return fetch_key (operand) op operand;
32.5.8.6 Member operators common to integers and pointers to objects[atomics.types.memop]
value_type operator++(int) volatile noexcept;
constexpr value_type operator++(int) noexcept;
1 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
2 Effects: Equivalent to:return fetch_add(1);
value_type operator--(int) volatile noexcept;
constexpr value_type operator--(int) noexcept;
3 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
4 Effects: Equivalent to:return fetch_sub(1);
value_type operator++() volatile noexcept;
constexpr value_type operator++() noexcept;
5 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
6 Effects: Equivalent to:return fetch_add(1) + 1;
value_type operator--() volatile noexcept;
constexpr value_type operator--() noexcept;
7 Constraints: For thevolatile overload of this function,is_always_lock_free is true.
8 Effects: Equivalent to:return fetch_sub(1) - 1;
32.5.8.7 Partial specializations for smart pointers [util.smartptr.atomic]
32.5.8.7.1 General [util.smartptr.atomic.general]
1 The library provides partial specializations of theatomic template for shared-ownership smart pointers
(20.3.2).
[Note 1: The partial specializations are declared in header<memory> (20.2.2). —end note]
The behavior of all operations is as specified in 32.5.8, unless specified otherwise. The template parameterT
of these partial specializations may be an incomplete type.
§ 32.5.8.7.1 © ISO/IEC
2202

===== PAGE 2214 =====

Dxxxx
2 All changes to an atomic smart pointer in 32.5.8.7, and all associateduse_count increments, are guaranteed
to be performed atomically. Associateduse_count decrements are sequenced after the atomic operation, but
are not required to be part of it. Any associated deletion and deallocation are sequenced after the atomic
update step and are not part of the atomic operation.
[Note 2: If the atomic operation uses locks, locks acquired by the implementation will be held when anyuse_count
adjustments are performed, and will not be held when any destruction or deallocation resulting from this is performed.
—end note]
3 [Example 1:
template<typename T> class atomic_list {
struct node {
T t;
shared_ptr<node> next;
};
atomic<shared_ptr<node>> head;
public:
shared_ptr<node> find(T t) const {
auto p = head.load();
while (p && p->t != t)
p = p->next;
return p;
}
void push_front(T t) {
auto p = make_shared<node>();
p->t = t;
p->next = head;
while (!head.compare_exchange_weak(p->next, p)) {}
}
};
—end example]
32.5.8.7.2 Partial specialization for shared_ptr [util.smartptr.atomic.shared]
namespace std {
template<class T> struct atomic<shared_ptr<T>> {
using value_type = shared_ptr<T>;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const noexcept;
constexpr atomic() noexcept;
constexpr atomic(nullptr_t) noexcept : atomic() { }
constexpr atomic(shared_ptr<T> desired) noexcept;
atomic(const atomic&) = delete;
void operator=(const atomic&) = delete;
constexpr shared_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
constexpr operator shared_ptr<T>() const noexcept;
constexpr void store(shared_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
constexpr void operator=(shared_ptr<T> desired) noexcept;
constexpr void operator=(nullptr_t) noexcept;
constexpr shared_ptr<T> exchange(shared_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
constexpr bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
constexpr bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
constexpr bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
§ 32.5.8.7.2 © ISO/IEC
2203

===== PAGE 2215 =====

Dxxxx
constexpr bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
constexpr void wait(shared_ptr<T> old,
memory_order order = memory_order::seq_cst) const noexcept;
constexpr void notify_one() noexcept;
constexpr void notify_all() noexcept;
private:
shared_ptr<T> p; // exposition only
};
}
constexpr atomic() noexcept;
1 Effects: Value-initializesp.
constexpr atomic(shared_ptr<T> desired) noexcept;
2 Effects: Initializes the object with the valuedesired. Initialization is not an atomic operation (6.10.2).
[Note 1: It is possible to have an access to an atomic objectA race with its construction, for example, by
communicating the address of the just-constructed objectA to another thread viamemory_order::relaxed
operations on a suitable atomic pointer variable, and then immediately accessingA in the receiving thread. This
results in undefined behavior.—end note]
constexpr void store(shared_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
3 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
4 Effects: Atomically replaces the value pointed to by this with the value of desired as if by
p.swap(desired). Memory is affected according to the value oforder.
constexpr void operator=(shared_ptr<T> desired) noexcept;
5 Effects: Equivalent tostore(desired).
constexpr void operator=(nullptr_t) noexcept;
6 Effects: Equivalent tostore(nullptr).
constexpr shared_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
7 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
8 Effects: Memory is affected according to the value oforder.
9 Returns: Atomically returnsp.
constexpr operator shared_ptr<T>() const noexcept;
10 Effects: Equivalent to:return load();
constexpr shared_ptr<T> exchange(shared_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
11 Effects: Atomically replacesp with desired as if byp.swap(desired). Memory is affected according
to the value oforder. This is an atomic read-modify-write operation (6.10.2.2).
12 Returns: Atomically returns the value ofp immediately before the effects.
constexpr bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
constexpr bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
13 Preconditions: failure is memory_order::relaxed, memory_order::acquire, or memory_order::
seq_cst.
§ 32.5.8.7.2 © ISO/IEC
2204

===== PAGE 2216 =====

Dxxxx
14 Effects: If p is equivalent to expected, assigns desired to p and has synchronization semantics
corresponding to the value ofsuccess, otherwise assigns p to expected and has synchronization
semantics corresponding to the value offailure.
15 Returns: true if p was equivalent toexpected, false otherwise.
16 Remarks: Twoshared_ptr objects are equivalent if they store the same pointer value and either share
ownership or are both empty. The weak form may fail spuriously. See 32.5.8.2.
17 If the operation returnstrue, expected is not accessed after the atomic update and the operation is
an atomic read-modify-write operation (6.10.2) on the memory pointed to bythis. Otherwise, the
operation is an atomic load operation on that memory, andexpected is updated with the existing value
read from the atomic object in the attempted atomic update. Theuse_count update corresponding to
the write toexpected is part of the atomic operation. The write toexpected itself is not required to
be part of the atomic operation.
constexpr bool compare_exchange_weak(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
18 Effects: Equivalent to:
return compare_exchange_weak(expected, desired, order, fail_order);
wherefail_orderisthesameas orderexceptthatavalueof memory_order::acq_relshallbereplaced
by the valuememory_order::acquire and a value ofmemory_order::release shall be replaced by
the valuememory_order::relaxed.
constexpr bool compare_exchange_strong(shared_ptr<T>& expected, shared_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
19 Effects: Equivalent to:
return compare_exchange_strong(expected, desired, order, fail_order);
wherefail_orderisthesameas orderexceptthatavalueof memory_order::acq_relshallbereplaced
by the valuememory_order::acquire and a value ofmemory_order::release shall be replaced by
the valuememory_order::relaxed.
constexpr void wait(shared_ptr<T> old, memory_order order = memory_order::seq_cst) const noexcept;
20 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
21 Effects: Repeatedly performs the following steps, in order:
—(21.1) Evaluates load(order) and compares it toold.
—(21.2) If the two are not equivalent, returns.
—(21.3) Blocks until it is unblocked by an atomic notifying operation or is unblocked spuriously.
22 Remarks: Two shared_ptr objects are equivalent if they store the same pointer and either share
ownership or are both empty. This function is an atomic waiting operation (32.5.6).
constexpr void notify_one() noexcept;
23 Effects: Unblocks the execution of at least one atomic waiting operation that is eligible to be unblocked
(32.5.6) by this call, if any such atomic waiting operations exist.
24 Remarks: This function is an atomic notifying operation (32.5.6).
constexpr void notify_all() noexcept;
25 Effects: Unblocks the execution of all atomic waiting operations that are eligible to be unblocked (32.5.6)
by this call.
26 Remarks: This function is an atomic notifying operation (32.5.6).
32.5.8.7.3 Partial specialization for weak_ptr [util.smartptr.atomic.weak]
namespace std {
template<class T> struct atomic<weak_ptr<T>> {
using value_type = weak_ptr<T>;
§ 32.5.8.7.3 © ISO/IEC
2205

===== PAGE 2217 =====

Dxxxx
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const noexcept;
constexpr atomic() noexcept;
constexpr atomic(weak_ptr<T> desired) noexcept;
atomic(const atomic&) = delete;
void operator=(const atomic&) = delete;
constexpr weak_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
constexpr operator weak_ptr<T>() const noexcept;
constexpr void store(weak_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
constexpr void operator=(weak_ptr<T> desired) noexcept;
constexpr weak_ptr<T> exchange(weak_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
constexpr bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
constexpr bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
constexpr bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
constexpr bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
constexpr void wait(weak_ptr<T> old,
memory_order order = memory_order::seq_cst) const noexcept;
constexpr void notify_one() noexcept;
constexpr void notify_all() noexcept;
private:
weak_ptr<T> p; // exposition only
};
}
constexpr atomic() noexcept;
1 Effects: Value-initializesp.
constexpr atomic(weak_ptr<T> desired) noexcept;
2 Effects: Initializes the object with the valuedesired. Initialization is not an atomic operation (6.10.2).
[Note 1: It is possible to have an access to an atomic objectA race with its construction, for example, by
communicating the address of the just-constructed objectA to another thread viamemory_order::relaxed
operations on a suitable atomic pointer variable, and then immediately accessingA in the receiving thread. This
results in undefined behavior.—end note]
constexpr void store(weak_ptr<T> desired, memory_order order = memory_order::seq_cst) noexcept;
3 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
4 Effects: Atomically replaces the value pointed to by this with the value of desired as if by
p.swap(desired). Memory is affected according to the value oforder.
constexpr void operator=(weak_ptr<T> desired) noexcept;
5 Effects: Equivalent tostore(desired).
constexpr weak_ptr<T> load(memory_order order = memory_order::seq_cst) const noexcept;
6 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
7 Effects: Memory is affected according to the value oforder.
8 Returns: Atomically returnsp.
§ 32.5.8.7.3 © ISO/IEC
2206

===== PAGE 2218 =====

Dxxxx
constexpr operator weak_ptr<T>() const noexcept;
9 Effects: Equivalent to:return load();
constexpr weak_ptr<T> exchange(weak_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
10 Effects: Atomically replacesp with desired as if byp.swap(desired). Memory is affected according
to the value oforder. This is an atomic read-modify-write operation (6.10.2.2).
11 Returns: Atomically returns the value ofp immediately before the effects.
constexpr bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
constexpr bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order success, memory_order failure) noexcept;
12 Preconditions: failure is memory_order::relaxed, memory_order::acquire, or memory_order::
seq_cst.
13 Effects: If p is equivalent to expected, assigns desired to p and has synchronization semantics
corresponding to the value ofsuccess, otherwise assigns p to expected and has synchronization
semantics corresponding to the value offailure.
14 Returns: true if p was equivalent toexpected, false otherwise.
15 Remarks: Twoweak_ptr objects are equivalent if they store the same pointer value and either share
ownership or are both empty. The weak form may fail spuriously. See 32.5.8.2.
16 If the operation returnstrue, expected is not accessed after the atomic update and the operation is
an atomic read-modify-write operation (6.10.2) on the memory pointed to bythis. Otherwise, the
operation is an atomic load operation on that memory, andexpected is updated with the existing value
read from the atomic object in the attempted atomic update. Theuse_count update corresponding to
the write toexpected is part of the atomic operation. The write toexpected itself is not required to
be part of the atomic operation.
constexpr bool compare_exchange_weak(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
17 Effects: Equivalent to:
return compare_exchange_weak(expected, desired, order, fail_order);
wherefail_orderisthesameas orderexceptthatavalueof memory_order::acq_relshallbereplaced
by the valuememory_order::acquire and a value ofmemory_order::release shall be replaced by
the valuememory_order::relaxed.
constexpr bool compare_exchange_strong(weak_ptr<T>& expected, weak_ptr<T> desired,
memory_order order = memory_order::seq_cst) noexcept;
18 Effects: Equivalent to:
return compare_exchange_strong(expected, desired, order, fail_order);
wherefail_orderisthesameas orderexceptthatavalueof memory_order::acq_relshallbereplaced
by the valuememory_order::acquire and a value ofmemory_order::release shall be replaced by
the valuememory_order::relaxed.
constexpr void wait(weak_ptr<T> old, memory_order order = memory_order::seq_cst) const noexcept;
19 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
20 Effects: Repeatedly performs the following steps, in order:
—(20.1) Evaluates load(order) and compares it toold.
—(20.2) If the two are not equivalent, returns.
—(20.3) Blocks until it is unblocked by an atomic notifying operation or is unblocked spuriously.
21 Remarks: Twoweak_ptr objects are equivalent if they store the same pointer and either share ownership
or are both empty. This function is an atomic waiting operation (32.5.6).
§ 32.5.8.7.3 © ISO/IEC
2207

===== PAGE 2219 =====

Dxxxx
constexpr void notify_one() noexcept;
22 Effects: Unblocks the execution of at least one atomic waiting operation that is eligible to be unblocked
(32.5.6) by this call, if any such atomic waiting operations exist.
23 Remarks: This function is an atomic notifying operation (32.5.6).
constexpr void notify_all() noexcept;
24 Effects: Unblocks the execution of all atomic waiting operations that are eligible to be unblocked (32.5.6)
by this call.
25 Remarks: This function is an atomic notifying operation (32.5.6).
32.5.9 Non-member functions [atomics.nonmembers]
1 A non-member function template whose name matches the patternatomic_f or the patternatomic_f _-
explicit invokes the member functionf , with the value of the first parameter as the object expression and
the values of the remaining parameters (if any) as the arguments of the member function call, in order. An
argument for a parameter of typeatomic<T>::value_type* is dereferenced when passed to the member
function call. If no such member function exists, the program is ill-formed.
2 [Note 1: The non-member functions enable programmers to write code that can be compiled as either C or C++, for
example in a shared header file.—end note]
32.5.10 Flag type and operations [atomics.flag]
namespace std {
struct atomic_flag {
constexpr atomic_flag() noexcept;
atomic_flag(const atomic_flag&) = delete;
atomic_flag& operator=(const atomic_flag&) = delete;
atomic_flag& operator=(const atomic_flag&) volatile = delete;
bool test(memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr bool test(memory_order = memory_order::seq_cst) const noexcept;
bool test_and_set(memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool test_and_set(memory_order = memory_order::seq_cst) noexcept;
void clear(memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void clear(memory_order = memory_order::seq_cst) noexcept;
void wait(bool, memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr void wait(bool, memory_order = memory_order::seq_cst) const noexcept;
void notify_one() volatile noexcept;
constexpr void notify_one() noexcept;
void notify_all() volatile noexcept;
constexpr void notify_all() noexcept;
};
}
1 The atomic_flag type provides the classic test-and-set functionality. It has two states, set and clear.
2 Operations on an object of typeatomic_flag shall be lock-free. The operations should also be address-free.
3 The atomic_flag type is a standard-layout struct. It has a trivial destructor.
constexpr atomic_flag::atomic_flag() noexcept;
4 Effects: Initializes *this to the clear state.
bool atomic_flag_test(const volatile atomic_flag* object) noexcept;
constexpr bool atomic_flag_test(const atomic_flag* object) noexcept;
bool atomic_flag_test_explicit(const volatile atomic_flag* object,
memory_order order) noexcept;
constexpr bool atomic_flag_test_explicit(const atomic_flag* object,
memory_order order) noexcept;
bool atomic_flag::test(memory_order order = memory_order::seq_cst) const volatile noexcept;
constexpr bool atomic_flag::test(memory_order order = memory_order::seq_cst) const noexcept;
5 For atomic_flag_test, letorder be memory_order::seq_cst.
§ 32.5.10 © ISO/IEC
2208

===== PAGE 2220 =====

Dxxxx
6 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
7 Effects: Memory is affected according to the value oforder.
8 Returns: Atomically returns the value pointed to byobject or this.
bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
constexpr bool atomic_flag_test_and_set(atomic_flag* object) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag* object, memory_order order) noexcept;
constexpr bool atomic_flag_test_and_set_explicit(atomic_flag* object, memory_order order) noexcept;
bool atomic_flag::test_and_set(memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr bool atomic_flag::test_and_set(memory_order order = memory_order::seq_cst) noexcept;
9 Effects: Atomically sets the value pointed to byobject or by this to true. Memory is affected
according to the value oforder. These operations are atomic read-modify-write operations (6.10.2).
10 Returns: Atomically, the value of the object immediately before the effects.
void atomic_flag_clear(volatile atomic_flag* object) noexcept;
constexpr void atomic_flag_clear(atomic_flag* object) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* object, memory_order order) noexcept;
constexpr void atomic_flag_clear_explicit(atomic_flag* object, memory_order order) noexcept;
void atomic_flag::clear(memory_order order = memory_order::seq_cst) volatile noexcept;
constexpr void atomic_flag::clear(memory_order order = memory_order::seq_cst) noexcept;
11 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
12 Effects: Atomically sets the value pointed to byobject or by this to false. Memory is affected
according to the value oforder.
void atomic_flag_wait(const volatile atomic_flag* object, bool old) noexcept;
constexpr void atomic_flag_wait(const atomic_flag* object, bool old) noexcept;
void atomic_flag_wait_explicit(const volatile atomic_flag* object,
bool old, memory_order order) noexcept;
constexpr void atomic_flag_wait_explicit(const atomic_flag* object,
bool old, memory_order order) noexcept;
void atomic_flag::wait(bool old, memory_order order =
memory_order::seq_cst) const volatile noexcept;
constexpr void atomic_flag::wait(bool old, memory_order order =
memory_order::seq_cst) const noexcept;
13 For atomic_flag_wait, let order be memory_order::seq_cst. Let flag be object for the non-
member functions andthis for the member functions.
14 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
15 Effects: Repeatedly performs the following steps, in order:
—(15.1) Evaluates flag->test(order) != old.
—(15.2) If the result of that evaluation istrue, returns.
—(15.3) Blocks until it is unblocked by an atomic notifying operation or is unblocked spuriously.
16 Remarks: This function is an atomic waiting operation (32.5.6).
void atomic_flag_notify_one(volatile atomic_flag* object) noexcept;
constexpr void atomic_flag_notify_one(atomic_flag* object) noexcept;
void atomic_flag::notify_one() volatile noexcept;
constexpr void atomic_flag::notify_one() noexcept;
17 Effects: Unblocks the execution of at least one atomic waiting operation that is eligible to be unblocked
(32.5.6) by this call, if any such atomic waiting operations exist.
18 Remarks: This function is an atomic notifying operation (32.5.6).
void atomic_flag_notify_all(volatile atomic_flag* object) noexcept;
constexpr void atomic_flag_notify_all(atomic_flag* object) noexcept;
void atomic_flag::notify_all() volatile noexcept;
§ 32.5.10 © ISO/IEC
2209

===== PAGE 2221 =====

Dxxxx
constexpr void atomic_flag::notify_all() noexcept;
19 Effects: Unblocks the execution of all atomic waiting operations that are eligible to be unblocked (32.5.6)
by this call.
20 Remarks: This function is an atomic notifying operation (32.5.6).
#define ATOMIC_FLAG_INIT see below
21 Remarks: The macroATOMIC_FLAG_INIT is defined in such a way that it can be used to initialize an
object of typeatomic_flag to the clear state. The macro can be used in the form:
atomic_flag guard = ATOMIC_FLAG_INIT;
It is unspecified whether the macro can be used in other initialization contexts. For a complete
static-duration object, that initialization shall be static.
32.5.11 Fences [atomics.fences]
1 This subclause introduces synchronization primitives calledfences. Fences can have acquire semantics, release
semantics, or both. A fence with acquire semantics is called anacquire fence. A fence with release semantics
is called arelease fence.
2 A release fenceAsynchronizes with an acquire fenceB if there exist atomic operationsX and Y, whereY is
not an atomic modify-write operation (32.5.4), both operating on some atomic objectM, such thatA is
sequenced beforeX, X modifies M, Y is sequenced beforeB, andY reads the value written byX or a value
written by any side effect in the hypothetical release sequenceX would head if it were a release operation.
3 A release fenceA synchronizes with an atomic operationB that performs an acquire operation on an atomic
object M if there exists an atomic operationX such thatA is sequenced beforeX, X modifies M, andB
reads the value written byX or a value written by any side effect in the hypothetical release sequenceX
would head if it were a release operation.
4 An atomic operationA that is a release operation on an atomic objectM synchronizes with an acquire fence
B if there exists some atomic operationX on M such thatX is sequenced beforeB and reads the value
written byA or a value written by any side effect in the release sequence headed byA.
extern "C" constexpr void atomic_thread_fence(memory_order order) noexcept;
5 Effects: Depending on the value oforder, this operation:
—(5.1) has no effects, iforder == memory_order::relaxed;
—(5.2) is an acquire fence, iforder == memory_order::acquire;
—(5.3) is a release fence, iforder == memory_order::release;
—(5.4) is both an acquire fence and a release fence, iforder == memory_order::acq_rel;
—(5.5) is a sequentially consistent acquire and release fence, iforder == memory_order::seq_cst.
extern "C" constexpr void atomic_signal_fence(memory_order order) noexcept;
6 Effects: Equivalent toatomic_thread_fence(order), except that the resulting ordering constraints
are established only between a thread and a signal handler executed in the same thread.
7 [Note 1: atomic_signal_fence can be used to specify the order in which actions performed by the thread
become visible to the signal handler. Compiler optimizations and reorderings of loads and stores are inhibited in
the same way as withatomic_thread_fence, but the hardware fence instructions thatatomic_thread_fence
would have inserted are not emitted.—end note]
32.5.12 C compatibility [stdatomic.h.syn]
The header<stdatomic.h> provides the following definitions:
template<class T>
using std-atomic = std::atomic<T>; // exposition only
#define _Atomic(T) std-atomic <T>
§ 32.5.12 © ISO/IEC
2210

===== PAGE 2222 =====

Dxxxx
#define ATOMIC_BOOL_LOCK_FREE see below
#define ATOMIC_CHAR_LOCK_FREE see below
#define ATOMIC_CHAR16_T_LOCK_FREE see below
#define ATOMIC_CHAR32_T_LOCK_FREE see below
#define ATOMIC_WCHAR_T_LOCK_FREE see below
#define ATOMIC_SHORT_LOCK_FREE see below
#define ATOMIC_INT_LOCK_FREE see below
#define ATOMIC_LONG_LOCK_FREE see below
#define ATOMIC_LLONG_LOCK_FREE see below
#define ATOMIC_POINTER_LOCK_FREE see below
using std::memory_order; // see below
using std::memory_order_relaxed; // see below
using std::memory_order_consume; // see below
using std::memory_order_acquire; // see below
using std::memory_order_release; // see below
using std::memory_order_acq_rel; // see below
using std::memory_order_seq_cst; // see below
using std::atomic_flag; // see below
using std::atomic_bool; // see below
using std::atomic_char; // see below
using std::atomic_schar; // see below
using std::atomic_uchar; // see below
using std::atomic_short; // see below
using std::atomic_ushort; // see below
using std::atomic_int; // see below
using std::atomic_uint; // see below
using std::atomic_long; // see below
using std::atomic_ulong; // see below
using std::atomic_llong; // see below
using std::atomic_ullong; // see below
using std::atomic_char8_t; // see below
using std::atomic_char16_t; // see below
using std::atomic_char32_t; // see below
using std::atomic_wchar_t; // see below
using std::atomic_int8_t; // see below
using std::atomic_uint8_t; // see below
using std::atomic_int16_t; // see below
using std::atomic_uint16_t; // see below
using std::atomic_int32_t; // see below
using std::atomic_uint32_t; // see below
using std::atomic_int64_t; // see below
using std::atomic_uint64_t; // see below
using std::atomic_int_least8_t; // see below
using std::atomic_uint_least8_t; // see below
using std::atomic_int_least16_t; // see below
using std::atomic_uint_least16_t; // see below
using std::atomic_int_least32_t; // see below
using std::atomic_uint_least32_t; // see below
using std::atomic_int_least64_t; // see below
using std::atomic_uint_least64_t; // see below
using std::atomic_int_fast8_t; // see below
using std::atomic_uint_fast8_t; // see below
using std::atomic_int_fast16_t; // see below
using std::atomic_uint_fast16_t; // see below
using std::atomic_int_fast32_t; // see below
using std::atomic_uint_fast32_t; // see below
using std::atomic_int_fast64_t; // see below
using std::atomic_uint_fast64_t; // see below
using std::atomic_intptr_t; // see below
using std::atomic_uintptr_t; // see below
using std::atomic_size_t; // see below
§ 32.5.12 © ISO/IEC
2211

===== PAGE 2223 =====

Dxxxx
using std::atomic_ptrdiff_t; // see below
using std::atomic_intmax_t; // see below
using std::atomic_uintmax_t; // see below
using std::atomic_is_lock_free; // see below
using std::atomic_load; // see below
using std::atomic_load_explicit; // see below
using std::atomic_store; // see below
using std::atomic_store_explicit; // see below
using std::atomic_exchange; // see below
using std::atomic_exchange_explicit; // see below
using std::atomic_compare_exchange_strong; // see below
using std::atomic_compare_exchange_strong_explicit; // see below
using std::atomic_compare_exchange_weak; // see below
using std::atomic_compare_exchange_weak_explicit; // see below
using std::atomic_fetch_add; // see below
using std::atomic_fetch_add_explicit; // see below
using std::atomic_fetch_sub; // see below
using std::atomic_fetch_sub_explicit; // see below
using std::atomic_fetch_and; // see below
using std::atomic_fetch_and_explicit; // see below
using std::atomic_fetch_or; // see below
using std::atomic_fetch_or_explicit; // see below
using std::atomic_fetch_xor; // see below
using std::atomic_fetch_xor_explicit; // see below
using std::atomic_flag_test_and_set; // see below
using std::atomic_flag_test_and_set_explicit; // see below
using std::atomic_flag_clear; // see below
using std::atomic_flag_clear_explicit; // see below
#define ATOMIC_FLAG_INIT see below
using std::atomic_thread_fence; // see below
using std::atomic_signal_fence; // see below
1 Each using-declaration for some nameA in the synopsis above makes available the same entity asstd::A
declared in<atomic> (32.5.2). Each macro listed above other than_Atomic(T) is defined as in<atomic>. It
is unspecified whether<stdatomic.h> makes available any declarations in namespacestd.
2 Each of theusing-declarations forintN_t, uintN_t, intptr_t, anduintptr_t listed above is defined if and
only if the implementation defines the correspondingtypedef-name in 32.5.2.
3 Neither the_Atomic macro, nor any of the non-macro global namespace declarations, are provided by any
C++ standard library header other than<stdatomic.h>.
4 Recommended practice: Implementations should ensure that C and C++ representations of atomic objects are
compatible, so that the same object can be accessed as both an_Atomic(T) from C code and anatomic<T>
from C++ code. The representations should be the same, and the mechanisms used to ensure atomicity and
memory ordering should be compatible.
32.6 Mutual exclusion [thread.mutex]
32.6.1 General [thread.mutex.general]
1 Subclause 32.6 provides mechanisms for mutual exclusion: mutexes, locks, and call once. These mechanisms
ease the production of race-free programs (6.10.2).
32.6.2 Header <mutex> synopsis [mutex.syn]
namespace std {
// 32.6.4.2.2, classmutex
class mutex;
// 32.6.4.2.3, classrecursive_mutex
class recursive_mutex;
// 32.6.4.3.2, classtimed_mutex
class timed_mutex;
// 32.6.4.3.3, classrecursive_timed_mutex
class recursive_timed_mutex;
§ 32.6.2 © ISO/IEC
2212

===== PAGE 2224 =====

Dxxxx
struct defer_lock_t { explicit defer_lock_t() = default; };
struct try_to_lock_t { explicit try_to_lock_t() = default; };
struct adopt_lock_t { explicit adopt_lock_t() = default; };
inline constexpr defer_lock_t defer_lock { };
inline constexpr try_to_lock_t try_to_lock { };
inline constexpr adopt_lock_t adopt_lock { };
// 32.6.5, locks
template<class Mutex> class lock_guard;
template<class... MutexTypes> class scoped_lock;
template<class Mutex> class unique_lock;
template<class Mutex>
void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;
// 32.6.6, generic locking algorithms
template<class L1, class L2, class... L3> int try_lock(L1&, L2&, L3&...);
template<class L1, class L2, class... L3> void lock(L1&, L2&, L3&...);
struct once_flag;
template<class Callable, class... Args>
void call_once(once_flag& flag, Callable&& func, Args&&... args);
}
32.6.3 Header <shared_mutex> synopsis [shared.mutex.syn]
namespace std {
// 32.6.4.4.2, classshared_mutex
class shared_mutex;
// 32.6.4.5.2, classshared_timed_mutex
class shared_timed_mutex;
// 32.6.5.5, class templateshared_lock
template<class Mutex> class shared_lock;
template<class Mutex>
void swap(shared_lock<Mutex>& x, shared_lock<Mutex>& y) noexcept;
}
32.6.4 Mutex requirements [thread.mutex.requirements]
32.6.4.1 General [thread.mutex.requirements.general]
1 A mutex object facilitates protection against data races and allows safe synchronization of data between
execution agents (32.2.5). An execution agentowns a mutex from the time it successfully calls one of the lock
functions until it calls unlock. Mutexes can be either recursive or non-recursive, and can grant simultaneous
ownership to one or many execution agents. Both recursive and non-recursive mutexes are supplied.
32.6.4.2 Mutex types [thread.mutex.requirements.mutex]
32.6.4.2.1 General [thread.mutex.requirements.mutex.general]
1 The mutex typesare the standard library typesmutex, recursive_mutex, timed_mutex, recursive_timed_-
mutex, shared_mutex, andshared_timed_mutex. They meet the requirements set out in 32.6.4.2. In this
description, m denotes an object of a mutex type.
[Note 1: The mutex types meet theCpp17Lockable requirements (32.2.5.3). —end note]
2 The mutex types meetCpp17DefaultConstructible and Cpp17Destructible. If initialization of an object of a
mutex type fails, an exception of typesystem_error is thrown. The mutex types are neither copyable nor
movable.
3 The error conditions for error codes, if any, reported by member functions of the mutex types are as follows:
—(3.1) resource_unavailable_try_again — if any native handle type manipulated is not available.
—(3.2) operation_not_permitted — if the thread does not have the privilege to perform the operation.
—(3.3) invalid_argument — if any native handle type manipulated as part of mutex construction is incorrect.
§ 32.6.4.2.1 © ISO/IEC
2213

===== PAGE 2225 =====

Dxxxx
4 The implementation provides lock and unlock operations, as described below. For purposes of determining
the existence of a data race, these behave as atomic operations (6.10.2). The lock and unlock operations on a
single mutex appears to occur in a single total order.
[Note 2: This can be viewed as the modification order (6.10.2) of the mutex.—end note]
[Note 3: Construction and destruction of an object of a mutex type need not be thread-safe; other synchronization
can be used to ensure that mutex objects are initialized and visible to other threads.—end note]
5 The expressionm.lock() is well-formed and has the following semantics:
6 Preconditions: If m is of typemutex, timed_mutex, shared_mutex, orshared_timed_mutex, the calling
thread does not own the mutex.
7 Effects: Blocks the calling thread until ownership of the mutex can be obtained for the calling thread.
8 Synchronization: Priorunlock() operations on the same objectsynchronize with(6.10.2) this operation.
9 Postconditions: The calling thread owns the mutex.
10 Return type: void.
11 Throws: system_error when an exception is required (32.2.2).
12 Error conditions:
—(12.1) operation_not_permitted — if the thread does not have the privilege to perform the operation.
—(12.2) resource_deadlock_would_occur — if the implementation detects that a deadlock would occur.
13 The expressionm.try_lock() is well-formed and has the following semantics:
14 Preconditions: If m is of typemutex, timed_mutex, shared_mutex, orshared_timed_mutex, the calling
thread does not own the mutex.
15 Effects: Attempts to obtain ownership of the mutex for the calling thread without blocking. If ownership
is not obtained, there is no effect andtry_lock() immediately returns. An implementation may fail to
obtain the lock even if it is not held by any other thread.
[Note 4: This spurious failure is normally uncommon, but allows interesting implementations based on a simple
compare and exchange (32.5).—end note]
An implementation should ensure thattry_lock() does not consistently returnfalse in the absence
of contending mutex acquisitions.
16 Synchronization: Iftry_lock()returnstrue, priorunlock()operations on the same objectsynchronize
with (6.10.2) this operation.
[Note 5: Since lock() does not synchronize with a failed subsequenttry_lock(), the visibility rules are weak
enough that little would be known about the state after a failure, even in the absence of spurious failures.
—end note]
17 Return type: bool.
18 Returns: true if ownership was obtained, otherwisefalse.
19 Throws: Nothing.
20 The expressionm.unlock() is well-formed and has the following semantics:
21 Preconditions: The calling thread owns the mutex.
22 Effects: Releases the calling thread’s ownership of the mutex.
23 Return type: void.
24 Synchronization: This operation synchronizes with (6.10.2) subsequent lock operations that obtain
ownership on the same object.
25 Throws: Nothing.
32.6.4.2.2 Class mutex [thread.mutex.class]
namespace std {
class mutex {
public:
constexpr mutex() noexcept;
~mutex();
§ 32.6.4.2.2 © ISO/IEC
2214

===== PAGE 2226 =====

Dxxxx
mutex(const mutex&) = delete;
mutex& operator=(const mutex&) = delete;
void lock();
bool try_lock();
void unlock();
using native_handle_type = implementation-defined; // see 32.2.3
native_handle_type native_handle(); // see 32.2.3
};
}
1 The classmutex provides a non-recursive mutex with exclusive ownership semantics. If one thread owns a
mutex object, attempts by another thread to acquire ownership of that object will fail (fortry_lock()) or
block (forlock()) until the owning thread has released ownership with a call tounlock().
2 [Note 1: After a threadA has calledunlock(), releasing a mutex, it is possible for another threadB to lock the same
mutex, observe that it is no longer in use, unlock it, and destroy it, before threadA appears to have returned from its
unlock call. Conforming implementations handle such scenarios correctly, as long as threadA does not access the
mutex after the unlock call returns. These cases typically occur when a reference-counted object contains a mutex
that is used to protect the reference count.—end note]
3 The classmutex meets all of the mutex requirements (32.6.4). It is a standard-layout class (11.2).
4 [Note 2: A program can deadlock if the thread that owns amutex object calls lock() on that object. If the
implementation can detect the deadlock, aresource_deadlock_would_occur error condition might be observed.
—end note]
5 The behavior of a program is undefined if it destroys amutex object owned by any thread or a thread
terminates while owning amutex object.
32.6.4.2.3 Class recursive_mutex [thread.mutex.recursive]
namespace std {
class recursive_mutex {
public:
recursive_mutex();
~recursive_mutex();
recursive_mutex(const recursive_mutex&) = delete;
recursive_mutex& operator=(const recursive_mutex&) = delete;
void lock();
bool try_lock() noexcept;
void unlock();
using native_handle_type = implementation-defined; // see 32.2.3
native_handle_type native_handle(); // see 32.2.3
};
}
1 The classrecursive_mutex provides a recursive mutex with exclusive ownership semantics. If one thread
owns arecursive_mutex object, attempts by another thread to acquire ownership of that object will fail
(for try_lock()) or block (forlock()) until the first thread has completely released ownership.
2 The classrecursive_mutex meets all of the mutex requirements (32.6.4). It is a standard-layout class (11.2).
3 A thread that owns arecursive_mutex object may acquire additional levels of ownership by callinglock()
or try_lock() on that object. It is unspecified how many levels of ownership may be acquired by a single
thread. If a thread has already acquired the maximum level of ownership for arecursive_mutex object,
additional calls totry_lock() fail, and additional calls tolock() throw an exception of typesystem_error.
A thread shall callunlock() once for each level of ownership acquired by calls tolock() and try_lock().
Only when all levels of ownership have been released may ownership be acquired by another thread.
4 The behavior of a program is undefined if
—(4.1) it destroys arecursive_mutex object owned by any thread or
—(4.2) a thread terminates while owning arecursive_mutex object.
§ 32.6.4.2.3 © ISO/IEC
2215

===== PAGE 2227 =====

Dxxxx
32.6.4.3 Timed mutex types [thread.timedmutex.requirements]
32.6.4.3.1 General [thread.timedmutex.requirements.general]
1 The timed mutex typesare the standard library typestimed_mutex, recursive_timed_mutex, andshared_-
timed_mutex. They meet the requirements set out below. In this description,m denotes an object of a mutex
type, rel_time denotes an object of an instantiation ofduration (30.5), andabs_time denotes an object of
an instantiation oftime_point (30.6).
[Note 1: The timed mutex types meet theCpp17TimedLockablerequirements (32.2.5.4). —end note]
2 The expressionm.try_lock_for(rel_time) is well-formed and has the following semantics:
3 Preconditions: If m is of typetimed_mutex or shared_timed_mutex, the calling thread does not own
the mutex.
4 Effects: The function attempts to obtain ownership of the mutex within the relative timeout (32.2.4)
specified byrel_time. If the time specified byrel_time is less than or equal torel_time.zero(), the
function attempts to obtain ownership without blocking (as if by callingtry_lock()). The function
returns within the timeout specified byrel_time only if it has obtained ownership of the mutex object.
[Note 2: As withtry_lock(), there is no guarantee that ownership will be obtained if the lock is available, but
implementations are expected to make a strong effort to do so.—end note]
5 Synchronization: If try_lock_for() returns true, prior unlock() operations on the same object
synchronize with(6.10.2) this operation.
6 Return type: bool.
7 Returns: true if ownership was obtained, otherwisefalse.
8 Throws: Timeout-related exceptions (32.2.4).
9 The expressionm.try_lock_until(abs_time) is well-formed and has the following semantics:
10 Preconditions: If m is of typetimed_mutex or shared_timed_mutex, the calling thread does not own
the mutex.
11 Effects: The function attempts to obtain ownership of the mutex. Ifabs_time has already passed, the
function attempts to obtain ownership without blocking (as if by callingtry_lock()). The function
returns before the absolute timeout (32.2.4) specified byabs_time only if it has obtained ownership of
the mutex object.
[Note 3: As withtry_lock(), there is no guarantee that ownership will be obtained if the lock is available, but
implementations are expected to make a strong effort to do so.—end note]
12 Synchronization: If try_lock_until() returns true, priorunlock() operations on the same object
synchronize with(6.10.2) this operation.
13 Return type: bool.
14 Returns: true if ownership was obtained, otherwisefalse.
15 Throws: Timeout-related exceptions (32.2.4).
32.6.4.3.2 Class timed_mutex [thread.timedmutex.class]
namespace std {
class timed_mutex {
public:
timed_mutex();
~timed_mutex();
timed_mutex(const timed_mutex&) = delete;
timed_mutex& operator=(const timed_mutex&) = delete;
void lock(); // blocking
bool try_lock();
template<class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
void unlock();
§ 32.6.4.3.2 © ISO/IEC
2216

===== PAGE 2228 =====

Dxxxx
using native_handle_type = implementation-defined; // see 32.2.3
native_handle_type native_handle(); // see 32.2.3
};
}
1 The classtimed_mutex provides a non-recursive mutex with exclusive ownership semantics. If one thread
owns atimed_mutex object, attempts by another thread to acquire ownership of that object will fail (for
try_lock()) or block (forlock(), try_lock_for(), andtry_lock_until()) until the owning thread has
released ownership with a call tounlock() or the call totry_lock_for() or try_lock_until() times out
(having failed to obtain ownership).
2 The class timed_mutex meets all of the timed mutex requirements (32.6.4.3). It is a standard-layout
class (11.2).
3 The behavior of a program is undefined if
—(3.1) it destroys atimed_mutex object owned by any thread,
—(3.2) a thread that owns atimed_mutex object callslock(), try_lock(), try_lock_for(), ortry_lock_-
until() on that object, or
—(3.3) a thread terminates while owning atimed_mutex object.
32.6.4.3.3 Class recursive_timed_mutex [thread.timedmutex.recursive]
namespace std {
class recursive_timed_mutex {
public:
recursive_timed_mutex();
~recursive_timed_mutex();
recursive_timed_mutex(const recursive_timed_mutex&) = delete;
recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;
void lock(); // blocking
bool try_lock() noexcept;
template<class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
void unlock();
using native_handle_type = implementation-defined; // see 32.2.3
native_handle_type native_handle(); // see 32.2.3
};
}
1 The classrecursive_timed_mutex provides a recursive mutex with exclusive ownership semantics. If one
thread owns arecursive_timed_mutex object, attempts by another thread to acquire ownership of that
object will fail (fortry_lock()) or block (forlock(), try_lock_for(), andtry_lock_until()) until the
owning thread has completely released ownership or the call totry_lock_for() or try_lock_until() times
out (having failed to obtain ownership).
2 The classrecursive_timed_mutex meets all of the timed mutex requirements (32.6.4.3). It is a standard-
layout class (11.2).
3 A thread that owns arecursive_timed_mutex object may acquire additional levels of ownership by calling
lock(), try_lock(), try_lock_for(), ortry_lock_until() on that object. It is unspecified how many
levels of ownership may be acquired by a single thread. If a thread has already acquired the maximum level of
ownership for arecursive_timed_mutex object, additional calls totry_lock(), try_lock_for(), ortry_-
lock_until() fail, and additional calls tolock() throw an exception of typesystem_error. A thread shall
call unlock() once for each level of ownership acquired by calls tolock(), try_lock(), try_lock_for(),
and try_lock_until(). Only when all levels of ownership have been released may ownership of the object
be acquired by another thread.
4 The behavior of a program is undefined if
—(4.1) it destroys arecursive_timed_mutex object owned by any thread, or
§ 32.6.4.3.3 © ISO/IEC
2217

===== PAGE 2229 =====

Dxxxx
—(4.2) a thread terminates while owning arecursive_timed_mutex object.
32.6.4.4 Shared mutex types [thread.sharedmutex.requirements]
32.6.4.4.1 General [thread.sharedmutex.requirements.general]
1 The standard library typesshared_mutex and shared_timed_mutex are shared mutex types. Shared mutex
types meet the requirements of mutex types (32.6.4.2) and additionally meet the requirements set out below.
In this description,m denotes an object of a shared mutex type.
[Note 1: The shared mutex types meet theCpp17SharedLockablerequirements (32.2.5.5). —end note]
2 In addition to the exclusive lock ownership mode specified in 32.6.4.2, shared mutex types provide ashared
lock ownership mode. Multiple execution agents can simultaneously hold a shared lock ownership of a shared
mutex type. But no execution agent holds a shared lock while another execution agent holds an exclusive
lock on the same shared mutex type, and vice-versa. The maximum number of execution agents which can
share a shared lock on a single shared mutex type is unspecified, but is at least 10000. If more than the
maximum number of execution agents attempt to obtain a shared lock, the excess execution agents block
until the number of shared locks are reduced below the maximum amount by other execution agents releasing
their shared lock.
3 The expressionm.lock_shared() is well-formed and has the following semantics:
4 Preconditions: The calling thread has no ownership of the mutex.
5 Effects: Blocks the calling thread until shared ownership of the mutex can be obtained for the calling
thread. If an exception is thrown then a shared lock has not been acquired for the current thread.
6 Synchronization: Priorunlock() operations on the same object synchronize with (6.10.2) this operation.
7 Postconditions: The calling thread has a shared lock on the mutex.
8 Return type: void.
9 Throws: system_error when an exception is required (32.2.2).
10 Error conditions:
—(10.1) operation_not_permitted — if the thread does not have the privilege to perform the operation.
—(10.2) resource_deadlock_would_occur — if the implementation detects that a deadlock would occur.
11 The expressionm.unlock_shared() is well-formed and has the following semantics:
12 Preconditions: The calling thread holds a shared lock on the mutex.
13 Effects: Releases a shared lock on the mutex held by the calling thread.
14 Return type: void.
15 Synchronization: This operation synchronizes with (6.10.2) subsequentlock() operations that obtain
ownership on the same object.
16 Throws: Nothing.
17 The expressionm.try_lock_shared() is well-formed and has the following semantics:
18 Preconditions: The calling thread has no ownership of the mutex.
19 Effects: Attempts to obtain shared ownership of the mutex for the calling thread without blocking. If
shared ownership is not obtained, there is no effect andtry_lock_shared() immediately returns. An
implementation may fail to obtain the lock even if it is not held by any other thread.
20 Synchronization: If try_lock_shared() returns true, priorunlock() operations on the same object
synchronize with (6.10.2) this operation.
21 Return type: bool.
22 Returns: true if the shared lock was acquired, otherwisefalse.
23 Throws: Nothing.
32.6.4.4.2 Class shared_mutex [thread.sharedmutex.class]
namespace std {
class shared_mutex {
public:
shared_mutex();
§ 32.6.4.4.2 © ISO/IEC
2218

===== PAGE 2230 =====

Dxxxx
~shared_mutex();
shared_mutex(const shared_mutex&) = delete;
shared_mutex& operator=(const shared_mutex&) = delete;
// exclusive ownership
void lock(); // blocking
bool try_lock();
void unlock();
// shared ownership
void lock_shared(); // blocking
bool try_lock_shared();
void unlock_shared();
using native_handle_type = implementation-defined; // see 32.2.3
native_handle_type native_handle(); // see 32.2.3
};
}
1 The classshared_mutex provides a non-recursive mutex with shared ownership semantics.
2 The class shared_mutex meets all of the shared mutex requirements (32.6.4.4). It is a standard-layout
class (11.2).
3 The behavior of a program is undefined if
—(3.1) it destroys ashared_mutex object owned by any thread,
—(3.2) a thread attempts to recursively gain any ownership of ashared_mutex, or
—(3.3) a thread terminates while possessing any ownership of ashared_mutex.
4 shared_mutex may be a synonym forshared_timed_mutex.
32.6.4.5 Shared timed mutex types [thread.sharedtimedmutex.requirements]
32.6.4.5.1 General [thread.sharedtimedmutex.requirements.general]
1 The standard library typeshared_timed_mutex is ashared timed mutex type. Shared timed mutex types
meet the requirements of timed mutex types (32.6.4.3), shared mutex types (32.6.4.4), and additionally
meet the requirements set out below. In this description,m denotes an object of a shared timed mutex type,
rel_time denotes an object of an instantiation ofduration (30.5), andabs_time denotes an object of an
instantiation oftime_point (30.6).
[Note 1: The shared timed mutex types meet theCpp17SharedTimedLockablerequirements (32.2.5.6). —end note]
2 The expressionm.try_lock_shared_for(rel_time) is well-formed and has the following semantics:
3 Preconditions: The calling thread has no ownership of the mutex.
4 Effects: Attempts to obtain shared lock ownership for the calling thread within the relative timeout
(32.2.4) specified by rel_time. If the time specified by rel_time is less than or equal torel_-
time.zero(), the function attempts to obtain ownership without blocking (as if by callingtry_lock_-
shared()). The function returns within the timeout specified byrel_time only if it has obtained
shared ownership of the mutex object.
[Note 2: As withtry_lock(), there is no guarantee that ownership will be obtained if the lock is available, but
implementations are expected to make a strong effort to do so.—end note]
If an exception is thrown then a shared lock has not been acquired for the current thread.
5 Synchronization: If try_lock_shared_for() returns true, priorunlock() operations on the same
object synchronize with (6.10.2) this operation.
6 Return type: bool.
7 Returns: true if the shared lock was acquired, otherwisefalse.
8 Throws: Timeout-related exceptions (32.2.4).
9 The expressionm.try_lock_shared_until(abs_time) is well-formed and has the following semantics:
10 Preconditions: The calling thread has no ownership of the mutex.
§ 32.6.4.5.1 © ISO/IEC
2219

===== PAGE 2231 =====

Dxxxx
11 Effects: The function attempts to obtain shared ownership of the mutex. Ifabs_time has already
passed, the function attempts to obtain shared ownership without blocking (as if by callingtry_lock_-
shared()). The function returns before the absolute timeout (32.2.4) specified byabs_time only if it
has obtained shared ownership of the mutex object.
[Note 3: As withtry_lock(), there is no guarantee that ownership will be obtained if the lock is available, but
implementations are expected to make a strong effort to do so.—end note]
If an exception is thrown then a shared lock has not been acquired for the current thread.
12 Synchronization: If try_lock_shared_until() returns true, priorunlock() operations on the same
object synchronize with (6.10.2) this operation.
13 Return type: bool.
14 Returns: true if the shared lock was acquired, otherwisefalse.
15 Throws: Timeout-related exceptions (32.2.4).
32.6.4.5.2 Class shared_timed_mutex [thread.sharedtimedmutex.class]
namespace std {
class shared_timed_mutex {
public:
shared_timed_mutex();
~shared_timed_mutex();
shared_timed_mutex(const shared_timed_mutex&) = delete;
shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;
// exclusive ownership
void lock(); // blocking
bool try_lock();
template<class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
void unlock();
// shared ownership
void lock_shared(); // blocking
bool try_lock_shared();
template<class Rep, class Period>
bool try_lock_shared_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_lock_shared_until(const chrono::time_point<Clock, Duration>& abs_time);
void unlock_shared();
};
}
1 The classshared_timed_mutex provides a non-recursive mutex with shared ownership semantics.
2 The classshared_timed_mutex meets all of the shared timed mutex requirements (32.6.4.5). It is a standard-
layout class (11.2).
3 The behavior of a program is undefined if
—(3.1) it destroys ashared_timed_mutex object owned by any thread,
—(3.2) a thread attempts to recursively gain any ownership of ashared_timed_mutex, or
—(3.3) a thread terminates while possessing any ownership of ashared_timed_mutex.
32.6.5 Locks [thread.lock]
32.6.5.1 General [thread.lock.general]
1 A lock is an object that holds a reference to a lockable object and may unlock the lockable object during the
lock’s destruction (such as when leaving block scope). An execution agent may use a lock to aid in managing
ownership of a lockable object in an exception safe manner. A lock is said toown a lockable object if it is
§ 32.6.5.1 © ISO/IEC
2220

===== PAGE 2232 =====

Dxxxx
currently managing the ownership of that lockable object for an execution agent. A lock does not manage
the lifetime of the lockable object it references.
[Note 1: Locks are intended to ease the burden of unlocking the lockable object under both normal and exceptional
circumstances. —end note]
2 Some lock constructors take tag types which describe what should be done with the lockable object during
the lock’s construction.
namespace std {
struct defer_lock_t { }; // do not acquire ownership of the mutex
struct try_to_lock_t { }; // try to acquire ownership of the mutex
// without blocking
struct adopt_lock_t { }; // assume the calling thread has already
// obtained mutex ownership and manage it
inline constexpr defer_lock_t defer_lock { };
inline constexpr try_to_lock_t try_to_lock { };
inline constexpr adopt_lock_t adopt_lock { };
}
32.6.5.2 Class template lock_guard [thread.lock.guard]
namespace std {
template<class Mutex>
class lock_guard {
public:
using mutex_type = Mutex;
explicit lock_guard(mutex_type& m);
lock_guard(mutex_type& m, adopt_lock_t);
~lock_guard();
lock_guard(const lock_guard&) = delete;
lock_guard& operator=(const lock_guard&) = delete;
private:
mutex_type& pm; // exposition only
};
}
1 An object of typelock_guardcontrols the ownership of a lockable object within a scope. Alock_guardobject
maintains ownership of a lockable object throughout thelock_guard object’s lifetime (6.8.4). The behavior
of a program is undefined if the lockable object referenced bypm does not exist for the entire lifetime of the
lock_guard object. The suppliedMutex type shall meet theCpp17BasicLockable requirements (32.2.5.2).
explicit lock_guard(mutex_type& m);
2 Effects: Initializes pm with m. Calls m.lock().
lock_guard(mutex_type& m, adopt_lock_t);
3 Preconditions: The calling thread holds a non-shared lock onm.
4 Effects: Initializes pm with m.
5 Throws: Nothing.
~lock_guard();
6 Effects: Equivalent to:pm.unlock()
32.6.5.3 Class template scoped_lock [thread.lock.scoped]
namespace std {
template<class... MutexTypes>
class scoped_lock {
public:
using mutex_type = see below ; // Only ifsizeof...(MutexTypes) == 1 is true
§ 32.6.5.3 © ISO/IEC
2221

===== PAGE 2233 =====

Dxxxx
explicit scoped_lock(MutexTypes&... m);
explicit scoped_lock(adopt_lock_t, MutexTypes&... m);
~scoped_lock();
scoped_lock(const scoped_lock&) = delete;
scoped_lock& operator=(const scoped_lock&) = delete;
private:
tuple<MutexTypes&...> pm; // exposition only
};
}
1 An object of typescoped_lock controls the ownership of lockable objects within a scope. Ascoped_lock
object maintains ownership of lockable objects throughout thescoped_lock object’s lifetime (6.8.4). The
behavior of a program is undefined if the lockable objects referenced bypm do not exist for the entire lifetime
of thescoped_lock object.
—(1.1) If sizeof...(MutexTypes) is one, letMutex denote the sole type constituting the packMutexTypes.
Mutex shall meet theCpp17BasicLockable requirements (32.2.5.2). The membertypedef-name mutex_-
type denotes the same type asMutex.
—(1.2) Otherwise, all types in the template parameter pack MutexTypes shall meet the Cpp17Lockable
requirements (32.2.5.3) and there is no membermutex_type.
explicit scoped_lock(MutexTypes&... m);
2 Effects: Initializes pm with tie(m...). Then ifsizeof...(MutexTypes) is 0, no effects. Otherwise if
sizeof...(MutexTypes) is 1, thenm.lock(). Otherwise, lock(m...).
explicit scoped_lock(adopt_lock_t, MutexTypes&... m);
3 Preconditions: The calling thread holds a non-shared lock on each element ofm.
4 Effects: Initializes pm with tie(m...).
5 Throws: Nothing.
~scoped_lock();
6 Effects: For alli in [0,sizeof...(MutexTypes)), get<i>(pm).unlock().
32.6.5.4 Class template unique_lock [thread.lock.unique]
32.6.5.4.1 General [thread.lock.unique.general]
namespace std {
template<class Mutex>
class unique_lock {
public:
using mutex_type = Mutex;
// 32.6.5.4.2, construct/copy/destroy
unique_lock() noexcept;
explicit unique_lock(mutex_type& m);
unique_lock(mutex_type& m, defer_lock_t) noexcept;
unique_lock(mutex_type& m, try_to_lock_t);
unique_lock(mutex_type& m, adopt_lock_t);
template<class Clock, class Duration>
unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
template<class Rep, class Period>
unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
~unique_lock();
unique_lock(const unique_lock&) = delete;
unique_lock& operator=(const unique_lock&) = delete;
unique_lock(unique_lock&& u) noexcept;
unique_lock& operator=(unique_lock&& u) noexcept;
§ 32.6.5.4.1 © ISO/IEC
2222

===== PAGE 2234 =====

Dxxxx
// 32.6.5.4.3, locking
void lock();
bool try_lock();
template<class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
void unlock();
// 32.6.5.4.4, modifiers
void swap(unique_lock& u) noexcept;
mutex_type* release() noexcept;
// 32.6.5.4.5, observers
bool owns_lock() const noexcept;
explicit operator bool() const noexcept;
mutex_type* mutex() const noexcept;
private:
mutex_type* pm; // exposition only
bool owns; // exposition only
};
}
1 An object of typeunique_lock controls the ownership of a lockable object within a scope. Ownership of
the lockable object may be acquired at construction or after construction, and may be transferred, after
acquisition, to anotherunique_lock object. Objects of typeunique_lock are not copyable but are movable.
The behavior of a program is undefined if the contained pointerpm is not null and the lockable object pointed
to bypm does not exist for the entire remaining lifetime (6.8.4) of theunique_lock object. The supplied
Mutex type shall meet theCpp17BasicLockable requirements (32.2.5.2).
2 [Note 1: unique_lock<Mutex> meets the Cpp17BasicLockable requirements. If Mutex meets the Cpp17Lockable
requirements (32.2.5.3), unique_lock<Mutex> also meets the Cpp17Lockable requirements; if Mutex meets the
Cpp17TimedLockablerequirements (32.2.5.4),unique_lock<Mutex> also meets theCpp17TimedLockablerequirements.
—end note]
32.6.5.4.2 Constructors, destructor, and assignment [thread.lock.unique.cons]
unique_lock() noexcept;
1 Postconditions: pm == nullptr and owns == false.
explicit unique_lock(mutex_type& m);
2 Effects: Calls m.lock().
3 Postconditions: pm == addressof(m) and owns == true.
unique_lock(mutex_type& m, defer_lock_t) noexcept;
4 Postconditions: pm == addressof(m) and owns == false.
unique_lock(mutex_type& m, try_to_lock_t);
5 Preconditions: The suppliedMutex type meets theCpp17Lockable requirements (32.2.5.3).
6 Effects: Calls m.try_lock().
7 Postconditions: pm == addressof(m) and owns == res, whereres is the value returned by the call
to m.try_lock().
unique_lock(mutex_type& m, adopt_lock_t);
8 Preconditions: The calling thread holds a non-shared lock onm.
9 Postconditions: pm == addressof(m) and owns == true.
10 Throws: Nothing.
§ 32.6.5.4.2 © ISO/IEC
2223

===== PAGE 2235 =====

Dxxxx
template<class Clock, class Duration>
unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
11 Preconditions: The suppliedMutex type meets theCpp17TimedLockablerequirements (32.2.5.4).
12 Effects: Calls m.try_lock_until(abs_time).
13 Postconditions: pm == addressof(m) and owns == res, whereres is the value returned by the call
to m.try_lock_until(abs_time).
template<class Rep, class Period>
unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
14 Preconditions: The suppliedMutex type meets theCpp17TimedLockablerequirements (32.2.5.4).
15 Effects: Calls m.try_lock_for(rel_time).
16 Postconditions: pm == addressof(m) and owns == res, whereres is the value returned by the call
to m.try_lock_for(rel_time).
unique_lock(unique_lock&& u) noexcept;
17 Postconditions: pm == u_p.pm and owns == u_p.owns (where u_p is the state ofu just prior to this
construction), u.pm == 0 and u.owns == false.
unique_lock& operator=(unique_lock&& u) noexcept;
18 Effects: Equivalent to:unique_lock(std::move(u)).swap(*this)
19 Returns: *this.
~unique_lock();
20 Effects: If owns calls pm->unlock().
32.6.5.4.3 Locking [thread.lock.unique.locking]
void lock();
1 Effects: As if bypm->lock().
2 Postconditions: owns == true.
3 Throws: Any exception thrown bypm->lock(). system_error when an exception is required (32.2.2).
4 Error conditions:
—(4.1) operation_not_permitted — ifpm is nullptr.
—(4.2) resource_deadlock_would_occur — if on entryowns is true.
bool try_lock();
5 Preconditions: The suppliedMutex meets theCpp17Lockable requirements (32.2.5.3).
6 Effects: As if bypm->try_lock().
7 Postconditions: owns == res, whereres is the value returned bypm->try_lock().
8 Returns: The value returned bypm->try_lock().
9 Throws: Any exception thrown bypm->try_lock(). system_error when an exception is required
(32.2.2).
10 Error conditions:
—(10.1) operation_not_permitted — ifpm is nullptr.
—(10.2) resource_deadlock_would_occur — if on entryowns is true.
template<class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
11 Preconditions: The suppliedMutex type meets theCpp17TimedLockablerequirements (32.2.5.4).
12 Effects: As if bypm->try_lock_until(abs_time).
13 Postconditions: owns == res, whereres is the value returned bypm->try_lock_until(abs_time).
14 Returns: The value returned bypm->try_lock_until(abs_time).
§ 32.6.5.4.3 © ISO/IEC
2224

===== PAGE 2236 =====

Dxxxx
15 Throws: Any exception thrown bypm->try_lock_until(abstime). system_error when an exception
is required (32.2.2).
16 Error conditions:
—(16.1) operation_not_permitted — ifpm is nullptr.
—(16.2) resource_deadlock_would_occur — if on entryowns is true.
template<class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
17 Preconditions: The suppliedMutex type meets theCpp17TimedLockablerequirements (32.2.5.4).
18 Effects: As if bypm->try_lock_for(rel_time).
19 Postconditions: owns == res, whereres is the value returned bypm->try_lock_for(rel_time).
20 Returns: The value returned bypm->try_lock_for(rel_time).
21 Throws: Any exception thrown bypm->try_lock_for(rel_time). system_error when an exception
is required (32.2.2).
22 Error conditions:
—(22.1) operation_not_permitted — ifpm is nullptr.
—(22.2) resource_deadlock_would_occur — if on entryowns is true.
void unlock();
23 Effects: As if bypm->unlock().
24 Postconditions: owns == false.
25 Throws: system_error when an exception is required (32.2.2).
26 Error conditions:
—(26.1) operation_not_permitted — if on entryowns is false.
32.6.5.4.4 Modifiers [thread.lock.unique.mod]
void swap(unique_lock& u) noexcept;
1 Effects: Swaps the data members of*this and u.
mutex_type* release() noexcept;
2 Postconditions: pm == 0 and owns == false.
3 Returns: The previous value ofpm.
template<class Mutex>
void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;
4 Effects: As if byx.swap(y).
32.6.5.4.5 Observers [thread.lock.unique.obs]
bool owns_lock() const noexcept;
1 Returns: owns.
explicit operator bool() const noexcept;
2 Returns: owns.
mutex_type *mutex() const noexcept;
3 Returns: pm.
32.6.5.5 Class template shared_lock [thread.lock.shared]
32.6.5.5.1 General [thread.lock.shared.general]
namespace std {
template<class Mutex>
class shared_lock {
§ 32.6.5.5.1 © ISO/IEC
2225

===== PAGE 2237 =====

Dxxxx
public:
using mutex_type = Mutex;
// 32.6.5.5.2, construct/copy/destroy
shared_lock() noexcept;
explicit shared_lock(mutex_type& m); // blocking
shared_lock(mutex_type& m, defer_lock_t) noexcept;
shared_lock(mutex_type& m, try_to_lock_t);
shared_lock(mutex_type& m, adopt_lock_t);
template<class Clock, class Duration>
shared_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
template<class Rep, class Period>
shared_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
~shared_lock();
shared_lock(const shared_lock&) = delete;
shared_lock& operator=(const shared_lock&) = delete;
shared_lock(shared_lock&& u) noexcept;
shared_lock& operator=(shared_lock&& u) noexcept;
// 32.6.5.5.3, locking
void lock(); // blocking
bool try_lock();
template<class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
void unlock();
// 32.6.5.5.4, modifiers
void swap(shared_lock& u) noexcept;
mutex_type* release() noexcept;
// 32.6.5.5.5, observers
bool owns_lock() const noexcept;
explicit operator bool() const noexcept;
mutex_type* mutex() const noexcept;
private:
mutex_type* pm; // exposition only
bool owns; // exposition only
};
}
1 An object of typeshared_lock controls the shared ownership of a lockable object within a scope. Shared
ownership of the lockable object may be acquired at construction or after construction, and may be transferred,
after acquisition, to anothershared_lock object. Objects of typeshared_lock are not copyable but are
movable. The behavior of a program is undefined if the contained pointerpm is not null and the lockable
object pointed to bypm does not exist for the entire remaining lifetime (6.8.4) of theshared_lock object.
The suppliedMutex type shall meet theCpp17SharedLockablerequirements (32.2.5.5).
2 [Note 1: shared_lock<Mutex> meets theCpp17Lockable requirements (32.2.5.3). IfMutex meets theCpp17Shared-
TimedLockable requirements (32.2.5.6), shared_lock<Mutex> also meets the Cpp17TimedLockable requirements
(32.2.5.4). —end note]
32.6.5.5.2 Constructors, destructor, and assignment [thread.lock.shared.cons]
shared_lock() noexcept;
1 Postconditions: pm == nullptr and owns == false.
explicit shared_lock(mutex_type& m);
2 Effects: Calls m.lock_shared().
3 Postconditions: pm == addressof(m) and owns == true.
§ 32.6.5.5.2 © ISO/IEC
2226

===== PAGE 2238 =====

Dxxxx
shared_lock(mutex_type& m, defer_lock_t) noexcept;
4 Postconditions: pm == addressof(m) and owns == false.
shared_lock(mutex_type& m, try_to_lock_t);
5 Effects: Calls m.try_lock_shared().
6 Postconditions: pm == addressof(m) and owns == res where res is the value returned by the call to
m.try_lock_shared().
shared_lock(mutex_type& m, adopt_lock_t);
7 Preconditions: The calling thread holds a shared lock onm.
8 Postconditions: pm == addressof(m) and owns == true.
template<class Clock, class Duration>
shared_lock(mutex_type& m,
const chrono::time_point<Clock, Duration>& abs_time);
9 Preconditions: Mutex meets theCpp17SharedTimedLockablerequirements (32.2.5.6).
10 Effects: Calls m.try_lock_shared_until(abs_time).
11 Postconditions: pm == addressof(m) and owns == res where res is the value returned by the call to
m.try_lock_shared_until(abs_time).
template<class Rep, class Period>
shared_lock(mutex_type& m,
const chrono::duration<Rep, Period>& rel_time);
12 Preconditions: Mutex meets theCpp17SharedTimedLockablerequirements (32.2.5.6).
13 Effects: Calls m.try_lock_shared_for(rel_time).
14 Postconditions: pm == addressof(m) and owns == res where res is the value returned by the call to
m.try_lock_shared_for(rel_time).
~shared_lock();
15 Effects: If owns calls pm->unlock_shared().
shared_lock(shared_lock&& sl) noexcept;
16 Postconditions: pm == sl_p.pm and owns == sl_p.owns (where sl_p is the state ofsl just prior to
this construction),sl.pm == nullptr and sl.owns == false.
shared_lock& operator=(shared_lock&& sl) noexcept;
17 Effects: Equivalent to:shared_lock(std::move(sl)).swap(*this)
18 Returns: *this.
32.6.5.5.3 Locking [thread.lock.shared.locking]
void lock();
1 Effects: As if bypm->lock_shared().
2 Postconditions: owns == true.
3 Throws: Any exception thrown bypm->lock_shared(). system_error when an exception is required
(32.2.2).
4 Error conditions:
—(4.1) operation_not_permitted — ifpm is nullptr.
—(4.2) resource_deadlock_would_occur — if on entryowns is true.
bool try_lock();
5 Effects: As if bypm->try_lock_shared().
6 Postconditions: owns == res, whereres is the value returned by the call topm->try_lock_shared().
7 Returns: The value returned by the call topm->try_lock_shared().
§ 32.6.5.5.3 © ISO/IEC
2227

===== PAGE 2239 =====

Dxxxx
8 Throws: Any exception thrown bypm->try_lock_shared(). system_error when an exception is
required (32.2.2).
9 Error conditions:
—(9.1) operation_not_permitted — ifpm is nullptr.
—(9.2) resource_deadlock_would_occur — if on entryowns is true.
template<class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
10 Preconditions: Mutex meets theCpp17SharedTimedLockablerequirements (32.2.5.6).
11 Effects: As if bypm->try_lock_shared_until(abs_time).
12 Postconditions: owns == res, whereres is the value returned by the call topm->try_lock_shared_-
until(abs_time).
13 Returns: The value returned by the call topm->try_lock_shared_until(abs_time).
14 Throws: Any exception thrown bypm->try_lock_shared_until(abs_time). system_error when an
exception is required (32.2.2).
15 Error conditions:
—(15.1) operation_not_permitted — ifpm is nullptr.
—(15.2) resource_deadlock_would_occur — if on entryowns is true.
template<class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
16 Preconditions: Mutex meets theCpp17SharedTimedLockablerequirements (32.2.5.6).
17 Effects: As if bypm->try_lock_shared_for(rel_time).
18 Postconditions: owns == res, whereres is the value returned by the call topm->try_lock_shared_-
for(rel_time).
19 Returns: The value returned by the call topm->try_lock_shared_for(rel_time).
20 Throws: Any exception thrown bypm->try_lock_shared_for(rel_time). system_error when an
exception is required (32.2.2).
21 Error conditions:
—(21.1) operation_not_permitted — ifpm is nullptr.
—(21.2) resource_deadlock_would_occur — if on entryowns is true.
void unlock();
22 Effects: As if bypm->unlock_shared().
23 Postconditions: owns == false.
24 Throws: system_error when an exception is required (32.2.2).
25 Error conditions:
—(25.1) operation_not_permitted — if on entryowns is false.
32.6.5.5.4 Modifiers [thread.lock.shared.mod]
void swap(shared_lock& sl) noexcept;
1 Effects: Swaps the data members of*this and sl.
mutex_type* release() noexcept;
2 Postconditions: pm == nullptr and owns == false.
3 Returns: The previous value ofpm.
template<class Mutex>
void swap(shared_lock<Mutex>& x, shared_lock<Mutex>& y) noexcept;
4 Effects: As if byx.swap(y).
§ 32.6.5.5.4 © ISO/IEC
2228

===== PAGE 2240 =====

Dxxxx
32.6.5.5.5 Observers [thread.lock.shared.obs]
bool owns_lock() const noexcept;
1 Returns: owns.
explicit operator bool() const noexcept;
2 Returns: owns.
mutex_type* mutex() const noexcept;
3 Returns: pm.
32.6.6 Generic locking algorithms [thread.lock.algorithm]
template<class L1, class L2, class... L3> int try_lock(L1&, L2&, L3&...);
1 Preconditions: Each template parameter type meets theCpp17Lockable requirements.
[Note 1: The unique_lock class template meets these requirements when suitably instantiated.—end note]
2 Effects: Calls try_lock() for each argument in order beginning with the first until all arguments have
been processed or a call totry_lock() fails, either by returningfalse or by throwing an exception. If a
call totry_lock() fails, unlock() is called for all prior arguments with no further calls totry_lock().
3 Returns: -1 if all calls totry_lock() returned true, otherwise a zero-based index value that indicates
the argument for whichtry_lock() returned false.
template<class L1, class L2, class... L3> void lock(L1&, L2&, L3&...);
4 Preconditions: Each template parameter type meets theCpp17Lockable requirements.
[Note 2: The unique_lock class template meets these requirements when suitably instantiated.—end note]
5 Effects: All arguments are locked via a sequence of calls tolock(), try_lock(), orunlock() on each
argument. The sequence of calls does not result in deadlock, but is otherwise unspecified.
[Note 3: A deadlock avoidance algorithm such as try-and-back-off can be used, but the specific algorithm is not
specified to avoid over-constraining implementations.—end note]
If a call tolock() or try_lock() throws an exception,unlock() is called for any argument that had
been locked by a call tolock() or try_lock().
32.6.7 Call once [thread.once]
32.6.7.1 Struct once_flag [thread.once.onceflag]
namespace std {
struct once_flag {
constexpr once_flag() noexcept;
once_flag(const once_flag&) = delete;
once_flag& operator=(const once_flag&) = delete;
};
}
1 The classonce_flag is an opaque data structure thatcall_once uses to initialize data without causing a
data race or deadlock.
constexpr once_flag() noexcept;
2 Synchronization: The construction of aonce_flag object is not synchronized.
3 Postconditions: The object’s internal state is set to indicate to an invocation ofcall_once with the
object as its initial argument that no function has been called.
32.6.7.2 Function call_once [thread.once.callonce]
template<class Callable, class... Args>
void call_once(once_flag& flag, Callable&& func, Args&&... args);
1 Mandates: is_invocable_v<Callable, Args...> is true.
§ 32.6.7.2 © ISO/IEC
2229

===== PAGE 2241 =====

Dxxxx
2 Effects: An execution ofcall_once that does not call itsfunc is apassive execution. An execution
of call_once that calls its func is an active execution. An active execution evaluates INVOKE(
std::forward<Callable>(func), std::forward<Args>(args)...) (22.10.4). If such a call tofunc
throws an exception the execution isexceptional, otherwise it isreturning. An exceptional execution
propagates the exception to the caller ofcall_once. Among all executions ofcall_once for any given
once_flag: at most one is a returning execution; if there is a returning execution, it is the last active
execution; and there are passive executions only if there is a returning execution.
[Note 1: Passive executions allow other threads to reliably observe the results produced by the earlier returning
execution. —end note]
3 Synchronization: For any givenonce_flag: all active executions occur in a total order; completion of
an active execution synchronizes with (6.10.2) the start of the next one in this total order; and the
returning execution synchronizes with the return from all passive executions.
4 Throws: system_error when an exception is required (32.2.2), or any exception thrown byfunc.
5 [Example 1:
// global flag, regular function
void init();
std::once_flag flag;
void f() {
std::call_once(flag, init);
}
// function static flag, function object
struct initializer {
void operator()();
};
void g() {
static std::once_flag flag2;
std::call_once(flag2, initializer());
}
// object flag, member function
class information {
std::once_flag verified;
void verifier();
public:
void verify() { std::call_once(verified, &information::verifier, *this); }
};
—end example]
32.7 Condition variables [thread.condition]
32.7.1 General [thread.condition.general]
1 Condition variables provide synchronization primitives used to block a thread until notified by some other
thread that some condition is met or until a system time is reached. Classcondition_variable provides a
condition variable that can only wait on an object of typeunique_lock<mutex>, allowing the implementation
to be more efficient. Classcondition_variable_any provides a general condition variable that can wait on
objects of user-supplied lock types.
2 Condition variables permit concurrent invocation of thewait, wait_for, wait_until, notify_one and
notify_all member functions.
3 The executions ofnotify_one and notify_all are atomic. The executions ofwait, wait_for, andwait_-
until are performed in three atomic parts:
1. the release of the mutex and entry into the waiting state;
2. the unblocking of the wait; and
3. the reacquisition of the lock.
§ 32.7.1 © ISO/IEC
2230

===== PAGE 2242 =====

Dxxxx
4 The implementation behaves as if all executions ofnotify_one, notify_all, and each part of thewait,
wait_for, andwait_until executions are executed in a single unspecified total order consistent with the
“happens before” order.
5 Condition variable construction and destruction need not be synchronized.
32.7.2 Header <condition_variable> synopsis [condition.variable.syn]
namespace std {
// 32.7.4, classcondition_variable
class condition_variable;
// 32.7.5, classcondition_variable_any
class condition_variable_any;
// 32.7.3, non-member functions
void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);
enum class cv_status { no_timeout, timeout };
}
32.7.3 Non-member functions [thread.condition.nonmember]
void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);
1 Preconditions: lk is locked by the calling thread and either
—(1.1) no other thread is waiting oncond, or
—(1.2) lk.mutex() returns the same value for each of the lock arguments supplied by all concurrently
waiting (viawait, wait_for, orwait_until) threads.
2 Effects: Transfers ownership of the lock associated withlk into internal storage and schedulescond to
be notified when the current thread exits. This notification is sequenced after all objects with thread
storage duration associated with the current thread have been destroyed and is equivalent to:
cond.notify_all();
lk.unlock();
3 Synchronization: The impliedlk.unlock() call is sequenced after the destruction of all objects with
thread storage duration associated with the current thread.
4 [Note 1: The supplied lock is held until the thread exits, which might cause deadlock due to lock ordering
issues. —end note]
5 [Note 2: It is the user’s responsibility to ensure that waiting threads do not incorrectly assume that the thread
has finished if they experience spurious wakeups. This typically requires that the condition being waited for
is satisfied while holding the lock onlk, and that this lock is not released and reacquired prior to calling
notify_all_at_thread_exit. —end note]
32.7.4 Class condition_variable [thread.condition.condvar]
namespace std {
class condition_variable {
public:
condition_variable();
~condition_variable();
condition_variable(const condition_variable&) = delete;
condition_variable& operator=(const condition_variable&) = delete;
void notify_one() noexcept;
void notify_all() noexcept;
void wait(unique_lock<mutex>& lock);
template<class Predicate>
void wait(unique_lock<mutex>& lock, Predicate pred);
template<class Clock, class Duration>
cv_status wait_until(unique_lock<mutex>& lock,
chrono::time_point<Clock, Duration> abs_time);
§ 32.7.4 © ISO/IEC
2231

===== PAGE 2243 =====

Dxxxx
template<class Clock, class Duration, class Predicate>
bool wait_until(unique_lock<mutex>& lock,
chrono::time_point<Clock, Duration> abs_time,
Predicate pred);
template<class Rep, class Period>
cv_status wait_for(unique_lock<mutex>& lock,
chrono::duration<Rep, Period> rel_time);
template<class Rep, class Period, class Predicate>
bool wait_for(unique_lock<mutex>& lock,
chrono::duration<Rep, Period> rel_time,
Predicate pred);
using native_handle_type = implementation-defined; // see 32.2.3
native_handle_type native_handle(); // see 32.2.3
};
}
1 The classcondition_variable is a standard-layout class (11.2).
condition_variable();
2 Throws: system_error when an exception is required (32.2.2).
3 Error conditions:
—(3.1) resource_unavailable_try_again — if some non-memory resource limitation prevents initial-
ization.
~condition_variable();
4 Preconditions: There is no thread blocked on*this.
[Note 1: That is, all threads have been notified; they can subsequently block on the lock specified in the wait.
This relaxes the usual rules, which would have required all wait calls to happen before destruction. Only the
notification to unblock the wait needs to happen before destruction. Undefined behavior ensues if a thread
waits on*this once the destructor has been started, especially when the waiting threads are calling the wait
functions in a loop or using the overloads ofwait, wait_for, orwait_until that take a predicate.—end note]
void notify_one() noexcept;
5 Effects: If any threads are blocked waiting for*this, unblocks one of those threads.
void notify_all() noexcept;
6 Effects: Unblocks all threads that are blocked waiting for*this.
void wait(unique_lock<mutex>& lock);
7 Preconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—(7.1) no other thread is waiting on thiscondition_variable object or
—(7.2) lock.mutex() returns the same value for each of thelock arguments supplied by all concurrently
waiting (viawait, wait_for, orwait_until) threads.
8 Effects:
—(8.1) Atomically callslock.unlock() and blocks on*this.
—(8.2) When unblocked, callslock.lock() (possibly blocking on the lock), then returns.
—(8.3) The function will unblock when signaled by a call tonotify_one() or a call tonotify_all(), or
spuriously.
9 Postconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
10 Throws: Nothing.
11 Remarks: If the function fails to meet the postcondition,terminate() is invoked (14.6.2).
[Note 2: This can happen if the re-locking of the mutex throws an exception.—end note]
§ 32.7.4 © ISO/IEC
2232

===== PAGE 2244 =====

Dxxxx
template<class Predicate>
void wait(unique_lock<mutex>& lock, Predicate pred);
12 Preconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—(12.1) no other thread is waiting on thiscondition_variable object or
—(12.2) lock.mutex() returns the same value for each of thelock arguments supplied by all concurrently
waiting (viawait, wait_for, orwait_until) threads.
13 Effects: Equivalent to:
while (!pred())
wait(lock);
14 Postconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
15 Throws: Any exception thrown bypred.
16 Remarks: If the function fails to meet the postcondition,terminate() is invoked (14.6.2).
[Note 3: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Clock, class Duration>
cv_status wait_until(unique_lock<mutex>& lock,
chrono::time_point<Clock, Duration> abs_time);
17 Preconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—(17.1) no other thread is waiting on thiscondition_variable object or
—(17.2) lock.mutex() returns the same value for each of thelock arguments supplied by all concurrently
waiting (viawait, wait_for, orwait_until) threads.
18 Effects:
—(18.1) Atomically callslock.unlock() and blocks on*this.
—(18.2) When unblocked, callslock.lock() (possibly blocking on the lock), then returns.
—(18.3) The function will unblock when signaled by a call tonotify_one(), a call tonotify_all(),
expiration of the absolute timeout (32.2.4) specified byabs_time, or spuriously.
—(18.4) If the function exits via an exception,lock.lock() is called prior to exiting the function.
19 Postconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
20 Returns: cv_status::timeoutif the absolute timeout (32.2.4) specified byabs_timeexpired, otherwise
cv_status::no_timeout.
21 Throws: Timeout-related exceptions (32.2.4).
22 Remarks: If the function fails to meet the postcondition,terminate() is invoked (14.6.2).
[Note 4: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Rep, class Period>
cv_status wait_for(unique_lock<mutex>& lock,
chrono::duration<Rep, Period> rel_time);
23 Preconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—(23.1) no other thread is waiting on thiscondition_variable object or
—(23.2) lock.mutex() returns the same value for each of thelock arguments supplied by all concurrently
waiting (viawait, wait_for, orwait_until) threads.
24 Effects: Equivalent to:
return wait_until(lock, chrono::steady_clock::now() + rel_time);
25 Postconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
26 Returns: cv_status::timeout if the relative timeout (32.2.4) specified byrel_time expired, otherwise
cv_status::no_timeout.
27 Throws: Timeout-related exceptions (32.2.4).
28 Remarks: If the function fails to meet the postcondition,terminate is invoked (14.6.2).
[Note 5: This can happen if the re-locking of the mutex throws an exception.—end note]
§ 32.7.4 © ISO/IEC
2233

===== PAGE 2245 =====

Dxxxx
template<class Clock, class Duration, class Predicate>
bool wait_until(unique_lock<mutex>& lock,
chrono::time_point<Clock, Duration> abs_time,
Predicate pred);
29 Preconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—(29.1) no other thread is waiting on thiscondition_variable object or
—(29.2) lock.mutex() returns the same value for each of thelock arguments supplied by all concurrently
waiting (viawait, wait_for, orwait_until) threads.
30 Effects: Equivalent to:
while (!pred())
if (wait_until(lock, abs_time) == cv_status::timeout)
return pred();
return true;
31 Postconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
32 [Note 6: The returned value indicates whether the predicate evaluated totrue regardless of whether the timeout
was triggered. —end note]
33 Throws: Timeout-related exceptions (32.2.4) or any exception thrown bypred.
34 Remarks: If the function fails to meet the postcondition,terminate() is invoked (14.6.2).
[Note 7: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Rep, class Period, class Predicate>
bool wait_for(unique_lock<mutex>& lock,
chrono::duration<Rep, Period> rel_time,
Predicate pred);
35 Preconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread, and either
—(35.1) no other thread is waiting on thiscondition_variable object or
—(35.2) lock.mutex() returns the same value for each of thelock arguments supplied by all concurrently
waiting (viawait, wait_for, orwait_until) threads.
36 Effects: Equivalent to:
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
37 [Note 8: There is no blocking ifpred() is initiallytrue, even if the timeout has already expired.—end note]
38 Postconditions: lock.owns_lock() is true and lock.mutex() is locked by the calling thread.
39 [Note 9: The returned value indicates whether the predicate evaluates totrue regardless of whether the timeout
was triggered. —end note]
40 Throws: Timeout-related exceptions (32.2.4) or any exception thrown bypred.
41 Remarks: If the function fails to meet the postcondition,terminate() is invoked (14.6.2).
[Note 10: This can happen if the re-locking of the mutex throws an exception.—end note]
32.7.5 Class condition_variable_any [thread.condition.condvarany]
32.7.5.1 General [thread.condition.condvarany.general]
1 In 32.7.5, template arguments for template parameters namedLock shall meet theCpp17BasicLockable
requirements (32.2.5.2).
[Note 1: All of the standard mutex types meet this requirement. If a type other than one of the standard mutex
types or aunique_lock wrapper for a standard mutex type is used withcondition_variable_any, any necessary
synchronization is assumed to be in place with respect to the predicate associated with thecondition_variable_any
instance. —end note]
namespace std {
class condition_variable_any {
public:
condition_variable_any();
~condition_variable_any();
§ 32.7.5.1 © ISO/IEC
2234

===== PAGE 2246 =====

Dxxxx
condition_variable_any(const condition_variable_any&) = delete;
condition_variable_any& operator=(const condition_variable_any&) = delete;
void notify_one() noexcept;
void notify_all() noexcept;
// 32.7.5.2, noninterruptible waits
template<class Lock>
void wait(Lock& lock);
template<class Lock, class Predicate>
void wait(Lock& lock, Predicate pred);
template<class Lock, class Clock, class Duration>
cv_status wait_until(Lock& lock, chrono::time_point<Clock, Duration> abs_time);
template<class Lock, class Clock, class Duration, class Predicate>
bool wait_until(Lock& lock, chrono::time_point<Clock, Duration abs_time,
Predicate pred);
template<class Lock, class Rep, class Period>
cv_status wait_for(Lock& lock, chrono::duration<Rep, Period> rel_time);
template<class Lock, class Rep, class Period, class Predicate>
bool wait_for(Lock& lock, chrono::duration<Rep, Period> rel_time, Predicate pred);
// 32.7.5.3, interruptible waits
template<class Lock, class Predicate>
bool wait(Lock& lock, stop_token stoken, Predicate pred);
template<class Lock, class Clock, class Duration, class Predicate>
bool wait_until(Lock& lock, stop_token stoken,
chrono::time_point<Clock, Duration> abs_time, Predicate pred);
template<class Lock, class Rep, class Period, class Predicate>
bool wait_for(Lock& lock, stop_token stoken,
chrono::duration<Rep, Period> rel_time, Predicate pred);
};
}
condition_variable_any();
2 Throws: bad_alloc or system_error when an exception is required (32.2.2).
3 Error conditions:
—(3.1) resource_unavailable_try_again — if some non-memory resource limitation prevents initial-
ization.
—(3.2) operation_not_permitted — if the thread does not have the privilege to perform the operation.
~condition_variable_any();
4 Preconditions: There is no thread blocked on*this.
[Note 2: That is, all threads have been notified; they can subsequently block on the lock specified in the wait.
This relaxes the usual rules, which would have required all wait calls to happen before destruction. Only the
notification to unblock the wait needs to happen before destruction. Undefined behavior ensues if a thread
waits on*this once the destructor has been started, especially when the waiting threads are calling the wait
functions in a loop or using the overloads ofwait, wait_for, orwait_until that take a predicate.—end note]
void notify_one() noexcept;
5 Effects: If any threads are blocked waiting for*this, unblocks one of those threads.
void notify_all() noexcept;
6 Effects: Unblocks all threads that are blocked waiting for*this.
32.7.5.2 Noninterruptible waits [thread.condvarany.wait]
template<class Lock>
void wait(Lock& lock);
1 Effects:
§ 32.7.5.2 © ISO/IEC
2235

===== PAGE 2247 =====

Dxxxx
—(1.1) Atomically callslock.unlock() and blocks on*this.
—(1.2) When unblocked, callslock.lock() (possibly blocking on the lock) and returns.
—(1.3) The function will unblock when signaled by a call tonotify_one(), a call tonotify_all(), or
spuriously.
2 Postconditions: lock is locked by the calling thread.
3 Throws: Nothing.
4 Remarks: If the function fails to meet the postcondition,terminate() is invoked (14.6.2).
[Note 1: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Lock, class Predicate>
void wait(Lock& lock, Predicate pred);
5 Effects: Equivalent to:
while (!pred())
wait(lock);
template<class Lock, class Clock, class Duration>
cv_status wait_until(Lock& lock, chrono::time_point<Clock, Duration> abs_time);
6 Effects:
—(6.1) Atomically callslock.unlock() and blocks on*this.
—(6.2) When unblocked, callslock.lock() (possibly blocking on the lock) and returns.
—(6.3) The function will unblock when signaled by a call tonotify_one(), a call tonotify_all(),
expiration of the absolute timeout (32.2.4) specified byabs_time, or spuriously.
—(6.4) If the function exits via an exception,lock.lock() is called prior to exiting the function.
7 Postconditions: lock is locked by the calling thread.
8 Returns: cv_status::timeoutif the absolute timeout (32.2.4) specified byabs_timeexpired, otherwise
cv_status::no_timeout.
9 Throws: Timeout-related exceptions (32.2.4).
10 Remarks: If the function fails to meet the postcondition,terminate() is invoked (14.6.2).
[Note 2: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Lock, class Rep, class Period>
cv_status wait_for(Lock& lock, chrono::duration<Rep, Period> rel_time);
11 Effects: Equivalent to:
return wait_until(lock, chrono::steady_clock::now() + rel_time);
12 Postconditions: lock is locked by the calling thread.
13 Returns: cv_status::timeout if the relative timeout (32.2.4) specified byrel_time expired, otherwise
cv_status::no_timeout.
14 Throws: Timeout-related exceptions (32.2.4).
15 Remarks: If the function fails to meet the postcondition,terminate is invoked (14.6.2).
[Note 3: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Lock, class Clock, class Duration, class Predicate>
bool wait_until(Lock& lock, chrono::time_point<Clock, Duration> abs_time, Predicate pred);
16 Effects: Equivalent to:
while (!pred())
if (wait_until(lock, abs_time) == cv_status::timeout)
return pred();
return true;
17 [Note 4: There is no blocking ifpred() is initiallytrue, or if the timeout has already expired.—end note]
18 [Note 5: The returned value indicates whether the predicate evaluates totrue regardless of whether the timeout
was triggered. —end note]
§ 32.7.5.2 © ISO/IEC
2236

===== PAGE 2248 =====

Dxxxx
template<class Lock, class Rep, class Period, class Predicate>
bool wait_for(Lock& lock, chrono::duration<Rep, Period> rel_time, Predicate pred);
19 Effects: Equivalent to:
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
32.7.5.3 Interruptible waits [thread.condvarany.intwait]
1 The following wait functions will be notified when there is a stop request on the passedstop_token. In that
case the functions return immediately, returningfalse if the predicate evaluates tofalse.
template<class Lock, class Predicate>
bool wait(Lock& lock, stop_token stoken, Predicate pred);
2 Effects: Registers for the duration of this call*this to get notified on a stop request onstoken during
this call and then equivalent to:
while (!stoken.stop_requested()) {
if (pred())
return true;
wait(lock);
}
return pred();
3 [Note 1: The returned value indicates whether the predicate evaluated totrue regardless of whether there was
a stop request. —end note]
4 Postconditions: lock is locked by the calling thread.
5 Throws: Any exception thrown bypred.
6 Remarks: If the function fails to meet the postcondition,terminate is called (14.6.2).
[Note 2: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Lock, class Clock, class Duration, class Predicate>
bool wait_until(Lock& lock, stop_token stoken,
chrono::time_point<Clock, Duration> abs_time, Predicate pred);
7 Effects: Registers for the duration of this call*this to get notified on a stop request onstoken during
this call and then equivalent to:
while (!stoken.stop_requested()) {
if (pred())
return true;
if (wait_until(lock, abs_time) == cv_status::timeout)
return pred();
}
return pred();
8 [Note 3: There is no blocking ifpred() is initiallytrue, stoken.stop_requested() was alreadytrue or the
timeout has already expired.—end note]
9 [Note 4: The returned value indicates whether the predicate evaluated totrue regardless of whether the timeout
was triggered or a stop request was made.—end note]
10 Postconditions: lock is locked by the calling thread.
11 Throws: Timeout-related exceptions (32.2.4), or any exception thrown bypred.
12 Remarks: If the function fails to meet the postcondition,terminate is called (14.6.2).
[Note 5: This can happen if the re-locking of the mutex throws an exception.—end note]
template<class Lock, class Rep, class Period, class Predicate>
bool wait_for(Lock& lock, stop_token stoken,
chrono::duration<Rep, Period> rel_time, Predicate pred);
13 Effects: Equivalent to:
return wait_until(lock, std::move(stoken), chrono::steady_clock::now() + rel_time,
std::move(pred));
§ 32.7.5.3 © ISO/IEC
2237

===== PAGE 2249 =====

Dxxxx
32.8 Semaphore [thread.sema]
32.8.1 General [thread.sema.general]
1 Semaphores are lightweight synchronization primitives used to constrain concurrent access to a shared
resource. They are widely used to implement other synchronization primitives and, whenever both are
applicable, can be more efficient than condition variables.
2 A counting semaphore is a semaphore object that models a non-negative resource count. A binary semaphore
is a semaphore object that has only two states. A binary semaphore should be more efficient than the default
implementation of a counting semaphore with a unit resource count.
32.8.2 Header <semaphore> synopsis [semaphore.syn]
namespace std {
// 32.8.3, class templatecounting_semaphore
template<ptrdiff_t least_max_value = implementation-defined >
class counting_semaphore;
using binary_semaphore = counting_semaphore<1>;
}
32.8.3 Class template counting_semaphore [thread.sema.cnt]
namespace std {
template<ptrdiff_t least_max_value = implementation-defined >
class counting_semaphore {
public:
static constexpr ptrdiff_t max() noexcept;
constexpr explicit counting_semaphore(ptrdiff_t desired);
~counting_semaphore();
counting_semaphore(const counting_semaphore&) = delete;
counting_semaphore& operator=(const counting_semaphore&) = delete;
void release(ptrdiff_t update = 1);
void acquire();
bool try_acquire() noexcept;
template<class Rep, class Period>
bool try_acquire_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_acquire_until(const chrono::time_point<Clock, Duration>& abs_time);
private:
ptrdiff_t counter; // exposition only
};
}
1 Class templatecounting_semaphore maintains an internal counter that is initialized when the semaphore
is created. The counter is decremented when a thread acquires the semaphore, and is incremented when
a thread releases the semaphore. If a thread tries to acquire the semaphore when the counter is zero, the
thread will block until another thread increments the counter by releasing the semaphore.
2 least_max_value shall be non-negative; otherwise the program is ill-formed.
3 Concurrent invocations of the member functions ofcounting_semaphore, other than its destructor, do not
introduce data races.
static constexpr ptrdiff_t max() noexcept;
4 Returns: The maximum value ofcounter. This value is greater than or equal toleast_max_value.
constexpr explicit counting_semaphore(ptrdiff_t desired);
5 Preconditions: desired >= 0 is true, anddesired <= max() is true.
6 Effects: Initializes counter with desired.
7 Throws: Nothing.
§ 32.8.3 © ISO/IEC
2238

===== PAGE 2250 =====

Dxxxx
void release(ptrdiff_t update = 1);
8 Preconditions: update >= 0 is true, andupdate <= max() - counter is true.
9 Effects: Atomically execute counter += update. Then, unblocks any threads that are waiting for
counter to be greater than zero.
10 Synchronization: Strongly happens before invocations oftry_acquire that observe the result of the
effects.
11 Throws: system_error when an exception is required (32.2.2).
12 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
bool try_acquire() noexcept;
13 Effects: Attempts to atomically decrementcounter if it is positive, without blocking. Ifcounter is
not decremented, there is no effect andtry_acquire immediately returns. An implementation may
fail to decrementcounter even if it is positive.
[Note 1: This spurious failure is normally uncommon, but allows interesting implementations based on a simple
compare and exchange (32.5).—end note]
An implementation should ensure thattry_acquire does not consistently returnfalse in the absence
of contending semaphore operations.
14 Returns: true if counter was decremented, otherwisefalse.
void acquire();
15 Effects: Repeatedly performs the following steps, in order:
—(15.1) Evaluates try_acquire(). If the result istrue, returns.
—(15.2) Blocks on*this until counter is greater than zero.
16 Throws: system_error when an exception is required (32.2.2).
17 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
template<class Rep, class Period>
bool try_acquire_for(const chrono::duration<Rep, Period>& rel_time);
template<class Clock, class Duration>
bool try_acquire_until(const chrono::time_point<Clock, Duration>& abs_time);
18 Effects: Repeatedly performs the following steps, in order:
—(18.1) Evaluates try_acquire(). If the result istrue, returnstrue.
—(18.2) Blocks on*this until counter is greater than zero or until the timeout expires. If it is unblocked
by the timeout expiring, returnsfalse.
The timeout expires (32.2.4) when the current time is afterabs_time (for try_acquire_until) or
when at leastrel_time has passed from the start of the function (fortry_acquire_for).
19 Throws: Timeout-related exceptions (32.2.4), orsystem_error when a non-timeout-related exception
is required (32.2.2).
20 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
32.9 Coordination types [thread.coord]
32.9.1 General [thread.coord.general]
1 Subclause 32.9 describes various concepts related to thread coordination, and defines the coordination types
latch and barrier. These types facilitate concurrent computation performed by a number of threads.
32.9.2 Latches [thread.latch]
32.9.2.1 General [thread.latch.general]
1 A latch is a thread coordination mechanism that allows any number of threads to block until an expected
number of threads arrive at the latch (via thecount_down function). The expected count is set when the
latch is created. An individual latch is a single-use object; once the expected count has been reached, the
latch cannot be reused.
§ 32.9.2.1 © ISO/IEC
2239

===== PAGE 2251 =====

Dxxxx
32.9.2.2 Header <latch> synopsis [latch.syn]
namespace std {
class latch;
}
32.9.2.3 Class latch [thread.latch.class]
namespace std {
class latch {
public:
static constexpr ptrdiff_t max() noexcept;
constexpr explicit latch(ptrdiff_t expected);
~latch();
latch(const latch&) = delete;
latch& operator=(const latch&) = delete;
void count_down(ptrdiff_t update = 1);
bool try_wait() const noexcept;
void wait() const;
void arrive_and_wait(ptrdiff_t update = 1);
private:
ptrdiff_t counter; // exposition only
};
}
1 A latch maintains an internal counter that is initialized when the latch is created. Threads can block on the
latch object, waiting for counter to be decremented to zero.
2 Concurrent invocations of the member functions oflatch, other than its destructor, do not introduce data
races.
static constexpr ptrdiff_t max() noexcept;
3 Returns: The maximum value ofcounter that the implementation supports.
constexpr explicit latch(ptrdiff_t expected);
4 Preconditions: expected >= 0 is true and expected <= max() is true.
5 Effects: Initializes counter with expected.
6 Throws: Nothing.
void count_down(ptrdiff_t update = 1);
7 Preconditions: update >= 0 is true, andupdate <= counter is true.
8 Effects: Atomically decrementscounter by update. If counter is equal to zero, unblocks all threads
blocked on*this.
9 Synchronization: Strongly happens before the returns from all calls that are unblocked.
10 Throws: system_error when an exception is required (32.2.2).
11 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
bool try_wait() const noexcept;
12 Returns: With very low probabilityfalse. Otherwise counter == 0.
void wait() const;
13 Effects: If counter equals zero, returns immediately. Otherwise, blocks on *this until a call to
count_down that decrementscounter to zero.
14 Throws: system_error when an exception is required (32.2.2).
15 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
§ 32.9.2.3 © ISO/IEC
2240

===== PAGE 2252 =====

Dxxxx
void arrive_and_wait(ptrdiff_t update = 1);
16 Effects: Equivalent to:
count_down(update);
wait();
32.9.3 Barriers [thread.barrier]
32.9.3.1 General [thread.barrier.general]
1 A barrier is a thread coordination mechanism whose lifetime consists of a sequence of barrier phases, where
each phase allows at most an expected number of threads to block until the expected number of threads
arrive at the barrier.
[Note 1: A barrier is useful for managing repeated tasks that are handled by multiple threads.—end note]
32.9.3.2 Header <barrier> synopsis [barrier.syn]
namespace std {
template<class CompletionFunction = see below >
class barrier;
}
32.9.3.3 Class template barrier [thread.barrier.class]
namespace std {
template<class CompletionFunction = see below >
class barrier {
public:
using arrival_token = see below ;
static constexpr ptrdiff_t max() noexcept;
constexpr explicit barrier(ptrdiff_t expected,
CompletionFunction f = CompletionFunction());
~barrier();
barrier(const barrier&) = delete;
barrier& operator=(const barrier&) = delete;
arrival_token arrive(ptrdiff_t update = 1);
void wait(arrival_token&& arrival) const;
void arrive_and_wait();
void arrive_and_drop();
private:
CompletionFunction completion; // exposition only
};
}
1 Each barrier phaseconsists of the following steps:
—(1.1) The expected count is decremented by each call toarrive or arrive_and_drop.
—(1.2) Exactly once after the expected count reaches zero, a thread executes the completion step during its
call toarrive, arrive_and_drop, orwait, except that it is implementation-defined whether the step
executes if no thread callswait.
—(1.3) When the completion step finishes, the expected count is reset to what was specified by theexpected
argument to the constructor, possibly adjusted by calls toarrive_and_drop, and the next phase starts.
2 Each phase defines aphase synchronization point. Threads that arrive at the barrier during the phase can
block on the phase synchronization point by callingwait, and will remain blocked until the phase completion
step is run.
3 The phase completion stepthat is executed at the end of each phase has the following effects:
—(3.1) Invokes the completion function, equivalent tocompletion().
—(3.2) Unblocks all threads that are blocked on the phase synchronization point.
§ 32.9.3.3 © ISO/IEC
2241

===== PAGE 2253 =====

Dxxxx
The end of the completion step strongly happens before the returns from all calls that were unblocked by the
completion step. For specializations that do not have the default value of theCompletionFunction template
parameter, the behavior is undefined if any of the barrier object’s member functions other thanwait are
called while the completion step is in progress.
4 Concurrent invocations of the member functions ofbarrier, other than its destructor, do not introduce data
races. The member functionsarrive and arrive_and_drop execute atomically.
5 CompletionFunction shall meet theCpp17MoveConstructible (Table 31) andCpp17Destructible (Table 35)
requirements. is_nothrow_invocable_v<CompletionFunction&> shall betrue.
6 The default value of theCompletionFunction template parameter is an unspecified type, such that, in
addition to satisfying the requirements ofCompletionFunction, it meets theCpp17DefaultConstructible
requirements (Table 30) andcompletion() has no effects.
7 barrier::arrival_token is an unspecified type, such that it meets theCpp17MoveConstructible (Table 31),
Cpp17MoveAssignable (Table 33), andCpp17Destructible (Table 35) requirements.
static constexpr ptrdiff_t max() noexcept;
8 Returns: The maximum expected count that the implementation supports.
constexpr explicit barrier(ptrdiff_t expected,
CompletionFunction f = CompletionFunction());
9 Preconditions: expected >= 0 is true and expected <= max() is true.
10 Effects: Sets both the initial expected count for each barrier phase and the current expected count for
the first phase toexpected. Initializes completion with std::move(f). Starts the first phase.
[Note 1: If expected is 0 this object can only be destroyed.—end note]
11 Throws: Any exception thrown byCompletionFunction’s move constructor.
arrival_token arrive(ptrdiff_t update = 1);
12 Preconditions: update > 0 is true, andupdate is less than or equal to the expected count for the
current barrier phase.
13 Effects: Constructs an object of typearrival_token that is associated with the phase synchronization
point for the current phase. Then, decrements the expected count byupdate.
14 Synchronization: The call toarrive strongly happens before the start of the phase completion step for
the current phase.
15 Returns: The constructedarrival_token object.
16 Throws: system_error when an exception is required (32.2.2).
17 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
18 [Note 2: This call can cause the completion step for the current phase to start.—end note]
void wait(arrival_token&& arrival) const;
19 Preconditions: arrival is associated with the phase synchronization point for the current phase or the
immediately preceding phase of the same barrier object.
20 Effects: Blocks at the synchronization point associated withstd::move(arrival) until the phase
completion step of the synchronization point’s phase is run.
[Note 3: Ifarrival is associated with the synchronization point for a previous phase, the call returns immediately.
—end note]
21 Throws: system_error when an exception is required (32.2.2).
22 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
void arrive_and_wait();
23 Effects: Equivalent to:wait(arrive()).
void arrive_and_drop();
24 Preconditions: The expected count for the current barrier phase is greater than zero.
§ 32.9.3.3 © ISO/IEC
2242

===== PAGE 2254 =====

Dxxxx
25 Effects: Decrements the initial expected count for all subsequent phases by one. Then decrements the
expected count for the current phase by one.
26 Synchronization: Thecallto arrive_and_dropstronglyhappensbeforethestartofthephasecompletion
step for the current phase.
27 Throws: system_error when an exception is required (32.2.2).
28 Error conditions: Any of the error conditions allowed for mutex types (32.6.4.2).
29 [Note 4: This call can cause the completion step for the current phase to start.—end note]
32.10 Futures [futures]
32.10.1 Overview [futures.overview]
1 32.10 describes components that a C++ program can use to retrieve in one thread the result (value or
exception) from a function that has run in the same thread or another thread.
[Note 1: These components are not restricted to multi-threaded programs but can be useful in single-threaded
programs as well. —end note]
32.10.2 Header <future> synopsis [future.syn]
namespace std {
enum class future_errc {
broken_promise = implementation-defined ,
future_already_retrieved = implementation-defined ,
promise_already_satisfied = implementation-defined ,
no_state = implementation-defined
};
enum class launch : unspecified {
async = unspecified ,
deferred = unspecified ,
implementation-defined
};
enum class future_status {
ready,
timeout,
deferred
};
// 32.10.3, error handling
template<> struct is_error_code_enum<future_errc> : public true_type { };
error_code make_error_code(future_errc e) noexcept;
error_condition make_error_condition(future_errc e) noexcept;
const error_category& future_category() noexcept;
// 32.10.4, classfuture_error
class future_error;
// 32.10.6, class templatepromise
template<class R> class promise;
template<class R> class promise<R&>;
template<> class promise<void>;
template<class R>
void swap(promise<R>& x, promise<R>& y) noexcept;
// 32.10.7, class templatefuture
template<class R> class future;
template<class R> class future<R&>;
template<> class future<void>;
§ 32.10.2 © ISO/IEC
2243

===== PAGE 2255 =====

Dxxxx
// 32.10.8, class templateshared_future
template<class R> class shared_future;
template<class R> class shared_future<R&>;
template<> class shared_future<void>;
// 32.10.10, class templatepackaged_task
template<class> class packaged_task; // not defined
template<class R, class... ArgTypes>
class packaged_task<R(ArgTypes...)>;
template<class R, class... ArgTypes>
void swap(packaged_task<R(ArgTypes...)>&, packaged_task<R(ArgTypes...)>&) noexcept;
// 32.10.9, function templateasync
template<class F, class... Args>
future<invoke_result_t<decay_t<F>, decay_t<Args>...>>
async(F&& f, Args&&... args);
template<class F, class... Args>
future<invoke_result_t<decay_t<F>, decay_t<Args>...>>
async(launch policy, F&& f, Args&&... args);
}
1 The enum type launch is a bitmask type (16.3.3.3.3) with elementslaunch::async and launch::deferred.
[Note 1: Implementations can provide bitmasks to specify restrictions on task interaction by functions launched by
async() applicable to a corresponding subset of available launch policies. Implementations can extend the behavior
of the first overload ofasync() by adding their extensions to the launch policy under the “as if” rule.—end note]
2 The enum values offuture_errc are distinct and not zero.
32.10.3 Error handling [futures.errors]
const error_category& future_category() noexcept;
1 Returns: A reference to an object of a type derived from classerror_category.
2 The object’sdefault_error_condition and equivalent virtual functions shall behave as specified for
the classerror_category. The object’sname virtual function returns a pointer to the string"future".
error_code make_error_code(future_errc e) noexcept;
3 Returns: error_code(static_cast<int>(e), future_category()).
error_condition make_error_condition(future_errc e) noexcept;
4 Returns: error_condition(static_cast<int>(e), future_category()).
32.10.4 Class future_error [futures.future.error]
namespace std {
class future_error : public logic_error {
public:
explicit future_error(future_errc e);
const error_code& code() const noexcept;
const char* what() const noexcept;
private:
error_code ec_; // exposition only
};
}
explicit future_error(future_errc e);
1 Effects: Initializes ec_ with make_error_code(e).
const error_code& code() const noexcept;
2 Returns: ec_.
§ 32.10.4 © ISO/IEC
2244

===== PAGE 2256 =====

Dxxxx
const char* what() const noexcept;
3 Returns: An ntbs incorporating code().message().
32.10.5 Shared state [futures.state]
1 Many of the classes introduced in subclause 32.10 use some state to communicate results. Thisshared state
consists of some state information and some (possibly not yet evaluated)result, which can be a (possibly
void) value or an exception.
[Note 1: Futures, promises, and tasks defined in this Clause reference such shared state.—end note]
2 [Note 2: The result can be any kind of object including a function to compute that result, as used byasync when
policy is launch::deferred. —end note]
3 An asynchronous return objectis an object that reads results from a shared state. Awaiting functionof an
asynchronous return object is one that potentially blocks to wait for the shared state to be made ready. If a
waiting function can return before the state is made ready because of a timeout (32.2.5), then it is atimed
waiting function, otherwise it is anon-timed waiting function.
4 An asynchronous provideris an object that provides a result to a shared state. The result of a shared state
is set by respective functions on the asynchronous provider.
[Example 1: Promises and tasks are examples of asynchronous providers.—end example]
The means of setting the result of a shared state is specified in the description of those classes and functions
that create such a state object.
5 When an asynchronous return object or an asynchronous provider is said to release its shared state, it means:
—(5.1) if the return object or provider holds the last reference to its shared state, the shared state is destroyed;
and
—(5.2) the return object or provider gives up its reference to its shared state; and
—(5.3) these actions will not block for the shared state to become ready, except that it may block if all of the
following are true: the shared state was created by a call tostd::async, the shared state is not yet
ready, and this was the last reference to the shared state.
6 When an asynchronous provider is said to make its shared state ready, it means:
—(6.1) first, the provider marks its shared state as ready; and
—(6.2) second, the provider unblocks any execution agents waiting for its shared state to become ready.
7 When an asynchronous provider is said to abandon its shared state, it means:
—(7.1) first, if that state is not ready, the provider
—(7.1.1) stores an exception object of typefuture_error with an error condition ofbroken_promise
within its shared state; and then
—(7.1.2) makes its shared state ready;
—(7.2) second, the provider releases its shared state.
8 A shared state isready only if it holds a value or an exception ready for retrieval. Waiting for a shared
state to become ready may invoke code to compute the result on the waiting thread if so specified in the
description of the class or function that creates the state object.
9 Calls to functions that successfully set the stored result of a shared state synchronize with (6.10.2) calls to
functions successfully detecting the ready state resulting from that setting. The storage of the result (whether
normal or exceptional) into the shared state synchronizes with (6.10.2) the successful return from a call to a
waiting function on the shared state.
10 Some functions (e.g.,promise::set_value_at_thread_exit) delay making the shared state ready until the
calling thread exits. The destruction of each of that thread’s objects with thread storage duration (6.8.6.3) is
sequenced before making that shared state ready.
11 Access to the result of the same shared state may conflict (6.10.2).
[Note 3: This explicitly specifies that the result of the shared state is visible in the objects that reference this state
in the sense of data race avoidance (16.4.6.10). For example, concurrent accesses through references returned by
shared_future::get() (32.10.8) must either use read-only operations or provide additional synchronization.—end
note]
§ 32.10.5 © ISO/IEC
2245

===== PAGE 2257 =====

Dxxxx
32.10.6 Class template promise [futures.promise]
namespace std {
template<class R>
class promise {
public:
promise();
template<class Allocator>
promise(allocator_arg_t, const Allocator& a);
promise(promise&& rhs) noexcept;
promise(const promise&) = delete;
~promise();
// assignment
promise& operator=(promise&& rhs) noexcept;
promise& operator=(const promise&) = delete;
void swap(promise& other) noexcept;
// retrieving the result
future<R> get_future();
// setting the result
void set_value(see below );
void set_exception(exception_ptr p);
// setting the result with deferred notification
void set_value_at_thread_exit(see below );
void set_exception_at_thread_exit(exception_ptr p);
};
}
1 For the primary template,R shall be an object type that meets theCpp17Destructible requirements.
2 The implementation provides the templatepromise and two specializations,promise<R&> and promise<
void>. These differ only in the argument type of the member functionsset_value and set_value_at_-
thread_exit, as set out in their descriptions, below.
3 The set_value, set_exception, set_value_at_thread_exit, andset_exception_at_thread_exit mem-
ber functions behave as though they acquire a single mutex associated with the promise object while updating
the promise object.
promise();
template<class Allocator>
promise(allocator_arg_t, const Allocator& a);
4 Effects: Creates a shared state. The second constructor uses the allocatora to allocate memory for the
shared state.
promise(promise&& rhs) noexcept;
5 Effects: Transfers ownership of the shared state ofrhs (if any) to the newly-constructed object.
6 Postconditions: rhs has no shared state.
~promise();
7 Effects: Abandons any shared state (32.10.5).
promise& operator=(promise&& rhs) noexcept;
8 Effects: Abandons any shared state (32.10.5) and then as ifpromise(std::move(rhs)).swap(*this).
9 Returns: *this.
void swap(promise& other) noexcept;
10 Effects: Exchanges the shared state of*this and other.
11 Postconditions: *this has the shared state (if any) thatother had prior to the call toswap. other
has the shared state (if any) that*this had prior to the call toswap.
§ 32.10.6 © ISO/IEC
2246

===== PAGE 2258 =====

Dxxxx
future<R> get_future();
12 Synchronization: Calls to this function do not introduce data races (6.10.2) with calls toset_value,
set_exception, set_value_at_thread_exit, orset_exception_at_thread_exit.
[Note 1: Such calls need not synchronize with each other.—end note]
13 Returns: A future<R> object with the same shared state as*this.
14 Throws: future_error if *this has no shared state or ifget_future has already been called on a
promise with the same shared state as*this.
15 Error conditions:
—(15.1) future_already_retrieved if get_future has already been called on apromise with the same
shared state as*this.
—(15.2) no_state if *this has no shared state.
void promise::set_value(const R& r);
void promise::set_value(R&& r);
void promise<R&>::set_value(R& r);
void promise<void>::set_value();
16 Effects: Atomically stores the valuer in the shared state and makes that state ready (32.10.5).
17 Throws:
—(17.1) future_error if its shared state already has a stored value or exception, or
—(17.2) for the first version, any exception thrown by the constructor selected to copy an object ofR, or
—(17.3) for the second version, any exception thrown by the constructor selected to move an object ofR.
18 Error conditions:
—(18.1) promise_already_satisfied if its shared state already has a stored value or exception.
—(18.2) no_state if *this has no shared state.
void set_exception(exception_ptr p);
19 Preconditions: p is not null.
20 Effects: Atomically stores the exception pointerp in the shared state and makes that state ready
(32.10.5).
21 Throws: future_error if its shared state already has a stored value or exception.
22 Error conditions:
—(22.1) promise_already_satisfied if its shared state already has a stored value or exception.
—(22.2) no_state if *this has no shared state.
void promise::set_value_at_thread_exit(const R& r);
void promise::set_value_at_thread_exit(R&& r);
void promise<R&>::set_value_at_thread_exit(R& r);
void promise<void>::set_value_at_thread_exit();
23 Effects: Stores the valuer in the shared state without making that state ready immediately. Schedules
that state to be made ready when the current thread exits, after all objects with thread storage duration
associated with the current thread have been destroyed.
24 Throws:
—(24.1) future_error if its shared state already has a stored value or exception, or
—(24.2) for the first version, any exception thrown by the constructor selected to copy an object ofR, or
—(24.3) for the second version, any exception thrown by the constructor selected to move an object ofR.
25 Error conditions:
—(25.1) promise_already_satisfied if its shared state already has a stored value or exception.
—(25.2) no_state if *this has no shared state.
§ 32.10.6 © ISO/IEC
2247

===== PAGE 2259 =====

Dxxxx
void set_exception_at_thread_exit(exception_ptr p);
26 Preconditions: p is not null.
27 Effects: Stores the exception pointerp in the shared state without making that state ready immediately.
Schedules that state to be made ready when the current thread exits, after all objects with thread
storage duration associated with the current thread have been destroyed.
28 Throws: future_error if an error condition occurs.
29 Error conditions:
—(29.1) promise_already_satisfied if its shared state already has a stored value or exception.
—(29.2) no_state if *this has no shared state.
template<class R>
void swap(promise<R>& x, promise<R>& y) noexcept;
30 Effects: As if byx.swap(y).
32.10.7 Class template future [futures.unique.future]
1 The class templatefuture defines a type for asynchronous return objects which do not share their shared
state with other asynchronous return objects. A default-constructedfuture object has no shared state. A
future object with shared state can be created by functions on asynchronous providers (32.10.5) or by the
move constructor and shares its shared state with the original asynchronous provider. The result (value or
exception) of afuture object can be set by calling a respective function on an object that shares the same
shared state.
2 [Note 1: Member functions offuture do not synchronize with themselves or with member functions ofshared_future.
—end note]
3 The effect of calling any member function other than the destructor, the move assignment operator,share,
or valid on afuture object for whichvalid() == false is undefined.
[Note 2: It is valid to move from a future object for whichvalid() == false. —end note]
Recommended practice: Implementations should detect this case and throw an object of typefuture_error
with an error condition offuture_errc::no_state.
namespace std {
template<class R>
class future {
public:
future() noexcept;
future(future&&) noexcept;
future(const future&) = delete;
~future();
future& operator=(const future&) = delete;
future& operator=(future&&) noexcept;
shared_future<R> share() noexcept;
// retrieving the value
see below get();
// functions to check state
bool valid() const noexcept;
void wait() const;
template<class Rep, class Period>
future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;
template<class Clock, class Duration>
future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
};
}
4 For the primary template,R shall be an object type that meets theCpp17Destructible requirements.
§ 32.10.7 © ISO/IEC
2248

===== PAGE 2260 =====

Dxxxx
5 The implementation provides the templatefuture and two specializations,future<R&> and future<void>.
These differ only in the return type and return value of the member functionget, as set out in its description,
below.
future() noexcept;
6 Effects: The object does not refer to a shared state.
7 Postconditions: valid() == false.
future(future&& rhs) noexcept;
8 Effects: Move constructs afuture object that refers to the shared state that was originally referred to
by rhs (if any).
9 Postconditions:
—(9.1) valid() returns the same value asrhs.valid() prior to the constructor invocation.
—(9.2) rhs.valid() == false.
~future();
10 Effects:
—(10.1) Releases any shared state (32.10.5);
—(10.2) destroys *this.
future& operator=(future&& rhs) noexcept;
11 Effects: If addressof(rhs) == this is true, there are no effects. Otherwise:
—(11.1) Releases any shared state (32.10.5).
—(11.2) move assigns the contents ofrhs to *this.
12 Postconditions:
—(12.1) valid() returns the same value asrhs.valid() prior to the assignment.
—(12.2) If addressof(rhs) == this is false, rhs.valid() == false.
shared_future<R> share() noexcept;
13 Postconditions: valid() == false.
14 Returns: shared_future<R>(std::move(*this)).
R future::get();
R& future<R&>::get();
void future<void>::get();
15 [Note 3: As described above, the template and its two required specializations differ only in the return type
and return value of the member functionget. —end note]
16 Effects:
—(16.1) wait()s until the shared state is ready, then retrieves the value stored in the shared state;
—(16.2) releases any shared state (32.10.5).
17 Postconditions: valid() == false.
18 Returns:
—(18.1) future::get() returns the valuev stored in the object’s shared state asstd::move(v).
—(18.2) future<R&>::get() returns the reference stored as value in the object’s shared state.
—(18.3) future<void>::get() returns nothing.
19 Throws: The stored exception, if an exception was stored in the shared state.
bool valid() const noexcept;
20 Returns: true only if*this refers to a shared state.
void wait() const;
§ 32.10.7 © ISO/IEC
2249

===== PAGE 2261 =====

Dxxxx
21 Effects: Blocks until the shared state is ready.
template<class Rep, class Period>
future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;
22 Effects: None if the shared state contains a deferred function (32.10.9), otherwise blocks until the
shared state is ready or until the relative timeout (32.2.4) specified byrel_time has expired.
23 Returns:
—(23.1) future_status::deferred if the shared state contains a deferred function.
—(23.2) future_status::ready if the shared state is ready.
—(23.3) future_status::timeoutifthefunctionisreturningbecausetherelativetimeout(32.2.4)specified
by rel_time has expired.
24 Throws: timeout-related exceptions (32.2.4).
template<class Clock, class Duration>
future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
25 Effects: None if the shared state contains a deferred function (32.10.9), otherwise blocks until the
shared state is ready or until the absolute timeout (32.2.4) specified byabs_time has expired.
26 Returns:
—(26.1) future_status::deferred if the shared state contains a deferred function.
—(26.2) future_status::ready if the shared state is ready.
—(26.3) future_status::timeout if the function is returning because the absolute timeout (32.2.4)
specified byabs_time has expired.
27 Throws: timeout-related exceptions (32.2.4).
32.10.8 Class template shared_future [futures.shared.future]
1 The class templateshared_future defines a type for asynchronous return objects which may share their
shared state with other asynchronous return objects. A default-constructedshared_future object has no
shared state. Ashared_future object with shared state can be created by conversion from afuture object
and shares its shared state with the original asynchronous provider (32.10.5) of the shared state. The result
(value or exception) of ashared_future object can be set by calling a respective function on an object that
shares the same shared state.
2 [Note 1: Member functions ofshared_future do not synchronize with themselves, but they synchronize with the
shared state. —end note]
3 The effect of calling any member function other than the destructor, the move assignment operator, the copy
assignment operator, orvalid() on ashared_future object for whichvalid() == false is undefined.
[Note 2: It is valid to copy or move from ashared_future object for whichvalid() is false. —end note]
Recommended practice: Implementations should detect this case and throw an object of typefuture_error
with an error condition offuture_errc::no_state.
namespace std {
template<class R>
class shared_future {
public:
shared_future() noexcept;
shared_future(const shared_future& rhs) noexcept;
shared_future(future<R>&&) noexcept;
shared_future(shared_future&& rhs) noexcept;
~shared_future();
shared_future& operator=(const shared_future& rhs) noexcept;
shared_future& operator=(shared_future&& rhs) noexcept;
// retrieving the value
see below get() const;
// functions to check state
bool valid() const noexcept;
§ 32.10.8 © ISO/IEC
2250

===== PAGE 2262 =====

Dxxxx
void wait() const;
template<class Rep, class Period>
future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;
template<class Clock, class Duration>
future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
};
}
4 For the primary template,R shall be an object type that meets theCpp17Destructible requirements.
5 The implementation provides the templateshared_future and two specializations,shared_future<R&> and
shared_future<void>. These differ only in the return type and return value of the member functionget,
as set out in its description, below.
shared_future() noexcept;
6 Effects: The object does not refer to a shared state.
7 Postconditions: valid() == false.
shared_future(const shared_future& rhs) noexcept;
8 Effects: The object refers to the same shared state asrhs (if any).
9 Postconditions: valid() returns the same value asrhs.valid().
shared_future(future<R>&& rhs) noexcept;
shared_future(shared_future&& rhs) noexcept;
10 Effects: Move constructs ashared_future object that refers to the shared state that was originally
referred to byrhs (if any).
11 Postconditions:
—(11.1) valid() returns the same value asrhs.valid() returned prior to the constructor invocation.
—(11.2) rhs.valid() == false.
~shared_future();
12 Effects:
—(12.1) Releases any shared state (32.10.5);
—(12.2) destroys *this.
shared_future& operator=(shared_future&& rhs) noexcept;
13 Effects: If addressof(rhs) == this is true, there are no effects. Otherwise:
—(13.1) Releases any shared state (32.10.5);
—(13.2) move assigns the contents ofrhs to *this.
14 Postconditions:
—(14.1) valid() returns the same value asrhs.valid() returned prior to the assignment.
—(14.2) If addressof(rhs) == this is false, rhs.valid() == false.
shared_future& operator=(const shared_future& rhs) noexcept;
15 Effects: If addressof(rhs) == this is true, there are no effects. Otherwise:
—(15.1) Releases any shared state (32.10.5);
—(15.2) assigns the contents ofrhs to *this.
[Note 3: As a result,*this refers to the same shared state asrhs (if any). —end note]
16 Postconditions: valid() == rhs.valid().
const R& shared_future::get() const;
R& shared_future<R&>::get() const;
void shared_future<void>::get() const;
17 [Note 4: As described above, the template and its two required specializations differ only in the return type
and return value of the member functionget. —end note]
§ 32.10.8 © ISO/IEC
2251

===== PAGE 2263 =====

Dxxxx
18 [Note 5: Access to a value object stored in the shared state is unsynchronized, so operations onR might
introduce a data race (6.10.2).—end note]
19 Effects: wait()s until the shared state is ready, then retrieves the value stored in the shared state.
20 Returns:
—(20.1) shared_future::get() returns a const reference to the value stored in the object’s shared state.
[Note 6: Access through that reference after the shared state has been destroyed produces undefined
behavior; this can be avoided by not storing the reference in any storage with a greater lifetime than the
shared_future object that returned the reference.—end note]
—(20.2) shared_future<R&>::get() returns the reference stored as value in the object’s shared state.
—(20.3) shared_future<void>::get() returns nothing.
21 Throws: The stored exception, if an exception was stored in the shared state.
bool valid() const noexcept;
22 Returns: true only if*this refers to a shared state.
void wait() const;
23 Effects: Blocks until the shared state is ready.
template<class Rep, class Period>
future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;
24 Effects: None if the shared state contains a deferred function (32.10.9), otherwise blocks until the
shared state is ready or until the relative timeout (32.2.4) specified byrel_time has expired.
25 Returns:
—(25.1) future_status::deferred if the shared state contains a deferred function.
—(25.2) future_status::ready if the shared state is ready.
—(25.3) future_status::timeoutifthefunctionisreturningbecausetherelativetimeout(32.2.4)specified
by rel_time has expired.
26 Throws: timeout-related exceptions (32.2.4).
template<class Clock, class Duration>
future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
27 Effects: None if the shared state contains a deferred function (32.10.9), otherwise blocks until the
shared state is ready or until the absolute timeout (32.2.4) specified byabs_time has expired.
28 Returns:
—(28.1) future_status::deferred if the shared state contains a deferred function.
—(28.2) future_status::ready if the shared state is ready.
—(28.3) future_status::timeout if the function is returning because the absolute timeout (32.2.4)
specified byabs_time has expired.
29 Throws: timeout-related exceptions (32.2.4).
32.10.9 Function template async [futures.async]
1 The function templateasync provides a mechanism to launch a function potentially in a new thread and
provides the result of the function in afuture object with which it shares a shared state.
template<class F, class... Args>
future<invoke_result_t<decay_t<F>, decay_t<Args>...>>
async(F&& f, Args&&... args);
template<class F, class... Args>
future<invoke_result_t<decay_t<F>, decay_t<Args>...>>
async(launch policy, F&& f, Args&&... args);
2 Mandates: The following are alltrue:
—(2.1) is_constructible_v<decay_t<F>, F>,
—(2.2) (is_constructible_v<decay_t<Args>, Args> && ...), and
§ 32.10.9 © ISO/IEC
2252

===== PAGE 2264 =====

Dxxxx
—(2.3) is_invocable_v<decay_t<F>, decay_t<Args>...>.
3 Effects: The first function behaves the same as a call to the second function with apolicy argument of
launch::async | launch::deferred and the same arguments forF and Args. The second function
creates a shared state that is associated with the returnedfuture object. The further behavior of
the second function depends on thepolicy argument as follows (if more than one of these conditions
applies, the implementation may choose any of the corresponding policies):
—(3.1) If launch::async is set inpolicy, callsinvoke(auto(std::forward<F>(f)), auto(std::for-
ward<Args>(args))...) (22.10.5, 32.4.3.3) as if in a new thread of execution represented by a
thread object with the values produced byauto being materialized (7.3.5) in the thread that called
async. Any return value is stored as the result in the shared state. Any exception propagated from
the execution ofinvoke(auto(std::forward<F>(f)), auto(std::forward<Args>(args))...)
is stored as the exceptional result in the shared state. Thethread object is stored in the shared
state and affects the behavior of any asynchronous return objects that reference that state.
—(3.2) If launch::deferred is set inpolicy, storesauto(std::forward<F>(f)) and auto(std::for-
ward<Args>(args))... in the shared state. These copies off and args constitute a deferred
function. Invocation of the deferred function evaluatesinvoke(std::move(g), std::move(xyz))
where g is the stored value of auto(std::forward<F>(f)) and xyz is the stored copy of
auto(std::forward<Args>(args)).... Any return value is stored as the result in the shared
state. Any exception propagated from the execution of the deferred function is stored as the
exceptional result in the shared state. The shared state is not made ready until the function
has completed. The first call to a non-timed waiting function (32.10.5) on an asynchronous
return object referring to this shared state invokes the deferred function in the thread that called
the waiting function. Once evaluation ofinvoke(std::move(g), std::move(xyz)) begins, the
function is no longer considered deferred.
Recommended practice: If this policy is specified together with other policies, such as when using a
policy value oflaunch::async | launch::deferred, implementations should defer invocation
or the selection of the policy when no more concurrency can be effectively exploited.
—(3.3) If no value is set in the launch policy, or a value is set that is neither specified in this document
nor by the implementation, the behavior is undefined.
4 Synchronization: The invocation ofasync synchronizes with the invocation off. The completion of
the functionf is sequenced before the shared state is made ready.
[Note 1: These apply regardless of the providedpolicy argument, and even if the correspondingfuture object
is moved to another thread. However, it is possible forf not to be called at all, in which case its completion
never happens. —end note]
If the implementation chooses thelaunch::async policy,
—(4.1) a call to a waiting function on an asynchronous return object that shares the shared state created
by thisasync call shall block until the associated thread has completed, as if joined, or else time
out (32.4.3.6);
—(4.2) the associated thread completion synchronizes with (6.10.2) the return from the first function that
successfully detects the ready status of the shared state or with the return from the last function
that releases the shared state, whichever happens first.
5 Returns: An object of typefuture<invoke_result_t<decay_t<F>, decay_t<Args>...>> that refers
to the shared state created by this call toasync.
[Note 2: If a future obtained fromasync is moved outside the local scope, the future’s destructor can block for
the shared state to become ready.—end note]
6 Throws: system_error if policy == launch::async and the implementation is unable to start a new
thread, orstd::bad_alloc if memory for the internal data structures cannot be allocated.
7 Error conditions:
—(7.1) resource_unavailable_try_again — if policy == launch::async and the system is unable
to start a new thread.
8 [Example 1:
int work1(int value);
int work2(int value);
§ 32.10.9 © ISO/IEC
2253

===== PAGE 2265 =====

Dxxxx
int work(int value) {
auto handle = std::async([=]{ return work2(value); });
int tmp = work1(value);
return tmp + handle.get(); // #1
}
[Note 3: Line #1 might not result in concurrency because theasync call uses the default policy, which might use
launch::deferred, in which case the lambda might not be invoked until theget() call; in that case,work1 and
work2 are called on the same thread and there is no concurrency.—end note]
—end example]
32.10.10 Class template packaged_task [futures.task]
32.10.10.1 General [futures.task.general]
1 The class templatepackaged_task defines a type for wrapping a function or callable object so that the
return value of the function or callable object is stored in a future when it is invoked.
2 When thepackaged_task object is invoked, its stored task is invoked and the result (whether normal or
exceptional) stored in the shared state. Any futures that share the shared state will then be able to access
the stored result.
namespace std {
template<class> class packaged_task; // not defined
template<class R, class... ArgTypes>
class packaged_task<R(ArgTypes...)> {
public:
// construction and destruction
packaged_task() noexcept;
template<class F>
explicit packaged_task(F&& f);
template<class F, class Allocator>
explicit packaged_task(allocator_arg_t, const Allocator& a, F&& f);
~packaged_task();
// no copy
packaged_task(const packaged_task&) = delete;
packaged_task& operator=(const packaged_task&) = delete;
// move support
packaged_task(packaged_task&& rhs) noexcept;
packaged_task& operator=(packaged_task&& rhs) noexcept;
void swap(packaged_task& other) noexcept;
bool valid() const noexcept;
// result retrieval
future<R> get_future();
// execution
void operator()(ArgTypes... );
void make_ready_at_thread_exit(ArgTypes...);
void reset();
};
template<class R, class... ArgTypes>
packaged_task(R (*)(ArgTypes...)) -> packaged_task<R(ArgTypes...)>;
template<class F> packaged_task(F) -> packaged_task<see below >;
}
§ 32.10.10.1 © ISO/IEC
2254

===== PAGE 2266 =====

Dxxxx
32.10.10.2 Member functions [futures.task.members]
packaged_task() noexcept;
1 Effects: The object has no shared state and no stored task.
template<class F>
explicit packaged_task(F&& f);
2 Effects: Equivalent topackaged_task(allocator_arg, allocator<int>(), std::forward<F>(f)).
template<class F, class Allocator>
explicit packaged_task(allocator_arg_t, const Allocator& a, F&& f);
3 Constraints: remove_cvref_t<F> is not the same type aspackaged_task<R(ArgTypes...)>.
4 Mandates: is_invocable_r_v<R, decay_t<F>&, ArgTypes...> is true.
5 Preconditions: Allocator meets theCpp17Allocator requirements (16.4.4.6.1).
6 Effects: Let A2 be allocator_traits<Allocator>::rebind_alloc<unspecified > and leta2 be an
object of typeA2 initialized withA2(a). Constructs a newpackaged_task object with a stored task of
type decay_t<F> and a shared state. Initializes the object’s stored task withstd::forward<F>(f).
Uses a2 to allocate storage for the shared state and stores a copy ofa2 in the shared state.
7 Throws: Any exceptions thrown by the initialization of the stored task. If storage for the shared state
cannot be allocated, any exception thrown byA2::allocate.
template<class F> packaged_task(F) -> packaged_task<see below >;
8 Constraints: &F::operator() is well-formed when treated as an unevaluated operand (7.2.3) and either
—(8.1) F::operator() is a non-static member function anddecltype(&F::operator()) is either of the
form R(G::*)(A...) cv &opt noexceptopt or of the formR(*)(G, A...) noexceptopt for a type
G, or
—(8.2) F::operator() is a static member function and decltype(&F::operator()) is of the form
R(*)(A...) noexceptopt.
9 Remarks: The deduced type ispackaged_task<R(A...)>.
packaged_task(packaged_task&& rhs) noexcept;
10 Effects: Transfers ownership ofrhs’s shared state to*this, leavingrhs with no shared state. Moves
the stored task fromrhs to *this.
11 Postconditions: rhs has no shared state.
packaged_task& operator=(packaged_task&& rhs) noexcept;
12 Effects:
—(12.1) Releases any shared state (32.10.5);
—(12.2) calls packaged_task(std::move(rhs)).swap(*this).
~packaged_task();
13 Effects: Abandons any shared state (32.10.5).
void swap(packaged_task& other) noexcept;
14 Effects: Exchanges the shared states and stored tasks of*this and other.
15 Postconditions: *this has the same shared state and stored task (if any) asother prior to the call to
swap. other has the same shared state and stored task (if any) as*this prior to the call toswap.
bool valid() const noexcept;
16 Returns: true only if*this has a shared state.
future<R> get_future();
17 Synchronization: Calls to this function do not introduce data races (6.10.2) with calls tooperator()
or make_ready_at_thread_exit.
[Note 1: Such calls need not synchronize with each other.—end note]
§ 32.10.10.2 © ISO/IEC
2255

===== PAGE 2267 =====

Dxxxx
18 Returns: A future object that shares the same shared state as*this.
19 Throws: A future_error object if an error occurs.
20 Error conditions:
—(20.1) future_already_retrieved if get_future has already been called on apackaged_task object
with the same shared state as*this.
—(20.2) no_state if *this has no shared state.
void operator()(ArgTypes... args);
21 Effects: As if byINVOKE<R>(f, t1, t2, ... , tN) (22.10.4), wheref is the stored task of*this and
t1, t2, ... , tN are the values inargs.... If the task returns normally, the return value is stored as
the asynchronous result in the shared state of*this, otherwise the exception thrown by the task is
stored. The shared state of*this is made ready, and any threads blocked in a function waiting for the
shared state of*this to become ready are unblocked.
22 Throws: A future_error exception object if there is no shared state or the stored task has already
been invoked.
23 Error conditions:
—(23.1) promise_already_satisfied if the stored task has already been invoked.
—(23.2) no_state if *this has no shared state.
void make_ready_at_thread_exit(ArgTypes... args);
24 Effects: As if byINVOKE<R>(f, t1, t2, ... , tN) (22.10.4), wheref is the stored task andt1, t2,
... , tN are the values inargs.... If the task returns normally, the return value is stored as the
asynchronous result in the shared state of*this, otherwise the exception thrown by the task is stored.
In either case, this is done without making that state ready (32.10.5) immediately. Schedules the shared
state to be made ready when the current thread exits, after all objects with thread storage duration
associated with the current thread have been destroyed.
25 Throws: future_error if an error condition occurs.
26 Error conditions:
—(26.1) promise_already_satisfied if the stored task has already been invoked.
—(26.2) no_state if *this has no shared state.
void reset();
27 Effects: Equivalent to:
if (!valid()) {
throw future_error(future_errc::no_state);
}
*this = packaged_task(allocator_arg, a, std::move(f));
where f is the task stored in*this and a is the allocator stored in the shared state.
[Note 2: This constructs a new shared state for*this. The old state is abandoned (32.10.5).—end note]
28 Throws:
—(28.1) Any exception thrown by thepackaged_task constructor.
—(28.2) future_error with an error condition ofno_state if *this has no shared state.
32.10.10.3 Globals [futures.task.nonmembers]
template<class R, class... ArgTypes>
void swap(packaged_task<R(ArgTypes...)>& x, packaged_task<R(ArgTypes...)>& y) noexcept;
1 Effects: As if byx.swap(y).
32.11 Safe reclamation [saferecl]
32.11.1 General [saferecl.general]
1 Subclause 32.11 contains safe-reclamation techniques, which are most frequently used to straightforwardly
resolve access-deletion races.
§ 32.11.1 © ISO/IEC
2256

===== PAGE 2268 =====

Dxxxx
32.11.2 Read-copy update (RCU) [saferecl.rcu]
32.11.2.1 General [saferecl.rcu.general]
1 RCU is a synchronization mechanism that can be used for linked data structures that are frequently read, but
seldom updated. RCU does not provide mutual exclusion, but instead allows the user to schedule specified
actions such as deletion at some later time.
2 A class typeT is rcu-protectableif it has exactly one base class of typercu_obj_base<T, D> for someD, and
that base is public and non-virtual, and it has no base classes of typercu_obj_base<X, Y> for any other
combination X, Y. An object is rcu-protectable if it is of rcu-protectable type.
3 An invocation ofunlock U on anrcu_domain dom corresponds to an invocation oflock L on dom if L is
sequenced beforeU and either
—(3.1) no other invocation oflock on dom is sequenced afterL and beforeU, or
—(3.2) every invocation ofunlock U2 on dom such thatL is sequenced beforeU2 and U2 is sequenced before
U corresponds to an invocation oflock L2 on dom such that L is sequenced beforeL2 and L2 is
sequenced beforeU2.
[Note 1: This pairs nested locks and unlocks on a given domain in each thread.—end note]
4 A region of RCU protectionon a domaindom starts with alock L on dom and ends with its corresponding
unlock U.
5 Given a region of RCU protectionR on a domaindom and given an evaluationE that scheduled another
evaluation F in dom, ifE does not strongly happen before the start ofR, the end ofR strongly happens
before evaluatingF.
6 The evaluation of a scheduled evaluation is potentially concurrent with any other scheduled evaluation. Each
scheduled evaluation is evaluated at most once.
32.11.2.2 Header <rcu> synopsis [rcu.syn]
namespace std {
// 32.11.2.3, class templatercu_obj_base
template<class T, class D = default_delete<T>> class rcu_obj_base;
// 32.11.2.4, classrcu_domain
class rcu_domain;
// 32.11.2.4.3, non-member functions
rcu_domain& rcu_default_domain() noexcept;
void rcu_synchronize(rcu_domain& dom = rcu_default_domain()) noexcept;
void rcu_barrier(rcu_domain& dom = rcu_default_domain()) noexcept;
template<class T, class D = default_delete<T>>
void rcu_retire(T* p, D d = D(), rcu_domain& dom = rcu_default_domain());
}
32.11.2.3 Class template rcu_obj_base [saferecl.rcu.base]
1 Objects of typeT to be protected by RCU inherit from a specializationrcu_obj_base<T, D> for someD.
namespace std {
template<class T, class D = default_delete<T>>
class rcu_obj_base {
public:
void retire(D d = D(), rcu_domain& dom = rcu_default_domain()) noexcept;
protected:
rcu_obj_base() = default;
rcu_obj_base(const rcu_obj_base&) = default;
rcu_obj_base(rcu_obj_base&&) = default;
rcu_obj_base& operator=(const rcu_obj_base&) = default;
rcu_obj_base& operator=(rcu_obj_base&&) = default;
~rcu_obj_base() = default;
private:
D deleter ; // exposition only
};
}
§ 32.11.2.3 © ISO/IEC
2257

===== PAGE 2269 =====

Dxxxx
2 The behavior of a program that adds specializations forrcu_obj_base is undefined.
3 T may be an incomplete type. It shall be complete before any member of the resulting specialization of
rcu_obj_base is referenced.
4 D shall be a function object type (22.10) for which, given a valued of typeD and a valueptr of typeT*, the
expression d(ptr) is valid.
5 D shall meet the requirements forCpp17DefaultConstructible and Cpp17MoveAssignable.
6 If D is trivially copyable, all specializations ofrcu_obj_base<T, D> are trivially copyable.
void retire(D d = D(), rcu_domain& dom = rcu_default_domain()) noexcept;
7 Mandates: T is an rcu-protectable type.
8 Preconditions: *this is a base class subobject of an objectx of typeT. The member functionrcu_-
obj_base<T, D>::retire was not invoked onx before. The assignment todeleter does not exit via
an exception.
9 Effects: Evaluatesdeleter = std::move(d) and schedules the evaluation of the expressiondeleter (
addressof(x)) in the domaindom; the behavior is undefined if that evaluation exits via an exception.
May invoke scheduled evaluations indom.
[Note 1: If such evaluations acquire resources held across any invocation ofretire on dom, deadlock can occur.
—end note]
32.11.2.4 Class rcu_domain [saferecl.rcu.domain]
32.11.2.4.1 General [saferecl.rcu.domain.general]
namespace std {
class rcu_domain {
public:
rcu_domain(const rcu_domain&) = delete;
rcu_domain& operator=(const rcu_domain&) = delete;
void lock() noexcept;
bool try_lock() noexcept;
void unlock() noexcept;
};
}
1 This class meets the requirements ofCpp17Lockable (32.2.5.3) and provides regions of RCU protection.
[Example 1:
std::scoped_lock<rcu_domain> rlock(rcu_default_domain());
—end example]
2 The functionslock and unlock establish (possibly nested) regions of RCU protection.
32.11.2.4.2 Member functions [saferecl.rcu.domain.members]
void lock() noexcept;
1 Effects: Opens a region of RCU protection.
2 Remarks: Calls tolock do not introduce a data race (6.10.2.2) involving*this.
bool try_lock() noexcept;
3 Effects: Equivalent tolock().
4 Returns: true.
void unlock() noexcept;
5 Preconditions: A call tolock that opened an unclosed region of RCU protection is sequenced before
the call tounlock.
6 Effects: Closes the unclosed region of RCU protection that was most recently opened. May invoke
scheduled evaluations in*this.
7 [Note 1: If such evaluations acquire resources held across any invocation ofunlock on *this, deadlock can
occur. —end note]
§ 32.11.2.4.2 © ISO/IEC
2258

===== PAGE 2270 =====

Dxxxx
8 Remarks: Calls tounlock do not introduce a data race involving*this.
[Note 2: Evaluation of scheduled evaluations can still cause a data race.—end note]
32.11.2.4.3 Non-member functions [saferecl.rcu.domain.func]
rcu_domain& rcu_default_domain() noexcept;
1 Returns: A reference to a static-duration object of typercu_domain. A reference to the same object is
returned every time this function is called.
void rcu_synchronize(rcu_domain& dom = rcu_default_domain()) noexcept;
2 Effects: If the call torcu_synchronize does not strongly happen before the lock opening an RCU
protection regionR on dom, blocks until theunlock closing R happens.
3 Synchronization: The unlock closing R strongly happens before the return fromrcu_synchronize.
void rcu_barrier(rcu_domain& dom = rcu_default_domain()) noexcept;
4 Effects: May evaluate any scheduled evaluations indom. For any evaluation that happens before the
call torcu_barrier and that schedules an evaluationE in dom, blocks untilE has been evaluated.
5 Synchronization: The evaluation of any suchE strongly happens before the return fromrcu_barrier.
[Note 1: A call torcu_barrier does not imply a call torcu_synchronize and vice versa. —end note]
template<class T, class D = default_delete<T>>
void rcu_retire(T* p, D d = D(), rcu_domain& dom = rcu_default_domain());
6 Mandates: is_move_constructible_v<D> is true and the expressiond(p) is well-formed.
7 Preconditions: D meets theCpp17MoveConstructible and Cpp17Destructible requirements.
8 Effects: May allocate memory. It is unspecified whether the memory allocation is performed by invoking
operator new. Initializes an object d1 of type D from std::move(d). Schedules the evaluation of
d1(p) in the domaindom; the behavior is undefined if that evaluation exits via an exception. May
invoke scheduled evaluations indom.
[Note 2: If rcu_retire exits via an exception, no evaluation is scheduled.—end note]
9 Throws: bad_alloc or any exception thrown by the initialization ofd1.
10 [Note 3: If scheduled evaluations acquire resources held across any invocation ofrcu_retire on dom, deadlock
can occur. —end note]
32.11.3 Hazard pointers [saferecl.hp]
32.11.3.1 General [saferecl.hp.general]
1 A hazard pointer is a single-writer multi-reader pointer that can be owned by at most one thread at any
time. Only the owner of the hazard pointer can set its value, while any number of threads may read its value.
The owner thread sets the value of a hazard pointer to point to an object in order to indicate to concurrent
threads—which may delete such an object—that the object is not yet safe to delete.
2 A class typeT is hazard-protectableif it has exactly one base class of typehazard_pointer_obj_base<T,
D> for someD, that base is public and non-virtual, and it has no base classes of typehazard_pointer_obj_-
base<T2, D2> for any other combinationT2, D2. An object ishazard-protectableif it is of hazard-protectable
type.
3 The time span between creation and destruction of a hazard pointerhis partitioned into a series ofprotection
epochs; in each protection epoch,h either isassociated witha hazard-protectable object, or isunassociated.
Upon creation, a hazard pointer is unassociated. Changing the association (possibly to the same object)
initiates a new protection epoch and ends the preceding one.
4 An object x of hazard-protectable typeT is retired with a deleter of typeD when the member function
hazard_pointer_obj_base<T, D>::retire is invoked onx. Any given objectx shall be retired at most
once.
5 A retired objectx is reclaimedby invoking its deleter with a pointer tox; the behavior is undefined if that
invocation exits via an exception.
6 A hazard-protectable objectx is possibly-reclaimablewith respect to an evaluationA if
—(6.1) x is not reclaimed; and
§ 32.11.3.1 © ISO/IEC
2259

===== PAGE 2271 =====

Dxxxx
—(6.2) x is retired in an evaluationR and A does not happen beforeR; and
—(6.3) for all hazard pointersh and for every protection epochE of h during whichh is associated withx:
—(6.3.1) if the beginning ofE happens beforeR, the end ofE strongly happens beforeA; and
—(6.3.2) if E began by an evaluation oftry_protect with argumentsrc, label its atomic load operation
L. If there exists an atomic modificationB on src such thatL observes a modification that is
modification-ordered beforeB, andB happens beforex is retired, the end ofE strongly happens
before A.
[Note 1: In typical use, a store tosrc sequenced before retiringx will be such an atomic operationB.
—end note]
[Note 2: The latter two conditions convey the informal notion that a protection epoch that began before retiring
x, as implied either by the happens-before relation or the coherence order of some source, delays the reclamation
of x. —end note]
7 The number of possibly-reclaimable objects has an unspecified bound.
[Note 3: The bound can be a function of the number of hazard pointers, the number of threads that retire objects,
and the number of threads that use hazard pointers.—end note]
[Example 1: The following example shows how hazard pointers allow updates to be carried out in the presence of
concurrent readers. The object of typehazard_pointer in print_name protects the object*ptr from being reclaimed
by ptr->retire until the end of the protection epoch.
struct Name : public hazard_pointer_obj_base<Name> { /∗ details ∗/ };
atomic<Name*> name;
// called often and in parallel!
void print_name() {
hazard_pointer h = make_hazard_pointer();
Name* ptr = h.protect(name); // Protection epoch starts
// ... safe to access*ptr
} // Protection epoch ends.
// called rarely, but possibly concurrently withprint_name
void update_name(Name* new_name) {
Name* ptr = name.exchange(new_name);
ptr->retire();
}
—end example]
32.11.3.2 Header <hazard_pointer> synopsis [hazard.pointer.syn]
namespace std {
// 32.11.3.3, class templatehazard_pointer_obj_base
template<class T, class D = default_delete<T>> class hazard_pointer_obj_base;
// 32.11.3.4, classhazard_pointer
class hazard_pointer;
// 32.11.3.4.4, non-member functions
hazard_pointer make_hazard_pointer();
void swap(hazard_pointer&, hazard_pointer&) noexcept;
}
32.11.3.3 Class template hazard_pointer_obj_base [saferecl.hp.base]
namespace std {
template<class T, class D = default_delete<T>>
class hazard_pointer_obj_base {
public:
void retire(D d = D()) noexcept;
protected:
hazard_pointer_obj_base() = default;
hazard_pointer_obj_base(const hazard_pointer_obj_base&) = default;
hazard_pointer_obj_base(hazard_pointer_obj_base&&) = default;
hazard_pointer_obj_base& operator=(const hazard_pointer_obj_base&) = default;
hazard_pointer_obj_base& operator=(hazard_pointer_obj_base&&) = default;
§ 32.11.3.3 © ISO/IEC
2260

===== PAGE 2272 =====

Dxxxx
~hazard_pointer_obj_base() = default;
private:
D deleter ; // exposition only
};
}
1 D shall be a function object type (22.10.4) for which, given a valued of typeD and a valueptr of typeT*,
the expressiond(ptr) is valid.
2 The behavior of a program that adds specializations forhazard_pointer_obj_base is undefined.
3 D shall meet the requirements forCpp17DefaultConstructible and Cpp17MoveAssignable.
4 T may be an incomplete type. It shall be complete before any member of the resulting specialization of
hazard_pointer_obj_base is referenced.
void retire(D d = D()) noexcept;
5 Mandates: T is a hazard-protectable type.
6 Preconditions: *this is a base class subobject of an objectx of typeT. x is not retired. Move-assigning
d to deleter does not exit via an exception.
7 Effects: Move-assignsd to deleter, thereby setting it as the deleter ofx, then retiresx. May reclaim
possibly-reclaimable objects.
32.11.3.4 Class hazard_pointer [saferecl.hp.holder]
32.11.3.4.1 General [saferecl.hp.holder.general]
namespace std {
class hazard_pointer {
public:
hazard_pointer() noexcept;
hazard_pointer(hazard_pointer&&) noexcept;
hazard_pointer& operator=(hazard_pointer&&) noexcept;
~hazard_pointer();
bool empty() const noexcept;
template<class T> T* protect(const atomic<T*>& src) noexcept;
template<class T> bool try_protect(T*& ptr, const atomic<T*>& src) noexcept;
template<class T> void reset_protection(const T* ptr) noexcept;
void reset_protection(nullptr_t = nullptr) noexcept;
void swap(hazard_pointer&) noexcept;
};
}
1 An object of typehazard_pointer is either empty orowns a hazard pointer. Each hazard pointer is owned
by exactly one object of typehazard_pointer.
[Note 1: An emptyhazard_pointer object is different from ahazard_pointer object that owns an unassociated
hazard pointer. An emptyhazard_pointer object does not own any hazard pointers.—end note]
32.11.3.4.2 Constructors, destructor, and assignment [saferecl.hp.holder.ctor]
hazard_pointer() noexcept;
1 Postconditions: *this is empty.
hazard_pointer(hazard_pointer&& other) noexcept;
2 Postconditions: If other is empty,*this is empty. Otherwise,*this owns the hazard pointer originally
owned byother; other is empty.
~hazard_pointer();
3 Effects: If *this is not empty, destroys the hazard pointer owned by*this, thereby ending its current
protection epoch.
hazard_pointer& operator=(hazard_pointer&& other) noexcept;
4 Effects: If this == &other is true, no effect. Otherwise, if*this is not empty, destroys the hazard
pointer owned by*this, thereby ending its current protection epoch.
§ 32.11.3.4.2 © ISO/IEC
2261

===== PAGE 2273 =====

Dxxxx
5 Postconditions: If other was empty,*this is empty. Otherwise, *this owns the hazard pointer
originally owned byother. If this != &other is true, other is empty.
6 Returns: *this.
32.11.3.4.3 Member functions [saferecl.hp.holder.mem]
bool empty() const noexcept;
1 Returns: true if and only if*this is empty.
template<class T> T* protect(const atomic<T*>& src) noexcept;
2 Effects: Equivalent to:
T* ptr = src.load(memory_order::relaxed);
while (!try_protect(ptr, src)) {}
return ptr;
template<class T> bool try_protect(T*& ptr, const atomic<T*>& src) noexcept;
3 Mandates: T is a hazard-protectable type.
4 Preconditions: *this is not empty.
5 Effects: Performs the following steps in order:
—(5.1) Initializes a variableold of typeT* with the value ofptr.
—(5.2) Evaluates reset_protection(old).
—(5.3) Assigns the value ofsrc.load(memory_order::acquire) to ptr.
—(5.4) If old == ptr is false, evaluatesreset_protection().
6 Returns: old == ptr.
template<class T> void reset_protection(const T* ptr) noexcept;
7 Mandates: T is a hazard-protectable type.
8 Preconditions: *this is not empty.
9 Effects: If ptr is a null pointer value, invokesreset_protection(). Otherwise, associates the hazard
pointer owned by*this with *ptr, thereby ending the current protection epoch.
10 Complexity: Constant.
void reset_protection(nullptr_t = nullptr) noexcept;
11 Preconditions: *this is not empty.
12 Postconditions: The hazard pointer owned by*this is unassociated.
13 Complexity: Constant.
void swap(hazard_pointer& other) noexcept;
14 Effects: Swaps the hazard pointer ownership of this object with that ofother.
[Note 1: The owned hazard pointers, if any, remain unchanged during the swap and continue to be associated
with the respective objects that they were protecting before the swap, if any. No protection epochs are ended or
initiated. —end note]
15 Complexity: Constant.
32.11.3.4.4 Non-member functions [saferecl.hp.holder.nonmem]
hazard_pointer make_hazard_pointer();
1 Effects: Constructs a hazard pointer.
2 Returns: A hazard_pointer object that owns the newly-constructed hazard pointer.
3 Throws: May throwbad_alloc if memory for the hazard pointer could not be allocated.
void swap(hazard_pointer& a, hazard_pointer& b) noexcept;
4 Effects: Equivalent toa.swap(b).
§ 32.11.3.4.4 © ISO/IEC
2262

===== PAGE 2274 =====

Dxxxx
33 Execution control library [exec]
33.1 General [exec.general]
1 This Clause describes components supporting execution of function objects (22.10).
2 The following subclauses describe the requirements, concepts, and components for execution control primitives
as summarized in Table 157.
Table 157 — Execution control library summary [tab:exec.summary]
Subclause Header
33.6 Schedulers <execution>
33.7 Receivers
33.8 Operation states
33.9 Senders
3 Table 158 shows the types of customization point objects (16.3.3.3.5) used in the execution control library.
Table 158 — Types of customization point objects in the execution control library
[tab:exec.pos]
Customization point Purpose Examples
object type
core provide core execution
functionality, and
connection between core
components
e.g., connect, start
completion functions called by senders to
announce the completion
of the work (success,
error, or cancellation)
set_value, set_error, set_stopped
senders allow the specialization
of the provided sender
algorithms
— sender factories (e.g.,schedule, just,
read_env)
— sender adaptors (e.g.,continues_on,
then, let_value)
— sender consumers (e.g.,sync_wait)
queries allow querying different
properties of objects — general queries (e.g.,get_allocator,
get_stop_token)
— environment queries (e.g.,get_scheduler,
get_delegation_scheduler)
— scheduler queries (e.g.,
get_forward_progress_guarantee)
— sender attribute queries (e.g.,
get_completion_scheduler)
4 This clause makes use of the following exposition-only entities.
5 For a subexpressionexpr, letMANDATE-NOTHROW (expr) be expression-equivalent toexpr.
Mandates: noexcept(expr) is true.
§ 33.1 © ISO/IEC
2263

===== PAGE 2275 =====

Dxxxx
6 namespace std {
template<class T>
concept movable-value = // exposition only
move_constructible<decay_t<T>> &&
constructible_from<decay_t<T>, T> &&
(!is_array_v<remove_reference_t<T>>);
}
7 For function typesF1 and F2 denoting R1(Args1...) and R2(Args2...), respectively,MATCHING-SIG (F1,
F2) is true if and only ifsame_as<R1(Args1&&...), R2(Args2&&...)> is true.
8 For a subexpressionerr, letErr be decltype((err)) and letAS-EXCEPT-PTR (err) be:
—(8.1) err if decay_t<Err> denotes the typeexception_ptr.
Preconditions: !err is false.
—(8.2) Otherwise, make_exception_ptr(system_error(err)) if decay_t<Err> denotes the type error_-
code.
—(8.3) Otherwise, make_exception_ptr(err).
9 For a subexpressionexpr, letAS-CONST (expr) be expression-equivalent to
[](const auto& x) noexcept -> const auto& { return x; }(expr)
33.2 Queries and queryables [exec.queryable]
33.2.1 General [exec.queryable.general]
1 A queryable objectis a read-only collection of key/value pair where each key is a customization point object
known as aquery object. A query is an invocation of a query object with a queryable object as its first
argument and a (possibly empty) set of additional arguments. A query imposes syntactic and semantic
requirements on its invocations.
2 Let q be a query object, letargs be a (possibly empty) pack of subexpressions, letenv be a subexpression
that refers to a queryable objecto of type O, and let cenv be a subexpression referring too such that
decltype((cenv)) is const O&. The expressionq(env, args...) is equal to (18.2) the expressionq(cenv,
args...).
3 The type of a query expression cannot bevoid.
4 The expressionq(env, args...) is equality-preserving (18.2) and does not modify the query object or the
arguments.
5 Iftheexpression env.query(q, args...)iswell-formed, thenitisexpression-equivalentto q(env, args...).
6 Unless otherwise specified, the result of a query is valid as long as the queryable object is valid.
33.2.2 queryable concept [exec.queryable.concept]
namespace std {
template<class T>
concept queryable = destructible<T>; // exposition only
}
1 The exposition-onlyqueryable concept specifies the constraints on the types of queryable objects.
2 Let env be an object of typeEnv. The type Env models queryable if for each callable objectq and a
pack of subexpressionsargs, if requires { q(env, args...) } is true then q(env, args...) meets any
semantic requirements imposed byq.
33.3 Asynchronous operations [exec.async.ops]
1 An execution resourceis a program entity that manages a (possibly dynamic) set of execution agents (32.2.5.1),
which it uses to execute parallel work on behalf of callers.
[Example 1: The currently active thread, a system-provided thread pool, and uses of an API associated with an
external hardware accelerator are all examples of execution resources.—end example]
Execution resources execute asynchronous operations. An execution resource is either valid or invalid.
2 An asynchronous operationis a distinct unit of program execution that
—(2.1) is explicitly created;
§ 33.3 © ISO/IEC
2264

===== PAGE 2276 =====

Dxxxx
—(2.2) can be explicitly started once at most;
—(2.3) once started, eventually completes exactly once with a (possibly empty) set of result datums and in
exactly one of threedispositions: success, failure, or cancellation;
—(2.3.1) A successful completion, also known as avalue completion, can have an arbitrary number of result
datums.
—(2.3.2) A failure completion, also known as anerror completion, has a single result datum.
—(2.3.3) A cancellation completion, also known as astopped completion, has no result datum.
An asynchronous operation’sasync resultis its disposition and its (possibly empty) set of result datums.
—(2.4) can complete on a different execution resource than the execution resource on which it started; and
—(2.5) can create and start other asynchronous operations calledchild operations. A child operation is an
asynchronous operation that is created by the parent operation and, if started, completes before the
parent operation completes. Aparent operationis the asynchronous operation that created a particular
child operation.
[Note 1: An asynchronous operation can execute synchronously; that is, it can complete during the execution of its
start operation on the thread of execution that started it.—end note]
3 An asynchronous operation has associated state known as itsoperation state.
4 An asynchronous operation has an associated environment. Anenvironment is a queryable object (33.2)
representing the execution-time properties of the operation’s caller. The caller of an asynchronous operation
is its parent operation or the function that created it.
5 An asynchronous operation has an associated receiver. Areceiver is an aggregation of three handlers for the
three asynchronous completion dispositions:
—(5.1) a value completion handler for a value completion,
—(5.2) an error completion handler for an error completion, and
—(5.3) a stopped completion handler for a stopped completion.
A receiver has an associated environment. An asynchronous operation’s operation state owns the operation’s
receiver. The environment of an asynchronous operation is equal to its receiver’s environment.
6 For each completion disposition, there is acompletion function. A completion function is a customization
point object (16.3.3.3.5) that accepts an asynchronous operation’s receiver as the first argument and the result
datums of the asynchronous operation as additional arguments. The value completion function invokes the
receiver’s value completion handler with the value result datums; likewise for the error completion function
and the stopped completion function. A completion function has an associated type known as itscompletion
tag that is the unqualified type of the completion function. A valid invocation of a completion function is
called acompletion operation.
7 The lifetime of an asynchronous operation, also known as the operation’sasync lifetime, begins when its start
operation begins executing and ends when its completion operation begins executing. If the lifetime of an
asynchronous operation’s associated operation state ends before the lifetime of the asynchronous operation,
the behavior is undefined. After an asynchronous operation executes a completion operation, its associated
operation state is invalid. Accessing any part of an invalid operation state is undefined behavior.
8 An asynchronous operation shall not execute a completion operation before its start operation has begun
executing. After its start operation has begun executing, exactly one completion operation shall execute.
The lifetime of an asynchronous operation’s operation state can end during the execution of the completion
operation.
9 A sender is a factory for one or more asynchronous operations.Connecting a sender and a receiver creates
an asynchronous operation. The asynchronous operation’s associated receiver is equal to the receiver used
to create it, and its associated environment is equal to the environment associated with the receiver used
to create it. The lifetime of an asynchronous operation’s associated operation state does not depend on
the lifetimes of either the sender or the receiver from which it was created. A sender is started when it is
connected to a receiver and the resulting asynchronous operation is started. A sender’s async result is the
async result of the asynchronous operation created by connecting it to a receiver. A sender sends its results
by way of the asynchronous operation(s) it produces, and a receiver receives those results. A sender is either
valid or invalid; it becomes invalid when its parent sender (see below) becomes invalid.
§ 33.3 © ISO/IEC
2265

===== PAGE 2277 =====

Dxxxx
10 A scheduler is an abstraction of an execution resource with a uniform, generic interface for scheduling work
onto that resource. It is a factory for senders whose asynchronous operations execute value completion
operations on an execution agent belonging to the scheduler’s associated execution resource. Aschedule-
expression obtains such a sender from a scheduler. Aschedule senderis the result of a schedule expression.
On success, an asynchronous operation produced by a schedule sender executes a value completion operation
with an empty set of result datums. Multiple schedulers can refer to the same execution resource. A scheduler
can be valid or invalid. A scheduler becomes invalid when the execution resource to which it refers becomes
invalid, as do any schedule senders obtained from the scheduler, and any operation states obtained from
those senders.
11 An asynchronous operation has one or more associated completion schedulers for each of its possible
dispositions. A completion scheduleris a scheduler whose associated execution resource is used to execute a
completion operation for an asynchronous operation. A value completion scheduler is a scheduler on which an
asynchronous operation’s value completion operation can execute. Likewise for error completion schedulers
and stopped completion schedulers.
12 A sender has an associated queryable object (33.2) known as itsattributes that describes various characteristics
of the sender and of the asynchronous operation(s) it produces. For each disposition, there is a query object
for reading the associated completion scheduler from a sender’s attributes; i.e., a value completion scheduler
query object for reading a sender’s value completion scheduler, etc. If a completion scheduler query is
well-formed, the returned completion scheduler is unique for that disposition for any asynchronous operation
the sender creates. A schedule sender is required to have a value completion scheduler attribute whose value
is equal to the scheduler that produced the schedule sender.
13 A completion signatureis a function type that describes a completion operation. An asynchronous operation
has a finite set of possible completion signatures corresponding to the completion operations that the
asynchronous operation potentially evaluates (6.3). For a completion functionset, receiverrcvr, and pack
of argumentsargs, letc be the completion operationset(rcvr, args...), and letF be the function type
decltype(auto(set))(decltype((args))...). A completion signatureSig is associated withc if and only
if MATCHING-SIG (Sig, F) is true (33.1). Together, a sender type and an environment typeEnv determine
the set of completion signatures of an asynchronous operation that results from connecting the sender with
a receiver that has an environment of typeEnv. The type of the receiver does not affect an asynchronous
operation’s completion signatures, only the type of the receiver’s environment. Anon-dependent senderis a
sender type whose completion signatures are knowable independent of an execution environment.
14 A sender algorithm is a function that takes and/or returns a sender. There are three categories of sender
algorithms:
—(14.1) A sender factoryis a function that takes non-senders as arguments and that returns a sender.
—(14.2) A sender adaptor is a function that constructs and returns a parent sender from a set of one or more
child senders and a (possibly empty) set of additional arguments. An asynchronous operation created
by a parent sender is a parent operation to the child operations created by the child senders.
—(14.3) A sender consumeris a function that takes one or more senders and a (possibly empty) set of additional
arguments, and whose return type is not the type of a sender.
33.4 Header <execution> synopsis [execution.syn]
namespace std {
// 26.3.6.2, execution policy type trait
template<class T> struct is_execution_policy; // freestanding
template<class T> constexpr bool is_execution_policy_v = // freestanding
is_execution_policy<T>::value;
}
namespace std::execution {
// 26.3.6.3, sequenced execution policy
class sequenced_policy;
// 26.3.6.4, parallel execution policy
class parallel_policy;
// 26.3.6.5, parallel and unsequenced execution policy
class parallel_unsequenced_policy;
§ 33.4 © ISO/IEC
2266

===== PAGE 2278 =====

Dxxxx
// 26.3.6.6, unsequenced execution policy
class unsequenced_policy;
// 26.3.6.7, execution policy objects
inline constexpr sequenced_policy seq{ unspecified };
inline constexpr parallel_policy par{ unspecified };
inline constexpr parallel_unsequenced_policy par_unseq{ unspecified };
inline constexpr unsequenced_policy unseq{ unspecified };
}
namespace std {
// 33.1, helper concepts
template<class T>
concept movable-value = see below; // exposition only
template<class From, class To>
concept decays-to = same_as<decay_t<From>, To>; // exposition only
template<class T>
concept class-type = decays-to<T, T> && is_class_v<T>; // exposition only
// 33.2, queryable objects
template<class T>
concept queryable = see below; // exposition only
// 33.5, queries
struct forwarding_query_t { unspecified };
struct get_allocator_t { unspecified };
struct get_stop_token_t { unspecified };
inline constexpr forwarding_query_t forwarding_query{};
inline constexpr get_allocator_t get_allocator{};
inline constexpr get_stop_token_t get_stop_token{};
template<class T>
using stop_token_of_t = remove_cvref_t<decltype(get_stop_token(declval<T>()))>;
template<class T>
concept forwarding-query = forwarding_query(T{}); // exposition only
}
namespace std::execution {
// 33.5, queries
struct get_domain_t { unspecified };
struct get_scheduler_t { unspecified };
struct get_delegation_scheduler_t { unspecified };
struct get_forward_progress_guarantee_t { unspecified };
template<class CPO>
struct get_completion_scheduler_t { unspecified };
struct get_await_completion_adaptor_t { unspecified };
inline constexpr get_domain_t get_domain{};
inline constexpr get_scheduler_t get_scheduler{};
inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
enum class forward_progress_guarantee;
inline constexpr get_forward_progress_guarantee_t get_forward_progress_guarantee{};
template<class CPO>
constexpr get_completion_scheduler_t<CPO> get_completion_scheduler{};
inline constexpr get_await_completion_adaptor_t get_await_completion_adaptor{};
struct get_env_t { unspecified };
inline constexpr get_env_t get_env{};
§ 33.4 © ISO/IEC
2267

===== PAGE 2279 =====

Dxxxx
template<class T>
using env_of_t = decltype(get_env(declval<T>()));
// 33.9.5, execution domains
struct default_domain;
// 33.6, schedulers
struct scheduler_t {};
template<class Sch>
concept scheduler = see below ;
// 33.7, receivers
struct receiver_t {};
template<class Rcvr>
concept receiver = see below ;
template<class Rcvr, class Completions>
concept receiver_of = see below ;
struct set_value_t { unspecified };
struct set_error_t { unspecified };
struct set_stopped_t { unspecified };
inline constexpr set_value_t set_value{};
inline constexpr set_error_t set_error{};
inline constexpr set_stopped_t set_stopped{};
// 33.8, operation states
struct operation_state_t {};
template<class O>
concept operation_state = see below ;
struct start_t;
inline constexpr start_t start{};
// 33.9, senders
struct sender_t {};
template<class Sndr>
inline constexpr bool enable_sender = see below ;
template<class Sndr>
concept sender = see below ;
template<class Sndr, class... Env>
concept sender_in = see below ;
template<class Sndr>
concept dependent_sender = see below ;
template<class Sndr, class Rcvr>
concept sender_to = see below ;
template<class... Ts>
struct type-list; // exposition only
template<class... Ts>
using decayed-tuple = tuple<decay_t<Ts>...>; // exposition only
template<class... Ts>
using variant-or-empty = see below; // exposition only
§ 33.4 © ISO/IEC
2268

===== PAGE 2280 =====

Dxxxx
template<class Sndr, class Env = env<>,
template<class...> class Tuple = decayed-tuple ,
template<class...> class Variant = variant-or-empty >
requires sender_in<Sndr, Env>
using value_types_of_t = see below ;
template<class Sndr, class Env = env<>,
template<class...> class Variant = variant-or-empty >
requires sender_in<Sndr, Env>
using error_types_of_t = see below ;
template<class Sndr, class Env = env<>>
requires sender_in<Sndr, Env>
constexpr bool sends_stopped = see below ;
template<class Sndr, class... Env>
using single-sender-value-type = see below; // exposition only
template<class Sndr, class... Env>
concept single-sender = see below ; // exposition only
template<sender Sndr>
using tag_of_t = see below ;
// 33.9.6, sender transformations
template<class Domain, sender Sndr, queryable ... Env>
requires (sizeof...(Env) <= 1)
constexpr sender decltype(auto) transform_sender(
Domain dom, Sndr&& sndr, const Env&... env) noexcept(see below );
// 33.9.7, environment transformations
template<class Domain, sender Sndr, queryable Env>
constexpr queryable decltype(auto) transform_env(
Domain dom, Sndr&& sndr, Env&& env) noexcept;
// 33.9.8, sender algorithm application
template<class Domain, class Tag, sender Sndr, class... Args>
constexpr decltype(auto) apply_sender(
Domain dom, Tag, Sndr&& sndr, Args&&... args) noexcept(see below );
// 33.9.9, get completion signatures
template<class Sndr, class... Env>
consteval auto get_completion_signatures() -> valid-completion-signatures auto;
template<class Sndr, class... Env>
requires sender_in<Sndr, Env...>
using completion_signatures_of_t = decltype(get_completion_signatures<Sndr, Env...>());
// 33.9.10, the connect sender algorithm
struct connect_t;
inline constexpr connect_t connect{};
template<class Sndr, class Rcvr>
using connect_result_t =
decltype(connect(declval<Sndr>(), declval<Rcvr>()));
// 33.9.11, sender factories
struct just_t { unspecified };
struct just_error_t { unspecified };
struct just_stopped_t { unspecified };
struct schedule_t { unspecified };
inline constexpr just_t just{};
inline constexpr just_error_t just_error{};
§ 33.4 © ISO/IEC
2269

===== PAGE 2281 =====

Dxxxx
inline constexpr just_stopped_t just_stopped{};
inline constexpr schedule_t schedule{};
inline constexpr unspecified read_env{};
template<scheduler Sch>
using schedule_result_t = decltype(schedule(declval<Sch>()));
// 33.9.12, sender adaptors
template<class-type D>
struct sender_adaptor_closure { };
struct starts_on_t { unspecified };
struct continues_on_t { unspecified };
struct on_t { unspecified };
struct schedule_from_t { unspecified };
struct then_t { unspecified };
struct upon_error_t { unspecified };
struct upon_stopped_t { unspecified };
struct let_value_t { unspecified };
struct let_error_t { unspecified };
struct let_stopped_t { unspecified };
struct bulk_t { unspecified };
struct bulk_chunked_t { unspecified };
struct bulk_unchunked_t { unspecified };
struct when_all_t { unspecified };
struct when_all_with_variant_t { unspecified };
struct into_variant_t { unspecified };
struct stopped_as_optional_t { unspecified };
struct stopped_as_error_t { unspecified };
struct associate_t { unspecified };
struct spawn_future_t { unspecified };
inline constexpr unspecified write_env{};
inline constexpr unspecified unstoppable{};
inline constexpr starts_on_t starts_on{};
inline constexpr continues_on_t continues_on{};
inline constexpr on_t on{};
inline constexpr schedule_from_t schedule_from{};
inline constexpr then_t then{};
inline constexpr upon_error_t upon_error{};
inline constexpr upon_stopped_t upon_stopped{};
inline constexpr let_value_t let_value{};
inline constexpr let_error_t let_error{};
inline constexpr let_stopped_t let_stopped{};
inline constexpr bulk_t bulk{};
inline constexpr bulk_chunked_t bulk_chunked{};
inline constexpr bulk_unchunked_t bulk_unchunked{};
inline constexpr when_all_t when_all{};
inline constexpr when_all_with_variant_t when_all_with_variant{};
inline constexpr into_variant_t into_variant{};
inline constexpr stopped_as_optional_t stopped_as_optional{};
inline constexpr stopped_as_error_t stopped_as_error{};
inline constexpr associate_t associate{};
inline constexpr spawn_future_t spawn_future{};
}
namespace std::this_thread {
// 33.9.13, consumers
struct sync_wait_t { unspecified };
struct sync_wait_with_variant_t { unspecified };
inline constexpr sync_wait_t sync_wait{};
inline constexpr sync_wait_with_variant_t sync_wait_with_variant{};
}
§ 33.4 © ISO/IEC
2270

===== PAGE 2282 =====

Dxxxx
namespace std::execution {
// 33.9.13, consumers
struct spawn_t { unspecified };
inline constexpr spawn_t spawn{};
// 33.10, completion signatures
template<class Fn>
concept completion-signature = see below; // exposition only
template<completion-signature ... Fns>
struct completion_signatures;
template<class Sigs>
concept valid-completion-signatures = see below; // exposition only
struct dependent_sender_error : exception {};
// 33.11.1, class templateprop
template<class QueryTag, class ValueType>
struct prop;
// 33.11.2, class templateenv
template<queryable ... Envs>
struct env;
// 33.12.1, run_loop
class run_loop;
// 33.13.1, coroutine utilityas_awaitable
struct as_awaitable_t { unspecified };
inline constexpr as_awaitable_t as_awaitable{};
// 33.13.2, coroutine utilitywith_awaitable_senders
template<class-type Promise>
struct with_awaitable_senders;
// 33.13.3, coroutine utilityaffine_on
struct affine_on_t { unspecified };
inline constexpr affine_on_t affine_on{};
// 33.13.4, inline scheduler
class inline_scheduler;
// 33.13.5, task scheduler
class task_scheduler;
template<class E>
struct with_error {
using type = remove_cvref_t<E>;
type error;
};
template<class E>
with_error(E) -> with_error<E>;
template<scheduler Sch>
struct change_coroutine_scheduler {
using type = remove_cvref_t<Sch>;
type scheduler;
};
template<scheduler Sch>
change_coroutine_scheduler(Sch) -> change_coroutine_scheduler<Sch>;
§ 33.4 © ISO/IEC
2271

===== PAGE 2283 =====

Dxxxx
// 33.13.6, class templatetask
template<class T, class Environment>
class task;
// 33.14.1, scope concepts
template<class Token>
concept scope_association = see below ;
template<class Token>
concept scope_token = see below ;
// 33.14.2.2, simple counting scope
class simple_counting_scope;
// 33.14.2.3, counting scope
class counting_scope;
// 33.15, parallel scheduler
class parallel_scheduler;
parallel_scheduler get_parallel_scheduler();
// 33.16, namespacesystem_context_replaceability
namespace system_context_replaceability {
struct receiver_proxy;
struct bulk_item_receiver_proxy;
struct parallel_scheduler_backend;
shared_ptr<parallel_scheduler_backend> query_parallel_scheduler_backend();
}
}
1 The exposition-only typevariant-or-empty <Ts...> is defined as follows:
—(1.1) If sizeof...(Ts) is greater than zero,variant-or-empty <Ts...> denotes variant<Us...> where
Us... is the packdecay_t<Ts>... with duplicate types removed.
—(1.2) Otherwise, variant-or-empty <Ts...> denotes the exposition-only class type:
namespace std::execution {
struct empty-variant { // exposition only
empty-variant() = delete;
};
}
2 For type Sndr and pack of typesEnv, let CS be completion_signatures_of_t<Sndr, Env...>. Then
single-sender-value-type <Sndr, Env...> is ill-formed ifCS is ill-formed; otherwise, it is an alias for:
—(2.1) gather-signatures <set_value_t, CS, decay_t, type_identity_t> if that type is well-formed,
—(2.2) Otherwise, void if gather-signatures <set_value_t, CS, tuple, variant> is variant<tuple<>>
or variant<>,
—(2.3) Otherwise, gather-signatures <set_value_t, CS, decayed-tuple , type_identity_t> if that
type is well-formed,
—(2.4) Otherwise, single-sender-value-type <Sndr, Env...> is ill-formed.
3 The exposition-only conceptsingle-sender is defined as follows:
namespace std::execution {
template<class Sndr, class... Env>
concept single-sender = sender_in<Sndr, Env...> &&
requires {
typename single-sender-value-type <Sndr, Env...>;
};
}
4 A type satisfies and models the exposition-only conceptvalid-completion-signatures if it is a specializa-
tion of thecompletion_signatures class template.
§ 33.4 © ISO/IEC
2272

===== PAGE 2284 =====

Dxxxx
33.5 Queries [exec.queries]
33.5.1 forwarding_query [exec.fwd.env]
1 forwarding_query asks a query object whether it should be forwarded through queryable adaptors.
2 The nameforwarding_query denotes a query object. For some query objectq of typeQ, forwarding_-
query(q) is expression-equivalent to:
—(2.1) MANDATE-NOTHROW (q.query(forwarding_query)) if that expression is well-formed.
Mandates: The expression above has typebool and is a core constant expression ifq is a core constant
expression.
—(2.2) Otherwise, true if derived_from<Q, forwarding_query_t> is true.
—(2.3) Otherwise, false.
33.5.2 get_allocator [exec.get.allocator]
1 get_allocator asks a queryable object for its associated allocator.
2 The name get_allocator denotes a query object. For a subexpression env, get_allocator(env) is
expression-equivalent toMANDATE-NOTHROW (AS-CONST (env).query(get_allocator)).
Mandates: If the expression above is well-formed, its type satisfiessimple-allocator (16.4.4.6.1).
3 forwarding_query(get_allocator) is a core constant expression and has valuetrue.
33.5.3 get_stop_token [exec.get.stop.token]
1 get_stop_token asks a queryable object for an associated stop token.
2 The name get_stop_token denotes a query object. For a subexpressionenv, get_stop_token(env) is
expression-equivalent to:
—(2.1) MANDATE-NOTHROW (AS-CONST (env).query(get_stop_token)) if that expression is well-formed.
Mandates: The type of the expression above satisfiesstoppable_token.
—(2.2) Otherwise, never_stop_token{}.
3 forwarding_query(get_stop_token) is a core constant expression and has valuetrue.
33.5.4 execution::get_env [exec.get.env]
1 execution::get_env is a customization point object. For a subexpressiono, execution::get_env(o) is
expression-equivalent to:
—(1.1) MANDATE-NOTHROW (AS-CONST (o).get_env()) if that expression is well-formed.
Mandates: The type of the expression above satisfiesqueryable (33.2).
—(1.2) Otherwise, env<>{}.
2 The value ofget_env(o) shall be valid whileo is valid.
3 [Note 1: When passed a sender object,get_env returns the sender’s associated attributes. When passed a receiver,
get_env returns the receiver’s associated execution environment.—end note]
33.5.5 execution::get_domain [exec.get.domain]
1 get_domain asks a queryable object for its associated execution domain tag.
2 The nameget_domain denotes a query object. For a subexpressionenv, get_domain(env) is expression-
equivalent toMANDATE-NOTHROW (AS-CONST (env).query(get_domain)).
3 forwarding_query(execution::get_domain) is a core constant expression and has valuetrue.
33.5.6 execution::get_scheduler [exec.get.scheduler]
1 get_scheduler asks a queryable object for its associated scheduler.
2 The name get_scheduler denotes a query object. For a subexpression env, get_scheduler(env) is
expression-equivalent toMANDATE-NOTHROW (AS-CONST (env).query(get_scheduler)).
Mandates: If the expression above is well-formed, its type satisfiesscheduler.
3 forwarding_query(execution::get_scheduler) is a core constant expression and has valuetrue.
§ 33.5.6 © ISO/IEC
2273

===== PAGE 2285 =====

Dxxxx
33.5.7 execution::get_delegation_scheduler [exec.get.delegation.scheduler]
1 get_delegation_scheduler asks a queryable object for a scheduler that can be used to delegate work to for
the purpose of forward progress delegation (6.10.2.3).
2 The nameget_delegation_scheduler denotes a query object. For a subexpressionenv, get_delegation_-
scheduler(env) is expression-equivalent toMANDATE-NOTHROW (AS-CONST (env).query(get_delegation_-
scheduler)).
Mandates: If the expression above is well-formed, its type satisfiesscheduler.
3 forwarding_query(execution::get_delegation_scheduler) is a core constant expression and has value
true.
33.5.8 execution::get_forward_progress_guarantee [exec.get.fwd.progress]
namespace std::execution {
enum class forward_progress_guarantee {
concurrent,
parallel,
weakly_parallel
};
}
1 get_forward_progress_guarantee asks a scheduler about the forward progress guarantee of execution
agents created by that scheduler’s associated execution resource (6.10.2.3).
2 The name get_forward_progress_guarantee denotes a query object. For a subexpressionsch, let Sch
be decltype((sch)). If Sch does not satisfyscheduler, get_forward_progress_guarantee is ill-formed.
Otherwise, get_forward_progress_guarantee(sch) is expression-equivalent to:
—(2.1) MANDATE-NOTHROW (AS-CONST (sch).query(get_forward_progress_guarantee)), if that expression
is well-formed.
Mandates: The type of the expression above isforward_progress_guarantee.
—(2.2) Otherwise, forward_progress_guarantee::weakly_parallel.
3 If get_forward_progress_guarantee(sch) for some scheduler sch returns forward_progress_guaran-
tee::concurrent, all execution agents created by that scheduler’s associated execution resource shall provide
the concurrent forward progress guarantee. If it returnsforward_progress_guarantee::parallel, all such
execution agents shall provide at least the parallel forward progress guarantee.
33.5.9 execution::get_completion_scheduler [exec.get.compl.sched]
1 get_completion_scheduler<completion-tag> obtains the completion scheduler associated with a comple-
tion tag from a sender’s attributes.
2 Thename get_completion_schedulerdenotesaqueryobjecttemplate. Forasubexpression q, theexpression
get_completion_scheduler<completion-tag >(q) is ill-formed if completion-tag is not one of set_-
value_t, set_error_t, orset_stopped_t. Otherwise, get_completion_scheduler<completion-tag >(q)
is expression-equivalent to
MANDATE-NOTHROW (AS-CONST (q).query(get_completion_scheduler<completion-tag >))
Mandates: If the expression above is well-formed, its type satisfiesscheduler.
3 Let completion-fn be a completion function (33.3); letcompletion-tag be the associated completion
tag of completion-fn ; let args be a pack of subexpressions; and letsndr be a subexpression such that
sender<decltype((sndr))>is trueand get_completion_scheduler<completion-tag >(get_env(sndr))
is well-formed and denotes a schedulersch. If an asynchronous operation created by connectingsndr with a
receiver rcvr causes the evaluation ofcompletion-fn (rcvr, args...), the behavior is undefined unless
the evaluation happens on an execution agent that belongs tosch’s associated execution resource.
4 The expressionforwarding_query(get_completion_scheduler<completion-tag >) is a core constant ex-
pression and has valuetrue.
33.5.10 execution::get_await_completion_adaptor [exec.get.await.adapt]
1 get_await_completion_adaptor asks a queryable object for its associated awaitable completion adaptor.
2 The nameget_await_completion_adaptor denotes a query object. For a subexpressionenv,
§ 33.5.10 © ISO/IEC
2274

===== PAGE 2286 =====

Dxxxx
get_await_completion_adaptor(env)
is expression-equivalent to
MANDATE-NOTHROW(AS-CONST (env).query(get_await_completion_adaptor))
3 forwarding_query(execution::get_await_completion_adaptor) is a core constant expression and has
value true.
33.6 Schedulers [exec.sched]
1 The scheduler concept defines the requirements of a scheduler type (33.3).schedule is a customization
point object that accepts a scheduler. A valid invocation ofschedule is a schedule-expression.
namespace std::execution {
template<class Sch>
concept scheduler =
derived_from<typename remove_cvref_t<Sch>::scheduler_concept, scheduler_t> &&
queryable <Sch> &&
requires(Sch&& sch) {
{ schedule(std::forward<Sch>(sch)) } -> sender;
{ auto(get_completion_scheduler<set_value_t>(
get_env(schedule(std::forward<Sch>(sch))))) }
-> same_as<remove_cvref_t<Sch>>;
} &&
equality_comparable<remove_cvref_t<Sch>> &&
copyable<remove_cvref_t<Sch>>;
}
2 Let Sch be the type of a scheduler and letEnv be the type of an execution environment for whichsender_-
in<schedule_result_t<Sch>, Env> is satisfied. Then sender-in-of <schedule_result_t<Sch>, Env>
shall be modeled.
3 No operation required bycopyable<remove_cvref_t<Sch>> and equality_comparable<remove_cvref_-
t<Sch>> shall exit via an exception. None of these operations, nor a scheduler type’sschedule function,
shall introduce data races as a result of potentially concurrent (6.10.2.2) invocations of those operations from
different threads.
4 For any two valuessch1 and sch2 of some scheduler typeSch, sch1 == sch2 shall returntrue only if both
sch1 and sch2 share the same associated execution resource.
5 For a given scheduler expressionsch, the expression get_completion_scheduler<set_value_t>(get_-
env(schedule(sch))) shall compare equal tosch.
6 For a given scheduler expressionsch, if the expressionget_domain(sch) is well-formed, then the expression
get_domain(get_env(schedule(sch))) is also well-formed and has the same type.
7 A scheduler type’s destructor shall not block pending completion of any receivers connected to the sender
objects returned fromschedule.
33.7 Receivers [exec.recv]
33.7.1 Receiver concepts [exec.recv.concepts]
1 A receiver represents the continuation of an asynchronous operation. Thereceiver concept defines the
requirements for a receiver type (33.3). Thereceiver_of concept defines the requirements for a receiver type
that is usable as the first argument of a set of completion operations corresponding to a set of completion
signatures. The get_env customization point object is used to access a receiver’s associated environment.
namespace std::execution {
template<class Rcvr>
concept receiver =
derived_from<typename remove_cvref_t<Rcvr>::receiver_concept, receiver_t> &&
requires(const remove_cvref_t<Rcvr>& rcvr) {
{ get_env(rcvr) } -> queryable ;
} &&
move_constructible<remove_cvref_t<Rcvr>> && // rvalues are movable, and
constructible_from<remove_cvref_t<Rcvr>, Rcvr> && // lvalues are copyable, and
is_nothrow_move_constructible_v<remove_cvref_t<Rcvr>>; // no-throw-movable
§ 33.7.1 © ISO/IEC
2275

===== PAGE 2287 =====

Dxxxx
template<class Signature, class Rcvr>
concept valid-completion-for = // exposition only
requires (Signature* sig) {
[]<class Tag, class... Args>(Tag(*)(Args...))
requires callable <Tag, remove_cvref_t<Rcvr>, Args...>
{}(sig);
};
template<class Rcvr, class Completions>
concept has-completions = // exposition only
requires (Completions* completions) {
[]<valid-completion-for <Rcvr>...Sigs>(completion_signatures<Sigs...>*)
{}(completions);
};
template<class Rcvr, class Completions>
concept receiver_of =
receiver<Rcvr> && has-completions <Rcvr, Completions>;
}
2 Class types that are markedfinal do not model thereceiver concept.
3 Let rcvr be a receiver and letop_state be an operation state associated with an asynchronous operation
created by connectingrcvr with a sender. Let token be a stop token equal toget_stop_token(get_-
env(rcvr)). token shall remain valid for the duration of the asynchronous operation’s lifetime (33.3).
[Note 1: This means that, unless it knows about further guarantees provided by the type ofrcvr, the implementation
of op_state cannot usetoken after it executes a completion operation. This also implies that any stop callbacks
registered on token must be destroyed before the invocation of the completion operation.—end note]
33.7.2 execution::set_value [exec.set.value]
1 set_valueisavaluecompletionfunction(33.3). Itsassociatedcompletiontagis set_value_t. Theexpression
set_value(rcvr, vs...) for a subexpressionrcvr and pack of subexpressionsvs is ill-formed ifrcvr is an
lvalue or an rvalue of const type. Otherwise, it is expression-equivalent toMANDATE-NOTHROW (rcvr.set_-
value(vs...)).
33.7.3 execution::set_error [exec.set.error]
1 set_error is an error completion function (33.3). Its associated completion tag isset_error_t. The
expression set_error(rcvr, err) for some subexpressionsrcvr and err is ill-formed ifrcvr is an lvalue or
an rvalue of const type. Otherwise, it is expression-equivalent toMANDATE-NOTHROW (rcvr.set_error(err)).
33.7.4 execution::set_stopped [exec.set.stopped]
1 set_stopped is a stopped completion function (33.3). Its associated completion tag isset_stopped_t. The
expression set_stopped(rcvr) for a subexpressionrcvr is ill-formed ifrcvr is an lvalue or an rvalue of
const type. Otherwise, it is expression-equivalent toMANDATE-NOTHROW (rcvr.set_stopped()).
33.8 Operation states [exec.opstate]
33.8.1 General [exec.opstate.general]
1 The operation_state concept defines the requirements of an operation state type (33.3).
namespace std::execution {
template<class O>
concept operation_state =
derived_from<typename O::operation_state_concept, operation_state_t> &&
requires (O& o) {
start(o);
};
}
2 If an operation_state object is destroyed during the lifetime of its asynchronous operation (33.3), the
behavior is undefined.
§ 33.8.1 © ISO/IEC
2276

===== PAGE 2288 =====

Dxxxx
[Note 1: The operation_state concept does not impose requirements on any operations other than destruction
and start, including copy and move operations. Invoking any such operation on an object whose type models
operation_state can lead to undefined behavior.—end note]
3 The program is ill-formed if it performs a copy or move construction or assignment operation on an operation
state object created by connecting a library-provided sender.
33.8.2 execution::start [exec.opstate.start]
1 The namestartdenotes a customization point object that starts (33.3) the asynchronous operation associated
with the operation state object. For a subexpressionop, the expressionstart(op) is ill-formed ifop is an
rvalue. Otherwise, it is expression-equivalent toMANDATE-NOTHROW (op.start()).
2 If op.start() does not start (33.3) the asynchronous operation associated with the operation stateop, the
behavior of callingstart(op) is undefined.
33.9 Senders [exec.snd]
33.9.1 General [exec.snd.general]
1 Subclauses 33.9.11 and 33.9.12 define customizable algorithms that return senders. Each algorithm has a
default implementation. Letsndr be the result of an invocation of such an algorithm or an object equal to
the result (18.2), and letSndr be decltype((sndr)). Let rcvr be a receiver of typeRcvr with associated
environment env of typeEnv such thatsender_to<Sndr, Rcvr> is true. For the default implementation of
the algorithm that producedsndr, connectingsndr to rcvr and starting the resulting operation state (33.3)
necessarily results in the potential evaluation (6.3) of a set of completion operations whose first argument
is a subexpression equal torcvr. Let Sigs be a pack of completion signatures corresponding to this set
of completion operations, and letCS be the type of the expressionget_completion_signatures<Sndr,
Env>(). Then CS is a specialization of the class templatecompletion_signatures (33.10), the set of whose
template arguments isSigs. If none of the types inSigs are dependent on the typeEnv, then the expression
get_completion_signatures<Sndr>() is well-formed and its type isCS. If a user-provided implementation
of the algorithm that producedsndr is selected instead of the default:
—(1.1) Any completion signature that is in the set of types denoted bycompletion_signatures_of_t<Sndr,
Env> and that is not part ofSigs shall correspond to error or stopped completion operations, unless
otherwise specified.
—(1.2) If none of the types inSigs are dependent on the typeEnv, thencompletion_signatures_of_t<Sndr>
and completion_signatures_of_t<Sndr, Env> shall denote the same type.
2 Various function templates in subclause 33.9 can throw an exception of typeunspecified-exception . Each
such exception object is of an unspecified type such that ahandler of typeexception matches (14.4) the
exception object but ahandler of typedependent_sender_error does not.
[Note 1: There is no requirement that two such exception objects have the same type.—end note]
33.9.2 Exposition-only entities [exec.snd.expos]
1 Subclause 33.9 makes use of the following exposition-only entities.
2 For a queryable objectenv, FWD-ENV (env) is an expression whose type satisfiesqueryable such that for a
query objectq and a pack of subexpressionsas, the expressionFWD-ENV (env).query(q, as...) is ill-formed
if forwarding_query(q) is false; otherwise, it is expression-equivalent toenv.query(q, as...). The type
FWD-ENV-T (Env) is decltype(FWD-ENV (declval<Env>())).
3 For a query objectq and a subexpressionv, MAKE-ENV (q, v) is an expressionenv whose type satisfies
queryable such that the result ofenv.query(q) has a value equal tov (18.2). Unless otherwise stated, the
object to whichenv.query(q) refers remains valid whileenv remains valid.
4 For two queryable objectsenv1 and env2, a query objectq, and a pack of subexpressionsas, JOIN-ENV (env1,
env2) is an expressionenv3 whose type satisfiesqueryable such thatenv3.query(q, as...) is expression-
equivalent to:
—(4.1) env1.query(q, as...) if that expression is well-formed,
—(4.2) otherwise, env2.query(q, as...) if that expression is well-formed,
—(4.3) otherwise, env3.query(q, as...) is ill-formed.
§ 33.9.2 © ISO/IEC
2277

===== PAGE 2289 =====

Dxxxx
5 The results of FWD-ENV , MAKE-ENV , and JOIN-ENV can be context-dependent; i.e., they can evaluate to
expressions with different types and value categories in different contexts for the same arguments.
6 For a schedulersch, SCHED-ATTRS (sch) is an expression o1 whose type satisfies queryable such that
o1.query(get_completion_scheduler<Tag>) is an expression with the same type and value assch where
Tag is one ofset_value_t or set_stopped_t, and such thato1.query(get_domain) is expression-equivalent
to sch.query(get_domain). SCHED-ENV (sch) is an expressiono2 whose type satisfiesqueryable such that
o2.query(get_scheduler) is a prvalue with the same type and value assch, and such thato2.query(get_-
domain) is expression-equivalent tosch.query(get_domain).
7 For two subexpressionsrcvr and expr, SET-VALUE (rcvr, expr) is expression-equivalent to(expr, set_-
value(std::move(rcvr))) if the type ofexpr is void; otherwise, set_value(std::move(rcvr), expr).
TRY-EVAL (rcvr, expr) is equivalent to:
try {
expr;
} catch(...) {
set_error(std::move(rcvr), current_exception());
}
if expr is potentially-throwing; otherwise,expr. TRY-SET-VALUE (rcvr, expr) is
TRY-EVAL (rcvr, SET-VALUE (rcvr, expr))
except thatrcvr is evaluated only once.
template<class Default = default_domain, class Sndr>
constexpr auto completion-domain (const Sndr& sndr) noexcept;
8 COMPL-DOMAIN (T) is the type of the expressionget_domain(get_completion_scheduler<T>(get_-
env(sndr))).
9 Effects: If all of the types COMPL-DOMAIN (set_value_t), COMPL-DOMAIN (set_error_t), and
COMPL-DOMAIN (set_stopped_t) are ill-formed, completion-domain<Default>(sndr) is a default-
constructed prvalue of typeDefault. Otherwise, if they all share a common type (21.3.9.7) (ignoring
those types that are ill-formed), thencompletion-domain <Default>(sndr) is a default-constructed
prvalue of that type. Otherwise,completion-domain <Default>(sndr) is ill-formed.
template<class Tag, class Env, class Default>
constexpr decltype(auto) query-with-default (
Tag, const Env& env, Default&& value) noexcept(see below );
10 Let e be the expression Tag()(env) if that expression is well-formed; otherwise, it is static_-
cast<Default>(std::forward<Default>(value)).
11 Returns: e.
12 Remarks: The expression in the noexcept clause isnoexcept(e).
template<class Sndr>
constexpr auto get-domain-early (const Sndr& sndr) noexcept;
13 Effects: Equivalent to:
return Domain();
where Domain is the decayed type of the first of the following expressions that is well-formed:
—(13.1) get_domain(get_env(sndr))
—(13.2) completion-domain (sndr)
—(13.3) default_domain()
template<class Sndr, class Env>
constexpr auto get-domain-late (const Sndr& sndr, const Env& env) noexcept;
14 Effects: Equivalent to:
—(14.1) If sender-for <Sndr, continues_on_t> is true, then
return Domain();
where Domain is the type of the following expression:
§ 33.9.2 © ISO/IEC
2278

===== PAGE 2290 =====

Dxxxx
[] {
auto [_, sch, _] = sndr;
return query-with-default (get_domain, sch, default_domain());
}();
[Note 1: The continues_on algorithm works in tandem withschedule_from (33.9.12.7) to give scheduler
authors a way to customize both how to transition onto (continues_on) and off of (schedule_from) a
given execution context. Thus,continues_on ignores the domain of the predecessor and uses the domain
of the destination scheduler to select a customization, a property that is unique tocontinues_on. That is
why it is given special treatment here.—end note]
—(14.2) Otherwise,
return Domain();
where Domain is the first of the following expressions that is well-formed and whose type is not
void:
—(14.2.1) get_domain(get_env(sndr))
—(14.2.2) completion-domain <void>(sndr)
—(14.2.3) get_domain(env)
—(14.2.4) get_domain(get_scheduler(env))
—(14.2.5) default_domain()
15 template<callable Fun>
requires is_nothrow_move_constructible_v<Fun>
struct emplace-from {
Fun fun ; // exposition only
using type = call-result-t <Fun>;
constexpr operator type() && noexcept(nothrow-callable <Fun>) {
return std::move(fun)();
}
constexpr type operator()() && noexcept(nothrow-callable <Fun>) {
return std::move(fun)();
}
};
[Note 2: emplace-from is used to emplace non-movable types intotuple, optional, variant, and similar types.
—end note]
16 struct on-stop-request {
inplace_stop_source& stop-src ; // exposition only
void operator()() noexcept { stop-src .request_stop(); }
};
17 template<class T0, class T1, ... , class Tn>
struct product-type { // exposition only
T0 t0; // exposition only
T1 t1; // exposition only
...
Tn tn; // exposition only
template<size_t I, class Self>
constexpr decltype(auto) get (this Self&& self) noexcept; // exposition only
template<class Self, class Fn>
constexpr decltype(auto) apply (this Self&& self, Fn&& fn) // exposition only
noexcept(see below );
};
18 [Note 3: product-type is presented here in pseudo-code form for the sake of exposition. It can be approximated in
standard C++ with a tuple-like implementation that takes care to keep the type an aggregate that can be used as the
initializer of a structured binding declaration.—end note]
§ 33.9.2 © ISO/IEC
2279

===== PAGE 2291 =====

Dxxxx
[Note 4: An expression of typeproduct-type is usable as the initializer of a structured binding declaration (9.7).
—end note]
template<size_t I, class Self>
constexpr decltype(auto) get (this Self&& self) noexcept;
19 Effects: Equivalent to:
auto& [...ts] = self;
return std::forward_like<Self>(ts...[I]);
template<class Self, class Fn>
constexpr decltype(auto) apply (this Self&& self, Fn&& fn) noexcept(see below );
20 Constraints: The expression in thereturn statement below is well-formed.
21 Effects: Equivalent to:
auto& [...ts] = self;
return std::forward<Fn>(fn)(std::forward_like<Self>(ts)...);
22 Remarks: The expression in thenoexceptclause istrueif thereturnstatement above is not potentially
throwing; otherwise,false.
23 Let valid-specialization be the following concept:
namespace std::execution {
template<template<class...> class T, class... Args>
concept valid-specialization = // exposition only
requires { typename T<Args...>; };
}
template<class Tag, class Data = see below , class... Child>
constexpr auto make-sender (Tag tag, Data&& data, Child&&... child);
24 Mandates: The following expressions aretrue:
—(24.1) semiregular<Tag>
—(24.2) movable-value <Data>
—(24.3) (sender<Child> && ...)
—(24.4) dependent_sender<Sndr> || sender_in<Sndr>, where Sndr is basic-sender <Tag, decay_-
t<Data>, decay_t<Child>...> as defined below.
Recommended practice: If evaluation ofsender_in<Sndr> results in an uncaught exception from
the evaluation of get_completion_signatures<Sndr>(), the implementation should include
information about that exception in the resulting diagnostic.
25 Returns: A prvalue of typebasic-sender <Tag, decay_t<Data>, decay_t<Child>...>that has been
direct-list-initialized with the forwarded arguments, wherebasic-sender is the following exposition-
only class template except as noted below.
26 Remarks: The default template argument for theData template parameter denotes an unspecified
empty trivially copyable class type that modelssemiregular.
namespace std::execution {
template<class Tag>
concept completion-tag = // exposition only
same_as<Tag, set_value_t> || same_as<Tag, set_error_t> || same_as<Tag, set_stopped_t>;
struct default-impls { // exposition only
static constexpr auto get-attrs = see below; // exposition only
static constexpr auto get-env = see below; // exposition only
static constexpr auto get-state = see below; // exposition only
static constexpr auto start = see below; // exposition only
static constexpr auto complete = see below; // exposition only
template<class Sndr, class... Env>
static consteval void check-types(); // exposition only
};
§ 33.9.2 © ISO/IEC
2280

===== PAGE 2292 =====

Dxxxx
template<class Tag>
struct impls-for : default-impls {}; // exposition only
template<class Sndr, class Rcvr> // exposition only
using state-type = decay_t<call-result-t <
decltype(impls-for <tag_of_t<Sndr>>::get-state ), Sndr, Rcvr&>>;
template<class Index, class Sndr, class Rcvr> // exposition only
using env-type = call-result-t <
decltype(impls-for <tag_of_t<Sndr>>::get-env ), Index,
state-type <Sndr, Rcvr>&, const Rcvr&>;
template<class Sndr>
using data-type = decltype(declval<Sndr>().template get<1>()); // exposition only
template<class Sndr, size_t I = 0>
using child-type = decltype(declval<Sndr>().template get<I+2>()); // exposition only
template<class Sndr>
using indices-for = remove_reference_t<Sndr>::indices-for; // exposition only
template<class Sndr, class Rcvr>
struct basic-state { // exposition only
basic-state (Sndr&& sndr, Rcvr&& rcvr) noexcept(see below )
: rcvr (std::move(rcvr))
, state (impls-for <tag_of_t<Sndr>>::get-state (std::forward<Sndr>(sndr), rcvr )) { }
Rcvr rcvr; // exposition only
state-type<Sndr, Rcvr> state; // exposition only
};
template<class Sndr, class Rcvr, class Index>
requires valid-specialization <env-type , Index, Sndr, Rcvr>
struct basic-receiver { // exposition only
using receiver_concept = receiver_t;
using tag-t = tag_of_t<Sndr>; // exposition only
using state-t = state-type<Sndr, Rcvr>; // exposition only
static constexpr const auto& complete = impls-for<tag-t>::complete; // exposition only
template<class... Args>
requires callable <decltype(complete ), Index, state-t &, Rcvr&, set_value_t, Args...>
void set_value(Args&&... args) && noexcept {
complete (Index(), op->state , op->rcvr , set_value_t(), std::forward<Args>(args)...);
}
template<class Error>
requires callable <decltype(complete ), Index, state-t &, Rcvr&, set_error_t, Error>
void set_error(Error&& err) && noexcept {
complete (Index(), op->state , op->rcvr , set_error_t(), std::forward<Error>(err));
}
void set_stopped() && noexcept
requires callable <decltype(complete ), Index, state-t &, Rcvr&, set_stopped_t> {
complete (Index(), op->state , op->rcvr , set_stopped_t());
}
auto get_env() const noexcept -> env-type <Index, Sndr, Rcvr> {
return impls-for <tag-t >::get-env (Index(), op->state , op->rcvr );
}
basic-state<Sndr, Rcvr>* op; // exposition only
};
§ 33.9.2 © ISO/IEC
2281

===== PAGE 2293 =====

Dxxxx
constexpr auto connect-all = see below; // exposition only
template<class Sndr, class Rcvr>
using connect-all-result = call-result-t< // exposition only
decltype(connect-all ), basic-state <Sndr, Rcvr>*, Sndr, indices-for <Sndr>>;
template<class Sndr, class Rcvr>
requires valid-specialization <state-type , Sndr, Rcvr> &&
valid-specialization <connect-all-result , Sndr, Rcvr>
struct basic-operation : basic-state<Sndr, Rcvr> { // exposition only
using operation_state_concept = operation_state_t;
using tag-t = tag_of_t<Sndr>; // exposition only
connect-all-result<Sndr, Rcvr> inner-ops; // exposition only
basic-operation(Sndr&& sndr, Rcvr&& rcvr) noexcept(see below) // exposition only
: basic-state <Sndr, Rcvr>(std::forward<Sndr>(sndr), std::move(rcvr)),
inner-ops (connect-all (this, std::forward<Sndr>(sndr), indices-for <Sndr>()))
{}
void start() & noexcept {
auto& [...ops] = inner-ops ;
impls-for <tag-t >::start (this->state , this->rcvr , ops...);
}
};
template<class Tag, class Data, class... Child>
struct basic-sender : product-type<Tag, Data, Child...> { // exposition only
using sender_concept = sender_t;
using indices-for = index_sequence_for<Child...>; // exposition only
decltype(auto) get_env() const noexcept {
auto& [_, data, ...child] = *this;
return impls-for <Tag>::get-attrs (data, child...);
}
template<decays-to <basic-sender > Self, receiver Rcvr>
auto connect(this Self&& self, Rcvr rcvr) noexcept(see below )
-> basic-operation <Self, Rcvr> {
return {std::forward<Self>(self), std::move(rcvr)};
}
template<decays-to <basic-sender > Self, class... Env>
static constexpr auto get_completion_signatures();
};
}
27 It is unspecified whether a specialization ofbasic-sender is an aggregate.
28 An expression of typebasic-sender is usable as the initializer of a structured binding declaration (9.7).
29 The expression in thenoexcept clause of the constructor ofbasic-state is
is_nothrow_move_constructible_v<Rcvr> &&
nothrow-callable <decltype(impls-for <tag_of_t<Sndr>>::get-state ), Sndr, Rcvr&> &&
(same_as<state-type <Sndr, Rcvr>, get-state-result > ||
is_nothrow_constructible_v<state-type <Sndr, Rcvr>, get-state-result >)
where get-state-result is
call-result-t <decltype(impls-for <tag_of_t<Sndr>>::get-state ), Sndr, Rcvr&>.
30 The objectconnect-all is initialized with a callable object equivalent to the following lambda:
[]<class Sndr, class Rcvr, size_t... Is>(
basic-state <Sndr, Rcvr>* op, Sndr&& sndr, index_sequence<Is...>) noexcept(see below )
-> decltype(auto) {
auto& [_, data, ...child] = sndr;
§ 33.9.2 © ISO/IEC
2282

===== PAGE 2294 =====

Dxxxx
return product-type {connect(
std::forward_like<Sndr>(child),
basic-receiver <Sndr, Rcvr, integral_constant<size_t, Is>>{op})...};
}
31 Constraints: The expression in thereturn statement is well-formed.
32 Remarks: The expression in thenoexcept clause istrue if thereturn statement is not potentially
throwing; otherwise,false.
33 The expression in thenoexcept clause of the constructor ofbasic-operation is:
is_nothrow_constructible_v<basic-state <Self, Rcvr>, Self, Rcvr> &&
noexcept(connect-all (this, std::forward<Sndr>(sndr), indices-for <Sndr>()))
34 The expression in thenoexcept clause of theconnect member function ofbasic-sender is:
is_nothrow_constructible_v<basic-operation <Self, Rcvr>, Self, Rcvr>
35 The memberdefault-impls ::get-attrs is initialized with a callable object equivalent to the following
lambda:
[](const auto&, const auto&... child) noexcept -> decltype(auto) {
if constexpr (sizeof...(child) == 1)
return (FWD-ENV (get_env(child)), ...);
else
return env<>();
}
36 The member default-impls ::get-env is initialized with a callable object equivalent to the following
lambda:
[](auto, auto&, const auto& rcvr) noexcept -> decltype(auto) {
return FWD-ENV (get_env(rcvr));
}
37 The memberdefault-impls ::get-state is initialized with a callable object equivalent to the following
lambda:
[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept -> decltype(auto) {
auto& [_, data, ...child] = sndr;
return allocator-aware-forward (std::forward_like<Sndr>(data), rcvr);
}
38 The memberdefault-impls ::start is initialized with a callable object equivalent to the following lambda:
[](auto&, auto&, auto&... ops) noexcept -> void {
(execution::start(ops), ...);
}
39 The member default-impls ::complete is initialized with a callable object equivalent to the following
lambda:
[]<class Index, class Rcvr, class Tag, class... Args>(
Index, auto& state, Rcvr& rcvr, Tag, Args&&... args) noexcept
-> void requires callable <Tag, Rcvr, Args...> {
static_assert(Index::value == 0);
Tag()(std::move(rcvr), std::forward<Args>(args)...);
}
template<class Sndr, class... Env>
static consteval void default-impls ::check-types ();
40 Let Is be the pack of integral template arguments of theinteger_sequence specialization denoted by
indices-for <Sndr>.
41 Effects: Equivalent to:
((void)get_completion_signatures<child-type <Sndr, Is>, FWD-ENV-T (Env)...>(), ...);
42 [Note 5: For any typesT and S, and packE, lete be the expressionimpls-for <T>::check-types <S, E...>().
Then exactly one of the following istrue:
—(42.1) e is ill-formed, or
—(42.2) the evaluation ofe exits with an exception, or
§ 33.9.2 © ISO/IEC
2283

===== PAGE 2295 =====

Dxxxx
—(42.3) e is a core constant expression.
When e is a core constant expression, the packS, E... uniquely determines a set of completion signatures.
—end note]
template<class Tag, class Data, class... Child>
template<decays-to <basic-sender > Sndr, class... Env>
constexpr auto basic-sender <Tag, Data, Child...>::get_completion_signatures();
43 Let Rcvr be the type of a receiver whose environment has typeE, whereE is the first type in the list
Env..., env<>. Let CHECK-TYPES () be the expressionimpls-for <Tag>::template check-types <
Sndr, E>(), and letCS be a type determined as follows:
—(43.1) If CHECK-TYPES () is a core constant expression, letop be an lvalue subexpression whose type
is connect_result_t<Sndr, Rcvr>. Then CS is the specialization ofcompletion_signatures
the set of whose template arguments correspond to the set of completion operations that are
potentially evaluated (6.3) as a result of evaluatingop.start().
—(43.2) Otherwise, CS is completion_signatures<>.
44 Constraints: CHECK-TYPES () is a well-formed expression.
45 Effects: Equivalent to:
CHECK-TYPES ();
return CS();
46 template<class... Fns>
struct overload-set : Fns... {
using Fns::operator()...;
};
47 struct not-a-sender {
using sender_concept = sender_t;
template<class Sndr>
static consteval auto get_completion_signatures() -> completion_signatures<> {
throw unspecified-exception ();
}
};
48 constexpr void decay-copyable-result-datums (auto cs) {
cs.for-each ([]<class Tag, class... Ts>(Tag(*)(Ts...)) {
if constexpr (!(is_constructible_v<decay_t<Ts>, Ts> &&...))
throw unspecified-exception ();
});
}
template<class T, class Context>
decltype(auto) allocator-aware-forward (T&& obj, Context&& context); // exposition only
49 allocator-aware-forward is an exposition-only function template used to either create a new object of
type remove_cvref_t<T>from objor forwardobjdepending on whether an allocator is available. If the
environment associated withcontext provides an allocator (i.e., the expressionget_allocator(get_-
env(context)) is valid), letalloc be the result of this expression and letP be remove_cvref_t<T>.
50 Returns:
—(50.1) If alloc is not defined, returnsstd::forward<T>(obj),
—(50.2) otherwise if P is a specialization ofproduct-type , returns an object of typeP whose elements
are initialized using
make_obj_using_allocator<decltype(e)>(std::forward_like<T>(e), alloc )
where e is the corresponding element ofobj,
—(50.3) otherwise, returnsmake_obj_using_allocator<P>(std::forward<T>(obj), alloc ).
33.9.3 Sender concepts [exec.snd.concepts]
1 The sender concept defines the requirements for a sender type (33.3). Thesender_in concept defines the
requirements for a sender type that can create asynchronous operations given an associated environment type.
§ 33.9.3 © ISO/IEC
2284

===== PAGE 2296 =====

Dxxxx
The sender_to concept defines the requirements for a sender type that can connect with a specific receiver
type. The get_env customization point object is used to access a sender’s associated attributes. The connect
customization point object is used to connect (33.3) a sender and a receiver to produce an operation state.
namespace std::execution {
template<auto>
concept is-constant = true; // exposition only
template<class Sndr>
concept is-sender = // exposition only
derived_from<typename Sndr::sender_concept, sender_t>;
template<class Sndr>
concept enable-sender = // exposition only
is-sender <Sndr> ||
is-awaitable <Sndr, env-promise <env<>>>; // 33.9.4
template<class Sndr>
inline constexpr bool enable_sender = enable-sender <Sndr>;
template<class Sndr>
consteval bool is-dependent-sender-helper() try { // exposition only
get_completion_signatures<Sndr>();
return false;
} catch (dependent_sender_error&) {
return true;
}
template<class Sndr>
concept sender =
enable_sender<remove_cvref_t<Sndr>> &&
requires (const remove_cvref_t<Sndr>& sndr) {
{ get_env(sndr) } -> queryable ;
} &&
move_constructible<remove_cvref_t<Sndr>> &&
constructible_from<remove_cvref_t<Sndr>, Sndr>;
template<class Sndr, class... Env>
concept sender_in =
sender<Sndr> &&
(sizeof...(Env) <= 1) &&
(queryable <Env> &&...) &&
is-constant <get_completion_signatures<Sndr, Env...>()>;
template<class Sndr>
concept dependent_sender =
sender<Sndr> && bool_constant<is-dependent-sender-helper <Sndr>()>::value;
template<class Sndr, class Rcvr>
concept sender_to =
sender_in<Sndr, env_of_t<Rcvr>> &&
receiver_of<Rcvr, completion_signatures_of_t<Sndr, env_of_t<Rcvr>>> &&
requires (Sndr&& sndr, Rcvr&& rcvr) {
connect(std::forward<Sndr>(sndr), std::forward<Rcvr>(rcvr));
};
}
2 For a typeSndr, if sender<Sndr> is true and dependent_sender<Sndr> is false, then Sndr is a non-
dependent sender (33.3).
3 Given a subexpressionsndr, letSndr be decltype((sndr)) and letrcvr be a receiver with an associated
environment whose type isEnv. A completion operation is a permissible completion for Sndr and Env
if its completion signature appears in the argument list of the specialization ofcompletion_signatures
denoted by completion_signatures_of_t<Sndr, Env>. Sndr and Env model sender_in<Sndr, Env> if
§ 33.9.3 © ISO/IEC
2285

===== PAGE 2297 =====

Dxxxx
all the completion operations that are potentially evaluated by connectingsndr to rcvr and starting the
resulting operation state are permissible completions forSndr and Env.
4 Remarks: Pursuant to 16.4.5.2.1, users may specializeenable_sender to true for cv-unqualified program-
defined types that modelsender, andfalse for types that do not. Such specializations shall be usable in
constant expressions (7.7) and have typeconst bool.
5 The exposition-only conceptssender-of and sender-in-of define the requirements for a sender type that
completes with a given unique set of value result types.
namespace std::execution {
template<class... As>
using value-signature = set_value_t(As...); // exposition only
template<class Sndr, class SetValue, class... Env>
concept sender-in-of-impl = // exposition only
sender_in<Sndr, Env...> &&
MATCHING-SIG (SetValue, // see 33.1
gather-signatures <set_value_t, // see 33.10
completion_signatures_of_t<Sndr, Env...>,
value-signature ,
type_identity_t>);
template<class Sndr, class Env, class... Values>
concept sender-in-of = // exposition only
sender-in-of-impl <Sndr, set_value_t(Values...), Env>;
template<class Sndr, class... Values>
concept sender-of = // exposition only
sender-in-of-impl <Sndr, set_value_t(Values...)>;
}
6 Let sndr be an expression such thatdecltype((sndr)) is Sndr. The typetag_of_t<Sndr> is as follows:
—(6.1) If the declaration
auto&& [tag, data, ...children] = sndr;
would be well-formed,tag_of_t<Sndr> is an alias fordecltype(auto(tag)).
—(6.2) Otherwise, tag_of_t<Sndr> is ill-formed.
7 Let sender-for be an exposition-only concept defined as follows:
namespace std::execution {
template<class Sndr, class Tag>
concept sender-for =
sender<Sndr> &&
same_as<tag_of_t<Sndr>, Tag>;
}
8 For a typeT, SET-VALUE-SIG (T) denotes the typeset_value_t() if T is cv void; otherwise, it denotes the
type set_value_t(T).
9 Library-provided sender types
—(9.1) always expose an overload of a memberconnect that accepts an rvalue sender and
—(9.2) only expose an overload of a memberconnect that accepts an lvalue sender if they modelcopy_-
constructible.
33.9.4 Awaitable helpers [exec.awaitable]
1 The sender concepts recognize awaitables as senders. For Clause 33, anawaitable is an expression that would
be well-formed as the operand of aco_await expression within a given context.
2 For a subexpressionc, letGET-AWAITER (c, p) be expression-equivalent to the series of transformations and
conversions applied toc as the operand of anawait-expressionin a coroutine, resulting in lvaluee as described
by 7.6.2.4, wherep is an lvalue referring to the coroutine’s promise, which has typePromise.
§ 33.9.4 © ISO/IEC
2286

===== PAGE 2298 =====

Dxxxx
[Note 1: This includes the invocation of the promise type’sawait_transform member if any, the invocation of the
operator co_await picked by overload resolution if any, and any necessary implicit conversions and materializations.
—end note]
Let GET-AWAITER (c) be expression-equivalent to GET-AWAITER (c, q) where q is an lvalue of an un-
specified empty class typenone-such that lacks anawait_transform member, and wherecoroutine_-
handle<none-such > behaves ascoroutine_handle<void>.
3 Let is-awaitable be the following exposition-only concept:
namespace std {
template<class T>
concept await-suspend-result = see below ; // exposition only
template<class A, class... Promise>
concept is-awaiter = // exposition only
requires (A& a, coroutine_handle<Promise...> h) {
a.await_ready() ? 1 : 0;
{ a.await_suspend(h) } -> await-suspend-result ;
a.await_resume();
};
template<class C, class... Promise>
concept is-awaitable = // exposition only
requires (C (*fc)() noexcept, Promise&... p) {
{ GET-AWAITER (fc(), p...) } -> is-awaiter <Promise...>;
};
}
await-suspend-result <T> is true if and only if one of the following istrue:
—(3.1) T is void, or
—(3.2) T is bool, or
—(3.3) T is a specialization ofcoroutine_handle.
4 For a subexpressionc such thatdecltype((c)) is typeC, and an lvaluep of typePromise, await-result-
type <C, Promise> denotes the type decltype(GET-AWAITER (c, p).await_resume()) and await-re-
sult-type <C> denotes the typedecltype(GET-AWAITER (c).await_resume()).
5 Let with-await-transform be the exposition-only class template:
namespace std::execution {
template<class T, class Promise>
concept has-as-awaitable = // exposition only
requires (T&& t, Promise& p) {
{ std::forward<T>(t).as_awaitable(p) } -> is-awaitable <Promise&>;
};
template<class Derived>
struct with-await-transform { // exposition only
template<class T>
T&& await_transform(T&& value) noexcept {
return std::forward<T>(value);
}
template<has-as-awaitable <Derived> T>
auto await_transform(T&& value)
noexcept(noexcept(std::forward<T>(value).as_awaitable(declval<Derived&>())))
-> decltype(std::forward<T>(value).as_awaitable(declval<Derived&>())) {
return std::forward<T>(value).as_awaitable(static_cast<Derived&>(*this));
}
};
}
6 Let env-promise be the exposition-only class template:
§ 33.9.4 © ISO/IEC
2287

===== PAGE 2299 =====

Dxxxx
namespace std::execution {
template<class Env>
struct env-promise : with-await-transform <env-promise <Env>> { // exposition only
unspecified get_return_object() noexcept;
unspecified initial_suspend() noexcept;
unspecified final_suspend() noexcept;
void unhandled_exception() noexcept;
void return_void() noexcept;
coroutine_handle<> unhandled_stopped() noexcept;
const Env& get_env() const noexcept;
};
}
[Note 2: Specializations ofenv-promise are used only for the purpose of type computation; its members need not be
defined. —end note]
33.9.5 execution::default_domain [exec.domain.default]
1 namespace std::execution {
struct default_domain {
template<sender Sndr, queryable ... Env>
requires (sizeof...(Env) <= 1)
static constexpr sender decltype(auto) transform_sender(Sndr&& sndr, const Env&... env)
noexcept(see below );
template<sender Sndr, queryable Env>
static constexpr queryable decltype(auto) transform_env(Sndr&& sndr, Env&& env) noexcept;
template<class Tag, sender Sndr, class... Args>
static constexpr decltype(auto) apply_sender(Tag, Sndr&& sndr, Args&&... args)
noexcept(see below );
};
}
template<sender Sndr, queryable ... Env>
requires (sizeof...(Env) <= 1)
constexpr sender decltype(auto) transform_sender(Sndr&& sndr, const Env&... env)
noexcept(see below );
2 Let e be the expression
tag_of_t<Sndr>().transform_sender(std::forward<Sndr>(sndr), env...)
if that expression is well-formed; otherwise,std::forward<Sndr>(sndr).
3 Returns: e.
4 Remarks: The exception specification is equivalent tonoexcept(e).
template<sender Sndr, queryable Env>
constexpr queryable decltype(auto) transform_env(Sndr&& sndr, Env&& env) noexcept;
5 Let e be the expression
tag_of_t<Sndr>().transform_env(std::forward<Sndr>(sndr), std::forward<Env>(env))
if that expression is well-formed; otherwise,FWD-ENV (std::forward<Env>(env)).
6 Mandates: noexcept(e) is true.
7 Returns: e.
template<class Tag, sender Sndr, class... Args>
constexpr decltype(auto) apply_sender(Tag, Sndr&& sndr, Args&&... args)
noexcept(see below );
8 Let e be the expression
Tag().apply_sender(std::forward<Sndr>(sndr), std::forward<Args>(args)...)
9 Constraints: e is a well-formed expression.
§ 33.9.5 © ISO/IEC
2288

===== PAGE 2300 =====

Dxxxx
10 Returns: e.
11 Remarks: The exception specification is equivalent tonoexcept(e).
33.9.6 execution::transform_sender [exec.snd.transform]
namespace std::execution {
template<class Domain, sender Sndr, queryable ... Env>
requires (sizeof...(Env) <= 1)
constexpr sender decltype(auto) transform_sender(Domain dom, Sndr&& sndr, const Env&... env)
noexcept(see below );
}
1 Let transformed-sndr be the expression
dom.transform_sender(std::forward<Sndr>(sndr), env...)
if that expression is well-formed; otherwise,
default_domain().transform_sender(std::forward<Sndr>(sndr), env...)
Let final-sndr be the expressiontransformed-sndr if transformed-sndr and sndr have the same
typeignoringcv-qualifiers; otherwise, itistheexpression transform_sender(dom, transformed-sndr ,
env...).
2 Returns: final-sndr .
3 Remarks: The exception specification is equivalent tonoexcept(final-sndr ).
33.9.7 execution::transform_env [exec.snd.transform.env]
namespace std::execution {
template<class Domain, sender Sndr, queryable Env>
constexpr queryable decltype(auto) transform_env(Domain dom, Sndr&& sndr, Env&& env) noexcept;
}
1 Let e be the expression
dom.transform_env(std::forward<Sndr>(sndr), std::forward<Env>(env))
if that expression is well-formed; otherwise,
default_domain().transform_env(std::forward<Sndr>(sndr), std::forward<Env>(env))
2 Mandates: noexcept(e) is true.
3 Returns: e.
33.9.8 execution::apply_sender [exec.snd.apply]
namespace std::execution {
template<class Domain, class Tag, sender Sndr, class... Args>
constexpr decltype(auto) apply_sender(Domain dom, Tag, Sndr&& sndr, Args&&... args)
noexcept(see below );
}
1 Let e be the expression
dom.apply_sender(Tag(), std::forward<Sndr>(sndr), std::forward<Args>(args)...)
if that expression is well-formed; otherwise,
default_domain().apply_sender(Tag(), std::forward<Sndr>(sndr), std::forward<Args>(args)...)
2 Constraints: The expressione is well-formed.
3 Returns: e.
4 Remarks: The exception specification is equivalent tonoexcept(e).
33.9.9 execution::get_completion_signatures [exec.getcomplsigs]
template<class Sndr, class... Env>
consteval auto get_completion_signatures() -> valid-completion-signatures auto;
1 Let except be an rvalue subexpression of an unspecified class typeExcept such thatmove_construc-
tible<Except> && derived_from<Except, exception> is true. Let CHECKED-COMPLSIGS (e) be e
§ 33.9.9 © ISO/IEC
2289

===== PAGE 2301 =====

Dxxxx
if e is a core constant expression whose type satisfiesvalid-completion-signatures ; otherwise, it is
the following expression:
(e, throw except, completion_signatures())
Letget-complsigs <Sndr, Env...>()beexpression-equivalentto remove_reference_t<Sndr>::tem-
plate get_completion_signatures<Sndr, Env...>(). LetNewSndrbe Sndrif sizeof...(Env) ==
0 is true; otherwise,decltype(s) where s is the following expression:
transform_sender(
get-domain-late (declval<Sndr>(), declval<Env>()...),
declval<Sndr>(),
declval<Env>()...)
2 Constraints: sizeof...(Env) <= 1 is true.
3 Effects: Equivalent to:return e; where e is expression-equivalent to the following:
—(3.1) CHECKED-COMPLSIGS (get-complsigs <NewSndr, Env...>()) if get-complsigs <NewSndr, Env
...>() is a well-formed expression.
—(3.2) Otherwise, CHECKED-COMPLSIGS (get-complsigs <NewSndr>()) if get-complsigs <NewSndr>()
is a well-formed expression.
—(3.3) Otherwise,
completion_signatures<
SET-VALUE-SIG (await-result-type <NewSndr, env-promise <Env>...>), // 33.9.3
set_error_t(exception_ptr),
set_stopped_t()>
if is-awaitable <NewSndr, env-promise <Env>...> is true.
—(3.4) Otherwise, (throw dependent-sender-error (), completion_signatures()) if sizeof...(
Env) == 0 is true, wheredependent-sender-error is dependent_sender_error or an unspec-
ified type derived publicly and unambiguously fromdependent_sender_error.
—(3.5) Otherwise, (throw except, completion_signatures()).
4 Given a typeEnv, ifcompletion_signatures_of_t<Sndr>and completion_signatures_of_t<Sndr, Env>
are both well-formed, they shall denote the same type.
5 Let rcvr be an rvalue whose typeRcvr models receiver, and letSndr be the type of a sender such that
sender_in<Sndr, env_of_t<Rcvr>> is true. Let Sigs... be the template arguments of thecompletion_-
signatures specialization named bycompletion_signatures_of_t<Sndr, env_of_t<Rcvr>>. Let CSO be
a completion function. If senderSndr or its operation state cause the expressionCSO(rcvr, args...) to be
potentially evaluated (6.3) then there shall be a signatureSig in Sigs... such that
MATCHING-SIG (decayed-typeof <CSO>(decltype(args)...), Sig)
is true (33.1).
33.9.10 execution::connect [exec.connect]
1 connect connects (33.3) a sender with a receiver.
2 The nameconnect denotes a customization point object. For subexpressionssndr and rcvr, letSndr be
decltype((sndr)) and Rcvr be decltype((rcvr)), letnew_sndr be the expression
transform_sender(decltype(get-domain-late (sndr, get_env(rcvr))){}, sndr, get_env(rcvr))
and letDS and DR be decay_t<decltype((new_sndr))> and decay_t<Rcvr>, respectively.
3 Let connect-awaitable-promise be the following exposition-only class:
namespace std::execution {
struct connect-awaitable-promise : with-await-transform <connect-awaitable-promise > {
connect-awaitable-promise (DS&, DR& rcvr) noexcept : rcvr (rcvr) {}
suspend_always initial_suspend() noexcept { return {}; }
[[noreturn]] suspend_always final_suspend() noexcept { terminate(); }
[[noreturn]] void unhandled_exception() noexcept { terminate(); }
[[noreturn]] void return_void() noexcept { terminate(); }
§ 33.9.10 © ISO/IEC
2290

===== PAGE 2302 =====

Dxxxx
coroutine_handle<> unhandled_stopped() noexcept {
set_stopped(std::move(rcvr ));
return noop_coroutine();
}
operation-state-task get_return_object() noexcept {
return operation-state-task {
coroutine_handle<connect-awaitable-promise >::from_promise(*this)};
}
env_of_t<DR> get_env() const noexcept {
return execution::get_env(rcvr );
}
private:
DR& rcvr ; // exposition only
};
}
4 Let operation-state-task be the following exposition-only class:
namespace std::execution {
struct operation-state-task { // exposition only
using operation_state_concept = operation_state_t;
using promise_type = connect-awaitable-promise ;
explicit operation-state-task (coroutine_handle<> h) noexcept : coro(h) {}
operation-state-task (operation-state-task &&) = delete;
~operation-state-task () { coro .destroy(); }
void start() & noexcept {
coro .resume();
}
private:
coroutine_handle<> coro ; // exposition only
};
}
5 Let V name the typeawait-result-type <DS, connect-awaitable-promise >, letSigs name the type
completion_signatures<
SET-VALUE-SIG (V), // see 33.9.3
set_error_t(exception_ptr),
set_stopped_t()>
and letconnect-awaitable be an exposition-only coroutine defined as follows:
namespace std::execution {
template<class Fun, class... Ts>
auto suspend-complete (Fun fun, Ts&&... as) noexcept { // exposition only
auto fn = [&, fun]() noexcept { fun(std::forward<Ts>(as)...); };
struct awaiter {
decltype(fn) fn ; // exposition only
static constexpr bool await_ready() noexcept { return false; }
void await_suspend(coroutine_handle<>) noexcept { fn (); }
[[noreturn]] void await_resume() noexcept { unreachable(); }
};
return awaiter{fn};
}
operation-state-task connect-awaitable (DS sndr, DR rcvr) requires receiver_of<DR, Sigs> {
exception_ptr ep;
§ 33.9.10 © ISO/IEC
2291

===== PAGE 2303 =====

Dxxxx
try {
if constexpr (same_as<V, void>) {
co_await std::move(sndr);
co_await suspend-complete (set_value, std::move(rcvr));
} else {
co_await suspend-complete (set_value, std::move(rcvr), co_await std::move(sndr));
}
} catch(...) {
ep = current_exception();
}
co_await suspend-complete (set_error, std::move(rcvr), std::move(ep));
}
}
6 The expressionconnect(sndr, rcvr) is expression-equivalent to:
—(6.1) new_sndr.connect(rcvr) if that expression is well-formed.
Mandates: The type of the expression above satisfiesoperation_state.
—(6.2) Otherwise, connect-awaitable (new_sndr, rcvr).
Except thatrcvr is evaluated only once. The program is ill-formed, no diagnostic required, if there exists an
rvalue expressionrcvr2 such that:
—(6.3) decltype(rcvr2) models receiver,
—(6.4) noexcept(rcvr2) is true,
—(6.5) is_same_v<decltype(get_env(rcvr2)), decltype(get_env(rcvr))> is true,
—(6.6) noexcept(execution::connect(sndr, rcvr)) is true, and
—(6.7) noexcept(execution::connect(sndr, rcvr2)) is well-formed and evaluates tofalse.
[Note 1: This allows determination of whetherconnect throws with only the context of the environment, such as
within get_completion_signatures. —end note]
Mandates: The following aretrue:
—(6.8) sender_in<Sndr, env_of_t<Rcvr>>
—(6.9) receiver_of<Rcvr, completion_signatures_of_t<Sndr, env_of_t<Rcvr>>>
33.9.11 Sender factories [exec.factories]
33.9.11.1 execution::schedule [exec.schedule]
1 schedule obtains a schedule sender (33.3) from a scheduler.
2 The name schedule denotes a customization point object. For a subexpression sch, the expression
schedule(sch) is expression-equivalent tosch.schedule().
3 Mandates: The type ofsch.schedule() satisfies sender.
4 If the expression
get_completion_scheduler<set_value_t>(get_env(sch.schedule())) == sch
is ill-formed or evaluates tofalse, the behavior of callingschedule(sch) is undefined.
33.9.11.2 execution::just, execution::just_error, execution::just_stopped [exec.just]
1 just, just_error, and just_stopped are sender factories whose asynchronous operations complete syn-
chronously in their start operation with a value completion operation, an error completion operation, or a
stopped completion operation, respectively.
2 The namesjust, just_error, andjust_stopped denote customization point objects. Letjust-cpo be
one of just, just_error, orjust_stopped. For a pack of subexpressionsts, letTs be the pack of types
decltype((ts)). The expressionjust-cpo (ts...) is ill-formed if
—(2.1) (movable-value <Ts> &&...) is false, or
—(2.2) just-cpo is just_error and sizeof...(ts) == 1 is false, or
—(2.3) just-cpo is just_stopped and sizeof...(ts) == 0 is false.
§ 33.9.11.2 © ISO/IEC
2292

===== PAGE 2304 =====

Dxxxx
Otherwise, it is expression-equivalent tomake-sender (just-cpo , product-type {ts...}).
For just, just_error, and just_stopped, let set-cpo be set_value, set_error, and set_stopped,
respectively. The exposition-only class templateimpls-for (33.9.2) is specialized forjust-cpo as follows:
namespace std::execution {
template<>
struct impls-for <decayed-typeof <just-cpo >> : default-impls {
static constexpr auto start =
[](auto& state, auto& rcvr) noexcept -> void {
auto& [...ts] = state;
set-cpo (std::move(rcvr), std::move(ts)...);
};
};
}
33.9.11.3 execution::read_env [exec.read.env]
1 read_env is a sender factory for a sender whose asynchronous operation completes synchronously in its start
operation with a value completion result equal to a value read from the receiver’s associated environment.
2 read_env is a customization point object. For some query objectq, the expressionread_env(q) is expression-
equivalent tomake-sender (read_env, q).
3 The exposition-only class templateimpls-for (33.9.2) is specialized forread_env as follows:
namespace std::execution {
template<>
struct impls-for <decayed-typeof <read_env>> : default-impls {
static constexpr auto start =
[](auto query, auto& rcvr) noexcept -> void {
TRY-SET-VALUE (rcvr, query(get_env(rcvr)));
};
};
template<class Sndr, class Env>
static consteval void check-types ();
}
template<class Sndr, class Env>
static consteval void check-types ();
4 Let Q be decay_t<data-type <Sndr>>.
5 Throws: An exception of typeunspecified-exception (33.9.1) if the expressionQ()(env)is ill-formed
or has typevoid, whereenv is an lvalue subexpression whose type isEnv.
33.9.12 Sender adaptors [exec.adapt]
33.9.12.1 General [exec.adapt.general]
1 Subclause 33.9.12 specifies a set of sender adaptors.
2 The bitwise inclusiveor operator is overloaded for the purpose of creating sender chains. The adaptors also
support function call syntax with equivalent semantics.
3 Unless otherwise specified:
—(3.1) A sender adaptor is prohibited from causing observable effects, apart from moving and copying its
arguments, before the returned sender is connected with a receiver usingconnect, andstart is called
on the resulting operation state.
—(3.2) A parent sender (33.3) with a single child sendersndr has an associated attribute object equal to
FWD-ENV (get_env(sndr)) (33.5.1).
—(3.3) A parent sender with more than one child sender has an associated attributes object equal toenv<>{}.
—(3.4) When a parent sender is connected to a receiverrcvr, any receiver used to connect a child sender has
an associated environment equal toFWD-ENV (get_env(rcvr)).
—(3.5) An adaptor whose child senders are all non-dependent (33.3) is itself non-dependent.
—(3.6) These requirements apply to any function that is selected by the implementation of the sender adaptor.
§ 33.9.12.1 © ISO/IEC
2293

===== PAGE 2305 =====

Dxxxx
—(3.7) Recommended practice: Implementations should use the completion signatures of the adaptors to
communicate type errors to users and to propagate any such type errors from child senders.
4 If a sender returned from a sender adaptor specified in 33.9.12 is specified to includeset_error_t(Err)
among its set of completion signatures wheredecay_t<Err> denotes the type exception_ptr, but the
implementation does not potentially evaluate an error completion operation with anexception_ptrargument,
the implementation is allowed to omit theexception_ptr error completion signature from the set.
33.9.12.2 Closure objects [exec.adapt.obj]
1 A pipeable sender adaptor closure objectis a function object that accepts one or moresender arguments
and returns asender. For a pipeable sender adaptor closure objectc and an expressionsndr such that
decltype((sndr)) models sender, the following expressions are equivalent and yield asender:
c(sndr)
sndr | c
Given an additional pipeable sender adaptor closure objectd, the expressionc | d produces another pipeable
sender adaptor closure objecte:
e is a perfect forwarding call wrapper (22.10.4) with the following properties:
—(1.1) Its target object is an objectd2 of typedecltype(auto(d)) direct-non-list-initialized withd.
—(1.2) It has one bound argument entity, an objectc2 of typedecltype(auto(c)) direct-non-list-initialized
with c.
—(1.3) Its call pattern isd2(c2(arg)), where arg is the argument used in a function call expression ofe.
The expressionc | d is well-formed if and only if the initializations of the state entities (22.10.3) ofe are all
well-formed.
2 An object t of type T is a pipeable sender adaptor closure object ifT models derived_from<sender_-
adaptor_closure<T>>, T has no other base classes of typesender_adaptor_closure<U> for any other type
U, andT does not satisfysender.
3 The template parameterD for sender_adaptor_closure can be an incomplete type. Before any expression
of typecv D appears as an operand to the| operator, D shall be complete and modelderived_from<sender_-
adaptor_closure<D>>. The behavior of an expression involving an object of typecv D as an operand to the
| operator is undefined if overload resolution selects a program-definedoperator| function.
4 A pipeable sender adaptor objectis a customization point object that accepts asender as its first argument
and returns asender. If a pipeable sender adaptor object accepts only one argument, then it is a pipeable
sender adaptor closure object.
5 If a pipeable sender adaptor object adaptor accepts more than one argument, then letsndr be an expres-
sion such that decltype((sndr)) models sender, let args... be arguments such that adaptor(sndr,
args...) is a well-formed expression as specified below, and let BoundArgs be a pack that denotes
decltype(auto(args)).... The expressionadaptor(args...) produces a pipeable sender adaptor closure
object f that is a perfect forwarding call wrapper with the following properties:
—(5.1) Its target object is a copy of adaptor.
—(5.2) Its bound argument entitiesbound_args consist of objects of typesBoundArgs... direct-non-list-
initialized withstd::forward<decltype((args))>(args)..., respectively.
—(5.3) Its call pattern isadaptor(rcvr, bound_args...), wherercvr is the argument used in a function
call expression off.
The expressionadaptor(args...) is well-formed if and only if the initializations of the bound argument
entities of the result, as specified above, are all well-formed.
33.9.12.3 execution::write_env [exec.write.env]
1 write_env is a sender adaptor that accepts a sender and a queryable object, and that returns a sender
that, when connected with a receiverrcvr, connects the adapted sender with a receiver whose execution
environment is the result of joining thequeryable object to the result ofget_env(rcvr).
2 write_env is a customization point object. For some subexpressionssndr and env, if decltype((sndr))
does not satisfysender or ifdecltype((env)) does not satisfyqueryable , the expressionwrite_env(sndr,
env) is ill-formed. Otherwise, it is expression-equivalent tomake-sender (write_env, env, sndr).
§ 33.9.12.3 © ISO/IEC
2294

===== PAGE 2306 =====

Dxxxx
3 Let write-env-t denote the type decltype(auto(write_env)). The exposition-only class template
impls-for (33.9.2) is specialized forwrite-env-t as follows:
template<>
struct impls-for <write-env-t > : default-impls {
static constexpr auto join-env (const auto& state, const auto& env) noexcept {
return see below ;
}
static constexpr auto get-env =
[](auto, const auto& state, const auto& rcvr) noexcept {
return join-env (state, FWD-ENV (get_env(rcvr)));
};
template<class Sndr, class... Env>
static consteval void check-types ();
};
4 Invocation ofimpls-for <write-env-t >::join-env returns an objecte such that
—(4.1) decltype(e) models queryable and
—(4.2) given a query objectq, the expressione.query(q) is expression-equivalent tostate.query(q) if that
expression is valid, otherwise,e.query(q) is expression-equivalent toenv.query(q).
5 For a typeSndr and a pack of typesEnv, let State be data-type <Sndr> and let JoinEnv be the pack
decltype(join-env (declval<State>(), FWD-ENV (declval<Env>()))). Then impls-for <write-env-
t >::check-types <Sndr, Env...>() is expression-equivalent to get_completion_signatures<child-
type <Sndr>, JoinEnv...>().
33.9.12.4 execution::unstoppable [exec.unstoppable]
1 unstoppable is a sender adaptor that connects its inner sender with a receiver that has the execution
environment of the outer receiver but with an object of typenever_stop_token as the result of theget_-
stop_token query.
2 For a subexpressionsndr, unstoppable(sndr) is expression-equivalent towrite_env(sndr, prop(get_-
stop_token, never_stop_token{})).
33.9.12.5 execution::starts_on [exec.starts.on]
1 starts_on adapts an input sender into a sender that will start on an execution agent belonging to a particular
scheduler’s associated execution resource.
2 The namestarts_on denotes a customization point object. For subexpressionssch and sndr, ifdecltype((
sch)) does not satisfyscheduler, ordecltype((sndr)) does not satisfysender, starts_on(sch, sndr)
is ill-formed.
3 Otherwise, the expressionstarts_on(sch, sndr) is expression-equivalent to:
transform_sender(
query-with-default (get_domain, sch, default_domain()),
make-sender (starts_on, sch, sndr))
except thatsch is evaluated only once.
4 Let out_sndr and env be subexpressions such thatOutSndr is decltype((out_sndr)). If sender-for <Out-
Sndr, starts_on_t> is false, then the expressions starts_on.transform_env(out_sndr, env) and
starts_on.transform_sender(out_sndr, env) are ill-formed; otherwise
—(4.1) starts_on.transform_env(out_sndr, env) is equivalent to:
auto&& [_, sch, _] = out_sndr;
return JOIN-ENV (SCHED-ENV (sch), FWD-ENV (env));
—(4.2) starts_on.transform_sender(out_sndr, env) is equivalent to:
auto&& [_, sch, sndr] = out_sndr;
return let_value(
schedule(sch),
[sndr = std::forward_like<OutSndr>(sndr)]() mutable
noexcept(is_nothrow_move_constructible_v<decay_t<OutSndr>>) {
§ 33.9.12.5 © ISO/IEC
2295

===== PAGE 2307 =====

Dxxxx
return std::move(sndr);
});
5 Let out_sndr be a subexpression denoting a sender returned fromstarts_on(sch, sndr) or one equal
to such, and letOutSndr be the typedecltype((out_sndr)). Let out_rcvr be a subexpression denoting
a receiver that has an environment of typeEnv such thatsender_in<OutSndr, Env> is true. Let op be
an lvalue referring to the operation state that results from connectingout_sndr with out_rcvr. Calling
start(op) shall startsndr on an execution agent of the associated execution resource ofsch. If scheduling
onto sch fails, an error completion onout_rcvr shall be executed on an unspecified execution agent.
33.9.12.6 execution::continues_on [exec.continues.on]
1 continues_on adapts a sender into one that completes on the specified scheduler.
2 The namecontinues_on denotes a pipeable sender adaptor object. For subexpressionssch and sndr, if
decltype((sch)) does not satisfyscheduler, ordecltype((sndr)) does not satisfysender, continues_-
on(sndr, sch) is ill-formed.
3 Otherwise, the expressioncontinues_on(sndr, sch) is expression-equivalent to:
transform_sender(get-domain-early (sndr), make-sender (continues_on, sch, sndr))
except thatsndr is evaluated only once.
4 The exposition-only class templateimpls-for (33.9.2) is specialized forcontinues_on_t as follows:
namespace std::execution {
template<>
struct impls-for <continues_on_t> : default-impls {
static constexpr auto get-attrs =
[](const auto& data, const auto& child) noexcept -> decltype(auto) {
return JOIN-ENV (SCHED-ATTRS (data), FWD-ENV (get_env(child)));
};
};
}
5 Letsndrandenvbe subexpressions such thatSndrisdecltype((sndr)). Ifsender-for <Sndr, continues-
_on_t>is false, then the expressioncontinues_on.transform_sender(sndr, env)is ill-formed; otherwise,
it is equal to:
auto [_, data, child] = sndr;
return schedule_from(std::move(data), std::move(child));
[Note 1: This causes thecontinues_on(sndr, sch) sender to becomeschedule_from(sch, sndr) when it is con-
nected with a receiver whose execution domain does not customizecontinues_on. —end note]
6 Let out_sndr be a subexpression denoting a sender returned fromcontinues_on(sndr, sch) or one equal
to such, and letOutSndr be the typedecltype((out_sndr)). Let out_rcvr be a subexpression denoting
a receiver that has an environment of typeEnv such thatsender_in<OutSndr, Env> is true. Let op be
an lvalue referring to the operation state that results from connectingout_sndr with out_rcvr. Calling
start(op) shall startsndr on the current execution agent and execute completion operations onout_rcvr
on an execution agent of the execution resource associated withsch. If scheduling ontosch fails, an error
completion onout_rcvr shall be executed on an unspecified execution agent.
33.9.12.7 execution::schedule_from [exec.schedule.from]
1 schedule_from schedules work dependent on the completion of a sender onto a scheduler’s associated
execution resource.
[Note 1: schedule_from is not meant to be used in user code; it is used in the implementation ofcontinues_on.
—end note]
2 The nameschedule_from denotes a customization point object. For some subexpressionssch and sndr, let
Sch be decltype((sch)) and Sndr be decltype((sndr)). If Sch does not satisfyscheduler, orSndr does
not satisfysender, schedule_from(sch, sndr) is ill-formed.
3 Otherwise, the expressionschedule_from(sch, sndr) is expression-equivalent to:
transform_sender(
query-with-default (get_domain, sch, default_domain()),
make-sender (schedule_from, sch, sndr))
§ 33.9.12.7 © ISO/IEC
2296

===== PAGE 2308 =====

Dxxxx
except thatsch is evaluated only once.
4 The exposition-only class templateimpls-for (33.9.2) is specialized forschedule_from_t as follows:
namespace std::execution {
template<>
struct impls-for <schedule_from_t> : default-impls {
static constexpr auto get-attrs = see below ;
static constexpr auto get-state = see below ;
static constexpr auto complete = see below ;
template<class Sndr, class... Env>
static consteval void check-types ();
};
}
5 The memberimpls-for <schedule_from_t>::get-attrs is initialized with a callable object equivalent to
the following lambda:
[](const auto& data, const auto& child) noexcept -> decltype(auto) {
return JOIN-ENV (SCHED-ATTRS (data), FWD-ENV (get_env(child)));
}
6 The memberimpls-for <schedule_from_t>::get-state is initialized with a callable object equivalent to
the following lambda:
[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(see below )
requires sender_in<child-type <Sndr>, FWD-ENV-T (env_of_t<Rcvr>)> {
auto& [_, sch, child] = sndr;
using sched_t = decltype(auto(sch));
using variant_t = see below ;
using receiver_t = see below ;
using operation_t = connect_result_t<schedule_result_t<sched_t>, receiver_t>;
constexpr bool nothrow = noexcept(connect(schedule(sch), receiver_t{nullptr}));
struct state-type {
Rcvr& rcvr ; // exposition only
variant_t async-result ; // exposition only
operation_t op-state ; // exposition only
explicit state-type (sched_t sch, Rcvr& rcvr) noexcept(nothrow)
: rcvr (rcvr), op-state (connect(schedule(sch), receiver_t{this})) {}
};
return state-type {sch, rcvr};
}
template<class Sndr, class... Env>
static consteval void check-types ();
7 Effects: Equivalent to:
get_completion_signatures<schedule_result_t<data-type <Sndr>>, FWD-ENV-T (Env)...>();
auto cs = get_completion_signatures<child-type <Sndr>, FWD-ENV-T (Env)...>();
decay-copyable-result-datums (cs); // see 33.9.2
8 Objects of the local classstate-type can be used to initialize a structured binding.
9 Let Sigs be a pack of the arguments to thecompletion_signatures specialization named bycompletion_-
signatures_of_t<child-type <Sndr>, FWD-ENV-T (env_of_t<Rcvr>)>. Let as-tuple be an alias tem-
plate such thatas-tuple <Tag(Args...)>denotes the typedecayed-tuple <Tag, Args...>, and letis-no-
throw-decay-copy-sig be a variable template such thatauto(is-nothrow-decay-copy-sig <Tag(Args...
)>) is a constant expression of typebool and equal to(is_nothrow_constructible_v<decay_t<Args>,
Args> && ...). Let error-completion be a pack consisting of the typeset_error_t(exception_ptr) if
(is-nothrow-decay-copy-sig <Sigs> &&...) is false, and an empty pack otherwise. Thenvariant_t de-
notes the typevariant<monostate, as-tuple <Sigs>..., error-completion ...>, except with duplicate
types removed.
§ 33.9.12.7 © ISO/IEC
2297

===== PAGE 2309 =====

Dxxxx
10 receiver_t is an alias for the following exposition-only class:
namespace std::execution {
struct receiver-type {
using receiver_concept = receiver_t;
state-type * state ; // exposition only
void set_value() && noexcept {
visit(
[this]<class Tuple>(Tuple& result) noexcept -> void {
if constexpr (!same_as<monostate, Tuple>) {
auto& [tag, ...args] = result;
tag(std::move(state ->rcvr ), std::move(args)...);
}
},
state ->async-result );
}
template<class Error>
void set_error(Error&& err) && noexcept {
execution::set_error(std::move(state ->rcvr ), std::forward<Error>(err));
}
void set_stopped() && noexcept {
execution::set_stopped(std::move(state ->rcvr ));
}
decltype(auto) get_env() const noexcept {
return FWD-ENV (execution::get_env(state ->rcvr ));
}
};
}
11 The expression in thenoexcept clause of the lambda istrue if the construction of the returnedstate-type
object is not potentially throwing; otherwise,false.
12 The memberimpls-for <schedule_from_t>::complete is initialized with a callable object equivalent to
the following lambda:
[]<class Tag, class... Args>(auto, auto& state, auto& rcvr, Tag, Args&&... args) noexcept
-> void {
using result_t = decayed-tuple <Tag, Args...>;
constexpr bool nothrow = (is_nothrow_constructible_v<decay_t<Args>, Args> && ...);
try {
state.async-result .template emplace<result_t>(Tag(), std::forward<Args>(args)...);
} catch (...) {
if constexpr (!nothrow)
state.async-result .template emplace<tuple<set_error_t,
exception_ptr>>(set_error, current_exception());
}
start(state.op-state );
};
13 Let out_sndr be a subexpression denoting a sender returned fromschedule_from(sch, sndr) or one equal
to such, and letOutSndr be the typedecltype((out_sndr)). Let out_rcvr be a subexpression denoting
a receiver that has an environment of typeEnv such thatsender_in<OutSndr, Env> is true. Let op be
an lvalue referring to the operation state that results from connectingout_sndr with out_rcvr. Calling
start(op) shall startsndr on the current execution agent and execute completion operations onout_rcvr
on an execution agent of the execution resource associated withsch. If scheduling ontosch fails, an error
completion onout_rcvr shall be executed on an unspecified execution agent.
33.9.12.8 execution::on [exec.on]
1 The on sender adaptor has two forms:
§ 33.9.12.8 © ISO/IEC
2298

===== PAGE 2310 =====

Dxxxx
—(1.1) on(sch, sndr), which starts a sendersndr on an execution agent belonging to a schedulersch’s
associated execution resource and that, upon sndr’s completion, transfers execution back to the
execution resource on which theon sender was started.
—(1.2) on(sndr, sch, closure), which upon completion of a sendersndr, transfers execution to an execution
agent belonging to a schedulersch’s associated execution resource, then executes a sender adaptor
closure closure with the async results of the sender, and that then transfers execution back to the
execution resource on whichsndr completed.
2 The nameon denotes a pipeable sender adaptor object. For subexpressionssch and sndr, on(sch, sndr) is
ill-formed if any of the following istrue:
—(2.1) decltype((sch)) does not satisfyscheduler, or
—(2.2) decltype((sndr)) does not satisfysender and sndr is not a pipeable sender adaptor closure object
(33.9.12.2), or
—(2.3) decltype((sndr)) satisfies sender and sndr is also a pipeable sender adaptor closure object.
3 Otherwise, if decltype((sndr)) satisfies sender, the expressionon(sch, sndr) is expression-equivalent
to:
transform_sender(
query-with-default (get_domain, sch, default_domain()),
make-sender (on, sch, sndr))
except thatsch is evaluated only once.
4 For subexpressionssndr, sch, andclosure, if
—(4.1) decltype((sch)) does not satisfyscheduler, or
—(4.2) decltype((sndr)) does not satisfysender, or
—(4.3) closure is not a pipeable sender adaptor closure object (33.9.12.2),
the expressionon(sndr, sch, closure) is ill-formed; otherwise, it is expression-equivalent to:
transform_sender(
get-domain-early (sndr),
make-sender (on, product-type {sch, closure}, sndr))
except thatsndr is evaluated only once.
5 Let out_sndrand envbe subexpressions, letOutSndrbe decltype((out_sndr)), and letEnvbe decltype((
env)). If sender-for <OutSndr, on_t>is false, then the expressionson.transform_env(out_sndr, env)
and on.transform_sender(out_sndr, env) are ill-formed.
6 Otherwise: Let not-a-scheduler be an unspecified empty class type.
7 The expressionon.transform_env(out_sndr, env) has effects equivalent to:
auto&& [_, data, _] = out_sndr;
if constexpr (scheduler<decltype(data)>) {
return JOIN-ENV (SCHED-ENV (std::forward_like<OutSndr>(data)), FWD-ENV (std::forward<Env>(env)));
} else {
return std::forward<Env>(env);
}
8 The expressionon.transform_sender(out_sndr, env) has effects equivalent to:
auto&& [_, data, child] = out_sndr;
if constexpr (scheduler<decltype(data)>) {
auto orig_sch =
query-with-default (get_scheduler, env, not-a-scheduler ());
if constexpr (same_as<decltype(orig_sch), not-a-scheduler >) {
return not-a-sender {};
} else {
return continues_on(
starts_on(std::forward_like<OutSndr>(data), std::forward_like<OutSndr>(child)),
std::move(orig_sch));
}
} else {
§ 33.9.12.8 © ISO/IEC
2299

===== PAGE 2311 =====

Dxxxx
auto& [sch, closure] = data;
auto orig_sch = query-with-default (
get_completion_scheduler<set_value_t>,
get_env(child),
query-with-default (get_scheduler, env, not-a-scheduler ()));
if constexpr (same_as<decltype(orig_sch), not-a-scheduler >) {
return not-a-sender {};
} else {
return write_env(
continues_on(
std::forward_like<OutSndr>(closure)(
continues_on(
write_env(std::forward_like<OutSndr>(child), SCHED-ENV (orig_sch)),
sch)),
orig_sch),
SCHED-ENV (sch));
}
}
9 Let out_sndr be a subexpression denoting a sender returned fromon(sch, sndr) or one equal to such, and
let OutSndr be the typedecltype((out_sndr)). Let out_rcvr be a subexpression denoting a receiver that
has an environment of typeEnv such thatsender_in<OutSndr, Env> is true. Let op be an lvalue referring
to the operation state that results from connectingout_sndr with out_rcvr. Calling start(op) shall
—(9.1) remember the current scheduler,get_scheduler(get_env(rcvr));
—(9.2) start sndr on an execution agent belonging tosch’s associated execution resource;
—(9.3) upon sndr’s completion, transfer execution back to the execution resource associated with the scheduler
remembered in step 1; and
—(9.4) forward sndr’s async result toout_rcvr.
If any scheduling operation fails, an error completion onout_rcvr shall be executed on an unspecified
execution agent.
10 Let out_sndr be a subexpression denoting a sender returned fromon(sndr, sch, closure) or one equal
to such, and letOutSndr be the typedecltype((out_sndr)). Let out_rcvr be a subexpression denoting
a receiver that has an environment of typeEnv such thatsender_in<OutSndr, Env> is true. Let op be
an lvalue referring to the operation state that results from connectingout_sndr with out_rcvr. Calling
start(op) shall
—(10.1) remember the current scheduler, which is the first of the following expressions that is well-formed:
—(10.1.1) get_completion_scheduler<set_value_t>(get_env(sndr))
—(10.1.2) get_scheduler(get_env(rcvr));
—(10.2) start sndr on the current execution agent;
—(10.3) upon sndr’s completion, transfer execution to an agent owned bysch’s associated execution resource;
—(10.4) forward sndr’s async result as if by connecting and starting a senderclosure(S), whereS is a sender
that completes synchronously withsndr’s async result; and
—(10.5) upon completion of the operation started in the previous step, transfer execution back to the execution
resource associated with the scheduler remembered in step 1 and forward the operation’s async result
to out_rcvr.
If any scheduling operation fails, an error completion onout_rcvr shall be executed on an unspecified
execution agent.
33.9.12.9 execution::then, execution::upon_error, execution::upon_stopped [exec.then]
1 then attaches an invocable as a continuation for an input sender’s value completion operation.upon_error
and upon_stopped do the same for the error and stopped completion operations, respectively, sending the
result of the invocable as a value completion.
2 The names then, upon_error, and upon_stopped denote pipeable sender adaptor objects. Let the ex-
pression then-cpo be one of then, upon_error, or upon_stopped. For subexpressions sndr and f, if
§ 33.9.12.9 © ISO/IEC
2300

===== PAGE 2312 =====

Dxxxx
decltype((sndr)) does not satisfysender, ordecltype((f)) does not satisfymovable-value , then-cpo (
sndr, f) is ill-formed.
3 Otherwise, the expressionthen-cpo (sndr, f) is expression-equivalent to:
transform_sender(get-domain-early (sndr), make-sender (then-cpo , f, sndr))
except thatsndr is evaluated only once.
4 For then, upon_error, and upon_stopped, let set-cpo be set_value, set_error, and set_stopped,
respectively. The exposition-only class templateimpls-for (33.9.2) is specialized forthen-cpo as follows:
namespace std::execution {
template<>
struct impls-for <decayed-typeof <then-cpo >> : default-impls {
static constexpr auto complete =
[]<class Tag, class... Args>
(auto, auto& fn, auto& rcvr, Tag, Args&&... args) noexcept -> void {
if constexpr (same_as<Tag, decayed-typeof <set-cpo >>) {
TRY-SET-VALUE (rcvr,
invoke(std::move(fn), std::forward<Args>(args)...));
} else {
Tag()(std::move(rcvr), std::forward<Args>(args)...);
}
};
template<class Sndr, class... Env>
static consteval void check-types ();
};
}
template<class Sndr, class... Env>
static consteval void check-types ();
5 Effects: Equivalent to:
auto cs = get_completion_signatures<child-type <Sndr>, FWD-ENV-T (Env)...>();
auto fn = []<class... Ts>(decayed-typeof <set-cpo >(*)(Ts...)) {
if constexpr (!invocable<remove_cvref_t<data-type <Sndr>>, Ts...>)
throw unspecified-exception ();
};
cs.for-each (overload-set {fn, [](auto){}});
6 The expressionthen-cpo (sndr, f) has undefined behavior unless it returns a senderout_sndr that
—(6.1) invokesfor a copy of such with the value, error, or stopped result datums ofsndrfor then, upon_error,
and upon_stopped, respectively, using the result value off as out_sndr’s value completion, and
—(6.2) forwards all other completion operations unchanged.
33.9.12.10 execution::let_value, execution::let_error, execution::let_stopped [exec.let]
1 let_value, let_error, and let_stopped transform a sender’s value, error, and stopped completions,
respectively, into a new child asynchronous operation by passing the sender’s result datums to a user-specified
callable, which returns a new sender that is connected and started.
2 For let_value, let_error, andlet_stopped, letset-cpo be set_value, set_error, andset_stopped,
respectively. Let the expressionlet-cpo be one oflet_value, let_error, orlet_stopped. For a subex-
pression sndr, letlet-env (sndr) be expression-equivalent to the first well-formed expression below:
—(2.1) SCHED-ENV (get_completion_scheduler<decayed-typeof <set-cpo >>(get_env(sndr)))
—(2.2) MAKE-ENV (get_domain, get_domain(get_env(sndr)))
—(2.3) (void(sndr), env<>{})
3 The nameslet_value, let_error, andlet_stopped denote pipeable sender adaptor objects. For subex-
pressions sndr and f, letF be the decayed type off. If decltype((sndr)) does not satisfysender or if
decltype((f)) does not satisfymovable-value , the expressionlet-cpo (sndr, f) is ill-formed. IfF does
not satisfyinvocable, the expressionlet_stopped(sndr, f) is ill-formed.
4 Otherwise, the expressionlet-cpo (sndr, f) is expression-equivalent to:
§ 33.9.12.10 © ISO/IEC
2301

===== PAGE 2313 =====

Dxxxx
transform_sender(get-domain-early (sndr), make-sender (let-cpo , f, sndr))
except thatsndr is evaluated only once.
5 The exposition-only class templateimpls-for (33.9.2) is specialized forlet-cpo as follows:
namespace std::execution {
template<class State, class Rcvr, class... Args>
void let-bind (State& state, Rcvr& rcvr, Args&&... args); // exposition only
template<>
struct impls-for <decayed-typeof <let-cpo >> : default-impls {
static constexpr auto get-state = see below ;
static constexpr auto complete = see below ;
template<class Sndr, class... Env>
static consteval void check-types ();
};
}
6 Let receiver2 denote the following exposition-only class template:
namespace std::execution {
template<class Rcvr, class Env>
struct receiver2 {
using receiver_concept = receiver_t;
template<class... Args>
void set_value(Args&&... args) && noexcept {
execution::set_value(std::move(rcvr ), std::forward<Args>(args)...);
}
template<class Error>
void set_error(Error&& err) && noexcept {
execution::set_error(std::move(rcvr ), std::forward<Error>(err));
}
void set_stopped() && noexcept {
execution::set_stopped(std::move(rcvr ));
}
decltype(auto) get_env() const noexcept {
return see below ;
}
Rcvr& rcvr ; // exposition only
Env env ; // exposition only
};
}
Invocation of the functionreceiver2::get_env returns an objecte such that
—(6.1) decltype(e) models queryable and
—(6.2) given a query objectq, the expressione.query(q) is expression-equivalent toenv .query(q) if that
expression is valid; otherwise, if the type ofq satisfies forwarding-query , e.query(q) is expression-
equivalent toget_env(rcvr ).query(q); otherwise,e.query(q) is ill-formed.
template<class Sndr, class... Env>
static consteval void check-types ();
7 Effects: Equivalent to:
using LetFn = remove_cvref_t<data-type <Sndr>>;
auto cs = get_completion_signatures<child-type <Sndr>, FWD-ENV-T (Env)...>();
auto fn = []<class... Ts>(decayed-typeof <set-cpo >(*)(Ts...)) {
if constexpr (!is-valid-let-sender ) // see below
throw unspecified-exception ();
};
§ 33.9.12.10 © ISO/IEC
2302

===== PAGE 2314 =====

Dxxxx
cs.for-each (overload-set (fn, [](auto){}));
where is-valid-let-sender is true if and only if all of the following aretrue:
—(7.1) (constructible_from<decay_t<Ts>, Ts> &&...)
—(7.2) invocable<LetFn, decay_t<Ts>&...>
—(7.3) sender<invoke_result_t<LetFn, decay_t<Ts>&...>>
—(7.4) sizeof...(Env) == 0 || sender_in<invoke_result_t<LetFn, decay_t<Ts>&...>, env-t
...>
where env-t is the packdecltype(let-cpo .transform_env(declval<Sndr>(), declval<Env>())).
8 impls-for <decayed-typeof <let-cpo >>::get-state is initialized with a callable object equivalent to the
following:
[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) requires see below {
auto& [_, fn, child] = sndr;
using fn_t = decay_t<decltype(fn)>;
using env_t = decltype(let-env (child));
using args_variant_t = see below ;
using ops2_variant_t = see below ;
struct state-type {
fn_t fn ; // exposition only
env_t env ; // exposition only
args_variant_t args ; // exposition only
ops2_variant_t ops2; // exposition only
};
return state-type {allocator-aware-forward (std::forward_like<Sndr>(fn), rcvr),
let-env (child), {}, {}};
}
9 Let Sigs be a pack of the arguments to thecompletion_signatures specialization named bycompletion_-
signatures_of_t<child-type <Sndr>, FWD-ENV-T (env_of_t<Rcvr>)>. Let LetSigs be a pack of those
types in Sigs with a return type of decayed-typeof <set-cpo >. Let as-tuple be an alias template
such thatas-tuple <Tag(Args...)> denotes the typedecayed-tuple <Args...>. Then args_variant_t
denotes the typevariant<monostate, as-tuple <LetSigs>...> except with duplicate types removed.
10 Given a typeTag and a packArgs, letas-sndr2 be an alias template such thatas-sndr2<Tag(Args...)>
denotes the typecall-result-t <F, decay_t<Args>&...>. Then ops2_variant_t denotes the type
variant<monostate, connect_result_t<as-sndr2<LetSigs>, receiver2<Rcvr, env_t>>...>
except with duplicate types removed.
11 The requires-clause constraining the above lambda is satisfied if and only if the typesargs_variant_t and
ops2_variant_t are well-formed.
12 The exposition-only function templatelet-bind has effects equivalent to:
using args_t = decayed-tuple <Args...>;
auto mkop2 = [&] {
return connect(
apply(std::move(state.fn),
state.args.template emplace<args_t>(std::forward<Args>(args)...)),
receiver2{rcvr, std::move(state.env)});
};
start(state.ops2.template emplace<decltype(mkop2())>(emplace-from {mkop2}));
13 impls-for <decayed-typeof <let-cpo >>::complete is initialized with a callable object equivalent to the
following:
[]<class Tag, class... Args>
(auto, auto& state, auto& rcvr, Tag, Args&&... args) noexcept -> void {
if constexpr (same_as<Tag, decayed-typeof <set-cpo >>) {
TRY-EVAL (rcvr, let-bind (state, rcvr, std::forward<Args>(args)...));
} else {
Tag()(std::move(rcvr), std::forward<Args>(args)...);
}
§ 33.9.12.10 © ISO/IEC
2303

===== PAGE 2315 =====

Dxxxx
}
14 Let sndr and env be subexpressions, and letSndr be decltype((sndr)). If sender-for <Sndr, decayed-
typeof <let-cpo >> is false, then the expressionlet-cpo .transform_env(sndr, env) is ill-formed. Oth-
erwise, it is equal to:
auto& [_, _, child] = sndr;
return JOIN-ENV (let-env (child), FWD-ENV (env));
15 Let the subexpressionout_sndr denote the result of the invocationlet-cpo (sndr, f) or an object equal
to such, and let the subexpressionrcvr denote a receiver such that the expressionconnect(out_sndr,
rcvr) is well-formed. The expressionconnect(out_sndr, rcvr) has undefined behavior unless it creates
an asynchronous operation (33.3) that, when started:
—(15.1) invokesf when set-cpo is called withsndr’s result datums,
—(15.2) makes its completion dependent on the completion of a sender returned byf, and
—(15.3) propagates the other completion operations sent bysndr.
33.9.12.11 execution::bulk, execution::bulk_chunked, andexecution::bulk_unchunked
[exec.bulk]
1 bulk, bulk_chunked, andbulk_unchunked run a task repeatedly for every index in an index space.
2 The names bulk, bulk_chunked, and bulk_unchunked denote pipeable sender adaptor objects. Let
bulk-algo be eitherbulk, bulk_chunked, orbulk_unchunked. For subexpressionssndr, policy, shape,
and f, letPolicy be remove_cvref_t<decltype(policy)>, Shape be decltype(auto(shape)), andFunc
be decay_t<decltype((f))>. If
—(2.1) decltype((sndr)) does not satisfysender, or
—(2.2) is_execution_policy_v<Policy> is false, or
—(2.3) Shape does not satisfyintegral, or
—(2.4) Func does not modelcopy_constructible,
bulk-algo (sndr, policy, shape, f) is ill-formed.
3 Otherwise, the expressionbulk-algo (sndr, policy, shape, f) is expression-equivalent to:
transform_sender(get-domain-early (sndr), make-sender (
bulk-algo , product-type <see below , Shape, Func>{policy, shape, f}, sndr))
except thatsndr is evaluated only once. The first template argument ofproduct-type is Policy if Policy
models copy_constructible, andconst Policy& otherwise.
4 Let sndr and env be subexpressions such thatSndr is decltype((sndr)). If sender-for <Sndr, bulk_t>
is false, then the expressionbulk.transform_sender(sndr, env) is ill-formed; otherwise, it is equivalent
to:
auto [_, data, child] = sndr;
auto& [policy, shape, f] = data;
auto new_f = [func = std::move(f)](Shape begin, Shape end, auto&&... vs)
noexcept(noexcept(f(begin, vs...))) {
while (begin != end) func(begin++, vs...);
}
return bulk_chunked(std::move(child), policy, shape, std::move(new_f));
[Note 1: This causes thebulk(sndr, policy, shape, f) sender to be expressed in terms ofbulk_chunked(sndr,
policy, shape, f) when it is connected to a receiver whose execution domain does not customizebulk. —end note]
5 The exposition-only class templateimpls-for (33.9.2) is specialized forbulk_chunked_t as follows:
namespace std::execution {
template<>
struct impls-for <bulk_chunked_t> : default-impls {
static constexpr auto complete = see below ;
template<class Sndr, class... Env>
static consteval void check-types ();
};
}
§ 33.9.12.11 © ISO/IEC
2304

===== PAGE 2316 =====

Dxxxx
The memberimpls-for <bulk_chunked_t>::complete is initialized with a callable object equivalent to the
following lambda:
[]<class Index, class State, class Rcvr, class Tag, class... Args>
(Index, State& state, Rcvr& rcvr, Tag, Args&&... args) noexcept
-> void requires see below {
if constexpr (same_as<Tag, set_value_t>) {
auto& [policy, shape, f] = state;
constexpr bool nothrow = noexcept(f(auto(shape), auto(shape), args...));
TRY-EVAL (rcvr, [&]() noexcept(nothrow) {
f(static_cast<decltype(auto(shape))>(0), auto(shape), args...);
Tag()(std::move(rcvr), std::forward<Args>(args)...);
}());
} else {
Tag()(std::move(rcvr), std::forward<Args>(args)...);
}
}
The expression in therequires-clause of the lambda above istrue if and only ifTag denotes a type other
than set_value_t or if the expressionf(auto(shape), auto(shape), args...) is well-formed.
template<class Sndr, class... Env>
static consteval void check-types ();
6 Effects: Equivalent to:
auto cs = get_completion_signatures<child-type <Sndr>, FWD-ENV-T (Env)...>();
auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
using data_type = data-type <Sndr>;
if constexpr (!invocable<remove_cvref_t<child-type <data_type>&,
remove_cvref_t<data-type <data_type>>, Ts&...>)
throw unspecified-exception ();
};
cs.for-each (overload-set (fn, [](auto){}));
7 The exposition-only class templateimpls-for (33.9.2) is specialized forbulk_unchunked_t as follows:
namespace std::execution {
template<>
struct impls-for <bulk_unchunked_t> : default-impls {
static constexpr auto complete = see below ;
template<class Sndr, class... Env>
static consteval void check-types ();
};
}
The memberimpls-for <bulk_unchunked_t>::complete is initialized with a callable object equivalent to
the following lambda:
[]<class Index, class State, class Rcvr, class Tag, class... Args>
(Index, State& state, Rcvr& rcvr, Tag, Args&&... args) noexcept
-> void requires see below {
if constexpr (same_as<Tag, set_value_t>) {
auto& [policy, shape, f] = state;
constexpr bool nothrow = noexcept(f(auto(shape), args...));
TRY-EVAL (rcvr, [&]() noexcept(nothrow) {
for (decltype(auto(shape)) i = 0; i < shape; ++i) {
f(auto(i), args...);
}
Tag()(std::move(rcvr), std::forward<Args>(args)...);
}());
} else {
Tag()(std::move(rcvr), std::forward<Args>(args)...);
}
}
The expression in therequires-clause of the lambda above istrue if and only ifTag denotes a type other
than set_value_t or if the expressionf(auto(shape), args...) is well-formed.
§ 33.9.12.11 © ISO/IEC
2305

===== PAGE 2317 =====

Dxxxx
template<class Sndr, class... Env>
static consteval void check-types ();
8 Effects: Equivalent to:
auto cs = get_completion_signatures<child-type <Sndr>, FWD-ENV-T (Env)...>();
auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
using data_type = data-type <Sndr>;
if constexpr (!invocable<remove_cvref_t<child-type <data_type>&,
remove_cvref_t<data-type <data_type>>, Ts&...>)
throw unspecified-exception ();
};
cs.for-each (overload-set (fn, [](auto){}));
9 Let the subexpression out_sndr denote the result of the invocationbulk-algo (sndr, policy, shape,
f) or an object equal to such, and let the subexpressionrcvr denote a receiver such that the expres-
sion connect(out_sndr, rcvr) is well-formed. The expressionconnect(out_sndr, rcvr) has undefined
behavior unless it creates an asynchronous operation (33.3) that, when started:
—(9.1) If sndr has a successful completion, whereargs is a pack of lvalue subexpressions referring to the value
completion result datums ofsndr, or decayed copies of those values if they modelcopy_constructible,
then:
—(9.1.1) If out_sndr also completes successfully, then:
—(9.1.1.1) for bulk, invokesf(i, args...) for everyi of typeShape from 0 to shape;
—(9.1.1.2) for bulk_unchunked, invokesf(i, args...) for everyi of typeShape from 0 to shape;
Recommended practice: The underlying scheduler should execute each iteration on a distinct
execution agent.
—(9.1.1.3) for bulk_chunked, invokesf(b, e, args...) zero or more times with pairs ofb and e of
type Shape in range[0,shape], such thatb<e and for everyiof typeShape from 0 to shape,
there is exactly one invocation with a pairb and e, such thati is in the range[b,e).
—(9.1.2) If out_sndr completes with set_error(rcvr, eptr), then the asynchronous operation may
invoke a subset of the invocations off before the error completion handler is called, andeptr is
an exception_ptr containing either:
—(9.1.2.1) an exception thrown by an invocation off, or
—(9.1.2.2) a bad_alloc exception if the implementation fails to allocate required resources, or
—(9.1.2.3) an exception derived fromruntime_error.
—(9.1.3) If out_sndr completes withset_stopped(rcvr), then the asynchronous operation may invoke a
subset of the invocations off before the stopped completion handler.
—(9.2) If sndr does not complete withset_value, then the completion is forwarded torecv.
—(9.3) Forbulk-algo , the parameterpolicy describes the manner in which the execution of the asynchronous
operations corresponding to these algorithms may be parallelized and the manner in which they apply
f. Permissions and requirements on parallel algorithm element access functions (26.3.3) apply tof.
10 [Note 2: The asynchronous operation corresponding tobulk-algo (sndr, policy, shape, f) can complete with
set_stopped if cancellation is requested or ignore cancellation requests.—end note]
33.9.12.12 execution::when_all [exec.when.all]
1 when_all and when_all_with_variant both adapt multiple input senders into a sender that completes when
all input senders have completed.when_all only accepts senders with a single value completion signature and
on success concatenates all the input senders’ value result datums into its own value completion operation.
when_all_with_variant(sndrs...) is semantically equivalent to when_all(into_variant(sndrs)...),
where sndrs is a pack of subexpressions whose types modelsender.
2 The names when_all and when_all_with_variant denote customization point objects. Let sndrs be
a pack of subexpressions, letSndrs be a pack of the typesdecltype((sndrs))..., and let CD be the
type common_type_t<decltype(get-domain-early (sndrs))...>. Let CD2 be CD if CD is well-formed, and
default_domainotherwise. Theexpressions when_all(sndrs...)andwhen_all_with_variant(sndrs...)
are ill-formed if any of the following istrue:
—(2.1) sizeof...(sndrs) is 0, or
§ 33.9.12.12 © ISO/IEC
2306

===== PAGE 2318 =====

Dxxxx
—(2.2) (sender<Sndrs> && ...) is false.
3 The expressionwhen_all(sndrs...) is expression-equivalent to:
transform_sender(CD2(), make-sender (when_all, {}, sndrs...))
4 The exposition-only class templateimpls-for (33.9.2) is specialized forwhen_all_t as follows:
namespace std::execution {
template<>
struct impls-for <when_all_t> : default-impls {
static constexpr auto get-attrs = see below ;
static constexpr auto get-env = see below ;
static constexpr auto get-state = see below ;
static constexpr auto start = see below ;
static constexpr auto complete = see below ;
template<class Sndr, class... Env>
static consteval void check-types ();
};
}
5 Let make-when-all-env be the following exposition-only function template:
template<class Env>
constexpr auto make-when-all-env (inplace_stop_source& stop_src, // exposition only
Env&& env) noexcept;
6 Returns: An objecte such that
—(6.1) decltype(e) models queryable , and
—(6.2) e.query(get_stop_token) is expression-equivalent tostop_src.get_token(), and
—(6.3) given a query objectq with type other thancv get_stop_token_t, e.query(q) is expression-equivalent
to env.query(q) if the type ofq satisfies forwarding-query , and ill-formed otherwise.
7 Let when-all-env be an alias template such thatwhen-all-env <Env> denotes the typedecltype(make-
when-all-env (declval<inplace_stop_source&>(), declval<Env>())).
template<class Sndr, class... Env>
static consteval void check-types ();
8 Let Is be the pack of integral template arguments of theinteger_sequence specialization denoted by
indices-for <Sndr>.
9 Effects: Equivalent to:
auto fn = []<class Child>() {
auto cs = get_completion_signatures<Child, when-all-env <Env>...>();
if constexpr (cs.count-of (set_value) >= 2)
throw unspecified-exception ();
decay-copyable-result-datums (cs); // see 33.9.2
};
(fn.template operator()<child-type <Sndr, Is>>(), ...);
10 Throws: Any exception thrown as a result of evaluating theEffects, or an exception of typeunspecified-
exception (33.9.1) whenCD is ill-formed.
11 The memberimpls-for <when_all_t>::get-attrs is initialized with a callable object equivalent to the
following lambda expression:
[](auto&&, auto&&... child) noexcept {
if constexpr (same_as<CD, default_domain>) {
return env<>();
} else {
return MAKE-ENV (get_domain, CD());
}
}
12 The member impls-for <when_all_t>::get-env is initialized with a callable object equivalent to the
following lambda expression:
§ 33.9.12.12 © ISO/IEC
2307

===== PAGE 2319 =====

Dxxxx
[]<class State, class Rcvr>(auto&&, State& state, const Receiver& rcvr) noexcept {
return make-when-all-env (state.stop-src , get_env(rcvr));
}
13 The memberimpls-for <when_all_t>::get-state is initialized with a callable object equivalent to the
following lambda expression:
[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(noexcept(e)) -> decltype(e) {
return e;
}
where e is the expression
std::forward<Sndr>(sndr).apply (make-state <Rcvr>())
and wheremake-state is the following exposition-only class template:
enum class disposition { started , error , stopped }; // exposition only
template<class Rcvr>
struct make-state {
template<class... Sndrs>
auto operator()(auto, auto, Sndrs&&... sndrs) const {
using values_tuple = see below ;
using errors_variant = see below ;
using stop_callback = stop_callback_for_t<stop_token_of_t<env_of_t<Rcvr>>, on-stop-request >;
struct state-type {
void arrive (Rcvr& rcvr) noexcept { // exposition only
if (0 == --count) {
complete (rcvr);
}
}
void complete (Rcvr& rcvr) noexcept; // exposition only
atomic<size_t> count {sizeof...(sndrs)}; // exposition only
inplace_stop_source stop_src {}; // exposition only
atomic<disposition > disp{disposition::started}; // exposition only
errors_variant errors {}; // exposition only
values_tuple values {}; // exposition only
optional<stop_callback> on_stop {nullopt}; // exposition only
};
return state-type {};
}
};
14 Let copy-fail be exception_ptr if decay-copying any of the child senders’ result datums can potentially
throw; otherwise,none-such , wherenone-such is an unspecified empty class type.
15 The aliasvalues_tuple denotes the type
tuple<value_types_of_t<Sndrs, FWD-ENV-T (env_of_t<Rcvr>), decayed-tuple , optional>...>
if that type is well-formed; otherwise,tuple<>.
16 The aliaserrors_variantdenotes the typevariant<none-such, copy-fail , Es...>with duplicate types
removed, whereEs is the pack of the decayed types of all the child senders’ possible error result datums.
17 The membervoid state-type ::complete (Rcvr& rcvr) noexcept behaves as follows:
—(17.1) If disp is equal todisposition ::started , evaluates:
auto tie = []<class... T>(tuple<T...>& t) noexcept { return tuple<T&...>(t); };
auto set = [&](auto&... t) noexcept { set_value(std::move(rcvr), std::move(t)...); };
on_stop .reset();
apply(
[&](auto&... opts) noexcept {
apply(set, tuple_cat(tie(*opts)...));
§ 33.9.12.12 © ISO/IEC
2308

===== PAGE 2320 =====

Dxxxx
},
values);
—(17.2) Otherwise, ifdisp is equal todisposition ::error , evaluates:
on_stop .reset();
visit(
[&]<class Error>(Error& error) noexcept {
if constexpr (!same_as<Error, none-such >) {
set_error(std::move(rcvr), std::move(error));
}
},
errors);
—(17.3) Otherwise, evaluates:
if constexpr (sends-stopped ) {
on_stop .reset();
set_stopped(std::move(rcvr));
}
where sends-stopped equals true if and only if there exists an element S of Sndrs such that
completion_signatures_of_t<S, when-all-env <Env>> contains set_stopped_t().
18 The memberimpls-for <when_all_t>::start is initialized with a callable object equivalent to the following
lambda expression:
[]<class State, class Rcvr, class... Ops>(
State& state, Rcvr& rcvr, Ops&... ops) noexcept -> void {
state.on_stop .emplace(
get_stop_token(get_env(rcvr)),
on-stop-request {state.stop_src });
(start(ops), ...);
}
19 The member impls-for <when_all_t>::complete is initialized with a callable object equivalent to the
following lambda expression:
[]<class Index, class State, class Rcvr, class Set, class... Args>(
this auto& complete, Index, State& state, Rcvr& rcvr, Set, Args&&... args) noexcept -> void {
if constexpr (same_as<Set, set_error_t>) {
if (disposition ::error != state.disp.exchange(disposition ::error )) {
state.stop_src .request_stop();
TRY-EMPLACE-ERROR (state.errors, std::forward<Args>(args)...);
}
} else if constexpr (same_as<Set, set_stopped_t>) {
auto expected = disposition ::started ;
if (state.disp.compare_exchange_strong(expected, disposition ::stopped )) {
state.stop_src .request_stop();
}
} else if constexpr (!same_as<decltype(State::values), tuple<>>) {
if (state.disp == disposition ::started ) {
auto& opt = get<Index::value>(state.values);
TRY-EMPLACE-VALUE (complete, opt, std::forward<Args>(args)...);
}
}
state.arrive (rcvr);
}
where TRY-EMPLACE-ERROR (v, e), for subexpressionsv and e, is equivalent to:
try {
v.template emplace<decltype(auto(e))>(e);
} catch (...) {
v.template emplace<exception_ptr>(current_exception());
}
if the expressiondecltype(auto(e))(e) is potentially throwing; otherwise,v.template emplace<decl-
type(auto(e))>(e); and whereTRY-EMPLACE-VALUE (c, o, as...), for subexpressionsc, o, and pack of
subexpressions as, is equivalent to:
§ 33.9.12.12 © ISO/IEC
2309

===== PAGE 2321 =====

Dxxxx
try {
o.emplace(as...);
} catch (...) {
c(Index(), state, rcvr, set_error, current_exception());
return;
}
if the expressiondecayed-tuple <decltype(as)...>{as...}is potentially throwing; otherwise,o.emplace(
as...).
20 The expressionwhen_all_with_variant(sndrs...) is expression-equivalent to:
transform_sender(CD2(), make-sender (when_all_with_variant, {}, sndrs...));
21 Given subexpressions sndr and env, if sender-for <decltype((sndr)), when_all_with_variant_t> is
false, then the expressionwhen_all_with_variant.transform_sender(sndr, env) is ill-formed; other-
wise, it is equivalent to:
auto&& [_, _, ...child] = sndr;
return when_all(into_variant(std::forward_like<decltype((sndr))>(child))...);
[Note 1: This causes thewhen_all_with_variant(sndrs...) sender to becomewhen_all(into_variant(sndrs)...)
when it is connected with a receiver whose execution domain does not customizewhen_all_with_variant. —end
note]
33.9.12.13 execution::into_variant [exec.into.variant]
1 into_variant adapts a sender with multiple value completion signatures into a sender with just one value
completion signature consisting of avariant of tuples.
2 The nameinto_variant denotes a pipeable sender adaptor object. For a subexpressionsndr, letSndr be
decltype((sndr)). If Sndr does not satisfysender, into_variant(sndr) is ill-formed.
3 Otherwise, the expressioninto_variant(sndr) is expression-equivalent to:
transform_sender(get-domain-early (sndr), make-sender (into_variant, {}, sndr))
except thatsndr is only evaluated once.
4 The exposition-only class templateimpls-for (33.9.2) is specialized forinto_variant as follows:
namespace std::execution {
template<>
struct impls-for <into_variant_t> : default-impls {
static constexpr auto get-state = see below ;
static constexpr auto complete = see below ;
template<class Sndr, class... Env>
static consteval void check-types () {
auto cs = get_completion_signatures<child-type <Sndr>, FWD-ENV-T (Env)...>();
decay-copyable-result-datums (cs); // see 33.9.2
}
};
}
5 The memberimpls-for <into_variant_t>::get-state is initialized with a callable object equivalent to
the following lambda:
[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept
-> type_identity<value_types_of_t<child-type <Sndr>, FWD-ENV-T (env_of_t<Rcvr>)>> {
return {};
}
6 The memberimpls-for <into_variant_t>::complete is initialized with a callable object equivalent to the
following lambda:
[]<class State, class Rcvr, class Tag, class... Args>(
auto, State, Rcvr& rcvr, Tag, Args&&... args) noexcept -> void {
if constexpr (same_as<Tag, set_value_t>) {
using variant_type = State::type;
TRY-SET-VALUE (rcvr, variant_type(decayed-tuple <Args...>{std::forward<Args>(args)...}));
} else {
Tag()(std::move(rcvr), std::forward<Args>(args)...);
§ 33.9.12.13 © ISO/IEC
2310

===== PAGE 2322 =====

Dxxxx
}
}
33.9.12.14 execution::stopped_as_optional [exec.stopped.opt]
1 stopped_as_optional maps a sender’s stopped completion operation into a value completion operation as
a disengagedoptional. The sender’s value completion operation is also converted into anoptional. The
result is a sender that never completes with stopped, reporting cancellation by completing with a disengaged
optional.
2 The namestopped_as_optional denotes a pipeable sender adaptor object. For a subexpressionsndr, let
Sndr be decltype((sndr)). The expressionstopped_as_optional(sndr) is expression-equivalent to:
transform_sender(get-domain-early (sndr), make-sender (stopped_as_optional, {}, sndr))
except thatsndr is only evaluated once.
3 The exposition-only class templateimpls-for (33.9.2) is specialized forstopped_as_optional_t as follows:
namespace std::execution {
template<>
struct impls-for <stopped_as_optional_t> : default-impls {
template<class Sndr, class... Env>
static consteval void check-types () {
default-impls ::check-types <Sndr, Env...>();
if constexpr (!requires {
requires (!same_as<void, single-sender-value-type <child-type <Sndr>,
FWD-ENV-T (Env)...>>); })
throw unspecified-exception ();
}
};
}
4 Let sndr and env be subexpressions such thatSndr is decltype((sndr)) and Env is decltype((env)). If
sender-for <Sndr, stopped_as_optional_t> is false then the expressionstopped_as_optional.trans-
form_sender(sndr, env) is ill-formed; otherwise, ifsender_in<child-type <Sndr>, FWD-ENV-T (Env)> is
false, the expressionstopped_as_optional.transform_sender(sndr, env) is equivalent tonot-a-sen-
der (); otherwise, it is equivalent to:
auto&& [_, _, child] = sndr;
using V = single-sender-value-type <child-type <Sndr>, FWD-ENV-T (Env)>;
return let_stopped(
then(std::forward_like<Sndr>(child),
[]<class... Ts>(Ts&&... ts) noexcept(is_nothrow_constructible_v<V, Ts...>) {
return optional<V>(in_place, std::forward<Ts>(ts)...);
}),
[]() noexcept { return just(optional<V>()); });
33.9.12.15 execution::stopped_as_error [exec.stopped.err]
1 stopped_as_error maps an input sender’s stopped completion operation into an error completion operation
as a custom error type. The result is a sender that never completes with stopped, reporting cancellation by
completing with an error.
2 The namestopped_as_error denotes a pipeable sender adaptor object. For some subexpressionssndr and
err, let Sndr be decltype((sndr)) and let Err be decltype((err)). If the typeSndr does not satisfy
sender or if the typeErr does not satisfymovable-value , stopped_as_error(sndr, err) is ill-formed.
Otherwise, the expressionstopped_as_error(sndr, err) is expression-equivalent to:
transform_sender(get-domain-early (sndr), make-sender (stopped_as_error, err, sndr))
except thatsndr is only evaluated once.
3 Let sndr and env be subexpressions such thatSndr is decltype((sndr)) and Env is decltype((env)). If
sender-for <Sndr, stopped_as_error_t> is false, then the expressionstopped_as_error.transform_-
sender(sndr, env) is ill-formed; otherwise, it is equivalent to:
auto&& [_, err, child] = sndr;
using E = decltype(auto(err));
§ 33.9.12.15 © ISO/IEC
2311

===== PAGE 2323 =====

Dxxxx
return let_stopped(
std::forward_like<Sndr>(child),
[err = std::forward_like<Sndr>(err)]() mutable noexcept(is_nothrow_move_constructible_v<E>) {
return just_error(std::move(err));
});
33.9.12.16 execution::associate [exec.associate]
1 associate tries to associate a sender with an async scope such that the scope can track the lifetime of any
asynchronous operations created with the sender.
2 Let associate-data be the following exposition-only class template:
namespace std::execution {
template<scope_token Token, sender Sender>
struct associate-data { // exposition only
using wrap-sender = // exposition only
remove_cvref_t<decltype(declval<Token&>().wrap(declval<Sender>()))>;
using assoc-t = decltype(declval<Token&>().try_associate()); // exposition only
using sender-ref = // exposition only
unique_ptr<wrap-sender, decltype([](auto* p) noexcept { destroy_at(p); })>;
explicit associate-data (Token t, Sender&& s)
: sndr (t.wrap(std::forward<Sender>(s))),
assoc ([&] {
sender-ref guard{addressof(sndr )};
auto assoc = t.try_associate();
if (assoc) {
guard.release();
}
return assoc;
}()) {}
associate-data (const associate-data & other)
noexcept(is_nothrow_copy_constructible_v<wrap-sender > &&
noexcept(other.assoc .try_associate()));
associate-data (associate-data && other)
noexcept(is_nothrow_move_constructible_v<wrap-sender >)
: associate-data (std::move(other).release()) {}
~associate-data ();
pair<assoc-t , sender-ref > release() && noexcept;
private:
associate-data(pair<assoc-t, sender-ref> parts); // exposition only
union {
wrap-sender sndr; // exposition only
};
assoc-t assoc; // exposition only
};
template<scope_token Token, sender Sender>
associate-data (Token, Sender&&) -> associate-data <Token, Sender>;
}
3 For anassociate-data object a, bool(a.assoc ) is true if and only if an association was successfully made
and is owned bya.
associate-data (const associate-data & other)
noexcept(is_nothrow_copy_constructible_v<wrap-sender > &&
noexcept(other.assoc .try_associate()));
4 Constraints: wrap-sender models copy_constructible.
§ 33.9.12.16 © ISO/IEC
2312

===== PAGE 2324 =====

Dxxxx
5 Effects: Initializes assoc with other.assoc .try_associate(). If bool(assoc ) is true, initializes
sndr with other.sndr .
associate-data (pair<assoc-t , sender-ref > parts);
6 Effects: Initializes assoc with std::move(parts.first). If bool(assoc ) is true, initializessndr
with std::move(*parts.second).
~associate-data ();
7 Effects: If bool(assoc ) is true, destroyssndr .
pair<assoc-t , sender-ref > release() && noexcept;
8 Effects: Constructs an object u of type sender-ref that is initialized with addressof(sndr ) if
bool(assoc ) is true and with nullptr otherwise, then returns pair{std::move(assoc ), std::
move(u)}.
9 The nameassociate denotes a pipeable sender adaptor object. For subexpressionssndr and token:
—(9.1) If decltype((sndr)) does not satisfy sender, or remove_cvref_t<decltype((token))> does not
satisfy scope_token, thenassociate(sndr, token) is ill-formed.
—(9.2) Otherwise, the expressionassociate(sndr, token) is expression-equivalent to:
transform_sender(get-domain-early (sndr),
make-sender (associate, associate-data (token, sndr)))
except thatsndr is evaluated only once.
10 The exposition-only class templateimpls-for (33.9.2) is specialized forassociate_t as follows:
namespace std::execution {
template<>
struct impls-for <associate_t> : default-impls {
static constexpr auto get-state = see below ; // exposition only
static constexpr auto start = see below ; // exposition only
template<class Sndr, class... Env>
static consteval void check-types () { // exposition only
using associate_data_t = remove_cvref_t<data-type <Sndr>>;
using child_type_t = associate_data_t::wrap-sender ;
(void)get_completion_signatures<child_type_t, FWD-ENV-T (Env)...>();
}
};
}
11 The memberimpls-for <associate_t>::get-state is initialized with a callable object equivalent to the
following lambda:
[]<class Sndr, class Rcvr>(Sndr&& sndr, Rcvr& rcvr) noexcept(see below ) {
auto&& [_, data] = std::forward<Sndr>(sndr);
using associate_data_t = remove_cvref_t<decltype(data)>;
using assoc_t = associate_data_t::assoc-t ;
using sender_ref_t = associate_data_t::sender-ref ;
using op_t = connect_result_t<typename sender_ref_t::element_type, Rcvr>;
struct op_state {
assoc_t assoc ; // exposition only
union {
Rcvr* rcvr ; // exposition only
op_t op ; // exposition only
};
explicit op_state(pair<assoc_t, sender_ref_t> parts, Rcvr& r)
: assoc (std::move(parts.first)) {
if (assoc ) {
::new (voidify(op )) op_t(connect(std::move(*parts.second), std::move(r)));
§ 33.9.12.16 © ISO/IEC
2313

===== PAGE 2325 =====

Dxxxx
} else {
rcvr = addressof(r);
}
}
explicit op_state(associate_data_t&& ad, Rcvr& r)
: op_state(std::move(ad).release(), r) {}
explicit op_state(const associate_data_t& ad, Rcvr& r)
requires copy_constructible<associate_data_t>
: op_state(associate_data_t(ad).release(), r) {}
op_state(op_state&&) = delete;
~op_state() {
if (assoc ) {
op .~op_t();
}
}
void run () noexcept { // exposition only
if (assoc ) {
start(op );
} else {
set_stopped(std::move(*rcvr ));
}
}
};
return op_state{std::forward_like<Sndr>(data), rcvr };
}
12 The expression in thenoexcept clause ofimpls-for <associate_t>::get-state is
(is_same_v<Sndr, remove_cvref_t<Sndr>> ||
is_nothrow_constructible_v<remove_cvref_t<Sndr>, Sndr>) &&
nothrow-callable <connect_t, wrap-sender , Rcvr>
where wrap-sender is the typeremove_cvref_t<data-type <Sndr>>::wrap-sender .
13 Themember impls-for <associate_t>::start isinitializedwithacallableobjectequivalenttothefollowing
lambda:
[](auto& state, auto&) noexcept -> void {
state.run ();
}
14 The evaluation ofassociate(sndr, token) may cause side effects observable viatoken’s associated async
scope object.
33.9.12.17 Exposition-only execution::stop-when [exec.stop.when]
1 stop-when fuses an additional stop tokentinto a sender so that, upon connecting to a receiverr, the resulting
operation state receives stop requests from botht and the token returned fromget_stop_token(get_-
env(r)).
2 The namestop-when denotes an exposition-only sender adaptor. For subexpressionssndr and token:
—(2.1) If decltype((sndr)) does not satisfy sender, or remove_cvref_t<decltype((token))> does not
satisfy stoppable_token, thenstop-when (sndr, token) is ill-formed.
—(2.2) Otherwise, if remove_cvref_t<decltype((token))> models unstoppable_token then stop-when (
sndr, token) is expression-equivalent to(void)token, sndr, except thattoken and sndr are inde-
terminately sequenced.
—(2.3) Otherwise, stop-when (sndr, token) returns a senderosndr. If osndr is connected to a receiverr,
let rtoken be the result ofget_stop_token(get_env(r)).
—(2.3.1) If the type ofrtoken models unstoppable_token then the effects of connectingosndr to r are
equivalent toconnect(write_env(sndr, prop(get_stop_token, token)), r).
§ 33.9.12.17 © ISO/IEC
2314

===== PAGE 2326 =====

Dxxxx
—(2.3.2) Otherwise, the effects of connecting osndr to r are equivalent to connect(write_env(sndr,
prop(get_stop_token, stoken)), r) where stoken is an object of an exposition-only type
stoken-t such that:
—(2.3.2.1) stoken-t models stoppable_token;
—(2.3.2.2) stoken.stop_requested() returns token.stop_requested() || rtoken.stop_reques-
ted();
—(2.3.2.3) stoken.stop_possible() returns token.stop_possible() || rtoken.stop_possible();
and
—(2.3.2.4) for typesFn and Init such that bothinvocable<Fn> and constructible_from<Fn, Init>
are modeled,stoken-t ::callback_type<Fn> models stoppable-callback-for <Fn, sto-
ken-t , Init>.
[Note 1: For an objectfn of typeFn constructed from a value,init, of typeInit, registeringfn
using stoken-t ::callback_type<Fn>(stoken, init) results in an invocation offn when a callback
registered withtoken or rtoken would be invoked.fn is invoked at most once.—end note]
33.9.12.18 execution::spawn_future [exec.spawn.future]
1 spawn_future attempts to associate the given input sender with the given token’s async scope and, on
success, eagerly starts the input sender; the return value is a sender that, when connected and started,
completes with either the result of the eagerly-started input sender or withset_stopped if the input sender
was not started.
2 The namespawn_future denotes a customization point object. For subexpressionssndr, token, andenv,
—(2.1) let Sndr be decltype((sndr)),
—(2.2) let Token be remove_cvref_t<decltype((token))>, and
—(2.3) let Env be remove_cvref_t<decltype((env))>.
If any ofsender<Sndr>, scope_token<Token>, orqueryable <Env> are not satisfied, the expressionspawn_-
future(sndr, token, env) is ill-formed.
3 Let spawn-future-state-base be the exposition-only class template:
namespace std::execution {
template<class Completions>
struct spawn-future-state-base ; // exposition only
template<class... Sigs>
struct spawn-future-state-base <completion_signatures<Sigs...>> { // exposition only
using variant-t = see below ; // exposition only
variant-t result ; // exposition only
virtual void complete () noexcept = 0; // exposition only
};
}
4 Let Sigs be the pack of arguments to thecompletion_signatures specialization provided as a parameter
to thespawn-future-state-base class template. Let as-tuple be an alias template that transforms a
completion signatureTag(Args...) into the tuple specializationdecayed-tuple <Tag, Args...>.
—(4.1) If is_nothrow_constructible_v<decay_t<Arg>, Arg> is true for every typeArg in every parameter
pack Args in every completion signatureTag(Args...) in Sigs then variant-t denotes the type
variant<monostate, tuple<set_stopped_t>, as-tuple <Sigs>...>, except with duplicate types
removed.
—(4.2) Otherwise variant-t denotes the typevariant<monostate, tuple<set_stopped_t>, tuple<set_-
error_t, exception_ptr>, as-tuple <Sigs>...>, except with duplicate types removed.
5 Let spawn-future-receiver be the exposition-only class template:
namespace std::execution {
template<class Completions>
struct spawn-future-receiver { // exposition only
using receiver_concept = receiver_t;
spawn-future-state-base <Completions>* state ; // exposition only
§ 33.9.12.18 © ISO/IEC
2315

===== PAGE 2327 =====

Dxxxx
template<class... T>
void set_value(T&&... t) && noexcept {
set-complete <set_value_t>(std::forward<T>(t)...);
}
template<class E>
void set_error(E&& e) && noexcept {
set-complete <set_error_t>(std::forward<E>(e));
}
void set_stopped() && noexcept {
set-complete <set_stopped_t>();
}
private:
template<class CPO, class... T>
void set-complete (T&&... t) noexcept { // exposition only
constexpr bool nothrow = (is_nothrow_constructible_v<decay_t<T>, T> && ...);
try {
state ->result .template emplace<decayed-tuple <CPO, T...>>(CPO{},
std::forward<T>(t)...);
}
catch (...) {
if constexpr (!nothrow) {
using tuple_t = decayed-tuple <set_error_t, exception_ptr>;
state ->result .template emplace<tuple_t>(set_error_t{}, current_exception());
}
}
state ->complete ();
}
};
}
6 Let ssource-t be an unspecified type that modelsstoppable-source and default_initializable, such
that a default-initialized object of typessource-t has an associated stop state. Letssource be an lvalue
of typessource-t . Let stoken-t be decltype(ssource.get_token()). Let future-spawned-sender be
the alias template:
template<sender Sender, class Env>
using future-spawned-sender = // exposition only
decltype(write_env(stop-when (declval<Sender>(), declval<stoken-t >()), declval<Env>()));
7 Let spawn-future-state be the exposition-only class template:
namespace std::execution {
template<class Alloc, scope_token Token, sender Sender, class Env>
struct spawn-future-state // exposition only
: spawn-future-state-base <completion_signatures_of_t<future-spawned-sender <Sender, Env>>> {
using sigs-t = // exposition only
completion_signatures_of_t<future-spawned-sender <Sender, Env>>;
using receiver-t = // exposition only
spawn-future-receiver <sigs-t >;
using op-t = // exposition only
connect_result_t<future-spawned-sender <Sender, Env>, receiver-t >;
spawn-future-state(Alloc alloc, Sender&& sndr, Token token, Env env) // exposition only
: alloc (std::move(alloc)),
op (connect(
write_env(stop-when (std::forward<Sender>(sndr), ssource .get_token()), std::move(env)),
receiver-t (this))),
assoc (token.try_associate()) {
if (assoc )
start(op );
else
set_stopped(receiver-t (this));
}
§ 33.9.12.18 © ISO/IEC
2316

===== PAGE 2328 =====

Dxxxx
void complete() noexcept override; // exposition only
void consume(receiver auto& rcvr) noexcept; // exposition only
void abandon() noexcept; // exposition only
private:
using assoc-t = // exposition only
remove_cvref_t<decltype(declval<Token&>().try_associate())>;
Alloc alloc; // exposition only
ssource-t ssource; // exposition only
op-t op; // exposition only
assoc-t assoc; // exposition only
void destroy() noexcept; // exposition only
};
template<class Alloc, scope_token Token, sender Sender, class Env> // exposition only
spawn-future-state (Alloc alloc, Sender&& sndr, Token token, Env env)
-> spawn-future-state <Alloc, Token, Sender, Env>;
}
8 For purposes of determining the existence of a data race,complete , consume , and abandon behave as
atomic operations (6.10.2). These operations on a single object of a type that is a specialization of
spawn-future-state appear to occur in a single total order.
void complete () noexcept;
9 Effects:
—(9.1) No effects if this invocation ofcomplete happens before an invocation ofconsume or abandon
on *this;
—(9.2) otherwise, if an invocation ofconsume on *this happens before this invocation ofcomplete then
there is a receiver,rcvr, registered and that receiver is completed as if byconsume (rcvr);
—(9.3) otherwise, destroy is invoked.
void consume (receiver auto& rcvr) noexcept;
10 Effects:
—(10.1) If this invocation ofconsume happens before an invocation ofcomplete on *this then rcvr is
registered to be completed whencomplete is subsequently invoked on*this;
—(10.2) otherwise, rcvr is completed as if by:
std::move(this->result ).visit(
[&rcvr](auto&& tuple) noexcept {
if constexpr (!same_as<remove_reference_t<decltype(tuple)>, monostate>) {
apply([&rcvr](auto cpo, auto&&... vals) {
cpo(std::move(rcvr), std::move(vals)...);
}, std::move(tuple));
}
});
void abandon () noexcept;
11 Effects:
—(11.1) If this invocation ofabandon happens before an invocation ofcomplete on *this then equivalent
to:
ssource .request_stop();
—(11.2) otherwise, destroy is invoked.
void destroy () noexcept;
12 Effects: Equivalent to:
auto associated = std::move(this->associated );
§ 33.9.12.18 © ISO/IEC
2317

===== PAGE 2329 =====

Dxxxx
{
using traits = allocator_traits<Alloc>::template rebind_traits<spawn-future-state >;
typename traits::allocator_type alloc(std::move(this->alloc ));
traits::destroy(alloc, this);
traits::deallocate(alloc, this, 1);
}
13 The exposition-only class templateimpls-for (33.9.2) is specialized forspawn_future_t as follows:
namespace std::execution {
template<>
struct impls-for <spawn_future_t> : default-impls {
static constexpr auto start = see below ; // exposition only
};
}
14 The memberimpls-for <spawn_future_t>::start is initialized with a callable object equivalent to the
following lambda:
[](auto& state, auto& rcvr) noexcept -> void {
state->consume (rcvr);
}
15 For the expressionspawn_future(sndr, token, env) let new_sender be the expressiontoken.wrap(sndr)
and letalloc and senv be defined as follows:
—(15.1) if the expressionget_allocator(env) is well-formed, thenalloc is the result ofget_allocator(env)
and senv is the expressionenv;
—(15.2) otherwise, if the expressionget_allocator(get_env(new_sender)) is well-formed, thenalloc is the
result of get_allocator(get_env(new_sender)) and senv is the expressionJOIN-ENV (prop(get_-
allocator, alloc), env);
—(15.3) otherwise, alloc is allocator<void>() and senv is the expressionenv.
16 The expressionspawn_future(sndr, token, env) has the following effects:
—(16.1) Uses alloc to allocate and construct an objects of type decltype(spawn-future-state (alloc,
token.wrap(sndr), token, senv)) from alloc, token.wrap(sndr), token, andsenv. If an excep-
tion is thrown then any constructed objects are destroyed and any allocated memory is deallocated.
—(16.2) Constructs an objectu of a type that is a specialization ofunique_ptr such that:
—(16.2.1) u.get() is equal to the address ofs, and
—(16.2.2) u.get_deleter()(u.release()) is equivalent tou.release()->abandon ().
—(16.3) Returns make-sender (spawn_future, std::move(u)).
17 The expressionspawn_future(sndr, token) is expression-equivalent tospawn_future(sndr, token, ex-
ecution::env<>()).
33.9.13 Sender consumers [exec.consumers]
33.9.13.1 this_thread::sync_wait [exec.sync.wait]
1 this_thread::sync_wait and this_thread::sync_wait_with_variant are used to block the current
thread of execution until the specified sender completes and to return its async result.sync_wait mandates
that the input sender has exactly one value completion signature.
2 Let sync-wait-env be the following exposition-only class type:
namespace std::this_thread {
struct sync-wait-env {
execution::run_loop* loop ; // exposition only
auto query(execution::get_scheduler_t) const noexcept {
return loop ->get_scheduler();
}
auto query(execution::get_delegation_scheduler_t) const noexcept {
return loop ->get_scheduler();
}
§ 33.9.13.1 © ISO/IEC
2318

===== PAGE 2330 =====

Dxxxx
};
}
3 Let sync-wait-result-type and sync-wait-with-variant-result-type be exposition-only alias tem-
plates defined as follows:
namespace std::this_thread {
template<execution::sender_in<sync-wait-env > Sndr>
using sync-wait-result-type =
optional<execution::value_types_of_t<Sndr, sync-wait-env , decayed-tuple ,
type_identity_t>>;
template<execution::sender_in<sync-wait-env > Sndr>
using sync-wait-with-variant-result-type =
optional<execution::value_types_of_t<Sndr, sync-wait-env >>;
}
4 The namethis_thread::sync_wait denotes a customization point object. For a subexpressionsndr, let
Sndr be decltype((sndr)). The expressionthis_thread::sync_wait(sndr) is expression-equivalent to
the following, except thatsndr is evaluated only once:
apply_sender(get-domain-early (sndr), sync_wait, sndr)
Mandates:
—(4.1) sender_in<Sndr, sync-wait-env > is true.
—(4.2) The typesync-wait-result-type <Sndr> is well-formed.
—(4.3) same_as<decltype(e), sync-wait-result-type <Sndr>> is true, wheree is theapply_sender ex-
pression above.
5 Let sync-wait-state and sync-wait-receiver be the following exposition-only class templates:
namespace std::this_thread {
template<class Sndr>
struct sync-wait-state { // exposition only
execution::run_loop loop ; // exposition only
exception_ptr error ; // exposition only
sync-wait-result-type <Sndr> result; // exposition only
};
template<class Sndr>
struct sync-wait-receiver { // exposition only
using receiver_concept = execution::receiver_t;
sync-wait-state<Sndr>* state ; // exposition only
template<class... Args>
void set_value(Args&&... args) && noexcept;
template<class Error>
void set_error(Error&& err) && noexcept;
void set_stopped() && noexcept;
sync-wait-env get_env() const noexcept { return {&state ->loop }; }
};
}
template<class... Args>
void set_value(Args&&... args) && noexcept;
6 Effects: Equivalent to:
try {
state ->result .emplace(std::forward<Args>(args)...);
} catch (...) {
state ->error = current_exception();
}
state ->loop .finish();
§ 33.9.13.1 © ISO/IEC
2319

===== PAGE 2331 =====

Dxxxx
template<class Error>
void set_error(Error&& err) && noexcept;
7 Effects: Equivalent to:
state ->error = AS-EXCEPT-PTR (std::forward<Error>(err)); // see 33.1
state ->loop .finish();
void set_stopped() && noexcept;
8 Effects: Equivalent tostate ->loop .finish().
9 For a subexpressionsndr, let Sndr be decltype((sndr)). If sender_to<Sndr, sync-wait-receiver <
Sndr>> is false, the expressionsync_wait.apply_sender(sndr) is ill-formed; otherwise, it is equivalent
to:
sync-wait-state <Sndr> state;
auto op = connect(sndr, sync-wait-receiver <Sndr>{&state});
start(op);
state.loop .run();
if (state.error ) {
rethrow_exception(std::move(state.error ));
}
return std::move(state.result );
10 The behavior ofthis_thread::sync_wait(sndr) is undefined unless:
—(10.1) It blocks the current thread of execution (3.6) with forward progress guarantee delegation (6.10.2.3)
until the specified sender completes.
[Note 1: The default implementation ofsync_wait achieves forward progress guarantee delegation by providing
a run_loop scheduler via theget_delegation_scheduler query on thesync-wait-receiver ’s environment.
The run_loop is driven by the current thread of execution.—end note]
—(10.2) It returns the specified sender’s async results as follows:
—(10.2.1) For a value completion, the result datums are returned in atuple in an engagedoptional object.
—(10.2.2) For an error completion, an exception is thrown.
—(10.2.3) For a stopped completion, a disengagedoptional object is returned.
33.9.13.2 this_thread::sync_wait_with_variant [exec.sync.wait.var]
1 The namethis_thread::sync_wait_with_variant denotes a customization point object. For a subexpres-
sion sndr, letSndr be decltype(into_variant(sndr)). The expressionthis_thread::sync_wait_with_-
variant(sndr) is expression-equivalent to the following, exceptsndr is evaluated only once:
apply_sender(get-domain-early (sndr), sync_wait_with_variant, sndr)
Mandates:
—(1.1) sender_in<Sndr, sync-wait-env > is true.
—(1.2) The typesync-wait-with-variant-result-type <Sndr> is well-formed.
—(1.3) same_as<decltype(e), sync-wait-with-variant-result-type <Sndr>> is true, wheree is theap-
ply_sender expression above.
2 The expressionsync_wait_with_variant.apply_sender(sndr) is equivalent to:
using result_type = sync-wait-with-variant-result-type <Sndr>;
if (auto opt_value = sync_wait(into_variant(sndr))) {
return result_type(std::move(get<0>(*opt_value)));
}
return result_type(nullopt);
3 The behavior ofthis_thread::sync_wait_with_variant(sndr) is undefined unless:
—(3.1) It blocks the current thread of execution (3.6) with forward progress guarantee delegation (6.10.2.3)
until the specified sender completes.
[Note 1: The default implementation ofsync_wait_with_variant achieves forward progress guarantee delega-
tion by relying on the forward progress guarantee delegation provided bysync_wait. —end note]
§ 33.9.13.2 © ISO/IEC
2320

===== PAGE 2332 =====

Dxxxx
—(3.2) It returns the specified sender’s async results as follows:
—(3.2.1) For a value completion, the result datums are returned in an engagedoptional object that
contains avariant of tuples.
—(3.2.2) For an error completion, an exception is thrown.
—(3.2.3) For a stopped completion, a disengagedoptional object is returned.
33.9.13.3 execution::spawn [exec.spawn]
1 spawn attempts to associate the given input sender with the given token’s async scope and, on success,
eagerly starts the input sender.
2 The namespawn denotes a customization point object. For subexpressionssndr, token, andenv,
—(2.1) let Sndr be decltype((sndr)),
—(2.2) let Token be remove_cvref_t<decltype((token))>, and
—(2.3) let Env be remove_cvref_t<decltype((env))>.
If any ofsender<Sndr>, scope_token<Token>, orqueryable <Env> are not satisfied, the expressionspawn(
sndr, token, env) is ill-formed.
3 Let spawn-state-base be the exposition-only class:
namespace std::execution {
struct spawn-state-base { // exposition only
virtual void complete () noexcept = 0; // exposition only
};
}
4 Let spawn-receiver be the exposition-only class:
namespace std::execution {
struct spawn-receiver { // exposition only
using receiver_concept = receiver_t;
spawn-state-base * state ; // exposition only
void set_value() && noexcept { state ->complete (); }
void set_stopped() && noexcept { state ->complete (); }
};
}
5 Let spawn-state be the exposition-only class template:
namespace std::execution {
template<class Alloc, scope_token Token, sender Sender>
struct spawn-state : spawn-state-base { // exposition only
using op-t = connect_result_t<Sender, spawn-receiver >; // exposition only
spawn-state (Alloc alloc, Sender&& sndr, Token token); // exposition only
void complete () noexcept override; // exposition only
void run () noexcept; // exposition only
private:
using assoc-t = // exposition only
remove_cvref_t<decltype(declval<Token&>().try_associate())>;
Alloc alloc ; // exposition only
op-t op ; // exposition only
assoc-t assoc ; // exposition only
};
}
spawn-state (Alloc alloc, Sender&& sndr, Token token);
6 Effects: Initializes alloc with std::move(alloc), op with connect(std::move(sndr), spawn-re-
ceiver (this)), andassoc with token.try_associate().
§ 33.9.13.3 © ISO/IEC
2321

===== PAGE 2333 =====

Dxxxx
void run () noexcept;
7 Effects: Equivalent to:
if (assoc )
start(op );
else
complete ();
void complete () noexcept override;
8 Effects: Equivalent to:
auto assoc = std::move(this->assoc );
{
using traits = allocator_traits<Alloc>::template rebind_traits<spawn-state >;
typename traits::allocator_type alloc(this->alloc );
traits::destroy(alloc, this);
traits::deallocate(alloc, this, 1);
}
9 For the expressionspawn(sndr, token, env) let new_sender be the expressiontoken.wrap(sndr) and let
alloc and senv be defined as follows:
—(9.1) if the expressionget_allocator(env) is well-formed, thenalloc is the result ofget_allocator(env)
and senv is the expressionenv,
—(9.2) otherwise if the expressionget_allocator(get_env(new_sender)) is well-formed, thenalloc is the
result of get_allocator(get_env(new_sender)) and senv is the expressionJOIN-ENV (prop(get_-
allocator, alloc), env),
—(9.3) otherwise alloc is allocator<void>() and senv is the expressionenv.
10 The expressionspawn(sndr, token, env) is of typevoid and has the following effects:
—(10.1) Uses alloc to allocate and construct an objecto of type decltype(spawn-state (alloc, write_-
env(token.wrap(sndr), senv), token)) from alloc, write_env(token.wrap(sndr), senv), and
token and then invokeso.run (). If an exception is thrown then any constructed objects are destroyed
and any allocated memory is deallocated.
11 The expressionspawn(sndr, token) is expression-equivalent tospawn(sndr, token, execution::env<>(
)).
33.10 Completion signatures [exec.cmplsig]
1 completion_signatures is a type that encodes a set of completion signatures (33.3).
2 [Example 1:
struct my_sender {
using sender_concept = sender_t;
using completion_signatures =
execution::completion_signatures<
set_value_t(),
set_value_t(int, float),
set_error_t(exception_ptr),
set_error_t(error_code),
set_stopped_t()>;
};
Declares my_sender to be a sender that can complete by calling one of the following for a receiver expressionrcvr:
—(2.1) set_value(rcvr)
—(2.2) set_value(rcvr, int{...}, float{...})
—(2.3) set_error(rcvr, exception_ptr{...})
—(2.4) set_error(rcvr, error_code{...})
—(2.5) set_stopped(rcvr)
—end example]
§ 33.10 © ISO/IEC
2322

===== PAGE 2334 =====

Dxxxx
3 This subclause makes use of the following exposition-only entities:
template<class Fn>
concept completion-signature = see below ;
4 A typeFn satisfies completion-signature if and only if it is a function type with one of the following forms:
—(4.1) set_value_t(Vs...), whereVs is a pack of object or reference types.
—(4.2) set_error_t(Err), whereErr is an object or reference type.
—(4.3) set_stopped_t()
5 template<bool>
struct indirect-meta-apply {
template<template<class...> class T, class... As>
using meta-apply = T<As...>; // exposition only
};
template<class...>
concept always-true = true; // exposition only
template<class Tag,
valid-completion-signatures Completions,
template<class...> class Tuple,
template<class...> class Variant>
using gather-signatures = see below ;
6 Let Fns be a pack of the arguments of thecompletion_signatures specialization named byCompletions,
let TagFns be a pack of the function types inFns whose return types areTag, and letTsn be a pack of the
function argument types in then-th type inTagFns. Then, given two variadic templatesTuple and Variant,
the typegather-signatures <Tag, Completions, Tuple, Variant> names the type
META-APPLY (Variant, META-APPLY (Tuple, Ts0...),
META-APPLY (Tuple, Ts1...),
...,
META-APPLY (Tuple, Tsm−1...))
where m is the size of the packTagFns and META-APPLY (T, As...) is equivalent to:
typename indirect-meta-apply <always-true <As...>>::template meta-apply <T, As...>
7 [Note 1: The purpose ofMETA-APPLY is to make it valid to use non-variadic templates asVariant and Tuple arguments
to gather-signatures . —end note]
8 namespace std::execution {
template<completion-signature ... Fns>
struct completion_signatures {
template<class Tag>
static constexpr size_t count-of (Tag) { return see below ; }
template<class Fn>
static constexpr void for-each (Fn&& fn) { // exposition only
(fn(static_cast<Fns*>(nullptr)), ...);
}
};
template<class Sndr, class Env = env<>,
template<class...> class Tuple = decayed-tuple ,
template<class...> class Variant = variant-or-empty >
requires sender_in<Sndr, Env>
using value_types_of_t =
gather-signatures <set_value_t, completion_signatures_of_t<Sndr, Env>, Tuple, Variant>;
template<class Sndr, class Env = env<>,
template<class...> class Variant = variant-or-empty >
requires sender_in<Sndr, Env>
using error_types_of_t =
gather-signatures <set_error_t, completion_signatures_of_t<Sndr, Env>,
type_identity_t, Variant>;
§ 33.10 © ISO/IEC
2323

===== PAGE 2335 =====

Dxxxx
template<class Sndr, class Env = env<>>
requires sender_in<Sndr, Env>
constexpr bool sends_stopped =
!same_as<type-list <>,
gather-signatures <set_stopped_t, completion_signatures_of_t<Sndr, Env>,
type-list , type-list >>;
}
9 For a subexpressiontag, letTagbe the decayed type oftag. completion_signatures<Fns...>::count-of (
tag) returns the count of function types inFns... that are of the formTag(Ts...) where Ts is a pack of
types.
33.11 Queryable utilities [exec.envs]
33.11.1 Class template prop [exec.prop]
namespace std::execution {
template<class QueryTag, class ValueType>
struct prop {
QueryTag query_; // exposition only
ValueType value_; // exposition only
constexpr const ValueType& query(QueryTag) const noexcept {
return value_;
}
};
template<class QueryTag, class ValueType>
prop(QueryTag, ValueType) -> prop<QueryTag, unwrap_reference_t<ValueType>>;
}
1 Class templateprop is for building a queryable object from a query object and a value.
2 Mandates: callable <QueryTag, prop-like <ValueType>> is modeled, whereprop-like is the following
exposition-only class template:
template<class ValueType>
struct prop-like { // exposition only
const ValueType& query(auto) const noexcept;
};
3 [Example 1:
template<sender Sndr>
sender auto parameterize_work(Sndr sndr) {
// Make an environment such thatget_allocator(env) returns a reference to a copy ofmy_alloc{}.
auto e = prop(get_allocator, my_alloc{});
// Parameterize the input sender so that it will use our custom execution environment.
return write_env(sndr, e);
}
—end example]
4 Specializations of prop are not assignable.
33.11.2 Class template env [exec.env]
namespace std::execution {
template<queryable ... Envs>
struct env {
Envs0 envs 0; // exposition only
Envs1 envs 1; // exposition only
...
Envsn−1 envs n−1; // exposition only
template<class QueryTag>
constexpr decltype(auto) query(QueryTag q) const noexcept(see below );
};
§ 33.11.2 © ISO/IEC
2324

===== PAGE 2336 =====

Dxxxx
template<class... Envs>
env(Envs...) -> env<unwrap_reference_t<Envs>...>;
}
1 The class template env is used to construct a queryable object from several queryable objects. Query
invocations on the resulting object are resolved by attempting to query each subobject in lexical order.
2 Specializations of env are not assignable.
3 It is unspecified whetherenv supports initialization using a parenthesizedexpression-list (9.5), unless the
expression-list consist of a single element of type (possibly const)env.
4 [Example 1:
template<sender Sndr>
sender auto parameterize_work(Sndr sndr) {
// Make an environment such that:
// get_allocator(env) returns a reference to a copy ofmy_alloc{}
// get_scheduler(env) returns a reference to a copy ofmy_sched{}
auto e = env{prop(get_allocator, my_alloc{}),
prop(get_scheduler, my_sched{})};
// Parameterize the input sender so that it will use our custom execution environment.
return write_env(sndr, e);
}
—end example]
template<class QueryTag>
constexpr decltype(auto) query(QueryTag q) const noexcept(see below );
5 Let has-query be the following exposition-only concept:
template<class Env, class QueryTag>
concept has-query = // exposition only
requires (const Env& env) {
env.query(QueryTag());
};
6 Let fe be the first element ofenvs 0, envs 1, ... , envs n−1 such that the expressionfe .query(q) is
well-formed.
7 Constraints: (has-query <Envs, QueryTag> || ...) is true.
8 Effects: Equivalent to:return fe .query(q);
9 Remarks: The expression in thenoexcept clause is equivalent tonoexcept(fe .query(q)).
33.12 Execution contexts [exec.ctx]
33.12.1 execution::run_loop [exec.run.loop]
33.12.1.1 General [exec.run.loop.general]
1 A run_loop is an execution resource on which work can be scheduled. It maintains a thread-safe first-in-
first-out queue of work. Itsrun member function removes elements from the queue and executes them in a
loop on the thread of execution that callsrun.
2 A run_loop instance has an associatedcount that corresponds to the number of work items that are in
its queue. Additionally, arun_loop instance has an associated state that can be one ofstarting, running,
finishing, orfinished.
3 Concurrent invocations of the member functions ofrun_loop other than run and its destructor do not
introduce data races. The member functionspop-front , push-back , andfinish execute atomically.
4 Recommended practice: Implementations should use an intrusive queue of operation states to hold the work
units to make scheduling allocation-free.
namespace std::execution {
class run_loop {
// 33.12.1.2, associated types
class run-loop-scheduler ; // exposition only
class run-loop-sender ; // exposition only
§ 33.12.1.1 © ISO/IEC
2325

===== PAGE 2337 =====

Dxxxx
struct run-loop-opstate-base { // exposition only
virtual void execute () = 0; // exposition only
run_loop* loop ; // exposition only
run-loop-opstate-base * next ; // exposition only
};
template<class Rcvr>
using run-loop-opstate = unspecified ; // exposition only
// 33.12.1.4, member functions
run-loop-opstate-base * pop-front (); // exposition only
void push-back (run-loop-opstate-base *); // exposition only
public:
// 33.12.1.3, constructor and destructor
run_loop() noexcept;
run_loop(run_loop&&) = delete;
~run_loop();
// 33.12.1.4, member functions
run-loop-scheduler get_scheduler();
void run();
void finish();
};
}
33.12.1.2 Associated types [exec.run.loop.types]
class run-loop-scheduler ;
1 run-loop-scheduler is an unspecified type that modelsscheduler.
2 Instances ofrun-loop-scheduler remain valid until the end of the lifetime of therun_loop instance from
which they were obtained.
3 Two instances ofrun-loop-scheduler compare equal if and only if they were obtained from the same
run_loop instance.
4 Let sch be an expression of typerun-loop-scheduler . The expressionschedule(sch ) has typerun-loop-
sender and is not potentially-throwing ifsch is not potentially-throwing.
class run-loop-sender ;
5 run-loop-sender is an exposition-only type that satisfiessender. completion_signatures_of_t<run-
loop-sender > is
completion_signatures<set_value_t(), set_error_t(exception_ptr), set_stopped_t()>
6 An instance of run-loop-sender remains valid until the end of the lifetime of its associatedrun_loop
instance.
7 Let sndr be an expression of typerun-loop-sender , let rcvr be an expression such thatreceiver_-
of<decltype((rcvr )), CS> is true where CS is thecompletion_signatures specialization above. LetC
be eitherset_value_t or set_stopped_t. Then:
—(7.1) The expressionconnect(sndr , rcvr ) has typerun-loop-opstate <decay_t<decltype((rcvr ))>>
and is potentially-throwing if and only if(void(sndr ), auto(rcvr )) is potentially-throwing.
—(7.2) The expressionget_completion_scheduler<C>(get_env(sndr )) is potentially-throwing if and only
if sndr is potentially-throwing, has typerun-loop-scheduler , and compares equal to therun-loop-
scheduler instance from whichsndr was obtained.
template<class Rcvr>
struct run-loop-opstate ;
8 run-loop-opstate <Rcvr> inherits privately and unambiguously fromrun-loop-opstate-base .
9 Let obe a non-const lvalue of typerun-loop-opstate <Rcvr>, and letREC(o) be a non-const lvalue reference
to an instance of typeRcvr that was initialized with the expressionrcvr passed to the invocation of connect
that returnedo. Then:
§ 33.12.1.2 © ISO/IEC
2326

===== PAGE 2338 =====

Dxxxx
—(9.1) The object to whichREC (o) refers remains valid for the lifetime of the object to whicho refers.
—(9.2) Thetype run-loop-opstate <Rcvr>overridesrun-loop-opstate-base ::execute ()suchthat o.exe-
cute () is equivalent to:
if (get_stop_token(REC (o)).stop_requested()) {
set_stopped(std::move(REC (o)));
} else {
set_value(std::move(REC (o)));
}
—(9.3) The expressionstart(o) is equivalent to:
try {
o.loop ->push-back (addressof(o));
} catch(...) {
set_error(std::move(REC (o)), current_exception());
}
33.12.1.3 Constructor and destructor [exec.run.loop.ctor]
run_loop() noexcept;
1 Postconditions: The run_loop instance’s count is 0 and its state is starting.
~run_loop();
2 Effects: If therun_loop instance’s count is not 0 or if its state is running, invokesterminate (14.6.2).
Otherwise, has no effects.
33.12.1.4 Member functions [exec.run.loop.members]
run-loop-opstate-base * pop-front ();
1 Effects: Blocks (3.6) until one of the following conditions istrue:
—(1.1) The run_loop instance’s count is 0 and its state is finishing, in which casepop-front sets the
state to finished and returnsnullptr; or
—(1.2) the run_loop instance’s count is greater than 0, in which case an item is removed from the front
of the queue, the count is decremented by1, and the removed item is returned.
void push-back (run-loop-opstate-base * item);
2 Effects: Addsitem to the back of the queue and increments therun_loop instance’s count by 1.
3 Synchronization: This operation synchronizes with thepop-front operation that obtainsitem.
run-loop-scheduler get_scheduler();
4 Returns: An instance ofrun-loop-scheduler that can be used to schedule work onto thisrun_loop
instance.
void run();
5 Preconditions: The run_loop instance’s state is either starting or finishing.
6 Effects: If therun_loop instance’s state is starting, sets the state to running, otherwise leaves the state
unchanged. Then, equivalent to:
while (auto* op = pop-front ()) {
op->execute ();
}
7 Remarks: When therun_loop instance’s state changes, it does so without introducing data races.
void finish();
8 Preconditions: The run_loop instance’s state is either starting or running.
9 Effects: Changes therun_loop instance’s state to finishing.
10 Synchronization: finish synchronizes with thepop-front operation that returnsnullptr.
§ 33.12.1.4 © ISO/IEC
2327

===== PAGE 2339 =====

Dxxxx
33.13 Coroutine utilities [exec.coro.util]
33.13.1 execution::as_awaitable [exec.as.awaitable]
1 as_awaitable transforms an object into one that is awaitable within a particular coroutine. Subclause 33.13
makes use of the following exposition-only entities:
namespace std::execution {
template<class Sndr, class Promise>
concept awaitable-sender =
single-sender <Sndr, env_of_t<Promise>> &&
sender_to<Sndr,
typename sender-awaitable <Sndr, Promise>::awaitable-receiver > && // see below
requires (Promise& p) {
{ p.unhandled_stopped() } -> convertible_to<coroutine_handle<>>;
};
template<class Sndr>
concept has-queryable-await-completion-adaptor = // exposition only
sender<Sndr> &&
requires(Sndr&& sender) {
get_await_completion_adaptor(get_env(sender));
};
template<class Sndr, class Promise>
class sender-awaitable; // exposition only
}
2 The typesender-awaitable <Sndr, Promise> is equivalent to:
namespace std::execution {
template<class Sndr, class Promise>
class sender-awaitable {
struct unit {}; // exposition only
using value-type = // exposition only
single-sender-value-type<Sndr, env_of_t<Promise>>;
using result-type = // exposition only
conditional_t<is_void_v<value-type >, unit, value-type >;
struct awaitable-receiver; // exposition only
variant<monostate, result-type, exception_ptr> result{}; // exposition only
connect_result_t<Sndr, awaitable-receiver> state; // exposition only
public:
sender-awaitable (Sndr&& sndr, Promise& p);
static constexpr bool await_ready() noexcept { return false; }
void await_suspend(coroutine_handle<Promise>) noexcept { start(state ); }
value-type await_resume();
};
}
3 awaitable-receiver is equivalent to:
struct awaitable-receiver {
using receiver_concept = receiver_t;
variant<monostate, result-type, exception_ptr>* result-ptr; // exposition only
coroutine_handle<Promise> continuation; // exposition only
// see below
};
4 Let rcvr be an rvalue expression of typeawaitable-receiver , letcrcvr be a const lvalue that refers to
rcvr, letvs be a pack of subexpressions, and leterr be an expression of typeErr. Then:
—(4.1) If constructible_from<result-type , decltype((vs))...> is satisfied, the expressionset_value(
rcvr, vs...) is equivalent to:
try {
rcvr.result-ptr ->template emplace<1>(vs...);
} catch(...) {
§ 33.13.1 © ISO/IEC
2328

===== PAGE 2340 =====

Dxxxx
rcvr.result-ptr ->template emplace<2>(current_exception());
}
rcvr.continuation .resume();
Otherwise, set_value(rcvr, vs...) is ill-formed.
—(4.2) The expressionset_error(rcvr, err) is equivalent to:
rcvr.result-ptr ->template emplace<2>(AS-EXCEPT-PTR (err)); // see 33.1
rcvr.continuation .resume();
—(4.3) The expressionset_stopped(rcvr) is equivalent to:
static_cast<coroutine_handle<>>(rcvr.continuation .promise().unhandled_stopped()).resume();
—(4.4) For any expressiontag whose type satisfiesforwarding-query and for any pack of subexpressionsas,
get_env(crcvr).query(tag, as...) is expression-equivalent to:
tag(get_env(as_const(crcvr.continuation .promise())), as...)
sender-awaitable (Sndr&& sndr, Promise& p);
5 Effects: Initializes state with
connect(std::forward<Sndr>(sndr),
awaitable-receiver {addressof(result), coroutine_handle<Promise>::from_promise(p)})
value-type await_resume();
6 Effects: Equivalent to:
if (result .index() == 2)
rethrow_exception(get<2>(result ));
if constexpr (!is_void_v<value-type >)
return std::forward<value-type >(get<1>(result ));
7 as_awaitableis a customization point object. For subexpressionsexprandpwherepis an lvalue,Exprnames
the typedecltype((expr)) and Promise names the typedecay_t<decltype((p))>, as_awaitable(expr,
p) is expression-equivalent to, except that the evaluations ofexpr and p are indeterminately sequenced:
—(7.1) expr.as_awaitable(p) if that expression is well-formed.
Mandates: is-awaitable <A, Promise> is true, whereA is the type of the expression above.
—(7.2) Otherwise, (void(p), expr) if decltype(GET-AWAITER (expr)) satisfies is-awaiter <Promise>.
—(7.3) Otherwise, sender-awaitable {adapted-expr , p} if
has-queryable-await-completion-adaptor <Expr>
and
awaitable-sender <decltype((adapted-expr )), Promise>
are both satisfied, whereadapted-expr is get_await_completion_adaptor(get_env(expr))(expr),
except thatexpr is evaluated only once.
—(7.4) Otherwise, sender-awaitable {expr, p} if awaitable-sender <Expr, Promise> is true.
—(7.5) Otherwise, (void(p), expr).
33.13.2 execution::with_awaitable_senders [exec.with.awaitable.senders]
1 with_awaitable_senders, when used as the base class of a coroutine promise type, makes senders awaitable
in that coroutine type.
In addition, it provides a default implementation ofunhandled_stopped such that if a sender completes
by calling set_stopped, it is treated as if an uncatchable "stopped" exception were thrown from the
await-expression.
[Note 1: The coroutine is never resumed, and theunhandled_stopped of the coroutine caller’s promise type is called.
—end note]
namespace std::execution {
template<class-type Promise>
struct with_awaitable_senders {
template<class OtherPromise>
requires (!same_as<OtherPromise, void>)
§ 33.13.2 © ISO/IEC
2329

===== PAGE 2341 =====

Dxxxx
void set_continuation(coroutine_handle<OtherPromise> h) noexcept;
coroutine_handle<> continuation() const noexcept { return continuation ; }
coroutine_handle<> unhandled_stopped() noexcept {
return stopped-handler (continuation .address());
}
template<class Value>
see below await_transform(Value&& value);
private:
[[noreturn]] static coroutine_handle<>
default-unhandled-stopped (void*) noexcept { // exposition only
terminate();
}
coroutine_handle<> continuation {}; // exposition only
coroutine_handle<> (*stopped-handler )(void*) noexcept = // exposition only
&default-unhandled-stopped ;
};
}
template<class OtherPromise>
requires (!same_as<OtherPromise, void>)
void set_continuation(coroutine_handle<OtherPromise> h) noexcept;
2 Effects: Equivalent to:
continuation = h;
if constexpr ( requires(OtherPromise& other) { other.unhandled_stopped(); } ) {
stopped-handler = [](void* p) noexcept -> coroutine_handle<> {
return coroutine_handle<OtherPromise>::from_address(p)
.promise().unhandled_stopped();
};
} else {
stopped-handler = &default-unhandled-stopped ;
}
template<class Value>
call-result-t <as_awaitable_t, Value, Promise&> await_transform(Value&& value);
3 Effects: Equivalent to:
return as_awaitable(std::forward<Value>(value), static_cast<Promise&>(*this));
33.13.3 execution::affine_on [exec.affine.on]
1 affine_on adapts a sender into one that completes on the specified scheduler. If the algorithm determines
that the adapted sender already completes on the correct scheduler it can avoid any scheduling operation.
2 The name affine_on denotes a pipeable sender adaptor object. For subexpressions sch and sndr, if
decltype((sch)) does not satisfy scheduler, or decltype((sndr)) does not satisfy sender, affine_-
on(sndr, sch) is ill-formed.
3 Otherwise, the expressionaffine_on(sndr, sch) is expression-equivalent to:
transform_sender(get-domain-early (sndr), make-sender (affine_on, sch, sndr))
except thatsndr is evaluated only once.
4 The exposition-only class templateimpls-for (33.9.2) is specialized foraffine_on_t as follows:
namespace std::execution {
template<>
struct impls-for <affine_on_t> : default-impls {
static constexpr auto get-attrs =
[](const auto& data, const auto& child) noexcept -> decltype(auto) {
return JOIN-ENV (SCHED-ATTRS (data), FWD-ENV (get_env(child)));
};
§ 33.13.3 © ISO/IEC
2330

===== PAGE 2342 =====

Dxxxx
};
}
5 Let out_sndr be a subexpression denoting a sender returned fromaffine_on(sndr, sch) or one equal
to such, and letOutSndr be the typedecltype((out_sndr )). Let out_rcvr be a subexpression denoting
a receiver that has an environment of typeEnv such thatsender_in<OutSndr, Env> is true. Let op be
an lvalue referring to the operation state that results from connectingout_sndr to out_rcvr . Calling
start(op ) will startsndr on the current execution agent and execute completion operations onout_rcvr
on an execution agent of the execution resource associated withsch. If the current execution resource is
the same as the execution resource associated withsch, the completion operation onout_rcvr may be
called beforestart(op ) completes. If scheduling ontosch fails, an error completion onout_rcvr shall be
executed on an unspecified execution agent.
33.13.4 execution::inline_scheduler [exec.inline.scheduler]
namespace std::execution {
class inline_scheduler {
class inline-sender; // exposition only
template<receiver R>
class inline-state; // exposition only
public:
using scheduler_concept = scheduler_t;
constexpr inline-sender schedule() noexcept { return {}; }
constexpr bool operator==(const inline_scheduler&) const noexcept = default;
};
}
1 inline_scheduler is a class that modelsscheduler (33.6). All objects of type inline_scheduler are
equal.
2 inline-sender is an exposition-only type that satisfiessender. The typecompletion_signatures_of_-
t<inline-sender > is completion_signatures<set_value_t()>.
3 Let sndr be an expression of type inline-sender , let rcvr be an expression such that receiver_-
of<decltype((rcvr)), CS> is true where CS is completion_signatures<set_value_t()>, then:
—(3.1) theexpression connect(sndr, rcvr)hastype inline-state <remove_cvref_t<decltype((rcvr))>>
and is potentially-throwing if and only if((void)sndr, auto(rcvr)) is potentially-throwing, and
—(3.2) the expressionget_completion_scheduler<set_value_t>(get_env(sndr)) has typeinline_sched-
uler and is potentially-throwing if and only ifget_env(sndr) is potentially-throwing.
4 Let o be a non-const lvalue of typeinline-state <Rcvr>, and letREC(o ) be a non-const lvalue reference
to an object of typeRcvr that was initialized with the expressionrcvr passed to an invocation ofconnect
that returnedo , then:
—(4.1) the object to whichREC(o ) refers remains valid for the lifetime of the object to whicho refers, and
—(4.2) the expressionstart(o ) is equivalent toset_value(std::move(REC(o ))).
33.13.5 execution::task_scheduler [exec.task.scheduler]
namespace std::execution {
class task_scheduler {
class ts-sender; // exposition only
template<receiver R>
class state; // exposition only
public:
using scheduler_concept = scheduler_t;
template<class Sch, class Allocator = allocator<void>>
requires (!same_as<task_scheduler, remove_cvref_t<Sch>>)
&& scheduler<Sch>
explicit task_scheduler(Sch&& sch, Allocator alloc = {});
§ 33.13.5 © ISO/IEC
2331

===== PAGE 2343 =====

Dxxxx
task_scheduler(const task_scheduler&) = default;
task_scheduler& operator=(const task_scheduler&) = default;
ts-sender schedule();
friend bool operator==(const task_scheduler& lhs, const task_scheduler& rhs)
noexcept;
template<class Sch>
requires (!same_as<task_scheduler, Sch>)
&& scheduler<Sch>
friend bool operator==(const task_scheduler& lhs, const Sch& rhs) noexcept;
private:
shared_ptr<void> sch_; // exposition only
};
}
1 task_scheduler is a class that modelsscheduler (33.6). Given an objects of typetask_scheduler, let
SCHED (s) be the object pointed to by the pointer owned bys.sch_.
template<class Sch, class Allocator = allocator<void>>
requires(!same_as<task_scheduler, remove_cvref_t<Sch>>) && scheduler<Sch>
explicit task_scheduler(Sch&& sch, Allocator alloc = {});
2 Effects: Initialize sch_ with allocate_shared<remove_cvref_t<Sch>>(alloc, std::forward<Sch>
(sch)).
3 Recommended practice: Implementations should avoid the use of dynamically allocated memory for
small scheduler objects.
4 Remarks: Any allocations performed by construction ofts-sender or state objects resulting from
calls on*this are performed using a copy ofalloc.
ts-sender schedule();
5 Effects: Returns an object of typets-sender containing a sender initialized withschedule(SCHED
(*this)).
bool operator==(const task_scheduler& lhs, const task_scheduler& rhs) noexcept;
6 Effects: Equivalent to:return lhs == SCHED (rhs);
template<class Sch>
requires (!same_as<task_scheduler, Sch>)
&& scheduler<Sch>
bool operator==(const task_scheduler& lhs, const Sch& rhs) noexcept;
7 Returns: false if the type ofSCHED (lhs) is notSch, otherwiseSCHED (lhs) == rhs.
8 namespace std::execution {
class task_scheduler::ts-sender { // exposition only
public:
using sender_concept = sender_t;
template<receiver Rcvr>
state <Rcvr> connect(Rcvr&& rcvr) &&;
};
}
ts-sender is an exposition-only class that modelssender (33.9) and for whichcompletion_signatures_-
of_t<ts-sender > denotes:
completion_signatures<
set_value_t(),
set_error_t(error_code),
set_error_t(exception_ptr),
set_stopped_t()>
§ 33.13.5 © ISO/IEC
2332

===== PAGE 2344 =====

Dxxxx
9 Let sch be an object of typetask_scheduler and letsndr be an object of typets-sender obtained from
schedule(sch ). Thenget_completion_scheduler<set_value_t>(get_env(sndr)) == sch istrue. The
object SENDER (sndr) is the sender object contained bysndr or an object move constructed from it.
template<receiver Rcvr>
state <Rcvr> connect(Rcvr&& rcvr) &&;
10 Effects: Let r be an object of a type that modelsreceiver and whose completion handlers result
in invoking the corresponding completion handlers ofrcvr or copy thereof. Returns an object of
type state <Rcvr> containing an operation state object initialized withconnect(SENDER (*this),
std::move(r )).
11 namespace std::execution {
template<receiver R>
class task_scheduler::state { // exposition only
public:
using operation_state_concept = operation_state_t;
void start() & noexcept;
};
}
state is an exposition-only class template whose specializations modeloperation_state (33.8).
void start() & noexcept;
12 Effects: Equivalent tostart(st) where st is the operation state object contained by*this.
33.13.6 execution::task [exec.task]
33.13.6.1 task overview [task.overview]
1 The task class template represents a sender that can be used as the return type of coroutines. The first
template parameterT defines the type of the value completion datum (33.3) ifT is notvoid. Otherwise, there
are no value completion datums. Inside coroutines returningtask<T, E> the operand ofco_return (if any)
becomes the argument ofset_value. The second template parameterEnvironment is used to customize the
behavior oftask.
33.13.6.2 Class template task [task.class]
namespace std::execution {
template<class T = void, class Environment = env<>>
class task {
// 33.13.6.4
template<receiver Rcvr>
class state; // exposition only
public:
using sender_concept = sender_t;
using completion_signatures = see below ;
using allocator_type = see below ;
using scheduler_type = see below ;
using stop_source_type = see below ;
using stop_token_type = decltype(declval<stop_source_type>().get_token());
using error_types = see below ;
// 33.13.6.5
class promise_type;
task(task&&) noexcept;
~task();
template<receiver Rcvr>
state <Rcvr> connect(Rcvr&& rcvr) &&;
private:
coroutine_handle<promise_type> handle; // exposition only
§ 33.13.6.2 © ISO/IEC
2333

===== PAGE 2345 =====

Dxxxx
};
}
1 task<T, E> models sender (33.9) ifT is void, a reference type, or acv-unqualified non-array object type
and E is a class type. Otherwise a program that instantiates the definition oftask<T, E> is ill-formed.
2 The nested types oftask template specializations are determined based on theEnvironment parameter:
—(2.1) allocator_type is Environment::allocator_type if that qualified-id is valid and denotes a type,
allocator<byte> otherwise.
—(2.2) scheduler_type is Environment::scheduler_type if that qualified-id is valid and denotes a type,
task_scheduler otherwise.
—(2.3) stop_source_type is Environment::stop_source_type if thatqualified-id is valid and denotes a type,
inplace_stop_source otherwise.
—(2.4) error_types is Environment::error_types if that qualified-id is valid and denotes a type, com-
pletion_signatures<set_error_t(exception_ptr)> otherwise.
3 A program is ill-formed iferror_types is not a specialization ofexecution::completion_signatures or
if the template arguments of that specialization contain an element which is not of the formset_error_t(E)
for some typeE.
4 The type aliascompletion_signatures is a specialization ofexecution::completion_signatures with
the template arguments (in unspecified order):
—(4.1) set_value_t() if T is void, andset_value_t(T) otherwise;
—(4.2) template arguments of the specialization ofexecution::completion_signatures denoted byerror_-
types; and
—(4.3) set_stopped_t().
5 allocator_type shall meet theCpp17Allocator requirements.
33.13.6.3 task members [task.members]
task(task&& other) noexcept;
1 Effects: Initializes handle with exchange(other.handle , {}).
~task();
2 Effects: Equivalent to:
if (handle )
handle .destroy();
template<receiver Rcvr>
state <Rcvr> connect(Rcvr&& recv) &&;
3 Preconditions: bool(handle ) is true.
4 Effects: Equivalent to:
return state <Rcvr>(exchange(handle , {}), std::forward<Rcvr>(recv));
33.13.6.4 Class template task::state [task.state]
namespace std::execution {
template<class T, class Environment>
template<receiver Rcvr>
class task<T, Environment>::state { // exposition only
public:
using operation_state_concept = operation_state_t;
template<class R>
state (coroutine_handle<promise_type> h, R&& rr);
~state ();
void start() & noexcept;
§ 33.13.6.4 © ISO/IEC
2334

===== PAGE 2346 =====

Dxxxx
private:
using own-env-t = see below; // exposition only
coroutine_handle<promise_type> handle; // exposition only
remove_cvref_t<Rcvr> rcvr; // exposition only
own-env-t own-env ; // exposition only
Environment environment; // exposition only
};
}
1 The type own-env-t is Environment::template env_type<decltype(get_env(declval<Rcvr>()))> if
that qualified-id is valid and denotes a type,env<> otherwise.
template<class R>
state (coroutine_handle<promise_type> h, R&& rr);
2 Effects: Initializes
—(2.1) handle with std::move(h);
—(2.2) rcvr with std::forward<R>(rr);
—(2.3) own-env with own-env-t (get_env(rcvr ))if that expression is valid andown-env-t ()otherwise.
If neither of these expressions is valid, the program is ill-formed.
—(2.4) environment with Environment(own-env ) if that expression is valid, otherwiseEnvironment(
get_env(rcvr )) if this expression is valid, otherwiseEnvironment(). If neither of these expres-
sions is valid, the program is ill-formed.
~state ();
3 Effects: Equivalent to:
if (handle )
handle .destroy();
void start() & noexcept;
4 Effects: Let prom be the object handle .promise(). Associates STATE (prom ), RCVR (prom ), and
SCHED (prom ) with *this as follows:
—(4.1) STATE (prom ) is *this.
—(4.2) RCVR (prom ) is rcvr .
—(4.3) SCHED (prom ) is the object initialized withscheduler_type(get_scheduler(get_env(rcvr )))
if that expression is valid andscheduler_type() otherwise. If neither of these expressions is
valid, the program is ill-formed.
Let st be get_stop_token(get_env(rcvr )). Initializes prom.token and prom.source such that
—(4.4) prom.token .stop_requested() returns st.stop_requested();
—(4.5) prom.token .stop_possible() returns st.stop_possible(); and
—(4.6) for typesFn and Init such that bothinvocable<Fn> and constructible_from<Fn, Init> are
modeled, stop_token_type::callback_type<Fn> models stoppable-callback-for <Fn, stop-
_token_type, Init>.
After that invokeshandle .resume().
33.13.6.5 Class task::promise_type [task.promise]
namespace std::execution {
template<class T, class Environment>
class task<T, Environment>::promise_type {
public:
template<class... Args>
promise_type(const Args&... args);
task get_return_object() noexcept;
static constexpr suspend_always initial_suspend() noexcept { return {}; }
auto final_suspend() noexcept;
§ 33.13.6.5 © ISO/IEC
2335

===== PAGE 2347 =====

Dxxxx
void unhandled_exception();
coroutine_handle<> unhandled_stopped() noexcept;
void return_void(); // present only ifis_void_v<T> is true
template<class V = T>
void return_value(V&& value); // present only ifis_void_v<T> is false
template<class E>
unspecified yield_value(with_error<E> error);
template<class A>
auto await_transform(A&& a);
template<class Sch>
auto await_transform(change_coroutine_scheduler<Sch> sch);
unspecified get_env() const noexcept;
template<class... Args>
void* operator new(size_t size, Args&&... args);
void operator delete(void* pointer, size_t size) noexcept;
private:
using error-variant = see below; // exposition only
allocator_type alloc; // exposition only
stop_source_type source; // exposition only
stop_token_type token; // exposition only
optional<T> result; // exposition only; present only ifis_void_v<T> is false
error-variant errors ; // exposition only
};
}
1 Let prom be an object ofpromise_type and let tsk be the task object created byprom.get_return_-
object(). The description below refers to objectsSTATE (prom ), RCVR (prom ), andSCHED (prom ) associated
with tsk during evaluation oftask::state <Rcvr>::start for some receiverRcvr.
2 error-variant is avariant<monostate, remove_cvref_t<E>...>, with duplicate types removed, where
E... are the parameter types of the template arguments of the specialization ofexecution::completion_-
signatures denoted byerror_types.
template<class... Args>
promise_type(const Args&... args);
3 Mandates: The first parameter of typeallocator_arg_t (if any) is not the last parameter.
4 Effects: If Args contains an element of typeallocator_arg_t then alloc is initialized with the
corresponding next element ofargs. Otherwise, alloc is initialized withallocator_type().
task get_return_object() noexcept;
5 Returns: Ataskobject whose memberhandle is coroutine_handle<promise_type>::from_promise
(*this).
auto final_suspend() noexcept;
6 Returns: An awaitable object of unspecified type (7.6.2.4) whose member functions arrange for the
completion of the asynchronous operation associated withSTATE (*this) by invoking:
—(6.1) set_error(std::move(RCVR (*this)), std::move(e)) if errors .index() is greater than zero
and e is the value held byerrors , otherwise
—(6.2) set_value(std::move(RCVR (*this))) if is_void<T> is true, and otherwise
—(6.3) set_value(std::move(RCVR (*this)), *result ).
§ 33.13.6.5 © ISO/IEC
2336

===== PAGE 2348 =====

Dxxxx
template<class Err>
auto yield_value(with_error<Err> err);
7 Mandates: std::move(err.error) is convertible to exactly one of theset_error_t argument types
of error_types. Let Cerr be that type.
8 Returns: An awaitable object of unspecified type (7.6.2.4) whose member functions arrange for the calling
coroutinetobesuspendedandthencompletestheasynchronousoperationassociatedwith STATE (*this)
by invokingset_error(std::move(RCVR (*this)), Cerr (std::move(err.error))).
template<sender Sender>
auto await_transform(Sender&& sndr) noexcept;
9 Returns: If same_as<inline_scheduler, scheduler_type> is true returns as_awaitable(std::
forward<Sender>(sndr), *this); otherwise returnsas_awaitable(affine_on(std::forward<Sen-
der>(sndr), SCHED (*this)), *this).
template<class Sch>
auto await_transform(change_coroutine_scheduler<Sch> sch) noexcept;
10 Effects: Equivalent to:
return await_transform(just(exchange(SCHED (*this), scheduler_type(sch.scheduler))), *this);
void unhandled_exception();
11 Effects: If the signature set_error_t(exception_ptr) is not an element of error_types, calls
terminate() (14.6.2). Otherwise, storescurrent_exception() into errors .
coroutine_handle<> unhandled_stopped() noexcept;
12 Effects: Completes the asynchronous operation associated with STATE (*this) by invoking set_-
stopped(std::move(RCVR (*this))).
13 Returns: noop_coroutine().
void return_void();
14 Effects: Does nothing.
template<class V>
void return_value(V&& v);
15 Effects: Equivalent toresult .emplace(std::forward<V>(v)).
unspecified get_env() const noexcept;
16 Returns: An objectenv such that queries are forwarded as follows:
—(16.1) env.query(get_scheduler) returns scheduler_type(SCHED (*this)).
—(16.2) env.query(get_allocator) returns alloc .
—(16.3) env.query(get_stop_token) returns token .
—(16.4) For any other queryq and argumentsa... a call toenv.query(q, a...) returns STATE (*this).
environment.query(q, a...) if this expression is well-formed andforwarding_query(q) is
well-formed and istrue. Otherwise env.query(q, a...) is ill-formed.
template<class... Args>
void* operator new(size_t size, const Args&... args);
17 If there is no parameter with typeallocator_arg_t then letalloc be allocator_type(). Other-
wise, letarg_next be the parameter following the firstallocator_arg_t parameter, and letalloc
be allocator_type(arg_next). Let PAlloc be allocator_traits<allocator_type>::template
rebind_alloc<U>, where U is an unspecified type whose size and alignment are both__STDCPP_-
DEFAULT_NEW_ALIGNMENT__.
18 Mandates:
—(18.1) The first parameter of typeallocator_arg_t (if any) is not the last parameter.
—(18.2) allocator_type(arg_next)is a valid expression if there is a parameter of typeallocator_arg_t.
—(18.3) allocator_traits<PAlloc>::pointer is a pointer type.
§ 33.13.6.5 © ISO/IEC
2337

===== PAGE 2349 =====

Dxxxx
19 Effects: Initializes an allocatorpalloc of typePAlloc with alloc. Uses palloc to allocate storage for
the smallest array ofU sufficient to provide storage for a coroutine state of sizesize, and unspecified
additional state necessary to ensure thatoperator delete can later deallocate this memory block
with an allocator equal topalloc.
20 Returns: A pointer to the allocated storage.
void operator delete(void* pointer, size_t size) noexcept;
21 Preconditions: pointer was returned from an invocation of the above overload ofoperator new with
a size argument equal tosize.
22 Effects: Deallocates the storage pointed to bypointer using an allocator equal to that used to allocate
it.
33.14 Execution scope utilities [exec.scope]
33.14.1 Execution scope concepts [exec.scope.concepts]
1 The scope_association concept defines the requirements on a typeAssoc. An object of typeAssoc is
engaged if and only if it owns an association with an async scope, referred to as itsassociated scope.
namespace std::execution {
template<class Assoc>
concept scope_association =
movable<Assoc> &&
is_nothrow_move_constructible_v<Assoc> &&
is_nothrow_move_assignable_v<Assoc> &&
default_initializable<Assoc> &&
requires(const Assoc assoc) {
{ static_cast<bool>(assoc) } noexcept;
{ assoc.try_associate() } -> same_as<Assoc>;
};
}
2 A typeAssoc models scope_association only if:
—(2.1) a default constructed object of typeAssoc is not engaged;
—(2.2) for an objectassoc of typeAssoc, static_cast<bool>(assoc) is true if and only ifassoc is engaged;
—(2.3) no two distinct objects of typeAssoc own the same assocation;
—(2.4) for an objectassoc of typeAssoc, destroyingassoc releases the assocation owned byassoc, if any;
—(2.5) for an objectassoc of typeAssoc, after it is used as the source operand of a move constructor, the
assoc is not engaged;
—(2.6) for distinct objectsassoc1 and assoc2 of typeAssoc, after evaluatingassoc1 = std::move(assoc2),
the association owned byassoc1, if any, is released andassoc2 is not engaged;
—(2.7) for an objectassoc of typeAssoc that is engaged,assoc.try_associate() either returns an object
that is not engaged or acquires a new association withassoc’s associated scope and returns an engaged
object that owns that association;
—(2.8) for an objectassoc of typeAssoc that is not engaged,assoc.try_associate() returns an object that
is not engaged.
3 The scope_token concept defines the requirements on a typeToken that can be used to create associations
between senders and an async scope. Every object of typeToken is associated with an async scope that is
referred to as itsassociated scope.
4 Let test-sender and test-env be unspecified types such thatsender_in<test-sender, test-env >is modeled.
namespace std::execution {
template<class Token>
concept scope_token =
copyable<Token> &&
requires(const Token token) {
{ token.try_associate() } -> scope_association;
{ token.wrap(declval<test-sender >()) } -> sender_in<test-env >;
§ 33.14.1 © ISO/IEC
2338

===== PAGE 2350 =====

Dxxxx
};
}
5 A typeToken models scope_token only if:
—(5.1) no exceptions are thrown from copy construction, move construction, copy assignment, or move
assignment of objects of typeToken;
—(5.2) for an objecttokenof typeToken, token.try_associate()either returns an object that is not engaged
or acquires a new association withtoken’s associated scope and returns an engaged object that owns
that association; and
—(5.3) given an lvaluetoken of type (possibly const)Token, for all expressionssndr such thatdecltype((
sndr)) models sender:
—(5.3.1) token.wrap(sndr) is a valid expression,
—(5.3.2) decltype(token.wrap(sndr)) models sender, and
—(5.3.3) completion_signatures_of_t<decltype(token.wrap(sndr)), E> contains the same comple-
tion signatures ascompletion_signatures_of_t<decltype((sndr)), E> for all typesE such
that sender_in<decltype((sndr)), E> is modeled.
33.14.2 Counting Scopes [exec.counting.scopes]
33.14.2.1 General [exec.counting.scopes.general]
1 Scopes of typesimple_counting_scope and counting_scope maintain counts of associations. Let:
—(1.1) Scope be eithersimple_counting_scope or counting_scope,
—(1.2) scope be an object of typeScope,
—(1.3) tkn be an object of typeScope::token obtained fromscope.get_token(),
—(1.4) jsndr be a sender obtained fromscope.join(), and
—(1.5) op be an operation state obtained from connectingjsndr to a receiver.
During its lifetimescope goes through different states which govern what operations are allowed and the
result of these operations:
—(1.6) unused : a newly constructed object starts in theunused state.
—(1.7) open : when tkn.try_associate() is called whilescope is in theunused state, scope moves to the
open state.
—(1.8) open-and-joining : when the operation stateop is started whilescope is in theunused or open state,
scope moves to theopen-and-joining state.
—(1.9) closed : when scope.close() is called whilescope is in theopen state, scope moves to theclosed
state.
—(1.10) unused-and-closed : when scope.close() is called whilescope is in theunused state, scope moves
to theunused-and-closed state.
—(1.11) closed-and-joining : when scope.close() is called whilescope is in theopen-and-joining state
or the operation stateop is started whilescope is in theclosed or unused-and-closed state, scope
moves to theclosed-and-joining state.
—(1.12) joined : when the count of associations drops to zero whilescope is in theopen-and-joining or
closed-and-joining state, scope moves to thejoined state.
2 Recommended practice: Forsimple_counting_scope and counting_scope, implementations should store
the state and the count of associations in a single member of typesize_t.
3 Subclause 33.14.2 makes use of the following exposition-only entities:
struct scope-join-t {}; // exposition only
enum scope-state-type { // exposition only
unused , // exposition only
open , // exposition only
closed , // exposition only
open-and-joining , // exposition only
closed-and-joining , // exposition only
§ 33.14.2.1 © ISO/IEC
2339

===== PAGE 2351 =====

Dxxxx
unused-and-closed , // exposition only
joined , // exposition only
};
template<class Scope>
struct association-t ; // exposition only
4 The exposition-only class templateimpls-for (33.9.2) is specialized forscope-join-t as follows:
namespace std::execution {
template<>
struct impls-for <scope-join-t > : default-impls {
template<class Scope, class Rcvr>
struct state { // exposition only
struct rcvr-t { // exposition only
using receiver_concept = receiver_t;
Rcvr& rcvr ; // exposition only
void set_value() && noexcept {
execution::set_value(std::move(rcvr ));
}
template<class E>
void set_error(E&& e) && noexcept {
execution::set_error(std::move(rcvr ), std::forward<E>(e));
}
void set_stopped() && noexcept {
execution::set_stopped(std::move(rcvr ));
}
decltype(auto) get_env() const noexcept {
return execution::get_env(rcvr );
}
};
using sched-sender = // exposition only
decltype(schedule(get_scheduler(get_env(declval<Rcvr&>()))));
using op-t = // exposition only
connect_result_t<sched-sender , rcvr-t >;
Scope* scope ; // exposition only
Rcvr& receiver ; // exposition only
op-t op ; // exposition only
state (Scope* scope, Rcvr& rcvr) // exposition only
noexcept(nothrow-callable <connect_t, sched-sender , rcvr-t >)
: scope (scope),
receiver (rcvr),
op (connect(schedule(get_scheduler(get_env(rcvr))), rcvr-t (rcvr))) {}
void complete () noexcept { // exposition only
start(op );
}
void complete-inline () noexcept { // exposition only
set_value(std::move(receiver ));
}
};
static constexpr auto get-state = // exposition only
[]<class Rcvr>(auto&& sender, Rcvr& receiver)
noexcept(is_nothrow_constructible_v<state <Rcvr>, data-type <decltype(sender)>, Rcvr&>) {
auto[_, self] = sender;
§ 33.14.2.1 © ISO/IEC
2340

===== PAGE 2352 =====

Dxxxx
return state (self, receiver);
};
static constexpr auto start = // exposition only
[](auto& s, auto&) noexcept {
if (s.scope ->start-join-sender (s))
s.complete-inline ();
};
};
}
5 association-t is a class template, specializations of which modelscope_association and contain an
exposition-only member scope of type Scope*. For a class type Scope and an object assoc of type
association-t <Scope>:
—(5.1) assoc.scope points to its associated scope,
—(5.2) assoc is engaged whenassoc.scope != nullptr is true,
—(5.3) if assoc is engaged, thenassoc.try_associate() is equivalent toassoc.scope ->try-associate (),
and
—(5.4) the association owned byassoc is released by invokingassoc.scope ->disassociate ().
33.14.2.2 Simple Counting Scope [exec.scope.simple.counting]
33.14.2.2.1 General [exec.scope.simple.counting.general]
namespace std::execution {
class simple_counting_scope {
public:
// 33.14.2.2.4, token
struct token;
using assoc-t = association-t <simple_counting_scope>; // exposition only
static constexpr size_t max_associations = implementation-defined ;
// 33.14.2.2.2, constructor and destructor
simple_counting_scope() noexcept;
simple_counting_scope(simple_counting_scope&&) = delete;
~simple_counting_scope();
// 33.14.2.2.3, members
token get_token() noexcept;
void close() noexcept;
sender auto join() noexcept;
private:
size_t count ; // exposition only
scope-state-type state ; // exposition only
assoc-t try-associate () noexcept; // exposition only
void disassociate () noexcept; // exposition only
template<class State>
bool start-join-sender (State& state) noexcept; // exposition only
};
}
1 For purposes of determining the existence of a data race, get_token, close, join, try-associate ,
disassociate , and start-join-sender behave as atomic operations (6.10.2). These operations on a
single object of typesimple_counting_scope appear to occur in a single total order.
33.14.2.2.2 Constructor and Destructor [exec.simple.counting.ctor]
simple_counting_scope() noexcept;
1 Postconditions: count is 0 and state is unused .
§ 33.14.2.2.2 © ISO/IEC
2341

===== PAGE 2353 =====

Dxxxx
~simple_counting_scope();
2 Effects: If state is not one ofjoined , unused , orunused-and-closed , invokesterminate (14.6.2).
Otherwise, has no effects.
33.14.2.2.3 Members [exec.simple.counting.mem]
token get_token() noexcept;
1 Returns: An objectt of typesimple_counting_scope::token such thatt.scope == this is true.
void close() noexcept;
2 Effects: If state is
—(2.1) unused , then changesstate to unused-and-closed ;
—(2.2) open , then changesstate to closed ;
—(2.3) open-and-joining , then changesstate to closed-and-joining ;
—(2.4) otherwise, no effects.
3 Postconditions: Any subsequent call totry-associate () on *this returns false.
sender auto join() noexcept;
4 Returns: make-sender (scope-join-t (), this).
assoc-t try-associate () noexcept;
5 Effects: If count is equal tomax_associations, then no effects. Otherwise, ifstate is
—(5.1) unused , then incrementscount and changesstate to open ;
—(5.2) open or open-and-joining , then incrementscount ;
—(5.3) otherwise, no effects.
6 Returns: If count was incremented, an object of typeassoc-t that is engaged and associated with
*this, andassoc-t () otherwise.
void disassociate () noexcept;
7 Preconditions: count is greater than zero.
8 Effects: Decrementscount . If count is zero after decrementing andstate is open-and-joining or
closed-and-joining , changesstate to joined and callscomplete () on all objects registered with
*this.
[Note 1: Calling complete () on any registered object can cause*this to be destroyed. —end note]
template<class State>
bool start-join-sender (State& st) noexcept;
9 Effects: If state is
—(9.1) unused , unused-and-closed , orjoined , then changesstate to joined and returnstrue;
—(9.2) open or open-and-joining , then changesstate to open-and-joining , registersst with *this
and returnsfalse;
—(9.3) closed or closed-and-joining , then changesstate to closed-and-joining , registersst with
*this and returnsfalse.
33.14.2.2.4 Token [exec.simple.counting.token]
namespace std::execution {
struct simple_counting_scope::token {
template<sender Sender>
Sender&& wrap(Sender&& snd) const noexcept;
assoc-t try_associate() const noexcept;
private:
simple_counting_scope* scope ; // exposition only
};
}
§ 33.14.2.2.4 © ISO/IEC
2342

===== PAGE 2354 =====

Dxxxx
template<sender Sender>
Sender&& wrap(Sender&& snd) const noexcept;
1 Returns: std::forward<Sender>(snd).
assoc-t try_associate() const noexcept;
2 Effects: Equivalent to:return scope ->try-associate ();
33.14.2.3 Counting Scope [exec.scope.counting]
namespace std::execution {
class counting_scope {
public:
using assoc-t = association-t <counting_scope>; // exposition only
struct token {
template<sender Sender>
sender auto wrap(Sender&& snd) const noexcept(see below );
assoc-t try_associate() const noexcept;
private:
counting_scope* scope ; // exposition only
};
static constexpr size_t max_associations = implementation-defined ;
counting_scope() noexcept;
counting_scope(counting_scope&&) = delete;
~counting_scope();
token get_token() noexcept;
void close() noexcept;
sender auto join() noexcept;
void request_stop() noexcept;
private:
size_t count ; // exposition only
scope-state-type state ; // exposition only
inplace_stop_source s_source ; // exposition only
assoc-t try-associate () noexcept; // exposition only
void disassociate () noexcept; // exposition only
template<class State>
bool start-join-sender (State& state) noexcept; // exposition only
};
}
1 counting_scope differs fromsimple_counting_scope by adding support for cancellation. Unless specified
below, the semantics of members ofcounting_scope are the same as the corresponding members ofsimple_-
counting_scope.
token get_token() noexcept;
2 Returns: An objectt of typecounting_scope::token such thatt.scope == this is true.
void request_stop() noexcept;
3 Effects: Equivalent tos_source .request_stop().
4 Remarks: Calls torequest_stop do not introduce data races.
assoc-t try-associate () noexcept;
5 Effects: If count is equal tomax_associations, then no effects. Otherwise, ifstate is
—(5.1) unused , then incrementscount and changesstate to open ;
—(5.2) open or open-and-joining , then incrementscount ;
§ 33.14.2.3 © ISO/IEC
2343

===== PAGE 2355 =====

Dxxxx
—(5.3) otherwise, no effects.
6 Returns: If count was incremented, an object of typeassoc-t that is engaged and associated with
*this, andassoc-t () otherwise.
template<sender Sender>
sender auto counting_scope::token::wrap(Sender&& snd) const
noexcept(is_nothrow_constructible_v<remove_cvref_t<Sender>, Sender>);
7 Effects: Equivalent to:
return stop-when (std::forward<Sender>(snd), scope ->s_source .get_token());
assoc-t counting_scope::token::try_associate() const noexcept;
8 Effects: Equivalent to:return scope ->try-associate ();
33.15 Parallel scheduler [exec.par.scheduler]
namespace std::execution {
class parallel_scheduler {
unspecified
};
}
1 parallel_scheduler models scheduler.
2 Let sch be an object of type parallel_scheduler, and let BACKEND-OF (sch) be *ptr, where sch is
associated withptr.
3 The expression get_forward_progress_guarantee(sch) has the valueforward_progress_guarantee::
parallel.
4 Let sch2 be an object of typeparallel_scheduler. Two objectssch and sch2 compare equal if and only if
BACKEND-OF (sch) and BACKEND-OF (sch2) refer to the same object.
5 Let rcvr be a receiver. Aproxy forrcvr with baseB is an lvaluer of typeB such that:
—(5.1) r.set_value() has effects equivalent toset_value(std::move(rcvr)).
—(5.2) r.set_error(e), whereeisan exception_ptrobject, haseffectsequivalentto set_error(std::move(
rcvr), std::move(e)).
—(5.3) r.set_stopped() has effects equivalent toset_stopped(std::move(rcvr)).
6 A preallocated backend storage for a proxyr is an objects of typespan<byte> such that the ranges remains
valid and may be overwritten until one ofset_value, set_error, orset_stopped is called onr.
[Note 1: The storage referenced bys can be used as temporary storage for operations launched via calls toparallel_-
scheduler_backend. —end note]
7 A bulk chunked proxy forrcvr with callablef and argumentsargs is a proxyr for rcvr with basesystem_-
context_replaceability::bulk_item_receiver_proxy such thatr.execute(i, j) for indices i and j
has effects equivalent tof(i, j, args...).
8 A bulk unchunked proxy forrcvr with callablef and argumentsargs is a proxyr for rcvr with basesystem_-
context_replaceability::bulk_item_receiver_proxy such thatr.execute(i, i + 1) for indexi has
effects equivalent tof(i, args...).
9 Let b be BACKEND-OF (sch), letsndr be the object returned byschedule(sch), and letrcvr be a receiver.
If rcvr is connected tosndr and the resulting operation state is started, then:
—(9.1) If sndr completes successfully, thenb.schedule(r, s) is called, where
—(9.1.1) r is a proxy forrcvr with basesystem_context_replaceability::receiver_proxy and
—(9.1.2) s is a preallocated backend storage forr.
—(9.2) All other completion operations are forwarded unchanged.
10 parallel_scheduler provides a customized implementation of thebulk_chunked algorithm (33.9.12.11).
If a receiverrcvr is connected to the sender returned bybulk_chunked(sndr, pol, shape, f) and the
resulting operation state is started, then:
—(10.1) If sndr completes with valuesvals, letargs be a pack of lvalue subexpressions designatingvals, then
b.schedule_bulk_chunked(shape, r, s) is called, where
§ 33.15 © ISO/IEC
2344

===== PAGE 2356 =====

Dxxxx
—(10.1.1) r is a bulk chunked proxy forrcvr with callablef and argumentsargs and
—(10.1.2) s is a preallocated backend storage forr.
—(10.2) All other completion operations are forwarded unchanged.
[Note 2: Customizing the behavior ofbulk_chunked affects the default implementation ofbulk. —end note]
11 parallel_scheduler provides a customized implementation of thebulk_unchunked algorithm (33.9.12.11).
If a receiverrcvr is connected to the sender returned bybulk_unchunked(sndr, pol, shape, f) and the
resulting operation state is started, then:
—(11.1) If sndr completes with valuesvals, letargs be a pack of lvalue subexpressions designatingvals, then
b.schedule_bulk_unchunked(shape, r, s) is called, where
—(11.1.1) r is a bulk unchunked proxy forrcvr with callablef and argumentsargs and
—(11.1.2) s is a preallocated backend storage forr.
—(11.2) All other completion operations are forwarded unchanged.
parallel_scheduler get_parallel_scheduler();
12 Effects: Let eb be the result ofsystem_context_replaceability::query_parallel_scheduler_-
backend(). If eb == nullptr is true, calls terminate (14.6.2). Otherwise, returns a parallel_-
scheduler object associated witheb.
33.16 Namespace system_context_replaceability [exec.sysctxrepl]
33.16.1 General [exec.sysctxrepl.general]
1 Facilities in thesystem_context_replaceability namespace allow users to replace the default implementa-
tion ofparallel_scheduler.
33.16.2 Receiver proxies [exec.sysctxrepl.recvproxy]
namespace std::execution::system_context_replaceability {
struct receiver_proxy {
virtual ~receiver_proxy() = default;
protected:
virtual bool query-env(unspecified) noexcept = 0; // exposition only
public:
virtual void set_value() noexcept = 0;
virtual void set_error(exception_ptr) noexcept = 0;
virtual void set_stopped() noexcept = 0;
template<class P, class-type Query>
optional<P> try_query(Query q) noexcept;
};
struct bulk_item_receiver_proxy : receiver_proxy {
virtual void execute(size_t, size_t) noexcept = 0;
};
}
1 receiver_proxy represents a receiver that will be notified by the implementations ofparallel_scheduler_-
backend to trigger the completion operations.bulk_item_receiver_proxy is derived fromreceiver_proxy
and is used forbulk_chunked and bulk_unchunked customizations that will also receive notifications from
implementations ofparallel_scheduler_backend corresponding to different iterations.
template<class P, class-type Query>
optional<P> try_query(Query q) noexcept;
2 Mandates: P is a cv-unqualified non-array object type.
3 Returns: Let env be the environment of the receiver represented by*this. If
—(3.1) Query is not a member of an implementation-defined set of supported queries; or
—(3.2) P is not a member of an implementation-defined set of supported result types forQuery; or
§ 33.16.2 © ISO/IEC
2345

===== PAGE 2357 =====

Dxxxx
—(3.3) the expressionq(env) is not well-formed or does not have typecv P,
then returnsnullopt. Otherwise, returnsq(env).
4 Remarks: get_stop_token_t is in the implementation-defined set of supported queries, andinplace_-
stop_token is a member of the implementation-defined set of supported result types forget_stop_-
token_t.
33.16.3 query_parallel_scheduler_backend [exec.sysctxrepl.query]
shared_ptr<parallel_scheduler_backend> query_parallel_scheduler_backend();
1 query_parallel_scheduler_backend() returns the implementation object for a parallel scheduler.
2 Returns: An objectp, such thatp.get() points to aparallel_scheduler_backend object that is a
base-class subobject of some most derived objecto within its lifetime. The lifetime ofo does not end
as long as there exists ashared_ptr object q within its lifetime such thatq.owner_equal(p) is true.
3 Remarks: This function is replaceable (9.6.5).
33.16.4 Class parallel_scheduler_backend [exec.sysctxrepl.psb]
namespace std::execution::system_context_replaceability {
struct parallel_scheduler_backend {
virtual ~parallel_scheduler_backend() = default;
virtual void schedule(receiver_proxy&, span<byte>) noexcept = 0;
virtual void schedule_bulk_chunked(size_t, bulk_item_receiver_proxy&,
span<byte>) noexcept = 0;
virtual void schedule_bulk_unchunked(size_t, bulk_item_receiver_proxy&,
span<byte>) noexcept = 0;
};
}
virtual void schedule(receiver_proxy& r, span<byte> s) noexcept = 0;
1 Preconditions: The ends of the lifetime of*this, of the lifetime of the object referred to byr, and of
the duration of any storage referenced bys all happen after the beginning of the evaluation of the call
to set_value, set_error, orset_stopped on r (see below).
2 Effects: A derived class shall implement this function such that:
—(2.1) One of the following expressions is evaluated:
—(2.1.1) r.set_value(), if no error occurs, and the work is successful;
—(2.1.2) r.set_error(eptr), if an error occurs, whereeptr is an object of typeexception_ptr;
—(2.1.3) r.set_stopped(), if the work is canceled.
—(2.2) Any call tor.set_value() happens on an execution agent of the execution context represented
by *this.
3 Remarks: The storage referenced bys may be used by*this as temporary storage for the duration of
the operation launched by this call.
virtual void schedule_bulk_chunked(size_t n, bulk_item_receiver_proxy& r,
span<byte> s) noexcept = 0;
4 Preconditions: The ends of the lifetime of*this, of the lifetime of the object referred to byr, and of
the duration of any storage referenced bys all happen after the beginning of the evaluation of the call
to set_value, set_error, orset_stopped on r (see below).
5 Effects: A derived class shall implement this function such that:
—(5.1) Eventually, one of the following expressions is evaluated:
—(5.1.1) r.set_value(), if no error occurs, and the work is successful;
—(5.1.2) r.set_error(eptr), if an error occurs, whereeptr is an object of typeexception_ptr;
—(5.1.3) r.set_stopped(), if the work is canceled.
§ 33.16.4 © ISO/IEC
2346

===== PAGE 2358 =====

Dxxxx
—(5.2) If r.execute(b, e) is called, thenb and e are in the range[0,n] and b <e.
—(5.3) For eachiin [0,n), there is at most one call tor.execute(b, e) such thatiis in the range[b,e).
—(5.4) If r.set_value() is called, then for eachi in [0,n), there is exactly one call tor.execute(b, e)
such thati is in the range[b,e).
—(5.5) All calls toexecute on r happen before the call to eitherset_value, set_error, orset_stopped
on r.
—(5.6) All calls toexecute and set_value on r are made on execution agents of the execution context
represented by*this.
6 Remarks: The storage referenced bys may be used by*this as temporary storage for the duration of
the operation launched by this call.
virtual void schedule_bulk_unchunked(size_t n, bulk_item_receiver_proxy& r,
span<byte> s) noexcept = 0;
7 Preconditions: The ends of the lifetime of*this, of the lifetime of the object referred to byr, and of
the duration of any storage referenced bys all happen after the beginning of the evaluation of the call
to set_value, set_error, orset_stopped on r (see below).
8 Effects: A derived class shall implement this function such that:
—(8.1) Eventually, one of the following expressions is evaluated:
—(8.1.1) r.set_value(), if no error occurs, and the work is successful;
—(8.1.2) r.set_error(eptr), if an error occurs, whereeptr is an object of typeexception_ptr;
—(8.1.3) r.set_stopped(), if the work is canceled.
—(8.2) If r.execute(b, e) is called, thenb is in the range[0,n) and e is equal tob + 1. For eachi in
[0,n), there is at most one call tor.execute(i, i + 1).
—(8.3) If r.set_value() is called, then for eachiin [0,n), there is exactly one call tor.execute(i, i +
1).
—(8.4) All calls toexecute on r happen before the call to eitherset_value, set_error, orset_stopped
on r.
—(8.5) All calls toexecute and set_value on r are made on execution agents of the execution context
represented by*this.
9 Remarks: The storage referenced bys may be used by*this as temporary storage for the duration of
the operation launched by this call.
§ 33.16.4 © ISO/IEC
2347

===== PAGE 2359 =====

Dxxxx
Annex A
(informative)
Grammar summary [gram]
A.1 General [gram.general]
1 This summary of C++ grammar is intended to be an aid to comprehension. It is not an exact statement
of the language. In particular, the grammar described here accepts a superset of valid C++ constructs.
Disambiguation rules (8.11, 9.2, 6.5.2) are applied to distinguish expressions from declarations. Further,
access control, ambiguity, and type rules are used to weed out syntactically valid but meaningless constructs.
A.2 Keywords [gram.key]
1 New context-dependent keywords are introduced into a program bytypedef (9.2.4), namespace (9.9.2),
class (Clause 11), enumeration (9.8.1), andtemplate (Clause 13) declarations.
typedef-name:
identifier
simple-template-id
namespace-name:
identifier
namespace-alias
namespace-alias:
identifier
class-name:
identifier
simple-template-id
enum-name:
identifier
template-name:
identifier
A.3 Lexical conventions [gram.lex]
n-char:
any member of the translation character set except theu+007d right curly bracketor new-line
character
n-char-sequence:
n-char n-char-sequenceopt
named-universal-character:
\N{ n-char-sequence }
hex-quad:
hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
simple-hexadecimal-digit-sequence:
hexadecimal-digit simple-hexadecimal-digit-sequenceopt
universal-character-name:
\u hex-quad
\U hex-quad hex-quad
\u{ simple-hexadecimal-digit-sequence }
named-universal-character
§ A.3 © ISO/IEC
2348

===== PAGE 2360 =====

Dxxxx
preprocessing-token:
header-name
import-keyword
module-keyword
export-keyword
identifier
pp-number
character-literal
user-defined-character-literal
string-literal
user-defined-string-literal
preprocessing-op-or-punc
each non-whitespace character that cannot be one of the above
header-name:
< h-char-sequence >
" q-char-sequence "
h-char-sequence:
h-char h-char-sequenceopt
h-char:
any member of the translation character set except new-line andu+003e greater-than sign
q-char-sequence:
q-char q-char-sequenceopt
q-char:
any member of the translation character set except new-line andu+0022 quotation mark
pp-number:
digit
. digit
pp-number identifier-continue
pp-number ’ digit
pp-number ’ nondigit
pp-number e sign
pp-number E sign
pp-number p sign
pp-number P sign
pp-number .
preprocessing-op-or-punc:
preprocessing-operator
operator-or-punctuator
preprocessing-operator: one of
# ## %: %:%:
operator-or-punctuator: one of
{ } [ ] ( ) [: :]
<% %> <: :> ; : ...
? :: . .* -> ->* ^^ ~
! + - * / % ^ & |
= += -= *= /= %= ^= &= |=
== != < > <= >= <=> && ||
<< >> <<= >>= ++ -- ,
and or xor not bitand bitor compl
and_eq or_eq xor_eq not_eq
token:
identifier
keyword
literal
operator-or-punctuator
identifier:
identifier-start
identifier identifier-continue
§ A.3 © ISO/IEC
2349

===== PAGE 2361 =====

Dxxxx
identifier-start:
nondigit
an element of the translation character set with the Unicode property XID_Start
identifier-continue:
digit
nondigit
an element of the translation character set with the Unicode property XID_Continue
nondigit: one of
a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z _
digit: one of
0 1 2 3 4 5 6 7 8 9
keyword:
any identifier listed in Table 5
import-keyword
module-keyword
export-keyword
literal:
integer-literal
character-literal
floating-point-literal
string-literal
boolean-literal
pointer-literal
user-defined-literal
integer-literal:
binary-literal integer-suffixopt
octal-literal integer-suffixopt
decimal-literal integer-suffixopt
hexadecimal-literal integer-suffixopt
binary-literal:
0b binary-digit
0B binary-digit
binary-literal ’opt binary-digit
octal-literal:
0
octal-literal ’opt octal-digit
decimal-literal:
nonzero-digit
decimal-literal ’opt digit
hexadecimal-literal:
hexadecimal-prefix hexadecimal-digit-sequence
binary-digit: one of
0 1
octal-digit: one of
0 1 2 3 4 5 6 7
nonzero-digit: one of
1 2 3 4 5 6 7 8 9
hexadecimal-prefix: one of
0x 0X
hexadecimal-digit-sequence:
hexadecimal-digit
hexadecimal-digit-sequence ’opt hexadecimal-digit
§ A.3 © ISO/IEC
2350

===== PAGE 2362 =====

Dxxxx
hexadecimal-digit: one of
0 1 2 3 4 5 6 7 8 9
a b c d e f
A B C D E F
integer-suffix:
unsigned-suffix long-suffixopt
unsigned-suffix long-long-suffixopt
unsigned-suffix size-suffixopt
long-suffix unsigned-suffixopt
long-long-suffix unsigned-suffixopt
size-suffix unsigned-suffixopt
unsigned-suffix: one of
u U
long-suffix: one of
l L
long-long-suffix: one of
ll LL
size-suffix: one of
z Z
character-literal:
encoding-prefixopt ’ c-char-sequence ’
encoding-prefix: one of
u8 u U L
c-char-sequence:
c-char c-char-sequenceopt
c-char:
basic-c-char
escape-sequence
universal-character-name
basic-c-char:
any member of the translation character set except theu+0027 apostrophe,
u+005c reverse solidus, or new-line character
escape-sequence:
simple-escape-sequence
numeric-escape-sequence
conditional-escape-sequence
simple-escape-sequence:
\ simple-escape-sequence-char
simple-escape-sequence-char: one of
’ " ? \ a b f n r t v
numeric-escape-sequence:
octal-escape-sequence
hexadecimal-escape-sequence
simple-octal-digit-sequence:
octal-digit simple-octal-digit-sequenceopt
octal-escape-sequence:
\ octal-digit
\ octal-digit octal-digit
\ octal-digit octal-digit octal-digit
\o{ simple-octal-digit-sequence }
hexadecimal-escape-sequence:
\x simple-hexadecimal-digit-sequence
\x{ simple-hexadecimal-digit-sequence }
conditional-escape-sequence:
\ conditional-escape-sequence-char
§ A.3 © ISO/IEC
2351

===== PAGE 2363 =====

Dxxxx
conditional-escape-sequence-char:
any member of the basic character set that is not anoctal-digit, asimple-escape-sequence-char, or the
characters N, o, u, U, orx
floating-point-literal:
decimal-floating-point-literal
hexadecimal-floating-point-literal
decimal-floating-point-literal:
fractional-constant exponent-partopt floating-point-suffixopt
digit-sequence exponent-part floating-point-suffixopt
hexadecimal-floating-point-literal:
hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-point-suffixopt
hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-point-suffixopt
fractional-constant:
digit-sequenceopt . digit-sequence
digit-sequence .
hexadecimal-fractional-constant:
hexadecimal-digit-sequenceopt . hexadecimal-digit-sequence
hexadecimal-digit-sequence .
exponent-part:
e signopt digit-sequence
E signopt digit-sequence
binary-exponent-part:
p signopt digit-sequence
P signopt digit-sequence
sign: one of
+ -
digit-sequence:
digit
digit-sequence ’opt digit
floating-point-suffix: one of
f l f16 f32 f64 f128 bf16 F L F16 F32 F64 F128 BF16
string-literal:
encoding-prefixopt plain-string-literal
encoding-prefixopt R raw-string
plain-string-literal:
" s-char-sequenceopt "
s-char-sequence:
s-char s-char-sequenceopt
s-char:
basic-s-char
escape-sequence
universal-character-name
basic-s-char:
any member of the translation character set except theu+0022 quotation mark,
u+005c reverse solidus, or new-line character
raw-string:
" d-char-sequenceopt ( r-char-sequenceopt ) d-char-sequenceopt "
r-char-sequence:
r-char r-char-sequenceopt
r-char:
any member of the translation character set, except au+0029 right parenthesisfollowed by
the initiald-char-sequence (which may be empty) followed by au+0022 quotation mark
d-char-sequence:
d-char d-char-sequenceopt
§ A.3 © ISO/IEC
2352

===== PAGE 2364 =====

Dxxxx
d-char:
any member of the basic character set except:
u+0020 space, u+0028 left parenthesis, u+0029 right parenthesis, u+005c reverse solidus,
u+0009 character tabulation, u+000b line tabulation, u+000c form feed, and new-line
unevaluated-string:
string-literal
boolean-literal:
false
true
pointer-literal:
nullptr
user-defined-literal:
user-defined-integer-literal
user-defined-floating-point-literal
user-defined-string-literal
user-defined-character-literal
user-defined-integer-literal:
decimal-literal ud-suffix
octal-literal ud-suffix
hexadecimal-literal ud-suffix
binary-literal ud-suffix
user-defined-floating-point-literal:
fractional-constant exponent-partopt ud-suffix
digit-sequence exponent-part ud-suffix
hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part ud-suffix
hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part ud-suffix
user-defined-string-literal:
string-literal ud-suffix
user-defined-character-literal:
character-literal ud-suffix
ud-suffix:
identifier
A.4 Basics [gram.basic]
splice-specifier:
[: constant-expression :]
splice-specialization-specifier:
splice-specifier < template-argument-listopt >
translation-unit:
declaration-seqopt
global-module-fragmentopt module-declaration declaration-seqopt private-module-fragmentopt
A.5 Expressions [gram.expr]
primary-expression:
literal
this
( expression )
id-expression
lambda-expression
fold-expression
requires-expression
splice-expression
id-expression:
unqualified-id
qualified-id
pack-index-expression
§ A.5 © ISO/IEC
2353

===== PAGE 2365 =====

Dxxxx
unqualified-id:
identifier
operator-function-id
conversion-function-id
literal-operator-id
~ type-name
~ computed-type-specifier
template-id
qualified-id:
nested-name-specifier templateopt unqualified-id
nested-name-specifier:
::
type-name ::
namespace-name ::
computed-type-specifier ::
splice-scope-specifier ::
nested-name-specifier identifier::
nested-name-specifier templateopt simple-template-id ::
splice-scope-specifier:
splice-specifier
templateopt splice-specialization-specifier
pack-index-expression:
id-expression ... [ constant-expression ]
lambda-expression:
lambda-introducer attribute-specifier-seqopt lambda-declarator compound-statement
lambda-introducer < template-parameter-list > requires-clauseopt attribute-specifier-seqopt
lambda-declarator compound-statement
lambda-introducer:
[ lambda-captureopt ]
lambda-declarator:
lambda-specifier-seq noexcept-specifieropt attribute-specifier-seqopt trailing-return-typeopt
function-contract-specifier-seqopt
noexcept-specifier attribute-specifier-seqopt trailing-return-typeopt function-contract-specifier-seqopt
trailing-return-typeopt function-contract-specifier-seqopt
( parameter-declaration-clause ) lambda-specifier-seqopt noexcept-specifieropt attribute-specifier-seqopt
trailing-return-typeopt requires-clauseopt function-contract-specifier-seqopt
lambda-specifier:
consteval
constexpr
mutable
static
lambda-specifier-seq:
lambda-specifier lambda-specifier-seqopt
lambda-capture:
capture-default
capture-list
capture-default , capture-list
capture-default:
&
=
capture-list:
capture
capture-list , capture
capture:
simple-capture
init-capture
§ A.5 © ISO/IEC
2354

===== PAGE 2366 =====

Dxxxx
simple-capture:
identifier ...opt
& identifier ...opt
this
* this
init-capture:
...opt identifier initializer
& ...opt identifier initializer
fold-expression:
( cast-expression fold-operator... )
( ... fold-operator cast-expression)
( cast-expression fold-operator... fold-operator cast-expression)
fold-operator: one of
+ - * / % ^ & | << >>
+= -= *= /= %= ^= &= |= <<= >>= =
== != < > <= >= && || , .* ->*
requires-expression:
requires requirement-parameter-listopt requirement-body
requirement-parameter-list:
( parameter-declaration-clause )
requirement-body:
{ requirement-seq }
requirement-seq:
requirement requirement-seqopt
requirement:
simple-requirement
type-requirement
compound-requirement
nested-requirement
simple-requirement:
expression ;
type-requirement:
typename nested-name-specifieropt type-name ;
typename splice-specifier ;
typename splice-specialization-specifier ;
compound-requirement:
{ expression } noexceptopt return-type-requirementopt ;
return-type-requirement:
-> type-constraint
nested-requirement:
requires constraint-expression ;
splice-expression:
splice-specifier
template splice-specifier
template splice-specialization-specifier
§ A.5 © ISO/IEC
2355

===== PAGE 2367 =====

Dxxxx
postfix-expression:
primary-expression
postfix-expression [ expression-listopt ]
postfix-expression ( expression-listopt )
simple-type-specifier ( expression-listopt )
typename-specifier ( expression-listopt )
simple-type-specifier braced-init-list
typename-specifier braced-init-list
postfix-expression . templateopt id-expression
postfix-expression . splice-expression
postfix-expression -> templateopt id-expression
postfix-expression -> splice-expression
postfix-expression ++
postfix-expression --
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
const_cast < type-id > ( expression )
typeid ( expression )
typeid ( type-id )
expression-list:
initializer-list
unary-expression:
postfix-expression
unary-operator cast-expression
++ cast-expression
-- cast-expression
await-expression
sizeof unary-expression
sizeof ( type-id )
sizeof ... (identifier )
alignof ( type-id )
noexcept-expression
new-expression
delete-expression
reflect-expression
unary-operator: one of
* & + - ! ~
await-expression:
co_await cast-expression
noexcept-expression:
noexcept ( expression )
new-expression:
::opt new new-placementopt new-type-id new-initializeropt
::opt new new-placementopt ( type-id ) new-initializeropt
new-placement:
( expression-list )
new-type-id:
type-specifier-seq new-declaratoropt
new-declarator:
ptr-operator new-declaratoropt
noptr-new-declarator
noptr-new-declarator:
[ expressionopt ] attribute-specifier-seqopt
noptr-new-declarator [ constant-expression ] attribute-specifier-seqopt
new-initializer:
( expression-listopt )
braced-init-list
§ A.5 © ISO/IEC
2356

===== PAGE 2368 =====

Dxxxx
delete-expression:
::opt delete cast-expression
::opt delete [ ]cast-expression
reflect-expression:
^^ ::
^^ reflection-name
^^ type-id
^^ id-expression
reflection-name:
nested-name-specifieropt identifier
nested-name-specifier template identifier
cast-expression:
unary-expression
( type-id ) cast-expression
pm-expression:
cast-expression
pm-expression .* cast-expression
pm-expression ->* cast-expression
multiplicative-expression:
pm-expression
multiplicative-expression * pm-expression
multiplicative-expression / pm-expression
multiplicative-expression % pm-expression
additive-expression:
multiplicative-expression
additive-expression + multiplicative-expression
additive-expression - multiplicative-expression
shift-expression:
additive-expression
shift-expression << additive-expression
shift-expression >> additive-expression
compare-expression:
shift-expression
compare-expression <=> shift-expression
relational-expression:
compare-expression
relational-expression < compare-expression
relational-expression > compare-expression
relational-expression <= compare-expression
relational-expression >= compare-expression
equality-expression:
relational-expression
equality-expression == relational-expression
equality-expression != relational-expression
and-expression:
equality-expression
and-expression & equality-expression
exclusive-or-expression:
and-expression
exclusive-or-expression ^ and-expression
inclusive-or-expression:
exclusive-or-expression
inclusive-or-expression | exclusive-or-expression
logical-and-expression:
inclusive-or-expression
logical-and-expression && inclusive-or-expression
§ A.5 © ISO/IEC
2357

===== PAGE 2369 =====

Dxxxx
logical-or-expression:
logical-and-expression
logical-or-expression || logical-and-expression
conditional-expression:
logical-or-expression
logical-or-expression ? expression : assignment-expression
yield-expression:
co_yield assignment-expression
co_yield braced-init-list
throw-expression:
throw assignment-expressionopt
assignment-expression:
conditional-expression
yield-expression
throw-expression
logical-or-expression assignment-operator initializer-clause
assignment-operator: one of
= *= /= %= += -= >>= <<= &= ^= |=
expression:
assignment-expression
expression , assignment-expression
constant-expression:
conditional-expression
A.6 Statements [gram.stmt]
statement:
labeled-statement
attribute-specifier-seqopt expression-statement
attribute-specifier-seqopt compound-statement
attribute-specifier-seqopt selection-statement
attribute-specifier-seqopt iteration-statement
attribute-specifier-seqopt expansion-statement
attribute-specifier-seqopt jump-statement
attribute-specifier-seqopt assertion-statement
declaration-statement
attribute-specifier-seqopt try-block
init-statement:
expression-statement
simple-declaration
alias-declaration
condition:
expression
attribute-specifier-seqopt decl-specifier-seq declarator brace-or-equal-initializer
structured-binding-declaration initializer
for-range-declaration:
attribute-specifier-seqopt decl-specifier-seq declarator
structured-binding-declaration
for-range-initializer:
expr-or-braced-init-list
label:
attribute-specifier-seqopt identifier :
attribute-specifier-seqopt case constant-expression :
attribute-specifier-seqopt default :
labeled-statement:
label statement
expression-statement:
expressionopt ;
§ A.6 © ISO/IEC
2358

===== PAGE 2370 =====

Dxxxx
compound-statement:
{ statement-seqopt label-seqopt }
statement-seq:
statement statement-seqopt
label-seq:
label label-seqopt
selection-statement:
if constexpropt ( init-statementopt condition ) statement
if constexpropt ( init-statementopt condition ) statement else statement
if !opt consteval compound-statement
if !opt consteval compound-statement else statement
switch ( init-statementopt condition ) statement
iteration-statement:
while ( condition ) statement
do statement while ( expression ) ;
for ( init-statement conditionopt ; expressionopt ) statement
for ( init-statementopt for-range-declaration : for-range-initializer ) statement
expansion-statement:
template for (init-statementopt for-range-declaration : expansion-initializer ) compound-statement
expansion-initializer:
expression
expansion-init-list
expansion-init-list:
{ expression-list ,opt }
{ }
jump-statement:
break ;
continue ;
return expr-or-braced-init-listopt ;
coroutine-return-statement
goto identifier ;
coroutine-return-statement:
co_return expr-or-braced-init-listopt ;
assertion-statement:
contract_assert attribute-specifier-seqopt ( conditional-expression ) ;
declaration-statement:
block-declaration
A.7 Declarations [gram.dcl]
declaration-seq:
declaration declaration-seqopt
declaration:
name-declaration
special-declaration
name-declaration:
block-declaration
nodeclspec-function-declaration
function-definition
friend-type-declaration
template-declaration
deduction-guide
linkage-specification
namespace-definition
empty-declaration
attribute-declaration
module-import-declaration
§ A.7 © ISO/IEC
2359

===== PAGE 2371 =====

Dxxxx
special-declaration:
explicit-instantiation
explicit-specialization
export-declaration
block-declaration:
simple-declaration
asm-declaration
namespace-alias-definition
using-declaration
using-enum-declaration
using-directive
static_assert-declaration
consteval-block-declaration
alias-declaration
opaque-enum-declaration
nodeclspec-function-declaration:
attribute-specifier-seqopt declarator ;
alias-declaration:
using identifier attribute-specifier-seqopt = defining-type-id ;
sb-identifier:
...opt identifier attribute-specifier-seqopt
sb-identifier-list:
sb-identifier
sb-identifier-list , sb-identifier
structured-binding-declaration:
attribute-specifier-seqopt decl-specifier-seq ref-qualifieropt [ sb-identifier-list ]
simple-declaration:
decl-specifier-seq init-declarator-listopt ;
attribute-specifier-seq decl-specifier-seq init-declarator-list;
structured-binding-declaration initializer;
static_assert-message:
unevaluated-string
constant-expression
static_assert-declaration:
static_assert ( constant-expression ) ;
static_assert ( constant-expression , static_assert-message ) ;
consteval-block-declaration:
consteval compound-statement
empty-declaration:
;
attribute-declaration:
attribute-specifier-seq ;
decl-specifier:
storage-class-specifier
defining-type-specifier
function-specifier
friend
typedef
constexpr
consteval
constinit
inline
decl-specifier-seq:
decl-specifier attribute-specifier-seqopt
decl-specifier decl-specifier-seq
§ A.7 © ISO/IEC
2360

===== PAGE 2372 =====

Dxxxx
storage-class-specifier:
static
thread_local
extern
mutable
function-specifier:
virtual
explicit-specifier
explicit-specifier:
explicit ( constant-expression )
explicit
typedef-name:
identifier
simple-template-id
type-specifier:
simple-type-specifier
elaborated-type-specifier
typename-specifier
cv-qualifier
type-specifier-seq:
type-specifier attribute-specifier-seqopt
type-specifier type-specifier-seq
defining-type-specifier:
type-specifier
class-specifier
enum-specifier
defining-type-specifier-seq:
defining-type-specifier attribute-specifier-seqopt
defining-type-specifier defining-type-specifier-seq
simple-type-specifier:
nested-name-specifieropt type-name
nested-name-specifier template simple-template-id
computed-type-specifier
placeholder-type-specifier
nested-name-specifieropt template-name
char
char8_t
char16_t
char32_t
wchar_t
bool
short
int
long
signed
unsigned
float
double
void
type-name:
class-name
enum-name
typedef-name
computed-type-specifier:
decltype-specifier
pack-index-specifier
splice-type-specifier
pack-index-specifier:
typedef-name ... [ constant-expression ]
§ A.7 © ISO/IEC
2361

===== PAGE 2373 =====

Dxxxx
elaborated-type-specifier:
class-key attribute-specifier-seqopt nested-name-specifieropt identifier
class-key simple-template-id
class-key nested-name-specifiertemplateopt simple-template-id
enum nested-name-specifieropt identifier
decltype-specifier:
decltype ( expression )
placeholder-type-specifier:
type-constraintopt auto
type-constraintopt decltype ( auto )
splice-type-specifier:
typenameopt splice-specifier
typenameopt splice-specialization-specifier
init-declarator-list:
init-declarator
init-declarator-list , init-declarator
init-declarator:
declarator initializer
declarator requires-clauseopt function-contract-specifier-seqopt
declarator:
ptr-declarator
noptr-declarator parameters-and-qualifiers trailing-return-type
ptr-declarator:
noptr-declarator
ptr-operator ptr-declarator
noptr-declarator:
declarator-id attribute-specifier-seqopt
noptr-declarator parameters-and-qualifiers
noptr-declarator [ constant-expressionopt ] attribute-specifier-seqopt
( ptr-declarator )
parameters-and-qualifiers:
( parameter-declaration-clause ) cv-qualifier-seqopt
ref-qualifieropt noexcept-specifieropt attribute-specifier-seqopt
trailing-return-type:
-> type-id
ptr-operator:
* attribute-specifier-seqopt cv-qualifier-seqopt
& attribute-specifier-seqopt
&& attribute-specifier-seqopt
nested-name-specifier * attribute-specifier-seqopt cv-qualifier-seqopt
cv-qualifier-seq:
cv-qualifier cv-qualifier-seqopt
cv-qualifier:
const
volatile
ref-qualifier:
&
&&
declarator-id:
...opt id-expression
type-id:
type-specifier-seq abstract-declaratoropt
defining-type-id:
defining-type-specifier-seq abstract-declaratoropt
§ A.7 © ISO/IEC
2362

===== PAGE 2374 =====

Dxxxx
abstract-declarator:
ptr-abstract-declarator
noptr-abstract-declaratoropt parameters-and-qualifiers trailing-return-type
abstract-pack-declarator
ptr-abstract-declarator:
noptr-abstract-declarator
ptr-operator ptr-abstract-declaratoropt
noptr-abstract-declarator:
noptr-abstract-declaratoropt parameters-and-qualifiers
noptr-abstract-declaratoropt [ constant-expressionopt ] attribute-specifier-seqopt
( ptr-abstract-declarator )
abstract-pack-declarator:
noptr-abstract-pack-declarator
ptr-operator abstract-pack-declarator
noptr-abstract-pack-declarator:
noptr-abstract-pack-declarator parameters-and-qualifiers
...
parameter-declaration-clause:
...
parameter-declaration-listopt
parameter-declaration-list , ...
parameter-declaration-list ...
parameter-declaration-list:
parameter-declaration
parameter-declaration-list , parameter-declaration
parameter-declaration:
attribute-specifier-seqopt thisopt decl-specifier-seq declarator
attribute-specifier-seqopt decl-specifier-seq declarator= initializer-clause
attribute-specifier-seqopt thisopt decl-specifier-seq abstract-declaratoropt
attribute-specifier-seqopt decl-specifier-seq abstract-declaratoropt = initializer-clause
function-contract-specifier-seq:
function-contract-specifier function-contract-specifier-seqopt
function-contract-specifier:
precondition-specifier
postcondition-specifier
precondition-specifier:
pre attribute-specifier-seqopt ( conditional-expression )
postcondition-specifier:
post attribute-specifier-seqopt ( result-name-introduceropt conditional-expression )
attributed-identifier:
identifier attribute-specifier-seqopt
result-name-introducer:
attributed-identifier :
initializer:
brace-or-equal-initializer
( expression-list )
brace-or-equal-initializer:
= initializer-clause
braced-init-list
initializer-clause:
assignment-expression
braced-init-list
braced-init-list:
{ initializer-list ,opt }
{ designated-initializer-list ,opt }
{ }
§ A.7 © ISO/IEC
2363

===== PAGE 2375 =====

Dxxxx
initializer-list:
initializer-clause ...opt
initializer-list , initializer-clause ...opt
designated-initializer-list:
designated-initializer-clause
designated-initializer-list , designated-initializer-clause
designated-initializer-clause:
designator brace-or-equal-initializer
designator:
. identifier
expr-or-braced-init-list:
expression
braced-init-list
function-definition:
attribute-specifier-seqopt decl-specifier-seqopt declarator virt-specifier-seqopt
function-contract-specifier-seqopt function-body
attribute-specifier-seqopt decl-specifier-seqopt declarator requires-clause
function-contract-specifier-seqopt function-body
function-body:
ctor-initializeropt compound-statement
function-try-block
= default ;
deleted-function-body
deleted-function-body:
= delete ;
= delete (unevaluated-string ) ;
enum-name:
identifier
enum-specifier:
enum-head { enumerator-listopt }
enum-head { enumerator-list , }
enum-head:
enum-key attribute-specifier-seqopt enum-head-nameopt enum-baseopt
enum-head-name:
nested-name-specifieropt identifier
opaque-enum-declaration:
enum-key attribute-specifier-seqopt enum-head-name enum-baseopt ;
enum-key:
enum
enum class
enum struct
enum-base:
: type-specifier-seq
enumerator-list:
enumerator-definition
enumerator-list , enumerator-definition
enumerator-definition:
enumerator
enumerator = constant-expression
enumerator:
identifier attribute-specifier-seqopt
using-enum-declaration:
using enum using-enum-declarator ;
§ A.7 © ISO/IEC
2364

===== PAGE 2376 =====

Dxxxx
using-enum-declarator:
nested-name-specifieropt identifier
nested-name-specifieropt simple-template-id
splice-type-specifier
namespace-name:
identifier
namespace-alias
namespace-definition:
named-namespace-definition
unnamed-namespace-definition
nested-namespace-definition
named-namespace-definition:
inlineopt namespace attribute-specifier-seqopt identifier { namespace-body }
unnamed-namespace-definition:
inlineopt namespace attribute-specifier-seqopt { namespace-body }
nested-namespace-definition:
namespace enclosing-namespace-specifier :: inlineopt identifier { namespace-body }
enclosing-namespace-specifier:
identifier
enclosing-namespace-specifier :: inlineopt identifier
namespace-body:
declaration-seqopt
namespace-alias:
identifier
namespace-alias-definition:
namespace identifier = qualified-namespace-specifier ;
namespace identifier = splice-specifier ;
qualified-namespace-specifier:
nested-name-specifieropt namespace-name
using-directive:
attribute-specifier-seqopt using namespace nested-name-specifieropt namespace-name ;
attribute-specifier-seqopt using namespace splice-specifier ;
using-declaration:
using using-declarator-list ;
using-declarator-list:
using-declarator ...opt
using-declarator-list , using-declarator ...opt
using-declarator:
typenameopt nested-name-specifier unqualified-id
asm-declaration:
attribute-specifier-seqopt asm ( balanced-token-seq ) ;
linkage-specification:
extern unevaluated-string { declaration-seqopt }
extern unevaluated-string name-declaration
attribute-specifier-seq:
attribute-specifier attribute-specifier-seqopt
attribute-specifier:
[ [ attribute-using-prefixopt attribute-list ] ]
[ [ annotation-list ] ]
alignment-specifier
alignment-specifier:
alignas ( type-id ...opt )
alignas ( constant-expression ...opt )
attribute-using-prefix:
using attribute-namespace :
§ A.7 © ISO/IEC
2365

===== PAGE 2377 =====

Dxxxx
attribute-list:
attributeopt
attribute-list , attributeopt
attribute ...
attribute-list , attribute ...
annotation-list:
annotation ...opt
annotation-list , annotation ...opt
attribute:
attribute-token attribute-argument-clauseopt
annotation:
= constant-expression
attribute-token:
identifier
attribute-scoped-token
attribute-scoped-token:
attribute-namespace :: identifier
attribute-namespace:
identifier
attribute-argument-clause:
( balanced-token-seqopt )
balanced-token-seq:
balanced-token balanced-token-seqopt
balanced-token:
( balanced-token-seqopt )
[ balanced-token-seqopt ]
{ balanced-token-seqopt }
[: balanced-token-seqopt :]
any token other than(, ), [, ], {, }, [:, or:]
A.8 Modules [gram.module]
module-declaration:
export-keywordopt module-keyword module-name module-partitionopt attribute-specifier-seqopt ;
module-name:
module-name-qualifieropt identifier
module-partition:
: module-name-qualifieropt identifier
module-name-qualifier:
identifier .
module-name-qualifier identifier.
export-declaration:
export name-declaration
export { declaration-seqopt }
export-keyword module-import-declaration
module-import-declaration:
import-keyword module-name attribute-specifier-seqopt ;
import-keyword module-partition attribute-specifier-seqopt ;
import-keyword header-name attribute-specifier-seqopt ;
global-module-fragment:
module-keyword ; declaration-seqopt
private-module-fragment:
module-keyword : private ;declaration-seqopt
A.9 Classes [gram.class]
class-name:
identifier
simple-template-id
§ A.9 © ISO/IEC
2366

===== PAGE 2378 =====

Dxxxx
class-specifier:
class-head { member-specificationopt }
class-head:
class-key attribute-specifier-seqopt class-head-name class-property-specifier-seqopt base-clauseopt
class-key attribute-specifier-seqopt base-clauseopt
class-head-name:
nested-name-specifieropt class-name
class-property-specifier-seq:
class-property-specifier class-property-specifier-seqopt
class-property-specifier:
final
class-key:
class
struct
union
member-specification:
member-declaration member-specificationopt
access-specifier : member-specificationopt
member-declaration:
attribute-specifier-seqopt decl-specifier-seqopt member-declarator-listopt ;
function-definition
friend-type-declaration
using-declaration
using-enum-declaration
static_assert-declaration
consteval-block-declaration
template-declaration
explicit-specialization
deduction-guide
alias-declaration
opaque-enum-declaration
empty-declaration
member-declarator-list:
member-declarator
member-declarator-list , member-declarator
member-declarator:
declarator virt-specifier-seqopt function-contract-specifier-seqopt pure-specifieropt
declarator requires-clause function-contract-specifier-seqopt
declarator brace-or-equal-initializer
identifieropt attribute-specifier-seqopt : constant-expression brace-or-equal-initializeropt
virt-specifier-seq:
virt-specifier virt-specifier-seqopt
virt-specifier:
override
final
pure-specifier:
= 0
friend-type-declaration:
friend friend-type-specifier-list ;
friend-type-specifier-list:
friend-type-specifier ...opt
friend-type-specifier-list , friend-type-specifier ...opt
friend-type-specifier:
simple-type-specifier
elaborated-type-specifier
typename-specifier
conversion-function-id:
operator conversion-type-id
§ A.9 © ISO/IEC
2367

===== PAGE 2379 =====

Dxxxx
conversion-type-id:
type-specifier-seq conversion-declaratoropt
conversion-declarator:
ptr-operator conversion-declaratoropt
base-clause:
: base-specifier-list
base-specifier-list:
base-specifier ...opt
base-specifier-list , base-specifier ...opt
base-specifier:
attribute-specifier-seqopt class-or-decltype
attribute-specifier-seqopt virtual access-specifieropt class-or-decltype
attribute-specifier-seqopt access-specifier virtualopt class-or-decltype
class-or-decltype:
nested-name-specifieropt type-name
nested-name-specifier template simple-template-id
computed-type-specifier
access-specifier:
private
protected
public
ctor-initializer:
: mem-initializer-list
mem-initializer-list:
mem-initializer ...opt
mem-initializer-list , mem-initializer ...opt
mem-initializer:
mem-initializer-id ( expression-listopt )
mem-initializer-id braced-init-list
mem-initializer-id:
class-or-decltype
identifier
A.10 Overloading [gram.over]
operator-function-id:
operator operator
operator: one of
new delete new[] delete[] co_await ( ) [ ] -> ->*
~ ! + - * / % ^ &
| = += -= *= /= %= ^= &=
|= == != < > <= >= <=> &&
|| << >> <<= >>= ++ -- ,
literal-operator-id:
operator unevaluated-string identifier
operator user-defined-string-literal
A.11 Templates [gram.temp]
template-declaration:
template-head declaration
template-head concept-definition
template-head:
template < template-parameter-list > requires-clauseopt
template-parameter-list:
template-parameter
template-parameter-list , template-parameter
requires-clause:
requires constraint-logical-or-expression
§ A.11 © ISO/IEC
2368

===== PAGE 2380 =====

Dxxxx
constraint-logical-or-expression:
constraint-logical-and-expression
constraint-logical-or-expression || constraint-logical-and-expression
constraint-logical-and-expression:
primary-expression
constraint-logical-and-expression && primary-expression
template-parameter:
type-parameter
parameter-declaration
type-tt-parameter
variable-tt-parameter
concept-tt-parameter
type-parameter:
type-parameter-key ...opt identifieropt
type-parameter-key identifieropt = type-id
type-constraint ...opt identifieropt
type-constraint identifieropt = type-id
type-parameter-key:
class
typename
type-constraint:
nested-name-specifieropt concept-name
nested-name-specifieropt concept-name < template-argument-listopt >
type-tt-parameter:
template-head type-parameter-key...opt identifieropt
template-head type-parameter-key identifieropt type-tt-parameter-default
type-tt-parameter-default:
= nested-name-specifieropt template-name
= nested-name-specifier template template-name
variable-tt-parameter:
template-head auto ...opt identifieropt
template-head auto identifieropt = nested-name-specifieropt template-name
concept-tt-parameter:
template < template-parameter-list > concept ...opt identifieropt
template < template-parameter-list > concept identifieropt = nested-name-specifieropt template-name
simple-template-id:
template-name < template-argument-listopt >
template-id:
simple-template-id
operator-function-id < template-argument-listopt >
literal-operator-id < template-argument-listopt >
template-name:
identifier
template-argument-list:
template-argument ...opt
template-argument-list , template-argument ...opt
template-argument:
template-argument-name
constant-expression
type-id
braced-init-list
template-argument-name:
nested-name-specifieropt identifier
nested-name-specifier template identifier
constraint-expression:
logical-or-expression
§ A.11 © ISO/IEC
2369

===== PAGE 2381 =====

Dxxxx
deduction-guide:
explicit-specifieropt template-name ( parameter-declaration-clause ) -> simple-template-id requires-clauseopt ;
concept-definition:
concept concept-name attribute-specifier-seqopt = constraint-expression ;
concept-name:
identifier
typename-specifier:
typename nested-name-specifier identifier
typename nested-name-specifier templateopt simple-template-id
explicit-instantiation:
externopt template declaration
explicit-specialization:
template < >declaration
A.12 Exception handling [gram.except]
try-block:
try compound-statement handler-seq
function-try-block:
try ctor-initializeropt compound-statement handler-seq
handler-seq:
handler handler-seqopt
handler:
catch ( exception-declaration ) compound-statement
exception-declaration:
attribute-specifier-seqopt type-specifier-seq declarator
attribute-specifier-seqopt type-specifier-seq abstract-declaratoropt
...
noexcept-specifier:
noexcept ( constant-expression )
noexcept
A.13 Preprocessing directives [gram.cpp]
preprocessing-file:
groupopt
module-file
module-file:
line-directivesopt pp-global-module-fragmentopt pp-module groupopt pp-private-module-fragmentopt
pp-global-module-fragment:
module ; new-line groupopt
pp-private-module-fragment:
module : private ;new-line groupopt
group:
group-part
group group-part
group-part:
control-line
if-section
text-line
# conditionally-supported-directive
§ A.13 © ISO/IEC
2370

===== PAGE 2382 =====

Dxxxx
control-line:
# include pp-tokens new-line
pp-import
# embed pp-tokens new-line
# define identifier replacement-list new-line
# define identifier lparen identifier-listopt ) replacement-list new-line
# define identifier lparen... ) replacement-list new-line
# define identifier lparen identifier-list, ... ) replacement-list new-line
# undef identifier new-line
line-directive
# error pp-tokensopt new-line
# warning pp-tokensopt new-line
# pragma pp-tokensopt new-line
# new-line
line-directives:
line-directive line-directivesopt
if-section:
if-group elif-groupsopt else-groupopt endif-line
if-group:
# if constant-expression new-line groupopt
# ifdef identifier new-line groupopt
# ifndef identifier new-line groupopt
elif-groups:
elif-group elif-groupsopt
elif-group:
# elif constant-expression new-line groupopt
# elifdef identifier new-line groupopt
# elifndef identifier new-line groupopt
else-group:
# else new-line groupopt
endif-line:
# endif new-line
text-line:
pp-tokensopt new-line
conditionally-supported-directive:
pp-tokens new-line
lparen:
a ( character not immediately preceded by whitespace
identifier-list:
identifier
identifier-list , identifier
replacement-list:
pp-tokensopt
pp-tokens:
preprocessing-token pp-tokensopt
embed-parameter-seq:
embed-parameter embed-parameter-seqopt
embed-parameter:
embed-standard-parameter
embed-prefixed-parameter
embed-standard-parameter:
limit ( pp-balanced-token-seq )
prefix ( pp-balanced-token-seqopt )
suffix ( pp-balanced-token-seqopt )
if_empty ( pp-balanced-token-seqopt )
§ A.13 © ISO/IEC
2371

===== PAGE 2383 =====

Dxxxx
embed-prefixed-parameter:
identifier :: identifier
identifier :: identifier( pp-balanced-token-seqopt )
pp-balanced-token-seq:
pp-balanced-token pp-balanced-token-seqopt
pp-balanced-token:
( pp-balanced-token-seqopt )
[ pp-balanced-token-seqopt ]
{ pp-balanced-token-seqopt }
any pp-token except:
parenthesis (u+0028 left parenthesisand u+0029 right parenthesis),
bracket (u+005b left square bracketand u+005d right square bracket), or
brace (u+007b left curly bracketand u+007d right curly bracket).
new-line:
the new-line character
defined-macro-expression:
defined identifier
defined ( identifier )
h-preprocessing-token:
any preprocessing-token other than>
h-pp-tokens:
h-preprocessing-token h-pp-tokensopt
header-name-tokens:
plain-string-literal
< h-pp-tokens >
has-include-expression:
__has_include ( header-name )
__has_include ( header-name-tokens )
has-embed-expression:
__has_embed ( header-name pp-balanced-token-seqopt )
__has_embed ( header-name-tokens pp-balanced-token-seqopt )
has-attribute-expression:
__has_cpp_attribute ( pp-tokens )
pp-module:
exportopt module pp-tokensopt ; new-line
pp-import:
exportopt import header-name pp-tokensopt ; new-line
exportopt import header-name-tokens pp-tokensopt ; new-line
exportopt import pp-tokens ; new-line
va-opt-replacement:
__VA_OPT__ ( pp-tokensopt )
line-directive:
# line pp-tokens new-line
§ A.13 © ISO/IEC
2372

===== PAGE 2384 =====

Dxxxx
Annex B
(informative)
Implementation quantities [implimits]
1 Implementations can exhibit limitations for various quantities; some possibilities are presented in the following
list. The bracketed number following each quantity is a potential minimum value for that quantity.
—(1.1) Nesting levels of compound statements (8.4), iteration control structures (8.6), and selection control
structures (8.5) [256].
—(1.2) Nesting levels of conditional inclusion (15.2) [256].
—(1.3) Pointer (9.3.4.2), pointer-to-member (9.3.4.4), array (9.3.4.5), and function (9.3.4.6) declarators (in any
combination) modifying a type in a declaration [256].
—(1.4) Nesting levels of parenthesized expressions (7.5.4) within a full-expression [256].
—(1.5) Number of characters in an internal identifier (5.11) or macro name (15.7) [1024].
—(1.6) Number of characters in an external identifier (5.11, 6.7) [1024].
—(1.7) External identifiers (6.7) in one translation unit [65536].
—(1.8) Identifiers with block scope declared in one block (6.4.3) [1024].
—(1.9) Structured bindings (9.7) introduced in one declaration [256].
—(1.10) Macro identifiers (15.7) simultaneously defined in one translation unit [65536].
—(1.11) Parameters in one function definition (9.6.1) [256].
—(1.12) Arguments in one function call (7.6.1.3) [256].
—(1.13) Parameters in one macro definition (15.7) [256].
—(1.14) Arguments in one macro invocation (15.7) [256].
—(1.15) Characters in one logical source line (5.2) [65536].
—(1.16) Characters in astring-literal (5.13.5) (after concatenation (5.2)) [65536].
—(1.17) Size of an object (6.8.2) [262144].
—(1.18) Nesting levels for#include files (15.3) [256].
—(1.19) Case labels for aswitch statement (8.5.3) (excluding those for any nestedswitch statements) [16384].
—(1.20) Non-static data members (including inherited ones) in a single class (11.4) [16384].
—(1.21) Lambda-captures in onelambda-expression (7.5.6.3) [256].
—(1.22) Enumeration constants in a single enumeration (9.8.1) [4096].
—(1.23) Levels of nested class definitions (11.4.12) in a singlemember-specification [256].
—(1.24) Functions registered byatexit() (17.5) [32].
—(1.25) Functions registered byat_quick_exit() (17.5) [32].
—(1.26) Direct and indirect base classes (11.7) [16384].
—(1.27) Direct base classes for a single class (11.7) [1024].
—(1.28) Class members declared in a singlemember-specification (including member functions) (11.4) [4096].
—(1.29) Final overriding virtual functions in a class, accessible or not (11.7.3) [16384].
—(1.30) Direct and indirect virtual bases of a class (11.7.2) [1024].
—(1.31) Static data members of a class (11.4.9.3) [1024].
Implementation quantities © ISO/IEC
2373

===== PAGE 2385 =====

Dxxxx
—(1.32) Friend declarations in a class (11.8.4) [4096].
—(1.33) Access control declarations in a class (11.8.2) [4096].
—(1.34) Member initializers in a constructor definition (11.9.3) [6144].
—(1.35) initializer-clauses in onebraced-init-list (9.5) [16384].
—(1.36) Scope qualifications of one identifier (7.5.5.3) [256].
—(1.37) Nested linkage-specifications (9.12) [1024].
—(1.38) Recursive constexpr function invocations (9.2.6) [512].
—(1.39) Full-expressions evaluated within a core constant expression (7.7) [1048576].
—(1.40) Template parameters in a template declaration (13.2) [1024].
—(1.41) Recursively nested template instantiations (13.9.2), including substitution during template argument
deduction (13.10.3) [1024].
—(1.42) Handlers per try block (14.4) [256].
—(1.43) Number of placeholders (22.10.15.5) [10].
—(1.44) Number of hazard-protectable possibly-reclaimable objects (32.11.3.1) [256].
Implementation quantities © ISO/IEC
2374

===== PAGE 2386 =====

Dxxxx
Annex C
(informative)
Compatibility [diff]
C.1 C ++ and ISO C++ 2023 [diff.cpp23]
C.1.1 General [diff.cpp23.general]
1 Subclause C.1 lists the differences between C++ and ISO C++ 2023, by the chapters of this document.
C.1.2 Clause 5: lexical conventions [diff.cpp23.lex]
1 Affected subclause:5.8
Change: New operator^^.
Rationale: Required for new features.
Effect on original feature:Valid C++ 2023 code that contains two consecutive^ tokens can be ill-formed
in this revision of C++.
[Example 1:
struct C { int operator^(int); };
int operator^(int (C::*p)(int), C);
int i = &C::operator^^C{}; // ill-formed; previously well-formed
—end example]
2 Affected subclause:5.12
Change: New keywords.
Rationale: Required for new features.
—(2.1) The contract_assertkeyword is added to introduce a contract assertion through anassertion-statement
(8.9).
Effect on original feature:Valid C++ 2023 code usingcontract_assert as an identifier is not valid in
this revision of C++.
C.1.3 Clause 7: expressions [diff.cpp23.expr]
1 Affected subclause:7.4
Change: Operations mixing a value of an enumeration type and a value of a different enumeration type or
of a floating-point type are no longer valid.
Rationale: Reinforcing type safety.
Effect on original feature:A valid C++ 2023 program that performs operations mixing a value of an
enumeration type and a value of a different enumeration type or of a floating-point type is ill-formed.
[Example 1:
enum E1 { e };
enum E2 { f };
bool b = e <= 3.7; // ill-formed; previously well-formed
int k = f - e; // ill-formed; previously well-formed
auto x = true ? e : f; // ill-formed; previously well-formed
—end example]
2 Affected subclauses:7.6.9 and 7.6.10
Change: Comparing two objects of array type is no longer valid.
Rationale: The old behavior was confusing since it compared not the contents of the two arrays, but their
addresses.
Effect on original feature:A valid C++ 2023 program directly comparing two array objects is rejected as
ill-formed in this document.
§ C.1.3 © ISO/IEC
2375

===== PAGE 2387 =====

Dxxxx
[Example 2:
int arr1[5];
int arr2[5];
bool same = arr1 == arr2; // ill-formed; previously well-formed
bool idem = arr1 == +arr2; // compare addresses
bool less = arr1 < +arr2; // compare addresses, unspecified result
—end example]
3 Affected subclause:7.6.2.9
Change: Calling delete on a pointer to an incomplete class is ill-formed.
Rationale: Reduce undefined behavior.
Effect on original feature:A valid C++ 2023 program that callsdelete on an incomplete class type is
ill-formed.
[Example 3:
struct S;
void f(S *p) {
delete p; // ill-formed; previously well-formed
}
struct S {};
—end example]
C.1.4 Clause 9: declarations [diff.cpp23.dcl.dcl]
1 Affected subclause:9.5.5
Change: Pointer comparisons betweeninitializer_list objects’ backing arrays are unspecified.
Rationale: Permit the implementation to store backing arrays in static read-only memory.
Effect on original feature:Valid C++ 2023 code that relies on the result of pointer comparison between
backing arrays may change behavior.
[Example 1:
bool ne(std::initializer_list<int> a, std::initializer_list<int> b) {
return a.begin() != b.begin() + 1;
}
bool b = ne({2,3}, {1,2,3}); // unspecified result; previouslyfalse
—end example]
2 Affected subclause:9.3.4.5
Change: Previously,T...[n] would declare a pack of function parameters.T...[n] is now apack-index-
specifier.
Rationale: Improve the handling of packs.
Effect on original feature:Valid C++ 2023 code that declares a pack of parameters without specifying a
declarator-id becomes ill-formed.
[Example 2:
template <typename... T>
void f(T... [1]);
template <typename... T>
void g(T... ptr[1]);
int main() {
f<int, double>(nullptr, nullptr); // ill-formed, previously void f<int, double>(int [1], double
[1])
g<int, double>(nullptr, nullptr); // ok
}
—end example]
3 Affected subclause:9.13.1
Change: New token:].
Rationale: Required for new features.
Effect on original feature:Valid C++ 2023 code that contained anattribute-specifier with anattribute-
using-prefix but no attributes and no whitespace is ill-formed in this revision of C++.
§ C.1.4 © ISO/IEC
2376

===== PAGE 2388 =====

Dxxxx
[Example 3:
struct [[using CC:]] C; // ill-formed; previously well-formed
struct [[using DD: ]] D; // OK
—end example]
C.1.5 Clause 13: templates [diff.cpp23.temp]
1 Affected subclause:13.5
Change: Some atomic constraints become fold expanded constraints.
Rationale: Permit the subsumption of fold expressions.
Effect on original feature:Valid C++ 2023 code may become ill-formed.
[Example 1:
template <typename ...V> struct A;
struct S {
static constexpr int compare(const S&) { return 1; }
};
template <typename ...T, typename ...U>
void f(A<T ...> *, A<U ...> *)
requires (T::compare(U{}) && ...); // was well-formed (atomic constraint of typebool),
// now ill-formed (results in an atomic constraint of typeint)
void g(A<S, S> *ap) {
f(ap, ap);
}
—end example]
2 Affected subclause:13.10.3.2
Change: Template argument deduction from overload sets succeeds in more cases.
Rationale: Allow consideration of constraints to disambiguate overload sets used as parameters in function
calls.
Effect on original feature:Valid C++ 2023 code may become ill-formed.
[Example 2:
template <typename T>
void f(T &&, void (*)(T &&));
void g(int &); // #1
inline namespace A {
void g(short &&); // #2
}
inline namespace B {
void g(short &&); // #3
}
void q() {
int x;
f(x, g); // ill-formed; previously well-formed, deducingT = int&
}
There is no change to the applicable deduction rules for the individualg candidates: Type deduction from #1 does
not succeed; type deductions from #2 and #3 both succeed.—end example]
C.1.6 Clause 16: library introduction [diff.cpp23.library]
1 Affected subclause:16.4.2.3
Change: New headers.
Rationale: New functionality.
Effect on original feature: The following C++ headers are new: <contracts> (17.10), <debugging>
(19.7.2), <hazard_pointer> (32.11.3.2), <hive> (23.3.8), <inplace_vector> (23.3.15), <linalg> (29.9.2),
<meta> (21.4.1), <rcu> (32.11.2.2), <simd> (29.10.3), <stdbit.h> (22.12), <stdckdint.h> (29.11.1), and
<text_encoding> (28.4.1). Valid C++ 2023 code that#includes headers with these names may be invalid
in this revision of C++.
§ C.1.6 © ISO/IEC
2377

===== PAGE 2389 =====

Dxxxx
C.1.7 Clause 20: memory management library [diff.cpp23.mem]
1 Affected subclause:20.2.12
Change: Calling realloc with a non-null pointer and zero size has erroneous behavior.
Rationale: The C standard library does not define this behavior.
Effect on original feature:Valid C++ 2023 code that callsrealloc with a non-null pointer and a size of
zero is erroneous and may change behavior.
C.1.8 Clause 23: containers library [diff.cpp23.containers]
1 Affected subclause:23.7.2.2.1
Change: span<const T> is constructible frominitializer_list<T>.
Rationale: Permit passing a braced initializer list to a function takingspan.
Effect on original feature:Valid C++ 2023 code that relies on the lack of this constructor may refuse to
compile, or change behavior in this revision of C++.
[Example 1:
void one(pair<int, int>); // #1
void one(span<const int>); // #2
void t1() { one({1, 2}); } // ambiguous between #1 and #2; previously called #1
void two(span<const int, 2>);
void t2() { two({{1, 2}}); } // ill-formed; previously well-formed
void *a[10];
int x = span<void* const>{a, 0}.size(); // x is 2; previously0
any b[10];
int y = span<const any>{b, b + 10}.size(); // y is 2; previously10
—end example]
C.1.9 Clause 27: strings library [diff.cpp23.strings]
1 Affected subclause:27.4.5
Change: Output of floating-point overloads ofto_string and to_wstring.
Rationale: Prevent loss of information and improve consistency with other formatting facilities.
Effect on original feature:to_string and to_wstring function calls that take floating-point arguments
may produce a different output.
[Example 1:
auto s = std::to_string(1e-7); // "1e-07"
// previously"0.000000" with ’.’ possibly
// changed according to the global C locale
—end example]
C.1.10 Clause 31: input/output library [diff.cpp23.io]
1 Affected subclause:31.7.5.4
Change: Overloaded std::basic_istream<char, traits>::ignore.
Rationale: Allow char values to be used as delimiters.
Effect on original feature:Calls toistream::ignore with a second argument ofchar type can change
behavior. Calls toistream::ignore with a second argument that is neitherint nor char type can become
ill-formed.
[Example 1:
std::istringstream in("\xF0\x9F\xA4\xA1 Clown Face");
in.ignore(100, '\xA1'); // ignore up to’\xA1’ delimiter,
// previously might have ignored to EOF
in.ignore(100, -1L); // ambiguous overload,
// previously equivalent to(int)-1L
—end example]
§ C.1.10 © ISO/IEC
2378

===== PAGE 2390 =====

Dxxxx
C.1.11 Annex D: compatibility features [diff.cpp23.depr]
1 Change: Remove the type aliasallocator<T>::is_always_equal.
Rationale: Non-empty allocator classes derived fromallocator needed to explicitly define anis_always_-
equal member type so thatallocator_traits would not use the one from the allocator base class.
Effect on original feature:It is simpler to correctly define an allocator class with an allocator base class.
[Example 1:
template <class T>
struct MyAlloc : allocator<T> {
int tag;
};
static_assert(!allocator_traits<MyAlloc<int>>::is_always_equal); // Error in C++ 2023,
// OK in C++ 2026
—end example]
2 Change: Removal of atomic access API forshared_ptr objects.
Rationale: The old behavior was brittle.shared_ptr objects using the old API were not protected by the
type system, and certain interactions with code not using this API would, in some cases, silently produce
undefined behavior. A complete type-safe replacement is provided in the form ofatomic<shared_ptr<T>>.
Effect on original feature:A valid C++ 2023 program that relies on the presence of the removed functions
may fail to compile.
3 Change: Remove thebasic_string::reserve() overload with no parameters.
Rationale: The overload of reserve with no parameters is redundant. The shrink_to_fit member
function can be used instead.
Effect on original feature:A valid C++ 2023 program that callsreserve() on abasic_string object
may fail to compile. The old functionality can be achieved by callingshrink_to_fit() instead, or the
function call can be safely eliminated with no side effects.
4 Change: Remove header<codecvt> and all its contents.
Rationale: The header has been deprecated for the previous three editions of this document and no longer
implements the current Unicode standard, supporting only the obsolete UCS-2 encoding. Ongoing support is
at implementer’s discretion, exercising freedoms granted by 16.4.5.3.2.
Effect on original feature:A valid C++ 2023 program#include-ing the header or importing the header
unit may fail to compile. Code that uses any of the following names by importing the standard library
modules may fail to compile:
—(4.1) codecvt_mode,
—(4.2) codecvt_utf16,
—(4.3) codecvt_utf8,
—(4.4) codecvt_utf8_utf16,
—(4.5) consume_header,
—(4.6) generate_header, and
—(4.7) little_endian.
5 Change: Remove header<strstream> and all its contents.
Rationale: The header has been deprecated since the original C++ standard; the<spanstream> header
provides an updated, safer facility. Ongoing support is at implementer’s discretion, exercising freedoms
granted by 16.4.5.3.2.
Effect on original feature:A valid C++ 2023 program#include-ing the header or importing the header
unit may become ill-formed. Code that uses any of the following classes by importing one of the standard
library modules may become ill-formed:
—(5.1) istrstream
—(5.2) ostrstream
—(5.3) strstream
—(5.4) strstreambuf
§ C.1.11 © ISO/IEC
2379

===== PAGE 2391 =====

Dxxxx
6 Change: Remove convenience interfaceswstring_convert and wbuffer_convert.
Rationale: These features were underspecified with no clear error reporting mechanism and were deprecated
for the last three editions of this document. Ongoing support is at implementer’s discretion, exercising
freedoms granted by 16.4.5.3.2.
Effect on original feature:A valid C++ 2023 program using these interfaces may become ill-formed.
C.2 C ++ and ISO C++ 2020 [diff.cpp20]
C.2.1 General [diff.cpp20.general]
1 Subclause C.2 lists the differences between C++ and ISO C++ 2020, in addition to those listed above, by the
chapters of this document.
C.2.2 Clause 5: lexical conventions [diff.cpp20.lex]
1 Affected subclause:5.11
Change: Previously valid identifiers containing characters not present in UAX#44 properties XID_Start or
XID_Continue, or not in Normalization Form C, are now rejected.
Rationale: Prevent confusing characters in identifiers. Requiring normalization of names ensures consistent
linker behavior.
Effect on original feature:Some identifiers are no longer well-formed.
2 Affected subclause:5.13.5
Change: Concatenated string-literals can no longer have conflictingencoding-prefixes.
Rationale: Removal of unimplemented conditionally-supported feature.
Effect on original feature:Concatenation ofstring-literals with differentencoding-prefixes is now ill-formed.
[Example 1:
auto c = L"a" U"b"; // was conditionally-supported; now ill-formed
—end example]
C.2.3 Clause 7: expressions [diff.cpp20.expr]
1 Affected subclause:7.5.5.2
Change: Change move-eligibleid-expressions from lvalues to xvalues.
Rationale: Simplify the rules for implicit move.
Effect on original feature:Valid C++ 2020 code that relies on a returnedid-expression’s being an lvalue
may change behavior or fail to compile.
[Example 1:
decltype(auto) f(int&& x) { return (x); } // returnsint&&; previously returnedint&
int& g(int&& x) { return x; } // ill-formed; previously well-formed
—end example]
2 Affected subclause:7.6.1.2
Change: Change the meaning of comma in subscript expressions.
Rationale: Enable repurposing a deprecated syntax to support multidimensional indexing.
Effect on original feature:Valid C++ 2020 code that uses a comma expression within a subscript expression
may fail to compile.
[Example 2:
arr[1, 2] // was equivalent toarr[(1, 2)],
// now equivalent toarr.operator[](1, 2) or ill-formed
—end example]
C.2.4 Clause 8: statements [diff.cpp20.stmt]
1 Affected subclause:8.6.5
Change: The lifetime of temporary objects in thefor-range-initializer is extended until the end of the
loop (6.8.7).
Rationale: Improve usability of the range-basedfor statement.
Effect on original feature:Destructors of some temporary objects are invoked later.
§ C.2.4 © ISO/IEC
2380

===== PAGE 2392 =====

Dxxxx
[Example 1:
void f() {
std::vector<int> v = { 42, 17, 13 };
std::mutex m;
for (int x :
static_cast<void>(std::lock_guard<std::mutex>(m)), v) { // lock released in C++ 2020
std::lock_guard<std::mutex> guard(m); // OK in C++ 2020, now deadlocks
}
}
—end example]
C.2.5 Clause 9: declarations [diff.cpp20.dcl]
1 Affected subclause:9.5.3
Change: UTF-8 string literals may initialize arrays ofchar or unsigned char.
Rationale: Compatibility with previously written code that conformed to previous versions of this document.
Effect on original feature:Arrays ofchar or unsigned char may now be initialized with a UTF-8 string
literal. This can affect initialization that includes arrays that are directly initialized within class types,
typically aggregates.
[Example 1:
struct A {
char8_t s[10];
};
struct B {
char s[10];
};
void f(A);
void f(B);
int main() {
f({u8""}); // ambiguous
}
—end example]
C.2.6 Clause 13: templates [diff.cpp20.temp]
1 Affected subclause:13.10.3.6
Change: Deducing template arguments from exception specifications.
Rationale: Facilitate generic handling of throwing and non-throwing functions.
Effect on original feature:Valid ISO C++ 2020 code may be ill-formed in this revision of C++.
[Example 1:
template<bool> struct A { };
template<bool B> void f(void (*)(A<B>) noexcept(B));
void g(A<false>) noexcept;
void h() {
f(g); // ill-formed; previously well-formed
}
—end example]
C.2.7 Clause 16: library introduction [diff.cpp20.library]
1 Affected subclause:16.4.2.3
Change: New headers.
Rationale: New functionality.
Effect on original feature:The following C++ headers are new:<expected> (22.8.2), <flat_map> (23.6.7),
<flat_set> (23.6.10), <generator> (25.8.2), <mdspan> (23.7.3.2), <print> (31.7.4), <spanstream> (31.9.2),
<stacktrace> (19.6.2), <stdatomic.h> (32.5.12), and <stdfloat> (17.4.2). Valid C++ 2020 code that
#includes headers with these names may be invalid in this revision of C++.
§ C.2.7 © ISO/IEC
2381

===== PAGE 2393 =====

Dxxxx
C.2.8 Clause 18: concepts library [diff.cpp20.concepts]
1 Affected subclauses:17.12.4, 18.5.4, and 18.5.5
Change: Replace common_reference_with in three_way_comparable_with, equality_comparable_with,
and totally_ordered_with with an exposition-only concept.
Rationale: Allow uncopyable, but movable, types to model these concepts.
Effect on original feature:Valid C++ 2020 code relying on subsumption withcommon_reference_with
may fail to compile in this revision of C++.
[Example 1:
template<class T, class U>
requires equality_comparable_with<T, U>
bool attempted_equals(const T&, const U& u); // previously selected overload
template<class T, class U>
requires common_reference_with<const remove_reference_t<T>&, const remove_reference_t<U>&>
bool attempted_equals(const T& t, const U& u); // ambiguous overload; previously
// rejected by partial ordering
bool test(shared_ptr<int> p) {
return attempted_equals(p, nullptr); // ill-formed; previously well-formed
}
—end example]
C.2.9 Clause 20: memory management library [diff.cpp20.memory]
1 Affected subclause:20.2.9.1
Change: Forbid partial and explicit program-defined specializations ofallocator_traits.
Rationale: Allow addition ofallocate_at_least to allocator_traits, and potentially other members
in the future.
Effect on original feature:Valid C++ 2020 code that partially or explicitly specializesallocator_traits
is ill-formed with no diagnostic required in this revision of C++.
C.2.10 Clause 22: general utilities library [diff.cpp20.utilities]
1 Affected subclause:28.5
Change: Signature changes: format, format_to, vformat_to, format_to_n, formatted_size. Removal
of format_args_t.
Rationale: Improve safety via compile-time format string checks, avoid unnecessary template instantiations.
Effect on original feature:Valid C++ 2020 code that contained errors in format strings or relied on
previous format string signatures orformat_args_t may become ill-formed.
[Example 1:
auto s = std::format("{:d}", "I am not a number"); // ill-formed,
// previously threwformat_error
—end example]
2 Affected subclause:28.5
Change: Signature changes:format, format_to, format_to_n, formatted_size.
Rationale: Enable formatting of views that do not support iteration when const-qualified and that are not
copyable.
Effect on original feature:Valid C++ 2020 code that passes bit-fields to formatting functions may become
ill-formed.
[Example 2:
struct tiny {
int bit: 1;
};
auto t = tiny();
std::format("{}", t.bit); // ill-formed, previously returned"0"
—end example]
§ C.2.10 © ISO/IEC
2382

===== PAGE 2394 =====

Dxxxx
3 Affected subclause:28.5.2.2
Change: Restrict types of formatting arguments used aswidth or precision in astd-format-spec.
Rationale: Disallow types that do not have useful or portable semantics as a formatting width or precision.
Effect on original feature:Valid C++ 2020 code that passes a boolean or character type asarg-id becomes
invalid.
[Example 3:
std::format("{:*^{}}", "", true); // ill-formed, previously returned"*"
std::format("{:*^{}}", "", '1'); // ill-formed, previously returned an
// implementation-defined number of’*’ characters
—end example]
4 Affected subclause:28.5.6.4
Change: Removed theformatter specialization:
template<size_t N> struct formatter<const charT[N], charT>;
Rationale: The specialization is inconsistent with the design of formatter, which is intended to be
instantiated only with cv-unqualified object types.
Effect on original feature:Valid C++ 2020 code that instantiated the removed specialization can become
ill-formed.
C.2.11 Clause 27: strings library [diff.cpp20.strings]
1 Affected subclause:27.4
Change: Additional rvalue overload for thesubstr member function and the corresponding constructor.
Rationale: Improve efficiency of operations on rvalues.
Effect on original feature: Valid C++ 2020 code that created a substring by callingsubstr (or the
corresponding constructor) on an xvalue expression with typeS that is a specialization ofbasic_string
may change meaning in this revision of C++.
[Example 1:
std::string s1 = "some long string that forces allocation", s2 = s1;
std::move(s1).substr(10, 5);
assert(s1 == s2); // unspecified, previously guaranteed to betrue
std::string s3(std::move(s2), 10, 5);
assert(s1 == s2); // unspecified, previously guaranteed to betrue
—end example]
C.2.12 Clause 23: containers library [diff.cpp20.containers]
1 Affected subclauses:23.2.7 and 23.2.8
Change: Heterogeneous extract and erase overloads for associative containers.
Rationale: Improve efficiency of erasing elements from associative containers.
Effect on original feature:Valid C++ 2020 code may fail to compile in this revision of C++.
[Example 1:
struct B {
auto operator<=>(const B&) const = default;
};
struct D : private B {
void f(std::set<B, std::less<>>& s) {
s.erase(*this); // ill-formed; previously well-formed
}
};
—end example]
C.2.13 Clause 32: concurrency support library [diff.cpp20.thread]
1 Affected subclause:32.9.3
Change: In this revision of C++, it is implementation-defined whether a barrier’s phase completion step
runs if no thread callswait. Previously the phase completion step was guaranteed to run on the last thread
that callsarrive or arrive_and_drop during the phase. In this revision of C++, it can run on any of the
threads that arrived or waited at the barrier during the phase.
§ C.2.13 © ISO/IEC
2383

===== PAGE 2395 =====

Dxxxx
Rationale: Correct contradictory wording and improve implementation flexibility for performance.
Effect on original feature:Valid C++ 2020 code using a barrier might have different semantics in this
revision of C++ if it depends on a completion function’s side effects occurring exactly once, on a specific
thread running the phase completion step, or on a completion function’s side effects occurring withoutwait
having been called.
[Example 1:
auto b0 = std::barrier(1);
b0.arrive();
b0.arrive(); // implementation-defined; previously well-defined
int data = 0;
auto b1 = std::barrier(1, [&] { data++; });
b1.arrive();
assert(data == 1); // implementation-defined; previously well-defined
b1.arrive(); // implementation-defined; previously well-defined
—end example]
C.3 C ++ and ISO C++ 2017 [diff.cpp17]
C.3.1 General [diff.cpp17.general]
1 Subclause C.3 lists the differences between C++ and ISO C++ 2017, in addition to those listed above, by the
chapters of this document.
C.3.2 Clause 5: lexical conventions [diff.cpp17.lex]
1 Affected subclauses:5.5, 10.1, 10.3, 15.1, 15.5, and 15.6
Change: New identifiers with special meaning.
Rationale: Required for new features.
Effect on original feature:Logical lines beginning withmodule or import may be interpreted differently
in this revision of C++.
[Example 1:
class module {};
module m1; // was variable declaration; nowmodule-declaration
module *m2; // variable declaration
class import {};
import j1; // was variable declaration; nowmodule-import-declaration
::import j2; // variable declaration
—end example]
2 Affected subclause:5.6
Change: header-name tokens are formed in more contexts.
Rationale: Required for new features.
Effect on original feature:When the identifierimport is followed by a< character, aheader-name token
may be formed.
[Example 2:
template<typename> class import {};
import<int> f(); // ill-formed; previously well-formed
::import<int> g(); // OK
—end example]
3 Affected subclause:5.12
Change: New keywords.
Rationale: Required for new features.
—(3.1) The char8_t keyword is added to differentiate the types of ordinary and UTF-8 literals (5.13.5).
—(3.2) The concept keyword is added to enable the definition of concepts (13.7.9).
—(3.3) The consteval keyword is added to declare immediate functions (9.2.6).
—(3.4) The constinit keyword is added to prevent unintended dynamic initialization (9.2.7).
§ C.3.2 © ISO/IEC
2384

===== PAGE 2396 =====

Dxxxx
—(3.5) The co_await, co_yield, andco_return keywords are added to enable the definition of coroutines
(9.6.4).
—(3.6) The requires keyword is added to introduce constraints through arequires-clause (13.1) or arequires-
expression (7.5.8).
Effect on original feature:Valid C++ 2017 code usingchar8_t, concept, consteval, constinit, co_-
await, co_yield, co_return, orrequires as an identifier is not valid in this revision of C++.
4 Affected subclause:5.8
Change: New operator<=>.
Rationale: Necessary for new functionality.
Effect on original feature:Valid C++ 2017 code that contains a<= token immediately followed by a>
token may be ill-formed or have different semantics in this revision of C++.
[Example 3:
namespace N {
struct X {};
bool operator<=(X, X);
template<bool(X, X)> struct Y {};
Y<operator<=> y; // ill-formed; previously well-formed
}
—end example]
5 Affected subclause:5.13
Change: Type of UTF-8 string and character literals.
Rationale: Requiredfornewfeatures. Thechangedtypesenablefunctionoverloading, templatespecialization,
and type deduction to distinguish ordinary and UTF-8 string and character literals.
Effect on original feature:Valid C++ 2017 code that depends on UTF-8 string literals having type “array
of const char” and UTF-8 character literals having type “char” is not valid in this revision of C++.
[Example 4:
const auto *u8s = u8"text"; // u8s previously deduced asconst char*; now deduced asconst char8_t*
const char *ps = u8s; // ill-formed; previously well-formed
auto u8c = u8'c'; // u8c previously deduced aschar; now deduced aschar8_t
char *pc = &u8c; // ill-formed; previously well-formed
std::string s = u8"text"; // ill-formed; previously well-formed
void f(const char *s);
f(u8"text"); // ill-formed; previously well-formed
template<typename> struct ct;
template<> struct ct<char> {
using type = char;
};
ct<decltype(u8'c')>::type x; // ill-formed; previously well-formed.
—end example]
C.3.3 Clause 6: basics [diff.cpp17.basic]
1 Affected subclause:6.8.4
Change: A pseudo-destructor call ends the lifetime of the object to which it is applied.
Rationale: Increase consistency of the language model.
Effect on original feature:Valid ISO C++ 2017 code may be ill-formed or have undefined behavior in this
revision of C++.
[Example 1:
int f() {
int a = 123;
using T = int;
a.~T();
return a; // undefined behavior; previously returned 123
}
§ C.3.3 © ISO/IEC
2385

===== PAGE 2397 =====

Dxxxx
—end example]
2 Affected subclause:6.10.2.2
Change: Except for the initial release operation, a release sequence consists solely of atomic read-modify-
write operations.
Rationale: Removal of rarely used and confusing feature.
Effect on original feature:If amemory_order_release atomic store is followed by amemory_order_-
relaxed store to the same variable by the same thread, then reading the latter value with amemory_order_-
acquire load no longer provides any “happens before” guarantees, even in the absence of intervening stores
by another thread.
C.3.4 Clause 7: expressions [diff.cpp17.expr]
1 Affected subclause:7.5.6.3
Change: Implicit lambda capture may capture additional entities.
Rationale: Rule simplification, necessary to resolve interactions with constexpr if.
Effect on original feature:Lambdas with acapture-default may capture local entities that were not
captured in C++ 2017 if those entities are only referenced in contexts that do not result in an odr-use.
C.3.5 Clause 9: declarations [diff.cpp17.dcl.dcl]
1 Affected subclause:9.2.4
Change: Unnamed classes with a typedef name for linkage purposes can contain only C-compatible
constructs.
Rationale: Necessary for implementability.
Effect on original feature:Valid C++ 2017 code may be ill-formed in this revision of C++.
[Example 1:
typedef struct {
void f() {} // ill-formed; previously well-formed
} S;
—end example]
2 Affected subclause:9.3.4.7
Change: A function cannot have different default arguments in different translation units.
Rationale: Required for modules support.
Effect on original feature:Valid C++ 2017 code may be ill-formed in this revision of C++, with no
diagnostic required.
[Example 2:
// Translation unit 1
int f(int a = 42);
int g() { return f(); }
// Translation unit 2
int f(int a = 76) { return a; } // ill-formed, no diagnostic required; previously well-formed
int g();
int main() { return g(); } // used to return 42
—end example]
3 Affected subclause:9.5.2
Change: A class that has user-declared constructors is never an aggregate.
Rationale: Remove potentially error-prone aggregate initialization which may apply notwithstanding the
declared constructors of a class.
Effect on original feature:Valid C++ 2017 code that aggregate-initializes a type with a user-declared
constructor may be ill-formed or have different semantics in this revision of C++.
[Example 3:
struct A { // not an aggregate; previously an aggregate
A() = delete;
};
struct B { // not an aggregate; previously an aggregate
B() = default;
§ C.3.5 © ISO/IEC
2386

===== PAGE 2398 =====

Dxxxx
int i = 0;
};
struct C { // not an aggregate; previously an aggregate
C(C&&) = default;
int a, b;
};
A a{}; // ill-formed; previously well-formed
B b = {1}; // ill-formed; previously well-formed
auto* c = new C{2, 3}; // ill-formed; previously well-formed
struct Y;
struct X {
operator Y();
};
struct Y { // not an aggregate; previously an aggregate
Y(const Y&) = default;
X x;
};
Y y{X{}}; // copy constructor call; previously aggregate-initialization
—end example]
4 Affected subclause:9.5.5
Change: Boolean conversion from a pointer or pointer-to-member type is now a narrowing conversion.
Rationale: Catches bugs.
Effect on original feature:Valid C++ 2017 code may fail to compile in this revision of C++.
[Example 4:
bool y[] = { "bc" }; // ill-formed; previously well-formed
—end example]
C.3.6 Clause 11: classes [diff.cpp17.class]
1 Affected subclauses:11.4.5 and 11.4.8.3
Change: The class name can no longer be used parenthesized immediately after anexplicit decl-specifier
in a constructor declaration. Theconversion-function-id can no longer be used parenthesized immediately
after anexplicit decl-specifier in a conversion function declaration.
Rationale: Necessary for new functionality.
Effect on original feature:Valid C++ 2017 code may fail to compile in this revision of C++.
[Example 1:
struct S {
explicit (S)(const S&); // ill-formed; previously well-formed
explicit (operator int)(); // ill-formed; previously well-formed
explicit(true) (S)(int); // OK
};
—end example]
2 Affected subclauses:11.4.5 and 11.4.7
Change: A simple-template-id is no longer valid as thedeclarator-id of a constructor or destructor.
Rationale: Remove potentially error-prone option for redundancy.
Effect on original feature:Valid C++ 2017 code may fail to compile in this revision of C++.
[Example 2:
template<class T>
struct A {
A<T>(); // error:simple-template-id not allowed for constructor
A(int); // OK, injected-class-name used
~A<T>(); // error:simple-template-id not allowed for destructor
};
§ C.3.6 © ISO/IEC
2387

===== PAGE 2399 =====

Dxxxx
—end example]
3 Affected subclause:11.9.6
Change: A function returning an implicitly movable entity may invoke a constructor taking an rvalue
reference to a type different from that of the returned expression. Function and catch-clause parameters can
be thrown using move constructors.
Rationale: Side effect of making it easier to write more efficient code that takes advantage of moves.
Effect on original feature:Valid C++ 2017 code may fail to compile or have different semantics in this
revision of C++.
[Example 3:
struct base {
base();
base(base const &);
private:
base(base &&);
};
struct derived : base {};
base f(base b) {
throw b; // error: base(base &&) is private
derived d;
return d; // error: base(base &&) is private
}
struct S {
S(const char *s) : m(s) { }
S(const S&) = default;
S(S&& other) : m(other.m) { other.m = nullptr; }
const char * m;
};
S consume(S&& s) { return s; }
void g() {
S s("text");
consume(static_cast<S&&>(s));
char c = *s.m; // undefined behavior; previously ok
}
—end example]
C.3.7 Clause 12: overloading [diff.cpp17.over]
1 Affected subclause:12.2.2.3
Change: Equality and inequality expressions can now find reversed and rewritten candidates.
Rationale: Improve consistency of equality with three-way comparison and make it easier to write the full
complement of equality operations.
Effect on original feature:For certain pairs of types where one is convertible to the other, equality or
inequality expressions between an object of one type and an object of the other type invoke a different
operator. Also, for certain types, equality or inequality expressions between two objects of that type become
ambiguous.
[Example 1:
struct A {
operator int() const;
};
bool operator==(A, int); // #1
// #2 is built-in candidate:bool operator==(int, int);
// #3 is built-in candidate:bool operator!=(int, int);
§ C.3.7 © ISO/IEC
2388

===== PAGE 2400 =====

Dxxxx
int check(A x, A y) {
return (x == y) + // ill-formed; previously well-formed
(10 == x) + // calls #1, previously selected #2
(10 != x); // calls #1, previously selected #3
}
—end example]
2 Affected subclause:12.2.2.3
Change: Overload resolution may change for equality operators (7.6.10).
Rationale: Support callingoperator== with reversed order of arguments.
Effect on original feature:Valid C++ 2017 code that uses equality operators with conversion functions
may be ill-formed or have different semantics in this revision of C++.
[Example 2:
struct A {
operator int() const { return 10; }
};
bool operator==(A, int); // #1
// #2 is built-in candidate:bool operator==(int, int);
bool b = 10 == A(); // calls #1 with reversed order of arguments; previously selected #2
struct B {
bool operator==(const B&); // member function with no cv-qualifier
};
B b1;
bool eq = (b1 == b1); // ambiguous; previously well-formed
—end example]
C.3.8 Clause 13: templates [diff.cpp17.temp]
1 Affected subclause:13.3
Change: An unqualified-id that is followed by a< and for which name lookup finds nothing or finds a
function will be treated as atemplate-name in order to potentially cause argument-dependent lookup to be
performed.
Rationale: It was problematic to call a function template with an explicit template argument list via
argument-dependent lookup because of the need to have a template with the same name visible via normal
lookup.
Effect on original feature:Previously valid code that uses a function name as the left operand of a<
operator would become ill-formed.
[Example 1:
struct A {};
bool operator<(void (*fp)(), A);
void f() {}
int main() {
A a;
f < a; // ill-formed; previously well-formed
(f) < a; // still well-formed
}
—end example]
C.3.9 Clause 14: exception handling [diff.cpp17.except]
1 Affected subclause:14.5
Change: Remove throw() exception specification.
Rationale: Removal of obsolete feature that has been replaced bynoexcept.
Effect on original feature:A valid C++ 2017 function declaration, member function declaration, function
pointer declaration, or function reference declaration that usesthrow() for its exception specification will be
rejected as ill-formed in this revision of C++. It should simply be replaced withnoexcept for no change of
meaning since C++ 2017.
§ C.3.9 © ISO/IEC
2389