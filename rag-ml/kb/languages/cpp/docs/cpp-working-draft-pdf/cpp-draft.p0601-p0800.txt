

===== PAGE 601 =====

Dxxxx
void* operator new(std::size_t size, std::align_val_t alignment);
1 Effects: The allocation functions (6.8.6.5.2) called by anew-expression (7.6.2.8) to allocatesize bytes
of storage. The second form is called for a type with new-extended alignment, and the first form is
called otherwise.
2 Required behavior: Return a non-null pointer to suitably aligned storage (6.8.6.5), or else throw a
bad_alloc exception. This requirement is binding on any replacement versions of these functions.
3 Default behavior:
—(3.1) Executes a loop: Within the loop, the function first attempts to allocate the requested storage.
Whether the attempt involves a call to the C standard library functionsmalloc or aligned_alloc
is unspecified.
—(3.2) Returns a pointer to the allocated storage if the attempt is successful. Otherwise, if the current
new_handler (17.6.4.5) is a null pointer value, throwsbad_alloc.
—(3.3) Otherwise, the function calls the currentnew_handler function (17.6.4.3). If the called function
returns, the loop repeats.
—(3.4) The loop terminates when an attempt to allocate the requested storage is successful or when a
called new_handler function does not return.
4 Remarks: This function is replaceable (9.6.5).
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;
void* operator new(std::size_t size, std::align_val_t alignment, const std::nothrow_t&) noexcept;
5 Effects: Same as above, except that these are called by a placement version of anew-expression when a
C++ program prefers a null pointer result as an error indication, instead of abad_alloc exception.
6 Required behavior: Return a non-null pointer to suitably aligned storage (6.8.6.5), or else return a null
pointer. Each of these nothrow versions ofoperator new returns a pointer obtained as if acquired
from the (possibly replaced) corresponding non-placement function. This requirement is binding on
any replacement versions of these functions.
7 Default behavior: Calls operator new(size), oroperator new(size, alignment), respectively. If
the call returns normally, returns the result of that call. Otherwise, returns a null pointer.
8 [Example 1:
T* p1 = new T; // throwsbad_alloc if it fails
T* p2 = new(nothrow) T; // returnsnullptr if it fails
—end example]
9 Remarks: This function is replaceable (9.6.5).
void operator delete(void* ptr) noexcept;
void operator delete(void* ptr, std::size_t size) noexcept;
void operator delete(void* ptr, std::align_val_t alignment) noexcept;
void operator delete(void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
10 Preconditions: ptr is a null pointer or its value represents the address of a block of memory allocated by
an earlier call to a (possibly replaced)operator new(std::size_t) or operator new(std::size_t,
std::align_val_t) which has not been invalidated by an intervening call tooperator delete.
11 If thealignment parameter is not present,ptr was returned by an allocation function without an
alignment parameter. If present, thealignment argument is equal to thealignment argument passed
to the allocation function that returnedptr. If present, the size argument is equal to thesize
argument passed to the allocation function that returnedptr.
12 Effects: The deallocation functions (6.8.6.5.3) called by adelete-expression (7.6.2.9) to render the value
of ptr invalid.
13 Required behavior: A call to anoperator delete with asize parameter may be changed to a call to
the correspondingoperator delete without asize parameter, without affecting memory allocation.
[Note 1: A conforming implementation is foroperator delete(void* ptr, std::size_t size) to simply call
operator delete(ptr). —end note]
14 Default behavior: The functions that have asize parameter forward their other parameters to the
corresponding function without asize parameter.
§ 17.6.3.2 © ISO/IEC
590

===== PAGE 602 =====

Dxxxx
[Note 2: See the note in the belowRemarks: paragraph. —end note]
15 Default behavior: If ptr is null, does nothing. Otherwise, reclaims the storage allocated by the earlier
call tooperator new.
16 Remarks: It is unspecified under what conditions part or all of such reclaimed storage will be allocated
by subsequent calls tooperator new or any ofaligned_alloc, calloc, malloc, orrealloc, declared
in <cstdlib> (17.2.2). This function is replaceable (9.6.5). If a replacement function without asize
parameter is defined by the program, the program should also define the corresponding function with
a size parameter. If a replacement function with asize parameter is defined by the program, the
program shall also define the corresponding version without thesize parameter.
[Note 3: The default behavior above might change in the future, which will require replacing both deallocation
functions when replacing the allocation function.—end note]
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* ptr, std::align_val_t alignment, const std::nothrow_t&) noexcept;
17 Preconditions: ptr is a null pointer or its value represents the address of a block of memory allocated by
an earlier call to a (possibly replaced)operator new(std::size_t) or operator new(std::size_t,
std::align_val_t) which has not been invalidated by an intervening call tooperator delete.
18 If thealignment parameter is not present,ptr was returned by an allocation function without an
alignment parameter. If present, thealignment argument is equal to thealignment argument passed
to the allocation function that returnedptr.
19 Effects: The deallocation functions (6.8.6.5.3) called by the implementation to render the value ofptr
invalid when the constructor invoked from a nothrow placement version of thenew-expression throws an
exception.
20 Default behavior: Calls operator delete(ptr), oroperator delete(ptr, alignment), respectively.
21 Remarks: This function is replaceable (9.6.5).
17.6.3.3 Array forms [new.delete.array]
void* operator new[](std::size_t size);
void* operator new[](std::size_t size, std::align_val_t alignment);
1 Effects: The allocation functions (6.8.6.5.2) called by the array form of anew-expression (7.6.2.8) to
allocate size bytes of storage. The second form is called for a type with new-extended alignment, and
the first form is called otherwise.181
2 Required behavior: Same as for the corresponding single-object forms. This requirement is binding on
any replacement versions of these functions.
3 Default behavior: Returns operator new(size), oroperator new(size, alignment), respectively.
4 Remarks: This function is replaceable (9.6.5).
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;
void* operator new[](std::size_t size, std::align_val_t alignment, const std::nothrow_t&) noexcept;
5 Effects: Same as above, except that these are called by a placement version of anew-expression when a
C++ program prefers a null pointer result as an error indication, instead of abad_alloc exception.
6 Required behavior: Return a non-null pointer to suitably aligned storage (6.8.6.5), or else return a null
pointer. Each of these nothrow versions ofoperator new[] returns a pointer obtained as if acquired
from the (possibly replaced) corresponding non-placement function. This requirement is binding on
any replacement versions of these functions.
7 Default behavior: Calls operator new[](size), oroperator new[](size, alignment), respectively.
If the call returns normally, returns the result of that call. Otherwise, returns a null pointer.
8 Remarks: This function is replaceable (9.6.5).
181) It is not the direct responsibility ofoperator new[] or operator delete[] to note the repetition count or element size of
the array. Those operations are performed elsewhere in the arraynew and delete expressions. The arraynew expression, can,
however, increase thesize argument tooperator new[] to obtain space to store supplemental information.
§ 17.6.3.3 © ISO/IEC
591

===== PAGE 603 =====

Dxxxx
void operator delete[](void* ptr) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
9 Preconditions: ptr is a null pointer or its value represents the address of a block of memory
allocated by an earlier call to a (possibly replaced)operator new[](std::size_t) or operator
new[](std::size_t, std::align_val_t) which has not been invalidated by an intervening call to
operator delete[].
10 If thealignment parameter is not present,ptr was returned by an allocation function without an
alignment parameter. If present, thealignment argument is equal to thealignment argument passed
to the allocation function that returnedptr. If present, the size argument is equal to thesize
argument passed to the allocation function that returnedptr.
11 Effects: The deallocation functions (6.8.6.5.3) called by the array form of adelete-expression to render
the value ofptr invalid.
12 Required behavior: A call to anoperator delete[] with a size parameter may be changed to a
call to the correspondingoperator delete[] without asize parameter, without affecting memory
allocation.
[Note 1: A conforming implementation is foroperator delete[](void* ptr, std::size_t size) to simply
call operator delete[](ptr). —end note]
13 Default behavior: The functions that have asize parameter forward their other parameters to the
corresponding function without asize parameter. The functions that do not have asize parameter
forward their parameters to the correspondingoperator delete (single-object) function.
14 Remarks: This function is replaceable (9.6.5). If a replacement function without asize parameter
is defined by the program, the program should also define the corresponding function with asize
parameter. If a replacement function with asize parameter is defined by the program, the program
shall also define the corresponding version without thesize parameter.
[Note 2: The default behavior above might change in the future, which will require replacing both deallocation
functions when replacing the allocation function.—end note]
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&) noexcept;
15 Preconditions: ptr is a null pointer or its value represents the address of a block of memory
allocated by an earlier call to a (possibly replaced)operator new[](std::size_t) or operator
new[](std::size_t, std::align_val_t) which has not been invalidated by an intervening call to
operator delete[].
16 If thealignment parameter is not present,ptr was returned by an allocation function without an
alignment parameter. If present, thealignment argument is equal to thealignment argument passed
to the allocation function that returnedptr.
17 Effects: The deallocation functions (6.8.6.5.3) called by the implementation to render the value ofptr
invalid when the constructor invoked from a nothrow placement version of the arraynew-expression
throws an exception.
18 Default behavior: Calls operator delete[](ptr), oroperator delete[](ptr, alignment), respec-
tively.
19 Remarks: This function is replaceable (9.6.5).
17.6.3.4 Non-allocating forms [new.delete.placement]
1 These functions are reserved; a C++ program may not define functions that displace the versions in the
C++ standard library (16.4.5). The provisions of 6.8.6.5 do not apply to these reserved placement forms of
operator new and operator delete.
constexpr void* operator new(std::size_t size, void* ptr) noexcept;
2 Returns: ptr.
3 Remarks: Intentionally performs no other action.
§ 17.6.3.4 © ISO/IEC
592

===== PAGE 604 =====

Dxxxx
4 [Example 1: This can be useful for constructing an object at a known address:
void* place = operator new(sizeof(Something));
Something* p = new (place) Something();
—end example]
constexpr void* operator new[](std::size_t size, void* ptr) noexcept;
5 Returns: ptr.
6 Remarks: Intentionally performs no other action.
void operator delete(void* ptr, void*) noexcept;
7 Effects: Intentionally performs no action.
8 Remarks: Default function called when any part of the initialization in a placementnew-expression that
invokes the library’s non-array placement operator new terminates by throwing an exception (7.6.2.8).
void operator delete[](void* ptr, void*) noexcept;
9 Effects: Intentionally performs no action.
10 Remarks: Default function called when any part of the initialization in a placementnew-expression that
invokes the library’s array placement operator new terminates by throwing an exception (7.6.2.8).
17.6.3.5 Data races [new.delete.dataraces]
1 For purposes of determining the existence of data races, the library versions ofoperator new, user replacement
versions of globaloperator new, the C standard library functionsaligned_alloc, calloc, andmalloc, the
library versions ofoperator delete, user replacement versions ofoperator delete, the C standard library
function free, and the C standard library functionrealloc shall not introduce a data race (16.4.6.10). Calls
to these functions that allocate or deallocate a particular unit of storage shall occur in a single total order,
and each such deallocation call shall happen before (6.10.2) the next allocation (if any) in this order.
17.6.4 Storage allocation errors [alloc.errors]
17.6.4.1 Class bad_alloc [bad.alloc]
namespace std {
class bad_alloc : public exception {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 The classbad_alloc defines the type of objects thrown as exceptions by the implementation to report a
failure to allocate storage.
constexpr const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
17.6.4.2 Class bad_array_new_length [new.badlength]
namespace std {
class bad_array_new_length : public bad_alloc {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 The classbad_array_new_length defines the type of objects thrown as exceptions by the implementation
to report an attempt to allocate an array of size less than zero or greater than an implementation-defined
limit (7.6.2.8).
constexpr const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
§ 17.6.4.2 © ISO/IEC
593

===== PAGE 605 =====

Dxxxx
17.6.4.3 Type new_handler [new.handler]
using new_handler = void (*)();
1 The type of ahandler function to be called byoperator new() or operator new[]() (17.6.3) when
they cannot satisfy a request for additional storage.
2 Required behavior: A new_handler shall perform one of the following:
—(2.1) make more storage available for allocation and then return;
—(2.2) throw an exception of typebad_alloc or a class derived frombad_alloc;
—(2.3) terminate execution of the program without returning to the caller.
17.6.4.4 set_new_handler [set.new.handler]
new_handler set_new_handler(new_handler new_p) noexcept;
1 Effects: Establishes the function designated bynew_p as the currentnew_handler.
2 Returns: The previousnew_handler.
3 Remarks: The initialnew_handler is a null pointer.
17.6.4.5 get_new_handler [get.new.handler]
new_handler get_new_handler() noexcept;
1 Returns: The currentnew_handler.
[Note 1: This can be a null pointer value.—end note]
17.6.5 Pointer optimization barrier [ptr.launder]
template<class T> constexpr T* launder(T* p) noexcept;
1 Mandates: !is_function_v<T> && !is_void_v<T> is true.
2 Preconditions: p represents the address A of a byte in memory. An object X that is within its
lifetime (6.8.4) and whose type is similar (7.3.6) toT is located at the addressA. All bytes of storage
that would be reachable through (6.9.4) the result are reachable throughp.
3 Returns: A value of typeT* that points toX.
4 Remarks: An invocation of this function may be used in a core constant expression if and only if the
(converted) value of its argument may be used in place of the function invocation.
5 [Note 1: If a new object is created in storage occupied by an existing object of the same type, a pointer to
the original object can be used to refer to the new object unless its complete object is a const object or it is a
base class subobject; in the latter cases, this function can be used to obtain a usable pointer to the new object.
See 6.8.4. —end note]
6 [Example 1:
struct X { int n; };
const X *p = new const X{3};
const int a = p->n;
new (const_cast<X*>(p)) const X{5}; // p does not point to new object (6.8.4) because its type isconst
const int b = p->n; // undefined behavior
const int c = std::launder(p)->n; // OK
—end example]
17.6.6 Hardware interference size [hardware.interference]
inline constexpr size_t hardware_destructive_interference_size = implementation-defined ;
1 This number is the minimum recommended offset between two concurrently-accessed objects to avoid
additional performance degradation due to contention introduced by the implementation. It shall be at least
alignof(max_align_t).
[Example 1:
struct keep_apart {
alignas(hardware_destructive_interference_size) atomic<int> cat;
§ 17.6.6 © ISO/IEC
594

===== PAGE 606 =====

Dxxxx
alignas(hardware_destructive_interference_size) atomic<int> dog;
};
—end example]
inline constexpr size_t hardware_constructive_interference_size = implementation-defined ;
2 This number is the maximum recommended size of contiguous memory occupied by two objects accessed
with temporal locality by concurrent threads. It shall be at leastalignof(max_align_t).
[Example 2:
struct together {
atomic<int> dog;
int puppy;
};
struct kennel {
// Other data members...
alignas(sizeof(together)) together pack;
// Other data members...
};
static_assert(sizeof(together) <= hardware_constructive_interference_size);
—end example]
17.7 Type identification [support.rtti]
17.7.1 General [support.rtti.general]
1 The header <typeinfo> (17.7.2) defines a type associated with type information generated by the im-
plementation. It also defines two types for reporting dynamic type identification errors. The header
<typeindex> (17.7.6) defines a wrapper type for use as an index type in associative containers (23.4) and in
unordered associative containers (23.5).
17.7.2 Header <typeinfo> synopsis [typeinfo.syn]
// all freestanding
namespace std {
class type_info;
class bad_cast;
class bad_typeid;
}
17.7.3 Class type_info [type.info]
namespace std {
class type_info {
public:
virtual ~type_info();
constexpr bool operator==(const type_info& rhs) const noexcept;
bool before(const type_info& rhs) const noexcept;
size_t hash_code() const noexcept;
const char* name() const noexcept;
type_info(const type_info&) = delete;
type_info& operator=(const type_info&) = delete;
};
}
1 The classtype_info describes type information generated by the implementation (7.6.1.8). Objects of this
class effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types
for equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified
and may differ between programs.
constexpr bool operator==(const type_info& rhs) const noexcept;
2 Effects: Compares the current object withrhs.
3 Returns: true if the two values describe the same type.
§ 17.7.3 © ISO/IEC
595

===== PAGE 607 =====

Dxxxx
bool before(const type_info& rhs) const noexcept;
4 Effects: Compares the current object withrhs.
5 Returns: true if *this precedes rhs in the implementation’s collation order.
size_t hash_code() const noexcept;
6 Returns: An unspecified value, except that within a single execution of the program, it shall return the
same value for any twotype_info objects which compare equal.
7 Remarks: An implementation should return different values for twotype_info objects which do not
compare equal.
const char* name() const noexcept;
8 Returns: An implementation-definedntbs.
9 Remarks: The message may be a null-terminated multibyte string (16.3.3.3.4.3), suitable for conversion
and display as awstring (27.4, 28.3.4.2.5).
17.7.4 Class bad_cast [bad.cast]
namespace std {
class bad_cast : public exception {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 The classbad_cast defines the type of objects thrown as exceptions by the implementation to report the
execution of an invaliddynamic_cast expression (7.6.1.7).
constexpr const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
17.7.5 Class bad_typeid [bad.typeid]
namespace std {
class bad_typeid : public exception {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 The classbad_typeid defines the type of objects thrown as exceptions by the implementation to report a
null pointer in atypeid expression (7.6.1.8).
constexpr const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
17.7.6 Header <typeindex> synopsis [type.index.synopsis]
#include <compare> // see 17.12.1
#include <typeinfo> // see 17.7.2
namespace std {
class type_index;
template<class T> struct hash;
template<> struct hash<type_index>;
}
17.7.7 Class type_index [type.index]
namespace std {
class type_index {
public:
type_index(const type_info& rhs) noexcept;
§ 17.7.7 © ISO/IEC
596

===== PAGE 608 =====

Dxxxx
bool operator==(const type_index& rhs) const noexcept;
bool operator< (const type_index& rhs) const noexcept;
bool operator> (const type_index& rhs) const noexcept;
bool operator<=(const type_index& rhs) const noexcept;
bool operator>=(const type_index& rhs) const noexcept;
strong_ordering operator<=>(const type_index& rhs) const noexcept;
size_t hash_code() const noexcept;
const char* name() const noexcept;
private:
const type_info* target; // exposition only
// Note that the use of a pointer here, rather than a reference,
// means that the default copy/move constructor and assignment
// operators will be provided and work as expected.
};
}
1 The class type_index provides a simple wrapper fortype_info which can be used as an index type in
associative containers (23.4) and in unordered associative containers (23.5).
type_index(const type_info& rhs) noexcept;
2 Effects: Constructs atype_index object, the equivalent oftarget = &rhs.
bool operator==(const type_index& rhs) const noexcept;
3 Returns: *target == *rhs.target.
bool operator<(const type_index& rhs) const noexcept;
4 Returns: target->before(*rhs.target).
bool operator>(const type_index& rhs) const noexcept;
5 Returns: rhs.target->before(*target).
bool operator<=(const type_index& rhs) const noexcept;
6 Returns: !rhs.target->before(*target).
bool operator>=(const type_index& rhs) const noexcept;
7 Returns: !target->before(*rhs.target).
strong_ordering operator<=>(const type_index& rhs) const noexcept;
8 Effects: Equivalent to:
if (*target == *rhs.target) return strong_ordering::equal;
if (target->before(*rhs.target)) return strong_ordering::less;
return strong_ordering::greater;
size_t hash_code() const noexcept;
9 Returns: target->hash_code().
const char* name() const noexcept;
10 Returns: target->name().
template<> struct hash<type_index>;
11 For an objectindex of type type_index, hash<type_index>()(index) shall evaluate to the same
result asindex.hash_code().
17.8 Source location [support.srcloc]
17.8.1 Header <source_location> synopsis [source.location.syn]
1 The header<source_location> defines the classsource_location that provides a means to obtain source
location information.
§ 17.8.1 © ISO/IEC
597

===== PAGE 609 =====

Dxxxx
// all freestanding
namespace std {
struct source_location;
}
17.8.2 Class source_location [support.srcloc.class]
17.8.2.1 General [support.srcloc.class.general]
namespace std {
struct source_location {
// source location construction
static consteval source_location current() noexcept;
constexpr source_location() noexcept;
// source location field access
constexpr uint_least32_t line() const noexcept;
constexpr uint_least32_t column() const noexcept;
constexpr const char* file_name() const noexcept;
constexpr const char* function_name() const noexcept;
private:
uint_least32_t line_; // exposition only
uint_least32_t column_; // exposition only
const char* file_name_; // exposition only
const char* function_name_; // exposition only
};
}
1 The typesource_location meets theCpp17DefaultConstructible, Cpp17CopyConstructible, Cpp17Copy-
Assignable, Cpp17Swappable, andCpp17Destructible requirements (16.4.4.2, 16.4.4.3). All of the following
conditions aretrue:
—(1.1) is_nothrow_move_constructible_v<source_location>
—(1.2) is_nothrow_move_assignable_v<source_location>
—(1.3) is_nothrow_swappable_v<source_location>
[Note 1: The intent ofsource_location is to have a small size and efficient copying. It is unspecified whether the
copy/move constructors and the copy/move assignment operators are trivial and/or constexpr.—end note]
2 The data membersfile_name_ and function_name_ always each refer to anntbs.
3 The copy/move constructors and the copy/move assignment operators ofsource_locationmeet the following
postconditions: Given two objectslhs and rhs of typesource_location, wherelhs is a copy/move result
of rhs, and whererhs_p is a value denoting the state ofrhs before the corresponding copy/move operation,
then each of the following conditions istrue:
—(3.1) strcmp(lhs.file_name(), rhs_p.file_name()) == 0
—(3.2) strcmp(lhs.function_name(), rhs_p.function_name()) == 0
—(3.3) lhs.line() == rhs_p.line()
—(3.4) lhs.column() == rhs_p.column()
17.8.2.2 Creation [support.srcloc.cons]
static consteval source_location current() noexcept;
1 Returns:
—(1.1) When invoked by a function call whosepostfix-expression is a (possibly parenthesized)id-expression
naming current, returns asource_location with an implementation-defined value. The value
should be affected by#line (15.8) in the same manner as for__LINE__ and __FILE__. The
values of the exposition-only data members of the returnedsource_location object are indicated
in Table 43.
—(1.2) Otherwise, when invoked in some other way, returns asource_location whose data members
are initialized with valid but unspecified values.
§ 17.8.2.2 © ISO/IEC
598

===== PAGE 610 =====

Dxxxx
Table 43 — Value of object returned bycurrent [tab:support.srcloc.current]
Element Value
line_ A presumed line number (15.12). Line numbers
are presumed to be 1-indexed; however, an imple-
mentation is encouraged to use 0 when the line
number is unknown.
column_ An implementation-defined value denoting some
offset from the start of the line denoted byline_.
Column numbers are presumed to be 1-indexed;
however, an implementation is encouraged to use
0 when the column number is unknown.
file_name_ A presumed name of the current source file (15.12)
as anntbs.
function_name_ A name of the current function such as in
__func__ (9.6.1) if any, an empty string other-
wise.
2 Remarks: Any call tocurrentthat appears as a default member initializer (11.4.1), or as a subexpression
thereof, should correspond to the location of the constructor definition or aggregate initialization that
uses the default member initializer. Any call tocurrent that appears as a default argument (9.3.4.7),
or as a subexpression thereof, should correspond to the location of the invocation of the function that
uses the default argument (7.6.1.3).
3 [Example 1:
struct s {
source_location member = source_location::current();
int other_member;
s(source_location loc = source_location::current())
: member(loc) // values ofmember refer to the location of the calling function (9.3.4.7)
{}
s(int blather) : // values ofmember refer to this location
other_member(blather)
{}
s(double) // values ofmember refer to this location
{}
};
void f(source_location a = source_location::current()) {
source_location b = source_location::current(); // values inb refer to this line
}
void g() {
f(); // f’s first argument corresponds to this line of code
source_location c = source_location::current();
f(c); // f’s first argument gets the same values asc, above
}
—end example]
constexpr source_location() noexcept;
4 Effects: The data members are initialized with valid but unspecified values.
17.8.2.3 Observers [support.srcloc.obs]
constexpr uint_least32_t line() const noexcept;
1 Returns: line_.
constexpr uint_least32_t column() const noexcept;
2 Returns: column_.
§ 17.8.2.3 © ISO/IEC
599

===== PAGE 611 =====

Dxxxx
constexpr const char* file_name() const noexcept;
3 Returns: file_name_.
constexpr const char* function_name() const noexcept;
4 Returns: function_name_.
17.9 Exception handling [support.exception]
17.9.1 General [support.exception.general]
1 The header<exception> defines several types and functions related to the handling of exceptions in a C++
program.
17.9.2 Header <exception> synopsis [exception.syn]
// all freestanding
namespace std {
class exception;
class bad_exception;
class nested_exception;
using terminate_handler = void (*)();
terminate_handler get_terminate() noexcept;
terminate_handler set_terminate(terminate_handler f) noexcept;
[[noreturn]] void terminate() noexcept;
constexpr int uncaught_exceptions() noexcept;
using exception_ptr = unspecified ;
constexpr exception_ptr current_exception() noexcept;
[[noreturn]] constexpr void rethrow_exception(exception_ptr p);
template<class E> constexpr exception_ptr make_exception_ptr(E e) noexcept;
template<class E> constexpr const E* exception_ptr_cast(const exception_ptr& p) noexcept;
template<class E> void exception_ptr_cast(const exception_ptr&&) = delete;
template<class T> [[noreturn]] constexpr void throw_with_nested(T&& t);
template<class E> constexpr void rethrow_if_nested(const E& e);
}
17.9.3 Class exception [exception]
namespace std {
class exception {
public:
constexpr exception() noexcept;
constexpr exception(const exception&) noexcept;
constexpr exception& operator=(const exception&) noexcept;
constexpr virtual ~exception();
constexpr virtual const char* what() const noexcept;
};
}
1 The classexception defines the base class for the types of objects thrown as exceptions by C++ standard
library components, and certain expressions, to report errors detected during program execution.
2 Except where explicitly specified otherwise, each standard library classT that derives from classexception
has the following publicly accessible member functions, each of them having a non-throwing exception
specification (14.5):
—(2.1) default constructor (unless the class synopsis shows other constructors)
—(2.2) copy constructor
—(2.3) copy assignment operator
The copy constructor and the copy assignment operator meet the following postcondition: If two objectslhs
and rhsboth have dynamic typeTand lhsis a copy ofrhs, thenstrcmp(lhs.what(), rhs.what())is equal
§ 17.9.3 © ISO/IEC
600

===== PAGE 612 =====

Dxxxx
to 0. The what() member function of each suchT satisfies the constraints specified forexception::what()
(see below).
constexpr exception(const exception& rhs) noexcept;
constexpr exception& operator=(const exception& rhs) noexcept;
3 Postconditions: If *this and rhs both have dynamic typeexception then the value of the expression
strcmp(what(), rhs.what()) shall equal 0.
constexpr virtual ~exception();
4 Effects: Destroys an object of classexception.
constexpr virtual const char* what() const noexcept;
5 Returns: An implementation-defined ntbs, which during constant evaluation is encoded with the
ordinary literal encoding (5.13.3).
6 Remarks: The message may be a null-terminated multibyte string (16.3.3.3.4.3), suitable for conversion
and display as awstring (27.4, 28.3.4.2.5). The return value remains valid until the exception object
from which it is obtained is destroyed or a non-const member function of the exception object is called.
17.9.4 Class bad_exception [bad.exception]
namespace std {
class bad_exception : public exception {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 The classbad_exception defines the type of the object referenced by theexception_ptr returned from a
call tocurrent_exception (17.9.7) when the currently active exception object fails to copy.
constexpr const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
17.9.5 Abnormal termination [exception.terminate]
17.9.5.1 Type terminate_handler [terminate.handler]
using terminate_handler = void (*)();
1 The type of ahandler function to be invoked byterminate when terminating exception processing.
2 Required behavior: A terminate_handler shall terminate execution of the program without returning
to the caller.
3 Default behavior: The implementation’s defaultterminate_handler calls abort().
17.9.5.2 set_terminate [set.terminate]
terminate_handler set_terminate(terminate_handler f) noexcept;
1 Effects: Establishes the function designated byf as the current handler function for terminating
exception processing.
2 Returns: The previousterminate_handler.
3 Remarks: It is unspecified whether a null pointer value designates the defaultterminate_handler.
17.9.5.3 get_terminate [get.terminate]
terminate_handler get_terminate() noexcept;
1 Returns: The currentterminate_handler.
[Note 1: This can be a null pointer value.—end note]
§ 17.9.5.3 © ISO/IEC
601

===== PAGE 613 =====

Dxxxx
17.9.5.4 terminate [terminate]
[[noreturn]] void terminate() noexcept;
1 Effects: Calls aterminate_handler function. It is unspecified whichterminate_handler function
will be called if an exception is active during a call toset_terminate. Otherwise calls the current
terminate_handler function.
[Note 1: A defaultterminate_handler is always considered a callable handler in this context.—end note]
2 Remarks: Called by the implementation when exception handling must be abandoned for any of several
reasons (14.6.2). May also be called directly by the program.
17.9.6 uncaught_exceptions [uncaught.exceptions]
constexpr int uncaught_exceptions() noexcept;
1 Returns: The number of uncaught exceptions (14.2) in the current thread.
2 Remarks: When uncaught_exceptions() > 0, throwing an exception can result in a call of the
function std::terminate (14.6.2).
17.9.7 Exception propagation [propagation]
using exception_ptr = unspecified ;
1 The typeexception_ptr can be used to refer to an exception object.
2 exception_ptr meets the requirements ofCpp17NullablePointer (Table 36).
3 Two non-null values of typeexception_ptr are equivalent and compare equal if and only if they refer
to the same exception.
4 The default constructor ofexception_ptr produces the null value of the type.
5 exception_ptr shall not be implicitly convertible to any arithmetic, enumeration, or pointer type.
6 [Note 1: An implementation can use a reference-counted smart pointer asexception_ptr. —end note]
7 For purposes of determining the presence of a data race, operations onexception_ptr objects shall
access and modify only theexception_ptr objects themselves and not the exceptions they refer to.
Use ofrethrow_exception or exception_ptr_cast on exception_ptr objects that refer to the same
exception object shall not introduce a data race.
[Note 2: If rethrow_exception rethrows the same exception object (rather than a copy), concurrent access to
that rethrown exception object can introduce a data race. Changes in the number ofexception_ptr objects
that refer to a particular exception do not introduce a data race.—end note]
8 All member functions are markedconstexpr.
constexpr exception_ptr current_exception() noexcept;
9 Returns: An exception_ptr object that refers to the currently handled exception (14.4) or a copy of
the currently handled exception, or a nullexception_ptr object if no exception is being handled. The
referenced object shall remain valid at least as long as there is anexception_ptr object that refers to
it. If the function needs to allocate memory and the attempt fails, it returns anexception_ptr object
that refers to an instance ofbad_alloc. It is unspecified whether the return values of two successive
calls tocurrent_exception refer to the same exception object.
[Note 3: That is, it is unspecified whethercurrent_exception creates a new copy each time it is called.—end
note]
If the attempt to copy the current exception object throws an exception, the function returns an
exception_ptr object that refers to the thrown exception or, if this is not possible, to an instance of
bad_exception.
[Note 4: The copy constructor of the thrown exception can also fail, so the implementation can substitute a
bad_exception object to avoid infinite recursion.—end note]
[[noreturn]] constexpr void rethrow_exception(exception_ptr p);
10 Preconditions: p is not a null pointer.
11 Effects: Let u be the exception object to whichp refers, or a copy of that exception object. It is
unspecified whether a copy is made, and memory for the copy is allocated in an unspecified way.
§ 17.9.7 © ISO/IEC
602

===== PAGE 614 =====

Dxxxx
—(11.1) If allocating memory to formu fails, throws an instance ofbad_alloc;
—(11.2) otherwise, if copying the exception to whichp refers to formu throws an exception, throws that
exception;
—(11.3) otherwise, throwsu.
template<class E> constexpr exception_ptr make_exception_ptr(E e) noexcept;
12 Effects: Creates anexception_ptr object that refers to a copy ofe, as if:
try {
throw e;
} catch(...) {
return current_exception();
}
13 [Note 5: This function is provided for convenience and efficiency reasons.—end note]
template<class E> constexpr const E* exception_ptr_cast(const exception_ptr& p) noexcept;
14 Mandates: E is a cv-unqualified complete object type.E is not an array type.E is not a pointer or
pointer-to-member type.
[Note 6: WhenE is a pointer or pointer-to-member type, a handler of typeconst E& can match without binding
to the exception object itself.—end note]
15 Returns: A pointer to the exception object referred to byp, ifp is not null and a handler of typeconst
E& would be a match (14.4) for that exception object. Otherwise,nullptr.
17.9.8 nested_exception [except.nested]
namespace std {
class nested_exception {
public:
constexpr nested_exception() noexcept;
constexpr nested_exception(const nested_exception&) noexcept = default;
constexpr nested_exception& operator=(const nested_exception&) noexcept = default;
constexpr virtual ~nested_exception() = default;
// access functions
[[noreturn]] constexpr void rethrow_nested() const;
constexpr exception_ptr nested_ptr() const noexcept;
};
template<class T> [[noreturn]] constexpr void throw_with_nested(T&& t);
template<class E> constexpr void rethrow_if_nested(const E& e);
}
1 The classnested_exception is designed for use as a mixin through multiple inheritance. It captures the
currently handled exception and stores it for later use.
2 [Note 1: nested_exception has a virtual destructor to make it a polymorphic class. Its presence can be tested for
with dynamic_cast. —end note]
constexpr nested_exception() noexcept;
3 Effects: The constructor callscurrent_exception() and stores the returned value.
[[noreturn]] constexpr void rethrow_nested() const;
4 Effects: If nested_ptr() returns a null pointer, the function calls the functionstd::terminate.
Otherwise, it throws the stored exception captured by*this.
constexpr exception_ptr nested_ptr() const noexcept;
5 Returns: The stored exception captured by thisnested_exception object.
template<class T> [[noreturn]] constexpr void throw_with_nested(T&& t);
6 Let U be decay_t<T>.
7 Preconditions: U meets theCpp17CopyConstructible requirements.
§ 17.9.8 © ISO/IEC
603

===== PAGE 615 =====

Dxxxx
8 Throws: Ifis_class_v<U> && !is_final_v<U> && !is_base_of_v<nested_exception, U>istrue,
an exception of unspecified type that is publicly derived from bothU and nested_exception and
constructed fromstd::forward<T>(t), otherwisestd::forward<T>(t).
template<class E> constexpr void rethrow_if_nested(const E& e);
9 Effects: If E is not a polymorphic class type, or ifnested_exception is an inaccessible or ambiguous
base class ofE, there is no effect. Otherwise, performs:
if (auto p = dynamic_cast<const nested_exception*>(addressof(e)))
p->rethrow_nested();
17.10 Contract-violation handling [support.contract]
17.10.1 Header <contracts> synopsis [contracts.syn]
1 The header<contracts> defines types for reporting information about contract violations (6.11.2).
// all freestanding
namespace std::contracts {
enum class assertion_kind : unspecified {
pre = 1,
post = 2,
assert = 3
};
enum class evaluation_semantic : unspecified {
ignore = 1,
observe = 2,
enforce = 3,
quick_enforce = 4
};
enum class detection_mode : unspecified {
predicate_false = 1,
evaluation_exception = 2
};
class contract_violation {
// no user-accessible constructor
public:
contract_violation(const contract_violation&) = delete;
contract_violation& operator=(const contract_violation&) = delete;
see below ~contract_violation();
const char* comment() const noexcept;
contracts::detection_mode detection_mode() const noexcept;
bool is_terminating() const noexcept;
assertion_kind kind() const noexcept;
source_location location() const noexcept;
evaluation_semantic semantic() const noexcept;
};
void invoke_default_contract_violation_handler(const contract_violation&);
}
17.10.2 Enumerations [support.contract.enum]
1 Recommended practice: For all enumerations in 17.10.2, if implementation-defined enumerators are provided,
they should have a minimum value of1000.
2 The enumerators ofassertion_kind correspond to the syntactic forms of a contract assertion (6.11.1), with
meanings listed in Table 44.
3 The enumerators ofevaluation_semantic correspond to the evaluation semantics with which a contract
assertion may be evaluated (6.11.2), with meanings listed in Table 45.
§ 17.10.2 © ISO/IEC
604

===== PAGE 616 =====

Dxxxx
Table 44 — Enumassertion_kind [tab:support.contract.enum.kind]
Name Meaning
pre A precondition assertion
post A postcondition assertion
assert An assertion-statement
Table 45 — Enumevaluation_semantic [tab:support.contract.enum.semantic]
Name Meaning
ignore Ignore evaluation semantic
observe Observe evaluation semantic
enforce Enforce evaluation semantic
quick_enforce Quick-enforce evaluation semantic
4 The enumerators of detection_mode correspond to the manners in which a contract violation can be
identified (6.11.2), with meanings listed in Table 46.
Table 46 — Enumdetection_mode [tab:support.contract.enum.detection]
Name Meaning
predicate_false The predicate of the contract assertion evaluated tofalse or
would have evaluated tofalse.
evaluation_exception An uncaught exception occurred during evaluation of the contract
assertion.
17.10.3 Class contract_violation [support.contract.violation]
1 The classcontract_violation defines the type of objects used to represent a contract violation that has
been detected during the evaluation of a contract assertion with a particular evaluation semantic (6.11.2).
Objects of this type can be created only by the implementation. It is implementation-defined whether the
destructor is virtual.
const char* comment() const noexcept;
2 Returns: An implementation-definedntmbs in the ordinary literal encoding (5.3.1).
3 Recommended practice: The string returned should contain a textual representation of the predicate of
the violated contract assertion or an empty string if storing a textual representation is undesired.
[Note 1: The string can represent a truncated, reformatted, or summarized rendering of the predicate, before or
after preprocessing. —end note]
contracts::detection_mode detection_mode() const noexcept;
4 Returns: The enumerator value corresponding to the manner in which the contract violation was
identified.
bool is_terminating() const noexcept;
5 Returns: true if the evaluation semantic is a terminating semantic (6.11.2); otherwise,false.
assertion_kind kind() const noexcept;
6 Returns: The enumerator value corresponding to the syntactic form of the violated contract assertion.
source_location location() const noexcept;
7 Returns: A source_location object with implementation-defined value.
8 Recommended practice: The value returned should be a default constructedsource_location object
or a value identifying the violated contract assertion:
§ 17.10.3 © ISO/IEC
605

===== PAGE 617 =====

Dxxxx
—(8.1) When possible, if the violated contract assertion was a precondition, the source location of the
function invocation should be returned.
—(8.2) Otherwise, the source location of the contract assertion should be returned.
evaluation_semantic semantic() const noexcept;
9 Returns: The enumerator value corresponding to the evaluation semantic with which the violated
contract assertion was evaluated.
17.10.4 Invoke default handler [support.contract.invoke]
void invoke_default_contract_violation_handler(const contract_violation& v);
1 Effects: Invokes the default contract-violation handler (6.11.3) with the argumentv.
17.11 Initializer lists [support.initlist]
17.11.1 General [support.initlist.general]
1 The header <initializer_list> defines a class template and several support functions related to list-
initialization (see 9.5.5). All functions specified in 17.11 are signal-safe (17.14.5).
17.11.2 Header <initializer_list> synopsis [initializer.list.syn]
// all freestanding
namespace std {
template<class E> class initializer_list {
public:
using value_type = E;
using reference = const E&;
using const_reference = const E&;
using size_type = size_t;
using iterator = const E*;
using const_iterator = const E*;
constexpr initializer_list() noexcept;
constexpr const E* data() const noexcept;
constexpr size_t size() const noexcept; // number of elements
constexpr bool empty() const noexcept;
constexpr const E* begin() const noexcept; // first element
constexpr const E* end() const noexcept; // one past the last element
};
}
1 An object of typeinitializer_list<E> provides access to an array of objects of typeconst E.
[Note 1: A pair of pointers or a pointer plus a length would be obvious representations forinitializer_list.
initializer_list is used to implement initializer lists as specified in 9.5.5. Copying aninitializer_list does not
copy the underlying elements.—end note]
2 If an explicit specialization or partial specialization of initializer_list is declared, the program is
ill-formed.
17.11.3 Initializer list constructors [support.initlist.cons]
constexpr initializer_list() noexcept;
1 Postconditions: size() == 0.
17.11.4 Initializer list access [support.initlist.access]
constexpr const E* begin() const noexcept;
1 Returns: A pointer to the beginning of the array. Ifsize() == 0 the values ofbegin() and end()
are unspecified but they shall be identical.
§ 17.11.4 © ISO/IEC
606

===== PAGE 618 =====

Dxxxx
constexpr const E* end() const noexcept;
2 Returns: begin() + size().
constexpr const E* data() const noexcept;
3 Returns: begin().
constexpr size_t size() const noexcept;
4 Returns: The number of elements in the array.
5 Complexity: Constant.
constexpr bool empty() const noexcept;
6 Returns: size() == 0.
17.12 Comparisons [cmp]
17.12.1 Header <compare> synopsis [compare.syn]
1 The header <compare> specifies types, objects, and functions for use primarily in connection with the
three-way comparison operator (7.6.8).
// all freestanding
namespace std {
// 17.12.2, comparison category types
class partial_ordering;
class weak_ordering;
class strong_ordering;
// named comparison functions
constexpr bool is_eq (partial_ordering cmp) noexcept { return cmp == 0; }
constexpr bool is_neq (partial_ordering cmp) noexcept { return cmp != 0; }
constexpr bool is_lt (partial_ordering cmp) noexcept { return cmp < 0; }
constexpr bool is_lteq(partial_ordering cmp) noexcept { return cmp <= 0; }
constexpr bool is_gt (partial_ordering cmp) noexcept { return cmp > 0; }
constexpr bool is_gteq(partial_ordering cmp) noexcept { return cmp >= 0; }
// 17.12.3, common comparison category type
template<class... Ts>
struct common_comparison_category {
using type = see below ;
};
template<class... Ts>
using common_comparison_category_t = common_comparison_category<Ts...>::type;
// 17.12.4, conceptthree_way_comparable
template<class T, class Cat = partial_ordering>
concept three_way_comparable = see below ;
template<class T, class U, class Cat = partial_ordering>
concept three_way_comparable_with = see below ;
// 17.12.5, result of three-way comparison
template<class T, class U = T> struct compare_three_way_result;
template<class T, class U = T>
using compare_three_way_result_t = compare_three_way_result<T, U>::type;
// 22.10.8.8, classcompare_three_way
struct compare_three_way;
// 17.12.6, comparison algorithms
inline namespace unspecified {
inline constexpr unspecified strong_order = unspecified ;
inline constexpr unspecified weak_order = unspecified ;
inline constexpr unspecified partial_order = unspecified ;
inline constexpr unspecified compare_strong_order_fallback = unspecified ;
§ 17.12.1 © ISO/IEC
607

===== PAGE 619 =====

Dxxxx
inline constexpr unspecified compare_weak_order_fallback = unspecified ;
inline constexpr unspecified compare_partial_order_fallback = unspecified ;
}
// 17.12.7, type ordering
template<class T, class U>
struct type_order;
template<class T, class U>
constexpr strong_ordering type_order_v = type_order<T, U>::value;
}
17.12.2 Comparison category types [cmp.categories]
17.12.2.1 Preamble [cmp.categories.pre]
1 The typespartial_ordering, weak_ordering, andstrong_orderingare collectively termed thecomparison
category types. Each is specified in terms of an exposition-only data member namedvalue whose value
typically corresponds to that of an enumerator from one of the following exposition-only enumerations:
enum class ord { equal = 0, equivalent = equal, less = -1, greater = 1 }; // exposition only
enum class ncmp { unordered = -127 }; // exposition only
2 [Note 1: The typestrong_ordering corresponds to the term total ordering in mathematics.—end note]
3 The relational and equality operators for the comparison category types are specified with an anonymous
parameter of unspecified type. This type shall be selected by the implementation such that these parameters
can accept literal0 as a corresponding argument.
[Example 1: nullptr_t meets this requirement. —end example]
In this context, the behavior of a program that supplies an argument other than a literal0 is undefined.
4 For the purposes of 17.12.2,substitutability is the property thatf(a) == f(b) is true whenever a == b is
true, wheref denotes a function that reads only comparison-salient state that is accessible via the argument’s
public const members.
17.12.2.2 Class partial_ordering [cmp.partialord]
1 The partial_ordering type is typically used as the result type of a three-way comparison operator (7.6.8)
for a type that admits all of the six two-way comparison operators (7.6.9, 7.6.10), for which equality need not
imply substitutability, and that permits two values to be incomparable.182
namespace std {
class partial_ordering {
int value ; // exposition only
bool is-ordered ; // exposition only
// exposition-only constructors
constexpr explicit
partial_ordering(ord v) noexcept : value (int(v)), is-ordered (true) {} // exposition only
constexpr explicit
partial_ordering(ncmp v) noexcept : value (int(v)), is-ordered (false) {} // exposition only
public:
// valid values
static const partial_ordering less;
static const partial_ordering equivalent;
static const partial_ordering greater;
static const partial_ordering unordered;
// comparisons
friend constexpr bool operator==(partial_ordering v, unspecified ) noexcept;
friend constexpr bool operator==(partial_ordering v, partial_ordering w) noexcept = default;
friend constexpr bool operator< (partial_ordering v, unspecified ) noexcept;
friend constexpr bool operator> (partial_ordering v, unspecified ) noexcept;
friend constexpr bool operator<=(partial_ordering v, unspecified ) noexcept;
182) That is,a < b, a == b, anda > b might all befalse.
§ 17.12.2.2 © ISO/IEC
608

===== PAGE 620 =====

Dxxxx
friend constexpr bool operator>=(partial_ordering v, unspecified ) noexcept;
friend constexpr bool operator< (unspecified , partial_ordering v) noexcept;
friend constexpr bool operator> (unspecified , partial_ordering v) noexcept;
friend constexpr bool operator<=(unspecified , partial_ordering v) noexcept;
friend constexpr bool operator>=(unspecified , partial_ordering v) noexcept;
friend constexpr partial_ordering operator<=>(partial_ordering v, unspecified ) noexcept;
friend constexpr partial_ordering operator<=>(unspecified , partial_ordering v) noexcept;
};
// valid values’ definitions
inline constexpr partial_ordering partial_ordering::less(ord ::less );
inline constexpr partial_ordering partial_ordering::equivalent(ord ::equivalent );
inline constexpr partial_ordering partial_ordering::greater(ord ::greater );
inline constexpr partial_ordering partial_ordering::unordered(ncmp ::unordered );
}
constexpr bool operator==(partial_ordering v, unspecified ) noexcept;
constexpr bool operator< (partial_ordering v, unspecified ) noexcept;
constexpr bool operator> (partial_ordering v, unspecified ) noexcept;
constexpr bool operator<=(partial_ordering v, unspecified ) noexcept;
constexpr bool operator>=(partial_ordering v, unspecified ) noexcept;
2 Returns: Foroperator@, v.is-ordered && v.value @ 0.
constexpr bool operator< (unspecified , partial_ordering v) noexcept;
constexpr bool operator> (unspecified , partial_ordering v) noexcept;
constexpr bool operator<=(unspecified , partial_ordering v) noexcept;
constexpr bool operator>=(unspecified , partial_ordering v) noexcept;
3 Returns: Foroperator@, v.is-ordered && 0 @ v.value .
constexpr partial_ordering operator<=>(partial_ordering v, unspecified ) noexcept;
4 Returns: v.
constexpr partial_ordering operator<=>(unspecified , partial_ordering v) noexcept;
5 Returns: v < 0 ? partial_ordering::greater : v > 0 ? partial_ordering::less : v.
17.12.2.3 Class weak_ordering [cmp.weakord]
1 The weak_ordering type is typically used as the result type of a three-way comparison operator (7.6.8) for a
type that admits all of the six two-way comparison operators (7.6.9, 7.6.10) and for which equality need not
imply substitutability.
namespace std {
class weak_ordering {
int value ; // exposition only
// exposition-only constructors
constexpr explicit weak_ordering(ord v) noexcept : value (int(v)) {} // exposition only
public:
// valid values
static const weak_ordering less;
static const weak_ordering equivalent;
static const weak_ordering greater;
// conversions
constexpr operator partial_ordering() const noexcept;
// comparisons
friend constexpr bool operator==(weak_ordering v, unspecified ) noexcept;
friend constexpr bool operator==(weak_ordering v, weak_ordering w) noexcept = default;
friend constexpr bool operator< (weak_ordering v, unspecified ) noexcept;
friend constexpr bool operator> (weak_ordering v, unspecified ) noexcept;
friend constexpr bool operator<=(weak_ordering v, unspecified ) noexcept;
friend constexpr bool operator>=(weak_ordering v, unspecified ) noexcept;
§ 17.12.2.3 © ISO/IEC
609

===== PAGE 621 =====

Dxxxx
friend constexpr bool operator< (unspecified , weak_ordering v) noexcept;
friend constexpr bool operator> (unspecified , weak_ordering v) noexcept;
friend constexpr bool operator<=(unspecified , weak_ordering v) noexcept;
friend constexpr bool operator>=(unspecified , weak_ordering v) noexcept;
friend constexpr weak_ordering operator<=>(weak_ordering v, unspecified ) noexcept;
friend constexpr weak_ordering operator<=>(unspecified , weak_ordering v) noexcept;
};
// valid values’ definitions
inline constexpr weak_ordering weak_ordering::less(ord ::less );
inline constexpr weak_ordering weak_ordering::equivalent(ord ::equivalent );
inline constexpr weak_ordering weak_ordering::greater(ord ::greater );
}
constexpr operator partial_ordering() const noexcept;
2 Returns:
value == 0 ? partial_ordering::equivalent :
value < 0 ? partial_ordering::less :
partial_ordering::greater
constexpr bool operator==(weak_ordering v, unspecified ) noexcept;
constexpr bool operator< (weak_ordering v, unspecified ) noexcept;
constexpr bool operator> (weak_ordering v, unspecified ) noexcept;
constexpr bool operator<=(weak_ordering v, unspecified ) noexcept;
constexpr bool operator>=(weak_ordering v, unspecified ) noexcept;
3 Returns: v.value @ 0 for operator@.
constexpr bool operator< (unspecified , weak_ordering v) noexcept;
constexpr bool operator> (unspecified , weak_ordering v) noexcept;
constexpr bool operator<=(unspecified , weak_ordering v) noexcept;
constexpr bool operator>=(unspecified , weak_ordering v) noexcept;
4 Returns: 0 @ v.value for operator@.
constexpr weak_ordering operator<=>(weak_ordering v, unspecified ) noexcept;
5 Returns: v.
constexpr weak_ordering operator<=>(unspecified , weak_ordering v) noexcept;
6 Returns: v < 0 ? weak_ordering::greater : v > 0 ? weak_ordering::less : v.
17.12.2.4 Class strong_ordering [cmp.strongord]
1 The strong_ordering type is typically used as the result type of a three-way comparison operator (7.6.8)
for a type that admits all of the six two-way comparison operators (7.6.9, 7.6.10) and for which equality does
imply substitutability.
namespace std {
class strong_ordering {
int value ; // exposition only
// exposition-only constructors
constexpr explicit strong_ordering(ord v) noexcept : value (int(v)) {} // exposition only
public:
// valid values
static const strong_ordering less;
static const strong_ordering equal;
static const strong_ordering equivalent;
static const strong_ordering greater;
// conversions
constexpr operator partial_ordering() const noexcept;
constexpr operator weak_ordering() const noexcept;
§ 17.12.2.4 © ISO/IEC
610

===== PAGE 622 =====

Dxxxx
// comparisons
friend constexpr bool operator==(strong_ordering v, unspecified ) noexcept;
friend constexpr bool operator==(strong_ordering v, strong_ordering w) noexcept = default;
friend constexpr bool operator< (strong_ordering v, unspecified ) noexcept;
friend constexpr bool operator> (strong_ordering v, unspecified ) noexcept;
friend constexpr bool operator<=(strong_ordering v, unspecified ) noexcept;
friend constexpr bool operator>=(strong_ordering v, unspecified ) noexcept;
friend constexpr bool operator< (unspecified , strong_ordering v) noexcept;
friend constexpr bool operator> (unspecified , strong_ordering v) noexcept;
friend constexpr bool operator<=(unspecified , strong_ordering v) noexcept;
friend constexpr bool operator>=(unspecified , strong_ordering v) noexcept;
friend constexpr strong_ordering operator<=>(strong_ordering v, unspecified ) noexcept;
friend constexpr strong_ordering operator<=>(unspecified , strong_ordering v) noexcept;
};
// valid values’ definitions
inline constexpr strong_ordering strong_ordering::less(ord ::less );
inline constexpr strong_ordering strong_ordering::equal(ord ::equal );
inline constexpr strong_ordering strong_ordering::equivalent(ord ::equivalent );
inline constexpr strong_ordering strong_ordering::greater(ord ::greater );
}
constexpr operator partial_ordering() const noexcept;
2 Returns:
value == 0 ? partial_ordering::equivalent :
value < 0 ? partial_ordering::less :
partial_ordering::greater
constexpr operator weak_ordering() const noexcept;
3 Returns:
value == 0 ? weak_ordering::equivalent :
value < 0 ? weak_ordering::less :
weak_ordering::greater
constexpr bool operator==(strong_ordering v, unspecified ) noexcept;
constexpr bool operator< (strong_ordering v, unspecified ) noexcept;
constexpr bool operator> (strong_ordering v, unspecified ) noexcept;
constexpr bool operator<=(strong_ordering v, unspecified ) noexcept;
constexpr bool operator>=(strong_ordering v, unspecified ) noexcept;
4 Returns: v.value @ 0 for operator@.
constexpr bool operator< (unspecified , strong_ordering v) noexcept;
constexpr bool operator> (unspecified , strong_ordering v) noexcept;
constexpr bool operator<=(unspecified , strong_ordering v) noexcept;
constexpr bool operator>=(unspecified , strong_ordering v) noexcept;
5 Returns: 0 @ v.value for operator@.
constexpr strong_ordering operator<=>(strong_ordering v, unspecified ) noexcept;
6 Returns: v.
constexpr strong_ordering operator<=>(unspecified , strong_ordering v) noexcept;
7 Returns: v < 0 ? strong_ordering::greater : v > 0 ? strong_ordering::less : v.
17.12.3 Class template common_comparison_category [cmp.common]
1 The typecommon_comparison_category provides an alias for the strongest comparison category to which
all of the template arguments can be converted.
[Note 1: A comparison category type is stronger than another if they are distinct types and an instance of the former
can be converted to an instance of the latter.—end note]
§ 17.12.3 © ISO/IEC
611

===== PAGE 623 =====

Dxxxx
template<class... Ts>
struct common_comparison_category {
using type = see below ;
};
2 Remarks: The membertypedef-name type denotes the common comparison type (11.10.3) ofTs...,
the expanded parameter pack, orvoid if any element ofTs is not a comparison category type.
[Note 2: This isstd::strong_ordering if the expansion is empty.—end note]
17.12.4 Concept three_way_comparable [cmp.concept]
template<class T, class Cat>
concept compares-as = // exposition only
same_as<common_comparison_category_t<T, Cat>, Cat>;
template<class T, class U>
concept partially-ordered-with = // exposition only
requires(const remove_reference_t<T>& t, const remove_reference_t<U>& u) {
{ t < u } -> boolean-testable ;
{ t > u } -> boolean-testable ;
{ t <= u } -> boolean-testable ;
{ t >= u } -> boolean-testable ;
{ u < t } -> boolean-testable ;
{ u > t } -> boolean-testable ;
{ u <= t } -> boolean-testable ;
{ u >= t } -> boolean-testable ;
};
1 Let t and u be lvalues of typesconst remove_reference_t<T> and const remove_reference_t<U>, re-
spectively. T and U model partially-ordered-with <T, U> only if
—(1.1) t < u, t <= u, t > u, t >= u, u < t, u <= t, u > t, andu >= t have the same domain,
—(1.2) bool(t < u) == bool(u > t) is true,
—(1.3) bool(u < t) == bool(t > u) is true,
—(1.4) bool(t <= u) == bool(u >= t) is true, and
—(1.5) bool(u <= t) == bool(t >= u) is true.
template<class T, class Cat = partial_ordering>
concept three_way_comparable =
weakly-equality-comparable-with <T, T> &&
partially-ordered-with <T, T> &&
requires(const remove_reference_t<T>& a, const remove_reference_t<T>& b) {
{ a <=> b } -> compares-as <Cat>;
};
2 Let a and b be lvalues of typeconst remove_reference_t<T>. T and Cat model three_way_comparable<T,
Cat> only if
—(2.1) (a <=> b == 0) == bool(a == b) is true,
—(2.2) (a <=> b != 0) == bool(a != b) is true,
—(2.3) ((a <=> b) <=> 0) and (0 <=> (b <=> a)) are equal,
—(2.4) (a <=> b < 0) == bool(a < b) is true,
—(2.5) (a <=> b > 0) == bool(a > b) is true,
—(2.6) (a <=> b <= 0) == bool(a <= b) is true,
—(2.7) (a <=> b >= 0) == bool(a >= b) is true, and
—(2.8) if Cat is convertible tostrong_ordering, T models totally_ordered (18.5.5).
template<class T, class U, class Cat = partial_ordering>
concept three_way_comparable_with =
three_way_comparable<T, Cat> &&
three_way_comparable<U, Cat> &&
comparison-common-type-with <T, U> &&
§ 17.12.4 © ISO/IEC
612

===== PAGE 624 =====

Dxxxx
three_way_comparable<
common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>, Cat> &&
weakly-equality-comparable-with <T, U> &&
partially-ordered-with <T, U> &&
requires(const remove_reference_t<T>& t, const remove_reference_t<U>& u) {
{ t <=> u } -> compares-as <Cat>;
{ u <=> t } -> compares-as <Cat>;
};
3 Let tand t2be lvalues denoting distinct equal objects of typesconst remove_reference_t<T>and remove_-
cvref_t<T>, respectively, and letu and u2 be lvalues denoting distinct equal objects of typesconst remove_-
reference_t<U> and remove_cvref_t<U>, respectively. Let C be common_reference_t<const remove_-
reference_t<T>&, const remove_reference_t<U>&>. Let CONVERT_TO_LVALUE <C>(E) be defined as in
18.5.1. T, U, andCat model three_way_comparable_with<T, U, Cat> only if
—(3.1) t <=> u and u <=> t have the same domain,
—(3.2) ((t <=> u) <=> 0) and (0 <=> (u <=> t)) are equal,
—(3.3) (t <=> u == 0) == bool(t == u) is true,
—(3.4) (t <=> u != 0) == bool(t != u) is true,
—(3.5) Cat(t <=> u) == Cat(CONVERT_TO_LVALUE <C>(t2) <=> CONVERT_TO_LVALUE <C>(u2)) is true,
—(3.6) (t <=> u < 0) == bool(t < u) is true,
—(3.7) (t <=> u > 0) == bool(t > u) is true,
—(3.8) (t <=> u <= 0) == bool(t <= u) is true,
—(3.9) (t <=> u >= 0) == bool(t >= u) is true, and
—(3.10) if Cat is convertible tostrong_ordering, T and U model totally_ordered_with<T, U> (18.5.5).
17.12.5 Result of three-way comparison [cmp.result]
1 The behavior of a program that adds specializations for thecompare_three_way_result template defined
in this subclause is undefined.
2 For thecompare_three_way_result type trait applied to the typesT and U, lett and u denote lvalues of
types const remove_reference_t<T> and const remove_reference_t<U>, respectively. If the expression
t <=> u is well-formed when treated as an unevaluated operand (7.2.3), the membertypedef-name type
denotes the typedecltype(t <=> u). Otherwise, there is no membertype.
17.12.6 Comparison algorithms [cmp.alg]
1 The namestrong_order denotes a customization point object (16.3.3.3.5). Given subexpressionsE and F,
the expressionstrong_order(E, F) is expression-equivalent (3.22) to the following:
—(1.1) If the decayed types ofE and F differ, strong_order(E, F) is ill-formed.
—(1.2) Otherwise, strong_ordering(strong_order(E, F))ifitisawell-formedexpressionwherethemeaning
of strong_order is established as-if by performing argument-dependent lookup only (6.5.4).
—(1.3) Otherwise, if the decayed typeTof Eis a floating-point type, yields a value of typestrong_orderingthat
is consistent with the ordering observed byT’s comparison operators, and ifnumeric_limits<T>::is_-
iec559 is true, is additionally consistent with thetotalOrder operation as specified in ISO/IEC
60559.
—(1.4) Otherwise, strong_ordering(compare_three_way()(E, F)) if it is a well-formed expression.
—(1.5) Otherwise, strong_order(E, F) is ill-formed.
[Note 1: Ill-formed cases above result in substitution failure whenstrong_order(E, F) appears in the immediate
context of a template instantiation.—end note]
2 The nameweak_order denotes a customization point object (16.3.3.3.5). Given subexpressionsE and F, the
expression weak_order(E, F) is expression-equivalent (3.22) to the following:
—(2.1) If the decayed types ofE and F differ, weak_order(E, F) is ill-formed.
—(2.2) Otherwise, weak_ordering(weak_order(E, F)) if it is a well-formed expression where the meaning of
weak_order is established as-if by performing argument-dependent lookup only (6.5.4).
§ 17.12.6 © ISO/IEC
613

===== PAGE 625 =====

Dxxxx
—(2.3) Otherwise, if the decayed typeT of E is a floating-point type, yields a value of typeweak_ordering
that is consistent with the ordering observed byT’s comparison operators andstrong_order, and
if numeric_limits<T>::is_iec559 is true, is additionally consistent with the following equivalence
classes, ordered from lesser to greater:
—(2.3.1) together, all negative NaN values;
—(2.3.2) negative infinity;
—(2.3.3) each normal negative value;
—(2.3.4) each subnormal negative value;
—(2.3.5) together, both zero values;
—(2.3.6) each subnormal positive value;
—(2.3.7) each normal positive value;
—(2.3.8) positive infinity;
—(2.3.9) together, all positive NaN values.
—(2.4) Otherwise, weak_ordering(compare_three_way()(E, F)) if it is a well-formed expression.
—(2.5) Otherwise, weak_ordering(strong_order(E, F)) if it is a well-formed expression.
—(2.6) Otherwise, weak_order(E, F) is ill-formed.
[Note 2: Ill-formed cases above result in substitution failure whenweak_order(E, F) appears in the immediate
context of a template instantiation.—end note]
3 The namepartial_order denotes a customization point object (16.3.3.3.5). Given subexpressionsE and F,
the expressionpartial_order(E, F) is expression-equivalent (3.22) to the following:
—(3.1) If the decayed types ofE and F differ, partial_order(E, F) is ill-formed.
—(3.2) Otherwise, partial_ordering(partial_order(E, F)) if it is a well-formed expression where the
meaning of partial_order is established as-if by performing argument-dependent lookup only (6.5.4).
—(3.3) Otherwise, partial_ordering(compare_three_way()(E, F)) if it is a well-formed expression.
—(3.4) Otherwise, partial_ordering(weak_order(E, F)) if it is a well-formed expression.
—(3.5) Otherwise, partial_order(E, F) is ill-formed.
[Note 3: Ill-formed cases above result in substitution failure whenpartial_order(E, F) appears in the immediate
context of a template instantiation.—end note]
4 The name compare_strong_order_fallback denotes a customization point object (16.3.3.3.5). Given
subexpressions E and F, the expressioncompare_strong_order_fallback(E, F) is expression-equivalent
(3.22) to:
—(4.1) If the decayed types ofE and F differ, compare_strong_order_fallback(E, F) is ill-formed.
—(4.2) Otherwise, strong_order(E, F) if it is a well-formed expression.
—(4.3) Otherwise, if the expressionsE == F and E < F are both well-formed and each ofdecltype(E == F)
and decltype(E < F) models boolean-testable ,
E == F ? strong_ordering::equal :
E < F ? strong_ordering::less :
strong_ordering::greater
except thatE and F are evaluated only once.
—(4.4) Otherwise, compare_strong_order_fallback(E, F) is ill-formed.
[Note 4: Ill-formed cases above result in substitution failure whencompare_strong_order_fallback(E, F) appears
in the immediate context of a template instantiation.—end note]
5 The namecompare_weak_order_fallback denotes a customization point object (16.3.3.3.5). Given subex-
pressions E and F, the expression compare_weak_order_fallback(E, F) is expression-equivalent (3.22)
to:
—(5.1) If the decayed types ofE and F differ, compare_weak_order_fallback(E, F) is ill-formed.
—(5.2) Otherwise, weak_order(E, F) if it is a well-formed expression.
§ 17.12.6 © ISO/IEC
614

===== PAGE 626 =====

Dxxxx
—(5.3) Otherwise, if the expressionsE == F and E < F are both well-formed and each ofdecltype(E == F)
and decltype(E < F) models boolean-testable ,
E == F ? weak_ordering::equivalent :
E < F ? weak_ordering::less :
weak_ordering::greater
except thatE and F are evaluated only once.
—(5.4) Otherwise, compare_weak_order_fallback(E, F) is ill-formed.
[Note 5: Ill-formed cases above result in substitution failure whencompare_weak_order_fallback(E, F) appears in
the immediate context of a template instantiation.—end note]
6 The name compare_partial_order_fallback denotes a customization point object (16.3.3.3.5). Given
subexpressions E and F, the expressioncompare_partial_order_fallback(E, F) is expression-equivalent
(3.22) to:
—(6.1) If the decayed types ofE and F differ, compare_partial_order_fallback(E, F) is ill-formed.
—(6.2) Otherwise, partial_order(E, F) if it is a well-formed expression.
—(6.3) Otherwise, if the expressionsE == F, E < F, andF < E are all well-formed and each ofdecltype(E
== F), decltype(E < F), anddecltype(F < E) models boolean-testable ,
E == F ? partial_ordering::equivalent :
E < F ? partial_ordering::less :
F < E ? partial_ordering::greater :
partial_ordering::unordered
except thatE and F are evaluated only once.
—(6.4) Otherwise, compare_partial_order_fallback(E, F) is ill-formed.
[Note 6: Ill-formed cases above result in substitution failure whencompare_partial_order_fallback(E, F) appears
in the immediate context of a template instantiation.—end note]
17.12.7 Type Ordering [compare.type]
1 There is an implementation-defined total ordering of all types. For any (possibly incomplete) typesX and
Y, the expressionTYPE-ORDER (X, Y) is a constant expression (7.7) of typestrong_ordering (17.12.2.4).
Its value isstrong_ordering::less if X precedes Y in this implementation-defined total order,strong_-
ordering::greater if Y precedes X, andstrong_ordering::equal if they are the same type.
[Note 1: int, const int and int& are different types. —end note]
[Note 2: This ordering need not be consistent with the one induced bytype_info::before. —end note]
[Note 3: The ordering of TU-local types from different translation units is not observable, because the necessary
specialization of type_order is impossible to name.—end note]
template<class T, class U> struct type_order {
static constexpr strong_ordering value = TYPE-ORDER (T, U);
using value_type = strong_ordering;
constexpr operator value_type() const noexcept { return value; }
constexpr value_type operator()() const noexcept { return value; }
};
2 If an explicit specialization or partial specialization oftype_order is declared, the program is ill-formed.
3 Recommended practice: The order should be lexicographical on parameter-type-lists and template
argument lists.
17.13 Coroutines [support.coroutine]
17.13.1 General [support.coroutine.general]
1 The header<coroutine> defines several types providing compile and run-time support for coroutines in a
C++ program.
§ 17.13.1 © ISO/IEC
615

===== PAGE 627 =====

Dxxxx
17.13.2 Header <coroutine> synopsis [coroutine.syn]
// all freestanding
#include <compare> // see 17.12.1
namespace std {
// 17.13.3, coroutine traits
template<class R, class... ArgTypes>
struct coroutine_traits;
// 17.13.4, coroutine handle
template<class Promise = void>
struct coroutine_handle;
// 17.13.4.8, comparison operators
constexpr bool operator==(coroutine_handle<> x, coroutine_handle<> y) noexcept;
constexpr strong_ordering operator<=>(coroutine_handle<> x, coroutine_handle<> y) noexcept;
// 17.13.4.9, hash support
template<class T> struct hash;
template<class P> struct hash<coroutine_handle<P>>;
// 17.13.5, no-op coroutines
struct noop_coroutine_promise;
template<> struct coroutine_handle<noop_coroutine_promise>;
using noop_coroutine_handle = coroutine_handle<noop_coroutine_promise>;
noop_coroutine_handle noop_coroutine() noexcept;
// 17.13.6, trivial awaitables
struct suspend_never;
struct suspend_always;
}
17.13.3 Coroutine traits [coroutine.traits]
17.13.3.1 General [coroutine.traits.general]
1 Subclause 17.13.3 defines requirements on classes representingcoroutine traits, and defines the class template
coroutine_traits that meets those requirements.
17.13.3.2 Class template coroutine_traits [coroutine.traits.primary]
1 The header <coroutine> defines the primary template coroutine_traits such that if ArgTypes is a
parameter pack of types and if thequalified-id R::promise_type is valid and denotes a type (13.10.3), then
coroutine_traits<R, ArgTypes...> has the following publicly accessible member:
using promise_type = R::promise_type;
Otherwise, coroutine_traits<R, ArgTypes...> has no members.
2 Program-defined specializations of this template shall define a publicly accessible nested type namedpromise_-
type.
17.13.4 Class template coroutine_handle [coroutine.handle]
17.13.4.1 General [coroutine.handle.general]
namespace std {
template<>
struct coroutine_handle<void>
{
// 17.13.4.2, construct/reset
constexpr coroutine_handle() noexcept;
constexpr coroutine_handle(nullptr_t) noexcept;
coroutine_handle& operator=(nullptr_t) noexcept;
§ 17.13.4.1 © ISO/IEC
616

===== PAGE 628 =====

Dxxxx
// 17.13.4.4, export/import
constexpr void* address() const noexcept;
static constexpr coroutine_handle from_address(void* addr);
// 17.13.4.5, observers
constexpr explicit operator bool() const noexcept;
bool done() const;
// 17.13.4.6, resumption
void operator()() const;
void resume() const;
void destroy() const;
private:
void* ptr; // exposition only
};
template<class Promise>
struct coroutine_handle
{
// 17.13.4.2, construct/reset
constexpr coroutine_handle() noexcept;
constexpr coroutine_handle(nullptr_t) noexcept;
static coroutine_handle from_promise(Promise&);
coroutine_handle& operator=(nullptr_t) noexcept;
// 17.13.4.4, export/import
constexpr void* address() const noexcept;
static constexpr coroutine_handle from_address(void* addr);
// 17.13.4.3, conversion
constexpr operator coroutine_handle<>() const noexcept;
// 17.13.4.5, observers
constexpr explicit operator bool() const noexcept;
bool done() const;
// 17.13.4.6, resumption
void operator()() const;
void resume() const;
void destroy() const;
// 17.13.4.7, promise access
Promise& promise() const;
private:
void* ptr; // exposition only
};
}
1 An object of typecoroutine_handle<T> is called acoroutine handleand can be used to refer to a suspended
or executing coroutine. Acoroutine_handle object whose memberaddress() returns a null pointer value
does not refer to any coroutine. Twocoroutine_handle objects refer to the same coroutine if and only if
their memberaddress() returns the same non-null value.
2 If a program declares an explicit or partial specialization ofcoroutine_handle, the behavior is undefined.
17.13.4.2 Construct/reset [coroutine.handle.con]
constexpr coroutine_handle() noexcept;
constexpr coroutine_handle(nullptr_t) noexcept;
1 Postconditions: address() == nullptr.
§ 17.13.4.2 © ISO/IEC
617

===== PAGE 629 =====

Dxxxx
static coroutine_handle from_promise(Promise& p);
2 Preconditions: p is a reference to a promise object of a coroutine.
3 Postconditions: addressof(h.promise()) == addressof(p).
4 Returns: A coroutine handleh referring to the coroutine.
coroutine_handle& operator=(nullptr_t) noexcept;
5 Postconditions: address() == nullptr.
6 Returns: *this.
17.13.4.3 Conversion [coroutine.handle.conv]
constexpr operator coroutine_handle<>() const noexcept;
1 Effects: Equivalent to:return coroutine_handle<>::from_address(address());
17.13.4.4 Export/import [coroutine.handle.export.import]
constexpr void* address() const noexcept;
1 Returns: ptr.
static constexpr coroutine_handle<> coroutine_handle<>::from_address(void* addr);
2 Preconditions: addr was obtained via a prior call toaddress on an object whose type is a specialization
of coroutine_handle.
3 Postconditions: from_address(address()) == *this.
static constexpr coroutine_handle<Promise> coroutine_handle<Promise>::from_address(void* addr);
4 Preconditions: addr was obtained via a prior call toaddress on an object of typecv coroutine_-
handle<Promise>.
5 Postconditions: from_address(address()) == *this.
17.13.4.5 Observers [coroutine.handle.observers]
constexpr explicit operator bool() const noexcept;
1 Returns: address() != nullptr.
bool done() const;
2 Preconditions: *this refers to a suspended coroutine.
3 Returns: true if the coroutine is suspended at its final suspend point, otherwisefalse.
17.13.4.6 Resumption [coroutine.handle.resumption]
1 Resuming a coroutine viaresume, operator(), ordestroy on an execution agent other than the one on
which it was suspended has implementation-defined behavior unless each execution agent either is an instance
of std::thread or std::jthread, or is the thread that executesmain.
[Note 1: A coroutine that is resumed on a different execution agent should avoid relying on consistent thread identity
throughout, such as holding a mutex object across a suspend point.—end note]
[Note 2: A concurrent resumption of the coroutine can result in a data race.—end note]
void operator()() const;
void resume() const;
2 Preconditions: *this refers to a suspended coroutine. The coroutine is not suspended at its final
suspend point.
3 Effects: Resumes the execution of the coroutine.
void destroy() const;
4 Preconditions: *this refers to a suspended coroutine.
5 Effects: Destroys the coroutine (9.6.4).
§ 17.13.4.6 © ISO/IEC
618

===== PAGE 630 =====

Dxxxx
17.13.4.7 Promise access [coroutine.handle.promise]
Promise& promise() const;
1 Preconditions: *this refers to a coroutine.
2 Returns: A reference to the promise of the coroutine.
17.13.4.8 Comparison operators [coroutine.handle.compare]
constexpr bool operator==(coroutine_handle<> x, coroutine_handle<> y) noexcept;
1 Returns: x.address() == y.address().
constexpr strong_ordering operator<=>(coroutine_handle<> x, coroutine_handle<> y) noexcept;
2 Returns: compare_three_way()(x.address(), y.address()).
17.13.4.9 Hash support [coroutine.handle.hash]
template<class P> struct hash<coroutine_handle<P>>;
1 The specialization is enabled (22.10.19).
17.13.5 No-op coroutines [coroutine.noop]
17.13.5.1 Class noop_coroutine_promise [coroutine.promise.noop]
struct noop_coroutine_promise {};
1 The classnoop_coroutine_promise defines the promise type for the coroutine referred to bynoop_-
coroutine_handle (17.13.2).
17.13.5.2 Class coroutine_handle<noop_coroutine_promise> [coroutine.handle.noop]
17.13.5.2.1 General [coroutine.handle.noop.general]
namespace std {
template<>
struct coroutine_handle<noop_coroutine_promise>
{
// 17.13.5.2.2, conversion
constexpr operator coroutine_handle<>() const noexcept;
// 17.13.5.2.3, observers
constexpr explicit operator bool() const noexcept;
constexpr bool done() const noexcept;
// 17.13.5.2.4, resumption
constexpr void operator()() const noexcept;
constexpr void resume() const noexcept;
constexpr void destroy() const noexcept;
// 17.13.5.2.5, promise access
noop_coroutine_promise& promise() const noexcept;
// 17.13.5.2.6, address
constexpr void* address() const noexcept;
private:
coroutine_handle(unspecified );
void* ptr; // exposition only
};
}
17.13.5.2.2 Conversion [coroutine.handle.noop.conv]
constexpr operator coroutine_handle<>() const noexcept;
1 Effects: Equivalent to:return coroutine_handle<>::from_address(address());
§ 17.13.5.2.2 © ISO/IEC
619

===== PAGE 631 =====

Dxxxx
17.13.5.2.3 Observers [coroutine.handle.noop.observers]
constexpr explicit operator bool() const noexcept;
1 Returns: true.
constexpr bool done() const noexcept;
2 Returns: false.
17.13.5.2.4 Resumption [coroutine.handle.noop.resumption]
constexpr void operator()() const noexcept;
constexpr void resume() const noexcept;
constexpr void destroy() const noexcept;
1 Effects: None.
2 Remarks: If noop_coroutine_handle is converted to coroutine_handle<>, calls to operator(),
resume and destroy on that handle will also have no observable effects.
17.13.5.2.5 Promise access [coroutine.handle.noop.promise]
noop_coroutine_promise& promise() const noexcept;
1 Returns: A reference to the promise object associated with this coroutine handle.
17.13.5.2.6 Address [coroutine.handle.noop.address]
constexpr void* address() const noexcept;
1 Returns: ptr.
2 Remarks: A noop_coroutine_handle’s ptr is always a non-null pointer value.
17.13.5.3 Function noop_coroutine [coroutine.noop.coroutine]
noop_coroutine_handle noop_coroutine() noexcept;
1 Returns: A handle to a coroutine that has no observable effects when resumed or destroyed.
2 Remarks: A handle returned fromnoop_coroutine may or may not compare equal to a handle returned
from another invocation ofnoop_coroutine.
17.13.6 Trivial awaitables [coroutine.trivial.awaitables]
namespace std {
struct suspend_never {
constexpr bool await_ready() const noexcept { return true; }
constexpr void await_suspend(coroutine_handle<>) const noexcept {}
constexpr void await_resume() const noexcept {}
};
struct suspend_always {
constexpr bool await_ready() const noexcept { return false; }
constexpr void await_suspend(coroutine_handle<>) const noexcept {}
constexpr void await_resume() const noexcept {}
};
}
1 [Note 1: The typessuspend_never and suspend_always can be used to indicate that anawait-expression either never
suspends or always suspends, and in either case does not produce a value.—end note]
17.14 Other runtime support [support.runtime]
17.14.1 General [support.runtime.general]
1 Headers <csetjmp> (nonlocal jumps),<csignal> (signal handling),<cstdarg> (variable arguments), and
<cstdlib> (runtime environmentgetenv, system), provide further compatibility with C code.
2 Calls to the functiongetenv (17.2.2) shall not introduce a data race (16.4.6.10) provided that nothing
modifies the environment.
[Note 1: Calls to the POSIX functionssetenv and putenv modify the environment. —end note]
§ 17.14.1 © ISO/IEC
620

===== PAGE 632 =====

Dxxxx
3 A call to thesetlocale function (28.3.5) may introduce a data race with other calls to thesetlocale
function or with calls to functions that are affected by the current C locale. The implementation shall behave
as if no library function other thanlocale::global calls thesetlocale function.
17.14.2 Header <cstdarg> synopsis [cstdarg.syn]
// all freestanding
#define __STDC_VERSION_STDARG_H__ 202311L
namespace std {
using va_list = see below ;
}
#define va_arg(V, P) see below
#define va_copy(VDST, VSRC) see below
#define va_end(V) see below
#define va_start(V, ...) see below
1 The contents of the header<cstdarg> are the same as the C standard library header<stdarg.h>, with the
following changes:
—(1.1) In lieu of the default argument promotions specified in ISO/IEC 9899:2024 6.5.3.3, the definition
in 7.6.1.3 applies.
—(1.2) If more than one argument is present forva_start and any of the second or subsequent arguments
expands to include unbalanced parentheses, or a preprocessing token that does not convert to a token,
the program is ill-formed, no diagnostic required. The preprocessing tokens comprising the second and
subsequent arguments tova_start (if any) are discarded.
[Note 1: va_start accepts a second argument for compatibility with prior revisions of C++. —end note]
See also: ISO/IEC 9899:2024, 7.16
17.14.3 Header <csetjmp> synopsis [csetjmp.syn]
#define __STDC_VERSION_SETJMP_H__ 202311L
namespace std {
using jmp_buf = see below ;
[[noreturn]] void longjmp(jmp_buf env, int val);
}
#define setjmp(env) see below
1 The contents of the header<csetjmp> are the same as the C standard library header<setjmp.h>.
2 The function signaturelongjmp(jmp_buf jbuf, int val) has more restricted behavior in this document.
A setjmp/longjmp call pair has undefined behavior if replacing thesetjmp and longjmp by catch and
throw would invoke any non-trivial destructors for any objects with automatic storage duration. A call to
setjmp or longjmp has undefined behavior if invoked in a suspension context of a coroutine (7.6.2.4).
See also: ISO/IEC 9899:2024, 7.13
17.14.4 Header <csignal> synopsis [csignal.syn]
namespace std {
using sig_atomic_t = see below ;
// 17.14.5, signal handlers
extern "C" using signal-handler = void(int); // exposition only
signal-handler * signal(int sig, signal-handler * func);
int raise(int sig);
}
§ 17.14.4 © ISO/IEC
621

===== PAGE 633 =====

Dxxxx
#define SIG_DFL see below
#define SIG_ERR see below
#define SIG_IGN see below
#define SIGABRT see below
#define SIGFPE see below
#define SIGILL see below
#define SIGINT see below
#define SIGSEGV see below
#define SIGTERM see below
1 The contents of the header<csignal> are the same as the C standard library header<signal.h>.
17.14.5 Signal handlers [support.signal]
1 A call to the functionsignal synchronizes with any resulting invocation of the signal handler so installed.
2 A plain lock-free atomic operationis an invocation of a functionf from 32.5, such that:
—(2.1) f is the functionatomic_is_lock_free(), or
—(2.2) f is the member functionis_lock_free(), or
—(2.3) f is a non-static member function of classatomic_flag, or
—(2.4) f is a non-member function, and the first parameter off has typecv atomic_flag*, or
—(2.5) f is a non-static member function invoked on an objectA, such thatA.is_lock_free() yields true, or
—(2.6) f is a non-member function, and for every pointer-to-atomic argumentA passed tof, atomic_is_-
lock_free(A) yields true.
3 An evaluation issignal-safe unless it includes one of the following:
—(3.1) a call to any standard library function, except for plain lock-free atomic operations and functions
explicitly identified as signal-safe;
[Note 1: This implicitly excludes the use ofnew and delete expressions that rely on a library-provided memory
allocator. —end note]
—(3.2) an access to an object with thread storage duration;
—(3.3) a dynamic_cast expression;
—(3.4) throwing of an exception;
—(3.5) control entering atry-block or function-try-block;
—(3.6) initialization of a variable with static storage duration requiring dynamic initialization (6.10.3.3, 8.10)183
; or
—(3.7) waiting for the completion of the initialization of a variable with static storage duration (8.10).
A signal handler invocation has undefined behavior if it includes an evaluation that is not signal-safe.
4 The function signal is signal-safe if it is invoked with the first argument equal to the signal number
corresponding to the signal that caused the invocation of the handler.
See also: ISO/IEC 9899:2024, 7.14
17.15 C headers [support.c.headers]
17.15.1 General [support.c.headers.general]
1 For compatibility with the C standard library, the C++ standard library provides theC headersshown in
Table 47. The intended use of these headers is for interoperability only. It is possible that C++ source files
need to include one of these headers in order to be valid C. Source files that are not intended to also be valid
C should not use any of the C headers.
[Note 1: The C headers either have no effect, such as<stdbool.h> (17.15.5) and<stdalign.h> (17.15.4), or otherwise
the corresponding header of the form<cname > provides the same facilities and assuredly defines them in namespace
std. —end note]
183) Such initialization can occur because it is the first odr-use (6.3) of that variable.
§ 17.15.1 © ISO/IEC
622

===== PAGE 634 =====

Dxxxx
[Example 1: The following source file is both valid C++ and valid C. Viewed as C++, it declares a function with C
language linkage; viewed as C it simply declares a function (and provides a prototype).
#include <uchar.h> // for char8_t in C, not necessary in C++
#include <stddef.h> // for size_t
#ifdef __cplusplus // see 15.12
extern "C" // see 9.12
#endif
void f(char8_t s[], size_t n);
—end example]
Table 47 — C headers [tab:c.headers]
<assert.h>
<complex.h>
<ctype.h>
<errno.h>
<fenv.h>
<float.h>
<inttypes.h>
<iso646.h>
<limits.h>
<locale.h>
<math.h>
<setjmp.h>
<signal.h>
<stdalign.h>
<stdarg.h>
<stdatomic.h>
<stdbit.h>
<stdbool.h>
<stdckdint.h>
<stddef.h>
<stdint.h>
<stdio.h>
<stdlib.h>
<string.h>
<tgmath.h>
<time.h>
<uchar.h>
<wchar.h>
<wctype.h>
17.15.2 Header <complex.h> synopsis [complex.h.syn]
#include <complex>
1 The header<complex.h> behaves as if it simply includes the header<complex> (29.4.2).
2 [Note 1: Names introduced by <complex> in namespace std are not placed into the global namespace scope by
<complex.h>. —end note]
17.15.3 Header <iso646.h> synopsis [iso646.h.syn]
1 The C++ header <iso646.h> is empty.
[Note 1: and, and_eq, bitand, bitor, compl, not_eq, not, or, or_eq, xor, andxor_eq are keywords in C++ (5.12).
—end note]
17.15.4 Header <stdalign.h> synopsis [stdalign.h.syn]
1 The contents of the C++ header <stdalign.h> are the same as the C standard library header<stdalign.h>.
See also: ISO/IEC 9899:2024, 7.15
17.15.5 Header <stdbool.h> synopsis [stdbool.h.syn]
1 The contents of the C++ header <stdbool.h> are the same as the C standard library header<stdbool.h>.
See also: ISO/IEC 9899:2024, 7.19
17.15.6 Header <tgmath.h> synopsis [tgmath.h.syn]
#include <cmath>
#include <complex>
1 The header<tgmath.h> behaves as if it simply includes the headers<cmath> (29.7.1) and<complex> (29.4.2).
2 [Note 1: The overloads provided in C by type-generic macros are already provided in<complex> and <cmath> by
“sufficient” additional overloads.—end note]
3 [Note 2: Names introduced by<cmath> or <complex> in namespacestd are not placed into the global namespace
scope by<tgmath.h>. —end note]
17.15.7 Other C headers [support.c.headers.other]
1 Every C header other than<complex.h> (17.15.2), <iso646.h> (17.15.3), <stdalign.h> (17.15.4),
<stdatomic.h> (32.5.12), <stdbit.h> (22.12), <stdbool.h> (17.15.5), <stdckdint.h> (29.11.1), and
<tgmath.h> (17.15.6), each of which has a name of the form<name.h>, behaves as if each name placed in
the standard library namespace by the corresponding<cname > header is placed within the global namespace
scope, except for the functions described in 29.7.6, thestd::lerp function overloads (29.7.4), the declaration
§ 17.15.7 © ISO/IEC
623

===== PAGE 635 =====

Dxxxx
of std::byte (17.2.1), and the functions and function templates described in 17.2.5. It is unspecified whether
these names are first declared or defined within namespace scope (6.4.6) of the namespacestd and are then
injected into the global namespace scope by explicitusing-declarations (9.10).
2 [Example 1: The header<cstdlib> assuredly provides its declarations and definitions within the namespacestd. It
may also provide these names within the global namespace. The header<stdlib.h> assuredly provides the same
declarations and definitions within the global namespace, much as in ISO/IEC 9899. It may also provide these names
within the namespacestd. —end example]
§ 17.15.7 © ISO/IEC
624

===== PAGE 636 =====

Dxxxx
18 Concepts library [concepts]
18.1 General [concepts.general]
1 This Clause describes library components that C++ programs may use to perform compile-time validation
of template arguments and perform function dispatch based on properties of types. The purpose of these
concepts is to establish a foundation for equational reasoning in programs.
2 The following subclauses describe language-related concepts, comparison concepts, object concepts, and
callable concepts as summarized in Table 48.
Table 48 — Fundamental concepts library summary [tab:concepts.summary]
Subclause Header
18.2 Equality preservation
18.4 Language-related concepts <concepts>
18.5 Comparison concepts
18.6 Object concepts
18.7 Callable concepts
18.2 Equality preservation [concepts.equality]
1 An expression isequality-preserving if, given equal inputs, the expression results in equal outputs. The inputs
to an expression are the set of the expression’s operands. The output of an expression is the expression’s
result and all operands modified by the expression. For the purposes of this subclause, the operands of an
expression are the largest subexpressions that include only:
—(1.1) an id-expression (7.5.5), and
—(1.2) invocations of the library function templatesstd::move, std::forward, andstd::declval (22.2.4,
22.2.6).
[Example 1: The operands of the expressiona = std::move(b) are a and std::move(b). —end example]
2 Not all input values need be valid for a given expression.
[Example 2: For integersa and b, the expressiona / b is not well-defined whenb is 0. This does not preclude the
expression a / b being equality-preserving. —end example]
The domain of an expression is the set of input values for which the expression is required to be well-defined.
3 Expressions required to be equality-preserving are further required to be stable: two evaluations of such an
expression with the same input objects are required to have equal outputs absent any explicit intervening
modification of those input objects.
[Note 1: This requirement allows generic code to reason about the current values of objects based on knowledge
of the prior values as observed via equality-preserving expressions. It effectively forbids spontaneous changes to an
object, changes to an object from another thread of execution, changes to an object as side effects of non-modifying
expressions, and changes to an object as side effects of modifying a distinct object if those changes could be observable
to a library function via an equality-preserving expression that is required to be valid for that object.—end note]
4 Expressions declared in arequires-expression in the library clauses are required to be equality-preserving,
except for those annotated with the comment “not required to be equality-preserving.” An expression so
annotated may be equality-preserving, but is not required to be so.
5 An expression that may alter the value of one or more of its inputs in a manner observable to equality-
preserving expressions is said to modify those inputs. The library clauses use a notational convention to
specify which expressions declared in arequires-expression modify which inputs: except where otherwise
specified, an expression operand that is a non-constant lvalue or rvalue may be modified. Operands that
are constant lvalues or rvalues are required to not be modified. For the purposes of this subclause, the
cv-qualification and value category of each operand are determined by assuming that each template type
parameter denotes a cv-unqualified complete non-array object type.
§ 18.2 © ISO/IEC
625

===== PAGE 637 =====

Dxxxx
6 Where arequires-expression declares an expression that is non-modifying for some constant lvalue operand,
additional variations of that expression that accept a non-constant lvalue or (possibly constant) rvalue for
the given operand are also required except where such an expression variation is explicitly required with
differing semantics. Theseimplicit expression variationsare required to meet the semantic requirements of
the declared expression. The extent to which an implementation validates the syntax of the variations is
unspecified.
7 [Example 3:
template<class T> concept C = requires(T a, T b, const T c, const T d) {
c == d; // #1
a = std::move(b); // #2
a = c; // #3
};
For the above example:
—(7.1) Expression #1 does not modify either of its operands, #2 modifies both of its operands, and #3 modifies only
its first operanda.
—(7.2) Expression #1 implicitly requires additional expression variations that meet the requirements forc == d
(including non-modification), as if the expressions
c == b;
c == std::move(d); c == std::move(b);
std::move(c) == d; std::move(c) == b;
std::move(c) == std::move(d); std::move(c) == std::move(b);
a == d; a == b;
a == std::move(d); a == std::move(b);
std::move(a) == d; std::move(a) == b;
std::move(a) == std::move(d); std::move(a) == std::move(b);
had been declared as well.
—(7.3) Expression #3 implicitly requires additional expression variations that meet the requirements fora = c
(including non-modification of the second operand), as if the expressionsa = b and a = std::move(c) had
been declared. Expression #3 does not implicitly require an expression variation with a non-constant rvalue
second operand, since expression #2 already specifies exactly such an expression explicitly.
—end example]
8 [Example 4: The following typeT meets the explicitly stated syntactic requirements of conceptC above but does not
meet the additional implicit requirements:
struct T {
bool operator==(const T&) const { return true; }
bool operator==(T&) = delete;
};
T fails to meet the implicit requirements ofC, soT satisfies but does not modelC. Since implementations are not
required to validate the syntax of implicit requirements, it is unspecified whether an implementation diagnoses as
ill-formed a program that requiresC<T>. —end example]
18.3 Header <concepts> synopsis [concepts.syn]
// all freestanding
namespace std {
// 18.4, language-related concepts
// 18.4.2, conceptsame_as
template<class T, class U>
concept same_as = see below ;
// 18.4.3, conceptderived_from
template<class Derived, class Base>
concept derived_from = see below ;
// 18.4.4, conceptconvertible_to
template<class From, class To>
concept convertible_to = see below ;
§ 18.3 © ISO/IEC
626

===== PAGE 638 =====

Dxxxx
// 18.4.5, conceptcommon_reference_with
template<class T, class U>
concept common_reference_with = see below ;
// 18.4.6, conceptcommon_with
template<class T, class U>
concept common_with = see below ;
// 18.4.7, arithmetic concepts
template<class T>
concept integral = see below ;
template<class T>
concept signed_integral = see below ;
template<class T>
concept unsigned_integral = see below ;
template<class T>
concept floating_point = see below ;
// 18.4.8, conceptassignable_from
template<class LHS, class RHS>
concept assignable_from = see below ;
// 18.4.9, conceptswappable
namespace ranges {
inline namespace unspecified {
inline constexpr unspecified swap = unspecified ;
}
}
template<class T>
concept swappable = see below ;
template<class T, class U>
concept swappable_with = see below ;
// 18.4.10, conceptdestructible
template<class T>
concept destructible = see below ;
// 18.4.11, conceptconstructible_from
template<class T, class... Args>
concept constructible_from = see below ;
// 18.4.12, conceptdefault_initializable
template<class T>
concept default_initializable = see below ;
// 18.4.13, conceptmove_constructible
template<class T>
concept move_constructible = see below ;
// 18.4.14, conceptcopy_constructible
template<class T>
concept copy_constructible = see below ;
// 18.5, comparison concepts
// 18.5.4, conceptequality_comparable
template<class T>
concept equality_comparable = see below ;
template<class T, class U>
concept equality_comparable_with = see below ;
// 18.5.5, concepttotally_ordered
template<class T>
concept totally_ordered = see below ;
§ 18.3 © ISO/IEC
627

===== PAGE 639 =====

Dxxxx
template<class T, class U>
concept totally_ordered_with = see below ;
// 18.6, object concepts
template<class T>
concept movable = see below ;
template<class T>
concept copyable = see below ;
template<class T>
concept semiregular = see below ;
template<class T>
concept regular = see below ;
// 18.7, callable concepts
// 18.7.2, conceptinvocable
template<class F, class... Args>
concept invocable = see below ;
// 18.7.3, conceptregular_invocable
template<class F, class... Args>
concept regular_invocable = see below ;
// 18.7.4, conceptpredicate
template<class F, class... Args>
concept predicate = see below ;
// 18.7.5, conceptrelation
template<class R, class T, class U>
concept relation = see below ;
// 18.7.6, conceptequivalence_relation
template<class R, class T, class U>
concept equivalence_relation = see below ;
// 18.7.7, conceptstrict_weak_order
template<class R, class T, class U>
concept strict_weak_order = see below ;
}
18.4 Language-related concepts [concepts.lang]
18.4.1 General [concepts.lang.general]
1 Subclause 18.4 contains the definition of concepts corresponding to language features. These concepts express
relationships between types, type classifications, and fundamental type properties.
18.4.2 Concept same_as [concept.same]
template<class T, class U>
concept same-as-impl = is_same_v<T, U>; // exposition only
template<class T, class U>
concept same_as = same-as-impl <T, U> && same-as-impl <U, T>;
1 [Note 1: same_as<T, U> subsumes same_as<U, T> and vice versa. —end note]
18.4.3 Concept derived_from [concept.derived]
template<class Derived, class Base>
concept derived_from =
is_base_of_v<Base, Derived> &&
is_convertible_v<const volatile Derived*, const volatile Base*>;
1 [Note 1: derived_from<Derived, Base> is satisfied if and only ifDerived is publicly and unambiguously
derived fromBase, orDerived and Base are the same class type ignoring cv-qualifiers.—end note]
§ 18.4.3 © ISO/IEC
628

===== PAGE 640 =====

Dxxxx
18.4.4 Concept convertible_to [concept.convertible]
1 Given types From and To and an expressionE whose type and value category are the same as those of
declval<From>(), convertible_to<From, To> requires E to be both implicitly and explicitly convertible
to typeTo. The implicit and explicit conversions are required to produce equal results.
template<class From, class To>
concept convertible_to =
is_convertible_v<From, To> &&
requires {
static_cast<To>(declval<From>());
};
2 Let FromR be add_rvalue_reference_t<From> and test be the invented function:
To test(FromR (&f)()) {
return f();
}
and letf be a function with no arguments and return typeFromR such thatf() is equality-preserving.
Types From and To model convertible_to<From, To> only if:
—(2.1) To is not an object or reference-to-object type, orstatic_cast<To>(f()) is equal totest(f).
—(2.2) FromR is not a reference-to-object type, or
—(2.2.1) If FromR is an rvalue reference to a non const-qualified type, the resulting state of the object
referenced byf() after either above expression is valid but unspecified (16.4.6.17).
—(2.2.2) Otherwise, the object referred to byf() is not modified by either above expression.
18.4.5 Concept common_reference_with [concept.commonref]
1 For two typesT and U, ifcommon_reference_t<T, U> is well-formed and denotes a typeC such that both
convertible_to<T, C> and convertible_to<U, C> are modeled, thenT and U share acommon reference
type, C.
[Note 1: C can be the same asT or U, or can be a different type.C can be a reference type.—end note]
template<class T, class U>
concept common_reference_with =
same_as<common_reference_t<T, U>, common_reference_t<U, T>> &&
convertible_to<T, common_reference_t<T, U>> &&
convertible_to<U, common_reference_t<T, U>>;
2 Let C be common_reference_t<T, U>. Let t1 and t2 be equality-preserving expressions (18.2) such
that decltype((t1)) and decltype((t2)) are each T, and let u1 and u2 be equality-preserving
expressions such thatdecltype((u1)) and decltype((u2)) are each U. T and U model common_-
reference_with<T, U> only if
—(2.1) C(t1) equals C(t2) if and only ift1 equals t2, and
—(2.2) C(u1) equals C(u2) if and only ifu1 equals u2.
3 [Note 2: Users can customize the behavior ofcommon_reference_with by specializing thebasic_common_-
reference class template (21.3.9.7). —end note]
18.4.6 Concept common_with [concept.common]
1 If T and U can both be explicitly converted to some third type,C, thenT and U share acommon type, C.
[Note 1: C can be the same asT or U, or can be a different type.C is not necessarily unique.—end note]
template<class T, class U>
concept common_with =
same_as<common_type_t<T, U>, common_type_t<U, T>> &&
requires {
static_cast<common_type_t<T, U>>(declval<T>());
static_cast<common_type_t<T, U>>(declval<U>());
} &&
§ 18.4.6 © ISO/IEC
629

===== PAGE 641 =====

Dxxxx
common_reference_with<
add_lvalue_reference_t<const T>,
add_lvalue_reference_t<const U>> &&
common_reference_with<
add_lvalue_reference_t<common_type_t<T, U>>,
common_reference_t<
add_lvalue_reference_t<const T>,
add_lvalue_reference_t<const U>>>;
2 Let C be common_type_t<T, U>. Let t1 and t2 be equality-preserving expressions (18.2) such that
decltype((t1)) and decltype((t2)) are eachT, and letu1 and u2 be equality-preserving expressions
such thatdecltype((u1)) and decltype((u2)) are eachU. T and U model common_with<T, U> only
if
—(2.1) C(t1) equals C(t2) if and only ift1 equals t2, and
—(2.2) C(u1) equals C(u2) if and only ifu1 equals u2.
3 [Note 2: Users can customize the behavior ofcommon_with by specializing thecommon_type class template
(21.3.9.7). —end note]
18.4.7 Arithmetic concepts [concepts.arithmetic]
template<class T>
concept integral = is_integral_v<T>;
template<class T>
concept signed_integral = integral<T> && is_signed_v<T>;
template<class T>
concept unsigned_integral = integral<T> && !signed_integral<T>;
template<class T>
concept floating_point = is_floating_point_v<T>;
1 [Note 1: signed_integral can be modeled even by types that are not signed integer types (6.9.2); for example,
char. —end note]
2 [Note 2: unsigned_integral can be modeled even by types that are not unsigned integer types (6.9.2); for
example, bool. —end note]
18.4.8 Concept assignable_from [concept.assignable]
template<class LHS, class RHS>
concept assignable_from =
is_lvalue_reference_v<LHS> &&
common_reference_with<const remove_reference_t<LHS>&, const remove_reference_t<RHS>&> &&
requires(LHS lhs, RHS&& rhs) {
{ lhs = std::forward<RHS>(rhs) } -> same_as<LHS>;
};
1 Let:
—(1.1) lhs be an lvalue that refers to an objectlcopy such thatdecltype((lhs)) is LHS,
—(1.2) rhs be an expression such thatdecltype((rhs)) is RHS, and
—(1.3) rcopy be a distinct object that is equal torhs.
LHS and RHS model assignable_from<LHS, RHS> only if
—(1.4) addressof(lhs = rhs) == addressof(lcopy).
—(1.5) After evaluatinglhs = rhs:
—(1.5.1) lhs is equal torcopy, unlessrhs is a non-const xvalue that refers tolcopy.
—(1.5.2) If rhs is a non-const xvalue, the resulting state of the object to which it refers is valid but
unspecified (16.4.6.17).
—(1.5.3) Otherwise, ifrhs is a glvalue, the object to which it refers is not modified.
2 [Note 1: Assignment need not be a total function (16.3.2.3); in particular, if assignment to an objectx can
result in a modification of some other objecty, thenx = y is likely not in the domain of=. —end note]
§ 18.4.8 © ISO/IEC
630

===== PAGE 642 =====

Dxxxx
18.4.9 Concept swappable [concept.swappable]
1 Let t1 and t2 be equality-preserving expressions that denote distinct equal objects of typeT, and letu1 and
u2 similarly denote distinct equal objects of typeU.
[Note 1: t1 and u1 can denote distinct objects, or the same object.—end note]
An operationexchanges the valuesdenoted byt1 and u1 if and only if the operation modifies neithert2 nor
u2 and:
—(1.1) If T and U are the same type, the result of the operation is thatt1 equals u2 and u1 equals t2.
—(1.2) If T and U are different types andcommon_reference_with<decltype((t1)), decltype((u1))> is
modeled, the result of the operation is thatC(t1) equals C(u2) and C(u1) equals C(t2) where C is
common_reference_t<decltype((t1)), decltype((u1))>.
2 The nameranges::swapdenotes a customization point object (16.3.3.3.5). The expressionranges::swap(E1,
E2) for subexpressionsE1 and E2 is expression-equivalent to an expressionS determined as follows:
—(2.1) S is (void)swap(E1, E2)184 if E1 or E2 has class or enumeration type (6.9.4) and that expression is
valid, with overload resolution performed in a context that includes the declaration
template<class T>
void swap(T&, T&) = delete;
and does not include a declaration ofranges::swap. If the function selected by overload resolution
does not exchange the values denoted byE1 and E2, the program is ill-formed, no diagnostic required.
[Note 2: This precludes calling unconstrained program-defined overloads ofswap. When the deleted overload is
viable, program-defined overloads need to be more specialized (13.7.7.3) to be selected.—end note]
—(2.2) Otherwise, ifE1 and E2 are lvalues of array types (6.9.4) with equal extent andranges::swap(*E1,
*E2) is a valid expression,S is (void)ranges::swap_ranges(E1, E2), except thatnoexcept(S) is
equal tonoexcept(ranges::swap(*E1, *E2)).
—(2.3) Otherwise, if E1 and E2 are lvalues of the same typeT that models move_constructible<T> and
assignable_from<T&, T>, S is an expression that exchanges the denoted values.S is a constant
expression if
—(2.3.1) T is a literal type (6.9.1),
—(2.3.2) both E1 = std::move(E2) and E2 = std::move(E1) are constant subexpressions (3.15), and
—(2.3.3) the full-expressions of the initializers in the declarations
T t1(std::move(E1));
T t2(std::move(E2));
are constant subexpressions.
noexcept(S)is equal tois_nothrow_move_constructible_v<T> && is_nothrow_move_assignable-
_v<T>.
—(2.4) Otherwise, ranges::swap(E1, E2) is ill-formed.
[Note 3: This case can result in substitution failure whenranges::swap(E1, E2) appears in the immediate
context of a template instantiation.—end note]
3 [Note 4: Wheneverranges::swap(E1, E2) is a valid expression, it exchanges the values denoted byE1 and E2 and
has typevoid. —end note]
template<class T>
concept swappable = requires(T& a, T& b) { ranges::swap(a, b); };
template<class T, class U>
concept swappable_with =
common_reference_with<T, U> &&
requires(T&& t, U&& u) {
ranges::swap(std::forward<T>(t), std::forward<T>(t));
ranges::swap(std::forward<U>(u), std::forward<U>(u));
ranges::swap(std::forward<T>(t), std::forward<U>(u));
ranges::swap(std::forward<U>(u), std::forward<T>(t));
};
184) The nameswap is used here unqualified.
§ 18.4.9 © ISO/IEC
631

===== PAGE 643 =====

Dxxxx
4 [Note 5: The semantics of the swappable and swappable_with concepts are fully defined by theranges::swap
customization point object. —end note]
5 [Example 1: User code can ensure that the evaluation ofswap calls is performed in an appropriate context under the
various conditions as follows:
#include <cassert>
#include <concepts>
#include <utility>
namespace ranges = std::ranges;
template<class T, std::swappable_with<T> U>
void value_swap(T&& t, U&& u) {
ranges::swap(std::forward<T>(t), std::forward<U>(u));
}
template<std::swappable T>
void lv_swap(T& t1, T& t2) {
ranges::swap(t1, t2);
}
namespace N {
struct A { int m; };
struct Proxy {
A* a;
Proxy(A& a) : a{&a} {}
friend void swap(Proxy x, Proxy y) {
ranges::swap(*x.a, *y.a);
}
};
Proxy proxy(A& a) { return Proxy{ a }; }
}
int main() {
int i = 1, j = 2;
lv_swap(i, j);
assert(i == 2 && j == 1);
N::A a1 = { 5 }, a2 = { -5 };
value_swap(a1, proxy(a2));
assert(a1.m == -5 && a2.m == 5);
}
—end example]
18.4.10 Concept destructible [concept.destructible]
1 The destructible concept specifies properties of all types, instances of which can be destroyed at the end
of their lifetime, or reference types.
template<class T>
concept destructible = is_nothrow_destructible_v<T>;
2 [Note 1: Unlike the Cpp17Destructible requirements (Table 35), this concept forbids destructors that are
potentially throwing, even if a particular invocation of the destructor does not actually throw.—end note]
18.4.11 Concept constructible_from [concept.constructible]
1 The constructible_from concept constrains the initialization of a variable of a given type with a particular
set of argument types.
template<class T, class... Args>
concept constructible_from = destructible<T> && is_constructible_v<T, Args...>;
§ 18.4.11 © ISO/IEC
632

===== PAGE 644 =====

Dxxxx
18.4.12 Concept default_initializable [concept.default.init]
template<class T>
constexpr bool is-default-initializable = see below ; // exposition only
template<class T>
concept default_initializable = constructible_from<T> &&
requires { T{}; } &&
is-default-initializable <T>;
1 For a typeT, is-default-initializable <T> is true if and only if the variable definition
T t;
is well-formed for some invented variablet; otherwise it isfalse. Access checking is performed as if in
a context unrelated toT. Only the validity of the immediate context of the variable initialization is
considered.
18.4.13 Concept move_constructible [concept.moveconstructible]
template<class T>
concept move_constructible = constructible_from<T, T> && convertible_to<T, T>;
1 If T is an object type, then letrv be an rvalue of typeT and u2 a distinct object of typeT equal torv.
T models move_constructible only if
—(1.1) After the definitionT u = rv;, u is equal tou2.
—(1.2) T(rv) is equal tou2.
—(1.3) If T is notconst, rv’s resulting state is valid but unspecified (16.4.6.17); otherwise, it is unchanged.
18.4.14 Concept copy_constructible [concept.copyconstructible]
template<class T>
concept copy_constructible =
move_constructible<T> &&
constructible_from<T, T&> && convertible_to<T&, T> &&
constructible_from<T, const T&> && convertible_to<const T&, T> &&
constructible_from<T, const T> && convertible_to<const T, T>;
1 If T is an object type, then letv be an lvalue of typeT or const T or an rvalue of typeconst T. T
models copy_constructible only if
—(1.1) After the definitionT u = v;, u is equal tov (18.2) andv is not modified.
—(1.2) T(v) is equal tov and does not modifyv.
18.5 Comparison concepts [concepts.compare]
18.5.1 General [concepts.compare.general]
1 Subclause 18.5 describes concepts that establish relationships and orderings on values of possibly differing
object types.
2 Given an expressionE and a typeC, letCONVERT_TO_LVALUE <C>(E) be:
—(2.1) static_cast<const C&>(as_const(E)) if that is a valid expression, and
—(2.2) static_cast<const C&>(std::move(E)) otherwise.
18.5.2 Boolean testability [concept.booleantestable]
1 The exposition-onlyboolean-testable concept specifies the requirements on expressions that are convertible
to bool and for which the logical operators (7.6.14, 7.6.15, 7.6.2.2) have the conventional semantics.
template<class T>
concept boolean-testable-impl = convertible_to<T, bool>; // exposition only
2 Let e be an expression such thatdecltype((e)) is T. T models boolean-testable-impl only if
—(2.1) either remove_cvref_t<T> is not a class type, or a search for the namesoperator&& and operator||
in the scope ofremove_cvref_t<T> finds nothing; and
§ 18.5.2 © ISO/IEC
633

===== PAGE 645 =====

Dxxxx
—(2.2) argument-dependent lookup (6.5.4) for the namesoperator&& and operator|| with T as the only
argument type finds no disqualifying declaration (defined below).
3 A disqualifying parameteris a function parameter whose declared typeP
—(3.1) is not dependent on a template parameter, and there exists an implicit conversion sequence (12.2.4.2)
from e to P; or
—(3.2) is dependent on one or more template parameters, and either
—(3.2.1) P contains no template parameter that participates in template argument deduction (13.10.3.6), or
—(3.2.2) template argument deduction using the rules for deducing template arguments in a function
call (13.10.3.2) ande as the argument succeeds.
4 A key parameterof a function templateD is a function parameter of typecv X or reference thereto, whereX
names a specialization of a class template that has the same innermost enclosing non-inline namespace asD,
and X contains at least one template parameter that participates in template argument deduction.
[Example 1: In
namespace Z {
template<class> struct C {};
template<class T>
void operator&&(C<T> x, T y);
template<class T>
void operator||(C<type_identity_t<T>> x, T y);
}
the declaration ofZ::operator&& contains one key parameter,C<T> x, and the declaration ofZ::operator|| contains
no key parameters. —end example]
5 A disqualifying declarationis
—(5.1) a (non-template) function declaration that contains at least one disqualifying parameter; or
—(5.2) a function template declaration that contains at least one disqualifying parameter, where
—(5.2.1) at least one disqualifying parameter is a key parameter; or
—(5.2.2) the declaration contains no key parameters; or
—(5.2.3) the declaration declares a function template to which no name is bound (9.3.4).
6 [Note 1: The intention is to ensure that given two typesT1 and T2 that each modelboolean-testable-impl , the&&
and || operators within the expressionsdeclval<T1>() && declval<T2>() and declval<T1>() || declval<T2>()
resolve to the corresponding built-in operators.—end note]
template<class T>
concept boolean-testable = // exposition only
boolean-testable-impl <T> && requires(T&& t) {
{ !std::forward<T>(t) } -> boolean-testable-impl ;
};
7 Let e be an expression such thatdecltype((e)) is T. T models boolean-testable only if bool(e) ==
!bool(!e).
8 [Example 2: The typesbool, true_type (21.3.3), int*, andbitset<N>::reference (22.9.2) modelboolean-testable .
—end example]
18.5.3 Comparison common types [concept.comparisoncommontype]
template<class T, class U, class C = common_reference_t<const T&, const U&>>
concept comparison-common-type-with-impl = // exposition only
same_as<common_reference_t<const T&, const U&>,
common_reference_t<const U&, const T&>> &&
requires {
requires convertible_to<const T&, const C&> || convertible_to<T, const C&>;
requires convertible_to<const U&, const C&> || convertible_to<U, const C&>;
};
§ 18.5.3 © ISO/IEC
634

===== PAGE 646 =====

Dxxxx
template<class T, class U>
concept comparison-common-type-with = // exposition only
comparison-common-type-with-impl <remove_cvref_t<T>, remove_cvref_t<U>>;
1 Let C be common_reference_t<const T&, const U&>. Let t1 and t2 be equality-preserving expressions
that are lvalues of typeremove_cvref_t<T>, and letu1 and u2 be equality-preserving expressions that are
lvalues of typeremove_cvref_t<U>. T and U model comparison-common-type-with <T, U> only if
—(1.1) CONVERT_TO_LVALUE <C>(t1) equals CONVERT_TO_LVALUE <C>(t2) if and only ift1 equals t2, and
—(1.2) CONVERT_TO_LVALUE <C>(u1) equals CONVERT_TO_LVALUE <C>(u2) if and only ifu1 equals u2
18.5.4 Concept equality_comparable [concept.equalitycomparable]
template<class T, class U>
concept weakly-equality-comparable-with = // exposition only
requires(const remove_reference_t<T>& t,
const remove_reference_t<U>& u) {
{ t == u } -> boolean-testable ;
{ t != u } -> boolean-testable ;
{ u == t } -> boolean-testable ;
{ u != t } -> boolean-testable ;
};
1 Given types T and U, let t and u be lvalues of types const remove_reference_t<T> and const
remove_reference_t<U> respectively. T and U model weakly-equality-comparable-with <T, U>
only if
—(1.1) t == u, u == t, t != u, andu != t have the same domain.
—(1.2) bool(u == t) == bool(t == u).
—(1.3) bool(t != u) == !bool(t == u).
—(1.4) bool(u != t) == bool(t != u).
template<class T>
concept equality_comparable = weakly-equality-comparable-with <T, T>;
2 Let a and b be objects of typeT. T models equality_comparable only ifbool(a == b) is true when
a is equal tob (18.2), andfalse otherwise.
3 [Note 1: The requirement that the expressiona == b is equality-preserving implies that== is transitive and
symmetric. —end note]
template<class T, class U>
concept equality_comparable_with =
equality_comparable<T> && equality_comparable<U> &&
comparison-common-type-with <T, U> &&
equality_comparable<
common_reference_t<
const remove_reference_t<T>&,
const remove_reference_t<U>&>> &&
weakly-equality-comparable-with <T, U>;
4 Given typesT and U, lett and t2 be lvalues denoting distinct equal objects of typesconst remove_-
reference_t<T> and remove_cvref_t<T>, respectively, letu and u2 be lvalues denoting distinct equal
objects of typesconst remove_reference_t<U> and remove_cvref_t<U>, respectively, and letC be:
common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>
T and U model equality_comparable_with<T, U> only if
bool(t == u) == bool(CONVERT_TO_LVALUE <C>(t2) == CONVERT_TO_LVALUE <C>(u2))
18.5.5 Concept totally_ordered [concept.totallyordered]
template<class T>
concept totally_ordered =
equality_comparable<T> && partially-ordered-with <T, T>;
§ 18.5.5 © ISO/IEC
635

===== PAGE 647 =====

Dxxxx
1 Given a typeT, leta, b, andc be lvalues of typeconst remove_reference_t<T>. T models totally_-
ordered only if
—(1.1) Exactly one ofbool(a < b), bool(a > b), orbool(a == b) is true.
—(1.2) If bool(a < b) and bool(b < c), thenbool(a < c).
—(1.3) bool(a <= b) == !bool(b < a).
—(1.4) bool(a >= b) == !bool(a < b).
template<class T, class U>
concept totally_ordered_with =
totally_ordered<T> && totally_ordered<U> &&
equality_comparable_with<T, U> &&
totally_ordered<
common_reference_t<
const remove_reference_t<T>&,
const remove_reference_t<U>&>> &&
partially-ordered-with <T, U>;
2 Given typesT and U, lett and t2 be lvalues denoting distinct equal objects of typesconst remove_-
reference_t<T> and remove_cvref_t<T>, respectively, letu and u2 be lvalues denoting distinct equal
objects of typesconst remove_reference_t<U> and remove_cvref_t<U>, respectively, and letC be:
common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>
T and U model totally_ordered_with<T, U> only if
—(2.1) bool(t < u) == bool(CONVERT_TO_LVALUE <C>(t2) < CONVERT_TO_LVALUE <C>(u2)).
—(2.2) bool(t > u) == bool(CONVERT_TO_LVALUE <C>(t2) > CONVERT_TO_LVALUE <C>(u2)).
—(2.3) bool(t <= u) == bool(CONVERT_TO_LVALUE <C>(t2) <= CONVERT_TO_LVALUE <C>(u2)).
—(2.4) bool(t >= u) == bool(CONVERT_TO_LVALUE <C>(t2) >= CONVERT_TO_LVALUE <C>(u2)).
—(2.5) bool(u < t) == bool(CONVERT_TO_LVALUE <C>(u2) < CONVERT_TO_LVALUE <C>(t2)).
—(2.6) bool(u > t) == bool(CONVERT_TO_LVALUE <C>(u2) > CONVERT_TO_LVALUE <C>(t2)).
—(2.7) bool(u <= t) == bool(CONVERT_TO_LVALUE <C>(u2) <= CONVERT_TO_LVALUE <C>(t2)).
—(2.8) bool(u >= t) == bool(CONVERT_TO_LVALUE <C>(u2) >= CONVERT_TO_LVALUE <C>(t2)).
18.6 Object concepts [concepts.object]
1 This subclause describes concepts that specify the basis of the value-oriented programming style on which
the library is based.
template<class T>
concept movable = is_object_v<T> && move_constructible<T> &&
assignable_from<T&, T> && swappable<T>;
template<class T>
concept copyable = copy_constructible<T> && movable<T> && assignable_from<T&, T&> &&
assignable_from<T&, const T&> && assignable_from<T&, const T>;
template<class T>
concept semiregular = copyable<T> && default_initializable<T>;
template<class T>
concept regular = semiregular<T> && equality_comparable<T>;
2 [Note 1: The semiregular concept is modeled by types that behave similarly to fundamental types likeint,
except that they need not be comparable with==. —end note]
3 [Note 2: The regular concept is modeled by types that behave similarly to fundamental types likeint and
that are comparable with==. —end note]
18.7 Callable concepts [concepts.callable]
18.7.1 General [concepts.callable.general]
1 The concepts in 18.7 describe the requirements on callable types (22.10.3) and their arguments.
§ 18.7.1 © ISO/IEC
636

===== PAGE 648 =====

Dxxxx
18.7.2 Concept invocable [concept.invocable]
1 The invocable concept specifies a relationship between a callable type (22.10.3)F and a set of argument
types Args... which can be evaluated by the library functioninvoke (22.10.5).
template<class F, class... Args>
concept invocable = requires(F&& f, Args&&... args) {
invoke(std::forward<F>(f), std::forward<Args>(args)...); // not required to be equality-preserving
};
2 [Example 1: A function that generates random numbers can modelinvocable, since theinvoke function call
expression is not required to be equality-preserving (18.2).—end example]
18.7.3 Concept regular_invocable [concept.regularinvocable]
template<class F, class... Args>
concept regular_invocable = invocable<F, Args...>;
1 The invoke function call expression shall be equality-preserving (18.2) and shall not modify the function
object or the arguments.
[Note 1: This requirement supersedes the “not required to be equality-preserving” comment in the definition of
invocable. —end note]
2 [Example 1: A random number generator does not modelregular_invocable. —end example]
3 [Note 2: The distinction betweeninvocable and regular_invocable is purely semantic. —end note]
18.7.4 Concept predicate [concept.predicate]
template<class F, class... Args>
concept predicate =
regular_invocable<F, Args...> && boolean-testable <invoke_result_t<F, Args...>>;
18.7.5 Concept relation [concept.relation]
template<class R, class T, class U>
concept relation =
predicate<R, T, T> && predicate<R, U, U> &&
predicate<R, T, U> && predicate<R, U, T>;
18.7.6 Concept equivalence_relation [concept.equiv]
template<class R, class T, class U>
concept equivalence_relation = relation<R, T, U>;
1 A relation models equivalence_relation only if it imposes an equivalence relation on its arguments.
18.7.7 Concept strict_weak_order [concept.strictweakorder]
template<class R, class T, class U>
concept strict_weak_order = relation<R, T, U>;
1 A relation models strict_weak_order only if it imposes astrict weak orderingon its arguments.
2 The termstrict refers to the requirement of an irreflexive relation (!comp(x, x) for allx), and the term
weak to requirements that are not as strong as those for a total ordering, but stronger than those for a
partial ordering. If we defineequiv(a, b) as !comp(a, b) && !comp(b, a), then the requirements
are thatcomp and equiv both be transitive relations:
—(2.1) comp(a, b) && comp(b, c) implies comp(a, c)
—(2.2) equiv(a, b) && equiv(b, c) implies equiv(a, c)
3 [Note 1: Under these conditions, it can be shown that
—(3.1) equiv is an equivalence relation,
—(3.2) comp induces a well-defined relation on the equivalence classes determined byequiv, and
—(3.3) the induced relation is a strict total ordering.
—end note]
§ 18.7.7 © ISO/IEC
637

===== PAGE 649 =====

Dxxxx
19 Diagnostics library [diagnostics]
19.1 General [diagnostics.general]
1 This Clause describes components that C++ programs may use to detect and report error conditions.
2 The following subclauses describe components for reporting several kinds of exceptional conditions, document-
ing program assertions, obtaining stacktraces, and a global variable for error number codes, as summarized
in Table 49.
Table 49 — Diagnostics library summary [tab:diagnostics.summary]
Subclause Header
19.2 Exception classes <stdexcept>
19.3 Assertions <cassert>
19.4 Error numbers <cerrno>
19.5 System error support <system_error>
19.6 Stacktrace <stacktrace>
19.7 Debugging <debugging>
19.2 Exception classes [std.exceptions]
19.2.1 General [std.exceptions.general]
1 The C++ standard library provides classes to be used to report certain errors (16.4.6.14) in C++ programs.
In the error model reflected in these classes, errors are divided into two broad categories:logic errors and
runtime errors.
2 The distinguishing characteristic of logic errors is that they are due to errors in the internal logic of the
program. In theory, they are preventable.
3 By contrast, runtime errors are due to events beyond the scope of the program. They cannot be easily
predicted in advance. The header<stdexcept> defines several types of predefined exceptions for reporting
errors in a C++ program. These exceptions are related by inheritance.
19.2.2 Header <stdexcept> synopsis [stdexcept.syn]
namespace std {
class logic_error;
class domain_error;
class invalid_argument;
class length_error;
class out_of_range;
class runtime_error;
class range_error;
class overflow_error;
class underflow_error;
}
19.2.3 Class logic_error [logic.error]
namespace std {
class logic_error : public exception {
public:
constexpr explicit logic_error(const string& what_arg);
constexpr explicit logic_error(const char* what_arg);
};
}
1 The classlogic_errordefines the type of objects thrown as exceptions to report errors presumably detectable
before the program executes, such as violations of logical preconditions or class invariants.
§ 19.2.3 © ISO/IEC
638

===== PAGE 650 =====

Dxxxx
constexpr logic_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr logic_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.2.4 Class domain_error [domain.error]
namespace std {
class domain_error : public logic_error {
public:
constexpr explicit domain_error(const string& what_arg);
constexpr explicit domain_error(const char* what_arg);
};
}
1 The classdomain_error defines the type of objects thrown as exceptions by the implementation to report
domain errors.
constexpr domain_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr domain_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.2.5 Class invalid_argument [invalid.argument]
namespace std {
class invalid_argument : public logic_error {
public:
constexpr explicit invalid_argument(const string& what_arg);
constexpr explicit invalid_argument(const char* what_arg);
};
}
1 The classinvalid_argument defines the type of objects thrown as exceptions to report an invalid argument.
constexpr invalid_argument(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr invalid_argument(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.2.6 Class length_error [length.error]
namespace std {
class length_error : public logic_error {
public:
constexpr explicit length_error(const string& what_arg);
constexpr explicit length_error(const char* what_arg);
};
}
1 The classlength_error defines the type of objects thrown as exceptions to report an attempt to produce an
object whose length exceeds its maximum allowable size.
constexpr length_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr length_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
§ 19.2.6 © ISO/IEC
639

===== PAGE 651 =====

Dxxxx
19.2.7 Class out_of_range [out.of.range]
namespace std {
class out_of_range : public logic_error {
public:
constexpr explicit out_of_range(const string& what_arg);
constexpr explicit out_of_range(const char* what_arg);
};
}
1 The classout_of_range defines the type of objects thrown as exceptions to report an argument value not in
its expected range.
constexpr out_of_range(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr out_of_range(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.2.8 Class runtime_error [runtime.error]
namespace std {
class runtime_error : public exception {
public:
constexpr explicit runtime_error(const string& what_arg);
constexpr explicit runtime_error(const char* what_arg);
};
}
1 The class runtime_error defines the type of objects thrown as exceptions to report errors presumably
detectable only when the program executes.
constexpr runtime_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr runtime_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.2.9 Class range_error [range.error]
namespace std {
class range_error : public runtime_error {
public:
constexpr explicit range_error(const string& what_arg);
constexpr explicit range_error(const char* what_arg);
};
}
1 The classrange_error defines the type of objects thrown as exceptions to report range errors in internal
computations.
constexpr range_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr range_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.2.10 Class overflow_error [overflow.error]
namespace std {
class overflow_error : public runtime_error {
public:
constexpr explicit overflow_error(const string& what_arg);
constexpr explicit overflow_error(const char* what_arg);
};
}
§ 19.2.10 © ISO/IEC
640

===== PAGE 652 =====

Dxxxx
1 The classoverflow_error defines the type of objects thrown as exceptions to report an arithmetic overflow
error.
constexpr overflow_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr overflow_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.2.11 Class underflow_error [underflow.error]
namespace std {
class underflow_error : public runtime_error {
public:
constexpr explicit underflow_error(const string& what_arg);
constexpr explicit underflow_error(const char* what_arg);
};
}
1 The classunderflow_error defines the type of objects thrown as exceptions to report an arithmetic underflow
error.
constexpr underflow_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr underflow_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
19.3 Assertions [assertions]
19.3.1 General [assertions.general]
1 The header <cassert> provides a macro for documenting C++ program assertions and a mechanism for
disabling the assertion checks through defining the macroNDEBUG.
19.3.2 Header <cassert> synopsis [cassert.syn]
#define assert(...) see below
19.3.3 The assert macro [assertions.assert]
1 If NDEBUG is defined as a macro name at the point in the source file where<cassert> is included, theassert
macro is defined as
#define assert(...) ((void)0)
2 Otherwise, theassert macro puts a diagnostic test into programs; it expands to an expression of typevoid
which has the following effects:
—(2.1) __VA_ARGS__ is evaluated and contextually converted tobool.
—(2.2) If the evaluation yieldstrue there are no further effects.
—(2.3) Otherwise, theassert macro’s expression creates a diagnostic on the standard error stream (ISO/IEC
9899:2024, 7.23.3) in an implementation-defined format and callsabort(). The diagnostic contains
#__VA_ARGS__ and information on the name of the source file, the source line number, and the name
of the enclosing function (such as provided bysource_location::current()).
3 If __VA_ARGS__ does not expand to anassignment-expression, the program is ill-formed.
4 The macroassert is redefined according to the current state ofNDEBUG each time that<cassert> is included.
5 An expressionassert(E) is a constant subexpression (3.15), if
—(5.1) NDEBUG is defined at the point whereassert is last defined or redefined, or
—(5.2) E contextually converted tobool (7.3) is a constant subexpression that evaluates to the valuetrue.
§ 19.3.3 © ISO/IEC
641

===== PAGE 653 =====

Dxxxx
19.4 Error numbers [errno]
19.4.1 General [errno.general]
1 The contents of the header<cerrno> are the same as the POSIX header<errno.h>, except thaterrno shall
be defined as a macro.
[Note 1: The intent is to remain in close alignment with the POSIX standard.—end note]
A separateerrno value is provided for each thread.
19.4.2 Header <cerrno> synopsis [cerrno.syn]
#define errno see below
#define E2BIG see below // freestanding
#define EACCES see below // freestanding
#define EADDRINUSE see below // freestanding
#define EADDRNOTAVAIL see below // freestanding
#define EAFNOSUPPORT see below // freestanding
#define EAGAIN see below // freestanding
#define EALREADY see below // freestanding
#define EBADF see below // freestanding
#define EBADMSG see below // freestanding
#define EBUSY see below // freestanding
#define ECANCELED see below // freestanding
#define ECHILD see below // freestanding
#define ECONNABORTED see below // freestanding
#define ECONNREFUSED see below // freestanding
#define ECONNRESET see below // freestanding
#define EDEADLK see below // freestanding
#define EDESTADDRREQ see below // freestanding
#define EDOM see below // freestanding
#define EEXIST see below // freestanding
#define EFAULT see below // freestanding
#define EFBIG see below // freestanding
#define EHOSTUNREACH see below // freestanding
#define EIDRM see below // freestanding
#define EILSEQ see below // freestanding
#define EINPROGRESS see below // freestanding
#define EINTR see below // freestanding
#define EINVAL see below // freestanding
#define EIO see below // freestanding
#define EISCONN see below // freestanding
#define EISDIR see below // freestanding
#define ELOOP see below // freestanding
#define EMFILE see below // freestanding
#define EMLINK see below // freestanding
#define EMSGSIZE see below // freestanding
#define ENAMETOOLONG see below // freestanding
#define ENETDOWN see below // freestanding
#define ENETRESET see below // freestanding
#define ENETUNREACH see below // freestanding
#define ENFILE see below // freestanding
#define ENOBUFS see below // freestanding
#define ENODEV see below // freestanding
#define ENOENT see below // freestanding
#define ENOEXEC see below // freestanding
#define ENOLCK see below // freestanding
#define ENOLINK see below // freestanding
#define ENOMEM see below // freestanding
#define ENOMSG see below // freestanding
#define ENOPROTOOPT see below // freestanding
#define ENOSPC see below // freestanding
#define ENOSYS see below // freestanding
#define ENOTCONN see below // freestanding
#define ENOTDIR see below // freestanding
§ 19.4.2 © ISO/IEC
642

===== PAGE 654 =====

Dxxxx
#define ENOTEMPTY see below // freestanding
#define ENOTRECOVERABLE see below // freestanding
#define ENOTSOCK see below // freestanding
#define ENOTSUP see below // freestanding
#define ENOTTY see below // freestanding
#define ENXIO see below // freestanding
#define EOPNOTSUPP see below // freestanding
#define EOVERFLOW see below // freestanding
#define EOWNERDEAD see below // freestanding
#define EPERM see below // freestanding
#define EPIPE see below // freestanding
#define EPROTO see below // freestanding
#define EPROTONOSUPPORT see below // freestanding
#define EPROTOTYPE see below // freestanding
#define ERANGE see below // freestanding
#define EROFS see below // freestanding
#define ESPIPE see below // freestanding
#define ESRCH see below // freestanding
#define ETIMEDOUT see below // freestanding
#define ETXTBSY see below // freestanding
#define EWOULDBLOCK see below // freestanding
#define EXDEV see below // freestanding
1 The meaning of the macros in this header is defined by the POSIX standard.
See also: ISO/IEC 9899:2024, 7.5
19.5 System error support [syserr]
19.5.1 General [syserr.general]
1 Subclause 19.5 describes components that the standard library and C++ programs may use to report error
conditions originating from the operating system or other low-level application program interfaces.
2 Components described in 19.5 do not change the value oferrno (19.4).
Recommended practice: Implementations should leave the error states provided by other libraries unchanged.
19.5.2 Header <system_error> synopsis [system.error.syn]
#include <compare> // see 17.12.1
namespace std {
class error_category;
const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;
class error_code;
class error_condition;
class system_error;
template<class T>
struct is_error_code_enum : public false_type {};
template<class T>
struct is_error_condition_enum : public false_type {};
enum class errc { // freestanding
address_family_not_supported, // EAFNOSUPPORT
address_in_use, // EADDRINUSE
address_not_available, // EADDRNOTAVAIL
already_connected, // EISCONN
argument_list_too_long, // E2BIG
argument_out_of_domain, // EDOM
bad_address, // EFAULT
bad_file_descriptor, // EBADF
bad_message, // EBADMSG
broken_pipe, // EPIPE
§ 19.5.2 © ISO/IEC
643

===== PAGE 655 =====

Dxxxx
connection_aborted, // ECONNABORTED
connection_already_in_progress, // EALREADY
connection_refused, // ECONNREFUSED
connection_reset, // ECONNRESET
cross_device_link, // EXDEV
destination_address_required, // EDESTADDRREQ
device_or_resource_busy, // EBUSY
directory_not_empty, // ENOTEMPTY
executable_format_error, // ENOEXEC
file_exists, // EEXIST
file_too_large, // EFBIG
filename_too_long, // ENAMETOOLONG
function_not_supported, // ENOSYS
host_unreachable, // EHOSTUNREACH
identifier_removed, // EIDRM
illegal_byte_sequence, // EILSEQ
inappropriate_io_control_operation, // ENOTTY
interrupted, // EINTR
invalid_argument, // EINVAL
invalid_seek, // ESPIPE
io_error, // EIO
is_a_directory, // EISDIR
message_size, // EMSGSIZE
network_down, // ENETDOWN
network_reset, // ENETRESET
network_unreachable, // ENETUNREACH
no_buffer_space, // ENOBUFS
no_child_process, // ECHILD
no_link, // ENOLINK
no_lock_available, // ENOLCK
no_message, // ENOMSG
no_protocol_option, // ENOPROTOOPT
no_space_on_device, // ENOSPC
no_such_device_or_address, // ENXIO
no_such_device, // ENODEV
no_such_file_or_directory, // ENOENT
no_such_process, // ESRCH
not_a_directory, // ENOTDIR
not_a_socket, // ENOTSOCK
not_connected, // ENOTCONN
not_enough_memory, // ENOMEM
not_supported, // ENOTSUP
operation_canceled, // ECANCELED
operation_in_progress, // EINPROGRESS
operation_not_permitted, // EPERM
operation_not_supported, // EOPNOTSUPP
operation_would_block, // EWOULDBLOCK
owner_dead, // EOWNERDEAD
permission_denied, // EACCES
protocol_error, // EPROTO
protocol_not_supported, // EPROTONOSUPPORT
read_only_file_system, // EROFS
resource_deadlock_would_occur, // EDEADLK
resource_unavailable_try_again, // EAGAIN
result_out_of_range, // ERANGE
state_not_recoverable, // ENOTRECOVERABLE
text_file_busy, // ETXTBSY
timed_out, // ETIMEDOUT
too_many_files_open_in_system, // ENFILE
too_many_files_open, // EMFILE
too_many_links, // EMLINK
too_many_symbolic_link_levels, // ELOOP
value_too_large, // EOVERFLOW
wrong_protocol_type, // EPROTOTYPE
§ 19.5.2 © ISO/IEC
644

===== PAGE 656 =====

Dxxxx
};
template<> struct is_error_condition_enum<errc> : true_type {};
// 19.5.4.5, non-member functions
error_code make_error_code(errc e) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const error_code& ec);
// 19.5.5.5, non-member functions
error_condition make_error_condition(errc e) noexcept;
// 19.5.6, comparison operator functions
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;
strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept;
// 19.5.7, hash support
template<class T> struct hash;
template<> struct hash<error_code>;
template<> struct hash<error_condition>;
// 19.5, system error support
template<class T>
constexpr bool is_error_code_enum_v = is_error_code_enum<T>::value;
template<class T>
constexpr bool is_error_condition_enum_v = is_error_condition_enum<T>::value;
}
1 The value of eachenum errc enumerator is the same as the value of the<cerrno> macro shown in the above
synopsis. Whether or not the<system_error> implementation exposes the<cerrno> macros is unspecified.
2 The is_error_code_enum and is_error_condition_enum templates may be specialized for program-defined
types to indicate that such types are eligible forclass error_code and class error_condition implicit
conversions, respectively.
19.5.3 Class error_category [syserr.errcat]
19.5.3.1 Overview [syserr.errcat.overview]
1 The classerror_category serves as a base class for types used to identify the source and encoding of a
particular category of error code. Classes may be derived fromerror_category to support categories of
errors in addition to those defined in this document. Such classes shall behave as specified in subclause 19.5.3.
[Note 1: error_category objects are passed by reference, and two such objects are equal if they have the same
address. If there is more than a single object of a customerror_category type, such equality comparisons can
evaluate tofalse even for objects holding the same value.—end note]
namespace std {
class error_category {
public:
constexpr error_category() noexcept;
virtual ~error_category();
error_category(const error_category&) = delete;
error_category& operator=(const error_category&) = delete;
virtual const char* name() const noexcept = 0;
virtual error_condition default_error_condition(int ev) const noexcept;
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
virtual bool equivalent(const error_code& code, int condition) const noexcept;
virtual string message(int ev) const = 0;
bool operator==(const error_category& rhs) const noexcept;
strong_ordering operator<=>(const error_category& rhs) const noexcept;
§ 19.5.3.1 © ISO/IEC
645

===== PAGE 657 =====

Dxxxx
};
const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;
}
19.5.3.2 Virtual members [syserr.errcat.virtuals]
virtual const char* name() const noexcept = 0;
1 Returns: A string naming the error category.
virtual error_condition default_error_condition(int ev) const noexcept;
2 Returns: error_condition(ev, *this).
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
3 Returns: default_error_condition(code) == condition.
virtual bool equivalent(const error_code& code, int condition) const noexcept;
4 Returns: *this == code.category() && code.value() == condition.
virtual string message(int ev) const = 0;
5 Returns: A string that describes the error condition denoted byev.
19.5.3.3 Non-virtual members [syserr.errcat.nonvirtuals]
bool operator==(const error_category& rhs) const noexcept;
1 Returns: this == &rhs.
strong_ordering operator<=>(const error_category& rhs) const noexcept;
2 Returns: compare_three_way()(this, &rhs).
[Note 1: compare_three_way (22.10.8.8) provides a total ordering for pointers.—end note]
19.5.3.4 Program-defined classes derived from error_category [syserr.errcat.derived]
virtual const char* name() const noexcept = 0;
1 Returns: A string naming the error category.
virtual error_condition default_error_condition(int ev) const noexcept;
2 Returns: An object of typeerror_condition that corresponds toev.
virtual bool equivalent(int code, const error_condition& condition) const noexcept;
3 Returns: true if, for the category of error represented by*this, code is considered equivalent to
condition; otherwise,false.
virtual bool equivalent(const error_code& code, int condition) const noexcept;
4 Returns: true if, for the category of error represented by*this, code is considered equivalent to
condition; otherwise,false.
19.5.3.5 Error category objects [syserr.errcat.objects]
const error_category& generic_category() noexcept;
1 Returns: A reference to an object of a type derived from classerror_category. All calls to this
function shall return references to the same object.
2 Remarks: The object’sdefault_error_condition and equivalent virtual functions shall behave as
specified for the classerror_category. The object’sname virtual function shall return a pointer to
the string"generic".
§ 19.5.3.5 © ISO/IEC
646

===== PAGE 658 =====

Dxxxx
const error_category& system_category() noexcept;
3 Returns: A reference to an object of a type derived from classerror_category. All calls to this
function shall return references to the same object.
4 Remarks: The object’sequivalent virtual functions shall behave as specified for classerror_category.
The object’sname virtual function shall return a pointer to the string"system". The object’sdefault_-
error_condition virtual function shall behave as follows:
If the argumentev is equal to 0, the function returnserror_condition(0, generic_category()).
Otherwise, ifev corresponds to a POSIXerrno valuepxv, the function returnserror_condition(pxv,
generic_category()). Otherwise, the function returnserror_condition(ev, system_category()).
What constitutes correspondence for any given operating system is unspecified.
[Note 1: The number of potential system error codes is large and unbounded, and some might not correspond to
any POSIXerrno value. Thus implementations are given latitude in determining correspondence.—end note]
19.5.4 Class error_code [syserr.errcode]
19.5.4.1 Overview [syserr.errcode.overview]
1 The classerror_code describes an object used to hold error code values, such as those originating from the
operating system or other low-level application program interfaces.
[Note 1: Class error_code is an adjunct to error reporting by exception.—end note]
namespace std {
class error_code {
public:
// 19.5.4.2, constructors
error_code() noexcept;
error_code(int val, const error_category& cat) noexcept;
template<class ErrorCodeEnum>
error_code(ErrorCodeEnum e) noexcept;
// 19.5.4.3, modifiers
void assign(int val, const error_category& cat) noexcept;
template<class ErrorCodeEnum>
error_code& operator=(ErrorCodeEnum e) noexcept;
void clear() noexcept;
// 19.5.4.4, observers
int value() const noexcept;
const error_category& category() const noexcept;
error_condition default_error_condition() const noexcept;
string message() const;
explicit operator bool() const noexcept;
private:
int val_; // exposition only
const error_category* cat_; // exposition only
};
// 19.5.4.5, non-member functions
error_code make_error_code(errc e) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const error_code& ec);
}
19.5.4.2 Constructors [syserr.errcode.constructors]
error_code() noexcept;
1 Effects: Initializes val_ with 0 and cat_ with &system_category().
error_code(int val, const error_category& cat) noexcept;
2 Effects: Initializes val_ with val and cat_ with &cat.
§ 19.5.4.2 © ISO/IEC
647

===== PAGE 659 =====

Dxxxx
template<class ErrorCodeEnum>
error_code(ErrorCodeEnum e) noexcept;
3 Constraints: is_error_code_enum_v<ErrorCodeEnum> is true.
4 Effects: Equivalent to:
error_code ec = make_error_code(e);
assign(ec.value(), ec.category());
19.5.4.3 Modifiers [syserr.errcode.modifiers]
void assign(int val, const error_category& cat) noexcept;
1 Postconditions: val_ == val and cat_ == &cat.
template<class ErrorCodeEnum>
error_code& operator=(ErrorCodeEnum e) noexcept;
2 Constraints: is_error_code_enum_v<ErrorCodeEnum> is true.
3 Effects: Equivalent to:
error_code ec = make_error_code(e);
assign(ec.value(), ec.category());
4 Returns: *this.
void clear() noexcept;
5 Postconditions: value() == 0 and category() == system_category().
19.5.4.4 Observers [syserr.errcode.observers]
int value() const noexcept;
1 Returns: val_.
const error_category& category() const noexcept;
2 Returns: *cat_.
error_condition default_error_condition() const noexcept;
3 Returns: category().default_error_condition(value()).
string message() const;
4 Returns: category().message(value()).
explicit operator bool() const noexcept;
5 Returns: value() != 0.
19.5.4.5 Non-member functions [syserr.errcode.nonmembers]
error_code make_error_code(errc e) noexcept;
1 Returns: error_code(static_cast<int>(e), generic_category()).
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& os, const error_code& ec);
2 Effects: Equivalent to:return os << ec.category().name() << ’:’ << ec.value();
19.5.5 Class error_condition [syserr.errcondition]
19.5.5.1 Overview [syserr.errcondition.overview]
1 The classerror_condition describes an object used to hold values identifying error conditions.
[Note 1: error_condition values are portable abstractions, whileerror_code values (19.5.4) are implementation
specific. —end note]
§ 19.5.5.1 © ISO/IEC
648

===== PAGE 660 =====

Dxxxx
namespace std {
class error_condition {
public:
// 19.5.5.2, constructors
error_condition() noexcept;
error_condition(int val, const error_category& cat) noexcept;
template<class ErrorConditionEnum>
error_condition(ErrorConditionEnum e) noexcept;
// 19.5.5.3, modifiers
void assign(int val, const error_category& cat) noexcept;
template<class ErrorConditionEnum>
error_condition& operator=(ErrorConditionEnum e) noexcept;
void clear() noexcept;
// 19.5.5.4, observers
int value() const noexcept;
const error_category& category() const noexcept;
string message() const;
explicit operator bool() const noexcept;
private:
int val_; // exposition only
const error_category* cat_; // exposition only
};
}
19.5.5.2 Constructors [syserr.errcondition.constructors]
error_condition() noexcept;
1 Effects: Initializes val_ with 0 and cat_ with &generic_category().
error_condition(int val, const error_category& cat) noexcept;
2 Effects: Initializes val_ with val and cat_ with &cat.
template<class ErrorConditionEnum>
error_condition(ErrorConditionEnum e) noexcept;
3 Constraints: is_error_condition_enum_v<ErrorConditionEnum> is true.
4 Effects: Equivalent to:
error_condition ec = make_error_condition(e);
assign(ec.value(), ec.category());
19.5.5.3 Modifiers [syserr.errcondition.modifiers]
void assign(int val, const error_category& cat) noexcept;
1 Postconditions: val_ == val and cat_ == &cat.
template<class ErrorConditionEnum>
error_condition& operator=(ErrorConditionEnum e) noexcept;
2 Constraints: is_error_condition_enum_v<ErrorConditionEnum> is true.
3 Effects: Equivalent to:
error_condition ec = make_error_condition(e);
assign(ec.value(), ec.category());
4 Returns: *this.
void clear() noexcept;
5 Postconditions: value() == 0 and category() == generic_category().
§ 19.5.5.3 © ISO/IEC
649

===== PAGE 661 =====

Dxxxx
19.5.5.4 Observers [syserr.errcondition.observers]
int value() const noexcept;
1 Returns: val_.
const error_category& category() const noexcept;
2 Returns: *cat_.
string message() const;
3 Returns: category().message(value()).
explicit operator bool() const noexcept;
4 Returns: value() != 0.
19.5.5.5 Non-member functions [syserr.errcondition.nonmembers]
error_condition make_error_condition(errc e) noexcept;
1 Returns: error_condition(static_cast<int>(e), generic_category()).
19.5.6 Comparison operator functions [syserr.compare]
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
1 Returns:
lhs.category() == rhs.category() && lhs.value() == rhs.value()
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
2 Returns:
lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs, rhs.value())
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
3 Returns:
lhs.category() == rhs.category() && lhs.value() == rhs.value()
strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;
4 Effects: Equivalent to:
if (auto c = lhs.category() <=> rhs.category(); c != 0) return c;
return lhs.value() <=> rhs.value();
strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept;
5 Returns:
if (auto c = lhs.category() <=> rhs.category(); c != 0) return c;
return lhs.value() <=> rhs.value();
19.5.7 System error hash support [syserr.hash]
template<> struct hash<error_code>;
template<> struct hash<error_condition>;
1 The specializations are enabled (22.10.19).
19.5.8 Class system_error [syserr.syserr]
19.5.8.1 Overview [syserr.syserr.overview]
1 The classsystem_error describes an exception object used to report error conditions that have an associated
error code. Such error conditions typically originate from the operating system or other low-level application
program interfaces.
2 [Note 1: If an error represents an out-of-memory condition, implementations are encouraged to throw an exception
object of typebad_alloc (17.6.4.1) rather thansystem_error. —end note]
§ 19.5.8.1 © ISO/IEC
650

===== PAGE 662 =====

Dxxxx
namespace std {
class system_error : public runtime_error {
public:
system_error(error_code ec, const string& what_arg);
system_error(error_code ec, const char* what_arg);
system_error(error_code ec);
system_error(int ev, const error_category& ecat, const string& what_arg);
system_error(int ev, const error_category& ecat, const char* what_arg);
system_error(int ev, const error_category& ecat);
const error_code& code() const noexcept;
const char* what() const noexcept override;
};
}
19.5.8.2 Members [syserr.syserr.members]
system_error(error_code ec, const string& what_arg);
1 Postconditions: code() == ec and
string_view(what()).find(what_arg.c_str()) != string_view::npos.
system_error(error_code ec, const char* what_arg);
2 Postconditions: code() == ec and string_view(what()).find(what_arg) != string_view::npos.
system_error(error_code ec);
3 Postconditions: code() == ec.
system_error(int ev, const error_category& ecat, const string& what_arg);
4 Postconditions: code() == error_code(ev, ecat) and
string_view(what()).find(what_arg.c_str()) != string_view::npos.
system_error(int ev, const error_category& ecat, const char* what_arg);
5 Postconditions: code() == error_code(ev, ecat) and
string_view(what()).find(what_arg) != string_view::npos.
system_error(int ev, const error_category& ecat);
6 Postconditions: code() == error_code(ev, ecat).
const error_code& code() const noexcept;
7 Returns: ec or error_code(ev, ecat), from the constructor, as appropriate.
const char* what() const noexcept override;
8 Returns: An ntbs incorporating the arguments supplied in the constructor.
[Note 1: The returnedntbs might be the contents ofwhat_arg + ": " + code.message(). —end note]
19.6 Stacktrace [stacktrace]
19.6.1 General [stacktrace.general]
1 Subclause 19.6 describes components that C++ programs may use to store the stacktrace of the current
thread of execution and query information about the stored stacktrace at runtime.
2 The invocation sequenceof the current evaluationx0 in the current thread of execution is a sequence
(x0,...,x n) of evaluations such that, fori≥0, xi is within the function invocationxi+1 (6.10.1).
3 A stacktrace is an approximate representation of an invocation sequence and consists of stacktrace entries. A
stacktrace entryrepresents an evaluation in a stacktrace.
19.6.2 Header <stacktrace> synopsis [stacktrace.syn]
#include <compare> // see 17.12.1
namespace std {
// 19.6.3, classstacktrace_entry
class stacktrace_entry;
§ 19.6.2 © ISO/IEC
651

===== PAGE 663 =====

Dxxxx
// 19.6.4, class templatebasic_stacktrace
template<class Allocator>
class basic_stacktrace;
// basic_stacktrace typedef-names
using stacktrace = basic_stacktrace<allocator<stacktrace_entry>>;
// 19.6.4.6, non-member functions
template<class Allocator>
void swap(basic_stacktrace<Allocator>& a, basic_stacktrace<Allocator>& b)
noexcept(noexcept(a.swap(b)));
string to_string(const stacktrace_entry& f);
template<class Allocator>
string to_string(const basic_stacktrace<Allocator>& st);
ostream& operator<<(ostream& os, const stacktrace_entry& f);
template<class Allocator>
ostream& operator<<(ostream& os, const basic_stacktrace<Allocator>& st);
// 19.6.5, formatting support
template<> struct formatter<stacktrace_entry>;
template<class Allocator> struct formatter<basic_stacktrace<Allocator>>;
namespace pmr {
using stacktrace = basic_stacktrace<polymorphic_allocator<stacktrace_entry>>;
}
// 19.6.6, hash support
template<class T> struct hash;
template<> struct hash<stacktrace_entry>;
template<class Allocator> struct hash<basic_stacktrace<Allocator>>;
}
19.6.3 Class stacktrace_entry [stacktrace.entry]
19.6.3.1 Overview [stacktrace.entry.overview]
namespace std {
class stacktrace_entry {
public:
using native_handle_type = implementation-defined ;
// 19.6.3.2, constructors
constexpr stacktrace_entry() noexcept;
constexpr stacktrace_entry(const stacktrace_entry& other) noexcept;
constexpr stacktrace_entry& operator=(const stacktrace_entry& other) noexcept;
~stacktrace_entry();
// 19.6.3.3, observers
constexpr native_handle_type native_handle() const noexcept;
constexpr explicit operator bool() const noexcept;
// 19.6.3.4, query
string description() const;
string source_file() const;
uint_least32_t source_line() const;
// 19.6.3.5, comparison
friend constexpr bool operator==(const stacktrace_entry& x,
const stacktrace_entry& y) noexcept;
friend constexpr strong_ordering operator<=>(const stacktrace_entry& x,
const stacktrace_entry& y) noexcept;
§ 19.6.3.1 © ISO/IEC
652

===== PAGE 664 =====

Dxxxx
};
}
1 An object of typestacktrace_entry is either empty, or represents a stacktrace entry and provides operations
for querying information about it. The classstacktrace_entry models regular (18.6) andthree_way_-
comparable<strong_ordering> (17.12.4).
19.6.3.2 Constructors [stacktrace.entry.cons]
constexpr stacktrace_entry() noexcept;
1 Postconditions: *this is empty.
19.6.3.3 Observers [stacktrace.entry.obs]
constexpr native_handle_type native_handle() const noexcept;
1 The semantics of this function are implementation-defined.
2 Remarks: Successive invocations of thenative_handle function for an unchangedstacktrace_entry
object return identical values.
constexpr explicit operator bool() const noexcept;
3 Returns: false if and only if*this is empty.
19.6.3.4 Query [stacktrace.entry.query]
1 [Note 1: All thestacktrace_entry query functions treat errors other than memory allocation errors as “no information
available” and do not throw in that case.—end note]
string description() const;
2 Returns: A description of the evaluation represented by*this, or an empty string.
3 Throws: bad_alloc if memory for the internal data structures or the resulting string cannot be
allocated.
string source_file() const;
4 Returns: The presumed or actual name of the source file (15.12) that lexically contains the expression
or statement whose evaluation is represented by*this, or an empty string.
5 Throws: bad_alloc if memory for the internal data structures or the resulting string cannot be
allocated.
uint_least32_t source_line() const;
6 Returns: 0, or a 1-based line number that lexically relates to the evaluation represented by*this.
If source_file returns the presumed name of the source file, returns the presumed line number; if
source_file returns the actual name of the source file, returns the actual line number.
7 Throws: bad_alloc if memory for the internal data structures cannot be allocated.
19.6.3.5 Comparison [stacktrace.entry.cmp]
friend constexpr bool operator==(const stacktrace_entry& x, const stacktrace_entry& y) noexcept;
1 Returns: true if and only ifx and y represent the same stacktrace entry or bothx and y are empty.
19.6.4 Class template basic_stacktrace [stacktrace.basic]
19.6.4.1 Overview [stacktrace.basic.overview]
namespace std {
template<class Allocator>
class basic_stacktrace {
public:
using value_type = stacktrace_entry;
using const_reference = const value_type&;
using reference = value_type&;
using const_iterator = implementation-defined ; // see 19.6.4.3
using iterator = const_iterator;
using reverse_iterator = std::reverse_iterator<iterator>;
§ 19.6.4.1 © ISO/IEC
653

===== PAGE 665 =====

Dxxxx
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
using difference_type = implementation-defined ;
using size_type = implementation-defined ;
using allocator_type = Allocator;
// 19.6.4.2, creation and assignment
static basic_stacktrace current(const allocator_type& alloc = allocator_type()) noexcept;
static basic_stacktrace current(size_type skip,
const allocator_type& alloc = allocator_type()) noexcept;
static basic_stacktrace current(size_type skip, size_type max_depth,
const allocator_type& alloc = allocator_type()) noexcept;
basic_stacktrace() noexcept(is_nothrow_default_constructible_v<allocator_type>);
explicit basic_stacktrace(const allocator_type& alloc) noexcept;
basic_stacktrace(const basic_stacktrace& other);
basic_stacktrace(basic_stacktrace&& other) noexcept;
basic_stacktrace(const basic_stacktrace& other, const allocator_type& alloc);
basic_stacktrace(basic_stacktrace&& other, const allocator_type& alloc);
basic_stacktrace& operator=(const basic_stacktrace& other);
basic_stacktrace& operator=(basic_stacktrace&& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
~basic_stacktrace();
// 19.6.4.3, observers
allocator_type get_allocator() const noexcept;
const_iterator begin() const noexcept;
const_iterator end() const noexcept;
const_reverse_iterator rbegin() const noexcept;
const_reverse_iterator rend() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;
bool empty() const noexcept;
size_type size() const noexcept;
size_type max_size() const noexcept;
const_reference operator[](size_type) const;
const_reference at(size_type) const;
// 19.6.4.4, comparisons
template<class Allocator2>
friend bool operator==(const basic_stacktrace& x,
const basic_stacktrace<Allocator2>& y) noexcept;
template<class Allocator2>
friend strong_ordering operator<=>(const basic_stacktrace& x,
const basic_stacktrace<Allocator2>& y) noexcept;
// 19.6.4.5, modifiers
void swap(basic_stacktrace& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
private:
vector<value_type, allocator_type> frames_; // exposition only
};
}
§ 19.6.4.1 © ISO/IEC
654

===== PAGE 666 =====

Dxxxx
1 The class templatebasic_stacktrace satisfies the requirements of a reversible container (23.2.2.3), of an
allocator-aware container (23.2.2.5), and of a sequence container (23.2.4), except that
—(1.1) only move, assignment, swap, and operations defined for const-qualified sequence containers are
supported and,
—(1.2) the semantics of comparison functions are different from those required for a container.
19.6.4.2 Creation and assignment [stacktrace.basic.cons]
static basic_stacktrace current(const allocator_type& alloc = allocator_type()) noexcept;
1 Returns: A basic_stacktrace object withframes_ storing the stacktrace of the current evaluation
in the current thread of execution, or an emptybasic_stacktrace object if the initialization of
frames_ failed. alloc is passed to the constructor of theframes_ object.
[Note 1: If the stacktrace was successfully obtained, thenframes_.front() is the stacktrace_entry rep-
resenting approximately the current evaluation, andframes_.back() is thestacktrace_entry representing
approximately the initial function of the current thread of execution.—end note]
static basic_stacktrace current(size_type skip,
const allocator_type& alloc = allocator_type()) noexcept;
2 Let t be a stacktrace as-if obtained viabasic_stacktrace::current(alloc). Let n be t.size().
3 Returns: A basic_stacktrace object where frames_ is direct-non-list-initialized from arguments
t.begin() + min(n, skip), t.end(), and alloc, or an empty basic_stacktrace object if the
initialization offrames_ failed.
static basic_stacktrace current(size_type skip, size_type max_depth,
const allocator_type& alloc = allocator_type()) noexcept;
4 Let t be a stacktrace as-if obtained viabasic_stacktrace::current(alloc). Let n be t.size().
5 Hardened preconditions: skip <= skip + max_depth is true.
6 Returns: A basic_stacktrace object where frames_ is direct-non-list-initialized from arguments
t.begin() + min(n, skip), t.begin() + min(n, skip + max_depth), and alloc, or an empty
basic_stacktrace object if the initialization offrames_ failed.
basic_stacktrace() noexcept(is_nothrow_default_constructible_v<allocator_type>);
7 Postconditions: empty() is true.
explicit basic_stacktrace(const allocator_type& alloc) noexcept;
8 Effects: alloc is passed to theframes_ constructor.
9 Postconditions: empty() is true.
basic_stacktrace(const basic_stacktrace& other);
basic_stacktrace(const basic_stacktrace& other, const allocator_type& alloc);
basic_stacktrace(basic_stacktrace&& other, const allocator_type& alloc);
basic_stacktrace& operator=(const basic_stacktrace& other);
basic_stacktrace& operator=(basic_stacktrace&& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
10 Remarks: Implementations may strengthen the exception specification for these functions (16.4.6.14)
by ensuring thatempty() is true on failed allocation.
19.6.4.3 Observers [stacktrace.basic.obs]
using const_iterator = implementation-defined ;
1 The type modelsrandom_access_iterator (24.3.4.13) and meets theCpp17RandomAccessIterator
requirements (24.3.5.7).
allocator_type get_allocator() const noexcept;
2 Returns: frames_.get_allocator().
§ 19.6.4.3 © ISO/IEC
655

===== PAGE 667 =====

Dxxxx
const_iterator begin() const noexcept;
const_iterator cbegin() const noexcept;
3 Returns: An iterator referring to the first element inframes_. If empty() is true, then it returns the
same value asend().
const_iterator end() const noexcept;
const_iterator cend() const noexcept;
4 Returns: The end iterator.
const_reverse_iterator rbegin() const noexcept;
const_reverse_iterator crbegin() const noexcept;
5 Returns: reverse_iterator(cend()).
const_reverse_iterator rend() const noexcept;
const_reverse_iterator crend() const noexcept;
6 Returns: reverse_iterator(cbegin()).
bool empty() const noexcept;
7 Returns: frames_.empty().
size_type size() const noexcept;
8 Returns: frames_.size().
size_type max_size() const noexcept;
9 Returns: frames_.max_size().
const_reference operator[](size_type frame_no) const;
10 Hardened preconditions: frame_no < size() is true.
11 Returns: frames_[frame_no].
12 Throws: Nothing.
const_reference at(size_type frame_no) const;
13 Returns: frames_[frame_no].
14 Throws: out_of_range if frame_no >= size().
19.6.4.4 Comparisons [stacktrace.basic.cmp]
template<class Allocator2>
friend bool operator==(const basic_stacktrace& x, const basic_stacktrace<Allocator2>& y) noexcept;
1 Returns: equal(x.begin(), x.end(), y.begin(), y.end()).
template<class Allocator2>
friend strong_ordering
operator<=>(const basic_stacktrace& x, const basic_stacktrace<Allocator2>& y) noexcept;
2 Returns: x.size() <=> y.size() if x.size() != y.size(); lexicographical_compare_three_-
way(x.begin(), x.end(), y.begin(), y.end()) otherwise.
19.6.4.5 Modifiers [stacktrace.basic.mod]
void swap(basic_stacktrace& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
1 Effects: Exchanges the contents of*this and other.
§ 19.6.4.5 © ISO/IEC
656

===== PAGE 668 =====

Dxxxx
19.6.4.6 Non-member functions [stacktrace.basic.nonmem]
template<class Allocator>
void swap(basic_stacktrace<Allocator>& a, basic_stacktrace<Allocator>& b)
noexcept(noexcept(a.swap(b)));
1 Effects: Equivalent toa.swap(b).
string to_string(const stacktrace_entry& f);
2 Returns: A string with a description off.
3 Recommended practice: The description should provide information about the contained evaluation,
including information fromf.source_file() and f.source_line().
template<class Allocator>
string to_string(const basic_stacktrace<Allocator>& st);
4 Returns: A string with a description ofst.
[Note 1: The number of lines is not guaranteed to be equal tost.size(). —end note]
ostream& operator<<(ostream& os, const stacktrace_entry& f);
5 Effects: Equivalent to:return os << to_string(f);
template<class Allocator>
ostream& operator<<(ostream& os, const basic_stacktrace<Allocator>& st);
6 Effects: Equivalent to:return os << to_string(st);
19.6.5 Formatting support [stacktrace.format]
template<> struct formatter<stacktrace_entry>;
1 formatter<stacktrace_entry> interprets format-spec as astacktrace-entry-format-spec. The syntax
of format specifications is as follows:
stacktrace-entry-format-spec:
fill-and-alignopt widthopt
[Note 1: The productionsfill-and-align and width are described in 28.5.2.2.—end note]
2 A stacktrace_entry object se is formatted as if by copyingto_string(se) through the output
iterator of the context with additional padding and adjustments as specified by the format specifiers.
template<class Allocator> struct formatter<basic_stacktrace<Allocator>>;
3 For formatter<basic_stacktrace<Allocator>>, format-spec is empty.
4 A basic_stacktrace<Allocator> object s is formatted as if by copyingto_string(s) through the
output iterator of the context.
19.6.6 Hash support [stacktrace.basic.hash]
template<> struct hash<stacktrace_entry>;
template<class Allocator> struct hash<basic_stacktrace<Allocator>>;
1 The specializations are enabled (22.10.19).
19.7 Debugging [debugging]
19.7.1 General [debugging.general]
1 Subclause 19.7 describes functionality to introspect and interact with the execution of the program.
[Note 1: The facilities provided by the debugging functionality interact with a program that could be tracing the
execution of a C++ program, such as a debugger.—end note]
19.7.2 Header <debugging> synopsis [debugging.syn]
// all freestanding
namespace std {
// 19.7.3, utility
void breakpoint() noexcept;
§ 19.7.2 © ISO/IEC
657

===== PAGE 669 =====

Dxxxx
void breakpoint_if_debugging() noexcept;
bool is_debugger_present() noexcept;
}
19.7.3 Utility [debugging.utility]
void breakpoint() noexcept;
1 The semantics of this function are implementation-defined.
[Note 1: It is intended that, when invoked with a debugger present, the execution of the program temporarily
halts and execution is handed to the debugger until the program is either terminated by the debugger or the
debugger resumes execution of the program as if the function was not invoked. In particular, there is no intent
for a call to this function to accomodate resumption of the program in a different manner. If there is no
debugger present, execution of the program can end abnormally.—end note]
void breakpoint_if_debugging() noexcept;
2 Effects: Equivalent to:
if (is_debugger_present()) breakpoint();
bool is_debugger_present() noexcept;
3 Required behavior: This function has no preconditions.
4 Default behavior: implementation-defined.
[Note 2: It is intended that, using an immediate (uncached) query to determine if the program is being traced
by a debugger, an implementation returnstrue only when tracing the execution of the program with a debugger.
On Windows or equivalent systems, this can be achieved by calling the::IsDebuggerPresent() Win32 function.
For systems compatible with ISO/IEC 23360:2021, this can be achieved by checking for a tracing process, with
a best-effort determination that such a tracing process is a debugger.—end note]
5 Remarks: This function is replaceable (9.6.5).
§ 19.7.3 © ISO/IEC
658

===== PAGE 670 =====

Dxxxx
20 Memory management library [mem]
20.1 General [mem.general]
1 This Clause describes components for memory management.
2 The following subclauses describe general memory management facilities, smart pointers, memory resources,
and scoped allocators, as summarized in Table 50.
Table 50 — Memory management library summary [tab:mem.summary]
Subclause Header
20.2 Memory <cstdlib>, <memory>
20.3 Smart pointers <memory>
20.4 Types for composite class design <memory>
20.5 Memory resources <memory_resource>
20.6 Scoped allocators <scoped_allocator>
20.2 Memory [memory]
20.2.1 General [memory.general]
1 Subclause 20.2 describes the contents of the header<memory> (20.2.2) and some of the contents of the header
<cstdlib> (17.2.2).
20.2.2 Header <memory> synopsis [memory.syn]
1 The header<memory> defines several types and function templates that describe properties of pointers and
pointer-like types, manage memory for containers and other template types, destroy objects, and construct
objects in uninitialized memory buffers (20.2.3–20.2.11 and 26.11). The header also defines the templates
unique_ptr, shared_ptr, weak_ptr, out_ptr_t, inout_ptr_t, and various function templates that operate
on objects of these types (20.3).
2 Let POINTER_OF (T) denote a type that is
—(2.1) T::pointer if thequalified-id T::pointer is valid and denotes a type,
—(2.2) otherwise, T::element_type* if thequalified-id T::element_type is valid and denotes a type,
—(2.3) otherwise, pointer_traits<T>::element_type*.
3 Let POINTER_OF_OR (T, U) denote a type that is:
—(3.1) POINTER_OF (T) if POINTER_OF (T) is valid and denotes a type,
—(3.2) otherwise, U.
#include <compare> // see 17.12.1
namespace std {
// 20.2.3, pointer traits
template<class Ptr> struct pointer_traits; // freestanding
template<class T> struct pointer_traits<T*>; // freestanding
// 20.2.4, pointer conversion
template<class T>
constexpr T* to_address(T* p) noexcept; // freestanding
template<class Ptr>
constexpr auto to_address(const Ptr& p) noexcept; // freestanding
// 20.2.5, pointer alignment
void* align(size_t alignment, size_t size, void*& ptr, size_t& space); // freestanding
template<size_t N, class T>
constexpr T* assume_aligned(T* ptr); // freestanding
§ 20.2.2 © ISO/IEC
659

===== PAGE 671 =====

Dxxxx
template<size_t Alignment, class T>
bool is_sufficiently_aligned(T* ptr); // freestanding
// 20.2.6, explicit lifetime management
template<class T>
T* start_lifetime_as(void* p) noexcept; // freestanding
template<class T>
const T* start_lifetime_as(const void* p) noexcept; // freestanding
template<class T>
volatile T* start_lifetime_as(volatile void* p) noexcept; // freestanding
template<class T>
const volatile T* start_lifetime_as(const volatile void* p) noexcept; // freestanding
template<class T>
T* start_lifetime_as_array(void* p, size_t n) noexcept; // freestanding
template<class T>
const T* start_lifetime_as_array(const void* p, size_t n) noexcept; // freestanding
template<class T>
volatile T* start_lifetime_as_array(volatile void* p, size_t n) noexcept; // freestanding
template<class T>
const volatile T* start_lifetime_as_array(const volatile void* p, // freestanding
size_t n) noexcept;
// 20.2.7, allocator argument tag
struct allocator_arg_t { explicit allocator_arg_t() = default; }; // freestanding
inline constexpr allocator_arg_t allocator_arg{}; // freestanding
// 20.2.8,uses_allocator
template<class T, class Alloc> struct uses_allocator; // freestanding
// 20.2.8.1,uses_allocator
template<class T, class Alloc>
constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value; // freestanding
// 20.2.8.2, uses-allocator construction
template<class T, class Alloc, class... Args>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
Args&&... args) noexcept;
template<class T, class Alloc, class Tuple1, class Tuple2>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
piecewise_construct_t,
Tuple1&& x, Tuple2&& y) noexcept;
template<class T, class Alloc>
constexpr auto uses_allocator_construction_args(const Alloc& alloc) noexcept; // freestanding
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
U&& u, V&& v) noexcept;
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
pair<U, V>& pr) noexcept;
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
const pair<U, V>& pr) noexcept;
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
pair<U, V>&& pr) noexcept;
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
const pair<U, V>&& pr) noexcept;
template<class T, class Alloc, pair-like P>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
P&& p) noexcept;
template<class T, class Alloc, class U>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, // freestanding
U&& u) noexcept;
§ 20.2.2 © ISO/IEC
660

===== PAGE 672 =====

Dxxxx
template<class T, class Alloc, class... Args>
constexpr T make_obj_using_allocator(const Alloc& alloc, Args&&... args); // freestanding
template<class T, class Alloc, class... Args>
constexpr T* uninitialized_construct_using_allocator(T* p, // freestanding
const Alloc& alloc, Args&&... args);
// 20.2.9, allocator traits
template<class Alloc> struct allocator_traits; // freestanding
template<class Pointer, class SizeType = size_t>
struct allocation_result { // freestanding
Pointer ptr;
SizeType count;
};
// 20.2.10, the default allocator
template<class T> class allocator;
template<class T, class U>
constexpr bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
// 20.2.11, addressof
template<class T>
constexpr T* addressof(T& r) noexcept; // freestanding
template<class T>
const T* addressof(const T&&) = delete; // freestanding
// 26.11, specialized algorithms
// 26.11.2, special memory concepts
template<class I>
concept nothrow-input-iterator = see below ; // exposition only
template<class I>
concept nothrow-forward-iterator = see below ; // exposition only
template<class I>
concept nothrow-bidirectional-iterator = see below ; // exposition only
template<class I>
concept nothrow-random-access-iterator = see below ; // exposition only
template<class S, class I>
concept nothrow-sentinel-for = see below ; // exposition only
template<class S, class I>
concept nothrow-sized-sentinel-for = see below ; // exposition only
template<class R>
concept nothrow-input-range = see below ; // exposition only
template<class R>
concept nothrow-forward-range = see below ; // exposition only
template<class R>
concept nothrow-bidirectional-range = see below ; // exposition only
template<class R>
concept nothrow-random-access-range = see below ; // exposition only
template<class R>
concept nothrow-sized-random-access-range = see below ; // exposition only
template<class NoThrowForwardIterator>
constexpr void uninitialized_default_construct(NoThrowForwardIterator first, // freestanding
NoThrowForwardIterator last);
template<class ExecutionPolicy, class NoThrowForwardIterator>
void uninitialized_default_construct(ExecutionPolicy&& exec, // freestanding-deleted,
NoThrowForwardIterator first, // see 26.3.5
NoThrowForwardIterator last);
template<class NoThrowForwardIterator, class Size>
constexpr NoThrowForwardIterator
uninitialized_default_construct_n(NoThrowForwardIterator first, Size n); // freestanding
template<class ExecutionPolicy, class NoThrowForwardIterator, class Size>
NoThrowForwardIterator
uninitialized_default_construct_n(ExecutionPolicy&& exec, // freestanding-deleted,
§ 20.2.2 © ISO/IEC
661

===== PAGE 673 =====

Dxxxx
NoThrowForwardIterator first, // see 26.3.5
Size n);
namespace ranges {
template<nothrow-forward-iterator I, nothrow-sentinel-for <I> S>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_default_construct(I first, S last); // freestanding
template<nothrow-forward-range R>
requires default_initializable<range_value_t<R>>
constexpr borrowed_iterator_t<R> uninitialized_default_construct(R&& r); // freestanding
template<nothrow-forward-iterator I>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_default_construct_n(I first, // freestanding
iter_difference_t<I> n);
template<execution-policy Ep, nothrow-random-access-iterator I,
nothrow-sized-sentinel-for <I> S>
requires default_initializable<iter_value_t<I>>
I uninitialized_default_construct(Ep&& exec, I first, S last); // freestanding-deleted,
// see 26.3.5
template<execution-policy Ep, nothrow-sized-random-access-range R>
requires default_initializable<range_value_t<R>>
borrowed_iterator_t<R> uninitialized_default_construct(Ep&& exec, // freestanding-deleted,
R&& r); // see 26.3.5
template<execution-policy Ep, nothrow-random-access-iterator I>
requires default_initializable<iter_value_t<I>>
I uninitialized_default_construct_n(Ep&& exec, I first, // freestanding-deleted,
iter_difference_t<I> n); // see 26.3.5
}
template<class NoThrowForwardIterator>
constexpr void uninitialized_value_construct(NoThrowForwardIterator first, // freestanding
NoThrowForwardIterator last);
template<class ExecutionPolicy, class NoThrowForwardIterator>
void uninitialized_value_construct(ExecutionPolicy&& exec, // freestanding-deleted,
NoThrowForwardIterator first, // see 26.3.5
NoThrowForwardIterator last);
template<class NoThrowForwardIterator, class Size>
constexpr NoThrowForwardIterator
uninitialized_value_construct_n(NoThrowForwardIterator first, Size n); // freestanding
template<class ExecutionPolicy, class NoThrowForwardIterator, class Size>
NoThrowForwardIterator
uninitialized_value_construct_n(ExecutionPolicy&& exec, // freestanding-deleted,
NoThrowForwardIterator first, // see 26.3.5
Size n);
namespace ranges {
template<nothrow-forward-iterator I, nothrow-sentinel-for <I> S>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_value_construct(I first, S last); // freestanding
template<nothrow-forward-range R>
requires default_initializable<range_value_t<R>>
constexpr borrowed_iterator_t<R> uninitialized_value_construct(R&& r); // freestanding
template<nothrow-forward-iterator I>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_value_construct_n(I first, // freestanding
iter_difference_t<I> n);
§ 20.2.2 © ISO/IEC
662

===== PAGE 674 =====

Dxxxx
template<execution-policy Ep, nothrow-random-access-iterator I,
nothrow-sized-sentinel-for <I> S>
requires default_initializable<iter_value_t<I>>
I uninitialized_value_construct(Ep&& exec, I first, S last); // freestanding-deleted,
// see 26.3.5
template<execution-policy Ep, nothrow-sized-random-access-range R>
requires default_initializable<range_value_t<R>>
borrowed_iterator_t<R> uninitialized_value_construct(Ep&& exec, // freestanding-deleted,
R&& r); // see 26.3.5
template<execution-policy Ep, nothrow-random-access-iterator I>
requires default_initializable<iter_value_t<I>>
I uninitialized_value_construct_n(Ep&& exec, I first, // freestanding-deleted,
iter_difference_t<I> n); // see 26.3.5
}
template<class InputIterator, class NoThrowForwardIterator>
constexpr NoThrowForwardIterator uninitialized_copy(InputIterator first, // freestanding
InputIterator last,
NoThrowForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator, class NoThrowForwardIterator>
NoThrowForwardIterator uninitialized_copy(ExecutionPolicy&& exec, // freestanding-deleted,
ForwardIterator first, // see 26.3.5
ForwardIterator last,
NoThrowForwardIterator result);
template<class InputIterator, class Size, class NoThrowForwardIterator>
constexpr NoThrowForwardIterator uninitialized_copy_n(InputIterator first, // freestanding
Size n,
NoThrowForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator, class Size,
class NoThrowForwardIterator>
NoThrowForwardIterator uninitialized_copy_n(ExecutionPolicy&& exec, // freestanding-deleted,
ForwardIterator first, // see 26.3.5
Size n,
NoThrowForwardIterator result);
namespace ranges {
template<class I, class O>
using uninitialized_copy_result = in_out_result<I, O>; // freestanding
template<input_iterator I, sentinel_for<I> S1,
nothrow-forward-iterator O, nothrow-sentinel-for <O> S2>
requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
constexpr uninitialized_copy_result<I, O>
uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast); // freestanding
template<input_range IR, nothrow-forward-range OR>
requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
constexpr uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
uninitialized_copy(IR&& in_range, OR&& out_range); // freestanding
template<class I, class O>
using uninitialized_copy_n_result = in_out_result<I, O>; // freestanding
template<input_iterator I, nothrow-forward-iterator O, nothrow-sentinel-for <O> S>
requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
constexpr uninitialized_copy_n_result<I, O>
uninitialized_copy_n(I ifirst, iter_difference_t<I> n, // freestanding
O ofirst, S olast);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S1,
nothrow-random-access-iterator O, nothrow-sized-sentinel-for <O> S2>
requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
uninitialized_copy_result<I, O>
uninitialized_copy(Ep&& exec, I ifirst, S1 ilast, // freestanding-deleted,
O ofirst, S2 olast); // see 26.3.5
§ 20.2.2 © ISO/IEC
663

===== PAGE 675 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range IR,
nothrow-sized-random-access-range OR>
requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
uninitialized_copy(Ep&& exec, IR&& in_range, OR&& out_range); // freestanding-deleted,
// see 26.3.5
template<execution-policy Ep, random_access_iterator I, nothrow-random-access-iterator O,
nothrow-sized-sentinel-for <O> S>
requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
uninitialized_copy_n_result<I, O>
uninitialized_copy_n(Ep&& exec, I ifirst, iter_difference_t<I> n, // freestanding-deleted,
O ofirst, S olast); // see 26.3.5
}
template<class InputIterator, class NoThrowForwardIterator>
constexpr NoThrowForwardIterator uninitialized_move(InputIterator first, // freestanding
InputIterator last,
NoThrowForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator, class NoThrowForwardIterator>
NoThrowForwardIterator uninitialized_move(ExecutionPolicy&& exec, // freestanding-deleted,
ForwardIterator first, // see 26.3.5
ForwardIterator last,
NoThrowForwardIterator result);
template<class InputIterator, class Size, class NoThrowForwardIterator>
constexpr pair<InputIterator, NoThrowForwardIterator>
uninitialized_move_n(InputIterator first, Size n, // freestanding
NoThrowForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator, class Size,
class NoThrowForwardIterator>
pair<ForwardIterator, NoThrowForwardIterator>
uninitialized_move_n(ExecutionPolicy&& exec, // freestanding-deleted,
ForwardIterator first, Size n, // see 26.3.5
NoThrowForwardIterator result);
namespace ranges {
template<class I, class O>
using uninitialized_move_result = in_out_result<I, O>; // freestanding
template<input_iterator I, sentinel_for<I> S1,
nothrow-forward-iterator O, nothrow-sentinel-for <O> S2>
requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
constexpr uninitialized_move_result<I, O>
uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast); // freestanding
template<input_range IR, nothrow-forward-range OR>
requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
constexpr uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
uninitialized_move(IR&& in_range, OR&& out_range); // freestanding
template<class I, class O>
using uninitialized_move_n_result = in_out_result<I, O>; // freestanding
template<input_iterator I,
nothrow-forward-iterator O, nothrow-sentinel-for <O> S>
requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
constexpr uninitialized_move_n_result<I, O>
uninitialized_move_n(I ifirst, iter_difference_t<I> n, // freestanding
O ofirst, S olast);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S1,
nothrow-random-access-iterator O, nothrow-sized-sentinel-for <O> S2>
requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
uninitialized_move_result<I, O>
uninitialized_move(Ep&& exec, I ifirst, S1 ilast, // freestanding-deleted,
O ofirst, S2 olast); // see 26.3.5
§ 20.2.2 © ISO/IEC
664

===== PAGE 676 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range IR,
nothrow-sized-random-access-range OR>
requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
uninitialized_move(Ep&& exec, IR&& in_range, OR&& out_range); // freestanding-deleted,
// see 26.3.5
template<execution-policy Ep, random_access_iterator I,
nothrow-random-access-iterator O, nothrow-sized-sentinel-for <O> S>
requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
uninitialized_move_n_result<I, O>
uninitialized_move_n(Ep&& exec, I ifirst, iter_difference_t<I> n, // freestanding-deleted,
O ofirst, S olast); // see 26.3.5
}
template<class NoThrowForwardIterator, class T>
constexpr void uninitialized_fill(NoThrowForwardIterator first, // freestanding
NoThrowForwardIterator last, const T& x);
template<class ExecutionPolicy, class NoThrowForwardIterator, class T>
void uninitialized_fill(ExecutionPolicy&& exec, // freestanding-deleted,
NoThrowForwardIterator first, // see 26.3.5
NoThrowForwardIterator last,
const T& x);
template<class NoThrowForwardIterator, class Size, class T>
constexpr NoThrowForwardIterator
uninitialized_fill_n(NoThrowForwardIterator first, Size n, const T& x); // freestanding
template<class ExecutionPolicy, class NoThrowForwardIterator, class Size, class T>
NoThrowForwardIterator
uninitialized_fill_n(ExecutionPolicy&& exec, // freestanding-deleted,
NoThrowForwardIterator first, // see 26.3.5
Size n, const T& x);
namespace ranges {
template<nothrow-forward-iterator I, nothrow-sentinel-for <I> S, class T>
requires constructible_from<iter_value_t<I>, const T&>
constexpr I uninitialized_fill(I first, S last, const T& x); // freestanding
template<nothrow-forward-range R, class T>
requires constructible_from<range_value_t<R>, const T&>
constexpr borrowed_iterator_t<R> uninitialized_fill(R&& r, const T& x); // freestanding
template<nothrow-forward-iterator I, class T>
requires constructible_from<iter_value_t<I>, const T&>
constexpr I uninitialized_fill_n(I first, // freestanding
iter_difference_t<I> n, const T& x);
template<execution-policy Ep, nothrow-random-access-iterator I,
nothrow-sized-sentinel-for <I> S, class T>
requires constructible_from<iter_value_t<I>, const T&>
I uninitialized_fill(Ep&& exec, I first, S last, const T& x); // freestanding-deleted,
// see 26.3.5
template<execution-policy Ep, nothrow-sized-random-access-range R, class T>
requires constructible_from<range_value_t<R>, const T&>
borrowed_iterator_t<R> uninitialized_fill(Ep&& exec, R&& r, // freestanding-deleted,
const T& x); // see 26.3.5
template<execution-policy Ep, nothrow-random-access-iterator I, class T>
requires constructible_from<iter_value_t<I>, const T&>
I uninitialized_fill_n(Ep&& exec, I first, // freestanding-deleted,
iter_difference_t<I> n, const T& x); // see 26.3.5
}
// 26.11.8,construct_at
template<class T, class... Args>
constexpr T* construct_at(T* location, Args&&... args); // freestanding
§ 20.2.2 © ISO/IEC
665

===== PAGE 677 =====

Dxxxx
namespace ranges {
template<class T, class... Args>
constexpr T* construct_at(T* location, Args&&... args); // freestanding
}
// 26.11.9,destroy
template<class T>
constexpr void destroy_at(T* location); // freestanding
template<class NoThrowForwardIterator>
constexpr void destroy(NoThrowForwardIterator first, // freestanding
NoThrowForwardIterator last);
template<class ExecutionPolicy, class NoThrowForwardIterator>
void destroy(ExecutionPolicy&& exec, // freestanding-deleted,
NoThrowForwardIterator first, // see 26.3.5
NoThrowForwardIterator last);
template<class NoThrowForwardIterator, class Size>
constexpr NoThrowForwardIterator destroy_n(NoThrowForwardIterator first, // freestanding
Size n);
template<class ExecutionPolicy, class NoThrowForwardIterator, class Size>
NoThrowForwardIterator destroy_n(ExecutionPolicy&& exec, // freestanding-deleted,
NoThrowForwardIterator first, Size n); // see 26.3.5
namespace ranges {
template<destructible T>
constexpr void destroy_at(T* location) noexcept; // freestanding
template<nothrow-input-iterator I, nothrow-sentinel-for <I> S>
requires destructible<iter_value_t<I>>
constexpr I destroy(I first, S last) noexcept; // freestanding
template<nothrow-input-range R>
requires destructible<range_value_t<R>>
constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept; // freestanding
template<nothrow-input-iterator I>
requires destructible<iter_value_t<I>>
constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept; // freestanding
template<execution-policy Ep, nothrow-random-access-iterator I,
nothrow-sized-sentinel-for <I> S>
requires destructible<iter_value_t<I>>
I destroy(Ep&& exec, I first, S last); // freestanding-deleted,
// see 26.3.5
template<execution-policy Ep, nothrow-sized-random-access-range R>
requires destructible<range_value_t<R>>
borrowed_iterator_t<R> destroy(Ep&& exec, R&& r); // freestanding-deleted,
// see 26.3.5
template<execution-policy Ep, nothrow-random-access-iterator I>
requires destructible<iter_value_t<I>>
I destroy_n(Ep&& exec, I first, iter_difference_t<I> n); // freestanding-deleted,
// see 26.3.5
}
// 20.3.1, class templateunique_ptr
template<class T> struct default_delete; // freestanding
template<class T> struct default_delete<T[]>; // freestanding
template<class T, class D = default_delete<T>> class unique_ptr; // freestanding
template<class T, class D> class unique_ptr<T[], D>; // freestanding
template<class T, class... Args>
constexpr unique_ptr<T> make_unique(Args&&... args); // T is not array
template<class T>
constexpr unique_ptr<T> make_unique(size_t n); // T is U[]
template<class T, class... Args>
unspecified make_unique(Args&&...) = delete; // T is U[N]
§ 20.2.2 © ISO/IEC
666

===== PAGE 678 =====

Dxxxx
template<class T>
constexpr unique_ptr<T> make_unique_for_overwrite(); // T is not array
template<class T>
constexpr unique_ptr<T> make_unique_for_overwrite(size_t n); // T is U[]
template<class T, class... Args>
unspecified make_unique_for_overwrite(Args&&...) = delete; // T is U[N]
template<class T, class D>
constexpr void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept; // freestanding
template<class T1, class D1, class T2, class D2>
constexpr bool operator==(const unique_ptr<T1, D1>& x, // freestanding
const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
constexpr bool operator<(const unique_ptr<T1, D1>& x, // freestanding
const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
constexpr bool operator>(const unique_ptr<T1, D1>& x, // freestanding
const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
constexpr bool operator<=(const unique_ptr<T1, D1>& x, // freestanding
const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
constexpr bool operator>=(const unique_ptr<T1, D1>& x, // freestanding
const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
requires three_way_comparable_with<typename unique_ptr<T1, D1>::pointer,
typename unique_ptr<T2, D2>::pointer>
constexpr compare_three_way_result_t<typename unique_ptr<T1, D1>::pointer,
typename unique_ptr<T2, D2>::pointer>
operator<=>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y); // freestanding
template<class T, class D>
constexpr bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept; // freestanding
template<class T, class D>
constexpr bool operator<(const unique_ptr<T, D>& x, nullptr_t); // freestanding
template<class T, class D>
constexpr bool operator<(nullptr_t, const unique_ptr<T, D>& y); // freestanding
template<class T, class D>
constexpr bool operator>(const unique_ptr<T, D>& x, nullptr_t); // freestanding
template<class T, class D>
constexpr bool operator>(nullptr_t, const unique_ptr<T, D>& y); // freestanding
template<class T, class D>
constexpr bool operator<=(const unique_ptr<T, D>& x, nullptr_t); // freestanding
template<class T, class D>
constexpr bool operator<=(nullptr_t, const unique_ptr<T, D>& y); // freestanding
template<class T, class D>
constexpr bool operator>=(const unique_ptr<T, D>& x, nullptr_t); // freestanding
template<class T, class D>
constexpr bool operator>=(nullptr_t, const unique_ptr<T, D>& y); // freestanding
template<class T, class D>
requires three_way_comparable<typename unique_ptr<T, D>::pointer>
constexpr compare_three_way_result_t<typename unique_ptr<T, D>::pointer>
operator<=>(const unique_ptr<T, D>& x, nullptr_t); // freestanding
template<class E, class T, class Y, class D>
basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const unique_ptr<Y, D>& p);
// 20.3.2.1, classbad_weak_ptr
class bad_weak_ptr;
// 20.3.2.2, class templateshared_ptr
template<class T> class shared_ptr;
§ 20.2.2 © ISO/IEC
667

===== PAGE 679 =====

Dxxxx
// 20.3.2.2.7,shared_ptr creation
template<class T, class... Args>
constexpr shared_ptr<T> make_shared(Args&&... args); // T is not array
template<class T, class A, class... Args>
constexpr shared_ptr<T> allocate_shared(const A& a, Args&&... args); // T is not array
template<class T>
constexpr shared_ptr<T> make_shared(size_t N); // T is U[]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a, size_t N); // T is U[]
template<class T>
constexpr shared_ptr<T> make_shared(); // T is U[N]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a); // T is U[N]
template<class T>
constexpr shared_ptr<T> make_shared(size_t N, const remove_extent_t<T>& u); // T is U[]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a, size_t N,
const remove_extent_t<T>& u); // T is U[]
template<class T>
constexpr shared_ptr<T> make_shared(const remove_extent_t<T>& u); // T is U[N]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a, // T is U[N]
const remove_extent_t<T>& u);
template<class T>
constexpr shared_ptr<T> make_shared_for_overwrite(); // T is not U[]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared_for_overwrite(const A& a); // T is not U[]
template<class T>
constexpr shared_ptr<T> make_shared_for_overwrite(size_t N); // T is U[]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared_for_overwrite(const A& a, size_t N); // T is U[]
// 20.3.2.2.8,shared_ptr comparisons
template<class T, class U>
constexpr bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
template<class T, class U>
constexpr strong_ordering operator<=>(const shared_ptr<T>& a,
const shared_ptr<U>& b) noexcept;
template<class T>
constexpr bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
template<class T>
constexpr strong_ordering operator<=>(const shared_ptr<T>& x, nullptr_t) noexcept;
// 20.3.2.2.9,shared_ptr specialized algorithms
template<class T>
constexpr void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
// 20.3.2.2.10,shared_ptr casts
template<class T, class U>
constexpr shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
constexpr shared_ptr<T> static_pointer_cast(shared_ptr<U>&& r) noexcept;
template<class T, class U>
constexpr shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
constexpr shared_ptr<T> dynamic_pointer_cast(shared_ptr<U>&& r) noexcept;
§ 20.2.2 © ISO/IEC
668

===== PAGE 680 =====

Dxxxx
template<class T, class U>
constexpr shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
constexpr shared_ptr<T> const_pointer_cast(shared_ptr<U>&& r) noexcept;
template<class T, class U>
shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
shared_ptr<T> reinterpret_pointer_cast(shared_ptr<U>&& r) noexcept;
// 20.3.2.2.11,shared_ptr get_deleter
template<class D, class T>
constexpr D* get_deleter(const shared_ptr<T>& p) noexcept;
// 20.3.2.2.12,shared_ptr I/O
template<class E, class T, class Y>
basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const shared_ptr<Y>& p);
// 20.3.2.3, class templateweak_ptr
template<class T> class weak_ptr;
// 20.3.2.3.7,weak_ptr specialized algorithms
template<class T> constexpr void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
// 20.3.2.4, class templateowner_less
template<class T = void> struct owner_less;
// 20.3.2.5, structowner_hash
struct owner_hash;
// 20.3.2.6, structowner_equal
struct owner_equal;
// 20.3.2.7, class templateenable_shared_from_this
template<class T> class enable_shared_from_this;
// 20.3.3, hash support
template<class T> struct hash; // freestanding
template<class T, class D> struct hash<unique_ptr<T, D>>; // freestanding
template<class T> struct hash<shared_ptr<T>>;
// 32.5.8.7, atomic smart pointers
template<class T> struct atomic; // freestanding
template<class T> struct atomic<shared_ptr<T>>;
template<class T> struct atomic<weak_ptr<T>>;
// 20.3.4.1, class templateout_ptr_t
template<class Smart, class Pointer, class... Args>
class out_ptr_t; // freestanding
// 20.3.4.2, function templateout_ptr
template<class Pointer = void, class Smart, class... Args>
constexpr auto out_ptr(Smart& s, Args&&... args); // freestanding
// 20.3.4.3, class templateinout_ptr_t
template<class Smart, class Pointer, class... Args>
class inout_ptr_t; // freestanding
// 20.3.4.4, function templateinout_ptr
template<class Pointer = void, class Smart, class... Args>
constexpr auto inout_ptr(Smart& s, Args&&... args); // freestanding
// 20.4.1, class templateindirect
template<class T, class Allocator = allocator<T>>
class indirect;
§ 20.2.2 © ISO/IEC
669

===== PAGE 681 =====

Dxxxx
// 20.4.1.10, hash support
template<class T, class Alloc> struct hash<indirect<T, Alloc>>;
// 20.4.2, class templatepolymorphic
template<class T, class Allocator = allocator<T>>
class polymorphic;
namespace pmr {
template<class T> using indirect = indirect<T, polymorphic_allocator<T>>;
template<class T> using polymorphic = polymorphic<T, polymorphic_allocator<T>>;
}
}
20.2.3 Pointer traits [pointer.traits]
20.2.3.1 General [pointer.traits.general]
1 The class templatepointer_traits supplies a uniform interface to certain attributes of pointer-like types.
namespace std {
template<class Ptr> struct pointer_traits {
see below ;
};
template<class T> struct pointer_traits<T*> {
using pointer = T*;
using element_type = T;
using difference_type = ptrdiff_t;
template<class U> using rebind = U*;
static constexpr pointer pointer_to(see below r) noexcept;
};
}
20.2.3.2 Member types [pointer.traits.types]
1 The definitions in this subclause make use of the following exposition-only class template and concept:
template<class T>
struct ptr-traits-elem // exposition only
{ };
template<class T> requires requires { typename T::element_type; }
struct ptr-traits-elem <T>
{ using type = T::element_type; };
template<template<class...> class SomePointer, class T, class... Args>
requires (!requires { typename SomePointer<T, Args...>::element_type; })
struct ptr-traits-elem <SomePointer<T, Args...>>
{ using type = T; };
template<class Ptr>
concept has-elem-type = // exposition only
requires { typename ptr-traits-elem <Ptr>::type; }
2 If Ptr satisfies has-elem-type , a specializationpointer_traits<Ptr> generated from thepointer_traits
primary template has the following members as well as those described in 20.2.3.3; otherwise, such a
specialization has no members by any of those names.
using pointer = see below ;
3 Type: Ptr.
using element_type = see below ;
4 Type: typename ptr-traits-elem <Ptr>::type.
§ 20.2.3.2 © ISO/IEC
670

===== PAGE 682 =====

Dxxxx
using difference_type = see below ;
5 Type: Ptr::difference_type if thequalified-id Ptr::difference_type is valid and denotes a type
(13.10.3); otherwise,ptrdiff_t.
template<class U> using rebind = see below ;
6 Alias template: Ptr::rebind<U>if thequalified-id Ptr::rebind<U>is valid and denotes a type (13.10.3);
otherwise, SomePointer<U, Args> if Ptr is a class template instantiation of the formSomePointer<T,
Args>, whereArgs is zero or more type arguments; otherwise, the instantiation ofrebind is ill-formed.
20.2.3.3 Member functions [pointer.traits.functions]
static constexpr pointer pointer_traits::pointer_to(see below r);
static constexpr pointer pointer_traits<T*>::pointer_to(see below r) noexcept;
1 Mandates: For the first member function,Ptr::pointer_to(r) is well-formed.
2 Preconditions: For the first member function,Ptr::pointer_to(r) returns a pointer tor through
which indirection is valid.
3 Returns: The first member function returns Ptr::pointer_to(r). The second member function
returns addressof(r).
4 Remarks: If element_type is cv void, the type ofr is unspecified; otherwise, it iselement_type&.
20.2.3.4 Optional members [pointer.traits.optmem]
1 Specializations of pointer_traits may define the member declared in this subclause to customize the
behavior of the standard library. A specialization generated from thepointer_traits primary template has
no member by this name.
static element_type* to_address(pointer p) noexcept;
2 Returns: A pointer of typeelement_type* that references the same location as the argumentp.
3 [Note 1: This function is intended to be the inverse ofpointer_to. If defined, it customizes the behavior of the
non-member functionto_address (20.2.4). —end note]
20.2.4 Pointer conversion [pointer.conversion]
template<class T> constexpr T* to_address(T* p) noexcept;
1 Mandates: T is not a function type.
2 Returns: p.
template<class Ptr> constexpr auto to_address(const Ptr& p) noexcept;
3 Returns: pointer_traits<Ptr>::to_address(p) if that expression is well-formed (see 20.2.3.4),
otherwise to_address(p.operator->()).
20.2.5 Pointer alignment [ptr.align]
void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
1 Preconditions:
—(1.1) alignment is a power of two
—(1.2) ptr represents the address of contiguous storage of at leastspace bytes
2 Effects: If it is possible to fitsize bytes of storage aligned byalignment into the buffer pointed to by
ptr with lengthspace, the function updatesptr to represent the first possible address of such storage
and decreasesspace by the number of bytes used for alignment. Otherwise, the function does nothing.
3 Returns: A null pointer if the requested aligned buffer would not fit into the available space, otherwise
the adjusted value ofptr.
4 [Note 1: The function updates itsptr and space arguments so that it can be called repeatedly with possibly
different alignment and size arguments for the same buffer.—end note]
§ 20.2.5 © ISO/IEC
671

===== PAGE 683 =====

Dxxxx
template<size_t N, class T>
constexpr T* assume_aligned(T* ptr);
5 Mandates: N is a power of two.
6 Preconditions: ptr points to an objectX of a type similar (7.3.6) toT, whereX has alignmentN (6.8.3).
7 Returns: ptr.
8 Throws: Nothing.
9 [Note 2: The alignment assumption on an objectX expressed by a call toassume_aligned might result in
generation of more efficient code. It is up to the program to ensure that the assumption actually holds. The
call does not cause the implementation to verify or enforce this. An implementation might only make the
assumption for those operations onX that accessX through the pointer returned byassume_aligned. —end
note]
template<size_t Alignment, class T>
bool is_sufficiently_aligned(T* ptr);
10 Preconditions: p points to an objectX of a type similar (7.3.6) toT.
11 Returns: true if X has alignment at leastAlignment, otherwisefalse.
12 Throws: Nothing.
20.2.6 Explicit lifetime management [obj.lifetime]
template<class T>
T* start_lifetime_as(void* p) noexcept;
template<class T>
const T* start_lifetime_as(const void* p) noexcept;
template<class T>
volatile T* start_lifetime_as(volatile void* p) noexcept;
template<class T>
const volatile T* start_lifetime_as(const volatile void* p) noexcept;
1 Mandates: T is an implicit-lifetime type (6.9.1) and not an incomplete type (6.9.1).
2 Preconditions: [p,(char*)p + sizeof(T)) denotes a region of allocated storage that is a subset of the
region of storage reachable through (6.9.4)p and suitably aligned for the typeT.
3 Effects: Implicitly creates objects (6.8.2) within the denoted region consisting of an objecta of typeT
whose address isp, and objects nested withina, as follows: The object representation ofa is the contents
of the storage prior to the call tostart_lifetime_as. The value of each created objecto of trivially
copyable type (6.9.1)U is determined in the same manner as for a call tobit_cast<U>(E) (22.11.3),
where E is an lvalue of typeU denoting o, except that the storage is not accessed. The value of any
other created object is unspecified.
[Note 1: The unspecified value can be indeterminate.—end note]
4 Returns: A pointer to thea defined in theEffects paragraph.
template<class T>
T* start_lifetime_as_array(void* p, size_t n) noexcept;
template<class T>
const T* start_lifetime_as_array(const void* p, size_t n) noexcept;
template<class T>
volatile T* start_lifetime_as_array(volatile void* p, size_t n) noexcept;
template<class T>
const volatile T* start_lifetime_as_array(const volatile void* p, size_t n) noexcept;
5 Mandates: T is a complete type.
6 Preconditions: p is suitably aligned for an array ofT or is null.n <= size_t(-1) / sizeof(T) is true.
If n > 0 is true, [(char*)p,(char*)p + (n * sizeof(T))) denotes a region of allocated storage that
is a subset of the region of storage reachable through (6.9.4)p.
7 Effects: If n > 0 is true, equivalent tostart_lifetime_as<U>(p) where U is the type “array ofn T”.
Otherwise, there are no effects.
8 Returns: A pointer to the first element of the created array, if any; otherwise, a pointer that compares
equal top (7.6.10).
§ 20.2.6 © ISO/IEC
672

===== PAGE 684 =====

Dxxxx
20.2.7 Allocator argument tag [allocator.tag]
namespace std {
struct allocator_arg_t { explicit allocator_arg_t() = default; };
inline constexpr allocator_arg_t allocator_arg{};
}
1 The allocator_arg_t struct is an empty class type used as a unique type to disambiguate constructor and
function overloading. Specifically, several types (seetuple 22.4) have constructors withallocator_arg_t
as the first argument, immediately followed by an argument of a type that meets theCpp17Allocator
requirements (16.4.4.6.1).
20.2.8 uses_allocator [allocator.uses]
20.2.8.1 uses_allocator trait [allocator.uses.trait]
template<class T, class Alloc> struct uses_allocator;
1 Remarks: Automatically detects whetherT has a nestedallocator_type that is convertible from
Alloc. Meets theCpp17BinaryTypeTraitrequirements (21.3.2). The implementation shall provide a
definition that is derived fromtrue_type if thequalified-id T::allocator_type is valid and denotes
a type (13.10.3) andis_convertible_v<Alloc, T::allocator_type> != false, otherwise it shall
be derived from false_type. A program may specialize this template to derive fromtrue_type
for a program-defined typeT that does not have a nestedallocator_type but nonetheless can be
constructed with an allocator where either:
—(1.1) the first argument of a constructor has typeallocator_arg_t and the second argument has type
Alloc or
—(1.2) the last argument of a constructor has typeAlloc.
20.2.8.2 Uses-allocator construction [allocator.uses.construction]
1 Uses-allocator constructionwith allocatorallocand constructor argumentsargs...refers to the construction
of an object of typeT such thatalloc is passed to the constructor ofT if T uses an allocator type compatible
with alloc. When applied to the construction of an object of typeT, it is equivalent to initializing it with
the value of the expressionmake_obj_using_allocator<T>(alloc, args...), described below.
2 The following utility functions support three conventions for passingalloc to a constructor:
—(2.1) If T does not use an allocator compatible withalloc, thenalloc is ignored.
—(2.2) Otherwise, if T has a constructor invocable asT(allocator_arg_t{}, alloc, args...) (leading-
allocator convention), then uses-allocator construction chooses this constructor form.
—(2.3) Otherwise, ifT has a constructor invocable asT(args..., alloc) (trailing-allocator convention), then
uses-allocator construction chooses this constructor form.
3 The uses_allocator_construction_args function template takes an allocator and argument list and
produces (as a tuple) a new argument list matching one of the above conventions. Additionally, overloads are
provided that treat specializations ofpair such that uses-allocator construction is applied individually to
the first and second data members. Themake_obj_using_allocator and uninitialized_construct_-
using_allocator function templates apply the modified constructor arguments to construct an object of
type T as a return value or in-place, respectively.
[Note 1: Foruses_allocator_construction_args and make_obj_using_allocator, typeT is not deduced and must
therefore be specified explicitly by the caller.—end note]
template<class T, class Alloc, class... Args>
constexpr auto uses_allocator_construction_args(const Alloc& alloc,
Args&&... args) noexcept;
4 Constraints: remove_cv_t<T> is not a specialization ofpair.
5 Returns: A tuple value determined as follows:
—(5.1) If uses_allocator_v<remove_cv_t<T>, Alloc> is false and is_constructible_v<T,
Args...> is true, returnforward_as_tuple(std::forward<Args>(args)...).
—(5.2) Otherwise, ifuses_allocator_v<remove_cv_t<T>, Alloc>istrueandis_constructible_v<T,
allocator_arg_t, const Alloc&, Args...> is true, return
§ 20.2.8.2 © ISO/IEC
673

===== PAGE 685 =====

Dxxxx
tuple<allocator_arg_t, const Alloc&, Args&&...>(
allocator_arg, alloc, std::forward<Args>(args)...)
—(5.3) Otherwise, ifuses_allocator_v<remove_cv_t<T>, Alloc>istrueandis_constructible_v<T,
Args..., const Alloc&> is true, returnforward_as_tuple(std::forward<Args>(args)...,
alloc).
—(5.4) Otherwise, the program is ill-formed.
[Note 2: This definition prevents a silent failure to pass the allocator to a constructor of a type for which
uses_allocator_v<T, Alloc> is true. —end note]
template<class T, class Alloc, class Tuple1, class Tuple2>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, piecewise_construct_t,
Tuple1&& x, Tuple2&& y) noexcept;
6 Let T1 be T::first_type. Let T2 be T::second_type.
7 Constraints: remove_cv_t<T> is a specialization ofpair.
8 Effects: Equivalent to:
return make_tuple(
piecewise_construct,
apply([&alloc](auto&&... args1) {
return uses_allocator_construction_args<T1>(
alloc, std::forward<decltype(args1)>(args1)...);
}, std::forward<Tuple1>(x)),
apply([&alloc](auto&&... args2) {
return uses_allocator_construction_args<T2>(
alloc, std::forward<decltype(args2)>(args2)...);
}, std::forward<Tuple2>(y)));
template<class T, class Alloc>
constexpr auto uses_allocator_construction_args(const Alloc& alloc) noexcept;
9 Constraints: remove_cv_t<T> is a specialization ofpair.
10 Effects: Equivalent to:
return uses_allocator_construction_args<T>(alloc, piecewise_construct,
tuple<>{}, tuple<>{});
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc,
U&& u, V&& v) noexcept;
11 Constraints: remove_cv_t<T> is a specialization ofpair.
12 Effects: Equivalent to:
return uses_allocator_construction_args<T>(alloc, piecewise_construct,
forward_as_tuple(std::forward<U>(u)),
forward_as_tuple(std::forward<V>(v)));
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc,
pair<U, V>& pr) noexcept;
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc,
const pair<U, V>& pr) noexcept;
13 Constraints: remove_cv_t<T> is a specialization ofpair.
14 Effects: Equivalent to:
return uses_allocator_construction_args<T>(alloc, piecewise_construct,
forward_as_tuple(pr.first),
forward_as_tuple(pr.second));
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc,
pair<U, V>&& pr) noexcept;
§ 20.2.8.2 © ISO/IEC
674

===== PAGE 686 =====

Dxxxx
template<class T, class Alloc, class U, class V>
constexpr auto uses_allocator_construction_args(const Alloc& alloc,
const pair<U, V>&& pr) noexcept;
15 Constraints: remove_cv_t<T> is a specialization ofpair.
16 Effects: Equivalent to:
return uses_allocator_construction_args<T>(alloc, piecewise_construct,
forward_as_tuple(get<0>(std::move(pr))),
forward_as_tuple(get<1>(std::move(pr))));
template<class T, class Alloc, pair-like P>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, P&& p) noexcept;
17 Constraints: remove_cv_t<T>is a specialization ofpairand remove_cvref_t<P>is not a specialization
of ranges::subrange.
18 Effects: Equivalent to:
return uses_allocator_construction_args<T>(alloc, piecewise_construct,
forward_as_tuple(get<0>(std::forward<P>(p))),
forward_as_tuple(get<1>(std::forward<P>(p))));
template<class T, class Alloc, class U>
constexpr auto uses_allocator_construction_args(const Alloc& alloc, U&& u) noexcept;
19 Let FUN be the function template:
template<class A, class B>
void FUN (const pair<A, B>&);
20 Constraints: remove_cv_t<T> is a specialization ofpair, and either:
—(20.1) remove_cvref_t<U> is a specialization ofranges::subrange, or
—(20.2) U does not satisfypair-like and the expressionFUN (u) is not well-formed when considered as
an unevaluated operand.
21 Let pair-constructor be an exposition-only class defined as follows:
class pair-constructor {
using pair-type = remove_cv_t<T>; // exposition only
constexpr auto do-construct (const pair-type & p) const { // exposition only
return make_obj_using_allocator<pair-type >(alloc_, p);
}
constexpr auto do-construct (pair-type && p) const { // exposition only
return make_obj_using_allocator<pair-type >(alloc_, std::move(p));
}
const Alloc& alloc_; // exposition only
U& u_; // exposition only
public:
constexpr operator pair-type () const {
return do-construct (std::forward<U>(u_));
}
};
22 Returns: make_tuple(pc), wherepcis apair-constructor object whosealloc_ member is initialized
with alloc and whoseu_ member is initialized withu.
template<class T, class Alloc, class... Args>
constexpr T make_obj_using_allocator(const Alloc& alloc, Args&&... args);
23 Effects: Equivalent to:
return make_from_tuple<T>(uses_allocator_construction_args<T>(
alloc, std::forward<Args>(args)...));
§ 20.2.8.2 © ISO/IEC
675

===== PAGE 687 =====

Dxxxx
template<class T, class Alloc, class... Args>
constexpr T* uninitialized_construct_using_allocator(T* p, const Alloc& alloc, Args&&... args);
24 Effects: Equivalent to:
return apply([&]<class... U>(U&&... xs) {
return construct_at(p, std::forward<U>(xs)...);
}, uses_allocator_construction_args<T>(alloc, std::forward<Args>(args)...));
20.2.9 Allocator traits [allocator.traits]
20.2.9.1 General [allocator.traits.general]
1 The class templateallocator_traits supplies a uniform interface to all allocator types. An allocator cannot
be a non-class type, however, even ifallocator_traits supplies the entire required interface.
[Note 1: Thus, it is always possible to create a derived class from an allocator.—end note]
If a program declares an explicit or partial specialization ofallocator_traits, the program is ill-formed,
no diagnostic required.
namespace std {
template<class Alloc> struct allocator_traits {
using allocator_type = Alloc;
using value_type = Alloc::value_type;
using pointer = see below ;
using const_pointer = see below ;
using void_pointer = see below ;
using const_void_pointer = see below ;
using difference_type = see below ;
using size_type = see below ;
using propagate_on_container_copy_assignment = see below ;
using propagate_on_container_move_assignment = see below ;
using propagate_on_container_swap = see below ;
using is_always_equal = see below ;
template<class T> using rebind_alloc = see below ;
template<class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;
static constexpr pointer allocate(Alloc& a, size_type n);
static constexpr pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
static constexpr allocation_result<pointer, size_type>
allocate_at_least(Alloc& a, size_type n);
static constexpr void deallocate(Alloc& a, pointer p, size_type n);
template<class T, class... Args>
static constexpr void construct(Alloc& a, T* p, Args&&... args);
template<class T>
static constexpr void destroy(Alloc& a, T* p);
static constexpr size_type max_size(const Alloc& a) noexcept;
static constexpr Alloc select_on_container_copy_construction(const Alloc& rhs);
};
}
20.2.9.2 Member types [allocator.traits.types]
using pointer = see below ;
1 Type: Alloc::pointer if the qualified-id Alloc::pointer is valid and denotes a type (13.10.3);
otherwise, value_type*.
§ 20.2.9.2 © ISO/IEC
676

===== PAGE 688 =====

Dxxxx
using const_pointer = see below ;
2 Type: Alloc::const_pointer if thequalified-id Alloc::const_pointer is valid and denotes a type
(13.10.3); otherwise,pointer_traits<pointer>::rebind<const value_type>.
using void_pointer = see below ;
3 Type: Alloc::void_pointer if the qualified-id Alloc::void_pointer is valid and denotes a type
(13.10.3); otherwise,pointer_traits<pointer>::rebind<void>.
using const_void_pointer = see below ;
4 Type: Alloc::const_void_pointer if thequalified-id Alloc::const_void_pointer is valid and de-
notes a type (13.10.3); otherwise,pointer_traits<pointer>::rebind<const void>.
using difference_type = see below ;
5 Type: Alloc::difference_type if thequalified-id Alloc::difference_type is valid and denotes a
type (13.10.3); otherwise,pointer_traits<pointer>::difference_type.
using size_type = see below ;
6 Type: Alloc::size_type if thequalified-id Alloc::size_type is valid and denotes a type (13.10.3);
otherwise, make_unsigned_t<difference_type>.
using propagate_on_container_copy_assignment = see below ;
7 Type: Alloc::propagate_on_container_copy_assignment if the qualified-id Alloc::propagate_-
on_container_copy_assignment is valid and denotes a type (13.10.3); otherwisefalse_type.
using propagate_on_container_move_assignment = see below ;
8 Type: Alloc::propagate_on_container_move_assignment if the qualified-id Alloc::propagate_-
on_container_move_assignment is valid and denotes a type (13.10.3); otherwisefalse_type.
using propagate_on_container_swap = see below ;
9 Type: Alloc::propagate_on_container_swap if thequalified-id Alloc::propagate_on_container_-
swap is valid and denotes a type (13.10.3); otherwisefalse_type.
using is_always_equal = see below ;
10 Type: Alloc::is_always_equal if thequalified-id Alloc::is_always_equal is valid and denotes a
type (13.10.3); otherwiseis_empty<Alloc>::type.
template<class T> using rebind_alloc = see below ;
11 Alias template: Alloc::rebind<T>::other if thequalified-id Alloc::rebind<T>::other is valid and
denotes a type (13.10.3); otherwise,Alloc<T, Args> if Alloc is a class template instantiation of the
form Alloc<U, Args>, where Args is zero or more type arguments; otherwise, the instantiation of
rebind_alloc is ill-formed.
20.2.9.3 Static member functions [allocator.traits.members]
static constexpr pointer allocate(Alloc& a, size_type n);
1 Returns: a.allocate(n).
static constexpr pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
2 Returns: a.allocate(n, hint) if that expression is well-formed; otherwise,a.allocate(n).
static constexpr allocation_result<pointer, size_type> allocate_at_least(Alloc& a, size_type n);
3 Returns: a.allocate_at_least(n) if that expression is well-formed; otherwise,{a.allocate(n), n}.
static constexpr void deallocate(Alloc& a, pointer p, size_type n);
4 Effects: Calls a.deallocate(p, n).
5 Throws: Nothing.
§ 20.2.9.3 © ISO/IEC
677

===== PAGE 689 =====

Dxxxx
template<class T, class... Args>
static constexpr void construct(Alloc& a, T* p, Args&&... args);
6 Effects: Calls a.construct(p, std::forward<Args>(args)...) if that call is well-formed; otherwise,
invokesconstruct_at(p, std::forward<Args>(args)...).
template<class T>
static constexpr void destroy(Alloc& a, T* p);
7 Effects: Calls a.destroy(p) if that call is well-formed; otherwise, invokesdestroy_at(p).
static constexpr size_type max_size(const Alloc& a) noexcept;
8 Returns: a.max_size() if that expression is well-formed; otherwise,numeric_limits<size_type>::
max() / sizeof(value_type).
static constexpr Alloc select_on_container_copy_construction(const Alloc& rhs);
9 Returns: rhs.select_on_container_copy_construction() if that expression is well-formed; other-
wise, rhs.
20.2.9.4 Other [allocator.traits.other]
1 The class templateallocation_result has the template parameters, data members, and special members
specified above. It has no base classes or members other than those specified.
20.2.10 The default allocator [default.allocator]
20.2.10.1 General [default.allocator.general]
1 All specializations of the default allocator meet the allocator completeness requirements (16.4.4.6.2).
namespace std {
template<class T> class allocator {
public:
using value_type = T;
using size_type = size_t;
using difference_type = ptrdiff_t;
using propagate_on_container_move_assignment = true_type;
constexpr allocator() noexcept;
constexpr allocator(const allocator&) noexcept;
template<class U> constexpr allocator(const allocator<U>&) noexcept;
constexpr ~allocator();
constexpr allocator& operator=(const allocator&) = default;
constexpr T* allocate(size_t n);
constexpr allocation_result<T*> allocate_at_least(size_t n);
constexpr void deallocate(T* p, size_t n);
};
}
2 allocator_traits<allocator<T>>::is_always_equal::value is true for anyT.
20.2.10.2 Members [allocator.members]
1 Except for the destructor, member functions of the default allocator shall not introduce data races (6.10.2)
as a result of concurrent calls to those member functions from different threads. Calls to these functions
that allocate or deallocate a particular unit of storage shall occur in a single total order, and each such
deallocation call shall happen before the next allocation (if any) in this order.
constexpr T* allocate(size_t n);
2 Mandates: T is not an incomplete type (6.9.1).
3 Returns: A pointer to the initial element of an array ofn T.
4 Throws: bad_array_new_length if numeric_limits<size_t>::max() / sizeof(T) < n, or bad_-
alloc if the storage cannot be obtained.
§ 20.2.10.2 © ISO/IEC
678

===== PAGE 690 =====

Dxxxx
5 Remarks: The storage for the array is obtained by calling::operator new (17.6.3), but it is unspecified
when or how often this function is called. This function starts the lifetime of the array object, but not
that of any of the array elements.
constexpr allocation_result<T*> allocate_at_least(size_t n);
6 Mandates: T is not an incomplete type (6.9.1).
7 Returns: allocation_result<T*>{ptr, count}, whereptr is a pointer to the initial element of an
array ofcount Tand count ≥n.
8 Throws: bad_array_new_length if numeric_limits<size_t>::max() / sizeof(T) < n, or bad_-
alloc if the storage cannot be obtained.
9 Remarks: The storage for the array is obtained by calling::operator new, but it is unspecified when
or how often this function is called. This function starts the lifetime of the array object, but not that
of any of the array elements.
constexpr void deallocate(T* p, size_t n);
10 Preconditions:
—(10.1) If p is memory that was obtained by a call toallocate_at_least, letret be the value returned
and req be the value passed as the first argument to that call.p is equal toret.ptr and n is a
value such thatreq ≤n ≤ret.count.
—(10.2) Otherwise, p is a pointer value obtained fromallocate. n equals the value passed as the first
argument to the invocation ofallocate which returnedp.
11 Effects: Deallocates the storage referenced byp.
12 Remarks: Uses ::operator delete (17.6.3), but it is unspecified when this function is called.
20.2.10.3 Operators [allocator.globals]
template<class T, class U>
constexpr bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
1 Returns: true.
20.2.11 addressof [specialized.addressof]
template<class T> constexpr T* addressof(T& r) noexcept;
1 Returns: The actual address of the object or function referenced byr, even in the presence of an
overloaded operator&.
2 Remarks: An expressionaddressof(E) is a constant subexpression (3.15) ifE is an lvalue constant
subexpression.
20.2.12 C library memory allocation [c.malloc]
1 [Note 1: The header<cstdlib> (17.2.2) declares the functions described in this subclause.—end note]
void* aligned_alloc(size_t alignment, size_t size);
void* calloc(size_t nmemb, size_t size);
void* malloc(size_t size);
2 Effects: These functions have the semantics specified in the C standard library.
3 Remarks: These functions do not attempt to allocate storage by calling::operator new() (17.6.3).
4 These functions implicitly create objects (6.8.2) in the returned region of storage and return a pointer
to a suitable created object. In the case ofcalloc, the objects are created before the storage is zeroed.
void* realloc(void* ptr, size_t size);
5 Preconditions: free(ptr) has well-defined behavior.
6 Effects: If ptr is not null andsize is zero, the behavior is erroneous and the effects are implementation-
defined. Otherwise, this function has the semantics specified in the C standard library.
7 Remarks: This function does not attempt to allocate storage by calling::operator new() (17.6.3).
When a non-null pointer is returned, this function implicitly creates objects (6.8.2) in the returned
§ 20.2.12 © ISO/IEC
679

===== PAGE 691 =====

Dxxxx
region of storage and returns a pointer to a suitable created object. The objects are created before the
storage is copied.
void free(void* ptr);
8 Effects: This function has the semantics specified in the C standard library.
9 Remarks: This function does not attempt to deallocate storage by calling::operator delete().
See also: ISO/IEC 9899:2024, 7.24.4
20.3 Smart pointers [smartptr]
20.3.1 Unique-ownership pointers [unique.ptr]
20.3.1.1 General [unique.ptr.general]
1 A unique pointeris an object that owns another object and manages that other object through a pointer.
More precisely, a unique pointer is an objectu that stores a pointer to a second objectp and will dispose of
p when u is itself destroyed (e.g., when leaving block scope (8.10)). In this context,u is said toown p.
2 The mechanism by whichu disposes ofp is known asp’s associateddeleter, a function object whose correct
invocation results inp’s appropriate disposition (typically its deletion).
3 Let the notationu.p denote the pointer stored byu, and letu.d denote the associated deleter. Upon request,
u can reset (replace) u.p and u.d with another pointer and deleter, but properly disposes of its owned object
via the associated deleter before such replacement is considered completed.
4 Each object of a type U instantiated from the unique_ptr template specified in 20.3.1 has the strict
ownership semantics, specified above, of a unique pointer. In partial satisfaction of these semantics, each
such U is Cpp17MoveConstructible and Cpp17MoveAssignable, but is not Cpp17CopyConstructible nor
Cpp17CopyAssignable. The template parameterT of unique_ptr may be an incomplete type.
5 [Note 1: The uses of unique_ptr include providing exception safety for dynamically allocated memory, passing
ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from a
function. —end note]
20.3.1.2 Default deleters [unique.ptr.dltr]
20.3.1.2.1 General [unique.ptr.dltr.general]
1 The class templatedefault_delete serves as the default deleter (destruction policy) for the class template
unique_ptr.
2 The template parameterT of default_delete may be an incomplete type.
20.3.1.2.2 default_delete [unique.ptr.dltr.dflt]
namespace std {
template<class T> struct default_delete {
constexpr default_delete() noexcept = default;
template<class U> constexpr default_delete(const default_delete<U>&) noexcept;
constexpr void operator()(T*) const;
};
}
template<class U> constexpr default_delete(const default_delete<U>& other) noexcept;
1 Constraints: U* is implicitly convertible toT*.
2 Effects: Constructs adefault_delete object from anotherdefault_delete<U> object.
constexpr void operator()(T* ptr) const;
3 Mandates: T is a complete type.
4 Effects: Calls delete on ptr.
20.3.1.2.3 default_delete<T[]> [unique.ptr.dltr.dflt1]
namespace std {
template<class T> struct default_delete<T[]> {
constexpr default_delete() noexcept = default;
template<class U> constexpr default_delete(const default_delete<U[]>&) noexcept;
template<class U> constexpr void operator()(U* ptr) const;
§ 20.3.1.2.3 © ISO/IEC
680

===== PAGE 692 =====

Dxxxx
};
}
template<class U> constexpr default_delete(const default_delete<U[]>& other) noexcept;
1 Constraints: U(*)[] is convertible toT(*)[].
2 Effects: Constructs adefault_delete object from anotherdefault_delete<U[]> object.
template<class U> constexpr void operator()(U* ptr) const;
3 Constraints: U(*)[] is convertible toT(*)[].
4 Mandates: U is a complete type.
5 Effects: Calls delete[] on ptr.
20.3.1.3 unique_ptr for single objects [unique.ptr.single]
20.3.1.3.1 General [unique.ptr.single.general]
namespace std {
template<class T, class D = default_delete<T>> class unique_ptr {
public:
using pointer = see below ;
using element_type = T;
using deleter_type = D;
// 20.3.1.3.2, constructors
constexpr unique_ptr() noexcept;
constexpr explicit unique_ptr(type_identity_t<pointer> p) noexcept;
constexpr unique_ptr(type_identity_t<pointer> p, see below d1) noexcept;
constexpr unique_ptr(type_identity_t<pointer> p, see below d2) noexcept;
constexpr unique_ptr(unique_ptr&& u) noexcept;
constexpr unique_ptr(nullptr_t) noexcept;
template<class U, class E>
constexpr unique_ptr(unique_ptr<U, E>&& u) noexcept;
// 20.3.1.3.3, destructor
constexpr ~unique_ptr();
// 20.3.1.3.4, assignment
constexpr unique_ptr& operator=(unique_ptr&& u) noexcept;
template<class U, class E>
constexpr unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
constexpr unique_ptr& operator=(nullptr_t) noexcept;
// 20.3.1.3.5, observers
constexpr add_lvalue_reference_t<T> operator*() const noexcept(see below );
constexpr pointer operator->() const noexcept;
constexpr pointer get() const noexcept;
constexpr deleter_type& get_deleter() noexcept;
constexpr const deleter_type& get_deleter() const noexcept;
constexpr explicit operator bool() const noexcept;
// 20.3.1.3.6, modifiers
constexpr pointer release() noexcept;
constexpr void reset(pointer p = pointer()) noexcept;
constexpr void swap(unique_ptr& u) noexcept;
// disable copy from lvalue
unique_ptr(const unique_ptr&) = delete;
unique_ptr& operator=(const unique_ptr&) = delete;
};
}
1 A program that instantiates the definition ofunique_ptr<T, D> is ill-formed ifT* is an invalid type.
§ 20.3.1.3.1 © ISO/IEC
681

===== PAGE 693 =====

Dxxxx
[Note 1: This prevents the instantiation of specializations such asunique_ptr<T&, D> and unique_ptr<int() const,
D>. —end note]
2 The default type for the template parameterD is default_delete. A client-supplied template argumentD
shall be a function object type (22.10), lvalue reference to function, or lvalue reference to function object type
for which, given a valued of typeD and a valueptr of typeunique_ptr<T, D>::pointer, the expression
d(ptr) is valid and has the effect of disposing of the pointer as appropriate for that deleter.
3 If the deleter’s typeD is not a reference type,D shall meet theCpp17Destructible requirements (Table 35).
4 If thequalified-id remove_reference_t<D>::pointer is valid and denotes a type (13.10.3), thenunique_-
ptr<T, D>::pointershall be a synonym forremove_reference_t<D>::pointer. Otherwiseunique_ptr<T,
D>::pointer shall be a synonym forelement_type*. The type unique_ptr<T, D>::pointer shall meet
the Cpp17NullablePointer requirements (Table 36).
5 [Example 1: Given an allocator typeX (16.4.4.6.1) and lettingA be a synonym forallocator_traits<X>, the types
A::pointer, A::const_pointer, A::void_pointer, and A::const_void_pointer may be used as unique_ptr<T,
D>::pointer. —end example]
20.3.1.3.2 Constructors [unique.ptr.single.ctor]
constexpr unique_ptr() noexcept;
constexpr unique_ptr(nullptr_t) noexcept;
1 Constraints: is_pointer_v<deleter_type> is false and is_default_constructible_v<deleter_-
type> is true.
2 Preconditions: D meets theCpp17DefaultConstructible requirements (Table 30), and that construction
does not throw an exception.
3 Effects: Constructs aunique_ptr object that owns nothing, value-initializing the stored pointer and
the stored deleter.
4 Postconditions: get() == nullptr. get_deleter() returns a reference to the stored deleter.
constexpr explicit unique_ptr(type_identity_t<pointer> p) noexcept;
5 Constraints: is_pointer_v<deleter_type> is false and is_default_constructible_v<deleter_-
type> is true.
6 Preconditions: D meets theCpp17DefaultConstructible requirements (Table 30), and that construction
does not throw an exception.
7 Effects: Constructs a unique_ptr which owns p, initializing the stored pointer withp and value-
initializing the stored deleter.
8 Postconditions: get() == p. get_deleter() returns a reference to the stored deleter.
constexpr unique_ptr(type_identity_t<pointer> p, const D& d) noexcept;
constexpr unique_ptr(type_identity_t<pointer> p, remove_reference_t<D>&& d) noexcept;
9 Constraints: is_constructible_v<D, decltype(d)> is true.
10 Preconditions: For the first constructor, ifD is not a reference type,D meets theCpp17CopyConstructible
requirements and such construction does not exit via an exception. For the second constructor, ifD is
not a reference type,D meets theCpp17MoveConstructible requirements and such construction does
not exit via an exception.
11 Effects: Constructs a unique_ptr object which ownsp, initializing the stored pointer withp and
initializing the deleter fromstd::forward<decltype(d)>(d).
12 Postconditions: get() == p. get_deleter() returns a reference to the stored deleter. If D is a
reference type thenget_deleter() returns a reference to the lvalued.
13 Remarks: If D is a reference type, the second constructor is defined as deleted.
14 [Example 1:
D d;
unique_ptr<int, D> p1(new int, D()); // D must be Cpp17MoveConstructible
unique_ptr<int, D> p2(new int, d); // D must be Cpp17CopyConstructible
unique_ptr<int, D&> p3(new int, d); // p3 holds a reference tod
unique_ptr<int, const D&> p4(new int, D()); // error: rvalue deleter object combined
§ 20.3.1.3.2 © ISO/IEC
682

===== PAGE 694 =====

Dxxxx
// with reference deleter type
—end example]
constexpr unique_ptr(unique_ptr&& u) noexcept;
15 Constraints: is_move_constructible_v<D> is true.
16 Preconditions: If D is not a reference type,D meets theCpp17MoveConstructible requirements (Table 31).
Construction of the deleter from an rvalue of typeD does not throw an exception.
17 Effects: Constructs aunique_ptr from u. If D is a reference type, this deleter is copy constructed from
u’s deleter; otherwise, this deleter is move constructed fromu’s deleter.
[Note 1: The construction of the deleter can be implemented withstd::forward<D>. —end note]
18 Postconditions: get() yields the valueu.get() yielded before the construction.u.get() == nullptr.
get_deleter() returns a reference to the stored deleter that was constructed fromu.get_deleter().
If D is a reference type thenget_deleter() and u.get_deleter() both reference the same lvalue
deleter.
template<class U, class E> constexpr unique_ptr(unique_ptr<U, E>&& u) noexcept;
19 Constraints:
—(19.1) unique_ptr<U, E>::pointer is implicitly convertible topointer,
—(19.2) U is not an array type, and
—(19.3) either D is a reference type andE is the same type asD, or D is not a reference type andE is
implicitly convertible toD.
20 Preconditions: If E is not a reference type, construction of the deleter from an rvalue of typeE is
well-formed and does not throw an exception. Otherwise,E is a reference type and construction of the
deleter from an lvalue of typeE is well-formed and does not throw an exception.
21 Effects: Constructs aunique_ptr from u. If E is a reference type, this deleter is copy constructed from
u’s deleter; otherwise, this deleter is move constructed fromu’s deleter.
[Note 2: The deleter constructor can be implemented withstd::forward<E>. —end note]
22 Postconditions: get() yields the valueu.get() yielded before the construction.u.get() == nullptr.
get_deleter() returns a reference to the stored deleter that was constructed fromu.get_deleter().
20.3.1.3.3 Destructor [unique.ptr.single.dtor]
constexpr ~unique_ptr();
1 Effects: Equivalent to:if (get()) get_deleter()(get());
[Note 1: The use ofdefault_delete requires T to be a complete type.—end note]
2 Remarks: The behavior is undefined if the evaluation ofget_deleter()(get()) throws an exception.
20.3.1.3.4 Assignment [unique.ptr.single.asgn]
constexpr unique_ptr& operator=(unique_ptr&& u) noexcept;
1 Constraints: is_move_assignable_v<D> is true.
2 Preconditions: If D is not a reference type,D meets theCpp17MoveAssignable requirements (Table 33)
and assignment of the deleter from an rvalue of typeD does not throw an exception. Otherwise,D is a
reference type;remove_reference_t<D> meets theCpp17CopyAssignable requirements and assignment
of the deleter from an lvalue of typeD does not throw an exception.
3 Effects: Calls reset(u.release()) followed by get_deleter() = std::forward<D>(u.get_dele-
ter()).
4 Postconditions: If this != addressof(u), u.get() == nullptr, otherwiseu.get() is unchanged.
5 Returns: *this.
template<class U, class E> constexpr unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
6 Constraints:
—(6.1) unique_ptr<U, E>::pointer is implicitly convertible topointer, and
§ 20.3.1.3.4 © ISO/IEC
683

===== PAGE 695 =====

Dxxxx
—(6.2) U is not an array type, and
—(6.3) is_assignable_v<D&, E&&> is true.
7 Preconditions: If E is not a reference type, assignment of the deleter from an rvalue of typeE is
well-formed and does not throw an exception. Otherwise,E is a reference type and assignment of the
deleter from an lvalue of typeE is well-formed and does not throw an exception.
8 Effects: Calls reset(u.release()) followed by get_deleter() = std::forward<E>(u.get_dele-
ter()).
9 Postconditions: u.get() == nullptr.
10 Returns: *this.
constexpr unique_ptr& operator=(nullptr_t) noexcept;
11 Effects: As if byreset().
12 Postconditions: get() == nullptr.
13 Returns: *this.
20.3.1.3.5 Observers [unique.ptr.single.observers]
constexpr add_lvalue_reference_t<T> operator*() const noexcept(noexcept(*declval<pointer>()));
1 Mandates: reference_converts_from_temporary_v<add_lvalue_reference_t<T>, decltype(
*declval<pointer>())> is false.
2 Preconditions: get() != nullptr is true.
3 Returns: *get().
constexpr pointer operator->() const noexcept;
4 Preconditions: get() != nullptr.
5 Returns: get().
6 [Note 1: The use of this function typically requires thatT be a complete type.—end note]
constexpr pointer get() const noexcept;
7 Returns: The stored pointer.
constexpr deleter_type& get_deleter() noexcept;
constexpr const deleter_type& get_deleter() const noexcept;
8 Returns: A reference to the stored deleter.
constexpr explicit operator bool() const noexcept;
9 Returns: get() != nullptr.
20.3.1.3.6 Modifiers [unique.ptr.single.modifiers]
constexpr pointer release() noexcept;
1 Postconditions: get() == nullptr.
2 Returns: The valueget() had at the start of the call torelease.
constexpr void reset(pointer p = pointer()) noexcept;
3 Effects: Assigns p to the stored pointer, and then, with the old value of the stored pointer,old_p,
evaluates if (old_p) get_deleter()(old_p);
[Note 1: The order of these operations is significant because the call toget_deleter() might destroy*this.
—end note]
4 Postconditions: get() == p.
[Note 2: The postcondition does not hold if the call toget_deleter() destroys *this since this->get() is no
longer a valid expression.—end note]
5 Remarks: The behavior is undefined if the evaluation ofget_deleter()(old_p) throws an exception.
§ 20.3.1.3.6 © ISO/IEC
684

===== PAGE 696 =====

Dxxxx
constexpr void swap(unique_ptr& u) noexcept;
6 Preconditions: get_deleter() is swappable (16.4.4.3) and does not throw an exception underswap.
7 Effects: Invokesswap on the stored pointers and on the stored deleters of*this and u.
20.3.1.4 unique_ptr for array objects with a runtime length [unique.ptr.runtime]
20.3.1.4.1 General [unique.ptr.runtime.general]
namespace std {
template<class T, class D> class unique_ptr<T[], D> {
public:
using pointer = see below ;
using element_type = T;
using deleter_type = D;
// 20.3.1.4.2, constructors
constexpr unique_ptr() noexcept;
template<class U> constexpr explicit unique_ptr(U p) noexcept;
template<class U> constexpr unique_ptr(U p, see below d) noexcept;
template<class U> constexpr unique_ptr(U p, see below d) noexcept;
constexpr unique_ptr(unique_ptr&& u) noexcept;
template<class U, class E>
constexpr unique_ptr(unique_ptr<U, E>&& u) noexcept;
constexpr unique_ptr(nullptr_t) noexcept;
// destructor
constexpr ~unique_ptr();
// assignment
constexpr unique_ptr& operator=(unique_ptr&& u) noexcept;
template<class U, class E>
constexpr unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
constexpr unique_ptr& operator=(nullptr_t) noexcept;
// 20.3.1.4.4, observers
constexpr T& operator[](size_t i) const;
constexpr pointer get() const noexcept;
constexpr deleter_type& get_deleter() noexcept;
constexpr const deleter_type& get_deleter() const noexcept;
constexpr explicit operator bool() const noexcept;
// 20.3.1.4.5, modifiers
constexpr pointer release() noexcept;
template<class U> constexpr void reset(U p) noexcept;
constexpr void reset(nullptr_t = nullptr) noexcept;
constexpr void swap(unique_ptr& u) noexcept;
// disable copy from lvalue
unique_ptr(const unique_ptr&) = delete;
unique_ptr& operator=(const unique_ptr&) = delete;
};
}
1 A specialization for array types is provided with a slightly altered interface.
—(1.1) Conversions between different types ofunique_ptr<T[], D> that would be disallowed for the cor-
responding pointer-to-array types, and conversions to or from the non-array forms ofunique_ptr,
produce an ill-formed program.
—(1.2) Pointers to types derived fromT are rejected by the constructors, and byreset.
—(1.3) The observersoperator* and operator-> are not provided.
—(1.4) The indexing observeroperator[] is provided.
—(1.5) The default deleter will calldelete[].
§ 20.3.1.4.1 © ISO/IEC
685

===== PAGE 697 =====

Dxxxx
2 Descriptions are provided below only for members that differ from the primary template.
3 The template argumentT shall be a complete type.
20.3.1.4.2 Constructors [unique.ptr.runtime.ctor]
template<class U> constexpr explicit unique_ptr(U p) noexcept;
1 This constructor behaves the same as the constructor in the primary template that takes a single
parameter of typepointer.
2 Constraints:
—(2.1) U is the same type aspointer, or
—(2.2) pointer is the same type aselement_type*, U is a pointer typeV*, andV(*)[] is convertible to
element_type(*)[].
template<class U> constexpr unique_ptr(U p, see below d) noexcept;
template<class U> constexpr unique_ptr(U p, see below d) noexcept;
3 These constructors behave the same as the constructors in the primary template that take a parameter
of typepointer and a second parameter.
4 Constraints:
—(4.1) U is the same type aspointer,
—(4.2) U is nullptr_t, or
—(4.3) pointer is the same type aselement_type*, U is a pointer typeV*, andV(*)[] is convertible to
element_type(*)[].
template<class U, class E> constexpr unique_ptr(unique_ptr<U, E>&& u) noexcept;
5 This constructor behaves the same as in the primary template.
6 Constraints: Where UP is unique_ptr<U, E>:
—(6.1) U is an array type, and
—(6.2) pointer is the same type aselement_type*, and
—(6.3) UP::pointer is the same type asUP::element_type*, and
—(6.4) UP::element_type(*)[] is convertible toelement_type(*)[], and
—(6.5) either D is a reference type andE is the same type asD, or D is not a reference type andE is
implicitly convertible toD.
[Note 1: This replaces theConstraints: specification of the primary template.—end note]
20.3.1.4.3 Assignment [unique.ptr.runtime.asgn]
template<class U, class E> constexpr unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
1 This operator behaves the same as in the primary template.
2 Constraints: Where UP is unique_ptr<U, E>:
—(2.1) U is an array type, and
—(2.2) pointer is the same type aselement_type*, and
—(2.3) UP::pointer is the same type asUP::element_type*, and
—(2.4) UP::element_type(*)[] is convertible toelement_type(*)[], and
—(2.5) is_assignable_v<D&, E&&> is true.
[Note 1: This replaces theConstraints: specification of the primary template.—end note]
20.3.1.4.4 Observers [unique.ptr.runtime.observers]
constexpr T& operator[](size_t i) const;
1 Preconditions: i < the number of elements in the array to which the stored pointer points.
2 Returns: get()[i].
§ 20.3.1.4.4 © ISO/IEC
686

===== PAGE 698 =====

Dxxxx
20.3.1.4.5 Modifiers [unique.ptr.runtime.modifiers]
constexpr void reset(nullptr_t p = nullptr) noexcept;
1 Effects: Equivalent toreset(pointer()).
template<class U> constexpr void reset(U p) noexcept;
2 This function behaves the same as thereset member of the primary template.
3 Constraints:
—(3.1) U is the same type aspointer, or
—(3.2) pointer is the same type aselement_type*, U is a pointer typeV*, andV(*)[] is convertible to
element_type(*)[].
20.3.1.5 Creation [unique.ptr.create]
template<class T, class... Args> constexpr unique_ptr<T> make_unique(Args&&... args);
1 Constraints: T is not an array type.
2 Returns: unique_ptr<T>(new T(std::forward<Args>(args)...)).
template<class T> constexpr unique_ptr<T> make_unique(size_t n);
3 Constraints: T is an array of unknown bound.
4 Returns: unique_ptr<T>(new remove_extent_t<T>[n]()).
template<class T, class... Args> unspecified make_unique(Args&&...) = delete;
5 Constraints: T is an array of known bound.
template<class T> constexpr unique_ptr<T> make_unique_for_overwrite();
6 Constraints: T is not an array type.
7 Returns: unique_ptr<T>(new T).
template<class T> constexpr unique_ptr<T> make_unique_for_overwrite(size_t n);
8 Constraints: T is an array of unknown bound.
9 Returns: unique_ptr<T>(new remove_extent_t<T>[n]).
template<class T, class... Args> unspecified make_unique_for_overwrite(Args&&...) = delete;
10 Constraints: T is an array of known bound.
20.3.1.6 Specialized algorithms [unique.ptr.special]
template<class T, class D> constexpr void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
1 Constraints: is_swappable_v<D> is true.
2 Effects: Calls x.swap(y).
template<class T1, class D1, class T2, class D2>
constexpr bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
3 Returns: x.get() == y.get().
template<class T1, class D1, class T2, class D2>
constexpr bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
4 Let CT denote
common_type_t<typename unique_ptr<T1, D1>::pointer,
typename unique_ptr<T2, D2>::pointer>
5 Mandates:
—(5.1) unique_ptr<T1, D1>::pointer is implicitly convertible toCT and
—(5.2) unique_ptr<T2, D2>::pointer is implicitly convertible toCT.
§ 20.3.1.6 © ISO/IEC
687

===== PAGE 699 =====

Dxxxx
6 Preconditions: The specializationless<CT> is a function object type (22.10) that induces a strict weak
ordering (26.8) on the pointer values.
7 Returns: less<CT>()(x.get(), y.get()).
template<class T1, class D1, class T2, class D2>
constexpr bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
8 Returns: y < x.
template<class T1, class D1, class T2, class D2>
constexpr bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
9 Returns: !(y < x).
template<class T1, class D1, class T2, class D2>
constexpr bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
10 Returns: !(x < y).
template<class T1, class D1, class T2, class D2>
requires three_way_comparable_with<typename unique_ptr<T1, D1>::pointer,
typename unique_ptr<T2, D2>::pointer>
constexpr compare_three_way_result_t<typename unique_ptr<T1, D1>::pointer,
typename unique_ptr<T2, D2>::pointer>
operator<=>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
11 Returns: compare_three_way()(x.get(), y.get()).
template<class T, class D>
constexpr bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
12 Returns: !x.
template<class T, class D>
constexpr bool operator<(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
constexpr bool operator<(nullptr_t, const unique_ptr<T, D>& x);
13 Preconditions: The specializationless<unique_ptr<T, D>::pointer> is a function object type (22.10)
that induces a strict weak ordering (26.8) on the pointer values.
14 Returns: The first function template returns
less<unique_ptr<T, D>::pointer>()(x.get(), nullptr)
The second function template returns
less<unique_ptr<T, D>::pointer>()(nullptr, x.get())
template<class T, class D>
constexpr bool operator>(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
constexpr bool operator>(nullptr_t, const unique_ptr<T, D>& x);
15 Returns: The first function template returnsnullptr < x. The second function template returnsx <
nullptr.
template<class T, class D>
constexpr bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
constexpr bool operator<=(nullptr_t, const unique_ptr<T, D>& x);
16 Returns: The first function template returns!(nullptr < x). The second function template returns
!(x < nullptr).
template<class T, class D>
constexpr bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
template<class T, class D>
constexpr bool operator>=(nullptr_t, const unique_ptr<T, D>& x);
17 Returns: The first function template returns!(x < nullptr). The second function template returns
!(nullptr < x).
§ 20.3.1.6 © ISO/IEC
688

===== PAGE 700 =====

Dxxxx
template<class T, class D>
requires three_way_comparable<typename unique_ptr<T, D>::pointer>
constexpr compare_three_way_result_t<typename unique_ptr<T, D>::pointer>
operator<=>(const unique_ptr<T, D>& x, nullptr_t);
18 Returns:
compare_three_way()(x.get(), static_cast<typename unique_ptr<T, D>::pointer>(nullptr)).
20.3.1.7 I/O [unique.ptr.io]
template<class E, class T, class Y, class D>
basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const unique_ptr<Y, D>& p);
1 Constraints: os << p.get() is a valid expression.
2 Effects: Equivalent to:os << p.get();
3 Returns: os.
20.3.2 Shared-ownership pointers [util.sharedptr]
20.3.2.1 Class bad_weak_ptr [util.smartptr.weak.bad]
namespace std {
class bad_weak_ptr : public exception {
public:
// see 17.9.3 for the specification of the special member functions
constexpr const char* what() const noexcept override;
};
}
1 An exception of typebad_weak_ptr is thrown by theshared_ptr constructor taking aweak_ptr.
constexpr const char* what() const noexcept override;
2 Returns: An implementation-definedntbs.
20.3.2.2 Class template shared_ptr [util.smartptr.shared]
20.3.2.2.1 General [util.smartptr.shared.general]
1 The shared_ptr class template stores a pointer, usually obtained vianew. shared_ptr implements semantics
of shared ownership; the last remaining owner of the pointer is responsible for destroying the object, or
otherwise releasing the resources associated with the stored pointer. Ashared_ptr is said to be empty if it
does not own a pointer.
namespace std {
template<class T> class shared_ptr {
public:
using element_type = remove_extent_t<T>;
using weak_type = weak_ptr<T>;
// 20.3.2.2.2, constructors
constexpr shared_ptr() noexcept;
constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
template<class Y>
constexpr explicit shared_ptr(Y* p);
template<class Y, class D>
constexpr shared_ptr(Y* p, D d);
template<class Y, class D, class A>
constexpr shared_ptr(Y* p, D d, A a);
template<class D>
constexpr shared_ptr(nullptr_t p, D d);
template<class D, class A>
constexpr shared_ptr(nullptr_t p, D d, A a);
template<class Y>
constexpr shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
template<class Y>
constexpr shared_ptr(shared_ptr<Y>&& r, element_type* p) noexcept;
constexpr shared_ptr(const shared_ptr& r) noexcept;
§ 20.3.2.2.1 © ISO/IEC
689

===== PAGE 701 =====

Dxxxx
template<class Y>
constexpr shared_ptr(const shared_ptr<Y>& r) noexcept;
constexpr shared_ptr(shared_ptr&& r) noexcept;
template<class Y>
constexpr shared_ptr(shared_ptr<Y>&& r) noexcept;
template<class Y>
constexpr explicit shared_ptr(const weak_ptr<Y>& r);
template<class Y, class D>
constexpr shared_ptr(unique_ptr<Y, D>&& r);
// 20.3.2.2.3, destructor
constexpr ~shared_ptr();
// 20.3.2.2.4, assignment
constexpr shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y>
constexpr shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
constexpr shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y>
constexpr shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
template<class Y, class D>
constexpr shared_ptr& operator=(unique_ptr<Y, D>&& r);
// 20.3.2.2.5, modifiers
constexpr void swap(shared_ptr& r) noexcept;
constexpr void reset() noexcept;
template<class Y>
constexpr void reset(Y* p);
template<class Y, class D>
constexpr void reset(Y* p, D d);
template<class Y, class D, class A>
constexpr void reset(Y* p, D d, A a);
// 20.3.2.2.6, observers
constexpr element_type* get() const noexcept;
constexpr T& operator*() const noexcept;
constexpr T* operator->() const noexcept;
constexpr element_type& operator[](ptrdiff_t i) const;
constexpr long use_count() const noexcept;
constexpr explicit operator bool() const noexcept;
template<class U>
constexpr bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U>
constexpr bool owner_before(const weak_ptr<U>& b) const noexcept;
size_t owner_hash() const noexcept;
template<class U>
constexpr bool owner_equal(const shared_ptr<U>& b) const noexcept;
template<class U>
constexpr bool owner_equal(const weak_ptr<U>& b) const noexcept;
};
template<class T>
shared_ptr(weak_ptr<T>) -> shared_ptr<T>;
template<class T, class D>
shared_ptr(unique_ptr<T, D>) -> shared_ptr<T>;
}
2 Specializations of shared_ptr shall beCpp17CopyConstructible, Cpp17CopyAssignable, andCpp17LessThan-
Comparable, allowing their use in standard containers. Specializations ofshared_ptr shall be contextually
convertible tobool, allowing their use in boolean expressions and declarations in conditions.
3 The template parameterT of shared_ptr may be an incomplete type.
[Note 1: T can be a function type.—end note]
§ 20.3.2.2.1 © ISO/IEC
690

===== PAGE 702 =====

Dxxxx
4 [Example 1:
if (shared_ptr<X> px = dynamic_pointer_cast<X>(py)) {
// do something withpx
}
—end example]
5 For purposes of determining the presence of a data race, member functions shall access and modify only the
shared_ptr and weak_ptr objects themselves and not objects they refer to. Changes inuse_count() do
not reflect modifications that can introduce data races.
6 For the purposes of 20.3, a pointer typeY* is said to becompatible witha pointer typeT* when eitherY* is
convertible toT* or Y is U[N] and T is cv U[].
20.3.2.2.2 Constructors [util.smartptr.shared.const]
1 In the constructor definitions below, enablesshared_from_this with p, for a pointerp of typeY*, means
that if Y has an unambiguous and accessible base class that is a specialization ofenable_shared_from_-
this (20.3.2.7), thenremove_cv_t<Y>* shall be implicitly convertible toT* and the constructor evaluates
the statement:
if (p != nullptr && p->weak-this .expired())
p->weak-this = shared_ptr<remove_cv_t<Y>>(*this, const_cast<remove_cv_t<Y>*>(p));
The assignment to theweak-this member is not atomic and conflicts with any potentially concurrent access
to the same object (6.10.2).
constexpr shared_ptr() noexcept;
2 Postconditions: use_count() == 0 && get() == nullptr.
template<class Y> constexpr explicit shared_ptr(Y* p);
3 Constraints: When T is an array type, the expressiondelete[] p is well-formed and eitherT is U[N]
and Y(*)[N] is convertible toT*, orT is U[] and Y(*)[] is convertible toT*. When T is not an array
type, the expressiondelete p is well-formed andY* is convertible toT*.
4 Mandates: Y is a complete type.
5 Preconditions: The expressiondelete[] p, whenT is an array type, ordelete p, whenT is not an
array type, has well-defined behavior, and does not throw exceptions.
6 Effects: WhenTis not an array type, constructs ashared_ptrobject that owns the pointerp. Otherwise,
constructs ashared_ptr that ownsp and a deleter of an unspecified type that callsdelete[] p. When
T is not an array type, enablesshared_from_this with p. If an exception is thrown,delete p is called
when T is not an array type,delete[] p otherwise.
7 Postconditions: use_count() == 1 && get() == p.
8 Throws: bad_alloc, or an implementation-defined exception when a resource other than memory
cannot be obtained.
template<class Y, class D> constexpr shared_ptr(Y* p, D d);
template<class Y, class D, class A> constexpr shared_ptr(Y* p, D d, A a);
template<class D> constexpr shared_ptr(nullptr_t p, D d);
template<class D, class A> constexpr shared_ptr(nullptr_t p, D d, A a);
9 Constraints: is_move_constructible_v<D> is true, andd(p) is a well-formed expression. For the
first two overloads:
—(9.1) If T is an array type, then eitherT is U[N] and Y(*)[N] is convertible toT*, or T is U[] and
Y(*)[] is convertible toT*.
—(9.2) If T is not an array type, thenY* is convertible toT*.
10 Preconditions: Construction ofd and a deleter of typeD initialized withstd::move(d) do not throw
exceptions. The expressiond(p) has well-defined behavior and does not throw exceptions.A meets the
Cpp17Allocator requirements (16.4.4.6.1).
11 Effects: Constructs ashared_ptr object that owns the objectp and the deleterd. When T is not an
array type, the first and second constructors enableshared_from_this with p. The second and fourth
§ 20.3.2.2.2 © ISO/IEC
691

===== PAGE 703 =====

Dxxxx
constructors shall use a copy ofa to allocate memory for internal use. If an exception is thrown,d(p)
is called.
12 Postconditions: use_count() == 1 && get() == p.
13 Throws: bad_alloc, or an implementation-defined exception when a resource other than memory
cannot be obtained.
template<class Y> constexpr shared_ptr(const shared_ptr<Y>& r, element_type* p) noexcept;
template<class Y> constexpr shared_ptr(shared_ptr<Y>&& r, element_type* p) noexcept;
14 Effects: Constructs ashared_ptr instance that storesp and shares ownership with the initial value of
r.
15 Postconditions: get() == p. For the second overload,r is empty andr.get() == nullptr.
16 [Note 1: Use of this constructor leads to a dangling pointer unlessp remains valid at least until the ownership
group ofr is destroyed. —end note]
17 [Note 2: This constructor allows creation of an emptyshared_ptr instance with a non-null stored pointer.
—end note]
constexpr shared_ptr(const shared_ptr& r) noexcept;
template<class Y> constexpr shared_ptr(const shared_ptr<Y>& r) noexcept;
18 Constraints: For the second constructor,Y* is compatible withT*.
19 Effects: If r is empty, constructs an emptyshared_ptr object; otherwise, constructs ashared_ptr
object that shares ownership withr.
20 Postconditions: get() == r.get() && use_count() == r.use_count().
constexpr shared_ptr(shared_ptr&& r) noexcept;
template<class Y> constexpr shared_ptr(shared_ptr<Y>&& r) noexcept;
21 Constraints: For the second constructor,Y* is compatible withT*.
22 Effects: Move constructs ashared_ptr instance fromr.
23 Postconditions: *this contains the old value ofr. r is empty, andr.get() == nullptr.
template<class Y> constexpr explicit shared_ptr(const weak_ptr<Y>& r);
24 Constraints: Y* is compatible withT*.
25 Effects: Constructs ashared_ptr object that shares ownership withr and stores a copy of the pointer
stored inr. If an exception is thrown, the constructor has no effect.
26 Postconditions: use_count() == r.use_count().
27 Throws: bad_weak_ptr when r.expired().
template<class Y, class D> constexpr shared_ptr(unique_ptr<Y, D>&& r);
28 Constraints: Y* is compatible withT* and unique_ptr<Y, D>::pointer is convertible toelement_-
type*.
29 Effects: If r.get() == nullptr, equivalent toshared_ptr(). Otherwise, ifD is not a reference type,
equivalent toshared_ptr(r.release(), std::move(r.get_deleter())). Otherwise, equivalent to
shared_ptr(r.release(), ref(r.get_deleter())). If an exception is thrown, the constructor has
no effect.
20.3.2.2.3 Destructor [util.smartptr.shared.dest]
constexpr ~shared_ptr();
1 Effects:
—(1.1) If *this is empty or shares ownership with anothershared_ptr instance (use_count() > 1),
there are no side effects.
—(1.2) Otherwise, if*this owns an objectp and a deleterd, d(p) is called.
—(1.3) Otherwise, *this owns a pointerp, anddelete p is called.
§ 20.3.2.2.3 © ISO/IEC
692

===== PAGE 704 =====

Dxxxx
2 [Note 1: Since the destruction of*this decreases the number of instances that share ownership with*this by one,
after *this has been destroyed allshared_ptr instances that shared ownership with*this will report ause_count()
that is one less than its previous value.—end note]
20.3.2.2.4 Assignment [util.smartptr.shared.assign]
constexpr shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> constexpr shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
1 Effects: Equivalent toshared_ptr(r).swap(*this).
2 Returns: *this.
3 [Note 1: The use count updates caused by the temporary object construction and destruction are not observable
side effects, so the implementation can meet the effects (and the implied guarantees) via different means, without
creating a temporary. In particular, in the example:
shared_ptr<int> p(new int);
shared_ptr<void> q(p);
p = p;
q = p;
both assignments can be no-ops.—end note]
constexpr shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> constexpr shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
4 Effects: Equivalent toshared_ptr(std::move(r)).swap(*this).
5 Returns: *this.
template<class Y, class D> constexpr shared_ptr& operator=(unique_ptr<Y, D>&& r);
6 Effects: Equivalent toshared_ptr(std::move(r)).swap(*this).
7 Returns: *this.
20.3.2.2.5 Modifiers [util.smartptr.shared.mod]
constexpr void swap(shared_ptr& r) noexcept;
1 Effects: Exchanges the contents of*this and r.
constexpr void reset() noexcept;
2 Effects: Equivalent toshared_ptr().swap(*this).
template<class Y> constexpr void reset(Y* p);
3 Effects: Equivalent toshared_ptr(p).swap(*this).
template<class Y, class D> constexpr void reset(Y* p, D d);
4 Effects: Equivalent toshared_ptr(p, d).swap(*this).
template<class Y, class D, class A> constexpr void reset(Y* p, D d, A a);
5 Effects: Equivalent toshared_ptr(p, d, a).swap(*this).
20.3.2.2.6 Observers [util.smartptr.shared.obs]
constexpr element_type* get() const noexcept;
1 Returns: The stored pointer.
constexpr T& operator*() const noexcept;
2 Preconditions: get() != nullptr.
3 Returns: *get().
4 Remarks: When T is an array type orcv void, it is unspecified whether this member function is
declared. If it is declared, it is unspecified what its return type is, except that the declaration (although
not necessarily the definition) of the function shall be well-formed.
§ 20.3.2.2.6 © ISO/IEC
693

===== PAGE 705 =====

Dxxxx
constexpr T* operator->() const noexcept;
5 Preconditions: get() != nullptr.
6 Returns: get().
7 Remarks: When T is an array type, it is unspecified whether this member function is declared. If it is
declared, it is unspecified what its return type is, except that the declaration (although not necessarily
the definition) of the function shall be well-formed.
constexpr element_type& operator[](ptrdiff_t i) const;
8 Preconditions: get() != nullptr is true.
9 Hardened preconditions: i ≥0. If T is U[N], i <N.
10 Returns: get()[i].
11 Throws: Nothing.
12 Remarks: When T is not an array type, it is unspecified whether this member function is declared.
If it is declared, it is unspecified what its return type is, except that the declaration (although not
necessarily the definition) of the function shall be well-formed.
constexpr long use_count() const noexcept;
13 Synchronization: None.
14 Returns: The number ofshared_ptr objects, *this included, that share ownership with*this, or0
when *this is empty.
15 [Note 1: get() == nullptr does not imply a specific return value ofuse_count(). —end note]
16 [Note 2: weak_ptr<T>::lock() can affect the return value ofuse_count(). —end note]
17 [Note 3: When multiple threads might affect the return value ofuse_count(), the result is approximate. In
particular, use_count() == 1 does not imply that accesses through a previously destroyedshared_ptr have in
any sense completed. —end note]
constexpr explicit operator bool() const noexcept;
18 Returns: get() != nullptr.
template<class U> constexpr bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> constexpr bool owner_before(const weak_ptr<U>& b) const noexcept;
19 Returns: An unspecified value such that
—(19.1) owner_before(b) defines a strict weak ordering as defined in 26.8;
—(19.2) !owner_before(b) && !b.owner_before(*this) is true if and only ifowner_equal(b) is true.
size_t owner_hash() const noexcept;
20 Returns: An unspecified value such that, for any objectxwhere owner_equal(x)is true, owner_hash()
== x.owner_hash() is true.
template<class U>
constexpr bool owner_equal(const shared_ptr<U>& b) const noexcept;
template<class U>
constexpr bool owner_equal(const weak_ptr<U>& b) const noexcept;
21 Returns: true if and only if*this and b share ownership or are both empty. Otherwise returnsfalse.
22 Remarks: owner_equal is an equivalence relation.
20.3.2.2.7 Creation [util.smartptr.shared.create]
1 The common requirements that apply to allmake_shared, allocate_shared, make_shared_for_overwrite,
and allocate_shared_for_overwrite overloads, unless specified otherwise, are described below.
template<class T, ...>
constexpr shared_ptr<T> make_shared(args);
template<class T, class A, ...>
constexpr shared_ptr<T> allocate_shared(const A& a, args);
§ 20.3.2.2.7 © ISO/IEC
694

===== PAGE 706 =====

Dxxxx
template<class T, ...>
constexpr shared_ptr<T> make_shared_for_overwrite(args);
template<class T, class A, ...>
constexpr shared_ptr<T> allocate_shared_for_overwrite(const A& a, args);
2 Preconditions: A meets theCpp17Allocator requirements (16.4.4.6.1).
3 Effects: Allocates memory for an object of typeT (or U[N] when T is U[], where N is determined
from args as specified by the concrete overload). The object is initialized fromargs as specified by
the concrete overload. Theallocate_shared and allocate_shared_for_overwrite templates use a
copy ofa (rebound for an unspecifiedvalue_type) to allocate memory. If an exception is thrown, the
functions have no effect.
4 Postconditions: r.get() != nullptr && r.use_count() == 1, wherer is the return value.
5 Returns: A shared_ptr instance that stores and owns the address of the newly constructed object.
6 Throws: bad_alloc, or an exception thrown fromallocate or from the initialization of the object.
7 Remarks:
—(7.1) Implementations should perform no more than one memory allocation.
[Note 1: This provides efficiency equivalent to an intrusive smart pointer.—end note]
—(7.2) When an object of an array typeU is specified to have an initial value ofu (of the same type),
this shall be interpreted to mean that each array element of the object has as its initial value the
corresponding element fromu.
—(7.3) When an object of an array type is specified to have a default initial value, this shall be interpreted
to mean that each array element of the object has a default initial value.
—(7.4) When a (sub)object of a non-array typeU is specified to have an initial value ofv, orU(l...),
where l... is a list of constructor arguments,make_shared shall initialize this (sub)object via the
expression ::new(pv) U(v) or ::new(pv) U(l...) respectively, wherepv has typevoid* and
points to storage suitable to hold an object of typeU.
—(7.5) When a (sub)object of a non-array typeU is specified to have an initial value ofv, orU(l...),
where l... is a list of constructor arguments,allocate_shared shall initialize this (sub)object
via the expression
—(7.5.1) allocator_traits<A2>::construct(a2, pu, v) or
—(7.5.2) allocator_traits<A2>::construct(a2, pu, l...)
respectively, wherepu is a pointer of typeremove_cv_t<U>* pointing to storage suitable to hold
an object of typeremove_cv_t<U> and a2 of typeA2 is a potentially rebound copy of the allocator
a passed toallocate_shared.
—(7.6) When a (sub)object of non-array typeU is specified to have a default initial value,make_shared
shall initialize this (sub)object via the expression::new(pv) U(), wherepv has typevoid* and
points to storage suitable to hold an object of typeU.
—(7.7) When a (sub)object of non-array typeU is specified to have a default initial value,allocate_-
shared initializes this (sub)object via the expressionallocator_traits<A2>::construct(a2,
pu), wherepu is a pointer of typeremove_cv_t<U>* pointing to storage suitable to hold an object
of typeremove_cv_t<U> and a2 of typeA2 is a potentially rebound copy of the allocatora passed
to allocate_shared.
—(7.8) When a (sub)object of non-array type U is initialized by make_shared_for_overwrite or
allocate_shared_for_overwrite, it is initialized via the expression::new(pv) U, where pv
has typevoid* and points to storage suitable to hold an object of typeU.
—(7.9) Array elements are initialized in ascending order of their addresses.
—(7.10) When the lifetime of the object managed by the return value ends, or when the initialization of an
array element throws an exception, the initialized elements are destroyed in the reverse order of
their original construction.
—(7.11) When a (sub)object of non-array typeU that was initialized bymake_shared, make_shared_-
for_overwrite, orallocate_shared_for_overwrite is to be destroyed, it is destroyed via the
expression pu->~U() where pu points to that object of typeU.
§ 20.3.2.2.7 © ISO/IEC
695

===== PAGE 707 =====

Dxxxx
—(7.12) When a (sub)object of non-array typeUthat was initialized byallocate_sharedis to be destroyed,
it is destroyed via the expressionallocator_traits<A2>::destroy(a2, pu)wherepuis a pointer
of typeremove_cv_t<U>* pointing to that object of typeremove_cv_t<U> and a2 of typeA2 is a
potentially rebound copy of the allocatora passed toallocate_shared.
[Note 2: These functions will typically allocate more memory thansizeof(T) to allow for internal bookkeeping
structures such as reference counts.—end note]
template<class T, class... Args>
constexpr shared_ptr<T> make_shared(Args&&... args); // T is not array
template<class T, class A, class... Args>
constexpr shared_ptr<T> allocate_shared(const A& a, Args&&... args); // T is not array
8 Constraints: T is not an array type.
9 Returns: Ashared_ptr to an object of typeT with an initial valueT(std::forward<Args>(args)...).
10 Remarks: The shared_ptr constructors called by these functions enableshared_from_this with the
address of the newly constructed object of typeT.
11 [Example 1:
shared_ptr<int> p = make_shared<int>(); // shared_ptr to int()
shared_ptr<vector<int>> q = make_shared<vector<int>>(16, 1);
// shared_ptr to vector of16 elements with value1
—end example]
template<class T>
constexpr shared_ptr<T> make_shared(size_t N); // T is U[]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a, size_t N); // T is U[]
12 Constraints: T is an array of unknown bound.
13 Returns: A shared_ptr to an array ofN elements of typeremove_extent_t<T> with a default initial
value.
14 [Example 2:
shared_ptr<double[]> p = make_shared<double[]>(1024);
// shared_ptr to a value-initializeddouble[1024]
shared_ptr<double[][2][2]> q = make_shared<double[][2][2]>(6);
// shared_ptr to a value-initializeddouble[6][2][2]
—end example]
template<class T>
constexpr shared_ptr<T> make_shared(); // T is U[N]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a); // T is U[N]
15 Constraints: T is an array of known bound.
16 Returns: A shared_ptr to an object of typeT with a default initial value.
17 [Example 3:
shared_ptr<double[1024]> p = make_shared<double[1024]>();
// shared_ptr to a value-initializeddouble[1024]
shared_ptr<double[6][2][2]> q = make_shared<double[6][2][2]>();
// shared_ptr to a value-initializeddouble[6][2][2]
—end example]
template<class T>
constexpr shared_ptr<T> make_shared(size_t N,
const remove_extent_t<T>& u); // T is U[]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a, size_t N,
const remove_extent_t<T>& u); // T is U[]
18 Constraints: T is an array of unknown bound.
§ 20.3.2.2.7 © ISO/IEC
696

===== PAGE 708 =====

Dxxxx
19 Returns: A shared_ptr to an array ofN elements of typeremove_extent_t<T> where each array
element has an initial value ofu.
20 [Example 4:
shared_ptr<double[]> p = make_shared<double[]>(1024, 1.0);
// shared_ptr to adouble[1024], where each element is1.0
shared_ptr<double[][2]> q = make_shared<double[][2]>(6, {1.0, 0.0});
// shared_ptr to adouble[6][2], where eachdouble[2] element is{1.0, 0.0}
shared_ptr<vector<int>[]> r = make_shared<vector<int>[]>(4, {1, 2});
// shared_ptr to avector<int>[4], where each vector has contents{1, 2}
—end example]
template<class T>
constexpr shared_ptr<T> make_shared(const remove_extent_t<T>& u); // T is U[N]
template<class T, class A>
constexpr shared_ptr<T> allocate_shared(const A& a,
const remove_extent_t<T>& u); // T is U[N]
21 Constraints: T is an array of known bound.
22 Returns: A shared_ptr to an object of typeT, where each array element of typeremove_extent_t<T>
has an initial value ofu.
23 [Example 5:
shared_ptr<double[1024]> p = make_shared<double[1024]>(1.0);
// shared_ptr to adouble[1024], where each element is1.0
shared_ptr<double[6][2]> q = make_shared<double[6][2]>({1.0, 0.0});
// shared_ptr to adouble[6][2], where each double[2] element is{1.0, 0.0}
shared_ptr<vector<int>[4]> r = make_shared<vector<int>[4]>({1, 2});
// shared_ptr to avector<int>[4], where each vector has contents{1, 2}
—end example]
template<class T>
constexpr shared_ptr<T> make_shared_for_overwrite();
template<class T, class A>
constexpr shared_ptr<T> allocate_shared_for_overwrite(const A& a);
24 Constraints: T is not an array of unknown bound.
25 Returns: A shared_ptr to an object of typeT.
26 [Example 6:
struct X { double data[1024]; };
shared_ptr<X> p = make_shared_for_overwrite<X>();
// shared_ptr to a default-initializedX, where each element inX::data has an indeterminate value
shared_ptr<double[1024]> q = make_shared_for_overwrite<double[1024]>();
// shared_ptr to a default-initializeddouble[1024], where each element has an indeterminate value
—end example]
template<class T>
constexpr shared_ptr<T> make_shared_for_overwrite(size_t N);
template<class T, class A>
constexpr shared_ptr<T> allocate_shared_for_overwrite(const A& a, size_t N);
27 Constraints: T is an array of unknown bound.
28 Returns: A shared_ptr to an array ofN elements of typeremove_extent_t<T>.
29 [Example 7:
shared_ptr<double[]> p = make_shared_for_overwrite<double[]>(1024);
// shared_ptr to a default-initializeddouble[1024], where each element has an indeterminate value
—end example]
§ 20.3.2.2.7 © ISO/IEC
697

===== PAGE 709 =====

Dxxxx
20.3.2.2.8 Comparison [util.smartptr.shared.cmp]
template<class T, class U>
constexpr bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
1 Returns: a.get() == b.get().
template<class T>
constexpr bool operator==(const shared_ptr<T>& a, nullptr_t) noexcept;
2 Returns: !a.
template<class T, class U>
constexpr strong_ordering operator<=>(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
3 Returns: compare_three_way()(a.get(), b.get()).
4 [Note 1: Defining a comparison operator function allowsshared_ptr objects to be used as keys in associative
containers. —end note]
template<class T>
constexpr strong_ordering operator<=>(const shared_ptr<T>& a, nullptr_t) noexcept;
5 Returns:
compare_three_way()(a.get(), static_cast<typename shared_ptr<T>::element_type*>(nullptr))
20.3.2.2.9 Specialized algorithms [util.smartptr.shared.spec]
template<class T>
constexpr void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
1 Effects: Equivalent toa.swap(b).
20.3.2.2.10 Casts [util.smartptr.shared.cast]
template<class T, class U>
constexpr shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
constexpr shared_ptr<T> static_pointer_cast(shared_ptr<U>&& r) noexcept;
1 Mandates: The expressionstatic_cast<T*>((U*)nullptr) is well-formed.
2 Returns:
shared_ptr<T>(R , static_cast<typename shared_ptr<T>::element_type*>(r.get()))
where R is r for the first overload, andstd::move(r) for the second.
3 [Note 1: The seemingly equivalent expression shared_ptr<T>(static_cast<T*>(r.get())) can result in
undefined behavior, attempting to delete the same object twice.—end note]
template<class T, class U>
constexpr shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
constexpr shared_ptr<T> dynamic_pointer_cast(shared_ptr<U>&& r) noexcept;
4 Mandates: The expressiondynamic_cast<T*>((U*)nullptr)is well-formed. The expressiondynamic_-
cast<typename shared_ptr<T>::element_type*>(r.get()) is well-formed.
5 Preconditions: Theexpression dynamic_cast<typename shared_ptr<T>::element_type*>(r.get())
has well-defined behavior.
6 Returns:
—(6.1) When dynamic_cast<typename shared_ptr<T>::element_type*>(r.get()) returns a non-null
value p, shared_ptr<T>(R, p), where R is r for the first overload, andstd::move(r) for the
second.
—(6.2) Otherwise, shared_ptr<T>().
7 [Note 2: The seemingly equivalent expression shared_ptr<T>(dynamic_cast<T*>(r.get())) can result in
undefined behavior, attempting to delete the same object twice.—end note]
§ 20.3.2.2.10 © ISO/IEC
698

===== PAGE 710 =====

Dxxxx
template<class T, class U>
constexpr shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
constexpr shared_ptr<T> const_pointer_cast(shared_ptr<U>&& r) noexcept;
8 Mandates: The expressionconst_cast<T*>((U*)nullptr) is well-formed.
9 Returns:
shared_ptr<T>(R , const_cast<typename shared_ptr<T>::element_type*>(r.get()))
where R is r for the first overload, andstd::move(r) for the second.
10 [Note 3: The seemingly equivalent expressionshared_ptr<T>(const_cast<T*>(r.get())) can result in unde-
fined behavior, attempting to delete the same object twice.—end note]
template<class T, class U>
shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
shared_ptr<T> reinterpret_pointer_cast(shared_ptr<U>&& r) noexcept;
11 Mandates: The expressionreinterpret_cast<T*>((U*)nullptr) is well-formed.
12 Returns:
shared_ptr<T>(R , reinterpret_cast<typename shared_ptr<T>::element_type*>(r.get()))
where R is r for the first overload, andstd::move(r) for the second.
13 [Note 4: The seemingly equivalent expressionshared_ptr<T>(reinterpret_cast<T*>(r.get())) can result in
undefined behavior, attempting to delete the same object twice.—end note]
20.3.2.2.11 get_deleter [util.smartptr.getdeleter]
template<class D, class T>
constexpr D* get_deleter(const shared_ptr<T>& p) noexcept;
1 Returns: If p owns a deleterd of type cv-unqualifiedD, returns addressof(d); otherwise returns
nullptr. The returned pointer remains valid as long as there exists ashared_ptr instance that owns
d.
[Note 1: It is unspecified whether the pointer remains valid longer than that. This can happen if the
implementation doesn’t destroy the deleter until allweak_ptr instances that share ownership withp have been
destroyed. —end note]
20.3.2.2.12 I/O [util.smartptr.shared.io]
template<class E, class T, class Y>
basic_ostream<E, T>& operator<<(basic_ostream<E, T>& os, const shared_ptr<Y>& p);
1 Effects: As if by:os << p.get();
2 Returns: os.
20.3.2.3 Class template weak_ptr [util.smartptr.weak]
20.3.2.3.1 General [util.smartptr.weak.general]
1 The weak_ptr class template stores a weak reference to an object that is already managed by ashared_ptr.
To access the object, aweak_ptr can be converted to ashared_ptr using the member functionlock.
namespace std {
template<class T> class weak_ptr {
public:
using element_type = remove_extent_t<T>;
// 20.3.2.3.2, constructors
constexpr weak_ptr() noexcept;
template<class Y>
constexpr weak_ptr(const shared_ptr<Y>& r) noexcept;
constexpr weak_ptr(const weak_ptr& r) noexcept;
template<class Y>
constexpr weak_ptr(const weak_ptr<Y>& r) noexcept;
constexpr weak_ptr(weak_ptr&& r) noexcept;
§ 20.3.2.3.1 © ISO/IEC
699

===== PAGE 711 =====

Dxxxx
template<class Y>
constexpr weak_ptr(weak_ptr<Y>&& r) noexcept;
// 20.3.2.3.3, destructor
constexpr ~weak_ptr();
// 20.3.2.3.4, assignment
constexpr weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y>
constexpr weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y>
constexpr weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
constexpr weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y>
constexpr weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
// 20.3.2.3.5, modifiers
constexpr void swap(weak_ptr& r) noexcept;
constexpr void reset() noexcept;
// 20.3.2.3.6, observers
constexpr long use_count() const noexcept;
constexpr bool expired() const noexcept;
constexpr shared_ptr<T> lock() const noexcept;
template<class U>
constexpr bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U>
constexpr bool owner_before(const weak_ptr<U>& b) const noexcept;
size_t owner_hash() const noexcept;
template<class U>
constexpr bool owner_equal(const shared_ptr<U>& b) const noexcept;
template<class U>
constexpr bool owner_equal(const weak_ptr<U>& b) const noexcept;
};
template<class T>
weak_ptr(shared_ptr<T>) -> weak_ptr<T>;
}
2 Specializations of weak_ptr shall beCpp17CopyConstructible and Cpp17CopyAssignable, allowing their use
in standard containers. The template parameterT of weak_ptr may be an incomplete type.
20.3.2.3.2 Constructors [util.smartptr.weak.const]
constexpr weak_ptr() noexcept;
1 Effects: Constructs an emptyweak_ptr object that stores a null pointer value.
2 Postconditions: use_count() == 0.
constexpr weak_ptr(const weak_ptr& r) noexcept;
template<class Y> constexpr weak_ptr(const weak_ptr<Y>& r) noexcept;
template<class Y> constexpr weak_ptr(const shared_ptr<Y>& r) noexcept;
3 Constraints: For the second and third constructors,Y* is compatible withT*.
4 Effects: If r is empty, constructs an emptyweak_ptr object that stores a null pointer value; otherwise,
constructs aweak_ptr object that shares ownership withr and stores a copy of the pointer stored inr.
5 Postconditions: use_count() == r.use_count().
constexpr weak_ptr(weak_ptr&& r) noexcept;
template<class Y> constexpr weak_ptr(weak_ptr<Y>&& r) noexcept;
6 Constraints: For the second constructor,Y* is compatible withT*.
7 Effects: Move constructs aweak_ptr instance fromr.
§ 20.3.2.3.2 © ISO/IEC
700

===== PAGE 712 =====

Dxxxx
8 Postconditions: *this contains the old value of r. r is empty, stores a null pointer value, and
r.use_count() == 0.
20.3.2.3.3 Destructor [util.smartptr.weak.dest]
constexpr ~weak_ptr();
1 Effects: Destroys thisweak_ptr object but has no effect on the object its stored pointer points to.
20.3.2.3.4 Assignment [util.smartptr.weak.assign]
constexpr weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y> constexpr weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y> constexpr weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
1 Effects: Equivalent toweak_ptr(r).swap(*this).
2 Returns: *this.
3 Remarks: The implementation may meet the effects (and the implied guarantees) via different means,
without creating a temporary object.
constexpr weak_ptr& operator=(weak_ptr&& r) noexcept;
template<class Y> constexpr weak_ptr& operator=(weak_ptr<Y>&& r) noexcept;
4 Effects: Equivalent toweak_ptr(std::move(r)).swap(*this).
5 Returns: *this.
20.3.2.3.5 Modifiers [util.smartptr.weak.mod]
constexpr void swap(weak_ptr& r) noexcept;
1 Effects: Exchanges the contents of*this and r.
constexpr void reset() noexcept;
2 Effects: Equivalent toweak_ptr().swap(*this).
20.3.2.3.6 Observers [util.smartptr.weak.obs]
constexpr long use_count() const noexcept;
1 Returns: 0 if *this is empty; otherwise, the number ofshared_ptr instances that share ownership
with *this.
constexpr bool expired() const noexcept;
2 Returns: use_count() == 0.
constexpr shared_ptr<T> lock() const noexcept;
3 Returns: expired() ? shared_ptr<T>() : shared_ptr<T>(*this), executed atomically.
template<class U> constexpr bool owner_before(const shared_ptr<U>& b) const noexcept;
template<class U> constexpr bool owner_before(const weak_ptr<U>& b) const noexcept;
4 Returns: An unspecified value such that
—(4.1) owner_before(b) defines a strict weak ordering as defined in 26.8;
—(4.2) !owner_before(b) && !b.owner_before(*this) is true if and only ifowner_equal(b) is true.
size_t owner_hash() const noexcept;
5 Returns: An unspecified value such that, for any objectxwhere owner_equal(x)is true, owner_hash()
== x.owner_hash() is true.
template<class U>
constexpr bool owner_equal(const shared_ptr<U>& b) const noexcept;
template<class U>
constexpr bool owner_equal(const weak_ptr<U>& b) const noexcept;
6 Returns: true if and only if*this and b share ownership or are both empty. Otherwise returnsfalse.
7 Remarks: owner_equal is an equivalence relation.
§ 20.3.2.3.6 © ISO/IEC
701

===== PAGE 713 =====

Dxxxx
20.3.2.3.7 Specialized algorithms [util.smartptr.weak.spec]
template<class T>
constexpr void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
1 Effects: Equivalent toa.swap(b).
20.3.2.4 Class template owner_less [util.smartptr.ownerless]
1 The class templateowner_less allows ownership-based mixed comparisons of shared and weak pointers.
namespace std {
template<class T = void> struct owner_less;
template<class T> struct owner_less<shared_ptr<T>> {
constexpr bool operator()(const shared_ptr<T>&, const shared_ptr<T>&) const noexcept;
constexpr bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
constexpr bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
};
template<class T> struct owner_less<weak_ptr<T>> {
constexpr bool operator()(const weak_ptr<T>&, const weak_ptr<T>&) const noexcept;
constexpr bool operator()(const shared_ptr<T>&, const weak_ptr<T>&) const noexcept;
constexpr bool operator()(const weak_ptr<T>&, const shared_ptr<T>&) const noexcept;
};
template<> struct owner_less<void> {
template<class T, class U>
constexpr bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
template<class T, class U>
constexpr bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
template<class T, class U>
constexpr bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
template<class T, class U>
constexpr bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
using is_transparent = unspecified ;
};
}
2 operator()(x, y) returns x.owner_before(y).
[Note 1: Note that
—(2.1) operator() defines a strict weak ordering as defined in 26.8;
—(2.2) !operator()(a, b) && !operator()(b, a) is true if and only ifa.owner_equal(b) is true.
—end note]
20.3.2.5 Struct owner_hash [util.smartptr.owner.hash]
1 The classowner_hash provides ownership-based hashing.
namespace std {
struct owner_hash {
template<class T>
size_t operator()(const shared_ptr<T>&) const noexcept;
template<class T>
size_t operator()(const weak_ptr<T>&) const noexcept;
using is_transparent = unspecified ;
};
}
template<class T>
size_t operator()(const shared_ptr<T>& x) const noexcept;
§ 20.3.2.5 © ISO/IEC
702

===== PAGE 714 =====

Dxxxx
template<class T>
size_t operator()(const weak_ptr<T>& x) const noexcept;
2 Returns: x.owner_hash().
3 [Note 1: For any object y where x.owner_equal(y) is true, x.owner_hash() == y.owner_hash() is true.
—end note]
20.3.2.6 Struct owner_equal [util.smartptr.owner.equal]
1 The classowner_equal provides ownership-based mixed equality comparisons of shared and weak pointers.
namespace std {
struct owner_equal {
template<class T, class U>
constexpr bool operator()(const shared_ptr<T>&, const shared_ptr<U>&) const noexcept;
template<class T, class U>
constexpr bool operator()(const shared_ptr<T>&, const weak_ptr<U>&) const noexcept;
template<class T, class U>
constexpr bool operator()(const weak_ptr<T>&, const shared_ptr<U>&) const noexcept;
template<class T, class U>
constexpr bool operator()(const weak_ptr<T>&, const weak_ptr<U>&) const noexcept;
using is_transparent = unspecified ;
};
}
template<class T, class U>
constexpr bool operator()(const shared_ptr<T>& x, const shared_ptr<U>& y) const noexcept;
template<class T, class U>
constexpr bool operator()(const shared_ptr<T>& x, const weak_ptr<U>& y) const noexcept;
template<class T, class U>
constexpr bool operator()(const weak_ptr<T>& x, const shared_ptr<U>& y) const noexcept;
template<class T, class U>
constexpr bool operator()(const weak_ptr<T>& x, const weak_ptr<U>& y) const noexcept;
2 Returns: x.owner_equal(y).
3 [Note 1: x.owner_equal(y) is true if and only ifx and y share ownership or are both empty.—end note]
20.3.2.7 Class template enable_shared_from_this [util.smartptr.enab]
1 A classTcan inherit fromenable_shared_from_this<T>to inherit theshared_from_thismember functions
that obtain ashared_ptr instance pointing to*this.
2 [Example 1:
struct X: public enable_shared_from_this<X> { };
int main() {
shared_ptr<X> p(new X);
shared_ptr<X> q = p->shared_from_this();
assert(p == q);
assert(p.owner_equal(q)); // p and q share ownership
}
—end example]
namespace std {
template<class T> class enable_shared_from_this {
protected:
constexpr enable_shared_from_this() noexcept;
constexpr enable_shared_from_this(const enable_shared_from_this&) noexcept;
constexpr enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept;
constexpr ~enable_shared_from_this();
public:
constexpr shared_ptr<T> shared_from_this();
constexpr shared_ptr<T const> shared_from_this() const;
constexpr weak_ptr<T> weak_from_this() noexcept;
constexpr weak_ptr<T const> weak_from_this() const noexcept;
§ 20.3.2.7 © ISO/IEC
703

===== PAGE 715 =====

Dxxxx
private:
mutable weak_ptr<T> weak-this ; // exposition only
};
}
3 The template parameterT of enable_shared_from_this may be an incomplete type.
constexpr enable_shared_from_this() noexcept;
constexpr enable_shared_from_this(const enable_shared_from_this<T>&) noexcept;
4 Effects: Value-initializesweak-this .
constexpr enable_shared_from_this<T>& operator=(const enable_shared_from_this<T>&) noexcept;
5 Returns: *this.
6 [Note 1: weak-this is not changed. —end note]
constexpr shared_ptr<T> shared_from_this();
constexpr shared_ptr<T const> shared_from_this() const;
7 Returns: shared_ptr<T>(weak-this ).
constexpr weak_ptr<T> weak_from_this() noexcept;
constexpr weak_ptr<T const> weak_from_this() const noexcept;
8 Returns: weak-this .
20.3.3 Smart pointer hash support [util.smartptr.hash]
template<class T, class D> struct hash<unique_ptr<T, D>>;
1 Letting UP be unique_ptr<T, D>, the specialization hash<UP> is enabled (22.10.19) if and only if
hash<typename UP::pointer> is enabled. When enabled, for an objectp of typeUP, hash<UP>()(p)
evaluates to the same value ashash<typename UP::pointer>()(p.get()). The member functions
are not guaranteed to benoexcept.
template<class T> struct hash<shared_ptr<T>>;
2 For an objectp of typeshared_ptr<T>, hash<shared_ptr<T>>()(p) evaluates to the same value as
hash<typename shared_ptr<T>::element_type*>()(p.get()).
20.3.4 Smart pointer adaptors [smartptr.adapt]
20.3.4.1 Class template out_ptr_t [out.ptr.t]
1 out_ptr_t is a class template used to adapt types such as smart pointers (20.3) for functions that use output
pointer parameters.
2 [Example 1:
#include <memory>
#include <cstdio>
int fopen_s(std::FILE** f, const char* name, const char* mode);
struct fclose_deleter {
void operator()(std::FILE* f) const noexcept {
std::fclose(f);
}
};
int main(int, char*[]) {
constexpr const char* file_name = "ow.o";
std::unique_ptr<std::FILE, fclose_deleter> file_ptr;
int err = fopen_s(std::out_ptr<std::FILE*>(file_ptr), file_name, "r+b");
if (err != 0)
return 1;
// *file_ptr is valid
return 0;
}
§ 20.3.4.1 © ISO/IEC
704

===== PAGE 716 =====

Dxxxx
unique_ptr can be used without_ptr to be passed into an output pointer-style function, without needing to hold
onto an intermediate pointer value and manually delete it on error or failure.—end example]
namespace std {
template<class Smart, class Pointer, class... Args>
class out_ptr_t {
public:
constexpr explicit out_ptr_t(Smart&, Args...);
out_ptr_t(const out_ptr_t&) = delete;
constexpr ~out_ptr_t();
constexpr operator Pointer*() const noexcept;
operator void**() const noexcept;
private:
Smart& s; // exposition only
tuple<Args...> a; // exposition only
Pointer p; // exposition only
};
}
3 Pointer shall meet theCpp17NullablePointer requirements. If Smart is a specialization ofshared_ptr and
sizeof...(Args) == 0, the program is ill-formed.
[Note 1: It is typically a user error to reset ashared_ptr without specifying a deleter, asshared_ptr will replace a
custom deleter upon usage ofreset, as specified in 20.3.2.2.5.—end note]
4 Program-defined specializations ofout_ptr_t that depend on at least one program-defined type need not
meet the requirements for the primary template.
5 Evaluations of the conversion functions on the same object may conflict (6.10.2.2).
constexpr explicit out_ptr_t(Smart& smart, Args... args);
6 Effects: Initializess with smart, a with std::forward<Args>(args)..., and value-initializesp. Then,
equivalent to:
—(6.1) s.reset();
if the expressions.reset() is well-formed;
—(6.2) otherwise,
s = Smart();
if is_constructible_v<Smart> is true;
—(6.3) otherwise, the program is ill-formed.
7 [Note 2: The constructor is notnoexcept to allow for a variety of non-terminating and safe implementation
strategies. For example, an implementation can allocate ashared_ptr’s internal node in the constructor and
let implementation-defined exceptions escape safely. The destructor can then move the allocated control block
in directly and avoid any other exceptions.—end note]
constexpr ~out_ptr_t();
8 Let SP be POINTER_OF_OR (Smart, Pointer) (20.2.1).
9 Effects: Equivalent to:
—(9.1) if (p) {
apply([&](auto&&... args) {
s.reset(static_cast<SP>(p), std::forward<Args>(args)...); }, std::move(a));
}
if the expression s.reset(static_cast<SP>(p), std::forward<Args>(args)...) is well-
formed;
—(9.2) otherwise,
if (p) {
apply([&](auto&&... args) {
s = Smart(static_cast<SP>(p), std::forward<Args>(args)...); }, std::move(a));
§ 20.3.4.1 © ISO/IEC
705

===== PAGE 717 =====

Dxxxx
}
if is_constructible_v<Smart, SP, Args...> is true;
—(9.3) otherwise, the program is ill-formed.
constexpr operator Pointer*() const noexcept;
10 Preconditions: operator void**() has not been called on*this.
11 Returns: addressof(const_cast<Pointer&>(p)).
operator void**() const noexcept;
12 Constraints: is_same_v<Pointer, void*> is false.
13 Mandates: is_pointer_v<Pointer> is true.
14 Preconditions: operator Pointer*() has not been called on*this.
15 Returns: A pointer valuev such that:
—(15.1) the initial value*v is equivalent tostatic_cast<void*>(p) and
—(15.2) any modification of*v that is not followed by a subsequent modification of*this affects the value
of p during the destruction of*this, such thatstatic_cast<void*>(p) == *v.
16 Remarks: Accessing *v outside the lifetime of*this has undefined behavior.
17 [Note 3: reinterpret_cast<void**>(static_cast<Pointer*>(*this)) can be a viable implementation strat-
egy for some implementations.—end note]
20.3.4.2 Function template out_ptr [out.ptr]
template<class Pointer = void, class Smart, class... Args>
constexpr auto out_ptr(Smart& s, Args&&... args);
1 Let P be Pointer if is_void_v<Pointer> is false, otherwisePOINTER_OF (Smart).
2 Returns: out_ptr_t<Smart, P, Args&&...>(s, std::forward<Args>(args)...).
20.3.4.3 Class template inout_ptr_t [inout.ptr.t]
1 inout_ptr_t is a class template used to adapt types such as smart pointers (20.3) for functions that use
output pointer parameters whose dereferenced values may first be deleted before being set to another allocated
value.
2 [Example 1:
#include <memory>
struct star_fish* star_fish_alloc();
int star_fish_populate(struct star_fish** ps, const char* description);
struct star_fish_deleter {
void operator() (struct star_fish* c) const noexcept;
};
using star_fish_ptr = std::unique_ptr<star_fish, star_fish_deleter>;
int main(int, char*[]) {
star_fish_ptr peach(star_fish_alloc());
// ...
// used, need to re-make
int err = star_fish_populate(std::inout_ptr(peach), "caring clown-fish liker");
return err;
}
A unique_ptr can be used withinout_ptr to be passed into an output pointer-style function. The original value will
be properly deleted according to the function it is used with and a new value reset in its place.—end example]
§ 20.3.4.3 © ISO/IEC
706

===== PAGE 718 =====

Dxxxx
namespace std {
template<class Smart, class Pointer, class... Args>
class inout_ptr_t {
public:
constexpr explicit inout_ptr_t(Smart&, Args...);
inout_ptr_t(const inout_ptr_t&) = delete;
constexpr ~inout_ptr_t();
constexpr operator Pointer*() const noexcept;
operator void**() const noexcept;
private:
Smart& s; // exposition only
tuple<Args...> a; // exposition only
Pointer p; // exposition only
};
}
3 Pointer shall meet theCpp17NullablePointer requirements. If Smart is a specialization ofshared_ptr, the
program is ill-formed.
[Note 1: It is impossible to properly acquire unique ownership of the managed resource from ashared_ptr given its
shared ownership model. —end note]
4 Program-defined specializations ofinout_ptr_t that depend on at least one program-defined type need not
meet the requirements for the primary template.
5 Evaluations of the conversion functions on the same object may conflict (6.10.2.2).
constexpr explicit inout_ptr_t(Smart& smart, Args... args);
6 Effects: Initializes s with smart, a with std::forward<Args>(args)..., andp to either
—(6.1) smart if is_pointer_v<Smart> is true,
—(6.2) otherwise, smart.get().
7 Remarks: An implementation can calls.release().
8 [Note 2: The constructor is notnoexcept to allow for a variety of non-terminating and safe implementation
strategies. For example, an intrusive pointer implementation with a control block can allocate in the constructor
and safely fail with an exception.—end note]
constexpr ~inout_ptr_t();
9 Let SP be POINTER_OF_OR (Smart, Pointer) (20.2.1).
10 Let release-statement be s.release(); if an implementation does not calls.release() in the
constructor. Otherwise, it is empty.
11 Effects: Equivalent to:
—(11.1) apply([&](auto&&... args) {
s = Smart(static_cast<SP>(p), std::forward<Args>(args)...); }, std::move(a));
if is_pointer_v<Smart> is true;
—(11.2) otherwise,
release-statement ;
if (p) {
apply([&](auto&&... args) {
s.reset(static_cast<SP>(p), std::forward<Args>(args)...); }, std::move(a));
}
if the expressions.reset(static_cast<SP>(p), std::forward<Args>(args)...) is well-
formed;
—(11.3) otherwise,
release-statement ;
§ 20.3.4.3 © ISO/IEC
707

===== PAGE 719 =====

Dxxxx
if (p) {
apply([&](auto&&... args) {
s = Smart(static_cast<SP>(p), std::forward<Args>(args)...); }, std::move(a));
}
if is_constructible_v<Smart, SP, Args...> is true;
—(11.4) otherwise, the program is ill-formed.
constexpr operator Pointer*() const noexcept;
12 Preconditions: operator void**() has not been called on*this.
13 Returns: addressof(const_cast<Pointer&>(p)).
operator void**() const noexcept;
14 Constraints: is_same_v<Pointer, void*> is false.
15 Mandates: is_pointer_v<Pointer> is true.
16 Preconditions: operator Pointer*() has not been called on*this.
17 Returns: A pointer valuev such that:
—(17.1) the initial value*v is equivalent tostatic_cast<void*>(p) and
—(17.2) any modification of*v that is not followed by subsequent modification of*this affects the value
of p during the destruction of*this, such thatstatic_cast<void*>(p) == *v.
18 Remarks: Accessing *v outside the lifetime of*this has undefined behavior.
19 [Note 3: reinterpret_cast<void**>(static_cast<Pointer*>(*this)) can be a viable implementation strat-
egy for some implementations.—end note]
20.3.4.4 Function template inout_ptr [inout.ptr]
template<class Pointer = void, class Smart, class... Args>
constexpr auto inout_ptr(Smart& s, Args&&... args);
1 Let P be Pointer if is_void_v<Pointer> is false, otherwisePOINTER_OF (Smart).
2 Returns: inout_ptr_t<Smart, P, Args&&...>(s, std::forward<Args>(args)...).
20.4 Types for composite class design [mem.composite.types]
20.4.1 Class template indirect [indirect]
20.4.1.1 General [indirect.general]
1 An indirect object manages the lifetime of an owned object. An indirect object isvalueless if it has no owned
object. An indirect object may become valueless only after it has been moved from.
2 In every specializationindirect<T, Allocator>, if the typeallocator_traits<Allocator>::value_type
is not the same type asT, the program is ill-formed. Every object of typeindirect<T, Allocator> uses an
object of typeAllocator to allocate and free storage for the owned object as needed.
3 Constructing an owned object withargs... using the allocatora means callingallocator_traits<Alloca-
tor>::construct(a, p , args...) where args is an expression pack,a is an allocator, andp is a pointer
obtained by callingallocator_traits<Allocator>::allocate.
4 The member alloc is used for any memory allocation and element construction performed by member
functions during the lifetime of each indirect object. The allocatoralloc may be replaced only via assignment
or swap(). Allocator replacement is performed by copy assignment, move assignment, or swapping of the
allocator only if (23.2.2.2):
—(4.1) allocator_traits<Allocator>::propagate_on_container_copy_assignment::value, or
—(4.2) allocator_traits<Allocator>::propagate_on_container_move_assignment::value, or
—(4.3) allocator_traits<Allocator>::propagate_on_container_swap::value
is true within the implementation of the correspondingindirect operation.
5 A program that instantiates the definition of the templateindirect<T, Allocator> with a type for theT
parameter that is a non-object type, an array type,in_place_t, a specialization ofin_place_type_t, or a
cv-qualified type is ill-formed.
§ 20.4.1.1 © ISO/IEC
708

===== PAGE 720 =====

Dxxxx
6 The template parameterT of indirect may be an incomplete type.
7 The template parameterAllocator of indirect shall meet theCpp17Allocator requirements.
8 If a program declares an explicit or partial specialization ofindirect, the behavior is undefined.
20.4.1.2 Synopsis [indirect.syn]
namespace std {
template<class T, class Allocator = allocator<T>>
class indirect {
public:
using value_type = T;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
// 20.4.1.3, constructors
constexpr explicit indirect();
constexpr explicit indirect(allocator_arg_t, const Allocator& a);
constexpr indirect(const indirect& other);
constexpr indirect(allocator_arg_t, const Allocator& a, const indirect& other);
constexpr indirect(indirect&& other) noexcept;
constexpr indirect(allocator_arg_t, const Allocator& a, indirect&& other)
noexcept(see below );
template<class U = T>
constexpr explicit indirect(U&& u);
template<class U = T>
constexpr explicit indirect(allocator_arg_t, const Allocator& a, U&& u);
template<class... Us>
constexpr explicit indirect(in_place_t, Us&&... us);
template<class... Us>
constexpr explicit indirect(allocator_arg_t, const Allocator& a,
in_place_t, Us&&... us);
template<class I, class... Us>
constexpr explicit indirect(in_place_t, initializer_list<I> ilist, Us&&... us);
template<class I, class... Us>
constexpr explicit indirect(allocator_arg_t, const Allocator& a,
in_place_t, initializer_list<I> ilist, Us&&... us);
// 20.4.1.4, destructor
constexpr ~indirect();
// 20.4.1.5, assignment
constexpr indirect& operator=(const indirect& other);
constexpr indirect& operator=(indirect&& other) noexcept(see below );
template<class U = T>
constexpr indirect& operator=(U&& u);
// 20.4.1.6, observers
constexpr const T& operator*() const & noexcept;
constexpr T& operator*() & noexcept;
constexpr const T&& operator*() const && noexcept;
constexpr T&& operator*() && noexcept;
constexpr const_pointer operator->() const noexcept;
constexpr pointer operator->() noexcept;
constexpr bool valueless_after_move() const noexcept;
constexpr allocator_type get_allocator() const noexcept;
// 20.4.1.7, swap
constexpr void swap(indirect& other) noexcept(see below );
friend constexpr void swap(indirect& lhs, indirect& rhs) noexcept(see below );
§ 20.4.1.2 © ISO/IEC
709

===== PAGE 721 =====

Dxxxx
// 20.4.1.8, relational operators
template<class U, class AA>
friend constexpr bool operator==(const indirect& lhs, const indirect<U, AA>& rhs)
noexcept(see below );
template<class U, class AA>
friend constexpr auto operator<=>(const indirect& lhs, const indirect<U, AA>& rhs)
-> synth-three-way-result <T, U>;
// 20.4.1.9, comparison withT
template<class U>
friend constexpr bool operator==(const indirect& lhs, const U& rhs) noexcept(see below );
template<class U>
friend constexpr auto operator<=>(const indirect& lhs, const U& rhs)
-> synth-three-way-result <T, U>;
private:
pointer p ; // exposition only
Allocator alloc = Allocator(); // exposition only
};
template<class Value>
indirect(Value) -> indirect<Value>;
template<class Allocator, class Value>
indirect(allocator_arg_t, Allocator, Value)
-> indirect<Value, typename allocator_traits<Allocator>::template rebind_alloc<Value>>;
}
20.4.1.3 Constructors [indirect.ctor]
1 The following element applies to all functions in 20.4.1.3:
2 Throws: Nothing unlessallocator_traits<Allocator>::allocate or allocator_traits<Alloca-
tor>::construct throws.
constexpr explicit indirect();
3 Constraints: is_default_constructible_v<Allocator> is true.
4 Mandates: is_default_constructible_v<T> is true.
5 Effects: Constructs an owned object of typeT with an empty argument list, using the allocatoralloc .
constexpr explicit indirect(allocator_arg_t, const Allocator& a);
6 Mandates: is_default_constructible_v<T> is true.
7 Effects: alloc is direct-non-list-initialized witha. Constructs an owned object of typeT with an empty
argument list, using the allocatoralloc .
constexpr indirect(const indirect& other);
8 Mandates: is_copy_constructible_v<T> is true.
9 Effects: alloc is direct-non-list-initialized withallocator_traits<Allocator>::select_on_contai-
ner_copy_construction(other.alloc ). If other is valueless,*this is valueless. Otherwise, con-
structs an owned object of typeT with *other, using the allocatoralloc .
constexpr indirect(allocator_arg_t, const Allocator& a, const indirect& other);
10 Mandates: is_copy_constructible_v<T> is true.
11 Effects: alloc is direct-non-list-initialized witha. If other is valueless,*this is valueless. Otherwise,
constructs an owned object of typeT with *other, using the allocatoralloc .
constexpr indirect(indirect&& other) noexcept;
12 Effects: alloc is direct-non-list-initialized from std::move(other.alloc ). If other is valueless,
*this is valueless. Otherwise*this takes ownership of the owned object ofother.
13 Postconditions: other is valueless.
§ 20.4.1.3 © ISO/IEC
710

===== PAGE 722 =====

Dxxxx
constexpr indirect(allocator_arg_t, const Allocator& a, indirect&& other)
noexcept(allocator_traits<Allocator>::is_always_equal::value);
14 Mandates: If allocator_traits<Allocator>::is_always_equal::value is false then T is a com-
plete type.
15 Effects: alloc is direct-non-list-initialized witha. If other is valueless,*this is valueless. Otherwise,
if alloc == other.alloc is true, constructs an object of typeindirect that takes ownership of the
owned object ofother. Otherwise, constructs an owned object of typeT with *std::move(other),
using the allocatoralloc .
16 Postconditions: other is valueless.
template<class U = T>
constexpr explicit indirect(U&& u);
17 Constraints:
—(17.1) is_same_v<remove_cvref_t<U>, indirect> is false,
—(17.2) is_same_v<remove_cvref_t<U>, in_place_t> is false,
—(17.3) is_constructible_v<T, U> is true, and
—(17.4) is_default_constructible_v<Allocator> is true.
18 Effects: Constructs an owned object of typeT with std::forward<U>(u), using the allocatoralloc .
template<class U = T>
constexpr explicit indirect(allocator_arg_t, const Allocator& a, U&& u);
19 Constraints:
—(19.1) is_same_v<remove_cvref_t<U>, indirect> is false,
—(19.2) is_same_v<remove_cvref_t<U>, in_place_t> is false, and
—(19.3) is_constructible_v<T, U> is true.
20 Effects: alloc is direct-non-list-initialized with a. Constructs an owned object of type T with
std::forward<U>(u), using the allocatoralloc .
template<class... Us>
constexpr explicit indirect(in_place_t, Us&&... us);
21 Constraints:
—(21.1) is_constructible_v<T, Us...> is true, and
—(21.2) is_default_constructible_v<Allocator> is true.
22 Effects: Constructs an owned object of typeT with std::forward<Us>(us)..., using the allocator
alloc .
template<class... Us>
constexpr explicit indirect(allocator_arg_t, const Allocator& a,
in_place_t, Us&& ...us);
23 Constraints: is_constructible_v<T, Us...> is true.
24 Effects: alloc is direct-non-list-initialized with a. Constructs an owned object of type T with
std::forward<Us>(us)..., using the allocatoralloc .
template<class I, class... Us>
constexpr explicit indirect(in_place_t, initializer_list<I> ilist, Us&&... us);
25 Constraints:
—(25.1) is_constructible_v<T, initializer_list<I>&, Us...> is true, and
—(25.2) is_default_constructible_v<Allocator> is true.
26 Effects: Constructs an owned object of typeT with the argumentsilist, std::forward<Us>(us)...,
using the allocatoralloc .
§ 20.4.1.3 © ISO/IEC
711

===== PAGE 723 =====

Dxxxx
template<class I, class... Us>
constexpr explicit indirect(allocator_arg_t, const Allocator& a,
in_place_t, initializer_list<I> ilist, Us&&... us);
27 Constraints: is_constructible_v<T, initializer_list<I>&, Us...> is true.
28 Effects: alloc is direct-non-list-initialized witha. Constructs an owned object of typeT with the
arguments ilist, std::forward<Us>(us)..., using the allocatoralloc .
20.4.1.4 Destructor [indirect.dtor]
constexpr ~indirect();
1 Mandates: T is a complete type.
2 Effects: If*thisis not valueless, destroys the owned object usingallocator_traits<Allocator>::de-
stroy and then the storage is deallocated.
20.4.1.5 Assignment [indirect.assign]
constexpr indirect& operator=(const indirect& other);
1 Mandates:
—(1.1) is_copy_assignable_v<T> is true, and
—(1.2) is_copy_constructible_v<T> is true.
2 Effects: If addressof(other) == this is true, there are no effects. Otherwise:
—(2.1) The allocator needs updating ifallocator_traits<Allocator>::propagate_on_container_-
copy_assignment::value is true.
—(2.2) If other is valueless,*this becomes valueless and the owned object in*this, if any, is destroyed
using allocator_traits<Allocator>::destroy and then the storage is deallocated.
—(2.3) Otherwise, ifalloc == other.alloc is true and *this is not valueless, equivalent to**this
= *other.
—(2.4) Otherwiseanewownedobjectisconstructedin *thisusingallocator_traits<Allocator>::con
struct with the owned object fromother as the argument, using either the allocator in*this or
the allocator inother if the allocator needs updating.
—(2.5) The previously owned object in*this, if any, is destroyed usingallocator_traits<Allocator>::
destroy and then the storage is deallocated.
—(2.6) If the allocator needs updating, the allocator in*this is replaced with a copy of the allocator in
other.
3 Returns: A reference to*this.
4 Remarks: If any exception is thrown, the result of the expressionthis->valueless_after_move()
remains unchanged. If an exception is thrown during the call toT’s selected copy constructor, no effect.
If an exception is thrown during the call toT’s copy assignment, the state of its owned object is as
defined by the exception safety guarantee ofT’s copy assignment.
constexpr indirect& operator=(indirect&& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
5 Mandates: If allocator_traits<Allocator>::propagate_on_container_move_assignment::val-
ue is false and allocator_traits<Allocator>::is_always_equal::value is false, is_move_con-
structible_v<T> is true.
6 Effects: If addressof(other) == this is true, there are no effects. Otherwise:
—(6.1) The allocator needs updating ifallocator_traits<Allocator>::propagate_on_container_-
move_assignment::value is true.
—(6.2) If other is valueless,*this becomes valueless.
—(6.3) Otherwise, if the allocator needs updating or ifalloc == other.alloc is true, *this takes
ownership of the owned object ofother.
§ 20.4.1.5 © ISO/IEC
712

===== PAGE 724 =====

Dxxxx
—(6.4) Otherwise, constructs a new owned object with the owned object ofother as the argument as an
rvalue, using the allocator in*this.
—(6.5) The previously owned object in*this, if any, is destroyed usingallocator_traits<Allocator>::
destroy and then the storage is deallocated.
—(6.6) If the allocator needs updating, the allocator in*this is replaced with a copy of the allocator in
other.
7 Postconditions: other is valueless.
8 Returns: A reference to*this.
9 Remarks: If any exception is thrown, there are no effects on*this or other.
template<class U = T>
constexpr indirect& operator=(U&& u);
10 Constraints:
—(10.1) is_same_v<remove_cvref_t<U>, indirect> is false,
—(10.2) is_constructible_v<T, U> is true, and
—(10.3) is_assignable_v<T&, U> is true.
11 Effects: If *this is valueless then constructs an owned object of typeT with std::forward<U>(u)
using the allocatoralloc . Otherwise, equivalent to**this = std::forward<U>(u).
12 Returns: A reference to*this.
20.4.1.6 Observers [indirect.obs]
constexpr const T& operator*() const & noexcept;
constexpr T& operator*() & noexcept;
1 Preconditions: *this is not valueless.
2 Returns: *p .
constexpr const T&& operator*() const && noexcept;
constexpr T&& operator*() && noexcept;
3 Preconditions: *this is not valueless.
4 Returns: std::move(*p ).
constexpr const_pointer operator->() const noexcept;
constexpr pointer operator->() noexcept;
5 Preconditions: *this is not valueless.
6 Returns: p .
constexpr bool valueless_after_move() const noexcept;
7 Returns: true if *this is valueless, otherwisefalse.
constexpr allocator_type get_allocator() const noexcept;
8 Returns: alloc .
20.4.1.7 Swap [indirect.swap]
constexpr void swap(indirect& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
1 Preconditions: If allocator_traits<Allocator>::propagate_on_container_swap::value is true,
then Allocator meets the Cpp17Swappable requirements. Otherwise get_allocator() == other.
get_allocator() is true.
2 Effects: Swaps the states of *this and other, exchanging owned objects or valueless states. If
allocator_traits<Allocator>::propagate_on_container_swap::value is true, then the alloca-
tors of *this and other are exchanged by callingswap as described in 16.4.4.3. Otherwise, the
allocators are not swapped.
§ 20.4.1.7 © ISO/IEC
713

===== PAGE 725 =====

Dxxxx
[Note 1: Does not callswap on the owned objects directly.—end note]
constexpr void swap(indirect& lhs, indirect& rhs) noexcept(noexcept(lhs.swap(rhs)));
3 Effects: Equivalent tolhs.swap(rhs).
20.4.1.8 Relational operators [indirect.relops]
template<class U, class AA>
constexpr bool operator==(const indirect& lhs, const indirect<U, AA>& rhs)
noexcept(noexcept(*lhs == *rhs));
1 Mandates: The expression*lhs == *rhs is well-formed and its result is convertible tobool.
2 Returns: If lhs is valueless orrhs is valueless,lhs.valueless_after_move() == rhs.valueless_-
after_move(); otherwise*lhs == *rhs.
template<class U, class AA>
constexpr synth-three-way-result <T, U>
operator<=>(const indirect& lhs, const indirect<U, AA>& rhs);
3 Returns: If lhs is valueless orrhs is valueless, !lhs.valueless_after_move() <=> !rhs.value-
less_after_move(); otherwisesynth-three-way (*lhs, *rhs).
20.4.1.9 Comparison with T [indirect.comp.with.t]
template<class U>
constexpr bool operator==(const indirect& lhs, const U& rhs) noexcept(noexcept(*lhs == rhs));
1 Mandates: The expression*lhs == rhs is well-formed and its result is convertible tobool.
2 Returns: If lhs is valueless,false; otherwise*lhs == rhs.
template<class U>
constexpr synth-three-way-result <T, U>
operator<=>(const indirect& lhs, const U& rhs);
3 Returns: If lhs is valueless,strong_ordering::less; otherwisesynth-three-way (*lhs, rhs).
20.4.1.10 Hash support [indirect.hash]
template<class T, class Allocator>
struct hash<indirect<T, Allocator>>;
1 The specialization hash<indirect<T, Allocator>> is enabled (22.10.19) if and only if hash<T>
is enabled. When enabled for an object i of type indirect<T, Allocator>, hash<indirect<T,
Allocator>>()(i) evaluates to either the same value ashash<T>()(*i), ifi is not valueless; other-
wise to an implementation-defined value. The member functions are not guaranteed to benoexcept.
20.4.2 Class template polymorphic [polymorphic]
20.4.2.1 General [polymorphic.general]
1 A polymorphic object manages the lifetime of an owned object. A polymorphic object may own objects of
different types at different points in its lifetime. A polymorphic object isvalueless if it has no owned object.
A polymorphic object may become valueless only after it has been moved from.
2 In every specializationpolymorphic<T, Allocator>, if the typeallocator_traits<Allocator>::value_-
type is not the same type asT, the program is ill-formed. Every object of typepolymorphic<T, Allocator>
uses an object of typeAllocator to allocate and free storage for the owned object as needed.
3 Constructing an owned object of typeU with args... using the allocatora means calling allocator_-
traits<Allocator>::construct(a, p , args...) where args is an expression pack,a is an allocator, and
p points to storage suitable for an owned object of typeU.
4 The member alloc is used for any memory allocation and element construction performed by member
functions during the lifetime of each polymorphic value object, or until the allocator is replaced. The allocator
may be replaced only via assignment orswap(). Allocator replacement is performed by copy assignment,
move assignment, or swapping of the allocator only if (23.2.2.2):
—(4.1) allocator_traits<Allocator>::propagate_on_container_copy_assignment::value, or
§ 20.4.2.1 © ISO/IEC
714

===== PAGE 726 =====

Dxxxx
—(4.2) allocator_traits<Allocator>::propagate_on_container_move_assignment::value, or
—(4.3) allocator_traits<Allocator>::propagate_on_container_swap::value
is true within the implementation of the correspondingpolymorphic operation.
5 A program that instantiates the definition ofpolymorphic for a non-object type, an array type,in_place_t,
a specialization ofin_place_type_t, or a cv-qualified type is ill-formed.
6 The template parameterT of polymorphic may be an incomplete type.
7 The template parameterAllocator of polymorphic shall meet the requirements ofCpp17Allocator.
8 If a program declares an explicit or partial specialization ofpolymorphic, the behavior is undefined.
20.4.2.2 Synopsis [polymorphic.syn]
namespace std {
template<class T, class Allocator = allocator<T>>
class polymorphic {
public:
using value_type = T;
using allocator_type = Allocator;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
// 20.4.2.3, constructors
constexpr explicit polymorphic();
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a);
constexpr polymorphic(const polymorphic& other);
constexpr polymorphic(allocator_arg_t, const Allocator& a, const polymorphic& other);
constexpr polymorphic(polymorphic&& other) noexcept;
constexpr polymorphic(allocator_arg_t, const Allocator& a, polymorphic&& other)
noexcept(see below );
template<class U = T>
constexpr explicit polymorphic(U&& u);
template<class U = T>
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a, U&& u);
template<class U, class... Ts>
constexpr explicit polymorphic(in_place_type_t<U>, Ts&&... ts);
template<class U, class... Ts>
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a,
in_place_type_t<U>, Ts&&... ts);
template<class U, class I, class... Us>
constexpr explicit polymorphic(in_place_type_t<U>, initializer_list<I> ilist, Us&&... us);
template<class U, class I, class... Us>
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a,
in_place_type_t<U>, initializer_list<I> ilist, Us&&... us);
// 20.4.2.4, destructor
constexpr ~polymorphic();
// 20.4.2.5, assignment
constexpr polymorphic& operator=(const polymorphic& other);
constexpr polymorphic& operator=(polymorphic&& other) noexcept(see below );
// 20.4.2.6, observers
constexpr const T& operator*() const noexcept;
constexpr T& operator*() noexcept;
constexpr const_pointer operator->() const noexcept;
constexpr pointer operator->() noexcept;
constexpr bool valueless_after_move() const noexcept;
constexpr allocator_type get_allocator() const noexcept;
// 20.4.2.7, swap
constexpr void swap(polymorphic& other) noexcept(see below );
friend constexpr void swap(polymorphic& lhs, polymorphic& rhs) noexcept(see below );
§ 20.4.2.2 © ISO/IEC
715

===== PAGE 727 =====

Dxxxx
private:
Allocator alloc = Allocator(); // exposition only
};
}
20.4.2.3 Constructors [polymorphic.ctor]
1 The following element applies to all functions in 20.4.2.3:
2 Throws: Nothing unlessallocator_traits<Allocator>::allocate or allocator_traits<Alloca-
tor>::construct throws.
constexpr explicit polymorphic();
3 Constraints: is_default_constructible_v<Allocator> is true.
4 Mandates:
—(4.1) is_default_constructible_v<T> is true, and
—(4.2) is_copy_constructible_v<T> is true.
5 Effects: Constructs an owned object of typeT with an empty argument list using the allocatoralloc .
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a);
6 Mandates:
—(6.1) is_default_constructible_v<T> is true, and
—(6.2) is_copy_constructible_v<T> is true.
7 Effects: alloc is direct-non-list-initialized witha. Constructs an owned object of typeT with an empty
argument list using the allocatoralloc .
constexpr polymorphic(const polymorphic& other);
8 Effects: alloc is direct-non-list-initialized withallocator_traits<Allocator>::select_on_contai-
ner_copy_construction(other.alloc ). If other is valueless,*this is valueless. Otherwise, con-
structs an owned object of typeU, whereU is the type of the owned object inother, with the owned
object inother using the allocatoralloc .
constexpr polymorphic(allocator_arg_t, const Allocator& a, const polymorphic& other);
9 Effects: alloc is direct-non-list-initialized witha. If other is valueless,*this is valueless. Otherwise,
constructs an owned object of typeU, whereU is the type of the owned object inother, with the owned
object inother using the allocatoralloc .
constexpr polymorphic(polymorphic&& other) noexcept;
10 Effects: alloc is direct-non-list-initialized with std::move(other.alloc ). If other is valueless,
*this is valueless. Otherwise, either*this takes ownership of the owned object ofother or, owns an
object of the same type constructed from the owned object ofother considering that owned object as
an rvalue, using the allocatoralloc .
constexpr polymorphic(allocator_arg_t, const Allocator& a, polymorphic&& other)
noexcept(allocator_traits<Allocator>::is_always_equal::value);
11 Effects: alloc is direct-non-list-initialized witha. If other is valueless,*this is valueless. Otherwise,
if alloc == other.alloc is true, either constructs an object of typepolymorphic that owns the
owned object of other, making other valueless; or, owns an object of the same type constructed
from the owned object ofother considering that owned object as an rvalue. Otherwise, ifalloc
!= other.alloc is true, constructs an object of typepolymorphic, considering the owned object in
other as an rvalue, using the allocatoralloc .
template<class U = T>
constexpr explicit polymorphic(U&& u);
12 Constraints: Where UU is remove_cvref_t<U>,
—(12.1) is_same_v<UU, polymorphic> is false,
—(12.2) derived_from<UU, T> is true,
§ 20.4.2.3 © ISO/IEC
716

===== PAGE 728 =====

Dxxxx
—(12.3) is_constructible_v<UU, U> is true,
—(12.4) is_copy_constructible_v<UU> is true,
—(12.5) UU is not a specialization ofin_place_type_t, and
—(12.6) is_default_constructible_v<Allocator> is true.
13 Effects: Constructs an owned object of typeUU with std::forward<U>(u) using the allocatoralloc .
template<class U = T>
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a, U&& u);
14 Constraints: Where UU is remove_cvref_t<U>,
—(14.1) is_same_v<UU, polymorphic> is false,
—(14.2) derived_from<UU, T> is true,
—(14.3) is_constructible_v<UU, U> is true,
—(14.4) is_copy_constructible_v<UU> is true, and
—(14.5) UU is not a specialization ofin_place_type_t.
15 Effects: alloc is direct-non-list-initialized with a. Constructs an owned object of type UU with
std::forward<U>(u) using the allocatoralloc .
template<class U, class... Ts>
constexpr explicit polymorphic(in_place_type_t<U>, Ts&&... ts);
16 Constraints:
—(16.1) is_same_v<remove_cvref_t<U>, U> is true,
—(16.2) derived_from<U, T> is true,
—(16.3) is_constructible_v<U, Ts...> is true,
—(16.4) is_copy_constructible_v<U> is true, and
—(16.5) is_default_constructible_v<Allocator> is true.
17 Effects: Constructs an owned object of typeU with std::forward<Ts>(ts)... using the allocator
alloc .
template<class U, class... Ts>
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a,
in_place_type_t<U>, Ts&&... ts);
18 Constraints:
—(18.1) is_same_v<remove_cvref_t<U>, U> is true,
—(18.2) derived_from<U, T> is true,
—(18.3) is_constructible_v<U, Ts...> is true, and
—(18.4) is_copy_constructible_v<U> is true.
19 Effects: alloc is direct-non-list-initialized with a. Constructs an owned object of type U with
std::forward<Ts>(ts)... using the allocatoralloc .
template<class U, class I, class... Us>
constexpr explicit polymorphic(in_place_type_t<U>, initializer_list<I> ilist, Us&&... us);
20 Constraints:
—(20.1) is_same_v<remove_cvref_t<U>, U> is true,
—(20.2) derived_from<U, T> is true,
—(20.3) is_constructible_v<U, initializer_list<I>&, Us...> is true,
—(20.4) is_copy_constructible_v<U> is true, and
—(20.5) is_default_constructible_v<Allocator> is true.
21 Effects: Constructs an owned object of typeU with the argumentsilist, std::forward<Us>(us)...
using the allocatoralloc .
§ 20.4.2.3 © ISO/IEC
717

===== PAGE 729 =====

Dxxxx
template<class U, class I, class... Us>
constexpr explicit polymorphic(allocator_arg_t, const Allocator& a,
in_place_type_t<U>, initializer_list<I> ilist, Us&&... us);
22 Constraints:
—(22.1) is_same_v<remove_cvref_t<U>, U> is true,
—(22.2) derived_from<U, T> is true,
—(22.3) is_constructible_v<U, initializer_list<I>&, Us...> is true, and
—(22.4) is_copy_constructible_v<U> is true.
23 Effects: alloc is direct-non-list-initialized witha. Constructs an owned object of typeU with the
arguments ilist, std::forward<Us>(us)... using the allocatoralloc .
20.4.2.4 Destructor [polymorphic.dtor]
constexpr ~polymorphic();
1 Mandates: T is a complete type.
2 Effects: If*thisis not valueless, destroys the owned object usingallocator_traits<Allocator>::de-
stroy and then the storage is deallocated.
20.4.2.5 Assignment [polymorphic.assign]
constexpr polymorphic& operator=(const polymorphic& other);
1 Mandates: T is a complete type.
2 Effects: If addressof(other) == this is true, there are no effects. Otherwise:
—(2.1) The allocator needs updating ifallocator_traits<Allocator>::propagate_on_container_-
copy_assignment::value is true.
—(2.2) If other is not valueless, a new owned object is constructed in *this using allocator_-
traits<Allocator>::construct with the owned object from other as the argument, using
either the allocator in*this or the allocator inother if the allocator needs updating.
—(2.3) The previously owned object in*this, if any, is destroyed usingallocator_traits<Allocator>::
destroy and then the storage is deallocated.
—(2.4) If the allocator needs updating, the allocator in*this is replaced with a copy of the allocator in
other.
3 Returns: A reference to*this.
4 Remarks: If any exception is thrown, there are no effects on*this.
constexpr polymorphic& operator=(polymorphic&& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
5 Mandates: If allocator_traits<Allocator>::propagate_on_container_move_assignment::val-
ue is false and allocator_traits<Allocator>::is_always_equal::value is false, T is a complete
type.
6 Effects: If addressof(other) == this is true, there are no effects. Otherwise:
—(6.1) The allocator needs updating ifallocator_traits<Allocator>::propagate_on_container_-
move_assignment::value is true.
—(6.2) If other is valueless,*this becomes valueless.
—(6.3) Otherwise, if the allocator needs updating or alloc == other.alloc is true, *this takes
ownership of the owned object ofother.
—(6.4) Otherwise, constructs a new owned object with the owned object ofother as the argument as an
rvalue, using the allocator in*this.
—(6.5) The previously owned object in*this, if any, is destroyed usingallocator_traits<Allocator>::
destroy and then the storage is deallocated.
§ 20.4.2.5 © ISO/IEC
718

===== PAGE 730 =====

Dxxxx
—(6.6) If the allocator needs updating, the allocator in*this is replaced with a copy of the allocator in
other.
7 Returns: A reference to*this.
8 Remarks: If any exception is thrown, there are no effects on*this or other.
20.4.2.6 Observers [polymorphic.obs]
constexpr const T& operator*() const noexcept;
constexpr T& operator*() noexcept;
1 Preconditions: *this is not valueless.
2 Returns: A reference to the owned object.
constexpr const_pointer operator->() const noexcept;
constexpr pointer operator->() noexcept;
3 Preconditions: *this is not valueless.
4 Returns: A pointer to the owned object.
constexpr bool valueless_after_move() const noexcept;
5 Returns: true if *this is valueless, otherwisefalse.
constexpr allocator_type get_allocator() const noexcept;
6 Returns: alloc .
20.4.2.7 Swap [polymorphic.swap]
constexpr void swap(polymorphic& other)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
1 Preconditions: If allocator_traits<Allocator>::propagate_on_container_swap::value is true,
then Allocator meets the Cpp17Swappable requirements. Otherwise get_allocator() == other.
get_allocator() is true.
2 Effects: Swaps the states of *this and other, exchanging owned objects or valueless states. If
allocator_traits<Allocator>::propagate_on_container_swap::value is true, then the alloca-
tors of *this and other are exchanged by callingswap as described in 16.4.4.3. Otherwise, the
allocators are not swapped.
[Note 1: Does not callswap on the owned objects directly.—end note]
constexpr void swap(polymorphic& lhs, polymorphic& rhs) noexcept(noexcept(lhs.swap(rhs)));
3 Effects: Equivalent tolhs.swap(rhs).
20.5 Memory resources [mem.res]
20.5.1 Header <memory_resource> synopsis [mem.res.syn]
namespace std::pmr {
// 20.5.2, classmemory_resource
class memory_resource;
bool operator==(const memory_resource& a, const memory_resource& b) noexcept;
// 20.5.3, class templatepolymorphic_allocator
template<class Tp = byte> class polymorphic_allocator;
template<class T1, class T2>
bool operator==(const polymorphic_allocator<T1>& a,
const polymorphic_allocator<T2>& b) noexcept;
// 20.5.4, global memory resources
memory_resource* new_delete_resource() noexcept;
memory_resource* null_memory_resource() noexcept;
§ 20.5.1 © ISO/IEC
719

===== PAGE 731 =====

Dxxxx
memory_resource* set_default_resource(memory_resource* r) noexcept;
memory_resource* get_default_resource() noexcept;
// 20.5.5, pool resource classes
struct pool_options;
class synchronized_pool_resource;
class unsynchronized_pool_resource;
class monotonic_buffer_resource;
}
20.5.2 Class memory_resource [mem.res.class]
20.5.2.1 General [mem.res.class.general]
1 The memory_resource class is an abstract interface to an unbounded set of classes encapsulating memory
resources.
namespace std::pmr {
class memory_resource {
static constexpr size_t max_align = alignof(max_align_t); // exposition only
public:
memory_resource() = default;
memory_resource(const memory_resource&) = default;
virtual ~memory_resource();
memory_resource& operator=(const memory_resource&) = default;
void* allocate(size_t bytes, size_t alignment = max_align);
void deallocate(void* p, size_t bytes, size_t alignment = max_align);
bool is_equal(const memory_resource& other) const noexcept;
private:
virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;
virtual bool do_is_equal(const memory_resource& other) const noexcept = 0;
};
}
20.5.2.2 Public member functions [mem.res.public]
~memory_resource();
1 Effects: Destroys thismemory_resource.
void* allocate(size_t bytes, size_t alignment = max_align);
2 Effects: Allocates storage by callingdo_allocate(bytes, alignment) and implicitly creates objects
within the allocated region of storage.
3 Returns: A pointer to a suitable created object (6.8.2) in the allocated region of storage.
4 Throws: What and when the call todo_allocate throws.
void deallocate(void* p, size_t bytes, size_t alignment = max_align);
5 Effects: Equivalent todo_deallocate(p, bytes, alignment).
bool is_equal(const memory_resource& other) const noexcept;
6 Effects: Equivalent to:return do_is_equal(other);
20.5.2.3 Private virtual member functions [mem.res.private]
virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
1 Preconditions: alignment is a power of two.
§ 20.5.2.3 © ISO/IEC
720

===== PAGE 732 =====

Dxxxx
2 Returns: A derived class shall implement this function to return a pointer to allocated storage (6.8.6.5.2)
with a size of at leastbytes, aligned to the specifiedalignment.
3 Throws: A derived class implementation shall throw an appropriate exception if it is unable to allocate
memory with the requested size and alignment.
virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;
4 Preconditions: p was returned from a prior call toallocate(bytes, alignment) on a memory resource
equal to*this, and the storage atp has not yet been deallocated.
5 Effects: A derived class shall implement this function to dispose of allocated storage.
6 Throws: Nothing.
virtual bool do_is_equal(const memory_resource& other) const noexcept = 0;
7 Returns: A derived class shall implement this function to returntrue if memory allocated from*this
can be deallocated fromother and vice-versa, otherwisefalse.
[Note 1: It is possible that the most-derived type ofother does not match the type of*this. For a derived
class D, an implementation of this function can immediately returnfalse if dynamic_cast<const D*>(&other)
== nullptr. —end note]
20.5.2.4 Equality [mem.res.eq]
bool operator==(const memory_resource& a, const memory_resource& b) noexcept;
1 Returns: &a == &b || a.is_equal(b).
20.5.3 Class template polymorphic_allocator [mem.poly.allocator.class]
20.5.3.1 General [mem.poly.allocator.class.general]
1 A specialization of class templatepmr::polymorphic_allocator meets theCpp17Allocator requirements
(16.4.4.6.1) if its template argument is acv-unqualified object type. Constructed with different memory
resources, different instances of the same specialization ofpmr::polymorphic_allocator can exhibit entirely
different allocation behavior. This runtime polymorphism allows objects that usepolymorphic_allocator
to behave as if they used different allocator types at run time even though they use the same static allocator
type.
2 A specialization of class templatepmr::polymorphic_allocator meets the allocator completeness require-
ments (16.4.4.6.2) if its template argument is acv-unqualified object type.
namespace std::pmr {
template<class Tp = byte> class polymorphic_allocator {
memory_resource* memory_rsrc; // exposition only
public:
using value_type = Tp;
// 20.5.3.2, constructors
polymorphic_allocator() noexcept;
polymorphic_allocator(memory_resource* r);
polymorphic_allocator(const polymorphic_allocator& other) = default;
template<class U>
polymorphic_allocator(const polymorphic_allocator<U>& other) noexcept;
polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;
// 20.5.3.3, member functions
Tp* allocate(size_t n);
void deallocate(Tp* p, size_t n);
void* allocate_bytes(size_t nbytes, size_t alignment = alignof(max_align_t));
void deallocate_bytes(void* p, size_t nbytes, size_t alignment = alignof(max_align_t));
template<class T> T* allocate_object(size_t n = 1);
template<class T> void deallocate_object(T* p, size_t n = 1);
§ 20.5.3.1 © ISO/IEC
721

===== PAGE 733 =====

Dxxxx
template<class T, class... CtorArgs> T* new_object(CtorArgs&&... ctor_args);
template<class T> void delete_object(T* p);
template<class T, class... Args>
void construct(T* p, Args&&... args);
template<class T>
void destroy(T* p);
polymorphic_allocator select_on_container_copy_construction() const;
memory_resource* resource() const;
// friends
friend bool operator==(const polymorphic_allocator& a,
const polymorphic_allocator& b) noexcept {
return *a.resource() == *b.resource();
}
};
}
20.5.3.2 Constructors [mem.poly.allocator.ctor]
polymorphic_allocator() noexcept;
1 Effects: Sets memory_rsrc to get_default_resource().
polymorphic_allocator(memory_resource* r);
2 Preconditions: r is non-null.
3 Effects: Sets memory_rsrc to r.
4 Throws: Nothing.
5 [Note 1: This constructor provides an implicit conversion frommemory_resource*. —end note]
template<class U> polymorphic_allocator(const polymorphic_allocator<U>& other) noexcept;
6 Effects: Sets memory_rsrc to other.resource().
20.5.3.3 Member functions [mem.poly.allocator.mem]
Tp* allocate(size_t n);
1 Effects: If numeric_limits<size_t>::max() / sizeof(Tp) < n, throws bad_array_new_length.
Otherwise equivalent to:
return static_cast<Tp*>(memory_rsrc->allocate(n * sizeof(Tp), alignof(Tp)));
void deallocate(Tp* p, size_t n);
2 Preconditions: p was allocated from a memory resourcex, equal to*memory_rsrc, usingx.allocate(n
* sizeof(Tp), alignof(Tp)).
3 Effects: Equivalent tomemory_rsrc->deallocate(p, n * sizeof(Tp), alignof(Tp)).
4 Throws: Nothing.
void* allocate_bytes(size_t nbytes, size_t alignment = alignof(max_align_t));
5 Effects: Equivalent to:return memory_rsrc->allocate(nbytes, alignment);
6 [Note 1: The return type isvoid* (rather than, e.g.,byte*) to support conversion to an arbitrary pointer type
U* by static_cast<U*>, thus facilitating construction of aU object in the allocated memory.—end note]
void deallocate_bytes(void* p, size_t nbytes, size_t alignment = alignof(max_align_t));
7 Effects: Equivalent tomemory_rsrc->deallocate(p, nbytes, alignment).
template<class T>
T* allocate_object(size_t n = 1);
8 Effects: Allocates memory suitable for holding an array ofn objects of typeT, as follows:
§ 20.5.3.3 © ISO/IEC
722

===== PAGE 734 =====

Dxxxx
—(8.1) if numeric_limits<size_t>::max() / sizeof(T) < n, throwsbad_array_new_length,
—(8.2) otherwise equivalent to:
return static_cast<T*>(allocate_bytes(n*sizeof(T), alignof(T)));
9 [Note 2: T is not deduced and must therefore be provided as a template argument.—end note]
template<class T>
void deallocate_object(T* p, size_t n = 1);
10 Effects: Equivalent todeallocate_bytes(p, n*sizeof(T), alignof(T)).
template<class T, class... CtorArgs>
T* new_object(CtorArgs&&... ctor_args);
11 Effects: Allocates and constructs an object of typeT, as follows.
Equivalent to:
T* p = allocate_object<T>();
try {
construct(p, std::forward<CtorArgs>(ctor_args)...);
} catch (...) {
deallocate_object(p);
throw;
}
return p;
12 [Note 3: T is not deduced and must therefore be provided as a template argument.—end note]
template<class T>
void delete_object(T* p);
13 Effects: Equivalent to:
destroy(p);
deallocate_object(p);
template<class T, class... Args>
void construct(T* p, Args&&... args);
14 Mandates: Uses-allocatorconstructionof Twithallocator *this(see20.2.8.2)andconstructorarguments
std::forward<Args>(args)... is well-formed.
15 Effects: Constructs a T object in the storage whose address is represented byp by uses-allocator
construction with allocator*this and constructor argumentsstd::forward<Args>(args)....
16 Throws: Nothing unless the constructor forT throws.
template<class T>
void destroy(T* p);
17 Effects: Equivalent top->~T().
polymorphic_allocator select_on_container_copy_construction() const;
18 Returns: polymorphic_allocator().
19 [Note 4: The memory resource is not propagated.—end note]
memory_resource* resource() const;
20 Returns: memory_rsrc.
20.5.3.4 Equality [mem.poly.allocator.eq]
template<class T1, class T2>
bool operator==(const polymorphic_allocator<T1>& a,
const polymorphic_allocator<T2>& b) noexcept;
1 Returns: *a.resource() == *b.resource().
§ 20.5.3.4 © ISO/IEC
723

===== PAGE 735 =====

Dxxxx
20.5.4 Access to program-wide memory_resource objects [mem.res.global]
memory_resource* new_delete_resource() noexcept;
1 Returns: A pointer to a static-duration object of a type derived frommemory_resource that can
serve as a resource for allocating memory using::operator new and ::operator delete. The same
value is returned every time this function is called. For a return valuep and a memory resourcer,
p->is_equal(r) returns &r == p.
memory_resource* null_memory_resource() noexcept;
2 Returns: A pointer to a static-duration object of a type derived frommemory_resource for which
allocate() always throwsbad_alloc and for whichdeallocate() has no effect. The same value is
returned every time this function is called. For a return valuep and a memory resourcer, p->is_-
equal(r) returns &r == p.
3 The default memory resource pointeris a pointer to a memory resource that is used by certain facilities when
an explicit memory resource is not supplied through the interface. Its initial value is the return value of
new_delete_resource().
memory_resource* set_default_resource(memory_resource* r) noexcept;
4 Effects: If r is non-null, sets the value of the default memory resource pointer tor, otherwise sets the
default memory resource pointer tonew_delete_resource().
5 Returns: The previous value of the default memory resource pointer.
6 Remarks: Calling theset_default_resource and get_default_resource functions shall not incur a
data race (6.10.2.2). A call to theset_default_resource function synchronizes with subsequent calls
to theset_default_resource and get_default_resource functions.
memory_resource* get_default_resource() noexcept;
7 Returns: The current value of the default memory resource pointer.
20.5.5 Pool resource classes [mem.res.pool]
20.5.5.1 Classes synchronized_pool_resource and unsynchronized_pool_resource
[mem.res.pool.overview]
1 The synchronized_pool_resource and unsynchronized_pool_resource classes (collectively calledpool
resource classes) are general-purpose memory resources having the following qualities:
—(1.1) Each resource frees its allocated memory on destruction, even ifdeallocate has not been called for
some of the allocated blocks.
—(1.2) A pool resource consists of a collection ofpools, serving requests for different block sizes. Each individual
pool manages a collection ofchunks that are in turn divided into blocks of uniform size, returned via
calls todo_allocate. Each call todo_allocate(size, alignment) is dispatched to the pool serving
the smallest blocks accommodating at leastsize bytes.
—(1.3) When a particular pool is exhausted, allocating a block from that pool results in the allocation of an
additional chunk of memory from theupstream allocator(supplied at construction), thus replenishing
the pool. With each successive replenishment, the chunk size obtained increases geometrically.
[Note 1: By allocating memory in chunks, the pooling strategy increases the chance that consecutive allocations
will be close together in memory.—end note]
—(1.4) Allocation requests that exceed the largest block size of any pool are fulfilled directly from the upstream
allocator.
—(1.5) A pool_options struct may be passed to the pool resource constructors to tune the largest block size
and the maximum chunk size.
2 A synchronized_pool_resource may be accessed from multiple threads without external synchronization
and may have thread-specific pools to reduce synchronization costs. Anunsynchronized_pool_resource
class may not be accessed from multiple threads simultaneously and thus avoids the cost of synchronization
entirely in single-threaded applications.
namespace std::pmr {
struct pool_options {
size_t max_blocks_per_chunk = 0;
§ 20.5.5.1 © ISO/IEC
724

===== PAGE 736 =====

Dxxxx
size_t largest_required_pool_block = 0;
};
class synchronized_pool_resource : public memory_resource {
public:
synchronized_pool_resource(const pool_options& opts, memory_resource* upstream);
synchronized_pool_resource()
: synchronized_pool_resource(pool_options(), get_default_resource()) {}
explicit synchronized_pool_resource(memory_resource* upstream)
: synchronized_pool_resource(pool_options(), upstream) {}
explicit synchronized_pool_resource(const pool_options& opts)
: synchronized_pool_resource(opts, get_default_resource()) {}
synchronized_pool_resource(const synchronized_pool_resource&) = delete;
virtual ~synchronized_pool_resource();
synchronized_pool_resource& operator=(const synchronized_pool_resource&) = delete;
void release();
memory_resource* upstream_resource() const;
pool_options options() const;
protected:
void* do_allocate(size_t bytes, size_t alignment) override;
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
bool do_is_equal(const memory_resource& other) const noexcept override;
};
class unsynchronized_pool_resource : public memory_resource {
public:
unsynchronized_pool_resource(const pool_options& opts, memory_resource* upstream);
unsynchronized_pool_resource()
: unsynchronized_pool_resource(pool_options(), get_default_resource()) {}
explicit unsynchronized_pool_resource(memory_resource* upstream)
: unsynchronized_pool_resource(pool_options(), upstream) {}
explicit unsynchronized_pool_resource(const pool_options& opts)
: unsynchronized_pool_resource(opts, get_default_resource()) {}
unsynchronized_pool_resource(const unsynchronized_pool_resource&) = delete;
virtual ~unsynchronized_pool_resource();
unsynchronized_pool_resource& operator=(const unsynchronized_pool_resource&) = delete;
void release();
memory_resource* upstream_resource() const;
pool_options options() const;
protected:
void* do_allocate(size_t bytes, size_t alignment) override;
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
bool do_is_equal(const memory_resource& other) const noexcept override;
};
}
20.5.5.2 pool_options data members [mem.res.pool.options]
1 The members ofpool_options comprise a set of constructor options for pool resources. The effect of each
option on the pool resource behavior is described below:
§ 20.5.5.2 © ISO/IEC
725

===== PAGE 737 =====

Dxxxx
size_t max_blocks_per_chunk;
2 The maximum number of blocks that will be allocated at once from the upstream memory resource
(20.5.6) to replenish a pool. If the value of max_blocks_per_chunk is zero or is greater than an
implementation-defined limit, that limit is used instead. The implementation may choose to use a
smaller value than is specified in this member and may use different values for different pools.
size_t largest_required_pool_block;
3 The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to
allocate a single block larger than this threshold will be allocated directly from the upstream memory
resource. If largest_required_pool_block is zero or is greater than an implementation-defined limit,
that limit is used instead. The implementation may choose a pass-through threshold larger than
specified in this member.
20.5.5.3 Constructors and destructors [mem.res.pool.ctor]
synchronized_pool_resource(const pool_options& opts, memory_resource* upstream);
unsynchronized_pool_resource(const pool_options& opts, memory_resource* upstream);
1 Preconditions: upstream is the address of a valid memory resource.
2 Effects: Constructs a pool resource object that will obtain memory fromupstream whenever the pool
resource is unable to satisfy a memory request from its own internal data structures. The resulting
object will hold a copy ofupstream, but will not own the resource to whichupstream points.
[Note 1: The intention is that calls to upstream->allocate() will be substantially fewer than calls to
this->allocate() in most cases. —end note]
The behavior of the pooling mechanism is tuned according to the value of theopts argument.
3 Throws: Nothing unlessupstream->allocate() throws. It is unspecified if, or under what conditions,
this constructor callsupstream->allocate().
virtual ~synchronized_pool_resource();
virtual ~unsynchronized_pool_resource();
4 Effects: Calls release().
20.5.5.4 Members [mem.res.pool.mem]
void release();
1 Effects: Calls upstream_resource()->deallocate() as necessary to release all allocated memory.
[Note 1: The memory is released back toupstream_resource() even if deallocate has not been called for
some of the allocated blocks.—end note]
memory_resource* upstream_resource() const;
2 Returns: The value of theupstream argument provided to the constructor of this object.
pool_options options() const;
3 Returns: The options that control the pooling behavior of this resource. The values in the returned
struct may differ from those supplied to the pool resource constructor in that values of zero will be
replaced with implementation-defined defaults, and sizes may be rounded to unspecified granularity.
void* do_allocate(size_t bytes, size_t alignment) override;
4 Effects: If the pool selected for a block of sizebytes is unable to satisfy the memory request from its
own internal data structures, it will callupstream_resource()->allocate() to obtain more memory.
If bytes is larger than that which the largest pool can handle, then memory will be allocated using
upstream_resource()->allocate().
5 Returns: A pointer to allocated storage (6.8.6.5.2) with a size of at leastbytes. The size and alignment
of the allocated memory shall meet the requirements for a class derived frommemory_resource (20.5.2).
6 Throws: Nothing unlessupstream_resource()->allocate() throws.
§ 20.5.5.4 © ISO/IEC
726

===== PAGE 738 =====

Dxxxx
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
7 Effects: Returns the memory atp to the pool. It is unspecified if, or under what circumstances, this
operation will result in a call toupstream_resource()->deallocate().
8 Throws: Nothing.
bool do_is_equal(const memory_resource& other) const noexcept override;
9 Returns: this == &other.
20.5.6 Class monotonic_buffer_resource [mem.res.monotonic.buffer]
20.5.6.1 General [mem.res.monotonic.buffer.general]
1 A monotonic_buffer_resource is a special-purpose memory resource intended for very fast memory alloca-
tions in situations where memory is used to build up a few objects and then is released all at once when the
memory resource object is destroyed.
namespace std::pmr {
class monotonic_buffer_resource : public memory_resource {
memory_resource* upstream_rsrc; // exposition only
void* current_buffer; // exposition only
size_t next_buffer_size; // exposition only
public:
explicit monotonic_buffer_resource(memory_resource* upstream);
monotonic_buffer_resource(size_t initial_size, memory_resource* upstream);
monotonic_buffer_resource(void* buffer, size_t buffer_size, memory_resource* upstream);
monotonic_buffer_resource()
: monotonic_buffer_resource(get_default_resource()) {}
explicit monotonic_buffer_resource(size_t initial_size)
: monotonic_buffer_resource(initial_size, get_default_resource()) {}
monotonic_buffer_resource(void* buffer, size_t buffer_size)
: monotonic_buffer_resource(buffer, buffer_size, get_default_resource()) {}
monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;
virtual ~monotonic_buffer_resource();
monotonic_buffer_resource& operator=(const monotonic_buffer_resource&) = delete;
void release();
memory_resource* upstream_resource() const;
protected:
void* do_allocate(size_t bytes, size_t alignment) override;
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
bool do_is_equal(const memory_resource& other) const noexcept override;
};
}
20.5.6.2 Constructors and destructor [mem.res.monotonic.buffer.ctor]
explicit monotonic_buffer_resource(memory_resource* upstream);
monotonic_buffer_resource(size_t initial_size, memory_resource* upstream);
1 Preconditions: upstream is the address of a valid memory resource.initial_size, if specified, is
greater than zero.
2 Effects: Sets upstream_rsrc to upstream and current_buffer to nullptr. If initial_size is
specified, setsnext_buffer_size to at leastinitial_size; otherwise setsnext_buffer_size to an
implementation-defined size.
§ 20.5.6.2 © ISO/IEC
727

===== PAGE 739 =====

Dxxxx
monotonic_buffer_resource(void* buffer, size_t buffer_size, memory_resource* upstream);
3 Preconditions: upstream is the address of a valid memory resource.buffer_size is no larger than the
number of bytes inbuffer.
4 Effects: Sets upstream_rsrc to upstream, current_buffer to buffer, and next_buffer_size to
buffer_size (but not less than 1), then increasesnext_buffer_size by an implementation-defined
growth factor (which need not be integral).
~monotonic_buffer_resource();
5 Effects: Calls release().
20.5.6.3 Members [mem.res.monotonic.buffer.mem]
void release();
1 Effects: Calls upstream_rsrc->deallocate() as necessary to release all allocated memory. Resets
current_buffer and next_buffer_size to their initial values at construction.
2 [Note 1: The memory is released back toupstream_rsrc even if some blocks that were allocated from*this
have not been deallocated from*this. —end note]
memory_resource* upstream_resource() const;
3 Returns: The value ofupstream_rsrc.
void* do_allocate(size_t bytes, size_t alignment) override;
4 Effects: If the unused space incurrent_buffer can fit a block with the specifiedbytes and alignment,
then allocate the return block fromcurrent_buffer; otherwise setcurrent_buffer to upstream_-
rsrc->allocate(n, m), wheren is not less thanmax(bytes, next_buffer_size) and m is not less
than alignment, and increasenext_buffer_size by an implementation-defined growth factor (which
need not be integral), then allocate the return block from the newly-allocatedcurrent_buffer.
5 Returns: A pointer to allocated storage (6.8.6.5.2) with a size of at leastbytes. The size and alignment
of the allocated memory shall meet the requirements for a class derived frommemory_resource (20.5.2).
6 Throws: Nothing unlessupstream_rsrc->allocate() throws.
void do_deallocate(void* p, size_t bytes, size_t alignment) override;
7 Effects: None.
8 Throws: Nothing.
9 Remarks: Memory used by this resource increases monotonically until its destruction.
bool do_is_equal(const memory_resource& other) const noexcept override;
10 Returns: this == &other.
20.6 Class template scoped_allocator_adaptor [allocator.adaptor]
20.6.1 Header <scoped_allocator> synopsis [allocator.adaptor.syn]
namespace std {
// class templatescoped_allocator_adaptor
template<class OuterAlloc, class... InnerAlloc>
class scoped_allocator_adaptor;
// 20.6.5, scoped allocator operators
template<class OuterA1, class OuterA2, class... InnerAllocs>
bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
}
1 The class templatescoped_allocator_adaptor is an allocator template that specifies an allocator resource
(the outer allocator) to be used by a container (as any other allocator does) and also specifies an inner allocator
resource to be passed to the constructor of every element within the container. This adaptor is instantiated
with one outer and zero or more inner allocator types. If instantiated with only one allocator type, the inner
allocator becomes thescoped_allocator_adaptor itself, thus using the same allocator resource for the
container and every element within the container and, if the elements themselves are containers, each of their
§ 20.6.1 © ISO/IEC
728

===== PAGE 740 =====

Dxxxx
elements recursively. If instantiated with more than one allocator, the first allocator is the outer allocator for
use by the container, the second allocator is passed to the constructors of the container’s elements, and, if
the elements themselves are containers, the third allocator is passed to the elements’ elements, and so on. If
containers are nested to a depth greater than the number of allocators, the last allocator is used repeatedly,
as in the single-allocator case, for any remaining recursions.
[Note 1: The scoped_allocator_adaptor is derived from the outer allocator type so it can be substituted for the
outer allocator type in most expressions.—end note]
namespace std {
template<class OuterAlloc, class... InnerAllocs>
class scoped_allocator_adaptor : public OuterAlloc {
private:
using OuterTraits = allocator_traits<OuterAlloc>; // exposition only
scoped_allocator_adaptor<InnerAllocs...> inner; // exposition only
public:
using outer_allocator_type = OuterAlloc;
using inner_allocator_type = see below ;
using value_type = OuterTraits::value_type;
using size_type = OuterTraits::size_type;
using difference_type = OuterTraits::difference_type;
using pointer = OuterTraits::pointer;
using const_pointer = OuterTraits::const_pointer;
using void_pointer = OuterTraits::void_pointer;
using const_void_pointer = OuterTraits::const_void_pointer;
using propagate_on_container_copy_assignment = see below ;
using propagate_on_container_move_assignment = see below ;
using propagate_on_container_swap = see below ;
using is_always_equal = see below ;
template<class Tp> struct rebind {
using other = scoped_allocator_adaptor<
OuterTraits::template rebind_alloc<Tp>, InnerAllocs...>;
};
scoped_allocator_adaptor();
template<class OuterA2>
scoped_allocator_adaptor(OuterA2&& outerAlloc,
const InnerAllocs&... innerAllocs) noexcept;
scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;
template<class OuterA2>
scoped_allocator_adaptor(
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& other) noexcept;
template<class OuterA2>
scoped_allocator_adaptor(
scoped_allocator_adaptor<OuterA2, InnerAllocs...>&& other) noexcept;
scoped_allocator_adaptor& operator=(const scoped_allocator_adaptor&) = default;
scoped_allocator_adaptor& operator=(scoped_allocator_adaptor&&) = default;
~scoped_allocator_adaptor();
inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;
outer_allocator_type& outer_allocator() noexcept;
const outer_allocator_type& outer_allocator() const noexcept;
pointer allocate(size_type n);
pointer allocate(size_type n, const_void_pointer hint);
§ 20.6.1 © ISO/IEC
729

===== PAGE 741 =====

Dxxxx
void deallocate(pointer p, size_type n);
size_type max_size() const;
template<class T, class... Args>
void construct(T* p, Args&&... args);
template<class T>
void destroy(T* p);
scoped_allocator_adaptor select_on_container_copy_construction() const;
};
template<class OuterAlloc, class... InnerAllocs>
scoped_allocator_adaptor(OuterAlloc, InnerAllocs...)
-> scoped_allocator_adaptor<OuterAlloc, InnerAllocs...>;
}
20.6.2 Member types [allocator.adaptor.types]
using inner_allocator_type = see below ;
1 Type: scoped_allocator_adaptor<OuterAlloc> if sizeof...(InnerAllocs) is zero; otherwise,
scoped_allocator_adaptor<InnerAllocs...>.
using propagate_on_container_copy_assignment = see below ;
2 Type: true_type if allocator_traits<A>::propagate_on_container_copy_assignment::value is
true for anyA in the set ofOuterAlloc and InnerAllocs...; otherwise,false_type.
using propagate_on_container_move_assignment = see below ;
3 Type: true_type if allocator_traits<A>::propagate_on_container_move_assignment::value is
true for anyA in the set ofOuterAlloc and InnerAllocs...; otherwise,false_type.
using propagate_on_container_swap = see below ;
4 Type: true_type if allocator_traits<A>::propagate_on_container_swap::value is true for any
A in the set ofOuterAlloc and InnerAllocs...; otherwise,false_type.
using is_always_equal = see below ;
5 Type: true_type if allocator_traits<A>::is_always_equal::value is true for everyA in the set
of OuterAlloc and InnerAllocs...; otherwise,false_type.
20.6.3 Constructors [allocator.adaptor.cnstr]
scoped_allocator_adaptor();
1 Effects: Value-initializes theOuterAlloc base class and theinner allocator object.
template<class OuterA2>
scoped_allocator_adaptor(OuterA2&& outerAlloc, const InnerAllocs&... innerAllocs) noexcept;
2 Constraints: is_constructible_v<OuterAlloc, OuterA2> is true.
3 Effects: Initializes theOuterAlloc base class withstd::forward<OuterA2>(outerAlloc) and inner
with innerAllocs... (hence recursively initializing each allocator within the adaptor with the corre-
sponding allocator from the argument list).
scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
4 Effects: Initializes each allocator within the adaptor with the corresponding allocator fromother.
scoped_allocator_adaptor(scoped_allocator_adaptor&& other) noexcept;
5 Effects: Move constructs each allocator within the adaptor with the corresponding allocator from
other.
§ 20.6.3 © ISO/IEC
730

===== PAGE 742 =====

Dxxxx
template<class OuterA2>
scoped_allocator_adaptor(
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& other) noexcept;
6 Constraints: is_constructible_v<OuterAlloc, const OuterA2&> is true.
7 Effects: Initializes each allocator within the adaptor with the corresponding allocator fromother.
template<class OuterA2>
scoped_allocator_adaptor(scoped_allocator_adaptor<OuterA2, InnerAllocs...>&& other) noexcept;
8 Constraints: is_constructible_v<OuterAlloc, OuterA2> is true.
9 Effects: Initializes each allocator within the adaptor with the corresponding allocator rvalue from
other.
20.6.4 Members [allocator.adaptor.members]
1 In theconstruct member functions,OUTERMOST(x) is OUTERMOST(x.outer_allocator()) if the expression
x.outer_allocator() is valid (13.10.3) and x otherwise; OUTERMOST_ALLOC_TRAITS(x) is allocator_-
traits<remove_reference_t<decltype(OUTERMOST(x))>>.
[Note 1: OUTERMOST(x) and OUTERMOST_ALLOC_TRAITS(x) are recursive operations. It is incumbent upon the definition
of outer_allocator() to ensure that the recursion terminates. It will terminate for all instantiations ofscoped_-
allocator_adaptor. —end note]
inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;
2 Returns: *this if sizeof...(InnerAllocs) is zero; otherwise,inner.
outer_allocator_type& outer_allocator() noexcept;
3 Returns: static_cast<OuterAlloc&>(*this).
const outer_allocator_type& outer_allocator() const noexcept;
4 Returns: static_cast<const OuterAlloc&>(*this).
pointer allocate(size_type n);
5 Returns: allocator_traits<OuterAlloc>::allocate(outer_allocator(), n).
pointer allocate(size_type n, const_void_pointer hint);
6 Returns: allocator_traits<OuterAlloc>::allocate(outer_allocator(), n, hint).
void deallocate(pointer p, size_type n) noexcept;
7 Effects: As if by:allocator_traits<OuterAlloc>::deallocate(outer_allocator(), p, n);
size_type max_size() const;
8 Returns: allocator_traits<OuterAlloc>::max_size(outer_allocator()).
template<class T, class... Args>
void construct(T* p, Args&&... args);
9 Effects: Equivalent to:
apply([p, this](auto&&... newargs) {
OUTERMOST_ALLOC_TRAITS(*this)::construct(
OUTERMOST(*this), p,
std::forward<decltype(newargs)>(newargs)...);
},
uses_allocator_construction_args<T>(inner_allocator(),
std::forward<Args>(args)...));
template<class T>
void destroy(T* p);
10 Effects: Calls OUTERMOST_ALLOC_TRAITS(*this)::destroy(OUTERMOST(*this), p).
§ 20.6.4 © ISO/IEC
731

===== PAGE 743 =====

Dxxxx
scoped_allocator_adaptor select_on_container_copy_construction() const;
11 Returns: A new scoped_allocator_adaptor object where each allocatora1 within the adaptor is
initialized withallocator_traits<A1>::select_on_container_copy_construction(a2), whereA1
is the type ofa1 and a2 is the corresponding allocator in*this.
20.6.5 Operators [scoped.adaptor.operators]
template<class OuterA1, class OuterA2, class... InnerAllocs>
bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
1 Returns: If sizeof...(InnerAllocs) is zero,
a.outer_allocator() == b.outer_allocator()
otherwise
a.outer_allocator() == b.outer_allocator() && a.inner_allocator() == b.inner_allocator()
§ 20.6.5 © ISO/IEC
732

===== PAGE 744 =====

Dxxxx
21 Metaprogramming library [meta]
21.1 General [meta.general]
1 This Clause describes metaprogramming facilities. These facilities are summarized in Table 51.
Table 51 — Metaprogramming library summary [tab:meta.summary]
Subclause Header
21.2 Integer sequences <utility>
21.3 Type traits <type_traits>
21.4 Reflection <meta>
21.5 Rational arithmetic <ratio>
21.2 Compile-time integer sequences [intseq]
21.2.1 General [intseq.general]
1 The library provides a class template that can represent an integer sequence. When used as an argument to
a function template the template parameter pack defining the sequence can be deduced and used in a pack
expansion.
[Note 1: The index_sequence alias template is provided for the common case of an integer sequence of typesize_t;
see also 22.4.6. —end note]
21.2.2 Class template integer_sequence [intseq.intseq]
namespace std {
template<class T, T... I> struct integer_sequence {
using value_type = T;
static constexpr size_t size() noexcept { return sizeof...(I); }
};
}
1 Mandates: T is an integer type.
21.2.3 Alias template make_integer_sequence [intseq.make]
template<class T, T N>
using make_integer_sequence = integer_sequence<T, see below >;
1 Mandates: N ≥0.
2 The alias templatemake_integer_sequence denotes a specialization ofinteger_sequence with N
constant template arguments. The type make_integer_sequence<T, N> is an alias for the type
integer_sequence<T, 0, 1, ... , N - 1>.
[Note 1: make_integer_sequence<int, 0> is an alias for the typeinteger_sequence<int>. —end note]
21.2.4 Structured binding support [intseq.binding]
template<class T, T... Values>
struct tuple_size<integer_sequence<T, Values...>>
: integral_constant<size_t, sizeof...(Values)> { };
template<size_t I, class T, T... Values>
struct tuple_element<I, integer_sequence<T, Values...>> {
using type = T;
};
template<size_t I, class T, T... Values>
struct tuple_element<I, const integer_sequence<T, Values...>> {
using type = T;
§ 21.2.4 © ISO/IEC
733

===== PAGE 745 =====

Dxxxx
};
1 Mandates: I <sizeof...(Values).
template<size_t I, class T, T... Values>
constexpr T get(integer_sequence<T, Values...>) noexcept;
2 Mandates: I <sizeof...(Values).
3 Returns: Values...[I].
21.3 Metaprogramming and type traits [type.traits]
21.3.1 General [type.traits.general]
1 Subclause 21.3 describes components used by C++ programs, particularly in templates, to support the widest
possible range of types, optimize template code usage, detect type related user errors, and perform type
inference and transformation at compile time. It includes type classification traits, type property inspection
traits, and type transformations. The type classification traits describe a complete taxonomy of all possible
C++ types, and state where in that taxonomy a given type belongs. The type property inspection traits allow
important characteristics of types or of combinations of types to be inspected. The type transformations
allow certain properties of types to be manipulated.
2 All functions specified in 21.3 are signal-safe (17.14.5).
21.3.2 Requirements [meta.rqmts]
1 A Cpp17UnaryTypeTraitdescribes a property of a type. It shall be a class template that takes one template
type argument and, optionally, additional arguments that help define the property being described. It shall
be Cpp17DefaultConstructible, Cpp17CopyConstructible, and publicly and unambiguously derived, directly or
indirectly, from itsbase characteristic, which is a specialization of the templateintegral_constant (21.3.4),
with the arguments to the templateintegral_constant determined by the requirements for the particular
property being described. The member names of the base characteristic shall not be hidden and shall be
unambiguously available in theCpp17UnaryTypeTrait.
2 A Cpp17BinaryTypeTraitdescribes a relationship between two types. It shall be a class template that takes
two template type arguments and, optionally, additional arguments that help define the relationship being
described. It shall beCpp17DefaultConstructible, Cpp17CopyConstructible, and publicly and unambiguously
derived, directly or indirectly, from itsbase characteristic, which is a specialization of the templateintegral_-
constant (21.3.4), with the arguments to the templateintegral_constant determined by the requirements
for the particular relationship being described. The member names of the base characteristic shall not be
hidden and shall be unambiguously available in theCpp17BinaryTypeTrait.
3 A Cpp17TransformationTraitmodifies a property of a type. It shall be a class template that takes one
template type argument and, optionally, additional arguments that help define the modification. It shall
define a publicly accessible nested type namedtype, which shall be a synonym for the modified type.
4 Unless otherwise specified, the behavior of a program that adds specializations for any of the templates
specified in 21.3 is undefined.
5 Unless otherwise specified, an incomplete type may be used to instantiate a template specified in 21.3. The
behavior of a program is undefined if
—(5.1) an instantiation of a template specified in 21.3 directly or indirectly depends on an incompletely-defined
object typeT, and
—(5.2) that instantiation could yield a different result wereT hypothetically completed.
21.3.3 Header <type_traits> synopsis [meta.type.synop]
// all freestanding
namespace std {
// 21.3.4, helper class
template<class T, T v> struct integral_constant;
template<bool B>
using bool_constant = integral_constant<bool, B>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;
§ 21.3.3 © ISO/IEC
734

===== PAGE 746 =====

Dxxxx
// 21.3.5, class templateconstant_wrapper
template<class T>
struct cw-fixed-value; // exposition only
template<cw-fixed-value X, class = typename decltype(X)::type >
struct constant_wrapper;
template<class T>
concept constexpr-param = // exposition only
requires { typename constant_wrapper<T::value>; };
struct cw-operators; // exposition only
template<cw-fixed-value X>
constexpr auto cw = constant_wrapper<X>{};
// 21.3.6.2, primary type categories
template<class T> struct is_void;
template<class T> struct is_null_pointer;
template<class T> struct is_integral;
template<class T> struct is_floating_point;
template<class T> struct is_array;
template<class T> struct is_pointer;
template<class T> struct is_lvalue_reference;
template<class T> struct is_rvalue_reference;
template<class T> struct is_member_object_pointer;
template<class T> struct is_member_function_pointer;
template<class T> struct is_enum;
template<class T> struct is_union;
template<class T> struct is_class;
template<class T> struct is_function;
template<class T> struct is_reflection;
// 21.3.6.3, composite type categories
template<class T> struct is_reference;
template<class T> struct is_arithmetic;
template<class T> struct is_fundamental;
template<class T> struct is_object;
template<class T> struct is_scalar;
template<class T> struct is_compound;
template<class T> struct is_member_pointer;
// 21.3.6.4, type properties
template<class T> struct is_const;
template<class T> struct is_volatile;
template<class T> struct is_trivially_copyable;
template<class T> struct is_standard_layout;
template<class T> struct is_empty;
template<class T> struct is_polymorphic;
template<class T> struct is_abstract;
template<class T> struct is_final;
template<class T> struct is_aggregate;
template<class T> struct is_consteval_only;
template<class T> struct is_signed;
template<class T> struct is_unsigned;
template<class T> struct is_bounded_array;
template<class T> struct is_unbounded_array;
template<class T> struct is_scoped_enum;
template<class T, class... Args> struct is_constructible;
template<class T> struct is_default_constructible;
template<class T> struct is_copy_constructible;
template<class T> struct is_move_constructible;
§ 21.3.3 © ISO/IEC
735

===== PAGE 747 =====

Dxxxx
template<class T, class U> struct is_assignable;
template<class T> struct is_copy_assignable;
template<class T> struct is_move_assignable;
template<class T, class U> struct is_swappable_with;
template<class T> struct is_swappable;
template<class T> struct is_destructible;
template<class T, class... Args> struct is_trivially_constructible;
template<class T> struct is_trivially_default_constructible;
template<class T> struct is_trivially_copy_constructible;
template<class T> struct is_trivially_move_constructible;
template<class T, class U> struct is_trivially_assignable;
template<class T> struct is_trivially_copy_assignable;
template<class T> struct is_trivially_move_assignable;
template<class T> struct is_trivially_destructible;
template<class T, class... Args> struct is_nothrow_constructible;
template<class T> struct is_nothrow_default_constructible;
template<class T> struct is_nothrow_copy_constructible;
template<class T> struct is_nothrow_move_constructible;
template<class T, class U> struct is_nothrow_assignable;
template<class T> struct is_nothrow_copy_assignable;
template<class T> struct is_nothrow_move_assignable;
template<class T, class U> struct is_nothrow_swappable_with;
template<class T> struct is_nothrow_swappable;
template<class T> struct is_nothrow_destructible;
template<class T> struct is_implicit_lifetime;
template<class T> struct has_virtual_destructor;
template<class T> struct has_unique_object_representations;
template<class T, class U> struct reference_constructs_from_temporary;
template<class T, class U> struct reference_converts_from_temporary;
// 21.3.7, type property queries
template<class T> struct alignment_of;
template<class T> struct rank;
template<class T, unsigned I = 0> struct extent;
// 21.3.8, type relations
template<class T, class U> struct is_same;
template<class Base, class Derived> struct is_base_of;
template<class Base, class Derived> struct is_virtual_base_of;
template<class From, class To> struct is_convertible;
template<class From, class To> struct is_nothrow_convertible;
template<class T, class U> struct is_layout_compatible;
template<class Base, class Derived> struct is_pointer_interconvertible_base_of;
template<class Fn, class... ArgTypes> struct is_invocable;
template<class R, class Fn, class... ArgTypes> struct is_invocable_r;
template<class Fn, class... ArgTypes> struct is_nothrow_invocable;
template<class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;
template<class Fn, class Tuple> struct is_applicable;
template<class Fn, class Tuple> struct is_nothrow_applicable;
§ 21.3.3 © ISO/IEC
736

===== PAGE 748 =====

Dxxxx
// 21.3.9.2, const-volatile modifications
template<class T> struct remove_const;
template<class T> struct remove_volatile;
template<class T> struct remove_cv;
template<class T> struct add_const;
template<class T> struct add_volatile;
template<class T> struct add_cv;
template<class T>
using remove_const_t = remove_const<T>::type;
template<class T>
using remove_volatile_t = remove_volatile<T>::type;
template<class T>
using remove_cv_t = remove_cv<T>::type;
template<class T>
using add_const_t = add_const<T>::type;
template<class T>
using add_volatile_t = add_volatile<T>::type;
template<class T>
using add_cv_t = add_cv<T>::type;
// 21.3.9.3, reference modifications
template<class T> struct remove_reference;
template<class T> struct add_lvalue_reference;
template<class T> struct add_rvalue_reference;
template<class T>
using remove_reference_t = remove_reference<T>::type;
template<class T>
using add_lvalue_reference_t = add_lvalue_reference<T>::type;
template<class T>
using add_rvalue_reference_t = add_rvalue_reference<T>::type;
// 21.3.9.4, sign modifications
template<class T> struct make_signed;
template<class T> struct make_unsigned;
template<class T>
using make_signed_t = make_signed<T>::type;
template<class T>
using make_unsigned_t = make_unsigned<T>::type;
// 21.3.9.5, array modifications
template<class T> struct remove_extent;
template<class T> struct remove_all_extents;
template<class T>
using remove_extent_t = remove_extent<T>::type;
template<class T>
using remove_all_extents_t = remove_all_extents<T>::type;
// 21.3.9.6, pointer modifications
template<class T> struct remove_pointer;
template<class T> struct add_pointer;
template<class T>
using remove_pointer_t = remove_pointer<T>::type;
template<class T>
using add_pointer_t = add_pointer<T>::type;
// 21.3.9.7, other transformations
template<class T> struct type_identity;
template<class T> struct remove_cvref;
template<class T> struct decay;
§ 21.3.3 © ISO/IEC
737

===== PAGE 749 =====

Dxxxx
template<bool, class T = void> struct enable_if;
template<bool, class T, class F> struct conditional;
template<class... T> struct common_type;
template<class T, class U, template<class> class TQual, template<class> class UQual>
struct basic_common_reference { };
template<class... T> struct common_reference;
template<class T> struct underlying_type;
template<class Fn, class... ArgTypes> struct invoke_result;
template<class Fn, class Tuple> struct apply_result;
template<class T> struct unwrap_reference;
template<class T> struct unwrap_ref_decay;
template<class T>
using type_identity_t = type_identity<T>::type;
template<class T>
using remove_cvref_t = remove_cvref<T>::type;
template<class T>
using decay_t = decay<T>::type;
template<bool B, class T = void>
using enable_if_t = enable_if<B, T>::type;
template<bool B, class T, class F>
using conditional_t = conditional<B, T, F>::type;
template<class... T>
using common_type_t = common_type<T...>::type;
template<class... T>
using common_reference_t = common_reference<T...>::type;
template<class T>
using underlying_type_t = underlying_type<T>::type;
template<class Fn, class... ArgTypes>
using invoke_result_t = invoke_result<Fn, ArgTypes...>::type;
template<class Fn, class Tuple>
using apply_result_t = apply_result<Fn, Tuple>::type;
template<class T>
using unwrap_reference_t = unwrap_reference<T>::type;
template<class T>
using unwrap_ref_decay_t = unwrap_ref_decay<T>::type;
template<class...>
using void_t = void;
// 21.3.10, logical operator traits
template<class... B> struct conjunction;
template<class... B> struct disjunction;
template<class B> struct negation;
// 21.3.6.2, primary type categories
template<class T>
constexpr bool is_void_v = is_void<T>::value;
template<class T>
constexpr bool is_null_pointer_v = is_null_pointer<T>::value;
template<class T>
constexpr bool is_integral_v = is_integral<T>::value;
template<class T>
constexpr bool is_floating_point_v = is_floating_point<T>::value;
template<class T>
constexpr bool is_array_v = is_array<T>::value;
template<class T>
constexpr bool is_pointer_v = is_pointer<T>::value;
template<class T>
constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;
template<class T>
constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;
template<class T>
constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;
§ 21.3.3 © ISO/IEC
738

===== PAGE 750 =====

Dxxxx
template<class T>
constexpr bool is_member_function_pointer_v = is_member_function_pointer<T>::value;
template<class T>
constexpr bool is_enum_v = is_enum<T>::value;
template<class T>
constexpr bool is_union_v = is_union<T>::value;
template<class T>
constexpr bool is_class_v = is_class<T>::value;
template<class T>
constexpr bool is_function_v = is_function<T>::value;
template<class T>
constexpr bool is_reflection_v = is_reflection<T>::value;
// 21.3.6.3, composite type categories
template<class T>
constexpr bool is_reference_v = is_reference<T>::value;
template<class T>
constexpr bool is_arithmetic_v = is_arithmetic<T>::value;
template<class T>
constexpr bool is_fundamental_v = is_fundamental<T>::value;
template<class T>
constexpr bool is_object_v = is_object<T>::value;
template<class T>
constexpr bool is_scalar_v = is_scalar<T>::value;
template<class T>
constexpr bool is_compound_v = is_compound<T>::value;
template<class T>
constexpr bool is_member_pointer_v = is_member_pointer<T>::value;
// 21.3.6.4, type properties
template<class T>
constexpr bool is_const_v = is_const<T>::value;
template<class T>
constexpr bool is_volatile_v = is_volatile<T>::value;
template<class T>
constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;
template<class T>
constexpr bool is_standard_layout_v = is_standard_layout<T>::value;
template<class T>
constexpr bool is_empty_v = is_empty<T>::value;
template<class T>
constexpr bool is_polymorphic_v = is_polymorphic<T>::value;
template<class T>
constexpr bool is_abstract_v = is_abstract<T>::value;
template<class T>
constexpr bool is_final_v = is_final<T>::value;
template<class T>
constexpr bool is_aggregate_v = is_aggregate<T>::value;
template<class T>
constexpr bool is_consteval_only_v = is_consteval_only<T>::value;
template<class T>
constexpr bool is_signed_v = is_signed<T>::value;
template<class T>
constexpr bool is_unsigned_v = is_unsigned<T>::value;
template<class T>
constexpr bool is_bounded_array_v = is_bounded_array<T>::value;
template<class T>
constexpr bool is_unbounded_array_v = is_unbounded_array<T>::value;
template<class T>
constexpr bool is_scoped_enum_v = is_scoped_enum<T>::value;
template<class T, class... Args>
constexpr bool is_constructible_v = is_constructible<T, Args...>::value;
template<class T>
constexpr bool is_default_constructible_v = is_default_constructible<T>::value;
§ 21.3.3 © ISO/IEC
739

===== PAGE 751 =====

Dxxxx
template<class T>
constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;
template<class T>
constexpr bool is_move_constructible_v = is_move_constructible<T>::value;
template<class T, class U>
constexpr bool is_assignable_v = is_assignable<T, U>::value;
template<class T>
constexpr bool is_copy_assignable_v = is_copy_assignable<T>::value;
template<class T>
constexpr bool is_move_assignable_v = is_move_assignable<T>::value;
template<class T, class U>
constexpr bool is_swappable_with_v = is_swappable_with<T, U>::value;
template<class T>
constexpr bool is_swappable_v = is_swappable<T>::value;
template<class T>
constexpr bool is_destructible_v = is_destructible<T>::value;
template<class T, class... Args>
constexpr bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;
template<class T>
constexpr bool is_trivially_default_constructible_v
= is_trivially_default_constructible<T>::value;
template<class T>
constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<T>::value;
template<class T>
constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<T>::value;
template<class T, class U>
constexpr bool is_trivially_assignable_v = is_trivially_assignable<T, U>::value;
template<class T>
constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<T>::value;
template<class T>
constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<T>::value;
template<class T>
constexpr bool is_trivially_destructible_v = is_trivially_destructible<T>::value;
template<class T, class... Args>
constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<T, Args...>::value;
template<class T>
constexpr bool is_nothrow_default_constructible_v
= is_nothrow_default_constructible<T>::value;
template<class T>
constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<T>::value;
template<class T>
constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<T>::value;
template<class T, class U>
constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<T, U>::value;
template<class T>
constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<T>::value;
template<class T>
constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<T>::value;
template<class T, class U>
constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<T, U>::value;
template<class T>
constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;
template<class T>
constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;
template<class T>
constexpr bool is_implicit_lifetime_v = is_implicit_lifetime<T>::value;
template<class T>
constexpr bool has_virtual_destructor_v = has_virtual_destructor<T>::value;
template<class T>
constexpr bool has_unique_object_representations_v
= has_unique_object_representations<T>::value;
template<class T, class U>
constexpr bool reference_constructs_from_temporary_v
= reference_constructs_from_temporary<T, U>::value;
§ 21.3.3 © ISO/IEC
740

===== PAGE 752 =====

Dxxxx
template<class T, class U>
constexpr bool reference_converts_from_temporary_v
= reference_converts_from_temporary<T, U>::value;
// 21.3.7, type property queries
template<class T>
constexpr size_t alignment_of_v = alignment_of<T>::value;
template<class T>
constexpr size_t rank_v = rank<T>::value;
template<class T, unsigned I = 0>
constexpr size_t extent_v = extent<T, I>::value;
// 21.3.8, type relations
template<class T, class U>
constexpr bool is_same_v = is_same<T, U>::value;
template<class Base, class Derived>
constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;
template<class Base, class Derived>
constexpr bool is_virtual_base_of_v = is_virtual_base_of<Base, Derived>::value;
template<class From, class To>
constexpr bool is_convertible_v = is_convertible<From, To>::value;
template<class From, class To>
constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<From, To>::value;
template<class T, class U>
constexpr bool is_layout_compatible_v = is_layout_compatible<T, U>::value;
template<class Base, class Derived>
constexpr bool is_pointer_interconvertible_base_of_v
= is_pointer_interconvertible_base_of<Base, Derived>::value;
template<class Fn, class... ArgTypes>
constexpr bool is_invocable_v = is_invocable<Fn, ArgTypes...>::value;
template<class R, class Fn, class... ArgTypes>
constexpr bool is_invocable_r_v = is_invocable_r<R, Fn, ArgTypes...>::value;
template<class Fn, class... ArgTypes>
constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<Fn, ArgTypes...>::value;
template<class R, class Fn, class... ArgTypes>
constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;
template<class Fn, class Tuple>
constexpr bool is_applicable_v = is_applicable<Fn, Tuple>::value;
template<class Fn, class Tuple>
constexpr bool is_nothrow_applicable_v = is_nothrow_applicable<Fn, Tuple>::value;
// 21.3.10, logical operator traits
template<class... B>
constexpr bool conjunction_v = conjunction<B...>::value;
template<class... B>
constexpr bool disjunction_v = disjunction<B...>::value;
template<class B>
constexpr bool negation_v = negation<B>::value;
// 21.3.11, member relationships
template<class S, class M>
constexpr bool is_pointer_interconvertible_with_class(M S::*m) noexcept;
template<class S1, class S2, class M1, class M2>
constexpr bool is_corresponding_member(M1 S1::*m1, M2 S2::*m2) noexcept;
// 21.3.12, constant evaluation context
constexpr bool is_constant_evaluated() noexcept;
consteval bool is_within_lifetime(const auto*) noexcept;
}
21.3.4 Helper classes [meta.help]
namespace std {
template<class T, T v> struct integral_constant {
static constexpr T value = v;
§ 21.3.4 © ISO/IEC
741

===== PAGE 753 =====

Dxxxx
using value_type = T;
using type = integral_constant<T, v>;
constexpr operator value_type() const noexcept { return value; }
constexpr value_type operator()() const noexcept { return value; }
};
}
1 The class templateintegral_constant, alias templatebool_constant, and its associatedtypedef-names
true_type and false_type are used as base classes to define the interface for various type traits.
21.3.5 Class template constant_wrapper [const.wrap.class]
namespace std {
template<class T>
struct cw-fixed-value { // exposition only
using type = T; // exposition only
constexpr cw-fixed-value(type v) noexcept : data(v) {}
T data; // exposition only
};
template<class T, size_t Extent>
struct cw-fixed-value<T[Extent]> { // exposition only
using type = T[Extent]; // exposition only
constexpr cw-fixed-value(T (&arr)[Extent]) noexcept;
T data[Extent]; // exposition only
};
template<class T, size_t Extent>
cw-fixed-value(T (&)[Extent]) -> cw-fixed-value<T[Extent]>; // exposition only
struct cw-operators { // exposition only
// unary operators
template<constexpr-param T>
friend constexpr auto operator+(T) noexcept -> constant_wrapper<(+T::value)>
{ return {}; }
template<constexpr-param T>
friend constexpr auto operator-(T) noexcept -> constant_wrapper<(-T::value)>
{ return {}; }
template<constexpr-param T>
friend constexpr auto operator~(T) noexcept -> constant_wrapper<(~T::value)>
{ return {}; }
template<constexpr-param T>
friend constexpr auto operator!(T) noexcept -> constant_wrapper<(!T::value)>
{ return {}; }
template<constexpr-param T>
friend constexpr auto operator&(T) noexcept -> constant_wrapper<(&T::value)>
{ return {}; }
template<constexpr-param T>
friend constexpr auto operator*(T) noexcept -> constant_wrapper<(*T::value)>
{ return {}; }
// binary operators
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator+(L, R) noexcept -> constant_wrapper<(L::value + R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator-(L, R) noexcept -> constant_wrapper<(L::value - R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator*(L, R) noexcept -> constant_wrapper<(L::value * R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator/(L, R) noexcept -> constant_wrapper<(L::value / R::value)>
{ return {}; }
§ 21.3.5 © ISO/IEC
742

===== PAGE 754 =====

Dxxxx
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator%(L, R) noexcept -> constant_wrapper<(L::value % R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator<<(L, R) noexcept -> constant_wrapper<(L::value << R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator>>(L, R) noexcept -> constant_wrapper<(L::value >> R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator&(L, R) noexcept -> constant_wrapper<(L::value & R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator|(L, R) noexcept -> constant_wrapper<(L::value | R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator^(L, R) noexcept -> constant_wrapper<(L::value ^ R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
requires (!is_constructible_v<bool, decltype(L::value)> ||
!is_constructible_v<bool, decltype(R::value)>)
friend constexpr auto operator&&(L, R) noexcept
-> constant_wrapper<(L::value && R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
requires (!is_constructible_v<bool, decltype(L::value)> ||
!is_constructible_v<bool, decltype(R::value)>)
friend constexpr auto operator||(L, R) noexcept
-> constant_wrapper<(L::value || R::value)>
{ return {}; }
// comparisons
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator<=>(L, R) noexcept
-> constant_wrapper<(L::value <=> R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator<(L, R) noexcept -> constant_wrapper<(L::value < R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator<=(L, R) noexcept -> constant_wrapper<(L::value <= R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator==(L, R) noexcept -> constant_wrapper<(L::value == R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator!=(L, R) noexcept -> constant_wrapper<(L::value != R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator>(L, R) noexcept -> constant_wrapper<(L::value > R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator>=(L, R) noexcept -> constant_wrapper<(L::value >= R::value)>
{ return {}; }
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator,(L, R) noexcept = delete;
template<constexpr-param L, constexpr-param R>
friend constexpr auto operator->*(L, R) noexcept -> constant_wrapper<L::value->*(R::value)>
{ return {}; }
§ 21.3.5 © ISO/IEC
743

===== PAGE 755 =====

Dxxxx
// call and index
template<constexpr-param T, constexpr-param ... Args>
constexpr auto operator()(this T, Args...) noexcept
requires requires { constant_wrapper<T::value(Args::value...)>(); }
{ return constant_wrapper<T::value(Args::value...)>{}; }
template<constexpr-param T, constexpr-param ... Args>
constexpr auto operator[](this T, Args...) noexcept
-> constant_wrapper<(T::value[Args::value...])>
{ return {}; }
// pseudo-mutators
template<constexpr-param T>
constexpr auto operator++(this T) noexcept
-> constant_wrapper<++Y> { return {}; }
template<constexpr-param T>
constexpr auto operator++(this T, int) noexcept
-> constant_wrapper<Y++> { return {}; }
template<constexpr-param T>
constexpr auto operator--(this T) noexcept
-> constant_wrapper<--Y> { return {}; }
template<constexpr-param T>
constexpr auto operator--(this T, int) noexcept
-> constant_wrapper<Y--> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator+=(T, R) noexcept
-> constant_wrapper<(T::value += R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator-=(T, R) noexcept
-> constant_wrapper<(T::value -= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator*=(T, R) noexcept
-> constant_wrapper<(T::value *= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator/=(T, R) noexcept
-> constant_wrapper<(T::value /= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator%=(T, R) noexcept
-> constant_wrapper<(T::value %= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator&=(T, R) noexcept
-> constant_wrapper<(T::value &= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator|=(T, R) noexcept
-> constant_wrapper<(T::value |= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator^=(T, R) noexcept
-> constant_wrapper<(T::value ^= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator<<=(T, R) noexcept
-> constant_wrapper<(T::value <<= R::value)> { return {}; }
template<constexpr-param T, constexpr-param R>
constexpr auto operator>>=(T, R) noexcept
-> constant_wrapper<(T::value >>= R::value)> { return {}; }
};
template<cw-fixed-value X, class>
struct constant_wrapper : cw-operators {
static constexpr const auto & value = X.data ;
using type = constant_wrapper;
using value_type = decltype(X)::type ;
§ 21.3.5 © ISO/IEC
744

===== PAGE 756 =====

Dxxxx
template<constexpr-param R>
constexpr auto operator=(R) const noexcept
-> constant_wrapper<X = R::value> { return {}; }
constexpr operator decltype(auto)() const noexcept { return value; }
};
}
1 Theclasstemplate constant_wrapperaidsinmetaprogrammingbyensuringthattheevaluationofexpressions
comprised entirely ofconstant_wrapper are core constant expressions (7.7), regardless of the context in
which they appear. In particular, this enables use ofconstant_wrapper values that are passed as arguments
to constexpr functions to be used in constant expressions.
2 [Note 1: The unnamed second template parameter toconstant_wrapper is present to aid argument-dependent
lookup (6.5.4) in finding overloads for whichconstant_wrapper’s wrapped value is a suitable argument, but for which
the constant_wrapper itself is not. —end note]
3 [Example 1:
constexpr auto initial_phase(auto quantity_1, auto quantity_2) {
return quantity_1 + quantity_2;
}
constexpr auto middle_phase(auto tbd) {
return tbd;
}
void final_phase(auto gathered, auto available) {
if constexpr (gathered == available)
std::cout << "Profit!\n";
}
void impeccable_underground_planning() {
auto gathered_quantity = middle_phase(initial_phase(std::cw<42>, std::cw<13>));
static_assert(gathered_quantity == 55);
auto all_available = std::cw<55>;
final_phase(gathered_quantity, all_available);
}
void deeply_flawed_underground_planning() {
constexpr auto gathered_quantity = middle_phase(initial_phase(42, 13));
constexpr auto all_available = 55;
final_phase(gathered_quantity, all_available); // error: gathered == available
// is not a constant expression
}
—end example]
constexpr cw-fixed-value (T (&arr)[Extent]) noexcept;
4 Effects: Initialize elements ofdata with corresponding elements ofarr.
21.3.6 Unary type traits [meta.unary]
21.3.6.1 General [meta.unary.general]
1 Subclause 21.3.6 contains templates that may be used to query the properties of a type at compile time.
2 Each of these templates shall be aCpp17UnaryTypeTrait(21.3.2) with a base characteristic oftrue_type if
the corresponding condition istrue, otherwisefalse_type.
21.3.6.2 Primary type categories [meta.unary.cat]
1 The primary type categories specified in Table 52 correspond to the descriptions given in subclause 6.9 of the
C++ standard.
2 For any given typeT, the result of applying one of these templates toT and tocv T shall yield the same
result.
3 [Note 1: For any given typeT, exactly one of the primary type categories has avalue member that evaluates totrue.
—end note]
§ 21.3.6.2 © ISO/IEC
745

===== PAGE 757 =====

Dxxxx
Table 52 — Primary type category predicates [tab:meta.unary.cat]
Template Condition Comments
template<class T>
struct is_void;
T is void
template<class T>
struct is_null_pointer;
T is nullptr_t (6.9.2)
template<class T>
struct is_integral;
T is an integral type (6.9.2)
template<class T>
struct is_floating_point;
T is a floating-point
type (6.9.2)
template<class T>
struct is_array;
T is an array type (6.9.4) of
known or unknown extent
Class template
array (23.3.3) is not an
array type.
template<class T>
struct is_pointer;
T is a pointer type (6.9.4) Includes pointers to
functions but not pointers
to non-static members.
template<class T>
struct is_lvalue_reference;
T is an lvalue reference
type (9.3.4.3)
template<class T>
struct is_rvalue_reference;
T is an rvalue reference
type (9.3.4.3)
template<class T>
struct is_member_object_pointer;
T is a pointer to data
member
template<class T>
struct
is_member_function_pointer;
T is a pointer to member
function
template<class T>
struct is_enum;
T is an enumeration
type (6.9.4)
template<class T>
struct is_union;
T is a union type (6.9.4)
template<class T>
struct is_class;
T is a non-union class
type (6.9.4)
template<class T>
struct is_function;
T is a function type (6.9.4)
template<class T>
struct is_reflection;
T is
std::meta::info (6.9.2)
21.3.6.3 Composite type traits [meta.unary.comp]
1 The templates specified in Table 53 provide convenient compositions of the primary type categories, corre-
sponding to the descriptions given in subclause 6.9.
2 For any given typeT, the result of applying one of these templates toT and tocv T shall yield the same
result.
§ 21.3.6.3 © ISO/IEC
746

===== PAGE 758 =====

Dxxxx
Table 53 — Composite type category predicates [tab:meta.unary.comp]
Template Condition Comments
template<class T>
struct is_reference;
T is an lvalue reference or
an rvalue reference
template<class T>
struct is_arithmetic;
T is an arithmetic
type (6.9.2)
template<class T>
struct is_fundamental;
T is a fundamental
type (6.9.2)
template<class T>
struct is_object;
T is an object type (6.9.1)
template<class T>
struct is_scalar;
T is a scalar type (6.9.1)
template<class T>
struct is_compound;
T is a compound
type (6.9.4)
template<class T>
struct is_member_pointer;
T is a pointer-to-member
type (6.9.4)
21.3.6.4 Type properties [meta.unary.prop]
1 The templates specified in Table 54 provide access to some of the more important properties of types.
2 It is unspecified whether the library defines any full or partial specializations of any of these templates.
3 For all of the class templatesX declared in this subclause, instantiating that template with a template-
argument that is a class template specialization may result in the implicit instantiation of the template
argument if and only if the semantics ofX require that the argument is a complete type.
4 For the purpose of defining the templates in this subclause, a function call expressiondeclval<T>() for any
type T is considered to be a trivial (D.13, 11.4.4) function call that is not an odr-use (6.3) ofdeclval in the
context of the corresponding definition notwithstanding the restrictions of 22.2.6.
5 For the purpose of defining the templates in this subclause, letVAL<T> for some typeT be an expression
defined as follows:
—(5.1) If T is a reference or function type,VAL<T> is an expression with the same type and value category as
declval<T>().
—(5.2) Otherwise, VAL<T> is a prvalue that initially has typeT.
[Note 1: If T is cv-qualified, the cv-qualification is subject to adjustment (7.2.2).—end note]
Table 54 — Type property predicates [tab:meta.unary.prop]
Template Condition Preconditions
template<class T>
struct is_const;
T is const-qualified (6.9.5)
template<class T>
struct is_volatile;
T is
volatile-qualified (6.9.5)
template<class T>
struct is_trivially_copyable;
T is a trivially copyable
type (6.9.1)
remove_all_extents_-
t<T> shall be a complete
type orcv void.
template<class T>
struct is_standard_layout;
T is a standard-layout
type (6.9.1)
remove_all_extents_-
t<T> shall be a complete
type orcv void.
§ 21.3.6.4 © ISO/IEC
747

===== PAGE 759 =====

Dxxxx
Table 54 — Type property predicates (continued)
Template Condition Preconditions
template<class T>
struct is_empty;
T is a class type, but not a
union type, with no
non-static data members
other than subobjects of
zero size, no virtual
member functions, no
virtual base classes, and no
base classB for which
is_empty_v<B> is false.
If T is a non-union class
type, T shall be a complete
type.
template<class T>
struct is_polymorphic;
T is a polymorphic
class (11.7.3)
If T is a non-union class
type, T shall be a complete
type.
template<class T>
struct is_abstract;
T is an abstract
class (11.7.4)
If T is a non-union class
type, T shall be a complete
type.
template<class T>
struct is_final;
T is a class type marked
with the
class-property-specifier
final (11.1).
[Note 2: A union is a class
type that can be marked
with final. —end note]
If T is a class type,T shall
be a complete type.
template<class T>
struct is_aggregate;
T is an aggregate
type (9.5.2)
T shall be an array type, a
complete type, orcv void.
template<class T>
struct is_consteval_only;
T is consteval-only (6.9.1) remove_all_extents_-
t<T> shall be a complete
type orcv void.
template<class T>
struct is_signed;
If is_arithmetic_v<T> is
true, the same result as
T(-1) < T(0); otherwise,
false
template<class T>
struct is_unsigned;
If is_arithmetic_v<T> is
true, the same result as
T(0) < T(-1); otherwise,
false
template<class T>
struct is_bounded_array;
T is an array type of
known bound (9.3.4.5)
template<class T>
struct is_unbounded_array;
T is an array type of
unknown bound (9.3.4.5)
template<class T>
struct is_scoped_enum;
T is a scoped
enumeration (9.8.1)
template<class T, class... Args>
struct is_constructible;
For a function typeT or
for acv void type T,
is_constructible_v<T,
Args...> is false,
otherwise see below
T and all types in the
template parameter pack
Args shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct is_default_constructible;
is_constructible_v<T>
is true.
T shall be a complete type,
cv void, or an array of
unknown bound.
§ 21.3.6.4 © ISO/IEC
748

===== PAGE 760 =====

Dxxxx
Table 54 — Type property predicates (continued)
Template Condition Preconditions
template<class T>
struct is_copy_constructible;
For a referenceable type
T (3.45), the same result as
is_constructible_v<T,
const T&>, otherwise
false.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct is_move_constructible;
For a referenceable typeT,
the same result as
is_constructible_v<T,
T&&>, otherwisefalse.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T, class U>
struct is_assignable;
The expression
declval<T>() =
declval<U>() is
well-formed when treated
as an unevaluated
operand (7.2.3). Access
checking is performed as if
in a context unrelated toT
and U. Only the validity of
the immediate context of
the assignment expression
is considered.
[Note 3: The compilation of
the expression can result in
side effects such as the
instantiation of class
template specializations and
function template
specializations, the
generation of
implicitly-defined functions,
and so on. Such side effects
are not in the “immediate
context” and can result in
the program being ill-formed.
—end note]
T and U shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct is_copy_assignable;
For a referenceable typeT,
the same result as
is_assignable_v<T&,
const T&>, otherwise
false.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct is_move_assignable;
For a referenceable typeT,
the same result as
is_assignable_v<T&,
T&&>, otherwisefalse.
T shall be a complete type,
cv void, or an array of
unknown bound.
§ 21.3.6.4 © ISO/IEC
749

===== PAGE 761 =====

Dxxxx
Table 54 — Type property predicates (continued)
Template Condition Preconditions
template<class T, class U>
struct is_swappable_with;
The expressions
swap(declval<T>(),
declval<U>()) and
swap(declval<U>(),
declval<T>()) are each
well-formed when treated
as an unevaluated
operand (7.2.3) in an
overload-resolution context
for swappable
values (16.4.4.3). Access
checking is performed as if
in a context unrelated toT
and U. Only the validity of
the immediate context of
the swap expressions is
considered.
[Note 4: The compilation of
the expressions can result in
side effects such as the
instantiation of class
template specializations and
function template
specializations, the
generation of
implicitly-defined functions,
and so on. Such side effects
are not in the “immediate
context” and can result in
the program being ill-formed.
—end note]
T and U shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct is_swappable;
For a referenceable typeT,
the same result asis_-
swappable_with_v<T&,
T&>, otherwisefalse.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct is_destructible;
Either T is a reference
type, orT is a complete
object type for which the
expression
declval<U&>().~U() is
well-formed when treated
as an unevaluated
operand (7.2.3), whereU is
remove_all_extents_-
t<T>.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T, class... Args>
struct
is_trivially_constructible;
is_constructible_v<T,
Args...> is true and the
variable definition for
is_constructible, as
defined below, is known to
call no operation that is
not trivial (D.13, 11.4.4).
T and all types in the
template parameter pack
Args shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct
is_trivially_default_constructible;
is_trivially_-
constructible_v<T> is
true.
T shall be a complete type,
cv void, or an array of
unknown bound.
§ 21.3.6.4 © ISO/IEC
750

===== PAGE 762 =====

Dxxxx
Table 54 — Type property predicates (continued)
Template Condition Preconditions
template<class T>
struct
is_trivially_copy_constructible;
For a referenceable typeT,
the same result as
is_trivially_-
constructible_v<T,
const T&>, otherwise
false.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct
is_trivially_move_constructible;
For a referenceable typeT,
the same result as
is_trivially_-
constructible_v<T,
T&&>, otherwisefalse.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T, class U>
struct is_trivially_assignable;
is_assignable_v<T, U>
is true and the
assignment, as defined by
is_assignable, is known
to call no operation that is
not trivial (D.13, 11.4.4).
T and U shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct
is_trivially_copy_assignable;
For a referenceable typeT,
the same result as
is_trivially_-
assignable_v<T&, const
T&>, otherwisefalse.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct
is_trivially_move_assignable;
For a referenceable typeT,
the same result as
is_trivially_-
assignable_v<T&, T&&>,
otherwise false.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct is_trivially_destructible;
is_destructible_v<T> is
true and remove_all_-
extents_t<T> is either a
non-class type or a class
type with a trivial
destructor.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T, class... Args>
struct is_nothrow_constructible;
is_constructible_v<T,
Args...> is true and the
variable definition for
is_constructible, as
defined below, is known
not to throw any
exceptions (7.6.2.7).
T and all types in the
template parameter pack
Args shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct
is_nothrow_default_constructible;
is_nothrow_-
constructible_v<T> is
true.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct
is_nothrow_copy_constructible;
For a referenceable typeT,
the same result as
is_nothrow_-
constructible_v<T,
const T&>, otherwise
false.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct
is_nothrow_move_constructible;
For a referenceable typeT,
the same result as
is_nothrow_-
constructible_v<T,
T&&>, otherwisefalse.
T shall be a complete type,
cv void, or an array of
unknown bound.
§ 21.3.6.4 © ISO/IEC
751

===== PAGE 763 =====

Dxxxx
Table 54 — Type property predicates (continued)
Template Condition Preconditions
template<class T, class U>
struct is_nothrow_assignable;
is_assignable_v<T, U>
is true and the assignment
is known not to throw any
exceptions (7.6.2.7).
T and U shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct is_nothrow_copy_assignable;
For a referenceable typeT,
the same result as
is_nothrow_-
assignable_v<T&, const
T&>, otherwisefalse.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct is_nothrow_move_assignable;
For a referenceable typeT,
the same result as
is_nothrow_-
assignable_v<T&, T&&>,
otherwise false.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T, class U>
struct is_nothrow_swappable_with;
is_swappable_with_v<T,
U> is true and eachswap
expression of the definition
of is_swappable_with<T,
U> is known not to throw
any exceptions (7.6.2.7).
T and U shall be complete
types, cv void, or arrays
of unknown bound.
template<class T>
struct is_nothrow_swappable;
For a referenceable typeT,
the same result as
is_nothrow_swappable_-
with_v<T&, T&>,
otherwise false.
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct is_nothrow_destructible;
is_destructible_v<T> is
true and the indicated
destructor is known not to
throw any
exceptions (7.6.2.7).
T shall be a complete type,
cv void, or an array of
unknown bound.
template<class T>
struct is_implicit_lifetime;
T is an implicit-lifetime
type (6.9.1).
T shall be an array type, a
complete type, orcv void.
template<class T>
struct has_virtual_destructor;
T has a virtual
destructor (11.4.7)
If T is a non-union class
type, T shall be a complete
type.
template<class T>
struct
has_unique_object_representations;
For an array typeT, the
same result as
has_unique_object_-
representations_-
v<remove_all_extents_-
t<T>>, otherwisesee
below.
remove_all_extents_-
t<T> shall be a complete
type orcv void.
§ 21.3.6.4 © ISO/IEC
752

===== PAGE 764 =====

Dxxxx
Table 54 — Type property predicates (continued)
Template Condition Preconditions
template<class T, class U>
struct reference_constructs_from_-
temporary;
T is a reference type, and
the initializationT
t(VAL<U>); is well-formed
and bindst to a temporary
object whose lifetime is
extended (6.8.7). Access
checking is performed as if
in a context unrelated toT
and U. Only the validity of
the immediate context of
the variable initialization is
considered.
[Note 5: The initialization
can result in effects such as
the instantiation of class
template specializations and
function template
specializations, the
generation of
implicitly-defined functions,
and so on. Such effects are
not in the “immediate
context” and can result in
the program being ill-formed.
—end note]
T and U shall be complete
types, cv void, or arrays
of unknown bound.
template<class T, class U>
struct
reference_converts_from_temporary;
T is a reference type, and
the initializationT t =
VAL<U>; is well-formed
and bindst to a temporary
object whose lifetime is
extended (6.8.7). Access
checking is performed as if
in a context unrelated toT
and U. Only the validity of
the immediate context of
the variable initialization is
considered.
[Note 6: The initialization
can result in effects such as
the instantiation of class
template specializations and
function template
specializations, the
generation of
implicitly-defined functions,
and so on. Such effects are
not in the “immediate
context” and can result in
the program being ill-formed.
—end note]
T and U shall be complete
types, cv void, or arrays
of unknown bound.
6 [Example 1:
is_const_v<const volatile int> // true
is_const_v<const int*> // false
is_const_v<const int&> // false
§ 21.3.6.4 © ISO/IEC
753

===== PAGE 765 =====

Dxxxx
is_const_v<int[3]> // false
is_const_v<const int[3]> // true
—end example]
7 [Example 2:
remove_const_t<const volatile int> // volatile int
remove_const_t<const int* const> // const int*
remove_const_t<const int&> // const int&
remove_const_t<const int[3]> // int[3]
—end example]
8 [Example 3:
// Given:
struct P final { };
union U1 { };
union U2 final { };
// the following assertions hold:
static_assert(!is_final_v<int>);
static_assert(is_final_v<P>);
static_assert(!is_final_v<U1>);
static_assert(is_final_v<U2>);
—end example]
9 The predicate condition for a template specializationis_constructible<T, Args...> shall be satisfied if
and only if the following variable definition would be well-formed for some invented variablet:
T t(declval<Args>()...);
[Note 7: These tokens are never interpreted as a function declaration.—end note]
Access checking is performed as if in a context unrelated toT and any of theArgs. Only the validity of the
immediate context of the variable initialization is considered.
[Note 8: The evaluation of the initialization can result in side effects such as the instantiation of class template
specializations and function template specializations, the generation of implicitly-defined functions, and so on. Such
side effects are not in the “immediate context” and can result in the program being ill-formed.—end note]
10 The predicate condition for a template specializationhas_unique_object_representations<T> shall be
satisfied if and only if
—(10.1) T is trivially copyable, and
—(10.2) any two objects of typeT with the same value have the same object representation, where
—(10.2.1) two objects of array or non-union class type are considered to have the same value if their respective
sequences of direct subobjects have the same values, and
—(10.2.2) two objects of union type are considered to have the same value if they have the same active
member and the corresponding members have the same value.
The set of scalar types for which this condition holds is implementation-defined.
[Note 9: If a type has padding bits, the condition does not hold; otherwise, the condition holds true for integral types.
—end note]
21.3.7 Type property queries [meta.unary.prop.query]
1 The templates specified in Table 55 may be used to query properties of types at compile time.
Table 55 — Type property queries [tab:meta.unary.prop.query]
Template Value
template<class T>
struct alignment_of;
alignof(T).
Mandates: alignof(T) is a valid expression (7.6.2.6)
template<class T>
struct rank;
If T is an array type, an integer value representing the number of
dimensions ofT; otherwise, 0.
§ 21.3.7 © ISO/IEC
754

===== PAGE 766 =====

Dxxxx
Table 55 — Type property queries (continued)
Template Value
template<class T,
unsigned I = 0>
struct extent;
If T is not an array type, or if it has rank less than or equal toI, or if
I is 0 andT has type “array of unknown bound ofU”, then 0;
otherwise, the bound (9.3.4.5) of theIth dimension ofT, where
indexing ofI is zero-based
2 Each of these templates shall be aCpp17UnaryTypeTrait(21.3.2) with a base characteristic ofintegral_-
constant<size_t, Value>.
3 [Example 1:
// the following assertions hold:
static_assert(rank_v<int> == 0);
static_assert(rank_v<int[2]> == 1);
static_assert(rank_v<int[][4]> == 2);
—end example]
4 [Example 2:
// the following assertions hold:
static_assert(extent_v<int> == 0);
static_assert(extent_v<int[2]> == 2);
static_assert(extent_v<int[2][4]> == 2);
static_assert(extent_v<int[][4]> == 0);
static_assert(extent_v<int, 1> == 0);
static_assert(extent_v<int[2], 1> == 0);
static_assert(extent_v<int[2][4], 1> == 4);
static_assert(extent_v<int[][4], 1> == 4);
—end example]
21.3.8 Relationships between types [meta.rel]
1 The templates specified in Table 56 may be used to query relationships between types at compile time.
2 Each of these templates shall be aCpp17BinaryTypeTrait(21.3.2) with a base characteristic oftrue_type if
the corresponding condition is true, otherwisefalse_type.
3 Let ELEMS-OF(T) be the parameter pack get<N >(declval<T>()), where N is the pack of size_t tem-
plate arguments of the specialization ofindex_sequence denoted bymake_index_sequence<tuple_size_-
v<remove_reference_t<T>>>.
Table 56 — Type relationship predicates [tab:meta.rel]
Template Condition Comments
template<class T, class U>
struct is_same;
T and U name the same type
with the same
cv-qualifications
template<class Base, class
Derived>
struct is_base_of;
Base is a base class of
Derived (11.7) without
regard to cv-qualifiers orBase
and Derived are not unions
and name the same class type
without regard to cv-qualifiers
If Base and Derived are
non-union class types and are
not (possibly cv-qualified
versions of) the same type,
Derived shall be a complete
type.
[Note 1: Base classes that are
private, protected, or ambiguous
are, nonetheless, base classes.
—end note]
§ 21.3.8 © ISO/IEC
755

===== PAGE 767 =====

Dxxxx
Table 56 — Type relationship predicates (continued)
Template Condition Comments
template<class Base, class
Derived>
struct is_virtual_base_of;
Base is a virtual base class of
Derived (11.7.2) without
regard to cv-qualifiers.
If Base and Derived are
non-union class types,Derived
shall be a complete type.
[Note 2: Virtual base classes that
are private, protected, or
ambiguous are, nonetheless,
virtual base classes. —end note]
[Note 3: A class is never a virtual
base class of itself.—end note]
template<class From, class To>
struct is_convertible;
see below From and To shall be complete
types, cv void, or arrays of
unknown bound.
template<class From, class To>
struct is_nothrow_convertible;
is_convertible_v<From,
To> is true and the
conversion, as defined by
is_convertible, is known
not to throw any
exceptions (7.6.2.7)
From and To shall be complete
types, cv void, or arrays of
unknown bound.
template<class T, class U>
struct is_layout_compatible;
T and U are
layout-compatible (6.9.1)
T and U shall be complete
types, cv void, or arrays of
unknown bound.
template<class Base, class
Derived>
struct is_pointer_-
interconvertible_base_of;
Derived is unambiguously
derived fromBase without
regard to cv-qualifiers, and
each object of typeDerived is
pointer-interconvertible (6.9.4)
with itsBase subobject, or
Base and Derived are not
unions and name the same
class type without regard to
cv-qualifiers.
If Base and Derived are
non-union class types and are
not (possibly cv-qualified
versions of) the same type,
Derived shall be a complete
type.
template<class Fn, class...
ArgTypes>
struct is_invocable;
The expression
INVOKE(declval<Fn>(),
declval<ArgTypes>()...)
(22.10.4) is well-formed when
treated as an unevaluated
operand (7.2.3)
Fn and all types in the
template parameter pack
ArgTypes shall be complete
types, cv void, or arrays of
unknown bound.
template<class R, class Fn,
class... ArgTypes>
struct is_invocable_r;
The expression
INVOKE<R>(declval<Fn>(),
declval<ArgTypes>()...) is
well-formed when treated as
an unevaluated operand
Fn, R, and all types in the
template parameter pack
ArgTypes shall be complete
types, cv void, or arrays of
unknown bound.
template<class Fn, class...
ArgTypes>
struct is_nothrow_invocable;
is_invocable_v<
Fn, ArgTypes...> is true
and the expression
INVOKE(declval<Fn>(),
declval<ArgTypes>()...) is
known not to throw any
exceptions (7.6.2.7)
Fn and all types in the
template parameter pack
ArgTypes shall be complete
types, cv void, or arrays of
unknown bound.
template<class R, class Fn,
class... ArgTypes>
struct is_nothrow_invocable_r;
is_invocable_r_v<
R, Fn, ArgTypes...> is
true and the expression
INVOKE<R>(declval<Fn>(),
declval<ArgTypes>()...) is
known not to throw any
exceptions (7.6.2.7)
Fn, R, and all types in the
template parameter pack
ArgTypes shall be complete
types, cv void, or arrays of
unknown bound.
§ 21.3.8 © ISO/IEC
756

===== PAGE 768 =====

Dxxxx
Table 56 — Type relationship predicates (continued)
Template Condition Comments
template<class Fn, class Tuple>
struct is_applicable;
tuple-like <Tuple> is true
and the expression
INVOKE(declval<Fn>(),
ELEMS-OF(Tuple)...) is
well-formed when treated as
an unevaluated operand.
Fn and Tuple shall be
complete types,cv void, or
arrays of unknown bound.
template<class Fn, class Tuple>
struct is_nothrow_applicable;
is_applicable_v<
Fn, Tuple> is true and the
expression
INVOKE(declval<Fn>(),
ELEMS-OF(Tuple)...) is
known not to throw any
exceptions (7.6.2.7).
Fn and Tuple shall be
complete types,cv void, or
arrays of unknown bound.
4 For the purpose of defining the templates in this subclause, a function call expressiondeclval<T>() for any
type T is considered to be a trivial (D.13, 11.4.4) function call that is not an odr-use (6.3) ofdeclval in the
context of the corresponding definition notwithstanding the restrictions of 22.2.6.
5 [Example 1:
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};
is_base_of_v<B, D> // true
is_base_of_v<const B, D> // true
is_base_of_v<B, const D> // true
is_base_of_v<B, const B> // true
is_base_of_v<D, B> // false
is_base_of_v<B&, D&> // false
is_base_of_v<B[3], D[3]> // false
is_base_of_v<int, int> // false
—end example]
6 The predicate condition for a template specializationis_convertible<From, To> shall be satisfied if and
only if the return expression in the following code would be well-formed, including any implicit conversions
to the return type of the function:
To test() {
return declval<From>();
}
[Note 4: This requirement gives well-defined results for reference types, array types, function types, andcv void.
—end note]
Access checking is performed in a context unrelated toTo and From. Only the validity of the immediate
context of theexpression of thereturn statement (8.8.4) (including initialization of the returned object or
reference) is considered.
[Note 5: The initialization can result in side effects such as the instantiation of class template specializations and
function template specializations, the generation of implicitly-defined functions, and so on. Such side effects are not in
the “immediate context” and can result in the program being ill-formed.—end note]
21.3.9 Transformations between types [meta.trans]
21.3.9.1 General [meta.trans.general]
1 Subclause 21.3.9 contains templates that may be used to transform one type to another following some
predefined rule.
2 Each of the templates in 21.3.9 shall be aCpp17TransformationTrait(21.3.2).
§ 21.3.9.1 © ISO/IEC
757

===== PAGE 769 =====

Dxxxx
21.3.9.2 Const-volatile modifications [meta.trans.cv]
1 The templates specified in Table 57 add or remove cv-qualifications (6.9.5).
Table 57 — Const-volatile modifications [tab:meta.trans.cv]
Template Comments
template<class T>
struct remove_const;
The member typedeftype denotes the type formed by removing any
top-level const-qualifier fromT.
[Example 1: remove_const_t<const volatile int> evaluates to
volatile int, whereasremove_const_t<const int*> evaluates toconst
int*. —end example]
template<class T>
struct remove_volatile;
The member typedeftype denotes the type formed by removing any
top-level volatile-qualifier fromT.
[Example 2: remove_volatile_t<const volatile int> evaluates to
const int, whereasremove_volatile_t<volatile int*> evaluates to
volatile int*. —end example]
template<class T>
struct remove_cv;
The member typedeftype denotes the type formed by removing any
top-level cv-qualifiers fromT.
[Example 3: remove_cv_t<const volatile int> evaluates toint,
whereas remove_cv_t<const volatile int*> evaluates toconst
volatile int*. —end example]
template<class T>
struct add_const;
The member typedeftype denotes const T.
[Note 1: const has no effect whenT is a reference, function, or top-level
const-qualified type. —end note]
template<class T>
struct add_volatile;
The member typedeftype denotes volatile T.
[Note 2: volatile has no effect whenT is a reference, function, or
top-level volatile-qualified type.—end note]
template<class T>
struct add_cv;
The member typedeftype denotes
add_const_t<add_volatile_t<T>>.
21.3.9.3 Reference modifications [meta.trans.ref]
1 The templates specified in Table 58 add or remove references.
Table 58 — Reference modifications [tab:meta.trans.ref]
Template Comments
template<class T>
struct remove_reference;
If T has type “reference toT1” then the member typedeftype
denotes T1; otherwise,type denotes T.
template<class T>
struct
add_lvalue_reference;
If T is a referenceable type (3.45) then the member typedeftype
denotes T&; otherwise,type denotes T.
[Note 1: This rule reflects the semantics of reference collapsing (9.3.4.3).
—end note]
template<class T>
struct
add_rvalue_reference;
If T is a referenceable type then the member typedeftype denotes
T&&; otherwise,type denotes T.
[Note 2: This rule reflects the semantics of reference collapsing (9.3.4.3).
For example, when a typeT is a reference typeT1&, the type
add_rvalue_reference_t<T> is not an rvalue reference.—end note]
21.3.9.4 Sign modifications [meta.trans.sign]
1 The templates specified in Table 59 convert an integer type to its corresponding signed or unsigned type.
§ 21.3.9.4 © ISO/IEC
758

===== PAGE 770 =====

Dxxxx
Table 59 — Sign modifications [tab:meta.trans.sign]
Template Comments
template<class T>
struct make_signed;
If T is a (possibly cv-qualified) signed integer type (6.9.2) then the
member typedeftype denotes T; otherwise, ifT is a (possibly
cv-qualified) unsigned integer type thentype denotes the
corresponding signed integer type, with the same cv-qualifiers asT;
otherwise, type denotes the signed integer type with smallest
rank (6.9.6) for whichsizeof(T) == sizeof(type), with the same
cv-qualifiers asT.
Mandates: T is an integral or enumeration type other thancv bool.
template<class T>
struct make_unsigned;
If T is a (possibly cv-qualified) unsigned integer type (6.9.2) then the
member typedeftype denotes T; otherwise, ifT is a (possibly
cv-qualified) signed integer type thentype denotes the corresponding
unsigned integer type, with the same cv-qualifiers asT; otherwise,
type denotes the unsigned integer type with smallest rank (6.9.6) for
which sizeof(T) == sizeof(type), with the same cv-qualifiers as
T.
Mandates: T is an integral or enumeration type other thancv bool.
21.3.9.5 Array modifications [meta.trans.arr]
1 The templates specified in Table 60 modify array types.
Table 60 — Array modifications [tab:meta.trans.arr]
Template Comments
template<class T>
struct remove_extent;
If T is a type “array ofU”, the member typedeftype denotes U,
otherwise T.
[Note 1: For multidimensional arrays, only the first array dimension is
removed. For a type “array ofconst U”, the resulting type isconst U.
—end note]
template<class T>
struct remove_all_extents;
If T is “multidimensional array ofU”, the resulting member typedef
type denotes U, otherwiseT.
2 [Example 1:
// the following assertions hold:
static_assert(is_same_v<remove_extent_t<int>, int>);
static_assert(is_same_v<remove_extent_t<int[2]>, int>);
static_assert(is_same_v<remove_extent_t<int[2][3]>, int[3]>);
static_assert(is_same_v<remove_extent_t<int[][3]>, int[3]>);
—end example]
3 [Example 2:
// the following assertions hold:
static_assert(is_same_v<remove_all_extents_t<int>, int>);
static_assert(is_same_v<remove_all_extents_t<int[2]>, int>);
static_assert(is_same_v<remove_all_extents_t<int[2][3]>, int>);
static_assert(is_same_v<remove_all_extents_t<int[][3]>, int>);
—end example]
21.3.9.6 Pointer modifications [meta.trans.ptr]
1 The templates specified in Table 61 add or remove pointers.
§ 21.3.9.6 © ISO/IEC
759

===== PAGE 771 =====

Dxxxx
Table 61 — Pointer modifications [tab:meta.trans.ptr]
Template Comments
template<class T>
struct remove_pointer;
If T has type “(possibly cv-qualified) pointer toT1” then the member
typedef type denotes T1; otherwise, it denotesT.
template<class T>
struct add_pointer;
If T is a referenceable type (3.45) or acv void type then the member
typedef type denotes remove_reference_t<T>*; otherwise,type
denotes T.
21.3.9.7 Other transformations [meta.trans.other]
1 The templates specified in Table 62 perform other modifications of a type.
Table 62 — Other transformations [tab:meta.trans.other]
Template Comments
template<class T>
struct type_identity;
The member typedeftype denotes T.
template<class T>
struct remove_cvref;
The member typedeftype denotes
remove_cv_t<remove_reference_t<T>>.
template<class T>
struct decay;
Let U be remove_reference_t<T>. If is_array_v<U> is true, the
member typedeftype denotes remove_extent_t<U>*. If
is_function_v<U> is true, the member typedeftype denotes
add_pointer_t<U>. Otherwise the member typedeftype denotes
remove_cv_t<U>.
[Note 1: This behavior is similar to the lvalue-to-rvalue (7.3.2),
array-to-pointer (7.3.3), and function-to-pointer (7.3.4) conversions applied
when an lvalue is used as an rvalue, but also strips cv-qualifiers from class
types in order to more closely model by-value argument passing.—end
note]
template<bool B, class T =
void> struct enable_if;
If B is true, the member typedeftype denotes T; otherwise, there
shall be no membertype.
template<bool B, class T,
class F>
struct conditional;
If B is true, the member typedeftype denotes T. IfB is false, the
member typedeftype denotes F.
template<class... T> struct
common_type;
Unless this trait is specialized, the membertype is defined or omitted
as specified below. If it is omitted, there shall be no membertype.
Each type in the template parameter packT shall be complete,
cv void, or an array of unknown bound.
template<class, class,
template<class> class,
template<class> class>
struct
basic_common_reference;
Unless this trait is specialized, there shall be no membertype.
template<class... T> struct
common_reference;
The membertypedef-name type is defined or omitted as specified
below. Each type in the parameter packT shall be complete orcv
void.
template<class T>
struct underlying_type;
If T is an enumeration type, the member typedeftype denotes the
underlying type ofT (9.8.1); otherwise, there is no membertype.
Mandates: T is not an incomplete enumeration type.
§ 21.3.9.7 © ISO/IEC
760

===== PAGE 772 =====

Dxxxx
Table 62 — Other transformations (continued)
Template Comments
template<class Fn,
class... ArgTypes>
struct invoke_result;
If the expressionINVOKE(declval<Fn>(),
declval<ArgTypes>()...) (22.10.4) is well-formed when treated as
an unevaluated operand (7.2.3), the member typedeftype denotes
the typedecltype(INVOKE(declval<Fn>(),
declval<ArgTypes>()...)); otherwise, there shall be no member
type. Access checking is performed as if in a context unrelated toFn
and ArgTypes. Only the validity of the immediate context of the
expression is considered.
[Note 2: The compilation of the expression can result in side effects such as
the instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on.
Such side effects are not in the “immediate context” and can result in the
program being ill-formed. —end note]
Preconditions: Fn and all types in the template parameter pack
ArgTypes are complete types,cv void, or arrays of unknown bound.
template<class Fn, class
Tuple>
struct apply_result;
If tuple-like <Tuple> is true and the expression
INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...) (22.10.4) is
well-formed when treated as an unevaluated operand (7.2.3), the
member typedeftype denotes the type
decltype(INVOKE(declval<Fn>(), ELEMS-OF(Tuple)...));
otherwise, there shall be no membertype. Access checking is
performed as if in a context unrelated toFn and Tuple. Only the
validity of the immediate context of the expression is considered.
[Note 3: The compilation of the expression can result in side effects such as
the instantiation of class template specializations and function template
specializations, the generation of implicitly-defined functions, and so on.
Such side effects are not in the “immediate context” and can result in the
program being ill-formed. —end note]
Preconditions: Fn and Tuple are complete types,cv void, or arrays
of unknown bound.
template<class T> struct
unwrap_reference;
If T is a specializationreference_wrapper<X> for some typeX, the
member typedeftype of unwrap_reference<T> denotes X&,
otherwise type denotes T.
template<class T>
unwrap_ref_decay;
The member typedeftype of unwrap_ref_decay<T> denotes the
type unwrap_reference_t<decay_t<T>>.
2 In addition to being available via inclusion of the<type_traits> header, the templatesunwrap_reference,
unwrap_ref_decay, unwrap_reference_t, andunwrap_ref_decay_t are available when the header<func-
tional> (22.10.2) is included.
3 Let:
—(3.1) CREF(A) be add_lvalue_reference_t<const remove_reference_t<A>>,
—(3.2) XREF(A) denote a unary alias templateT such thatT<U> denotes the same type asU with the addition
of A’s cv and reference qualifiers, for a non-reference cv-unqualified typeU,
—(3.3) COPYCV(FROM, TO) be an alias for typeTO with the addition ofFROM’s top-level cv-qualifiers,
[Example 1: COPYCV(const int, volatile short) is an alias forconst volatile short. —end example]
—(3.4) COND-RES(X, Y) be decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()()).
Given typesA and B, letX be remove_reference_t<A>, letY be remove_reference_t<B>, and letCOMMON-
REF(A, B) be:
—(3.5) If A and B are both lvalue reference types,COMMON-REF(A, B) is COND-RES(COPYCV(X, Y) &, COPYCV(
Y, X) &) if that type exists and is a reference type.
—(3.6) Otherwise, letCbe remove_reference_t<COMMON-REF(X&, Y&)>&&. IfAandBarebothrvaluereference
types, C is well-formed, andis_convertible_v<A, C> && is_convertible_v<B, C> is true, then
COMMON-REF(A, B) is C.
§ 21.3.9.7 © ISO/IEC
761

===== PAGE 773 =====

Dxxxx
—(3.7) Otherwise, letD be COMMON-REF(const X&, Y&). If A is an rvalue reference andB is an lvalue reference
and D is well-formed andis_convertible_v<A, D> is true, thenCOMMON-REF(A, B) is D.
—(3.8) Otherwise, if A is an lvalue reference and B is an rvalue reference, then COMMON-REF(A, B) is
COMMON-REF(B, A).
—(3.9) Otherwise, COMMON-REF(A, B) is ill-formed.
If any of the types computed above is ill-formed, thenCOMMON-REF(A, B) is ill-formed.
4 For thecommon_type trait applied to a template parameter packT of types, the membertype shall be either
defined or not present as follows:
—(4.1) If sizeof...(T) is zero, there shall be no membertype.
—(4.2) If sizeof...(T) is one, letT0 denote the sole type constituting the packT. The membertypedef-name
type shall denote the same type, if any, ascommon_type_t<T0, T0>; otherwise there shall be no
member type.
—(4.3) If sizeof...(T) is two, let the first and second types constitutingT be denoted by T1 and T2,
respectively, and letD1 and D2 denote the same types asdecay_t<T1> and decay_t<T2>, respectively.
—(4.3.1) If is_same_v<T1, D1> is false or is_same_v<T2, D2> is false, letC denote the same type, if
any, ascommon_type_t<D1, D2>.
—(4.3.2) [Note 4: None of the following will apply if there is a specializationcommon_type<D1, D2>. —end note]
—(4.3.3) Otherwise, if
decay_t<decltype(false ? declval<D1>() : declval<D2>())>
denotes a valid type, letC denote that type.
—(4.3.4) Otherwise, if COND-RES(CREF(D1), CREF(D2)) denotes a type, letC denote the typedecay_-
t<COND-RES(CREF(D1), CREF(D2))>.
In either case, the membertypedef-name type shall denote the same type, if any, asC. Otherwise, there
shall be no membertype.
—(4.4) If sizeof...(T) is greater than two, letT1, T2, and R, respectively, denote the first, second, and
(pack of) remaining types constitutingT. Let C denote the same type, if any, ascommon_type_t<T1,
T2>. If there is such a typeC, the membertypedef-name type shall denote the same type, if any, as
common_type_t<C, R...>. Otherwise, there shall be no membertype.
5 Notwithstanding the provisions of 21.3.2, and pursuant to 16.4.5.2.1, a program may specializecommon_-
type<T1, T2> for typesT1 and T2 such thatis_same_v<T1, decay_t<T1>> and is_same_v<T2, decay_-
t<T2>> are eachtrue.
[Note 5: Such specializations are needed when only explicit conversions are desired between the template arguments.
—end note]
Such a specialization need not have a member namedtype, but if it does, thequalified-id common_type<T1,
T2>::type shall denote a cv-unqualified non-reference type to which each of the typesT1 and T2 is explicitly
convertible. Moreover,common_type_t<T1, T2> shall denote the same type, if any, as doescommon_type_-
t<T2, T1>. No diagnostic is required for a violation of this Note’s rules.
6 For thecommon_reference trait applied to a parameter packT of types, the membertype shall be either
defined or not present as follows:
—(6.1) If sizeof...(T) is zero, there shall be no membertype.
—(6.2) Otherwise, if sizeof...(T) is one, letT0 denote the sole type in the packT. The member typedef
type shall denote the same type asT0.
—(6.3) Otherwise, ifsizeof...(T) is two, letT1 and T2 denote the two types in the packT. Then
—(6.3.1) Let R be COMMON-REF(T1, T2). If T1 and T2 are reference types, R is well-formed, and is_-
convertible_v<add_pointer_t<T1>, add_pointer_t<R>> && is_convertible_v<add_poin
ter_t<T2>, add_pointer_t<R>> is true, then the member typedeftype denotes R.
—(6.3.2) Otherwise, if basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>, XREF(
T1), XREF(T2)>::type is well-formed, then the member typedeftype denotes that type.
—(6.3.3) Otherwise, ifCOND-RES(T1, T2) is well-formed, then the member typedeftype denotes that type.
§ 21.3.9.7 © ISO/IEC
762

===== PAGE 774 =====

Dxxxx
—(6.3.4) Otherwise, if common_type_t<T1, T2> is well-formed, then the member typedeftype denotes
that type.
—(6.3.5) Otherwise, there shall be no membertype.
—(6.4) Otherwise, if sizeof...(T) is greater than two, letT1, T2, andRest, respectively, denote the first,
second, and (pack of) remaining types comprisingT. Let C be the typecommon_reference_t<T1, T2>.
Then:
—(6.4.1) If there is such a type C, the member typedef type shall denote the same type, if any, as
common_reference_t<C, Rest...>.
—(6.4.2) Otherwise, there shall be no membertype.
7 Notwithstanding the provisions of 21.3.2, and pursuant to 16.4.5.2.1, a program may partially specialize
basic_common_reference<T, U, TQual, UQual> for typesT and U such thatis_same_v<T, decay_t<T>>
and is_same_v<U, decay_t<U>> are eachtrue.
[Note 6: Such specializations can be used to influence the result ofcommon_reference, and are needed when only
explicit conversions are desired between the template arguments.—end note]
Such a specialization need not have a member namedtype, but if it does, thequalified-id basic_common_-
reference<T, U, TQual, UQual>::type shall denote a type to which each of the typesTQual<T> and
UQual<U> is convertible. Moreover,basic_common_reference<T, U, TQual, UQual>::type shall denote
the same type, if any, as doesbasic_common_reference<U, T, UQual, TQual>::type. No diagnostic is
required for a violation of these rules.
8 [Example 2: Given these definitions:
using PF1 = bool (&)();
using PF2 = short (*)(long);
struct S {
operator PF2() const;
double operator()(char, int&);
void fn(long) const;
char data;
};
using PMF = void (S::*)(long) const;
using PMD = char S::*;
the following assertions will hold:
static_assert(is_same_v<invoke_result_t<S, int>, short>);
static_assert(is_same_v<invoke_result_t<S&, unsigned char, int&>, double>);
static_assert(is_same_v<invoke_result_t<PF1>, bool>);
static_assert(is_same_v<invoke_result_t<PMF, unique_ptr<S>, int>, void>);
static_assert(is_same_v<invoke_result_t<PMD, S>, char&&>);
static_assert(is_same_v<invoke_result_t<PMD, const S*>, const char&>);
—end example]
21.3.10 Logical operator traits [meta.logical]
1 This subclause describes type traits for applying logical operators to other type traits.
template<class... B> struct conjunction : see below { };
2 The class templateconjunction forms the logical conjunction of its template type arguments.
3 For a specializationconjunction<B1, ... , BN>, if there is a template type argumentBi for which
bool(Bi::value) is false, then instantiatingconjunction<B1, ... , BN>::value does not require
the instantiation ofBj::value for j >i.
[Note 1: This is analogous to the short-circuiting behavior of the built-in operator&&. —end note]
4 Every template type argument for whichBi::value is instantiated shall be usable as a base class and
shall have a membervalue which is convertible tobool, is not hidden, and is unambiguously available
in the type.
5 The specializationconjunction<B1, ... , BN> has a public and unambiguous base that is either
§ 21.3.10 © ISO/IEC
763

===== PAGE 775 =====

Dxxxx
—(5.1) the first typeBi in the listtrue_type, B1, ... , BN for whichbool(Bi::value) is false, or
—(5.2) if there is no suchBi, the last type in the list.
[Note 2: This means a specialization ofconjunction does not necessarily inherit from eithertrue_type or
false_type. —end note]
6 The member names of the base class, other thanconjunction and operator=, shall not be hidden
and shall be unambiguously available inconjunction.
template<class... B> struct disjunction : see below { };
7 The class templatedisjunction forms the logical disjunction of its template type arguments.
8 For a specializationdisjunction<B1, ... , BN>, if there is a template type argumentBi for which
bool(Bi::value) is true, then instantiatingdisjunction<B1, ... , BN>::value does not require
the instantiation ofBj::value for j >i.
[Note 3: This is analogous to the short-circuiting behavior of the built-in operator||. —end note]
9 Every template type argument for whichBi::value is instantiated shall be usable as a base class and
shall have a membervalue which is convertible tobool, is not hidden, and is unambiguously available
in the type.
10 The specializationdisjunction<B1, ... , BN> has a public and unambiguous base that is either
—(10.1) the first typeBi in the listfalse_type, B1, ... , BN for whichbool(Bi::value) is true, or
—(10.2) if there is no suchBi, the last type in the list.
[Note 4: This means a specialization ofdisjunction does not necessarily inherit from eithertrue_type or
false_type. —end note]
11 The member names of the base class, other thandisjunction and operator=, shall not be hidden
and shall be unambiguously available indisjunction.
template<class B> struct negation : see below { };
12 The class templatenegation forms the logical negation of its template type argument. The type
negation<B> is a Cpp17UnaryTypeTrait with a base characteristic of bool_constant<!bool(B::
value)>.
21.3.11 Member relationships [meta.member]
template<class S, class M>
constexpr bool is_pointer_interconvertible_with_class(M S::*m) noexcept;
1 Mandates: S is a complete type.
2 Returns: true if and only ifS is a standard-layout type,M is an object type,m is not null, and each
object s of typeS is pointer-interconvertible (6.9.4) with its subobjects.*m.
template<class S1, class S2, class M1, class M2>
constexpr bool is_corresponding_member(M1 S1::*m1, M2 S2::*m2) noexcept;
3 Mandates: S1 and S2 are complete types.
4 Returns: true if and only ifS1 and S2 are standard-layout struct (11.2) types,M1 and M2 are object
types, m1 and m2 are not null, andm1 and m2 point to corresponding members of the common initial
sequence (11.4) ofS1 and S2.
5 [Note 1: The type of a pointer-to-member expression&C::b is not always a pointer to member ofC, leading to
potentially surprising results when using these functions in conjunction with inheritance.
[Example 1:
struct A { int a; }; // a standard-layout class
struct B { int b; }; // a standard-layout class
struct C: public A, public B { }; // not a standard-layout class
static_assert( is_pointer_interconvertible_with_class( &C::b ) );
// Succeeds because, despite its appearance,&C::b has type
// “pointer to member ofB of typeint”.
static_assert( !is_pointer_interconvertible_with_class<C, int>( &C::b ) );
// Forces the use of classC, and the result isfalse.
§ 21.3.11 © ISO/IEC
764

===== PAGE 776 =====

Dxxxx
static_assert( is_corresponding_member( &C::a, &C::b ) );
// Succeeds because, despite its appearance,&C::a and &C::b have types
// “pointer to member ofA of typeint” and
// “pointer to member ofB of typeint”, respectively.
static_assert( !is_corresponding_member<C, C, int, int>( &C::a, &C::b ) );
// Forces the use of classC, and the result isfalse.
—end example]
—end note]
21.3.12 Constant evaluation context [meta.const.eval]
constexpr bool is_constant_evaluated() noexcept;
1 Effects: Equivalent to:
if consteval {
return true;
} else {
return false;
}
2 [Example 1:
constexpr void f(unsigned char *p, int n) {
if (std::is_constant_evaluated()) { // should not be a constexpr if statement
for (int k = 0; k<n; ++k) p[k] = 0;
} else {
memset(p, 0, n); // not a core constant expression
}
}
—end example]
consteval bool is_within_lifetime(const auto* p) noexcept;
3 Returns: true if p is a pointer to an object that is within its lifetime (6.8.4); otherwise,false.
4 Remarks: During the evaluation of an expressionE as a core constant expression, a call to this function
is ill-formed unlessp points to an object that is usable in constant expressions or whose complete
object’s lifetime began withinE.
5 [Example 2:
struct OptBool {
union { bool b; char c; };
// note: this assumes common implementation properties forbool and char:
// * sizeof(bool) == sizeof(char), and
// * the value representations fortrue and false are distinct
// from the value representation for2
constexpr OptBool() : c(2) { }
constexpr OptBool(bool b) : b(b) { }
constexpr auto has_value() const -> bool {
if consteval {
return std::is_within_lifetime(&b); // during constant evaluation, cannot read fromc
} else {
return c != 2; // during runtime, must read fromc
}
}
constexpr auto operator*() const -> const bool& {
return b;
}
};
constexpr OptBool disengaged;
constexpr OptBool engaged(true);
static_assert(!disengaged.has_value());
§ 21.3.12 © ISO/IEC
765

===== PAGE 777 =====

Dxxxx
static_assert(engaged.has_value());
static_assert(*engaged);
—end example]
21.4 Reflection [meta.reflection]
21.4.1 Header <meta> synopsis [meta.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 21.4.2, checking string literals
consteval bool is_string_literal(const char* p);
consteval bool is_string_literal(const wchar_t* p);
consteval bool is_string_literal(const char8_t* p);
consteval bool is_string_literal(const char16_t* p);
consteval bool is_string_literal(const char32_t* p);
// 21.4.3, promoting to static storage
namespace meta {
template<ranges::input_range R>
consteval info reflect_constant_string(R&& r);
template<ranges::input_range R>
consteval info reflect_constant_array(R&& r);
}
template<ranges::input_range R>
consteval const ranges::range_value_t<R>* define_static_string(R&& r);
template<ranges::input_range R>
consteval span<const ranges::range_value_t<R>> define_static_array(R&& r);
template<class T>
consteval const remove_cvref_t<T>* define_static_object(T&& r);
}
namespace std::meta {
using info = decltype(^^::);
// 21.4.4, classexception
class exception;
// 21.4.5, operator representations
enum class operators {
see below ;
};
using enum operators;
consteval operators operator_of(info r);
consteval string_view symbol_of(operators op);
consteval u8string_view u8symbol_of(operators op);
// 21.4.6, reflection names and locations
consteval bool has_identifier(info r);
consteval string_view identifier_of(info r);
consteval u8string_view u8identifier_of(info r);
consteval string_view display_string_of(info r);
consteval u8string_view u8display_string_of(info r);
consteval source_location source_location_of(info r);
// 21.4.7, reflection queries
consteval info type_of(info r);
consteval info object_of(info r);
consteval info constant_of(info r);
§ 21.4.1 © ISO/IEC
766

===== PAGE 778 =====

Dxxxx
consteval bool is_public(info r);
consteval bool is_protected(info r);
consteval bool is_private(info r);
consteval bool is_virtual(info r);
consteval bool is_pure_virtual(info r);
consteval bool is_override(info r);
consteval bool is_final(info r);
consteval bool is_deleted(info r);
consteval bool is_defaulted(info r);
consteval bool is_user_provided(info r);
consteval bool is_user_declared(info r);
consteval bool is_explicit(info r);
consteval bool is_noexcept(info r);
consteval bool is_bit_field(info r);
consteval bool is_enumerator(info r);
consteval bool is_annotation(info r);
consteval bool is_const(info r);
consteval bool is_volatile(info r);
consteval bool is_mutable_member(info r);
consteval bool is_lvalue_reference_qualified(info r);
consteval bool is_rvalue_reference_qualified(info r);
consteval bool has_static_storage_duration(info r);
consteval bool has_thread_storage_duration(info r);
consteval bool has_automatic_storage_duration(info r);
consteval bool has_internal_linkage(info r);
consteval bool has_module_linkage(info r);
consteval bool has_external_linkage(info r);
consteval bool has_c_language_linkage(info r);
consteval bool has_linkage(info r);
consteval bool is_complete_type(info r);
consteval bool is_enumerable_type(info r);
consteval bool is_variable(info r);
consteval bool is_type(info r);
consteval bool is_namespace(info r);
consteval bool is_type_alias(info r);
consteval bool is_namespace_alias(info r);
consteval bool is_function(info r);
consteval bool is_conversion_function(info r);
consteval bool is_operator_function(info r);
consteval bool is_literal_operator(info r);
consteval bool is_special_member_function(info r);
consteval bool is_constructor(info r);
consteval bool is_default_constructor(info r);
consteval bool is_copy_constructor(info r);
consteval bool is_move_constructor(info r);
consteval bool is_assignment(info r);
consteval bool is_copy_assignment(info r);
consteval bool is_move_assignment(info r);
consteval bool is_destructor(info r);
consteval bool is_function_parameter(info r);
consteval bool is_explicit_object_parameter(info r);
consteval bool has_default_argument(info r);
consteval bool has_ellipsis_parameter(info r);
§ 21.4.1 © ISO/IEC
767

===== PAGE 779 =====

Dxxxx
consteval bool is_template(info r);
consteval bool is_function_template(info r);
consteval bool is_variable_template(info r);
consteval bool is_class_template(info r);
consteval bool is_alias_template(info r);
consteval bool is_conversion_function_template(info r);
consteval bool is_operator_function_template(info r);
consteval bool is_literal_operator_template(info r);
consteval bool is_constructor_template(info r);
consteval bool is_concept(info r);
consteval bool is_value(info r);
consteval bool is_object(info r);
consteval bool is_structured_binding(info r);
consteval bool is_class_member(info r);
consteval bool is_namespace_member(info r);
consteval bool is_nonstatic_data_member(info r);
consteval bool is_static_member(info r);
consteval bool is_base(info r);
consteval bool has_default_member_initializer(info r);
consteval bool has_parent(info r);
consteval info parent_of(info r);
consteval info dealias(info r);
consteval bool has_template_arguments(info r);
consteval info template_of(info r);
consteval vector<info> template_arguments_of(info r);
consteval vector<info> parameters_of(info r);
consteval info variable_of(info r);
consteval info return_type_of(info r);
// 21.4.8, access control context
struct access_context;
// 21.4.9, member accessibility queries
consteval bool is_accessible(info r, access_context ctx);
consteval bool has_inaccessible_nonstatic_data_members(info r, access_context ctx);
consteval bool has_inaccessible_bases(info r, access_context ctx);
consteval bool has_inaccessible_subobjects(info r, access_context ctx);
// 21.4.10, reflection member queries
consteval vector<info> members_of(info r, access_context ctx);
consteval vector<info> bases_of(info type, access_context ctx);
consteval vector<info> static_data_members_of(info type, access_context ctx);
consteval vector<info> nonstatic_data_members_of(info type, access_context ctx);
consteval vector<info> subobjects_of(info type, access_context ctx);
consteval vector<info> enumerators_of(info type_enum);
// 21.4.11, reflection layout queries
struct member_offset;
consteval member_offset offset_of(info r);
consteval size_t size_of(info r);
consteval size_t alignment_of(info r);
consteval size_t bit_size_of(info r);
// 21.4.12, annotation reflection
consteval vector<info> annotations_of(info item);
consteval vector<info> annotations_of_with_type(info item, info type);
§ 21.4.1 © ISO/IEC
768

===== PAGE 780 =====

Dxxxx
// 21.4.13, value extraction
template<class T>
consteval T extract(info);
// 21.4.14, reflection substitution
template<class R>
concept reflection_range = see below ;
template<reflection_range R = initializer_list<info>>
consteval bool can_substitute(info templ, R&& arguments);
template<reflection_range R = initializer_list<info>>
consteval info substitute(info templ, R&& arguments);
// 21.4.15, expression result reflection
template<class T>
consteval info reflect_constant(T expr);
template<class T>
consteval info reflect_object(T& expr);
template<class T>
consteval info reflect_function(T& fn);
// 21.4.16, class definition generation
struct data_member_options;
consteval info data_member_spec(info type, data_member_options options);
consteval bool is_data_member_spec(info r);
template<reflection_range R = initializer_list<info>>
consteval info define_aggregate(info type_class, R&&);
// associated with 21.3.6.2, primary type categories
consteval bool is_void_type(info type);
consteval bool is_null_pointer_type(info type);
consteval bool is_integral_type(info type);
consteval bool is_floating_point_type(info type);
consteval bool is_array_type(info type);
consteval bool is_pointer_type(info type);
consteval bool is_lvalue_reference_type(info type);
consteval bool is_rvalue_reference_type(info type);
consteval bool is_member_object_pointer_type(info type);
consteval bool is_member_function_pointer_type(info type);
consteval bool is_enum_type(info type);
consteval bool is_union_type(info type);
consteval bool is_class_type(info type);
consteval bool is_function_type(info type);
consteval bool is_reflection_type(info type);
// associated with 21.3.6.3, composite type categories
consteval bool is_reference_type(info type);
consteval bool is_arithmetic_type(info type);
consteval bool is_fundamental_type(info type);
consteval bool is_object_type(info type);
consteval bool is_scalar_type(info type);
consteval bool is_compound_type(info type);
consteval bool is_member_pointer_type(info type);
// associated with 21.3.6.4, type properties
consteval bool is_const_type(info type);
consteval bool is_volatile_type(info type);
consteval bool is_trivially_copyable_type(info type);
consteval bool is_standard_layout_type(info type);
consteval bool is_empty_type(info type);
consteval bool is_polymorphic_type(info type);
consteval bool is_abstract_type(info type);
consteval bool is_final_type(info type);
consteval bool is_aggregate_type(info type);
§ 21.4.1 © ISO/IEC
769

===== PAGE 781 =====

Dxxxx
consteval bool is_consteval_only_type(info type);
consteval bool is_signed_type(info type);
consteval bool is_unsigned_type(info type);
consteval bool is_bounded_array_type(info type);
consteval bool is_unbounded_array_type(info type);
consteval bool is_scoped_enum_type(info type);
template<reflection_range R = initializer_list<info>>
consteval bool is_constructible_type(info type, R&& type_args);
consteval bool is_default_constructible_type(info type);
consteval bool is_copy_constructible_type(info type);
consteval bool is_move_constructible_type(info type);
consteval bool is_assignable_type(info type_dst, info type_src);
consteval bool is_copy_assignable_type(info type);
consteval bool is_move_assignable_type(info type);
consteval bool is_swappable_with_type(info type1, info type2);
consteval bool is_swappable_type(info type);
consteval bool is_destructible_type(info type);
template<reflection_range R = initializer_list<info>>
consteval bool is_trivially_constructible_type(info type, R&& type_args);
consteval bool is_trivially_default_constructible_type(info type);
consteval bool is_trivially_copy_constructible_type(info type);
consteval bool is_trivially_move_constructible_type(info type);
consteval bool is_trivially_assignable_type(info type_dst, info type_src);
consteval bool is_trivially_copy_assignable_type(info type);
consteval bool is_trivially_move_assignable_type(info type);
consteval bool is_trivially_destructible_type(info type);
template<reflection_range R = initializer_list<info>>
consteval bool is_nothrow_constructible_type(info type, R&& type_args);
consteval bool is_nothrow_default_constructible_type(info type);
consteval bool is_nothrow_copy_constructible_type(info type);
consteval bool is_nothrow_move_constructible_type(info type);
consteval bool is_nothrow_assignable_type(info type_dst, info type_src);
consteval bool is_nothrow_copy_assignable_type(info type);
consteval bool is_nothrow_move_assignable_type(info type);
consteval bool is_nothrow_swappable_with_type(info type1, info type2);
consteval bool is_nothrow_swappable_type(info type);
consteval bool is_nothrow_destructible_type(info type);
consteval bool is_implicit_lifetime_type(info type);
consteval bool has_virtual_destructor(info type);
consteval bool has_unique_object_representations(info type);
consteval bool reference_constructs_from_temporary(info type_dst, info type_src);
consteval bool reference_converts_from_temporary(info type_dst, info type_src);
// associated with 21.3.7, type property queries
consteval size_t rank(info type);
consteval size_t extent(info type, unsigned i = 0);
// associated with 21.3.8, type relations
consteval bool is_same_type(info type1, info type2);
consteval bool is_base_of_type(info type_base, info type_derived);
§ 21.4.1 © ISO/IEC
770

===== PAGE 782 =====

Dxxxx
consteval bool is_virtual_base_of_type(info type_base, info type_derived);
consteval bool is_convertible_type(info type_src, info type_dst);
consteval bool is_nothrow_convertible_type(info type_src, info type_dst);
consteval bool is_layout_compatible_type(info type1, info type2);
consteval bool is_pointer_interconvertible_base_of_type(info type_base, info type_derived);
template<reflection_range R = initializer_list<info>>
consteval bool is_invocable_type(info type, R&& type_args);
template<reflection_range R = initializer_list<info>>
consteval bool is_invocable_r_type(info type_result, info type, R&& type_args);
template<reflection_range R = initializer_list<info>>
consteval bool is_nothrow_invocable_type(info type, R&& type_args);
template<reflection_range R = initializer_list<info>>
consteval bool is_nothrow_invocable_r_type(info type_result, info type, R&& type_args);
// associated with 21.3.9.2, const-volatile modifications
consteval info remove_const(info type);
consteval info remove_volatile(info type);
consteval info remove_cv(info type);
consteval info add_const(info type);
consteval info add_volatile(info type);
consteval info add_cv(info type);
// associated with 21.3.9.3, reference modifications
consteval info remove_reference(info type);
consteval info add_lvalue_reference(info type);
consteval info add_rvalue_reference(info type);
// associated with 21.3.9.4, sign modifications
consteval info make_signed(info type);
consteval info make_unsigned(info type);
// associated with 21.3.9.5, array modifications
consteval info remove_extent(info type);
consteval info remove_all_extents(info type);
// associated with 21.3.9.6, pointer modifications
consteval info remove_pointer(info type);
consteval info add_pointer(info type);
// associated with 21.3.9.7, other transformations
consteval info remove_cvref(info type);
consteval info decay(info type);
template<reflection_range R = initializer_list<info>>
consteval info common_type(R&& type_args);
template<reflection_range R = initializer_list<info>>
consteval info common_reference(R&& type_args);
consteval info underlying_type(info type);
template<reflection_range R = initializer_list<info>>
consteval info invoke_result(info type, R&& type_args);
consteval info unwrap_reference(info type);
consteval info unwrap_ref_decay(info type);
consteval size_t tuple_size(info type);
consteval info tuple_element(size_t index, info type);
consteval size_t variant_size(info type);
consteval info variant_alternative(size_t index, info type);
consteval strong_ordering type_order(info type_a, info type_b);
}
§ 21.4.1 © ISO/IEC
771

===== PAGE 783 =====

Dxxxx
1 Unless otherwise specified, each function, and each specialization of any function template, specified in this
header is a designated addressable function (16.4.5.2.1).
2 The behavior of any function specified in namespacestd::meta is implementation-defined when a reflection
of a construct not otherwise specified by this document is provided as an argument.
[Note 1: Values of typestd::meta::info can represent implementation-specific constructs (6.9.2).—end note]
[Note 2: Many of the functions specified in namespace std::meta have semantics that can be affected by the
completeness of class types represented by reflection values. For such functions, for any reflectionr such that
dealias(r) represents a specialization of a templated class with a reachable definition, the specialization is implicitly
instantiated (13.9.2).
[Example 1:
template<class T>
struct X {
T mem;
};
static_assert(size_of(^^X<int>) == sizeof(int)); // instantiatesX<int>
—end example]
—end note]
3 Any function in namespacestd::meta whose return type isstring_view or u8string_view returns an
object V such thatV .data()[V .size()] equals ’\0’.
[Example 2:
struct C { };
constexpr string_view sv = identifier_of(^^C);
static_assert(sv == "C");
static_assert(sv.data()[0] == 'C');
static_assert(sv.data()[1] == '\0');
—end example]
4 For the purpose of exposition, throughout this clause^^E is used to indicate a reflection representing source
construct E .
21.4.2 Checking string literals [meta.string.literal]
consteval bool is_string_literal(const char* p);
consteval bool is_string_literal(const wchar_t* p);
consteval bool is_string_literal(const char8_t* p);
consteval bool is_string_literal(const char16_t* p);
consteval bool is_string_literal(const char32_t* p);
1 Returns:
—(1.1) If p points to an unspecified object (7.7),false.
—(1.2) Otherwise, ifp points to a subobject of a string literal object (5.13.5),true.
—(1.3) Otherwise, false.
21.4.3 Promoting to static storage [meta.define.static]
1 The functions in this subclause promote compile-time storage into static storage.
template<ranges::input_range R>
consteval info reflect_constant_string(R&& r);
2 Let CharT be ranges::range_value_t<R>.
3 Mandates: CharT is one ofchar, wchar_t, char8_t, char16_t, char32_t.
4 Let V be the pack of values of typeCharT whose elements are the corresponding elements ofr, except
that if r is a reference to a string literal object, thenV does not include the terminatingu+0000 null
character ofr.
5 Let P be the template parameter object (13.2) of typeconst CharT[sizeof...(V) + 1] initialized
with {V..., CharT()}.
§ 21.4.3 © ISO/IEC
772

===== PAGE 784 =====

Dxxxx
6 Returns: ^^P.
7 [Note 1: P is a potentially non-unique object (6.8.2).—end note]
template<ranges::input_range R>
consteval info reflect_constant_array(R&& r);
8 Let T be ranges::range_value_t<R> and e i be static_cast<T>(*it i), whereit i is an iterator to
the ith element ofr.
9 Mandates: T is a structural type (13.2),is_constructible_v<T, ranges::range_reference_t<R>>
is true, andT satisfies copy_constructible.
10 Let V be the pack of values of typeinfo of the same size asr, where theith element isreflect_-
constant(e i).
11 Let P be
—(11.1) the template parameter object (13.2) of type const T[sizeof...(V)] initialized with
{[:V:]...} if sizeof...(V) > 0 is true, otherwise
—(11.2) the template parameter object of typeconst array<T, 0> initialized with{}.
12 Returns: ^^P.
13 Throws: Any exception thrown by the evaluation of anye i, ormeta::exception if evaluation of any
reflect_constant(e i) would exit via an exception.
14 [Note 2: P is a potentially non-unique object (6.8.2).—end note]
template<ranges::input_range R>
consteval const ranges::range_value_t<R>* define_static_string(R&& r);
15 Effects: Equivalent to:
return meta::extract<const ranges::range_value_t<R>*>(meta::reflect_constant_string(r));
template<ranges::input_range R>
consteval span<const ranges::range_value_t<R>> define_static_array(R&& r);
16 Effects: Equivalent to:
using T = ranges::range_value_t<R>;
meta::info array = meta::reflect_constant_array(r);
if (meta::is_array_type(meta::type_of(array))) {
return span<const T>(meta::extract<const T*>(array), meta::extent(meta::type_of(array)));
} else {
return span<const T>();
}
template<class T>
consteval const remove_cvref_t<T>* define_static_object(T&& t);
17 Effects: Equivalent to:
using U = remove_cvref_t<T>;
if constexpr (meta::is_class_type(^^U)) {
return addressof(meta::extract<const U&>(meta::reflect_constant(std::forward<T>(t))));
} else {
return define_static_array(span(addressof(t), 1)).data();
}
18 [Note 3: For class types,define_static_object provides the address of the template parameter object (13.2)
that is template-argument equivalent tot. —end note]
21.4.4 Class exception [meta.reflection.exception]
namespace std::meta {
class exception : public std::exception {
private:
optional<string> what_; // exposition only
u8string u8what_; // exposition only
info from_; // exposition only
source_location where_; // exposition only
§ 21.4.4 © ISO/IEC
773

===== PAGE 785 =====

Dxxxx
public:
consteval exception(u8string_view what, info from,
source_location where = source_location::current()) noexcept;
consteval exception(string_view what, info from,
source_location where = source_location::current()) noexcept;
exception(const exception&) = default;
exception(exception&&) = default;
exception& operator=(const exception&) = default;
exception& operator=(exception&&) = default;
constexpr const char* what() const noexcept override;
consteval u8string_view u8what() const noexcept;
consteval info from() const noexcept;
consteval source_location where() const noexcept;
};
}
1 Reflection functions throw exceptions of typemeta::exception to signal an error.meta::exception is a
consteval-only type.
consteval exception(u8string_view what, info from,
source_location where = source_location::current()) noexcept;
2 Effects: Initializes u8what_ with what, from_ with from, and where_ with where. If what can be
represented in the ordinary literal encoding, initializeswhat_ with what, transcoded from UTF-8 to the
ordinary literal encoding. Otherwise,what_ is value-initialized.
consteval exception(string_view what, info from,
source_location where = source_location::current()) noexcept;
3 Constant When: what designates a sequence of characters that can be encoded in UTF-8.
4 Effects: Initializes what_ with what, u8what_ with what transcoded from the ordinary literal encoding
to UTF-8,from_ with from and where_ with where.
constexpr const char* what() const noexcept override;
5 Constant When: what_.has_value() is true.
6 Returns: what_->c_str().
consteval u8string_view u8what() const noexcept;
7 Returns: u8what_.
consteval info from() const noexcept;
8 Returns: from_.
consteval source_location where() const noexcept;
9 Returns: where_.
21.4.5 Operator representations [meta.reflection.operators]
enum class operators {
see below ;
};
using enum operators;
1 The enumeration typeoperators specifies constants used to identify operators that can be overloaded,
with the meanings listed in Table 63. The values of the constants are distinct.
consteval operators operator_of(info r);
2 Returns: The value of the enumerator fromoperators whose correspondingoperator-function-id is the
unqualified name of the entity represented byr.
§ 21.4.5 © ISO/IEC
774

===== PAGE 786 =====

Dxxxx
Table 63 — Enum classoperators [tab:meta.reflection.operators]
Constant Corresponding operator-function-id Operator symbol name
op_new operator new new
op_delete operator delete delete
op_array_new operator new[] new[]
op_array_delete operator delete[] delete[]
op_co_await operator co_await co_await
op_parentheses operator() ()
op_square_brackets operator[] []
op_arrow operator-> ->
op_arrow_star operator->* ->*
op_tilde operator ~ ~
op_exclamation operator! !
op_plus operator+ +
op_minus operator- -
op_star operator* *
op_slash operator/ /
op_percent operator% %
op_caret operator^ ^
op_ampersand operator& &
op_equals operator= =
op_pipe operator| |
op_plus_equals operator+= +=
op_minus_equals operator-= -=
op_star_equals operator*= *=
op_slash_equals operator/= /=
op_percent_equals operator%= %=
op_caret_equals operator^= ^=
op_ampersand_equals operator&= &=
op_pipe_equals operator|= |=
op_equals_equals operator== ==
op_exclamation_equals operator!= !=
op_less operator< <
op_greater operator> >
op_less_equals operator<= <=
op_greater_equals operator>= >=
op_spaceship operator<=> <=>
op_ampersand_ampersand operator&& &&
op_pipe_pipe operator|| ||
op_less_less operator<< <<
op_greater_greater operator>> >>
op_less_less_equals operator<<= <<=
op_greater_greater_equals operator>>= >>=
op_plus_plus operator++ ++
op_minus_minus operator-- --
op_comma operator, ,
§ 21.4.5 © ISO/IEC
775

===== PAGE 787 =====

Dxxxx
3 Throws: meta::exception unless r represents an operator function or operator function template.
consteval string_view symbol_of(operators op);
consteval u8string_view u8symbol_of(operators op);
4 Returns: A string_view or u8string_view containing the characters of the operator symbol name
corresponding toop, respectively encoded with the ordinary literal encoding or with UTF-8.
5 Throws: meta::exception unless the value ofop corresponds to one of the enumerators inoperators.
21.4.6 Reflection names and locations [meta.reflection.names]
consteval bool has_identifier(info r);
1 Returns:
—(1.1) If r represents an entity that has a typedef name for linkage purposes (9.2.4), thentrue.
—(1.2) Otherwise, ifr represents an unnamed entity, thenfalse.
—(1.3) Otherwise, ifr represents a type alias, then!has_template_arguments(r).
—(1.4) Otherwise, ifr represents a type, thentrue if
—(1.4.1) r represents a cv-unqualified class type andhas_template_arguments(r) is false, or
—(1.4.2) r represents a cv-unqualified enumeration type.
Otherwise, false.
—(1.5) Otherwise, if r represents a function, thentrue if has_template_arguments(r) is false and
the function is not a constructor, destructor, operator function, or conversion function. Otherwise,
false.
—(1.6) Otherwise, ifr represents a template, thentrue if r does not represent a constructor template,
operator function template, or conversion function template. Otherwise,false.
—(1.7) Otherwise, if r represents the ith parameter of a functionF that is an (implicit or explicit)
specialization of a templated functionT and theith parameter of the instantiated declaration of
T whose template arguments are those ofF would be instantiated from a pack, thenfalse.
—(1.8) Otherwise, if r represents the parameterP of a functionF, then letS be the set of declarations,
ignoring any explicit instantiations, that precede some point in the evaluation context and that
declare eitherF or a templated function of whichF is a specialization;true if
—(1.8.1) there is a declaration D in S that introduces a name N for either P or the parameter
corresponding toP in the templated function thatD declares and
—(1.8.2) no declaration inS does so using any name other thanN.
Otherwise, false.
[Example 1:
void fun(int);
constexpr std::meta::info r = parameters_of(^^fun)[0];
static_assert(!has_identifier(r));
void fun(int x);
static_assert(has_identifier(r));
void fun(int x);
static_assert(has_identifier(r));
void poison() {
void fun(int y);
}
static_assert(!has_identifier(r));
—end example]
—(1.9) Otherwise, ifr represents a variable, thenfalse if the declaration of that variable was instantiated
from a function parameter pack. Otherwise,!has_template_arguments(r).
§ 21.4.6 © ISO/IEC
776

===== PAGE 788 =====

Dxxxx
—(1.10) Otherwise, ifr represents a structured binding, thenfalse if the declaration of that structured
binding was instantiated from a structured binding pack. Otherwise,true.
—(1.11) Otherwise, ifr represents an enumerator, non-static-data member, namespace, or namespace alias,
then true.
—(1.12) Otherwise, ifr represents a direct base class relationship, thenhas_identifier(type_of(r)).
—(1.13) Otherwise, r represents a data member description(T,N,A,W, NUA) (11.4.1); true if N is not
⊥. Otherwise, false.
consteval string_view identifier_of(info r);
consteval u8string_view u8identifier_of(info r);
2 Let E be UTF-8 foru8identifier_of, and otherwise the ordinary literal encoding.
3 Returns: An ntmbs, encoded withE, determined as follows:
—(3.1) If r represents an entity with a typedef name for linkage purposes, then that name.
—(3.2) Otherwise, ifr represents a literal operator or literal operator template, then theud-suffix of the
operator or operator template.
—(3.3) Otherwise, if r represents the parameterP of a functionF, then letS be the set of declarations,
ignoring any explicit instantiations, that precede some point in the evaluation context and that
declare either F or a templated function of whichF is a specialization; the name that was
introduced by a declaration inS for the parameter corresponding toP.
—(3.4) Otherwise, ifr represents an entity, then the identifier introduced by the declaration of that entity.
—(3.5) Otherwise, ifr represents a direct base class relationship, thenidentifier_of(type_of(r)) or
u8identifier_of(type_of(r)), respectively.
—(3.6) Otherwise, r represents a data member description(T,N,A,W,NUA ) (11.4.1); astring_view
or u8string_view, respectively, containing the identifierN.
4 Throws: meta::exceptionunless has_identifier(r)is trueand the identifier that would be returned
(see above) is representable byE.
consteval string_view display_string_of(info r);
consteval u8string_view u8display_string_of(info r);
5 Returns: An implementation-definedstring_view or u8string_view, respectively.
6 Recommended practice: Where possible, implementations should return a string suitable for identifying
the represented construct.
consteval source_location source_location_of(info r);
7 Returns: If r represents a value, a type other than a class type or an enumeration type, the global
namespace, or a data member description, thensource_location{}. Otherwise, an implementation-
defined source_location value.
8 Recommended practice: If r represents an entity with a definition that is reachable from the evaluation
context, a value corresponding to a definition should be returned.
21.4.7 Reflection queries [meta.reflection.queries]
consteval bool has-type (info r); // exposition only
1 Returns: true if r represents a value, annotation, object, variable, function whose type does not contain
an undeduced placeholder type and that is not a constructor or destructor, enumerator, non-static
data member, unnamed bit-field, direct base class relationship, data member description, or function
parameter. Otherwise, false.
consteval info type_of(info r);
2 Returns:
—(2.1) If r represents theith parameter of a functionF, then theith type in the parameter-type-list of
F (9.3.4.6).
—(2.2) Otherwise, ifr represents a value, object, variable, function, non-static data member, or unnamed
bit-field, then the type of what is represented byr.
§ 21.4.7 © ISO/IEC
777

===== PAGE 789 =====

Dxxxx
—(2.3) Otherwise, ifr represents an annotation, thentype_of(constant_of(r)).
—(2.4) Otherwise, ifr represents an enumeratorN of an enumerationE, then:
—(2.4.1) If E is defined by a declarationD that precedes a pointP in the evaluation context andP
does not occur within anenum-specifier of D, then a reflection ofE.
—(2.4.2) Otherwise, a reflection of the type ofN prior to the closing brace of theenum-specifier as
specified in 9.8.1.
—(2.5) Otherwise, ifr represents a direct base class relationship(D,B), then a reflection ofB.
—(2.6) Otherwise, for a data member description(T,N,A,W, NUA) (11.4.1), a reflection of the typeT.
3 Throws: meta::exception unless has-type (r) is true.
consteval info object_of(info r);
4 Returns:
—(4.1) If r represents an object, thenr.
—(4.2) Otherwise, if r represents a reference, then a reflection of the object referred to by that reference.
—(4.3) Otherwise, r represents a variable; a reflection of the object declared by that variable.
5 Throws: meta::exception unless r is a reflection representing either
—(5.1) an object with static storage duration (6.8.6.1), or
—(5.2) a variable that either declares or refers to such an object, and if that variable is a referenceR,
then either
—(5.2.1) R is usable in constant expressions (7.7), or
—(5.2.2) the lifetime ofR began within the core constant expression currently under evaluation.
6 [Example 1:
int x;
int& y = x;
static_assert(^^x != ^^y); // OK, r and y are different variables so their
// reflections compare different
static_assert(object_of(^^x) == object_of(^^y)); // OK, becausey is a reference
// tox, their underlying objects are the same
—end example]
consteval info constant_of(info r);
7 Let R be a constant expression of typeinfo such thatR == r is true. If r represents an annotation,
then letC be its underlying constant.
8 Effects: Equivalent to:
if constexpr (is_annotation(R)) {
return C;
} else if constexpr (is_array_type(type_of(R))) {
return reflect_constant_array([: R :]);
} else if constexpr (is_function_type(type_of(R))) {
return reflect_function([: R :]);
} else {
return reflect_constant([: R :]);
}
9 Throws: meta::exception unless either r represents an annotation or [: R :] is a valid splice-
expression (7.5.9).
10 [Example 2:
constexpr int x = 0;
constexpr int y = 0;
static_assert(^^x != ^^y); // OK,x and y are different variables,
§ 21.4.7 © ISO/IEC
778

===== PAGE 790 =====

Dxxxx
// so their reflections compare different
static_assert(constant_of(^^x) ==
constant_of(^^y)); // OK, bothconstant_of(^^x) and
// constant_of(^^y) represent the value0
static_assert(constant_of(^^x) ==
reflect_constant(0)); // OK, likewise
struct S { int m; };
constexpr S s {42};
static_assert(is_object(constant_of(^^s)) &&
is_object(reflect_object(s)));
static_assert(constant_of(^^s) != // OK, template parameter object that is template-argument-
reflect_object(s)); // equivalent tos is a different object thans
static_assert(constant_of(^^s) ==
constant_of(reflect_object(s))); // OK
consteval info fn() {
constexpr int x = 42;
return ^^x;
}
constexpr info r = constant_of(fn()); // error: x is outside its lifetime
—end example]
consteval bool is_public(info r);
consteval bool is_protected(info r);
consteval bool is_private(info r);
11 Returns: true if r represents either
—(11.1) a class member or unnamed bit-field that is public, protected, or private, respectively, or
—(11.2) a direct base class relationship(D,B) for whichB is, respectively, a public, protected, or private
base class ofD.
Otherwise, false.
consteval bool is_virtual(info r);
12 Returns: true if r represents either a virtual member function or a direct base class relationship(D,B)
for whichB is a virtual base class ofD. Otherwise, false.
consteval bool is_pure_virtual(info r);
consteval bool is_override(info r);
13 Returns: true if r represents a member function that is pure virtual or overrides another member
function, respectively. Otherwise,false.
consteval bool is_final(info r);
14 Returns: true if r represents a final class or a final member function. Otherwise,false.
consteval bool is_deleted(info r);
consteval bool is_defaulted(info r);
15 Returns: true if r represents a function that is a deleted function (9.6.3) or defaulted function (9.6.2),
respectively. Otherwise,false.
consteval bool is_user_provided(info r);
consteval bool is_user_declared(info r);
16 Returns: true if r represents a function that is user-provided or user-declared (9.6.2), respectively.
Otherwise, false.
consteval bool is_explicit(info r);
17 Returns: true if r represents a member function that is declared explicit. Otherwise,false.
[Note 1: If r represents a member function template that is declared explicit,is_explicit(r) is stillfalse
because in general, such queries for templates cannot be answered.—end note]
§ 21.4.7 © ISO/IEC
779

===== PAGE 791 =====

Dxxxx
consteval bool is_noexcept(info r);
18 Returns: true if r represents anoexcept function type or a function with a non-throwing exception
specification (14.5). Otherwise,false.
[Note 2: If r represents a function template that is declarednoexcept, is_noexcept(r) is stillfalse because
in general, such queries for templates cannot be answered.—end note]
consteval bool is_bit_field(info r);
19 Returns: true if r represents a bit-field, or ifr represents a data member description(T,N,A,W, NUA)
(11.4.1) for whichW is not⊥. Otherwise, false.
consteval bool is_enumerator(info r);
consteval bool is_annotation(info r);
20 Returns: true if r represents an enumerator or annotation, respectively. Otherwise,false.
consteval bool is_const(info r);
consteval bool is_volatile(info r);
21 Let T be type_of(r) if has-type (r) is true. Otherwise, letT be dealias(r).
22 Returns: true if T represents a const or volatile type, respectively, or a const- or volatile-qualified
function type, respectively. Otherwise,false.
consteval bool is_mutable_member(info r);
23 Returns: true if r represents amutable non-static data member. Otherwise,false.
consteval bool is_lvalue_reference_qualified(info r);
consteval bool is_rvalue_reference_qualified(info r);
24 Let T be type_of(r) if has-type (r) is true. Otherwise, letT be dealias(r).
25 Returns: true if T represents an lvalue- or rvalue-qualified function type, respectively. Otherwise,
false.
consteval bool has_static_storage_duration(info r);
consteval bool has_thread_storage_duration(info r);
consteval bool has_automatic_storage_duration(info r);
26 Returns: true if r represents an object or variable that has static, thread, or automatic storage duration,
respectively (6.8.6). Otherwise,false.
[Note 3: It is not possible to have a reflection representing an object or variable having dynamic storage
duration. —end note]
consteval bool has_internal_linkage(info r);
consteval bool has_module_linkage(info r);
consteval bool has_external_linkage(info r);
consteval bool has_linkage(info r);
27 Returns: true if r represents a variable, function, type, template, or namespace whose name has
internal linkage, module linkage, external linkage, or any linkage, respectively (6.7). Otherwise,false.
consteval bool has_c_language_linkage(info r);
28 Returns: true if r represents a variable, function, or function type with C language linkage. Otherwise,
false.
consteval bool is_complete_type(info r);
29 Returns: true if is_type(r) is true and there is some point in the evaluation context from which the
type represented bydealias(r) is not an incomplete type (6.9). Otherwise,false.
consteval bool is_enumerable_type(info r);
30 A typeT is enumerable from a pointP if either
—(30.1) T is a class type complete at pointP or
—(30.2) T is an enumeration type defined by a declarationD such thatD is reachable fromP but P does
not occur within anenum-specifier of D (9.8.1).
§ 21.4.7 © ISO/IEC
780

===== PAGE 792 =====

Dxxxx
31 Returns: true if dealias(r) represents a type that is enumerable from some point in the evaluation
context. Otherwise,false.
32 [Example 3:
class S;
enum class E;
static_assert(!is_enumerable_type(^^S));
static_assert(!is_enumerable_type(^^E));
class S {
void mfn() {
static_assert(is_enumerable_type(^^S));
}
static_assert(!is_enumerable_type(^^S));
};
static_assert(is_enumerable_type(^^S));
enum class E {
A = is_enumerable_type(^^E) ? 1 : 2
};
static_assert(is_enumerable_type(^^E));
static_assert(static_cast<int>(E::A) == 2);
—end example]
consteval bool is_variable(info r);
33 Returns: true if r represents a variable. Otherwise,false.
consteval bool is_type(info r);
consteval bool is_namespace(info r);
34 Returns: true if r represents an entity whose underlying entity is a type or namespace, respectively.
Otherwise, false.
consteval bool is_type_alias(info r);
consteval bool is_namespace_alias(info r);
35 Returns: true if r represents a type alias or namespace alias, respectively. Otherwise,false.
[Note 4: A specialization of an alias template is a type alias.—end note]
consteval bool is_function(info r);
36 Returns: true if r represents a function. Otherwise,false.
consteval bool is_conversion_function(info r);
consteval bool is_operator_function(info r);
consteval bool is_literal_operator(info r);
37 Returns: true if r represents a function that is a conversion function (11.4.8.3), operator function (12.4),
or literal operator (12.6), respectively. Otherwise,false.
consteval bool is_special_member_function(info r);
consteval bool is_constructor(info r);
consteval bool is_default_constructor(info r);
consteval bool is_copy_constructor(info r);
consteval bool is_move_constructor(info r);
consteval bool is_assignment(info r);
consteval bool is_copy_assignment(info r);
consteval bool is_move_assignment(info r);
consteval bool is_destructor(info r);
38 Returns: true if r represents a function that is a special member function (11.4.4), a constructor, a
default constructor, a copy constructor, a move constructor, an assignment operator, a copy assignment
operator, a move assignment operator, or a destructor, respectively. Otherwise,false.
consteval bool is_function_parameter(info r);
39 Returns: true if r represents a function parameter. Otherwise,false.
§ 21.4.7 © ISO/IEC
781

===== PAGE 793 =====

Dxxxx
consteval bool is_explicit_object_parameter(info r);
40 Returns: true if r represents a function parameter that is an explicit object parameter (9.3.4.6).
Otherwise, false.
consteval bool has_default_argument(info r);
41 Returns: If r represents a parameterP of a functionF, then:
—(41.1) If F is a specialization of a templated functionT, thentrue if there exists a declarationD of T
that precedes some point in the evaluation context andD specifies a default argument for the
parameter ofT corresponding toP. Otherwise, false.
—(41.2) Otherwise, if there exists a declarationD of F that precedes some point in the evaluation context
and D specifies a default argument forP, thentrue.
Otherwise, false.
consteval bool has_ellipsis_parameter(info r);
42 Returns: true if r represents a function or function type that has an ellipsis in its parameter-type-
list (9.3.4.6). Otherwise,false.
consteval bool is_template(info r);
43 Returns: true if r represents a function template, class template, variable template, alias template, or
concept. Otherwise, false.
44 [Note 5: A template specialization is not a template. For example,is_template(^^std::vector) is true but
is_template(^^std::vector<int>) is false. —end note]
consteval bool is_function_template(info r);
consteval bool is_variable_template(info r);
consteval bool is_class_template(info r);
consteval bool is_alias_template(info r);
consteval bool is_conversion_function_template(info r);
consteval bool is_operator_function_template(info r);
consteval bool is_literal_operator_template(info r);
consteval bool is_constructor_template(info r);
consteval bool is_concept(info r);
45 Returns: true if r represents a function template, variable template, class template, alias template,
conversionfunctiontemplate, operatorfunctiontemplate, literaloperatortemplate, constructortemplate,
or concept, respectively. Otherwise,false.
consteval bool is_value(info r);
consteval bool is_object(info r);
46 Returns: true if r represents a value or object, respectively. Otherwise,false.
consteval bool is_structured_binding(info r);
47 Returns: true if r represents a structured binding. Otherwise,false.
consteval bool is_class_member(info r);
consteval bool is_namespace_member(info r);
consteval bool is_nonstatic_data_member(info r);
consteval bool is_static_member(info r);
consteval bool is_base(info r);
48 Returns: true if r represents a class member, namespace member, non-static data member, static
member, or direct base class relationship, respectively. Otherwise,false.
consteval bool has_default_member_initializer(info r);
49 Returns: true if r represents a non-static data member that has a default member initializer. Otherwise,
false.
consteval bool has_parent(info r);
50 Returns:
—(50.1) If r represents the global namespace, thenfalse.
§ 21.4.7 © ISO/IEC
782

===== PAGE 794 =====

Dxxxx
—(50.2) Otherwise, ifr represents an entity that has C language linkage (9.12), thenfalse.
—(50.3) Otherwise, if r represents an entity that has a language linkage other than C++ language linkage,
then an implementation-defined value.
—(50.4) Otherwise, ifr represents a type that is neither a class nor enumeration type, thenfalse.
—(50.5) Otherwise, ifr represents an entity or direct base class relationship, thentrue.
—(50.6) Otherwise, false.
consteval info parent_of(info r);
51 Returns:
—(51.1) If r represents a non-static data member that is a direct member of an anonymous union, or
an unnamed bit-field declared within themember-specification of such a union, then a reflection
representing the innermost enclosing anonymous union.
—(51.2) Otherwise, ifr represents an enumerator, then a reflection representing the corresponding enumer-
ation type.
—(51.3) Otherwise, if r represents a direct base class relationship(D,B), then a reflection representingD.
—(51.4) Otherwise, letE be a class, function, or namespace whose class scope, function parameter scope,
or namespace scope, respectively, is the innermost such scope that either is, or encloses, the target
scope of a declaration of what is represented byr.
—(51.4.1) If E is the function call operator of a closure type for aconsteval-block-declaration (9.1), then
parent_of(parent_of(^^E)).
[Note 6: In this case, the firstparent_of will be the closure type, so the secondparent_of is necessary
to give the parent of that closure type.—end note]
—(51.4.2) Otherwise, ^^E.
52 Throws: meta::exception unless has_parent(r) is true.
53 [Example 4:
struct I { };
struct F : I {
union {
int o;
};
enum N {
A
};
};
constexpr auto ctx = std::meta::access_context::current();
static_assert(parent_of(^^F) == ^^::);
static_assert(parent_of(bases_of(^^F, ctx)[0]) == ^^F);
static_assert(is_union_type(parent_of(^^F::o)));
static_assert(parent_of(^^F::N) == ^^F);
static_assert(parent_of(^^F::A) == ^^F::N);
—end example]
consteval info dealias(info r);
54 Returns: If r represents an entity, then a reflection representing the underlying entity of whatr
represents. Otherwise,r.
55 [Example 5:
using X = int;
using Y = X;
static_assert(dealias(^^int) == ^^int);
static_assert(dealias(^^X) == ^^int);
static_assert(dealias(^^Y) == ^^int);
§ 21.4.7 © ISO/IEC
783

===== PAGE 795 =====

Dxxxx
—end example]
consteval bool has_template_arguments(info r);
56 Returns: true if r represents a specialization of a function template, variable template, class template,
or an alias template. Otherwise,false.
consteval info template_of(info r);
57 Returns: A reflection of the template of the specialization represented byr.
58 Throws: meta::exception unless has_template_arguments(r) is true.
consteval vector<info> template_arguments_of(info r);
59 Returns: A vector containing reflections of the template arguments of the template specialization
represented byr, in the order in which they appear in the corresponding template argument list. For a
given template argumentA, its corresponding reflectionR is determined as follows:
—(59.1) If A denotes a type or type alias, thenR is a reflection representing the underlying entity ofA.
[Note 7: R always represents a type, never a type alias.—end note]
—(59.2) Otherwise, ifA denotes a class template, variable template, concept, or alias template, thenR is
a reflection representingA.
—(59.3) Otherwise, A is a constant template argument (13.4.3). LetP be the corresponding template
parameter.
—(59.3.1) If P has reference type, thenR is a reflection representing the object or function referred to
by A.
—(59.3.2) Otherwise, ifP has class type, thenRrepresents the corresponding template parameter object.
—(59.3.3) Otherwise, R is a reflection representing the value ofA.
60 Throws: meta::exception unless has_template_arguments(r) is true.
61 [Example 6:
template<class T, class U = T> struct Pair { };
template<class T> struct Pair<char, T> { };
template<class T> using PairPtr = Pair<T*>;
static_assert(template_of(^^Pair<int>) == ^^Pair);
static_assert(template_of(^^Pair<char, char>) == ^^Pair);
static_assert(template_arguments_of(^^Pair<int>).size() == 2);
static_assert(template_arguments_of(^^Pair<int>)[0] == ^^int);
static_assert(template_of(^^PairPtr<int>) == ^^PairPtr);
static_assert(template_arguments_of(^^PairPtr<int>).size() == 1);
struct S { };
int i;
template<int, int&, S, template<class> class>
struct X { };
constexpr auto T = ^^X<1, i, S{}, PairPtr>;
static_assert(is_value(template_arguments_of(T)[0]));
static_assert(is_object(template_arguments_of(T)[1]));
static_assert(is_object(template_arguments_of(T)[2]));
static_assert(template_arguments_of(T)[3] == ^^PairPtr);
—end example]
consteval vector<info> parameters_of(info r);
62 Returns:
—(62.1) If r represents a functionF, then avector containing reflections of the parameters ofF, in the
order in which they appear in a declaration ofF.
—(62.2) Otherwise, rrepresents a function typeT; avectorcontaining reflections of the types in parameter-
type-list (9.3.4.6) ofT, in the order in which they appear in the parameter-type-list.
§ 21.4.7 © ISO/IEC
784

===== PAGE 796 =====

Dxxxx
63 Throws: meta::exception unless r represents a function or a function type.
consteval info variable_of(info r);
64 Returns: The reflection of the parameter variable corresponding tor.
65 Throws: meta::exception unless
—(65.1) r represents a parameter of a functionF and
—(65.2) there is a pointP in the evaluation context for which the innermost non-block scope enclosingP
is the function parameter scope (6.4.4) associated withF.
consteval info return_type_of(info r);
66 Returns: The reflection of the return type of the function or function type represented byr.
67 Throws: meta::exceptionunlesseither rrepresentsafunctionand has-type (r)istrueorrrepresents
a function type.
21.4.8 Access control context [meta.reflection.access.context]
1 The classaccess_context represents a namespace, class, or function from which queries pertaining to access
rules may be performed, as well as the designating class (11.8.3), if any.
2 An access_context has an associated scope and designating class.
namespace std::meta {
struct access_context {
access_context() = delete;
consteval info scope() const;
consteval info designating_class() const;
static consteval access_context current() noexcept;
static consteval access_context unprivileged() noexcept;
static consteval access_context unchecked() noexcept;
consteval access_context via(info cls) const;
};
}
3 The type access_context is a structural, consteval-only, non-aggregate type. Two valuesac1 and ac2
of type access_context are template-argument-equivalent (13.6) ifac1.scope() and ac2.scope() are
template-argument-equivalent andac1.designating_class()and ac2.designating_class()are template-
argument-equivalent.
consteval info scope() const;
consteval info designating_class() const;
4 Returns: The access_context’s associated scope and designating class, respectively.
static consteval access_context current() noexcept;
5 Given a program pointP, leteval-point (P) be the following program point:
—(5.1) If a potentially-evaluated subexpression (6.10.1) of a default member initializerI for a member of
class C (11.4.1) appears atP, then a point determined as follows:
—(5.1.1) If an aggregate initialization is usingI, eval-point (Q), whereQ is the point at which that
aggregate initialization appears.
—(5.1.2) Otherwise, if an initialization by an inherited constructor (11.9.4) is usingI, a point whose
immediate scope is the class scope corresponding toC.
—(5.1.3) Otherwise, a point whose immediate scope is the function parameter scope corresponding to
the constructor definition that is usingI.
—(5.2) Otherwise, if a potentially-evaluated subexpression of a default argument (9.3.4.7) appears atP,
eval-point (Q), whereQis the point at which the invocation of the function (7.6.1.3) using that
default argument appears.
—(5.3) Otherwise, if the immediate scope ofP is a function parameter scope introduced by a declaration
D, andP appears either before the locus ofD or within the trailingrequires-clause of D, a point
§ 21.4.8 © ISO/IEC
785

===== PAGE 797 =====

Dxxxx
whose immediate scope is the innermost scope enclosing the locus ofD that is not a template
parameter scope.
—(5.4) Otherwise, if the immediate scope ofP is a function parameter scope introduced by alambda-
expression L whose lambda-introducer appears at point Q, and P appears either within the
trailing-return-type or the trailingrequires-clause of L, eval-point (Q).
—(5.5) Otherwise, if the innermost non-block scope enclosingP is the function parameter scope introduced
by aconsteval-block-declaration (9.1), a point whose immediate scope is that inhabited by the
outermost consteval-block-declaration D containing P such that each scope (if any) that intervenes
between P and the function parameter scope introduced byD is either
—(5.5.1) a block scope or
—(5.5.2) a function parameter scope or lambda scope introduced by aconsteval-block-declaration.
—(5.6) Otherwise, P.
6 Given a scopeS, letctx-scope (S) be the following scope:
—(6.1) If S is a class scope or namespace scope,S.
—(6.2) Otherwise, ifS is a function parameter scope introduced by the declaration of a function,S.
—(6.3) Otherwise, ifS is a lambda scope introduced by alambda-expression L, the function parameter
scope corresponding to the call operator of the closure type ofL.
—(6.4) Otherwise, ctx-scope (S′), whereS′is the parent scope ofS.
7 Returns: An access_context whose designating class is the null reflection and whose scope represents
the function, class, or namespace whose corresponding function parameter scope, class scope, or
namespace scope, respectively, isctx-scope (S), whereS is the immediate scope ofeval-point (P)
and P is the point at which the invocation ofcurrent lexically appears.
8 Remarks: currentis not an addressable function (16.4.5.2.1). An invocation ofcurrentthat appears at
a program pointP is value-dependent (13.8.3.4) ifeval-point (P) is enclosed by a scope corresponding
to a templated entity.
9 [Example 1:
struct A {
int a = 0;
consteval A(int p) : a(p) {}
};
struct B : A {
using A::A;
consteval B(int p, int q) : A(p * q) {}
info s = access_context::current().scope();
};
struct C : B { using B::B; };
struct Agg {
consteval bool eq(info rhs = access_context::current().scope()) {
return s == rhs;
}
info s = access_context::current().scope();
};
namespace NS {
static_assert(Agg{}.s == access_context::current().scope()); // OK
static_assert(Agg{}.eq()); // OK
static_assert(B(1).s == ^^B); // OK
static_assert(is_constructor(B{1, 2}.s) && parent_of(B{1, 2}.s) == ^^B); // OK
static_assert(is_constructor(C{1, 2}.s) && parent_of(C{1, 2}.s) == ^^B); // OK
auto fn() -> [:is_namespace(access_context::current().scope()) ? ^^int : ^^bool:];
static_assert(type_of(^^fn) == ^^auto()->int); // OK
§ 21.4.8 © ISO/IEC
786

===== PAGE 798 =====

Dxxxx
template<auto R>
struct TCls {
consteval bool fn()
requires (is_type(access_context::current().scope())) {
return true; // OK, scope isTCls<R>.
}
};
static_assert(TCls<0>{}.fn()); // OK
}
—end example]
static consteval access_context unprivileged() noexcept;
10 Returns: An access_context whose designating class is the null reflection and whose scope is the
global namespace.
static consteval access_context unchecked() noexcept;
11 Returns: An access_context whose designating class and scope are both the null reflection.
consteval access_context via(info cls) const;
12 Returns: An access_context whose scope isthis->scope() and whose designating class iscls.
13 Throws: meta::exception unless cls is either the null reflection or a reflection of a complete class
type.
21.4.9 Member accessibility queries [meta.reflection.access.queries]
consteval bool is_accessible(info r, access_context ctx);
1 Let PARENT-CLS (r) be:
—(1.1) If parent_of(r) represents a classC, thenC.
—(1.2) Otherwise, PARENT-CLS (parent_of(r)).
2 Let DESIGNATING-CLS (r, ctx) be:
—(2.1) If ctx.designating_class() represents a classC, thenC.
—(2.2) Otherwise, PARENT-CLS (r).
3 Returns:
—(3.1) If r represents an unnamed bit-fieldF, thenis_accessible(rH, ctx), whererH represents a
hypothetical non-static data member of the class represented byPARENT-CLS (r) with the same
access asF.
[Note 1: Unnamed bit-fields are treated as class members for the purpose ofis_accessible. —end note]
—(3.2) Otherwise, ifr does not represent a class member or a direct base class relationship, thentrue.
—(3.3) Otherwise, ifr represents
—(3.3.1) a class member that is not a (possibly indirect or variant) member ofDESIGNATING-CLS (r,
ctx) or
—(3.3.2) a direct base class relationship such thatparent_of(r)does not representDESIGNATING-CLS (
r, ctx) or a (direct or indirect) base class thereof,
then false.
—(3.4) Otherwise, ifctx.scope() is the null reflection, thentrue.
—(3.5) Otherwise, lettingP be a program point whose immediate scope is the function parameter scope,
class scope, or namespace scope corresponding to the function, class, or namespace represented by
ctx.scope():
—(3.5.1) If r represents a direct base class relationship(D,B), thentrue if base classB of DESIG-
NATING-CLS (r, ctx) is accessible atP (11.8.3); otherwisefalse.
—(3.5.2) Otherwise, r represents a class memberM; true if M would be accessible atP with the
designating class (11.8.3) asDESIGNATING-CLS (r, ctx) if the effect of anyusing-declarations
(9.10) were ignored. Otherwise,false.
§ 21.4.9 © ISO/IEC
787

===== PAGE 799 =====

Dxxxx
[Note 2: The definitions of when a class member or base class is accessible from a pointP do not consider
whether a declaration of that entity is reachable fromP. —end note]
4 Throws: meta::exception if r represents a class member for whichPARENT-CLS (r) is an incomplete
class.
5 [Example 1:
consteval access_context fn() {
return access_context::current();
}
class Cls {
int mem;
friend consteval access_context fn();
public:
static constexpr auto r = ^^mem;
};
static_assert(is_accessible(Cls::r, fn())); // OK
static_assert(!is_accessible(Cls::r, access_context::current())); // OK
static_assert(is_accessible(Cls::r, access_context::unchecked())); // OK
—end example]
consteval bool has_inaccessible_nonstatic_data_members(info r, access_context ctx);
6 Returns: true if is_accessible(R, ctx) is false for any R in nonstatic_data_members_of(r,
access_context::unchecked()). Otherwise, false.
7 Throws: meta::exception if
—(7.1) the evaluation ofnonstatic_data_members_of(r, access_context::unchecked()) would exit
via an exception or
—(7.2) r represents a closure type.
consteval bool has_inaccessible_bases(info r, access_context ctx);
8 Returns: true if is_accessible(R, ctx) is false for any R in bases_of(r, access_context::
unchecked()). Otherwise, false.
9 Throws: meta::exception if the evaluation ofbases_of(r, access_context::unchecked()) would
exit via an exception.
consteval bool has_inaccessible_subobjects(info r, access_context ctx);
10 Effects: Equivalent to:
return has_inaccessible_bases(r, ctx) || has_inaccessible_nonstatic_data_members(r, ctx);
21.4.10 Reflection member queries [meta.reflection.member.queries]
consteval vector<info> members_of(info r, access_context ctx);
1 A declaration D members-of-precedesa point P if D precedes either P or the point immediately
following theclass-specifier of the outermost class for whichP is in a complete-class context.
2 A declarationD of a memberM of a class or namespaceQ is Q-members-of-eligible if
—(2.1) the host scope ofD (6.4.1) is the class scope or namespace scope associated withQ,
—(2.2) D is not a friend declaration,
—(2.3) M is not a closure type (7.5.6.2),
—(2.4) M is not a specialization of a template (13.1),
—(2.5) if Q is a class that is not a closure type, thenM is a direct member ofQ (11.4.1) that is not a
variant member of a nested anonymous union ofQ (11.5.2), and
—(2.6) if Q is a closure type, thenM is a function call operator or function call operator template.
It is implementation-defined whether declarations of other members of a closure typeQare Q-members-
of-eligible.
§ 21.4.10 © ISO/IEC
788

===== PAGE 800 =====

Dxxxx
3 A memberM of a class or namespaceQis Q-members-of-representablefrom a pointP if aQ-members-
of-eligible declaration ofM members-of-precedes P, andM is
—(3.1) a class or enumeration type,
—(3.2) a type alias,
—(3.3) a class template, function template, variable template, alias template, or concept,
—(3.4) a variable or referenceV for which the type ofV does not contain an undeduced placeholder type,
—(3.5) a functionF for which
—(3.5.1) the type ofF does not contain an undeduced placeholder type,
—(3.5.2) the constraints (if any) ofF are satisfied, and
—(3.5.3) if F is a prospective destructor,F is the selected destructor (11.4.7),
—(3.6) a non-static data member,
—(3.7) a namespace, or
—(3.8) a namespace alias.
[Note 1: Examples of direct members that are notQ-members-of-representable for any entityQ include:
unscoped enumerators (9.8), partial specializations of templates (13.7.6), and closure types (7.5.6.2).—end
note]
4 Returns: A vector containing reflections of all membersM of the entityQrepresented bydealias(r)
for which
—(4.1) M is Q-members-of-representable from some point in the evaluation context and
—(4.2) is_accessible(^^M, ctx) is true.
If dealias(r) represents a classC, then the vector also contains reflections representing all un-
named bit-fields B whose declarations inhabit the class scope corresponding toC for which is_-
accessible(^^B, ctx) is true. Reflections of class members and unnamed bit-fields that are declared
appear in the order in which they are declared.
[Note 2: Base classes are not members. Implicitly-declared special members appear after any user-declared
members (11.4.4). —end note]
5 Throws: meta::exception unless dealias(r) is a reflection representing either a class type that is
complete from some point in the evaluation context or a namespace.
6 [Example 1:
// TU1
export module M;
namespace NS {
export int m;
static int l;
}
static_assert(members_of(^^NS, access_context::current()).size() == 2);
// TU2
import M;
static_assert( // NS::l does not precede
members_of(^^NS, access_context::current()).size() == 1); // the constant-expression (6.5)
class B {};
struct S : B {
private:
class I;
public:
int m;
};
static_assert( // 6 special members,
members_of(^^S, access_context::current()).size() == 7); // 1 public member,
§ 21.4.10 © ISO/IEC
789