

===== PAGE 401 =====

Dxxxx
[Example 1:
struct A {};
struct B : public A {} b;
int f(A&);
int f(B&);
int i = f(b); // calls f(B&), an exact match, rather thanf(A&), a conversion
void g() noexcept;
int h(void (&)() noexcept); // #1
int h(void (&)()); // #2
int j = h(g); // calls #1, an exact match, rather than #2, a function pointer conversion
—end example]
If the parameter binds directly to the result of applying a conversion function to the argument expression,
the implicit conversion sequence is a user-defined conversion sequence (12.2.4.2.3) whose second standard
conversion sequence is determined by the above rules.
2 When a parameter of reference type is not bound directly to an argument expression, the conversion
sequence is the one required to convert the argument expression to the referenced type according to 12.2.4.2.
Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the referenced type
with the argument expression. Any difference in top-level cv-qualification is subsumed by the initialization
itself and does not constitute a conversion.
3 Except for an implicit object parameter, for which see 12.2.2, an implicit conversion sequence cannot be
formed if it requires binding an lvalue reference other than a reference to a non-volatileconst type to an
rvalue or binding an rvalue reference to an lvalue of object type.
[Note 1: This means, for example, that a candidate function cannot be a viable function if it has a non-const lvalue
reference parameter (other than the implicit object parameter) and the corresponding argument would require a
temporary to be created to initialize the lvalue reference (see 9.5.4).—end note]
4 Other restrictions on binding a reference to a particular argument that are not based on the types of the
reference and the argument do not affect the formation of an implicit conversion sequence, however.
[Example 2: A function with an “lvalue reference toint” parameter can be a viable candidate even if the corresponding
argument is anint bit-field. The formation of implicit conversion sequences treats theint bit-field as anint lvalue
and finds an exact match with the parameter. If the function is selected by overload resolution, the call will nonetheless
be ill-formed because of the prohibition on binding a non-const lvalue reference to a bit-field (9.5.4).—end example]
12.2.4.2.6 List-initialization sequence [over.ics.list]
1 When an argument is an initializer list (9.5.5), it is not an expression and special rules apply for converting
it to a parameter type.
2 If the initializer list is adesignated-initializer-list and the parameter is not a reference, a conversion is only
possible if the parameter has an aggregate type that can be initialized from the initializer list according to
the rules for aggregate initialization (9.5.2), in which case the implicit conversion sequence is a user-defined
conversion sequence whose second standard conversion sequence is an identity conversion.
[Note 1: Aggregate initialization does not require that the members are declared in designation order. If, after
overload resolution, the order does not match for the selected overload, the initialization of the parameter will be
ill-formed (9.5.5).
[Example 1:
struct A { int x, y; };
struct B { int y, x; };
void f(A a, int); // #1
void f(B b, ...); // #2
void g(A a); // #3
void g(B b); // #4
void h() {
f({.x = 1, .y = 2}, 0); // OK; calls #1
f({.y = 2, .x = 1}, 0); // error: selects #1, initialization ofa fails
// due to non-matching member order (9.5.5)
g({.x = 1, .y = 2}); // error: ambiguous between #3 and #4
}
—end example]
§ 12.2.4.2.6 © ISO/IEC
390

===== PAGE 402 =====

Dxxxx
—end note]
3 Otherwise, if the parameter type is an aggregate classX and the initializer list has a single element of type
cv U, whereU is X or a class derived fromX, the implicit conversion sequence is the one required to convert
the element to the parameter type.
4 Otherwise, if the parameter type is a character array101 and the initializer list has a single element that is an
appropriately-typed string-literal (9.5.3), the implicit conversion sequence is the identity conversion.
5 Otherwise, if the parameter type isstd::initializer_list<X> and all the elements of the initializer list
can be implicitly converted toX, the implicit conversion sequence is the worst conversion necessary to convert
an element of the list toX, or if the initializer list has no elements, the identity conversion. This conversion
can be a user-defined conversion even in the context of a call to an initializer-list constructor.
[Example 2:
void f(std::initializer_list<int>);
f( {} ); // OK,f(initializer_list<int>) identity conversion
f( {1,2,3} ); // OK,f(initializer_list<int>) identity conversion
f( {'a','b'} ); // OK,f(initializer_list<int>) integral promotion
f( {1.0} ); // error: narrowing
struct A {
A(std::initializer_list<double>); // #1
A(std::initializer_list<std::complex<double>>); // #2
A(std::initializer_list<std::string>); // #3
};
A a{ 1.0,2.0 }; // OK, uses #1
void g(A);
g({ "foo", "bar" }); // OK, uses #3
typedef int IA[3];
void h(const IA&);
h({ 1, 2, 3 }); // OK, identity conversion
—end example]
6 Otherwise, if the parameter type is “array ofN X” or “array of unknown bound ofX”, if there exists an
implicit conversion sequence from each element of the initializer list (and from{} in the former case ifN
exceeds the number of elements in the initializer list) toX, the implicit conversion sequence is the worst such
implicit conversion sequence.
7 Otherwise, if the parameter is a non-aggregate classX and overload resolution per 12.2.2.8 chooses a single
best constructorC of X to perform the initialization of an object of typeX from the argument initializer list:
—(7.1) If C is not an initializer-list constructor and the initializer list has a single element of typecv U, where
U is X or a class derived fromX, the implicit conversion sequence has Exact Match rank ifU is X, or
Conversion rank ifU is derived fromX.
—(7.2) Otherwise, the implicit conversion sequence is a user-defined conversion sequence whose second standard
conversion sequence is an identity conversion.
If multiple constructors are viable but none is better than the others, the implicit conversion sequence is
the ambiguous conversion sequence. User-defined conversions are allowed for conversion of the initializer list
elements to the constructor parameter types except as noted in 12.2.4.2.
[Example 3:
struct A {
A(std::initializer_list<int>);
};
void f(A);
f( {'a', 'b'} ); // OK,f(A(std::initializer_list<int>)) user-defined conversion
struct B {
B(int, double);
};
101) Since there are no parameters of array type, this will only occur as the referenced type of a reference parameter.
§ 12.2.4.2.6 © ISO/IEC
391

===== PAGE 403 =====

Dxxxx
void g(B);
g( {'a', 'b'} ); // OK,g(B(int, double)) user-defined conversion
g( {1.0, 1.0} ); // error: narrowing
void f(B);
f( {'a', 'b'} ); // error: ambiguousf(A) or f(B)
struct C {
C(std::string);
};
void h(C);
h({"foo"}); // OK,h(C(std::string("foo")))
struct D {
D(A, C);
};
void i(D);
i({ {1,2}, {"bar"} }); // OK,i(D(A(std::initializer_list<int>{1,2}), C(std::string("bar"))))
—end example]
8 Otherwise, if the parameter has an aggregate type which can be initialized from the initializer list according
to the rules for aggregate initialization (9.5.2), the implicit conversion sequence is a user-defined conversion
sequence whose second standard conversion sequence is an identity conversion.
[Example 4:
struct A {
int m1;
double m2;
};
void f(A);
f( {'a', 'b'} ); // OK,f(A(int,double)) user-defined conversion
f( {1.0} ); // error: narrowing
—end example]
9 Otherwise, if the parameter is a reference, see 12.2.4.2.5.
[Note 2: The rules in this subclause will apply for initializing the underlying temporary for the reference.—end note]
[Example 5:
struct A {
int m1;
double m2;
};
void f(const A&);
f( {'a', 'b'} ); // OK,f(A(int,double)) user-defined conversion
f( {1.0} ); // error: narrowing
void g(const double &);
g({1}); // same conversion asint to double
—end example]
10 Otherwise, if the parameter type is not a class:
—(10.1) if the initializer list has one element that is not itself an initializer list, the implicit conversion sequence
is the one required to convert the element to the parameter type;
[Example 6:
void f(int);
f( {'a'} ); // OK, same conversion aschar to int
f( {1.0} ); // error: narrowing
—end example]
—(10.2) if the initializer list has no elements, the implicit conversion sequence is the identity conversion.
§ 12.2.4.2.6 © ISO/IEC
392

===== PAGE 404 =====

Dxxxx
[Example 7:
void f(int);
f( { } ); // OK, identity conversion
—end example]
11 In all cases other than those enumerated above, no conversion is possible.
12.2.4.3 Ranking implicit conversion sequences [over.ics.rank]
1 This subclause defines a partial ordering of implicit conversion sequences based on the relationshipsbetter
conversion sequenceand better conversion. If an implicit conversion sequence S1 is defined by these rules to
be a better conversion sequence than S2, then it is also the case that S2 is aworse conversion sequencethan
S1. If conversion sequence S1 is neither better than nor worse than conversion sequence S2, S1 and S2 are
said to beindistinguishable conversion sequences.
2 When comparing the basic forms of implicit conversion sequences (as defined in 12.2.4.2)
—(2.1) a standard conversion sequence (12.2.4.2.2) is a better conversion sequence than a user-defined conversion
sequence or an ellipsis conversion sequence, and
—(2.2) a user-defined conversion sequence (12.2.4.2.3) is a better conversion sequence than an ellipsis conversion
sequence (12.2.4.2.4).
3 Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of
the following rules applies:
—(3.1) List-initialization sequenceL1 is a better conversion sequence than list-initialization sequenceL2 if
—(3.1.1) L1 converts tostd::initializer_list<X> for someX and L2 does not, or, if not that,
—(3.1.2) L1 and L2 convert to arrays of the same element type, and either the number of elementsn1
initialized by L1 is less than the number of elementsn2 initialized by L2, or n1 = n2 and L2
converts to an array of unknown bound andL1 does not,
even if one of the other rules in this paragraph would otherwise apply.
[Example 1:
void f1(int); // #1
void f1(std::initializer_list<long>); // #2
void g1() { f1({42}); } // chooses #2
void f2(std::pair<const char*, const char*>); // #3
void f2(std::initializer_list<std::string>); // #4
void g2() { f2({"foo","bar"}); } // chooses #4
—end example]
[Example 2:
void f(int (&&)[] ); // #1
void f(double (&&)[] ); // #2
void f(int (&&)[2]); // #3
f( {1} ); // Calls #1: Better than #2 due to conversion, better than #3 due to bounds
f( {1.0} ); // Calls #2: Identity conversion is better than floating-integral conversion
f( {1.0, 2.0} ); // Calls #2: Identity conversion is better than floating-integral conversion
f( {1, 2} ); // Calls #3: Converting to array of known bound is better than to unknown bound,
// and an identity conversion is better than floating-integral conversion
—end example]
—(3.2) Standard conversion sequenceS1 is a better conversion sequence than standard conversion sequenceS2
if
—(3.2.1) S1 is a proper subsequence ofS2 (comparing the conversion sequences in the canonical form
defined by 12.2.4.2.2, excluding any Lvalue Transformation; the identity conversion sequence is
considered to be a subsequence of any non-identity conversion sequence) or, if not that,
—(3.2.2) the rank ofS1is better than the rank ofS2, orS1andS2have the same rank and are distinguishable
by the rules in the paragraph below, or, if not that,
§ 12.2.4.3 © ISO/IEC
393

===== PAGE 405 =====

Dxxxx
—(3.2.3) S1 and S2 include reference bindings (9.5.4) and neither refers to an implicit object parameter of
a non-static member function declared without aref-qualifier, andS1 binds an rvalue reference to
an rvalue andS2 binds an lvalue reference
[Example 3:
int i;
int f1();
int&& f2();
int g(const int&);
int g(const int&&);
int j = g(i); // calls g(const int&)
int k = g(f1()); // calls g(const int&&)
int l = g(f2()); // calls g(const int&&)
struct A {
A& operator<<(int);
void p() &;
void p() &&;
};
A& operator<<(A&&, char);
A() << 1; // calls A::operator<<(int)
A() << 'c'; // calls operator<<(A&&, char)
A a;
a << 1; // calls A::operator<<(int)
a << 'c'; // calls A::operator<<(int)
A().p(); // calls A::p()&&
a.p(); // calls A::p()&
—end example]
or, if not that,
—(3.2.4) S1 and S2 include reference bindings (9.5.4) andS1 binds an lvalue reference to an lvalue of
function type andS2 binds an rvalue reference to an lvalue of function type
[Example 4:
int f(void(&)()); // #1
int f(void(&&)()); // #2
void g();
int i1 = f(g); // calls #1
—end example]
or, if not that,
—(3.2.5) S1 and S2 differ only in their qualification conversion (7.3.6) and yield similar typesT1 and T2,
respectively (where a standard conversion sequence that is a reference binding is considered to
yield the cv-unqualified referenced type), whereT1 and T2 are not the same type, andconst T2
is reference-compatible withT1 (9.5.4)
[Example 5:
int f(const volatile int *);
int f(const int *);
int i;
int j = f(&i); // calls f(const int*)
int g(const int*);
int g(const volatile int* const&);
int* p;
int k = g(p); // calls g(const int*)
—end example]
or, if not that,
—(3.2.6) S1 and S2 bind “reference toT1” and “reference toT2”, respectively (9.5.4), whereT1 and T2 are
not the same type, andT2 is reference-compatible withT1
[Example 6:
int f(const int &);
§ 12.2.4.3 © ISO/IEC
394

===== PAGE 406 =====

Dxxxx
int f(int &);
int g(const int &);
int g(int);
int i;
int j = f(i); // calls f(int &)
int k = g(i); // ambiguous
struct X {
void f() const;
void f();
};
void g(const X& a, X b) {
a.f(); // calls X::f() const
b.f(); // calls X::f()
}
int h(int (&)[]);
int h(int (&)[1]);
void g2() {
int a[1];
h(a); // calls h(int (&)[1])
}
—end example]
or, if not that,
—(3.2.7) S1 and S2 bind the same reference type “reference toT” and have source typesV1 and V2,
respectively, where the standard conversion sequence fromV1* to T* is better than the standard
conversion sequence fromV2* to T*.
[Example 7:
struct Z {};
struct A {
operator Z&();
operator const Z&(); // #1
};
struct B {
operator Z();
operator const Z&&(); // #2
};
const Z& r1 = A(); // OK, uses #1
const Z&& r2 = B(); // OK, uses #2
—end example]
—(3.3) User-defined conversion sequenceU1is a better conversion sequence than another user-defined conversion
sequence U2 if they contain the same user-defined conversion function or constructor or they initialize
the same class in an aggregate initialization and in either case the second standard conversion sequence
of U1 is better than the second standard conversion sequence ofU2.
[Example 8:
struct A {
operator short();
} a;
int f(int);
int f(float);
int i = f(a); // calls f(int), becauseshort →int is
// better thanshort →float.
—end example]
§ 12.2.4.3 © ISO/IEC
395

===== PAGE 407 =====

Dxxxx
4 Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a
Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank
are indistinguishable unless one of the following rules applies:
—(4.1) A conversion that does not convert a pointer or a pointer to member tobool is better than one that
does.
—(4.2) A conversion that promotes an enumeration whose underlying type is fixed to its underlying type is
better than one that promotes to the promoted underlying type, if the two are different.
—(4.3) A conversion in either direction between floating-point typeFP1 and floating-point typeFP2 is better
than a conversion in the same direction betweenFP1 and arithmetic typeT3 if
—(4.3.1) the floating-point conversion rank (6.9.6) ofFP1 is equal to the rank ofFP2, and
—(4.3.2) T3 is not a floating-point type, orT3 is a floating-point type whose rank is not equal to the rank
of FP1, or the floating-point conversion subrank (6.9.6) ofFP2 is greater than the subrank ofT3.
[Example 9:
int f(std::float32_t);
int f(std::float64_t);
int f(long long);
float x;
std::float16_t y;
int i = f(x); // calls f(std::float32_t) on implementations where
// float and std::float32_t have equal conversion ranks
int j = f(y); // error: ambiguous, no equal conversion rank
—end example]
—(4.4) If classB is derived directly or indirectly from classA, conversion ofB* to A* is better than conversion
of B* to void*, and conversion ofA* to void* is better than conversion ofB* to void*.
—(4.5) If classB is derived directly or indirectly from classA and classC is derived directly or indirectly fromB,
—(4.5.1) conversion ofC* to B* is better than conversion ofC* to A*,
[Example 10:
struct A {};
struct B : public A {};
struct C : public B {};
C* pc;
int f(A*);
int f(B*);
int i = f(pc); // calls f(B*)
—end example]
—(4.5.2) conversion ofA::* to B::* is better than conversion ofA::* to C::*,
—(4.5.3) conversion ofC to B is better than conversion ofC to A,
—(4.5.4) conversion ofB* to A* is better than conversion ofC* to A*,
—(4.5.5) conversion ofB::* to C::* is better than conversion ofA::* to C::*, and
—(4.5.6) conversion ofB to A is better than conversion ofC to A.
[Note 1: Compared conversion sequences will have different source types only in the context of comparing the
second standard conversion sequence of an initialization by user-defined conversion (see 12.2.4); in all other
contexts, the source types will be the same and the target types will be different.—end note]
12.3 Address of an overload set [over.over]
1 An expression that designates an overload setS and that appears without arguments is resolved to a function,
a pointer to function, or a pointer to member function for a specific function that is chosen from a set of
functions selected fromS determined based on the target type required in the context (if any), as described
below. The target can be
—(1.1) an object or reference being initialized (9.5, 9.5.4, 9.5.5),
—(1.2) the left side of an assignment (7.6.19),
—(1.3) a parameter of a function (7.6.1.3),
§ 12.3 © ISO/IEC
396

===== PAGE 408 =====

Dxxxx
—(1.4) a parameter of a user-defined operator (12.4),
—(1.5) the return value of a function, operator function, or conversion (8.8.4),
—(1.6) an explicit type conversion (7.6.1.4, 7.6.1.9, 7.6.3), or
—(1.7) a constant template parameter (13.4.3).
If the target type contains a placeholder type, placeholder type deduction is performed (9.2.9.7.2), and the
remainder of this subclause uses the target type so deduced. The expression can be preceded by the&
operator.
[Note 1: Any redundant set of parentheses surrounding the function name is ignored (7.5.4).—end note]
2 If there is no target, all non-template functions named are selected. Otherwise, a non-template function with
type F is selected for the function typeFT of the target type ifF (after possibly applying the function pointer
conversion (7.3.14)) is identical toFT.
[Note 2: That is, the class of which the function is a member is ignored when matching a pointer-to-member-function
type. —end note]
3 The specialization, if any, generated by template argument deduction (13.10.4, 13.10.3.3, 13.10.2) for each
function template named is added to the set of selected functions considered.
4 Non-member functions, static member functions, and explicit object member functions match targets of
function pointer type or reference to function type. Implicit object member functions match targets of
pointer-to-member-function type.
[Note 3: If an implicit object member function is chosen, the result can be used only to form a pointer to member
(7.6.2.2). —end note]
5 All functions with associated constraints that are not satisfied (13.5.3) are eliminated from the set of selected
functions. If more than one function in the set remains, all function template specializations in the set
are eliminated if the set also contains a function that is not a function template specialization. Any given
non-template function F0 is eliminated if the set contains a second non-template function that is more
partial-ordering-constrained thanF0 (13.5.5). Any given function template specializationF1 is eliminated if
the set contains a second function template specialization whose function template is more specialized than
the function template ofF1 according to the partial ordering rules of 13.7.7.3. After such eliminations, if any,
there shall remain exactly one selected function.
6 [Example 1:
int f(double);
int f(int);
int (*pfd)(double) = &f; // selectsf(double)
int (*pfi)(int) = &f; // selectsf(int)
int (*pfe)(...) = &f; // error: type mismatch
int (&rfi)(int) = f; // selectsf(int)
int (&rfd)(double) = f; // selectsf(double)
void g() {
(int (*)(int))&f; // cast expression as selector
}
The initialization ofpfe is ill-formed because nof() with typeint(...) has been declared, and not because of any
ambiguity. —end example]
[Example 2:
struct X {
int f(int);
static int f(long);
};
int (X::*p1)(int) = &X::f; // OK
int (*p2)(int) = &X::f; // error: mismatch
int (*p3)(long) = &X::f; // OK
int (X::*p4)(long) = &X::f; // error: mismatch
int (X::*p5)(int) = &(X::f); // error: wrong syntax for
// pointer to member
int (*p6)(long) = &(X::f); // OK
—end example]
§ 12.3 © ISO/IEC
397

===== PAGE 409 =====

Dxxxx
[Example 3:
template<bool B> struct X {
void f(short) requires B;
void f(long);
template<typename> void g(short) requires B;
template<typename> void g(long);
};
void test() {
&X<true>::f; // error: ambiguous; constraints are not considered
&X<true>::g<int>; // error: ambiguous; constraints are not considered
}
—end example]
7 [Note 4: If f and g are both overload sets, the Cartesian product of possibilities is considered to resolvef(&g), or the
equivalent expressionf(g). —end note]
8 [Note 5: Even ifB is a public base ofD, we have
D* f();
B* (*p1)() = &f; // error
void g(D*);
void (*p2)(B*) = &g; // error
—end note]
12.4 Overloaded operators [over.oper]
12.4.1 General [over.oper.general]
1 A declaration whosedeclarator-id is anoperator-function-id shall declare a function or function template or an
explicit instantiation or specialization of a function template. A function so declared is anoperator function.
A function template so declared is anoperator function template. A specialization of an operator function
template is also an operator function. An operator function is said toimplement the operator named in its
operator-function-id.
operator-function-id:
operator operator
operator: one of
new delete new[] delete[] co_await ( ) [ ] -> ->*
~ ! + - * / % ^ &
| = += -= *= /= %= ^= &=
|= == != < > <= >= <=> &&
|| << >> <<= >>= ++ -- ,
[Note 1: The operatorsnew[], delete[], (), and[] are formed from more than one token. The latter two operators
are function call (7.6.1.3) and subscripting (7.6.1.2).—end note]
2 Both the unary and binary forms of
+ - * &
can be overloaded.
3 [Note 2: The following operators cannot be overloaded:
. .* :: ?:
nor can the preprocessing symbols# (15.7.3) and## (15.7.4). —end note]
4 Operator functions are usually not called directly; instead they are invoked to evaluate the operators they
implement (12.4.2 – 12.4.7). They can be explicitly called, however, using theoperator-function-id as the
name of the function in the function call syntax (7.6.1.3).
[Example 1:
complex z = a.operator+(b); // complex z = a+b;
void* p = operator new(sizeof(int)*n);
—end example]
§ 12.4.1 © ISO/IEC
398

===== PAGE 410 =====

Dxxxx
5 The allocation and deallocation functions,operator new, operator new[], operator delete, andoperator
delete[], are described completely in 6.8.6.5. The attributes and restrictions found in the rest of 12.4 do
not apply to them unless explicitly stated in 6.8.6.5.
6 The co_await operator is described completely in 7.6.2.4. The attributes and restrictions found in the rest
of 12.4 do not apply to it unless explicitly stated in 7.6.2.4.
7 An operator function shall have at least one function parameter or implicit object parameter whose type is a
class, a reference to a class, an enumeration, or a reference to an enumeration. It is not possible to change
the precedence, grouping, or number of operands of operators. The meaning of the operators=, (unary)
&, and, (comma), predefined for each type, can be changed for specific class types by defining operator
functions that implement these operators. Likewise, the meaning of the operators (unary)& and , (comma)
can be changed for specific enumeration types. Operator functions are inherited in the same manner as other
base class functions.
8 An operator function shall be a prefix unary, binary, function call, subscripting, class member access,
increment, or decrement operator function.
9 [Note 3: The identities among certain predefined operators applied to fundamental types (for example,++a ≡a+=1)
need not hold for operator functions. Some predefined operators, such as+=, require an operand to be an lvalue when
applied to fundamental types; this is not required by operator functions.—end note]
10 An operator function cannot have default arguments (9.3.4.7), except where explicitly stated below. Operator
functions cannot have more or fewer parameters than the number required for the corresponding operator, as
described in the rest of 12.4.
11 Operators not mentioned explicitly in subclauses 12.4.3.2 through 12.4.7 act as ordinary unary and binary
operators obeying the rules of 12.4.2 or 12.4.3.
12.4.2 Unary operators [over.unary]
1 A prefix unary operator functionis a function namedoperator@ for a prefixunary-operator @ (7.6.2.2) that
is either a non-static member function (11.4.2) with no non-object parameters or a non-member function
with one parameter. For aunary-expression of the form@ cast-expression, the operator function is selected by
overload resolution (12.2.2.3). If a member function is selected, the expression is interpreted as
cast-expression . operator @ ()
Otherwise, if a non-member function is selected, the expression is interpreted as
operator @ (cast-expression )
[Note 1: The operators++ and -- (7.6.2.3) are described in 12.4.7.—end note]
2 [Note 2: The unary and binary forms of the same operator have the same name. Consequently, a unary operator can
hide a binary operator from an enclosing scope, and vice versa.—end note]
12.4.3 Binary operators [over.binary]
12.4.3.1 General [over.binary.general]
1 A binary operator functionis a function namedoperator@ for a binary operator@ that is either a non-static
member function (11.4.2) with one non-object parameter or a non-member function with two parameters.
For an expressionx @ y with subexpressionsxand y, the operator function is selected by overload resolution
(12.2.2.3). If a member function is selected, the expression is interpreted as
x . operator @ (y )
Otherwise, if a non-member function is selected, the expression is interpreted as
operator @ (x , y )
2 An equality operator functionis an operator function for an equality operator (7.6.10). Arelational operator
function is an operator function for a relational operator (7.6.9). Athree-way comparison operator function
is an operator function for the three-way comparison operator (7.6.8). Acomparison operator functionis an
equality operator function, a relational operator function, or a three-way comparison operator function.
12.4.3.2 Simple assignment [over.assign]
1 A simple assignment operator functionis a binary operator function namedoperator=. A simple assignment
operator function shall be a non-static member function.
§ 12.4.3.2 © ISO/IEC
399

===== PAGE 411 =====

Dxxxx
[Note 1: Because only standard conversion sequences are considered when converting to the left operand of an
assignment operation (12.2.4.2), an expressionx = y with a subexpressionx of class type is always interpreted as
x.operator=(y). —end note]
2 [Note 2: Since a copy assignment operator is implicitly declared for a class if not declared by the user (11.4.6), a base
class assignment operator function is always hidden by the copy assignment operator function of the derived class.
—end note]
3 [Note 3: Any assignment operator function, even the copy and move assignment operators, can be virtual. For a
derived classD with a base classB for which a virtual copy/move assignment has been declared, the copy/move
assignment operator inD does not overrideB’s virtual copy/move assignment operator.
[Example 1:
struct B {
virtual int operator= (int);
virtual B& operator= (const B&);
};
struct D : B {
virtual int operator= (int);
virtual D& operator= (const B&);
};
D dobj1;
D dobj2;
B* bptr = &dobj1;
void f() {
bptr->operator=(99); // calls D::operator=(int)
*bptr = 99; // ditto
bptr->operator=(dobj2); // calls D::operator=(const B&)
*bptr = dobj2; // ditto
dobj1 = dobj2; // calls implicitly-declaredD::operator=(const D&)
}
—end example]
—end note]
12.4.4 Function call [over.call]
1 A function call operator functionis a function namedoperator() that is a member function with an arbitrary
number of parameters. It may have default arguments. For an expression of the form
postfix-expression ( expression-listopt )
where thepostfix-expression is of class type, the operator function is selected by overload resolution (12.2.2.2.3).
If a surrogate call function is selected, lete be the result of invoking the corresponding conversion operator
function on thepostfix-expression;
the expression is interpreted as
e ( expression-listopt )
Otherwise, the expression is interpreted as
postfix-expression . operator () (expression-listopt )
12.4.5 Subscripting [over.sub]
1 A subscripting operator functionis a member function namedoperator[] with an arbitrary number of
parameters. It may have default arguments. For an expression of the form
postfix-expression [ expression-listopt ]
the operator function is selected by overload resolution (12.2.2.3). If a member function is selected, the
expression is interpreted as
postfix-expression .operator [] (expression-listopt )
2 [Example 1:
struct X {
Z operator[](std::initializer_list<int>);
Z operator[](auto...);
};
§ 12.4.5 © ISO/IEC
400

===== PAGE 412 =====

Dxxxx
X x;
x[{1,2,3}] = 7; // OK, meaningx.operator[]({1,2,3})
x[1,2,3] = 7; // OK, meaningx.operator[](1,2,3)
int a[10];
a[{1,2,3}] = 7; // error: built-in subscript operator
a[1,2,3] = 7; // error: built-in subscript operator
—end example]
12.4.6 Class member access [over.ref]
1 A class member access operator functionis a function namedoperator-> that is a non-static member
function taking no non-object parameters. For an expression of the form
postfix-expression -> templateopt id-expression
the operator function is selected by overload resolution (12.2.2.3), and the expression is interpreted as
( postfix-expression .operator -> () ) -> templateopt id-expression
Analogously, for an expression of the form
postfix-expression -> splice-expression
the operator function is selected by overload resolution, and the expression is interpreted as
( postfix-expression .operator -> () ) ->splice-expression
12.4.7 Increment and decrement [over.inc]
1 An increment operator functionis a function namedoperator++. If this function is a non-static member
function with no non-object parameters, or a non-member function with one parameter, it defines the prefix
increment operator++ for objects of that type. If the function is a non-static member function with one
non-object parameter (which shall be of typeint) or a non-member function with two parameters (the second
of which shall be of typeint), it defines the postfix increment operator++ for objects of that type. When
the postfix increment is called as a result of using the++ operator, theint argument will have value zero.102
[Example 1:
struct X {
X& operator++(); // prefix++a
X operator++(int); // postfixa++
};
struct Y { };
Y& operator++(Y&); // prefix++b
Y operator++(Y&, int); // postfixb++
void f(X a, Y b) {
++a; // a.operator++();
a++; // a.operator++(0);
++b; // operator++(b);
b++; // operator++(b, 0);
a.operator++(); // explicit call: like++a;
a.operator++(0); // explicit call: likea++;
operator++(b); // explicit call: like++b;
operator++(b, 0); // explicit call: likeb++;
}
—end example]
2 A decrement operator functionis a function namedoperator-- and is handled analogously to an increment
operator function.
12.5 Built-in operators [over.built]
1 The candidate operator functions that represent the built-in operators defined in 7.6 are specified in this
subclause. These candidate functions participate in the operator overload resolution process as described
in 12.2.2.3 and are used for no other purpose.
102) Calling operator++ explicitly, as in expressions likea.operator++(2), has no special properties: The argument tooperator++
is 2.
§ 12.5 © ISO/IEC
401

===== PAGE 413 =====

Dxxxx
[Note 1: Because built-in operators take only operands with non-class type, and operator overload resolution occurs
only when an operand expression originally has class or enumeration type, operator overload resolution can resolve
to a built-in operator only when an operand has a class type that has a user-defined conversion to a non-class type
appropriate for the operator, or when an operand has an enumeration type that can be converted to a type appropriate
for the operator. Also note that some of the candidate operator functions given in this subclause are more permissive
than the built-in operators themselves. As described in 12.2.2.3, after a built-in operator is selected by overload
resolution the expression is subject to the requirements for the built-in operator given in 7.6, and therefore to any
additional semantic constraints given there. In some cases, user-written candidates with the same name and parameter
types as a built-in candidate operator function cause the built-in operator function to not be included in the set of
candidate functions. —end note]
2 In this subclause, the termpromoted integral typeis used to refer to those cv-unqualified integral types which
are preserved by integral promotion (7.3.7) (including e.g.int and long but excluding e.g.char).
[Note 2: In all cases where a promoted integral type is required, an operand of unscoped enumeration type will be
acceptable by way of the integral promotions.—end note]
3 In the remainder of this subclause,vq represents eithervolatile or no cv-qualifier.
4 For every pair (T , vq), whereT is a cv-unqualified arithmetic type other thanbool or a cv-unqualified pointer
to (possibly cv-qualified) object type, there exist candidate operator functions of the form
vq T & operator++(vq T &);
T operator++(vq T &, int);
vq T & operator--(vq T &);
T operator--(vq T &, int);
5 For every (possibly cv-qualified) object typeT and for every function typeT that has neithercv-qualifiers
nor aref-qualifier, there exist candidate operator functions of the form
T & operator*( T *);
6 For every typeT there exist candidate operator functions of the form
T * operator+( T *);
7 For every cv-unqualified floating-point or promoted integral typeT , there exist candidate operator functions
of the form
T operator+(T );
T operator-(T );
8 For every promoted integral typeT , there exist candidate operator functions of the form
T operator~(T );
9 For every quintuple (C1, C2, T , cv1, cv2), whereC2 is a class type,C1 is the same type asC2 or is a derived
class of C2, andT is an object type or a function type, there exist candidate operator functions of the form
cv12 T & operator->*(cv1 C1 *, cv2 T C2 ::*);
where cv12 is the union ofcv1 and cv2. The return type is shown for exposition only; see 7.6.4 for the
determination of the operator’s result type.
10 For every pair of typesL and R , where each ofL and R is a floating-point or promoted integral type, there
exist candidate operator functions of the form
LR operator*(L , R );
LR operator/(L , R );
LR operator+(L , R );
LR operator-(L , R );
bool operator==( L , R );
bool operator!=( L , R );
bool operator<( L , R );
bool operator>( L , R );
bool operator<=( L , R );
bool operator>=( L , R );
where LR is the result of the usual arithmetic conversions (7.4) between typesL and R .
11 For every integral typeT there exists a candidate operator function of the form
std::strong_ordering operator<=>(T , T );
12 For every pair of floating-point typesL and R , there exists a candidate operator function of the form
§ 12.5 © ISO/IEC
402

===== PAGE 414 =====

Dxxxx
std::partial_ordering operator<=>(L , R );
13 For every cv-qualified or cv-unqualified object typeT there exist candidate operator functions of the form
T * operator+( T *, std::ptrdiff_t);
T & operator[]( T *, std::ptrdiff_t);
T * operator-( T *, std::ptrdiff_t);
T * operator+(std::ptrdiff_t, T *);
T & operator[](std::ptrdiff_t, T *);
14 For everyT , whereT is a pointer to object type, there exist candidate operator functions of the form
std::ptrdiff_t operator-( T , T );
15 For everyT , whereT is an enumeration type or a pointer type, there exist candidate operator functions of
the form
bool operator==( T , T );
bool operator!=( T , T );
bool operator<( T , T );
bool operator>( T , T );
bool operator<=( T , T );
bool operator>=( T , T );
R operator<=>(T , T );
where R is the result type specified in 7.6.8.
16 For every T , where T is a pointer-to-member type, std::meta::info, or std::nullptr_t, there exist
candidate operator functions of the form
bool operator==(T , T );
bool operator!=(T , T );
17 For every pair of promoted integral typesL and R , there exist candidate operator functions of the form
LR operator%(L , R );
LR operator&(L , R );
LR operator^(L , R );
LR operator|(L , R );
L operator<<(L , R );
L operator>>(L , R );
where LR is the result of the usual arithmetic conversions (7.4) between typesL and R .
18 For every triple (L , vq, R ), whereL is an arithmetic type, andR is a floating-point or promoted integral
type, there exist candidate operator functions of the form
vq L & operator=( vq L &, R );
vq L & operator*=( vq L &, R );
vq L & operator/=( vq L &, R );
vq L & operator+=( vq L &, R );
vq L & operator-=( vq L &, R );
19 For every pair (T , vq), whereT is any type, there exist candidate operator functions of the form
T *vq & operator=( T *vq &, T *);
20 For every pair (T , vq), whereT is an enumeration or pointer-to-member type, there exist candidate operator
functions of the form
vq T & operator=( vq T &, T );
21 For every pair (T , vq), whereT is a cv-qualified or cv-unqualified object type, there exist candidate operator
functions of the form
T *vq & operator+=( T *vq &, std::ptrdiff_t);
T *vq & operator-=( T *vq &, std::ptrdiff_t);
22 For every triple (L , vq, R ), where L is an integral type, andR is a promoted integral type, there exist
candidate operator functions of the form
vq L & operator%=( vq L &, R );
vq L & operator<<=( vq L &, R );
vq L & operator>>=( vq L &, R );
vq L & operator&=( vq L &, R );
vq L & operator^=( vq L &, R );
§ 12.5 © ISO/IEC
403

===== PAGE 415 =====

Dxxxx
vq L & operator|=( vq L &, R );
23 There also exist candidate operator functions of the form
bool operator!(bool);
bool operator&&(bool, bool);
bool operator||(bool, bool);
24 For every pair of typesL and R , where each ofL and R is a floating-point or promoted integral type, there
exist candidate operator functions of the form
LR operator?:(bool, L , R );
where LR is the result of the usual arithmetic conversions (7.4) between typesL and R .
[Note 3: As with all these descriptions of candidate functions, this declaration serves only to describe the built-in
operator for purposes of overload resolution. The operator “?:” cannot be overloaded.—end note]
25 For every typeT , whereT is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate
operator functions of the form
T operator?:(bool, T , T );
12.6 User-defined literals [over.literal]
literal-operator-id:
operator unevaluated-string identifier
operator user-defined-string-literal
1 The user-defined-string-literal in aliteral-operator-id shall have noencoding-prefix. The unevaluated-string or
user-defined-string-literal shall be empty. Theud-suffix of theuser-defined-string-literal or theidentifier in a
literal-operator-id is called aliteral suffix identifier. The first form ofliteral-operator-id is deprecated (D.8).
Some literal suffix identifiers are reserved for future standardization; see 16.4.5.3.6. A declaration whose
literal-operator-id uses such a literal suffix identifier is ill-formed, no diagnostic required.
2 A declaration whosedeclarator-id is aliteral-operator-id shall declare a function or function template that
belongs to a namespace (it could be a friend function (11.8.4)) or an explicit instantiation or specialization of
a function template. A function declared with aliteral-operator-id is aliteral operator. A function template
declared with aliteral-operator-id is aliteral operator template.
3 The declaration of a literal operator shall have aparameter-declaration-clause equivalent to one of the following:
const char*
unsigned long long int
long double
char
wchar_t
char8_t
char16_t
char32_t
const char*, std::size_t
const wchar_t*, std::size_t
const char8_t*, std::size_t
const char16_t*, std::size_t
const char32_t*, std::size_t
If a parameter has a default argument (9.3.4.7), the program is ill-formed.
4 A raw literal operatoris a literal operator with a single parameter whose type isconst char*.
5 A numeric literal operator templateis a literal operator template whosetemplate-parameter-list has a single
template-parameter that is a constant template parameter pack (13.7.4) with element typechar. A string
literal operator templateis a literal operator template whosetemplate-parameter-list comprises a single
parameter-declaration that declares a constant template parameter of class type. The declaration of a literal
operator template shall have an emptyparameter-declaration-clause and shall declare either a numeric literal
operator template or a string literal operator template.
6 Literal operators and literal operator templates shall not have C language linkage.
7 [Note 1: Literal operators and literal operator templates are usually invoked implicitly through user-defined literals
(5.13.9). However, except for the constraints described above, they are ordinary namespace-scope functions and
function templates. In particular, they are looked up like ordinary functions and function templates and they follow
§ 12.6 © ISO/IEC
404

===== PAGE 416 =====

Dxxxx
the same overload resolution rules. Also, they can be declaredinline or constexpr, they can have internal, module,
or external linkage, they can be called explicitly, their addresses can be taken, etc.—end note]
8 [Example 1:
void operator ""_km(long double); // OK
string operator "" _i18n(const char*, std::size_t); // OK, deprecated
template <char...> double operator ""_\u03C0(); // OK, UCN for lowercase pi
float operator ""_e(const char*); // OK
float operator ""E(const char*); // ill-formed, no diagnostic required:
// reserved literal suffix (16.4.5.3.6, 5.13.9)
double operator""_Bq(long double); // OK, does not use the reservedidentifier _Bq (5.11)
double operator"" _Bq(long double); // ill-formed, no diagnostic required:
// uses the reservedidentifier _Bq (5.11)
float operator " "B(const char*); // error: non-emptystring-literal
string operator ""5X(const char*, std::size_t); // error: invalid literal suffix identifier
double operator ""_miles(double); // error: invalidparameter-declaration-clause
template <char...> int operator ""_j(const char*); // error: invalidparameter-declaration-clause
extern "C" void operator ""_m(long double); // error: C language linkage
—end example]
§ 12.6 © ISO/IEC
405

===== PAGE 417 =====

Dxxxx
13 Templates [temp]
13.1 Preamble [temp.pre]
1 A template defines a family of classes, functions, or variables, an alias for a family of types, or a concept.
template-declaration:
template-head declaration
template-head concept-definition
template-head:
template < template-parameter-list > requires-clauseopt
template-parameter-list:
template-parameter
template-parameter-list , template-parameter
requires-clause:
requires constraint-logical-or-expression
constraint-logical-or-expression:
constraint-logical-and-expression
constraint-logical-or-expression || constraint-logical-and-expression
constraint-logical-and-expression:
primary-expression
constraint-logical-and-expression && primary-expression
[Note 1: The > token following thetemplate-parameter-list of atemplate-declaration can be the product of replacing a
>> token by two consecutive> tokens (13.3). —end note]
2 The declaration in atemplate-declaration (if any) shall
—(2.1) declare or define a function, a class, or a variable, or
—(2.2) define a member function, a member class, a member enumeration, or a static data member of a class
template or of a class nested within a class template, or
—(2.3) define a member template of a class or class template, or
—(2.4) be afriend-type-declaration, or
—(2.5) be adeduction-guide, or
—(2.6) be analias-declaration.
3 A template-declaration is adeclaration. A declaration introduced by a template declaration of a variable is a
variable template. A variable template at class scope is astatic data member template.
[Example 1:
template<class T>
constexpr T pi = T(3.1415926535897932385L);
template<class T>
T circular_area(T r) {
return pi<T> * r * r;
}
struct matrix_constants {
template<class T>
using pauli = hermitian_matrix<T, 2>;
template<class T>
constexpr static pauli<T> sigma1 = { { 0, 1 }, { 1, 0 } };
template<class T>
constexpr static pauli<T> sigma2 = { { 0, -1i }, { 1i, 0 } };
template<class T>
constexpr static pauli<T> sigma3 = { { 1, 0 }, { 0, -1 } };
};
—end example]
4 [Note 2: A template-declaration can appear only as a namespace scope or class scope declaration.—end note]
§ 13.1 © ISO/IEC
406

===== PAGE 418 =====

Dxxxx
Its declaration shall not be anexport-declaration. In a function template declaration, theunqualified-id of the
declarator-id shall be a name.
[Note 3: A class or variable template declaration of asimple-template-id declares a partial specialization (13.7.6).
—end note]
5 In a template-declaration, explicit specialization, or explicit instantiation, the init-declarator-list in the
declaration shall contain at most one declarator. When such a declaration is used to declare a class template,
no declarator is permitted. In a template-declaration whose declaration is a friend-type-declaration, the
friend-type-declaration shall be of the form
friend friend-type-specifier ;
[Example 2:
template<class ...>
struct C {
struct Nested { };
};
template<class ... Us>
struct S {
template <typename ...Ts>
friend class C<Ts>::Nested...; // error: pack expansion is not afriend-type-specifier
friend class C<Us>::Nested...; // OK, not atemplate-declaration
};
—end example]
6 A specialization (explicit or implicit) of one template is distinct from all specializations of any other template.
A template, an explicit specialization (13.9.4), and a partial specialization shall not have C language linkage.
[Note 4: Default arguments for function templates and for member functions of class templates are considered
definitions for the purpose of template instantiation (13.7) and must obey the one-definition rule (6.3).—end note]
7 [Note 5: A template cannot have the same name as any other name bound in the same scope (6.4.1), except that a
function template can share a name withusing-declarators, a type, non-template functions (9.3.4.6) and/or function
templates (13.10.4). Specializations, including partial specializations (13.7.6), do not reintroduce or bind names. Their
target scope is the target scope of the primary template, so all specializations of a template belong to the same scope
as it does.
[Example 3:
void f() {}
class f {}; // OK
namespace N {
void f(int) {}
}
using N::f; // OK
template<typename> void f(long) {} // #1, OK
template<typename> void f(long) {} // error: redefinition of #1
template<typename> void f(long long) {} // OK
template<> void f<int>(long long) {} // OK, doesn’t bind a name
—end example]
—end note]
8 An entity istemplated if it is
—(8.1) a template,
—(8.2) an entity defined (6.2) or created (6.8.7) within thecompound-statement of anexpansion-statement (8.7),
—(8.3) an entity defined or created in a templated entity,
—(8.4) a member of a templated entity,
—(8.5) an enumerator for an enumeration that is a templated entity, or
—(8.6) the closure type of alambda-expression (7.5.6.2) appearing in the declaration of a templated entity.
[Note 6: A local class, a local or block variable, or a friend function defined in a templated entity is a templated
entity. —end note]
§ 13.1 © ISO/IEC
407

===== PAGE 419 =====

Dxxxx
A templated functionis a function template or a function that is templated. Atemplated classis a class
template or a class that is templated. Atemplated variable is a variable template or a variable that is
templated.
9 A template-declaration is written in terms of its template parameters. The optionalrequires-clause following a
template-parameter-list allows the specification of constraints (13.5.3) on template arguments (13.4). The
requires-clause introduces the constraint-expression that results from interpreting theconstraint-logical-or-
expression as aconstraint-expression. The constraint-logical-or-expression of arequires-clause is an unevaluated
operand (7.2.3).
[Note 7: The expression in arequires-clause uses a restricted grammar to avoid ambiguities. Parentheses can be used
to specify arbitrary expressions in arequires-clause.
[Example 4:
template<int N> requires N == sizeof new unsigned short
int f(); // error: parentheses required around== expression
—end example]
—end note]
10 A definition of a function template, member function of a class template, variable template, or static data
member of a class template shall be reachable from the end of every definition domain (6.3) in which it is
implicitly instantiated (13.9.2) unless the corresponding specialization is explicitly instantiated (13.9.3) in
some translation unit; no diagnostic is required.
13.2 Template parameters [temp.param]
1 The syntax fortemplate-parameters is:
template-parameter:
type-parameter
parameter-declaration
type-tt-parameter
variable-tt-parameter
concept-tt-parameter
type-parameter:
type-parameter-key ...opt identifieropt
type-parameter-key identifieropt = type-id
type-constraint ...opt identifieropt
type-constraint identifieropt = type-id
type-parameter-key:
class
typename
type-constraint:
nested-name-specifieropt concept-name
nested-name-specifieropt concept-name < template-argument-listopt >
type-tt-parameter:
template-head type-parameter-key...opt identifieropt
template-head type-parameter-key identifieropt type-tt-parameter-default
type-tt-parameter-default:
= nested-name-specifieropt template-name
= nested-name-specifier template template-name
variable-tt-parameter:
template-head auto ...opt identifieropt
template-head auto identifieropt = nested-name-specifieropt template-name
concept-tt-parameter:
template < template-parameter-list > concept ...opt identifieropt
template < template-parameter-list > concept identifieropt = nested-name-specifieropt template-name
The component names of atype-constraint are itsconcept-name and those of itsnested-name-specifier (if any).
[Note 1: The > token following thetemplate-parameter-list of atype-tt-parameter, variable-tt-parameter, orconcept-tt-
parameter can be the product of replacing a>> token by two consecutive> tokens (13.3). —end note]
§ 13.2 © ISO/IEC
408

===== PAGE 420 =====

Dxxxx
2 A template parameter is of one of the following kinds:
—(2.1) A type template parameteris a template parameter introduced by atype-parameter.
—(2.2) A constant template parameteris a template parameter introduced by aparameter-declaration.
—(2.3) A type template template parameteris a template parameter introduced by atype-tt-parameter.
—(2.4) A variable template template parameteris a template parameter introduced by avariable-tt-parameter.
—(2.5) A concept template parameteris a template parameter introduced by aconcept-tt-parameter.
3 Type template template parameters, variable template template parameters, and concept template parameters
are collectively referred to astemplate template parameters.
4 The nested-name-specifier of atype-constraint, if any, shall not be dependent.
5 A concept template parameter shall not have associated constraints (13.5.3).
6 If atemplate-parameter is aparameter-declaration that declares a pack (9.3.4.6), or otherwise has an ellipsis
prior to its optionalidentifier, then thetemplate-parameter declares a template parameter pack (13.7.4). A
template parameter pack that is aparameter-declaration whose type contains one or more unexpanded packs
is a pack expansion. Similarly, a template parameter pack that is a template template parameter with a
template-parameter-list containing one or more unexpanded packs is a pack expansion. A type parameter
pack with atype-constraint that contains an unexpanded parameter pack is a pack expansion. A template
parameter pack that is a pack expansion shall not expand a template parameter pack declared in the same
template-parameter-list.
[Example 1:
template <class... Types> // Types is a template type parameter pack
class Tuple; // but not a pack expansion
template <class T, int... Dims> // Dims is a constant template parameter pack
struct multi_array; // but not a pack expansion
template <class... T>
struct value_holder {
template <T... Values> struct apply { }; // Values is a constant template parameter pack
}; // and a pack expansion
template <class... T, T... Values> // error: Values expands template type parameter
struct static_array; // packT within the same template parameter list
—end example]
7 There is no semantic difference betweenclass and typename in atype-parameter-key. typename followed by
an unqualified-id names a template type parameter.typename followed by aqualified-id denotes the type in a
parameter-declaration. A template-parameter of the formclass identifier is atype-parameter.
[Example 2:
class T { /* ... */ };
int i;
template<class T, T i> void f(T t) {
T t1 = i; // template parametersT and i
::T t2 = ::i; // global namespace membersT and i
}
Here, the templatef has a type template parameter calledT, rather than an unnamed constant template parameter
of classT. —end example]
The parameter-declaration of atemplate-parameter shall not have astorage-class-specifier. Types shall not be
defined in a template parameter declaration.
8 The identifier in atemplate-parameter denoting a type or template is not looked up. Anidentifier that does
not follow an ellipsis is defined to be
—(8.1) a typedef-name for atype-parameter,
—(8.2) a template-name for avariable-tt-parameter,
—(8.3) a template-name for atype-tt-parameter, or
§ 13.2 © ISO/IEC
409

===== PAGE 421 =====

Dxxxx
—(8.4) a concept-name for aconcept-tt-parameter,
in the scope of the template declaration.
9 A type-constraint Q that designates a conceptC can be used to constrain a contextually-determined type or
template type parameter packT with aconstraint-expression E defined as follows. IfQ is of the formC<A1,
... , An>, then letE′ be C<T, A1, ... , An>. Otherwise, let E′ be C<T>. If T is not a pack, thenE is E′,
otherwise E is (E′ && ...). This constraint-expression E is called theimmediately-declared constraintof Q for
T. The concept designated by atype-constraint shall be a type concept (13.7.9).
10 A type-parameter that starts with atype-constraint introduces the immediately-declared constraint of the
type-constraint for the parameter.
[Example 3:
template<typename T> concept C1 = true;
template<typename... Ts> concept C2 = true;
template<typename T, typename U> concept C3 = true;
template<C1 T> struct s1; // associatesC1<T>
template<C1... T> struct s2; // associates(C1<T> && ...)
template<C2... T> struct s3; // associates(C2<T> && ...)
template<C3<int> T> struct s4; // associatesC3<T, int>
template<C3<int>... T> struct s5; // associates(C3<T, int> && ...)
—end example]
11 A constant template parameter shall have one of the following (possibly cv-qualified) types:
—(11.1) a structural type (see below),
—(11.2) a type that contains a placeholder type (9.2.9.7), or
—(11.3) a placeholder for a deduced class type (9.2.9.8).
The top-levelcv-qualifiers on thetemplate-parameter are ignored when determining its type.
12 A structural typeis one of the following:
—(12.1) a scalar type, or
—(12.2) an lvalue reference type, or
—(12.3) a literal class type with the following properties:
—(12.3.1) all base classes and non-static data members are public and non-mutable and
—(12.3.2) the types of all base classes and non-static data members are structural types or (possibly
multidimensional) arrays thereof.
13 Certain constructs refer to template parameter objects, which are distinct objects with static storage duration
and non-volatile const type. No two such objects have template-argument-equivalent values (13.6). An
id-expression naming a constant template parameter of class typeT denotes the template parameter object of
type const T, which is template-argument-equivalent to the corresponding template argument after it has
been converted to the type of the template parameter (13.4.3).
[Note 2: There can be template parameter objects of array type (21.4.3), but such an object is never denoted by an
id-expression that names a constant template parameter.—end note]
[Note 3: If anid-expression names a non-reference constant template parameter, then it is a prvalue if it has non-class
type. Otherwise, if it is of class typeT, it is an lvalue and has typeconst T (7.5.5.2). —end note]
[Example 4:
using X = int;
struct A {};
template<const X& x, int i, A a> void f() {
i++; // error: change of template parameter value
&x; // OK
&i; // error: address of non-reference template parameter
&a; // OK
int& ri = i; // error: attempt to bind non-const reference to temporary
const int& cri = i; // OK, const reference binds to temporary
§ 13.2 © ISO/IEC
410

===== PAGE 422 =====

Dxxxx
const A& ra = a; // OK, const reference binds to a template parameter object
}
—end example]
14 [Note 4: A constant template parameter cannot be declared to have typecv void.
[Example 5:
template<void v> class X; // error
template<void* pv> class Y; // OK
—end example]
—end note]
15 A constant template parameter of type “array ofT” or of function typeT is adjusted to be of type “pointer
to T”.
[Example 6:
template<int* a> struct R { /* ... */ };
template<int b[5]> struct S { /* ... */ };
int p;
R<&p> w; // OK
S<&p> x; // OK due to parameter adjustment
int v[5];
R<v> y; // OK due to implicit argument conversion
S<v> z; // OK due to both adjustment and conversion
—end example]
16 A constant template parameter declared with a type that contains a placeholder type with atype-constraint
introduces the immediately-declared constraint of thetype-constraint for the invented type corresponding to
the placeholder (9.3.4.6).
17 A default template argumentis a template argument (13.4) specified after= in a template-parameter. A
default template argument shall not be specified for a template parameter pack (13.7.4). A default template
argument may be specified in a template declaration. A default template argument shall not be specified in
the template-parameter-lists of the definition of a member of a class template that appears outside of the
member’s class. A default template argument shall not be specified in a friend class template declaration. If
a friend function template declarationD specifies a default template argument, that declaration shall be a
definition and there shall be no other declaration of the function template which is reachable fromD or from
which D is reachable.
18 The set of default template arguments available for use is obtained by merging the default arguments from
all prior declarations of the template in the same way default function arguments are (9.3.4.7).
[Example 7:
template<class T1, class T2 = int> class A;
template<class T1 = int, class T2> class A;
is equivalent to
template<class T1 = int, class T2 = int> class A;
—end example]
19 If a template-parameter of a class template, variable template, or alias template has a default template
argument, each subsequenttemplate-parameter shall either have a default template argument supplied or
declare a template parameter pack. If atemplate-parameter of a primary class template, primary variable
template, or alias template declares a template parameter pack, it shall be the lasttemplate-parameter. If a
template-parameter of a function template declares a template parameter pack, it shall not be followed by
another template-parameter unless that template parameter is deducible from the parameter-type-list (9.3.4.6)
of the function template or has a default argument (13.10.3). A template parameter of a deduction guide
template (13.7.2.3) that does not have a default argument shall be deducible from the parameter-type-list of
the deduction guide template.
[Example 8:
template<class T1 = int, class T2> class B; // error
§ 13.2 © ISO/IEC
411

===== PAGE 423 =====

Dxxxx
// U can be neither deduced from the parameter-type-list nor specified
template<class... T, class... U> void f() { } // error
template<class... T, class U> void g() { } // error
—end example]
20 When parsing a default template argument for a constant template parameter, the first non-nested> is taken
as the end of thetemplate-parameter-list rather than a greater-than operator.
[Example 9:
template<int i = 3 > 4 > // syntax error
class X { /* ... */ };
template<int i = (3 > 4) > // OK
class Y { /* ... */ };
—end example]
21 A template-parameter of a templatetemplate-parameter is permitted to have a default template argument.
When such default arguments are specified, they apply to the templatetemplate-parameter in the scope of
the templatetemplate-parameter.
[Example 10:
template <template <class TT = float> class T> struct A {
inline void f();
inline void g();
};
template <template <class TT> class T> void A<T>::f() {
T<> t; // error: TT has no default template argument
}
template <template <class TT = char> class T> void A<T>::g() {
T<> t; // OK,T<char>
}
—end example]
The associated constraints of a template template parameter shall not contain a concept-dependent constraint
(13.5.2.4).
[Example 11:
template<
template<typename> concept C,
template<C> class TT // error: C forms a concept-dependent constraint
>
struct A {};
—end example]
13.3 Names of template specializations [temp.names]
1 A template specialization (13.9) can be referred to by atemplate-id:
simple-template-id:
template-name < template-argument-listopt >
template-id:
simple-template-id
operator-function-id < template-argument-listopt >
literal-operator-id < template-argument-listopt >
template-name:
identifier
template-argument-list:
template-argument ...opt
template-argument-list , template-argument ...opt
template-argument:
template-argument-name
constant-expression
type-id
braced-init-list
§ 13.3 © ISO/IEC
412

===== PAGE 424 =====

Dxxxx
template-argument-name:
nested-name-specifieropt identifier
nested-name-specifier template identifier
2 The component name of asimple-template-id, template-id, ortemplate-name is the first name in it.
3 A < is interpreted as the delimiter of atemplate-argument-list if either
—(3.1) it follows asplice-specifier that either
—(3.1.1) appears in a type-only context or
—(3.1.2) is preceded bytemplate or typename, or
—(3.2) it follows a name that is not aconversion-function-id and
—(3.2.1) that follows the keywordtemplate or a~ after anested-name-specifier or in a class member access
expression, or
—(3.2.2) for which name lookup finds the injected-class-name of a class template or finds any declaration of
a template, or
—(3.2.3) that is an unqualified name for which name lookup either finds one or more functions or finds
nothing, or
—(3.2.4) that is a terminal name in ausing-declarator (9.10), in adeclarator-id (9.3.4), or in a type-only
context other than anested-name-specifier (13.8).
[Note 1: If the name is anidentifier, it is then interpreted as atemplate-name. The keywordtemplate is used to
indicate that a dependent qualified name (13.8.3.2) denotes a template where an expression might appear.—end
note]
[Example 1:
struct X {
template<std::size_t> X* alloc();
template<std::size_t> static X* adjust();
};
template<class T> void f(T* p) {
T* p1 = p->alloc<200>(); // error: < means less than
T* p2 = p->template alloc<200>(); // OK,< starts template argument list
T::adjust<100>(); // error: < means less than
T::template adjust<100>(); // OK,< starts template argument list
static constexpr std::meta::info r = ^^T::adjust;
T* p3 = [:r:]<200>(); // error: < means less than
T* p4 = template [:r:]<200>(); // OK,< starts template argument list
}}
—end example]
4 When parsing atemplate-argument-list, the first non-nested>103 is taken as the ending delimiter rather
than a greater-than operator. Similarly, the first non-nested>> is treated as two consecutive but distinct>
tokens, the first of which is taken as the end of thetemplate-argument-list and completes thetemplate-id or
splice-specialization-specifier.
[Note 2: The second> token produced by this replacement rule can terminate an enclosingtemplate-id or splice-
specialization-specifier construct or it can be part of a different construct (e.g., a cast).—end note]
[Example 2:
template<int i> class X { /* ... */ };
X< 1>2 > x1; // syntax error
X<(1>2)> x2; // OK
template<class T> class Y { /* ... */ };
Y<X<1>> x3; // OK, same asY<X<1> > x3;
Y<X<6>>1>> x4; // syntax error
Y<X<(6>>1)>> x5; // OK
103) A > that encloses thetype-id of adynamic_cast, static_cast, reinterpret_cast or const_cast, or which encloses the
template-arguments of a subsequenttemplate-id or splice-specialization-specifier, is considered nested for the purpose of this
description.
§ 13.3 © ISO/IEC
413

===== PAGE 425 =====

Dxxxx
—end example]
5 The keywordtemplate shall not appear immediately after a declarativenested-name-specifier (7.5.5.3).
6 The constant-expression of atemplate-argument shall not be an unparenthesizedsplice-expression.
[Example 3:
template<int> struct S { };
constexpr int k = 5;
constexpr std::meta::info r = ^^k;
S<[:r:]> s1; // error: unparenthesizedsplice-expression used as template argument
S<([:r:])> s2; // OK
S<[:r:] + 1> s3; // OK
—end example]
7 A name prefixed by the keywordtemplate shall be followed by a template argument list or refer to a class
template or an alias template. The latter case is deprecated (D.9). The keywordtemplate shall not appear
immediately before a~ token (as to name a destructor).
[Note 3: The keywordtemplate cannot be applied to non-template members of class templates.—end note]
[Note 4: As is the case with thetypename prefix, thetemplate prefix is well-formed even when lookup for the name
would already find a template.—end note]
[Example 4:
template <class T> struct A {
void f(int);
template <class U> void f(U);
};
template <class T> void f(T t) {
A<T> a;
a.template f<>(t); // OK, calls template
a.template f(t); // error: not atemplate-id
}
template <class T> struct B {
template <class T2> struct C { };
};
// deprecated:T::C is assumed to name a class template:
template <class T, template <class X> class TT = T::template C> struct D { };
D<B<int> > db;
—end example]
8 The component names of atemplate-argument-name are those of itsnested-name-specifier (if any) and its
identifier.
9 A template-id or splice-specialization-specifier is valid if
—(9.1) there are at most as many arguments as there are parameters or a parameter is a template parameter
pack (13.7.4),
—(9.2) there is an argument for each non-deducible non-pack parameter that does not have a defaulttemplate-
argument,
—(9.3) each template-argument matches the corresponding template parameter (13.4),
—(9.4) substitution of each template argument into the following template parameters (if any) succeeds, and
—(9.5) if thetemplate-id or splice-specialization-specifier is non-dependent, the associated constraints are satisfied
as specified in the next paragraph.
A simple-template-id or splice-specialization-specifier shall be valid unless its respectivetemplate-name or
splice-specifier designates a function template (13.10.3).
[Example 5:
template<class T, T::type n = 0> class X;
§ 13.3 © ISO/IEC
414

===== PAGE 426 =====

Dxxxx
struct S {
using type = int;
};
using T1 = X<S, int, int>; // error: too many arguments
using T2 = X<>; // error: no default argument for first template parameter
using T3 = X<1>; // error: value1 does not match type-parameter
using T4 = X<int>; // error: substitution failure for second template parameter
using T5 = X<S>; // OK
—end example]
10 When the template-name of a simple-template-id or the splice-specifier of a splice-specialization-specifier
designates a constrained non-function template or a constrained template template parameter, and all
template-arguments in thesimple-template-id or splice-specialization-specifier are non-dependent (13.8.3.7), the
associated constraints (13.5.3) of the constrained template shall be satisfied (13.5.2).
[Example 6:
template<typename T> concept C1 = sizeof(T) != sizeof(int);
template<C1 T> struct S1 { };
template<C1 T> using Ptr = T*;
S1<int>* p; // error: constraints not satisfied
Ptr<int> p; // error: constraints not satisfied
template<typename T>
struct S2 { Ptr<int> x; }; // ill-formed, no diagnostic required
template<typename T>
struct S3 { Ptr<T> x; }; // OK, satisfaction is not required
S3<int> x; // error: constraints not satisfied
template<template<C1 T> class X>
struct S4 {
X<int> x; // ill-formed, no diagnostic required
};
template<typename T> concept C2 = sizeof(T) == 1;
template<C2 T> struct S { };
template struct S<char[2]>; // error: constraints not satisfied
template<> struct S<char[2]> { }; // error: constraints not satisfied
—end example]
11 A concept-id is asimple-template-id where thetemplate-name is aconcept-name. A concept-id is a prvalue of
type bool, and does not name a template specialization. A concept-id evaluates totrue if the concept’s
normalized constraint-expression (13.5.3) is satisfied (13.5.2) by the specified template arguments andfalse
otherwise.
[Note 5: Since aconstraint-expression is an unevaluated operand, a concept-id appearing in aconstraint-expression is
not evaluated except as necessary to determine whether the normalized constraints are satisfied.—end note]
[Example 7:
template<typename T> concept C = true;
static_assert(C<int>); // OK
—end example]
13.4 Template arguments [temp.arg]
13.4.1 General [temp.arg.general]
1 The type and form of eachtemplate-argument specified in atemplate-id or in asplice-specialization-specifier
shall match the type and form specified for the corresponding parameter declared by the template in its
§ 13.4.1 © ISO/IEC
415

===== PAGE 427 =====

Dxxxx
template-parameter-list. When the parameter declared by the template is a template parameter pack (13.7.4),
it will correspond to zero or moretemplate-arguments.
[Example 1:
template<class T> class Array {
T* v;
int sz;
public:
explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }
};
Array<int> v1(20);
typedef std::complex<double> dcomplex; // std::complex is a standard library template
Array<dcomplex> v2(30);
Array<dcomplex> v3(40);
void bar() {
v1[3] = 7;
v2[3] = v3.elem(4) = dcomplex(7,8);
}
—end example]
2 The template argument list of atemplate-head is a template argument list in which thenth template argument
has the value of thenth template parameter of thetemplate-head. If thenth template parameter is a template
parameter pack (13.7.4), thenth template argument is a pack expansion whose pattern is the name of the
template parameter pack.
3 If atemplate-argument A matches the formtemplate-argument-name, it is interpreted as such; theidentifier is
looked up and its meaning is determined as follows:
—(3.1) If lookup finds an injected-class-name (13.8.2), then:
—(3.1.1) When A is for a type template template parameter,A denotes the corresponding class template.
—(3.1.2) Otherwise, it denotes atype-name.
—(3.2) Otherwise, if lookup finds a template,A denotes that template.
—(3.3) Otherwise, if lookup finds a type alias or a type,A denotes the underlying type and is interpreted as a
type-id.
—(3.4) Otherwise, A is interpreted as an expression.
4 In atemplate-argument, an ambiguity between atype-id and an expression is resolved to atype-id, regardless
of the form of the correspondingtemplate-parameter.104
[Example 2:
template<class T> void f();
template<int I> void f();
void g() {
f<int()>(); // int() is a type-id: call the firstf()
}
—end example]
5 [Note 1: Names used in atemplate-argument are subject to access control where they appear. Because a template
parameter is not a class member, no access control applies where the template parameter is used.—end note]
[Example 3:
template<class T> class X {
static T t;
};
104) There is no such ambiguity in a defaulttemplate-argument because the form of thetemplate-parameter determines the
allowable forms of thetemplate-argument.
§ 13.4.1 © ISO/IEC
416

===== PAGE 428 =====

Dxxxx
class Y {
private:
struct S { /* ... */ };
X<S> x; // OK,S is accessible
// X<Y::S> has a static member of typeY::S
// OK, even thoughY::S is private
};
X<Y::S> y; // error: S not accessible
—end example]
For a template argument that is a class type or a class template, the template definition has no special access
rights to the members of the template argument.
[Example 4:
template <template <class TT> class T> class A {
typename T<int>::S s;
};
template <class U> class B {
private:
struct S { /* ... */ };
};
A<B> b; // error: A has no access toB::S
—end example]
6 When template argument packs or default template arguments are used, atemplate-argument list can be
empty. In that case the empty<> brackets shall still be used as thetemplate-argument-list.
[Example 5:
template<class T = char> class String;
String<>* p; // OK,String<char>
String* q; // syntax error
template<class ... Elements> class Tuple;
Tuple<>* t; // OK,Elements is empty
Tuple* u; // syntax error
—end example]
7 An explicit destructor call (11.4.7) for an object that has a type that is a class template specialization may
explicitly specify thetemplate-arguments.
[Example 6:
template<class T> struct A {
~A();
};
void f(A<int>* p, A<int>* q) {
p->A<int>::~A(); // OK, destructor call
q->A<int>::~A<int>(); // OK, destructor call
}
—end example]
8 If the use of a template argument gives rise to an ill-formed construct in the instantiation of a template
specialization, the program is ill-formed.
9 When name lookup for the component name of atemplate-id finds an overload set, both non-template
functions in the overload set and function templates in the overload set for which thetemplate-arguments do
not match thetemplate-parameters are ignored.
[Note 2: If none of the function templates have matchingtemplate-parameters, the program is ill-formed.—end note]
10 When asimple-template-id or splice-specialization-specifier does not designate a function, a defaulttemplate-
argument is implicitly instantiated (13.9.2) when the value of that default argument is needed.
[Example 7:
template<typename T, typename U = int> struct S { };
§ 13.4.1 © ISO/IEC
417

===== PAGE 429 =====

Dxxxx
S<bool>* p; // the type ofp is S<bool, int>*
The default argument forU is instantiated to form the typeS<bool, int>*. —end example]
11 A template-argument followed by an ellipsis is a pack expansion (13.7.4).
13.4.2 Type template arguments [temp.arg.type]
1 A template-argument for a type template parameter shall be atype-id.
2 [Example 1:
template <class T> class X { };
template <class T> void f(T t) { }
struct { } unnamed_obj;
void f() {
struct A { };
enum { e1 };
typedef struct { } B;
B b;
X<A> x1; // OK
X<A*> x2; // OK
X<B> x3; // OK
f(e1); // OK
f(unnamed_obj); // OK
f(b); // OK
}
—end example]
[Note 1: A template type argument can be an incomplete type (6.9.1).—end note]
13.4.3 Constant template arguments [temp.arg.nontype]
1 A template argumentE for a constant template parameter with declared typeT shall be such that the
invented declaration
T x = E ;
satisfies the semantic constraints for the definition of aconstexpr variable with static storage duration (9.2.6).
If T contains a placeholder type (9.2.9.7) or a placeholder for a deduced class type (9.2.9.8), the type of the
parameter is deduced from the above declaration.
[Note 1: E is atemplate-argument or (for a default template argument) aninitializer-clause. —end note]
If the parameter type thus deduced is not permitted for a constant template parameter (13.2), the program
is ill-formed.
2 The value of a constant template parameterP of (possibly deduced) typeT is determined from its template
argument A as follows. IfT is not a class type andA is not abraced-init-list, A shall be a converted constant
expression (7.7) of typeT; the value ofP is A (as converted).
3 Otherwise, a temporary variable
constexpr T v = A;
is introduced. The lifetime ofv ends immediately after initializing it and any template parameter object (see
below). For each such variable, theid-expression v is termed acandidate initializer.
4 If T is a class type, a template parameter object (13.2) exists that is constructed so as to be template-
argument-equivalent tov; P denotes that template parameter object.P is copy-initialized from an unspecified
candidate initializer that is template-argument-equivalent tov. If, for the initialization from any candidate
initializer,
—(4.1) the initialization would be ill-formed, or
—(4.2) the full-expression of an inventedinit-declarator for the initialization would not be a constant expression
when interpreted as aconstant-expression (7.7), or
—(4.3) the initialization would causeP to not be template-argument-equivalent (13.6) tov,
the program is ill-formed.
5 Otherwise, the value ofP is that of v.
§ 13.4.3 © ISO/IEC
418

===== PAGE 430 =====

Dxxxx
6 For a constant template parameter of reference or pointer type, or for each non-static data member of
reference or pointer type in a constant template parameter of class type or subobject thereof, the reference or
pointer value shall not refer or point to (respectively):
—(6.1) a temporary object (6.8.7),
—(6.2) a string literal object (5.13.5),
—(6.3) the result of atypeid expression (7.6.1.8),
—(6.4) a predefined__func__ variable (9.6.1), or
—(6.5) a subobject (6.8.2) of one of the above.
7 [Example 1:
template <int& r> class A{};
extern int x;
A<x> a; // OK
void f(int p) {
constexpr int& r = p; // OK
A<r> a; // error: a static constexprint& variable cannot be initialized to refer top here
}
—end example]
8 [Example 2:
template<const int* pci> struct X { /* ... */ };
int ai[10];
X<ai> xi; // array to pointer and qualification conversions
struct Y { /* ... */ };
template<const Y& b> struct Z { /* ... */ };
Y y;
Z<y> z; // no conversion, but note extra cv-qualification
template<int (&pa)[5]> struct W { /* ... */ };
int b[5];
W<b> w; // no conversion
void f(char);
void f(int);
template<void (*pf)(int)> struct A { /* ... */ };
A<&f> a; // selectsf(int)
template<auto n> struct B { /* ... */ };
B<5> b1; // OK, template parameter type isint
B<'a'> b2; // OK, template parameter type ischar
B<2.5> b3; // OK, template parameter type isdouble
B<void(0)> b4; // error: template parameter type cannot bevoid
template<int i> struct C { /∗ ... ∗/ };
C<{ 42 }> c1; // OK
struct J1 {
J1 *self = this;
};
B<J1{}> j1; // error: initialization of template parameter object is not a constant expression
struct J2 {
J2 *self = this;
constexpr J2() {}
constexpr J2(const J2&) {}
};
B<J2{}> j2; // error: template parameter object not template-argument-equivalent to introduced temporary
—end example]
§ 13.4.3 © ISO/IEC
419

===== PAGE 431 =====

Dxxxx
9 [Note 2: A string-literal (5.13.5) is not an acceptabletemplate-argument for a constant template parameter of non-class
type.
[Example 3:
template<class T, T p> class X {
/* ... */
};
X<const char*, "Studebaker"> x; // error: string literal object astemplate-argument
X<const char*, "Knope" + 1> x2; // error: subobject of string literal object astemplate-argument
const char p[] = "Vivisectionist";
X<const char*, p> y; // OK
struct A {
constexpr A(const char*) {}
};
X<A, "Pyrophoricity"> z; // OK,string-literal is a constructor argument toA
—end example]
—end note]
10 [Note 3: A temporary object is not an acceptabletemplate-argument when the corresponding template parameter has
reference type.
[Example 4:
template<const int& CRI> struct B { /* ... */ };
B<1> b1; // error: temporary would be required for template argument
int c = 1;
B<c> b2; // OK
struct X { int n; };
struct Y { const int &r; };
template<Y y> struct C { /* ... */ };
C<Y{X{1}.n}> c; // error: subobject of temporary object used to initialize
// reference member of template parameter
—end example]
—end note]
13.4.4 Template template arguments [temp.arg.template]
1 A template-argument for a template template parameter shall be the name of a template. For atype-tt-
parameter, the name shall denote a class template, alias template, or type template template parameter. For
a variable-tt-parameter, the name shall denote a variable template or variable template template parameter.
For aconcept-tt-parameter, the name shall denote a concept or concept template parameter. Only primary
templates are considered when matching the template template argument with the corresponding parameter;
partial specializations are not considered even if their parameter lists match that of the template template
parameter.
2 Any partial specializations (13.7.6) associated with the primary template are considered when a specialization
based on the template template parameter is instantiated. If a specialization is not reachable from the
point of instantiation, and it would have been selected had it been reachable, the program is ill-formed, no
diagnostic required.
[Example 1:
template<class T> class A { // primary template
int x;
};
template<class T> class A<T*> { // partial specialization
long x;
};
§ 13.4.4 © ISO/IEC
420

===== PAGE 432 =====

Dxxxx
template<template<class U> class V> class C {
V<int> y;
V<int*> z;
};
C<A> c; // V<int> within C<A> uses the primary template, soc.y.x has typeint
// V<int*> within C<A> uses the partial specialization, soc.z.x has typelong
—end example]
3 A template template parameterP and atemplate-argument A are compatible if
—(3.1) A denotes a class template or an alias template andP is a type template template parameter,
—(3.2) A denotes a variable template andP is a variable template template parameter, or
—(3.3) A denotes a concept andP is a concept template parameter.
4 A templatetemplate-argument A matches a template template parameterP when A and P are compatible
and P is at least as specialized asA, ignoring constraints onA if P is unconstrained. IfP contains a template
parameter pack, thenA also matchesP if each ofA’s template parameters matches the corresponding template
parameter declared in thetemplate-head of P. Two template parameters match if they are of the same kind,
for constant template parameters, their types are equivalent (13.7.7.2), and for template template parameters,
each of their corresponding template parameters matches, recursively. WhenP’s template-head contains
a template-parameter that declares a template parameter pack (13.7.4), the template parameter pack will
match zero or more template parameters or template parameter packs declared in thetemplate-head of A
with the same type and form as the template parameter pack declared inP (ignoring whether those template
parameters are template parameter packs).
[Example 2:
template<class T> class A { /* ... */ };
template<class T, class U = T> class B { /* ... */ };
template<class ... Types> class C { /* ... */ };
template<auto n> class D { /* ... */ };
template<template<class> class P> class X { /* ... */ };
template<template<class ...> class Q> class Y { /* ... */ };
template<template<int> class R> class Z { /* ... */ };
X<A> xa; // OK
X<B> xb; // OK
X<C> xc; // OK
Y<A> ya; // OK
Y<B> yb; // OK
Y<C> yc; // OK
Z<D> zd; // OK
—end example]
[Example 3:
template <class T> struct eval;
template <template <class, class...> class TT, class T1, class... Rest>
struct eval<TT<T1, Rest...>> { };
template <class T1> struct A;
template <class T1, class T2> struct B;
template <int N> struct C;
template <class T1, int N> struct D;
template <class T1, class T2, int N = 17> struct E;
eval<A<int>> eA; // OK, matches partial specialization ofeval
eval<B<int, float>> eB; // OK, matches partial specialization ofeval
eval<C<17>> eC; // error: C does not matchTT in partial specialization
eval<D<int, 17>> eD; // error: D does not matchTT in partial specialization
eval<E<int, float>> eE; // error: E does not matchTT in partial specialization
—end example]
§ 13.4.4 © ISO/IEC
421

===== PAGE 433 =====

Dxxxx
[Example 4:
template<typename T> concept C = requires (T t) { t.f(); };
template<typename T> concept D = C<T> && requires (T t) { t.g(); };
template<template<C> class P> struct S { };
template<C> struct X { };
template<D> struct Y { };
template<typename T> struct Z { };
S<X> s1; // OK,X and P have equivalent constraints
S<Y> s2; // error: P is not at least as specialized asY
S<Z> s3; // OK,P is at least as specialized asZ
—end example]
5 A template template parameterP is at least as specialized as a templatetemplate-argument A if, given
the following rewrite to two function templates, the function template corresponding toP is at least as
specialized as the function template corresponding toA according to the partial ordering rules for function
templates (13.7.7.3). Given an invented class templateX with the template-head of A (including default
arguments andrequires-clause, if any):
—(5.1) Each of the two function templates has the same template parameters andrequires-clause (if any),
respectively, asP or A.
—(5.2) Each function template has a single function parameter whose type is a specialization ofX with
template arguments corresponding to the template parameters from the respective function template
where, for eachtemplate-parameter PP in thetemplate-head of the function template, a corresponding
template-argument AA is formed. IfPP declares a template parameter pack, thenAA is the pack expansion
PP... (13.7.4); otherwise,AA is anid-expression denoting PP.
If the rewrite produces an invalid type, thenP is not at least as specialized asA.
13.5 Template constraints [temp.constr]
13.5.1 General [temp.constr.general]
1 [Note 1: Subclause 13.5 defines the meaning of constraints on template arguments. The abstract syntax and satisfaction
rules are defined in 13.5.2. Constraints are associated with declarations in 13.5.3. Declarations are partially ordered
by their associated constraints (13.5.5).—end note]
13.5.2 Constraints [temp.constr.constr]
13.5.2.1 General [temp.constr.constr.general]
1 A constraint is a sequence of logical operations and operands that specifies requirements on template
arguments. The operands of a logical operation are constraints. There are five different kinds of constraints:
—(1.1) conjunctions (13.5.2.2),
—(1.2) disjunctions (13.5.2.2),
—(1.3) atomic constraints (13.5.2.3),
—(1.4) concept-dependent constraints (13.5.2.4), and
—(1.5) fold expanded constraints (13.5.2.5).
2 In order for a constrained template to be instantiated (13.9), its associated constraints (13.5.3) shall be
satisfied as described in the following subclauses.
[Note 1: Forming the name of a specialization of a class template, a variable template, or an alias template (13.3)
requires the satisfaction of its constraints. Overload resolution (12.2.3) requires the satisfaction of constraints on
functions and function templates.—end note]
13.5.2.2 Logical operations [temp.constr.op]
1 There are two binary logical operations on constraints: conjunction and disjunction.
[Note 1: These logical operations have no corresponding C++ syntax. For the purpose of exposition, conjunction is
spelled using the symbol∧and disjunction is spelled using the symbol∨. The operands of these operations are called
the left and right operands. In the constraintA∧B, A is the left operand, andB is the right operand.—end note]
§ 13.5.2.2 © ISO/IEC
422

===== PAGE 434 =====

Dxxxx
2 A conjunction is a constraint taking two operands. To determine if a conjunction issatisfied, the satisfaction
of the first operand is checked. If that is not satisfied, the conjunction is not satisfied. Otherwise, the
conjunction is satisfied if and only if the second operand is satisfied.
3 A disjunction is a constraint taking two operands. To determine if a disjunction issatisfied, the satisfaction
of the first operand is checked. If that is satisfied, the disjunction is satisfied. Otherwise, the disjunction is
satisfied if and only if the second operand is satisfied.
4 [Example 1:
template<typename T>
constexpr bool get_value() { return T::value; }
template<typename T>
requires (sizeof(T) > 1) && (get_value<T>())
void f(T); // has associated constraintsizeof(T) > 1 ∧ get_value<T>()
void f(int);
f('a'); // OK, callsf(int)
In the satisfaction of the associated constraints (13.5.3) off, the constraintsizeof(char) > 1 is not satisfied; the
second operand is not checked for satisfaction.—end example]
5 [Note 2: A logical negation expression (7.6.2.2) is an atomic constraint; the negation operator is not treated as a
logical operation on constraints. As a result, distinct negationconstraint-expressions that are equivalent under 13.7.7.2
do not subsume one another under 13.5.5. Furthermore, if substitution to determine whether an atomic constraint is
satisfied (13.5.2.3) encounters a substitution failure, the constraint is not satisfied, regardless of the presence of a
negation operator.
[Example 2:
template <class T> concept sad = false;
template <class T> int f1(T) requires (!sad<T>);
template <class T> int f1(T) requires (!sad<T>) && true;
int i1 = f1(42); // ambiguous,!sad<T> atomic constraint expressions (13.5.2.3)
// are not formed from the sameexpression
template <class T> concept not_sad = !sad<T>;
template <class T> int f2(T) requires not_sad<T>;
template <class T> int f2(T) requires not_sad<T> && true;
int i2 = f2(42); // OK,!sad<T> atomic constraint expressions both come fromnot_sad
template <class T> int f3(T) requires (!sad<typename T::type>);
int i3 = f3(42); // error: associated constraints not satisfied due to substitution failure
template <class T> concept sad_nested_type = sad<typename T::type>;
template <class T> int f4(T) requires (!sad_nested_type<T>);
int i4 = f4(42); // OK, substitution failure contained withinsad_nested_type
Here, requires (!sad<typename T::type>) requires that there is a nestedtype that is notsad, whereasrequires
(!sad_nested_type<T>) requires that there is nosad nested type. —end example]
—end note]
13.5.2.3 Atomic constraints [temp.constr.atomic]
1 An atomic constraintis formed from an expressionE and a mapping from the template parameters that
appear withinE to template arguments that are formed via substitution during constraint normalization in
the declaration of a constrained entity (and, therefore, can involve the unsubstituted template parameters of
the constrained entity), called theparameter mapping(13.5.3).
[Note 1: Atomic constraints are formed by constraint normalization (13.5.4).E is never a logicaland expression (7.6.14)
nor a logicalor expression (7.6.15). —end note]
2 Two atomic constraints,e1 and e2, areidentical if they are formed from the same appearance of the same
expressionand if, given a hypothetical templateAwhose template-parameter-list consists oftemplate-parameters
corresponding and equivalent (13.7.7.2) to those mapped by the parameter mappings of the expression,
a template-id naming A whose template-arguments are the targets of the parameter mapping ofe1 is the
§ 13.5.2.3 © ISO/IEC
423

===== PAGE 435 =====

Dxxxx
same (13.6) as atemplate-id naming A whose template-arguments are the targets of the parameter mapping
of e2.
[Note 2: The comparison of parameter mappings of atomic constraints operates in a manner similar to that of
declaration matching with alias template substitution (13.7.8).
[Example 1:
template <unsigned N> constexpr bool Atomic = true;
template <unsigned N> concept C = Atomic<N>;
template <unsigned N> concept Add1 = C<N + 1>;
template <unsigned N> concept AddOne = C<N + 1>;
template <unsigned M> void f()
requires Add1<2 * M>;
template <unsigned M> int f()
requires AddOne<2 * M> && true;
int x = f<0>(); // OK, the atomic constraints from conceptC in bothfs areAtomic<N>
// with mapping similar toN ↦→2 * M + 1
template <unsigned N> struct WrapN;
template <unsigned N> using Add1Ty = WrapN<N + 1>;
template <unsigned N> using AddOneTy = WrapN<N + 1>;
template <unsigned M> void g(Add1Ty<2 * M> *);
template <unsigned M> void g(AddOneTy<2 * M> *);
void h() {
g<0>(nullptr); // OK, there is only oneg
}
—end example]
As specified in 13.7.7.2, if the validity or meaning of the program depends on whether two constructs are equivalent,
and they are functionally equivalent but not equivalent, the program is ill-formed, no diagnostic required.
[Example 2:
template <unsigned N> void f2()
requires Add1<2 * N>;
template <unsigned N> int f2()
requires Add1<N * 2> && true;
void h2() {
f2<0>(); // ill-formed, no diagnostic required:
// requires determination of subsumption between atomic constraints that are
// functionally equivalent but not equivalent
}
—end example]
—end note]
3 To determine if an atomic constraint issatisfied, the parameter mapping and template arguments are first
substituted into its expression. If substitution results in an invalid type or expression in the immediate
context of the atomic constraint (13.10.3.1), the constraint is not satisfied. Otherwise, the lvalue-to-rvalue
conversion (7.3.2) is performed if necessary, andE shall be a constant expression of typebool. The constraint
is satisfied if and only if evaluation ofE results intrue. If, at different points in the program, the satisfaction
result is different for identical atomic constraints and template arguments, the program is ill-formed, no
diagnostic required.
[Example 3:
template<typename T> concept C =
sizeof(T) == 4 && !true; // requires atomic constraintssizeof(T) == 4 and !true
template<typename T> struct S {
constexpr operator bool() const { return true; }
};
template<typename T> requires (S<T>{})
void f(T); // #1
§ 13.5.2.3 © ISO/IEC
424

===== PAGE 436 =====

Dxxxx
void f(int); // #2
void g() {
f(0); // error: expressionS<int>{} does not have typebool
} // while checking satisfaction of deduced arguments of #1;
// call is ill-formed even though #2 is a better match
—end example]
13.5.2.4 Concept-dependent constraints [temp.constr.concept]
1 A concept-dependent constraintCD is an atomic constraint whose expression is a concept-idCI whose
concept-name names a dependent concept namedC.
2 To determine ifCD is satisfied, the parameter mapping and template arguments are first substituted intoC.
If substitution results in an invalid concept-id in the immediate context of the constraint (13.10.3.1), the
constraint is not satisfied. Otherwise, letCI′be the normal form (13.5.4) of the concept-id after substitution
of C.
[Note 1: Normalization ofCI can be ill-formed with no diagnostic required.—end note]
3 To formCI′′, each appearance ofC’s template parameters in the parameter mappings of the atomic constraints
(including concept-dependent constraints) inCI′ is substituted with their respective arguments from the
parameter mapping ofCD and the arguments ofCI.
4 CD is satisfied ifCI′′is satisfied.
[Note 2: Checking whetherCI′′is satisfied can lead to further normalization of concept-dependent constraints.—end
note]
[Example 1:
template<typename>
concept C = true;
template<typename T, template<typename> concept CC>
concept D = CC<T>;
template<typename U,
template<typename> concept CT,
template<typename, template<typename> concept> concept CU>
int f() requires CU<U, CT>;
int i = f<int, C, D>();
In this example, the associated constraints off consist of a concept-dependent constraint whose expression is the
concept-id CU<U, CT> with the mappingU ↦→U,CT ↦→CT,CU ↦→CU. The result of substitutingD into this expression is
D<U, CT>. We consider the normal form of the resulting concept-id, which isCC<T> with the mappingT ↦→U,CC ↦→CT.
By recursion,C is substituted intoCC<T>, and the result is normalized to the atomic constrainttrue, which is satisfied.
—end example]
13.5.2.5 Fold expanded constraint [temp.constr.fold]
1 A fold expanded constraintis formed from a constraintC and a fold-operator which can either be&& or
||. A fold expanded constraint is a pack expansion (13.7.4). LetN be the number of elements in the pack
expansion parameters (13.7.4).
2 A fold expanded constraint whosefold-operator is && is satisfied if it is a valid pack expansion and ifN = 0 or
if for eachiwhere 0 ≤i<N in increasing order,C is satisfied when replacing each pack expansion parameter
with the correspondingith element. No substitution takes place for anyi greater than the smallesti for
which the constraint is not satisfied.
3 A fold expanded constraint whosefold-operator is || is satisfied if it is a valid pack expansion,N >0, and if
for i where 0 ≤i<N in increasing order, there is a smallesti for whichC is satisfied when replacing each
pack expansion parameter with the correspondingith element. No substitution takes place for anyi greater
than the smallesti for which the constraint is satisfied.
4 [Note 1: If the pack expansion expands packs of different size, then it is invalid and the fold expanded constraint is
not satisfied. —end note]
5 Two fold expanded constraints arecompatible for subsumptionif their respective constraints both contain an
equivalent unexpanded pack (13.7.7.2).
§ 13.5.2.5 © ISO/IEC
425

===== PAGE 437 =====

Dxxxx
13.5.3 Constrained declarations [temp.constr.decl]
1 A template declaration (13.1) or templated function declaration (9.3.4.6) can be constrained by the use of a
requires-clause. This allows the specification of constraints for that declaration as an expression:
constraint-expression:
logical-or-expression
2 Constraints can also be associated with a declaration through the use oftype-constraints in atemplate-
parameter-list or parameter-type-list. Each of these forms introduces additionalconstraint-expressions that are
used to constrain the declaration.
3 A declaration’sassociated constraintsare defined as follows:
—(3.1) If there are no introducedconstraint-expressions, the declaration has no associated constraints.
—(3.2) Otherwise, if there is a single introducedconstraint-expression, the associated constraints are the normal
form (13.5.4) of that expression.
—(3.3) Otherwise, the associated constraints are the normal form of a logicaland expression (7.6.14) whose
operands are in the following order:
—(3.3.1) the constraint-expression introduced by eachtype-constraint (13.2) in the declaration’stemplate-
parameter-list, in order of appearance, and
—(3.3.2) the constraint-expression introduced by arequires-clause following atemplate-parameter-list (13.1),
and
—(3.3.3) the constraint-expression introduced by eachtype-constraint in the parameter-type-list of a function
declaration, and
—(3.3.4) the constraint-expression introduced by a trailingrequires-clause (9.3) of a function declaration
(9.3.4.6).
The formation of the associated constraints establishes the order in which constraints are instantiated when
checking for satisfaction (13.5.2).
[Example 1:
template<typename T> concept C = true;
template<C T> void f1(T);
template<typename T> requires C<T> void f2(T);
template<typename T> void f3(T) requires C<T>;
The functionsf1, f2, andf3 have the associated constraintC<T>.
template<typename T> concept C1 = true;
template<typename T> concept C2 = sizeof(T) > 0;
template<C1 T> void f4(T) requires C2<T>;
template<typename T> requires C1<T> && C2<T> void f5(T);
The associated constraints off4 and f5 are C1<T> ∧ C2<T>.
template<C1 T> requires C2<T> void f6();
template<C2 T> requires C1<T> void f7();
The associated constraints off6 are C1<T> ∧ C2<T>, and those off7 are C2<T> ∧ C1<T>. —end example]
4 When determining whether a given introducedconstraint-expression C1 of a declaration in an instantiated
specialization of a templated class is equivalent (13.7.7.2) to the correspondingconstraint-expression C2 of a
declaration outside the class body,C1 is instantiated. If the instantiation results in an invalid expression, the
constraint-expressions are not equivalent.
[Note 1: This can happen when determining which member template is specialized by an explicit specialization
declaration. —end note]
[Example 2:
template <class T> concept C = true;
template <class T> struct A {
template <class U> U f(U) requires C<typename T::type>; // #1
template <class U> U f(U) requires C<T>; // #2
};
§ 13.5.3 © ISO/IEC
426

===== PAGE 438 =====

Dxxxx
template <> template <class U>
U A<int>::f(U u) requires C<int> { return u; } // OK, specializes #2
Substituting int for T in C<typename T::type> produces an invalid expression, so the specialization does not match #1.
Substituting int for T in C<T> produces C<int>, which is equivalent to theconstraint-expression for the specialization,
so it does match #2.—end example]
13.5.4 Constraint normalization [temp.constr.normal]
1 The normal formof anexpression E is a constraint (13.5.2) that is defined as follows:
—(1.1) The normal form of an expression( E ) is the normal form ofE.
—(1.2) The normal form of an expressionE1 || E2 is the disjunction (13.5.2.2) of the normal forms ofE1 and
E2.
—(1.3) The normal form of an expressionE1 && E2 is the conjunction of the normal forms ofE1 and E2.
—(1.4) For a concept-idC<A1, A2, ... , An> termed CI:
—(1.4.1) If C names a dependent concept, the normal form ofCI is a concept-dependent constraint whose
concept-id isCI and whose parameter mapping is the identity mapping.
—(1.4.2) Otherwise, to formCE, any non-dependent concept template argumentAi is substituted into the
constraint-expression of C. If any such substitution results in an invalid concept-id, the program is
ill-formed; no diagnostic is required. The normal form ofCI is the result of substituting, in the
normal formN of CE, appearances ofC’s template parameters in the parameter mappings of the
atomic constraints inN with their respective arguments fromC. If any such substitution results in
an invalid type or expression, the program is ill-formed; no diagnostic is required.
[Example 1:
template<typename T> concept A = T::value || true;
template<typename U> concept B = A<U*>;
template<typename V> concept C = B<V&>;
Normalization ofB’s constraint-expression is valid and results inT::value (with the mappingT ↦→U*) ∨true
(with an empty mapping), despite the expressionT::value being ill-formed for a pointer typeT. Normalization
of C’s constraint-expression results in the program being ill-formed, because it would form the invalid typeV&*
in the parameter mapping.—end example]
—(1.5) For afold-operator Op (7.5.7) that is either&& or ||:
—(1.5.1) The normal form of an expression( ... Op E ) is the normal form of( E Op ... ).
—(1.5.2) The normal form of an expression( E1 Op ... Op E2 ) is the normal form of
—(1.5.2.1) ( E1 Op ... ) Op E2 if E1 contains an unexpanded pack, or
—(1.5.2.2) E1 Op ( E2 Op ... ) otherwise.
—(1.5.3) The normal form of an expressionF of the form( E Op ... ) is as follows:
If E contains an unexpanded concept template parameter pack, it shall not contain an unexpanded
template parameter pack of another kind. LetE′be the normal form ofE.
—(1.5.3.1) If E contains an unexpanded concept template parameter packPk that has corresponding
template arguments in the parameter mapping of any atomic constraint (including concept-
dependent constraints) ofE′, the number of arguments specified for all suchPk shall be the
same number N. The normal form of F is the normal form ofE0 Op ··· Op EN−1 after
substituting inEi the respectiveith concept argument of eachPk. If any such substitution
results in an invalid type or expression, the program is ill-formed; no diagnostic is required.
—(1.5.3.2) Otherwise, the normal form ofF is a fold expanded constraint (13.5.2.5) whose constraint is
E′and whosefold-operator is Op.
—(1.6) The normal form of any other expressionE is the atomic constraint whose expression isE and whose
parameter mapping is the identity mapping.
2 The process of obtaining the normal form of aconstraint-expression is callednormalization.
[Note 1: Normalization ofconstraint-expressions is performed when determining the associated constraints (13.5.2) of a
declaration and when evaluating the value of anid-expression that names a concept specialization (7.5.5).—end note]
§ 13.5.4 © ISO/IEC
427

===== PAGE 439 =====

Dxxxx
3 [Example 2:
template<typename T> concept C1 = sizeof(T) == 1;
template<typename T> concept C2 = C1<T> && 1 == 2;
template<typename T> concept C3 = requires { typename T::type; };
template<typename T> concept C4 = requires (T x) { ++x; };
template<C2 U> void f1(U); // #1
template<C3 U> void f2(U); // #2
template<C4 U> void f3(U); // #3
The associated constraints of #1 aresizeof(T) == 1 (with mappingT ↦→U) ∧1 == 2.
The associated constraints of #2 arerequires { typename T::type; } (with mappingT ↦→U).
The associated constraints of #3 arerequires (T x) { ++x; } (with mappingT ↦→U). —end example]
[Example 3:
template<typename T>
concept C = true;
template<typename T, template<typename> concept CT>
concept CC = CT<T>;
template<typename U,
template<typename, template<typename> concept> concept CT>
void f() requires CT<U*, C>;
template<typename U>
void g() requires CC<U*, C>;
The normal form of the associated constraints off is the concept-dependent constraintCT<T, C>.
The normal form of the associated constraints ofg is the atomic constrainttrue. —end example]
[Example 4:
template<typename T>
concept A = true;
template<typename T>
concept B = A<T> && true; // B subsumes A
template<typename T>
concept C = true;
template<typename T>
concept D = C<T> && true; // D subsumes C
template<typename T, template<typename> concept... CTs>
concept all_of = (CTs<T> && ...);
template<typename T> requires all_of<T, A, C>
constexpr int f(T) { return 1; } // #1
template<typename T> requires all_of<T, B, D>
constexpr int f(T) { return 2; } // #2
static_assert(f(1) == 2); // ok
The normal form ofall_of<T, A, C> is the conjunction of the normal forms ofA<T> and C<T>.
Similarly, the normal form ofall_of<T, B, D> is the conjunction of the normal forms ofB<T> and D<T>.
#2 therefore is more constrained than #1.—end example]
[Example 5:
template<typename T, template<typename> concept>
struct wrapper {};
template<typename... T, template<typename> concept... CTs>
int f(wrapper<T, CTs>...) requires (CTs<T> && ...); // error: fold expression contains
// different kinds of template parameters
—end example]
§ 13.5.4 © ISO/IEC
428

===== PAGE 440 =====

Dxxxx
13.5.5 Partial ordering by constraints [temp.constr.order]
1 A constraintP subsumes a constraintQ if and only if, for every disjunctive clausePi in the disjunctive
normal form105 of P, Pi subsumes every conjunctive clauseQj in the conjunctive normal form106 of Q, where
—(1.1) a disjunctive clausePi subsumes a conjunctive clauseQj if and only if there exists an atomic constraint
Pia in Pi for which there exists an atomic constraintQjb in Qj such thatPia subsumes Qjb,
—(1.2) an atomic constraintA subsumes another atomic constraintB if and only ifA and B are identical
using the rules described in 13.5.2.3, and
—(1.3) a fold expanded constraintA subsumes another fold expanded constraintB if they are compatible for
subsumption, have the samefold-operator, and the constraint ofA subsumes that ofB.
[Example 1: LetAand B be atomic constraints (13.5.2.3). The constraintA∧B subsumes A, butAdoes not subsume
A∧B. The constraintA subsumes A∨B, butA∨B does not subsumeA. Also note that every constraint subsumes
itself. —end example]
2 [Note 1: The subsumption relation defines a partial ordering on constraints. This partial ordering is used to determine
—(2.1) the best viable candidate of non-template functions (12.2.4),
—(2.2) the address of a non-template function (12.3),
—(2.3) the matching of template template arguments (13.4.4),
—(2.4) the partial ordering of class template specializations (13.7.6.3), and
—(2.5) the partial ordering of function templates (13.7.7.3).
—end note]
3 The associated constraintsC of a declarationD are eligible for subsumptionunless C contains a concept-
dependent constraint.
4 A declarationD1 is at least as constrainedas a declarationD2 if
—(4.1) D1 and D2 are both constrained declarations andD1’s associated constraints are eligible for subsumption
and subsume those ofD2; or
—(4.2) D2 has no associated constraints.
5 A declarationD1 is more constrainedthan another declarationD2 when D1 is at least as constrained asD2,
and D2 is not at least as constrained asD1.
[Example 2:
template<typename T> concept C1 = requires(T t) { --t; };
template<typename T> concept C2 = C1<T> && requires(T t) { *t; };
template<C1 T> void f(T); // #1
template<C2 T> void f(T); // #2
template<typename T> void g(T); // #3
template<C1 T> void g(T); // #4
f(0); // selects #1
f((int*)0); // selects #2
g(true); // selects #3 becauseC1<bool> is not satisfied
g(0); // selects #4
—end example]
[Example 3:
template<template<typename T> concept CT, typename T>
struct S {};
template<typename T>
concept A = true;
105) A constraint is in disjunctive normal form when it is a disjunction of clauses where each clause is a conjunction of fold
expanded or atomic constraints. For atomic constraintsA, B, andC, the disjunctive normal form of the constraintA ∧(B ∨C)
is (A ∧B) ∨(A ∧C). Its disjunctive clauses are(A ∧B) and (A ∧C).
106) A constraint is in conjunctive normal form when it is a conjunction of clauses where each clause is a disjunction of fold
expanded or atomic constraints. For atomic constraintsA, B, andC, the constraintA ∧(B ∨C) is in conjunctive normal form.
Its conjunctive clauses areA and (B ∨C).
§ 13.5.5 © ISO/IEC
429

===== PAGE 441 =====

Dxxxx
template<template<typename T> concept X, typename T>
int f(S<X, T>) requires A<T> { return 42; } // #1
template<template<typename T> concept X, typename T>
int f(S<X, T>) requires X<T> { return 43; } // #2
f(S<A, int>{}); // ok, select #1 because #2 is not eligible for subsumption
—end example]
6 A non-template functionF1 is more partial-ordering-constrainedthan a non-template functionF2 if
—(6.1) they have the same non-object-parameter-type-lists (9.3.4.6), and
—(6.2) if they are member functions, both are direct members of the same class, and
—(6.3) if both are non-static member functions, they have the same types for their object parameters, and
—(6.4) the declaration ofF1 is more constrained than the declaration ofF2.
13.6 Type equivalence [temp.type]
1 Twotemplate-ids are the same if
—(1.1) their template-names, operator-function-ids, orliteral-operator-ids refer to the same template, and
—(1.2) their corresponding typetemplate-arguments are the same type, and
—(1.3) the template parameter values determined by their corresponding constant template arguments (13.4.3)
are template-argument-equivalent (see below), and
—(1.4) their corresponding templatetemplate-arguments refer to the same template.
Twotemplate-ids that are the same refer to the same class, function, or variable.
2 Two values aretemplate-argument-equivalent if they are of the same type and
—(2.1) they are of integral type and their values are the same, or
—(2.2) they are of floating-point type and their values are identical, or
—(2.3) they are of typestd::nullptr_t, or
—(2.4) they are of typestd::meta::info and their values compare equal (7.6.10), or
—(2.5) they are of enumeration type and their values are the same,107 or
—(2.6) they are of pointer type and they have the same pointer value, or
—(2.7) they are of pointer-to-member type and they refer to the same class member or are both the null
member pointer value, or
—(2.8) they are of reference type and they refer to the same object or function, or
—(2.9) they are of array type and their corresponding elements are template-argument-equivalent,108 or
—(2.10) they are of union type and either they both have no active member or they have the same active
member and their active members are template-argument-equivalent, or
—(2.11) they are of a closure type (7.5.6.2), or
—(2.12) they are of class type and their corresponding direct subobjects and reference members are template-
argument-equivalent.
3 [Example 1:
template<class E, int size> class buffer { /* ... */ };
buffer<char,2*512> x;
buffer<char,1024> y;
declares x and y to be of the same type, and
template<class T, void(*err_fct)()> class list { /* ... */ };
list<int,&error_handler1> x1;
list<int,&error_handler2> x2;
list<int,&error_handler2> x3;
list<char,&error_handler2> x4;
107) The identity of enumerators is not preserved.
108) An array as atemplate-parameter decays to a pointer.
§ 13.6 © ISO/IEC
430

===== PAGE 442 =====

Dxxxx
declares x2 and x3 to be of the same type. Their type differs from the types ofx1 and x4.
template<class T> struct X { };
template<class> struct Y { };
template<class T> using Z = Y<T>;
X<Y<int> > y;
X<Z<int> > z;
declares y and z to be of the same type.—end example]
4 If an expressione is type-dependent (13.8.3.3),decltype(e) denotes a unique dependent type. Two such
decltype-specifiers refer to the same type only if theirexpressions are equivalent (13.7.7.2).
[Note 1: However, such a type might be aliased, e.g., by atypedef-name. —end note]
5 For a type template parameter packT, T...[constant-expression] denotes a unique dependent type.
6 If theconstant-expression of apack-index-specifier is value-dependent, two suchpack-index-specifiers refer to the
same type only if theirconstant-expressions are equivalent (13.7.7.2). Otherwise, two suchpack-index-specifiers
refer to the same type only if their indexes have the same value.
13.7 Template declarations [temp.decls]
13.7.1 General [temp.decls.general]
1 The template parameters of a template are specified in the angle bracket enclosed list that immediately
follows the keywordtemplate.
2 Aprimary templatedeclaration is one in which the name of the template is not followed by atemplate-argument-
list. The template argument list of a primary template is the template argument list of itstemplate-head (13.4).
A template declaration in which the name of the template is followed by atemplate-argument-list is a partial
specialization (13.7.6) of the template named in the declaration, which shall be a class or variable template.
3 For purposes of name lookup and instantiation, default arguments,type-constraints, requires-clauses (13.1),
and noexcept-specifiers of function templates and of member functions of class templates are considered
definitions; each default argument,type-constraint, requires-clause, ornoexcept-specifier is a separate definition
which is unrelated to the templated function definition or to any other default arguments,type-constraints,
requires-clauses, ornoexcept-specifiers. For the purpose of instantiation, the substatements of a constexpr
if statement (8.5.2) are considered definitions. For the purpose of name lookup and instantiation, the
compound-statement of anexpansion-statement is considered a template definition.
4 Because analias-declaration cannot declare atemplate-id, it is not possible to partially or explicitly specialize
an alias template.
13.7.2 Class templates [temp.class]
13.7.2.1 General [temp.class.general]
1 A class templatedefines the layout and operations for an unbounded set of related types.
2 [Example 1: It is possible for a single class templateList to provide an unbounded set of class definitions: one
class List<T> for every typeT, each describing a linked list of elements of typeT. Similarly, a class templateArray
describing a contiguous, dynamic array can be defined like this:
template<class T> class Array {
T* v;
int sz;
public:
explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }
};
The prefixtemplate<class T> specifies that a template is being declared and that atype-name T can be used in the
declaration. In other words,Array is a parameterized type withT as its parameter. —end example]
3 [Note 1: When a member of a class template is defined outside of the class template definition, the member definition
is defined as a template definition with thetemplate-head equivalent to that of the class template. The names of the
template parameters used in the definition of the member can differ from the template parameter names used in the
class template definition. The class template name in the member definition is followed by the template argument list
of thetemplate-head (13.4).
§ 13.7.2.1 © ISO/IEC
431

===== PAGE 443 =====

Dxxxx
[Example 2:
template<class T1, class T2> struct A {
void f1();
void f2();
};
template<class T2, class T1> void A<T2,T1>::f1() { } // OK
template<class T2, class T1> void A<T1,T2>::f2() { } // error
template<class ... Types> struct B {
void f3();
void f4();
};
template<class ... Types> void B<Types ...>::f3() { } // OK
template<class ... Types> void B<Types>::f4() { } // error
template<typename T> concept C = true;
template<typename T> concept D = true;
template<C T> struct S {
void f();
void g();
void h();
template<D U> struct Inner;
};
template<C A> void S<A>::f() { } // OK,template-heads match
template<typename T> void S<T>::g() { } // error: no matching declaration forS<T>
template<typename T> requires C<T> // ill-formed, no diagnostic required:template-heads are
void S<T>::h() { } // functionally equivalent but not equivalent
template<C X> template<D Y>
struct S<X>::Inner { }; // OK
—end example]
—end note]
4 In a partial specialization, explicit specialization or explicit instantiation of a class template, theclass-key
shall agree in kind with the original class template declaration (9.2.9.5).
13.7.2.2 Member functions of class templates [temp.mem.func]
1 A member function of a class template may be defined outside of the class template definition in which it is
declared.
[Example 1:
template<class T> class Array {
T* v;
int sz;
public:
explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }
};
declares three member functions of a class template. The subscript function can be defined like this:
template<class T> T& Array<T>::operator[](int i) {
if (i<0 || sz<=i) error("Array: range error");
return v[i];
}
A constrained member function can be defined out of line:
template<typename T> concept C = requires {
typename T::type;
};
§ 13.7.2.2 © ISO/IEC
432

===== PAGE 444 =====

Dxxxx
template<typename T> struct S {
void f() requires C<T>;
void g() requires C<T>;
};
template<typename T>
void S<T>::f() requires C<T> { } // OK
template<typename T>
void S<T>::g() { } // error: no matching function inS<T>
—end example]
2 The template-arguments for a member function of a class template are determined by thetemplate-arguments
of the type of the object for which the member function is called.
[Example 2: The template-argument for Array<T>::operator[] will be determined by the Array to which the
subscripting operation is applied.
Array<int> v1(20);
Array<dcomplex> v2(30);
v1[3] = 7; // Array<int>::operator[]
v2[3] = dcomplex(7,8); // Array<dcomplex>::operator[]
—end example]
13.7.2.3 Deduction guides [temp.deduct.guide]
1 Deduction guides are used when atemplate-name or splice-type-specifier appears as a type specifier for a
deduced class type (9.2.9.8). Deduction guides are not found by name lookup. Instead, when performing
class template argument deduction (12.2.2.9), all reachable deduction guides declared for the class template
are considered.
deduction-guide:
explicit-specifieropt template-name ( parameter-declaration-clause ) -> simple-template-id requires-clauseopt ;
2 [Example 1:
template<class T, class D = int>
struct S {
T data;
};
template<class U>
S(U) -> S<typename U::type>;
struct A {
using type = short;
operator type();
};
S x{A()}; // x is of typeS<short, int>
—end example]
3 The same restrictions apply to theparameter-declaration-clause of a deduction guide as in a function declaration
(9.3.4.6), except that a generic parameter type placeholder (9.2.9.7) shall not appear in theparameter-
declaration-clause of a deduction guide. Thesimple-template-id shall name a class template specialization. The
template-name shall be the sameidentifier as thetemplate-name of thesimple-template-id. A deduction-guide
shall inhabit the scope to which the corresponding class template belongs and, for a member class template,
have the same access. Two deduction guide declarations for the same class template shall not have equivalent
parameter-declaration-clauses if either is reachable from the other.
13.7.2.4 Member classes of class templates [temp.mem.class]
1 A member class of a class template may be defined outside the class template definition in which it is declared.
[Note 1: The member class must be defined before its first use that requires an instantiation (13.9.2). For example,
template<class T> struct A {
class B;
};
A<int>::B* b1; // OK, requiresA to be defined but notA::B
§ 13.7.2.4 © ISO/IEC
433

===== PAGE 445 =====

Dxxxx
template<class T> class A<T>::B { };
A<int>::B b2; // OK, requiresA::B to be defined
—end note]
13.7.2.5 Static data members of class templates [temp.static]
1 A definition for a static data member or static data member template may be provided in a namespace scope
enclosing the definition of the static member’s class template.
[Example 1:
template<class T> class X {
static T s;
};
template<class T> T X<T>::s = 0;
struct limits {
template<class T>
static const T min; // declaration
};
template<class T>
const T limits::min = { }; // definition
—end example]
2 An explicit specialization of a static data member declared as an array of unknown bound can have a different
bound from its definition, if any.
[Example 2:
template <class T> struct A {
static int i[];
};
template <class T> int A<T>::i[4]; // 4 elements
template <> int A<int>::i[] = { 1 }; // OK, 1 element
—end example]
13.7.2.6 Enumeration members of class templates [temp.mem.enum]
1 An enumeration member of a class template may be defined outside the class template definition.
[Example 1:
template<class T> struct A {
enum E : T;
};
template<class T> enum A<T>::E : T { e1, e2 };
A<int>::E e = A<int>::e1;
—end example]
13.7.3 Member templates [temp.mem]
1 A template can be declared within a class or class template; such a template is called a member template. A
member template can be defined within or outside its class definition or class template definition. A member
template of a class template that is defined outside of its class template definition shall be specified with a
template-head equivalent to that of the class template followed by atemplate-head equivalent to that of the
member template (13.7.7.2).
[Example 1:
template<class T> struct string {
template<class T2> int compare(const T2&);
template<class T2> string(const string<T2>& s) { /* ... */ }
};
template<class T> template<class T2> int string<T>::compare(const T2& s) {
}
—end example]
§ 13.7.3 © ISO/IEC
434

===== PAGE 446 =====

Dxxxx
[Example 2:
template<typename T> concept C1 = true;
template<typename T> concept C2 = sizeof(T) <= 4;
template<C1 T> struct S {
template<C2 U> void f(U);
template<C2 U> void g(U);
};
template<C1 T> template<C2 U>
void S<T>::f(U) { } // OK
template<C1 T> template<typename U>
void S<T>::g(U) { } // error: no matching function inS<T>
—end example]
2 A local class of non-closure type shall not have member templates. Access control rules (11.8) apply to member
template names. A destructor shall not be a member template. A non-template member function (9.3.4.6)
with a given name and type and a member function template of the same name, which could be used to
generate a specialization of the same type, can both be declared in a class. When both exist, a use of that
name and type refers to the non-template member unless an explicit template argument list is supplied.
[Example 3:
template <class T> struct A {
void f(int);
template <class T2> void f(T2);
};
template <> void A<int>::f(int) { } // non-template member function
template <> template <> void A<int>::f<>(int) { } // member function template specialization
int main() {
A<char> ac;
ac.f(1); // non-template
ac.f('c'); // template
ac.f<>(1); // template
}
—end example]
3 A member function template shall not be declaredvirtual.
[Example 4:
template <class T> struct AA {
template <class C> virtual void g(C); // error
virtual void f(); // OK
};
—end example]
4 A specialization of a member function template does not override a virtual function from a base class.
[Example 5:
class B {
virtual void f(int);
};
class D : public B {
template <class T> void f(T); // does not overrideB::f(int)
void f(int i) { f<>(i); } // overriding function that calls the function template specialization
};
—end example]
5 [Note 1: A specialization of a conversion function template is named in the same way as a non-template conversion
function that converts to the same type (11.4.8.3).
[Example 6:
§ 13.7.3 © ISO/IEC
435

===== PAGE 447 =====

Dxxxx
struct A {
template <class T> operator T*();
};
template <class T> A::operator T*() { return 0; }
template <> A::operator char*() { return 0; } // specialization
template A::operator void*(); // explicit instantiation
int main() {
A a;
int* ip;
ip = a.operator int*(); // explicit call to template operatorA::operator int*()
}
—end example]
An expression designating a particular specialization of a conversion function template can only be formed with a
splice-expression. There is no analogous syntax to form atemplate-id (13.3) for such a function by providing an explicit
template argument list (13.10.2).—end note]
13.7.4 Variadic templates [temp.variadic]
1 A template parameter packis a template parameter that accepts zero or more template arguments.
[Example 1:
template<class ... Types> struct Tuple { };
Tuple<> t0; // Types contains no arguments
Tuple<int> t1; // Types contains one argument:int
Tuple<int, float> t2; // Types contains two arguments:int and float
Tuple<0> error; // error: 0 is not a type
—end example]
2 A function parameter packis a function parameter that accepts zero or more function arguments.
[Example 2:
template<class ... Types> void f(Types ... args);
f(); // args contains no arguments
f(1); // args contains one argument:int
f(2, 1.0); // args contains two arguments:int and double
—end example]
3 An init-capture pack is a lambda capture that introduces aninit-capture for each of the elements in the pack
expansion of itsinitializer.
[Example 3:
template <typename... Args>
void foo(Args... args) {
[...xs=args]{
bar(xs...); // xs is aninit-capture pack
};
}
foo(); // xs contains zeroinit-captures
foo(1); // xs contains oneinit-capture
—end example]
4 A structured binding packis ansb-identifier that introduces zero or more structured bindings (9.7).
[Example 4:
auto foo() -> int(&)[2];
template <class T>
void g() {
auto [...a] = foo(); // a is a structured binding pack containing two elements
auto [b, c, ...d] = foo(); // d is a structured binding pack containing zero elements
}
§ 13.7.4 © ISO/IEC
436

===== PAGE 448 =====

Dxxxx
—end example]
5 A pack is a template parameter pack, a function parameter pack, aninit-capture pack, or a structured binding
pack. The number of elements of a template parameter pack or a function parameter pack is the number of
arguments provided for the parameter pack. The number of elements of aninit-capture pack is the number of
elements in the pack expansion of itsinitializer.
6 A pack expansionconsists of apattern and an ellipsis, the instantiation of which produces zero or more
instantiations of the pattern in a list (described below). The form of the pattern depends on the context in
which the expansion occurs. Pack expansions can occur in the following contexts:
—(6.1) In a function parameter pack (9.3.4.6); the pattern is theparameter-declaration without the ellipsis.
—(6.2) In ausing-declaration (9.10); the pattern is ausing-declarator.
—(6.3) In afriend-type-declaration (11.4.1); the pattern is afriend-type-specifier.
—(6.4) In a template parameter pack that is a pack expansion (13.2):
—(6.4.1) if the template parameter pack is aparameter-declaration; the pattern is theparameter-declaration
without the ellipsis;
—(6.4.2) if the template parameter pack is atype-parameter; the pattern is the correspondingtype-parameter
without the ellipsis;
—(6.4.3) if the template parameter pack is a template template parameter; the pattern is the corresponding
type-tt-parameter, variable-tt-parameter, orconcept-tt-parameter without the ellipsis.
—(6.5) In aninitializer-list (9.5); the pattern is aninitializer-clause.
—(6.6) In abase-specifier-list (11.7); the pattern is abase-specifier.
—(6.7) In amem-initializer-list (11.9.3) for amem-initializer whose mem-initializer-id denotes a base class; the
pattern is themem-initializer.
—(6.8) In atemplate-argument-list (13.4); the pattern is atemplate-argument.
—(6.9) In anattribute-list (9.13.1); the pattern is anattribute.
—(6.10) In anannotation-list (9.13.1); the pattern is anannotation.
—(6.11) In analignment-specifier (9.13.2); the pattern is thealignment-specifier without the ellipsis.
—(6.12) In acapture-list (7.5.6.3); the pattern is thecapture without the ellipsis.
—(6.13) In asizeof... expression (7.6.2.5); the pattern is anidentifier.
—(6.14) In apack-index-expression; the pattern is anidentifier.
—(6.15) In apack-index-specifier; the pattern is atypedef-name.
—(6.16) In afold-expression (7.5.7); the pattern is thecast-expression that contains an unexpanded pack.
—(6.17) In a fold expanded constraint (13.5.2.5); the pattern is the constraint of that fold expanded constraint.
[Example 5:
template<class ... Types> void f(Types ... rest);
template<class ... Types> void g(Types ... rest) {
f(&rest ...); // “&rest ...” is a pack expansion; “&rest” is its pattern
}
—end example]
7 For the purpose of determining whether a pack satisfies a rule regarding entities other than packs, the pack
is considered to be the entity that would result from an instantiation of the pattern in which it appears.
8 A pack whose name appears within the pattern of a pack expansion is expanded by that pack expansion.
An appearance of the name of a pack is only expanded by the innermost enclosing pack expansion. The
pattern of a pack expansion shall name one or more packs that are not expanded by a nested pack expansion;
such packs are calledunexpanded packsin the pattern. All of the packs expanded by a pack expansion shall
have the same number of arguments specified. An appearance of a name of a pack that is not expanded is
ill-formed.
[Example 6:
template<typename...> struct Tuple {};
template<typename T1, typename T2> struct Pair {};
§ 13.7.4 © ISO/IEC
437

===== PAGE 449 =====

Dxxxx
template<class ... Args1> struct zip {
template<class ... Args2> struct with {
typedef Tuple<Pair<Args1, Args2> ... > type;
};
};
typedef zip<short, int>::with<unsigned short, unsigned>::type T1;
// T1 is Tuple<Pair<short, unsigned short>, Pair<int, unsigned>>
typedef zip<short>::with<unsigned short, unsigned>::type T2;
// error: different number of arguments specified forArgs1 and Args2
template<class ... Args>
void g(Args ... args) { // OK, Args is expanded by the function parameter packargs
f(const_cast<const Args*>(&args)...); // OK, “Args” and “args” are expanded
f(5 ...); // error: pattern does not contain any packs
f(args); // error: pack “args” is not expanded
f(h(args ...) + args ...); // OK, first “args” expanded withinh,
// second “args” expanded withinf
}
—end example]
9 The instantiation of a pack expansion considers itemsE1,E2,..., EN, whereN is the number of elements in
the pack expansion parameters. EachEi is generated by instantiating the pattern and replacing each pack
expansion parameter with itsith element. Such an element, in the context of the instantiation, is interpreted
as follows:
—(9.1) if the pack is a template parameter pack, the element is
—(9.1.1) a typedef-name for a type template parameter pack,
—(9.1.2) an id-expression for a constant template parameter pack, or
—(9.1.3) a template-name for a template template parameter pack
designating theith corresponding type, constant, or template template argument;
—(9.2) if the pack is a function parameter pack, the element is anid-expression designating theith function
parameter that resulted from instantiation of the function parameter pack declaration;
—(9.3) if the pack is aninit-capture pack, the element is anid-expression designating the variable introduced by
the ith init-capture that resulted from instantiation of theinit-capture pack declaration; otherwise
—(9.4) if the pack is a structured binding pack, the element is anid-expression designating theith structured
binding in the pack that resulted from the structured binding declaration.
When N is zero, the instantiation of a pack expansion does not alter the syntactic interpretation of the
enclosing construct, even in cases where omitting the pack expansion entirely would otherwise be ill-formed
or would result in an ambiguity in the grammar.
10 The instantiation of asizeof... expression (7.6.2.5) produces an integral constant with valueN.
11 When instantiating a pack-index-expression P, let K be the index of P. The instantiation of P is the
id-expression EK.
12 When instantiating apack-index-specifier P, letKbe the index ofP. The instantiation ofP is thetypedef-name
EK.
13 The instantiation of analignment-specifier with an ellipsis producesE1 E2 ... EN.
14 The instantiation of afold-expression (7.5.7) produces:
—(14.1) ( ((E1 op E2) op ···) op EN ) for a unary left fold,
—(14.2) ( E1 op (··· op (EN−1 op EN)) ) for a unary right fold,
—(14.3) ( (((E op E1) op E2) op ···) op EN ) for a binary left fold, and
—(14.4) ( E1 op (··· op (EN−1 op (EN op E))) ) for a binary right fold.
In each case,op is thefold-operator. For a binary fold,E is generated by instantiating thecast-expression that
did not contain an unexpanded pack.
§ 13.7.4 © ISO/IEC
438

===== PAGE 450 =====

Dxxxx
[Example 7:
template<typename ...Args>
bool all(Args ...args) { return (... && args); }
bool b = all(true, true, true, false);
Within the instantiation ofall, the returned expression expands to((true && true) && true) && false, which
evaluates tofalse. —end example]
If N is zero for a unary fold, the value of the expression is shown in Table 20; if the operator is not listed in
Table 20, the instantiation is ill-formed.
Table 20 — Value of folding empty sequences [tab:temp.fold.empty]
Operator Value when pack is empty
&& true
|| false
, void()
15 A fold expanded constraint is not instantiated (13.5.2.5).
16 The instantiation of any other pack expansion produces a list of elementsE1,E2,..., EN.
[Note 1: The variety of list varies with the context:expression-list, base-specifier-list, template-argument-list, etc.
—end note]
When N is zero, the instantiation of the expansion produces an empty list.
[Example 8:
template<class... T> struct X : T... { };
template<class... T> void f(T... values) {
X<T...> x(values...);
}
template void f<>(); // OK,X<> has no base classes
// x is a variable of typeX<> that is value-initialized
—end example]
13.7.5 Friends [temp.friend]
1 A friend of a class or class template can be a function template or class template, a specialization of a
function template or class template, or a non-template function or class.
[Example 1:
template<class T> class task;
template<class T> task<T>* preempt(task<T>*);
template<class T> class task {
friend void next_time();
friend void process(task<T>*);
friend task<T>* preempt<T>(task<T>*);
template<class C> friend int func(C);
friend class task<int>;
template<class P> friend class frd;
};
Here, each specialization of thetask class template has the functionnext_time as a friend; becauseprocess does not
have explicittemplate-arguments, each specialization of thetask class template has an appropriately typed function
process as a friend, and this friend is not a function template specialization; because the friendpreempt has an
explicit template-argument T, each specialization of thetask class template has the appropriate specialization of the
function templatepreempt as a friend; and each specialization of thetask class template has all specializations of the
function templatefunc as friends. Similarly, each specialization of thetask class template has the class template
specialization task<int> as a friend, and has all specializations of the class templatefrd as friends. —end example]
§ 13.7.5 © ISO/IEC
439

===== PAGE 451 =====

Dxxxx
2 Friend classes, class templates, functions, or function templates can be declared within a class template.
When a template is instantiated, its friend declarations are found by name lookup as if the specialization had
been explicitly declared at its point of instantiation.
[Note 1: They can introduce entities that belong to an enclosing namespace scope (9.3.4), in which case they are
attached to the same module as the class template (10.1).—end note]
3 A friend template may be declared within a class or class template. A friend function template may be
defined within a class or class template, but a friend class template may not be defined in a class or class
template. In these cases, all specializations of the friend class or friend function template are friends of the
class or class template granting friendship.
[Example 2:
class A {
template<class T> friend class B; // OK
template<class T> friend void f(T) { /* ... */ } // OK
};
—end example]
4 A template friend declaration specifies that all specializations of that template, whether they are implicitly
instantiated (13.9.2), partially specialized (13.7.6) or explicitly specialized (13.9.4), are friends of the class
containing the template friend declaration.
[Example 3:
class X {
template<class T> friend struct A;
class Y { };
};
template<class T> struct A { X::Y ab; }; // OK
template<class T> struct A<T*> { X::Y ab; }; // OK
—end example]
5 A template friend declaration may declare a member of a dependent type to be a friend. The friend
declaration shall declare a function or specify a type with anelaborated-type-specifier, in either case with a
nested-name-specifier ending with asimple-template-id, C, whosetemplate-name names a class template. The
template parameters of the template friend declaration shall be deducible fromC (13.10.3.6). In this case, a
member of a specializationS of the class template is a friend of the class granting friendship if deduction of
the template parameters ofC from S succeeds, and substituting the deduced template arguments into the
friend declaration produces a declaration that corresponds to the member of the specialization.
[Example 4:
template<class T> struct A {
struct B { };
void f();
struct D {
void g();
};
T h();
template<T U> T i();
};
template<> struct A<int> {
struct B { };
int f();
struct D {
void g();
};
template<int U> int i();
};
template<> struct A<float*> {
int *h();
};
class C {
template<class T> friend struct A<T>::B; // grants friendship toA<int>::B even though
§ 13.7.5 © ISO/IEC
440

===== PAGE 452 =====

Dxxxx
// it is not a specialization ofA<T>::B
template<class T> friend void A<T>::f(); // does not grant friendship toA<int>::f()
// because its return type does not match
template<class T> friend void A<T>::D::g(); // error: A<T>::D does not end with asimple-template-id
template<class T> friend int *A<T*>::h(); // grants friendship toA<int*>::h() and A<float*>::h()
template<class T> template<T U> // grants friendship to instantiations ofA<T>::i() and
friend T A<T>::i(); // toA<int>::i(), and thereby to all specializations
}; // of those function templates
—end example]
6 A friend template shall not be declared in a local class.
7 Friend declarations shall not declare partial specializations.
[Example 5:
template<class T> class A { };
class X {
template<class T> friend class A<T*>; // error
};
—end example]
8 When a friend declaration refers to a specialization of a function template, the function parameter declarations
shall not include default arguments, nor shall theinline, constexpr, orconsteval specifiers be used in
such a declaration.
9 A non-template friend declaration with arequires-clause shall be a definition. A friend function template
with a constraint that depends on a template parameter from an enclosing template shall be a definition.
Such a constrained friend function or function template declaration does not declare the same function or
function template as a declaration in any other scope.
13.7.6 Partial specialization [temp.spec.partial]
13.7.6.1 General [temp.spec.partial.general]
1 A partial specialization of a template provides an alternative definition of the template that is used instead of
the primary definition when the arguments in a specialization match those given in the partial specialization
(13.7.6.2). A declaration of the primary template shall precede any partial specialization of that template. A
partial specialization shall be reachable from any use of a template specialization that would make use of the
partial specialization as the result of an implicit or explicit instantiation; no diagnostic is required.
2 Two partial specialization declarations declare the same entity if they are partial specializations of the
same template and have equivalenttemplate-heads and template argument lists (13.7.7.2). Each partial
specialization is a distinct template.
3 [Example 1:
template<class T1, class T2, int I> class A { };
template<class T, int I> class A<T, T*, I> { };
template<class T1, class T2, int I> class A<T1*, T2, I> { };
template<class T> class A<int, T*, 5> { };
template<class T1, class T2, int I> class A<T1, T2*, I> { };
The first declaration declares the primary (unspecialized) class template. The second and subsequent declarations
declare partial specializations of the primary template.—end example]
4 A partial specialization may be constrained (13.5).
[Example 2:
template<typename T> concept C = true;
template<typename T> struct X { };
template<typename T> struct X<T*> { }; // #1
template<C T> struct X<T> { }; // #2
Both partial specializations are more specialized than the primary template. #1 is more specialized because the
deduction of its template arguments from the template argument list of the class template specialization succeeds,
while the reverse does not. #2 is more specialized because the template arguments are equivalent, but the partial
specialization is more constrained (13.5.5).—end example]
§ 13.7.6.1 © ISO/IEC
441

===== PAGE 453 =====

Dxxxx
5 The template argument list of a partial specialization is thetemplate-argument-list following the name of the
template.
6 A partial specialization may be declared in any scope in which the corresponding primary template may be
defined (9.3.4, 11.4, 13.7.3).
[Example 3:
template<class T> struct A {
struct C {
template<class T2> struct B { };
template<class T2> struct B<T2**> { }; // partial specialization #1
};
};
// partial specialization ofA<T>::C::B<T2>
template<class T> template<class T2>
struct A<T>::C::B<T2*> { }; // #2
A<short>::C::B<int*> absip; // uses partial specialization #2
—end example]
7 Partial specialization declarations do not introduce a name. Instead, when the primary template name is
used, any reachable partial specializations of the primary template are also considered.
[Note 1: One consequence is that ausing-declaration which refers to a class template does not restrict the set of partial
specializations that are found through theusing-declaration. —end note]
[Example 4:
namespace N {
template<class T1, class T2> class A { }; // primary template
}
using N::A; // refers to the primary template
namespace N {
template<class T> class A<T, T*> { }; // partial specialization
}
A<int,int*> a; // uses the partial specialization, which is found through the using-declaration
// which refers to the primary template
—end example]
8 A constant template argument is non-specialized if it is the name of a constant template parameter. All
other constant template arguments are specialized.
9 Within the argument list of a partial specialization, the following restrictions apply:
—(9.1) The type of a template parameter corresponding to a specialized constant template argument shall not
be dependent on a parameter of the partial specialization.
[Example 5:
template <class T, T t> struct C {};
template <class T> struct C<T, 1>; // error
template< int X, int (*array_ptr)[X] > class A {};
int array[5];
template< int X > class A<X,&array> { }; // error
—end example]
—(9.2) The partial specialization shall be more specialized than the primary template (13.7.6.3).
—(9.3) The template parameter list of a partial specialization shall not contain default template argument
values.109
—(9.4) An argument shall not contain an unexpanded pack. If an argument is a pack expansion (13.7.4), it
shall be the last argument in the template argument list.
109) There is no context in which they would be used.
§ 13.7.6.1 © ISO/IEC
442

===== PAGE 454 =====

Dxxxx
10 The usual access checking rules do not apply to non-dependent names used to specify template arguments of
the simple-template-id of the partial specialization.
[Note 2: The template arguments can be private types or objects that would normally not be accessible. Dependent
names cannot be checked when declaring the partial specialization, but will be checked when substituting into the
partial specialization. —end note]
13.7.6.2 Matching of partial specializations [temp.spec.partial.match]
1 When a template is used in a context that requires an instantiation of the template, it is necessary to
determine whether the instantiation is to be generated using the primary template or one of the partial
specializations. This is done by matching the template arguments of the template specialization with the
template argument lists of the partial specializations.
—(1.1) If exactly one matching partial specialization is found, the instantiation is generated from that partial
specialization.
—(1.2) If more than one matching partial specialization is found, the partial order rules (13.7.6.3) are used
to determine whether one of the partial specializations is more specialized than the others. If such a
partial specialization exists, the instantiation is generated from that partial specialization; otherwise,
the use of the template is ambiguous and the program is ill-formed.
—(1.3) If no matches are found, the instantiation is generated from the primary template.
2 A partial specialization matches a given actual template argument list if the template arguments of the
partial specialization can be deduced from the actual template argument list (13.10.3), and the deduced
template arguments satisfy the associated constraints of the partial specialization, if any (13.5.3).
[Example 1:
template<class T1, class T2, int I> class A { }; // #1
template<class T, int I> class A<T, T*, I> { }; // #2
template<class T1, class T2, int I> class A<T1*, T2, I> { }; // #3
template<class T> class A<int, T*, 5> { }; // #4
template<class T1, class T2, int I> class A<T1, T2*, I> { }; // #5
A<int, int, 1> a1; // uses #1
A<int, int*, 1> a2; // uses #2,T is int, I is 1
A<int, char*, 5> a3; // uses #4,T is char
A<int, char*, 1> a4; // uses #5,T1 is int, T2 is char, I is 1
A<int*, int*, 2> a5; // ambiguous: matches #3 and #5
—end example]
[Example 2:
template<typename T> concept C = requires (T t) { t.f(); };
template<typename T> struct S { }; // #1
template<C T> struct S<T> { }; // #2
struct Arg { void f(); };
S<int> s1; // uses #1; the constraints of #2 are not satisfied
S<Arg> s2; // uses #2; both constraints are satisfied but #2 is more specialized
—end example]
3 If the template arguments of a partial specialization cannot be deduced because of the structure of its
template-parameter-list and thetemplate-id, the program is ill-formed.
[Example 3:
template <int I, int J> struct A {};
template <int I> struct A<I+5, I*2> {}; // error
template <int I> struct A<I, I> {}; // OK
template <int I, int J, int K> struct B {};
template <int I> struct B<I, I*2, 2> {}; // OK
—end example]
§ 13.7.6.2 © ISO/IEC
443

===== PAGE 455 =====

Dxxxx
4 In a name that refers to a specialization of a class or variable template (e.g.,A<int, int, 1>), the argument
list shall match the template parameter list of the primary template. The template arguments of a partial
specialization are deduced from the arguments of the primary template.
13.7.6.3 Partial ordering of partial specializations [temp.spec.partial.order]
1 For two partial specializations, the first ismore specializedthan the second if, given the following rewrite
to two function templates, the first function template is more specialized than the second according to the
ordering rules for function templates (13.7.7.3):
—(1.1) Each of the two function templates has the same template parameters and associated constraints (13.5.3)
as the corresponding partial specialization.
—(1.2) Each function template has a single function parameter whose type is a class template specialization
where the template arguments are the corresponding template parameters from the function template
for each template argument in the template-argument-list of the simple-template-id of the partial
specialization.
2 [Example 1:
template<int I, int J, class T> class X { };
template<int I, int J> class X<I, J, int> { }; // #1
template<int I> class X<I, I, int> { }; // #2
template<int I0, int J0> void f(X<I0, J0, int>); // A
template<int I0> void f(X<I0, I0, int>); // B
template <auto v> class Y { };
template <auto* p> class Y<p> { }; // #3
template <auto** pp> class Y<pp> { }; // #4
template <auto* p0> void g(Y<p0>); // C
template <auto** pp0> void g(Y<pp0>); // D
According to the ordering rules for function templates, the function templateB is more specialized than the function
template A and the function templateD is more specialized than the function templateC. Therefore, the partial
specialization #2 is more specialized than the partial specialization #1 and the partial specialization #4 is more
specialized than the partial specialization #3.—end example]
[Example 2:
template<typename T> concept C = requires (T t) { t.f(); };
template<typename T> concept D = C<T> && requires (T t) { t.f(); };
template<typename T> class S { };
template<C T> class S<T> { }; // #1
template<D T> class S<T> { }; // #2
template<C T> void f(S<T>); // A
template<D T> void f(S<T>); // B
The partial specialization #2 is more specialized than #1 becauseB is more specialized thanA. —end example]
13.7.6.4 Members of class template partial specializations [temp.spec.partial.member]
1 The members of the class template partial specialization are unrelated to the members of the primary
template. Class template partial specialization members that are used in a way that requires a definition
shall be defined; the definitions of members of the primary template are never used as definitions for members
of a class template partial specialization. An explicit specialization of a member of a class template partial
specialization is declared in the same way as an explicit specialization of a member of the primary template.
[Example 1:
// primary class template
template<class T, int I> struct A {
void f();
};
// member of primary class template
template<class T, int I> void A<T,I>::f() { }
§ 13.7.6.4 © ISO/IEC
444

===== PAGE 456 =====

Dxxxx
// class template partial specialization
template<class T> struct A<T,2> {
void f();
void g();
void h();
};
// member of class template partial specialization
template<class T> void A<T,2>::g() { }
// explicit specialization
template<> void A<char,2>::h() { }
int main() {
A<char,0> a0;
A<char,2> a2;
a0.f(); // OK, uses definition of primary template’s member
a2.g(); // OK, uses definition of partial specialization’s member
a2.h(); // OK, uses definition of explicit specialization’s member
a2.f(); // error: no definition off for A<T,2>; the primary template is not used here
}
—end example]
2 If a member template of a class template is partially specialized, the member template partial specializations
are member templates of the enclosing class template; if the enclosing class template is instantiated (13.9.2,
13.9.3), a declaration for every member template partial specialization is also instantiated as part of creating
the members of the class template specialization. If the primary member template is explicitly specialized for
a given (implicit) specialization of the enclosing class template, the partial specializations of the member
template are ignored for this specialization of the enclosing class template. If a partial specialization of the
member template is explicitly specialized for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are still considered for this specialization
of the enclosing class template.
[Example 2:
template<class T> struct A {
template<class T2> struct B {}; // #1
template<class T2> struct B<T2*> {}; // #2
};
template<> template<class T2> struct A<short>::B {}; // #3
A<char>::B<int*> abcip; // uses #2
A<short>::B<int*> absip; // uses #3
A<char>::B<int> abci; // uses #1
—end example]
13.7.7 Function templates [temp.fct]
13.7.7.1 General [temp.fct.general]
1 A function template defines an unbounded set of related functions.
[Example 1: A family of sort functions can be declared like this:
template<class T> class Array { };
template<class T> void sort(Array<T>&);
—end example]
2 [Note 1: A function template can have the same name as other function templates and non-template functions (9.3.4.6)
in the same scope.—end note]
A non-template function is not related to a function template (i.e., it is never considered to be a specialization),
even if it has the same name and type as a potentially generated function template specialization.110
110) That is, declarations of non-template functions do not merely guide overload resolution of function template specializations
with the same name. If such a non-template function is odr-used (6.3) in a program, it must be defined; it will not be implicitly
instantiated using the function template definition.
§ 13.7.7.1 © ISO/IEC
445

===== PAGE 457 =====

Dxxxx
13.7.7.2 Function template overloading [temp.over.link]
1 It is possible to overload function templates so that two different function template specializations have the
same type.
[Example 1:
// translation unit 1:
template<class T>
void f(T*);
void g(int* p) {
f(p); // calls f<int>(int*)
}
// translation unit 2:
template<class T>
void f(T);
void h(int* p) {
f(p); // calls f<int*>(int*)
}
—end example]
2 Such specializations are distinct functions and do not violate the one-definition rule (6.3).
3 The signature of a function template is defined in Clause 3. The names of the template parameters are
significant only for establishing the relationship between the template parameters and the rest of the signature.
[Note 1: Two distinct function templates can have identical function return types and function parameter lists, even
if overload resolution alone cannot distinguish them.
template<class T> void f();
template<int I> void f(); // OK, overloads the first template
// distinguishable with an explicit template argument list
—end note]
4 When an expression that references a template parameter is used in the function parameter list or the return
type in the declaration of a function template, the expression that references the template parameter is part
of the signature of the function template. This is necessary to permit a declaration of a function template in
one translation unit to be linked with another declaration of the function template in another translation
unit and, conversely, to ensure that function templates that are intended to be distinct are not linked with
one another.
[Example 2:
template <int I, int J> A<I+J> f(A<I>, A<J>); // #1
template <int K, int L> A<K+L> f(A<K>, A<L>); // same as #1
template <int I, int J> A<I-J> f(A<I>, A<J>); // different from #1
—end example]
[Note 2: Most expressions that use template parameters use constant template parameters, but it is possible for
an expression to reference a type parameter. For example, a template type parameter can be used in thesizeof
operator. —end note]
5 Two expressions involving template parameters are consideredequivalent if two function definitions containing
the expressions would satisfy the one-definition rule (6.3), except that the tokens used to name the template
parameters may differ as long as a token used to name a template parameter in one expression is replaced by
another token that names the same template parameter in the other expression. Two unevaluated operands
that do not involve template parameters are considered equivalent if two function definitions containing the
expressions would satisfy the one-definition rule, except that the tokens used to name types and declarations
may differ as long as they name the same entities, and the tokens used to form concept-ids (13.3) may differ
as long as the twotemplate-ids are the same (13.6).
[Note 3: For instance,A<42> and A<40+2> name the same type.—end note]
Twolambda-expressions are never considered equivalent.
[Note 4: The intent is to avoidlambda-expressions appearing in the signature of a function template with external
linkage. —end note]
For determining whether two dependent names (13.8.3) are equivalent, only the name itself is considered, not
the result of name lookup.
[Note 5: If such a dependent name is unqualified, it is looked up from a first declaration of the function template (13.8.1).
—end note]
[Example 3:
template <int I, int J> void f(A<I+J>); // #1
template <int K, int L> void f(A<K+L>); // same as #1
§ 13.7.7.2 © ISO/IEC
446

===== PAGE 458 =====

Dxxxx
template <class T> decltype(g(T())) h();
int g(int);
template <class T> decltype(g(T())) h() // redeclaration ofh() uses the earlier lookup...
{ return g(T()); } // ... although the lookup here does findg(int)
int i = h<int>(); // template argument substitution fails;g(int)
// not considered at the first declaration ofh()
// ill-formed, no diagnostic required: the two expressions are functionally equivalent but not equivalent
template <int N> void foo(const char (*s)[([]{}, N)]);
template <int N> void foo(const char (*s)[([]{}, N)]);
// two different declarations because the non-dependent portions are not considered equivalent
template <class T> void spam(decltype([]{}) (*s)[sizeof(T)]);
template <class T> void spam(decltype([]{}) (*s)[sizeof(T)]);
—end example]
Two potentially-evaluated expressions involving template parameters that are not equivalent arefunctionally
equivalent if, for any given set of template arguments, the evaluation of the expression results in the same
value. Two unevaluated operands that are not equivalent are functionally equivalent if, for any given set of
template arguments, the expressions perform the same operations in the same order with the same entities.
[Note 6: For instance, one could have redundant parentheses.—end note]
[Example 4:
template<int I> concept C = true;
template<typename T> struct A {
void f() requires C<42>; // #1
void f() requires true; // OK, different functions
};
—end example]
6 Two template-heads are equivalent if their template-parameter-lists have the same length, corresponding
template-parameters are equivalent and are both declared withtype-constraints that are equivalent if either
template-parameter is declared with atype-constraint, and if eithertemplate-head has arequires-clause, they
both haverequires-clauses and the correspondingconstraint-expressions are equivalent. Twotemplate-parameters
are equivalent under the following conditions:
—(6.1) they declare template parameters of the same kind,
—(6.2) if either declares a template parameter pack, they both do,
—(6.3) if they declare constant template parameters, they have equivalent types ignoring the use oftype-
constraints for placeholder types, and
—(6.4) if they declare template template parameters, theirtemplate-heads are equivalent.
When determining whether types ortype-constraints are equivalent, the rules above are used to compare
expressions involving template parameters. Twotemplate-heads arefunctionally equivalent if they accept and
are satisfied by (13.5.2) the same set of template argument lists.
7 If the validity or meaning of the program depends on whether two constructs are equivalent, and they are
functionally equivalent but not equivalent, the program is ill-formed, no diagnostic required. Furthermore, if
two declarationsA and B of function templates
—(7.1) introduce the same name,
—(7.2) have corresponding signatures (6.4.1),
—(7.3) would declare the same entity, when consideringA and B to correspond in that determination (6.7),
and
—(7.4) accept and are satisfied by the same set of template argument lists,
but do not correspond, the program is ill-formed, no diagnostic required.
8 [Note 7: This rule guarantees that equivalent declarations will be linked with one another, while not requiring
implementations to use heroic efforts to guarantee that functionally equivalent declarations will be treated as distinct.
For example, the last two declarations are functionally equivalent and would cause a program to be ill-formed:
// guaranteed to be the same
template <int I> void f(A<I>, A<I+10>);
§ 13.7.7.2 © ISO/IEC
447

===== PAGE 459 =====

Dxxxx
template <int I> void f(A<I>, A<I+10>);
// guaranteed to be different
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+11>);
// ill-formed, no diagnostic required
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+1+2+3+4>);
—end note]
13.7.7.3 Partial ordering of function templates [temp.func.order]
1 If multiple function templates share a name, the use of that name can be ambiguous because template
argument deduction (13.10.3) may identify a specialization for more than one function template.Partial
ordering of overloaded function template declarations is used in the following contexts to select the function
template to which a function template specialization refers:
—(1.1) during overload resolution for a call to a function template specialization (12.2.4);
—(1.2) when the address of a function template specialization is taken;
—(1.3) when a placement operator delete that is a function template specialization is selected to match a
placement operator new (6.8.6.5.3, 7.6.2.8);
—(1.4) when a friend function declaration (13.7.5), an explicit instantiation (13.9.3) or an explicit specialization
(13.9.4) refers to a function template specialization.
2 Partial ordering selects which of two function templates is more specialized than the other by transforming
each template in turn (see next paragraph) and performing template argument deduction using the function
type. The deduction process determines whether one of the templates is more specialized than the other.
If so, the more specialized template is the one chosen by the partial ordering process. If both deductions
succeed, the partial ordering selects the more constrained template (if one exists) as determined below.
3 To produce the transformed template, for each type, constant, type template, variable template, or concept
template parameter (including template parameter packs (13.7.4) thereof) synthesize a unique type, value,
class template, variable template, or concept, respectively, and substitute it for each occurrence of that
parameter in the function type of the template. The type replacing a placeholder in the type of the value
synthesized for a constant template parameter is a unique synthesized type.
4 A synthesized template has the sametemplate-head as its corresponding template template parameter.
5 Each function templateM that is a member function is considered to have a new first parameter of type
X(M), described below, inserted in its function parameter list. If exactly one of the function templates was
considered by overload resolution via a rewritten candidate (12.2.2.3) with a reversed order of parameters,
then the order of the function parameters in its transformed template is reversed. For a function templateM
with cv-qualifierscv that is a member of a classA:
—(5.1) The typeX(M) is “rvalue reference tocv A” if the optionalref-qualifier of M is && or ifM has no
ref-qualifier and the positionally-corresponding parameter of the other transformed template has rvalue
reference type; if this determination depends recursively upon whetherX(M) is an rvalue reference
type, it is not considered to have rvalue reference type.
—(5.2) Otherwise, X(M) is “lvalue reference tocv A”.
[Note 1: This allows a non-static member to be ordered with respect to a non-member function and for the results to
be equivalent to the ordering of two equivalent non-members.—end note]
[Example 1:
struct A { };
template<class T> struct B {
template<class R> int operator*(R&); // #1
};
template<class T, class R> int operator*(T&, R&); // #2
// The declaration ofB::operator* is transformed into the equivalent of
// template<class R> int operator*(B<A>&, R&); // #1a
§ 13.7.7.3 © ISO/IEC
448

===== PAGE 460 =====

Dxxxx
int main() {
A a;
B<A> b;
b * a; // calls #1
}
—end example]
6 Using the transformed function template’s function type, perform type deduction against the other template
as described in 13.10.3.5.
[Example 2:
template<class T> struct A { A(); };
template<class T> void f(T);
template<class T> void f(T*);
template<class T> void f(const T*);
template<class T> void g(T);
template<class T> void g(T&);
template<class T> void h(const T&);
template<class T> void h(A<T>&);
void m() {
const int* p;
f(p); // f(const T*) is more specialized thanf(T) or f(T*)
float x;
g(x); // ambiguous: g(T) or g(T&)
A<int> z;
h(z); // overload resolution selectsh(A<T>&)
const A<int> z2;
h(z2); // h(const T&) is called becauseh(A<T>&) is not callable
}
—end example]
7 [Note 2: Since, in a call context, such type deduction considers only parameters for which there are explicit call
arguments, some parameters are ignored (namely, function parameter packs, parameters with default arguments, and
ellipsis parameters).
[Example 3:
template<class T> void f(T); // #1
template<class T> void f(T*, int=1); // #2
template<class T> void g(T); // #3
template<class T> void g(T*, ...); // #4
int main() {
int* ip;
f(ip); // calls #2
g(ip); // calls #4
}
—end example]
[Example 4:
template<class T, class U> struct A { };
template<class T, class U> void f(U, A<U, T>* p = 0); // #1
template< class U> void f(U, A<U, U>* p = 0); // #2
template<class T > void g(T, T = T()); // #3
template<class T, class... U> void g(T, U ...); // #4
void h() {
f<int>(42, (A<int, int>*)0); // calls #2
f<int>(42); // error: ambiguous
g(42); // error: ambiguous
}
§ 13.7.7.3 © ISO/IEC
449

===== PAGE 461 =====

Dxxxx
—end example]
[Example 5:
template<class T, class... U> void f(T, U...); // #1
template<class T > void f(T); // #2
template<class T, class... U> void g(T*, U...); // #3
template<class T > void g(T); // #4
void h(int i) {
f(&i); // OK, calls #2
g(&i); // OK, calls #3
}
—end example]
—end note]
8 If deduction against the other template succeeds for both transformed templates, constraints can be considered
as follows:
—(8.1) If theirtemplate-parameter-lists (possibly includingtemplate-parameters invented for an abbreviated
function template (9.3.4.6)) or function parameter lists differ in length, neither template is more
specialized than the other.
—(8.2) Otherwise:
—(8.2.1) If exactly one of the templates was considered by overload resolution via a rewritten candidate
with reversed order of parameters:
—(8.2.1.1) If, for either template, some of the template parameters are not deducible from their function
parameters, neither template is more specialized than the other.
—(8.2.1.2) If there is either no reordering or more than one reordering of the associatedtemplate-parameter-
list such that
—(8.2.1.2) the correspondingtemplate-parameters of thetemplate-parameter-lists are equivalent and
—(8.2.1.2) the function parameters that positionally correspond between the two templates are of
the same type,
neither template is more specialized than the other.
—(8.2.2) Otherwise, if the correspondingtemplate-parameters of thetemplate-parameter-lists are not equiva-
lent (13.7.7.2) or if the function parameters that positionally correspond between the two templates
are not of the same type, neither template is more specialized than the other.
—(8.3) Otherwise, if the context in which the partial ordering is done is that of a call to a conversion function
and the return types of the templates are not the same, then neither template is more specialized than
the other.
—(8.4) Otherwise, if one template is more constrained than the other (13.5.5), the more constrained template
is more specialized than the other.
—(8.5) Otherwise, neither template is more specialized than the other.
[Example 6:
template <typename> constexpr bool True = true;
template <typename T> concept C = True<T>;
void f(C auto &, auto &) = delete;
template <C Q> void f(Q &, C auto &);
void g(struct A *ap, struct B *bp) {
f(*ap, *bp); // OK, can use different methods to produce template parameters
}
template <typename T, typename U> struct X {};
template <typename T, C U, typename V> bool operator==(X<T, U>, V) = delete;
template <C T, C U, C V> bool operator==(T, X<U, V>);
§ 13.7.7.3 © ISO/IEC
450

===== PAGE 462 =====

Dxxxx
void h() {
X<void *, int>{} == 0; // OK, correspondence of [T, U, V] and [U, V, T]
}
—end example]
13.7.8 Alias templates [temp.alias]
1 A template-declaration in which thedeclaration is analias-declaration (9.1) declares theidentifier to be an
alias template. An alias template is a name for a family of types. The name of the alias template is a
template-name.
2 A
—(2.1) template-id that is not the operand of areflect-expression or
—(2.2) splice-specialization-specifier
that designates the specialization of an alias template is equivalent to the associated type obtained by
substitution of itstemplate-arguments for thetemplate-parameters in thedefining-type-id of the alias template.
Any othertemplate-id that names a specialization of an alias template is atypedef-name for a type alias; such
a template-id is ill-formed if forming the associated type results in substitution failure.
[Note 1: The alias template name is not deduced from such a type (13.10.3.6).—end note]
[Example 1:
template<class T> struct Alloc { /* ... */ };
template<class T> using Vec = vector<T, Alloc<T>>;
Vec<int> v; // same asvector<int, Alloc<int>> v;
template<class T>
void process(Vec<T>& v)
{ /* ... */ }
template<class T>
void process(vector<T, Alloc<T>>& w)
{ /* ... */ } // error: redefinition
template<template<class> class TT>
void f(TT<int>);
f(v); // error: Vec not deduced
template<template<class,class> class TT>
void g(TT<int, Alloc<int>>);
g(v); // OK,TT = vector
—end example]
3 However, if thetemplate-id is dependent, subsequent template argument substitution still applies to the
template-id.
[Example 2:
template<typename...> using void_t = void;
template<typename T> void_t<typename T::foo> f();
f<int>(); // error: int does not have a nested typefoo
—end example]
4 The defining-type-id in an alias template declaration shall not refer to the alias template being declared.
The type produced by an alias template specialization shall not directly or indirectly make use of that
specialization.
[Example 3:
template <class T> struct A;
template <class T> using B = typename A<T>::U;
template <class T> struct A {
typedef B<T> U;
};
B<short> b; // error: instantiation ofB<short> uses own type viaA<short>::U
§ 13.7.8 © ISO/IEC
451

===== PAGE 463 =====

Dxxxx
—end example]
5 The type of alambda-expression appearing in an alias template declaration is different between instantiations
of that template, even when thelambda-expression is not dependent.
[Example 4:
template <class T>
using A = decltype([] { }); // A<int> and A<char> refer to different closure types
—end example]
13.7.9 Concept definitions [temp.concept]
1 A concept is a template that defines constraints on its template arguments.
concept-definition:
concept concept-name attribute-specifier-seqopt = constraint-expression ;
concept-name:
identifier
2 A concept-definition declares a concept. Itsidentifier becomes aconcept-name referring to that concept within
its scope. The optionalattribute-specifier-seq appertains to the concept.
[Example 1:
template<typename T>
concept C = requires(T x) {
{ x == x } -> std::convertible_to<bool>;
};
template<typename T>
requires C<T> // C constrains f1(T) in constraint-expression
T f1(T x) { return x; }
template<C T> // C, as atype-constraint, constrainsf2(T)
T f2(T x) { return x; }
—end example]
3 A concept-definition shall inhabit a namespace scope (6.4.6).
4 A concept shall not have associated constraints (13.5.3).
5 A concept is not instantiated (13.9).
[Note 1: A concept-id (13.3) is evaluated as an expression. A concept cannot be explicitly instantiated (13.9.3),
explicitly specialized (13.9.4), or partially specialized (13.7.6).—end note]
6 The constraint-expression of aconcept-definition is an unevaluated operand (7.2.3).
7 The first declared template parameter of a concept definition is itsprototype parameter. A type conceptis a
concept whose prototype parameter is a type template parameter.
13.8 Name resolution [temp.res]
13.8.1 General [temp.res.general]
1 A name that appears in a declarationD of a templateT is looked up from where it appears in an unspecified
declaration ofT that either isD itself or is reachable fromD and from which no other declaration ofT that
contains the usage of the name is reachable. If the name is dependent (as specified in 13.8.3), it is looked up
for each specialization (after substitution) because the lookup depends on a template parameter.
[Note 1: Some dependent names are also looked up during parsing to determine that they are dependent or to interpret
following < tokens. Uses of other names might be type-dependent or value-dependent (13.8.3.3, 13.8.3.4). Ausing-
declarator is never dependent in a specialization and is therefore replaced during lookup for that specialization (6.5).
—end note]
[Example 1:
struct A { operator int(); };
template<class B, class T>
struct D : B {
T get() { return operator T(); } // conversion-function-id is dependent
};
§ 13.8.1 © ISO/IEC
452

===== PAGE 464 =====

Dxxxx
int f(D<A, int> d) { return d.get(); } // OK, lookup findsA::operator int
—end example]
[Example 2:
void f(char);
template<class T> void g(T t) {
f(1); // f(char)
f(T(1)); // dependent
f(t); // dependent
dd++; // not dependent; error: declaration fordd not found
}
enum E { e };
void f(E);
double dd;
void h() {
g(e); // will cause one call off(char) followed by two calls off(E)
g('a'); // will cause three calls off(char)
}
—end example]
[Example 3:
struct A {
struct B { /* ... */ };
int a;
int Y;
};
int a;
template<class T> struct Y : T {
struct B { /* ... */ };
B b; // TheB defined inY
void f(int i) { a = i; } // ::a
Y* p; // Y<T>
};
Y<A> ya;
The membersA::B, A::a, andA::Y of the template argumentA do not affect the binding of names inY<A>. —end
example]
2 If the validity or meaning of the program would be changed by considering a default argument or default
template argument introduced in a declaration that is reachable from the point of instantiation of a
specialization (13.8.4.1) but is not found by lookup for the specialization, the program is ill-formed, no
diagnostic required.
typename-specifier:
typename nested-name-specifier identifier
typename nested-name-specifier templateopt simple-template-id
3 The component names of atypename-specifier are itsidentifier (if any) and those of itsnested-name-specifier
and simple-template-id (if any). A typename-specifier denotes the type or class template denoted by the
simple-type-specifier (9.2.9.3) formed by omitting the keywordtypename.
[Note 2: The usual qualified name lookup (6.5.5) applies even in the presence oftypename. —end note]
[Example 4:
struct A {
struct X { };
int X;
};
§ 13.8.1 © ISO/IEC
453

===== PAGE 465 =====

Dxxxx
struct B {
struct X { };
};
template<class T> void f(T t) {
typename T::X x;
}
void foo() {
A a;
B b;
f(b); // OK,T::X refers toB::X
f(a); // error: T::X refers to the data memberA::X not the structA::X
}
—end example]
4 A type-only contextis defined as follows: A qualified or unqualified name is said to be in a type-only context
if it is the terminal name of
—(4.1) a typename-specifier, type-requirement, nested-name-specifier, elaborated-type-specifier, class-or-decltype,
using-enum-declarator, or
—(4.2) a simple-type-specifier of afriend-type-specifier, or
—(4.3) a type-specifier of a
—(4.3.1) new-type-id,
—(4.3.2) defining-type-id,
—(4.3.3) conversion-type-id,
—(4.3.4) trailing-return-type,
—(4.3.5) default argument of atype-parameter, or
—(4.3.6) type-id of astatic_cast, const_cast, reinterpret_cast, ordynamic_cast, or
—(4.4) a decl-specifier of thedecl-specifier-seq of a
—(4.4.1) simple-declaration or function-definition in namespace scope,
—(4.4.2) member-declaration,
—(4.4.3) parameter-declaration in amember-declaration,111 unless thatparameter-declaration appears in a
default argument,
—(4.4.4) parameter-declarationin adeclarator of a function or function template declaration whosedeclarator-
id is qualified, unless thatparameter-declaration appears in a default argument,
—(4.4.5) parameter-declaration in alambda-declarator or requirement-parameter-list, unless thatparameter-
declaration appears in a default argument, or
—(4.4.6) parameter-declaration of a template-parameter (which necessarily declares a constant template
parameter).
A splice-specifier or splice-specialization-specifier (6.6) is said to be in a type-only context if a hypothetical
qualified name appearing in the same position would be in a type-only context.
[Example 5:
template<class T> T::R f(); // OK, return type of a function declaration at global scope
template<class T> void f(T::R); // ill-formed, no diagnostic required: attempt to declare
// avoid variable template
enum class Enum { A, B, C };
template<class T> struct S {
using Ptr = PtrTraits<T>::Ptr; // OK, in adefining-type-id
using Alias = [:^^int:]; // OK, in adefining-type-id
T::R f(T::P p) { // OK, class scope
return static_cast<T::R>(p); // OK,type-id of astatic_cast
}
auto g() -> S<T*>::Ptr; // OK,trailing-return-type
auto h() -> [:^^S:]<T*>; // OK,trailing-return-type
111) This includes friend function declarations.
§ 13.8.1 © ISO/IEC
454

===== PAGE 466 =====

Dxxxx
using enum [:^^Enum:]; // OK,using-enum-declarator
};
template<typename T> void f() {
void (*pf)(T::X); // variablepf of typevoid* initialized withT::X
void g(T::X); // error: T::X at block scope does not denote a type
// (attempt to declare avoid variable)
}
—end example]
5 A qualified-id whose terminal name is dependent and that is in a type-only context is considered to denote
a type. A name that refers to ausing-declarator whose terminal name is dependent is interpreted as a
typedef-name if theusing-declarator uses the keywordtypename.
[Example 6:
template <class T> void f(int i) {
T::x * i; // expression, not the declaration of a variablei
}
struct Foo {
typedef int x;
};
struct Bar {
static int const x = 5;
};
int main() {
f<Bar>(1); // OK
f<Foo>(1); // error: Foo::x is a type
}
—end example]
6 The validity of a templated entity may be checked prior to any instantiation.
[Note 3: Knowing which names are type names allows the syntax of every template to be checked in this way.—end
note]
The program is ill-formed, no diagnostic required, if
—(6.1) no valid specialization, ignoringstatic_assert-declarations that fail (9.1), can be generated for a templated
entity or a substatement of a constexpr if statement (8.5.2) within a templated entity and the innermost
enclosing template is not instantiated, or
—(6.2) no valid specialization, ignoringstatic_assert-declarations that fail, can be generated for thecompound-
statement of anexpansion-statement and there is no instantiation of it, or
—(6.3) no valid specialization, ignoringstatic_assert-declarations that fail, can be generated for a default
template-argument and the defaulttemplate-argument is not used in any instantiation, or
—(6.4) no specialization of an alias template (13.7.8) is valid and no specialization of the alias template is
named in the program, or
—(6.5) any constraint-expression in the program, introduced or otherwise, has (in its normal form) an atomic
constraint A where no satisfaction check ofA could be well-formed and no satisfaction check ofA is
performed, or
—(6.6) every valid specialization of a variadic template requires an empty template parameter pack, or
—(6.7) a hypothetical instantiation of a templated entity immediately following its definition would be ill-formed
due to a construct (other than astatic_assert-declaration that fails) that does not depend on a template
parameter, or
—(6.8) the interpretation of such a construct in the hypothetical instantiation is different from the interpretation
of the corresponding construct in any actual instantiation of the templated entity.
[Note 4: This can happen in situations including the following:
—(6.9) a type used in a non-dependent name is incomplete at the point at which a template is defined but is complete
at the point at which an instantiation is performed, or
§ 13.8.1 © ISO/IEC
455

===== PAGE 467 =====

Dxxxx
—(6.10) lookup for a name in the template definition found ausing-declaration, but the lookup in the corresponding
scope in the instantiation does not find any declarations because theusing-declaration was a pack expansion and
the corresponding pack is empty, or
—(6.11) an instantiation uses a default argument or default template argument that had not been defined at the point
at which the template was defined, or
—(6.12) constant expression evaluation (7.7) within the template instantiation uses
—(6.12.1) the value of a const object of integral or unscoped enumeration type or
—(6.12.2) the value of aconstexpr object or
—(6.12.3) the value of a reference or
—(6.12.4) the definition of a constexpr function,
and that entity was not defined when the template was defined, or
—(6.13) a class template specialization or variable template specialization that is specified by a non-dependentsimple-
template-id is used by the template, and either it is instantiated from a partial specialization that was not
defined when the template was defined or it names an explicit specialization that was not declared when the
template was defined.
—end note]
[Note 5: If a template is instantiated, errors will be diagnosed according to the other rules in this document. Exactly
when these errors are diagnosed is a quality of implementation issue.—end note]
[Example 7:
int j;
template<class T> class X {
void f(T t, int i, char* p) {
t = i; // diagnosed ifX::f is instantiated, and the assignment tot is an error
p = i; // may be diagnosed even ifX::f is not instantiated
p = j; // may be diagnosed even ifX::f is not instantiated
X<T>::g(t); // OK
X<T>::h(); // may be diagnosed even ifX::f is not instantiated
}
void g(T t) {
+; // may be diagnosed even ifX::g is not instantiated
}
};
template<class... T> struct A {
void operator++(int, T... t); // error: too many parameters
};
template<class... T> union X : T... { }; // error: union with base class
template<class... T> struct A : T..., T... { }; // error: duplicate base class
—end example]
7 [Note 6: For purposes of name lookup, default arguments andnoexcept-specifiers of function templates and default
arguments andnoexcept-specifiers of member functions of class templates are considered definitions (13.7).—end
note]
13.8.2 Locally declared names [temp.local]
1 Like normal (non-template) classes, class templates have an injected-class-name (11.1). The injected-class-
name can be used as atemplate-name or atype-name. When it is used with atemplate-argument-list, as a
template-argument for a type template template parameter, or as the final identifier in theelaborated-type-
specifier of a friend class template declaration, it is atemplate-name that refers to the class template itself.
Otherwise, it is atype-name equivalent to thetemplate-name followed by the template argument list (13.7.1,
13.4.1) of the class template enclosed in<>.
2 When the injected-class-name of a class template specialization or partial specialization is used as atype-name,
it is equivalent to thetemplate-name followed by thetemplate-arguments of the class template specialization
or partial specialization enclosed in<>.
[Example 1:
template<template<class> class T> class A { };
template<class T> class Y;
§ 13.8.2 © ISO/IEC
456

===== PAGE 468 =====

Dxxxx
template<> class Y<int> {
Y* p; // meaningY<int>
Y<char>* q; // meaningY<char>
A<Y>* a; // meaningA<::Y>
class B {
template<class> friend class Y; // meaning::Y
};
};
—end example]
3 The injected-class-name of a class template or class template specialization can be used as either atemplate-
name or atype-name wherever it is named.
[Example 2:
template <class T> struct Base {
Base* p;
};
template <class T> struct Derived: public Base<T> {
typename Derived::Base* p; // meaningDerived::Base<T>
};
template<class T, template<class> class U = T::Base> struct Third { };
Third<Derived<int> > t; // OK, default argument uses injected-class-name as a template
—end example]
4 A lookup that finds an injected-class-name (6.5.2) can result in an ambiguity in certain cases (for example, if it
is found in more than one base class). If all of the injected-class-names that are found refer to specializations
of the same class template, and if the name is used as atemplate-name, the reference refers to the class
template itself and not a specialization thereof, and is not ambiguous.
[Example 3:
template <class T> struct Base { };
template <class T> struct Derived: Base<int>, Base<char> {
typename Derived::Base b; // error: ambiguous
typename Derived::Base<double> d; // OK
};
—end example]
5 When the normal name of the template (i.e., the name from the enclosing scope, not the injected-class-name)
is used, it always refers to the class template itself and not a specialization of the template.
[Example 4:
template<class T> class X {
X* p; // meaningX<T>
X<T>* p2;
X<int>* p3;
::X* p4; // error: missing template argument list
// ::X does not refer to the injected-class-name
};
—end example]
6 The name of a template parameter shall not be bound to any following declaration whose locus is contained
by the scope to which the template parameter belongs.
[Example 5:
template<class T, int i> class Y {
int T; // error: template parameter hidden
void f() {
char T; // error: template parameter hidden
}
friend void T(); // OK, no name bound
};
§ 13.8.2 © ISO/IEC
457

===== PAGE 469 =====

Dxxxx
template<class X> class X; // error: hidden by template parameter
—end example]
7 Unqualified name lookup considers the template parameter scope of atemplate-declaration immediately after
the outermost scope associated with the template declared (even if its parent scope does not contain the
template-parameter-list).
[Note 1: The scope of a class template, including its non-dependent base classes (13.8.3.2, 6.5.2), is searched before
its template parameter scope.—end note]
[Example 6:
struct B { };
namespace N {
typedef void V;
template<class T> struct A : B {
typedef void C;
void f();
template<class U> void g(U);
};
}
template<class V> void N::A<V>::f() { // N::V not considered here
V v; // V is still the template parameter, notN::V
}
template<class B> template<class C> void N::A<B>::g(C) {
B b; // B is the base class, not the template parameter
C c; // C is the template parameter, notA’s C
}
—end example]
13.8.3 Dependent names [temp.dep]
13.8.3.1 General [temp.dep.general]
1 Inside a template, some constructs have semantics which may differ from one instantiation to another. Such
a constructdepends on the template parameters. In particular, types and expressions may depend on the
type and/or value of template parameters (as determined by the template arguments) and this determines
the context for name lookup for certain names. An expression may betype-dependent (that is, its type
may depend on a template parameter) orvalue-dependent (that is, its value when evaluated as a constant
expression (7.7) may depend on a template parameter) as described below.
2 A dependent callis an expression, possibly formed as a non-member candidate for an operator (12.2.2.3), of
the form:
postfix-expression ( expression-listopt )
where thepostfix-expression is anunqualified-id and
—(2.1) any of the expressions in theexpression-list is a pack expansion (13.7.4), or
—(2.2) any of the expressions orbraced-init-lists in theexpression-list is type-dependent (13.8.3.3), or
—(2.3) the unqualified-id is a template-id in which any of the template arguments depends on a template
parameter.
The component name of anunqualified-id (7.5.5.2) is dependent if
—(2.4) it is aconversion-function-id whose conversion-type-id is dependent, or
—(2.5) it isoperator= and the current class is a templated entity, or
—(2.6) the unqualified-id is thepostfix-expression in a dependent call.
[Note 1: Such names are looked up only at the point of the template instantiation (13.8.4.1) in both the context of
the template definition and the context of the point of instantiation (13.8.4.2).—end note]
3 [Example 1:
template<class T> struct X : B<T> {
typename T::A* pa;
§ 13.8.3.1 © ISO/IEC
458

===== PAGE 470 =====

Dxxxx
void f(B<T>* pb) {
static int i = B<T>::i;
pb->j++;
}
};
The base class nameB<T>, the type nameT::A, the namesB<T>::i and pb->j explicitly depend on thetemplate-
parameter. —end example]
13.8.3.2 Dependent types [temp.dep.type]
1 A name ortemplate-id refers to thecurrent instantiationif it is
—(1.1) in the definition of a class template, a nested class of a class template, a member of a class template, or
a member of a nested class of a class template, the injected-class-name (11.1) of the class template or
nested class,
—(1.2) in the definition of a primary class template or a member of a primary class template, the name of the
class template followed by the template argument list of itstemplate-head (13.4) enclosed in<> (or an
equivalent template alias specialization),
—(1.3) in the definition of a nested class of a class template, the name of the nested class referenced as a
member of the current instantiation,
—(1.4) in the definition of a class template partial specialization or a member of a class template partial
specialization, the name of the class template followed by a template argument list equivalent to that
of the partial specialization (13.7.6) enclosed in<> (or an equivalent template alias specialization), or
—(1.5) in the definition of a templated function, the name of a local class (11.6).
2 A template argument that is equivalent to a template parameter can be used in place of that template
parameter in a reference to the current instantiation. A template argument is equivalent to a type template
parameter if it denotes the same type. A template argument is equivalent to a constant template parameter if
it is anidentifier that names a variable that is equivalent to the template parameter. A variable is equivalent
to a template parameter if
—(2.1) it has the same type as the template parameter (ignoring cv-qualification) and
—(2.2) its initializer consists of a singleidentifier that names the template parameter or, recursively, such a
variable.
[Note 1: Using a parenthesized variable name breaks the equivalence.—end note]
[Example 1:
template <class T> class A {
A* p1; // A is the current instantiation
A<T>* p2; // A<T> is the current instantiation
A<T*> p3; // A<T*> is not the current instantiation
::A<T>* p4; // ::A<T> is the current instantiation
class B {
B* p1; // B is the current instantiation
A<T>::B* p2; // A<T>::B is the current instantiation
typename A<T*>::B* p3; // A<T*>::B is not the current instantiation
};
};
template <class T> class A<T*> {
A<T*>* p1; // A<T*> is the current instantiation
A<T>* p2; // A<T> is not the current instantiation
};
template <class T1, class T2, int I> struct B {
B<T1, T2, I>* b1; // refers to the current instantiation
B<T2, T1, I>* b2; // not the current instantiation
typedef T1 my_T1;
static const int my_I = I;
static const int my_I2 = I+0;
static const int my_I3 = my_I;
static const long my_I4 = I;
§ 13.8.3.2 © ISO/IEC
459

===== PAGE 471 =====

Dxxxx
static const int my_I5 = (I);
B<my_T1, T2, my_I>* b3; // refers to the current instantiation
B<my_T1, T2, my_I2>* b4; // not the current instantiation
B<my_T1, T2, my_I3>* b5; // refers to the current instantiation
B<my_T1, T2, my_I4>* b6; // not the current instantiation
B<my_T1, T2, my_I5>* b7; // not the current instantiation
};
—end example]
3 A dependent base classis a base class that is a dependent type and is not the current instantiation.
[Note 2: A base class can be the current instantiation in the case of a nested class naming an enclosing class as a base.
[Example 2:
template<class T> struct A {
typedef int M;
struct B {
typedef void M;
struct C;
};
};
template<class T> struct A<T>::B::C : A<T> {
M m; // OK,A<T>::M
};
—end example]
—end note]
4 A qualified (6.5.5) or unqualified name is amember of the current instantiationif
—(4.1) its lookup context, if it is a qualified name, is the current instantiation, and
—(4.2) lookup for it finds any member of a class that is the current instantiation
[Example 3:
template <class T> class A {
static const int i = 5;
int n1[i]; // i refers to a member of the current instantiation
int n2[A::i]; // A::i refers to a member of the current instantiation
int n3[A<T>::i]; // A<T>::i refers to a member of the current instantiation
int f();
};
template <class T> int A<T>::f() {
return i; // i refers to a member of the current instantiation
}
—end example]
A qualified or unqualified name names adependent member of the current instantiationif it is a member
of the current instantiation that, when looked up, refers to at least one member declaration (including a
using-declarator whose terminal name is dependent) of a class that is the current instantiation.
5 A qualified name (6.5.5) is dependent if
—(5.1) it is aconversion-function-id whose conversion-type-id is dependent, or
—(5.2) its lookup context is dependent and is not the current instantiation, or
—(5.3) its lookup context is the current instantiation and it isoperator=,112 or
—(5.4) its lookup context is the current instantiation and has at least one dependent base class, and qualified
name lookup for the name finds nothing (6.5.5).
[Example 4:
struct A {
using B = int;
112) Every instantiation of a class template declares a different set of assignment operators.
§ 13.8.3.2 © ISO/IEC
460

===== PAGE 472 =====

Dxxxx
A f();
};
struct C : A {};
template<class T>
void g(T t) {
decltype(t.A::f())::B i; // error: typename needed to interpretB as a type
}
template void g(C); // ...even though A is ::A here
—end example]
6 If, for a given set of template arguments, a specialization of a template is instantiated that refers to a member
of the current instantiation with a qualified name, the name is looked up in the template instantiation context.
If the result of this lookup differs from the result of name lookup in the template definition context, name
lookup is ambiguous.
[Example 5:
struct A {
int m;
};
struct B {
int m;
};
template<typename T>
struct C : A, T {
int f() { return this->m; } // findsA::m in the template definition context
int g() { return m; } // findsA::m in the template definition context
};
template int C<B>::f(); // error: finds bothA::m and B::m
template int C<B>::g(); // OK, transformation to class member access syntax
// does not occur in the template definition context; see 7.5.5.1
—end example]
7 An initializer is dependent if any constituent expression (6.10.1) of the initializer is type-dependent. A
placeholder type (9.2.9.7.1) is dependent if it designates a type deduced from a dependent initializer.
8 A placeholder for a deduced class type (9.2.9.8) is dependent if
—(8.1) it has a dependent initializer, or
—(8.2) it refers to an alias template that is a member of the current instantiation and whosedefining-type-id is
dependent after class template argument deduction (12.2.2.9) and substitution (13.7.8).
9 [Example 6:
template<class T, class V>
struct S { S(T); };
template<class U>
struct A {
template<class T> using X = S<T, U>;
template<class T> using Y = S<T, int>;
void f() {
new X(1); // dependent
new Y(1); // not dependent
}
};
—end example]
10 A type is dependent if it is
—(10.1) a template parameter,
—(10.2) denoted by a dependent (qualified) name,
—(10.3) a nested class or enumeration that is a direct member of a class that is the current instantiation,
§ 13.8.3.2 © ISO/IEC
461

===== PAGE 473 =====

Dxxxx
—(10.4) a cv-qualified type where the cv-unqualified type is dependent,
—(10.5) a compound type constructed from any dependent type,
—(10.6) an array type whose element type is dependent or whose bound (if any) is value-dependent,
—(10.7) a function type whose parameters include one or more function parameter packs,
—(10.8) a function type whose exception specification is value-dependent,
—(10.9) denoted by a dependent placeholder type,
—(10.10) denoted by a dependent placeholder for a deduced class type,
—(10.11) denoted by asimple-template-id in which either the template name is a template parameter or any of
the template arguments is dependent (13.8.3.7),113
—(10.12) a pack-index-specifier,
—(10.13) denoted bydecltype(expression), whereexpression is type-dependent (13.8.3.3), or
—(10.14) denoted by asplice-type-specifier in which either thesplice-specifier or splice-specialization-specifier is
dependent (13.8.3.5).
11 [Note 3: Because typedefs do not introduce new types, but instead simply refer to other types, a name that refers to
a typedef that is a member of the current instantiation is dependent only if the type referred to is dependent.—end
note]
13.8.3.3 Type-dependent expressions [temp.dep.expr]
1 Except as described below, an expression is type-dependent if any subexpression is type-dependent.
2 this is type-dependent if the current class (7.5.3) is dependent (13.8.3.2).
3 An id-expression is type-dependent if it is atemplate-id that is not a concept-id and is dependent; or if its
terminal name is
—(3.1) associated by name lookup with one or more declarations declared with a dependent type,
—(3.2) associated by name lookup with a constant template parameter declared with a type that contains a
placeholder type (9.2.9.7),
—(3.3) associated by name lookup with a variable declared with a type that contains a placeholder type (9.2.9.7)
where the initializer is type-dependent,
—(3.4) associated by name lookup with one or more declarations of member functions of a class that is the
current instantiation declared with a return type that contains a placeholder type,
—(3.5) associated by name lookup with a structured binding declaration (9.7) whosebrace-or-equal-initializer is
type-dependent,
—(3.6) associated by name lookup with a structured binding pack,
[Example 1:
struct C { };
void g(...); // #1
template <typename T>
void f() {
C arr[1];
auto [...e] = arr;
g(e...); // calls #2
}
void g(C); // #2
int main() {
f<int>();
}
—end example]
113) This includes an injected-class-name (11.1) of a class template used without atemplate-argument-list.
§ 13.8.3.3 © ISO/IEC
462

===== PAGE 474 =====

Dxxxx
—(3.7) associated by name lookup with an entity captured by copy (7.5.6.3) in alambda-expression that has an
explicit object parameter whose type is dependent (9.3.4.6),
—(3.8) the identifier __func__ (9.6.1), where any enclosing function is a template, a member of a class template,
or a generic lambda,
—(3.9) associated by name lookup with a result binding (9.4.2) of a function whose return type is dependent,
—(3.10) a conversion-function-id that specifies a dependent type,
—(3.11) a nameN introduced by thefor-range-declaration of anexpansion-statement S if the type specified for
N contains a placeholder type and either
—(3.11.1) S is not an iterating expansion statement or
—(3.11.2) the expansion-initializer of S is type-dependent, or
—(3.12) dependent
or if it names a dependent member of the current instantiation that is a static data member of type “array of
unknown bound ofT” for someT (13.7.2.5). Expressions of the following forms are type-dependent only if
the type specified by thetype-id, simple-type-specifier, typename-specifier, ornew-type-id is dependent, even if
any subexpression is type-dependent:
simple-type-specifier ( expression-listopt )
simple-type-specifier braced-init-list
typename-specifier ( expression-listopt )
typename-specifier braced-init-list
::opt new new-placementopt new-type-id new-initializeropt
::opt new new-placementopt ( type-id ) new-initializeropt
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
const_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
( type-id ) cast-expression
4 Expressions of the following forms are never type-dependent (because the type of the expression cannot be
dependent):
literal
sizeof unary-expression
sizeof ( type-id )
sizeof ... (identifier )
alignof ( type-id )
typeid ( expression )
typeid ( type-id )
::opt delete cast-expression
::opt delete [ ]cast-expression
throw assignment-expressionopt
noexcept ( expression )
requires-expression
reflect-expression
[Note 1: For the standard library macrooffsetof, see 17.2. —end note]
5 A class member access expression (7.6.1.5) is type-dependent if
—(5.1) the terminal name of itsid-expression, if any, is dependent,
—(5.2) its splice-expression, if any, is type-dependent, or
—(5.3) the expression refers to a member of the current instantiation and the type of the referenced member is
dependent.
[Note 2: In an expression of the formx.y or xp->y the type of the expression is usually the type of the membery of
the class ofx (or the class pointed to byxp). However, ifx or xp refers to a dependent type that is not the current
instantiation, the type ofy is always dependent.—end note]
6 A braced-init-list is type-dependent if any element is type-dependent or is a pack expansion.
7 A fold-expression is type-dependent.
8 A pack-index-expression is type-dependent if itsid-expression is type-dependent.
§ 13.8.3.3 © ISO/IEC
463

===== PAGE 475 =====

Dxxxx
9 A splice-expression is type-dependent if itssplice-specifier or splice-specialization-specifier is dependent (13.8.3.5).
13.8.3.4 Value-dependent expressions [temp.dep.constexpr]
1 Except as described below, an expression used in a context where a constant expression is required is
value-dependent if any subexpression is value-dependent.
2 An id-expression is value-dependent if
—(2.1) it is a concept-id and itsconcept-name is dependent or any of its arguments are dependent (13.8.3.7),
—(2.2) it is type-dependent,
—(2.3) it is the name of a constant template parameter,
—(2.4) it is a name introduced by thefor-range-declaration of anexpansion-statement (8.7),
—(2.5) it names a static data member that is a dependent member of the current instantiation and is not
initialized in amember-declarator,
—(2.6) it names a static member function that is a dependent member of the current instantiation, or
—(2.7) it names a potentially-constant variable (7.7) that is initialized with an expression that is value-
dependent.
Expressions of the following form are value-dependent if theunary-expression or expression is type-dependent
or thetype-id is dependent:
sizeof unary-expression
sizeof ( type-id )
typeid ( expression )
typeid ( type-id )
alignof ( type-id )
[Note 1: For the standard library macrooffsetof, see 17.2. —end note]
3 Expressions of the following form are value-dependent if either thetype-id, simple-type-specifier, ortypename-
specifier is dependent or theexpression or cast-expression is value-dependent or anyexpression in theexpression-
list is value-dependent or anyassignment-expression in thebraced-init-list is value-dependent:
simple-type-specifier ( expression-listopt )
typename-specifier ( expression-listopt )
simple-type-specifier braced-init-list
typename-specifier braced-init-list
static_cast < type-id > ( expression )
const_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
dynamic_cast < type-id > ( expression )
( type-id ) cast-expression
4 Expressions of the following form are value-dependent:
sizeof ... (identifier )
fold-expression
5 A noexcept-expression (7.6.2.7) is value-dependent if itsexpression involves a template parameter.
6 An expression of the form&qualified-id where thequalified-id names a dependent member of the current
instantiation is value-dependent. An expression of the form &cast-expression is also value-dependent if
evaluating cast-expression as a core constant expression (7.7) succeeds and the result of the evaluation refers
to a templated entity that is an object with static or thread storage duration or a member function.
7 A reflect-expression is value-dependent if
—(7.1) it is of the form^^reflection-name and thereflection-name
—(7.1.1) is a dependent qualified name,
—(7.1.2) is a dependentnamespace-name,
—(7.1.3) is the name of a template parameter, or
—(7.1.4) names a dependent member of the current instantiation (13.8.3.2),
—(7.2) it is of the form^^type-id and thetype-id denotes a dependent type, or
—(7.3) it is of the form^^id-expression and theid-expression is value-dependent.
§ 13.8.3.4 © ISO/IEC
464

===== PAGE 476 =====

Dxxxx
8 A splice-expression is value-dependent if its splice-specifier or splice-specialization-specifier is dependent
(13.8.3.5).
13.8.3.5 Dependent splice specifiers [temp.dep.splice]
1 A splice-specifier is dependent if its convertedconstant-expression is value-dependent. Asplice-specialization-
specifier is dependent if itssplice-specifier is dependent or if any of its template arguments are dependent. A
splice-scope-specifier is dependent if itssplice-specifier or splice-specialization-specifier is dependent.
2 [Example 1:
template<auto T, auto NS>
void fn() {
using a = [:T:]<1>; // [:T:]<1> is dependent because[:T:] is dependent
static_assert([:NS:]::template TCls<1>::v == a::v); // [:NS:] is dependent
}
namespace N {
template <auto V> struct TCls { static constexpr int v = V; };
}
int main() {
fn<^^N::TCls, ^^N>();
}
—end example]
3 [Example 2:
template<template<class> class X>
struct S {
[:^^X:]<int, float> m;
};
template<class> struct V1 {};
template<class, class = int> struct V2 {};
S<V1> s1; // error: V1<int, float> has too many template arguments
S<V2> s2; // OK
—end example]
13.8.3.6 Dependent namespaces [temp.dep.namespace]
1 A namespace alias is dependent if it is introduced by anamespace-alias-definition whose qualified-namespace-
specifier (ifany)isadependentqualifiednameorwhose splice-specifier (ifany)isdependent. A namespace-name
is dependent if it names a dependent namespace alias.
2 [Example 1:
template<std::meta::info R>
int fn() {
namespace Alias = [:R:]; // [:R:] is dependent
return typename Alias::T{}; // Alias is dependent
}
namespace NS {
using T = int;
}
int a = fn<^^NS>();
—end example]
13.8.3.7 Dependent template arguments [temp.dep.temp]
1 A typetemplate-argument is dependent if the type it specifies is dependent.
2 A constanttemplate-argument is dependent if its type is dependent or the constant expression it specifies is
value-dependent.
§ 13.8.3.7 © ISO/IEC
465

===== PAGE 477 =====

Dxxxx
3 Furthermore, a constanttemplate-argument is dependent if the corresponding constant template parameter
is of reference or pointer type and thetemplate-argument designates or points to a member of the current
instantiation or a member of a dependent type.
4 A template argument is also dependent if it is a pack expansion.
5 A template template argument is dependent if it names a template parameter or its terminal name is
dependent.
13.8.4 Dependent name resolution [temp.dep.res]
13.8.4.1 Point of instantiation [temp.point]
1 For a function template specialization, a member function template specialization, or a specialization for a
member function or static data member of a class template, if the specialization is implicitly instantiated
because it is referenced from within another template specialization and the context from which it is referenced
depends on a template parameter, the point of instantiation of the specialization is the point of instantiation
of the enclosing specialization. Otherwise, the point of instantiation for such a specialization immediately
follows the namespace scope declaration or definition that refers to the specialization.
2 If a function template or member function of a class template is called in a way which uses the definition of a
default argument of that function template or member function, the point of instantiation of the default
argument is the point of instantiation of the function template or member function specialization.
3 For anoexcept-specifier of a function template specialization or specialization of a member function of a
class template, if thenoexcept-specifier is implicitly instantiated because it is needed by another template
specialization and the context that requires it depends on a template parameter, the point of instantiation
of thenoexcept-specifier is the point of instantiation of the specialization that requires it. Otherwise, the
point of instantiation for such anoexcept-specifier immediately follows the namespace scope declaration or
definition that requires thenoexcept-specifier.
4 For a class template specialization, a class member template specialization, or a specialization for a class
member of a class template, if the specialization is implicitly instantiated because it is referenced from within
another template specialization, if the context from which the specialization is referenced depends on a
template parameter, and if the specialization is not instantiated previous to the instantiation of the enclosing
template, the point of instantiation is immediately before the point of instantiation of the enclosing template.
Otherwise, the point of instantiation for such a specialization immediately precedes the namespace scope
declaration or definition that refers to the specialization.
5 If a virtual function is implicitly instantiated, its point of instantiation is immediately following the point of
instantiation of its enclosing class template specialization.
6 An explicit instantiation definition is an instantiation point for the specialization or specializations specified
by the explicit instantiation.
7 A specialization for a function template, a member function template, or of a member function or static
data member of a class template may have multiple points of instantiations within a translation unit, and in
addition to the points of instantiation described above,
—(7.1) for any such specialization that has a point of instantiation within thedeclaration-seq of thetranslation-
unit, prior to theprivate-module-fragment (if any), the point after thedeclaration-seq of thetranslation-unit
is also considered a point of instantiation, and
—(7.2) for any such specialization that has a point of instantiation within theprivate-module-fragment, the end
of the translation unit is also considered a point of instantiation.
A specialization for a class template has at most one point of instantiation within a translation unit. A
specialization for any template may have points of instantiation in multiple translation units. If two different
points of instantiation give a template specialization different meanings according to the one-definition
rule (6.3), the program is ill-formed, no diagnostic required.
8 For the compound-statement of an expansion-statement (8.7), the point of instantiation is the point of
instantiation of its enclosing templated entity, if any. Otherwise, it immediately follows the namespace-scope
declaration or definition that contains the expansion statement.
13.8.4.2 Candidate functions [temp.dep.candidate]
1 If a dependent call (13.8.3) would be ill-formed or would find a better match had the lookup for its dependent
name considered all the function declarations with external linkage introduced in the associated namespaces
§ 13.8.4.2 © ISO/IEC
466

===== PAGE 478 =====

Dxxxx
in all translation units, not just considering those declarations found in the template definition and template
instantiation contexts (6.5.4), then the program is ill-formed, no diagnostic required.
2 [Example 1:
Source file"X.h":
namespace Q {
struct X { };
}
Source file"G.h":
namespace Q {
void g_impl(X, X);
}
Module interface unit ofM1:
module;
#include "X.h"
#include "G.h"
export module M1;
export template<typename T>
void g(T t) {
g_impl(t, Q::X{ }); // ADL in definition context findsQ::g_impl, g_impl not discarded
}
Module interface unit ofM2:
module;
#include "X.h"
export module M2;
import M1;
void h(Q::X x) {
g(x); // OK
}
—end example]
3 [Example 2:
Module interface unit ofStd:
export module Std;
export template<typename Iter>
void indirect_swap(Iter lhs, Iter rhs)
{
swap(*lhs, *rhs); // swap not found by unqualified lookup, can be found only via ADL
}
Module interface unit ofM:
export module M;
import Std;
struct S { /∗ ...∗/ };
void swap(S&, S&); // #1
void f(S* p, S* q)
{
indirect_swap(p, q); // finds #1 via ADL in instantiation context
}
—end example]
4 [Example 3:
Source file"X.h":
struct X { /∗ ... ∗/ };
X operator+(X, X);
§ 13.8.4.2 © ISO/IEC
467

===== PAGE 479 =====

Dxxxx
Module interface unit ofF:
export module F;
export template<typename T>
void f(T t) {
t + t;
}
Module interface unit ofM:
module;
#include "X.h"
export module M;
import F;
void g(X x) {
f(x); // OK, instantiatesf from F,
// operator+ is visible in instantiation context
}
—end example]
5 [Example 4:
Module interface unit ofA:
export module A;
export template<typename T>
void f(T t) {
cat(t, t); // #1
dog(t, t); // #2
}
Module interface unit ofB:
export module B;
import A;
export template<typename T, typename U>
void g(T t, U u) {
f(t);
}
Source file"foo.h", not an importable header:
struct foo {
friend int cat(foo, foo);
};
int dog(foo, foo);
Module interface unit ofC1:
module;
#include "foo.h" // dog not referenced, discarded
export module C1;
import B;
export template<typename T>
void h(T t) {
g(foo{ }, t);
}
Translation unit:
import C1;
void i() {
h(0); // error: dog not found at #2
}
Importable header"bar.h":
struct bar {
friend int cat(bar, bar);
};
int dog(bar, bar);
§ 13.8.4.2 © ISO/IEC
468

===== PAGE 480 =====

Dxxxx
Module interface unit ofC2:
module;
#include "bar.h" // imports header unit"bar.h"
export module C2;
import B;
export template<typename T>
void j(T t) {
g(bar{ }, t);
}
Translation unit:
import C2;
void k() {
j(0); // OK,dog found in instantiation context:
// visible at end of module interface unit ofC2
}
—end example]
13.9 Template instantiation and specialization [temp.spec]
13.9.1 General [temp.spec.general]
1 The act of instantiating a function, a variable, a class, a member of a class template, or a member template
is referred to astemplate instantiation.
2 A function instantiated from a function template is called an instantiated function. A class instantiated from
a class template is called an instantiated class. A member function, a member class, a member enumeration,
or a static data member of a class template instantiated from the member definition of the class template is
called, respectively, an instantiated member function, member class, member enumeration, or static data
member. A member function instantiated from a member function template is called an instantiated member
function. A member class instantiated from a member class template is called an instantiated member class.
A variable instantiated from a variable template is called an instantiated variable. A static data member
instantiated from a static data member template is called an instantiated static data member.
3 An explicit specialization may be declared for a function template, a variable template, a class template, a
member of a class template, or a member template. An explicit specialization declaration is introduced by
template<>. In an explicit specialization declaration for a variable template, a class template, a member
of a class template, or a class member template, the variable or class that is explicitly specialized shall be
specified with asimple-template-id. In the explicit specialization declaration for a function template, the
function explicitly specialized may be specified using atemplate-id.
[Example 1:
template<class T = int> struct A {
static int x;
};
template<class U> void g(U) { }
template<> struct A<double> { }; // specialize forT == double
template<> struct A<> { }; // specialize forT == int
template<> void g(char) { } // specialize forU == char
// U is deduced from the parameter type
template<> void g<int>(int) { } // specialize forU == int
template<> int A<char>::x = 0; // specialize forT == char
template<class T = int> struct B {
static int x;
};
template<> int B<>::x = 1; // specialize forT == int
—end example]
4 An instantiated template specialization can be either implicitly instantiated (13.9.2) for a given argument list
or be explicitly instantiated (13.9.3). Aspecialization is a class, variable, function, or class member that is
either instantiated (13.9.2) from a templated entity or is an explicit specialization (13.9.4) of a templated
entity.
§ 13.9.1 © ISO/IEC
469

===== PAGE 481 =====

Dxxxx
5 For a given template and a given set oftemplate-arguments,
—(5.1) an explicit instantiation definition shall appear at most once in a program,
—(5.2) an explicit specialization shall be defined at most once in a program, as specified in 6.3, and
—(5.3) both an explicit instantiation and a declaration of an explicit specialization shall not appear in a
program unless the explicit specialization is reachable from the explicit instantiation.
An implementation is not required to diagnose a violation of this rule if neither declaration is reachable from
the other.
6 The usual access checking rules do not apply to names in a declaration of an explicit instantiation or explicit
specialization, with the exception of names appearing in a function body, default argument,base-clause,
member-specification, enumerator-list, or static data member or variable template initializer.
[Note 1: In particular, the template arguments and names used in the function declarator (including parameter types,
return types and exception specifications) can be private types or objects that would normally not be accessible.
—end note]
7 Each class template specialization instantiated from a template has its own copy of any static members.
[Example 2:
template<class T> class X {
static T s;
};
template<class T> T X<T>::s = 0;
X<int> aa;
X<char*> bb;
X<int> has a static members of typeint and X<char*> has a static members of typechar*. —end example]
8 If a function declaration acquired its function type through a dependent type (13.8.3.2) without using the
syntactic form of a function declarator, the program is ill-formed.
[Example 3:
template<class T> struct A {
static T t;
};
typedef int function();
A<function> a; // error: would declareA<function>::t as a static member function
—end example]
13.9.2 Implicit instantiation [temp.inst]
1 A template specializationE is adeclared specializationif there is a reachable explicit instantiation definition
(13.9.3) or explicit specialization declaration (13.9.4) forE, or if there is a reachable explicit instantiation
declaration forE and E is not
—(1.1) an inline function,
—(1.2) declared with a type deduced from its initializer or return value (9.2.9.7),
—(1.3) a potentially-constant variable (7.7), or
—(1.4) a specialization of a templated class.
[Note 1: An implicit instantiation in an importing translation unit cannot use names with internal linkage from an
imported translation unit (6.7).—end note]
2 Unless a class template specialization is a declared specialization, the class template specialization is implicitly
instantiated when the specialization is referenced in a context that requires a completely-defined object type
or when the completeness of the class type affects the semantics of the program.
[Note 2: In particular, if the semantics of an expression depend on the member or base class lists of a class template
specialization, the class template specialization is implicitly generated. For instance, deleting a pointer to class type
depends on whether or not the class declares a destructor, and a conversion between pointers to class type depends on
the inheritance relationship between the two classes involved.—end note]
[Example 1:
template<class T> class B { /* ... */ };
template<class T> class D : public B<T> { /* ... */ };
§ 13.9.2 © ISO/IEC
470

===== PAGE 482 =====

Dxxxx
void f(void*);
void f(B<int>*);
void g(D<int>* p, D<char>* pp, D<double>* ppp) {
f(p); // instantiation ofD<int> required: callf(B<int>*)
B<char>* q = pp; // instantiation ofD<char> required: convertD<char>* to B<char>*
delete ppp; // instantiation ofD<double> required
}
—end example]
If the template selected for the specialization (13.7.6.2) has been declared, but not defined, at the point of
instantiation (13.8.4.1), the instantiation yields an incomplete class type (6.9.1).
[Example 2:
template<class T> class X;
X<char> ch; // error: incomplete typeX<char>
—end example]
[Note 3: Within a template declaration, a local class (11.6) or enumeration and the members of a local class are never
considered to be entities that can be separately instantiated (this includes their default arguments,noexcept-specifiers,
and non-static data member initializers, if any, but not theirtype-constraints orrequires-clauses). As a result, the
dependent names are looked up, the semantic constraints are checked, and any templates used are instantiated as part
of the instantiation of the entity within which the local class or enumeration is declared.—end note]
3 The implicit instantiation of a class template specialization causes
—(3.1) the implicit instantiation of the declarations, but not of the definitions, of the non-deleted class member
functions, member classes, scoped member enumerations, static data members, member templates, and
friends; and
—(3.2) the implicit instantiation of the definitions of deleted member functions, unscoped member enumerations,
and member anonymous unions.
The implicit instantiation of a class template specialization does not cause the implicit instantiation of default
arguments ornoexcept-specifiers of the class member functions.
[Example 3:
template<class T>
struct C {
void f() { T x; }
void g() = delete;
};
C<void> c; // OK, definition ofC<void>::f is not instantiated at this point
template<> void C<int>::g() { } // error: redefinition ofC<int>::g
—end example]
However, for the purpose of determining whether an instantiated redeclaration is valid according to 6.3
and 11.4, an instantiated declaration that corresponds to a definition in the template is considered to be a
definition.
[Example 4:
template<class T, class U>
struct Outer {
template<class X, class Y> struct Inner;
template<class Y> struct Inner<T, Y>; // #1a
template<class Y> struct Inner<T, Y> { }; // #1b; OK, valid redeclaration of #1a
template<class Y> struct Inner<U, Y> { }; // #2
};
Outer<int, int> outer; // error at #2
Outer<int, int>::Inner<int, Y> is redeclared at #1b. (It is not defined but noted as being associated with a
definition inOuter<T, U>.) #2 is also a redeclaration of #1a. It is noted as associated with a definition, so it is an
invalid redeclaration of the same partial specialization.
template<typename T> struct Friendly {
template<typename U> friend int f(U) { return sizeof(T); }
};
§ 13.9.2 © ISO/IEC
471

===== PAGE 483 =====

Dxxxx
Friendly<char> fc;
Friendly<float> ff; // error: produces second definition off(U)
—end example]
4 Unless a member of a templated class is a declared specialization, the specialization of the member is implicitly
instantiated when the specialization is referenced in a context that requires the member definition to exist
or if the existence of the definition of the member affects the semantics of the program; in particular, the
initialization (and any associated side effects) of a static data member does not occur unless the static data
member is itself used in a way that requires the definition of the static data member to exist.
5 Unless a function template specialization is a declared specialization, the function template specialization is
implicitly instantiated when the specialization is referenced in a context that requires a function definition to
exist or if the existence of the definition affects the semantics of the program. A function whose declaration
was instantiated from a friend function definition is implicitly instantiated when it is referenced in a context
that requires a function definition to exist or if the existence of the definition affects the semantics of the
program. Unless a call is to a function template explicit specialization or to a member function of an
explicitly specialized class template, a default argument for a function template or a member function of a
class template is implicitly instantiated when the function is called in a context that requires the value of the
default argument.
[Note 4: An inline function that is the subject of an explicit instantiation declaration is not a declared specialization;
the intent is that it still be implicitly instantiated when odr-used (6.3) so that the body can be considered for inlining,
but that no out-of-line copy of it be generated in the translation unit.—end note]
6 [Example 5:
template<class T> struct Z {
void f();
void g();
};
void h() {
Z<int> a; // instantiation of classZ<int> required
Z<char>* p; // instantiation of classZ<char> not required
Z<double>* q; // instantiation of classZ<double> not required
a.f(); // instantiation ofZ<int>::f() required
p->g(); // instantiation of classZ<char> required, and
// instantiation ofZ<char>::g() required
}
Nothing in this example requiresclass Z<double>, Z<int>::g(), or Z<char>::f() to be implicitly instantiated.
—end example]
7 Unless a variable template specialization is a declared specialization, the variable template specialization is
implicitly instantiated when it is referenced in a context that requires a variable definition to exist or if the
existence of the definition affects the semantics of the program. A default template argument for a variable
template is implicitly instantiated when the variable template is referenced in a context that requires the
value of the default argument.
8 The existence of a definition of a variable or function is considered to affect the semantics of the program if
the variable or function is needed for constant evaluation by an expression (7.7), even if constant evaluation
of the expression is not required or if constant expression evaluation does not use the definition.
[Example 6:
template<typename T> constexpr int f() { return T::value; }
template<bool B, typename T> void g(decltype(B ? f<T>() : 0));
template<bool B, typename T> void g(...);
template<bool B, typename T> void h(decltype(int{B ? f<T>() : 0}));
template<bool B, typename T> void h(...);
void x() {
g<false, int>(0); // OK,B ? f<T>() : 0 is not potentially constant evaluated
h<false, int>(0); // error, instantiatesf<int> even though B evaluates tofalse and
// list-initialization ofint from int cannot be narrowing
}
—end example]
§ 13.9.2 © ISO/IEC
472

===== PAGE 484 =====

Dxxxx
9 If the function selected by overload resolution (12.2) can be determined without instantiating a class template
definition, it is unspecified whether that instantiation actually takes place.
[Example 7:
template <class T> struct S {
operator int();
};
void f(int);
void f(S<int>&);
void f(S<float>);
void g(S<int>& sr) {
f(sr); // instantiation ofS<int> allowed but not required
// instantiation ofS<float> allowed but not required
};
—end example]
10 If a function template specialization is used in a way that involves overload resolution, a declaration of the
specialization is implicitly instantiated (13.10.4).
11 An implementation shall not implicitly instantiate a function template, a variable template, a member
template, a non-virtual member function, a member class or static data member of a templated class, or a
substatement of a constexpr if statement (8.5.2), unless such instantiation is required.
[Note 5: The instantiation of a generic lambda does not require instantiation of substatements of a constexpr if
statement within itscompound-statement unless the call operator template is instantiated.—end note]
It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a
class template if the virtual member function would not otherwise be instantiated. The use of a template
specialization in a default argument or default member initializer shall not cause the template to be implicitly
instantiated except where needed to determine the correctness of the default argument or default member
initializer. The use of a default argument in a function call causes specializations in the default argument to
be implicitly instantiated. Similarly, the use of a default member initializer in a constructor definition or an
aggregate initialization causes specializations in the default member initializer to be instantiated.
12 If a templated functionf is called in a way that requires a default argument to be used, the dependent names
are looked up, the semantics constraints are checked, and the instantiation of any template used in the default
argument is done as if the default argument had been an initializer used in a function template specialization
with the same scope, the same template parameters and the same access as that of the function templatef
used at that point, except that the scope in which a closure type is declared (7.5.6.2) — and therefore its
associated namespaces — remain as determined from the context of the definition for the default argument.
This analysis is calleddefault argument instantiation. The instantiated default argument is then used as the
argument off.
13 Each default argument is instantiated independently.
[Example 8:
template<class T> void f(T x, T y = ydef(T()), T z = zdef(T()));
class A { };
A zdef(A);
void g(A a, A b, A c) {
f(a, b, c); // no default argument instantiation
f(a, b); // default argumentz = zdef(T()) instantiated
f(a); // error: ydef is not declared
}
—end example]
14 The noexcept-specifier and function-contract-specifiers of a function template specialization are not instantiated
along with the function declaration; they are instantiated when needed (14.5, 9.4.1). If such a specifier is
needed but has not yet been instantiated, the dependent names are looked up, the semantics constraints are
§ 13.9.2 © ISO/IEC
473

===== PAGE 485 =====

Dxxxx
checked, and the instantiation of any template used in the specifier is done as if it were being done as part of
instantiating the declaration of the specialization at that point.
15 [Note 6: 13.8.4.1 defines the point of instantiation of a template specialization.—end note]
16 There is an implementation-defined quantity that specifies the limit on the total depth of recursive instan-
tiations (Annex B), which could involve more than one template. The result of an infinite recursion in
instantiation is undefined.
[Example 9:
template<class T> class X {
X<T>* p; // OK
X<T*> a; // implicit generation ofX<T> requires
// the implicit instantiation ofX<T*> which requires
// the implicit instantiation ofX<T**> which ...
};
—end example]
17 The type-constraints andrequires-clause of a template specialization or member function are not instantiated
along with the specialization or function itself, even for a member function of a local class; substitution
into the atomic constraints formed from them is instead performed as specified in 13.5.3 and 13.5.2.3 when
determining whether the constraints are satisfied or as specified in 13.5.3 when comparing declarations.
[Note 7: The satisfaction of constraints is determined during template argument deduction (13.10.3) and overload
resolution (12.2). —end note]
[Example 10:
template<typename T> concept C = sizeof(T) > 2;
template<typename T> concept D = C<T> && sizeof(T) > 4;
template<typename T> struct S {
S() requires C<T> { } // #1
S() requires D<T> { } // #2
};
S<char> s1; // error: no matching constructor
S<char[8]> s2; // OK, calls #2
When S<char> is instantiated, both constructors are part of the specialization. Their constraints are not satisfied, and
they suppress the implicit declaration of a default constructor forS<char> (11.4.5.2), so there is no viable constructor
for s1. —end example]
[Example 11:
template<typename T> struct S1 {
template<typename U>
requires false
struct Inner1; // ill-formed, no diagnostic required
};
template<typename T> struct S2 {
template<typename U>
requires (sizeof(T[-(int)sizeof(T)]) > 1)
struct Inner2; // ill-formed, no diagnostic required
};
The classS1<T>::Inner1 is ill-formed, no diagnostic required, because it has no valid specializations.S2 is ill-formed,
no diagnostic required, since no substitution into the constraints of itsInner2 template would result in a valid
expression. —end example]
13.9.3 Explicit instantiation [temp.explicit]
1 A class, function, variable, or member template specialization can be explicitly instantiated from its template.
A member function, member class or static data member of a class template can be explicitly instantiated
from the member definition associated with its class template.
2 The syntax for explicit instantiation is:
explicit-instantiation:
externopt template declaration
§ 13.9.3 © ISO/IEC
474

===== PAGE 486 =====

Dxxxx
There are two forms of explicit instantiation: an explicit instantiation definition and an explicit instantiation
declaration. An explicit instantiation declaration begins with theextern keyword.
3 An explicit instantiation shall not use astorage-class-specifier (9.2.2) other thanthread_local. An explicit
instantiation of a function template, member function of a class template, or variable template shall not
use theinline, constexpr, orconsteval specifiers. No attribute-specifier-seq (9.13.1) shall appertain to an
explicit instantiation.
4 If the explicit instantiation is for a class or member class, theelaborated-type-specifier in thedeclaration shall
include asimple-template-id; otherwise, thedeclaration shall be asimple-declaration whose init-declarator-list
comprises a singleinit-declarator that does not have aninitializer. If the explicit instantiation is for a variable
template specialization, theunqualified-id in thedeclarator shall be asimple-template-id.
[Example 1:
template<class T> class Array { void mf(); };
template class Array<char>;
template void Array<int>::mf();
template<class T> void sort(Array<T>& v) { /* ... */ }
template void sort(Array<char>&); // argument is deduced here (13.10.2)
namespace N {
template<class T> void f(T&) { }
}
template void N::f<int>(int&);
—end example]
5 An explicit instantiation does not introduce a name (6.4.1). A declaration of a function template, a variable
template, a member function or static data member of a class template, or a member function template of a
class or class template shall be reachable from any explicit instantiation of that entity. A definition of a class
template, a member class of a class template, or a member class template of a class or class template shall be
reachable from any explicit instantiation of that entity unless an explicit specialization of the entity with the
same template arguments is reachable therefrom. If thedeclaration of the explicit instantiation names an
implicitly-declared special member function (11.4.4), the program is ill-formed.
6 The declaration in anexplicit-instantiation and thedeclaration produced by the corresponding substitution
into the templated function, variable, or class are two declarations of the same entity.
[Note 1: These declarations need to have matching types as specified in 6.7, except as specified in 14.5.
[Example 2:
template<typename T> T var = {};
template float var<float>; // OK, instantiated variable has typefloat
template int var<int[16]>[]; // OK, absence of major array bound is permitted
template int *var<int>; // error: instantiated variable has typeint
template<typename T> auto av = T();
template int av<int>; // OK, variable with typeauto can be redeclared with typeint
template<typename T> auto f() {}
template void f<int>(); // error: function with deduced return type
// redeclared with non-deduced return type (9.2.9.7)
—end example]
—end note]
Despite its syntactic form, thedeclaration in anexplicit-instantiation for a variable is not itself a definition and
does not conflict with the definition instantiated by an explicit instantiation definition for that variable.
7 For a given set of template arguments, if an explicit instantiation of a template appears after a declaration
of an explicit specialization for that template, the explicit instantiation has no effect. Otherwise, for an
explicit instantiation definition, the definition of a function template, a variable template, a member function
template, or a member function or static data member of a class template shall be present in every translation
unit in which it is explicitly instantiated.
8 [Note 2: An explicit instantiation of a constrained template needs to satisfy that template’s associated constraints
(13.5.3). The satisfaction of constraints is determined when forming the template name of an explicit instantiation in
§ 13.9.3 © ISO/IEC
475

===== PAGE 487 =====

Dxxxx
which all template arguments are specified (13.3), or, for explicit instantiations of function templates, during template
argument deduction (13.10.3.7) when one or more trailing template arguments are left unspecified.—end note]
9 An explicit instantiation that names a class template specialization is also an explicit instantiation of the
same kind (declaration or definition) of each of its direct non-template members that has not been previously
explicitly specialized in the translation unit containing the explicit instantiation, provided that the associated
constraints, if any, of that member are satisfied by the template arguments of the explicit instantiation (13.5.3,
13.5.2), except as described below.
[Note 3: In addition, it will typically be an explicit instantiation of certain implementation-dependent data about the
class. —end note]
10 An explicit instantiation definition that names a class template specialization explicitly instantiates the class
template specialization and is an explicit instantiation definition of only those members that have been
defined at the point of instantiation.
11 An explicit instantiation of a prospective destructor (11.4.7) shall correspond to the selected destructor of
the class.
12 If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation definition
in the same translation unit, the definition shall follow the declaration. An entity that is the subject of
an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit
instantiation (13.9.2) in the translation unit shall be the subject of an explicit instantiation definition
somewhere in the program; otherwise the program is ill-formed, no diagnostic required.
[Note 4: This rule does apply to inline functions even though an explicit instantiation declaration of such an entity has
no other normative effect. This is needed to ensure that if the address of an inline function is taken in a translation
unit in which the implementation chose to suppress the out-of-line body, another translation unit will supply the
body. —end note]
An explicit instantiation declaration shall not name a specialization of a template with internal linkage.
13 An explicit instantiation does not constitute a use of a default argument, so default argument instantiation is
not done.
[Example 3:
char* p = 0;
template<class T> T g(T x = &p) { return x; }
template int g<int>(int); // OK even though&p isn’t anint.
—end example]
13.9.4 Explicit specialization [temp.expl.spec]
1 An explicit specialization of any of the following:
—(1.1) function template
—(1.2) class template
—(1.3) variable template
—(1.4) member function of a class template
—(1.5) static data member of a class template
—(1.6) member class of a class template
—(1.7) member enumeration of a class template
—(1.8) member class template of a class or class template
—(1.9) member function template of a class or class template
can be declared by a declaration introduced bytemplate<>; that is:
explicit-specialization:
template < >declaration
[Example 1:
template<class T> class stream;
template<> class stream<char> { /* ... */ }; // #1
§ 13.9.4 © ISO/IEC
476

===== PAGE 488 =====

Dxxxx
template<class T> class Array { /* ... */ };
template<class T> void sort(Array<T>& v) { /* ... */ }
template<> void sort<int>(Array<int>&); // #2
template<> void sort(Array<char*>&); // #3 template argument is deduced (13.10.2)
Given these declarations, #1 will be used as the definition of streams ofchars; other streams will be handled by
class template specializations instantiated from the class template. Similarly, #2 will be used as the sort function for
arguments of typeArray<int> and #3 will be used for arguments of typeArray<char*>; otherArray types will be
sorted by functions generated from the function template.—end example]
2 The declaration in anexplicit-specialization shall not be anexport-declaration. An explicit specialization shall
not use astorage-class-specifier (9.2.2) other thanthread_local.
3 An explicit specialization may be declared in any scope in which the corresponding primary template may be
defined (9.3.4, 11.4, 13.7.3).
4 An explicit specialization does not introduce a name (6.4.1). A declaration of a function template, class
template, or variable template being explicitly specialized shall be reachable from the declaration of the
explicit specialization.
[Note 1: A declaration, but not a definition of the template is needed.—end note]
The definition of a class or class template shall be reachable from the declaration of an explicit specialization
for a member template of the class or class template.
[Example 2:
template<> class X<int> { /* ... */ }; // error: X not a template
template<class T> class X;
template<> class X<char*> { /* ... */ }; // OK,X is a template
—end example]
5 A member function, a member function template, a member class, a member enumeration, a member class
template, a static data member, or a static data member template of a class template may be explicitly
specialized for a class specialization that is implicitly instantiated; in this case, the definition of the class
template shall be reachable from the explicit specialization for the member of the class template. If such
an explicit specialization for the member of a class template names an implicitly-declared special member
function (11.4.4), the program is ill-formed.
6 A member of an explicitly specialized class is not implicitly instantiated from the member declaration of
the class template; instead, the member of the class template specialization shall itself be explicitly defined
if its definition is required. The definition of the class template explicit specialization shall be reachable
from the definition of any member of it. The definition of an explicitly specialized class is unrelated to the
definition of a generated specialization. That is, its members need not have the same names, types, etc. as
the members of a generated specialization. Members of an explicitly specialized class template are defined in
the same manner as members of normal classes, and not using thetemplate<> syntax. The same is true
when defining a member of an explicitly specialized member class. However,template<> is used in defining
a member of an explicitly specialized member class template that is specialized as a class template.
[Example 3:
template<class T> struct A {
struct B { };
template<class U> struct C { };
};
template<> struct A<int> {
void f(int);
};
void h() {
A<int> a;
a.f(16); // A<int>::f must be defined somewhere
}
§ 13.9.4 © ISO/IEC
477

===== PAGE 489 =====

Dxxxx
// template<> not used for a member of an explicitly specialized class template
void A<int>::f(int) { /* ... */ }
template<> struct A<char>::B {
void f();
};
// template<> also not used when defining a member of an explicitly specialized member class
void A<char>::B::f() { /* ... */ }
template<> template<class U> struct A<char>::C {
void f();
};
// template<> is used when defining a member of an explicitly specialized member class template
// specialized as a class template
template<>
template<class U> void A<char>::C<U>::f() { /* ... */ }
template<> struct A<short>::B {
void f();
};
template<> void A<short>::B::f() { /* ... */ } // error: template<> not permitted
template<> template<class U> struct A<short>::C {
void f();
};
template<class U> void A<short>::C<U>::f() { /* ... */ } // error: template<> required
—end example]
7 If a template, a member template or a member of a class template is explicitly specialized, a declaration
of that specialization shall be reachable from every use of that specialization that would cause an implicit
instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. If
the program does not provide a definition for an explicit specialization and either the specialization is used in
a way that would cause an implicit instantiation to take place or the member is a virtual member function,
the program is ill-formed, no diagnostic required. An implicit instantiation is never generated for an explicit
specialization that is declared but not defined.
[Example 4:
class String { };
template<class T> class Array { /* ... */ };
template<class T> void sort(Array<T>& v) { /* ... */ }
void f(Array<String>& v) {
sort(v); // use primary templatesort(Array<T>&), T is String
}
template<> void sort<String>(Array<String>& v); // error: specialization after use of primary template
template<> void sort<>(Array<char*>& v); // OK,sort<char*> not yet used
template<class T> struct A {
enum E : T;
enum class S : T;
};
template<> enum A<int>::E : int { eint }; // OK
template<> enum class A<int>::S : int { sint }; // OK
template<class T> enum A<T>::E : T { eT };
template<class T> enum class A<T>::S : T { sT };
template<> enum A<char>::E : char { echar }; // error: A<char>::E was instantiated
// when A<char> was instantiated
template<> enum class A<char>::S : char { schar }; // OK
—end example]
8 The placement of explicit specialization declarations for function templates, class templates, variable templates,
member functions of class templates, static data members of class templates, member classes of class templates,
member enumerations of class templates, member class templates of class templates, member function
§ 13.9.4 © ISO/IEC
478

===== PAGE 490 =====

Dxxxx
templates of class templates, static data member templates of class templates, member functions of member
templates of class templates, member functions of member templates of non-template classes, static data
member templates of non-template classes, member function templates of member classes of class templates,
etc., and the placement of partial specialization declarations of class templates, variable templates, member
class templates of non-template classes, static data member templates of non-template classes, member class
templates of class templates, etc., can affect whether a program is well-formed according to the relative
positioning of the explicit specialization declarations and their points of instantiation in the translation unit
as specified above and below. When writing a specialization, be careful about its location; or to make it
compile will be such a trial as to kindle its self-immolation.
9 [Note 2: A class template explicit specialization that has been declared but not defined can be used exactly like other
incompletely-defined classes (6.9).
[Example 5:
template<class T> class X; // X is a class template
template<> class X<int>;
X<int>* p; // OK, pointer to declared classX<int>
X<int> x; // error: object of incomplete classX<int>
—end example]
—end note]
10 [Note 3: An explicit specialization of a constrained template needs to satisfy that template’s associated constraints
(13.5.3). The satisfaction of constraints is determined when forming the template name of an explicit specialization in
which all template arguments are specified (13.3), or, for explicit specializations of function templates, during template
argument deduction (13.10.3.7) when one or more trailing template arguments are left unspecified.—end note]
11 A function with the same name as a template and a type that exactly matches that of a template specialization
is not an explicit specialization (13.7.7).
12 Whether an explicit specialization of a function or variable template is inline, constexpr, constinit, or consteval
is determined by the explicit specialization and is independent of those properties of the template. Similarly,
attributes andfunction-contract-specifiers appearing in the declaration of a template have no effect on an
explicit specialization of that template.
[Example 6:
template<class T> void f(T) { /* ... */ }
template<class T> inline T g(T) { /* ... */ }
template<> inline void f<>(int) { /* ... */ } // OK, inline
template<> int g<>(int) { /* ... */ } // OK, not inline
template<typename> [[noreturn]] void h([[maybe_unused]] int i);
template<> void h<int>(int i) {
// Implementations are expected not to warn that the function returns
// but can warn about the unused parameter.
}
—end example]
13 An explicit specialization of a static data member of a template or an explicit specialization of a static data
member template is a definition if the declaration includes an initializer; otherwise, it is a declaration.
[Note 4: The definition of a static data member of a template for which default-initialization is desired can use
functional cast notation (7.6.1.4):
template<> X Q<int>::x; // declaration
template<> X Q<int>::x (); // error: declares a function
template<> X Q<int>::x = X(); // definition
—end note]
14 A member or a member template of a class template may be explicitly specialized for a given implicit
instantiation of the class template, even if the member or member template is defined in the class template
definition. An explicit specialization of a member or member template is specified using the syntax for
explicit specialization.
§ 13.9.4 © ISO/IEC
479

===== PAGE 491 =====

Dxxxx
[Example 7:
template<class T> struct A {
void f(T);
template<class X1> void g1(T, X1);
template<class X2> void g2(T, X2);
void h(T) { }
};
// specialization
template<> void A<int>::f(int);
// out of class member template definition
template<class T> template<class X1> void A<T>::g1(T, X1) { }
// member template specialization
template<> template<class X1> void A<int>::g1(int, X1);
// member template specialization
template<> template<>
void A<int>::g1(int, char); // X1 deduced aschar
template<> template<>
void A<int>::g2<char>(int, char); // X2 specified aschar
// member specialization even if defined in class definition
template<> void A<int>::h(int) { }
—end example]
15 A member or a member template may be nested within many enclosing class templates. In an explicit
specialization for such a member, the member declaration shall be preceded by atemplate<> for each
enclosing class template that is explicitly specialized.
[Example 8:
template<class T1> class A {
template<class T2> class B {
void mf();
};
};
template<> template<> class A<int>::B<double>;
template<> template<> void A<char>::B<char>::mf();
—end example]
16 In an explicit specialization declaration for a member of a class template or a member template that
appears in namespace scope, the member template and some of its enclosing class templates may remain
unspecialized, except that the declaration shall not explicitly specialize a class member template if its
enclosing class templates are not explicitly specialized as well. In such an explicit specialization declaration,
the keywordtemplate followed by atemplate-parameter-list shall be provided instead of thetemplate<>
preceding the explicit specialization declaration of the member. The types of thetemplate-parameters in the
template-parameter-list shall be the same as those specified in the primary template definition.
[Example 9:
template <class T1> class A {
template<class T2> class B {
template<class T3> void mf1(T3);
void mf2();
};
};
template <> template <class X>
class A<int>::B {
template <class T> void mf1(T);
};
template <> template <> template<class T>
void A<int>::B<double>::mf1(T t) { }
§ 13.9.4 © ISO/IEC
480

===== PAGE 492 =====

Dxxxx
template <class Y> template <>
void A<Y>::B<double>::mf2() { } // error: B<double> is specialized but
// its enclosing class templateA is not
—end example]
17 A specialization of a member function template, member class template, or static data member template of a
non-specialized class template is itself a template.
18 An explicit specialization declaration shall not be a friend declaration.
19 Default function arguments shall not be specified in a declaration or a definition for one of the following
explicit specializations:
—(19.1) the explicit specialization of a function template;
—(19.2) the explicit specialization of a member function template;
—(19.3) the explicit specialization of a member function of a class template where the class template specialization
to which the member function specialization belongs is implicitly instantiated.
[Note 5: Default function arguments can be specified in the declaration or definition of a member function of a
class template specialization that is explicitly specialized.—end note]
13.10 Function template specializations [temp.fct.spec]
13.10.1 General [temp.fct.spec.general]
1 A function instantiated from a function template is called a function template specialization; so is an explicit
specialization of a function template. Template arguments can be explicitly specified when naming the
function template specialization, deduced from the context (e.g., deduced from the function arguments in a
call to the function template specialization, see 13.10.3), or obtained from default template arguments.
2 Each function template specialization instantiated from a template has its own copy of any static variable.
[Example 1:
template<class T> void f(T* p) {
static T s;
};
void g(int a, char* b) {
f(&a); // calls f<int>(int*)
f(&b); // calls f<char*>(char**)
}
Here f<int>(int*) has a static variables of typeint and f<char*>(char**) has a static variables of typechar*.
—end example]
13.10.2 Explicit template argument specification [temp.arg.explicit]
1 Template arguments can be specified when referring to a function template specialization that is not a
specialization of a constructor template by qualifying the function template name with the list oftemplate-
arguments in the same way astemplate-arguments are specified in uses of a class template specialization.
[Example 1:
template<class T> void sort(Array<T>& v);
void f(Array<dcomplex>& cv, Array<int>& ci) {
sort<dcomplex>(cv); // sort(Array<dcomplex>&)
sort<int>(ci); // sort(Array<int>&)
}
and
template<class U, class V> U convert(V v);
void g(double d) {
int i = convert<int,double>(d); // int convert(double)
char c = convert<char,double>(d); // char convert(double)
}
—end example]
§ 13.10.2 © ISO/IEC
481

===== PAGE 493 =====

Dxxxx
2 Template arguments shall not be specified when referring to a specialization of a constructor template (11.4.5,
6.5.5.2).
3 A template argument list may be specified when referring to a specialization of a function template
—(3.1) when a function is called,
—(3.2) when the address of a function is taken, when a function initializes a reference to function, or when a
pointer to member function is formed,
—(3.3) in an explicit specialization,
—(3.4) in an explicit instantiation, or
—(3.5) in a friend declaration.
4 Trailing template arguments that can be deduced (13.10.3) or obtained from defaulttemplate-arguments may
be omitted from the list of explicittemplate-arguments.
[Note 1: A trailing template parameter pack (13.7.4) not otherwise deduced will be deduced as an empty sequence of
template arguments. —end note]
If all of the template arguments can be deduced or obtained from defaulttemplate-arguments, they may all
be omitted; in this case, the empty template argument list<> itself may also be omitted.
[Example 2:
template<class X, class Y> X f(Y);
template<class X, class Y, class ... Z> X g(Y);
void h() {
int i = f<int>(5.6); // Y deduced asdouble
int j = f(5.6); // error: X cannot be deduced
f<void>(f<int, bool>); // Y for outer f deduced asint (*)(bool)
f<void>(f<int>); // error: f<int> does not denote a single function template specialization
int k = g<int>(5.6); // Y deduced as double;Z deduced as an empty sequence
f<void>(g<int, bool>); // Y for outer f deduced asint (*)(bool),
// Z deduced as an empty sequence
}
—end example]
5 [Note 2: An empty template argument list can be used to indicate that a given use refers to a specialization of a
function template even when a non-template function (9.3.4.6) is visible that would otherwise be used. For example:
template <class T> int f(T); // #1
int f(int); // #2
int k = f(1); // uses #2
int l = f<>(1); // uses #1
—end note]
6 Template arguments that are present shall be specified in the declaration order of their corresponding
template parameters. The template argument list shall not specify moretemplate-arguments than there are
corresponding template-parameters unless one of thetemplate-parameters declares a template parameter pack.
[Example 3:
template<class X, class Y, class Z> X f(Y,Z);
template<class ... Args> void f2();
void g() {
f<int,const char*,double>("aa",3.0);
f<int,const char*>("aa",3.0); // Z deduced asdouble
f<int>("aa",3.0); // Y deduced asconst char*; Z deduced asdouble
f("aa",3.0); // error: X cannot be deduced
f2<char, short, int, long>(); // OK
}
—end example]
7 Implicit conversions (7.3) will be performed on a function argument to convert it to the type of the
corresponding function parameter if the parameter type contains no template parameters that participate in
template argument deduction.
[Note 3: Template parameters do not participate in template argument deduction if they are explicitly specified. For
example,
§ 13.10.2 © ISO/IEC
482

===== PAGE 494 =====

Dxxxx
template<class T> void f(T);
class Complex {
Complex(double);
};
void g() {
f<Complex>(1); // OK, meansf<Complex>(Complex(1))
}
—end note]
8 [Note 4: Because the explicit template argument list follows the function template name, and because constructor
templates (11.4.5) are named without using a function name (6.5.5.2), there is no way to provide an explicit template
argument list for these function templates.—end note]
9 Template argument deduction can extend the sequence of template arguments corresponding to a template
parameter pack, even when the sequence contains explicitly specified template arguments.
[Example 4:
template<class ... Types> void f(Types ... values);
void g() {
f<int*, float*>(0, 0, 0); // Types deduced as the sequenceint*, float*, int
}
—end example]
13.10.3 Template argument deduction [temp.deduct]
13.10.3.1 General [temp.deduct.general]
1 When a function template specialization is referenced, all of the template arguments shall have values.
The values can be explicitly specified or, in some cases, be deduced from the use or obtained from default
template-arguments.
[Example 1:
void f(Array<dcomplex>& cv, Array<int>& ci) {
sort(cv); // calls sort(Array<dcomplex>&)
sort(ci); // calls sort(Array<int>&)
}
and
void g(double d) {
int i = convert<int>(d); // calls convert<int,double>(double)
int c = convert<char>(d); // calls convert<char,double>(double)
}
—end example]
2 When an explicit template argument list is specified, if the giventemplate-id or splice-specialization-specifier
is not valid (13.3), type deduction fails. Otherwise, the specified template argument values are substituted
for the corresponding template parameters as specified below.
3 After this substitution is performed, the function parameter type adjustments described in 9.3.4.6 are
performed.
[Example 2: A parameter type of “void (const int, int[5])” becomes “void(*)(int,int*)”. —end example]
[Note 1: A top-level qualifier in a function parameter declaration does not affect the function type but still affects the
type of the function parameter variable within the function.—end note]
[Example 3:
template <class T> void f(T t);
template <class X> void g(const X x);
template <class Z> void h(Z, Z*);
int main() {
// #1: function type isf(int), t is non const
f<int>(1);
§ 13.10.3.1 © ISO/IEC
483

===== PAGE 495 =====

Dxxxx
// #2: function type isf(int), t is const
f<const int>(1);
// #3: function type isg(int), x is const
g<int>(1);
// #4: function type isg(int), x is const
g<const int>(1);
// #5: function type ish(int, const int*)
h<const int>(1,0);
}
—end example]
4 [Note 2: f<int>(1) and f<const int>(1) call distinct functions even though both of the functions called have the
same function type. —end note]
5 The resulting substituted and adjusted function type is used as the type of the function template for template
argument deduction. If a template argument has not been deduced and its corresponding template parameter
has a default argument, the template argument is determined by substituting the template arguments
determined for preceding template parameters into the default argument. If the substitution results in an
invalid type, as described above, type deduction fails.
[Example 4:
template <class T, class U = double>
void f(T t = 0, U u = 0);
void g() {
f(1, 'c'); // f<int,char>(1,’c’)
f(1); // f<int,double>(1,0)
f(); // error: T cannot be deduced
f<int>(); // f<int,double>(0,0)
f<int,char>(); // f<int,char>(0,0)
}
—end example]
When all template arguments have been deduced or obtained from default template arguments, all uses of
template parameters in the template parameter list of the template are replaced with the corresponding
deduced or default argument values. If the substitution results in an invalid type, as described above, type
deduction fails. If the function template has associated constraints (13.5.3), those constraints are checked for
satisfaction (13.5.2). If the constraints are not satisfied, type deduction fails. In the context of a function
call, if type deduction has not yet failed, then for those function parameters for which the function call
has arguments, each function parameter with a type that was non-dependent before substitution of any
explicitly-specified template arguments is checked against its corresponding argument; if the corresponding
argument cannot be implicitly converted to the parameter type, type deduction fails.
[Note 3: Overload resolution will check the other parameters, including parameters with dependent types in which no
template parameters participate in template argument deduction and parameters that became non-dependent due to
substitution of explicitly-specified template arguments.—end note]
If type deduction has not yet failed, then all uses of template parameters in the function type are replaced
with the corresponding deduced or default argument values. If the substitution results in an invalid type, as
described above, type deduction fails.
[Example 5:
template <class T> struct Z {
typedef typename T::x xx;
};
template <class T> concept C = requires { typename T::A; };
template <C T> typename Z<T>::xx f(void *, T); // #1
template <class T> void f(int, T); // #2
struct A {} a;
struct ZZ {
template <class T, class = typename Z<T>::xx> operator T *();
§ 13.10.3.1 © ISO/IEC
484

===== PAGE 496 =====

Dxxxx
operator int();
};
int main() {
ZZ zz;
f(1, a); // OK, deduction fails for #1 because there is no conversion fromint to void*
f(zz, 42); // OK, deduction fails for #1 becauseC<int> is not satisfied
}
—end example]
6 At certain points in the template argument deduction process it is necessary to take a function type
that makes use of template parameters and replace those template parameters with the corresponding
template arguments. This is done at the beginning of template argument deduction when any explicitly
specified template arguments are substituted into the function type, and again at the end of template
argument deduction when any template arguments that were deduced or obtained from default arguments
are substituted.
7 The deduction substitution lociare
—(7.1) the function type outside of thenoexcept-specifier,
—(7.2) the explicit-specifier,
—(7.3) the template parameter declarations, and
—(7.4) the template argument list of a partial specialization (13.7.6.1).
The substitution occurs in all types and expressions that are used in the deduction substitution loci. The
expressions include not only constant expressions such as those that appear in array bounds or as constant
template arguments but also general expressions (i.e., non-constant expressions) insidesizeof, decltype,
and other contexts that allow non-constant expressions. The substitution proceeds in lexical order and stops
when a condition that causes deduction to fail is encountered. If substitution into different declarations of
the same function template would cause template instantiations to occur in a different order or not at all,
the program is ill-formed; no diagnostic required.
[Note 4: The equivalent substitution in exception specifications (14.5) and function contract assertions (9.4.1) is done
only when thenoexcept-specifier or function-contract-specifier, respectively, is instantiated, at which point a program
is ill-formed if the substitution results in an invalid type or expression.—end note]
[Example 6:
template <class T> struct A { using X = typename T::X; };
template <class T> typename T::X f(typename A<T>::X);
template <class T> void f(...) { }
template <class T> auto g(typename A<T>::X) -> typename T::X;
template <class T> void g(...) { }
template <class T> typename T::X h(typename A<T>::X);
template <class T> auto h(typename A<T>::X) -> typename T::X; // redeclaration
template <class T> void h(...) { }
void x() {
f<int>(0); // OK, substituting return type causes deduction to fail
g<int>(0); // error, substituting parameter type instantiatesA<int>
h<int>(0); // ill-formed, no diagnostic required
}
—end example]
8 If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is
one that would be ill-formed, with a diagnostic required, if written in the same context using the substituted
arguments.
[Note 5: If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution
process. —end note]
Invalid types and expressions can result in a deduction failure only in the immediate context of the deduction
substitution loci.
[Note 6: The substitution into types and expressions can result in effects such as the instantiation of class template
specializations and/or function template specializations, the generation of implicitly-defined functions, etc. Such
effects are not in the “immediate context” and can result in the program being ill-formed.—end note]
§ 13.10.3.1 © ISO/IEC
485

===== PAGE 497 =====

Dxxxx
9 When substituting into alambda-expression, substitution into its body is not in the immediate context.
[Note 7: The intent is to avoid requiring implementations to deal with substitution failure involving arbitrary
statements.
[Example 7:
template <class T>
auto f(T) -> decltype([]() { T::invalid; } ());
void f(...);
f(0); // error: invalid expression not part of the immediate context
template <class T, std::size_t = sizeof([]() { T::invalid; })>
void g(T);
void g(...);
g(0); // error: invalid expression not part of the immediate context
template <class T>
auto h(T) -> decltype([x = T::invalid]() { });
void h(...);
h(0); // OK, callsh(...)
template <class T>
auto i(T) -> decltype([]() -> typename T::invalid { });
void i(...);
i(0); // OK, callsi(...)
template <class T>
auto j(T t) -> decltype([](auto x) -> decltype(x.invalid) { } (t));
void j(...);
j(0); // OK, callsj(...)
—end example]
—end note]
10 [Example 8:
struct X { };
struct Y {
Y(X) {}
};
template <class T> auto f(T t1, T t2) -> decltype(t1 + t2); // #1
X f(Y, Y); // #2
X x1, x2;
X x3 = f(x1, x2); // deduction fails on #1 (cannot addX+X), calls #2
—end example]
11 [Note 8: Type deduction can fail for the following reasons:
—(11.1) Attempting to instantiate a pack expansion containing multiple packs of differing lengths.
—(11.2) Attempting to create an array with an element type that isvoid, a function type, or a reference type, or
attempting to create an array with a size that is zero or negative.
[Example 9:
template <class T> int f(T[5]);
int I = f<int>(0);
int j = f<void>(0); // invalid array
—end example]
—(11.3) Attempting to use a type that is not a class or enumeration type in a qualified name.
[Example 10:
template <class T> int f(typename T::B*);
int i = f<int>(0);
—end example]
§ 13.10.3.1 © ISO/IEC
486

===== PAGE 498 =====

Dxxxx
—(11.4) Attempting to use a type in anested-name-specifier of aqualified-id when that type does not contain the specified
member, or
—(11.4.1) the specified member is not a type where a type is required, or
—(11.4.2) the specified member is not a template where a template is required, or
—(11.4.3) the specified member is not a non-type, non-template where a non-type, non-template is required.
[Example 11:
template <int I> struct X { };
template <template <class T> class> struct Z { };
template <class T> void f(typename T::Y*) {}
template <class T> void g(X<T::N>*) {}
template <class T> void h(Z<T::TT>*) {}
struct A {};
struct B { int Y; };
struct C {
typedef int N;
};
struct D {
typedef int TT;
};
int main() {
// Deduction fails in each of these cases:
f<A>(0); // A does not contain a memberY
f<B>(0); // TheY member of B is not a type
g<C>(0); // TheN member of C is not a non-type, non-template name
h<D>(0); // TheTT member of D is not a template
}
—end example]
—(11.5) Attempting to create a pointer to reference type.
—(11.6) Attempting to create a reference tovoid.
—(11.7) Attempting to create “pointer to member ofT” whenT is not a class type.
[Example 12:
template <class T> int f(int T::*);
int i = f<int>(0);
—end example]
—(11.8) Attempting to give an invalid type to a constant template parameter.
[Example 13:
template <class T, T> struct S {};
template <class T> int f(S<T, T{}>*); // #1
class X {
int m;
};
int i0 = f<X>(0); // #1 uses a value of non-structural typeX as a constant template argument
—end example]
—(11.9) Attempting to perform an invalid conversion in either a template argument expression, or an expression used in
the function declaration.
[Example 14:
template <class T, T*> int f(int);
int i2 = f<int,1>(0); // can’t convert1 to int*
—end example]
—(11.10) Attempting to create a function type in which a parameter has a type ofvoid, or in which the return type is a
function type or array type.
—(11.11) Attempting to give to an explicit object parameter of a lambda’s function call operator a type not permitted
for such (7.5.6.2).
—end note]
§ 13.10.3.1 © ISO/IEC
487

===== PAGE 499 =====

Dxxxx
12 [Example 15: In the following example, assuming asigned char cannot represent the value 1000, a narrowing
conversion(9.5.5)wouldberequiredtoconvertthe template-argument oftype int tosigned char, thereforesubstitution
fails for the second template (13.4.3).
template <int> int f(int);
template <signed char> int f(int);
int i1 = f<1000>(0); // OK
int i2 = f<1>(0); // ambiguous; not narrowing
—end example]
13.10.3.2 Deducing template arguments from a function call [temp.deduct.call]
1 Template argument deduction is done by comparing each function template parameter type (call itP)
that contains template parameters that participate in template argument deduction with the type of the
corresponding argument of the call (call itA) as described below. If removing references and cv-qualifiers from
P gives std::initializer_list<P′> or P′[N] for someP′and N and the argument is a non-empty initializer
list (9.5.5), then deduction is performed instead for each element of the initializer list independently, taking
P′ as separate function template parameter typesP′
i and the ith initializer element as the corresponding
argument. In the P′[N] case, if N is a constant template parameter,N is deduced from the length of the
initializer list. Otherwise, an initializer list argument causes the parameter to be considered a non-deduced
context (13.10.3.6).
[Example 1:
template<class T> void f(std::initializer_list<T>);
f({1,2,3}); // T deduced asint
f({1,"asdf"}); // error: T deduced as bothint and const char*
template<class T> void g(T);
g({1,2,3}); // error: no argument deduced forT
template<class T, int N> void h(T const(&)[N]);
h({1,2,3}); // T deduced asint; N deduced as3
template<class T> void j(T const(&)[3]);
j({42}); // T deduced asint; array bound not considered
struct Aggr { int i; int j; };
template<int N> void k(Aggr const(&)[N]);
k({1,2,3}); // error: deduction fails, no conversion fromint to Aggr
k({{1},{2},{3}}); // OK,N deduced as3
template<int M, int N> void m(int const(&)[M][N]);
m({{1,2},{3,4}}); // M and N both deduced as2
template<class T, int N> void n(T const(&)[N], T);
n({{1},{2},{3}},Aggr()); // OK,T is Aggr, N is 3
template<typename T, int N> void o(T (* const (&)[N])(T)) { }
int f1(int);
int f4(int);
char f4(char);
o({ &f1, &f4 }); // OK,T deduced asint from first element, nothing
// deduced from second element,N deduced as2
o({ &f1, static_cast<char(*)(char)>(&f4) }); // error: conflicting deductions forT
—end example]
For a function parameter pack that occurs at the end of theparameter-declaration-list, deduction is performed
for each remaining argument of the call, taking the typeP of thedeclarator-id of the function parameter pack
as the corresponding function template parameter type. Each deduction deduces template arguments for
subsequent positions in the template parameter packs expanded by the function parameter pack. When a
function parameter pack appears in a non-deduced context (13.10.3.6), the type of that pack is never deduced.
[Example 2:
template<class ... Types> void f(Types& ...);
§ 13.10.3.2 © ISO/IEC
488

===== PAGE 500 =====

Dxxxx
template<class T1, class ... Types> void g(T1, Types ...);
template<class T1, class ... Types> void g1(Types ..., T1);
void h(int x, float& y) {
const int z = x;
f(x, y, z); // Types deduced asint, float, const int
g(x, y, z); // T1 deduced asint; Types deduced asfloat, int
g1(x, y, z); // error: Types is not deduced
g1<int, int, int>(x, y, z); // OK, no deduction occurs
}
—end example]
2 If P is not a reference type:
—(2.1) If A is an array type, the pointer type produced by the array-to-pointer standard conversion (7.3.3) is
used in place ofA for type deduction; otherwise,
—(2.2) If A is a function type, the pointer type produced by the function-to-pointer standard conversion (7.3.4)
is used in place ofA for type deduction; otherwise,
—(2.3) If A is a cv-qualified type, the top-level cv-qualifiers ofA’s type are ignored for type deduction.
3 If P is a cv-qualified type, the top-level cv-qualifiers ofP’s type are ignored for type deduction. IfP is a
reference type, the type referred to byP is used for type deduction.
[Example 3:
template<class T> int f(const T&);
int n1 = f(5); // calls f<int>(const int&)
const int i = 0;
int n2 = f(i); // calls f<int>(const int&)
template <class T> int g(volatile T&);
int n3 = g(i); // calls g<const int>(const volatile int&)
—end example]
A forwarding referenceis an rvalue reference to a cv-unqualified template parameter that does not represent
a template parameter of a class template (during class template argument deduction (12.2.2.9)). IfP is a
forwarding reference and the argument is an lvalue, the type “lvalue reference toA” is used in place ofA for
type deduction.
[Example 4:
template <class T> int f(T&& heisenreference);
template <class T> int g(const T&&);
int i;
int n1 = f(i); // calls f<int&>(int&)
int n2 = f(0); // calls f<int>(int&&)
int n3 = g(i); // error: would callg<int>(const int&&), which
// would bind an rvalue reference to an lvalue
template <class T> struct A {
template <class U>
A(T&&, U&&, int*); // #1: T&& is not a forwarding reference.
// U&& is a forwarding reference.
A(T&&, int*); // #2
};
template <class T> A(T&&, int*) -> A<T>; // #3: T&& is a forwarding reference.
int *ip;
A a{i, 0, ip}; // error: cannot deduce from #1
A a0{0, 0, ip}; // uses #1 to deduceA<int> and #1 to initialize
A a2{i, ip}; // uses #3 to deduceA<int&> and #2 to initialize
—end example]
4 In general, the deduction process attempts to find template argument values that will make the deducedA
identical toA (after the typeA is transformed as described above). However, there are three cases that allow
a difference:
§ 13.10.3.2 © ISO/IEC
489

===== PAGE 501 =====

Dxxxx
—(4.1) If the originalP is a reference type, the deducedA (i.e., the type referred to by the reference) can be
more cv-qualified than the transformedA.
—(4.2) The transformedA can be another pointer or pointer-to-member type that can be converted to the
deduced A via a function pointer conversion (7.3.14) and/or qualification conversion (7.3.6).
—(4.3) If P is a class andP has the formsimple-template-id or typenameopt splice-specialization-specifier, then
the transformedA can be a derived classD of the deducedA. Likewise, ifP is a pointer to a class of the
form simple-template-id or typenameopt splice-specialization-specifier, the transformedA can be a pointer
to a derived classD of the class pointed to by the deducedA. However, if there is a classC that is a
(direct or indirect) base class ofD and derived (directly or indirectly) from a classB and that would be
a valid deducedA, the deducedA cannot beB or pointer toB, respectively.
[Example 5:
template <typename... T> struct X;
template <> struct X<> {};
template <typename T, typename... Ts>
struct X<T, Ts...> : X<Ts...> {};
struct D : X<int> {};
struct E : X<>, X<int> {};
template <typename... T>
int f(const X<T...>&);
int x = f(D()); // calls f<int>, not f<>
// B is X<>, C is X<int>
int z = f(E()); // calls f<int>, not f<>
—end example]
5 These alternatives are considered only if type deduction would otherwise fail. If they yield more than one
possible deducedA, the type deduction fails.
[Note 1: If a template parameter is not used in any of the function parameters of a function template, or is used
only in a non-deduced context, its correspondingtemplate-argument cannot be deduced from a function call and the
template-argument must be explicitly specified.—end note]
6 When P is a function type, function pointer type, or pointer-to-member-function type:
—(6.1) If the argument is an overload set containing one or more function templates, the parameter is treated
as a non-deduced context.
—(6.2) If the argument is an overload set (not containing function templates), trial argument deduction is
attempted using each of the members of the set whose associated constraints (13.5.2) are satisfied. If
all successful deductions yield the same deducedA, that deducedA is the result of deduction; otherwise,
the parameter is treated as a non-deduced context.
7 [Example 6:
// Only one function of an overload set matches the call so the function parameter is a deduced context.
template <class T> int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g); // calls f(int (*)(int))
—end example]
8 [Example 7:
// Ambiguous deduction causes the second function parameter to be a non-deduced context.
template <class T> int f(T, T (*p)(T));
int g(int);
char g(char);
int i = f(1, g); // calls f(int, int (*)(int))
—end example]
9 [Example 8:
// The overload set contains a template, causing the second function parameter to be a non-deduced context.
template <class T> int f(T, T (*p)(T));
char g(char);
template <class T> T g(T);
§ 13.10.3.2 © ISO/IEC
490

===== PAGE 502 =====

Dxxxx
int i = f(1, g); // calls f(int, int (*)(int))
—end example]
10 [Example 9:
// All arguments for placeholder type deduction (9.2.9.7.2) yield the same deduced type.
template<bool B> struct X {
static void f(short) requires B; // #1
static void f(short); // #2
};
void test() {
auto x = &X<true>::f; // OK, deducesvoid(*)(short), selects #1
auto y = &X<false>::f; // OK, deducesvoid(*)(short), selects #2
}
—end example]
13.10.3.3 Deducing template arguments taking the address of a function template
[temp.deduct.funcaddr]
1 Template arguments can be deduced from the type specified when taking the address of an overload set (12.3).
If there is a target, the function template’s function type and the target type are used as the types ofP and
A, and the deduction is done as described in 13.10.3.6. Otherwise, deduction is performed with empty sets of
types P and A.
2 A placeholder type (9.2.9.7) in the return type of a function template is a non-deduced context. If template
argument deduction succeeds for such a function, the return type is determined from instantiation of the
function body.
13.10.3.4 Deducing conversion function template arguments [temp.deduct.conv]
1 Template argument deduction is done by comparing the return type of the conversion function template (call
it P) with the type specified by theconversion-type-id of theconversion-function-id being looked up (call itA)
as described in 13.10.3.6. If theconversion-function-id is constructed during overload resolution (12.2.2), the
rules in the remainder of this subclause apply.
2 If P is a reference type, the type referred to byP is used in place ofP for type deduction and for any further
references to or transformations ofP in the remainder of this subclause.
3 If A is not a reference type:
—(3.1) If P is an array type, the pointer type produced by the array-to-pointer standard conversion (7.3.3) is
used in place ofP for type deduction; otherwise,
—(3.2) If P is a function type, the pointer type produced by the function-to-pointer standard conversion (7.3.4)
is used in place ofP for type deduction; otherwise,
—(3.3) If P is a cv-qualified type, the top-level cv-qualifiers ofP’s type are ignored for type deduction.
4 If A is a cv-qualified type, the top-level cv-qualifiers ofA’s type are ignored for type deduction. IfA is a
reference type, the type referred to byA is used for type deduction.
5 In general, the deduction process attempts to find template argument values that will make the deducedA
identical toA. However, certain attributes ofA may be ignored:
—(5.1) If the originalA is a reference type, any cv-qualifiers ofA (i.e., the type referred to by the reference).
—(5.2) If the originalA is a function pointer or pointer-to-member-function type with a potentially-throwing
exception specification (14.5), the exception specification.
—(5.3) Any cv-qualifiers inA that can be restored by a qualification conversion.
These attributes are ignored only if type deduction would otherwise fail. If ignoring them allows more than
one possible deducedA, the type deduction fails.
13.10.3.5 Deducing template arguments during partial ordering [temp.deduct.partial]
1 Template argument deduction is done by comparing certain types associated with the two function templates
being compared.
2 Two sets of types are used to determine the partial ordering. For each of the templates involved there is the
original function type and the transformed function type.
§ 13.10.3.5 © ISO/IEC
491

===== PAGE 503 =====

Dxxxx
[Note 1: The creation of the transformed type is described in 13.7.7.3.—end note]
The deduction process uses the transformed type as the argument template and the original type of the
other template as the parameter template. This process is done twice for each type involved in the partial
ordering comparison: once using the transformed template-1 as the argument template and template-2 as the
parameter template and again using the transformed template-2 as the argument template and template-1 as
the parameter template.
3 The types used to determine the ordering depend on the context in which the partial ordering is done:
—(3.1) In the context of a function call, the types used are those function parameter types for which the
function call has arguments.114
—(3.2) In the context of a call to a conversion function, the return types of the conversion function templates
are used.
—(3.3) In other contexts (13.7.7.3) the function template’s function type is used.
4 Each type nominated above from the parameter template and the corresponding type from the argument
template are used as the types ofP and A.
5 Before the partial ordering is done, certain transformations are performed on the types used for partial
ordering:
—(5.1) If P is a reference type,P is replaced by the type referred to.
—(5.2) If A is a reference type,A is replaced by the type referred to.
6 If bothP and A were reference types (before being replaced with the type referred to above), determine which
of the two types (if any) is more cv-qualified than the other; otherwise the types are considered to be equally
cv-qualified for partial ordering purposes. The result of this determination will be used below.
7 Remove any top-level cv-qualifiers:
—(7.1) If P is a cv-qualified type,P is replaced by the cv-unqualified version ofP.
—(7.2) If A is a cv-qualified type,A is replaced by the cv-unqualified version ofA.
8 Using the resulting typesP and A, the deduction is then done as described in 13.10.3.6. IfP is a function
parameter pack, the typeA of each remaining parameter type of the argument template is compared with the
type P of thedeclarator-id of the function parameter pack. Each comparison deduces template arguments for
subsequent positions in the template parameter packs expanded by the function parameter pack. Similarly,
if A was transformed from a function parameter pack, it is compared with each remaining parameter type
of the parameter template. If deduction succeeds for a given type, the type from the argument template is
considered to be at least as specialized as the type from the parameter template.
[Example 1:
template<class... Args> void f(Args... args); // #1
template<class T1, class... Args> void f(T1 a1, Args... args); // #2
template<class T1, class T2> void f(T1 a1, T2 a2); // #3
f(); // calls #1
f(1, 2, 3); // calls #2
f(1, 2); // calls #3; non-variadic template #3 is more specialized
// than the variadic templates #1 and #2
—end example]
9 If, for a given type, the types are identical after the transformations above and bothP and A were reference
types (before being replaced with the type referred to above):
—(9.1) if the type from the argument template was an lvalue reference and the type from the parameter
template was not, the parameter type is not considered to be at least as specialized as the argument
type; otherwise,
—(9.2) if the type from the argument template is more cv-qualified than the type from the parameter template
(as described above), the parameter type is not considered to be at least as specialized as the argument
type.
114) Default arguments are not considered to be arguments in this context; they only become arguments after a function has
been selected.
§ 13.10.3.5 © ISO/IEC
492

===== PAGE 504 =====

Dxxxx
10 Function templateF is at least as specialized asfunction templateG if, for each pair of types used to determine
the ordering, the type fromF is at least as specialized as the type fromG. F is more specialized thanG if F is
at least as specialized asG and G is not at least as specialized asF.
11 If, after considering the above, function templateF is at least as specialized as function templateG and
vice-versa, and if G has a trailing function parameter pack for whichF does not have a corresponding
parameter, and ifF does not have a trailing function parameter pack, thenF is more specialized thanG.
12 In most cases, deduction fails if not all template parameters have values, but for partial ordering purposes a
template parameter may remain without a value provided it is not used in the types being used for partial
ordering.
[Note 2: A template parameter used in a non-deduced context is considered used.—end note]
[Example 2:
template <class T> T f(int); // #1
template <class T, class U> T f(U); // #2
void g() {
f<int>(1); // calls #1
}
—end example]
13 [Note 3: Partial ordering of function templates containing template parameter packs is independent of the number of
deduced arguments for those template parameter packs.—end note]
[Example 3:
template<class ...> struct Tuple { };
template<class ... Types> void g(Tuple<Types ...>); // #1
template<class T1, class ... Types> void g(Tuple<T1, Types ...>); // #2
template<class T1, class ... Types> void g(Tuple<T1, Types& ...>); // #3
g(Tuple<>()); // calls #1
g(Tuple<int, float>()); // calls #2
g(Tuple<int, float&>()); // calls #3
g(Tuple<int>()); // calls #3
—end example]
13.10.3.6 Deducing template arguments from a type [temp.deduct.type]
1 Template arguments can be deduced in several different contexts, but in each case a type that is specified in
terms of template parameters (call itP) is compared with an actual type (call itA), and an attempt is made
to find template argument values (a type for a type parameter, a value for a constant template parameter, or
a template for a template template parameter) that will makeP, after substitution of the deduced values
(call it the deducedA), compatible withA.
2 In some cases, the deduction is done using a single set of typesP and A, in other cases, there will be a set
of corresponding typesP and A. Type deduction is done independently for eachP/A pair, and the deduced
template argument values are then combined. If type deduction cannot be done for anyP/A pair, or if for any
pair the deduction leads to more than one possible set of deduced values, or if different pairs yield different
deduced values, or if any template argument remains neither deduced nor explicitly specified, template
argument deduction fails. The type of a type parameter is only deduced from an array bound if it is not
otherwise deduced.
3 A given typeP can be composed from a number of other types, templates, and constant template argument
values:
—(3.1) A function type includes the types of each of the function parameters, the return type, and its exception
specification.
—(3.2) A pointer-to-member type includes the type of the class object pointed to and the type of the member
pointed to.
—(3.3) A type that is a specialization of a class template (e.g.,A<int>) includes the types, templates, and
constant template argument values referenced by the template argument list of the specialization.
—(3.4) An array type includes the array element type and the value of the array bound.
§ 13.10.3.6 © ISO/IEC
493

===== PAGE 505 =====

Dxxxx
4 In most cases, the types, templates, and constant template argument values that are used to composeP
participate in template argument deduction. That is, they may be used to determine the value of a template
argument, and template argument deduction fails if the value so determined is not consistent with the values
determined elsewhere. In certain contexts, however, the value does not participate in type deduction, but
instead uses the values of template arguments that were either deduced elsewhere or explicitly specified. If a
template parameter is used only in non-deduced contexts and is not explicitly specified, template argument
deduction fails.
[Note 1: Under 13.10.3.2, ifP contains no template parameters that appear in deduced contexts, no deduction is
done, soP and A need not have the same form.—end note]
5 The non-deduced contexts are:
—(5.1) The nested-name-specifier of a type that was specified using aqualified-id.
—(5.2) A pack-index-specifier or apack-index-expression.
—(5.3) A type-constraint.
—(5.4) The expression of adecltype-specifier.
—(5.5) The constant-expression of asplice-specifier.
—(5.6) A constant template argument or an array bound in which a subexpression references a template
parameter.
—(5.7) A template parameter used in the parameter type of a function parameter that has a default argument
that is being used in the call for which argument deduction is being done.
—(5.8) A function parameter for which the associated argument is an overload set such that one or more of
the following apply:
—(5.8.1) functions whose associated constraints are satisfied and that do not all have the same function
type match the function parameter type (resulting in an ambiguous deduction), or
—(5.8.2) no function whose associated constraints are satisfied matches the function parameter type, or
—(5.8.3) the overload set supplied as an argument contains one or more function templates.
[Note 2: A particular function from the overload set is selected (12.3) after template argument deduction has
succeeded (13.10.4). —end note]
—(5.9) A function parameter for which the associated argument is an initializer list (9.5.5) but the parameter
does not have a type for which deduction from an initializer list is specified (13.10.3.2).
[Example 1:
template<class T> void g(T);
g({1,2,3}); // error: no argument deduced forT
—end example]
—(5.10) A function parameter pack that does not occur at the end of theparameter-declaration-list.
6 When a type name is specified in a way that includes a non-deduced context, all of the types that comprise
that type name are also non-deduced. However, a compound type can include both deduced and non-deduced
types.
[Example 2: If a type is specified asA<T>::B<T2>, bothT and T2 are non-deduced. Likewise, if a type is specified
as A<I+J>::X<T>, I, J, andT are non-deduced. If a type is specified asvoid f(typename A<T>::B, A<T>), theT in
A<T>::B is non-deduced but theT in A<T> is deduced. —end example]
7 [Example 3: Here is an example in which different parameter/argument pairs produce inconsistent template argument
deductions:
template<class T> void f(T x, T y) { /* ... */ }
struct A { /* ... */ };
struct B : A { /* ... */ };
void g(A a, B b) {
f(a,b); // error: T deduced as bothA and B
f(b,a); // error: T deduced as bothA and B
f(a,a); // OK,T is A
f(b,b); // OK,T is B
}
§ 13.10.3.6 © ISO/IEC
494

===== PAGE 506 =====

Dxxxx
Here is an example where two template arguments are deduced from a single function parameter/argument pair. This
can lead to conflicts that cause type deduction to fail:
template <class T, class U> void f(T (*)(T, U, U));
int g1(int, float, float);
char g2(int, float, float);
int g3(int, char, float);
void r() {
f(g1); // OK,T is int and U is float
f(g2); // error: T deduced as bothchar and int
f(g3); // error: U deduced as bothchar and float
}
Here is an example where the exception specification of a function type is deduced:
template<bool E> void f1(void (*)() noexcept(E));
template<bool> struct A { };
template<bool B> void f2(void (*)(A<B>) noexcept(B));
void g1();
void g2() noexcept;
void g3(A<true>);
void h() {
f1(g1); // OK,E is false
f1(g2); // OK,E is true
f2(g3); // error: B deduced as bothtrue and false
}
Here is an example where a qualification conversion applies between the argument type on the function call and the
deduced template argument type:
template<class T> void f(const T*) { }
int* p;
void s() {
f(p); // f(const int*)
}
Here is an example where the template argument is used to instantiate a derived class type of the corresponding
function parameter type:
template <class T> struct B { };
template <class T> struct D : public B<T> {};
struct D2 : public B<int> {};
template <class T> void f(B<T>&) {}
void t() {
D<int> d;
D2 d2;
f(d); // calls f(B<int>&)
f(d2); // calls f(B<int>&)
}
—end example]
8 A type template argumentT, a constant template argumenti, a template template argumentTT denoting a
class template or an alias template, or a template template argumentVV denoting a variable template or a
concept can be deduced ifP and A have one of the following forms:
cv opt T
T*
T&
T&&
Topt [iopt ]
Topt (Topt ) noexcept(iopt )
Topt Topt ::*
TTopt <T>
TTopt <i>
TTopt <TT>
§ 13.10.3.6 © ISO/IEC
495

===== PAGE 507 =====

Dxxxx
TTopt <VV>
TTopt <>
where
—(8.1) Topt represents a type or parameter-type-list that either satisfies these rules recursively, is a non-deduced
context inP or A, or is the same non-dependent type inP and A,
—(8.2) iopt represents an expression that either is ani, is value-dependent inP or A, or has the same constant
value inP and A,
—(8.3) TTopt represents either a class template or a template template parameter, and
—(8.4) noexcept(iopt) represents an exception specification (14.5) in which the (possibly-implicit, see 9.3.4.6)
noexcept-specifier’s operand satisfies the rules for aniopt above.
[Note 3: If a type matches such a form but contains noTs, is, orTTs, deduction is not possible.—end note]
Similarly,<X> represents template argument lists where at least one argument contains anX, whereX is
one ofT, i, TT, orVV; and<> represents template argument lists where no argument contains aT, ani, aTT,
or aVV.
9 If P has a form that contains<T>, <i>, <TT>, or<VV>, then each argumentPi of the respective template
argument list ofP is compared with the corresponding argumentAi of the corresponding template argument
list ofA. If the template argument list ofP contains a pack expansion that is not the last template argument,
the entire template argument list is a non-deduced context. IfPi is a pack expansion, then the pattern ofPi
is compared with each remaining argument in the template argument list ofA. Each comparison deduces
template arguments for subsequent positions in the template parameter packs expanded byPi. During partial
ordering (13.10.3.5), ifAi was originally a pack expansion:
—(9.1) if P does not contain a template argument corresponding toAi then Ai is ignored;
—(9.2) otherwise, ifPi is not a pack expansion, template argument deduction fails.
[Example 4:
template<class T1, class... Z> class S; // #1
template<class T1, class... Z> class S<T1, const Z&...> { }; // #2
template<class T1, class T2> class S<T1, const T2&> { }; // #3
S<int, const int&> s; // both #2 and #3 match; #3 is more specialized
template<class T, class... U> struct A { }; // #1
template<class T1, class T2, class... U> struct A<T1, T2*, U...> { }; // #2
template<class T1, class T2> struct A<T1, T2> { }; // #3
template struct A<int, int*>; // selects #2
—end example]
10 Similarly, ifP has a form that contains(T), then each parameter typePi of the respective parameter-type-
list (9.3.4.6) ofP is compared with the corresponding parameter typeAi of the corresponding parameter-
type-list of A. If P and A are function types that originated from deduction when taking the address of a
function template (13.10.3.3) or when deducing template arguments from a function declaration (13.10.3.7)
and Pi and Ai are parameters of the top-level parameter-type-list ofP and A, respectively,Pi is adjusted if it
is a forwarding reference (13.10.3.2) andAi is an lvalue reference, in which case the type ofPi is changed to
be the template parameter type (i.e.,T&& is changed to simplyT).
[Note 4: As a result, whenPi is T&& and Ai is X&, the adjustedPi will beT, causingT to be deduced asX&. —end
note]
[Example 5:
template <class T> void f(T&&);
template <> void f(int&) { } // #1
template <> void f(int&&) { } // #2
void g(int i) {
f(i); // calls f<int&>(int&), i.e., #1
f(0); // calls f<int>(int&&), i.e., #2
}
—end example]
If theparameter-declaration corresponding toPi is a function parameter pack, then the type of itsdeclarator-id
is compared with each remaining parameter type in the parameter-type-list ofA. Each comparison deduces
§ 13.10.3.6 © ISO/IEC
496

===== PAGE 508 =====

Dxxxx
template arguments for subsequent positions in the template parameter packs expanded by the function
parameter pack. During partial ordering (13.10.3.5), ifAi was originally a function parameter pack:
—(10.1) if P does not contain a function parameter type corresponding toAi then Ai is ignored;
—(10.2) otherwise, ifPi is not a function parameter pack, template argument deduction fails.
[Example 6:
template<class T, class... U> void f(T*, U...) { } // #1
template<class T> void f(T) { } // #2
template void f(int*); // selects #1
—end example]
11 These forms can be used in the same way asT is for further composition of types.
[Example 7:
X<int> (*)(char[6])
is of the form
template-name<T> (*)(type [i])
which is a variant of
type (*)(T)
where type isX<int> and T is char[6]. —end example]
12 Template arguments cannot be deduced from function arguments involving constructs other than the ones
specified above.
13 When the value of the argument corresponding to a constant template parameterP that is declared with a
dependent type is deduced from an expression, the template parameters in the type ofP are deduced from
the type of the value.
[Example 8:
template<long n> struct A { };
template<typename T> struct C;
template<typename T, T n> struct C<A<n>> {
using Q = T;
};
using R = long;
using R = C<A<2>>::Q; // OK;T was deduced aslong from the
// template argument value in the typeA<2>
—end example]
14 The type ofN in the typeT[N] is std::size_t.
[Example 9:
template<typename T> struct S;
template<typename T, T n> struct S<int[n]> {
using Q = T;
};
using V = decltype(sizeof 0);
using V = S<int[42]>::Q; // OK;T was deduced asstd::size_t from the typeint[42]
—end example]
15 The type ofB in thenoexcept-specifier noexcept(B) of a function type isbool.
[Example 10:
template<bool> struct A { };
template<auto> struct B;
template<auto X, void (*F)() noexcept(X)> struct B<F> {
A<X> ax;
};
void f_nothrow() noexcept;
B<f_nothrow> bn; // OK, type ofX deduced asbool
§ 13.10.3.6 © ISO/IEC
497

===== PAGE 509 =====

Dxxxx
—end example]
16 [Example 11:
template<class T, T i> void f(int (&a)[i]);
int v[10];
void g() {
f(v); // OK,T is std::size_t
}
—end example]
17 [Note 5: Except for reference and pointer types, a major array bound is not part of a function parameter type and
cannot be deduced from an argument:
template<int i> void f1(int a[10][i]);
template<int i> void f2(int a[i][20]);
template<int i> void f3(int (&a)[i][20]);
void g() {
int v[10][20];
f1(v); // OK,i deduced as20
f1<20>(v); // OK
f2(v); // error: cannot deduce template-argumenti
f2<10>(v); // OK
f3(v); // OK,i deduced as10
}
—end note]
18 [Note 6: If, in the declaration of a function template with a constant template parameter, the constant template
parameter is used in a subexpression in the function parameter list, the expression is a non-deduced context as
specified above.
[Example 12:
template <int i> class A { /* ... */ };
template <int i> void g(A<i+1>);
template <int i> void f(A<i>, A<i+1>);
void k() {
A<1> a1;
A<2> a2;
g(a1); // error: deduction fails for expressioni+1
g<0>(a1); // OK
f(a1, a2); // OK
}
—end example]
—end note]
19 [Note 7: Template parameters do not participate in template argument deduction if they are used only in non-deduced
contexts. For example,
template<int i, typename T>
T deduce(typename A<T>::X x, // T is not deduced here
T t, // but T is deduced here
typename B<i>::Y y); // i is not deduced here
A<int> a;
B<77> b;
int x = deduce<77>(a.xm, 62, b.ym);
// T deduced asint; a.xm must be convertible toA<int>::X
// i is explicitly specified to be77; b.ym must be convertible toB<77>::Y
—end note]
20 If P has a form that contains<i>, deduction fails unless the type ofi is the same as that of the corresponding
template parameterp in the specialization (fromA) of the template named by the enclosingsimple-template-id
or splice-specialization-specifier; if the declared type ofi contains a placeholder type, the corresponding
template argument for the purposes of placeholder type deduction (9.2.9.7.2) is anid-expression for p. If P
§ 13.10.3.6 © ISO/IEC
498

===== PAGE 510 =====

Dxxxx
has a form that contains[i], and if the type ofi is not an integral type, deduction fails.115 If P has a form
that includesnoexcept(i) and the type ofi is notbool, deduction fails.
[Example 13:
template<int i> class A { /* ... */ };
template<short s> void f(A<s>);
void k1() {
A<1> a;
f(a); // error: deduction fails for conversion fromint to short
f<1>(a); // OK
}
template<const short cs> class B { };
template<short s> void g(B<s>);
void k2() {
B<1> b;
g(b); // OK, cv-qualifiers are ignored on template parameter types
}
template<auto> struct C;
template<long long x> void f(C<x> *);
void g(C<0LL> *ap) {
f(ap); // OK, deduceslong long value from0LL
}
template<int> struct D;
template<auto x> void f(D<x> *);
void g(D<0LL> *ap) {
f(ap); // OK, deducesx as an int value
}
template<int &> struct E;
template<auto x> void f(E<x> *);
int v;
void g(E<v> *bp) {
f(bp); // error: typeint of x does not match theint & type
} // of the template parameter in theE<v> specialization of E
template<const int &> struct F;
template<decltype(auto) x> void f(F<x> *);
int i;
void g(F<i> *ap) {
f(ap); // OK, deducesx as a constant template parameter of typeconst int &
}
template <decltype(auto) q> struct G;
template <auto x> long *f(G<x> *); // #1
template <decltype(auto) x> short *f(G<x> *); // #2
const int j = 0;
short *g(G<(j)> *ap) { // OK,q has typeconst int &
return f(ap); // OK, only #2 matches
}
long *g(G<j> *ap) { // OK,q has typeint
return f(ap); // OK, #1 is more specialized
}
—end example]
21 A template-argument can be deduced from a function, pointer to function, or pointer-to-member-function
type.
115) Although thetemplate-argument corresponding to a template parameter of typebool can be deduced from an array bound,
the resulting value will always betrue because the array bound will be nonzero.
§ 13.10.3.6 © ISO/IEC
499

===== PAGE 511 =====

Dxxxx
[Example 14:
template<class T> void f(void(*)(T,int));
template<class T> void foo(T,int);
void g(int,int);
void g(char,int);
void h(int,int,int);
void h(char,int);
int m() {
f(&g); // error: ambiguous
f(&h); // OK, voidh(char,int) is a unique match
f(&foo); // error: type deduction fails becausefoo is a template
}
—end example]
22 A templatetype-parameter cannot be deduced from the type of a function default argument.
[Example 15:
template <class T> void f(T = 5, T = 7);
void g() {
f(1); // OK, callsf<int>(1,7)
f(); // error: cannot deduceT
f<int>(); // OK, callsf<int>(5,7)
}
—end example]
23 The template-argument corresponding to a template template parameter is deduced from the type of the
template-argument of a class template specialization used in the argument list of a function call.
[Example 16:
template <template <class T> class X> struct A { };
template <template <class T> class X> void f(A<X>) { }
template<class T> struct B { };
A<B> ab;
f(ab); // calls f(A<B>)
—end example]
24 [Note 8: Template argument deduction involving parameter packs (13.7.4) can deduce zero or more arguments for
each parameter pack.—end note]
[Example 17:
template<class> struct X { };
template<class R, class ... ArgTypes> struct X<R(int, ArgTypes ...)> { };
template<class ... Types> struct Y { };
template<class T, class ... Types> struct Y<T, Types& ...> { };
template<class ... Types> int f(void (*)(Types ...));
void g(int, float);
X<int> x1; // uses primary template
X<int(int, float, double)> x2; // uses partial specialization;ArgTypes contains float, double
X<int(float, int)> x3; // uses primary template
Y<> y1; // uses primary template;Types is empty
Y<int&, float&, double&> y2; // uses partial specialization;T is int&, Types contains float, double
Y<int, float, double> y3; // uses primary template;Types contains int, float, double
int fv = f(g); // OK;Types contains int, float
—end example]
13.10.3.7 Deducing template arguments from a function declaration [temp.deduct.decl]
1 In a declaration whosedeclarator-id refers to a specialization of a function template, template argument
deduction is performed to identify the specialization to which the declaration refers. Specifically, this is done
for explicit instantiations (13.9.3), explicit specializations (13.9.4), and certain friend declarations (13.7.5).
This is also done to determine whether a deallocation function template specialization matches a placement
§ 13.10.3.7 © ISO/IEC
500

===== PAGE 512 =====

Dxxxx
operator new (6.8.6.5.3, 7.6.2.8). In all these cases,P is the type of the function template being considered
as a potential match andA is either the function type from the declaration or the type of the deallocation
function that would match the placementoperator new as described in 7.6.2.8. The deduction is done as
described in 13.10.3.6.
2 If, for the set of function templates so considered, there is either no match or more than one match after
partial ordering has been considered (13.7.7.3), deduction fails and, in the declaration cases, the program is
ill-formed.
13.10.4 Overload resolution [temp.over]
1 When a call of a function or function template is written (explicitly, or implicitly using the operator notation),
template argument deduction (13.10.3) and checking of any explicit template arguments (13.4) are performed
for each function template to find the template argument values (if any) that can be used with that function
template to instantiate a function template specialization that can be invoked with the call arguments or, for
conversion function templates, that can convert to the required type. For each function template:
—(1.1) If the argument deduction and checking succeeds, thetemplate-arguments (deduced and/or explicit) are
used to synthesize the declaration of a single function template specialization which is added to the
candidate functions set to be used in overload resolution.
—(1.2) If the argument deduction fails or the synthesized function template specialization would be ill-formed,
no such function is added to the set of candidate functions for that template.
The complete set of candidate functions includes all the synthesized declarations and all of the non-template
functions found by name lookup. The synthesized declarations are treated like any other functions in the
remainder of overload resolution, except as explicitly noted in 12.2.4.116
2 [Example 1:
template<class T> T max(T a, T b) { return a>b?a:b; }
void f(int a, int b, char c, char d) {
int m1 = max(a,b); // max(int a, int b)
char m2 = max(c,d); // max(char a, char b)
int m3 = max(a,c); // error: cannot generatemax(int,char)
}
Adding the non-template function
int max(int,int);
to the example above would resolve the third call, by providing a function that can be called formax(a,c) after using
the standard conversion ofchar to int for c. —end example]
3 [Example 2: Here is an example involving conversions on a function argument involved in template argument
deduction:
template<class T> struct B { /* ... */ };
template<class T> struct D : public B<T> { /* ... */ };
template<class T> void f(B<T>&);
void g(B<int>& bi, D<int>& di) {
f(bi); // f(bi)
f(di); // f((B<int>&)di)
}
—end example]
4 [Example 3: Here is an example involving conversions on a function argument not involved in template argument
deduction:
template<class T> void f(T*,int); // #1
template<class T> void f(T,char); // #2
116) The parameters of function template specializations contain no template parameter types. The set of conversions allowed on
deduced arguments is limited, because the argument deduction process produces function templates with parameters that either
match the call arguments exactly or differ only in ways that can be bridged by the allowed limited conversions. Non-deduced
arguments allow the full range of conversions. Note also that 12.2.4 specifies that a non-template function will be given preference
over a template specialization if the two functions are otherwise equally good candidates for an overload match.
§ 13.10.4 © ISO/IEC
501

===== PAGE 513 =====

Dxxxx
void h(int* pi, int i, char c) {
f(pi,i); // #1: f<int>(pi,i)
f(pi,c); // #2: f<int*>(pi,c)
f(i,c); // #2: f<int>(i,c);
f(i,i); // #2: f<int>(i,char(i))
}
—end example]
5 Only the signature of a function template specialization is needed to enter the specialization in a set of
candidate functions. Therefore only the function template declaration is needed to resolve a call for which a
template specialization is a candidate.
[Example 4:
template<class T> void f(T); // declaration
void g() {
f("Annemarie"); // calls f<const char*>
}
The call tof is well-formed even if the templatef is only declared and not defined at the point of the call. The
program will be ill-formed unless a specialization forf<const char*> is explicitly instantiated in some translation
unit (13.1). —end example]
§ 13.10.4 © ISO/IEC
502

===== PAGE 514 =====

Dxxxx
14 Exception handling [except]
14.1 Preamble [except.pre]
1 Exception handling provides a way of transferring control and information from a point in the execution of a
thread to an exception handler associated with a point previously passed by the execution. A handler will be
invoked only by throwing an exception in code executed in the handler’s try block or in functions called from
the handler’s try block.
try-block:
try compound-statement handler-seq
function-try-block:
try ctor-initializeropt compound-statement handler-seq
handler-seq:
handler handler-seqopt
handler:
catch ( exception-declaration ) compound-statement
exception-declaration:
attribute-specifier-seqopt type-specifier-seq declarator
attribute-specifier-seqopt type-specifier-seq abstract-declaratoropt
...
The optional attribute-specifier-seq in an exception-declaration appertains to the parameter of the catch
clause (14.4).
2 A try-block is astatement (8.1).
[Note 1: Within this Clause “try block” is taken to mean bothtry-block and function-try-block. —end note]
3 The compound-statement of a try block or of a handler is a control-flow-limited statement (8.2).
[Example 1:
void f() {
goto l1; // error
goto l2; // error
try {
goto l1; // OK
goto l2; // error
l1: ;
} catch (...) {
l2: ;
goto l1; // error
goto l2; // OK
}
}
—end example]
A goto, break, return, orcontinue statement can be used to transfer control out of a try block or handler.
When this happens, each variable declared in the try block will be destroyed in the context that directly
contains its declaration.
[Example 2:
lab: try {
T1 t1;
try {
T2 t2;
if (condition)
goto lab;
} catch(...) { /* handler 2 */ }
} catch(...) { /* handler 1 */ }
§ 14.1 © ISO/IEC
503

===== PAGE 515 =====

Dxxxx
Here, executinggoto lab; will destroy firstt2, thent1, assuming thecondition does not declare a variable. Any
exception thrown while destroyingt2 will result in executinghandler 2; any exception thrown while destroyingt1
will result in executinghandler 1. —end example]
4 A function-try-block associates ahandler-seq with thector-initializer, if present, and thecompound-statement.
An exception thrown during the execution of thecompound-statement or, for constructors and destructors,
during the initialization or destruction, respectively, of the class’s subobjects, transfers control to a handler
in afunction-try-block in the same way as an exception thrown during the execution of atry-block transfers
control to other handlers.
[Example 3:
int f(int);
class C {
int i;
double d;
public:
C(int, double);
};
C::C(int ii, double id)
try : i(f(ii)), d(id) {
// constructor statements
} catch (...) {
// handles exceptions thrown from the ctor-initializer and from the constructor statements
}
—end example]
5 In this Clause, “before” and “after” refer to the “sequenced before” relation (6.10.1).
14.2 Throwing an exception [except.throw]
1 Throwing an exception transfers control to a handler.
[Note 1: An exception can be thrown from one of the following contexts:throw-expressions (7.6.18), allocation functions
(6.8.6.5.2), dynamic_cast (7.6.1.7), typeid (7.6.1.8), new-expressions (7.6.2.8), and standard library functions (16.3.2.4).
—end note]
An object is passed and the type of that object determines which handlers can catch it.
[Example 1:
throw "Help!";
can be caught by ahandler of const char* type:
try {
// ...
} catch(const char* p) {
// handle character string exceptions here
}
and
class Overflow {
public:
Overflow(char,double,double);
};
void f(double x) {
throw Overflow('+',x,3.45e107);
}
can be caught by a handler for exceptions of typeOverflow:
try {
f(1.2);
} catch(Overflow& oo) {
// handle exceptions of typeOverflow here
}
—end example]
§ 14.2 © ISO/IEC
504

===== PAGE 516 =====

Dxxxx
2 When an exception is thrown, control is transferred to the nearest handler with a matching type (14.4);
“nearest” means the handler for which thecompound-statement or ctor-initializer following thetry keyword
was most recently entered by the thread of control and not yet exited.
3 Throwing an exception initializes an object with dynamic storage duration, called theexception object. If the
type of the exception object would be an incomplete type (6.9.1), an abstract class type (11.7.4), or a pointer
to an incomplete type other thancv void (6.9.4), the program is ill-formed.
4 The memory for the exception object is allocated in an unspecified way, except as noted in 6.8.6.5.2. If a
handler exits by rethrowing, control is passed to another handler for the same exception object. The points
of potential destruction for the exception object are:
—(4.1) when an active handler for the exception exits by any means other than rethrowing, immediately after
the destruction of the object (if any) declared in theexception-declaration in the handler;
—(4.2) when an object of typestd::exception_ptr (17.9.7) that refers to the exception object is destroyed,
before the destructor ofstd::exception_ptr returns.
Among all points of potential destruction for the exception object, there is an unspecified last one where the
exception object is destroyed. All other points happen before that last one (6.10.2.2).
[Note 2: No other thread synchronization is implied in exception handling.—end note]
The implementation may then deallocate the memory for the exception object; any such deallocation is done
in an unspecified way.
[Note 3: A thrown exception does not propagate to other threads unless caught, stored, and rethrown using appropriate
library functions; see 17.9.7 and 32.10.—end note]
5 Let T denote the type of the exception object. Copy-initialization of an object of typeT from an lvalue of
type const T in a context unrelated toT shall be well-formed. IfT is a class type, the selected constructor is
odr-used (6.3) and the destructor ofT is potentially invoked (11.4.7).
6 An exception is considereduncaught after completing the initialization of the exception object until completing
the activation of a handler for the exception (14.4).
[Note 4: As a consequence, an exception is considered uncaught during any stack unwinding resulting from it being
thrown. —end note]
7 If an exception is rethrown (7.6.18, 17.9.7), it is considered uncaught from the point of rethrow until the
rethrown exception is caught.
[Note 5: The functionstd::uncaught_exceptions (17.9.6) returns the number of uncaught exceptions in the current
thread. —end note]
8 An exception is considered caught when a handler for that exception becomes active (14.4).
[Note 6: An exception can have active handlers and still be considered uncaught if it is rethrown.—end note]
9 If the exception handling mechanism handling an uncaught exception directly invokes a function that exits
via an exception, the functionstd::terminate is invoked (14.6.2).
[Example 2:
struct C {
C() { }
C(const C&) {
if (std::uncaught_exceptions()) {
throw 0; // throw during copy to handler’sexception-declaration object (14.4)
}
}
};
int main() {
try {
throw C(); // calls std::terminate if construction of the handler’s
// exception-declaration object is not elided (11.9.6)
} catch(C) { }
}
—end example]
[Note 7: If a destructor directly invoked by stack unwinding exits via an exception,std::terminate is invoked.
—end note]
§ 14.2 © ISO/IEC
505

===== PAGE 517 =====

Dxxxx
14.3 Stack unwinding [except.ctor]
1 As control passes from the point where an exception is thrown to a handler, objects are destroyed by a
process, specified in this subclause, calledstack unwinding.
2 Each object with automatic storage duration is destroyed if it has been constructed, but not yet destroyed,
since the try block was entered. If an exception is thrown during the destruction of temporaries or local
variables for areturn statement (8.8.4), the destructor for the returned object (if any) is also invoked. The
objects are destroyed in the reverse order of the completion of their construction.
[Example 1:
struct A { };
struct Y { ~Y() noexcept(false) { throw 0; } };
A f() {
try {
A a;
Y y;
A b;
return {}; // #1
} catch (...) {
}
return {}; // #2
}
At #1, the returned object of typeA is constructed. Then, the local variableb is destroyed (8.8). Next, the local
variable y is destroyed, causing stack unwinding, resulting in the destruction of the returned object, followed by the
destruction of the local variablea. Finally, the returned object is constructed again at #2.—end example]
3 If the initialization of an object other than by delegating constructor is terminated by an exception, the
destructor is invoked for each of the object’s subobjects that were known to be initialized by the object’s
initialization and whose initialization has completed (9.5).
[Note 1: If such an object has a reference member that extends the lifetime of a temporary object, this ends the
lifetime of the reference member, so the lifetime of the temporary object is effectively not extended.—end note]
A subobject isknown to be initializedif it is not an anonymous union member and its initialization is specified
—(3.1) in 11.9.3 for initialization by constructor,
—(3.2) in 11.4.5.3 for initialization by defaulted copy/move constructor,
—(3.3) in 11.9.4 for initialization by inherited constructor,
—(3.4) in 9.5.2 for aggregate initialization,
—(3.5) in 7.5.6.3 for the initialization of the closure object when evaluating alambda-expression,
—(3.6) in 9.5.1 for default-initialization, value-initialization, or direct-initialization of an array.
[Note 2: This includes virtual base class subobjects if the initialization is for a complete object, and can include
variant members that were nominated explicitly by amem-initializer or designated-initializer-clause or that have a
default member initializer. —end note]
If the destructor of an object is terminated by an exception, each destructor invocation that would be
performed after executing the body of the destructor (11.4.7) and that has not yet begun execution is
performed.
[Note 3: This includes virtual base class subobjects if the destructor was invoked for a complete object.—end note]
The subobjects are destroyed in the reverse order of the completion of their construction. Such destruction is
sequenced before entering a handler of thefunction-try-block of the constructor or destructor, if any.
4 If the compound-statement of the function-body of a delegating constructor for an object exits via an
exception, the object’s destructor is invoked. Such destruction is sequenced before entering a handler of the
function-try-block of a delegating constructor for that object, if any.
5 [Note 4: If the object was allocated by anew-expression (7.6.2.8), the matching deallocation function (6.8.6.5.3), if
any, is called to free the storage occupied by the object.—end note]
§ 14.3 © ISO/IEC
506

===== PAGE 518 =====

Dxxxx
14.4 Handling an exception [except.handle]
1 The exception-declaration in ahandler describes the type(s) of exceptions that can cause thathandler to be
entered. The exception-declaration shall not denote an incomplete type, an abstract class type, or an rvalue
reference type. Theexception-declaration shall not denote a pointer or reference to an incomplete type, other
than “pointer tocv void”.
2 A handler of type “array ofT” or function typeT is adjusted to be of type “pointer toT”.
3 A handler is a match for an exception object of typeE if
—(3.1) The handler is of typecv T or cv T& and E and T are the same type (ignoring the top-levelcv-qualifiers),
or
—(3.2) the handler is of typecv T or cv T& and T is an unambiguous public base class ofE, or
—(3.3) the handler is of typecv T or const T& where T is a pointer or pointer-to-member type andE is a
pointer or pointer-to-member type that can be converted toT by one or more of
—(3.3.1) a standard pointer conversion (7.3.12) not involving conversions to pointers to private or protected
or ambiguous classes
—(3.3.2) a function pointer conversion (7.3.14)
—(3.3.3) a qualification conversion (7.3.6), or
—(3.4) the handler is of type cv T or const T& where T is a pointer or pointer-to-member type andE is
std::nullptr_t.
[Note 1: A throw-expression whose operand is an integer literal with value zero does not match a handler of pointer
or pointer-to-member type. A handler of reference to array or function type is never a match for any exception
object (7.6.18). —end note]
[Example 1:
class Matherr { /* ... */ virtual void vf(); };
class Overflow: public Matherr { /* ... */ };
class Underflow: public Matherr { /* ... */ };
class Zerodivide: public Matherr { /* ... */ };
void f() {
try {
g();
} catch (Overflow oo) {
// ...
} catch (Matherr mm) {
// ...
}
}
Here, theOverflow handler will catch exceptions of typeOverflow and theMatherr handler will catch exceptions of
type Matherr and of all types publicly derived fromMatherr including exceptions of typeUnderflow and Zerodivide.
—end example]
4 The handlers for a try block are tried in order of appearance.
[Note 2: This makes it possible to write handlers that can never be executed, for example by placing a handler for a
final derived class after a handler for a corresponding unambiguous public base class.—end note]
5 A ... in a handler’sexception-declaration specifies a match for any exception. If present, a... handler shall
be the last handler for its try block.
6 If no match is found among the handlers for a try block, the search for a matching handler continues in a
dynamically surrounding try block of the same thread.
7 If the search for a handler exits the function body of a function with a non-throwing exception specification,
the functionstd::terminate (14.6.2) is invoked.
[Note 3: An implementation is not permitted to reject an expression merely because, when executed, it throws or
might throw an exception from a function with a non-throwing exception specification.—end note]
[Example 2:
extern void f(); // potentially-throwing
§ 14.4 © ISO/IEC
507

===== PAGE 519 =====

Dxxxx
void g() noexcept {
f(); // valid, even iff throws
throw 42; // valid, effectively a call tostd::terminate
}
The call tof is well-formed despite the possibility for it to throw an exception.—end example]
8 If no matching handler is found, the functionstd::terminate is invoked; whether or not the stack is unwound
before this invocation ofstd::terminate is implementation-defined (14.6.2).
9 A handler is consideredactive when initialization is complete for the parameter (if any) of the catch clause.
[Note 4: The stack will have been unwound at that point.—end note]
Also, an implicit handler is considered active when the functionstd::terminate is entered due to a throw.
A handler is no longer considered active when the catch clause exits.
10 The exception with the most recently activated handler that is still active is called thecurrently handled
exception.
11 Referring to any non-static member or base class of an object in the handler for afunction-try-block of a
constructor or destructor for that object results in undefined behavior.
12 Exceptions thrown in destructors of objects with static storage duration or in constructors of objects
associated with non-block variables with static storage duration are not caught by afunction-try-block on
the main function (6.10.3.1). Exceptions thrown in destructors of objects with thread storage duration or in
constructors of objects associated with non-block variables with thread storage duration are not caught by a
function-try-block on the initial function of the thread.
13 If areturn statement (8.8.4) appears in a handler of thefunction-try-block of a constructor, the program is
ill-formed.
14 The currently handled exception is rethrown if control reaches the end of a handler of thefunction-try-block
of a constructor or destructor. Otherwise, flowing off the end of thecompound-statement of ahandler of a
function-try-block is equivalent to flowing off the end of thecompound-statement of that function (see 8.8.4).
15 The variable declared by theexception-declaration, of typecv T or cv T&, is initialized from the exception
object, of typeE, as follows:
—(15.1) if T is a base class ofE, the variable is copy-initialized (9.5) from an lvalue of typeT designating the
corresponding base class subobject of the exception object;
—(15.2) otherwise, the variable is copy-initialized (9.5) from an lvalue of typeE designating the exception object.
The lifetime of the variable ends when the handler exits, after the destruction of any objects with automatic
storage duration initialized within the handler.
16 [Note 5: When the handler declares an object, any changes to that object will not affect the exception object. When
the handler declares a reference to an object, any changes to the referenced object are changes to the exception object.
—end note]
14.5 Exception specifications [except.spec]
1 The predicate indicating whether a function cannot exit via an exception is called theexception specification
of the function. If the predicate is false, the function has apotentially-throwing exception specification,
otherwise it has anon-throwing exception specification. The exception specification is either defined implicitly,
or defined explicitly by using anoexcept-specifier as a suffix of a function declarator (9.3.4.6).
noexcept-specifier:
noexcept ( constant-expression )
noexcept
2 In a noexcept-specifier, the constant-expression, if supplied, shall be a contextually converted constant
expression of typebool (7.7); that constant expression is the exception specification of the function type
in which thenoexcept-specifier appears. A ( token that followsnoexcept is part of thenoexcept-specifier
and does not commence an initializer (9.5). Thenoexcept-specifier noexcept without aconstant-expression is
equivalent to thenoexcept-specifier noexcept(true).
[Example 1:
void f() noexcept(sizeof(char[2])); // error: narrowing conversion of value 2 to typebool
void g() noexcept(sizeof(char)); // OK, conversion of value 1 to typebool is non-narrowing
—end example]
§ 14.5 © ISO/IEC
508

===== PAGE 520 =====

Dxxxx
3 If a declaration of a function does not have anoexcept-specifier, the declaration has a potentially throwing
exception specification unless it is a destructor or a deallocation function or is defaulted on its first declaration,
in which cases the exception specification is as specified below and no other declaration for that function
shall have anoexcept-specifier. In an explicit instantiation (13.9.3) anoexcept-specifier may be specified, but
is not required. If anoexcept-specifier is specified in an explicit instantiation, the exception specification shall
be the same as the exception specification of all other declarations of that function. A diagnostic is required
only if the exception specifications are not the same within a single translation unit.
4 If a virtual function has a non-throwing exception specification, all declarations, including the definition, of
any function that overrides that virtual function in any derived class shall have a non-throwing exception
specification, unless the overriding function is defined as deleted.
[Example 2:
struct B {
virtual void f() noexcept;
virtual void g();
virtual void h() noexcept = delete;
};
struct D: B {
void f(); // error
void g() noexcept; // OK
void h() = delete; // OK
};
The declaration ofD::f is ill-formed because it has a potentially-throwing exception specification, whereasB::f has a
non-throwing exception specification. —end example]
5 An expressionE is potentially-throwing if
—(5.1) E is a function call (7.6.1.3) whosepostfix-expression has a function type, or a pointer-to-function type,
with a potentially-throwing exception specification, or
—(5.2) E implicitly invokes a function (such as an overloaded operator, an allocation function in anew-
expression, a constructor for a function argument, or a destructor) that has a potentially-throwing
exception specification, or
—(5.3) E is athrow-expression (7.6.18), or
—(5.4) E is adynamic_cast expression that casts to a reference type and requires a runtime check (7.6.1.7), or
—(5.5) E is atypeid expression applied to a (possibly parenthesized) built-in unary* operator applied to a
pointer to a polymorphic class type (7.6.1.8), or
—(5.6) any of the immediate subexpressions (6.10.1) ofE is potentially-throwing.
6 An implicitly-declared constructor for a classX, or a constructor without anoexcept-specifier that is defaulted
on its first declaration, has a potentially-throwing exception specification if and only if any of the following
constructs is potentially-throwing:
—(6.1) the invocation of a constructor selected by overload resolution in the implicit definition of the constructor
for classX to initialize a potentially constructed subobject, or
—(6.2) a subexpression of such an initialization, such as a default argument expression, or,
—(6.3) for a default constructor, a default member initializer.
[Note 1: Even though destructors for fully-constructed subobjects are invoked when an exception is thrown during
the execution of a constructor (14.3), their exception specifications do not contribute to the exception specification of
the constructor, because an exception thrown from such a destructor would call the functionstd::terminate rather
than escape the constructor (14.2, 14.6.2).—end note]
7 The exception specification for an implicitly-declared destructor, or a destructor without anoexcept-specifier,
is potentially-throwing if and only if any of the destructors for any of its potentially constructed subobjects
has a potentially-throwing exception specification or the destructor is virtual and the destructor of any virtual
base class has a potentially-throwing exception specification.
8 The exception specification for an implicitly-declared assignment operator, or an assignment-operator without
a noexcept-specifier that is defaulted on its first declaration, is potentially-throwing if and only if the invocation
of any assignment operator in the implicit definition is potentially-throwing.
§ 14.5 © ISO/IEC
509

===== PAGE 521 =====

Dxxxx
9 A deallocation function (6.8.6.5.3) with no explicitnoexcept-specifier has a non-throwing exception specifica-
tion.
10 The exception specification for a comparison operator function (12.4.3) without anoexcept-specifier that is
defaulted on its first declaration is potentially-throwing if and only if any expression in the implicit definition
is potentially-throwing.
11 [Example 3:
struct A {
A(int = (A(5), 0)) noexcept;
A(const A&) noexcept;
A(A&&) noexcept;
~A();
};
struct B {
B() noexcept;
B(const B&) = default; // implicit exception specification isnoexcept(true)
B(B&&, int = (throw 42, 0)) noexcept;
~B() noexcept(false);
};
int n = 7;
struct D : public A, public B {
int * p = new int[n];
// D::D() potentially-throwing, as thenew operator may throwbad_alloc or bad_array_new_length
// D::D(const D&) non-throwing
// D::D(D&&) potentially-throwing, as the default argument forB’s constructor may throw
// D::~D() potentially-throwing
};
Furthermore, if A::~A() were virtual, the program would be ill-formed since a function that overrides a virtual
function from a base class shall not have a potentially-throwing exception specification if the base class function has a
non-throwing exception specification. —end example]
12 An exception specification is considered to beneeded when:
—(12.1) in an expression, the function is selected by overload resolution (12.2, 12.3);
—(12.2) the function is odr-used (6.3);
—(12.3) the exception specification is compared to that of another declaration (e.g., an explicit specialization or
an overriding virtual function);
—(12.4) the function is defined; or
—(12.5) the exception specification is needed for a defaulted function that calls the function.
[Note 2: A defaulted declaration does not require the exception specification of a base member function
to be evaluated until the implicit exception specification of the derived function is needed, but an explicit
noexcept-specifier needs the implicit exception specification to compare against.—end note]
The exception specification of a defaulted function is evaluated as described above only when needed; similarly,
the noexcept-specifier of a specialization of a templated function is instantiated only when needed.
14.6 Special functions [except.special]
14.6.1 General [except.special.general]
1 The functionstd::terminate (14.6.2) is used by the exception handling mechanism for coping with errors
related to the exception handling mechanism itself. The functionstd::uncaught_exceptions(17.9.6) reports
how many exceptions are uncaught in the current thread. The functionstd::current_exception (17.9.7)
and the classstd::nested_exception (17.9.8) can be used by a program to capture the currently handled
exception.
14.6.2 The std::terminate function [except.terminate]
1 Some errors in a program cannot be recovered from, such as when an exception is not handled or a
std::thread object is destroyed while its thread function is still executing. In such cases, the function
std::terminate (17.9.5) is invoked.
§ 14.6.2 © ISO/IEC
510

===== PAGE 522 =====

Dxxxx
[Note 1: These situations are:
—(1.1) when the exception handling mechanism, after completing the initialization of the exception object but before
activation of a handler for the exception (14.2), calls a function that exits via an exception, or
—(1.2) when the exception handling mechanism cannot find a handler for a thrown exception (14.4), or
—(1.3) when the search for a handler (14.4) exits the function body of a function with a non-throwing exception
specification (14.5), including when a contract-violation handler invoked from an evaluation of a function
contract assertion (6.11.2) associated with the function exits via an exception, or
—(1.4) when the destruction of an object during stack unwinding (14.3) terminates by throwing an exception, or
—(1.5) when initialization of a non-block variable with static or thread storage duration (6.10.3.3) exits via an exception,
or
—(1.6) when destruction of an object with static or thread storage duration exits via an exception (6.10.3.4), or
—(1.7) when execution of a function registered withstd::atexit or std::at_quick_exit exits via an exception (17.5),
or
—(1.8) when athrow-expression (7.6.18) with no operand attempts to rethrow an exception and no exception is being
handled (14.2), or
—(1.9) when the function std::nested_exception::rethrow_nested is called for an object that has captured no
exception (17.9.8), or
—(1.10) when execution of the initial function of a thread exits via an exception (32.4.3.3), or
—(1.11) for a parallel algorithm whoseExecutionPolicy specifies such behavior (26.3.6.3, 26.3.6.4, 26.3.6.5), when
execution of an element access function (26.3.1) of the parallel algorithm exits via an exception (26.3.4), or
—(1.12) when the destructor or the move assignment operator is invoked on an object of typestd::thread that refers
to a joinable thread (32.4.3.4, 32.4.3.5), or
—(1.13) when a call to await(), wait_until(), orwait_for() function on a condition variable (32.7.4, 32.7.5) fails to
meet a postcondition, or
—(1.14) when a callback invocation exits via an exception when requesting stop on astd::stop_source or astd::in-
place_stop_source (32.3.5.3, 32.3.9.3), or in the constructor ofstd::stop_callback or std::inplace_stop_-
callback (32.3.6.2, 32.3.10.2) when a callback invocation exits via an exception, or
—(1.15) when arun_loop object is destroyed that is still in therunning state (33.12.1), or
—(1.16) when unhandled_stopped is called on awith_awaitable_senders<T> object (33.13.2) whose continuation is
not a handle to a coroutine whose promise type has anunhandled_stopped member function, or
—(1.17) when an object scope of type std::execution::simple_counting_scope or std::execution::counting_-
scope is destroyed andscope.state is not equal tojoined , unused , or unused-and-closed (33.14.2.2.2),
or
—(1.18) when std::execution::get_parallel_scheduler is called andstd::execution::system_context_replace-
ability::query_parallel_scheduler_backend() returns a null pointer value (33.15), or
—(1.19) when an exception is thrown from a coroutinestd::execution::task (33.13.6) which doesn’t support a
std::execution::set_error_t(std::exception_ptr) completion.
—end note]
2 In the situation where no matching handler is found, it is implementation-defined whether or not the stack is
unwound beforestd::terminate is invoked. In the situation where the search for a handler (14.4) exits the
function body of a function with a non-throwing exception specification (14.5), it is implementation-defined
whether the stack is unwound, unwound partially, or not unwound at all before the functionstd::terminate
is invoked. In all other situations, the stack shall not be unwound before the functionstd::terminate is
invoked. An implementation is not permitted to finish stack unwinding prematurely based on a determination
that the unwind process will eventually cause an invocation of the functionstd::terminate.
§ 14.6.2 © ISO/IEC
511

===== PAGE 523 =====

Dxxxx
15 Preprocessing directives [cpp]
15.1 Preamble [cpp.pre]
preprocessing-file:
groupopt
module-file
module-file:
line-directivesopt pp-global-module-fragmentopt pp-module groupopt pp-private-module-fragmentopt
pp-global-module-fragment:
module ; new-line groupopt
pp-private-module-fragment:
module : private ;new-line groupopt
group:
group-part
group group-part
group-part:
control-line
if-section
text-line
# conditionally-supported-directive
control-line:
# include pp-tokens new-line
pp-import
# embed pp-tokens new-line
# define identifier replacement-list new-line
# define identifier lparen identifier-listopt ) replacement-list new-line
# define identifier lparen... ) replacement-list new-line
# define identifier lparen identifier-list, ... ) replacement-list new-line
# undef identifier new-line
line-directive
# error pp-tokensopt new-line
# warning pp-tokensopt new-line
# pragma pp-tokensopt new-line
# new-line
line-directives:
line-directive line-directivesopt
if-section:
if-group elif-groupsopt else-groupopt endif-line
if-group:
# if constant-expression new-line groupopt
# ifdef identifier new-line groupopt
# ifndef identifier new-line groupopt
elif-groups:
elif-group elif-groupsopt
elif-group:
# elif constant-expression new-line groupopt
# elifdef identifier new-line groupopt
# elifndef identifier new-line groupopt
else-group:
# else new-line groupopt
endif-line:
# endif new-line
text-line:
pp-tokensopt new-line
§ 15.1 © ISO/IEC
512

===== PAGE 524 =====

Dxxxx
conditionally-supported-directive:
pp-tokens new-line
lparen:
a ( character not immediately preceded by whitespace
identifier-list:
identifier
identifier-list , identifier
replacement-list:
pp-tokensopt
pp-tokens:
preprocessing-token pp-tokensopt
embed-parameter-seq:
embed-parameter embed-parameter-seqopt
embed-parameter:
embed-standard-parameter
embed-prefixed-parameter
embed-standard-parameter:
limit ( pp-balanced-token-seq )
prefix ( pp-balanced-token-seqopt )
suffix ( pp-balanced-token-seqopt )
if_empty ( pp-balanced-token-seqopt )
embed-prefixed-parameter:
identifier :: identifier
identifier :: identifier( pp-balanced-token-seqopt )
pp-balanced-token-seq:
pp-balanced-token pp-balanced-token-seqopt
pp-balanced-token:
( pp-balanced-token-seqopt )
[ pp-balanced-token-seqopt ]
{ pp-balanced-token-seqopt }
any pp-token except:
parenthesis (u+0028 left parenthesisand u+0029 right parenthesis),
bracket (u+005b left square bracketand u+005d right square bracket), or
brace (u+007b left curly bracketand u+007d right curly bracket).
new-line:
the new-line character
1 The implementation can process and skip sections of source files conditionally, include other source files,
import macros from header units, and replace macros. These capabilities are calledpreprocessing, because
conceptually they occur before translation of the resulting translation unit.
2 A preprocessing directiveconsists of a sequence of preprocessing tokens that satisfies the following constraints:
At the start of translation phase 4, the first preprocessing token in the sequence, referred to as adirective-
introducing token, begins with the first character in the source file (optionally after whitespace containing no
new-line characters) or follows whitespace containing at least one new-line character, and is
—(2.1) a # preprocessing token, or
—(2.2) an import preprocessing token immediately followed on the same logical source line by aheader-name,
<, identifier, or: preprocessing token, or
—(2.3) a module preprocessing token immediately followed on the same logical source line by anidentifier, :,
or ; preprocessing token, or
—(2.4) an export preprocessing token immediately followed on the same logical source line by one of the two
preceding forms.
The last preprocessing token in the sequence is the first preprocessing token within the sequence that is
immediately followed by whitespace containing a new-line character.117
117) Thus, preprocessing directives are commonly called “lines”. These “lines” have no other syntactic significance, as all
whitespace is equivalent except in certain situations during preprocessing (see the# character string literal creation operator
in 15.7.3, for example).
§ 15.1 © ISO/IEC
513

===== PAGE 525 =====

Dxxxx
[Note 1: A new-line character ends the preprocessing directive even if it occurs within what would otherwise be an
invocation of a function-like macro.—end note]
[Example 1:
# // preprocessing directive
module ; // preprocessing directive
export module leftpad; // preprocessing directive
import <string>; // preprocessing directive
export import "squee"; // preprocessing directive
import rightpad; // preprocessing directive
import :part; // preprocessing directive
module // not a preprocessing directive
; // not a preprocessing directive
export // not a preprocessing directive
import // not a preprocessing directive
foo; // not a preprocessing directive
export // not a preprocessing directive
import foo; // preprocessing directive (ill-formed at phase 7)
import :: // not a preprocessing directive
import -> // not a preprocessing directive
—end example]
3 A sequence of preprocessing tokens is only atext-line if it does not begin with a directive-introducing token.
[Example 2:
using module = int;
module i; // not atext-line and not acontrol-line
int foo() {
return i;
}
The example is not a validpreprocessing-file. —end example]
A sequence of preprocessing tokens is only aconditionally-supported-directive if it does not begin with any of the
directive names appearing after a#in the syntax. Aconditionally-supported-directive is conditionally-supported
with implementation-defined semantics.
4 If one of thepp-tokens of a #embed directive (before macro replacement) is theidentifier limit, prefix,
suffix, or if_empty and that identifier is defined as a macro (15.7.1), the program is ill-formed. Any
embed-prefixed-parameter is conditionally-supported, with implementation-defined semantics.
5 At the start of phase 4 of translation, thegroup of app-global-module-fragment shall contain neither atext-line
nor app-import.
6 When in a group that is skipped (15.2), the directive syntax is relaxed to allow any sequence of preprocessing
tokens to occur between the directive name and the following new-line character.
7 The only whitespace characters that shall appear between preprocessing tokens within a preprocessing
directive (from just after the directive-introducing token through just before the terminating new-line
character) are u+0020 space and u+0009 character tabulation(including spaces that have replaced
comments or possibly other whitespace characters in translation phase 3).
8 The preprocessing tokens within a preprocessing directive are not subject to macro expansion unless otherwise
stated.
[Example 3: In:
#define EMPTY
EMPTY # include <file.h>
the sequence of preprocessing tokens on the second line isnot a preprocessing directive, because it does not begin
with a# at the start of translation phase 4, even though it will do so after the macroEMPTY has been replaced. —end
example]
§ 15.1 © ISO/IEC
514

===== PAGE 526 =====

Dxxxx
15.2 Conditional inclusion [cpp.cond]
defined-macro-expression:
defined identifier
defined ( identifier )
h-preprocessing-token:
any preprocessing-token other than>
h-pp-tokens:
h-preprocessing-token h-pp-tokensopt
header-name-tokens:
plain-string-literal
< h-pp-tokens >
has-include-expression:
__has_include ( header-name )
__has_include ( header-name-tokens )
has-embed-expression:
__has_embed ( header-name pp-balanced-token-seqopt )
__has_embed ( header-name-tokens pp-balanced-token-seqopt )
has-attribute-expression:
__has_cpp_attribute ( pp-tokens )
1 The expression that controls conditional inclusion shall be an integral constant expression except that
identifiers (including those lexically identical to keywords) are interpreted as described below118 and it
may contain zero or moredefined-macro-expressions, has-include-expressions, has-attribute-expressions, and/or
has-embed-expressions as unary operator expressions. Adefined-macro-expression shall not appear within a
has-include-expression or has-embed-expression.
2 A defined-macro-expression evaluates to1 if the identifier is currently defined as a macro name (that is, if it
is predefined or if it has one or more active macro definitions (15.6), for example because it has been the
subject of a#define preprocessing directive without an intervening#undef directive with the same subject
identifier), 0 if it is not.
3 The header or source file identified by the parenthesized preprocessing token sequence in each contained
has-include-expression is searched for as if that preprocessing token sequence were thepp-tokens of a#include
directive, except that no further macro expansion is performed. If the preprocessing token sequence does not
consist solely of aheader-name or cannot be combined (15.3) into a singleheader-name preprocessing token,
the program is ill-formed. Thehas-include-expression evaluates to1 if the search for the source file succeeds,
and to0 if the search fails.
4 The parenthesized preprocessing token sequence of each containedhas-embed-expression is processed as if
that preprocessing token sequence were thepp-tokens of a#embed directive (15.4), except that no further
macro expansion is performed. Thehas-embed-expression evaluates to:
—(4.1) __STDC_EMBED_FOUND__ if the search for the resource succeeds, all the givenembed-parameters in the
embed-parameter-seq are supported, and the resource is not empty.
—(4.2) Otherwise, __STDC_EMBED_EMPTY__ if the search for the resource succeeds, all the given embed-
parameters in theembed-parameter-seq are supported, and the resource is empty.
—(4.3) Otherwise, __STDC_EMBED_NOT_FOUND__.
[Note 1: An unrecognizedembed-parameter in anhas-embed-expression is not ill-formed and is instead treated as not
supported. —end note]
5 Each has-attribute-expression is replaced by a non-zeropp-number matching the form of aninteger-literal if
the implementation supports an attribute with the name specified by interpreting thepp-tokens, after macro
expansion, as anattribute-token, and by0 otherwise. The program is ill-formed if thepp-tokens do not match
the form of anattribute-token.
6 For an attribute specified in this document, it is implementation-defined whether the value of thehas-attribute-
expression is 0 or is given by Table 21. For other attributes recognized by the implementation, the value is
implementation-defined.
[Note 2: It is expected that the availability of an attribute can be detected by any non-zero result.—end note]
§ 15.2 © ISO/IEC
515

===== PAGE 527 =====

Dxxxx
Table 21 —__has_cpp_attribute values [tab:cpp.cond.ha]
Attribute Value
assume 202207L
deprecated 201309L
fallthrough 201603L
indeterminate 202403L
likely 201803L
maybe_unused 201603L
no_unique_address 201803L
nodiscard 201907L
noreturn 200809L
unlikely 201803L
7 The #ifdef, #ifndef, #elifdef, and#elifndef directives, and thedefined conditional inclusion operator,
shall treat__has_include, __has_embed, and__has_cpp_attribute as if they were the names of defined
macros. The identifiers__has_include, __has_embed, and__has_cpp_attribute shall not appear in any
context not mentioned in this subclause.
8 Each preprocessing token that remains (in the list of preprocessing tokens that will become the controlling
expression) after all macro replacements have occurred shall be in the lexical form of a token (5.10).
9 Preprocessing directives of the forms
# if constant-expression new-line groupopt
# elif constant-expression new-line groupopt
check whether the controlling constant expression evaluates to nonzero.
10 Prior to evaluation, macro invocations in the list of preprocessing tokens that will become the controlling
constant expression are replaced (except for those macro names modified by thedefined unary operator), just
as in normal text. If replacement of macros in the preprocessing tokens following the sequence__has_embed
( and before a matching) (possibly produced by macro expansion) encounters a preprocessing token that is
one of theidentifiers limit, prefix, suffix, orif_empty and thatidentifier is defined as a macro (15.7.1),
the program is ill-formed. If the preprocessing tokendefined is generated as a result of this replacement
process or use of thedefined unary operator does not match one of the two specified forms prior to macro
replacement, the program is ill-formed, no diagnostic required.
11 After all replacements due to macro expansion and evaluations ofdefined-macro-expressions, has-include-
expressions, has-embed-expressions, andhas-attribute-expressions have been performed, all remaining identifiers
(including those lexically identical to keywords), except fortrue and false, are replaced with thepp-number
0, and then each preprocessing token is converted into a token.
[Note 3: An alternative token (5.9) is not an identifier, even when its spelling consists entirely of letters and underscores.
Therefore it is not subject to this replacement.—end note]
12 The resulting tokens comprise the controlling constant expression which is evaluated according to the rules
of 7.7 using arithmetic that has at least the ranges specified in 17.3. For the purposes of this token conversion
and evaluation all signed and unsigned integer types act as if they have the same representation as, respectively,
intmax_t or uintmax_t (17.4.1).
[Note 4: Thus on an implementation where std::numeric_limits<int>::max() is 0x7FFF and std::numeric_-
limits<unsigned int>::max() is 0xFFFF, the integer literal0x8000 is signed and positive within a#if expression
even though it is unsigned in translation phase 7 (5.2).—end note]
This includes interpretingcharacter-literals according to the rules in 5.13.3.
[Note 5: The associated character encodings of literals are the same in#if and #elif directives and in any expression.
—end note]
Each subexpression with typebool is subjected to integral promotion before processing continues.
13 Preprocessing directives of the forms
118) Because the controlling constant expression is evaluated during translation phase 4, all identifiers either are or are not
macro names — there simply are no keywords, enumeration constants, etc.
§ 15.2 © ISO/IEC
516

===== PAGE 528 =====

Dxxxx
# ifdef identifier new-line groupopt
# ifndef identifier new-line groupopt
# elifdef identifier new-line groupopt
# elifndef identifier new-line groupopt
check whether the identifier is or is not currently defined as a macro name. Their conditions are equivalent
to #if definedidentifier, #if !definedidentifier, #elif definedidentifier, and#elif !definedidentifier,
respectively.
14 Each directive’s condition is checked in order. If it evaluates to false (zero), the group that it controls is
skipped: directives are processed only through the directive name that determines the directive in order to
keep track of the level of nested conditionals; the rest of the directives’ preprocessing tokens are ignored, as
are the other preprocessing tokens in the group. Only the first group whose control condition evaluates to
true (nonzero) is processed; any following groups are skipped and their controlling directives are processed
as if they were in a group that is skipped. If none of the conditions evaluates to true, and there is a#else
directive, the group controlled by the#else is processed; lacking a#else directive, all the groups until the
#endif are skipped.119
15 [Example 1: This demonstrates a way to include a libraryoptional facility only if it is available:
#if __has_include(<optional>)
# include <optional>
# if __cpp_lib_optional >= 201603
# define have_optional 1
# endif
#elif __has_include(<experimental/optional>)
# include <experimental/optional>
# if __cpp_lib_experimental_optional >= 201411
# define have_optional 1
# define experimental_optional 1
# endif
#endif
#ifndef have_optional
# define have_optional 0
#endif
—end example]
16 [Example 2: This demonstrates a way to use the attribute[[acme::deprecated]] only if it is available.
#if __has_cpp_attribute(acme::deprecated)
# define ATTR_DEPRECATED(msg) [[acme::deprecated(msg)]]
#else
# define ATTR_DEPRECATED(msg) [[deprecated(msg)]]
#endif
ATTR_DEPRECATED("This function is deprecated") void anvil();
—end example]
15.3 Source file inclusion [cpp.include]
1 A header searchfor a sequence of characters searches a sequence of places for a header identified uniquely by
that sequence of characters. How the places are determined or the header identified is implementation-defined.
2 A source file searchfor a sequence of characters attempts to identify a source file that is named by the
sequence of characters. The named source file is searched for in an implementation-defined manner. If the
implementation does not support a source file search for that sequence of characters, or if the search fails,
the result of the source file search is the result of a header search for the same sequence of characters.
3 A preprocessing directive of the form
# include header-name new-line
causes the replacement of that directive by the entire contents of the header or source file identified by
header-name.
4 If theheader-name is of the form
< h-char-sequence >
119) As indicated by the syntax, a preprocessing token cannot follow a#else or #endif directive before the terminating new-line
character. However, comments can appear anywhere in a source file, including within a preprocessing directive.
§ 15.3 © ISO/IEC
517

===== PAGE 529 =====

Dxxxx
a header is identified by a header search for the sequence of characters of theh-char-sequence.
5 If theheader-name is of the form
" q-char-sequence "
the source file or header is identified by a source file search for the sequence of characters of theq-char-sequence.
6 If a header search fails, or if a source file search or header search identifies a header or source file that cannot
be processed by the implementation, the program is ill-formed.
[Note 1: If the header or source file cannot be processed, the program is ill-formed even when evaluating__has_include.
—end note]
7 A preprocessing directive of the form
# include pp-tokens new-line
(that does not match the previous form) is permitted. The preprocessing tokens afterinclude in the directive
are processed just as in normal text (i.e., each identifier currently defined as a macro name is replaced by its
replacement list of preprocessing tokens). The resulting sequence of preprocessing tokens shall be of the form
header-name-tokens
An attempt is then made to form aheader-name preprocessing token (5.6) from the whitespace and the
characters of the spellings of theheader-name-tokens; the treatment of whitespace is implementation-defined.
If the attempt succeeds, the directive with the so-formedheader-name is processed as specified for the previous
form. Otherwise, the program is ill-formed, no diagnostic required.
[Note 2: Adjacentstring-literals are not concatenated into a singlestring-literal (see the translation phases in 5.2);
thus, an expansion that results in twostring-literals is an invalid directive.—end note]
8 The implementation shall provide unique mappings for sequences consisting of one or morenondigits or
digits (5.11) followed by a period (.) and a singlenondigit. The first character shall not be adigit. The
implementation may ignore distinctions of alphabetical case.
9 A #include preprocessing directive may appear in a source file that has been read because of a#include
directive in another file, up to an implementation-defined nesting limit.
10 If the header identified by theheader-name denotes an importable header (10.3), it is implementation-defined
whether the #include preprocessing directive is instead replaced by animport directive (15.6) of the
form
import header-name ; new-line
11 [Note 3: An implementation can provide a mechanism for making arbitrary source files available to the< > search.
However, using the< > form for headers provided with the implementation and the" " form for sources outside the
control of the implementation achieves wider portability. For instance:
#include <stdio.h>
#include <unistd.h>
#include "usefullib.h"
#include "myprog.h"
—end note]
12 [Example 1: This illustrates macro-replaced#include directives:
#if VERSION == 1
#define INCFILE "vers1.h"
#elif VERSION == 2
#define INCFILE "vers2.h" // and so on
#else
#define INCFILE "versN.h"
#endif
#include INCFILE
—end example]
15.4 Resource inclusion [cpp.embed]
15.4.1 General [cpp.embed.gen]
1 A bracket resource searchfor a sequence of characters searches a sequence of places for a resource identified
uniquely by that sequence of characters. How the places are determined or the resource identified is
§ 15.4.1 © ISO/IEC
518

===== PAGE 530 =====

Dxxxx
implementation-defined.
2 A quote resource searchfor a sequence of characters attempts to identify a resource that is named by the
sequence of characters. The named resource is searched for in an implementation-defined manner. If the
implementation does not support a quote resource search for that sequence of characters, or if the search
fails, the result of the quote resource search is the result of a bracket resource search for the same sequence of
characters.
3 A preprocessing directive of the form
# embed header-name pp-tokensopt new-line
causes the replacement of that directive by preprocessing tokens derived from data in the resource identified
by header-name, as specified below.
4 If theheader-name is of the form
< h-char-sequence >
the resource is identified by a bracket resource search for the sequence of characters of theh-char-sequence.
5 If theheader-name is of the form
" q-char-sequence "
the resource is identified by a quote resource search for the sequence of characters of theq-char-sequence.
6 If a bracket resource search fails, or if a quote or bracket resource search identifies a resource that cannot be
processed by the implementation, the program is ill-formed.
[Note 1: If the resource cannot be processed, the program is ill-formed even when processing#embed with limit(0)
(15.4.2.1) or evaluating__has_embed. —end note]
7 Recommended practice: A mechanism similar to, but distinct from, the implementation-defined search paths
used for#include (15.3) is encouraged.
8 Either form of the#embed directive processes thepp-tokens, if present, just as in normal text. Thepp-tokens
shall then have the formembed-parameter-seq.
9 A resource is a source of data accessible from the translation environment. A resource has animplementation-
resource-width, which is the implementation-defined size in bits of the resource. If the implementation-resource-
width is not an integral multiple ofCHAR_BIT, the program is ill-formed. Letimplementation-resource-count
be implementation-resource-width divided byCHAR_BIT. Every resource also has aresource-count, which is
—(9.1) the value as computed from the optionally-providedlimit embed-parameter (15.4.2.1), if present;
—(9.2) otherwise, the implementation-resource-count.
A resource is empty if the resource-count is zero.
10 [Example 1:
// ill-formed if the implementation-resource-width is 6 bits
#embed "6_bits.bin"
—end example]
11 The #embed directive is replaced by a comma-separated list of integer literals of typeint, unless otherwise
modified by embed parameters (15.4.2).
12 The integer literals in the comma-separated list correspond to resource-count consecutive calls tostd::fgetc
(31.13.1) from the resource, as a binary file. If any call tostd::fgetc returns EOF, the program is ill-formed.
13 Recommended practice: The value of each integer literal should closely represent the bit stream of the resource
unmodified. This can require an implementation to consider potential differences between translation and
execution environments, as well as any other applicable sources of mismatch.
[Example 2:
#include <cstring>
#include <cstddef>
#include <fstream>
#include <vector>
#include <cassert>
§ 15.4.1 © ISO/IEC
519

===== PAGE 531 =====

Dxxxx
int main() {
// If the file is the same as the resource in the translation environment, no assert in this program should fail.
constexpr unsigned char d[] = {
#embed <data.dat>
};
const std::vector<unsigned char> vec_d = {
#embed <data.dat>
};
constexpr std::size_t expected_size = sizeof(d);
// same file in execution environment as was embedded
std::ifstream f_source("data.dat", std::ios::binary | std::ios::in);
unsigned char runtime_d[expected_size];
char* ifstream_ptr = reinterpret_cast<char*>(runtime_d);
assert(!f_source.read(ifstream_ptr, expected_size));
std::size_t ifstream_size = f_source.gcount();
assert (ifstream_size == expected_size);
int is_same = std::memcmp(&d[0], ifstream_ptr, ifstream_size);
assert(is_same == 0);
int is_same_vec = std::memcmp(vec_d.data(), ifstream_ptr, ifstream_size);
assert(is_same_vec == 0);
}
—end example]
[Example 3:
int i = {
#embed "i.dat"
}; // well-formed ifi.dat produces a single value
int i2 =
#embed "i.dat"
; // also well-formed ifi.dat produces a single value
struct s {
double a, b, c;
struct { double e, f, g; } x;
double h, i, j;
};
s x = {
// well-formed if the directive produces nine or fewer values
#embed "s.dat"
};
—end example]
14 A preprocessing directive of the form
# embed pp-tokens new-line
(that does not match the previous form) is permitted. The preprocessing tokens afterembed in the directive
are processed just as in normal text (i.e., each identifier currently defined as a macro name is replaced by its
replacement list of preprocessing tokens). Then, an attempt is made to form aheader-name preprocessing
token (5.6) from the whitespace and the characters of the spellings of the resulting sequence of preprocessing
tokens immediately afterembed; the treatment of whitespace is implementation-defined. If the attempt
succeeds, the directive with the so-formedheader-name is processed as specified for the previous form.
Otherwise, the program is ill-formed.
[Note 2: Adjacentstring-literals are not concatenated into a singlestring-literal (see the translation phases in 5.2);
thus, an expansion that results in twostring-literals is an invalid directive.—end note]
Any further processing as in normal text described for the previous form is not performed.
[Note 3: That is, processing as in normal text happens once and only once for the entire directive.—end note]
[Example 4: If the directive matches the second form, the whole directive is replaced. If the directive matches the
first form, everything after theheader-name is replaced.
#define EMPTY
#define X myfile
§ 15.4.1 © ISO/IEC
520

===== PAGE 532 =====

Dxxxx
#define Y rsc
#define Z 42
#embed <myfile.rsc> prefix(Z)
#embed EMPTY <X.Y> prefix(Z)
is equivalent to:
#embed <myfile.rsc> prefix(42)
#embed <myfile.rsc> prefix(42)
—end example]
15.4.2 Embed parameters [cpp.embed.param]
15.4.2.1 limit parameter [cpp.embed.param.limit]
1 An embed-parameter of the formlimit ( pp-balanced-token-seq ) specifies the maximum possible number
of elements in the comma-delimited list. It shall appear at most once in theembed-parameter-seq. The
preprocessing tokendefined shall not appear in thepp-balanced-token-seq.
2 The pp-balanced-token-seq is evaluated as aconstant-expression using the rules as described in conditional
inclusion (15.2), but without being processed as in normal text an additional time.
[Example 1:
#undef DATA_LIMIT
#if __has_embed(<data.dat> limit(DATA_LIMIT))
#endif
is equivalent to:
#if __has_embed(<data.dat> limit(0))
#endif
—end example]
[Example 2:
#embed <data.dat> limit(__has_include("a.h"))
#if __has_embed(<data.dat> limit(__has_include("a.h")))
// ill-formed: __has_include (15.2) cannot appear here
#endif
—end example]
3 The constant-expression shall be an integral constant expression whose value is greater than or equal to zero.
The resource-count (15.4.1) becomes implementation-resource-count, if the value of theconstant-expression is
greater than implementation-resource-count; otherwise, the value of theconstant-expression.
[Example 3:
constexpr unsigned char sound_signature[] = {
// a hypothetical resource capable of expanding to four or more elements
#embed <sdk/jump.wav> limit(2+2)
};
static_assert(sizeof(sound_signature) == 4); // OK
—end example]
15.4.2.2 prefix parameter [cpp.embed.param.prefix]
1 An embed-parameter of the form
prefix ( pp-balanced-token-seqopt )
shall appear at most once in theembed-parameter-seq.
2 If the resource is empty, thisembed-parameter is ignored. Otherwise, thepp-balanced-token-seq is placed
immediately before the comma-delimited list of integral literals.
15.4.2.3 suffix parameter [cpp.embed.param.suffix]
1 An embed-parameter of the form
suffix ( pp-balanced-token-seqopt )
§ 15.4.2.3 © ISO/IEC
521

===== PAGE 533 =====

Dxxxx
shall appear at most once in theembed-parameter-seq.
2 If the resource is empty, thisembed-parameter is ignored. Otherwise, thepp-balanced-token-seq is placed
immediately after the comma-delimited list of the integral constant expressions.
[Example 1:
constexpr unsigned char whl[] = {
#embed "ches.glsl" \
prefix(0xEF, 0xBB, 0xBF, ) /∗ a sequence of bytes∗/ \
suffix(,)
0
};
// always null-terminated, contains the sequence if not empty
constexpr bool is_empty = sizeof(whl) == 1 && whl[0] == '\0';
constexpr bool is_not_empty = sizeof(whl) >= 4
&& whl[sizeof(whl) - 1] == '\0'
&& whl[0] == '\xEF' && whl[1] == '\xBB' && whl[2] == '\xBF';
static_assert(is_empty || is_not_empty);
—end example]
15.4.2.4 if_empty parameter [cpp.embed.param.if.empty]
1 An embed-parameter of the form
if_empty ( pp-balanced-token-seqopt )
shall appear at most once in theembed-parameter-seq.
2 If the resource is not empty, thisembed-parameter is ignored. Otherwise, the#embed directive is replaced by
the pp-balanced-token-seq.
[Example 1: limit(0) affects when a resource is considered empty. Therefore, the following program:
#embed </owo/uwurandom> \
if_empty(42203) limit(0)
expands to
42203
—end example]
[Example 2: This resource is considered empty due to thelimit(0) embed-parameter, always, including in__has_embed
clauses.
int infinity_zero () {
#if __has_embed(</owo/uwurandom> limit(0) prefix(some tokens)) == __STDC_EMBED_EMPTY__
// if </owo/uwurandom> exists, this conditional inclusion branch is taken and the function returns0.
return 0;
#else
// otherwise, the resource does not exist
#error "The resource does not exist"
#endif
}
—end example]
15.5 Module directive [cpp.module]
pp-module:
exportopt module pp-tokensopt ; new-line
1 The pp-tokens, if any, of app-module shall be of the form:
pp-module-name pp-module-partitionopt pp-tokensopt
where thepp-tokens (if any) shall not begin with a( preprocessing token and the grammar non-terminals are
defined as:
pp-module-name:
pp-module-name-qualifieropt identifier
pp-module-partition:
: pp-module-name-qualifieropt identifier
§ 15.5 © ISO/IEC
522

===== PAGE 534 =====

Dxxxx
pp-module-name-qualifier:
identifier .
pp-module-name-qualifier identifier.
No identifier in thepp-module-name or pp-module-partition shall currently be defined as an object-like macro.
2 Any preprocessing tokens after themodule preprocessing token in themodule directive are processed just as
in normal text.
[Note 1: Each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens.
—end note]
3 The module and export (if it exists) preprocessing tokens are replaced by themodule-keyword and export-
keyword preprocessing tokens respectively.
[Note 2: This makes the line no longer a directive so it is not removed at the end of phase 4.—end note]
15.6 Header unit importation [cpp.import]
pp-import:
exportopt import header-name pp-tokensopt ; new-line
exportopt import header-name-tokens pp-tokensopt ; new-line
exportopt import pp-tokens ; new-line
1 The preprocessing tokens after theimport preprocessing token in theimport control-line are processed just
as in normal text (i.e., each identifier currently defined as a macro name is replaced by its replacement list of
preprocessing tokens).
[Note 1: An import directive matching the first two forms of app-import instructs the preprocessor to import macros
from the header unit (10.3) denoted by theheader-name, as described below.—end note]
The point of macro importfor the first two forms ofpp-import is immediately after thenew-line terminating
the pp-import. The last form ofpp-import does not have a point of macro import, and is only considered if,
after macro replacement, the first two forms did not match.
2 If a pp-import is produced by source file inclusion (including by the rewrite produced when a#include
directive names an importable header) while processing thegroup of amodule-file, the program is ill-formed.
3 In all three forms ofpp-import, theimport and export (if it exists) preprocessing tokens are replaced by the
import-keyword and export-keyword preprocessing tokens respectively.
[Note 2: This makes the line no longer a directive so it is not removed at the end of phase 4.—end note]
Additionally, in the second form ofpp-import, aheader-name token is formed as if theheader-name-tokens
were thepp-tokens of a#include directive. The header-name-tokens are replaced by theheader-name token.
[Note 3: This ensures that imports are treated consistently by the preprocessor and later phases of translation.—end
note]
4 Each #define directive encountered when preprocessing each translation unit in a program results in a
distinct macro definition.
[Note 4: A predefined macro name (15.12) is not introduced by a#define directive. Implementations providing
mechanisms to predefine additional macros are encouraged to not treat them as being introduced by a#define
directive. —end note]
Each macro definition has at most one point of definition in each translation unit and at most one point of
undefinition, as follows:
—(4.1) The point of definitionof a macro definition within a translation unitT is
—(4.1.1) if the#define directive of the macro definition occurs withinT, the point at which that directive
occurs, or otherwise,
—(4.1.2) if the macro name is not lexically identical to a keyword (5.12) or to theidentifiers module or
import, the first point of macro import inT of a header unit containing a point of definition for
the macro definition, if any.
In the latter case, the macro is said to beimported from the header unit.
—(4.2) The point of undefinitionof a macro definition within a translation unit is the first point at which
a #undef directive naming the macro occurs after its point of definition, or the first point of macro
import of a header unit containing a point of undefinition for the macro definition, whichever (if any)
occurs first.
§ 15.6 © ISO/IEC
523

===== PAGE 535 =====

Dxxxx
5 A macro definition isactive at a source location if it has a point of definition in that translation unit preceding
the location, and does not have a point of undefinition in that translation unit preceding the location.
6 If a macro would be replaced or redefined, and multiple macro definitions are active for that macro name,
the active macro definitions shall all be valid redefinitions of the same macro (15.7).
[Note 5: The relative order ofpp-imports has no bearing on whether a particular macro definition is active.—end
note]
7 [Example 1:
Importable header"a.h":
#define X 123 // #1
#define Y 45 // #2
#define Z a // #3
#undef X // point of undefinition of #1 in"a.h"
Importable header"b.h":
import "a.h"; // point of definition of #1, #2, and #3, point of undefinition of #1 in"b.h"
#define X 456 // OK, #1 is not active
#define Y 6 // error: #2 is active
Importable header"c.h":
#define Y 45 // #4
#define Z c // #5
Importable header"d.h":
import "c.h"; // point of definition of #4 and #5 in"d.h"
Importable header"e.h":
import "a.h"; // point of definition of #1, #2, and #3, point of undefinition of #1 in"e.h"
import "d.h"; // point of definition of #4 and #5 in"e.h"
int a = Y; // OK, active macro definitions #2 and #4 are valid redefinitions
int c = Z; // error: active macro definitions #3 and #5 are not valid redefinitions ofZ
Module unitf:
export module f;
export import "a.h";
int a = Y; // OK
Translation unit#1:
import f;
int x = Y; // error: Y is neither a defined macro nor a declared name
—end example]
15.7 Macro replacement [cpp.replace]
15.7.1 General [cpp.replace.general]
1 Two replacement lists are identical if and only if the preprocessing tokens in both have the same number,
ordering, spelling, and whitespace separation, where all whitespace separations are considered identical.
2 An identifier currently defined as an object-like macro (see below) may be redefined by another#define
preprocessing directive provided that the second definition is an object-like macro definition and the two
replacement lists are identical, otherwise the program is ill-formed. Likewise, an identifier currently defined as
a function-like macro (see below) may be redefined by another#define preprocessing directive provided that
the second definition is a function-like macro definition that has the same number and spelling of parameters,
and the two replacement lists are identical, otherwise the program is ill-formed.
3 [Example 1: The following sequence is valid:
#define OBJ_LIKE (1-1)
#define OBJ_LIKE /* whitespace */ (1-1) /* other */
#define FUNC_LIKE(a) ( a )
#define FUNC_LIKE( a )( /* note the whitespace */ \
§ 15.7.1 © ISO/IEC
524

===== PAGE 536 =====

Dxxxx
a /* other stuff on this line
*/ )
But the following redefinitions are invalid:
#define OBJ_LIKE (0) // different token sequence
#define OBJ_LIKE (1 - 1) // different whitespace
#define FUNC_LIKE(b) ( a ) // different parameter usage
#define FUNC_LIKE(b) ( b ) // different parameter spelling
—end example]
4 There shall be whitespace between the identifier and the replacement list in the definition of an object-like
macro.
5 If theidentifier-list in the macro definition does not end with an ellipsis, the number of arguments (including
those arguments consisting of no preprocessing tokens) in an invocation of a function-like macro shall equal
the number of parameters in the macro definition. Otherwise, there shall be at least as many arguments in
the invocation as there are parameters in the macro definition (excluding the...). There shall exist a)
preprocessing token that terminates the invocation.
6 The identifiers__VA_ARGS__ and __VA_OPT__ shall occur only in thereplacement-list of a function-like macro
that uses the ellipsis notation in the parameters.
7 A parameter identifier in a function-like macro shall be uniquely declared within its scope.
8 The identifier immediately following thedefine is called themacro name. There is one name space for
macro names. Any whitespace characters preceding or following the replacement list of preprocessing tokens
are not considered part of the replacement list for either form of macro.
9 A translation unit shall not#define or #undef macro names lexically identical to keywords, to the identifiers
listed in Table 4, or to theattribute-tokens described in 9.13, except that the macro nameslikely and
unlikely may be defined as function-like macros and may be undefined.
[Note 1: An alternative token (5.9) is not an identifier, even when its spelling consists entirely of letters and underscores.
Therefore it is not possible to define a macro whose name is the same as that of an alternative token.—end note]
10 If a# preprocessing token, followed by an identifier, occurs lexically at the point at which a preprocessing
directive can begin, the identifier is not subject to macro replacement.
11 A preprocessing directive of the form
# define identifier replacement-list new-line
defines anobject-like macrothat causes each subsequent instance of the macro name120 to be replaced by the
replacement list of preprocessing tokens that constitute the remainder of the directive. The replacement list
is then rescanned for more macro names as specified in 15.7.5.
12 [Example 2: The simplest use of this facility is to define a “manifest constant”, as in
#define TABSIZE 100
int table[TABSIZE];
—end example]
13 A preprocessing directive of the form
# define identifier lparen identifier-listopt ) replacement-list new-line
# define identifier lparen... ) replacement-list new-line
# define identifier lparen identifier-list, ... ) replacement-list new-line
defines afunction-like macrowith parameters, whose use is similar syntactically to a function call. The
parameters are specified by the optional list of identifiers. Each subsequent instance of the function-like
macro name followed by a( as the next preprocessing token introduces the sequence of preprocessing tokens
that is replaced by the replacement list in the definition (an invocation of the macro). The replaced sequence
of preprocessing tokens is terminated by the matching) preprocessing token, skipping intervening matched
pairs of left and right parenthesis preprocessing tokens. Within the sequence of preprocessing tokens making
up an invocation of a function-like macro, new-line is considered a normal whitespace character.
14 The sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of
arguments for the function-like macro. The individual arguments within the list are separated by comma
120) Since, by macro-replacement time, allcharacter-literals andstring-literals are preprocessing tokens, not sequences possibly
containing identifier-like subsequences (see 5.2, translation phases), they are never scanned for macro names or parameters.
§ 15.7.1 © ISO/IEC
525

===== PAGE 537 =====

Dxxxx
preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate
arguments. If there are sequences of preprocessing tokens within the list of arguments that would otherwise
act as preprocessing directives,121 the program is ill-formed.
15 [Example 3: The following defines a function-like macro whose value is the maximum of its arguments. It has the
disadvantages of evaluating one or the other of its arguments a second time (including side effects) and generating
more code than a function if invoked several times. It also cannot have its address taken, as it has none.
#define max(a, b) ((a) > (b) ? (a) : (b))
The parentheses ensure that the arguments and the resulting expression are bound properly.—end example]
16 If there is a... immediately preceding the) in the function-like macro definition, then the trailing arguments
(if any), including any separating comma preprocessing tokens, are merged to form a single item: thevariable
arguments. The number of arguments so combined is such that, following merger, the number of arguments
is either equal to or one more than the number of parameters in the macro definition (excluding the...).
15.7.2 Argument substitution [cpp.subst]
va-opt-replacement:
__VA_OPT__ ( pp-tokensopt )
1 After the arguments for the invocation of a function-like macro have been identified, argument substitution
takes place. For each parameter in the replacement list that is neither preceded by a# or ## preprocessing
token nor followed by a## preprocessing token, the preprocessing tokens naming the parameter are replaced
by a preprocessing token sequence determined as follows:
—(1.1) If the parameter is of the formva-opt-replacement, the replacement preprocessing tokens are the
preprocessing token sequence for the corresponding argument, as specified below.
—(1.2) Otherwise, the replacement preprocessing tokens are the preprocessing tokens of corresponding argument
after all macros contained therein have been expanded. The argument’s preprocessing tokens are
completely macro replaced before being substituted as if they formed the rest of the preprocessing
translation unit with no other preprocessing tokens being available.
[Example 1:
#define LPAREN() (
#define G(Q) 42
#define F(R, X, ...) __VA_OPT__(G R X) )
int x = F(LPAREN(), 0, <:-); // replaced byint x = 42;
—end example]
2 An identifier__VA_ARGS__ that occurs in the replacement list shall be treated as if it were a parameter, and
the variable arguments shall form the preprocessing tokens used to replace it.
3 [Example 2:
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define showlist(...) puts(#__VA_ARGS__)
#define report(test, ...) ((test) ? puts(#test) : printf(__VA_ARGS__))
debug("Flag");
debug("X = %d\n", x);
showlist(The first, second, and third items.);
report(x>y, "x is %d but y is %d", x, y);
results in
fprintf(stderr, "Flag");
fprintf(stderr, "X = %d\n", x);
puts("The first, second, and third items.");
((x>y) ? puts("x>y") : printf("x is %d but y is %d", x, y));
—end example]
4 The identifier__VA_OPT__ shall always occur as part of the preprocessing token sequenceva-opt-replacement;
its closing) is determined by skipping intervening pairs of matching left and right parentheses in itspp-
tokens. The pp-tokens of a va-opt-replacement shall not contain__VA_OPT__. If the pp-tokens would be
ill-formed as the replacement list of the current function-like macro, the program is ill-formed. Ava-opt-
replacement is treated as if it were a parameter, and the preprocessing token sequence for the corresponding
121) A conditionally-supported-directive is a preprocessing directive regardless of whether the implementation supports it.
§ 15.7.2 © ISO/IEC
526

===== PAGE 538 =====

Dxxxx
argument is defined as follows. If the substitution of__VA_ARGS__ as neither an operand of# nor ##
consists of no preprocessing tokens, the argument consists of a single placemarker preprocessing token (15.7.4,
15.7.5). Otherwise, the argument consists of the results of the expansion of the containedpp-tokens as the
replacement list of the current function-like macro before removal of placemarker tokens, rescanning, and
further replacement.
[Note 1: The placemarker tokens are removed before stringization (15.7.3), and can be removed by rescanning and
further replacement (15.7.5). —end note]
[Example 3:
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
#define EMP
F(a, b, c) // replaced byf(0, a, b, c)
F() // replaced byf(0)
F(EMP) // replaced byf(0)
G(a, b, c) // replaced byf(0, a, b, c)
G(a, ) // replaced byf(0, a)
G(a) // replaced byf(0, a)
SDEF(foo); // replaced byS foo;
SDEF(bar, 1, 2); // replaced byS bar = { 1, 2 };
#define H1(X, ...) X __VA_OPT__(##) __VA_ARGS__ // error: ## may not appear at
// the beginning of a replacement list (15.7.4)
#define H2(X, Y, ...) __VA_OPT__(X ## Y,) __VA_ARGS__
H2(a, b, c, d) // replaced byab, c, d
#define H3(X, ...) #__VA_OPT__(X##X X##X)
H3(, 0) // replaced by""
#define H4(X, ...) __VA_OPT__(a X ## X) ## b
H4(, 1) // replaced bya b
#define H5A(...) __VA_OPT__()/**/__VA_OPT__()
#define H5B(X) a ## X ## b
#define H5C(X) H5B(X)
H5C(H5A()) // replaced byab
—end example]
15.7.3 The # operator [cpp.stringize]
1 Each # preprocessing token in the replacement list for a function-like macro shall be followed by a parameter
as the next preprocessing token in the replacement list.
2 A character string literal is a string-literal with no prefix. If, in the replacement list, a parameter is
immediately preceded by a# preprocessing token, both are replaced by a single character string literal
preprocessing token that contains the spelling of the preprocessing token sequence for the corresponding
argument (excluding placemarker tokens). Let thestringizing argumentbe the preprocessing token sequence
for the corresponding argument with placemarker tokens removed. Each occurrence of whitespace between
the stringizing argument’s preprocessing tokens becomes a single space character in the character string
literal. Whitespace before the first preprocessing token and after the last preprocessing token comprising the
stringizing argument is deleted. Otherwise, the original spelling of each preprocessing token in the stringizing
argument is retained in the character string literal, except for special handling for producing the spelling of
header-names, character-literals, andstring-literals (including the delimitingu+0022 quotation mark("))
contained within the preprocessing token: au+005c reverse soliduscharacter (\) is inserted before each
u+0022 quotation markand u+005c reverse soliduscharacter of aheader-name, character-literal, or
string-literal, and each new-line character is replaced by the two-character sequence\n. If the replacement
that results is not a valid character string literal, the program is ill-formed. The character string literal
§ 15.7.3 © ISO/IEC
527

===== PAGE 539 =====

Dxxxx
corresponding to an empty stringizing argument is"". The order of evaluation of# and ## operators is
unspecified.
15.7.4 The ## operator [cpp.concat]
1 A ## preprocessing token shall not occur at the beginning or at the end of a replacement list for either form
of macro definition.
2 If, in the replacement list of a function-like macro, a parameter is immediately preceded or followed by a##
preprocessing token, the parameter is replaced by the corresponding argument’s preprocessing token sequence;
however, if an argument consists of no preprocessing tokens, the parameter is replaced by a placemarker
preprocessing token instead.122
3 For both object-like and function-like macro invocations, before the replacement list is reexamined for more
macro names to replace, each instance of a## preprocessing token in the replacement list (not from an
argument) is deleted and the preceding preprocessing token is concatenated with the following preprocessing
token. Placemarker preprocessing tokens are handled specially: concatenation of two placemarkers results
in a single placemarker preprocessing token, and concatenation of a placemarker with a non-placemarker
preprocessing token results in the non-placemarker preprocessing token.
[Note 1: Concatenation can form auniversal-character-name (5.3.1). —end note]
If the result is not a valid preprocessing token, the program is ill-formed. The resulting preprocessing token
is available for further macro replacement. The order of evaluation of## operators is unspecified.
4 [Example 1: The sequence
#define str(s) # s
#define xstr(s) str(s)
#define debug(s, t) printf("x" # s "= %d, x" # t "= %s", \
x ## s, x ## t)
#define INCFILE(n) vers ## n
#define glue(a, b) a ## b
#define xglue(a, b) glue(a, b)
#define HIGHLOW "hello"
#define LOW LOW ", world"
debug(1, 2);
fputs(str(strncmp("abc\0d", "abc", '\4') // this goes away
== 0) str(: @\n), s);
#include xstr(INCFILE(2).h)
glue(HIGH, LOW);
xglue(HIGH, LOW)
results in
printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", '\\4') == 0" ": @\n", s);
#include "vers2.h" (after macro replacement, before file access)
"hello";
"hello" ", world"
or, after concatenation of the character string literals,
printf("x1= %d, x2= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", '\\4') == 0: @\n", s);
#include "vers2.h" (after macro replacement, before file access)
"hello";
"hello, world"
Space around the# and ## preprocessing tokens in the macro definition is optional.—end example]
5 [Example 2: In the following fragment:
#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)
char p[] = join(x, y); // equivalent tochar p[] = "x ## y";
122) Placemarker preprocessing tokens do not appear in the syntax because they are temporary entities that exist only within
translation phase 4.
§ 15.7.4 © ISO/IEC
528

===== PAGE 540 =====

Dxxxx
The expansion produces, at various stages:
join(x, y)
in_between(x hash_hash y)
in_between(x ## y)
mkstr(x ## y)
"x ## y"
In other words, expandinghash_hash produces a new preprocessing token, consisting of two adjacent sharp signs, but
this new preprocessing token is not the## operator. —end example]
6 [Example 3: To illustrate the rules for placemarker preprocessing tokens, the sequence
#define t(x,y,z) x ## y ## z
int j[] = { t(1,2,3), t(,4,5), t(6,,7), t(8,9,),
t(10,,), t(,11,), t(,,12), t(,,) };
results in
int j[] = { 123, 45, 67, 89,
10, 11, 12, };
—end example]
15.7.5 Rescanning and further replacement [cpp.rescan]
1 After all parameters in the replacement list have been substituted and# and ## processing has taken place, all
placemarker preprocessing tokens are removed. Then the resulting preprocessing token sequence is rescanned,
along with all subsequent preprocessing tokens of the source file, for more macro names to replace.
2 [Example 1: The sequence
#define x 3
#define f(a) f(x * (a))
#undef x
#define x 2
#define g f
#define z z[0]
#define h g( ~
#define m(a) a(w)
#define w 0,1
#define t(a) a
#define p() int
#define q(x) x
#define r(x,y) x ## y
#define str(x) # x
f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) & m
(f)^m(m);
p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };
results in
f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (~ 5)) & f(2 * (0,1))^m(0,1);
int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };
—end example]
3 If the name of the macro being replaced is found during this scan of the replacement list (not including the rest
of the source file’s preprocessing tokens), it is not replaced. Furthermore, if any nested replacements encounter
the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing
tokens are no longer available for further replacement even if they are later (re)examined in contexts in which
that macro name preprocessing token would otherwise have been replaced.
4 The resulting completely macro-replaced preprocessing token sequence is not processed as a preprocessing
directive even if it resembles one, but all pragma unary operator expressions within it are then processed as
specified in 15.13 below.
§ 15.7.5 © ISO/IEC
529

===== PAGE 541 =====

Dxxxx
15.7.6 Scope of macro definitions [cpp.scope]
1 A macro definition lasts (independent of block structure) until a corresponding#undefdirective is encountered
or (if none is encountered) until the end of the translation unit. Macro definitions have no significance after
translation phase 4.
2 A preprocessing directive of the form
# undef identifier new-line
causes the specified identifier no longer to be defined as a macro name. It is ignored if the specified identifier
is not currently defined as a macro name.
15.8 Line control [cpp.line]
line-directive:
# line pp-tokens new-line
1 The string-literal of a#line directive, if present, shall be a character string literal.
2 The line numberof the current source line is the line number of the current physical source line, i.e., it is
one greater than the number of new-line characters read or introduced in translation phase 1 (5.2) while
processing the source file to the current preprocessing token.
3 A preprocessing directive of the form
# line digit-sequence new-line
causes the implementation to behave as if the following sequence of source lines begins with a source line that
has a line number as specified by the digit sequence (interpreted as a decimal integer). If the digit sequence
specifies zero or a number greater than 2147483647, the program is ill-formed.
4 A preprocessing directive of the form
# line digit-sequence " s-char-sequenceopt " new-line
sets the presumed line number similarly and changes the presumed name of the source file to be the contents
of the character string literal.
5 A preprocessing directive of the form
# line pp-tokens new-line
(that does not match one of the two previous forms) is permitted. The preprocessing tokens afterline on the
directive are processed just as in normal text (each identifier currently defined as a macro name is replaced by
its replacement list of preprocessing tokens). If the directive resulting after all replacements does not match
one of the two previous forms, the program is ill-formed; otherwise, the result is processed as appropriate.
15.9 Diagnostic directives [cpp.error]
1 A preprocessing directive of the form
# error pp-tokensopt new-line
renders the program ill-formed. A preprocessing directive of the form
# warning pp-tokensopt new-line
requires the implementation to produce at least one diagnostic message for the preprocessing translation
unit (4.1.1).
2 Recommended practice: Any diagnostic message caused by either of these directives should include the
specified sequence of preprocessing tokens.
15.10 Pragma directive [cpp.pragma]
1 A preprocessing directive of the form
# pragma pp-tokensopt new-line
causes the implementation to behave in an implementation-defined manner. The behavior may cause
translation to fail or cause the translator or the resulting program to behave in a non-conforming manner.
Any pragma that is not recognized by the implementation is ignored.
15.11 Null directive [cpp.null]
1 A preprocessing directive of the form
§ 15.11 © ISO/IEC
530

===== PAGE 542 =====

Dxxxx
# new-line
has no effect.
15.12 Predefined macro names [cpp.predefined]
1 The following macro names shall be defined by the implementation:
__cplusplus
The integer literal202302L.
[Note 1: Future revisions of this document will replace the value of this macro with a greater value.—end
note]
The macro names listed in Table 22.
The macros defined in Table 22 shall be defined to the corresponding integer literal.
[Note 2: Future revisions of this document might replace the values of these macros with greater values.—end
note]
__DATE__
The date of translation of the source file: a character string literal of the form"Mmm dd yyyy", where
the names of the months are the same as those generated by theasctime function, and the first
character ofdd is a space character if the value is less than 10. If the date of translation is not available,
an implementation-defined valid date shall be supplied.
__FILE__
A character string literal representing the presumed name of the current source file.
[Note 3: The presumed source file name can be changed by the#line directive (15.8). —end note]
__LINE__
An integer literal representing the presumed line number of the current source line within the current
source file.
[Note 4: The presumed line number can be changed by the#line directive (15.8). —end note]
__STDC_EMBED_NOT_FOUND__, __STDC_EMBED_FOUND__, and__STDC_EMBED_EMPTY__
The integer literals0, 1, and2, respectively.
[Note 5: These represent values replaced fromhas-embed-expressions (15.2). —end note]
__STDC_HOSTED__
The integer literal1 if the implementation is a hosted implementation or the integer literal0 if it is a
freestanding implementation (4.1).
__STDCPP_DEFAULT_NEW_ALIGNMENT__
An integer literal of typestd::size_t whose value is the alignment guaranteed by a call tooperator
new(std::size_t) or operator new[](std::size_t).
[Note 6: Larger alignments will be passed tooperator new(std::size_t, std::align_val_t), etc. (7.6.2.8).
—end note]
__STDCPP_FLOAT16_T__
Defined as the integer literal1 if and only if the implementation supports the ISO/IEC 60559 floating-
point interchange format binary16 as an extended floating-point type (6.9.3).
__STDCPP_FLOAT32_T__
Defined as the integer literal1 if and only if the implementation supports the ISO/IEC 60559 floating-
point interchange format binary32 as an extended floating-point type.
__STDCPP_FLOAT64_T__
Defined as the integer literal1 if and only if the implementation supports the ISO/IEC 60559 floating-
point interchange format binary64 as an extended floating-point type.
__STDCPP_FLOAT128_T__
Defined as the integer literal1 if and only if the implementation supports the ISO/IEC 60559 floating-
point interchange format binary128 as an extended floating-point type.
§ 15.12 © ISO/IEC
531

===== PAGE 543 =====

Dxxxx
__STDCPP_BFLOAT16_T__
Defined as the integer literal1 if and only if the implementation supports an extended floating-point
type with the properties of thetypedef-name std::bfloat16_t as described in 6.9.3.
__TIME__
The time of translation of the source file: a character string literal of the form"hh:mm:ss" as in the time
generated by theasctime function. If the time of translation is not available, an implementation-defined
valid time shall be supplied.
Table 22 — Feature-test macros [tab:cpp.predefined.ft]
Macro name Value
__cpp_aggregate_bases 201603L
__cpp_aggregate_nsdmi 201304L
__cpp_aggregate_paren_init 201902L
__cpp_alias_templates 200704L
__cpp_aligned_new 201606L
__cpp_attributes 200809L
__cpp_auto_cast 202110L
__cpp_binary_literals 201304L
__cpp_capture_star_this 201603L
__cpp_char8_t 202207L
__cpp_concepts 202002L
__cpp_conditional_explicit 201806L
__cpp_consteval 202211L
__cpp_constexpr 202406L
__cpp_constexpr_dynamic_alloc 201907L
__cpp_constexpr_exceptions 202411L
__cpp_constexpr_in_decltype 201711L
__cpp_constexpr_virtual_inheritance 202506L
__cpp_constinit 201907L
__cpp_contracts 202502L
__cpp_decltype 200707L
__cpp_decltype_auto 201304L
__cpp_deduction_guides 202207L
__cpp_delegating_constructors 200604L
__cpp_deleted_function 202403L
__cpp_designated_initializers 201707L
__cpp_enumerator_attributes 201411L
__cpp_expansion_statements 202506L
__cpp_explicit_this_parameter 202110L
__cpp_fold_expressions 201603L
__cpp_generic_lambdas 201707L
__cpp_guaranteed_copy_elision 201606L
__cpp_hex_float 201603L
__cpp_if_consteval 202106L
__cpp_if_constexpr 201606L
__cpp_impl_coroutine 201902L
__cpp_impl_destroying_delete 201806L
__cpp_impl_reflection 202506L
__cpp_impl_three_way_comparison 201907L
__cpp_implicit_move 202207L
__cpp_inheriting_constructors 201511L
__cpp_init_captures 201803L
__cpp_initializer_lists 200806L
__cpp_inline_variables 201606L
__cpp_lambdas 200907L
§ 15.12 © ISO/IEC
532

===== PAGE 544 =====

Dxxxx
Table 22 — Feature-test macros (continued)
Name Value
__cpp_modules 201907L
__cpp_multidimensional_subscript 202211L
__cpp_named_character_escapes 202207L
__cpp_namespace_attributes 201411L
__cpp_noexcept_function_type 201510L
__cpp_nontype_template_args 201911L
__cpp_nontype_template_parameter_auto 201606L
__cpp_nsdmi 200809L
__cpp_pack_indexing 202311L
__cpp_placeholder_variables 202306L
__cpp_pp_embed 202502L
__cpp_range_based_for 202211L
__cpp_raw_strings 200710L
__cpp_ref_qualifiers 200710L
__cpp_return_type_deduction 201304L
__cpp_rvalue_references 200610L
__cpp_size_t_suffix 202011L
__cpp_sized_deallocation 201309L
__cpp_static_assert 202306L
__cpp_static_call_operator 202207L
__cpp_structured_bindings 202411L
__cpp_template_parameters 202502L
__cpp_template_template_args 201611L
__cpp_threadsafe_static_init 200806L
__cpp_trivial_union 202502L
__cpp_unicode_characters 200704L
__cpp_unicode_literals 200710L
__cpp_user_defined_literals 200809L
__cpp_using_enum 201907L
__cpp_variable_templates 201304L
__cpp_variadic_friend 202403L
__cpp_variadic_templates 200704L
__cpp_variadic_using 201611L
2 The following macro names are conditionally defined by the implementation:
__STDC__
Whether __STDC__ is predefined and if so, what its value is, are implementation-defined.
__STDC_MB_MIGHT_NEQ_WC__
The integer literal1, intended to indicate that, in the encoding forwchar_t, a member of the basic
character set need not have a code value equal to its value when used as the lone character in an
ordinary character literal.
__STDC_VERSION__
Whether __STDC_VERSION__ is predefined and if so, what its value is, are implementation-defined.
__STDC_ISO_10646__
An integer literal of the formyyyymmL (for example, 199712L). Whether __STDC_ISO_10646__ is
predefined and if so, what its value is, are implementation-defined.
__STDCPP_THREADS__
Defined, and has the value integer literal 1, if and only if a program can have more than one thread of
execution (6.10.2).
§ 15.12 © ISO/IEC
533

===== PAGE 545 =====

Dxxxx
3 The values of the predefined macros (except for__FILE__ and __LINE__) remain constant throughout the
translation unit.
4 If any of the pre-defined macro names in this subclause, or the identifierdefined, is the subject of a#define
or a#undef preprocessing directive, the program is ill-formed. Any other predefined macro names shall begin
with a leading underscore followed by an uppercase letter or a second underscore.
15.13 Pragma operator [cpp.pragma.op]
1 A unary operator expression of the form
_Pragma ( string-literal )
is processed as follows: Thestring-literal is destringized by deleting anyencoding-prefix, deleting the leading
and trailing double-quotes, replacing each escape sequence\" by a double-quote, and replacing each escape
sequence \\ by a single backslash. The resulting sequence of characters is processed through translation
phase 3 to produce preprocessing tokens that are executed as if they were thepp-tokens in a pragma directive.
The original four preprocessing tokens in the unary operator expression are removed.
2 [Example 1:
#pragma listing on "..\listing.dir"
can also be expressed as:
_Pragma ( "listing on \"..\\listing.dir\"" )
The latter form is processed in the same way whether it appears literally as shown, or results from macro replacement,
as in:
#define LISTING(x) PRAGMA(listing on #x)
#define PRAGMA(x) _Pragma(#x)
LISTING( ..\listing.dir )
—end example]
§ 15.13 © ISO/IEC
534

===== PAGE 546 =====

Dxxxx
16 Library introduction [library]
16.1 General [library.general]
1 This Clause describes the contents of theC++ standard library, how a well-formed C++ program makes use
of the library, and how a conforming implementation may provide the entities in the library.
2 The following subclauses describe the method of description (16.3) and organization (16.4.2) of the library.
16.4, Clause 17 through Clause 33, and Annex D specify the contents of the library, as well as library
requirements and constraints on both well-formed C++ programs and conforming implementations.
3 Detailed specifications for each of the components in the library are in Clause 17–Clause 33, as shown in
Table 23.
Table 23 — Library categories [tab:library.categories]
Clause Category
Clause 17 Language support library
Clause 18 Concepts library
Clause 19 Diagnostics library
Clause 20 Memory management library
Clause 21 Metaprogramming library
Clause 22 General utilities library
Clause 23 Containers library
Clause 24 Iterators library
Clause 25 Ranges library
Clause 26 Algorithms library
Clause 27 Strings library
Clause 28 Text processing library
Clause 29 Numerics library
Clause 30 Time library
Clause 31 Input/output library
Clause 32 Concurrency support library
Clause 33 Execution control library
4 The operating system interface described in ISO/IEC/IEEE 9945:2009 is hereinafter calledPOSIX.
5 The language support library (Clause 17) provides components that are required by certain parts of the C++
language, such as memory allocation (7.6.2.8, 7.6.2.9) and exception processing (Clause 14).
6 The concepts library (Clause 18) describes library components that C++ programs may use to perform
compile-time validation of template arguments and perform function dispatch based on properties of types.
7 The diagnostics library (Clause 19) provides a consistent framework for reporting errors in a C++ program,
including predefined exception classes.
8 The memory management library (Clause 20) provides components for memory management, including smart
pointers and scoped allocators.
9 The metaprogramming library (Clause 21) describes facilities for use in templates and during constant
evaluation, including type traits, integer sequences, and rational arithmetic.
10 The general utilities library (Clause 22) includes components used by other library elements, such as a
predefined storage allocator for dynamic storage management (6.8.6.5), and components used as infrastructure
in C++ programs, such as tuples and function wrappers.
11 The containers (Clause 23), iterators (Clause 24), ranges (Clause 25), and algorithms (Clause 26) libraries
provide a C++ program with access to a subset of the most widely used algorithms and data structures.
§ 16.1 © ISO/IEC
535

===== PAGE 547 =====

Dxxxx
12 The strings library (Clause 27) provides support for manipulating sequences of typechar, sequences of
type char8_t, sequences of typechar16_t, sequences of typechar32_t, sequences of typewchar_t, and
sequences of any other character-like type.
13 The text processing library (Clause 28) provides support for text processing, including formatting, interna-
tionalization support and regular expression matching and searching.
14 The numerics library (Clause 29) provides numeric algorithms and complex number components that extend
support for numeric processing. The valarray component provides support forn-at-a-time processing,
potentially implemented as parallel operations on platforms that support such processing. The random
number component provides facilities for generating pseudo-random numbers.
15 The time library (Clause 30) provides generally useful time utilities.
16 The input/output library (Clause 31) provides theiostream components that are the primary mechanism
for C++ program input and output. They can be used with other elements of the library, particularly strings,
locales, and iterators.
17 The concurrency support library (Clause 32) provides components to create and manage threads, including
atomic operations, mutual exclusion, and interthread communication.
18 The execution control library (Clause 33) provides components supporting execution of function objects.
16.2 The C standard library [library.c]
1 The C++ standard library also makes available the facilities of the C standard library, suitably adjusted to
ensure static type safety.
2 The descriptions of many library functions rely on the C standard library for the semantics of those functions.
In some cases, the signatures specified in this document may be different from the signatures in the C
standard library, and additional overloads may be declared in this document, but the behavior and the
preconditions (including any preconditions implied by the use of a Crestrict qualifier) are the same unless
otherwise stated.
3 A call to a C standard library function is a non-constant library call (3.35) if it raises a floating-point
exception other thanFE_INEXACT. The semantics of a call to a C standard library function evaluated as a
core constant expression are those specified in ISO/IEC 9899:2024, Annex F123 to the extent applicable to
the floating-point types (6.9.2) that are parameter types of the called function.
[Note 1: ISO/IEC 9899:2024, Annex F specifies the conditions under which floating-point exceptions are raised and
the behavior when NaNs and/or infinities are passed as arguments.—end note]
[Note 2: Equivalently, a call to a C standard library function is a non-constant library call iferrno is set when
math_errhandling & MATH_ERRNO is true. —end note]
16.3 Method of description [description]
16.3.1 General [description.general]
1 Subclause 16.3 describes the conventions used to specify the C++ standard library. 16.3.2 describes the
structure of Clause 17 through Clause 33 and Annex D. 16.3.3 describes other editorial conventions.
16.3.2 Structure of each clause [structure]
16.3.2.1 Elements [structure.elements]
1 Each library clause contains the following elements, as applicable:124
—(1.1) Summary
—(1.2) Requirements
—(1.3) Detailed specifications
—(1.4) References to the C standard library
123) See also ISO/IEC 9899:2024, 7.6.
124) To save space, items that do not apply to a Clause are omitted. For example, if a Clause does not specify any requirements,
there will be no “Requirements” subclause.
§ 16.3.2.1 © ISO/IEC
536

===== PAGE 548 =====

Dxxxx
16.3.2.2 Summary [structure.summary]
1 The Summary provides a synopsis of the category, and introduces the first-level subclauses. Each subclause
also provides a summary, listing the headers specified in the subclause and the library entities provided in
each header.
2 The contents of the summary and the detailed specifications include:
—(2.1) macros
—(2.2) values
—(2.3) types and alias templates
—(2.4) classes and class templates
—(2.5) functions and function templates
—(2.6) objects and variable templates
—(2.7) concepts
16.3.2.3 Requirements [structure.requirements]
1 Requirements describe constraints that shall be met by a C++ program that extends the standard library.
Such extensions are generally one of the following:
—(1.1) Template arguments
—(1.2) Derived classes
—(1.3) Containers, iterators, and algorithms that meet an interface convention or model a concept
2 The string and iostream components use an explicit representation of operations required of template
arguments. They use a class templatechar_traits to define these constraints.
3 Interface convention requirements are stated as generally as possible. Instead of stating “classX has to define
a member functionoperator++()”, the interface requires “for any objectx of classX, ++x is defined”. That
is, whether the operator is a member is unspecified.
4 Requirements are stated in terms of well-defined expressions that define valid terms of the types that meet
the requirements. For every set of well-defined expression requirements there is either a named concept or a
table that specifies an initial set of the valid expressions and their semantics. Any generic algorithm (Clause
26) that uses the well-defined expression requirements is described in terms of the valid expressions for its
template type parameters.
5 The library specification uses a typographical convention for naming requirements. Names initalic type that
begin with the prefixCpp17 refer to sets of well-defined expression requirements typically presented in tabular
form, possibly with additional prose semantic requirements. For example,Cpp17Destructible (Table 35) is
such a named requirement. Names inconstant width type refer to library concepts which are presented
as a concept definition (Clause 13), possibly with additional prose semantic requirements. For example,
destructible (18.4.10) is such a named requirement.
6 Template argument requirements are sometimes referenced by name. See 16.3.3.3.
7 In some cases the semantic requirements are presented as C++ code. Such code is intended as a specification
of equivalence of a construct to another construct, not necessarily as the way the construct must be
implemented.125
8 Required operations of any concept defined in this document need not be total functions; that is, some
arguments to a required operation may result in the required semantics failing to be met.
[Example 1: The required< operator of thetotally_ordered concept (18.5.5) does not meet the semantic requirements
of that concept when operating on NaNs.—end example]
This does not affect whether a type models the concept.
9 A declaration may explicitly impose requirements through its associated constraints (13.5.3). When the
associated constraints refer to a concept (13.7.9), the semantic constraints specified for that concept are
additionally imposed on the use of the declaration.
125) Although in some cases the code given is unambiguously the optimum implementation.
§ 16.3.2.3 © ISO/IEC
537

===== PAGE 549 =====

Dxxxx
16.3.2.4 Detailed specifications [structure.specifications]
1 The detailed specifications each contain the following elements:
—(1.1) name and brief description
—(1.2) synopsis (class definition or function declaration, as appropriate)
—(1.3) restrictions on template arguments, if any
—(1.4) description of class invariants
—(1.5) description of function semantics
2 Descriptions of class member functions follow the order (as appropriate):126
—(2.1) constructor(s) and destructor
—(2.2) copying, moving & assignment functions
—(2.3) comparison operator functions
—(2.4) modifier functions
—(2.5) observer functions
—(2.6) operators and other non-member functions
3 Descriptions of function semantics contain the following elements (as appropriate):127
—(3.1) Constraints: the conditions for the function’s participation in overload resolution (12.2).
[Note 1: Failure to meet such a condition results in the function’s silent non-viability.—end note]
[Example 1: An implementation can express such a condition via aconstraint-expression (13.5.3). —end
example]
—(3.2) Mandates: the conditions that, if not met, render the program ill-formed.
[Example 2: An implementation can express such a condition via theconstant-expression in astatic_assert-
declaration (9.1). If the diagnostic is to be emitted only after the function has been selected by overload
resolution, an implementation can express such a condition via aconstraint-expression (13.5.3) and also define
the function as deleted.—end example]
—(3.3) Constant When: the conditions that are required for a call to the function to be a constant subexpression
(3.15).
—(3.4) Preconditions: conditions that the function assumes to hold whenever it is called; violation of any
preconditions results in undefined behavior.
[Example 3: An implementation can express some such conditions via the use of a contract assertion, such as a
precondition assertion (9.4.1). —end example]
—(3.5) Hardened preconditions: conditions that the function assumes to hold whenever it is called.
—(3.5.1) When invoking the function in a hardened implementation, prior to any other observable side
effects of the function, contract assertions whose predicates are as described in the hardened
precondition are evaluated with a terminating semantic (6.11.2).
—(3.5.2) When invoking the function in a non-hardened implementation, if any hardened precondition is
violated, the program has undefined behavior.
—(3.6) Effects: the actions performed by the function.
—(3.7) Synchronization: the synchronization operations (6.10.2) applicable to the function.
—(3.8) Postconditions: the conditions (sometimes termed observable results) established by the function.
[Example 4: An implementation can express some such conditions via the use of a contract assertion, such as a
postcondition assertion (9.4.1). —end example]
—(3.9) Result: for atypename-specifier, a description of the named type; for anexpression, a description of the
type and value category of the expression; the expression is an lvalue if the type is an lvalue reference
type, an xvalue if the type is an rvalue reference type, and a prvalue otherwise.
126) To save space, items that do not apply to a class are omitted. For example, if a class does not specify any comparison
operator functions, there will be no “Comparison operator functions” subclause.
127) To save space, elements that do not apply to a function are omitted. For example, if a function specifies no preconditions,
there will be noPreconditions: element.
§ 16.3.2.4 © ISO/IEC
538

===== PAGE 550 =====

Dxxxx
—(3.10) Returns: a description of the value(s) returned by the function.
—(3.11) Throws: any exceptions thrown by the function, and the conditions that would cause the exception.
—(3.12) Complexity: the time and/or space complexity of the function.
—(3.13) Remarks: additional semantic constraints on the function.
—(3.14) Error conditions: the error conditions for error codes reported by the function.
4 Whenever theEffects element specifies that the semantics of some functionF are Equivalent tosome code
sequence, then the various elements are interpreted as follows. IfF’s semantics specifies anyConstraints
or Mandates elements, then those requirements are logically imposed prior to theequivalent-to semantics.
Next, the semantics of the code sequence are determined by theConstraints, Mandates, Constant When,
Preconditions, Hardened preconditions, Effects, Synchronization, Postconditions, Returns, Throws, Complexity,
Remarks, andError conditionsspecified for the function invocations contained in the code sequence. The
value returned fromF is specified byF’s Returns element, or ifF has noReturns element, a non-void return
from F is specified by thereturn statements (8.8.4) in the code sequence. IfF’s semantics contains aThrows,
Postconditions, orComplexity element, then that supersedes any occurrences of that element in the code
sequence.
5 For non-reserved replacement and handler functions, Clause 17 specifies two behaviors for the functions in
question: their required and default behavior. Thedefault behaviordescribes a function definition provided
by the implementation. Therequired behaviordescribes the semantics of a function definition provided by
either the implementation or a C++ program. Where no distinction is explicitly made in the description, the
behavior described is the required behavior.
6 If the formulation of a complexity requirement calls for a negative number of operations, the actual requirement
is zero operations.128
7 Complexity requirements specified in the library clauses are upper bounds, and implementations that provide
better complexity guarantees meet the requirements.
8 Error conditions specify conditions where a function may fail. The conditions are listed, together with a
suitable explanation, as theenum class errc constants (19.5).
16.3.2.5 C library [structure.see.also]
1 Paragraphs labeled “See also” contain cross-references to the relevant portions of other standards (Clause
2).
16.3.3 Other conventions [conventions]
16.3.3.1 General [conventions.general]
1 Subclause 16.3.3 describes several editorial conventions used to describe the contents of the C++ standard
library. These conventions are for describing implementation-defined types (16.3.3.3), and member functions
(16.3.3.5).
16.3.3.2 Exposition-only entities, etc. [expos.only.entity]
1 Several entities defined in Clause 17 through Clause 33 and Annex D are only defined for the purpose of
exposition. The declaration of such an entity is followed by a comment ending inexposition only.
2 The following are defined for exposition only to aid in the specification of the library:
namespace std {
template<class T>
requires convertible_to<T, decay_t<T>>
constexpr decay_t<T> decay-copy(T&& v) // exposition only
noexcept(is_nothrow_convertible_v<T, decay_t<T>>)
{ return std::forward<T>(v); }
constexpr auto synth-three-way = // exposition only
[]<class T, class U>(const T& t, const U& u)
requires requires {
{ t < u } -> boolean-testable ;
{ u < t } -> boolean-testable ;
}
128) This simplifies the presentation of complexity requirements in some cases.
§ 16.3.3.2 © ISO/IEC
539

===== PAGE 551 =====

Dxxxx
{
if constexpr (three_way_comparable_with<T, U>) {
return t <=> u;
} else {
if (t < u) return weak_ordering::less;
if (u < t) return weak_ordering::greater;
return weak_ordering::equivalent;
}
};
template<class T, class U = T>
using synth-three-way-result = // exposition only
decltype(synth-three-way(declval<T&>(), declval<U&>()));
}
3 An objectdst is said to bedecay-copied froma subexpressionsrc if the type ofdst is
decay_t<decltype((src))>
and dst is copy-initialized fromsrc.
16.3.3.3 Type descriptions [type.descriptions]
16.3.3.3.1 General [type.descriptions.general]
1 The Requirements subclauses may describe names that are used to specify constraints on template argu-
ments.129 These names are used in library Clauses to describe the types that may be supplied as arguments
by a C++ program when instantiating template components from the library.
2 Certain types defined in Clause 31 are used to describe implementation-defined types. They are based on
other types, but with added constraints.
16.3.3.3.2 Enumerated types [enumerated.types]
1 Several types defined in Clause 31 areenumerated types. Each enumerated type may be implemented as an
enumeration or as a synonym for an enumeration.130
2 The enumerated typeenumerated can be written:
enum enumerated { V 0, V 1, V 2, V 3, ... };
inline const enumerated C 0(V 0);
inline const enumerated C 1(V 1);
inline const enumerated C 2(V 2);
inline const enumerated C 3(V 3);
...
3 Here, the namesC 0, C 1, etc. representenumerated elementsfor this particular enumerated type. All such
elements have distinct values.
16.3.3.3.3 Bitmask types [bitmask.types]
1 Several types defined in Clause 17 through Clause 33 and Annex D arebitmask types. Each bitmask type
can be implemented as an enumerated type that overloads certain operators, as an integer type, or as a
bitset (22.9.2).
2 The bitmask typebitmask can be written:
// For exposition only.
// int_type is an integral type capable of representing all values of the bitmask type.
enum bitmask : int_type {
V 0 = 1 << 0, V 1 = 1 << 1, V 2 = 1 << 2, V 3 = 1 << 3, ...
};
129) Examples from 16.4.4 include:Cpp17EqualityComparable, Cpp17LessThanComparable, Cpp17CopyConstructible. Examples
from 24.3 include:Cpp17InputIterator, Cpp17ForwardIterator.
130) Such as an integer type, with constant integer values (6.9.2).
§ 16.3.3.3.3 © ISO/IEC
540

===== PAGE 552 =====

Dxxxx
inline constexpr bitmask C 0(V 0);
inline constexpr bitmask C 1(V 1);
inline constexpr bitmask C 2(V 2);
inline constexpr bitmask C 3(V 3);
...
constexpr bitmask operator&(bitmask X, bitmask Y) {
return static_cast<bitmask >(
static_cast<int_type>(X) & static_cast<int_type>(Y));
}
constexpr bitmask operator|(bitmask X, bitmask Y) {
return static_cast<bitmask >(
static_cast<int_type>(X) | static_cast<int_type>(Y));
}
constexpr bitmask operator^(bitmask X, bitmask Y) {
return static_cast<bitmask >(
static_cast<int_type>(X) ^ static_cast<int_type>(Y));
}
constexpr bitmask operator~(bitmask X) {
return static_cast<bitmask >(~static_cast<int_type>(X));
}
bitmask & operator&=(bitmask & X, bitmask Y) {
X = X & Y; return X;
}
bitmask & operator|=(bitmask & X, bitmask Y) {
X = X | Y; return X;
}
bitmask & operator^=(bitmask & X, bitmask Y) {
X = X ^ Y; return X;
}
3 Here, the namesC 0, C 1, etc. representbitmask elementsfor this particular bitmask type. All such elements
have distinct, nonzero values such that, for any pairC i and C j where i̸= j, Ci & Ci is nonzero andCi & Cj
is zero. Additionally, the value0 is used to represent anempty bitmask, in which no bitmask elements are set.
4 The following terms apply to objects and values of bitmask types:
—(4.1) To set a valueY in an objectX is to evaluate the expressionX |= Y.
—(4.2) To clear a valueY in an objectX is to evaluate the expressionX &= ~Y.
—(4.3) The valueY is setin the objectX if the expressionX & Y is nonzero.
16.3.3.3.4 Character sequences [character.seq]
16.3.3.3.4.1 General [character.seq.general]
1 The C standard library makes widespread use of characters and character sequences that follow a few uniform
conventions:
—(1.1) Properties specified aslocale-specificmay change during program execution by a call tosetlocale(int,
const char*) (28.3.5.1), or by a change to alocale object, as described in 28.3.3 and Clause 31.
—(1.2) The execution character setand the execution wide-character setare supersets of the basic literal
character set (5.3.1). The encodings of the execution character sets and the sets of additional elements
(if any) are locale-specific. Each element of the execution wide-character set is encoded as a single code
unit representable by a value of typewchar_t.
[Note 1: The encodings of the execution character sets can be unrelated to any literal encoding.—end note]
—(1.3) A letter is any of the 26 lowercase or 26 uppercase letters in the basic character set.
—(1.4) The decimal-point characteris the locale-specific (single-byte) character used by functions that convert
between a (single-byte) character sequence and a value of one of the floating-point types. It is used
in the character sequence to denote the beginning of a fractional part. It is represented in Clause 17
through Clause 33 and Annex D by a period,’.’, which is also its value in the"C" locale.
—(1.5) A character sequenceis an array object (9.3.4.5)A that can be declared asT A[N ], whereT is any of
the typeschar, unsigned char, orsigned char (6.9.2), optionally qualified by any combination of
§ 16.3.3.3.4 © ISO/IEC
541

===== PAGE 553 =====

Dxxxx
const or volatile. The initial elements of the array have defined contents up to and including an
element determined by some predicate. A character sequence can be designated by a pointer valueS
that points to its first element.
—(1.6) Let STATICALLY-WIDEN <charT>("...") be "..." if charT is char and L"..." if charT is wchar_t.
16.3.3.3.4.2 Byte strings [byte.strings]
1 A null-terminated byte string, orntbs, is a character sequence whose highest-addressed element with defined
content has the value zero (theterminating null character); no other element in the sequence has the value
zero.131
2 The length of anntbs is the number of elements that precede the terminating null character. Anempty
ntbs has a length of zero.
3 The value of anntbs is the sequence of values of the elements up to and including the terminating null
character.
4 A static ntbs is anntbs with static storage duration.132
16.3.3.3.4.3 Multibyte strings [multibyte.strings]
1 A multibyte characteris a sequence of one or more bytes representing the code unit sequence for an encoded
character of the execution character set.
2 A null-terminated multibyte string, or ntmbs, is anntbs that constitutes a sequence of valid multibyte
characters, beginning and ending in the initial shift state.133
3 A static ntmbs is anntmbs with static storage duration.
16.3.3.3.5 Customization Point Object types [customization.point.object]
1 A customization point object is a function object (22.10) with a literal class type that interacts with
program-defined types while enforcing semantic requirements on that interaction.
2 The type of a customization point object, ignoring cv-qualifiers, shall modelsemiregular (18.6) and shall
be a structural type (13.2) and a trivially copyable type (11.2). Every constructor of this type shall have a
non-throwing exception specification (14.5).
3 All instances of a specific customization point object type shall be equal (18.2). The effects of invoking
different instances of a specific customization point object type on the same arguments are equivalent.
4 The typeT of a customization point object, ignoringcv-qualifiers, shall modelinvocable<T&, Args...>,
invocable<const T&, Args...>, invocable<T, Args...>, andinvocable<const T, Args...> (18.7.2)
when the types inArgs... meet the requirements specified in that customization point object’s definition.
When the types ofArgs... do not meet the customization point object’s requirements,T shall not have a
function call operator that participates in overload resolution.
5 For a given customization point objecto, letp be a variable initialized as if byauto p = o;. Then for any
sequence of argumentsargs..., the following expressions have effects equivalent too(args...):
—(5.1) p(args...)
—(5.2) as_const(p)(args...)
—(5.3) std::move(p)(args...)
—(5.4) std::move(as_const(p))(args...)
16.3.3.4 Algorithm function objects [alg.func.obj]
1 An algorithm function objectis a customization point object (16.3.3.3.5) that is specified as one or more
overloaded function templates. The name of these function templates designates the corresponding algorithm
function object.
2 For an algorithm function objecto, let S be the corresponding set of function templates. Then for any
sequence of argumentsargs... , o(args... ) is expression-equivalent tos(args... ), where the result of
name lookup fors is the overload setS.
131) Many of the objects manipulated by function signatures declared in<cstring> (27.5.1) are character sequences orntbss.
The size of some of these character sequences is limited by a length value, maintained separately from the character sequence.
132) A string-literal, such as"abc", is a staticntbs.
133) An ntbs that contains characters only from the basic literal character set is also anntmbs. Each multibyte character then
consists of a single byte.
§ 16.3.3.4 © ISO/IEC
542

===== PAGE 554 =====

Dxxxx
[Note 1: Algorithm function objects are not found by argument-dependent name lookup (6.5.4). When found by
unqualified name lookup (6.5.3) for thepostfix-expression in a function call (7.6.1.3), they inhibit argument-dependent
name lookup.
[Example 1:
void foo() {
using namespace std::ranges;
std::vector<int> vec{1,2,3};
find(begin(vec), end(vec), 2); // #1
}
The function call expression at #1 invokesstd::ranges::find, notstd::find. —end example]
—end note]
16.3.3.5 Functions within classes [functions.within.classes]
1 For the sake of exposition, Clause 17 through Clause 33 and Annex D do not describe copy/move constructors,
assignment operators, or (non-virtual) destructors with the same apparent semantics as those that can be
generated by default (11.4.5.3, 11.4.6, 11.4.7). It is unspecified whether the implementation provides explicit
definitions for such member function signatures, or for virtual destructors that can be generated by default.
16.3.3.6 Private members [objects.within.classes]
1 Clause 17 through Clause 33 and Annex D do not specify the representation of classes, and intentionally omit
specification of class members (11.4). An implementation may define static or non-static class members, or
both, as needed to implement the semantics of the member functions specified in Clause 17 through Clause
33 and Annex D.
2 For the sake of exposition, some subclauses provide representative declarations, and semantic requirements,
for private members of classes that meet the external specifications of the classes. The declarations for such
members are followed by a comment that ends withexposition only, as in:
streambuf* sb; // exposition only
3 An implementation may use any technique that provides equivalent observable behavior.
16.3.3.7 Freestanding items [freestanding.item]
1 A freestanding item is a declaration, entity, or macro that is required to be present in a freestanding
implementation and a hosted implementation.
2 Unless otherwise specified, the requirements on freestanding items for a freestanding implementation are the
same as the corresponding requirements for a hosted implementation, except that not all of the members of
those items are required to be present.
3 Function declarations and function template declarations followed by a comment that includefreestanding-
deleted are freestanding deleted functions. On freestanding implementations, it is implementation-defined
whether each entity introduced by a freestanding deleted function is a deleted function (9.6.3) or whether the
requirements are the same as the corresponding requirements for a hosted implementation.
[Note 1: Deleted definitions reduce the chance of overload resolution silently changing when migrating from a
freestanding implementation to a hosted implementation.—end note]
[Example 1:
double abs(double j); // freestanding-deleted
—end example]
4 A declaration in a synopsis is a freestanding item if
—(4.1) it is followed by a comment that includesfreestanding,
—(4.2) it is followed by a comment that includesfreestanding-deleted, or
—(4.3) the header synopsis begins with a comment that includesfreestandingand the declaration is not followed
by a comment that includeshosted.
[Note 2: Declarations followed byhosted in freestanding headers are not freestanding items. As a result, looking
up the name of such functions can vary between hosted and freestanding implementations.—end note]
§ 16.3.3.7 © ISO/IEC
543

===== PAGE 555 =====

Dxxxx
[Example 2:
// all freestanding
namespace std {
—end example]
5 An entity or deduction guide is a freestanding item if its introducing declaration is not followed by a comment
that includeshosted, and is:
—(5.1) introduced by a declaration that is a freestanding item,
—(5.2) a member of a freestanding item other than a namespace,
—(5.3) an enumerator of a freestanding item,
—(5.4) a deduction guide of a freestanding item,
—(5.5) an enclosing namespace of a freestanding item,
—(5.6) a friend of a freestanding item,
—(5.7) denoted by a type alias that is a freestanding item, or
—(5.8) denoted by an alias template that is a freestanding item.
6 A macro is a freestanding item if it is defined in a header synopsis and
—(6.1) the definition is followed by a comment that includesfreestanding, or
—(6.2) the header synopsis begins with a comment that includesfreestanding and the definition is not followed
by a comment that includeshosted.
[Example 3:
#define NULL see below // freestanding
—end example]
7 [Note 3: Freestanding annotations follow some additional exposition conventions that do not impose any additional
normative requirements. Header synopses that begin with a comment containing "all freestanding" contain no
hosted items and no freestanding deleted functions. Header synopses that begin with a comment containing "mostly
freestanding" contain at least one hosted item or freestanding deleted function. Classes and class templates followed
by a comment containing "partially freestanding" contain at least one hosted item or freestanding deleted function.
—end note]
[Example 4:
template<class T, size_t N> struct array; // partially freestanding
template<class T, size_t N>
struct array {
constexpr reference operator[](size_type n);
constexpr const_reference operator[](size_type n) const;
constexpr reference at(size_type n); // freestanding-deleted
constexpr const_reference at(size_type n) const; // freestanding-deleted
};
—end example]
16.4 Library-wide requirements [requirements]
16.4.1 General [requirements.general]
1 Subclause 16.4 specifies requirements that apply to the entire C++ standard library. Clause 17 through
Clause 33 and Annex D specify the requirements of individual entities within the library.
2 Requirements specified in terms of interactions between threads do not apply to programs having only a
single thread of execution.
3 16.4.2 describes the library’s contents and organization, 16.4.3 describes how well-formed C++ programs gain
access to library entities, 16.4.4 describes constraints on types and functions used with the C++ standard
library, 16.4.5 describes constraints on well-formed C++ programs, and 16.4.6 describes constraints on
conforming implementations.
§ 16.4.1 © ISO/IEC
544

===== PAGE 556 =====

Dxxxx
16.4.2 Library contents and organization [organization]
16.4.2.1 General [organization.general]
1 16.4.2.2 describes the entities and macros defined in the C++ standard library. 16.4.2.3 lists the standard library
headers and some constraints on those headers. 16.4.2.5 lists requirements for a freestanding implementation
of the C++ standard library.
16.4.2.2 Library contents [contents]
1 The C++ standard library provides definitions for the entities and macros described in the synopses of the
C++ standard library headers (16.4.2.3), unless otherwise specified.
2 All library entities exceptoperator new and operator delete are defined within the namespacestd or
namespaces nested within namespacestd.134 It is unspecified whether names declared in a specific namespace
are declared directly in that namespace or in an inline namespace inside that namespace.135
3 Whenever an unqualified name other thanswap, make_error_code, make_error_condition, from_stream,
or submdspan_mapping is used in the specification of a declarationD in Clause 17 through Clause 33 or
Annex D, its meaning is established as-if by performing unqualified name lookup (6.5.3) in the context ofD.
[Note 1: Argument-dependent lookup is not performed.—end note]
Similarly, the meaning of aqualified-id is established as-if by performing qualified name lookup (6.5.5) in the
context ofD.
[Example 1: The reference tois_array_v in the specification ofstd::to_array (23.3.3.6) refers to::std::is_array_v.
—end example]
[Note 2: Operators in expressions (12.2.2.3) are not so constrained; see 16.4.6.4.—end note]
The meaning of the unqualified nameswap is established in an overload resolution context for swappable
values (16.4.4.3). The meanings of the unqualified namesmake_error_code, make_error_condition, from_-
stream, andsubmdspan_mapping are established as-if by performing argument-dependent lookup (6.5.4).
16.4.2.3 Headers [headers]
1 Each element of the C++ standard library is declared or defined (as appropriate) in aheader.136
2 The C++ standard library provides theC++ library headers, shown in Table 24.
3 The facilities of the C standard library are provided in the additional headers shown in Table 25.137
4 The headers listed in Table 24, or, for a freestanding implementation, the subset of such headers that are
provided by the implementation, are collectively known as theimportable C++ library headers.
[Note 1: Importable C++ library headers can be imported (10.3).—end note]
[Example 1:
import <vector>; // imports the<vector> header unit
std::vector<int> vi; // OK
—end example]
5 Except as noted in Clause 16 through Clause 33 and Annex D, the contents of each headercname is the
same as that of the corresponding headername.h as specified in the C standard library (Clause 2). In the
C++ standard library, however, the declarations (except for names which are defined as macros in C) are
within namespace scope (6.4.6) of the namespacestd. It is unspecified whether these names (including any
overloads added in Clause 17 through Clause 33 and Annex D) are first declared within the global namespace
scope and are then injected into namespacestd by explicitusing-declarations (9.10).
6 Names which are defined as macros in C shall be defined as macros in the C++ standard library, even if C
grants license for implementation as functions.
[Note 2: The names defined as macros in C include the following:assert, offsetof, setjmp, va_arg, va_end, and
va_start. —end note]
134) The C standard library headers (17.15) also define names within the global namespace, while the C++ headers for C library
facilities (16.4.2.3) can also define names within the global namespace.
135) This gives implementers freedom to use inline namespaces to support multiple configurations of the library.
136) A header is not necessarily a source file, nor are the sequences delimited by< and > in header names necessarily valid source
file names (15.3).
137) It is intentional that there is no C++ header for any of these C headers:<stdnoreturn.h>, <threads.h>.
§ 16.4.2.3 © ISO/IEC
545

===== PAGE 557 =====

Dxxxx
Table 24 — C++ library headers [tab:headers.cpp]
<algorithm>
<any>
<array>
<atomic>
<barrier>
<bit>
<bitset>
<charconv>
<chrono>
<compare>
<complex>
<concepts>
<condition_variable>
<contracts>
<coroutine>
<debugging>
<deque>
<exception>
<execution>
<expected>
<filesystem>
<flat_map>
<flat_set>
<format>
<forward_list>
<fstream>
<functional>
<future>
<generator>
<hazard_pointer>
<hive>
<initializer_list>
<inplace_vector>
<iomanip>
<ios>
<iosfwd>
<iostream>
<istream>
<iterator>
<latch>
<limits>
<linalg>
<list>
<locale>
<map>
<mdspan>
<memory>
<memory_resource>
<meta>
<mutex>
<new>
<numbers>
<numeric>
<optional>
<ostream>
<print>
<queue>
<random>
<ranges>
<ratio>
<rcu>
<regex>
<scoped_allocator>
<semaphore>
<set>
<shared_mutex>
<simd>
<source_location>
<span>
<spanstream>
<sstream>
<stack>
<stacktrace>
<stdexcept>
<stdfloat>
<stop_token>
<streambuf>
<string>
<string_view>
<syncstream>
<system_error>
<text_encoding>
<thread>
<tuple>
<type_traits>
<typeindex>
<typeinfo>
<unordered_map>
<unordered_set>
<utility>
<valarray>
<variant>
<vector>
<version>
Table 25 — C++ headers for C library facilities [tab:headers.cpp.c]
<cassert>
<cctype>
<cerrno>
<cfenv>
<cfloat>
<cinttypes>
<climits>
<clocale>
<cmath>
<csetjmp>
<csignal>
<cstdarg>
<cstddef>
<cstdint>
<cstdio>
<cstdlib>
<cstring>
<ctime>
<cuchar>
<cwchar>
<cwctype>
7 Names that are defined as functions in C shall be defined as functions in the C++ standard library.138
8 Identifiers that are keywords or operators in C++ shall not be defined as macros in C++ standard library
headers.139
9 Subclause 17.15 describes the effects of using thename.h (C header) form in a C++ program.140
10 ISO/IEC 9899:2024, Annex K describes a large number of functions, with associated types and macros, which
“promote safer, more secure programming” than many of the traditional C library functions. The names of
the functions have a suffix of_s; most of them provide the same service as the C library function with the
unsuffixed name, but generally take an additional argument whose value is the size of the result array. If any
C++ header is included, it is implementation-defined whether any of these names is declared in the global
namespace. (None of them is declared in namespacestd.)
11 Table 26 lists the Annex K names that may be declared in some header. These names are also subject to the
restrictions of 16.4.5.3.3.
16.4.2.4 Modules [std.modules]
1 The C++ standard library provides the followingC++ library modules.
138) This disallows the practice, allowed in C, of providing a masking macro in addition to the function prototype. The only
way to achieve equivalent inline behavior in C++ is to provide a definition as an extern inline function.
139) In particular, including the standard header<iso646.h> has no effect.
140) The ".h" headers dump all their names into the global namespace, whereas the newer forms keep their names in namespace
std. Therefore, the newer forms are the preferred forms for all uses except for C++ programs which are intended to be strictly
compatible with C.
§ 16.4.2.4 © ISO/IEC
546

===== PAGE 558 =====

Dxxxx
Table 26 — Names from ISO/IEC 9899:2024, Annex K [tab:c.annex.k.names]
abort_handler_s
asctime_s
bsearch_s
constraint_handler_t
ctime_s
errno_t
fopen_s
fprintf_s
freopen_s
fscanf_s
fwprintf_s
fwscanf_s
getenv_s
gets_s
gmtime_s
ignore_handler_s
localtime_s
L_tmpnam_s
mbsrtowcs_s
mbstowcs_s
memcpy_s
memmove_s
memset_s
printf_s
qsort_s
RSIZE_MAX
rsize_t
scanf_s
set_constraint_handler_s
snprintf_s
snwprintf_s
sprintf_s
sscanf_s
strcat_s
strcpy_s
strerrorlen_s
strerror_s
strlen_s
strncat_s
strncpy_s
strtok_s
swprintf_s
swscanf_s
tmpfile_s
TMP_MAX_S
tmpnam_s
vfprintf_s
vfscanf_s
vfwprintf_s
vfwscanf_s
vprintf_s
vscanf_s
vsnprintf_s
vsnwprintf_s
vsprintf_s
vsscanf_s
vswprintf_s
vswscanf_s
vwprintf_s
vwscanf_s
wcrtomb_s
wcscat_s
wcscpy_s
wcsncat_s
wcsncpy_s
wcsnlen_s
wcsrtombs_s
wcstok_s
wcstombs_s
wctomb_s
wmemcpy_s
wmemmove_s
wprintf_s
wscanf_s
2 The named modulestd exports declarations in namespacestd that are provided by the importable C++
library headers (Table 24 or the subset provided by a freestanding implementation) and the C++ headers for
C library facilities (Table 25). It additionally exports declarations in the global namespace for the storage
allocation and deallocation functions that are provided by<new> (17.6.2).
3 The named modulestd.compat exports the same declarations as the named modulestd, and additionally
exports
—(3.1) declarations in the global namespace corresponding to the declarations in namespacestd that are
provided by the C++ headers for C library facilities (Table 25), except the explicitly excluded declarations
described in 17.15.7 and
—(3.2) declarations provided by the headers<stdbit.h> (22.12) and<stdckdint.h> (29.11.1).
4 It is unspecified to which module a declaration in the standard library is attached.
[Note 1: Conforming implementations ensure that mixing #include and import does not result in conflicting
attachments (6.7). —end note]
Recommended practice: Implementations should ensure such attachments do not preclude further evolution
or decomposition of the standard library modules.
5 A declaration in the standard library denotes the same entity regardless of whether it was made reachable
through including a header, importing a header unit, or importing a C++ library module.
6 Recommended practice: Implementations should avoid exporting any other declarations from the C++ library
modules.
[Note 2: Like all named modules, the C++ library modules do not make macros visible (10.3), such asassert (19.3.2),
errno (19.4.2), offsetof (17.2.1), andva_arg (17.14.2). —end note]
16.4.2.5 Freestanding implementations [compliance]
1 Two kinds of implementations are defined: hosted and freestanding (4.1); the kind of the implementation is
implementation-defined. For a hosted implementation, this document describes the set of available headers.
2 A freestanding implementation has an implementation-defined set of headers. This set shall include at least
the headers shown in Table 27.
3 For each of the headers listed in Table 27, a freestanding implementation provides at least the freestanding
items (16.3.3.7) declared in the header.
4 The hosted library facilitiesare the set of facilities described in this document that are required for hosted
implementations, but not required for freestanding implementations. A freestanding implementation provides
§ 16.4.2.5 © ISO/IEC
547

===== PAGE 559 =====

Dxxxx
Table 27 — C++ headers for freestanding implementations [tab:headers.cpp.fs]
Subclause Header
17.2 Common definitions <cstddef>
17.2.2 C standard library <cstdlib>
17.3 Implementation properties <cfloat>, <climits>, <limits>,
<version>
17.4.1 Integer types <cstdint>
17.6 Dynamic memory management <new>
17.7 Type identification <typeinfo>
17.8 Source location <source_location>
17.9 Exception handling <exception>
17.11 Initializer lists <initializer_list>
17.12 Comparisons <compare>
17.10 Contract-violation handling <contracts>
17.13 Coroutines support <coroutine>
17.14 Other runtime support <cstdarg>
Clause 18 Concepts library <concepts>
19.4 Error numbers <cerrno>
19.5 System error support <system_error>
19.7 Debugging <debugging>
20.2 Memory <memory>
21.3 Type traits <type_traits>
21.5 Compile-time rational arithmetic <ratio>
22.2 Utility components <utility>
22.4 Tuples <tuple>
22.5 Optional objects <optional>
22.6 Variants <variant>
22.8 Expected objects <expected>
22.10 Function objects <functional>
22.11 Bit manipulation <bit>
22.12 C-compatible bit manipulation <stdbit.h>
23.3.3 Class template array <array>
23.3.16 Class template inplace_vector <inplace_vector>
23.7.2 Contiguous access <span>
23.7.3 Multidimensional access <mdspan>
Clause 24 Iterators library <iterator>
Clause 25 Ranges library <ranges>
Clause 26 Algorithms library <algorithm>, <numeric>
26.3.6 Execution policies <execution>
27.3 String view classes <string_view>
27.4 String classes <string>
27.5 Null-terminated sequence utilities <cstring>, <cwchar>
28.2 Primitive numeric conversions <charconv>
29.5 Random number generation <random>
29.7 Mathematical functions for floating-point types <cmath>
32.5 Atomics <atomic>
§ 16.4.2.5 © ISO/IEC
548

===== PAGE 560 =====

Dxxxx
a (possibly empty) implementation-defined subset of the hosted library facilities. Unless otherwise specified,
the requirements on each declaration, entity, and macro provided in this way are the same as the corresponding
requirements for a hosted implementation, except that not all of the members of the namespaces are required
to be present.
5 A freestanding implementation provides deleted definitions (9.6.3) for a (possibly empty) implementation-
defined subset of the namespace-scope functions and function templates from the hosted library facilities.
[Note 1: An implementation can provide a deleted definition so that the result of overload resolution does not silently
change when migrating a program from a freestanding implementation to a hosted implementation.—end note]
16.4.3 Using the library [using]
16.4.3.1 Overview [using.overview]
1 Subclause 16.4.3 describes how a C++ program gains access to the facilities of the C++ standard library.
16.4.3.2 describes effects during translation phase 4, while 16.4.3.3 describes effects during phase 8 (5.2).
16.4.3.2 Headers [using.headers]
1 The entities in the C++ standard library are defined in headers, whose contents are made available to a
translation unit when it contains the appropriate#include preprocessing directive (15.3) or the appropriate
import declaration (10.3).
2 A translation unit may include library headers in any order (5.1). Each may be included more than
once, with no effect different from being included exactly once, except that the effect of including either
<cassert> (19.3.2) or<assert.h> (17.15) depends each time on the lexically current definition ofNDEBUG.141
3 A translation unit shall include a header only outside of any declaration or definition and, in the case of a
module unit, only in itsglobal-module-fragment, and shall include the header or import the corresponding
header unit lexically before the first reference in that translation unit to any of the entities declared in that
header. No diagnostic is required.
16.4.3.3 Linkage [using.linkage]
1 Entities in the C++ standard library have external linkage (6.7). Unless otherwise specified, objects and
functions have the defaultextern "C++" linkage (9.12).
2 Whether a name from the C standard library declared with external linkage hasextern "C" or extern
"C++" linkage is implementation-defined. It is recommended that an implementation useextern "C++"
linkage for this purpose.142
3 Objects and functions defined in the library and required by a C++ program are included in the program
prior to program startup.
4 See also replacement functions (16.4.5.6), runtime changes (16.4.5.7).
16.4.4 Requirements on types and expressions [utility.requirements]
16.4.4.1 General [utility.requirements.general]
1 16.4.4.2 describes requirements on types and expressions used to instantiate templates defined in the C++
standard library. 16.4.4.3 describes the requirements on swappable types and swappable expressions. 16.4.4.4
describes the requirements on pointer-like types that support null values. 16.4.4.5 describes the requirements
on hash function objects. 16.4.4.6 describes the requirements on storage allocators.
16.4.4.2 Template argument requirements [utility.arg.requirements]
1 The template definitions in the C++ standard library refer to various named requirements whose details are
set out in Tables 28–35. In these tables,
—(1.1) T denotes an object or reference type to be supplied by a C++ program instantiating a template,
—(1.2) a, b, andc denote values of type (possibly const)T,
—(1.3) s and t denote modifiable lvalues of typeT,
—(1.4) u denotes an identifier,
141) This is the same as the C standard library.
142) The only reliable way to declare an object or function signature from the C standard library is by including the header that
declares it, notwithstanding the latitude granted in ISO/IEC 9899:2024, 7.1.4.
§ 16.4.4.2 © ISO/IEC
549

===== PAGE 561 =====

Dxxxx
—(1.5) rv denotes an rvalue of typeT, and
—(1.6) v denotes an lvalue of type (possibly const)T or an rvalue of typeconst T.
2 In general, a default constructor is not required. Certain container class member function signatures specify
T() as a default argument.T() shall be a well-defined expression (9.5) if one of those signatures is called
using the default argument (9.3.4.7).
Table 28 —Cpp17EqualityComparable requirements [tab:cpp17.equalitycomparable]
Expression Return type Requirement
a == b decltype(a ==
b) models
boolean-testa-
ble
== is an equivalence relation, that is, it has the
following properties:
— For alla, a == a.
— If a == b, thenb == a.
— If a == b and b == c, thena == c.
Table 29 —Cpp17LessThanComparable requirements [tab:cpp17.lessthancomparable]
Expression Return type Requirement
a < b decltype(a <
b) models
boolean-testa-
ble
< is a strict weak ordering relation (26.8)
Table 30 —Cpp17DefaultConstructible requirements [tab:cpp17.defaultconstructible]
Expression Post-condition
T t; object t is default-initialized
T u{}; object u is value-initialized or aggregate-initialized
T()
T{}
an object of typeT is value-initialized or aggregate-
initialized
Table 31 —Cpp17MoveConstructible requirements [tab:cpp17.moveconstructible]
Expression Post-condition
T u = rv; u is equivalent to the value ofrv before the construction
T(rv) T(rv) is equivalent to the value ofrv before the construction
rv’s state is unspecified
[Note 1: rv must still meet the requirements of the library component that is using it. The
operations listed in those requirements must work as specified whetherrv has been moved from
or not. —end note]
16.4.4.3 Swappable requirements [swappable.requirements]
1 This subclause provides definitions for swappable types and expressions. In these definitions, lett denote an
expression of typeT, and letu denote an expression of typeU.
2 An objectt is swappable withan objectu if and only if
—(2.1) the expressionsswap(t, u) and swap(u, t) are valid when evaluated in the context described below,
and
§ 16.4.4.3 © ISO/IEC
550

===== PAGE 562 =====

Dxxxx
Table 32 —Cpp17CopyConstructible requirements (in addition toCpp17MoveConstructible)
[tab:cpp17.copyconstructible]
Expression Post-condition
T u = v; the value ofv is unchanged and is equivalent tou
T(v) the value ofv is unchanged and is equivalent toT(v)
Table 33 —Cpp17MoveAssignable requirements [tab:cpp17.moveassignable]
Expression Return type Return value Post-condition
t = rv T& t If t and rv do not refer to the
same object, t is equivalent to
the value ofrvbefore the assign-
ment
rv’s state is unspecified.
[Note 2: rv must still meet the requirements of the library component that is using it, whether
or nott and rv refer to the same object. The operations listed in those requirements must work
as specified whetherrv has been moved from or not.—end note]
Table 34 —Cpp17CopyAssignable requirements (in addition toCpp17MoveAssignable)
[tab:cpp17.copyassignable]
Expression Return type Return value Post-condition
t = v T& t t is equivalent tov, the value of
v is unchanged
Table 35 —Cpp17Destructible requirements [tab:cpp17.destructible]
Expression Post-condition
a.~T() No exception is propagated.
[Note 3: Array types and non-object types are notCpp17Destructible. —end note]
—(2.2) these expressions have the following effects:
—(2.2.1) the object referred to byt has the value originally held byu and
—(2.2.2) the object referred to byu has the value originally held byt.
3 The context in whichswap(t, u) and swap(u, t) are evaluated shall ensure that a binary non-member
function named “swap” is selected via overload resolution (12.2) on a candidate set that includes:
—(3.1) the twoswap function templates defined in<utility> (22.2.1) and
—(3.2) the lookup set produced by argument-dependent lookup (6.5.4).
[Note 1: If T and U are both fundamental types or arrays of fundamental types and the declarations from the header
<utility> are in scope, the overall lookup set described above is equivalent to that of the qualified name lookup
applied to the expressionstd::swap(t, u) or std::swap(u, t) as appropriate. —end note]
[Note 2: It is unspecified whether a library component that has a swappable requirement includes the header<utility>
to ensure an appropriate evaluation context.—end note]
4 An rvalue or lvaluet is swappable if and only ift is swappable with any rvalue or lvalue, respectively, of
type T.
5 A typeX meets theCpp17Swappable requirements if lvalues of typeX are swappable.
6 A typeX meeting any of the iterator requirements (24.3) meets theCpp17ValueSwappablerequirements if, for
any dereferenceable objectx of typeX, *x is swappable.
§ 16.4.4.3 © ISO/IEC
551

===== PAGE 563 =====

Dxxxx
7 [Example 1: User code can ensure that the evaluation ofswap calls is performed in an appropriate context under the
various conditions as follows:
#include <cassert>
#include <utility>
// Preconditions:std::forward<T>(t) is swappable withstd::forward<U>(u).
template<class T, class U>
void value_swap(T&& t, U&& u) {
using std::swap;
swap(std::forward<T>(t), std::forward<U>(u)); // OK, uses “swappable with” conditions
// for rvalues and lvalues
}
// Preconditions:T meets the Cpp17Swappable requirements.
template<class T>
void lv_swap(T& t1, T& t2) {
using std::swap;
swap(t1, t2); // OK, uses swappable conditions for lvalues of typeT
}
namespace N {
struct A { int m; };
struct Proxy { A* a; };
Proxy proxy(A& a) { return Proxy{ &a }; }
void swap(A& x, Proxy p) {
std::swap(x.m, p.a->m); // OK, uses context equivalent to swappable
// conditions for fundamental types
}
void swap(Proxy p, A& x) { swap(x, p); } // satisfy symmetry constraint
}
int main() {
int i = 1, j = 2;
lv_swap(i, j);
assert(i == 2 && j == 1);
N::A a1 = { 5 }, a2 = { -5 };
value_swap(a1, proxy(a2));
assert(a1.m == -5 && a2.m == 5);
}
—end example]
16.4.4.4 Cpp17NullablePointer requirements [nullablepointer.requirements]
1 A Cpp17NullablePointer type is a pointer-like type that supports null values. A typeP meets theCpp17-
NullablePointer requirements if
—(1.1) P meets theCpp17EqualityComparable, Cpp17DefaultConstructible, Cpp17CopyConstructible, Cpp17-
CopyAssignable, Cpp17Swappable, andCpp17Destructible requirements,
—(1.2) the expressions shown in Table 36 are valid and have the indicated semantics, and
—(1.3) P meets all the other requirements of this subclause.
2 A value-initialized object of typeP produces the null value of the type. The null value shall be equivalent
only to itself. A default-initialized object of typeP may have an indeterminate or erroneous value.
[Note 1: Operations involving indeterminate values can cause undefined behavior, and operations involving erroneous
values can cause erroneous behavior (6.8.5).—end note]
3 An objectp of typeP can be contextually converted tobool (7.3). The effect shall be as ifp != nullptr
had been evaluated in place ofp.
4 No operation which is part of theCpp17NullablePointer requirements shall exit via an exception.
5 In Table 36,u denotes an identifier,t denotes a non-const lvalue of typeP, a and b denote values of type
(possibly const)P, andnp denotes a value of type (possibly const)std::nullptr_t.
§ 16.4.4.4 © ISO/IEC
552

===== PAGE 564 =====

Dxxxx
Table 36 —Cpp17NullablePointer requirements [tab:cpp17.nullablepointer]
Expression Return type Operational semantics
P u(np); Postconditions: u == nullptr
P u = np;
P(np) Postconditions: P(np) == nullptr
t = np P& Postconditions: t == nullptr
a != b decltype(a != b) models
boolean-testable
!(a == b)
a == np decltype(a == np) and
decltype(np == a) each model
boolean-testable
a == P()
np == a
a != np decltype(a != np) and
decltype(np != a) each model
boolean-testable
!(a == np)
np != a
16.4.4.5 Cpp17Hash requirements [hash.requirements]
1 A typeH meets theCpp17Hash requirements if
—(1.1) it is a function object type (22.10),
—(1.2) it meets theCpp17CopyConstructible (Table 32) andCpp17Destructible (Table 35) requirements, and
—(1.3) the expressions shown in Table 37 are valid and have the indicated semantics.
2 Given Key is an argument type for function objects of typeH, in Table 37h is a value of type (possibly const)
H, u is an lvalue of typeKey, andk is a value of a type convertible to (possibly const)Key.
Table 37 —Cpp17Hash requirements [tab:cpp17.hash]
Expression Return type Requirement
h(k) size_t The value returned shall depend only on the argumentk for
the duration of the program.
[Note 1: Thus all evaluations of the expressionh(k) with the
same value fork yield the same result for a given execution of
the program. —end note]
For two different valuest1andt2, the probability thath(t1)
and h(t2) compare equal should be very small, approaching
1.0 / numeric_limits<size_t>::max().
h(u) size_t Shall not modifyu.
16.4.4.6 Cpp17Allocator requirements [allocator.requirements]
16.4.4.6.1 General [allocator.requirements.general]
1 Thelibrarydescribesastandardsetofrequirementsfor allocators, whichareclass-typeobjectsthatencapsulate
the information about an allocation model. This information includes the knowledge of pointer types, the
type of their difference, the type of the size of objects in this allocation model, as well as the memory
allocation and deallocation primitives for it. All of the string types (Clause 27), containers (Clause 23) (except
array and inplace_vector), string buffers and string streams (Clause 31), andmatch_results (28.6) are
parameterized in terms of allocators.
2 In 16.4.4.6,
—(2.1) T, U, C denote anycv-unqualified object type (6.9.1),
—(2.2) X denotes an allocator class for typeT,
—(2.3) Y denotes the corresponding allocator class for typeU,
§ 16.4.4.6.1 © ISO/IEC
553

===== PAGE 565 =====

Dxxxx
—(2.4) XX denotes the typeallocator_traits<X>,
—(2.5) YY denotes the typeallocator_traits<Y>,
—(2.6) a, a1, a2 denote lvalues of typeX,
—(2.7) u denotes the name of a variable being declared,
—(2.8) b denotes a value of typeY,
—(2.9) c denotes a pointer of typeC* through which indirection is valid,
—(2.10) p denotes a value of typeXX::pointer obtained by callinga1.allocate, wherea1 == a,
—(2.11) q denotes a value of typeXX::const_pointer obtained by conversion from a valuep,
—(2.12) r denotes a value of typeT& obtained by the expression*p,
—(2.13) w denotes a value of typeXX::void_pointer obtained by conversion from a valuep,
—(2.14) x denotes a value of typeXX::const_void_pointer obtained by conversion from a valueq or a value
w,
—(2.15) y denotes a value of typeXX::const_void_pointer obtained by conversion from a result value of
YY::allocate, or else a value of type (possibly const)std::nullptr_t,
—(2.16) n denotes a value of typeXX::size_type,
—(2.17) Args denotes a template parameter pack, and
—(2.18) args denotes a function parameter pack with the patternArgs&&.
3 The class templateallocator_traits (20.2.9) supplies a uniform interface to all allocator types. This
subclause describes the requirements on allocator types and thus on types used to instantiateallocator_-
traits. A requirement is optional if a default for a given type or expression is specified. Within the standard
library allocator_traits template, an optional requirement that is not supplied by an allocator is replaced
by the specified default type or expression.
[Note 1: There are no program-defined specializations ofallocator_traits. —end note]
typename X::pointer
4 Remarks: Default: T*
typename X::const_pointer
5 Mandates: XX::pointer is convertible toXX::const_pointer.
6 Remarks: Default: pointer_traits<XX::pointer>::rebind<const T>
typename X::void_pointer
typename Y::void_pointer
7 Mandates: XX::pointer is convertible toXX::void_pointer. XX::void_pointer and YY::void_-
pointer are the same type.
8 Remarks: Default: pointer_traits<XX::pointer>::rebind<void>
typename X::const_void_pointer
typename Y::const_void_pointer
9 Mandates: XX::pointer, XX::const_pointer, andXX::void_pointer are convertible toXX::const_-
void_pointer. XX::const_void_pointer and YY::const_void_pointer are the same type.
10 Remarks: Default: pointer_traits<XX::pointer>::rebind<const void>
typename X::value_type
11 Result: Identical toT.
typename X::size_type
12 Result: An unsigned integer type that can represent the size of the largest object in the allocation
model.
13 Remarks: Default: make_unsigned_t<XX::difference_type>
§ 16.4.4.6.1 © ISO/IEC
554

===== PAGE 566 =====

Dxxxx
typename X::difference_type
14 Result: A signed integer type that can represent the difference between any two pointers in the allocation
model.
15 Remarks: Default: pointer_traits<XX::pointer>::difference_type
typename X::rebind<U>::other
16 Result: Y
17 Postconditions: For allU (including T), YY::rebind_alloc<T> is X.
18 Remarks: If Allocator is a class template instantiation of the formSomeAllocator<T, Args>, where
Args is zero or more type arguments, andAllocator does not supply arebind member template,
the standardallocator_traits template usesSomeAllocator<U, Args> in place ofAllocator::re-
bind<U>::other by default. For allocator types that are not template instantiations of the above form,
no default is provided.
19 [Note 2: The member class template rebind of X is effectively a typedef template. In general, if the
name Allocator is bound to SomeAllocator<T>, then Allocator::rebind<U>::other is the same type as
SomeAllocator<U>, whereSomeAllocator<T>::value_type is T and SomeAllocator<U>::value_type is U. —
end note]
*p
20 Result: T&
*q
21 Result: const T&
22 Postconditions: *q refers to the same object as*p.
p->m
23 Result: Type ofT::m.
24 Preconditions: (*p).m is well-defined.
25 Effects: Equivalent to(*p).m.
q->m
26 Result: Type ofT::m.
27 Preconditions: (*q).m is well-defined.
28 Effects: Equivalent to(*q).m.
static_cast<XX::pointer>(w)
29 Result: XX::pointer
30 Postconditions: static_cast<XX::pointer>(w) == p.
static_cast<XX::const_pointer>(x)
31 Result: XX::const_pointer
32 Postconditions: static_cast<XX::const_pointer>(x) == q.
pointer_traits<XX::pointer>::pointer_to(r)
33 Result: XX::pointer
34 Postconditions: Same asp.
a.allocate(n)
35 Result: XX::pointer
36 Effects: Memory is allocated for an array ofn Tand such an object is created but array elements are
not constructed.
[Example 1: When reusing storage denoted by some pointer valuep, launder(reinterpret_cast<T*>(new (p)
byte[n * sizeof(T)])) can be used to implicitly create a suitable array object and obtain a pointer to it.
—end example]
§ 16.4.4.6.1 © ISO/IEC
555

===== PAGE 567 =====

Dxxxx
37 Throws: allocate may throw an appropriate exception.
38 [Note 3: It is intended thata.allocate be an efficient means of allocating a single object of typeT, even when
sizeof(T) is small. That is, there is no need for a container to maintain its own free list.—end note]
39 Remarks: If n == 0, the return value is unspecified.
a.allocate(n, y)
40 Result: XX::pointer
41 Effects: Same asa.allocate(n). The use ofy is unspecified, but it is intended as an aid to locality.
42 Remarks: Default: a.allocate(n)
a.allocate_at_least(n)
43 Result: allocation_result<XX::pointer, XX::size_type>
44 Returns: allocation_result<XX::pointer, XX::size_type>{ptr, count} where ptr is memory
allocated for an array ofcount Tand such an object is created but array elements are not constructed,
such thatcount ≥n. If n == 0, the return value is unspecified.
45 Throws: allocate_at_least may throw an appropriate exception.
46 Remarks: Default: {a.allocate(n), n}.
a.deallocate(p, n)
47 Result: (not used)
48 Preconditions:
—(48.1) If p is memory that was obtained by a call toa.allocate_at_least, letret be the value returned
and req be the value passed as the first argument of that call.p is equal toret.ptr and n is a
value such thatreq ≤n ≤ret.count.
—(48.2) Otherwise, p is a pointer value obtained fromallocate. n equals the value passed as the first
argument to the invocation ofallocate which returnedp.
p has not been invalidated by an intervening call todeallocate.
49 Throws: Nothing.
a.max_size()
50 Result: XX::size_type
51 Returns: The largest valuen that can meaningfully be passed toa.allocate(n).
52 Remarks: Default: numeric_limits<size_type>::max() / sizeof(value_type)
a1 == a2
53 Result: bool
54 Returns: true only if storage allocated from each can be deallocated via the other.
55 Throws: Nothing.
56 Remarks: operator== shall be reflexive, symmetric, and transitive.
a1 != a2
57 Result: bool
58 Returns: !(a1 == a2).
a == b
59 Result: bool
60 Returns: a == YY::rebind_alloc<T>(b).
a != b
61 Result: bool
62 Returns: !(a == b).
§ 16.4.4.6.1 © ISO/IEC
556

===== PAGE 568 =====

Dxxxx
X u(a);
X u = a;
63 Postconditions: u == a
64 Throws: Nothing.
X u(b);
65 Postconditions: Y(u) == b and u == X(b).
66 Throws: Nothing.
X u(std::move(a));
X u = std::move(a);
67 Postconditions: The value ofa is unchanged and is equal tou.
68 Throws: Nothing.
X u(std::move(b));
69 Postconditions: u is equal to the prior value ofX(b).
70 Throws: Nothing.
a.construct(c, args...)
71 Result: (not used)
72 Effects: Constructs an object of typeC at c.
73 Remarks: Default: construct_at(c, std::forward<Args>(args)...)
a.destroy(c)
74 Result: (not used)
75 Effects: Destroys the object atc.
76 Remarks: Default: destroy_at(c)
a.select_on_container_copy_construction()
77 Result: X
78 Returns: Typically returns eithera or X().
79 Remarks: Default: return a;
typename X::propagate_on_container_copy_assignment
80 Result: Identical to or derived fromtrue_type or false_type.
81 Returns: true_type only if an allocator of typeX should be copied when the client container is
copy-assigned; if so,X shall meet theCpp17CopyAssignable requirements (Table 34) and the copy
operation shall not throw exceptions.
82 Remarks: Default: false_type
typename X::propagate_on_container_move_assignment
83 Result: Identical to or derived fromtrue_type or false_type.
84 Returns: true_type only if an allocator of typeX should be moved when the client container is
move-assigned; if so,X shall meet theCpp17MoveAssignable requirements (Table 33) and the move
operation shall not throw exceptions.
85 Remarks: Default: false_type
typename X::propagate_on_container_swap
86 Result: Identical to or derived fromtrue_type or false_type.
87 Returns: true_type only if an allocator of typeX should be swapped when the client container is
swapped; if so,X shall meet theCpp17Swappable requirements (16.4.4.3) and theswap operation shall
not throw exceptions.
88 Remarks: Default: false_type
§ 16.4.4.6.1 © ISO/IEC
557

===== PAGE 569 =====

Dxxxx
typename X::is_always_equal
89 Result: Identical to or derived fromtrue_type or false_type.
90 Returns: true_type only if the expressiona1 == a2 is guaranteed to betrue for any two (possibly
const) valuesa1, a2 of typeX.
91 Remarks: Default: is_empty<X>::type
92 An allocator typeX shall meet theCpp17CopyConstructible requirements (Table 32). TheXX::pointer,
XX::const_pointer, XX::void_pointer, andXX::const_void_pointertypesshallmeetthe Cpp17Nullable-
Pointer requirements (Table 36). No constructor, comparison operator function, copy operation, move
operation, or swap operation on these pointer types shall exit via an exception.XX::pointerand XX::const_-
pointer shall also meet the requirements for aCpp17RandomAccessIterator(24.3.5.7) and the additional
requirement that, whenp and (p + n) are dereferenceable pointer values for some integral valuen,
addressof(*(p + n)) == addressof(*p) + n
is true.
93 Let x1 and x2 denote objects of (possibly different) typesXX::void_pointer, XX::const_void_pointer,
XX::pointer, orXX::const_pointer. Then, x1 and x2 are equivalently-valued pointer values, if and only if
both x1 and x2 can be explicitly converted to the two corresponding objectspx1 and px2 of typeXX::const_-
pointer, using a sequence ofstatic_casts using only these four types, and the expressionpx1 == px2
evaluates totrue.
94 Let w1 and w2 denote objects of typeXX::void_pointer. Then for the expressions
w1 == w2
w1 != w2
either or both objects may be replaced by an equivalently-valued object of typeXX::const_void_pointer
with no change in semantics.
95 Let p1 and p2 denote objects of typeXX::pointer. Then for the expressions
p1 == p2
p1 != p2
p1 < p2
p1 <= p2
p1 >= p2
p1 > p2
p1 - p2
either or both objects may be replaced by an equivalently-valued object of typeXX::const_pointer with no
change in semantics.
96 An allocator may constrain the types on which it can be instantiated and the arguments for which its
construct or destroy members may be called. If a type cannot be used with a particular allocator, the
allocator class or the call toconstruct or destroy may fail to instantiate.
97 If the alignment associated with a specific over-aligned type is not supported by an allocator, instantiation of
the allocator for that type may fail. The allocator also may silently ignore the requested alignment.
[Note 4: Additionally, the member functionallocate for that type can fail by throwing an object of typebad_alloc.
—end note]
98 [Example 2: The following is an allocator class template supporting the minimal interface that meets the requirements
of 16.4.4.6.1:
template<class T>
struct SimpleAllocator {
using value_type = T;
SimpleAllocator(ctor args );
template<class U> SimpleAllocator(const SimpleAllocator<U>& other);
T* allocate(std::size_t n);
void deallocate(T* p, std::size_t n);
template<class U> bool operator==(const SimpleAllocator<U>& rhs) const;
};
§ 16.4.4.6.1 © ISO/IEC
558

===== PAGE 570 =====

Dxxxx
—end example]
99 The following exposition-only concept defines the minimal requirements on an Allocator type.
namespace std {
template<class Alloc>
concept simple-allocator =
requires(Alloc alloc, size_t n) {
{ *alloc.allocate(n) } -> same_as<typename Alloc::value_type&>;
{ alloc.deallocate(alloc.allocate(n), n) };
} &&
copy_constructible<Alloc> &&
equality_comparable<Alloc>;
}
A typeAlloc models simple-allocator if it meets the requirements of 16.4.4.6.1.
16.4.4.6.2 Allocator completeness requirements [allocator.requirements.completeness]
1 If X is an allocator class for typeT, X additionally meets the allocator completeness requirements if, whether
or notT is a complete type:
—(1.1) X is a complete type, and
—(1.2) all the member types ofallocator_traits<X> (20.2.9) other thanvalue_type are complete types.
16.4.5 Constraints on programs [constraints]
16.4.5.1 Overview [constraints.overview]
1 Subclause 16.4.5 describes restrictions on C++ programs that use the facilities of the C++ standard library.
The following subclauses specify constraints on the program’s use of namespaces (16.4.5.2.1), its use of
various reserved names (16.4.5.3), its use of headers (16.4.5.4), its use of standard library classes as base
classes (16.4.5.5), its definitions of replacement functions (16.4.5.6), and its installation of handler functions
during execution (16.4.5.7).
16.4.5.2 Namespace use [namespace.constraints]
16.4.5.2.1 Namespace std [namespace.std]
1 Unless otherwise specified, the behavior of a C++ program is undefined if it adds declarations or definitions
to namespacestd or to a namespace within namespacestd.
2 Unless explicitly prohibited, a program may add a template specialization for any standard library class
template to namespacestd provided that
—(2.1) the added declaration depends on at least one program-defined type, and
—(2.2) the specialization meets the standard library requirements for the original template.143
3 The behavior of a C++ program is undefined if it declares an explicit or partial specialization of any standard
library variable template, except where explicitly permitted by the specification of that variable template.
[Note 1: The requirements on an explicit or partial specialization are stated by each variable template that grants
such permission. —end note]
4 The behavior of a C++ program is undefined if it declares
—(4.1) an explicit specialization of any member function of a standard library class template, or
—(4.2) an explicit specialization of any member function template of a standard library class or class template,
or
—(4.3) an explicit or partial specialization of any member class template of a standard library class or class
template, or
—(4.4) a deduction guide for any standard library class template.
5 A program may explicitly instantiate a class template defined in the standard library only if the declaration
—(5.1) depends on the name of at least one program-defined type, and
—(5.2) the instantiation meets the standard library requirements for the original template.
143) Any library code that instantiates other library templates must be prepared to work adequately with any user-supplied
specialization that meets the minimum requirements of this document.
§ 16.4.5.2.1 © ISO/IEC
559

===== PAGE 571 =====

Dxxxx
6 Let F denote a standard library function (16.4.6.4), a standard library static member function, or an
instantiation of a standard library function template. UnlessF is designated anaddressable function, the
behavior of a C++ program is unspecified (possibly ill-formed) if it explicitly or implicitly attempts to form a
pointer toF .
[Note 2: Possible means of forming such pointers include application of the unary& operator (7.6.2.2),addressof
(20.2.11), or a function-to-pointer standard conversion (7.3.4).—end note]
Moreover, the behavior of a C++ program is unspecified (possibly ill-formed) if it attempts to form a reference
to F or if it attempts to form a pointer-to-member designating either a standard library non-static member
function (16.4.6.5) or an instantiation of a standard library member function template.
7 Let F denote a standard library function or function template. UnlessF is designated an addressable function,
it is unspecified if or how a reflection value designating the associated entity can be formed.
[Note 3: For example, it is possible thatstd::meta::members_of will not return reflections of standard library
functions that an implementation handles through an extra-linguistic mechanism.—end note]
8 Let C denote a standard library class or class template specialization. It is unspecified if or how a reflection
value can be formed to any private member ofC , or what the names of such members may be.
9 A translation unit shall not declare namespacestd to be an inline namespace (9.9.2).
16.4.5.2.2 Namespace posix [namespace.posix]
1 The behavior of a C++ program is undefined if it adds declarations or definitions to namespaceposix or to a
namespace within namespaceposix unless otherwise specified. The namespaceposix is reserved for use by
ISO/IEC/IEEE 9945 and other POSIX standards.
16.4.5.2.3 Namespaces for future standardization [namespace.future]
1 Top-level namespaces whosenamespace-name consists ofstd followed by one or moredigits (5.11) are reserved
for future standardization. The behavior of a C++ program is undefined if it adds declarations or definitions
to such a namespace.
[Example 1: The top-level namespacestd2 is reserved for use by future revisions of this International Standard.
—end example]
16.4.5.3 Reserved names [reserved.names]
16.4.5.3.1 General [reserved.names.general]
1 The C++ standard library reserves the following kinds of names:
—(1.1) macros
—(1.2) global names
—(1.3) names with external linkage
2 If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by
Clause 16, its behavior is undefined.
16.4.5.3.2 Zombie names [zombie.names]
1 In namespacestd, the names shown in Table 38 are reserved for previous standardization:
2 The names shown in Table 39 are reserved as members for previous standardization, and may not be used as
a name for object-like macros in portable code:
3 The names shown in Table 40 are reserved as member functions for previous standardization, and may not
be used as a name for function-like macros in portable code:
4 The header names shown in Table 41 are reserved for previous standardization:
16.4.5.3.3 Macro names [macro.names]
1 A translation unit that includes a standard library header shall not#define or #undef names declared in
any standard library header.
§ 16.4.5.3.3 © ISO/IEC
560

===== PAGE 572 =====

Dxxxx
Table 38 — Zombie names in namespacestd [tab:zombie.names.std]
auto_ptr
auto_ptr_ref
binary_function
binary_negate
bind1st
bind2nd
binder1st
binder2nd
codecvt_mode
codecvt_utf16
codecvt_utf8
codecvt_utf8_utf16
const_mem_fun1_ref_t
const_mem_fun1_t
const_mem_fun_ref_t
const_mem_fun_t
consume_header
declare_no_pointers
declare_reachable
generate_header
get_pointer_safety
get_temporary_buffer
get_unexpected
gets
is_literal_type
is_literal_type_v
istrstream
little_endian
mem_fun1_ref_t
mem_fun1_t
mem_fun_ref_t
mem_fun_ref
mem_fun_t
mem_fun
not1
not2
ostrstream
pointer_safety
pointer_to_binary_function
pointer_to_unary_function
ptr_fun
random_shuffle
raw_storage_iterator
result_of
result_of_t
return_temporary_buffer
set_unexpected
strstream
strstreambuf
unary_function
unary_negate
uncaught_exception
undeclare_no_pointers
undeclare_reachable
unexpected_handler
wbuffer_convert
wstring_convert
Table 39 — Zombie object-like macros [tab:zombie.names.objmacro]
argument_type
first_argument_type
io_state
op
open_mode
preferred
second_argument_type
seek_dir
strict
Table 40 — Zombie function-like macros [tab:zombie.names.fnmacro]
converted freeze from_bytes pcount stossc to_bytes
16.4.5.3.4 External linkage [extern.names]
1 Each name declared as an object with external linkage in a header is reserved to the implementation to
designate that library object with external linkage,144 both in namespacestd and in the global namespace.
2 Each global function signature declared with external linkage in a header is reserved to the implementation
to designate that function signature with external linkage.145
3 Each name from the C standard library declared with external linkage is reserved to the implementation for
use as a name withextern "C" linkage, both in namespacestd and in the global namespace.
4 Each function signature from the C standard library declared with external linkage is reserved to the
implementation for use as a function signature with bothextern "C" and extern "C++" linkage,146 or as a
name of namespace scope in the global namespace.
144) The list of such reserved names includeserrno, declared or defined in<cerrno> (19.4.2).
145) The list of such reserved function signatures with external linkage includessetjmp(jmp_buf), declared or defined in
<csetjmp> (17.14.3), andva_end(va_list), declared or defined in<cstdarg> (17.14.2).
146) The function signatures declared in<cuchar> (28.7.4), <cwchar> (28.7.3), and <cwctype> (28.7.2) are always reserved,
notwithstanding the restrictions imposed in subclause 4.5.1 of Amendment 1 to the C Standard for these headers.
Table 41 — Zombie headers [tab:zombie.names.header]
<ccomplex>
<ciso646>
<codecvt>
<cstdalign>
<cstdbool> <ctgmath> <strstream>
§ 16.4.5.3.4 © ISO/IEC
561

===== PAGE 573 =====

Dxxxx
16.4.5.3.5 Types [extern.types]
1 For each typeT from the C standard library, the types::T and std::T are reserved to the implementation
and, when defined,::T shall be identical tostd::T.
16.4.5.3.6 User-defined literal suffixes [usrlit.suffix]
1 Literal suffix identifiers (12.6) that do not start with an underscore are reserved for future standardization.
Literal suffix identifiers that contain a double underscore__ are reserved for use by C++ implementations.
16.4.5.4 Headers [alt.headers]
1 If a file with a name equivalent to the derived file name for one of the C++ standard library headers is not
provided as part of the implementation, and a file with that name is placed in any of the standard places for
a source file to be included (15.3), the behavior is undefined.
16.4.5.5 Derived classes [derived.classes]
1 Virtual member function signatures defined for a base class in the C++ standard library may be overridden
in a derived class defined in the program (11.7.3).
16.4.5.6 Replacement functions [replacement.functions]
1 If a function defined in Clause 17 through Clause 33 and Annex D is specified as replaceable (9.6.5), the
description of function semantics apply to both the default version defined by the C++ standard library and
the replacement function defined by the program.
16.4.5.7 Handler functions [handler.functions]
1 The C++ standard library provides a default version of the following handler function (Clause 17):
—(1.1) terminate_handler
2 A C++ program may install different handler functions during execution, by supplying a pointer to a function
defined in the program or the library as an argument to (respectively):
—(2.1) set_new_handler
—(2.2) set_terminate
See also subclauses 17.6.4, Storage allocation errors, and 17.9, Exception handling.
3 A C++ program can get a pointer to the current handler function by calling the following functions:
—(3.1) get_new_handler
—(3.2) get_terminate
4 Calling theset_* and get_* functions shall not incur a data race (6.10.2.2). A call to any of theset_*
functions synchronizes with subsequent calls to the sameset_* function and to the correspondingget_*
function.
16.4.5.8 Other functions [res.on.functions]
1 In certain cases (replacement functions, handler functions, operations on types used to instantiate standard
library template components), the C++ standard library depends on components supplied by a C++ pro-
gram. If these components do not meet their requirements, this document places no requirements on the
implementation.
2 In particular, the behavior is undefined in the following cases:
—(2.1) For replacement functions (16.4.5.6), if the installed replacement function does not implement the
semantics of the applicableRequired behavior: paragraph.
—(2.2) For handler functions (17.6.4.3, 17.9.5.1), if the installed handler function does not implement the
semantics of the applicableRequired behavior: paragraph.
—(2.3) For types used as template arguments when instantiating a template component, if the operations on
the type do not implement the semantics of the applicableRequirementssubclause (16.4.4.6, 23.2, 24.3,
26.2, 29.2). Operations on such types can report a failure by throwing an exception unless otherwise
specified.
—(2.4) If any replacement function or handler function or destructor operation exits via an exception, unless
specifically allowed in the applicableRequired behavior: paragraph.
§ 16.4.5.8 © ISO/IEC
562

===== PAGE 574 =====

Dxxxx
—(2.5) If an incomplete type (6.9.1) is used as a template argument when instantiating a template component
or evaluating a concept, unless specifically allowed for that component.
16.4.5.9 Function arguments [res.on.arguments]
1 Each of the following applies to all arguments to functions defined in the C++ standard library, unless
explicitly stated otherwise.
—(1.1) If an argument to a function has an invalid value (such as a value outside the domain of the function or
a pointer invalid for its intended use), the behavior is undefined.
—(1.2) If a function argument is described as being an array, the pointer actually passed to the function shall
have a value such that all address computations and accesses to objects (that would be valid if the
pointer did point to the first element of such an array) are in fact valid.
—(1.3) If a function argument is bound to an rvalue reference parameter, the implementation may assume
that this parameter is a unique reference to this argument, except that the argument passed to a move
assignment operator may be a reference to*this (16.4.6.17).
[Note 1: If the type of a parameter is a forwarding reference (13.10.3.2) that is deduced to an lvalue reference
type, then the argument is not bound to an rvalue reference.—end note]
[Note 2: If a program casts an lvalue to an xvalue while passing that lvalue to a library function (e.g., by calling
the function with the argumentstd::move(x)), the program is effectively asking that function to treat that
lvalue as a temporary object. The implementation is free to optimize away aliasing checks which would possibly
be needed if the argument was an lvalue.—end note]
16.4.5.10 Library object access [res.on.objects]
1 The behavior of a program is undefined if calls to standard library functions from different threads may
introduce a data race. The conditions under which this may occur are specified in 16.4.6.10.
[Note 1: Modifying an object of a standard library type that is shared between threads risks undefined behavior
unless objects of that type are explicitly specified as being shareable without data races or the user supplies a locking
mechanism. —end note]
2 If an object of a standard library type is accessed, and the beginning of the object’s lifetime (6.8.4) does not
happen before the access, or the access does not happen before the end of the object’s lifetime, the behavior
is undefined unless otherwise specified.
[Note 2: This applies even to objects such as mutexes intended for thread synchronization.—end note]
16.4.5.11 Semantic requirements [res.on.requirements]
1 A sequenceArgs of template arguments is said tomodel a conceptC if Args satisfies C (13.5.3) and meets all
semantic requirements (if any) given in the specification ofC.
2 If the validity or meaning of a program depends on whether a sequence of template arguments models a
concept, and the concept is satisfied but not modeled, the program is ill-formed, no diagnostic required.
3 If the semantic requirements of a declaration’s constraints (16.3.2.3) are not modeled at the point of use, the
program is ill-formed, no diagnostic required.
16.4.6 Conforming implementations [conforming]
16.4.6.1 Overview [conforming.overview]
1 Subclause 16.4.6 describes the constraints upon, and latitude of, implementations of the C++ standard library.
2 An implementation’s use of
—(2.1) headers is discussed in 16.4.6.2,
—(2.2) macros in 16.4.6.3,
—(2.3) non-member functions in 16.4.6.4,
—(2.4) member functions in 16.4.6.5,
—(2.5) data race avoidance in 16.4.6.10,
—(2.6) access specifiers in 16.4.6.12,
—(2.7) class derivation in 16.4.6.13,
—(2.8) exceptions in 16.4.6.14, and
§ 16.4.6.1 © ISO/IEC
563

===== PAGE 575 =====

Dxxxx
—(2.9) contract assertions in 16.4.6.15.
16.4.6.2 Headers [res.on.headers]
1 A C++ header may include other C++ headers. A C++ header shall provide the declarations and definitions
that appear in its synopsis. A C++ header shown in its synopsis as including other C++ headers shall provide
the declarations and definitions that appear in the synopses of those other headers.
2 Certain types and macros are defined in more than one header. Every such entity shall be defined such that
any header that defines it may be included after any other header that also defines it (6.3).
3 The C standard library headers (17.15) shall include only their corresponding C++ standard library header,
as described in 16.4.2.3.
16.4.6.3 Restrictions on macro definitions [res.on.macro.definitions]
1 The names and global function signatures described in 16.4.2.2 are reserved to the implementation.
2 All object-like macros defined by the C standard library and described in this Clause as expanding to integral
constant expressions are also suitable for use in#if preprocessing directives, unless explicitly stated otherwise.
16.4.6.4 Non-member functions [global.functions]
1 It is unspecified whether any non-member functions in the C++ standard library are defined as inline (9.2.8).
2 A call to a non-member function signature described in Clause 17 through Clause 33 and Annex D shall
behave as if the implementation declared no additional non-member function signatures.147
3 An implementation shall not declare a non-member function signature with additional default arguments.
4 Unless otherwise specified, calls made by functions in the standard library to non-operator, non-member
functions do not use functions from another namespace which are found through argument-dependent name
lookup (6.5.4).
[Note 1: The phrase “unless otherwise specified” applies to cases such as the swappable with requirements
(16.4.4.3). The exception for overloaded operators allows argument-dependent lookup in cases like that ofostream_-
iterator::operator= (24.6.3.3):
Effects:
*out_stream << value;
if (delim != 0)
*out_stream << delim ;
return *this;
—end note]
16.4.6.5 Member functions [member.functions]
1 It is unspecified whether any member functions in the C++ standard library are defined as inline (9.2.8).
2 For a non-virtual member function described in the C++ standard library, an implementation may declare a
different set of member function signatures, provided that any call to the member function that would select
an overload from the set of declarations described in this document behaves as if that overload were selected.
[Note 1: For instance, an implementation can add parameters with default values, or replace a member function with
default arguments with two or more member functions with equivalent behavior, or add additional signatures for a
member function name. —end note]
16.4.6.6 Friend functions [hidden.friends]
1 Whenever this document specifies a friend declaration of a function or function template within a class or
class template definition, that declaration shall be the only declaration of that function or function template
provided by an implementation.
[Note 1: In particular, a conforming implementation does not provide any additional declarations of that function or
function template at namespace scope.—end note]
[Note 2: Such a friend function or function template declaration is known as a hidden friend, as it is visible neither to
ordinary unqualified lookup (6.5.3) nor to qualified lookup (6.5.5).—end note]
147) A valid C++ program always calls the expected library non-member function. An implementation can also define additional
non-member functions that would otherwise not be called by a valid C++ program.
§ 16.4.6.6 © ISO/IEC
564

===== PAGE 576 =====

Dxxxx
16.4.6.7 Constexpr functions and constructors [constexpr.functions]
1 This document explicitly requires that certain standard library functions areconstexpr (9.2.6). An imple-
mentation shall not declare any standard library function signature asconstexpr except for those where it
is explicitly required. Within any header that provides any non-defining declarations of constexpr functions
an implementation shall provide corresponding definitions.
16.4.6.8 Requirements for stable algorithms [algorithm.stable]
1 When the requirements for an algorithm state that it is “stable” without further elaboration, it means:
—(1.1) For the sort algorithms the relative order of equivalent elements is preserved.
—(1.2) For the remove and copy algorithms the relative order of the elements that are not removed is preserved.
—(1.3) For the merge algorithms, for equivalent elements in the original two ranges, the elements from the first
range (preserving their original order) precede the elements from the second range (preserving their
original order).
16.4.6.9 Reentrancy [reentrancy]
1 Except where explicitly specified in this document, it is implementation-defined which functions in the C++
standard library may be recursively reentered.
16.4.6.10 Data race avoidance [res.on.data.races]
1 This subclause specifies requirements that implementations shall meet to prevent data races (6.10.2). Every
standard library function shall meet each requirement unless otherwise specified. Implementations may
prevent data races in cases other than those specified below.
2 A C++ standard library function shall not directly or indirectly access objects (6.10.2) accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function’s arguments,
including this.
3 A C++ standard library function shall not directly or indirectly modify objects (6.10.2) accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function’s non-const
arguments, includingthis.
4 [Note 1: This means, for example, that implementations can’t use an object with static storage duration for internal
purposes without synchronization because doing so can cause a data race even in programs that do not explicitly
share objects between threads.—end note]
5 A C++ standard library function shall not access objects indirectly accessible via its arguments or via elements
of its container arguments except by invoking functions required by its specification on those container
elements.
6 Operations on iterators obtained by calling a standard library container or string member function may
access the underlying container, but shall not modify it.
[Note 2: In particular, container operations that invalidate iterators conflict with operations on iterators associated
with that container. —end note]
7 Implementations may share their own internal objects between threads if the objects are not visible to users
and are protected against data races.
8 Unless otherwise specified, C++ standard library functions shall perform all operations solely within the
current thread if those operations have effects that are visible (6.10.2) to users.
9 [Note 3: This allows implementations to parallelize operations if there are no visible side effects.—end note]
16.4.6.11 Properties of library classes [library.class.props]
1 Unless explicitly stated otherwise, it is unspecified whether any class described in Clause 17 through Clause
33 and Annex D is a trivially copyable class, a standard-layout class, or an implicit-lifetime class (11.2).
16.4.6.12 Protection within classes [protection.within.classes]
1 It is unspecified whether any function signature or class described in Clause 17 through Clause 33 and Annex
D is a friend of another class in the C++ standard library.
§ 16.4.6.12 © ISO/IEC
565

===== PAGE 577 =====

Dxxxx
16.4.6.13 Derived classes [derivation]
1 An implementation may derive any class in the C++ standard library from a class with a name reserved to
the implementation.
2 Certain classes defined in the C++ standard library are required to be derived from other classes in the C++
standard library. An implementation may derive such a class directly from the required base or indirectly
through a hierarchy of base classes with names reserved to the implementation.
3 In any case:
—(3.1) Every base class described asvirtual shall be virtual;
—(3.2) Every base class not specified asvirtual shall not be virtual;
—(3.3) Unless explicitly stated otherwise, types with distinct names shall be distinct types.
[Note 1: There is an implicit exception to this rule for types that are described as synonyms (9.2.4, 9.10), such
as size_t (17.2) andstreamoff (31.2.2). —end note]
4 All types specified in the C++ standard library shall be non-final types unless otherwise specified.
16.4.6.14 Restrictions on exception handling [res.on.exception.handling]
1 Any of the functions defined in the C++ standard library can report a failure by throwing an exception of a
type described in itsThrows: paragraph, or of a type derived from a type named in theThrows: paragraph
that would be caught by ahandler (14.4) for the base type.
2 Functions from the C standard library shall not throw exceptions148 except when such a function calls a
program-supplied function that throws an exception.149
3 Destructor operations defined in the C++ standard library shall not throw exceptions. Every destructor in
the C++ standard library shall behave as if it had a non-throwing exception specification (14.5).
4 Functions defined in the C++ standard library that do not have aThrows: paragraph but do have a potentially-
throwing exception specification may throw implementation-defined exceptions.150 Implementations should
report errors by throwing exceptions of or derived from the standard exception classes (17.6.4.1, 17.9, 19.2).
5 An implementation may strengthen the exception specification for a non-virtual function by adding a
non-throwing exception specification.
16.4.6.15 Contract assertions [res.contract.assertions]
1 Unless specified otherwise, an implementation may check the specified preconditions and postconditions of a
function in the C++ standard library using contract assertions (6.11, 16.3.2.4).
16.4.6.16 Value of error codes [value.error.codes]
1 Certain functions in the C++ standard library report errors via aerror_code (19.5.4.1) object. That object’s
category() member shall returnsystem_category() for errors originating from the operating system, or
a reference to an implementation-definederror_category object for errors originating elsewhere. The
implementation shall define the possible values ofvalue() for each of these error categories.
[Example 1: For operating systems that are based on POSIX, implementations should define thestd::system_-
category() values as identical to the POSIXerrno values, with additional values as defined by the operating system’s
documentation. Implementations for operating systems that are not based on POSIX should define values identical to
the operating system’s values. For errors that do not originate from the operating system, the implementation may
provide enums for the associated values.—end example]
16.4.6.17 Moved-from state of library types [lib.types.movedfrom]
1 Objects of types defined in the C++ standard library may be moved from (11.4.5.3). Move operations may
be explicitly specified or implicitly generated. Unless otherwise specified, such moved-from objects shall be
placed in a valid but unspecified state (3.67).
2 An object of a type defined in the C++ standard library may be move-assigned (11.4.6) to itself. Unless
otherwise specified, such an assignment places the object in a valid but unspecified state.
148) That is, the C standard library functions can all be treated as if they are markednoexcept. This allows implementations
to make performance optimizations based on the absence of exceptions at runtime.
149) The functionsqsort() and bsearch() (26.13) meet this condition.
150) In particular, they can report a failure to allocate storage by throwing an exception of typebad_alloc, or a class derived
from bad_alloc (17.6.4.1).
§ 16.4.6.17 © ISO/IEC
566

===== PAGE 578 =====

Dxxxx
17 Language support library [support]
17.1 General [support.general]
1 This Clause describes the function signatures that are called implicitly, and the types of objects generated
implicitly, during the execution of some C++ programs. It also describes the headers that declare these
function signatures and define any related types.
2 The following subclauses describe common type definitions used throughout the library, characteristics of the
predefined types, functions supporting start and termination of a C++ program, support for dynamic memory
management, support for dynamic type identification, support for contract-violation handling, support for
exception processing, support for initializer lists, and other runtime support, as summarized in Table 42.
Table 42 — Language support library summary [tab:support.summary]
Subclause Header
17.2 Common definitions <cstddef>, <cstdlib>
17.3 Implementation properties <cfloat>, <climits>, <limits>, <version>
17.4 Arithmetic types <cstdint>, <stdfloat>
17.5 Start and termination <cstdlib>
17.6 Dynamic memory management <new>
17.7 Type identification <typeinfo>, <typeindex>
17.8 Source location <source_location>
17.9 Exception handling <exception>
17.10 Contract-violation handling <contracts>
17.11 Initializer lists <initializer_list>
17.12 Comparisons <compare>
17.13 Coroutines <coroutine>
17.14 Other runtime support <csetjmp>, <csignal>, <cstdarg>, <cstdlib>
17.2 Common definitions [support.types]
17.2.1 Header <cstddef> synopsis [cstddef.syn]
// all freestanding
namespace std {
using ptrdiff_t = see below ;
using size_t = see below ;
using max_align_t = see below ;
using nullptr_t = decltype(nullptr);
enum class byte : unsigned char {};
// 17.2.5,byte type operations
template<class IntType>
constexpr byte& operator<<=(byte& b, IntType shift) noexcept;
template<class IntType>
constexpr byte operator<<(byte b, IntType shift) noexcept;
template<class IntType>
constexpr byte& operator>>=(byte& b, IntType shift) noexcept;
template<class IntType>
constexpr byte operator>>(byte b, IntType shift) noexcept;
constexpr byte& operator|=(byte& l, byte r) noexcept;
constexpr byte operator|(byte l, byte r) noexcept;
constexpr byte& operator&=(byte& l, byte r) noexcept;
constexpr byte operator&(byte l, byte r) noexcept;
constexpr byte& operator^=(byte& l, byte r) noexcept;
constexpr byte operator^(byte l, byte r) noexcept;
§ 17.2.1 © ISO/IEC
567

===== PAGE 579 =====

Dxxxx
constexpr byte operator~(byte b) noexcept;
template<class IntType>
constexpr IntType to_integer(byte b) noexcept;
}
#define NULL see below
#define offsetof(P, D) see below
1 The contents and meaning of the header<cstddef>are the same as the C standard library header<stddef.h>,
except that it does not declare the typewchar_t, that it does not define the macrounreachable, that it
also declares the typebyte and its associated operations (17.2.5), and as noted in 17.2.3 and 17.2.4.
See also: ISO/IEC 9899:2024, 7.21
17.2.2 Header <cstdlib> synopsis [cstdlib.syn]
namespace std {
using size_t = see below ; // freestanding
using div_t = see below ; // freestanding
using ldiv_t = see below ; // freestanding
using lldiv_t = see below ; // freestanding
}
#define NULL see below // freestanding
#define EXIT_FAILURE see below // freestanding
#define EXIT_SUCCESS see below // freestanding
#define RAND_MAX see below
#define MB_CUR_MAX see below
namespace std {
// Exposition-only function type aliases
extern "C" using c-atexit-handler = void(); // exposition only
extern "C++" using atexit-handler = void(); // exposition only
extern "C" using c-compare-pred = int(const void*, const void*); // exposition only
extern "C++" using compare-pred = int(const void*, const void*); // exposition only
// 17.5, start and termination
[[noreturn]] void abort() noexcept; // freestanding
int atexit(c-atexit-handler * func) noexcept; // freestanding
int atexit(atexit-handler * func) noexcept; // freestanding
int at_quick_exit(c-atexit-handler * func) noexcept; // freestanding
int at_quick_exit(atexit-handler * func) noexcept; // freestanding
[[noreturn]] void exit(int status); // freestanding
[[noreturn]] void _Exit(int status) noexcept; // freestanding
[[noreturn]] void quick_exit(int status) noexcept; // freestanding
char* getenv(const char* name);
int system(const char* string);
// 20.2.12, C library memory allocation
void* aligned_alloc(size_t alignment, size_t size);
void* calloc(size_t nmemb, size_t size);
void free(void* ptr);
void free_sized(void* ptr, size_t size);
void free_aligned_sized(void* ptr, size_t alignment, size_t size);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
size_t memalignment(const void* p); // freestanding
double atof(const char* nptr);
int atoi(const char* nptr);
long int atol(const char* nptr);
long long int atoll(const char* nptr);
double strtod(const char* nptr, char** endptr);
int strfromd(char* s, size_t n, const char* format, double fp);
§ 17.2.2 © ISO/IEC
568

===== PAGE 580 =====

Dxxxx
int strfromf(char* s, size_t n, const char* format, float fp);
int strfroml(char* s, size_t n, const char* format, long double fp);
float strtof(const char* nptr, char** endptr);
long double strtold(const char* nptr, char** endptr);
long int strtol(const char* nptr, char** endptr, int base);
long long int strtoll(const char* nptr, char** endptr, int base);
unsigned long int strtoul(const char* nptr, char** endptr, int base);
unsigned long long int strtoull(const char* nptr, char** endptr, int base);
// 28.7.5, multibyte / wide string and character conversion functions
int mblen(const char* s, size_t n);
int mbtowc(wchar_t* pwc, const char* s, size_t n);
int wctomb(char* s, wchar_t wchar);
size_t mbstowcs(wchar_t* pwcs, const char* s, size_t n);
size_t wcstombs(char* s, const wchar_t* pwcs, size_t n);
// 26.13, C standard library algorithms
void* bsearch(const void* key, void* base, size_t nmemb, size_t size, // freestanding
c-compare-pred * compar);
void* bsearch(const void* key, void* base, size_t nmemb, size_t size, // freestanding
compare-pred * compar);
const void* bsearch(const void* key, const void* base, size_t nmemb, // freestanding
size_t size, c-compare-pred * compar);
const void* bsearch(const void* key, const void* base, size_t nmemb, // freestanding
size_t size, compare-pred * compar);
void qsort(void* base, size_t nmemb, size_t size, c-compare-pred * compar); // freestanding
void qsort(void* base, size_t nmemb, size_t size, compare-pred * compar); // freestanding
// 29.5.10, low-quality random number generation
int rand();
void srand(unsigned int seed);
// 29.7.2, absolute values
constexpr int abs(int j); // freestanding
constexpr long int abs(long int j); // freestanding
constexpr long long int abs(long long int j); // freestanding
constexpr floating-point-type abs(floating-point-type j); // freestanding-deleted
constexpr long int labs(long int j); // freestanding
constexpr long long int llabs(long long int j); // freestanding
constexpr div_t div(int numer, int denom); // freestanding
constexpr ldiv_t div(long int numer, long int denom); // freestanding; see 16.2
constexpr lldiv_t div(long long int numer, long long int denom); // freestanding; see 16.2
constexpr ldiv_t ldiv(long int numer, long int denom); // freestanding
constexpr lldiv_t lldiv(long long int numer, long long int denom); // freestanding
}
1 The contents and meaning of the header<cstdlib>are the same as the C standard library header<stdlib.h>,
except that it does not declare the typeswchar_t or once_flag, and does not declare the functioncall_once,
and except as noted in 17.2.3, 17.2.4, 17.5, 20.2.12, 28.7.5, 26.13, 29.5.10, and 29.7.2.
[Note 1: Several functions have additional overloads in this document, but they have the same behavior as in the C
standard library (16.2). —end note]
See also: ISO/IEC 9899:2024, 7.24
17.2.3 Null pointers [support.types.nullptr]
1 The type nullptr_t is a synonym for the type of anullptr expression, and it has the characteristics
described in 6.9.2 and 7.3.12.
[Note 1: Although nullptr’s address cannot be taken, the address of anothernullptr_t object that is an lvalue can
be taken. —end note]
§ 17.2.3 © ISO/IEC
569

===== PAGE 581 =====

Dxxxx
2 The macroNULL is an implementation-defined null pointer constant.151
See also: ISO/IEC 9899:2024, 7.21
17.2.4 Sizes, alignments, and offsets [support.types.layout]
1 The macrooffsetof(type, member-designator )has the same semantics as the corresponding macro in the
C standard library header<stddef.h>, but accepts a restricted set oftype arguments in this document. Use
of theoffsetof macro with atype other than a standard-layout class (11.2) is conditionally-supported.152
The expressionoffsetof(type, member-designator ) is never type-dependent (13.8.3.3) and it is value-
dependent (13.8.3.4) if and only iftype is dependent. The result of applying theoffsetof macro to a static
data member or a function member is undefined. No operation invoked by theoffsetof macro shall throw
an exception andnoexcept(offsetof(type, member-designator )) shall betrue.
2 The typeptrdiff_t is an implementation-defined signed integer type that can hold the difference of two
subscripts in an array object, as described in 7.6.6.
3 The typesize_t is an implementation-defined unsigned integer type that is large enough to contain the size
in bytes of any object (7.6.2.5).
4 Recommended practice: An implementation should choose types forptrdiff_t and size_t whose integer
conversion ranks (6.9.6) are no greater than that ofsigned long int unless a larger size is necessary to
contain all the possible values.
5 The typemax_align_t is a trivially copyable standard-layout type whose alignment requirement is at least
as great as that of every scalar type, and whose alignment requirement is supported in every context (6.8.3).
std::is_trivially_default_constructible_v<max_align_t> is true.
See also: ISO/IEC 9899:2024, 7.21
17.2.5 byte type operations [support.types.byteops]
template<class IntType>
constexpr byte& operator<<=(byte& b, IntType shift) noexcept;
1 Constraints: is_integral_v<IntType> is true.
2 Effects: Equivalent to:return b = b << shift;
template<class IntType>
constexpr byte operator<<(byte b, IntType shift) noexcept;
3 Constraints: is_integral_v<IntType> is true.
4 Effects: Equivalent to:
return static_cast<byte>(static_cast<unsigned int>(b) << shift);
template<class IntType>
constexpr byte& operator>>=(byte& b, IntType shift) noexcept;
5 Constraints: is_integral_v<IntType> is true.
6 Effects: Equivalent to:return b = b >> shift;
template<class IntType>
constexpr byte operator>>(byte b, IntType shift) noexcept;
7 Constraints: is_integral_v<IntType> is true.
8 Effects: Equivalent to:
return static_cast<byte>(static_cast<unsigned int>(b) >> shift);
constexpr byte& operator|=(byte& l, byte r) noexcept;
9 Effects: Equivalent to:return l = l | r;
151) Possible definitions include0 and 0L, but not(void*)0.
152) Note thatoffsetof is required to work as specified even if unaryoperator& is overloaded for any of the types involved.
§ 17.2.5 © ISO/IEC
570

===== PAGE 582 =====

Dxxxx
constexpr byte operator|(byte l, byte r) noexcept;
10 Effects: Equivalent to:
return static_cast<byte>(static_cast<unsigned int>(l) | static_cast<unsigned int>(r));
constexpr byte& operator&=(byte& l, byte r) noexcept;
11 Effects: Equivalent to:return l = l & r;
constexpr byte operator&(byte l, byte r) noexcept;
12 Effects: Equivalent to:
return static_cast<byte>(static_cast<unsigned int>(l) & static_cast<unsigned int>(r));
constexpr byte& operator^=(byte& l, byte r) noexcept;
13 Effects: Equivalent to:return l = l ^ r;
constexpr byte operator^(byte l, byte r) noexcept;
14 Effects: Equivalent to:
return static_cast<byte>(static_cast<unsigned int>(l) ^ static_cast<unsigned int>(r));
constexpr byte operator~(byte b) noexcept;
15 Effects: Equivalent to:
return static_cast<byte>(~static_cast<unsigned int>(b));
template<class IntType>
constexpr IntType to_integer(byte b) noexcept;
16 Constraints: is_integral_v<IntType> is true.
17 Effects: Equivalent to:return static_cast<IntType>(b);
17.3 Implementation properties [support.limits]
17.3.1 General [support.limits.general]
1 The headers<limits> (17.3.3), <climits> (17.3.6), and<cfloat> (17.3.7) supply characteristics of imple-
mentation-dependent arithmetic types (6.9.2).
17.3.2 Header <version> synopsis [version.syn]
1 The header<version> supplies implementation-dependent information about the C++ standard library (e.g.,
version number and release date).
2 Each of the macros defined in<version> is also defined after inclusion of any member of the set of library
headers indicated in the corresponding comment in this synopsis.
[Note 1: Future revisions of this document might replace the values of these macros with greater values.—end note]
#define __cpp_lib_adaptor_iterator_pair_constructor 202106L // also in<stack>, <queue>
#define __cpp_lib_addressof_constexpr 201603L // freestanding, also in<memory>
#define __cpp_lib_algorithm_default_value_type 202403L
// also in<algorithm>, <ranges>, <string>, <deque>, <list>, <forward_list>, <vector>
#define __cpp_lib_algorithm_iterator_requirements 202207L
// also in<algorithm>, <numeric>, <memory>
#define __cpp_lib_aligned_accessor 202411L // freestanding, also in<mdspan>
#define __cpp_lib_allocate_at_least 202302L // also in<memory>
#define __cpp_lib_allocator_traits_is_always_equal 201411L
// freestanding, also in<memory>, <scoped_allocator>, <string>, <deque>, <forward_list>, <list>,
// <vector>, <map>, <set>, <unordered_map>, <unordered_set>
#define __cpp_lib_any 201606L // also in<any>
#define __cpp_lib_apply 202506L // freestanding, also in <tuple>, <type_-
traits>
#define __cpp_lib_array_constexpr 201811L
// freestanding, also in<iterator>, <array>
#define __cpp_lib_as_const 201510L // freestanding, also in<utility>
#define __cpp_lib_associative_heterogeneous_erasure 202110L
// also in<map>, <set>, <unordered_map>, <unordered_set>
§ 17.3.2 © ISO/IEC
571

===== PAGE 583 =====

Dxxxx
#define __cpp_lib_associative_heterogeneous_insertion 202306L
// also in<map>, <set>, <unordered_map>, <unordered_set>
#define __cpp_lib_assume_aligned 201811L // freestanding, also in<memory>
#define __cpp_lib_atomic_flag_test 201907L // freestanding, also in<atomic>
#define __cpp_lib_atomic_float 201711L // freestanding, also in<atomic>
#define __cpp_lib_atomic_is_always_lock_free 201603L // freestanding, also in<atomic>
#define __cpp_lib_atomic_lock_free_type_aliases 201907L // also in<atomic>
#define __cpp_lib_atomic_min_max 202506L // freestanding, also in<atomic>
#define __cpp_lib_atomic_reductions 202506L // freestanding, also in<atomic>
#define __cpp_lib_atomic_ref 202411L // freestanding, also in<atomic>
#define __cpp_lib_atomic_shared_ptr 201711L // also in<memory>
#define __cpp_lib_atomic_value_initialization 201911L // freestanding, also in<atomic>, <memory>
#define __cpp_lib_atomic_wait 201907L // freestanding, also in<atomic>
#define __cpp_lib_barrier 202302L // also in<barrier>
#define __cpp_lib_bind_back 202306L // freestanding, also in<functional>
#define __cpp_lib_bind_front 202306L // freestanding, also in<functional>
#define __cpp_lib_bit_cast 201806L // freestanding, also in<bit>
#define __cpp_lib_bitops 201907L // freestanding, also in<bit>
#define __cpp_lib_bitset 202306L // also in<bitset>
#define __cpp_lib_bool_constant 201505L // freestanding, also in<type_traits>
#define __cpp_lib_bounded_array_traits 201902L // freestanding, also in<type_traits>
#define __cpp_lib_boyer_moore_searcher 201603L // also in<functional>
#define __cpp_lib_byte 201603L // freestanding, also in<cstddef>
#define __cpp_lib_byteswap 202110L // freestanding, also in<bit>
#define __cpp_lib_char8_t 201907L
// freestanding, also in <atomic>, <filesystem>, <iosfwd>, <istream>, <limits>, <locale>, <ostream>,
<string>,
// <string_view>
#define __cpp_lib_chrono 202306L // also in<chrono>
#define __cpp_lib_chrono_udls 201304L // also in<chrono>
#define __cpp_lib_clamp 201603L // freestanding, also in<algorithm>
#define __cpp_lib_common_reference 202302L // freestanding, also in<type_traits>
#define __cpp_lib_common_reference_wrapper 202302L // freestanding, also in<functional>
#define __cpp_lib_complex_udls 201309L // also in<complex>
#define __cpp_lib_concepts 202207L
// freestanding, also in<concepts>, <compare>
#define __cpp_lib_constant_wrapper 202506L // freestanding, also in<type_traits>
#define __cpp_lib_constexpr_algorithms 202306L // also in<algorithm>, <utility>
#define __cpp_lib_constexpr_atomic 202411L // also in<atomic>
#define __cpp_lib_constexpr_bitset 202207L // also in<bitset>
#define __cpp_lib_constexpr_charconv 202207L // freestanding, also in<charconv>
#define __cpp_lib_constexpr_cmath 202306L // also in<cmath>, <cstdlib>
#define __cpp_lib_constexpr_complex 202306L // also in<complex>
#define __cpp_lib_constexpr_deque 202502L // also in<deque>
#define __cpp_lib_constexpr_dynamic_alloc 201907L // also in<memory>
#define __cpp_lib_constexpr_exceptions 202502L
// also in<exception>, <stdexcept>, <expected>, <optional>, <variant>, and<format>
#define __cpp_lib_constexpr_flat_map 202502L // also in<flat_map>
#define __cpp_lib_constexpr_flat_set 202502L // also in<flat_set>
#define __cpp_lib_constexpr_format 202511L // also in<format>
#define __cpp_lib_constexpr_forward_list 202502L // also in<forward_list>
#define __cpp_lib_constexpr_functional 201907L // freestanding, also in<functional>
#define __cpp_lib_constexpr_inplace_vector 202502L // also in<inplace_vector>
#define __cpp_lib_constexpr_iterator 201811L // freestanding, also in<iterator>
#define __cpp_lib_constexpr_list 202502L // also in<list>
#define __cpp_lib_constexpr_map 202502L // also in<map>
#define __cpp_lib_constexpr_memory 202506L // freestanding, also in<memory>
#define __cpp_lib_constexpr_new 202406L // freestanding, also in<new>
#define __cpp_lib_constexpr_numeric 201911L // freestanding, also in<numeric>
#define __cpp_lib_constexpr_queue 202502L // also in<queue>
#define __cpp_lib_constexpr_set 202502L // also in<set>
#define __cpp_lib_constexpr_stack 202502L // also in<stack>
#define __cpp_lib_constexpr_string 201907L // also in<string>
#define __cpp_lib_constexpr_string_view 201811L // also in<string_view>
§ 17.3.2 © ISO/IEC
572

===== PAGE 584 =====

Dxxxx
#define __cpp_lib_constexpr_tuple 201811L // freestanding, also in<tuple>
#define __cpp_lib_constexpr_typeinfo 202106L // freestanding, also in<typeinfo>
#define __cpp_lib_constexpr_unordered_map 202502L // also in<unordered_map>
#define __cpp_lib_constexpr_unordered_set 202502L // also in<unordered_set>
#define __cpp_lib_constexpr_utility 201811L // freestanding, also in<utility>
#define __cpp_lib_constexpr_vector 201907L // also in<vector>
#define __cpp_lib_constrained_equality 202411L // freestanding,
// also in<utility>, <tuple>, <optional>, <variant>, <expected>
#define __cpp_lib_containers_ranges 202202L
// also in<vector>, <list>, <forward_list>, <map>, <set>, <unordered_map>, <unordered_set>,
// <deque>, <queue>, <stack>, <string>
#define __cpp_lib_contracts 202502L // freestanding, also in<contracts>
#define __cpp_lib_copyable_function 202306L // also in<functional>
#define __cpp_lib_coroutine 201902L // freestanding, also in<coroutine>
#define __cpp_lib_counting_scope 202506L // also in<execution>
#define __cpp_lib_debugging 202403L // freestanding, also in<debugging>
#define __cpp_lib_define_static 202506L // freestanding, also in<meta>
#define __cpp_lib_destroying_delete 201806L // freestanding, also in<new>
#define __cpp_lib_enable_shared_from_this 201603L // also in<memory>
#define __cpp_lib_endian 201907L // freestanding, also in<bit>
#define __cpp_lib_erase_if 202002L
// also in<string>, <deque>, <forward_list>, <list>, <vector>, <map>, <set>, <unordered_map>,
// <unordered_set>
#define __cpp_lib_exception_ptr_cast 202506L // also in<exception>
#define __cpp_lib_exchange_function 201304L // freestanding, also in<utility>
#define __cpp_lib_execution 201902L // also in<execution>
#define __cpp_lib_expected 202211L // also in<expected>
#define __cpp_lib_filesystem 201703L // also in<filesystem>
#define __cpp_lib_flat_map 202511L // also in<flat_map>
#define __cpp_lib_flat_set 202511L // also in<flat_set>
#define __cpp_lib_format 202311L // also in<format>
#define __cpp_lib_format_path 202506L // also in<filesystem>
#define __cpp_lib_format_ranges 202207L // also in<format>
#define __cpp_lib_format_uchar 202311L // also in<format>
#define __cpp_lib_formatters 202302L // also in<stacktrace>, <thread>
#define __cpp_lib_forward_like 202207L // freestanding, also in<utility>
#define __cpp_lib_freestanding_algorithm 202502L // freestanding, also in<algorithm>
#define __cpp_lib_freestanding_array 202311L // freestanding, also in<array>
#define __cpp_lib_freestanding_char_traits 202306L // freestanding, also in<string>
#define __cpp_lib_freestanding_charconv 202306L // freestanding, also in<charconv>
#define __cpp_lib_freestanding_cstdlib 202306L // freestanding, also in<cstdlib>, <cmath>
#define __cpp_lib_freestanding_cstring 202311L // freestanding, also in<cstring>
#define __cpp_lib_freestanding_cwchar 202306L // freestanding, also in<cwchar>
#define __cpp_lib_freestanding_errc 202306L
// freestanding, also in<cerrno>, <system_error>
#define __cpp_lib_freestanding_execution 202502L // freestanding, also in<execution>
#define __cpp_lib_freestanding_expected 202311L // freestanding, also in<expected>
#define __cpp_lib_freestanding_feature_test_macros 202306L // freestanding
#define __cpp_lib_freestanding_functional 202306L // freestanding, also in<functional>
#define __cpp_lib_freestanding_iterator 202306L // freestanding, also in<iterator>
#define __cpp_lib_freestanding_mdspan 202311L // freestanding, also in<mdspan>
#define __cpp_lib_freestanding_memory 202502L // freestanding, also in<memory>
#define __cpp_lib_freestanding_numeric 202502L // freestanding, also in<numeric>
#define __cpp_lib_freestanding_operator_new see below // freestanding, also in<new>
#define __cpp_lib_freestanding_optional 202506L // freestanding, also in<optional>
#define __cpp_lib_freestanding_random 202502L // freestanding, also in<random>
#define __cpp_lib_freestanding_ranges 202306L // freestanding, also in<ranges>
#define __cpp_lib_freestanding_ratio 202306L // freestanding, also in<ratio>
#define __cpp_lib_freestanding_string_view 202311L // freestanding, also in<string_view>
#define __cpp_lib_freestanding_tuple 202306L // freestanding, also in<tuple>
#define __cpp_lib_freestanding_utility 202306L // freestanding, also in<utility>
#define __cpp_lib_freestanding_variant 202311L // freestanding, also in<variant>
#define __cpp_lib_fstream_native_handle 202306L // also in<fstream>
#define __cpp_lib_function_ref 202511L // freestanding, also in<functional>
§ 17.3.2 © ISO/IEC
573

===== PAGE 585 =====

Dxxxx
#define __cpp_lib_gcd_lcm 201606L // freestanding, also in<numeric>
#define __cpp_lib_generator 202207L // also in<generator>
#define __cpp_lib_generic_associative_lookup 201304L // also in<map>, <set>
#define __cpp_lib_generic_unordered_lookup 201811L
// also in<unordered_map>, <unordered_set>
#define __cpp_lib_hardware_interference_size 201703L // freestanding, also in<new>
#define __cpp_lib_has_unique_object_representations 201606L // freestanding, also in<type_traits>
#define __cpp_lib_hazard_pointer 202306L // also in<hazard_pointer>
#define __cpp_lib_hive 202502L // also in<hive>
#define __cpp_lib_hypot 201603L // also in<cmath>
#define __cpp_lib_incomplete_container_elements 201505L
// also in<forward_list>, <list>, <vector>
#define __cpp_lib_indirect 202502L // also in<memory>
#define __cpp_lib_initializer_list 202511L
// freestanding, also in<initializer_list>
#define __cpp_lib_inplace_vector 202406L // also in<inplace_vector>
#define __cpp_lib_int_pow2 202002L // freestanding, also in<bit>
#define __cpp_lib_integer_comparison_functions 202002L // freestanding, also in<utility>
#define __cpp_lib_integer_sequence 202511L // freestanding, also in<utility>
#define __cpp_lib_integral_constant_callable 201304L // freestanding, also in<type_traits>
#define __cpp_lib_interpolate 201902L // also in<cmath>, <numeric>
#define __cpp_lib_invoke 201411L // freestanding, also in<functional>
#define __cpp_lib_invoke_r 202106L // freestanding, also in<functional>
#define __cpp_lib_ios_noreplace 202207L // also in<ios>
#define __cpp_lib_is_aggregate 201703L // freestanding, also in<type_traits>
#define __cpp_lib_is_constant_evaluated 201811L // freestanding, also in<type_traits>
#define __cpp_lib_is_final 201402L // freestanding, also in<type_traits>
#define __cpp_lib_is_implicit_lifetime 202302L // freestanding, also in<type_traits>
#define __cpp_lib_is_invocable 201703L // freestanding, also in<type_traits>
#define __cpp_lib_is_layout_compatible 201907L // freestanding, also in<type_traits>
#define __cpp_lib_is_nothrow_convertible 201806L // freestanding, also in<type_traits>
#define __cpp_lib_is_null_pointer 201309L // freestanding, also in<type_traits>
#define __cpp_lib_is_pointer_interconvertible 201907L // freestanding, also in<type_traits>
#define __cpp_lib_is_scoped_enum 202011L // freestanding, also in<type_traits>
#define __cpp_lib_is_sufficiently_aligned 202411L // freestanding, also in<memory>
#define __cpp_lib_is_swappable 201603L // freestanding, also in<type_traits>
#define __cpp_lib_is_virtual_base_of 202406L // freestanding, also in<type_traits>
#define __cpp_lib_is_within_lifetime 202306L // freestanding, also in<type_traits>
#define __cpp_lib_jthread 201911L // also in<stop_token>, <thread>
#define __cpp_lib_latch 201907L // also in<latch>
#define __cpp_lib_launder 201606L // freestanding, also in<new>
#define __cpp_lib_linalg 202511L // also in<linalg>
#define __cpp_lib_list_remove_return_type 201806L // also in<forward_list>, <list>
#define __cpp_lib_logical_traits 201510L // freestanding, also in<type_traits>
#define __cpp_lib_make_from_tuple 201606L // freestanding, also in<tuple>
#define __cpp_lib_make_reverse_iterator 201402L // freestanding, also in<iterator>
#define __cpp_lib_make_unique 201304L // also in<memory>
#define __cpp_lib_map_try_emplace 201411L // also in<map>
#define __cpp_lib_math_constants 201907L // also in<numbers>
#define __cpp_lib_math_special_functions 201603L // also in<cmath>
#define __cpp_lib_mdspan 202406L // freestanding, also in<mdspan>
#define __cpp_lib_memory_resource 201603L // also in<memory_resource>
#define __cpp_lib_modules 202207L // freestanding
#define __cpp_lib_move_iterator_concept 202207L // freestanding, also in<iterator>
#define __cpp_lib_move_only_function 202110L // also in<functional>
#define __cpp_lib_node_extract 201606L
// also in<map>, <set>, <unordered_map>, <unordered_set>
#define __cpp_lib_nonmember_container_access 201411L
// freestanding, also in<array>, <deque>, <forward_list>, <iterator>, <list>, <map>, <regex>, <set>,
// <string>, <unordered_map>, <unordered_set>, <vector>
#define __cpp_lib_not_fn 202306L // freestanding, also in<functional>
#define __cpp_lib_null_iterators 201304L // freestanding, also in<iterator>
#define __cpp_lib_observable_checkpoint 202506L // freestanding, also in<utility>
#define __cpp_lib_optional 202506L // also in<optional>
§ 17.3.2 © ISO/IEC
574

===== PAGE 586 =====

Dxxxx
#define __cpp_lib_optional_range_support 202406L // freestanding, also in<optional>
#define __cpp_lib_out_ptr 202311L // freestanding, also in<memory>
#define __cpp_lib_parallel_algorithm 202506L
// also in<algorithm>, <numeric>, <memory>
#define __cpp_lib_parallel_scheduler 202506L // also in<execution>
#define __cpp_lib_philox_engine 202406L // also in<random>
#define __cpp_lib_polymorphic 202502L // also in<memory>
#define __cpp_lib_polymorphic_allocator 201902L // also in<memory_resource>
#define __cpp_lib_print 202406L // also in<print>, <ostream>
#define __cpp_lib_quoted_string_io 201304L // also in<iomanip>
#define __cpp_lib_ranges 202406L
// also in<algorithm>, <functional>, <iterator>, <memory>, <ranges>
#define __cpp_lib_ranges_as_const 202311L // freestanding, also in<ranges>
#define __cpp_lib_ranges_as_rvalue 202207L // freestanding, also in<ranges>
#define __cpp_lib_ranges_cache_latest 202411L // freestanding, also in<ranges>
#define __cpp_lib_ranges_cartesian_product 202207L // freestanding, also in<ranges>
#define __cpp_lib_ranges_chunk 202202L // freestanding, also in<ranges>
#define __cpp_lib_ranges_chunk_by 202202L // freestanding, also in<ranges>
#define __cpp_lib_ranges_concat 202403L // freestanding, also in<ranges>
#define __cpp_lib_ranges_contains 202207L // freestanding, also in<algorithm>
#define __cpp_lib_ranges_enumerate 202302L // freestanding, also in<ranges>
#define __cpp_lib_ranges_find_last 202207L // freestanding, also in<algorithm>
#define __cpp_lib_ranges_fold 202207L // freestanding, also in<algorithm>
#define __cpp_lib_ranges_generate_random 202403L // also in<random>
#define __cpp_lib_ranges_indices 202506L // also in<ranges>
#define __cpp_lib_ranges_iota 202202L // freestanding, also in<numeric>
#define __cpp_lib_ranges_join_with 202202L // freestanding, also in<ranges>
#define __cpp_lib_ranges_repeat 202207L // freestanding, also in<ranges>
#define __cpp_lib_ranges_reserve_hint 202502L // also in<ranges>
#define __cpp_lib_ranges_slide 202202L // freestanding, also in<ranges>
#define __cpp_lib_ranges_starts_ends_with 202106L // freestanding, also in<algorithm>
#define __cpp_lib_ranges_stride 202207L // freestanding, also in<ranges>
#define __cpp_lib_ranges_to_container 202202L // freestanding, also in<ranges>
#define __cpp_lib_ranges_to_input 202502L // freestanding, also in<ranges>
#define __cpp_lib_ranges_zip 202110L
// freestanding, also in<ranges>, <tuple>, <utility>
#define __cpp_lib_ratio 202306L // freestanding, also in<ratio>
#define __cpp_lib_raw_memory_algorithms 202411L // also in<memory>
#define __cpp_lib_rcu 202306L // also in<rcu>
#define __cpp_lib_reference_from_temporary 202202L // freestanding, also in<type_traits>
#define __cpp_lib_reference_wrapper 202403L // freestanding, also in<functional>
#define __cpp_lib_reflection 202506L // also in<meta>
#define __cpp_lib_remove_cvref 201711L // freestanding, also in<type_traits>
#define __cpp_lib_result_of_sfinae 201210L
// freestanding, also in<functional>, <type_traits>
#define __cpp_lib_robust_nonmodifying_seq_ops 201304L // freestanding, also in<algorithm>
#define __cpp_lib_sample 201603L // freestanding, also in<algorithm>
#define __cpp_lib_saturation_arithmetic 202311L // freestanding, also in<numeric>
#define __cpp_lib_scoped_lock 201703L // also in<mutex>
#define __cpp_lib_semaphore 201907L // also in<semaphore>
#define __cpp_lib_senders 202506L // also in<execution>
#define __cpp_lib_shared_mutex 201505L // also in<shared_mutex>
#define __cpp_lib_shared_ptr_arrays 201707L // also in<memory>
#define __cpp_lib_shared_ptr_weak_type 201606L // also in<memory>
#define __cpp_lib_shared_timed_mutex 201402L // also in<shared_mutex>
#define __cpp_lib_shift 202202L // also in<algorithm>
#define __cpp_lib_simd 202511L // also in<simd>
#define __cpp_lib_simd_complex 202502L // also in<simd>
#define __cpp_lib_simd_permutations 202506L // also in<simd>
#define __cpp_lib_smart_ptr_for_overwrite 202002L // also in<memory>
#define __cpp_lib_smart_ptr_owner_equality 202306L // also in<memory>
#define __cpp_lib_source_location 201907L // freestanding, also in<source_location>
#define __cpp_lib_span 202311L // freestanding, also in<span>
#define __cpp_lib_span_initializer_list 202311L // freestanding, also in<span>
§ 17.3.2 © ISO/IEC
575

===== PAGE 587 =====

Dxxxx
#define __cpp_lib_spanstream 202106L // also in<iosfwd>, <spanstream>
#define __cpp_lib_ssize 201902L // freestanding, also in<iterator>
#define __cpp_lib_sstream_from_string_view 202306L // also in<sstream>
#define __cpp_lib_stacktrace 202011L // also in<stacktrace>
#define __cpp_lib_start_lifetime_as 202207L // freestanding, also in<memory>
#define __cpp_lib_starts_ends_with 201711L // also in<string>, <string_view>
#define __cpp_lib_stdatomic_h 202011L // also in<stdatomic.h>
#define __cpp_lib_string_contains 202011L // also in<string>, <string_view>
#define __cpp_lib_string_resize_and_overwrite 202110L // also in<string>
#define __cpp_lib_string_subview 202506L // also in<string>, <string_view>
#define __cpp_lib_string_udls 201304L // also in<string>
#define __cpp_lib_string_view 202403L // also in<string>, <string_view>
#define __cpp_lib_submdspan 202511L // freestanding, also in<mdspan>
#define __cpp_lib_syncbuf 201803L // also in<iosfwd>, <syncstream>
#define __cpp_lib_task 202506L // also in<execution>
#define __cpp_lib_text_encoding 202306L // also in<text_encoding>
#define __cpp_lib_three_way_comparison 201907L // freestanding, also in<compare>
#define __cpp_lib_to_address 201711L // freestanding, also in<memory>
#define __cpp_lib_to_array 201907L // freestanding, also in<array>
#define __cpp_lib_to_chars 202306L // also in<charconv>
#define __cpp_lib_to_string 202306L // also in<string>
#define __cpp_lib_to_underlying 202102L // freestanding, also in<utility>
#define __cpp_lib_transformation_trait_aliases 201304L // freestanding, also in<type_traits>
#define __cpp_lib_transparent_operators 201510L
// freestanding, also in<memory>, <functional>
#define __cpp_lib_tuple_element_t 201402L // freestanding, also in<tuple>
#define __cpp_lib_tuple_like 202311L
// also in<utility>, <tuple>, <map>, <unordered_map>
#define __cpp_lib_tuples_by_type 201304L // freestanding, also in<utility>, <tuple>
#define __cpp_lib_type_identity 201806L // freestanding, also in<type_traits>
#define __cpp_lib_type_order 202506L // also in<compare>
#define __cpp_lib_type_trait_variable_templates 201510L // freestanding, also in<type_traits>
#define __cpp_lib_uncaught_exceptions 201411L // freestanding, also in<exception>
#define __cpp_lib_unordered_map_try_emplace 201411L // also in<unordered_map>
#define __cpp_lib_unreachable 202202L // freestanding, also in<utility>
#define __cpp_lib_unwrap_ref 201811L // freestanding, also in<type_traits>
#define __cpp_lib_valarray 202511L // also in<valarray>
#define __cpp_lib_variant 202306L // also in<variant>
#define __cpp_lib_void_t 201411L // freestanding, also in<type_traits>
3 Additionally, each of the following macros is defined in a hardened implementation:
#define __cpp_lib_hardened_array 202502L // also in<array>
#define __cpp_lib_hardened_basic_stacktrace 202506L // also in<stacktrace>
#define __cpp_lib_hardened_basic_string 202502L // also in<string>
#define __cpp_lib_hardened_basic_string_view 202502L // also in<string_view>
#define __cpp_lib_hardened_bitset 202502L // also in<bitset>
#define __cpp_lib_hardened_common_iterator 202506L // also in<iterator>
#define __cpp_lib_hardened_counted_iterator 202506L // also in<iterator>
#define __cpp_lib_hardened_deque 202502L // also in<deque>
#define __cpp_lib_hardened_expected 202502L // also in<expected>
#define __cpp_lib_hardened_forward_list 202502L // also in<forward_list>
#define __cpp_lib_hardened_inplace_vector 202502L // also in<inplace_vector>
#define __cpp_lib_hardened_list 202502L // also in<list>
#define __cpp_lib_hardened_mdspan 202502L // also in<mdspan>
#define __cpp_lib_hardened_optional 202502L // also in<optional>
#define __cpp_lib_hardened_shared_ptr_array 202506L // also in<memory>
#define __cpp_lib_hardened_span 202502L // also in<span>
#define __cpp_lib_hardened_valarray 202502L // also in<valarray>
#define __cpp_lib_hardened_vector 202502L // also in<vector>
#define __cpp_lib_hardened_view_interface 202506L // also in<ranges>
4 The macro__cpp_lib_freestanding_operator_new is defined to the integer literal202306Lif all the default
versions of the replaceable global allocation functions meet the requirements of a hosted implementation, and
to the integer literal0 otherwise (17.6.3).
§ 17.3.2 © ISO/IEC
576

===== PAGE 588 =====

Dxxxx
5 Recommended practice: Freestanding implementations should only define a macro from<version> if the
implementation provides the corresponding facility in its entirety.
6 Recommended practice: A non-hardened implementation should not define macros from<version> required
for hardened implementations.
17.3.3 Header <limits> synopsis [limits.syn]
// all freestanding
namespace std {
// 17.3.4, enumerationfloat_round_style
enum float_round_style;
// 17.3.5, class templatenumeric_limits
template<class T> class numeric_limits;
template<class T> class numeric_limits<const T>;
template<class T> class numeric_limits<volatile T>;
template<class T> class numeric_limits<const volatile T>;
template<> class numeric_limits<bool>;
template<> class numeric_limits<char>;
template<> class numeric_limits<signed char>;
template<> class numeric_limits<unsigned char>;
template<> class numeric_limits<char8_t>;
template<> class numeric_limits<char16_t>;
template<> class numeric_limits<char32_t>;
template<> class numeric_limits<wchar_t>;
template<> class numeric_limits<short>;
template<> class numeric_limits<int>;
template<> class numeric_limits<long>;
template<> class numeric_limits<long long>;
template<> class numeric_limits<unsigned short>;
template<> class numeric_limits<unsigned int>;
template<> class numeric_limits<unsigned long>;
template<> class numeric_limits<unsigned long long>;
template<> class numeric_limits<float>;
template<> class numeric_limits<double>;
template<> class numeric_limits<long double>;
}
17.3.4 Enum float_round_style [round.style]
namespace std {
enum float_round_style {
round_indeterminate = -1,
round_toward_zero = 0,
round_to_nearest = 1,
round_toward_infinity = 2,
round_toward_neg_infinity = 3
};
}
1 The rounding mode for floating-point arithmetic is characterized by the values:
—(1.1) round_indeterminate if the rounding style is indeterminable
—(1.2) round_toward_zero if the rounding style is toward zero
—(1.3) round_to_nearest if the rounding style is to the nearest representable value
—(1.4) round_toward_infinity if the rounding style is toward infinity
—(1.5) round_toward_neg_infinity if the rounding style is toward negative infinity
§ 17.3.4 © ISO/IEC
577

===== PAGE 589 =====

Dxxxx
17.3.5 Class template numeric_limits [numeric.limits]
17.3.5.1 General [numeric.limits.general]
1 The numeric_limits class template provides a C++ program with information about various properties of
the implementation’s representation of the arithmetic types.
namespace std {
template<class T> class numeric_limits {
public:
static constexpr bool is_specialized = false;
static constexpr T min() noexcept { return T(); }
static constexpr T max() noexcept { return T(); }
static constexpr T lowest() noexcept { return T(); }
static constexpr int digits = 0;
static constexpr int digits10 = 0;
static constexpr int max_digits10 = 0;
static constexpr bool is_signed = false;
static constexpr bool is_integer = false;
static constexpr bool is_exact = false;
static constexpr int radix = 0;
static constexpr T epsilon() noexcept { return T(); }
static constexpr T round_error() noexcept { return T(); }
static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;
static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr T infinity() noexcept { return T(); }
static constexpr T quiet_NaN() noexcept { return T(); }
static constexpr T signaling_NaN() noexcept { return T(); }
static constexpr T denorm_min() noexcept { return T(); }
static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = false;
static constexpr bool is_modulo = false;
static constexpr bool traps = false;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};
}
2 For all members declaredstatic constexprin thenumeric_limits template, specializations shall define
these values in such a way that they are usable as constant expressions.
3 For thenumeric_limits primary template, all data members are value-initialized and all member functions
return a value-initialized object.
[Note 1: This means all members have zero orfalse values unlessnumeric_limits is specialized for a type.—end
note]
4 Specializations shall be provided for each arithmetic type, both floating-point and integer, includingbool.
The memberis_specialized shall betrue for all such specializations ofnumeric_limits.
5 The value of each member of a specialization ofnumeric_limits on a cv-qualified typecv T shall be equal
to the value of the corresponding member of the specialization on the unqualified typeT.
6 Non-arithmetic standard types, such ascomplex<T> (29.4.3), shall not have specializations.
17.3.5.2 numeric_limits members [numeric.limits.members]
1 Each member function defined in this subclause is signal-safe (17.14.5).
[Note 1: The arithmetic specification described in ISO/IEC 10967-1:2012 is commonly termed LIA-1.—end note]
§ 17.3.5.2 © ISO/IEC
578

===== PAGE 590 =====

Dxxxx
static constexpr T min() noexcept;
2 Minimum finite value.153
3 For floating-point types with subnormal numbers, returns the minimum positive normalized value.
4 Meaningful for all specializations in whichis_bounded != false, oris_bounded == false && is_-
signed == false.
static constexpr T max() noexcept;
5 Maximum finite value.154
6 Meaningful for all specializations in whichis_bounded != false.
static constexpr T lowest() noexcept;
7 A finite valuex such that there is no other finite valuey where y < x.155
8 Meaningful for all specializations in whichis_bounded != false.
static constexpr int digits;
9 Number ofradix digits that can be represented without change.
10 For integer types, the number of non-sign bits in the representation.
11 For floating-point types, the number ofradix digits in the significand.156
static constexpr int digits10;
12 Number of base 10 digits that can be represented without change.157
13 Meaningful for all specializations in whichis_bounded != false.
static constexpr int max_digits10;
14 Number of base 10 digits required to ensure that values which differ are always differentiated.
15 Meaningful for all floating-point types.
static constexpr bool is_signed;
16 true if the type is signed.
17 Meaningful for all specializations.
static constexpr bool is_integer;
18 true if the type is integer.
19 Meaningful for all specializations.
static constexpr bool is_exact;
20 true if the type uses an exact representation. All integer types are exact, but not all exact types are
integer. For example, rational and fixed-exponent representations are exact but not integer.
21 Meaningful for all specializations.
static constexpr int radix;
22 For floating-point types, specifies the base or radix of the exponent representation (often 2).158
23 For integer types, specifies the base of the representation.159
24 Meaningful for all specializations.
153) Equivalent toCHAR_MIN, SHRT_MIN, FLT_MIN, DBL_MIN, etc.
154) Equivalent toCHAR_MAX, SHRT_MAX, FLT_MAX, DBL_MAX, etc.
155) lowest() is necessary because not all floating-point representations have a smallest (most negative) value that is the
negative of the largest (most positive) finite value.
156) Equivalent toFLT_MANT_DIG, DBL_MANT_DIG, LDBL_MANT_DIG.
157) Equivalent toFLT_DIG, DBL_DIG, LDBL_DIG.
158) Equivalent toFLT_RADIX.
159) Distinguishes types with bases other than 2 (e.g., BCD).
§ 17.3.5.2 © ISO/IEC
579

===== PAGE 591 =====

Dxxxx
static constexpr T epsilon() noexcept;
25 Machine epsilon: the difference between 1 and the least value greater than 1 that is representable.160
26 Meaningful for all floating-point types.
static constexpr T round_error() noexcept;
27 Measure of the maximum rounding error.161
static constexpr int min_exponent;
28 Minimum negative integer such thatradix raised to the power of one less than that integer is a
normalized floating-point number.162
29 Meaningful for all floating-point types.
static constexpr int min_exponent10;
30 Minimum negative integer such that 10 raised to that power is in the range of normalized floating-point
numbers.163
31 Meaningful for all floating-point types.
static constexpr int max_exponent;
32 Maximumpositiveintegersuchthat radixraisedtothepoweronelessthanthatintegerisarepresentable
finite floating-point number.164
33 Meaningful for all floating-point types.
static constexpr int max_exponent10;
34 Maximum positive integer such that 10 raised to that power is in the range of representable finite
floating-point numbers.165
35 Meaningful for all floating-point types.
static constexpr bool has_infinity;
36 true if the type has a representation for positive infinity.
37 Meaningful for all floating-point types.
38 Shall betrue for all specializations in whichis_iec559 != false.
static constexpr bool has_quiet_NaN;
39 true if the type has a representation for a quiet (non-signaling) “Not a Number”.166
40 Meaningful for all floating-point types.
41 Shall betrue for all specializations in whichis_iec559 != false.
static constexpr bool has_signaling_NaN;
42 true if the type has a representation for a signaling “Not a Number”.167
43 Meaningful for all floating-point types.
44 Shall betrue for all specializations in whichis_iec559 != false.
static constexpr T infinity() noexcept;
45 Representation of positive infinity, if available.168
160) Equivalent toFLT_EPSILON, DBL_EPSILON, LDBL_EPSILON.
161) Rounding error is described in ISO/IEC 10967-1:2012 Section 5.2.4 and Annex C Rationale Section C.5.2.4 — Rounding
and rounding constants.
162) Equivalent toFLT_MIN_EXP, DBL_MIN_EXP, LDBL_MIN_EXP.
163) Equivalent toFLT_MIN_10_EXP, DBL_MIN_10_EXP, LDBL_MIN_10_EXP.
164) Equivalent toFLT_MAX_EXP, DBL_MAX_EXP, LDBL_MAX_EXP.
165) Equivalent toFLT_MAX_10_EXP, DBL_MAX_10_EXP, LDBL_MAX_10_EXP.
166) Required by ISO/IEC 10967-1:2012.
167) Required by ISO/IEC 10967-1:2012.
168) Required by ISO/IEC 10967-1:2012.
§ 17.3.5.2 © ISO/IEC
580

===== PAGE 592 =====

Dxxxx
46 Meaningful for all specializations for whichhas_infinity != false. Required in specializations for
which is_iec559 != false.
static constexpr T quiet_NaN() noexcept;
47 Representation of a quiet “Not a Number”, if available.169
48 Meaningful for all specializations for whichhas_quiet_NaN != false. Required in specializations for
which is_iec559 != false.
static constexpr T signaling_NaN() noexcept;
49 Representation of a signaling “Not a Number”, if available.170
50 Meaningful for all specializations for whichhas_signaling_NaN != false. Required in specializations
for whichis_iec559 != false.
static constexpr T denorm_min() noexcept;
51 Minimum positive subnormal value, if available.171 Otherwise, minimum positive normalized value.
52 Meaningful for all floating-point types.
static constexpr bool is_iec559;
53 true if and only if the type adheres to ISO/IEC 60559.172
[Note 2: The value istrue for any of the typesfloat16_t, float32_t, float64_t, orfloat128_t, if present
(6.9.3). —end note]
54 Meaningful for all floating-point types.
static constexpr bool is_bounded;
55 true if the set of values representable by the type is finite.173
[Note 3: All fundamental types (6.9.2) are bounded. This member would befalse for arbitrary precision types.
—end note]
56 Meaningful for all specializations.
static constexpr bool is_modulo;
57 true if the type is modulo.174 A type is modulo if, for any operation involving+, -, or* on values of
that type whose result would fall outside the range[min(),max()], the value returned differs from the
true value by an integer multiple ofmax() - min() + 1.
58 [Example 1: is_modulo is false for signed integer types (6.9.2) unless an implementation, as an extension to
this document, defines signed integer overflow to wrap.—end example]
59 Meaningful for all specializations.
static constexpr bool traps;
60 true if, at the start of the program, there exists a value of the type that would cause an arithmetic
operation using that value to trap.175
61 Meaningful for all specializations.
static constexpr bool tinyness_before;
62 true if tinyness is detected before rounding.176
63 Meaningful for all floating-point types.
169) Required by ISO/IEC 10967-1:2012.
170) Required by ISO/IEC 10967-1:2012.
171) Required by ISO/IEC 10967-1:2012.
172) ISO/IEC 60559:2020 is the same as IEEE 754-2019.
173) Required by ISO/IEC 10967-1:2012.
174) Required by ISO/IEC 10967-1:2012.
175) Required by ISO/IEC 10967-1:2012.
176) Refer to ISO/IEC 60559. Required by ISO/IEC 10967-1:2012.
§ 17.3.5.2 © ISO/IEC
581

===== PAGE 593 =====

Dxxxx
static constexpr float_round_style round_style;
64 The rounding style for the type.177
65 Meaningful for all floating-point types. Specializations for integer types shall returnround_toward_-
zero.
17.3.5.3 numeric_limits specializations [numeric.special]
1 All members shall be provided for all specializations. However, many values are only required to be meaningful
under certain conditions (for example,epsilon() is only meaningful ifis_integer is false). Any value
that is not “meaningful” shall be set to 0 orfalse.
2 [Example 1:
namespace std {
template<> class numeric_limits<float> {
public:
static constexpr bool is_specialized = true;
static constexpr float min() noexcept { return 1.17549435E-38F; }
static constexpr float max() noexcept { return 3.40282347E+38F; }
static constexpr float lowest() noexcept { return -3.40282347E+38F; }
static constexpr int digits = 24;
static constexpr int digits10 = 6;
static constexpr int max_digits10 = 9;
static constexpr bool is_signed = true;
static constexpr bool is_integer = false;
static constexpr bool is_exact = false;
static constexpr int radix = 2;
static constexpr float epsilon() noexcept { return 1.19209290E-07F; }
static constexpr float round_error() noexcept { return 0.5F; }
static constexpr int min_exponent = -125;
static constexpr int min_exponent10 = - 37;
static constexpr int max_exponent = +128;
static constexpr int max_exponent10 = + 38;
static constexpr bool has_infinity = true;
static constexpr bool has_quiet_NaN = true;
static constexpr bool has_signaling_NaN = true;
static constexpr float infinity() noexcept { return value ; }
static constexpr float quiet_NaN() noexcept { return value ; }
static constexpr float signaling_NaN() noexcept { return value ; }
static constexpr float denorm_min() noexcept { return min(); }
static constexpr bool is_iec559 = true;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;
static constexpr bool traps = true;
static constexpr bool tinyness_before = true;
static constexpr float_round_style round_style = round_to_nearest;
};
}
—end example]
3 The specialization forbool shall be provided as follows:
177) Equivalent toFLT_ROUNDS. Required by ISO/IEC 10967-1:2012.
§ 17.3.5.3 © ISO/IEC
582

===== PAGE 594 =====

Dxxxx
namespace std {
template<> class numeric_limits<bool> {
public:
static constexpr bool is_specialized = true;
static constexpr bool min() noexcept { return false; }
static constexpr bool max() noexcept { return true; }
static constexpr bool lowest() noexcept { return false; }
static constexpr int digits = 1;
static constexpr int digits10 = 0;
static constexpr int max_digits10 = 0;
static constexpr bool is_signed = false;
static constexpr bool is_integer = true;
static constexpr bool is_exact = true;
static constexpr int radix = 2;
static constexpr bool epsilon() noexcept { return 0; }
static constexpr bool round_error() noexcept { return 0; }
static constexpr int min_exponent = 0;
static constexpr int min_exponent10 = 0;
static constexpr int max_exponent = 0;
static constexpr int max_exponent10 = 0;
static constexpr bool has_infinity = false;
static constexpr bool has_quiet_NaN = false;
static constexpr bool has_signaling_NaN = false;
static constexpr bool infinity() noexcept { return 0; }
static constexpr bool quiet_NaN() noexcept { return 0; }
static constexpr bool signaling_NaN() noexcept { return 0; }
static constexpr bool denorm_min() noexcept { return 0; }
static constexpr bool is_iec559 = false;
static constexpr bool is_bounded = true;
static constexpr bool is_modulo = false;
static constexpr bool traps = false;
static constexpr bool tinyness_before = false;
static constexpr float_round_style round_style = round_toward_zero;
};
}
17.3.6 Header <climits> synopsis [climits.syn]
// all freestanding
#define BOOL_WIDTH see below
#define CHAR_BIT see below
#define CHAR_WIDTH see below
#define SCHAR_WIDTH see below
#define UCHAR_WIDTH see below
#define USHRT_WIDTH see below
#define SHRT_WIDTH see below
#define UINT_WIDTH see below
#define INT_WIDTH see below
#define ULONG_WIDTH see below
#define LONG_WIDTH see below
#define ULLONG_WIDTH see below
#define LLONG_WIDTH see below
#define SCHAR_MIN see below
#define SCHAR_MAX see below
#define UCHAR_MAX see below
#define CHAR_MIN see below
#define CHAR_MAX see below
#define MB_LEN_MAX see below
§ 17.3.6 © ISO/IEC
583

===== PAGE 595 =====

Dxxxx
#define SHRT_MIN see below
#define SHRT_MAX see below
#define USHRT_MAX see below
#define INT_MIN see below
#define INT_MAX see below
#define UINT_MAX see below
#define LONG_MIN see below
#define LONG_MAX see below
#define ULONG_MAX see below
#define LLONG_MIN see below
#define LLONG_MAX see below
#define ULLONG_MAX see below
1 The header<climits> defines all macros the same as the C standard library header<limits.h>, except
that it does not define the macroBITINT_MAXWIDTH.
[Note 1: Except for theWIDTH macros, CHAR_BIT, andMB_LEN_MAX, a macro referring to an integer typeT defines a
constant whose type is the promoted type ofT (7.3.7). —end note]
See also: ISO/IEC 9899:2024, 5.3.5.3.2
17.3.7 Header <cfloat> synopsis [cfloat.syn]
// all freestanding
#define __STDC_VERSION_FLOAT_H__ 202311L
#define FLT_ROUNDS see below
#define FLT_EVAL_METHOD see below
#define FLT_RADIX see below
#define INFINITY see below
#define NAN see below
#define FLT_SNAN see below
#define DBL_SNAN see below
#define LDBL_SNAN see below
#define FLT_MANT_DIG see below
#define DBL_MANT_DIG see below
#define LDBL_MANT_DIG see below
#define FLT_DECIMAL_DIG see below
#define DBL_DECIMAL_DIG see below
#define LDBL_DECIMAL_DIG see below
#define FLT_DIG see below
#define DBL_DIG see below
#define LDBL_DIG see below
#define FLT_MIN_EXP see below
#define DBL_MIN_EXP see below
#define LDBL_MIN_EXP see below
#define FLT_MIN_10_EXP see below
#define DBL_MIN_10_EXP see below
#define LDBL_MIN_10_EXP see below
#define FLT_MAX_EXP see below
#define DBL_MAX_EXP see below
#define LDBL_MAX_EXP see below
#define FLT_MAX_10_EXP see below
#define DBL_MAX_10_EXP see below
#define LDBL_MAX_10_EXP see below
#define FLT_MAX see below
#define DBL_MAX see below
#define LDBL_MAX see below
#define FLT_EPSILON see below
#define DBL_EPSILON see below
#define LDBL_EPSILON see below
#define FLT_MIN see below
#define DBL_MIN see below
#define LDBL_MIN see below
#define FLT_TRUE_MIN see below
#define DBL_TRUE_MIN see below
§ 17.3.7 © ISO/IEC
584

===== PAGE 596 =====

Dxxxx
#define LDBL_TRUE_MIN see below
1 The header<cfloat> defines all macros the same as the C standard library header<float.h>.
See also: ISO/IEC 9899:2024, 5.3.5.3.3
17.4 Arithmetic types [support.arith.types]
17.4.1 Header <cstdint> synopsis [cstdint.syn]
1 The header <cstdint> supplies integer types having specified widths, and macros that specify limits of
integer types.
// all freestanding
#define __STDC_VERSION_STDINT_H__ 202311L
namespace std {
using int8_t = signed integer type ; // optional
using int16_t = signed integer type ; // optional
using int32_t = signed integer type ; // optional
using int64_t = signed integer type ; // optional
using intN_t = see below ; // optional
using int_fast8_t = signed integer type ;
using int_fast16_t = signed integer type ;
using int_fast32_t = signed integer type ;
using int_fast64_t = signed integer type ;
using int_fastN_t = see below ; // optional
using int_least8_t = signed integer type ;
using int_least16_t = signed integer type ;
using int_least32_t = signed integer type ;
using int_least64_t = signed integer type ;
using int_leastN_t = see below ; // optional
using intmax_t = signed integer type ;
using intptr_t = signed integer type ; // optional
using uint8_t = unsigned integer type ; // optional
using uint16_t = unsigned integer type ; // optional
using uint32_t = unsigned integer type ; // optional
using uint64_t = unsigned integer type ; // optional
using uintN_t = see below ; // optional
using uint_fast8_t = unsigned integer type ;
using uint_fast16_t = unsigned integer type ;
using uint_fast32_t = unsigned integer type ;
using uint_fast64_t = unsigned integer type ;
using uint_fastN_t = see below ; // optional
using uint_least8_t = unsigned integer type ;
using uint_least16_t = unsigned integer type ;
using uint_least32_t = unsigned integer type ;
using uint_least64_t = unsigned integer type ;
using uint_leastN_t = see below ; // optional
using uintmax_t = unsigned integer type ;
using uintptr_t = unsigned integer type ; // optional
}
#define INTN_MIN see below
#define INTN_MAX see below
#define UINTN_MAX see below
#define INTN_WIDTH see below
#define UINTN_WIDTH see below
§ 17.4.1 © ISO/IEC
585

===== PAGE 597 =====

Dxxxx
#define INT_FASTN_MIN see below
#define INT_FASTN_MAX see below
#define UINT_FASTN_MAX see below
#define INT_FASTN_WIDTH see below
#define UINT_FASTN_WIDTH see below
#define INT_LEASTN_MIN see below
#define INT_LEASTN_MAX see below
#define UINT_LEASTN_MAX see below
#define INT_LEASTN_WIDTH see below
#define UINT_LEASTN_WIDTH see below
#define INTMAX_MIN see below
#define INTMAX_MAX see below
#define UINTMAX_MAX see below
#define INTMAX_WIDTH see below
#define UINTMAX_WIDTH see below
#define INTPTR_MIN see below // optional
#define INTPTR_MAX see below // optional
#define UINTPTR_MAX see below // optional
#define INTPTR_WIDTH see below // optional
#define UINTPTR_WIDTH see below // optional
#define PTRDIFF_MIN see below
#define PTRDIFF_MAX see below
#define PTRDIFF_WIDTH see below
#define SIZE_MAX see below
#define SIZE_WIDTH see below
#define SIG_ATOMIC_MIN see below
#define SIG_ATOMIC_MAX see below
#define SIG_ATOMIC_WIDTH see below
#define WCHAR_MIN see below
#define WCHAR_MAX see below
#define WCHAR_WIDTH see below
#define WINT_MIN see below
#define WINT_MAX see below
#define WINT_WIDTH see below
#define INTN_C(value) see below
#define UINTN_C(value) see below
#define INTMAX_C(value) see below
#define UINTMAX_C(value) see below
2 The header defines all types and macros the same as the C standard library header<stdint.h>. The types
denoted byintmax_t and uintmax_t are not required to be able to represent all values of extended integer
types wider thanlong long and unsigned long long, respectively.
See also: ISO/IEC 9899:2024, 7.22
3 All types that use the placeholderN are optional whenN is not8, 16, 32, or64. The exact-width types
intN_t and uintN_t for N = 8, 16, 32, and64 are also optional; however, if an implementation defines integer
types with the corresponding width and no padding bits, it defines the correspondingtypedef-names. Each of
the macros listed in this subclause is defined if and only if the implementation defines the corresponding
typedef-name.
[Note 1: The macros INTN_C and UINTN_C correspond to the typedef-names int_leastN_t and uint_leastN_t,
respectively. —end note]
17.4.2 Header <stdfloat> synopsis [stdfloat.syn]
1 The header<stdfloat> defines type aliases for the optional extended floating-point types that are specified
in 6.9.3.
§ 17.4.2 © ISO/IEC
586

===== PAGE 598 =====

Dxxxx
namespace std {
#if defined(__STDCPP_FLOAT16_T__)
using float16_t = implementation-defined ; // see 6.9.3
#endif
#if defined(__STDCPP_FLOAT32_T__)
using float32_t = implementation-defined ; // see 6.9.3
#endif
#if defined(__STDCPP_FLOAT64_T__)
using float64_t = implementation-defined ; // see 6.9.3
#endif
#if defined(__STDCPP_FLOAT128_T__)
using float128_t = implementation-defined ; // see 6.9.3
#endif
#if defined(__STDCPP_BFLOAT16_T__)
using bfloat16_t = implementation-defined ; // see 6.9.3
#endif
}
17.5 Startup and termination [support.start.term]
1 [Note 1: The header<cstdlib> (17.2.2) declares the functions described in this subclause.—end note]
[[noreturn]] void _Exit(int status) noexcept;
2 Effects: This function has the semantics specified in the C standard library.
3 Remarks: The program is terminated without executing destructors for objects with automatic, thread,
or static storage duration and without calling functions passed toatexit() (6.10.3.4). The function
_Exit is signal-safe (17.14.5).
[[noreturn]] void abort() noexcept;
4 Effects: This function has the semantics specified in the C standard library.
5 Remarks: The program is terminated without executing destructors for objects of automatic, thread,
or static storage duration and without calling functions passed toatexit() (6.10.3.4). The function
abort is signal-safe (17.14.5).
int atexit(c-atexit-handler * f) noexcept;
int atexit(atexit-handler * f) noexcept;
6 Effects: The atexit() functions register the function pointed to byf to be called without arguments
at normal program termination. It is unspecified whether a call toatexit() that does not happen
before (6.10.2) a call toexit() will succeed.
[Note 2: The atexit() functions do not introduce a data race (16.4.6.10).—end note]
7 Implementation limits: The implementation shall support the registration of at least 32 functions.
8 Returns: The atexit() function returns zero if the registration succeeds, nonzero if it fails.
[[noreturn]] void exit(int status);
9 Effects:
—(9.1) First, objects with thread storage duration and associated with the current thread are destroyed.
Next, objects with static storage duration are destroyed and functions registered by callingatexit
are called.178 See 6.10.3.4 for the order of destructions and calls. (Objects with automatic storage
duration are not destroyed as a result of callingexit().)179
If a registered function invoked byexit exits via an exception, the functionstd::terminate is
invoked (14.6.2).
—(9.2) Next, all open C streams (as mediated by the function signatures declared in<cstdio> (31.13.1))
with unwritten buffered data are flushed, all open C streams are closed, and all files created by
calling tmpfile() are removed.
178) A function is called for every time it is registered.
179) Objects with automatic storage duration are all destroyed in a program whosemain function (6.10.3.1) contains no objects
with automatic storage duration and executes the call toexit(). Control can be transferred directly to such amain function by
throwing an exception that is caught inmain.
§ 17.5 © ISO/IEC
587

===== PAGE 599 =====

Dxxxx
—(9.3) Finally, control is returned to the host environment. Ifstatus is zero or EXIT_SUCCESS, an
implementation-defined form of the statussuccessful terminationis returned. Ifstatus is EXIT_-
FAILURE, an implementation-defined form of the statusunsuccessful termination is returned.
Otherwise the status returned is implementation-defined.180
int at_quick_exit(c-atexit-handler * f) noexcept;
int at_quick_exit(atexit-handler * f) noexcept;
10 Effects: The at_quick_exit() functions register the function pointed to byf to be called without
arguments whenquick_exit is called. It is unspecified whether a call toat_quick_exit() that does
not happen before (6.10.2) all calls toquick_exit will succeed.
[Note 3: The at_quick_exit() functions do not introduce a data race (16.4.6.10).—end note]
[Note 4: The order of registration could be indeterminate ifat_quick_exit was called from more than one
thread. —end note]
[Note 5: The at_quick_exit registrations are distinct from theatexit registrations, and applications might
need to call both registration functions with the same argument.—end note]
11 Implementation limits: The implementation shall support the registration of at least 32 functions.
12 Returns: Zero if the registration succeeds, nonzero if it fails.
[[noreturn]] void quick_exit(int status) noexcept;
13 Effects: Functions registered by calls to at_quick_exit are called in the reverse order of their
registration, except that a function shall be called after any previously registered functions that had
already been called at the time it was registered. Objects shall not be destroyed as a result of calling
quick_exit. If a registered function invoked byquick_exit exits via an exception, the function
std::terminate is invoked (14.6.2).
[Note 6: A function registered viaat_quick_exit is invoked by the thread that callsquick_exit, which can be
a different thread than the one that registered it, so registered functions cannot rely on the identity of objects
with thread storage duration.—end note]
After calling registered functions,quick_exit shall call_Exit(status).
14 Remarks: The functionquick_exit is signal-safe (17.14.5) when the functions registered withat_-
quick_exit are.
See also: ISO/IEC 9899:2024, 7.24.5
17.6 Dynamic memory management [support.dynamic]
17.6.1 General [support.dynamic.general]
1 The header<new> defines several functions that manage the allocation of dynamic storage in a program. It
also defines components for reporting storage management errors.
17.6.2 Header <new> synopsis [new.syn]
// all freestanding
namespace std {
// 17.6.4, storage allocation errors
class bad_alloc;
class bad_array_new_length;
struct destroying_delete_t {
explicit destroying_delete_t() = default;
};
inline constexpr destroying_delete_t destroying_delete{};
// globaloperator new control
enum class align_val_t : size_t {};
struct nothrow_t { explicit nothrow_t() = default; };
extern const nothrow_t nothrow;
180) The macrosEXIT_FAILURE and EXIT_SUCCESS are defined in<cstdlib> (17.2.2).
§ 17.6.2 © ISO/IEC
588

===== PAGE 600 =====

Dxxxx
using new_handler = void (*)();
new_handler get_new_handler() noexcept;
new_handler set_new_handler(new_handler new_p) noexcept;
// 17.6.5, pointer optimization barrier
template<class T> constexpr T* launder(T* p) noexcept;
// 17.6.6, hardware interference size
inline constexpr size_t hardware_destructive_interference_size = implementation-defined ;
inline constexpr size_t hardware_constructive_interference_size = implementation-defined ;
}
// 17.6.3, storage allocation and deallocation
void* operator new(std::size_t size);
void* operator new(std::size_t size, std::align_val_t alignment);
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;
void* operator new(std::size_t size, std::align_val_t alignment, const std::nothrow_t&) noexcept;
void operator delete(void* ptr) noexcept;
void operator delete(void* ptr, std::size_t size) noexcept;
void operator delete(void* ptr, std::align_val_t alignment) noexcept;
void operator delete(void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* ptr, std::align_val_t alignment, const std::nothrow_t&) noexcept;
void* operator new[](std::size_t size);
void* operator new[](std::size_t size, std::align_val_t alignment);
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept;
void* operator new[](std::size_t size, std::align_val_t alignment,
const std::nothrow_t&) noexcept;
void operator delete[](void* ptr) noexcept;
void operator delete[](void* ptr, std::size_t size) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment) noexcept;
void operator delete[](void* ptr, std::size_t size, std::align_val_t alignment) noexcept;
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&) noexcept;
constexpr void* operator new (std::size_t size, void* ptr) noexcept;
constexpr void* operator new[](std::size_t size, void* ptr) noexcept;
void operator delete (void* ptr, void*) noexcept;
void operator delete[](void* ptr, void*) noexcept;
17.6.3 Storage allocation and deallocation [new.delete]
17.6.3.1 General [new.delete.general]
1 Except where otherwise specified, the provisions of 6.8.6.5 apply to the library versions ofoperator new
and operator delete. If the value of an alignment argument passed to any of these functions is not a valid
alignment value, the behavior is undefined.
2 On freestanding implementations, it is implementation-defined whether the default versions of the replaceable
global allocation functions satisfy the required behaviors described in 17.6.3.2 and 17.6.3.3.
[Note 1: A freestanding implementation’s default versions of the replaceable global allocation functions can cause
undefined behavior when invoked. During constant evaluation, the behaviors of those default versions are irrelevant,
as those calls are omitted (7.6.2.8).—end note]
Recommended practice: If any of the default versions of the replaceable global allocation functions meet the
requirements of a hosted implementation, they all should.
17.6.3.2 Single-object forms [new.delete.single]
void* operator new(std::size_t size);
§ 17.6.3.2 © ISO/IEC
589