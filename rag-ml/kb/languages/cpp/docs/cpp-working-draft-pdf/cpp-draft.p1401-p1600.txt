

===== PAGE 1401 =====

Dxxxx
11 Returns: p.
25.7.33.3 Class template cartesian_product_view::iterator [range.cartesian.iterator]
namespace std::ranges {
template<input_range First, forward_range... Vs>
requires (view<First> && ... && view<Vs>)
template<bool Const>
class cartesian_product_view<First, Vs...>::iterator {
public:
using iterator_category = input_iterator_tag;
using iterator_concept = see below ;
using value_type = tuple<range_value_t<maybe-const <Const, First>>,
range_value_t<maybe-const <Const, Vs>>...>;
using reference = tuple<range_reference_t<maybe-const <Const, First>>,
range_reference_t<maybe-const <Const, Vs>>...>;
using difference_type = see below ;
iterator () = default;
constexpr iterator (iterator <!Const> i) requires Const &&
(convertible_to<iterator_t<First>, iterator_t<const First>> &&
... && convertible_to<iterator_t<Vs>, iterator_t<const Vs>>);
constexpr auto operator*() const;
constexpr iterator & operator++();
constexpr void operator++(int);
constexpr iterator operator++(int) requires forward_range<maybe-const <Const, First>>;
constexpr iterator & operator--()
requires cartesian-product-is-bidirectional <Const, First, Vs...>;
constexpr iterator operator--(int)
requires cartesian-product-is-bidirectional <Const, First, Vs...>;
constexpr iterator & operator+=(difference_type x)
requires cartesian-product-is-random-access <Const, First, Vs...>;
constexpr iterator & operator-=(difference_type x)
requires cartesian-product-is-random-access <Const, First, Vs...>;
constexpr reference operator[](difference_type n) const
requires cartesian-product-is-random-access <Const, First, Vs...>;
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<maybe-const <Const, First>>>;
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires all-random-access <Const, First, Vs...>;
friend constexpr iterator operator+(const iterator & x, difference_type y)
requires cartesian-product-is-random-access <Const, First, Vs...>;
friend constexpr iterator operator+(difference_type x, const iterator & y)
requires cartesian-product-is-random-access <Const, First, Vs...>;
friend constexpr iterator operator-(const iterator & x, difference_type y)
requires cartesian-product-is-random-access <Const, First, Vs...>;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires cartesian-is-sized-sentinel <Const, iterator_t, First, Vs...>;
friend constexpr difference_type operator-(const iterator & i, default_sentinel_t)
requires cartesian-is-sized-sentinel <Const, sentinel_t, First, Vs...>;
friend constexpr difference_type operator-(default_sentinel_t, const iterator & i)
requires cartesian-is-sized-sentinel <Const, sentinel_t, First, Vs...>;
friend constexpr auto iter_move(const iterator & i) noexcept(see below );
§ 25.7.33.3 © ISO/IEC
1390

===== PAGE 1402 =====

Dxxxx
friend constexpr void iter_swap(const iterator & l, const iterator & r) noexcept(see below )
requires (indirectly_swappable<iterator_t<maybe-const <Const, First>>> && ... &&
indirectly_swappable<iterator_t<maybe-const <Const, Vs>>>);
private:
using Parent = maybe-const<Const, cartesian_product_view>; // exposition only
Parent* parent_ = nullptr; // exposition only
tuple<iterator_t<maybe-const <Const, First>>,
iterator_t<maybe-const<Const, Vs>>...> current_; // exposition only
template<size_t N = sizeof...(Vs)>
constexpr void next(); // exposition only
template<size_t N = sizeof...(Vs)>
constexpr void prev(); // exposition only
template<class Tuple>
constexpr difference_type distance-from(const Tuple& t) const; // exposition only
constexpr iterator (Parent & parent, tuple<iterator_t<maybe-const <Const, First>>,
iterator_t<maybe-const<Const, Vs>>...> current); // exposition only
};
}
1 iterator ::iterator_concept is defined as follows:
—(1.1) If cartesian-product-is-random-access <Const, First, Vs...> is modeled, theniterator_con-
cept denotes random_access_iterator_tag.
—(1.2) Otherwise, ifcartesian-product-is-bidirectional <Const, First, Vs...> is modeled, thenit-
erator_concept denotes bidirectional_iterator_tag.
—(1.3) Otherwise, ifmaybe-const <Const, First> models forward_range, theniterator_concept denotes
forward_iterator_tag.
—(1.4) Otherwise, iterator_concept denotes input_iterator_tag.
2 iterator ::difference_type is an implementation-defined signed-integer-like type.
3 Recommended practice: iterator ::difference_type should be the smallest signed-integer-like type that is
sufficiently wide to store the product of the maximum sizes of all underlying ranges if such a type exists.
template<size_t N = sizeof...(Vs)>
constexpr void next ();
4 Effects: Equivalent to:
auto& it = std::get<N>(current_);
++it;
if constexpr (N > 0) {
if (it == ranges::end(std::get<N>(parent_->bases_))) {
it = ranges::begin(std::get<N>(parent_->bases_));
next <N - 1>();
}
}
template<size_t N = sizeof...(Vs)>
constexpr void prev ();
5 Effects: Equivalent to:
auto& it = std::get<N>(current_);
if constexpr (N > 0) {
if (it == ranges::begin(std::get<N>(parent_->bases_))) {
it = cartesian-common-arg-end (std::get<N>(parent_->bases_));
prev <N - 1>();
}
}
--it;
§ 25.7.33.3 © ISO/IEC
1391

===== PAGE 1403 =====

Dxxxx
template<class Tuple>
constexpr difference_type distance-from (const Tuple& t) const;
6 Let:
—(6.1) scaled-size (N) be the product ofstatic_cast<difference_type>(ranges::size(std::get<
N>(parent_->bases_))) and scaled-size (N + 1) if N ≤sizeof...(Vs), otherwisestatic_-
cast<difference_type>(1);
—(6.2) scaled-distance (N) be the product ofstatic_cast<difference_type>(std::get<N>(cur-
rent_) - std::get<N>(t)) and scaled-size (N + 1); and
—(6.3) scaled-sum be the sum ofscaled-distance (N) for every integer0 ≤N ≤sizeof...(Vs).
7 Preconditions: scaled-sum can be represented bydifference_type.
8 Returns: scaled-sum .
constexpr iterator (Parent & parent, tuple<iterator_t<maybe-const <Const, First>>,
iterator_t<maybe-const <Const, Vs>>...> current);
9 Effects: Initializes parent_ with addressof(parent) and current_ with std::move(current).
constexpr iterator (iterator <!Const> i) requires Const &&
(convertible_to<iterator_t<First>, iterator_t<const First>> &&
... && convertible_to<iterator_t<Vs>, iterator_t<const Vs>>);
10 Effects: Initializes parent_ with i.parent_ and current_ with std::move(i.current_).
constexpr auto operator*() const;
11 Effects: Equivalent to:
return tuple-transform ([](auto& i) -> decltype(auto) { return *i; }, current_);
constexpr iterator & operator++();
12 Effects: Equivalent to:
next ();
return *this;
constexpr void operator++(int);
13 Effects: Equivalent to++*this.
constexpr iterator operator++(int) requires forward_range<maybe-const <Const, First>>;
14 Effects: Equivalent to:
auto tmp = *this;
++*this;
return tmp;
constexpr iterator & operator--()
requires cartesian-product-is-bidirectional <Const, First, Vs...>;
15 Effects: Equivalent to:
prev ();
return *this;
constexpr iterator operator--(int)
requires cartesian-product-is-bidirectional <Const, First, Vs...>;
16 Effects: Equivalent to:
auto tmp = *this;
--*this;
return tmp;
constexpr iterator & operator+=(difference_type x)
requires cartesian-product-is-random-access <Const, First, Vs...>;
17 Let orig be the value of*this before the call.
Let ret be:
§ 25.7.33.3 © ISO/IEC
1392

===== PAGE 1404 =====

Dxxxx
—(17.1) If x > 0, the value of*this had next been calledx times.
—(17.2) Otherwise, ifx < 0, the value of*this had prev been called-x times.
—(17.3) Otherwise, orig.
18 Preconditions: x is in the range[ranges::distance(*this, ranges::begin(*parent_)),
ranges::distance(*this, ranges::end(*parent_))].
19 Effects: Sets the value of*this to ret.
20 Returns: *this.
21 Complexity: Constant.
constexpr iterator & operator-=(difference_type x)
requires cartesian-product-is-random-access <Const, First, Vs...>;
22 Effects: Equivalent to:
*this += -x;
return *this;
constexpr reference operator[](difference_type n) const
requires cartesian-product-is-random-access <Const, First, Vs...>;
23 Effects: Equivalent to:return *((*this) + n);
friend constexpr bool operator==(const iterator & x, const iterator & y)
requires equality_comparable<iterator_t<maybe-const <Const, First>>>;
24 Effects: Equivalent to:return x.current_ == y.current_;
friend constexpr bool operator==(const iterator & x, default_sentinel_t);
25 Returns: true if std::get<i>(x.current_) == ranges::end(std::get<i>(x.parent_->bases_))
is true for any integer0 ≤i≤sizeof...(Vs); otherwise,false.
friend constexpr auto operator<=>(const iterator & x, const iterator & y)
requires all-random-access <Const, First, Vs...>;
26 Effects: Equivalent to:return x.current_ <=> y.current_;
friend constexpr iterator operator+(const iterator & x, difference_type y)
requires cartesian-product-is-random-access <Const, First, Vs...>;
27 Effects: Equivalent to:return iterator (x) += y;
friend constexpr iterator operator+(difference_type x, const iterator & y)
requires cartesian-product-is-random-access <Const, First, Vs...>;
28 Effects: Equivalent to:return y + x;
friend constexpr iterator operator-(const iterator & x, difference_type y)
requires cartesian-product-is-random-access <Const, First, Vs...>;
29 Effects: Equivalent to:return iterator (x) -= y;
friend constexpr difference_type operator-(const iterator & x, const iterator & y)
requires cartesian-is-sized-sentinel <Const, iterator_t, First, Vs...>;
30 Effects: Equivalent to:return x.distance-from (y.current_);
friend constexpr difference_type operator-(const iterator & i, default_sentinel_t)
requires cartesian-is-sized-sentinel <Const, sentinel_t, First, Vs...>;
31 Let end-tuple be an object of a type that is a specialization oftuple, such that:
—(31.1) std::get<0>(end-tuple ) has the same value asranges::end(std::get<0>(i.parent_->ba-
ses_));
—(31.2) std::get<N>(end-tuple ) has the same value asranges::begin(std::get<N>(i.parent_-
->bases_)) for every integer1 ≤N ≤sizeof...(Vs).
32 Effects: Equivalent to:return i.distance-from (end-tuple );
§ 25.7.33.3 © ISO/IEC
1393

===== PAGE 1405 =====

Dxxxx
friend constexpr difference_type operator-(default_sentinel_t s, const iterator & i)
requires cartesian-is-sized-sentinel <Const, sentinel_t, First, Vs...>;
33 Effects: Equivalent to:return -(i - s);
friend constexpr auto iter_move(const iterator & i) noexcept(see below );
34 Effects: Equivalent to:return tuple-transform (ranges::iter_move, i.current_);
35 Remarks: The exception specification is equivalent to the logicaland of the following expressions:
—(35.1) noexcept(ranges::iter_move(std::get<N>(i.current_))) for every integer
0 ≤N ≤sizeof...(Vs),
—(35.2) is_nothrow_move_constructible_v<range_rvalue_reference_t<maybe-const <Const, T>>>
for every typeT in First, Vs....
friend constexpr void iter_swap(const iterator & l, const iterator & r) noexcept(see below )
requires (indirectly_swappable<iterator_t<maybe-const <Const, First>>> && ... &&
indirectly_swappable<iterator_t<maybe-const <Const, Vs>>>);
36 Effects: For every integer0 ≤i≤sizeof...(Vs), performs:
ranges::iter_swap(std::get<i>(l.current_), std::get<i>(r.current_))
37 Remarks: The exception specification is equivalent to the logicaland of the following expressions:
—(37.1) noexcept(ranges::iter_swap(std::get<i>(l.current_), std::get<i>(r.current_))) for
every integer0 ≤i≤sizeof...(Vs).
25.7.34 Cache latest view [range.cache.latest]
25.7.34.1 Overview [range.cache.latest.overview]
1 cache_latest_view caches the last-accessed element of its underlying sequence so that the element does not
have to be recomputed on repeated access.
[Note 1: This is useful if computation of the element to produce is expensive.—end note]
2 The name views::cache_latest denotes a range adaptor object (25.7.2). LetE be an expression. The
expression views::cache_latest(E) is expression-equivalent tocache_latest_view(E).
25.7.34.2 Class template cache_latest_view [range.cache.latest.view]
namespace std::ranges {
template<input_range V>
requires view<V>
class cache_latest_view : public view_interface<cache_latest_view<V>> {
V base_ = V(); // exposition only
using cache-t = conditional_t<is_reference_v<range_reference_t<V>>, // exposition only
add_pointer_t<range_reference_t<V>>,
range_reference_t<V>>;
non-propagating-cache <cache-t > cache_; // exposition only
// 25.7.34.3, classcache_latest_view::iterator
class iterator ; // exposition only
// 25.7.34.4, classcache_latest_view::sentinel
class sentinel ; // exposition only
public:
cache_latest_view() requires default_initializable<V> = default;
constexpr explicit cache_latest_view(V base);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin();
constexpr auto end();
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
§ 25.7.34.2 © ISO/IEC
1394

===== PAGE 1406 =====

Dxxxx
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
};
template<class R>
cache_latest_view(R&&) -> cache_latest_view<views::all_t<R>>;
}
constexpr explicit cache_latest_view(V base);
1 Effects: Initializes base_ with std::move(base).
constexpr auto begin();
2 Effects: Equivalent to:return iterator (*this);
constexpr auto end();
3 Effects: Equivalent to:return sentinel (*this);
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
4 Effects: Equivalent to:return ranges::size(base_);
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
5 Effects: Equivalent to:return ranges::reserve_hint(base_);
25.7.34.3 Class cache_latest_view::iterator [range.cache.latest.iterator]
namespace std::ranges {
template<input_range V>
requires view<V>
class cache_latest_view<V>::iterator {
cache_latest_view* parent_; // exposition only
iterator_t<V> current_; // exposition only
constexpr explicit iterator (cache_latest_view& parent); // exposition only
public:
using difference_type = range_difference_t<V>;
using value_type = range_value_t<V>;
using iterator_concept = input_iterator_tag;
iterator (iterator &&) = default;
iterator & operator=(iterator &&) = default;
constexpr iterator_t<V> base() &&;
constexpr const iterator_t<V>& base() const & noexcept;
constexpr range_reference_t<V>& operator*() const;
constexpr iterator & operator++();
constexpr void operator++(int);
friend constexpr range_rvalue_reference_t<V> iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<V>>;
};
}
§ 25.7.34.3 © ISO/IEC
1395

===== PAGE 1407 =====

Dxxxx
constexpr explicit iterator (cache_latest_view& parent);
1 Effects: Initializes current_ with ranges::begin(parent.base_) and parent_ with addressof(par-
ent).
constexpr iterator_t<V> base() &&;
2 Returns: std::move(current_).
constexpr const iterator_t<V>& base() const & noexcept;
3 Returns: current_.
constexpr iterator & operator++();
4 Effects: Equivalent to:
parent_->cache_.reset();
++current_;
return *this;
constexpr void operator++(int);
5 Effects: Equivalent to:++*this.
constexpr range_reference_t<V>& operator*() const;
6 Effects: Equivalent to:
if constexpr (is_reference_v<range_reference_t<V>>) {
if (!parent_->cache_) {
parent_->cache_ = addressof(as-lvalue (*current_));
}
return **parent_->cache_;
} else {
if (!parent_->cache_) {
parent_->cache_.emplace-deref (current_);
}
return *parent_->cache_;
}
[Note 1: Evaluations ofoperator* on the same iterator object can conflict (6.10.2.2).—end note]
friend constexpr range_rvalue_reference_t<V> iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
7 Effects: Equivalent to:return ranges::iter_move(i.current_);
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<V>>;
8 Effects: Equivalent toranges::iter_swap(x.current_, y.current_).
25.7.34.4 Class cache_latest_view::sentinel [range.cache.latest.sentinel]
namespace std::ranges {
template<input_range V>
requires view<V>
class cache_latest_view<V>::sentinel {
sentinel_t<V> end_ = sentinel_t<V>(); // exposition only
constexpr explicit sentinel (cache_latest_view& parent); // exposition only
public:
sentinel () = default;
constexpr sentinel_t<V> base() const;
friend constexpr bool operator==(const iterator & x, const sentinel & y);
§ 25.7.34.4 © ISO/IEC
1396

===== PAGE 1408 =====

Dxxxx
friend constexpr range_difference_t<V> operator-(const iterator & x, const sentinel & y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
friend constexpr range_difference_t<V> operator-(const sentinel & x, const iterator & y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
};
}
constexpr explicit sentinel (cache_latest_view& parent);
1 Effects: Initializes end_ with ranges::end(parent.base_).
constexpr sentinel_t<V> base() const;
2 Returns: end_.
friend constexpr bool operator==(const iterator & x, const sentinel & y);
3 Returns: x.current_ == y.end_.
friend constexpr range_difference_t<V> operator-(const iterator & x, const sentinel & y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
4 Returns: x.current_ - y.end_.
friend constexpr range_difference_t<V> operator-(const sentinel & x, const iterator & y)
requires sized_sentinel_for<sentinel_t<V>, iterator_t<V>>;
5 Returns: x.end_ - y.current_.
25.7.35 To input view [range.to.input]
25.7.35.1 Overview [range.to.input.overview]
1 to_input_view presents a view of an underlying sequence as an input-only non-common range.
[Note 1: This is useful to avoid overhead that can be necessary to provide support for the operations needed for
greater iterator strength. —end note]
2 The nameviews::to_input denotes a range adaptor object (25.7.2). LetE be an expression and letT be
decltype((E)). The expressionviews::to_input(E) is expression-equivalent to:
—(2.1) views::all(E) if T models input_range, does not satisfy common_range, and does not satisfy
forward_range.
—(2.2) Otherwise, to_input_view(E).
25.7.35.2 Class template to_input_view [range.to.input.view]
namespace std::ranges {
template<input_range V>
requires view<V>
class to_input_view : public view_interface<to_input_view<V>> {
V base_ = V(); // exposition only
// 25.7.35.3, class templateto_input_view::iterator
template<bool Const> class iterator ; // exposition only
public:
to_input_view() requires default_initializable<V> = default;
constexpr explicit to_input_view(V base);
constexpr V base() const & requires copy_constructible<V> { return base_; }
constexpr V base() && { return std::move(base_); }
constexpr auto begin() requires (!simple-view <V>);
constexpr auto begin() const requires range<const V>;
constexpr auto end() requires (!simple-view <V>);
constexpr auto end() const requires range<const V>;
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
§ 25.7.35.2 © ISO/IEC
1397

===== PAGE 1409 =====

Dxxxx
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
};
template<class R>
to_input_view(R&&) -> to_input_view<views::all_t<R>>;
}
constexpr explicit to_input_view(V base);
1 Effects: Initializes base_ with std::move(base).
constexpr auto begin() requires (!simple-view <V>);
2 Effects: Equivalent to:return iterator <false>(ranges::begin(base_));
constexpr auto begin() const requires range<const V>;
3 Effects: Equivalent to:return iterator <true>(ranges::begin(base_));
constexpr auto end() requires (!simple-view <V>);
constexpr auto end() const requires range<const V>;
4 Effects: Equivalent to:return ranges::end(base_);
constexpr auto size() requires sized_range<V>;
constexpr auto size() const requires sized_range<const V>;
5 Effects: Equivalent to:return ranges::size(base_);
constexpr auto reserve_hint() requires approximately_sized_range<V>;
constexpr auto reserve_hint() const requires approximately_sized_range<const V>;
6 Effects: Equivalent to:return ranges::reserve_hint(base_);
25.7.35.3 Class template to_input_view::iterator [range.to.input.iterator]
namespace std::ranges {
template<input_range V>
requires view<V>
template<bool Const>
class to_input_view<V>::iterator {
using Base = maybe-const <Const, V>; // exposition only
iterator_t<Base > current_ = iterator_t<Base >(); // exposition only
constexpr explicit iterator (iterator_t<Base > current); // exposition only
public:
using difference_type = range_difference_t<Base >;
using value_type = range_value_t<Base >;
using iterator_concept = input_iterator_tag;
iterator () requires default_initializable<iterator_t<Base >> = default;
iterator (iterator &&) = default;
iterator & operator=(iterator &&) = default;
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
constexpr iterator_t<Base > base() &&;
constexpr const iterator_t<Base >& base() const & noexcept;
constexpr decltype(auto) operator*() const { return *current_; }
constexpr iterator & operator++();
constexpr void operator++(int);
§ 25.7.35.3 © ISO/IEC
1398

===== PAGE 1410 =====

Dxxxx
friend constexpr bool operator==(const iterator & x, const sentinel_t<Base >& y);
friend constexpr difference_type operator-(const sentinel_t<Base >& y, const iterator & x)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
friend constexpr difference_type operator-(const iterator & x, const sentinel_t<Base >& y)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
friend constexpr range_rvalue_reference_t<Base > iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<Base >>;
};
}
constexpr explicit iterator (iterator_t<Base > current);
1 Effects: Initializes current_ with std::move(current).
constexpr iterator (iterator <!Const> i)
requires Const && convertible_to<iterator_t<V>, iterator_t<Base >>;
2 Effects: Initializes current_ with std::move(i.current_).
constexpr iterator_t<Base > base() &&;
3 Returns: std::move(current_).
constexpr const iterator_t<Base >& base() const & noexcept;
4 Returns: current_.
constexpr iterator & operator++();
5 Effects: Equivalent to:
++current_;
return *this;
constexpr void operator++(int);
6 Effects: Equivalent to:++*this;
friend constexpr bool operator==(const iterator & x, const sentinel_t<Base >& y);
7 Returns: x.current_ == y.
friend constexpr difference_type operator-(const sentinel_t<Base >& y, const iterator & x)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
8 Returns: y - x.current_.
friend constexpr difference_type operator-(const iterator & x, const sentinel_t<Base >& y)
requires sized_sentinel_for<sentinel_t<Base >, iterator_t<Base >>;
9 Returns: x.current_ - y.
friend constexpr range_rvalue_reference_t<Base > iter_move(const iterator & i)
noexcept(noexcept(ranges::iter_move(i.current_)));
10 Effects: Equivalent to:return ranges::iter_move(i.current_);
friend constexpr void iter_swap(const iterator & x, const iterator & y)
noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
requires indirectly_swappable<iterator_t<Base >>;
11 Effects: Equivalent to:ranges::iter_swap(x.current_, y.current_);
25.8 Range generators [coro.generator]
25.8.1 Overview [coroutine.generator.overview]
1 Class templategenerator presents a view of the elements yielded by the evaluation of a coroutine.
§ 25.8.1 © ISO/IEC
1399

===== PAGE 1411 =====

Dxxxx
2 A generator generates a sequence of elements by repeatedly resuming the coroutine from which it was
returned. Elements of the sequence are produced by the coroutine each time aco_yield statement is
evaluated. When theco_yield statement is of the formco_yield elements_of(r), each element of the
range r is successively produced as an element of the sequence.
[Example 1:
generator<int> ints(int start = 0) {
while (true)
co_yield start++;
}
void f() {
for (auto i : ints() | views::take(3))
cout << i << ' '; // prints0 1 2
}
—end example]
25.8.2 Header <generator> synopsis [generator.syn]
namespace std {
// 25.8.3, class templategenerator
template<class Ref, class Val = void, class Allocator = void>
class generator;
namespace pmr {
template<class Ref, class Val = void>
using generator = std::generator<Ref, Val, polymorphic_allocator<>>;
}
}
25.8.3 Class template generator [coro.generator.class]
namespace std {
template<class Ref, class Val = void, class Allocator = void>
class generator : public ranges::view_interface<generator<Ref, Val, Allocator>> {
private:
using value = conditional_t<is_void_v<Val>, remove_cvref_t<Ref>, Val>; // exposition only
using reference = conditional_t<is_void_v<Val>, Ref&&, Ref>; // exposition only
// 25.8.6, classgenerator::iterator
class iterator; // exposition only
public:
using yielded =
conditional_t<is_reference_v<reference >, reference , const reference &>;
// 25.8.5, classgenerator::promise_type
class promise_type;
generator(const generator&) = delete;
generator(generator&& other) noexcept;
~generator();
generator& operator=(generator other) noexcept;
iterator begin();
default_sentinel_t end() const noexcept;
private:
coroutine_handle<promise_type> coroutine_ = nullptr; // exposition only
unique_ptr<stack<coroutine_handle<>>> active_; // exposition only
};
}
§ 25.8.3 © ISO/IEC
1400

===== PAGE 1412 =====

Dxxxx
1 Mandates:
—(1.1) If Allocator is notvoid, allocator_traits<Allocator>::pointer is a pointer type.
—(1.2) value is a cv-unqualified object type.
—(1.3) reference is either a reference type, or a cv-unqualified object type that modelscopy_constructible.
—(1.4) LetRRefdenoteremove_reference_t<reference >&&if reference is a reference type, andreference
otherwise. Each of:
—(1.4.1) common_reference_with<reference &&, value &>,
—(1.4.2) common_reference_with<reference &&, RRef&&>, and
—(1.4.3) common_reference_with<RRef&&, const value &>
is modeled.
[Note 1: These requirements ensure the exposition-onlyiterator type can modelindirectly_readable and
thus input_iterator. —end note]
2 If Allocator is notvoid, it shall meet theCpp17Allocator requirements.
3 Specializations of generator model view and input_range.
4 The behavior of a program that adds a specialization forgenerator is undefined.
25.8.4 Members [coro.generator.members]
generator(generator&& other) noexcept;
1 Effects: Initializescoroutine_ with exchange(other.coroutine_, {}) and active_ with exchange(
other.active_, nullptr).
2 [Note 1: Iterators previously obtained fromother are not invalidated; they become iterators into*this. —end
note]
~generator();
3 Effects: Equivalent to:
if (coroutine_) {
coroutine_.destroy();
}
4 [Note 2: Ownership of recursively yielded generators is held in awaitable objects in the coroutine frame of the
yielding generator, so destroying the root generator effectively destroys the entire stack of yielded generators.
—end note]
generator& operator=(generator other) noexcept;
5 Effects: Equivalent to:
swap(coroutine_, other.coroutine_);
swap(active_, other.active_);
6 Returns: *this.
7 [Note 3: Iterators previously obtained fromother are not invalidated; they become iterators into*this. —end
note]
iterator begin();
8 Preconditions: coroutine_ refers to a coroutine suspended at its initial suspend point (9.6.4).
9 Effects: Pushes coroutine_ into *active_, then evaluatescoroutine_.resume().
10 Returns: An iterator object whose member coroutine_ refers to the same coroutine as does
coroutine_.
11 [Note 4: A program that callsbegin more than once on the same generator has undefined behavior.—end
note]
default_sentinel_t end() const noexcept;
12 Returns: default_sentinel.
§ 25.8.4 © ISO/IEC
1401

===== PAGE 1413 =====

Dxxxx
25.8.5 Class generator::promise_type [coro.generator.promise]
namespace std {
template<class Ref, class Val, class Allocator>
class generator<Ref, Val, Allocator>::promise_type {
public:
generator get_return_object() noexcept;
suspend_always initial_suspend() const noexcept { return {}; }
auto final_suspend() noexcept;
suspend_always yield_value(yielded val) noexcept;
auto yield_value(const remove_reference_t<yielded>& lval)
requires is_rvalue_reference_v<yielded> &&
constructible_from<remove_cvref_t<yielded>, const remove_reference_t<yielded>&>;
template<class R2, class V2, class Alloc2, class Unused>
requires same_as<typename generator<R2, V2, Alloc2>::yielded, yielded>
auto yield_value(ranges::elements_of<generator<R2, V2, Alloc2>&&, Unused> g) noexcept;
template<class R2, class V2, class Alloc2, class Unused>
requires same_as<typename generator<R2, V2, Alloc2>::yielded, yielded>
auto yield_value(ranges::elements_of<generator<R2, V2, Alloc2>&, Unused> g) noexcept;
template<ranges::input_range R, class Alloc>
requires convertible_to<ranges::range_reference_t<R>, yielded>
auto yield_value(ranges::elements_of<R, Alloc> r);
void await_transform() = delete;
void return_void() const noexcept {}
void unhandled_exception();
void* operator new(size_t size)
requires same_as<Allocator, void> || default_initializable<Allocator>;
template<class Alloc, class... Args>
void* operator new(size_t size, allocator_arg_t, const Alloc& alloc, const Args&...);
template<class This, class Alloc, class... Args>
void* operator new(size_t size, const This&, allocator_arg_t, const Alloc& alloc,
const Args&...);
void operator delete(void* pointer, size_t size) noexcept;
private:
add_pointer_t<yielded> value_ = nullptr; // exposition only
exception_ptr except_; // exposition only
};
}
generator get_return_object() noexcept;
1 Returns: A generator object whose member coroutine_ is coroutine_handle<promise_type>::
from_promise(*this), and whose memberactive_ points to an empty stack.
auto final_suspend() noexcept;
2 Preconditions: A handle referring to the coroutine whose promise object is*this is at the top of
*active_ of somegenerator object x. This function is called by that coroutine upon reaching its final
suspend point (9.6.4).
3 Returns: An awaitable object of unspecified type (7.6.2.4) whose member functions arrange for the
calling coroutine to be suspended, pop the coroutine handle from the top of*x.active_, and resume
execution of the coroutine referred to byx.active_->top() if *x.active_ is not empty. If it is empty,
control flow returns to the current coroutine caller or resumer (9.6.4).
§ 25.8.5 © ISO/IEC
1402

===== PAGE 1414 =====

Dxxxx
suspend_always yield_value(yielded val) noexcept;
4 Effects: Equivalent tovalue_ = addressof(val).
5 Returns: {}.
auto yield_value(const remove_reference_t<yielded>& lval)
requires is_rvalue_reference_v<yielded> &&
constructible_from<remove_cvref_t<yielded>, const remove_reference_t<yielded>&>;
6 Preconditions: A handle referring to the coroutine whose promise object is*this is at the top of
*active_ of somegenerator object.
7 Returns: An awaitable object of an unspecified type (7.6.2.4) that stores an object of typeremove_-
cvref_t<yielded> direct-non-list-initialized withlval, whose member functions arrange forvalue_ to
point to that stored object and then suspend the coroutine.
8 Throws: Any exception thrown by the initialization of the stored object.
9 Remarks: A yield-expression that calls this function has typevoid (7.6.17).
template<class R2, class V2, class Alloc2, class Unused>
requires same_as<typename generator<R2, V2, Alloc2>::yielded, yielded>
auto yield_value(ranges::elements_of<generator<R2, V2, Alloc2>&&, Unused> g) noexcept;
template<class R2, class V2, class Alloc2, class Unused>
requires same_as<typename generator<R2, V2, Alloc2>::yielded, yielded>
auto yield_value(ranges::elements_of<generator<R2, V2, Alloc2>&, Unused> g) noexcept;
10 Preconditions: A handle referring to the coroutine whose promise object is*this is at the top of
*active_ of somegenerator object x. The coroutine referred to byg.range.coroutine_ is suspended
at its initial suspend point.
11 Returns: An awaitable object of an unspecified type (7.6.2.4) into whichg.range is moved, whose
member await_ready returns false, whose member await_suspend pushes g.range.coroutine_
into *x.active_ and resumes execution of the coroutine referred to byg.range.coroutine_, and
whose memberawait_resume evaluates rethrow_exception(except_) if bool(except_) is true. If
bool(except_) is false, theawait_resume member has no effects.
12 Remarks: A yield-expression that calls one of these functions has typevoid (7.6.17).
template<ranges::input_range R, class Alloc>
requires convertible_to<ranges::range_reference_t<R>, yielded>
auto yield_value(ranges::elements_of<R, Alloc> r);
13 Effects: Equivalent to:
auto nested = [](allocator_arg_t, Alloc, ranges::iterator_t<R> i, ranges::sentinel_t<R> s)
-> generator<yielded, void, Alloc> {
for (; i != s; ++i) {
co_yield static_cast<yielded>(*i);
}
};
return yield_value(ranges::elements_of(nested(
allocator_arg, r.allocator, ranges::begin(r.range), ranges::end(r.range))));
14 [Note 1: A yield-expression that calls this function has typevoid (7.6.17). —end note]
void unhandled_exception();
15 Preconditions: A handle referring to the coroutine whose promise object is*this is at the top of
*active_ of somegenerator object x.
16 Effects: If the handle referring to the coroutine whose promise object is*this is the sole element of
*x.active_, equivalent tothrow, otherwise, assignscurrent_exception() to except_.
void* operator new(size_t size)
requires same_as<Allocator, void> || default_initializable<Allocator>;
template<class Alloc, class... Args>
void* operator new(size_t size, allocator_arg_t, const Alloc& alloc, const Args&...);
§ 25.8.5 © ISO/IEC
1403

===== PAGE 1415 =====

Dxxxx
template<class This, class Alloc, class... Args>
void* operator new(size_t size, const This&, allocator_arg_t, const Alloc& alloc,
const Args&...);
17 Let A be
—(17.1) Allocator, if it is notvoid,
—(17.2) Alloc for the overloads with a template parameterAlloc, or
—(17.3) allocator<void> otherwise.
Let B be allocator_traits<A>::template rebind_alloc<U> where U is an unspecified type whose
size and alignment are both__STDCPP_DEFAULT_NEW_ALIGNMENT__.
18 Mandates: allocator_traits<B>::pointer is a pointer type. For the overloads with a template
parameter Alloc, same_as<Allocator, void> || convertible_to<const Alloc&, Allocator> is
modeled.
19 Effects: Initializes an allocatorb of typeB with A(alloc), for the overloads with a function parameter
alloc, and withA() otherwise. Uses b to allocate storage for the smallest array ofU sufficient to
provide storage for a coroutine state of sizesize, and unspecified additional state necessary to ensure
that operator delete can later deallocate this memory block with an allocator equal tob.
20 Returns: A pointer to the allocated storage.
void operator delete(void* pointer, size_t size) noexcept;
21 Preconditions: pointer was returned from an invocation of one of the above overloads ofoperator
new with asize argument equal tosize.
22 Effects: Deallocates the storage pointed to bypointer using an allocator equivalent to that used to
allocate it.
25.8.6 Class generator::iterator [coro.generator.iterator]
namespace std {
template<class Ref, class Val, class Allocator>
class generator<Ref, Val, Allocator>::iterator {
public:
using value_type = value ;
using difference_type = ptrdiff_t;
iterator (iterator && other) noexcept;
iterator & operator=(iterator && other) noexcept;
reference operator*() const noexcept(is_nothrow_copy_constructible_v<reference >);
iterator & operator++();
void operator++(int);
friend bool operator==(const iterator & i, default_sentinel_t);
private:
coroutine_handle<promise_type> coroutine_; // exposition only
};
}
iterator (iterator && other) noexcept;
1 Effects: Initializes coroutine_ with exchange(other.coroutine_, {}).
iterator & operator=(iterator && other) noexcept;
2 Effects: Equivalent tocoroutine_ = exchange(other.coroutine_, {}).
3 Returns: *this.
reference operator*() const noexcept(is_nothrow_copy_constructible_v<reference >);
4 Preconditions: For somegenerator object x, coroutine_ is in*x.active_ and x.active_->top()
refers to a suspended coroutine with promise objectp.
§ 25.8.6 © ISO/IEC
1404

===== PAGE 1416 =====

Dxxxx
5 Effects: Equivalent to:return static_cast<reference >(*p.value_);
iterator & operator++();
6 Preconditions: For somegenerator object x, coroutine_ is in*x.active_.
7 Effects: Equivalent tox.active_->top().resume().
8 Returns: *this.
void operator++(int);
9 Effects: Equivalent to++*this.
friend bool operator==(const iterator & i, default_sentinel_t);
10 Effects: Equivalent to:return i.coroutine_.done();
§ 25.8.6 © ISO/IEC
1405

===== PAGE 1417 =====

Dxxxx
26 Algorithms library [algorithms]
26.1 General [algorithms.general]
1 This Clause describes components that C++ programs may use to perform algorithmic operations on
containers (Clause 23) and other sequences.
2 The following subclauses describe components for non-modifying sequence operations, mutating sequence
operations, sorting and related operations, and algorithms from the C library, as summarized in Table 85.
Table 85 — Algorithms library summary [tab:algorithms.summary]
Subclause Header
26.2 Algorithms requirements
26.3 Parallel algorithms <execution>
26.5 Algorithm result types <algorithm>
26.6 Non-modifying sequence operations
26.7 Mutating sequence operations
26.8 Sorting and related operations
26.10 Generalized numeric operations <numeric>
26.11 Specialized <memory> algorithms <memory>
26.12 Specialized <random> algorithms <random>
26.13 C library algorithms <cstdlib>
26.2 Algorithms requirements [algorithms.requirements]
1 All of the algorithms are separated from the particular implementations of data structures and are parame-
terized by iterator types. Because of this, they can work with program-defined data structures, as long as
these data structures have iterator types satisfying the assumptions on the algorithms.
2 The entities defined in thestd::ranges namespace in this Clause and specified as function templates are
algorithm function objects (16.3.3.4).
3 For purposes of determining the existence of data races, algorithms shall not modify objects referenced
through an iterator argument unless the specification requires such modification.
4 Throughout this Clause, where the template parameters are not constrained, the names of template parameters
are used to express type requirements.
—(4.1) If an algorithm’sEffects element specifies that a value pointed to by any iterator passed as an argument
is modified, then the type of that argument shall meet the requirements of a mutable iterator (24.3).
—(4.2) If an algorithm’s template parameter is namedInputIterator, InputIterator1, orInputIterator2,
the template argument shall meet theCpp17InputIterator requirements (24.3.5.3).
—(4.3) If an algorithm’s template parameter is named OutputIterator, OutputIterator1, or Output-
Iterator2, the template argument shall meet theCpp17OutputIterator requirements (24.3.5.4).
—(4.4) If an algorithm’s template parameter is namedForwardIterator, ForwardIterator1, ForwardItera-
tor2, or NoThrowForwardIterator, the template argument shall meet theCpp17ForwardIterator
requirements (24.3.5.5) if it is required to be a mutable iterator, or modelforward_iterator (24.3.4.11)
otherwise.
—(4.5) If an algorithm’s template parameter is namedNoThrowForwardIterator, the template argument
is also required to have the property that no exceptions are thrown from increment, assignment, or
comparison of, or indirection through, valid iterators.
—(4.6) If an algorithm’s template parameter is namedBidirectionalIterator, BidirectionalIterator1,
or BidirectionalIterator2, the template argument shall meet theCpp17BidirectionalIteratorrequire-
ments (24.3.5.6) if it is required to be a mutable iterator, or modelbidirectional_iterator (24.3.4.12)
otherwise.
§ 26.2 © ISO/IEC
1406

===== PAGE 1418 =====

Dxxxx
—(4.7) If an algorithm’s template parameter is namedRandomAccessIterator, RandomAccessIterator1, or
RandomAccessIterator2, the template argument shall meet theCpp17RandomAccessIteratorrequire-
ments (24.3.5.7) if it is required to be a mutable iterator, or modelrandom_access_iterator (24.3.4.13)
otherwise.
[Note 1: These requirements do not affect iterator arguments that are constrained, for which iterator category and
mutability requirements are expressed explicitly.—end note]
5 Both in-place and copying versions are provided for certain algorithms.192 When such a version is provided
for algorithm it is calledalgorithm_copy. Algorithms that take predicates end with the suffix_if (which
follows the suffix_copy).
6 When not otherwise constrained, thePredicate parameter is used whenever an algorithm expects a function
object (22.10) that, when applied to the result of dereferencing the corresponding iterator, returns a value
testable astrue. If an algorithm takesPredicate pred as its argument andfirst as its iterator argument
with value typeT, the expressionpred(*first) shall be well-formed and the typedecltype(pred(*first))
shall modelboolean-testable (18.5.2). The function objectpred shall not apply any non-constant function
through its argument. Given a glvalueu of type (possibly const)T that designates the same object as*first,
pred(u) shall be a valid expression that is equal topred(*first).
7 When not otherwise constrained, theBinaryPredicate parameter is used whenever an algorithm expects a
function object that, when applied to the result of dereferencing two corresponding iterators or to dereferencing
an iterator and typeT when T is part of the signature, returns a value testable astrue. If an algorithm takes
BinaryPredicate binary_pred as its argument andfirst1 and first2 as its iterator arguments with
respective value typesT1 and T2, the expressionbinary_pred(*first1, *first2) shall be well-formed and
the typedecltype(binary_pred(*first1, *first2)) shall modelboolean-testable . Unless otherwise
specified, BinaryPredicate always takes the first iterator’svalue_type as its first argument, that is, in
those cases whenT value is part of the signature, the expressionbinary_pred(*first1, value) shall
be well-formed and the typedecltype(binary_pred(*first1, value)) shall modelboolean-testable .
binary_pred shall not apply any non-constant function through any of its arguments. Given a glvalueu of
type (possibly const)T1 that designates the same object as*first1, and a glvaluev of type (possibly const)
T2 that designates the same object as*first2, binary_pred(u, *first2), binary_pred(*first1, v),
and binary_pred(u, v) shall each be a valid expression that is equal tobinary_pred(*first1, *first2),
and binary_pred(u, value) shall be a valid expression that is equal tobinary_pred(*first1, value).
8 The parametersUnaryOperation, BinaryOperation, BinaryOperation1, andBinaryOperation2 are used
whenever an algorithm expects a function object (22.10).
9 [Note 2: Unless otherwise specified, algorithms that take function objects as arguments can copy those function
objects freely. If object identity is important, a wrapper class that points to a non-copied implementation object such
as reference_wrapper<T> (22.10.6), or some equivalent solution, can be used.—end note]
10 When the description of an algorithm gives an expression such as*first == value for a condition, the
expression shall evaluate to eithertrue or false in boolean contexts.
11 In the description of the algorithms, operator+ is used for some of the iterator categories for which it does
not have to be defined. In these cases the semantics ofa + n are the same as those of
auto tmp = a;
for (; n < 0; ++n) --tmp;
for (; n > 0; --n) ++tmp;
return tmp;
Similarly, operator- is used for some combinations of iterators and sentinel types for which it does not have
to be defined. If[a,b) denotes a range, the semantics ofb - a in these cases are the same as those of
iter_difference_t<decltype(a)> n = 0;
for (auto tmp = a; tmp != b; ++tmp) ++n;
return n;
and if[b,a) denotes a range, the same as those of
iter_difference_t<decltype(b)> n = 0;
for (auto tmp = b; tmp != a; ++tmp) --n;
return n;
192) The decision whether to include a copying version was usually based on complexity considerations. When the cost of doing
the operation dominates the cost of copy, the copying version is not included. For example,sort_copy is not included because
the cost of sorting is much more significant, and users can invokecopy followed bysort.
§ 26.2 © ISO/IEC
1407

===== PAGE 1419 =====

Dxxxx
For each iteratori and sentinels produced from a ranger, the semantics ofs - i are the same as those of
an expression that has the same type, value, and value category asranges::distance(i, s).
[Note 3: The implementation can use ranges::distance(r) when that produces the same value asranges::-
distance(i, s). This can be more efficient for sized ranges.—end note]
12 In the description of the algorithms, given an iteratora whose difference type isD, and an expressionn of
integer-like type other thancv D, the semantics ofa + n and a - n are, respectively, those ofa + D(n) and
a - D(n).
13 In the description of algorithm return values, a sentinel values denoting the end of a range[i,s) is sometimes
returned where an iterator is expected. In these cases, the semantics are as if the sentinel is converted into
an iterator usingranges::next(i, s).
14 Overloads of algorithms that takerange arguments (25.4.2) behave as if they are implemented by dispatching
to the overload in namespaceranges that takes separate iterator and sentinel arguments, where for each
range argumentr
—(14.1) a corresponding iterator argument is initialized withranges::begin(r) and
—(14.2) a corresponding sentinel argument is initialized withranges::end(r), or ranges::next(ranges::
begin(r), ranges::end(r)) if the type ofr models forward_range and computingranges::next
meets the specified complexity requirements.
15 The well-formedness and behavior of a call to an algorithm with an explicitly-specified template argument
list is unspecified, except where explicitly stated otherwise.
[Note 4: Consequently, an implementation can declare an algorithm with different template parameters than those
presented. —end note]
26.3 Parallel algorithms [algorithms.parallel]
26.3.1 Preamble [algorithms.parallel.defns]
1 Subclause 26.3 describes components that C++ programs may use to perform operations on containers and
other sequences in parallel.
2 A parallel algorithm is a function template listed in this document with a template parameter named
ExecutionPolicy or constrained by the following exposition-only concept:
template<class Ep>
concept execution-policy = is_execution_policy_v<remove_cvref_t<Ep>>; // exposition only
Such a template parameter is termed anexecution policy template parameter.
3 A parallel algorithm accesses objects indirectly accessible via its arguments by invoking the following functions:
—(3.1) All operations of the categories of the iterators, sentinels, ormdspan types that the algorithm is
instantiated with.
—(3.2) Operations on those sequence elements that are required by its specification.
—(3.3) User-provided invocable objects to be applied during the execution of the algorithm, if required by the
specification.
—(3.4) Operations on those invocable objects required by the specification.
[Note 1: See 26.2. —end note]
These functions are herein calledelement access functions.
4 [Example 1: The sort function may invoke the following element access functions:
—(4.1) Operations of the random-access iterator of the actual template argument (as per 24.3.5.7), as implied by the
name of the template parameterRandomAccessIterator.
—(4.2) The swap function on the elements of the sequence (as per the preconditions specified in 26.8.2.1).
—(4.3) The user-providedCompare function object.
—end example]
5 A standard library function isvectorization-unsafe if it is specified to synchronize with another function
invocation, or another function invocation is specified to synchronize with it, and if it is not a memory
allocation or deallocation function or lock-free atomic modify-write operation (32.5.4).
§ 26.3.1 © ISO/IEC
1408

===== PAGE 1420 =====

Dxxxx
[Note 2: Implementations must ensure that internal synchronization inside standard library functions does not prevent
forward progress when those functions are executed by threads of execution with weakly parallel forward progress
guarantees. —end note]
[Example 2:
int x = 0;
std::mutex m;
void f() {
int a[] = {1,2};
std::for_each(std::execution::par_unseq, std::begin(a), std::end(a), [&](int) {
std::lock_guard<mutex> guard(m); // incorrect:lock_guard constructor callsm.lock()
++x;
});
}
The above program may result in two consecutive calls tom.lock() on the same thread of execution (which may
deadlock), because the applications of the function object are not guaranteed to run on different threads of execution.
—end example]
26.3.2 Requirements on user-provided function objects [algorithms.parallel.user]
1 Unless otherwise specified, invocable objects passed into parallel algorithms as objects of a type denoted by
a template parameter namedPredicate, BinaryPredicate, Compare, UnaryOperation, BinaryOperation,
BinaryOperation1, BinaryOperation2, BinaryDivideOp, or constrained by a concept whose semantic
requirements include that the type modelsregular_invocable and the operators used by the analogous
overloads to these parallel algorithms that are formed by an invocation with the specified default predicate
or operation (where applicable) shall not directly or indirectly modify objects via their arguments, nor shall
they rely on the identity of the provided objects.
26.3.3 Effect of execution policies on algorithm execution [algorithms.parallel.exec]
1 An execution policy template parameter describes the manner in which the execution of a parallel algorithm
may be parallelized and the manner in which it applies the element access functions.
2 If an object is modified by an element access function, the algorithm will perform no other unsynchronized
accesses to that object. The modifying element access functions are those which are specified as modifying
the object.
[Note 1: For example,swap, ++, --, @=, and assignments modify the object. For the assignment and@= operators,
only the left argument is modified.—end note]
3 Unless otherwise stated, implementations may make arbitrary copies of elements (with typeT) from sequences
where is_trivially_copy_constructible_v<T> and is_trivially_destructible_v<T> are true.
[Note 2: This implies that user-supplied function objects cannot rely on object identity of arguments for such input
sequences. If object identity of the arguments to these function objects is important, a wrapping iterator that returns
a non-copied implementation object such asreference_wrapper<T> (22.10.6), or some equivalent solution, can be
used. —end note]
4 The invocations of element access functions in parallel algorithms invoked with an execution policy object of
type execution::sequenced_policy all occur in the calling thread of execution.
[Note 3: The invocations are not interleaved; see 6.10.1.—end note]
5 The invocations of element access functions in parallel algorithms invoked with an execution policy object
of typeexecution::unsequenced_policy are permitted to execute in an unordered fashion in the calling
thread of execution, unsequenced with respect to one another in the calling thread of execution.
[Note 4: This means that multiple function object invocations can be interleaved on a single thread of execution,
which overrides the usual guarantee from 6.10.1 that function executions do not overlap with one another.—end
note]
The behavior of a program is undefined if it invokes a vectorization-unsafe standard library function from
user code called from anexecution::unsequenced_policy algorithm.
[Note 5: Because execution::unsequenced_policy allows the execution of element access functions to be interleaved
on a single thread of execution, blocking synchronization, including the use of mutexes, risks deadlock.—end note]
6 The invocations of element access functions in parallel algorithms invoked with an execution policy object
of typeexecution::parallel_policy are permitted to execute either in the invoking thread of execution
or in a thread of execution implicitly created by the library to support parallel algorithm execution. If the
§ 26.3.3 © ISO/IEC
1409

===== PAGE 1421 =====

Dxxxx
threads of execution created bythread (32.4.3) orjthread (32.4.4) provide concurrent forward progress
guarantees (6.10.2.3), then a thread of execution implicitly created by the library will provide parallel forward
progress guarantees; otherwise, the provided forward progress guarantee is implementation-defined. Any such
invocations executing in the same thread of execution are indeterminately sequenced with respect to each
other.
[Note 6: It is the caller’s responsibility to ensure that the invocation does not introduce data races or deadlocks.
—end note]
[Example 1:
int a[] = {0,1};
std::vector<int> v;
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int i) {
v.push_back(i*2+1); // incorrect: data race
});
The program above has a data race because of the unsynchronized access to the containerv. —end example]
[Example 2:
std::atomic<int> x{0};
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int) {
x.fetch_add(1, std::memory_order::relaxed);
// spin wait for another iteration to change the value ofx
while (x.load(std::memory_order::relaxed) == 1) { } // incorrect: assumes execution order
});
The above example depends on the order of execution of the iterations, and will not terminate if both iterations are
executed sequentially on the same thread of execution.—end example]
[Example 3:
int x = 0;
std::mutex m;
int a[] = {1,2};
std::for_each(std::execution::par, std::begin(a), std::end(a), [&](int) {
std::lock_guard<mutex> guard(m);
++x;
});
The above example synchronizes access to objectx ensuring that it is incremented correctly.—end example]
7 The invocations of element access functions in parallel algorithms invoked with an execution policy object
of typeexecution::parallel_unsequenced_policy are permitted to execute in an unordered fashion in
unspecified threads of execution, and unsequenced with respect to one another within each thread of execution.
These threads of execution are either the invoking thread of execution or threads of execution implicitly
created by the library; the latter will provide weakly parallel forward progress guarantees.
[Note 7: This means that multiple function object invocations can be interleaved on a single thread of execution,
which overrides the usual guarantee from 6.10.1 that function executions do not overlap with one another.—end
note]
The behavior of a program is undefined if it invokes a vectorization-unsafe standard library function from
user code called from anexecution::parallel_unsequenced_policy algorithm.
[Note 8: Because execution::parallel_unsequenced_policy allows the execution of element access functions to be
interleaved on a single thread of execution, blocking synchronization, including the use of mutexes, risks deadlock.
—end note]
8 [Note 9: The semantics of invocation with execution::unsequenced_policy, execution::parallel_policy, or
execution::parallel_unsequenced_policy allow the implementation to fall back to sequential execution if the
system cannot parallelize an algorithm invocation, e.g., due to lack of resources.—end note]
9 If an invocation of a parallel algorithm uses threads of execution implicitly created by the library, then the
invoking thread of execution will either
—(9.1) temporarily block with forward progress guarantee delegation (6.10.2.3) on the completion of these
library-managed threads of execution, or
—(9.2) eventually execute an element access function;
the thread of execution will continue to do so until the algorithm is finished.
§ 26.3.3 © ISO/IEC
1410

===== PAGE 1422 =====

Dxxxx
[Note 10: In blocking with forward progress guarantee delegation in this context, a thread of execution created by
the library is considered to have finished execution as soon as it has finished the execution of the particular element
access function that the invoking thread of execution logically depends on.—end note]
10 The semantics of parallel algorithms invoked with an execution policy object of implementation-defined type
are implementation-defined.
26.3.4 Parallel algorithm exceptions [algorithms.parallel.exceptions]
1 During the execution of a parallel algorithm, if temporary memory resources are required for parallelization
and none are available, the algorithm throws abad_alloc exception.
2 During the execution of a parallel algorithm, if the invocation of an element access function exits via an
uncaught exception, the behavior is determined by the execution policy.
26.3.5 Parallel algorithm overloads [algorithms.parallel.overloads]
1 Parallel algorithms are algorithm overloads. Each parallel algorithm overload has an additional function
parameter P of typeT&& as the first function parameter, whereT is the execution policy template parameter.
[Note 1: Not all algorithms have parallel algorithm overloads.—end note]
2 Unless otherwise specified, the semantics of calling a parallel algorithm overload are identical to calling the
corresponding algorithm overload without the parameterP, using all but the first argument.
3 Unless otherwise specified, the complexity requirements of a parallel algorithm overload are relaxed from
the complexity requirements of the corresponding overload without the parameterP as follows: when the
guarantee says “at mostexpr” or “exactlyexpr” and does not specify the number of assignments or swaps,
and expr is not already expressed withO() notation, the complexity of the algorithm shall beO(expr).
4 A parallel algorithm with a template parameter namedExecutionPolicy shall not participate in overload
resolution unless that template parameter satisfiesexecution-policy .
26.3.6 Execution policies [execpol]
26.3.6.1 General [execpol.general]
1 Subclause 26.3.6 describes classes that areexecution policytypes. An object of an execution policy type
indicates the kinds of parallelism allowed in the execution of an algorithm and expresses the consequent
requirements on the element access functions. Execution policy types are declared in header<execution>
(33.4).
[Example 1:
using namespace std;
vector<int> v = /* ... */;
// standard sequential sort
sort(v.begin(), v.end());
// explicitly sequential sort
sort(execution::seq, v.begin(), v.end());
// permitting parallel execution
sort(execution::par, v.begin(), v.end());
// permitting vectorization as well
sort(execution::par_unseq, v.begin(), v.end());
—end example]
[Note 1: Implementations can provide additional execution policies to those described in this document as extensions
to address parallel architectures that require idiosyncratic parameters for efficient execution.—end note]
26.3.6.2 Execution policy type trait [execpol.type]
template<class T> struct is_execution_policy;
1 is_execution_policy can be used to detect execution policies for the purpose of excluding function
signatures from otherwise ambiguous overload resolution participation.
§ 26.3.6.2 © ISO/IEC
1411

===== PAGE 1423 =====

Dxxxx
2 is_execution_policy<T> is aCpp17UnaryTypeTraitwith a base characteristic oftrue_type if T is
the type of a standard or implementation-defined execution policy, otherwisefalse_type.
[Note 1: This provision reserves the privilege of creating non-standard execution policies to the library
implementation. —end note]
3 The behavior of a program that adds specializations foris_execution_policy is undefined.
26.3.6.3 Sequenced execution policy [execpol.seq]
class execution::sequenced_policy { unspecified };
1 The classexecution::sequenced_policy is an execution policy type used as a unique type to disam-
biguate parallel algorithm overloading and require that a parallel algorithm’s execution may not be
parallelized.
2 During the execution of a parallel algorithm with theexecution::sequenced_policy policy, if the
invocation of an element access function exits via an exception,terminate is invoked (14.6.2).
26.3.6.4 Parallel execution policy [execpol.par]
class execution::parallel_policy { unspecified };
1 The class execution::parallel_policy is an execution policy type used as a unique type to dis-
ambiguate parallel algorithm overloading and indicate that a parallel algorithm’s execution may be
parallelized.
2 During the execution of a parallel algorithm with theexecution::parallel_policy policy, if the
invocation of an element access function exits via an exception,terminate is invoked (14.6.2).
26.3.6.5 Parallel and unsequenced execution policy [execpol.parunseq]
class execution::parallel_unsequenced_policy { unspecified };
1 The classexecution::parallel_unsequenced_policy is an execution policy type used as a unique
type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm’s execution
may be parallelized and vectorized.
2 During the execution of a parallel algorithm with theexecution::parallel_unsequenced_policy
policy, if the invocation of an element access function exits via an exception,terminate is invoked
(14.6.2).
26.3.6.6 Unsequenced execution policy [execpol.unseq]
class execution::unsequenced_policy { unspecified };
1 The class unsequenced_policy is an execution policy type used as a unique type to disambiguate
parallel algorithm overloading and indicate that a parallel algorithm’s execution may be vectorized,
e.g., executed on a single thread using instructions that operate on multiple data items.
2 During the execution of a parallel algorithm with theexecution::unsequenced_policy policy, if the
invocation of an element access function exits via an exception,terminate is invoked (14.6.2).
26.3.6.7 Execution policy objects [execpol.objects]
inline constexpr execution::sequenced_policy execution::seq{ unspecified };
inline constexpr execution::parallel_policy execution::par{ unspecified };
inline constexpr execution::parallel_unsequenced_policy execution::par_unseq{ unspecified };
inline constexpr execution::unsequenced_policy execution::unseq{ unspecified };
1 The header<execution> (33.4) declares global objects associated with each type of execution policy.
26.4 Header <algorithm> synopsis [algorithm.syn]
// mostly freestanding
#include <initializer_list> // see 17.11.2
namespace std {
namespace ranges {
// 26.5, algorithm result types
template<class I, class F>
struct in_fun_result;
§ 26.4 © ISO/IEC
1412

===== PAGE 1424 =====

Dxxxx
template<class I1, class I2>
struct in_in_result;
template<class I, class O>
struct in_out_result;
template<class I1, class I2, class O>
struct in_in_out_result;
template<class I, class O1, class O2>
struct in_out_out_result;
template<class T>
struct min_max_result;
template<class I>
struct in_found_result;
template<class I, class T>
struct in_value_result;
template<class O, class T>
struct out_value_result;
}
// 26.6, non-modifying sequence operations
// 26.6.1, all of
template<class InputIterator, class Predicate>
constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool all_of(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, Predicate pred);
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool all_of(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool all_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool all_of(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
// 26.6.2, any of
template<class InputIterator, class Predicate>
constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool any_of(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, Predicate pred);
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool any_of(R&& r, Pred pred, Proj proj = {});
§ 26.4 © ISO/IEC
1413

===== PAGE 1425 =====

Dxxxx
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool any_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool any_of(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
// 26.6.3, none of
template<class InputIterator, class Predicate>
constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool none_of(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, Predicate pred);
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool none_of(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool none_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool none_of(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
// 26.6.4, contains
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr bool contains(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr bool contains(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
bool contains(Ep&& exec, I first, S last, const T& value,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
bool contains(Ep&& exec, R&& r, const T& value, Proj proj = {}); // freestanding-deleted
template<forward_iterator I1, sentinel_for<I1> S1,
forward_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool contains_subrange(R1&& r1, R2&& r2,
§ 26.4 © ISO/IEC
1414

===== PAGE 1426 =====

Dxxxx
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool contains_subrange(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool contains_subrange(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {}, Proj1 proj1 = {},
Proj2 proj2 = {}); // freestanding-deleted
}
// 26.6.5, for each
template<class InputIterator, class Function>
constexpr Function for_each(InputIterator first, InputIterator last, Function f);
template<class ExecutionPolicy, class ForwardIterator, class Function>
void for_each(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, Function f);
namespace ranges {
template<class I, class F>
using for_each_result = in_fun_result<I, F>;
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
constexpr for_each_result<I, Fun>
for_each(I first, S last, Fun f, Proj proj = {});
template<input_range R, class Proj = identity,
indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
constexpr for_each_result<borrowed_iterator_t<R>, Fun>
for_each(R&& r, Fun f, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
I for_each(Ep&& exec, I first, S last, Fun f, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
borrowed_iterator_t<R>
for_each(Ep&& exec, R&& r, Fun f, Proj proj = {}); // freestanding-deleted
}
template<class InputIterator, class Size, class Function>
constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
ForwardIterator for_each_n(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, Size n, Function f);
namespace ranges {
template<class I, class F>
using for_each_n_result = in_fun_result<I, F>;
template<input_iterator I, class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
constexpr for_each_n_result<I, Fun>
for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
I for_each_n(Ep&& exec, I first, iter_difference_t<I> n, Fun f,
Proj proj = {}); // freestanding-deleted
§ 26.4 © ISO/IEC
1415

===== PAGE 1427 =====

Dxxxx
}
// 26.6.6, find
template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
constexpr InputIterator find(InputIterator first, InputIterator last,
const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator find(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
const T& value);
template<class InputIterator, class Predicate>
constexpr InputIterator find_if(InputIterator first, InputIterator last,
Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator find_if(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Predicate pred);
template<class InputIterator, class Predicate>
constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator find_if_not(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Predicate pred);
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr I find(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
constexpr borrowed_iterator_t<R>
find(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
I find(Ep&& exec, I first, S last, const T& value, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
borrowed_iterator_t<R>
find(Ep&& exec, R&& r, const T& value, Proj proj = {}); // freestanding-deleted
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_iterator_t<R>
find_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
I find_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_iterator_t<R>
find_if(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
§ 26.4 © ISO/IEC
1416

===== PAGE 1428 =====

Dxxxx
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_iterator_t<R>
find_if_not(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
I find_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_iterator_t<R>
find_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
// 26.6.7, find last
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr subrange<I> find_last(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr borrowed_subrange_t<R> find_last(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
subrange<I>
find_last(Ep&& exec, I first, S last, const T& value,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
borrowed_subrange_t<R>
find_last(Ep&& exec, R&& r, const T& value, Proj proj = {}); // freestanding-deleted
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I> find_last_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_subrange_t<R> find_last_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
subrange<I>
find_last_if(Ep&& exec, I first, S last, Pred pred,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_subrange_t<R>
find_last_if(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I> find_last_if_not(I first, S last, Pred pred, Proj proj = {});
§ 26.4 © ISO/IEC
1417

===== PAGE 1429 =====

Dxxxx
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_subrange_t<R> find_last_if_not(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
subrange<I>
find_last_if_not(Ep&& exec, I first, S last, Pred pred,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_subrange_t<R>
find_last_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
// 26.6.8, find end
template<class ForwardIterator1, class ForwardIterator2>
constexpr ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
constexpr ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator1
find_end(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1,
class ForwardIterator2, class BinaryPredicate>
ForwardIterator1
find_end(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
namespace ranges {
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr subrange<I1>
find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr borrowed_subrange_t<R1>
find_end(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
subrange<I1>
find_end(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
borrowed_subrange_t<R1>
§ 26.4 © ISO/IEC
1418

===== PAGE 1430 =====

Dxxxx
find_end(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
// 26.6.9, find first of
template<class InputIterator, class ForwardIterator>
constexpr InputIterator
find_first_of(InputIterator first1, InputIterator last1,
ForwardIterator first2, ForwardIterator last2);
template<class InputIterator, class ForwardIterator, class BinaryPredicate>
constexpr InputIterator
find_first_of(InputIterator first1, InputIterator last1,
ForwardIterator first2, ForwardIterator last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator1
find_first_of(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1,
class ForwardIterator2, class BinaryPredicate>
ForwardIterator1
find_first_of(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
namespace ranges {
template<input_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, forward_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr borrowed_iterator_t<R1>
find_first_of(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
I1 find_first_of(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
borrowed_iterator_t<R1>
find_first_of(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
// 26.6.10, adjacent find
template<class ForwardIterator>
constexpr ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class BinaryPredicate>
constexpr ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
§ 26.4 © ISO/IEC
1419

===== PAGE 1431 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
adjacent_find(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
ForwardIterator
adjacent_find(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_binary_predicate<projected<I, Proj>,
projected<I, Proj>> Pred = ranges::equal_to>
constexpr I adjacent_find(I first, S last, Pred pred = {},
Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_binary_predicate<projected<iterator_t<R>, Proj>,
projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
constexpr borrowed_iterator_t<R>
adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_binary_predicate<projected<I, Proj>,
projected<I, Proj>> Pred = ranges::equal_to>
I adjacent_find(Ep&& exec, I first, S last, Pred pred = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_binary_predicate<projected<iterator_t<R>, Proj>,
projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
borrowed_iterator_t<R>
adjacent_find(Ep&& exec, R&& r, Pred pred = {}, Proj proj = {}); // freestanding-deleted
}
// 26.6.11, count
template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
constexpr typename iterator_traits<InputIterator>::difference_type
count(InputIterator first, InputIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
typename iterator_traits<ForwardIterator>::difference_type
count(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, const T& value);
template<class InputIterator, class Predicate>
constexpr typename iterator_traits<InputIterator>::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
typename iterator_traits<ForwardIterator>::difference_type
count_if(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, Predicate pred);
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr iter_difference_t<I>
count(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
constexpr range_difference_t<R>
count(R&& r, const T& value, Proj proj = {});
§ 26.4 © ISO/IEC
1420

===== PAGE 1432 =====

Dxxxx
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
iter_difference_t<I>
count(Ep&& exec, I first, S last, const T& value, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
range_difference_t<R>
count(Ep&& exec, R&& r, const T& value, Proj proj = {}); // freestanding-deleted
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr iter_difference_t<I>
count_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr range_difference_t<R>
count_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
iter_difference_t<I>
count_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
range_difference_t<R>
count_if(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
// 26.6.12, mismatch
template<class InputIterator1, class InputIterator2>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2);
template<class InputIterator1, class InputIterator2, class BinaryPredicate>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);
template<class InputIterator1, class InputIterator2>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class InputIterator1, class InputIterator2, class BinaryPredicate>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
§ 26.4 © ISO/IEC
1421

===== PAGE 1433 =====

Dxxxx
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
namespace ranges {
template<class I1, class I2>
using mismatch_result = in_in_result<I1, I2>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr mismatch_result<I1, I2>
mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
mismatch(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
mismatch_result<I1, I2>
mismatch(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
mismatch(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
// 26.6.13, equal
template<class InputIterator1, class InputIterator2>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2);
template<class InputIterator1, class InputIterator2, class BinaryPredicate>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);
template<class InputIterator1, class InputIterator2>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class InputIterator1, class InputIterator2, class BinaryPredicate>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool equal(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
bool equal(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);
§ 26.4 © ISO/IEC
1422

===== PAGE 1434 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool equal(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
bool equal(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
namespace ranges {
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool equal(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool equal(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool equal(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
// 26.6.14, is permutation
template<class ForwardIterator1, class ForwardIterator2>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);
template<class ForwardIterator1, class ForwardIterator2>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
namespace ranges {
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
sentinel_for<I2> S2, class Proj1 = identity, class Proj2 = identity,
indirect_equivalence_relation<projected<I1, Proj1>,
projected<I2, Proj2>> Pred = ranges::equal_to>
constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
class Proj1 = identity, class Proj2 = identity,
indirect_equivalence_relation<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>
§ 26.4 © ISO/IEC
1423

===== PAGE 1435 =====

Dxxxx
Pred = ranges::equal_to>
constexpr bool is_permutation(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
}
// 26.6.15, search
template<class ForwardIterator1, class ForwardIterator2>
constexpr ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
constexpr ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator1
search(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
ForwardIterator1
search(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
namespace ranges {
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
sentinel_for<I2> S2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr subrange<I1>
search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr borrowed_subrange_t<R1>
search(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
subrange<I1>
search(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
borrowed_subrange_t<R1>
search(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
template<class ForwardIterator, class Size,
class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator
search_n(ForwardIterator first, ForwardIterator last,
Size count, const T& value);
§ 26.4 © ISO/IEC
1424

===== PAGE 1436 =====

Dxxxx
template<class ForwardIterator, class Size,
class T = iterator_traits<ForwardIterator>::value_type, class BinaryPredicate>
constexpr ForwardIterator
search_n(ForwardIterator first, ForwardIterator last,
Size count, const T& value, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Size,
class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator
search_n(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Size count, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size,
class T = iterator_traits<ForwardIterator>::value_type, class BinaryPredicate>
ForwardIterator
search_n(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Size count, const T& value,
BinaryPredicate pred);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S,
class Pred = ranges::equal_to, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirectly_comparable<I, const T*, Pred, Proj>
constexpr subrange<I>
search_n(I first, S last, iter_difference_t<I> count,
const T& value, Pred pred = {}, Proj proj = {});
template<forward_range R, class Pred = ranges::equal_to,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
constexpr borrowed_subrange_t<R>
search_n(R&& r, range_difference_t<R> count,
const T& value, Pred pred = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Pred = ranges::equal_to, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirectly_comparable<I, const T*, Pred, Proj>
subrange<I>
search_n(Ep&& exec, I first, S last, iter_difference_t<I> count,
const T& value, Pred pred = {}, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Pred = ranges::equal_to,
class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
borrowed_subrange_t<R>
search_n(Ep&& exec, R&& r, range_difference_t<R> count,
const T& value, Pred pred = {}, Proj proj = {}); // freestanding-deleted
}
template<class ForwardIterator, class Searcher>
constexpr ForwardIterator
search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);
namespace ranges {
// 26.6.16, starts with
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool starts_with(R1&& r1, R2&& r2, Pred pred = {},
§ 26.4 © ISO/IEC
1425

===== PAGE 1437 =====

Dxxxx
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool starts_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1,
sized-random-access-range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool starts_with(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
// 26.6.17, ends with
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires (forward_iterator<I1> || sized_sentinel_for<S1, I1>) &&
(forward_iterator<I2> || sized_sentinel_for<S2, I2>) &&
indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires (forward_range<R1> || sized_range<R1>) &&
(forward_range<R2> || sized_range<R2>) &&
indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool ends_with(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool ends_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1,
sized-random-access-range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool ends_with(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
// 26.6.18, fold
template<class F>
class flipped { // exposition only
F f ; // exposition only
public:
template<class T, class U> requires invocable<F&, U, T>
invoke_result_t<F&, U, T> operator()(T&&, U&&);
};
template<class F, class T, class I, class U>
concept indirectly-binary-left-foldable-impl = // exposition only
movable<T> && movable<U> &&
convertible_to<T, U> && invocable<F&, U, iter_reference_t<I>> &&
assignable_from<U&, invoke_result_t<F&, U, iter_reference_t<I>>>;
template<class F, class T, class I>
concept indirectly-binary-left-foldable = // exposition only
copy_constructible<F> && indirectly_readable<I> &&
invocable<F&, T, iter_reference_t<I>> &&
§ 26.4 © ISO/IEC
1426

===== PAGE 1438 =====

Dxxxx
convertible_to<invoke_result_t<F&, T, iter_reference_t<I>>,
decay_t<invoke_result_t<F&, T, iter_reference_t<I>>>> &&
indirectly-binary-left-foldable-impl <F, T, I,
decay_t<invoke_result_t<F&, T, iter_reference_t<I>>>>;
template<class F, class T, class I>
concept indirectly-binary-right-foldable = // exposition only
indirectly-binary-left-foldable <flipped <F>, T, I>;
template<input_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
indirectly-binary-left-foldable <T, I> F>
constexpr auto fold_left(I first, S last, T init, F f);
template<input_range R, class T = range_value_t<R>,
indirectly-binary-left-foldable <T, iterator_t<R>> F>
constexpr auto fold_left(R&& r, T init, F f);
template<input_iterator I, sentinel_for<I> S,
indirectly-binary-left-foldable <iter_value_t<I>, I> F>
requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
constexpr auto fold_left_first(I first, S last, F f);
template<input_range R, indirectly-binary-left-foldable <range_value_t<R>, iterator_t<R>> F>
requires constructible_from<range_value_t<R>, range_reference_t<R>>
constexpr auto fold_left_first(R&& r, F f);
template<bidirectional_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
indirectly-binary-right-foldable <T, I> F>
constexpr auto fold_right(I first, S last, T init, F f);
template<bidirectional_range R, class T = range_value_t<R>,
indirectly-binary-right-foldable <T, iterator_t<R>> F>
constexpr auto fold_right(R&& r, T init, F f);
template<bidirectional_iterator I, sentinel_for<I> S,
indirectly-binary-right-foldable <iter_value_t<I>, I> F>
requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
constexpr auto fold_right_last(I first, S last, F f);
template<bidirectional_range R,
indirectly-binary-right-foldable <range_value_t<R>, iterator_t<R>> F>
requires constructible_from<range_value_t<R>, range_reference_t<R>>
constexpr auto fold_right_last(R&& r, F f);
template<class I, class T>
using fold_left_with_iter_result = in_value_result<I, T>;
template<class I, class T>
using fold_left_first_with_iter_result = in_value_result<I, T>;
template<input_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
indirectly-binary-left-foldable <T, I> F>
constexpr see below fold_left_with_iter(I first, S last, T init, F f);
template<input_range R, class T = range_value_t<R>,
indirectly-binary-left-foldable <T, iterator_t<R>> F>
constexpr see below fold_left_with_iter(R&& r, T init, F f);
template<input_iterator I, sentinel_for<I> S,
indirectly-binary-left-foldable <iter_value_t<I>, I> F>
requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
constexpr see below fold_left_first_with_iter(I first, S last, F f);
§ 26.4 © ISO/IEC
1427

===== PAGE 1439 =====

Dxxxx
template<input_range R,
indirectly-binary-left-foldable <range_value_t<R>, iterator_t<R>> F>
requires constructible_from<range_value_t<R>, range_reference_t<R>>
constexpr see below fold_left_first_with_iter(R&& r, F f);
}
// 26.7, mutating sequence operations
// 26.7.1, copy
template<class InputIterator, class OutputIterator>
constexpr OutputIterator copy(InputIterator first, InputIterator last,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2 copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
namespace ranges {
template<class I, class O>
using copy_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr copy_result<I, O>
copy(I first, S last, O result);
template<input_range R, weakly_incrementable O>
requires indirectly_copyable<iterator_t<R>, O>
constexpr copy_result<borrowed_iterator_t<R>, O>
copy(R&& r, O result);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
copy_result<I, O>
copy(Ep&& exec, I first, S last, O result, OutS result_last); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
copy(Ep&& exec, R&& r, OutR&& result_r); // freestanding-deleted
}
template<class InputIterator, class Size, class OutputIterator>
constexpr OutputIterator copy_n(InputIterator first, Size n,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class Size,
class ForwardIterator2>
ForwardIterator2 copy_n(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, Size n,
ForwardIterator2 result);
namespace ranges {
template<class I, class O>
using copy_n_result = in_out_result<I, O>;
template<input_iterator I, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr copy_n_result<I, O>
copy_n(I first, iter_difference_t<I> n, O result);
template<execution-policy Ep, random_access_iterator I, random_access_iterator O,
sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
copy_n_result<I, O>
copy_n(Ep&& exec, I first, iter_difference_t<I> n, O result,
OutS result_last); // freestanding-deleted
§ 26.4 © ISO/IEC
1428

===== PAGE 1440 =====

Dxxxx
}
template<class InputIterator, class OutputIterator, class Predicate>
constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Predicate>
ForwardIterator2 copy_if(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, Predicate pred);
namespace ranges {
template<class I, class O>
using copy_if_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
constexpr copy_if_result<I, O>
copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O>
constexpr copy_if_result<borrowed_iterator_t<R>, O>
copy_if(R&& r, O result, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
copy_if_result<I, O>
copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred,
Proj proj = {}); // freestanding-deleted
}
template<class BidirectionalIterator1, class BidirectionalIterator2>
constexpr BidirectionalIterator2
copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
BidirectionalIterator2 result);
namespace ranges {
template<class I1, class I2>
using copy_backward_result = in_out_result<I1, I2>;
template<bidirectional_iterator I1, sentinel_for<I1> S1, bidirectional_iterator I2>
requires indirectly_copyable<I1, I2>
constexpr copy_backward_result<I1, I2>
copy_backward(I1 first, S1 last, I2 result);
template<bidirectional_range R, bidirectional_iterator I>
requires indirectly_copyable<iterator_t<R>, I>
constexpr copy_backward_result<borrowed_iterator_t<R>, I>
copy_backward(R&& r, I result);
}
§ 26.4 © ISO/IEC
1429

===== PAGE 1441 =====

Dxxxx
// 26.7.2, move
template<class InputIterator, class OutputIterator>
constexpr OutputIterator move(InputIterator first, InputIterator last,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1,
class ForwardIterator2>
ForwardIterator2 move(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
namespace ranges {
template<class I, class O>
using move_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_movable<I, O>
constexpr move_result<I, O>
move(I first, S last, O result);
template<input_range R, weakly_incrementable O>
requires indirectly_movable<iterator_t<R>, O>
constexpr move_result<borrowed_iterator_t<R>, O>
move(R&& r, O result);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_movable<I, O>
move_result<I, O>
move(Ep&& exec, I first, S last, O result, OutS result_last); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_movable<iterator_t<R>, iterator_t<OutR>>
move_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
move(Ep&& exec, R&& r, OutR&& result_r); // freestanding-deleted
}
template<class BidirectionalIterator1, class BidirectionalIterator2>
constexpr BidirectionalIterator2
move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
BidirectionalIterator2 result);
namespace ranges {
template<class I1, class I2>
using move_backward_result = in_out_result<I1, I2>;
template<bidirectional_iterator I1, sentinel_for<I1> S1, bidirectional_iterator I2>
requires indirectly_movable<I1, I2>
constexpr move_backward_result<I1, I2>
move_backward(I1 first, S1 last, I2 result);
template<bidirectional_range R, bidirectional_iterator I>
requires indirectly_movable<iterator_t<R>, I>
constexpr move_backward_result<borrowed_iterator_t<R>, I>
move_backward(R&& r, I result);
}
// 26.7.3, swap
template<class ForwardIterator1, class ForwardIterator2>
constexpr ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2 swap_ranges(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
§ 26.4 © ISO/IEC
1430

===== PAGE 1442 =====

Dxxxx
namespace ranges {
template<class I1, class I2>
using swap_ranges_result = in_in_result<I1, I2>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2>
requires indirectly_swappable<I1, I2>
constexpr swap_ranges_result<I1, I2>
swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
template<input_range R1, input_range R2>
requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
constexpr swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
swap_ranges(R1&& r1, R2&& r2);
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2>
requires indirectly_swappable<I1, I2>
swap_ranges_result<I1, I2>
swap_ranges(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2>
requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
swap_ranges(Ep&& exec, R1&& r1, R2&& r2); // freestanding-deleted
}
template<class ForwardIterator1, class ForwardIterator2>
constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b);
// 26.7.4, transform
template<class InputIterator, class OutputIterator, class UnaryOperation>
constexpr OutputIterator
transform(InputIterator first1, InputIterator last1,
OutputIterator result, UnaryOperation op);
template<class InputIterator1, class InputIterator2, class OutputIterator,
class BinaryOperation>
constexpr OutputIterator
transform(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, OutputIterator result,
BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class UnaryOperation>
ForwardIterator2
transform(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 result, UnaryOperation op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class BinaryOperation>
ForwardIterator
transform(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator result,
BinaryOperation binary_op);
namespace ranges {
template<class I, class O>
using unary_transform_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
copy_constructible F, class Proj = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
constexpr unary_transform_result<I, O>
transform(I first1, S last1, O result, F op, Proj proj = {});
template<input_range R, weakly_incrementable O, copy_constructible F,
class Proj = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
§ 26.4 © ISO/IEC
1431

===== PAGE 1443 =====

Dxxxx
constexpr unary_transform_result<borrowed_iterator_t<R>, O>
transform(R&& r, O result, F op, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
copy_constructible F, class Proj = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
unary_transform_result<I, O>
transform(Ep&& exec, I first1, S last1, O result, OutS result_last,
F op, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
copy_constructible F, class Proj = identity>
requires indirectly_writable<iterator_t<OutR>,
indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
unary_transform_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
transform(Ep&& exec, R&& r, OutR&& result_r, F op, Proj proj = {}); // freestanding-deleted
template<class I1, class I2, class O>
using binary_transform_result = in_in_out_result<I1, I2, O>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, copy_constructible F, class Proj1 = identity,
class Proj2 = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
projected<I2, Proj2>>>
constexpr binary_transform_result<I1, I2, O>
transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
copy_constructible F, class Proj1 = identity, class Proj2 = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>>
constexpr binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
transform(R1&& r1, R2&& r2, O result,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS,
copy_constructible F, class Proj1 = identity, class Proj2 = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
projected<I2, Proj2>>>
binary_transform_result<I1, I2, O>
transform(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
O result, OutS result_last,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, copy_constructible F,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_writable<iterator_t<OutR>,
indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>>
binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
transform(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
// 26.7.5, replace
template<class ForwardIterator, class T>
constexpr void replace(ForwardIterator first, ForwardIterator last,
const T& old_value, const T& new_value);
§ 26.4 © ISO/IEC
1432

===== PAGE 1444 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
void replace(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
const T& old_value, const T& new_value);
template<class ForwardIterator, class Predicate,
class T = iterator_traits<ForwardIterator>::value_type>
constexpr void replace_if(ForwardIterator first, ForwardIterator last,
Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator, class Predicate,
class T = iterator_traits<ForwardIterator>::value_type>
void replace_if(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Predicate pred, const T& new_value);
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<I>>
requires indirectly_writable<I, const T2&> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
constexpr I
replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
template<input_range R, class Proj = identity,
class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = range_value_t<R>>
requires indirectly_writable<iterator_t<R>, const T2&> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T1*>
constexpr borrowed_iterator_t<R>
replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<I>>
requires indirectly_writable<I, const T2&> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
I replace(Ep&& exec, I first, S last,
const T1& old_value, const T2& new_value, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = range_value_t<R>>
requires indirectly_writable<iterator_t<R>, const T2&> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T1*>
borrowed_iterator_t<R>
replace(Ep&& exec, R&& r, const T1& old_value, const T2& new_value,
Proj proj = {}); // freestanding-deleted
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = iter_value_t<I>,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_writable<I, const T&>
constexpr I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
template<input_range R, class Proj = identity, class T = range_value_t<R>,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_writable<iterator_t<R>, const T&>
constexpr borrowed_iterator_t<R>
replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = iter_value_t<I>,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_writable<I, const T&>
I replace_if(Ep&& exec, I first, S last, Pred pred,
const T& new_value, Proj proj = {}); // freestanding-deleted
§ 26.4 © ISO/IEC
1433

===== PAGE 1445 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = range_value_t<R>,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_writable<iterator_t<R>, const T&>
borrowed_iterator_t<R>
replace_if(Ep&& exec, R&& r, Pred pred, const T& new_value,
Proj proj = {}); // freestanding-deleted
}
template<class InputIterator, class OutputIterator, class T>
constexpr OutputIterator replace_copy(InputIterator first, InputIterator last,
OutputIterator result,
const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
ForwardIterator2 replace_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result,
const T& old_value, const T& new_value);
template<class InputIterator, class OutputIterator, class Predicate,
class T = iterator_traits<OutputIterator>::value_type>
constexpr OutputIterator replace_copy_if(InputIterator first, InputIterator last,
OutputIterator result,
Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Predicate, class T = iterator_traits<ForwardIterator2>::value_type>
ForwardIterator2 replace_copy_if(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result,
Predicate pred, const T& new_value);
namespace ranges {
template<class I, class O>
using replace_copy_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, class O,
class Proj = identity,
class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
output_iterator<O, const T2&>
constexpr replace_copy_result<I, O>
replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
Proj proj = {});
template<input_range R, class O, class Proj = identity,
class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
requires indirectly_copyable<iterator_t<R>, O> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T1*> &&
output_iterator<O, const T2&>
constexpr replace_copy_result<borrowed_iterator_t<R>, O>
replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity,
class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
indirectly_writable<O, const T2&>
replace_copy_result<I, O>
replace_copy(Ep&& exec, I first, S last, O result, OutS result_last, const T1& old_value,
const T2& new_value, Proj proj = {}); // freestanding-deleted
§ 26.4 © ISO/IEC
1434

===== PAGE 1446 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity, class T1 = projected_value_t<iterator_t<R>, Proj>,
class T2 = range_value_t<OutR>>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T1*> &&
indirectly_writable<iterator_t<OutR>, const T2&>
replace_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
replace_copy(Ep&& exec, R&& r, OutR&& result_r, const T1& old_value, const T2& new_value,
Proj proj = {}); // freestanding-deleted
template<class I, class O>
using replace_copy_if_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, class O, class T = iter_value_t<O>,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O> && output_iterator<O, const T&>
constexpr replace_copy_if_result<I, O>
replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
Proj proj = {});
template<input_range R, class O, class T = iter_value_t<O>, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O> && output_iterator<O, const T&>
constexpr replace_copy_if_result<borrowed_iterator_t<R>, O>
replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS, class T = iter_value_t<O>,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O> && indirectly_writable<O, const T&>
replace_copy_if_result<I, O>
replace_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
Pred pred, const T& new_value, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class T = range_value_t<OutR>, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
indirectly_writable<iterator_t<OutR>, const T&>
replace_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
replace_copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, const T& new_value,
Proj proj = {}); // freestanding-deleted
}
// 26.7.6, fill
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
void fill(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, const T& value);
template<class OutputIterator, class Size,
class T = iterator_traits<OutputIterator>::value_type>
constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value)
template<class ExecutionPolicy, class ForwardIterator,
class Size, class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator fill_n(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, Size n, const T& value);
namespace ranges {
template<class O, sentinel_for<O> S, class T = iter_value_t<O>>
requires output_iterator<O, const T&>
constexpr O fill(O first, S last, const T& value);
§ 26.4 © ISO/IEC
1435

===== PAGE 1447 =====

Dxxxx
template<class R, class T = range_value_t<R>>
requires output_range<R, const T&>
constexpr borrowed_iterator_t<R> fill(R&& r, const T& value);
template<class O, class T = iter_value_t<O>>
requires output_iterator<O, const T&>
constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);
template<execution-policy Ep, random_access_iterator O, sized_sentinel_for<O> S,
class T = iter_value_t<O>>
requires indirectly_writable<O, const T&>
O fill(Ep&& exec, O first, S last, const T& value); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class T = range_value_t<R>>
requires indirectly_writable<iterator_t<R>, const T&>
borrowed_iterator_t<R> fill(Ep&& exec, R&& r, const T& value); // freestanding-deleted
template<execution-policy Ep, random_access_iterator O, class T = iter_value_t<O>>
requires indirectly_writable<O, const T&>
O fill_n(Ep&& exec, O first, iter_difference_t<O> n, const T& value); // freestanding-deleted
}
// 26.7.7, generate
template<class ForwardIterator, class Generator>
constexpr void generate(ForwardIterator first, ForwardIterator last,
Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Generator>
void generate(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Generator gen);
template<class OutputIterator, class Size, class Generator>
constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
ForwardIterator generate_n(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, Size n, Generator gen);
namespace ranges {
template<input_or_output_iterator O, sentinel_for<O> S, copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
constexpr O generate(O first, S last, F gen);
template<class R, copy_constructible F>
requires invocable<F&> && output_range<R, invoke_result_t<F&>>
constexpr borrowed_iterator_t<R> generate(R&& r, F gen);
template<input_or_output_iterator O, copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
template<execution-policy Ep, random_access_iterator O, sized_sentinel_for<O> S,
copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
O generate(Ep&& exec, O first, S last, F gen); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, copy_constructible F>
requires invocable<F&> && indirectly_writable<iterator_t<R>, invoke_result_t<F&>>
borrowed_iterator_t<R> generate(Ep&& exec, R&& r, F gen); // freestanding-deleted
template<execution-policy Ep, random_access_iterator O, copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
O generate_n(Ep&& exec, O first, iter_difference_t<O> n, F gen); // freestanding-deleted
}
// 26.7.8, remove
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator remove(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
const T& value);
§ 26.4 © ISO/IEC
1436

===== PAGE 1448 =====

Dxxxx
template<class ForwardIterator, class Predicate>
constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator remove_if(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Predicate pred);
namespace ranges {
template<permutable I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr subrange<I> remove(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires permutable<iterator_t<R>> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
constexpr borrowed_subrange_t<R>
remove(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires permutable<I> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
subrange<I> remove(Ep&& exec, I first, S last, const T& value,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires permutable<iterator_t<R>> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
borrowed_subrange_t<R>
remove(Ep&& exec, R&& r, const T& value, Proj proj = {}); // freestanding-deleted
template<permutable I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I> remove_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R>
remove_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
subrange<I>
remove_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
remove_if(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
template<class InputIterator, class OutputIterator,
class T = iterator_traits<InputIterator>::value_type>
constexpr OutputIterator
remove_copy(InputIterator first, InputIterator last,
OutputIterator result, const T& value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class T = iterator_traits<ForwardIterator1>::value_type>
ForwardIterator2
§ 26.4 © ISO/IEC
1437

===== PAGE 1449 =====

Dxxxx
remove_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, const T& value);
template<class InputIterator, class OutputIterator, class Predicate>
constexpr OutputIterator
remove_copy_if(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Predicate>
ForwardIterator2
remove_copy_if(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, Predicate pred);
namespace ranges {
template<class I, class O>
using remove_copy_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr remove_copy_result<I, O>
remove_copy(I first, S last, O result, const T& value, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirectly_copyable<iterator_t<R>, O> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
constexpr remove_copy_result<borrowed_iterator_t<R>, O>
remove_copy(R&& r, O result, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
remove_copy_result<I, O>
remove_copy(Ep&& exec, I first, S last, O result, OutS result_last, const T& value,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
remove_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
remove_copy(Ep&& exec, R&& r, OutR&& result_r, const T& value,
Proj proj = {}); // freestanding-deleted
template<class I, class O>
using remove_copy_if_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
constexpr remove_copy_if_result<I, O>
remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O>
constexpr remove_copy_if_result<borrowed_iterator_t<R>, O>
remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
§ 26.4 © ISO/IEC
1438

===== PAGE 1450 =====

Dxxxx
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
remove_copy_if_result<I, O>
remove_copy_if(Ep&& exec, I first, S last, O result, OutS result_last, Pred pred,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
remove_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
remove_copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred,
Proj proj = {}); // freestanding-deleted
}
// 26.7.9, unique
template<class ForwardIterator>
constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class BinaryPredicate>
constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator unique(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
ForwardIterator unique(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
namespace ranges {
template<permutable I, sentinel_for<I> S, class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
constexpr subrange<I> unique(I first, S last, C comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R>
unique(R&& r, C comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
requires permutable<I>
subrange<I> unique(Ep&& exec, I first, S last, C comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
unique(Ep&& exec, R&& r, C comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
unique_copy(InputIterator first, InputIterator last,
OutputIterator result);
template<class InputIterator, class OutputIterator, class BinaryPredicate>
constexpr OutputIterator
unique_copy(InputIterator first, InputIterator last,
OutputIterator result, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
unique_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
§ 26.4 © ISO/IEC
1439

===== PAGE 1451 =====

Dxxxx
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
ForwardIterator2
unique_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryPredicate pred);
namespace ranges {
template<class I, class O>
using unique_copy_result = in_out_result<I, O>;
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
requires indirectly_copyable<I, O> &&
(forward_iterator<I> ||
(input_iterator<O> && same_as<iter_value_t<I>, iter_value_t<O>>) ||
indirectly_copyable_storable<I, O>)
constexpr unique_copy_result<I, O>
unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires indirectly_copyable<iterator_t<R>, O> &&
(forward_iterator<iterator_t<R>> ||
(input_iterator<O> && same_as<range_value_t<R>, iter_value_t<O>>) ||
indirectly_copyable_storable<iterator_t<R>, O>)
constexpr unique_copy_result<borrowed_iterator_t<R>, O>
unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS, class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
requires indirectly_copyable<I, O>
unique_copy_result<I, O>
unique_copy(Ep&& exec, I first, S last, O result, OutS result_last, C comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
unique_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
unique_copy(Ep&& exec, R&& r, OutR&& result_r, C comp = {},
Proj proj = {}); // freestanding-deleted
}
// 26.7.10, reverse
template<class BidirectionalIterator>
constexpr void reverse(BidirectionalIterator first, BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
void reverse(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
BidirectionalIterator first, BidirectionalIterator last);
namespace ranges {
template<bidirectional_iterator I, sentinel_for<I> S>
requires permutable<I>
constexpr I reverse(I first, S last);
template<bidirectional_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_iterator_t<R> reverse(R&& r);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
I reverse(Ep&& exec, I first, S last); // freestanding-deleted
§ 26.4 © ISO/IEC
1440

===== PAGE 1452 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_iterator_t<R> reverse(Ep&& exec, R&& r); // freestanding-deleted
}
template<class BidirectionalIterator, class OutputIterator>
constexpr OutputIterator
reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
OutputIterator result);
template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
ForwardIterator
reverse_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
BidirectionalIterator first, BidirectionalIterator last,
ForwardIterator result);
namespace ranges {
template<class I, class O>
using reverse_copy_result = in_out_result<I, O>;
template<class I, class O>
using reverse_copy_truncated_result = in_in_out_result<I, I, O>;
template<bidirectional_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr reverse_copy_result<I, O>
reverse_copy(I first, S last, O result);
template<bidirectional_range R, weakly_incrementable O>
requires indirectly_copyable<iterator_t<R>, O>
constexpr reverse_copy_result<borrowed_iterator_t<R>, O>
reverse_copy(R&& r, O result);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
reverse_copy_truncated_result<I, O>
reverse_copy(Ep&& exec, I first, S last, O result,
OutS result_last); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
reverse_copy_truncated_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
reverse_copy(Ep&& exec, R&& r, OutR&& result_r); // freestanding-deleted
}
// 26.7.11, rotate
template<class ForwardIterator>
constexpr ForwardIterator rotate(ForwardIterator first,
ForwardIterator middle,
ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator rotate(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first,
ForwardIterator middle,
ForwardIterator last);
namespace ranges {
template<permutable I, sentinel_for<I> S>
constexpr subrange<I> rotate(I first, I middle, S last);
template<forward_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> rotate(R&& r, iterator_t<R> middle);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
subrange<I>
rotate(Ep&& exec, I first, I middle, S last); // freestanding-deleted
§ 26.4 © ISO/IEC
1441

===== PAGE 1453 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
rotate(Ep&& exec, R&& r, iterator_t<R> middle); // freestanding-deleted
}
template<class ForwardIterator, class OutputIterator>
constexpr OutputIterator
rotate_copy(ForwardIterator first, ForwardIterator middle,
ForwardIterator last, OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
rotate_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 middle,
ForwardIterator1 last, ForwardIterator2 result);
namespace ranges {
template<class I, class O>
using rotate_copy_result = in_out_result<I, O>;
template<class I, class O>
using rotate_copy_truncated_result = in_in_out_result<I, I, O>;
template<forward_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr rotate_copy_result<I, O>
rotate_copy(I first, I middle, S last, O result);
template<forward_range R, weakly_incrementable O>
requires indirectly_copyable<iterator_t<R>, O>
constexpr rotate_copy_result<borrowed_iterator_t<R>, O>
rotate_copy(R&& r, iterator_t<R> middle, O result);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
rotate_copy_truncated_result<I, O>
rotate_copy(Ep&& exec, I first, I middle, S last, O result, // freestanding-deleted
OutS result_last);
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
rotate_copy_truncated_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
rotate_copy(Ep&& exec, R&& r, iterator_t<R> middle, // freestanding-deleted
OutR&& result_r);
}
// 26.7.12, sample
template<class PopulationIterator, class SampleIterator,
class Distance, class UniformRandomBitGenerator>
SampleIterator sample(PopulationIterator first, PopulationIterator last,
SampleIterator out, Distance n,
UniformRandomBitGenerator&& g);
namespace ranges {
template<input_iterator I, sentinel_for<I> S,
weakly_incrementable O, class Gen>
requires (forward_iterator<I> || random_access_iterator<O>) &&
indirectly_copyable<I, O> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
O sample(I first, S last, O out, iter_difference_t<I> n, Gen&& g);
template<input_range R, weakly_incrementable O, class Gen>
requires (forward_range<R> || random_access_iterator<O>) &&
indirectly_copyable<iterator_t<R>, O> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
O sample(R&& r, O out, range_difference_t<R> n, Gen&& g);
}
§ 26.4 © ISO/IEC
1442

===== PAGE 1454 =====

Dxxxx
// 26.7.13, shuffle
template<class RandomAccessIterator, class UniformRandomBitGenerator>
void shuffle(RandomAccessIterator first,
RandomAccessIterator last,
UniformRandomBitGenerator&& g);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Gen>
requires permutable<I> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
I shuffle(I first, S last, Gen&& g);
template<random_access_range R, class Gen>
requires permutable<iterator_t<R>> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
borrowed_iterator_t<R> shuffle(R&& r, Gen&& g);
}
// 26.7.14, shift
template<class ForwardIterator>
constexpr ForwardIterator
shift_left(ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
shift_left(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
namespace ranges {
template<permutable I, sentinel_for<I> S>
constexpr subrange<I> shift_left(I first, S last, iter_difference_t<I> n);
template<forward_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> shift_left(R&& r, range_difference_t<R> n);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
subrange<I>
shift_left(Ep&& exec, I first, S last, iter_difference_t<I> n); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
shift_left(Ep&& exec, R&& r, range_difference_t<R> n); // freestanding-deleted
}
template<class ForwardIterator>
constexpr ForwardIterator
shift_right(ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
shift_right(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
namespace ranges {
template<permutable I, sentinel_for<I> S>
constexpr subrange<I> shift_right(I first, S last, iter_difference_t<I> n);
template<forward_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> shift_right(R&& r, range_difference_t<R> n);
§ 26.4 © ISO/IEC
1443

===== PAGE 1455 =====

Dxxxx
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
subrange<I>
shift_right(Ep&& exec, I first, S last, iter_difference_t<I> n); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
shift_right(Ep&& exec, R&& r, range_difference_t<R> n); // freestanding-deleted
}
// 26.8, sorting and related operations
// 26.8.2, sorting
template<class RandomAccessIterator>
constexpr void sort(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void sort(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator>
void sort(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void sort(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
sort(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
sort(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class RandomAccessIterator>
constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last); // hosted
template<class RandomAccessIterator, class Compare>
constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last, // hosted
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator>
void stable_sort(ExecutionPolicy&& exec, // hosted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void stable_sort(ExecutionPolicy&& exec, // hosted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
§ 26.4 © ISO/IEC
1444

===== PAGE 1456 =====

Dxxxx
constexpr I stable_sort(I first, S last, Comp comp = {}, Proj proj = {}); // hosted
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
stable_sort(R&& r, Comp comp = {}, Proj proj = {}); // hosted
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I stable_sort(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
stable_sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class RandomAccessIterator>
constexpr void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
RandomAccessIterator last, Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator>
void partial_sort(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator middle,
RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void partial_sort(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator middle,
RandomAccessIterator last, Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
partial_sort(R&& r, iterator_t<R> middle, Comp comp = {},
Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I partial_sort(Ep&& exec, I first, I middle, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R,
class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
partial_sort(Ep&& exec, R&& r, iterator_t<R> middle, Comp comp = {},
Proj proj = {}); // freestanding-deleted
}
template<class InputIterator, class RandomAccessIterator>
constexpr RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last);
§ 26.4 © ISO/IEC
1445

===== PAGE 1457 =====

Dxxxx
template<class InputIterator, class RandomAccessIterator, class Compare>
constexpr RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
RandomAccessIterator
partial_sort_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
class Compare>
RandomAccessIterator
partial_sort_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last,
Compare comp);
namespace ranges {
template<class I, class O>
using partial_sort_copy_result = in_out_result<I, O>;
template<input_iterator I1, sentinel_for<I1> S1,
random_access_iterator I2, sentinel_for<I2> S2,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
constexpr partial_sort_copy_result<I1, I2>
partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, random_access_range R2, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
sortable<iterator_t<R2>, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>
constexpr partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
partial_sort_copy_result<I1, I2>
partial_sort_copy(Ep&& exec, I1 first, S1 last, I2 result_first, S2 result_last,
Comp comp = {}, Proj1 proj1 = {},
Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
sortable<iterator_t<R2>, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>
partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
partial_sort_copy(Ep&& exec, R1&& r, R2&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
§ 26.4 © ISO/IEC
1446

===== PAGE 1458 =====

Dxxxx
template<class ForwardIterator>
constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator>
bool is_sorted(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
bool is_sorted(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Compare comp);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr bool is_sorted(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
bool is_sorted(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
bool is_sorted(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class ForwardIterator>
constexpr ForwardIterator
is_sorted_until(ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr ForwardIterator
is_sorted_until(ForwardIterator first, ForwardIterator last,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
is_sorted_until(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
ForwardIterator
is_sorted_until(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Compare comp);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I is_sorted_until(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
§ 26.4 © ISO/IEC
1447

===== PAGE 1459 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
is_sorted_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
// 26.8.3, Nth element
template<class RandomAccessIterator>
constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last, Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator>
void nth_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void nth_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last, Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I nth_element(Ep&& exec, I first, I nth, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
nth_element(Ep&& exec, R&& r, iterator_t<R> nth, Comp comp = {},
Proj proj = {}); // freestanding-deleted
}
// 26.8.4, binary search
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
const T& value, Compare comp);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>,
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr I lower_bound(I first, S last, const T& value, Comp comp = {},
Proj proj = {});
§ 26.4 © ISO/IEC
1448

===== PAGE 1460 =====

Dxxxx
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr borrowed_iterator_t<R>
lower_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
const T& value, Compare comp);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr I upper_bound(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr borrowed_iterator_t<R>
upper_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr pair<ForwardIterator, ForwardIterator>
equal_range(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr pair<ForwardIterator, ForwardIterator>
equal_range(ForwardIterator first, ForwardIterator last,
const T& value, Compare comp);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj,
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr subrange<I>
equal_range(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr borrowed_subrange_t<R>
equal_range(R&& r, const T& value, Comp comp = {}, Proj proj = {});
}
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr bool
binary_search(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr bool
binary_search(ForwardIterator first, ForwardIterator last,
const T& value, Compare comp);
§ 26.4 © ISO/IEC
1449

===== PAGE 1461 =====

Dxxxx
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>,
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr bool binary_search(I first, S last, const T& value, Comp comp = {},
Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr bool binary_search(R&& r, const T& value, Comp comp = {},
Proj proj = {});
}
// 26.8.5, partitions
template<class InputIterator, class Predicate>
constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool is_partitioned(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, Predicate pred);
namespace ranges {
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool is_partitioned(Ep&& exec, I first, S last, Pred pred,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool is_partitioned(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
template<class ForwardIterator, class Predicate>
constexpr ForwardIterator partition(ForwardIterator first,
ForwardIterator last,
Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator partition(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first,
ForwardIterator last,
Predicate pred);
namespace ranges {
template<permutable I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I>
partition(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R>
partition(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
subrange<I>
partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {}); // freestanding-deleted
§ 26.4 © ISO/IEC
1450

===== PAGE 1462 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
partition(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
template<class BidirectionalIterator, class Predicate>
constexpr BidirectionalIterator stable_partition(BidirectionalIterator first, // hosted
BidirectionalIterator last,
Predicate pred);
template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
BidirectionalIterator stable_partition(ExecutionPolicy&& exec, // hosted,
BidirectionalIterator first, // see 26.3.5
BidirectionalIterator last,
Predicate pred);
namespace ranges {
template<bidirectional_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
constexpr subrange<I> stable_partition(I first, S last, Pred pred, // hosted
Proj proj = {});
template<bidirectional_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> stable_partition(R&& r, Pred pred, // hosted
Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
subrange<I>
stable_partition(Ep&& exec, I first, S last, Pred pred,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
stable_partition(Ep&& exec, R&& r, Pred pred, Proj proj = {}); // freestanding-deleted
}
template<class InputIterator, class OutputIterator1,
class OutputIterator2, class Predicate>
constexpr pair<OutputIterator1, OutputIterator2>
partition_copy(InputIterator first, InputIterator last,
OutputIterator1 out_true, OutputIterator2 out_false,
Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
class ForwardIterator2, class Predicate>
pair<ForwardIterator1, ForwardIterator2>
partition_copy(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
ForwardIterator1 out_true, ForwardIterator2 out_false,
Predicate pred);
namespace ranges {
template<class I, class O1, class O2>
using partition_copy_result = in_out_out_result<I, O1, O2>;
template<input_iterator I, sentinel_for<I> S,
weakly_incrementable O1, weakly_incrementable O2,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
§ 26.4 © ISO/IEC
1451

===== PAGE 1463 =====

Dxxxx
constexpr partition_copy_result<I, O1, O2>
partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
Proj proj = {});
template<input_range R, weakly_incrementable O1, weakly_incrementable O2,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O1> &&
indirectly_copyable<iterator_t<R>, O2>
constexpr partition_copy_result<borrowed_iterator_t<R>, O1, O2>
partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O1, sized_sentinel_for<O1> OutS1,
random_access_iterator O2, sized_sentinel_for<O2> OutS2,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
partition_copy_result<I, O1, O2>
partition_copy(Ep&& exec, I first, S last, O1 out_true, OutS1 last_true,
O2 out_false, OutS2 last_false, Pred pred,
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R,
sized-random-access-range OutR1, sized-random-access-range OutR2,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR1>> &&
indirectly_copyable<iterator_t<R>, iterator_t<OutR2>>
partition_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR1>,
borrowed_iterator_t<OutR2>>
partition_copy(Ep&& exec, R&& r, OutR1&& out_true_r, OutR2&& out_false_r, Pred pred,
Proj proj = {}); // freestanding-deleted
}
template<class ForwardIterator, class Predicate>
constexpr ForwardIterator
partition_point(ForwardIterator first, ForwardIterator last,
Predicate pred);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_iterator_t<R>
partition_point(R&& r, Pred pred, Proj proj = {});
}
// 26.8.6, merge
template<class InputIterator1, class InputIterator2, class OutputIterator>
constexpr OutputIterator
merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class InputIterator1, class InputIterator2, class OutputIterator,
class Compare>
constexpr OutputIterator
merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
merge(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
§ 26.4 © ISO/IEC
1452

===== PAGE 1464 =====

Dxxxx
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
merge(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
namespace ranges {
template<class I1, class I2, class O>
using merge_result = in_in_out_result<I1, I2, O>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr merge_result<I1, I2, O>
merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
merge(R1&& r1, R2&& r2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
merge_result<I1, I2, O>
merge(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, O result, OutS result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
merge(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
template<class BidirectionalIterator>
constexpr void inplace_merge(BidirectionalIterator first, // hosted
BidirectionalIterator middle,
BidirectionalIterator last);
template<class BidirectionalIterator, class Compare>
constexpr void inplace_merge(BidirectionalIterator first, // hosted
BidirectionalIterator middle,
BidirectionalIterator last, Compare comp);
template<class ExecutionPolicy, class BidirectionalIterator>
void inplace_merge(ExecutionPolicy&& exec, // hosted, see 26.3.5
BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
void inplace_merge(ExecutionPolicy&& exec, // hosted, see 26.3.5
BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last, Compare comp);
§ 26.4 © ISO/IEC
1453

===== PAGE 1465 =====

Dxxxx
namespace ranges {
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {}); // hosted
template<bidirectional_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {}); // hosted
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I inplace_merge(Ep&& exec, I first, I middle, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
inplace_merge(Ep&& exec, R&& r, iterator_t<R> middle, Comp comp = {},
Proj proj = {}); // freestanding-deleted
}
// 26.8.7, set operations
template<class InputIterator1, class InputIterator2>
constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class InputIterator1, class InputIterator2, class Compare>
constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool includes(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Compare>
bool includes(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
Compare comp);
namespace ranges {
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
ranges::less>
constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
constexpr bool includes(R1&& r1, R2&& r2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
ranges::less>
bool includes(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
§ 26.4 © ISO/IEC
1454

===== PAGE 1466 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
bool includes(Ep&& exec, R1&& r1, R2&& r2,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
template<class InputIterator1, class InputIterator2, class OutputIterator>
constexpr OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
constexpr OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_union(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_union(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
namespace ranges {
template<class I1, class I2, class O>
using set_union_result = in_in_out_result<I1, I2, O>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr set_union_result<I1, I2, O>
set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
set_union_result<I1, I2, O>
set_union(Ep&& exec, I1 first1, S1 last1,
I2 first2, S2 last2, O result, OutS result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
§ 26.4 © ISO/IEC
1455

===== PAGE 1467 =====

Dxxxx
set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
set_union(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
template<class InputIterator1, class InputIterator2, class OutputIterator>
constexpr OutputIterator
set_intersection(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
constexpr OutputIterator
set_intersection(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_intersection(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_intersection(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
namespace ranges {
template<class I1, class I2, class O>
using set_intersection_result = in_in_out_result<I1, I2, O>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr set_intersection_result<I1, I2, O>
set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
set_intersection(R1&& r1, R2&& r2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
set_intersection_result<I1, I2, O>
set_intersection(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
O result, OutS result_last, Comp comp = {}, Proj1 proj1 = {},
Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
§ 26.4 © ISO/IEC
1456

===== PAGE 1468 =====

Dxxxx
set_intersection(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
template<class InputIterator1, class InputIterator2, class OutputIterator>
constexpr OutputIterator
set_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
constexpr OutputIterator
set_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_difference(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_difference(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
namespace ranges {
template<class I, class O>
using set_difference_result = in_out_result<I, O>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr set_difference_result<I1, O>
set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr set_difference_result<borrowed_iterator_t<R1>, O>
set_difference(R1&& r1, R2&& r2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
set_difference_result<I1, O>
set_difference(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
O result, OutS result_last, Comp comp = {}, Proj1 proj1 = {},
Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
set_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<OutR>>
set_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
§ 26.4 © ISO/IEC
1457

===== PAGE 1469 =====

Dxxxx
template<class InputIterator1, class InputIterator2, class OutputIterator>
constexpr OutputIterator
set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
constexpr OutputIterator
set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_symmetric_difference(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_symmetric_difference(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
namespace ranges {
template<class I1, class I2, class O>
using set_symmetric_difference_result = in_in_out_result<I1, I2, O>;
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr set_symmetric_difference_result<I1, I2, O>
set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {},
Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr set_symmetric_difference_result<borrowed_iterator_t<R1>,
borrowed_iterator_t<R2>, O>
set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
set_symmetric_difference_result<I1, I2, O>
set_symmetric_difference(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
O result, OutS result_last, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
set_symmetric_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
set_symmetric_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
§ 26.4 © ISO/IEC
1458

===== PAGE 1470 =====

Dxxxx
// 26.8.8, heap operations
template<class RandomAccessIterator>
constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
push_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
push_heap(R&& r, Comp comp = {}, Proj proj = {});
}
template<class RandomAccessIterator>
constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
pop_heap(R&& r, Comp comp = {}, Proj proj = {});
}
template<class RandomAccessIterator>
constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
make_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
make_heap(R&& r, Comp comp = {}, Proj proj = {});
}
template<class RandomAccessIterator>
constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
§ 26.4 © ISO/IEC
1459

===== PAGE 1471 =====

Dxxxx
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
sort_heap(R&& r, Comp comp = {}, Proj proj = {});
}
template<class RandomAccessIterator>
constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator>
bool is_heap(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
bool is_heap(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr bool is_heap(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
bool is_heap(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
bool is_heap(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class RandomAccessIterator>
constexpr RandomAccessIterator
is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr RandomAccessIterator
is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator>
RandomAccessIterator
is_heap_until(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
RandomAccessIterator
is_heap_until(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
namespace ranges {
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
§ 26.4 © ISO/IEC
1460

===== PAGE 1472 =====

Dxxxx
template<random_access_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I is_heap_until(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
is_heap_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
// 26.8.9, minimum and maximum
template<class T> constexpr const T& min(const T& a, const T& b);
template<class T, class Compare>
constexpr const T& min(const T& a, const T& b, Compare comp);
template<class T>
constexpr T min(initializer_list<T> t);
template<class T, class Compare>
constexpr T min(initializer_list<T> t, Compare comp);
namespace ranges {
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr const T& min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
template<copyable T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr T min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
constexpr range_value_t<R>
min(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
range_value_t<R>
min(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class T> constexpr const T& max(const T& a, const T& b);
template<class T, class Compare>
constexpr const T& max(const T& a, const T& b, Compare comp);
template<class T>
constexpr T max(initializer_list<T> t);
template<class T, class Compare>
constexpr T max(initializer_list<T> t, Compare comp);
namespace ranges {
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr const T& max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
template<copyable T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr T max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
constexpr range_value_t<R>
max(R&& r, Comp comp = {}, Proj proj = {});
§ 26.4 © ISO/IEC
1461

===== PAGE 1473 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
range_value_t<R>
max(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
template<class T, class Compare>
constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
template<class T>
constexpr pair<T, T> minmax(initializer_list<T> t);
template<class T, class Compare>
constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);
namespace ranges {
template<class T>
using minmax_result = min_max_result<T>;
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr minmax_result<const T&>
minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
template<copyable T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr minmax_result<T>
minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
constexpr minmax_result<range_value_t<R>>
minmax(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
minmax_result<range_value_t<R>>
minmax(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class ForwardIterator>
constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator min_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
ForwardIterator min_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Compare comp);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
min_element(R&& r, Comp comp = {}, Proj proj = {});
§ 26.4 © ISO/IEC
1462

===== PAGE 1474 =====

Dxxxx
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I min_element(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R,
class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
min_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class ForwardIterator>
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator max_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
ForwardIterator max_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last,
Compare comp);
namespace ranges {
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
max_element(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I max_element(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R,
class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
max_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
template<class ForwardIterator>
constexpr pair<ForwardIterator, ForwardIterator>
minmax_element(ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr pair<ForwardIterator, ForwardIterator>
minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
template<class ExecutionPolicy, class ForwardIterator>
pair<ForwardIterator, ForwardIterator>
minmax_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
pair<ForwardIterator, ForwardIterator>
minmax_element(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, Compare comp);
namespace ranges {
template<class I>
using minmax_element_result = min_max_result<I>;
§ 26.4 © ISO/IEC
1463

===== PAGE 1475 =====

Dxxxx
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr minmax_element_result<I>
minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr minmax_element_result<borrowed_iterator_t<R>>
minmax_element(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
minmax_element_result<I>
minmax_element(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
minmax_element_result<borrowed_iterator_t<R>>
minmax_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {}); // freestanding-deleted
}
// 26.8.10, bounded value
template<class T>
constexpr const T& clamp(const T& v, const T& lo, const T& hi);
template<class T, class Compare>
constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);
namespace ranges {
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr const T&
clamp(const T& v, const T& lo, const T& hi, Comp comp = {}, Proj proj = {});
}
// 26.8.11, lexicographical comparison
template<class InputIterator1, class InputIterator2>
constexpr bool
lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class InputIterator1, class InputIterator2, class Compare>
constexpr bool
lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool
lexicographical_compare(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Compare>
bool
lexicographical_compare(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
Compare comp);
namespace ranges {
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
ranges::less>
constexpr bool
lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
§ 26.4 © ISO/IEC
1464

===== PAGE 1476 =====

Dxxxx
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
constexpr bool
lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>,
projected<I2, Proj2>> Comp = ranges::less>
bool lexicographical_compare(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Comp comp = {}, Proj1 proj1 = {},
Proj2 proj2 = {}); // freestanding-deleted
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
bool lexicographical_compare(Ep&& exec, R1&& r1, R2&& r2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {}); // freestanding-deleted
}
// 26.8.12, three-way comparison algorithms
template<class InputIterator1, class InputIterator2, class Cmp>
constexpr auto
lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
InputIterator2 b2, InputIterator2 e2,
Cmp comp)
-> decltype(comp(*b1, *b2));
template<class InputIterator1, class InputIterator2>
constexpr auto
lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
InputIterator2 b2, InputIterator2 e2);
// 26.8.13, permutations
template<class BidirectionalIterator>
constexpr bool next_permutation(BidirectionalIterator first,
BidirectionalIterator last);
template<class BidirectionalIterator, class Compare>
constexpr bool next_permutation(BidirectionalIterator first,
BidirectionalIterator last, Compare comp);
namespace ranges {
template<class I>
using next_permutation_result = in_found_result<I>;
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr next_permutation_result<I>
next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
template<bidirectional_range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr next_permutation_result<borrowed_iterator_t<R>>
next_permutation(R&& r, Comp comp = {}, Proj proj = {});
}
template<class BidirectionalIterator>
constexpr bool prev_permutation(BidirectionalIterator first,
BidirectionalIterator last);
§ 26.4 © ISO/IEC
1465

===== PAGE 1477 =====

Dxxxx
template<class BidirectionalIterator, class Compare>
constexpr bool prev_permutation(BidirectionalIterator first,
BidirectionalIterator last, Compare comp);
namespace ranges {
template<class I>
using prev_permutation_result = in_found_result<I>;
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr prev_permutation_result<I>
prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
template<bidirectional_range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr prev_permutation_result<borrowed_iterator_t<R>>
prev_permutation(R&& r, Comp comp = {}, Proj proj = {});
}
}
26.5 Algorithm result types [algorithms.results]
1 Each of the class templates specified in this subclause has the template parameters, data members, and
special members specified below, and has no base classes or members other than those specified.
namespace std::ranges {
template<class I, class F>
struct in_fun_result {
[[no_unique_address]] I in;
[[no_unique_address]] F fun;
template<class I2, class F2>
requires convertible_to<const I&, I2> && convertible_to<const F&, F2>
constexpr operator in_fun_result<I2, F2>() const & {
return {in, fun};
}
template<class I2, class F2>
requires convertible_to<I, I2> && convertible_to<F, F2>
constexpr operator in_fun_result<I2, F2>() && {
return {std::move(in), std::move(fun)};
}
};
template<class I1, class I2>
struct in_in_result {
[[no_unique_address]] I1 in1;
[[no_unique_address]] I2 in2;
template<class II1, class II2>
requires convertible_to<const I1&, II1> && convertible_to<const I2&, II2>
constexpr operator in_in_result<II1, II2>() const & {
return {in1, in2};
}
template<class II1, class II2>
requires convertible_to<I1, II1> && convertible_to<I2, II2>
constexpr operator in_in_result<II1, II2>() && {
return {std::move(in1), std::move(in2)};
}
};
§ 26.5 © ISO/IEC
1466

===== PAGE 1478 =====

Dxxxx
template<class I, class O>
struct in_out_result {
[[no_unique_address]] I in;
[[no_unique_address]] O out;
template<class I2, class O2>
requires convertible_to<const I&, I2> && convertible_to<const O&, O2>
constexpr operator in_out_result<I2, O2>() const & {
return {in, out};
}
template<class I2, class O2>
requires convertible_to<I, I2> && convertible_to<O, O2>
constexpr operator in_out_result<I2, O2>() && {
return {std::move(in), std::move(out)};
}
};
template<class I1, class I2, class O>
struct in_in_out_result {
[[no_unique_address]] I1 in1;
[[no_unique_address]] I2 in2;
[[no_unique_address]] O out;
template<class II1, class II2, class OO>
requires convertible_to<const I1&, II1> &&
convertible_to<const I2&, II2> &&
convertible_to<const O&, OO>
constexpr operator in_in_out_result<II1, II2, OO>() const & {
return {in1, in2, out};
}
template<class II1, class II2, class OO>
requires convertible_to<I1, II1> &&
convertible_to<I2, II2> &&
convertible_to<O, OO>
constexpr operator in_in_out_result<II1, II2, OO>() && {
return {std::move(in1), std::move(in2), std::move(out)};
}
};
template<class I, class O1, class O2>
struct in_out_out_result {
[[no_unique_address]] I in;
[[no_unique_address]] O1 out1;
[[no_unique_address]] O2 out2;
template<class II, class OO1, class OO2>
requires convertible_to<const I&, II> &&
convertible_to<const O1&, OO1> &&
convertible_to<const O2&, OO2>
constexpr operator in_out_out_result<II, OO1, OO2>() const & {
return {in, out1, out2};
}
template<class II, class OO1, class OO2>
requires convertible_to<I, II> &&
convertible_to<O1, OO1> &&
convertible_to<O2, OO2>
constexpr operator in_out_out_result<II, OO1, OO2>() && {
return {std::move(in), std::move(out1), std::move(out2)};
}
};
§ 26.5 © ISO/IEC
1467

===== PAGE 1479 =====

Dxxxx
template<class T>
struct min_max_result {
[[no_unique_address]] T min;
[[no_unique_address]] T max;
template<class T2>
requires convertible_to<const T&, T2>
constexpr operator min_max_result<T2>() const & {
return {min, max};
}
template<class T2>
requires convertible_to<T, T2>
constexpr operator min_max_result<T2>() && {
return {std::move(min), std::move(max)};
}
};
template<class I>
struct in_found_result {
[[no_unique_address]] I in;
bool found;
template<class I2>
requires convertible_to<const I&, I2>
constexpr operator in_found_result<I2>() const & {
return {in, found};
}
template<class I2>
requires convertible_to<I, I2>
constexpr operator in_found_result<I2>() && {
return {std::move(in), found};
}
};
template<class I, class T>
struct in_value_result {
[[no_unique_address]] I in;
[[no_unique_address]] T value;
template<class I2, class T2>
requires convertible_to<const I&, I2> && convertible_to<const T&, T2>
constexpr operator in_value_result<I2, T2>() const & {
return {in, value};
}
template<class I2, class T2>
requires convertible_to<I, I2> && convertible_to<T, T2>
constexpr operator in_value_result<I2, T2>() && {
return {std::move(in), std::move(value)};
}
};
template<class O, class T>
struct out_value_result {
[[no_unique_address]] O out;
[[no_unique_address]] T value;
template<class O2, class T2>
requires convertible_to<const O&, O2> && convertible_to<const T&, T2>
constexpr operator out_value_result<O2, T2>() const & {
return {out, value};
}
§ 26.5 © ISO/IEC
1468

===== PAGE 1480 =====

Dxxxx
template<class O2, class T2>
requires convertible_to<O, O2> && convertible_to<T, T2>
constexpr operator out_value_result<O2, T2>() && {
return {std::move(out), std::move(value)};
}
};
}
26.6 Non-modifying sequence operations [alg.nonmodifying]
26.6.1 All of [alg.all.of]
template<class InputIterator, class Predicate>
constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool all_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
Predicate pred);
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool ranges::all_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool ranges::all_of(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool ranges::all_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool ranges::all_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let E be:
—(1.1) pred(*i) for the overloads in namespacestd;
—(1.2) invoke(pred, invoke(proj, *i)) for the overloads in namespaceranges.
2 Returns: false if E is false for some iteratori in the range[first,last), andtrue otherwise.
3 Complexity: At mostlast - first applications of the predicate and any projection.
26.6.2 Any of [alg.any.of]
template<class InputIterator, class Predicate>
constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool any_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
Predicate pred);
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool ranges::any_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool ranges::any_of(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool ranges::any_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool ranges::any_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let E be:
—(1.1) pred(*i) for the overloads in namespacestd;
—(1.2) invoke(pred, invoke(proj, *i)) for the overloads in namespaceranges.
§ 26.6.2 © ISO/IEC
1469

===== PAGE 1481 =====

Dxxxx
2 Returns: true if E is true for some iteratori in the range[first,last), andfalse otherwise.
3 Complexity: At mostlast - first applications of the predicate and any projection.
26.6.3 None of [alg.none.of]
template<class InputIterator, class Predicate>
constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool none_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
Predicate pred);
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool ranges::none_of(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool ranges::none_of(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool ranges::none_of(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool ranges::none_of(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let E be:
—(1.1) pred(*i) for the overloads in namespacestd;
—(1.2) invoke(pred, invoke(proj, *i)) for the overloads in namespaceranges.
2 Returns: false if E is true for some iteratori in the range[first,last), andtrue otherwise.
3 Complexity: At mostlast - first applications of the predicate and any projection.
26.6.4 Contains [alg.contains]
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr bool ranges::contains(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr bool ranges::contains(R&& r, const T& value, Proj proj = {});
1 Returns: ranges::find(std::move(first), last, value, proj) != last.
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
bool ranges::contains(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
bool ranges::contains(Ep&& exec, R&& r, const T& value, Proj proj = {});
2 Returns: ranges::find(std::forward<Ep>(exec), first, last, value, proj) != last.
template<forward_iterator I1, sentinel_for<I1> S1,
forward_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool ranges::contains_subrange(I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
§ 26.6.4 © ISO/IEC
1470

===== PAGE 1482 =====

Dxxxx
template<forward_range R1, forward_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool ranges::contains_subrange(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
3 Returns:
first2 == last2 || !ranges::search(first1, last1, first2, last2,
pred, proj1, proj2).empty()
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool ranges::contains_subrange(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool ranges::contains_subrange(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
4 Returns:
first2 == last2 || !ranges::search(std::forward<Ep>(exec), first1, last1,
first2, last2, pred, proj1, proj2).empty()
26.6.5 For each [alg.foreach]
template<class InputIterator, class Function>
constexpr Function for_each(InputIterator first, InputIterator last, Function f);
1 Preconditions: Function meets theCpp17MoveConstructible requirements (Table 31).
[Note 1: Function need not meet the requirements ofCpp17CopyConstructible (Table 32). —end note]
2 Effects: Applies f to the result of dereferencing every iterator in the range[first,last), starting from
first and proceeding tolast - 1.
[Note 2: If the type offirst meets the requirements of a mutable iterator,f can apply non-constant functions
through the dereferenced iterator.—end note]
3 Returns: f.
4 Complexity: Applies f exactly last - first times.
5 Remarks: If f returns a result, the result is ignored.
template<class ExecutionPolicy, class ForwardIterator, class Function>
void for_each(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Function f);
6 Preconditions: Function meets theCpp17CopyConstructible requirements.
7 Effects: Applies f to the result of dereferencing every iterator in the range[first,last).
[Note 3: If the type offirst meets the requirements of a mutable iterator,f can apply non-constant functions
through the dereferenced iterator.—end note]
8 Complexity: Applies f exactly last - first times.
9 Remarks: If f returns a result, the result is ignored. Implementations do not have the freedom granted
under 26.3.3 to make arbitrary copies of elements from the input sequence.
10 [Note 4: Does not return a copy of itsFunction parameter, since parallelization often does not permit efficient
state accumulation. —end note]
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
constexpr ranges::for_each_result<I, Fun>
ranges::for_each(I first, S last, Fun f, Proj proj = {});
§ 26.6.5 © ISO/IEC
1471

===== PAGE 1483 =====

Dxxxx
template<input_range R, class Proj = identity,
indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
constexpr ranges::for_each_result<borrowed_iterator_t<R>, Fun>
ranges::for_each(R&& r, Fun f, Proj proj = {});
11 Effects: Calls invoke(f, invoke(proj, *i)) for every iteratori in the range[first,last), starting
from first and proceeding tolast - 1.
[Note 5: If the result ofinvoke(proj, *i) is a mutable reference,f can apply non-constant functions.—end
note]
12 Returns: {last, std::move(f)}.
13 Complexity: Applies f and proj exactly last - first times.
14 Remarks: If f returns a result, the result is ignored.
15 [Note 6: The overloads in namespaceranges require Fun to modelcopy_constructible. —end note]
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
I ranges::for_each(Ep&& exec, I first, S last, Fun f, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
borrowed_iterator_t<R>
ranges::for_each(Ep&& exec, R&& r, Fun f, Proj proj = {});
16 Effects: Calls invoke(f, invoke(proj, *i)) for every iteratori in the range[first,last).
[Note 7: If the result ofinvoke(proj, *i) is a mutable reference,f can apply non-constant functions.—end
note]
17 Returns: last.
18 Complexity: Applies f and proj exactly last - first times.
19 Remarks:
—(19.1) If f returns a result, the result is ignored.
—(19.2) Implementations do not have the freedom granted under 26.3.3 to make arbitrary copies of elements
from the input sequence.
—(19.3) f may modify objects via its arguments (26.3.2).
[Note 8: Does not return a copy of itsFun parameter, since parallelization often does not permit efficient state
accumulation. —end note]
template<class InputIterator, class Size, class Function>
constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
20 Mandates: The typeSize is convertible to an integral type (7.3.9, 11.4.8).
21 Preconditions: n >= 0 is true. Function meets theCpp17MoveConstructible requirements.
[Note 9: Function need not meet the requirements ofCpp17CopyConstructible. —end note]
22 Effects: Applies f to the result of dereferencing every iterator in the range[first,first + n) in order.
[Note 10: If the type offirst meets the requirements of a mutable iterator,f can apply non-constant functions
through the dereferenced iterator.—end note]
23 Returns: first + n.
24 Remarks: If f returns a result, the result is ignored.
template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
ForwardIterator for_each_n(ExecutionPolicy&& exec, ForwardIterator first, Size n,
Function f);
25 Mandates: The typeSize is convertible to an integral type (7.3.9, 11.4.8).
26 Preconditions: n >= 0 is true. Function meets theCpp17CopyConstructible requirements.
27 Effects: Applies f to the result of dereferencing every iterator in the range[first,first + n).
§ 26.6.5 © ISO/IEC
1472

===== PAGE 1484 =====

Dxxxx
[Note 11: If the type offirst meets the requirements of a mutable iterator,f can apply non-constant functions
through the dereferenced iterator.—end note]
28 Returns: first + n.
29 Remarks: If f returns a result, the result is ignored. Implementations do not have the freedom granted
under 26.3.3 to make arbitrary copies of elements from the input sequence.
template<input_iterator I, class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
constexpr ranges::for_each_n_result<I, Fun>
ranges::for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
30 Preconditions: n >= 0 is true.
31 Effects: Calls invoke(f, invoke(proj, *i)) for every iteratori in the range[first,first + n) in
order.
[Note 12: If the result ofinvoke(proj, *i) is a mutable reference,f can apply non-constant functions.—end
note]
32 Returns: {first + n, std::move(f)}.
33 Remarks: If f returns a result, the result is ignored.
34 [Note 13: The overload in namespaceranges requires Fun to modelcopy_constructible. —end note]
template<execution-policy Ep, random_access_iterator I, class Proj = identity,
indirectly_unary_invocable<projected<I, Proj>> Fun>
I ranges::for_each_n(Ep&& exec, I first, iter_difference_t<I> n, Fun f, Proj proj = {});
35 Preconditions: n >= 0 is true.
36 Effects: Calls invoke(f, invoke(proj, *i)) for every iteratori in the range[first,first + n).
[Note 14: If the result ofinvoke(proj, *i) is a mutable reference,f can apply non-constant functions.—end
note]
37 Returns: first + n.
38 Remarks:
—(38.1) If f returns a result, the result is ignored.
—(38.2) Implementations do not have the freedom granted under 26.3.3 to make arbitrary copies of elements
from the input sequence.
—(38.3) f may modify objects via its arguments (26.3.2).
[Note 15: Does not return a copy of itsFun parameter, since parallelization often does not permit efficient state
accumulation. —end note]
26.6.6 Find [alg.find]
template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
constexpr InputIterator find(InputIterator first, InputIterator last,
const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator find(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
const T& value);
template<class InputIterator, class Predicate>
constexpr InputIterator find_if(InputIterator first, InputIterator last,
Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator find_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
Predicate pred);
template<class InputIterator, class Predicate>
constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
Predicate pred);
§ 26.6.6 © ISO/IEC
1473

===== PAGE 1485 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator find_if_not(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Predicate pred);
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr I ranges::find(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr borrowed_iterator_t<R>
ranges::find(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
I ranges::find(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
borrowed_iterator_t<R> ranges::find(Ep&& exec, R&& r, const T& value, Proj proj = {});
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr I ranges::find_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_iterator_t<R>
ranges::find_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
I ranges::find_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_iterator_t<R> ranges::find_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr I ranges::find_if_not(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_iterator_t<R>
ranges::find_if_not(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
I ranges::find_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_iterator_t<R> ranges::find_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let E be:
—(1.1) *i == value for find;
—(1.2) pred(*i) != false for find_if;
—(1.3) pred(*i) == false for find_if_not;
—(1.4) bool(invoke(proj, *i) == value) for ranges::find;
—(1.5) bool(invoke(pred, invoke(proj, *i))) for ranges::find_if;
—(1.6) bool(!invoke(pred, invoke(proj, *i))) for ranges::find_if_not.
§ 26.6.6 © ISO/IEC
1474

===== PAGE 1486 =====

Dxxxx
2 Returns: The first iteratori in the range[first,last) for whichE is true. Returns last if no such
iterator is found.
3 Complexity: At mostlast - first applications of the corresponding predicate and any projection.
26.6.7 Find last [alg.find.last]
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr subrange<I> ranges::find_last(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr borrowed_subrange_t<R> ranges::find_last(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
subrange<I> ranges::find_last(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
borrowed_subrange_t<R> ranges::find_last(Ep&& exec, R&& r, const T& value, Proj proj = {});
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I> ranges::find_last_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_subrange_t<R> ranges::find_last_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
subrange<I> ranges::find_last_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_subrange_t<R> ranges::find_last_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I> ranges::find_last_if_not(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_subrange_t<R> ranges::find_last_if_not(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
subrange<I> ranges::find_last_if_not(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
borrowed_subrange_t<R> ranges::find_last_if_not(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let E be:
—(1.1) bool(invoke(proj, *i) == value) for ranges::find_last;
—(1.2) bool(invoke(pred, invoke(proj, *i))) for ranges::find_last_if;
—(1.3) bool(!invoke(pred, invoke(proj, *i))) for ranges::find_last_if_not.
2 Returns: Let i be the last iterator in the range[first,last) for whichE is true. Returns {i, last},
or {last, last} if no such iterator is found.
3 Complexity: At mostlast - first applications of the corresponding predicate and projection.
§ 26.6.7 © ISO/IEC
1475

===== PAGE 1487 =====

Dxxxx
26.6.8 Find end [alg.find.end]
template<class ForwardIterator1, class ForwardIterator2>
constexpr ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator1
find_end(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
constexpr ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
ForwardIterator1
find_end(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr subrange<I1>
ranges::find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr borrowed_subrange_t<R1>
ranges::find_end(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
subrange<I1>
ranges::find_end(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
borrowed_subrange_t<R1>
ranges::find_end(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) pred be equal_to{} for the overloads with no parameterpred;
—(1.2) E be:
—(1.2.1) pred(*(i + n), *(first2 + n)) for the overloads in namespacestd;
—(1.2.2) invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n)))fortheover-
loads in namespaceranges;
—(1.3) i be last1 if [first2,last2) is empty, or if(last2 - first2) > (last1 - first1) is true,
or if there is no iterator in the range[first1,last1 - (last2 - first2)) such that for every
§ 26.6.8 © ISO/IEC
1476

===== PAGE 1488 =====

Dxxxx
non-negative integern < (last2 - first2), E is true. Otherwise i is the last such iterator in
[first1,last1 - (last2 - first2)).
2 Returns:
—(2.1) i for the overloads in namespacestd.
—(2.2) {i, i + (i == last1 ? 0 : last2 - first2)} for the overloads in namespaceranges.
3 Complexity: At most (last2 - first2) * (last1 - first1 - (last2 - first2) + 1) applica-
tions of the corresponding predicate and any projections.
26.6.9 Find first of [alg.find.first.of]
template<class InputIterator, class ForwardIterator>
constexpr InputIterator
find_first_of(InputIterator first1, InputIterator last1,
ForwardIterator first2, ForwardIterator last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator1
find_first_of(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class InputIterator, class ForwardIterator,
class BinaryPredicate>
constexpr InputIterator
find_first_of(InputIterator first1, InputIterator last1,
ForwardIterator first2, ForwardIterator last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
ForwardIterator1
find_first_of(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<input_iterator I1, sentinel_for<I1> S1, forward_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr I1 ranges::find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, forward_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr borrowed_iterator_t<R1>
ranges::find_first_of(R1&& r1, R2&& r2,
Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
I1 ranges::find_first_of(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
borrowed_iterator_t<R1>
ranges::find_first_of(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let E be:
§ 26.6.9 © ISO/IEC
1477

===== PAGE 1489 =====

Dxxxx
—(1.1) *i == *j for the overloads with no parameterpred;
—(1.2) pred(*i, *j) != false for the overloads with a parameterpred and no parameterproj1;
—(1.3) bool(invoke(pred, invoke(proj1, *i), invoke(proj2, *j))) for the overloads with param-
eters pred and proj1.
2 Effects: Finds an element that matches one of a set of values.
3 Returns: The first iteratori in the range[first1,last1) such that for some iteratorj in the range
[first2,last2) E holds. Returns last1 if [first2,last2) is empty or if no such iterator is found.
4 Complexity: At most (last1 - first1) * (last2 - first2) applications of the corresponding
predicate and any projections.
26.6.10 Adjacent find [alg.adjacent.find]
template<class ForwardIterator>
constexpr ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
adjacent_find(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class BinaryPredicate>
constexpr ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
ForwardIterator
adjacent_find(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_binary_predicate<projected<I, Proj>,
projected<I, Proj>> Pred = ranges::equal_to>
constexpr I ranges::adjacent_find(I first, S last, Pred pred = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_binary_predicate<projected<iterator_t<R>, Proj>,
projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
constexpr borrowed_iterator_t<R> ranges::adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_binary_predicate<projected<I, Proj>,
projected<I, Proj>> Pred = ranges::equal_to>
I ranges::adjacent_find(Ep&& exec, I first, S last, Pred pred = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_binary_predicate<projected<iterator_t<R>, Proj>,
projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
borrowed_iterator_t<R>
ranges::adjacent_find(Ep&& exec, R&& r, Pred pred = {}, Proj proj = {});
1 Let E be:
—(1.1) *i == *(i + 1) for the overloads with no parameterpred;
—(1.2) pred(*i, *(i + 1)) != false for the overloads with a parameterpred and no parameterproj;
—(1.3) bool(invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1)))) for the overloads with
both parameterspred and proj.
2 Returns: The first iteratori such that bothi and i + 1 are in the range[first,last) for whichE
holds. Returns last if no such iterator is found.
3 Complexity: For the non-parallel algorithm overloads, exactly
min((i - first) + 1, (last - first) - 1)
§ 26.6.10 © ISO/IEC
1478

===== PAGE 1490 =====

Dxxxx
applications of the corresponding predicate, wherei is adjacent_find’s return value. For the parallel
algorithm overloads,O(last - first) applications of the corresponding predicate. No more than
twice as many applications of any projection.
26.6.11 Count [alg.count]
template<class InputIterator, class T = iterator_traits<InputIterator>::value_type>
constexpr typename iterator_traits<InputIterator>::difference_type
count(InputIterator first, InputIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
typename iterator_traits<ForwardIterator>::difference_type
count(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, const T& value);
template<class InputIterator, class Predicate>
constexpr typename iterator_traits<InputIterator>::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
typename iterator_traits<ForwardIterator>::difference_type
count_if(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, Predicate pred);
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr iter_difference_t<I>
ranges::count(I first, S last, const T& value, Proj proj = {});
template<input_range R, class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr range_difference_t<R>
ranges::count(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
iter_difference_t<I>
ranges::count(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
range_difference_t<R> ranges::count(Ep&& exec, R&& r, const T& value, Proj proj = {});
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr iter_difference_t<I>
ranges::count_if(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr range_difference_t<R>
ranges::count_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
iter_difference_t<I>
ranges::count_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
range_difference_t<R>
ranges::count_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let E be:
—(1.1) *i == value for the overloads with no parameterpred or proj;
§ 26.6.11 © ISO/IEC
1479

===== PAGE 1491 =====

Dxxxx
—(1.2) pred(*i) != false for the overloads with a parameterpred but no parameterproj;
—(1.3) invoke(proj, *i) == value for the overloads with a parameterproj but no parameterpred;
—(1.4) bool(invoke(pred, invoke(proj, *i))) for the overloads with both parameters proj and
pred.
2 Effects: Returns the number of iteratorsi in the range[first,last) for whichE holds.
3 Complexity: Exactly last - first applications of the corresponding predicate and any projection.
26.6.12 Mismatch [alg.mismatch]
template<class InputIterator1, class InputIterator2>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class InputIterator1, class InputIterator2,
class BinaryPredicate>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);
template<class InputIterator1, class InputIterator2>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class InputIterator1, class InputIterator2,
class BinaryPredicate>
constexpr pair<InputIterator1, InputIterator2>
mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
pair<ForwardIterator1, ForwardIterator2>
mismatch(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr ranges::mismatch_result<I1, I2>
ranges::mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
§ 26.6.12 © ISO/IEC
1480

===== PAGE 1492 =====

Dxxxx
template<input_range R1, input_range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr ranges::mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
ranges::mismatch(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
ranges::mismatch_result<I1, I2>
ranges::mismatch(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
ranges::mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
ranges::mismatch(Ep&& exec, R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let last2 be first2 + (last1 - first1) for the overloads in namespacestd with no parameter
last2.
2 Let E be:
—(2.1) !(*(first1 + n) == *(first2 + n)) for the overloads with no parameterpred;
—(2.2) pred(*(first1 + n), *(first2 + n)) == false for the overloads with a parameterpred and
no parameterproj1;
—(2.3) !invoke(pred, invoke(proj1, *(first1 + n)), invoke(proj2, *(first2 + n))) for the
overloads with both parameterspred and proj1.
3 Let N be min(last1 - first1, last2 - first2).
4 Returns: { first1 + n, first2 + n }, wheren is the smallest integer in[0,N) such thatE holds,
or N if no such integer exists.
5 Complexity: At mostN applications of the corresponding predicate and any projections.
26.6.13 Equal [alg.equal]
template<class InputIterator1, class InputIterator2>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool equal(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class InputIterator1, class InputIterator2,
class BinaryPredicate>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
bool equal(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);
template<class InputIterator1, class InputIterator2>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool equal(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
§ 26.6.13 © ISO/IEC
1481

===== PAGE 1493 =====

Dxxxx
template<class InputIterator1, class InputIterator2,
class BinaryPredicate>
constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
bool equal(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool ranges::equal(I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool ranges::equal(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool ranges::equal(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool ranges::equal(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) last2 be first2 + (last1 - first1) for the overloads in namespacestd with no parameter
last2;
—(1.2) pred be equal_to{} for the overloads with no parameterpred;
—(1.3) E be:
—(1.3.1) pred(*i, *(first2 + (i - first1))) for the overloads with no parameterproj1;
—(1.3.2) invoke(pred, invoke(proj1, *i), invoke(proj2, *(first2 + (i - first1)))) for
the overloads with parameterproj1.
2 Returns: If last1 - first1 != last2 - first2, returnfalse. Otherwise return true if E holds
for every iteratori in the range[first1,last1). Otherwise, returnsfalse.
3 Complexity: If
—(3.1) the types offirst1, last1, first2, andlast2 meet theCpp17RandomAccessIteratorrequire-
ments (24.3.5.7) andlast1 - first1 != last2 - first2 for the overloads in namespacestd;
—(3.2) the types offirst1, last1, first2, andlast2 pairwise modelsized_sentinel_for (24.3.4.8)
and last1 - first1 != last2 - first2 for the first and third overloads in namespaceranges,
or
—(3.3) R1 and R2 each modelsized_range and ranges::distance(r1) != ranges::distance(r2) for
the second and fourth overloads in namespaceranges,
then no applications of the corresponding predicate and each projection; otherwise, at most
min(last1 - first1, last2 - first2)
applications of the corresponding predicate and any projections.
§ 26.6.13 © ISO/IEC
1482

===== PAGE 1494 =====

Dxxxx
26.6.14 Is permutation [alg.is.permutation]
template<class ForwardIterator1, class ForwardIterator2>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, BinaryPredicate pred);
template<class ForwardIterator1, class ForwardIterator2>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
1 Let last2 be first2 + (last1 - first1) for the overloads with no parameter namedlast2, and
let pred be equal_to{} for the overloads with no parameterpred.
2 Mandates: ForwardIterator1 and ForwardIterator2 have the same value type.
3 Preconditions: The comparison function is an equivalence relation.
4 Returns: If last1 - first1 != last2 - first2, returnfalse. Otherwise returntrue if there exists
a permutation of the elements in the range[first2,last2), beginning withForwardIterator2 begin,
such thatequal(first1, last1, begin, pred) returns true; otherwise, returnsfalse.
5 Complexity: No applications of the corresponding predicate ifForwardIterator1 and ForwardIter-
ator2 meet the requirements of random access iterators andlast1 - first1 != last2 - first2.
Otherwise, exactly last1 - first1 applications of the corresponding predicate ifequal(first1,
last1, first2, last2, pred) would returntrue; otherwise, at worstO(N2), whereN has the value
last1 - first1.
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
sentinel_for<I2> S2, class Proj1 = identity, class Proj2 = identity,
indirect_equivalence_relation<projected<I1, Proj1>,
projected<I2, Proj2>> Pred = ranges::equal_to>
constexpr bool ranges::is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2,
class Proj1 = identity, class Proj2 = identity,
indirect_equivalence_relation<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Pred = ranges::equal_to>
constexpr bool ranges::is_permutation(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
6 Returns: If last1 - first1 != last2 - first2, returnfalse. Otherwise returntrue if there exists
a permutation of the elements in the range[first2,last2), bounded by[pfirst,plast), such that
ranges::equal(first1, last1, pfirst, plast, pred, proj1, proj2) returns true; otherwise,
returns false.
7 Complexity: No applications of the corresponding predicate and projections if
—(7.1) for the first overload,
—(7.1.1) S1 and I1 model sized_sentinel_for<S1, I1>,
—(7.1.2) S2 and I2 model sized_sentinel_for<S2, I2>, and
—(7.1.3) last1 - first1 != last2 - first2;
—(7.2) for the second overload,R1 and R2 each model sized_range, and ranges::distance(r1) !=
ranges::distance(r2).
Otherwise, exactly last1 - first1 applications of the corresponding predicate and projections if
ranges::equal(first1, last1, first2, last2, pred, proj1, proj2) would returntrue; other-
wise, at worstO(N2), whereN has the valuelast1 - first1.
§ 26.6.14 © ISO/IEC
1483

===== PAGE 1495 =====

Dxxxx
26.6.15 Search [alg.search]
template<class ForwardIterator1, class ForwardIterator2>
constexpr ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator1
search(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
constexpr ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
ForwardIterator1
search(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);
1 Returns: The first iteratoriin the range[first1,last1 - (last2 - first2)] such that for every non-
negative integern less thanlast2 - first2 the following corresponding conditions hold:*(i + n) ==
*(first2 + n), pred(*(i + n), *(first2 + n)) != false. Returns first1 if [first2,last2) is
empty, otherwise returnslast1 if no such iterator is found.
2 Complexity: At most (last1 - first1) * (last2 - first2) applications of the corresponding
predicate.
template<forward_iterator I1, sentinel_for<I1> S1, forward_iterator I2,
sentinel_for<I2> S2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr subrange<I1>
ranges::search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<forward_range R1, forward_range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr borrowed_subrange_t<R1>
ranges::search(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
subrange<I1>
ranges::search(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
borrowed_subrange_t<R1>
ranges::search(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
3 Returns:
—(3.1) {i, i + (last2 - first2)}, wherei is the first iterator in the range[first1,last1 - (last2
- first2)] such that for every non-negative integern less thanlast2 - first2 the condition
§ 26.6.15 © ISO/IEC
1484

===== PAGE 1496 =====

Dxxxx
bool(invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n))))
is true.
—(3.2) Returns {last1, last1} if no such iterator exists.
4 Complexity: At most (last1 - first1) * (last2 - first2) applications of the corresponding
predicate and projections.
template<class ForwardIterator, class Size, class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator
search_n(ForwardIterator first, ForwardIterator last,
Size count, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size,
class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator
search_n(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Size count, const T& value);
template<class ForwardIterator, class Size, class T = iterator_traits<ForwardIterator>::value_type,
class BinaryPredicate>
constexpr ForwardIterator
search_n(ForwardIterator first, ForwardIterator last,
Size count, const T& value,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Size,
class T = iterator_traits<ForwardIterator>::value_type,
class BinaryPredicate>
ForwardIterator
search_n(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Size count, const T& value,
BinaryPredicate pred);
5 Mandates: The typeSize is convertible to an integral type (7.3.9, 11.4.8).
6 Let E be pred(*(i + n), value) != false for the overloads with a parameterpred, and*(i + n)
== value otherwise.
7 Returns: The first iterator i in the range[first,last - count] such that for every non-negative
integer n less thancount the conditionE is true. Returns last if no such iterator is found.
8 Complexity: At mostlast - first applications of the corresponding predicate.
template<forward_iterator I, sentinel_for<I> S,
class Pred = ranges::equal_to, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirectly_comparable<I, const T*, Pred, Proj>
constexpr subrange<I>
ranges::search_n(I first, S last, iter_difference_t<I> count,
const T& value, Pred pred = {}, Proj proj = {});
template<forward_range R, class Pred = ranges::equal_to,
class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
constexpr borrowed_subrange_t<R>
ranges::search_n(R&& r, range_difference_t<R> count,
const T& value, Pred pred = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Pred = ranges::equal_to, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirectly_comparable<I, const T*, Pred, Proj>
subrange<I>
ranges::search_n(Ep&& exec, I first, S last, iter_difference_t<I> count,
const T& value, Pred pred = {}, Proj proj = {});
§ 26.6.15 © ISO/IEC
1485

===== PAGE 1497 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, class Pred = ranges::equal_to,
class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
borrowed_subrange_t<R>
ranges::search_n(Ep&& exec, R&& r, range_difference_t<R> count,
const T& value, Pred pred = {}, Proj proj = {});
9 Returns: {i, i + count} where i is the first iterator in the range [first,last - count] such
that for every non-negative integern less thancount, the following condition holds:invoke(pred,
invoke(proj, *(i + n)), value). Returns {last, last} if no such iterator is found.
10 Complexity: At mostlast - first applications of the corresponding predicate and projection.
template<class ForwardIterator, class Searcher>
constexpr ForwardIterator
search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);
11 Effects: Equivalent to:return searcher(first, last).first;
12 Remarks: Searcher need not meet theCpp17CopyConstructible requirements.
26.6.16 Starts with [alg.starts.with]
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool ranges::starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity,
class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool ranges::starts_with(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Returns:
ranges::mismatch(std::move(first1), last1, std::move(first2), last2,
pred, proj1, proj2).in2 == last2
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool ranges::starts_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1,
sized-random-access-range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool ranges::starts_with(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
2 Returns:
ranges::mismatch(std::forward<Ep>(exec), std::move(first1), last1, std::move(first2),
last2, pred, proj1, proj2).in2 == last2
26.6.17 Ends with [alg.ends.with]
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires (forward_iterator<I1> || sized_sentinel_for<S1, I1>) &&
(forward_iterator<I2> || sized_sentinel_for<S2, I2>) &&
indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
constexpr bool ranges::ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let N1 be last1 - first1 and N2 be last2 - first2.
2 Returns: false if N1 <N2, otherwise:
§ 26.6.17 © ISO/IEC
1486

===== PAGE 1498 =====

Dxxxx
ranges::equal(std::move(first1) + (N1 - N2), last1, std::move(first2), last2,
pred, proj1, proj2)
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
bool ranges::ends_with(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
3 Let N1 be last1 - first1 and N2 be last2 - first2.
4 Returns: false if N1 <N2, otherwise:
ranges::equal(std::forward<Ep>(exec), std::move(first1) + (N1 - N2), last1,
std::move(first2), last2, pred, proj1, proj2)
template<input_range R1, input_range R2, class Pred = ranges::equal_to, class Proj1 = identity,
class Proj2 = identity>
requires (forward_range<R1> || sized_range<R1>) &&
(forward_range<R2> || sized_range<R2>) &&
indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
constexpr bool ranges::ends_with(R1&& r1, R2&& r2, Pred pred = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
5 Let N1 be ranges::distance(r1) and N2 be ranges::distance(r2).
6 Returns: false if N1 <N2, otherwise:
ranges::equal(views::drop(ranges::ref_view(r1), N1 - static_cast<decltype(N1)>(N2)),
r2, pred, proj1, proj2)
template<execution-policy Ep, sized-random-access-range R1,
sized-random-access-range R2, class Pred = ranges::equal_to,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
bool ranges::ends_with(Ep&& exec, R1&& r1, R2&& r2,
Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
7 Let N1 be ranges::distance(r1) and N2 be ranges::distance(r2).
8 Returns: false if N1 <N2, otherwise:
ranges::equal(std::forward<Ep>(exec),
views::drop(ranges::ref_view(r1), N1 - static_cast<decltype(N1)>(N2)),
r2, pred, proj1, proj2)
26.6.18 Fold [alg.fold]
template<input_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
indirectly-binary-left-foldable <T, I> F>
constexpr auto ranges::fold_left(I first, S last, T init, F f);
template<input_range R, class T = range_value_t<R>,
indirectly-binary-left-foldable <T, iterator_t<R>> F>
constexpr auto ranges::fold_left(R&& r, T init, F f);
1 Returns:
ranges::fold_left_with_iter(std::move(first), last, std::move(init), f).value
template<input_iterator I, sentinel_for<I> S,
indirectly-binary-left-foldable <iter_value_t<I>, I> F>
requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
constexpr auto ranges::fold_left_first(I first, S last, F f);
template<input_range R, indirectly-binary-left-foldable <range_value_t<R>, iterator_t<R>> F>
requires constructible_from<range_value_t<R>, range_reference_t<R>>
constexpr auto ranges::fold_left_first(R&& r, F f);
2 Returns:
ranges::fold_left_first_with_iter(std::move(first), last, f).value
§ 26.6.18 © ISO/IEC
1487

===== PAGE 1499 =====

Dxxxx
template<bidirectional_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
indirectly-binary-right-foldable <T, I> F>
constexpr auto ranges::fold_right(I first, S last, T init, F f);
template<bidirectional_range R, class T = range_value_t<R>,
indirectly-binary-right-foldable <T, iterator_t<R>> F>
constexpr auto ranges::fold_right(R&& r, T init, F f);
3 Effects: Equivalent to:
using U = decay_t<invoke_result_t<F&, iter_reference_t<I>, T>>;
if (first == last)
return U(std::move(init));
I tail = ranges::next(first, last);
U accum = invoke(f, *--tail, std::move(init));
while (first != tail)
accum = invoke(f, *--tail, std::move(accum));
return accum;
template<bidirectional_iterator I, sentinel_for<I> S,
indirectly-binary-right-foldable <iter_value_t<I>, I> F>
requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
constexpr auto ranges::fold_right_last(I first, S last, F f);
template<bidirectional_range R,
indirectly-binary-right-foldable <range_value_t<R>, iterator_t<R>> F>
requires constructible_from<range_value_t<R>, range_reference_t<R>>
constexpr auto ranges::fold_right_last(R&& r, F f);
4 Let U be decltype(ranges::fold_right(first, last, iter_value_t<I>(*first), f)).
5 Effects: Equivalent to:
if (first == last)
return optional<U>();
I tail = ranges::prev(ranges::next(first, std::move(last)));
return optional<U>(in_place,
ranges::fold_right(std::move(first), tail, iter_value_t<I>(*tail), std::move(f)));
template<input_iterator I, sentinel_for<I> S, class T = iter_value_t<I>,
indirectly-binary-left-foldable <T, I> F>
constexpr see below ranges::fold_left_with_iter(I first, S last, T init, F f);
template<input_range R, class T = range_value_t<R>,
indirectly-binary-left-foldable <T, iterator_t<R>> F>
constexpr see below ranges::fold_left_with_iter(R&& r, T init, F f);
6 Let U be decay_t<invoke_result_t<F&, T, iter_reference_t<I>>>.
7 Effects: Equivalent to:
if (first == last)
return {std::move(first), U(std::move(init))};
U accum = invoke(f, std::move(init), *first);
for (++first; first != last; ++first)
accum = invoke(f, std::move(accum), *first);
return {std::move(first), std::move(accum)};
8 Remarks: The return type isfold_left_with_iter_result<I, U> for the first overload andfold_-
left_with_iter_result<borrowed_iterator_t<R>, U> for the second overload.
template<input_iterator I, sentinel_for<I> S,
indirectly-binary-left-foldable <iter_value_t<I>, I> F>
requires constructible_from<iter_value_t<I>, iter_reference_t<I>>
constexpr see below ranges::fold_left_first_with_iter(I first, S last, F f);
template<input_range R, indirectly-binary-left-foldable <range_value_t<R>, iterator_t<R>> F>
requires constructible_from<range_value_t<R>, range_reference_t<R>>
constexpr see below ranges::fold_left_first_with_iter(R&& r, F f);
9 Let U be
decltype(ranges::fold_left(std::move(first), last, iter_value_t<I>(*first), f))
10 Effects: Equivalent to:
§ 26.6.18 © ISO/IEC
1488

===== PAGE 1500 =====

Dxxxx
if (first == last)
return {std::move(first), optional<U>()};
optional<U> init(in_place, *first);
for (++first; first != last; ++first)
*init = invoke(f, std::move(*init), *first);
return {std::move(first), std::move(init)};
11 Remarks: The return type isfold_left_first_with_iter_result<I, optional<U>> for the first
overload and fold_left_first_with_iter_result<borrowed_iterator_t<R>, optional<U>> for
the second overload.
26.7 Mutating sequence operations [alg.modifying.operations]
26.7.1 Copy [alg.copy]
template<class InputIterator, class OutputIterator>
constexpr OutputIterator copy(InputIterator first, InputIterator last,
OutputIterator result);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr ranges::copy_result<I, O> ranges::copy(I first, S last, O result);
template<input_range R, weakly_incrementable O>
requires indirectly_copyable<iterator_t<R>, O>
constexpr ranges::copy_result<borrowed_iterator_t<R>, O> ranges::copy(R&& r, O result);
1 Let N be last - first.
2 Preconditions: result is not in the range[first,last).
3 Effects: Copies elements in the range[first,last) into the range[result,result + N) starting from
first and proceeding tolast. For each non-negative integern < N, performs *(result + n) =
*(first + n).
4 Returns:
—(4.1) result + N for the overload in namespacestd.
—(4.2) {last, result + N} for the overloads in namespaceranges.
5 Complexity: Exactly N assignments.
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2 copy(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
ranges::copy_result<I, O>
ranges::copy(Ep&& exec, I first, S last, O result, OutS result_last);
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
ranges::copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::copy(Ep&& exec, R&& r, OutR&& result_r);
6 Let result_last be result + (last - first) for the overload in namespacestd.
7 Let N be min(last - first, result_last - result).
8 Preconditions: The ranges[first,last) and [result,result + N) do not overlap.
9 Effects: Copies elements in the range[first,first + N) into the range[result,result + N). For
each non-negative integern<N , performs*(result + n) = *(first + n).
10 Returns:
—(10.1) result + N for the overload in namespacestd.
—(10.2) {first + N, result + N} for the overloads in namespaceranges.
11 Complexity: Exactly N assignments.
§ 26.7.1 © ISO/IEC
1489

===== PAGE 1501 =====

Dxxxx
template<class InputIterator, class Size, class OutputIterator>
constexpr OutputIterator copy_n(InputIterator first, Size n,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class Size, class ForwardIterator2>
ForwardIterator2 copy_n(ExecutionPolicy&& exec,
ForwardIterator1 first, Size n,
ForwardIterator2 result);
template<input_iterator I, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr ranges::copy_n_result<I, O>
ranges::copy_n(I first, iter_difference_t<I> n, O result);
template<execution-policy Ep, random_access_iterator I, random_access_iterator O,
sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
ranges::copy_n_result<I, O>
ranges::copy_n(Ep&& exec, I first, iter_difference_t<I> n, O result, OutS result_last);
12 Let M be max(0, n).
13 Let result_last be result + M for the overloads with no parameterresult_last.
14 Let N be min(result_last - result,M).
15 Mandates: The typeSize is convertible to an integral type (7.3.9, 11.4.8).
16 Effects: For each non-negative integeri<N , performs*(result + i) = *(first + i).
17 Returns:
—(17.1) result + N for the overloads in namespacestd.
—(17.2) {first + N, result + N} for the overload in namespaceranges.
18 Complexity: Exactly N assignments.
template<class InputIterator, class OutputIterator, class Predicate>
constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Predicate>
ForwardIterator2 copy_if(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, Predicate pred);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
constexpr ranges::copy_if_result<I, O>
ranges::copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O>
constexpr ranges::copy_if_result<borrowed_iterator_t<R>, O>
ranges::copy_if(R&& r, O result, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
ranges::copy_if_result<I, O>
ranges::copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
Pred pred, Proj proj = {});
§ 26.7.1 © ISO/IEC
1490

===== PAGE 1502 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
ranges::copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, Proj proj = {});
19 Let E(i) be:
—(19.1) bool(pred(*i)) for the overloads in namespacestd;
—(19.2) bool(invoke(pred, invoke(proj, *i))) for the overloads in namespaceranges.
20 Let:
—(20.1) M be the number of iteratorsi in the range[first,last) for which the conditionE(i) holds;
—(20.2) result_last be result + M for the overloads with no parameterresult_last or result_r;
—(20.3) N be min(M, result_last - result).
21 Preconditions: The ranges[first,last) and [result,result + N) do not overlap.
[Note 1: For the parallel algorithm overload in namespacestd, there can be a performance cost ifiterator_-
traits<ForwardIterator1>::value_type does not meet theCpp17MoveConstructible (Table 31) requirements.
For the parallel algorithm overloads in namespaceranges, there can be a performance cost ifiter_value_t<I>
does not modelmove_constructible. —end note]
22 Effects: Copies the firstN elements referred to by the iteratori in the range[first,last) for which
E(i) is true into the range[result,result + N).
23 Returns:
—(23.1) result + N for the overloads in namespacestd.
—(23.2) {last, result + N} for the overloads in namespaceranges, ifN is equal toM.
—(23.3) Otherwise, {j, result_last} for the overloads in namespaceranges, wherej is the iterator in
[first,last) for whichE(j) holds and there are exactlyN iterators i in [first,j) for which
E(i) holds.
24 Complexity: At mostlast - first applications of the corresponding predicate and any projection.
25 Remarks: Stable (16.4.6.8).
template<class BidirectionalIterator1, class BidirectionalIterator2>
constexpr BidirectionalIterator2
copy_backward(BidirectionalIterator1 first,
BidirectionalIterator1 last,
BidirectionalIterator2 result);
template<bidirectional_iterator I1, sentinel_for<I1> S1, bidirectional_iterator I2>
requires indirectly_copyable<I1, I2>
constexpr ranges::copy_backward_result<I1, I2>
ranges::copy_backward(I1 first, S1 last, I2 result);
template<bidirectional_range R, bidirectional_iterator I>
requires indirectly_copyable<iterator_t<R>, I>
constexpr ranges::copy_backward_result<borrowed_iterator_t<R>, I>
ranges::copy_backward(R&& r, I result);
26 Let N be last - first.
27 Preconditions: result is not in the range(first,last].
28 Effects: Copies elements in the range[first,last) into the range[result - N,result) starting from
last - 1 and proceeding tofirst.193 For each positive integern≤N, performs*(result - n) =
*(last - n).
29 Returns:
—(29.1) result - N for the overload in namespacestd.
—(29.2) {last, result - N} for the overloads in namespaceranges.
193) copy_backward can be used instead ofcopy when last is in the range[result - N, result).
§ 26.7.1 © ISO/IEC
1491

===== PAGE 1503 =====

Dxxxx
30 Complexity: Exactly N assignments.
26.7.2 Move [alg.move]
template<class InputIterator, class OutputIterator>
constexpr OutputIterator move(InputIterator first, InputIterator last,
OutputIterator result);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_movable<I, O>
constexpr ranges::move_result<I, O>
ranges::move(I first, S last, O result);
template<input_range R, weakly_incrementable O>
requires indirectly_movable<iterator_t<R>, O>
constexpr ranges::move_result<borrowed_iterator_t<R>, O>
ranges::move(R&& r, O result);
1 Let E(n) be
—(1.1) std::move(*(first + n)) for the overload in namespacestd;
—(1.2) ranges::iter_move(first + n) for the overloads in namespaceranges.
Let N be last - first.
2 Preconditions: result is not in the range[first,last).
3 Effects: Moves elements in the range[first,last) into the range[result,result + N) starting from
first and proceeding tolast. For each non-negative integern < N, performs *(result + n) =
E(n).
4 Returns:
—(4.1) result + N for the overload in namespacestd.
—(4.2) {last, result + N} for the overloads in namespaceranges.
5 Complexity: Exactly N assignments.
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2 move(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_movable<I, O>
ranges::move_result<I, O>
ranges::move(Ep&& exec, I first, S last, O result, OutS result_last);
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_movable<iterator_t<R>, iterator_t<OutR>>
ranges::move_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::move(Ep&& exec, R&& r, OutR&& result_r);
6 Let E(n) be:
—(6.1) std::move(*(first + n)) for the overload in namespacestd;
—(6.2) ranges::iter_move(first + n) for the overloads in namespaceranges.
7 Let result_last be result + (last - first) for the overloads in namespacestd.
8 Let N be min(last - first, result_last - result).
9 Preconditions: The ranges[first,last) and [result,result + N) do not overlap.
10 Effects: Moves elements in the range[first,first + N) into the range[result,result + N). For
each non-negative integern<N , performs*(result + n) = E(n).
11 Returns:
—(11.1) result + N for the overload in namespacestd.
—(11.2) {first + N, result + N} for the overloads in namespaceranges.
§ 26.7.2 © ISO/IEC
1492

===== PAGE 1504 =====

Dxxxx
12 Complexity: Exactly N assignments.
template<class BidirectionalIterator1, class BidirectionalIterator2>
constexpr BidirectionalIterator2
move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
BidirectionalIterator2 result);
template<bidirectional_iterator I1, sentinel_for<I1> S1, bidirectional_iterator I2>
requires indirectly_movable<I1, I2>
constexpr ranges::move_backward_result<I1, I2>
ranges::move_backward(I1 first, S1 last, I2 result);
template<bidirectional_range R, bidirectional_iterator I>
requires indirectly_movable<iterator_t<R>, I>
constexpr ranges::move_backward_result<borrowed_iterator_t<R>, I>
ranges::move_backward(R&& r, I result);
13 Let E(n) be
—(13.1) std::move(*(last - n)) for the overload in namespacestd;
—(13.2) ranges::iter_move(last - n) for the overloads in namespaceranges.
Let N be last - first.
14 Preconditions: result is not in the range(first,last].
15 Effects: Moves elements in the range[first,last) into the range[result - N,result) starting from
last - 1 and proceeding tofirst.194 For each positive integern≤N, performs*(result - n) =
E(n).
16 Returns:
—(16.1) result - N for the overload in namespacestd.
—(16.2) {last, result - N} for the overloads in namespaceranges.
17 Complexity: Exactly N assignments.
26.7.3 Swap [alg.swap]
template<class ForwardIterator1, class ForwardIterator2>
constexpr ForwardIterator2
swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
swap_ranges(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2>
requires indirectly_swappable<I1, I2>
constexpr ranges::swap_ranges_result<I1, I2>
ranges::swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
template<input_range R1, input_range R2>
requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
constexpr ranges::swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
ranges::swap_ranges(R1&& r1, R2&& r2);
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2>
requires indirectly_swappable<I1, I2>
ranges::swap_ranges_result<I1, I2>
ranges::swap_ranges(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2);
194) move_backward can be used instead ofmove when last is in the range[result - N, result).
§ 26.7.3 © ISO/IEC
1493

===== PAGE 1505 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2>
requires indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
ranges::swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
ranges::swap_ranges(Ep&& exec, R1&& r1, R2&& r2);
1 Let:
—(1.1) last2 be first2 + (last1 - first1) for the overloads in namespacestd with no parameter
named last2;
—(1.2) M be min(last1 - first1, last2 - first2).
2 Preconditions: The two ranges[first1,last1) and [first2,last2) do not overlap. For the overloads
in namespacestd, *(first1 + n) is swappable with (16.4.4.3)*(first2 + n).
3 Effects: For each non-negative integern<M performs:
—(3.1) swap(*(first1 + n), *(first2 + n)) for the overloads in namespacestd;
—(3.2) ranges::iter_swap(first1 + n, first2 + n) for the overloads in namespaceranges.
4 Returns:
—(4.1) last2 for the overloads in namespacestd.
—(4.2) {first1 + M, first2 + M} for the overloads in namespaceranges.
5 Complexity: Exactly M swaps.
template<class ForwardIterator1, class ForwardIterator2>
constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b);
6 Preconditions: a and b are dereferenceable. *a is swappable with (16.4.4.3)*b.
7 Effects: As if byswap(*a, *b).
26.7.4 Transform [alg.transform]
template<class InputIterator, class OutputIterator,
class UnaryOperation>
constexpr OutputIterator
transform(InputIterator first1, InputIterator last1,
OutputIterator result, UnaryOperation op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class UnaryOperation>
ForwardIterator2
transform(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 result, UnaryOperation op);
template<class InputIterator1, class InputIterator2,
class OutputIterator, class BinaryOperation>
constexpr OutputIterator
transform(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, OutputIterator result,
BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class BinaryOperation>
ForwardIterator
transform(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator result,
BinaryOperation binary_op);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
copy_constructible F, class Proj = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
constexpr ranges::unary_transform_result<I, O>
ranges::transform(I first1, S last1, O result, F op, Proj proj = {});
§ 26.7.4 © ISO/IEC
1494

===== PAGE 1506 =====

Dxxxx
template<input_range R, weakly_incrementable O, copy_constructible F,
class Proj = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
constexpr ranges::unary_transform_result<borrowed_iterator_t<R>, O>
ranges::transform(R&& r, O result, F op, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
copy_constructible F, class Proj = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
ranges::unary_transform_result<I, O>
ranges::transform(Ep&& exec, I first1, S last1, O result, OutS result_last,
F op, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
copy_constructible F, class Proj = identity>
requires indirectly_writable<iterator_t<OutR>,
indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
ranges::unary_transform_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::transform(Ep&& exec, R&& r, OutR&& result_r, F op, Proj proj = {});
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, copy_constructible F, class Proj1 = identity,
class Proj2 = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
projected<I2, Proj2>>>
constexpr ranges::binary_transform_result<I1, I2, O>
ranges::transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
copy_constructible F, class Proj1 = identity, class Proj2 = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>>
constexpr ranges::binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
ranges::transform(R1&& r1, R2&& r2, O result,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS,
copy_constructible F, class Proj1 = identity, class Proj2 = identity>
requires indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
projected<I2, Proj2>>>
ranges::binary_transform_result<I1, I2, O>
ranges::transform(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
O result, OutS result_last,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, copy_constructible F,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_writable<iterator_t<OutR>,
indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>>
ranges::binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
ranges::transform(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) last2be first2 + (last1 - first1)for the overloads in namespacestdwith parameterfirst2
but no parameterlast2;
—(1.2) M be last1 - first1 for unary transforms, or min(last1 - first1, last2 - first2) for
binary transforms;
—(1.3) result_last be result + M for the overloads with no parameterresult_last or result_r;
§ 26.7.4 © ISO/IEC
1495

===== PAGE 1507 =====

Dxxxx
—(1.4) N be min(M, result_last - result);
—(1.5) E(i) be
—(1.5.1) op(*(first1 + (i - result))) for unary transforms defined in namespacestd;
—(1.5.2) binary_op(*(first1 + (i - result)), *(first2 + (i - result))) for binary trans-
forms defined in namespacestd;
—(1.5.3) invoke(op, invoke(proj, *(first1 + (i - result)))) for unary transforms defined in
namespace ranges;
—(1.5.4) invoke(binary_op, invoke(proj1, *(first1 + (i - result))), invoke(proj2,
*(first2 + (i - result)))) for binary transforms defined in namespaceranges.
2 Preconditions: For parallel algorithm overloadsop and binary_op satisfy the requirements specified in
26.3.2. op and binary_op do not invalidate iterators or subranges, nor modify elements in the ranges
—(2.1) [first1,first1 + N],
—(2.2) [first2,first2 + N], and
—(2.3) [result,result + N].195
3 Effects: Assigns through every iteratori in the range[result,result + N) a new corresponding value
equal toE(i).
4 Returns:
—(4.1) result + N for the overloads defined in namespacestd.
—(4.2) {first1 + N, result + N} for unary transforms defined in namespaceranges.
—(4.3) {first1 + N, first2 + N, result + N} for binary transforms defined in namespaceranges.
5 Complexity: Exactly N applications ofop or binary_op, and any projections. This requirement also
applies to the parallel algorithm overloads.
6 Remarks: result may be equal tofirst1 or first2.
26.7.5 Replace [alg.replace]
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr void replace(ForwardIterator first, ForwardIterator last,
const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
void replace(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
const T& old_value, const T& new_value);
template<class ForwardIterator, class Predicate,
class T = iterator_traits<ForwardIterator>::value_type>
constexpr void replace_if(ForwardIterator first, ForwardIterator last,
Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator, class Predicate,
class T = iterator_traits<ForwardIterator>::value_type>
void replace_if(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Predicate pred, const T& new_value);
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<I>>
requires indirectly_writable<I, const T2&> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
constexpr I
ranges::replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
195) The use of fully closed ranges is intentional.
§ 26.7.5 © ISO/IEC
1496

===== PAGE 1508 =====

Dxxxx
template<input_range R, class Proj = identity,
class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = range_value_t<R>>
requires indirectly_writable<iterator_t<R>, const T2&> &&
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
constexpr borrowed_iterator_t<R>
ranges::replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<I>>
requires indirectly_writable<I, const T2&> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
I ranges::replace(Ep&& exec, I first, S last,
const T1& old_value, const T2& new_value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = range_value_t<R>>
requires indirectly_writable<iterator_t<R>, const T2&> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T1*>
borrowed_iterator_t<R>
ranges::replace(Ep&& exec, R&& r, const T1& old_value, const T2& new_value,
Proj proj = {});
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
class T = iter_value_t<I>,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_writable<I, const T&>
constexpr I ranges::replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
template<input_range R, class Proj = identity, class T = range_value_t<R>,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_writable<iterator_t<R>, const T&>
constexpr borrowed_iterator_t<R>
ranges::replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = iter_value_t<I>,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_writable<I, const T&>
I ranges::replace_if(Ep&& exec, I first, S last, Pred pred,
const T& new_value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = range_value_t<R>,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_writable<iterator_t<R>, const T&>
borrowed_iterator_t<R>
ranges::replace_if(Ep&& exec, R&& r, Pred pred, const T& new_value, Proj proj = {});
1 Let E(i) be
—(1.1) bool(*i == old_value) for replace;
—(1.2) bool(pred(*i)) for replace_if;
—(1.3) bool(invoke(proj, *i) == old_value) for ranges::replace;
—(1.4) bool(invoke(pred, invoke(proj, *i))) for ranges::replace_if.
2 Mandates: new_value is writable (24.3.1) tofirst.
3 Effects: Substitutes elements referred by the iteratori in the range[first,last) with new_value,
when E(i) is true.
4 Returns: last for the overloads in namespaceranges.
5 Complexity: Exactly last - first applications of the corresponding predicate and any projection.
§ 26.7.5 © ISO/IEC
1497

===== PAGE 1509 =====

Dxxxx
template<class InputIterator, class OutputIterator, class T>
constexpr OutputIterator
replace_copy(InputIterator first, InputIterator last,
OutputIterator result,
const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
ForwardIterator2
replace_copy(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result,
const T& old_value, const T& new_value);
template<class InputIterator, class OutputIterator, class Predicate, class T>
constexpr OutputIterator
replace_copy_if(InputIterator first, InputIterator last,
OutputIterator result,
Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Predicate, class T>
ForwardIterator2
replace_copy_if(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result,
Predicate pred, const T& new_value);
template<input_iterator I, sentinel_for<I> S, class O,
class Proj = identity, class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
output_iterator<O, const T2&>
constexpr ranges::replace_copy_result<I, O>
ranges::replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
Proj proj = {});
template<input_range R, class O, class Proj = identity,
class T1 = projected_value_t<iterator_t<R>, Proj>, class T2 = iter_value_t<O>>
requires indirectly_copyable<iterator_t<R>, O> &&
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T1*>
&& output_iterator<O, const T2&>
constexpr ranges::replace_copy_result<borrowed_iterator_t<R>, O>
ranges::replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity,
class T1 = projected_value_t<I, Proj>, class T2 = iter_value_t<O>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*> &&
indirectly_writable<O, const T2&>
ranges::replace_copy_result<I, O>
ranges::replace_copy(Ep&& exec, I first, S last, O result, OutS result_last,
const T1& old_value, const T2& new_value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity, class T1 = projected_value_t<iterator_t<R>, Proj>,
class T2 = range_value_t<OutR>>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T1*> &&
indirectly_writable<iterator_t<OutR>, const T2&>
ranges::replace_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::replace_copy(Ep&& exec, R&& r, OutR&& result_r, const T1& old_value,
const T2& new_value, Proj proj = {});
§ 26.7.5 © ISO/IEC
1498

===== PAGE 1510 =====

Dxxxx
template<input_iterator I, sentinel_for<I> S,class O, class T = iter_value_t<O>,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O> && output_iterator<O, const T&>
constexpr ranges::replace_copy_if_result<I, O>
ranges::replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
Proj proj = {});
template<input_range R, class O, class T = iter_value_t<O>, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O> && output_iterator<O, const T&>
constexpr ranges::replace_copy_if_result<borrowed_iterator_t<R>, O>
ranges::replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS, class T = iter_value_t<O>,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O> && indirectly_writable<O, const T&>
ranges::replace_copy_if_result<I, O>
ranges::replace_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
Pred pred, const T& new_value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class T = range_value_t<OutR>, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
indirectly_writable<OutR, const T&>
ranges::replace_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::replace_copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, const T& new_value,
Proj proj = {});
6 Let E(i) be
—(6.1) bool(*(first + (i - result)) == old_value) for replace_copy;
—(6.2) bool(pred(*(first + (i - result)))) for replace_copy_if;
—(6.3) bool(invoke(proj, *(first + (i - result))) == old_value) for ranges::replace_copy;
—(6.4) bool(invoke(pred, invoke(proj, *(first + (i - result))))) for ranges::replace_-
copy_if.
7 Let:
—(7.1) result_last be result + (last - first) for the overloads with no parameterresult_last
or result_r;
—(7.2) N be min(last - first, result_last - result).
8 Mandates: The results of the expressions*first and new_value are writable (24.3.1) toresult.
9 Preconditions: The ranges[first,last) and [result,result + N) do not overlap.
10 Effects: Assigns through every iteratori in the range[result,result + N) a new corresponding value
—(10.1) new_value if E(i) is true or
—(10.2) *(first + (i - result)) otherwise.
11 Returns:
—(11.1) result + N for the overloads in namespacestd.
—(11.2) {first + N, result + N} for the overloads in namespaceranges.
12 Complexity: Exactly N applications of the corresponding predicate and any projection.
26.7.6 Fill [alg.fill]
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
void fill(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, const T& value);
§ 26.7.6 © ISO/IEC
1499

===== PAGE 1511 =====

Dxxxx
template<class OutputIterator, class Size, class T = iterator_traits<OutputIterator>::value_type>
constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size,
class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator fill_n(ExecutionPolicy&& exec,
ForwardIterator first, Size n, const T& value);
template<class O, sentinel_for<O> S, class T = iter_value_t<O>>
requires output_iterator<O, const T&>
constexpr O ranges::fill(O first, S last, const T& value);
template<class R, class T = range_value_t<R>>
requires output_range<R, const T&>
constexpr borrowed_iterator_t<R> ranges::fill(R&& r, const T& value);
template<class O, class T = iter_value_t<O>>
requires output_iterator<O, const T&>
constexpr O ranges::fill_n(O first, iter_difference_t<O> n, const T& value);
template<execution-policy Ep, random_access_iterator O, sized_sentinel_for<O> S,
class T = iter_value_t<O>>
requires indirectly_writable<O, const T&>
O ranges::fill(Ep&& exec, O first, S last, const T& value);
template<execution-policy Ep, sized-random-access-range R, class T = range_value_t<R>>
requires indirectly_writable<iterator_t<R>, const T&>
borrowed_iterator_t<R> fill(Ep&& exec, R&& r, const T& value);
template<execution-policy Ep, random_access_iterator O, class T = iter_value_t<O>>
requires indirectly_writable<O, const T&>
O ranges::fill_n(Ep&& exec, O first, iter_difference_t<O> n, const T& value);
1 Let N be max(0,n) for thefill_n algorithms, andlast - first for thefill algorithms.
2 Mandates: The expressionvalue is writable (24.3.1) to the output iterator. The typeSize is convertible
to an integral type (7.3.9, 11.4.8).
3 Effects: Assigns value through all the iterators in the range[first,first + N).
4 Returns: first + N.
5 Complexity: Exactly N assignments.
26.7.7 Generate [alg.generate]
template<class ForwardIterator, class Generator>
constexpr void generate(ForwardIterator first, ForwardIterator last,
Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Generator>
void generate(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Generator gen);
template<class OutputIterator, class Size, class Generator>
constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
ForwardIterator generate_n(ExecutionPolicy&& exec,
ForwardIterator first, Size n, Generator gen);
template<input_or_output_iterator O, sentinel_for<O> S, copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
constexpr O ranges::generate(O first, S last, F gen);
template<class R, copy_constructible F>
requires invocable<F&> && output_range<R, invoke_result_t<F&>>
constexpr borrowed_iterator_t<R> ranges::generate(R&& r, F gen);
template<input_or_output_iterator O, copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
constexpr O ranges::generate_n(O first, iter_difference_t<O> n, F gen);
§ 26.7.7 © ISO/IEC
1500

===== PAGE 1512 =====

Dxxxx
template<execution-policy Ep, random_access_iterator O, sized_sentinel_for<O> S,
copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
O ranges::generate(Ep&& exec, O first, S last, F gen);
template<execution-policy Ep, sized-random-access-range R, copy_constructible F>
requires invocable<F&> && indirectly_writable<iterator_t<R>, invoke_result_t<F&>>
borrowed_iterator_t<R> ranges::generate(Ep&& exec, R&& r, F gen);
template<execution-policy Ep, random_access_iterator O, copy_constructible F>
requires invocable<F&> && indirectly_writable<O, invoke_result_t<F&>>
O ranges::generate_n(Ep&& exec, O first, iter_difference_t<O> n, F gen);
1 Let N be max(0,n) for thegenerate_n algorithms, andlast - first for thegenerate algorithms.
2 Mandates: Size is convertible to an integral type (7.3.9, 11.4.8).
3 Effects: Assigns the result of successive evaluations of gen() through each iterator in the range
[first,first + N).
4 Returns: first + N.
5 Complexity: Exactly N evaluations ofgen() and assignments.
6 Remarks: gen may modify objects via its arguments for parallel algorithm overloads (26.3.2).
26.7.8 Remove [alg.remove]
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ExecutionPolicy, class ForwardIterator,
class T = iterator_traits<ForwardIterator>::value_type>
ForwardIterator remove(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class Predicate>
constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator remove_if(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Predicate pred);
template<permutable I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>>
requires indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr subrange<I> ranges::remove(I first, S last, const T& value, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires permutable<iterator_t<R>> &&
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr borrowed_subrange_t<R>
ranges::remove(R&& r, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires permutable<I> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
subrange<I>
ranges::remove(Ep&& exec, I first, S last, const T& value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires permutable<iterator_t<R>> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
borrowed_subrange_t<R>
ranges::remove(Ep&& exec, R&& r, const T& value, Proj proj = {});
§ 26.7.8 © ISO/IEC
1501

===== PAGE 1513 =====

Dxxxx
template<permutable I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I> ranges::remove_if(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R>
ranges::remove_if(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
subrange<I>
ranges::remove_if(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
ranges::remove_if(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let E be
—(1.1) bool(*i == value) for remove;
—(1.2) bool(pred(*i)) for remove_if;
—(1.3) bool(invoke(proj, *i) == value) for ranges::remove;
—(1.4) bool(invoke(pred, invoke(proj, *i))) for ranges::remove_if.
2 Preconditions: For the algorithms in namespacestd, the type of*firstmeets theCpp17MoveAssignable
requirements (Table 33).
3 Effects: Eliminates all the elements referred to by iteratori in the range[first,last) for whichE
holds.
4 Returns: Let j be the end of the resulting range. Returns:
—(4.1) j for the overloads in namespacestd.
—(4.2) {j, last} for the overloads in namespaceranges.
5 Complexity: Exactly last - first applications of the corresponding predicate and any projection.
6 Remarks: Stable (16.4.6.8).
7 [Note 1: Each element in the range[ret,last), whereret is the returned value, has a valid but unspecified
state, because the algorithms can eliminate elements by moving from elements that were originally in that
range. —end note]
template<class InputIterator, class OutputIterator,
class T = iterator_traits<InputIterator>::value_type>
constexpr OutputIterator
remove_copy(InputIterator first, InputIterator last,
OutputIterator result, const T& value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class T = iterator_traits<ForwardIterator1>::value_type>
ForwardIterator2
remove_copy(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, const T& value);
template<class InputIterator, class OutputIterator, class Predicate>
constexpr OutputIterator
remove_copy_if(InputIterator first, InputIterator last,
OutputIterator result, Predicate pred);
§ 26.7.8 © ISO/IEC
1502

===== PAGE 1514 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Predicate>
ForwardIterator2
remove_copy_if(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, Predicate pred);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
constexpr ranges::remove_copy_result<I, O>
ranges::remove_copy(I first, S last, O result, const T& value, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>>
requires indirectly_copyable<iterator_t<R>, O> &&
indirect_binary_predicate<ranges::equal_to, projected<iterator_t<R>, Proj>, const T*>
constexpr ranges::remove_copy_result<borrowed_iterator_t<R>, O>
ranges::remove_copy(R&& r, O result, const T& value, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity, class T = projected_value_t<I, Proj>>
requires indirectly_copyable<I, O> &&
indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
ranges::remove_copy_result<I, O>
ranges::remove_copy(Ep&& exec, I first, S last, O result, OutS result_last,
const T& value, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity, class T = projected_value_t<iterator_t<R>, Proj>>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>> &&
indirect_binary_predicate<ranges::equal_to,
projected<iterator_t<R>, Proj>, const T*>
ranges::remove_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::remove_copy(Ep&& exec, R&& r, OutR&& result_r, const T& value, Proj proj = {});
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
constexpr ranges::remove_copy_if_result<I, O>
ranges::remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O>
constexpr ranges::remove_copy_if_result<borrowed_iterator_t<R>, O>
ranges::remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O>
ranges::remove_copy_if_result<I, O>
ranges::remove_copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
ranges::remove_copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::remove_copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, Proj proj = {});
8 Let E(i) be
—(8.1) bool(*i == value) for remove_copy;
§ 26.7.8 © ISO/IEC
1503

===== PAGE 1515 =====

Dxxxx
—(8.2) bool(pred(*i)) for remove_copy_if;
—(8.3) bool(invoke(proj, *i) == value) for ranges::remove_copy;
—(8.4) bool(invoke(pred, invoke(proj, *i))) for ranges::remove_copy_if.
9 Let:
—(9.1) M be the number of iteratorsi in [first,last) for whichE(i) is false;
—(9.2) result_last be result + M for the overloads with no parameterresult_last or result_r;
—(9.3) N be min(M, result_last - result).
10 Mandates: *first is writable (24.3.1) toresult.
11 Preconditions: The ranges[first,last) and [result,result + N) do not overlap.
[Note 2: For the parallel algorithm overloads in namespacestd, there can be a performance cost ifiterator_-
traits<ForwardIterator1>::value_type does not meet theCpp17MoveConstructible (Table 31) requirements.
For the parallel algorithm overloads in namespaceranges, there can be a performance cost ifiter_value_t<I>
does not modelmove_constructible. —end note]
12 Effects: Copies the firstN elements referred to by the iteratori in the range[first,last) for which
E(i) is false into the range[result,result + N).
13 Returns:
—(13.1) result + N, for the algorithms in namespacestd.
—(13.2) {last, result + N}, for the algorithms in namespaceranges, ifN is equal toM.
—(13.3) Otherwise, {j, result_last}, for the algorithms in namespaceranges, wherej is the iterator in
[first,last) for whichE(j) is false and there are exactlyN iterators i in [first,j) for which
E(i) is false.
14 Complexity: At mostlast - first applications of the corresponding predicate and any projection.
15 Remarks: Stable (16.4.6.8).
26.7.9 Unique [alg.unique]
template<class ForwardIterator>
constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator unique(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class BinaryPredicate>
constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
ForwardIterator unique(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
BinaryPredicate pred);
template<permutable I, sentinel_for<I> S, class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
constexpr subrange<I> ranges::unique(I first, S last, C comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R>
ranges::unique(R&& r, C comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
requires permutable<I>
subrange<I> ranges::unique(Ep&& exec, I first, S last, C comp = {}, Proj proj = {});
§ 26.7.9 © ISO/IEC
1504

===== PAGE 1516 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R> ranges::unique(Ep&& exec, R&& r, C comp = {}, Proj proj = {});
1 Let pred be equal_to{} for the overloads with no parameterpred, and letE(i) be
—(1.1) false if i is equal tofirst; otherwise
—(1.2) bool(pred(*(i - 1), *i)) for the overloads in namespacestd;
—(1.3) bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i))) for the overloads in
namespace ranges.
2 Preconditions: For the overloads in namespacestd, pred is an equivalence relation and the type of
*first meets theCpp17MoveAssignable requirements (Table 33).
3 Effects: Eliminates all elements referred to by the iteratori in the range[first,last) for whichE(i)
is true.
4 Returns: Let j be the end of the resulting range. Returns:
—(4.1) j for the overloads in namespacestd.
—(4.2) {j, last} for the overloads in namespaceranges.
5 Complexity: For nonempty ranges, exactly(last - first) - 1 applications of the corresponding
predicate and no more than twice as many applications of any projection.
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
unique_copy(InputIterator first, InputIterator last,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
unique_copy(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
template<class InputIterator, class OutputIterator,
class BinaryPredicate>
constexpr OutputIterator
unique_copy(InputIterator first, InputIterator last,
OutputIterator result, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryPredicate>
ForwardIterator2
unique_copy(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryPredicate pred);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
requires indirectly_copyable<I, O> &&
(forward_iterator<I> ||
(input_iterator<O> && same_as<iter_value_t<I>, iter_value_t<O>>) ||
indirectly_copyable_storable<I, O>)
constexpr ranges::unique_copy_result<I, O>
ranges::unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
template<input_range R, weakly_incrementable O, class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires indirectly_copyable<iterator_t<R>, O> &&
(forward_iterator<iterator_t<R>> ||
(input_iterator<O> && same_as<range_value_t<R>, iter_value_t<O>>) ||
indirectly_copyable_storable<iterator_t<R>, O>)
constexpr ranges::unique_copy_result<borrowed_iterator_t<R>, O>
ranges::unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
§ 26.7.9 © ISO/IEC
1505

===== PAGE 1517 =====

Dxxxx
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS, class Proj = identity,
indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
requires indirectly_copyable<I, O>
ranges::unique_copy_result<I, O>
ranges::unique_copy(Ep&& exec, I first, S last, O result, OutS result_last,
C comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR,
class Proj = identity,
indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
ranges::unique_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::unique_copy(Ep&& exec, R&& r, OutR&& result_r, C comp = {}, Proj proj = {});
6 Let pred be equal_to{} for the overloads in namespacestd with no parameterpred, and letE(i) be
—(6.1) false if i is equal tofirst; otherwise
—(6.2) bool(pred(*(i - 1), *i)) for the overloads in namespacestd;
—(6.3) bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i))) for the overloads in
namespace ranges.
7 Let:
—(7.1) M be the number of iteratorsi in the range[first,last) for whichE(i) is false;
—(7.2) result_last be result + M for the overloads with no parameterresult_last or result_r;
—(7.3) N be min(M, result_last - result).
8 Mandates: *first is writable (24.3.1) toresult.
9 Preconditions:
—(9.1) The ranges[first,last) and [result,result + N) do not overlap.
—(9.2) For the overloads in namespacestd:
—(9.2.1) The comparison function is an equivalence relation.
—(9.2.2) For the overloads with noExecutionPolicy, letT be the value type ofInputIterator. If
InputIterator models forward_iterator (24.3.4.11), then there are no additional require-
ments forT. Otherwise, ifOutputIteratormeets theCpp17ForwardIteratorrequirements and
its value type is the same asT, thenT meets theCpp17CopyAssignable (Table 34) requirements.
Otherwise, T meets both theCpp17CopyConstructible (Table 32) andCpp17CopyAssignable
requirements.
[Note 1: For the parallel algorithm overloads in namespacestd, there can be a performance cost if the value type
of ForwardIterator1 does not meet both theCpp17CopyConstructible and Cpp17CopyAssignable requirements.
For the parallel algorithm overloads in namespaceranges, there can be a performance cost ifiter_value_t<I>
does not modelcopyable. —end note]
10 Effects: Copies only the firstN elements referred to by the iteratori in the range[first,last) for
which E(i) is false into the range[result,result + N).
11 Returns:
—(11.1) result + N for the overloads in namespacestd.
—(11.2) {last, result + N} for the overloads in namespaceranges, ifN is equal toM.
—(11.3) Otherwise, {j, result_last} for the overloads in namespaceranges, wherej is the iterator in
[first,last) for whichE(j) is false and there are exactlyN iterators i in [first,j) for which
E(i) is false.
12 Complexity: At mostlast - first - 1 applications of the corresponding predicate and no more than
twice as many applications of any projection.
26.7.10 Reverse [alg.reverse]
template<class BidirectionalIterator>
constexpr void reverse(BidirectionalIterator first, BidirectionalIterator last);
§ 26.7.10 © ISO/IEC
1506

===== PAGE 1518 =====

Dxxxx
template<class ExecutionPolicy, class BidirectionalIterator>
void reverse(ExecutionPolicy&& exec,
BidirectionalIterator first, BidirectionalIterator last);
template<bidirectional_iterator I, sentinel_for<I> S>
requires permutable<I>
constexpr I ranges::reverse(I first, S last);
template<bidirectional_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_iterator_t<R> ranges::reverse(R&& r);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
I ranges::reverse(Ep&& exec, I first, S last);
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_iterator_t<R> ranges::reverse(Ep&& exec, R&& r);
1 Preconditions: For the overloads in namespacestd, BidirectionalIterator meets theCpp17Value-
Swappable requirements (16.4.4.3).
2 Effects: For each non-negative integeri < (last - first) / 2, appliesstd::iter_swap, orranges::
iter_swap for the overloads in namespaceranges, to all pairs of iteratorsfirst + i, (last - i) -
1.
3 Returns: last for the overloads in namespaceranges.
4 Complexity: Exactly (last - first)/2 swaps.
template<class BidirectionalIterator, class OutputIterator>
constexpr OutputIterator
reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
OutputIterator result);
template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
ForwardIterator
reverse_copy(ExecutionPolicy&& exec,
BidirectionalIterator first, BidirectionalIterator last,
ForwardIterator result);
template<bidirectional_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr ranges::reverse_copy_result<I, O>
ranges::reverse_copy(I first, S last, O result);
template<bidirectional_range R, weakly_incrementable O>
requires indirectly_copyable<iterator_t<R>, O>
constexpr ranges::reverse_copy_result<borrowed_iterator_t<R>, O>
ranges::reverse_copy(R&& r, O result);
5 Let N be last - first.
6 Preconditions: The ranges[first,last) and [result,result + N) do not overlap.
7 Effects: Copies the range[first,last) to the range[result,result + N) such that for every non-
negative integeri < N the following assignment takes place:*(result + N - 1 - i) = *(first +
i).
8 Returns:
—(8.1) result + N for the overloads in namespacestd.
—(8.2) {last, result + N} for the overloads in namespaceranges.
9 Complexity: Exactly N assignments.
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
ranges::reverse_copy_truncated_result<I, O>
ranges::reverse_copy(Ep&& exec, I first, S last, O result,
§ 26.7.10 © ISO/IEC
1507

===== PAGE 1519 =====

Dxxxx
OutS result_last);
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
ranges::reverse_copy_truncated_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::reverse_copy(Ep&& exec, R&& r, OutR&& result_r);
10 Let N be min(last - first, result_last - result), and let NEW_FIRST be first + (last -
first) - N.
11 Preconditions: The ranges[first,last) and [result,result + N) do not overlap.
12 Effects: Copies the range[NEW_FIRST ,last) to the range[result,result + N) such that for every
non-negative integeri<N the following assignment takes place:*(result + N - 1 - i) = *(NEW_-
FIRST + i).
13 Returns: {last, NEW_FIRST , result + N}.
14 Complexity: Exactly N assignments.
26.7.11 Rotate [alg.rotate]
template<class ForwardIterator>
constexpr ForwardIterator
rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
rotate(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator middle, ForwardIterator last);
template<permutable I, sentinel_for<I> S>
constexpr subrange<I> ranges::rotate(I first, I middle, S last);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
subrange<I> ranges::rotate(Ep&& exec, I first, I middle, S last);
1 Preconditions: [first,middle) and [middle,last) are valid ranges. For the overloads in namespace
std, ForwardIteratormeets theCpp17ValueSwappablerequirements (16.4.4.3), and the type of*first
meets theCpp17MoveConstructible (Table 31) andCpp17MoveAssignable (Table 33) requirements.
2 Effects: For each non-negative integeri < (last - first), places the element from the position
first + i into positionfirst + (i + (last - middle)) % (last - first).
[Note 1: This is a left rotate.—end note]
3 Returns:
—(3.1) first + (last - middle) for the overloads in namespacestd.
—(3.2) {first + (last - middle), last} for the overload in namespaceranges.
4 Complexity: At mostlast - first swaps.
template<forward_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> ranges::rotate(R&& r, iterator_t<R> middle);
5 Effects: Equivalent to:return ranges::rotate(ranges::begin(r), middle, ranges::end(r));
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R> ranges::rotate(Ep&& exec, R&& r, iterator_t<R> middle);
6 Effects: Equivalent to:
return ranges::rotate(std::forward<Ep>(exec), ranges::begin(r), middle,
ranges::begin(r) + ranges::distance(r));
template<class ForwardIterator, class OutputIterator>
constexpr OutputIterator
rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last,
OutputIterator result);
§ 26.7.11 © ISO/IEC
1508

===== PAGE 1520 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
rotate_copy(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 middle, ForwardIterator1 last,
ForwardIterator2 result);
template<forward_iterator I, sentinel_for<I> S, weakly_incrementable O>
requires indirectly_copyable<I, O>
constexpr ranges::rotate_copy_result<I, O>
ranges::rotate_copy(I first, I middle, S last, O result);
7 Let N be last - first.
8 Preconditions: [first,middle) and [middle,last) are valid ranges. The ranges[first,last) and
[result,result + N) do not overlap.
9 Effects: Copies the range[first,last) to the range[result,result + N) such that for each non-
negative integer i < N the following assignment takes place: *(result + i) = *(first + (i +
(middle - first)) % N).
10 Returns:
—(10.1) result + N for the overloads in namespacestd.
—(10.2) {last, result + N} for the overload in namespaceranges.
11 Complexity: Exactly N assignments.
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O, sized_sentinel_for<O> OutS>
requires indirectly_copyable<I, O>
ranges::rotate_copy_truncated_result<I, O>
ranges::rotate_copy(Ep&& exec, I first, I middle, S last, O result, OutS result_last);
12 Let M be last - first and N be min(M, result_last - result).
13 Preconditions: [first,middle) and [middle,last) are valid ranges. The ranges[first,last) and
[result,result + N) do not overlap.
14 Effects: Copies the range[first,last) to the range[result,result + N) such that for each non-
negative integer i < N the following assignment takes place: *(result + i) = *(first + (i +
(middle - first)) % M).
15 Returns:
—(15.1) {middle + N, first, result + N} if N is less thanlast - middle.
—(15.2) Otherwise, {last, first + (N + (middle - first)) % M, result + N}.
16 Complexity: Exactly N assignments.
template<forward_range R, weakly_incrementable O>
requires indirectly_copyable<iterator_t<R>, O>
constexpr ranges::rotate_copy_result<borrowed_iterator_t<R>, O>
ranges::rotate_copy(R&& r, iterator_t<R> middle, O result);
17 Effects: Equivalent to:
return ranges::rotate_copy(ranges::begin(r), middle, ranges::end(r), std::move(result));
template<execution-policy Ep, sized-random-access-range R, sized-random-access-range OutR>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
ranges::rotate_copy_truncated_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
ranges::rotate_copy(Ep&& exec, R&& r, iterator_t<R> middle, OutR&& result_r);
18 Effects: Equivalent to:
return ranges::rotate_copy(std::forward<Ep>(exec), ranges::begin(r), middle,
ranges::begin(r) + ranges::distance(r),
ranges::begin(result_r),
ranges::begin(result_r) + ranges::distance(result_r));
§ 26.7.11 © ISO/IEC
1509

===== PAGE 1521 =====

Dxxxx
26.7.12 Sample [alg.random.sample]
template<class PopulationIterator, class SampleIterator,
class Distance, class UniformRandomBitGenerator>
SampleIterator sample(PopulationIterator first, PopulationIterator last,
SampleIterator out, Distance n,
UniformRandomBitGenerator&& g);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O, class Gen>
requires (forward_iterator<I> || random_access_iterator<O>) &&
indirectly_copyable<I, O> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
O ranges::sample(I first, S last, O out, iter_difference_t<I> n, Gen&& g);
template<input_range R, weakly_incrementable O, class Gen>
requires (forward_range<R> || random_access_iterator<O>) &&
indirectly_copyable<iterator_t<R>, O> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
O ranges::sample(R&& r, O out, range_difference_t<R> n, Gen&& g);
1 Mandates: For the overload in namespacestd, Distance is an integer type and*first is writable
(24.3.1) toout.
2 Preconditions: out is not in the range[first,last). For the overload in namespacestd:
—(2.1) PopulationIterator meets theCpp17InputIterator requirements (24.3.5.3).
—(2.2) SampleIterator meets theCpp17OutputIterator requirements (24.3.5.4).
—(2.3) SampleIterator meets theCpp17RandomAccessIteratorrequirements (24.3.5.7) unlessPopulat-
ionIterator models forward_iterator (24.3.4.11).
—(2.4) remove_reference_t<UniformRandomBitGenerator> meets the requirements of a uniform ran-
dom bit generator type (29.5.3.3).
3 Effects: Copies min(last - first, n) elements (thesample) from[first,last) (the population) to
out such that each possible sample has equal probability of appearance.
[Note 1: Algorithms that obtain such effects includeselection samplingand reservoir sampling. —end note]
4 Returns: The end of the resulting sample range.
5 Complexity: O(last - first).
6 Remarks:
—(6.1) For the overload in namespacestd, stable if and only ifPopulationIterator models forward_-
iterator. For the first overload in namespaceranges, stable if and only ifI models forward_-
iterator.
—(6.2) To the extent that the implementation of this function makes use of random numbers, the object
g serves as the implementation’s source of randomness.
26.7.13 Shuffle [alg.random.shuffle]
template<class RandomAccessIterator, class UniformRandomBitGenerator>
void shuffle(RandomAccessIterator first,
RandomAccessIterator last,
UniformRandomBitGenerator&& g);
template<random_access_iterator I, sentinel_for<I> S, class Gen>
requires permutable<I> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
I ranges::shuffle(I first, S last, Gen&& g);
template<random_access_range R, class Gen>
requires permutable<iterator_t<R>> &&
uniform_random_bit_generator<remove_reference_t<Gen>>
borrowed_iterator_t<R> ranges::shuffle(R&& r, Gen&& g);
1 Preconditions: For the overload in namespacestd:
—(1.1) RandomAccessIterator meets theCpp17ValueSwappablerequirements (16.4.4.3).
§ 26.7.13 © ISO/IEC
1510

===== PAGE 1522 =====

Dxxxx
—(1.2) The type remove_reference_t<UniformRandomBitGenerator> meets the uniform random bit
generator (29.5.3.3) requirements.
2 Effects: Permutes the elements in the range[first,last) such that each possible permutation of those
elements has equal probability of appearance.
3 Returns: last for the overloads in namespaceranges.
4 Complexity: Exactly (last - first) - 1 swaps.
5 Remarks: To the extent that the implementation of this function makes use of random numbers, the
object referenced byg shall serve as the implementation’s source of randomness.
26.7.14 Shift [alg.shift]
template<class ForwardIterator>
constexpr ForwardIterator
shift_left(ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
shift_left(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
template<permutable I, sentinel_for<I> S>
constexpr subrange<I> ranges::shift_left(I first, S last, iter_difference_t<I> n);
template<forward_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> ranges::shift_left(R&& r, range_difference_t<R> n);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
subrange<I>
ranges::shift_left(Ep&& exec, I first, S last, iter_difference_t<I> n);
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
ranges::shift_left(Ep&& exec, R&& r, range_difference_t<R> n);
1 Preconditions: n >= 0 is true. For the overloads in namespacestd, the type of*first meets the
Cpp17MoveAssignable requirements.
2 Effects: If n == 0 or n >= last - first, does nothing. Otherwise, moves the element from position
first + n + i into positionfirst + i for each non-negative integeri < (last - first) - n. For
the non-parallel algorithm overloads, does so in order starting fromi = 0 and proceeding toi = (last
- first) - n - 1.
3 Returns: Let NEW_LAST be first + (last - first - n) if n < last - first, otherwise first.
Returns:
—(3.1) NEW_LAST for the overloads in namespacestd.
—(3.2) {first, NEW_LAST } for the overloads in namespaceranges.
4 Complexity: At most(last - first) - n assignments.
template<class ForwardIterator>
constexpr ForwardIterator
shift_right(ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
shift_right(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
typename iterator_traits<ForwardIterator>::difference_type n);
template<permutable I, sentinel_for<I> S>
constexpr subrange<I> ranges::shift_right(I first, S last, iter_difference_t<I> n);
§ 26.7.14 © ISO/IEC
1511

===== PAGE 1523 =====

Dxxxx
template<forward_range R>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> ranges::shift_right(R&& r, range_difference_t<R> n);
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S>
requires permutable<I>
subrange<I>
ranges::shift_right(Ep&& exec, I first, S last, iter_difference_t<I> n);
template<execution-policy Ep, sized-random-access-range R>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
ranges::shift_right(Ep&& exec, R&& r, range_difference_t<R> n);
5 Preconditions: n >= 0 is true. For the overloads in namespace std, the type of *first meets
the Cpp17MoveAssignable requirements, andForwardIterator meets theCpp17BidirectionalIterator
requirements (24.3.5.6) or theCpp17ValueSwappablerequirements.
6 Effects: If n == 0 or n >= last - first, does nothing. Otherwise, moves the element from position
first + iinto positionfirst + n + ifor each non-negative integeri < (last - first) - n. Does
so in order starting fromi = (last - first) - n - 1 and proceeding toi = 0 if
—(6.1) for the non-parallel algorithm overload in namespacestd, ForwardIterator meets theCpp17Bi-
directionalIterator requirements,
—(6.2) for the non-parallel algorithm overloads in namespaceranges, Imodels bidirectional_iterator.
7 Returns: Let NEW_FIRST be first + n if n < last - first, otherwiselast. Returns:
—(7.1) NEW_FIRST for the overloads in namespacestd.
—(7.2) {NEW_FIRST , last} for the overloads in namespaceranges.
8 Complexity: At most(last - first) - n assignments or swaps.
26.8 Sorting and related operations [alg.sorting]
26.8.1 General [alg.sorting.general]
1 The operations in 26.8 defined directly in namespacestd have two versions: one that takes a function object
of typeCompare and one that uses anoperator<.
2 Compare is a function object type (22.10) that meets the requirements for a template parameter named
BinaryPredicate (26.2). The return value of the function call operation applied to an object of typeCompare,
when converted tobool, yields true if the first argument of the call is less than the second, andfalse
otherwise. Compare comp is used throughout for algorithms assuming an ordering relation.
3 For all algorithms that takeCompare, there is a version that usesoperator< instead. That is,comp(*i, *j)
!= false defaults to*i < *j != false. For algorithms other than those described in 26.8.4,comp shall
induce a strict weak ordering on the values.
4 The termstrict refers to the requirement of an irreflexive relation (!comp(x, x) for allx), and the term
weak to requirements that are not as strong as those for a total ordering, but stronger than those for a partial
ordering. If we defineequiv(a, b) as !comp(a, b) && !comp(b, a), then the requirements are thatcomp
and equiv both be transitive relations:
—(4.1) comp(a, b) && comp(b, c) implies comp(a, c)
—(4.2) equiv(a, b) && equiv(b, c) implies equiv(a, c)
[Note 1: Under these conditions, it can be shown that
—(4.3) equiv is an equivalence relation,
—(4.4) comp induces a well-defined relation on the equivalence classes determined byequiv, and
—(4.5) the induced relation is a strict total ordering.
—end note]
5 A sequence issorted with respect to acomp and proj for a comparator and projectioncomp and proj if for
every iteratori pointing to the sequence and every non-negative integern such thati + n is a valid iterator
pointing to an element of the sequence,
bool(invoke(comp, invoke(proj, *(i + n)), invoke(proj, *i)))
§ 26.8.1 © ISO/IEC
1512

===== PAGE 1524 =====

Dxxxx
is false.
6 A sequence issorted with respect to a comparatorcomp for a comparatorcomp if it is sorted with respect to
comp and identity{} (the identity projection).
7 A sequence[start,finish) is partitioned with respect to an expressionf(e) if there exists an integern such
that for all0 <= i < (finish - start), f(*(start + i)) is true if and only ifi < n.
8 In the descriptions of the functions that deal with ordering relationships we frequently use a notion of
equivalence to describe concepts such as stability. The equivalence to which we refer is not necessarily an
operator==, but an equivalence relation induced by the strict weak ordering. That is, two elementsa and b
are considered equivalent if and only if!(a < b) && !(b < a).
26.8.2 Sorting [alg.sort]
26.8.2.1 sort [sort]
template<class RandomAccessIterator>
constexpr void sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
void sort(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void sort(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void sort(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
ranges::sort(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::sort(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I ranges::sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R> ranges::sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: For the overloads in namespacestd, RandomAccessIterator meets theCpp17Value-
Swappable requirements (16.4.4.3) and the type of*first meets theCpp17MoveConstructible (Table 31)
and Cpp17MoveAssignable (Table 33) requirements.
3 Effects: Sorts the elements in the range[first,last) with respect tocomp and proj.
4 Returns: last for the overloads in namespaceranges.
5 Complexity: Let N be last - first. O(Nlog N) comparisons and projections.
26.8.2.2 stable_sort [stable.sort]
template<class RandomAccessIterator>
constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
void stable_sort(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last);
§ 26.8.2.2 © ISO/IEC
1513

===== PAGE 1525 =====

Dxxxx
template<class RandomAccessIterator, class Compare>
constexpr void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void stable_sort(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I ranges::stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::stable_sort(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I ranges::stable_sort(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
ranges::stable_sort(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: For the overloads in namespacestd, RandomAccessIterator meets theCpp17Value-
Swappable requirements (16.4.4.3) and the type of*first meets theCpp17MoveConstructible (Table 31)
and Cpp17MoveAssignable (Table 33) requirements.
3 Effects: Sorts the elements in the range[first,last) with respect tocomp and proj.
4 Returns: last for the overloads in namespaceranges.
5 Complexity: Let N be last - first. If enough extra memory is available,Nlog(N) comparisons.
Otherwise, at mostNlog2(N) comparisons. In either case, twice as many projections as the number of
comparisons.
6 Remarks: Stable (16.4.6.8).
26.8.2.3 partial_sort [partial.sort]
template<class RandomAccessIterator>
constexpr void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
void partial_sort(ExecutionPolicy&& exec,
RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last,
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void partial_sort(ExecutionPolicy&& exec,
RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last,
Compare comp);
§ 26.8.2.3 © ISO/IEC
1514

===== PAGE 1526 =====

Dxxxx
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
ranges::partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I ranges::partial_sort(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: [first,middle) and [middle,last) are valid ranges. For the overloads in namespacestd,
RandomAccessIteratormeetsthe Cpp17ValueSwappablerequirements(16.4.4.3)andthetypeof *first
meets theCpp17MoveConstructible (Table 31) andCpp17MoveAssignable (Table 33) requirements.
3 Effects: Places the firstmiddle - first elements from the range[first,last) as sorted with respect
to comp and proj into the range[first,middle). The rest of the elements in the range[middle,last)
are placed in an unspecified order.
4 Returns: last for the overload in namespaceranges.
5 Complexity: Approximately (last - first) * log(middle - first) comparisons, and twice as
many projections.
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::partial_sort(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
6 Effects: Equivalent to:
return ranges::partial_sort(ranges::begin(r), middle, ranges::end(r), comp, proj);
template<execution-policy Ep, sized-random-access-range R,
class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
ranges::partial_sort(Ep&& exec, R&& r, iterator_t<R> middle, Comp comp = {},
Proj proj = {});
7 Effects: Equivalent to:
return ranges::partial_sort(std::forward<Ep>(exec), ranges::begin(r), middle,
ranges::begin(r) + ranges::distance(r),
comp, proj);
26.8.2.4 partial_sort_copy [partial.sort.copy]
template<class InputIterator, class RandomAccessIterator>
constexpr RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
RandomAccessIterator
partial_sort_copy(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last);
template<class InputIterator, class RandomAccessIterator,
class Compare>
constexpr RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last,
Compare comp);
§ 26.8.2.4 © ISO/IEC
1515

===== PAGE 1527 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
class Compare>
RandomAccessIterator
partial_sort_copy(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last,
Compare comp);
template<input_iterator I1, sentinel_for<I1> S1, random_access_iterator I2, sentinel_for<I2> S2,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
constexpr ranges::partial_sort_copy_result<I1, I2>
ranges::partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, random_access_range R2, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
sortable<iterator_t<R2>, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>
constexpr ranges::partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
ranges::partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<I1, I2> && sortable<I2, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
ranges::partial_sort_copy_result<I1, I2>
ranges::partial_sort_copy(Ep&& exec, I1 first, S1 last, I2 result_first, S2 result_last,
Comp comp = {}, Proj1 proj1 = {},
Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
sortable<iterator_t<R2>, Comp, Proj2> &&
indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>>
ranges::partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
ranges::partial_sort_copy(Ep&& exec, R1&& r, R2&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let N be min(last - first, result_last - result_first). Let comp be less{}, andproj1 and
proj2 be identity{} for the overloads with no parameters by those names.
2 Mandates: For the overloads in namespacestd, the expression*first is writable (24.3.1) toresult_-
first.
3 Preconditions: For the overloads in namespacestd, RandomAccessIterator meets theCpp17Value-
Swappable requirements (16.4.4.3), the type of*result_first meets the Cpp17MoveConstructible
(Table 31) andCpp17MoveAssignable (Table 33) requirements.
4 For iteratorsa1 and b1 in [first,last), and iteratorsx2 and y2 in [result_first,result_last),
after evaluating the assignment*y2 = *b1, letE be the value of
bool(invoke(comp, invoke(proj1, *a1), invoke(proj2, *y2))).
Then, after evaluating the assignment*x2 = *a1, E is equal to
bool(invoke(comp, invoke(proj2, *x2), invoke(proj2, *y2))).
[Note 1: Writing a value from the input range into the output range does not affect how it is ordered bycomp
and proj1 or proj2. —end note]
§ 26.8.2.4 © ISO/IEC
1516

===== PAGE 1528 =====

Dxxxx
5 Effects: Places the firstN elements as sorted with respect tocomp and proj2 into the range[result_-
first,result_first + N).
6 Returns:
—(6.1) result_first + N for the overloads in namespacestd.
—(6.2) {last, result_first + N} for the overloads in namespaceranges.
7 Complexity: Approximately (last - first) * log N comparisons, and twice as many projections.
26.8.2.5 is_sorted [is.sorted]
template<class ForwardIterator>
constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
1 Effects: Equivalent to:return is_sorted_until(first, last) == last;
template<class ExecutionPolicy, class ForwardIterator>
bool is_sorted(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
2 Effects: Equivalent to:
return is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last) == last;
template<class ForwardIterator, class Compare>
constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
Compare comp);
3 Effects: Equivalent to:return is_sorted_until(first, last, comp) == last;
template<class ExecutionPolicy, class ForwardIterator, class Compare>
bool is_sorted(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Compare comp);
4 Effects: Equivalent to:
return is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last;
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr bool ranges::is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr bool ranges::is_sorted(R&& r, Comp comp = {}, Proj proj = {});
5 Effects: Equivalent to:return ranges::is_sorted_until(first, last, comp, proj) == last;
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
bool ranges::is_sorted(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
bool ranges::is_sorted(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
6 Effects: Equivalent to:
return ranges::is_sorted_until(std::forward<Ep>(exec), first, last, comp, proj) == last;
template<class ForwardIterator>
constexpr ForwardIterator
is_sorted_until(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator
is_sorted_until(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
§ 26.8.2.5 © ISO/IEC
1517

===== PAGE 1529 =====

Dxxxx
template<class ForwardIterator, class Compare>
constexpr ForwardIterator
is_sorted_until(ForwardIterator first, ForwardIterator last,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
ForwardIterator
is_sorted_until(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Compare comp);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I ranges::is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
ranges::is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I ranges::is_sorted_until(Ep&& exec, I first, S last, Comp comp = {},
Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
ranges::is_sorted_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
7 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
8 Returns: The last iteratori in [first,last] for which the range[first,i) is sorted with respect to
comp and proj.
9 Complexity: Linear.
26.8.3 Nth element [alg.nth.element]
template<class RandomAccessIterator>
constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
void nth_element(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last, Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
void nth_element(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last, Compare comp);
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
ranges::nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I ranges::nth_element(Ep&& exec, I first, I nth, S last, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: [first,nth) and [nth,last) are valid ranges. For the overloads in namespacestd,
RandomAccessIterator meets the Cpp17ValueSwappable requirements (16.4.4.3), and the type of
§ 26.8.3 © ISO/IEC
1518

===== PAGE 1530 =====

Dxxxx
*first meets theCpp17MoveConstructible (Table 31) andCpp17MoveAssignable (Table 33) require-
ments.
3 Effects: After nth_element the element in the position pointed to bynth is the element that would be
in that position if the whole range were sorted with respect tocomp and proj, unlessnth == last.
Also for every iteratori in the range[first,nth) and every iteratorj in the range[nth,last) it holds
that: bool(invoke(comp, invoke(proj, *j), invoke(proj, *i))) is false.
4 Returns: last for the overload in namespaceranges.
5 Complexity: For the non-parallel algorithm overloads, linear on average. For the parallel algorithm
overloads, O(N) applications of the predicate, andO(Nlog N) swaps, whereN = last - first.
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
6 Effects: Equivalent to:
return ranges::nth_element(ranges::begin(r), nth, ranges::end(r), comp, proj);
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
ranges::nth_element(Ep&& exec, R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
7 Effects: Equivalent to:
return ranges::nth_element(std::forward<Ep>(exec), ranges::begin(r), nth,
ranges::begin(r) + ranges::distance(r),
comp, proj);
26.8.4 Binary search [alg.binary.search]
26.8.4.1 General [alg.binary.search.general]
1 All of the algorithms in 26.8.4 are versions of binary search and assume that the sequence being searched is
partitioned with respect to an expression formed by binding the search key to an argument of the comparison
function. They work on non-random access iterators minimizing the number of comparisons, which will be
logarithmic for all types of iterators. They are especially appropriate for random access iterators, because
these algorithms do a logarithmic number of steps through the data structure. For non-random access
iterators they execute a linear number of steps.
26.8.4.2 lower_bound [lower.bound]
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
const T& value, Compare comp);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>,
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr I ranges::lower_bound(I first, S last, const T& value, Comp comp = {},
Proj proj = {});
§ 26.8.4.2 © ISO/IEC
1519

===== PAGE 1531 =====

Dxxxx
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr borrowed_iterator_t<R>
ranges::lower_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for overloads with no parameters by those names.
2 Preconditions: The elementse of [first,last) are partitioned with respect to the expression
bool(invoke(comp, invoke(proj, e), value)).
3 Returns: The furthermost iteratori in the range[first,last] such that for every iteratorj in the
range [first,i), bool(invoke(comp, invoke(proj, *j), value)) is true.
4 Complexity: At mostlog2(last - first) + O(1) comparisons and projections.
26.8.4.3 upper_bound [upper.bound]
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
const T& value, Compare comp);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>,
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr I ranges::upper_bound(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr borrowed_iterator_t<R>
ranges::upper_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for overloads with no parameters by those names.
2 Preconditions: The elementse of [first,last) are partitioned with respect to the expression
!bool(invoke(comp, value, invoke(proj, e))).
3 Returns: The furthermost iteratori in the range[first,last] such that for every iteratorj in the
range [first,i), !bool(invoke(comp, value, invoke(proj, *j))) is true.
4 Complexity: At mostlog2(last - first) + O(1) comparisons and projections.
26.8.4.4 equal_range [equal.range]
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr pair<ForwardIterator, ForwardIterator>
equal_range(ForwardIterator first,
ForwardIterator last, const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr pair<ForwardIterator, ForwardIterator>
equal_range(ForwardIterator first,
ForwardIterator last, const T& value,
Compare comp);
§ 26.8.4.4 © ISO/IEC
1520

===== PAGE 1532 =====

Dxxxx
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>,
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr subrange<I>
ranges::equal_range(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr borrowed_subrange_t<R>
ranges::equal_range(R&& r, const T& value, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for overloads with no parameters by those names.
2 Preconditions: The elements e of [first,last) are partitioned with respect to the expressions
bool(invoke(comp, invoke(proj, e), value)) and !bool(invoke(comp, value, invoke(proj,
e))). Also, for all elementse of [first,last), bool(comp(e, value)) implies !bool(comp(value,
e)) for the overloads in namespacestd.
3 Returns:
—(3.1) For the overloads in namespacestd:
{lower_bound(first, last, value, comp),
upper_bound(first, last, value, comp)}
—(3.2) For the overloads in namespaceranges:
{ranges::lower_bound(first, last, value, comp, proj),
ranges::upper_bound(first, last, value, comp, proj)}
4 Complexity: At most2 ∗log2(last - first) + O(1) comparisons and projections.
26.8.4.5 binary_search [binary.search]
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type>
constexpr bool
binary_search(ForwardIterator first, ForwardIterator last,
const T& value);
template<class ForwardIterator, class T = iterator_traits<ForwardIterator>::value_type,
class Compare>
constexpr bool
binary_search(ForwardIterator first, ForwardIterator last,
const T& value, Compare comp);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
class T = projected_value_t<I, Proj>,
indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
constexpr bool ranges::binary_search(I first, S last, const T& value, Comp comp = {},
Proj proj = {});
template<forward_range R, class Proj = identity,
class T = projected_value_t<iterator_t<R>, Proj>,
indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
ranges::less>
constexpr bool ranges::binary_search(R&& r, const T& value, Comp comp = {},
Proj proj = {});
1 Let comp be less{} and proj be identity{} for overloads with no parameters by those names.
2 Preconditions: The elements e of [first,last) are partitioned with respect to the expressions
bool(invoke(comp, invoke(proj, e), value)) and !bool(invoke(comp, value, invoke(proj,
e))). Also, for all elementse of [first,last), bool(comp(e, value)) implies !bool(comp(value,
e)) for the overloads in namespacestd.
3 Returns: true if and only if for some iteratori in the range [first,last), !bool(invoke(comp,
invoke(proj, *i), value)) && !bool(invoke(comp, value, invoke(proj, *i))) is true.
4 Complexity: At mostlog2(last - first) + O(1) comparisons and projections.
§ 26.8.4.5 © ISO/IEC
1521

===== PAGE 1533 =====

Dxxxx
26.8.5 Partitions [alg.partitions]
template<class InputIterator, class Predicate>
constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
bool is_partitioned(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, Predicate pred);
template<input_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr bool ranges::is_partitioned(I first, S last, Pred pred, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr bool ranges::is_partitioned(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
bool ranges::is_partitioned(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
bool ranges::is_partitioned(Ep&& exec, R&& r, Pred pred, Proj proj = {});
1 Let proj be identity{} for the overloads with no parameter namedproj.
2 Returns: true if and only if the elementse of [first,last) are partitioned with respect to the
expression bool(invoke(pred, invoke(proj, e))).
3 Complexity: Linear. At mostlast - first applications ofpred and proj.
template<class ForwardIterator, class Predicate>
constexpr ForwardIterator
partition(ForwardIterator first, ForwardIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
ForwardIterator
partition(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Predicate pred);
template<permutable I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr subrange<I>
ranges::partition(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R>
ranges::partition(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
subrange<I> ranges::partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R> ranges::partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});
4 Letprojbe identity{}for the overloads with no parameter namedprojand letE(x) be bool(invoke(
pred, invoke(proj, x))).
5 Preconditions: For the overloads in namespacestd, ForwardIterator meets theCpp17ValueSwappable
requirements (16.4.4.3).
6 Effects: Places all the elementse in [first,last) that satisfyE(e) before all the elements that do not.
7 Returns: Let i be an iterator such thatE(*j) is true for every iteratorj in [first,i) and false for
every iteratorj in [i,last). Returns:
—(7.1) i for the overloads in namespacestd.
—(7.2) {i, last} for the overloads in namespaceranges.
§ 26.8.5 © ISO/IEC
1522

===== PAGE 1534 =====

Dxxxx
8 Complexity: Let N = last - first:
—(8.1) For the non-parallel algorithm overloads, exactlyN applications of the predicate and projection.
At mostN/2 swaps if the type offirst meets theCpp17BidirectionalIteratorrequirements for the
overloads in namespacestd or modelsbidirectional_iterator for the overloads in namespace
ranges, and at mostN swaps otherwise.
—(8.2) For the parallel algorithm overloads,O(Nlog N) swaps andO(N) applications of the predicate.
template<class BidirectionalIterator, class Predicate>
BidirectionalIterator
constexpr stable_partition(BidirectionalIterator first, BidirectionalIterator last,
Predicate pred);
template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
BidirectionalIterator
stable_partition(ExecutionPolicy&& exec,
BidirectionalIterator first, BidirectionalIterator last, Predicate pred);
template<bidirectional_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
constexpr subrange<I> ranges::stable_partition(I first, S last, Pred pred, Proj proj = {});
template<bidirectional_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
constexpr borrowed_subrange_t<R> ranges::stable_partition(R&& r, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires permutable<I>
subrange<I>
ranges::stable_partition(Ep&& exec, I first, S last, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires permutable<iterator_t<R>>
borrowed_subrange_t<R>
ranges::stable_partition(Ep&& exec, R&& r, Pred pred, Proj proj = {});
9 Letprojbe identity{}for the overloads with no parameter namedprojand letE(x) be bool(invoke(
pred, invoke(proj, x))).
10 Preconditions: For the overloads in namespacestd, BidirectionalIterator meets theCpp17Value-
Swappable requirements (16.4.4.3) and the type of*first meets theCpp17MoveConstructible (Table 31)
and Cpp17MoveAssignable (Table 33) requirements.
11 Effects: Places all the elementse in [first,last) that satisfyE(e) before all the elements that do not.
The relative order of the elements in both groups is preserved.
12 Returns: Let i be an iterator such that for every iteratorj in [first,i), E(*j) is true, and for every
iterator j in the range[i,last), E(*j) is false. Returns:
—(12.1) i for the overloads in namespacestd.
—(12.2) {i, last} for the overloads in namespaceranges.
13 Complexity: Let N = last - first:
—(13.1) For the non-parallel algorithm overloads, at mostNlog2 N swaps, but onlyO(N) swaps if there
is enough extra memory. ExactlyN applications of the predicate and projection.
—(13.2) For the parallel algorithm overloads,O(Nlog N) swaps andO(N) applications of the predicate.
template<class InputIterator, class OutputIterator1, class OutputIterator2, class Predicate>
constexpr pair<OutputIterator1, OutputIterator2>
partition_copy(InputIterator first, InputIterator last,
OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);
§ 26.8.5 © ISO/IEC
1523

===== PAGE 1535 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
class ForwardIterator2, class Predicate>
pair<ForwardIterator1, ForwardIterator2>
partition_copy(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
ForwardIterator1 out_true, ForwardIterator2 out_false, Predicate pred);
template<input_iterator I, sentinel_for<I> S, weakly_incrementable O1, weakly_incrementable O2,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
constexpr ranges::partition_copy_result<I, O1, O2>
ranges::partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
Proj proj = {});
template<input_range R, weakly_incrementable O1, weakly_incrementable O2,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, O1> &&
indirectly_copyable<iterator_t<R>, O2>
constexpr ranges::partition_copy_result<borrowed_iterator_t<R>, O1, O2>
ranges::partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
random_access_iterator O1, sized_sentinel_for<O1> OutS1,
random_access_iterator O2, sized_sentinel_for<O2> OutS2,
class Proj = identity, indirect_unary_predicate<projected<I, Proj>> Pred>
requires indirectly_copyable<I, O1> && indirectly_copyable<I, O2>
ranges::partition_copy_result<I, O1, O2>
ranges::partition_copy(Ep&& exec, I first, S last, O1 out_true, OutS1 last_true,
O2 out_false, OutS2 last_false, Pred pred, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R,
sized-random-access-range OutR1, sized-random-access-range OutR2,
class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
requires indirectly_copyable<iterator_t<R>, iterator_t<OutR1>> &&
indirectly_copyable<iterator_t<R>, iterator_t<OutR2>>
ranges::partition_copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR1>,
borrowed_iterator_t<OutR2>>
ranges::partition_copy(Ep&& exec, R&& r, OutR1&& out_true_r, OutR2&& out_false_r,
Pred pred, Proj proj = {});
14 Letprojbe identity{}for the overloads with no parameter namedprojand letE(x) be bool(invoke(
pred, invoke(proj, x))).
15 For the overloads with no parameterslast_true, last_false, out_true_r, orout_false_r, let
—(15.1) M be the number of iteratorsi in [first,last) for whichE(*i) is true, andK be last - first
- M;
—(15.2) last_true be out_true + M, andlast_false be out_false + K.
16 For the overloads with parameterslast_true, last_false, out_true_r, orout_false_r, letM be
last_true - out_true and K be last_false - out_false.
17 Let:
—(17.1) i1 be the iterator in[first,last) for whichE(*i1) is true and there are exactlyM iterators j
in [first,i1) for whichE(*j) is true, orlast if no such iterator exists;
—(17.2) i2 be the iterator in[first,last) for whichE(*i2) is false and there are exactlyK iterators j
in [first,i2) for whichE(*j) is false, orlast if no such iterator exists;
—(17.3) N be min(i1 - first, i2 - first).
18 Mandates: For the overloads in namespacestd, the expression*first is writable (24.3.1) toout_true
and out_false.
19 Preconditions: The input range and output ranges do not overlap.
[Note 1: For the parallel algorithm overload in namespacestd, there can be a performance cost iffirst’s
value type does not meet theCpp17CopyConstructible requirements. For the parallel algorithm overloads in
§ 26.8.5 © ISO/IEC
1524

===== PAGE 1536 =====

Dxxxx
namespace ranges, there can be a performance cost iffirst’s value type does not modelcopy_constructible.
—end note]
20 Effects: For each iteratoriin[first,first + N), copies*ito the output range[out_true,last_true)
if E(*i) is true, or to the output range[out_false,last_false) otherwise.
21 Returns: Let Q be the number of elements copied into the output range[out_true,last_true), and
V be the number of elements copied into the output range[out_false,last_false). Returns:
—(21.1) {out_true + Q, out_false + V} for the overloads in namespacestd.
—(21.2) {first + N, out_true + Q, out_false + V} for the overloads in namespaceranges.
22 Complexity: At mostlast - first applications ofpred and proj.
template<class ForwardIterator, class Predicate>
constexpr ForwardIterator
partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_unary_predicate<projected<I, Proj>> Pred>
constexpr I ranges::partition_point(I first, S last, Pred pred, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
constexpr borrowed_iterator_t<R>
ranges::partition_point(R&& r, Pred pred, Proj proj = {});
23 Letprojbe identity{}for the overloads with no parameter namedprojand letE(x) be bool(invoke(
pred, invoke(proj, x))).
24 Preconditions: The elementse of [first,last) are partitioned with respect toE(e).
25 Returns: An iteratormid such thatE(*i) is true for all iteratorsi in [first,mid), andfalse for all
iterators i in [mid,last).
26 Complexity: O(log(last - first)) applications ofpred and proj.
26.8.6 Merge [alg.merge]
template<class InputIterator1, class InputIterator2,
class OutputIterator>
constexpr OutputIterator
merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
merge(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class InputIterator1, class InputIterator2,
class OutputIterator, class Compare>
constexpr OutputIterator
merge(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
merge(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
§ 26.8.6 © ISO/IEC
1525

===== PAGE 1537 =====

Dxxxx
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr ranges::merge_result<I1, I2, O>
ranges::merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr ranges::merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
ranges::merge(R1&& r1, R2&& r2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
ranges::merge_result<I1, I2, O>
ranges::merge(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2, O result, OutS result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
ranges::merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, borrowed_iterator_t<OutR>>
ranges::merge(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) N be:
—(1.1.1) (last1 - first1) + (last2 - first2) for the overloads with no parameterresult_last
or result_r;
—(1.1.2) min((last1 - first1) + (last2 - first2), result_last - result) for the overloads
with parametersresult_last or result_r;
—(1.2) comp be less{}, proj1 be identity{}, and proj2 be identity{}, for the overloads with no
parameters by those names;
—(1.3) E be bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)));
—(1.4) K be the smallest integer in[0,last1 - first1) such that for the elemente1 in the position
first1 + K there are at leastN −K elements e2 in [first2,last2) for whichE holds, and be
equal tolast1 - first1 if no such integer exists.
[Note 1: first1 + K points to the position past the last element to be copied.—end note]
2 Preconditions: The ranges[first1,last1) and [first2,last2) are sorted with respect tocomp and
proj1 or proj2, respectively. The resulting range does not overlap with either of the original ranges.
3 Effects: Copies the firstK elements of the range[first1,last1) and the firstN −K elements of the
range [first2,last2) into the range[result,result + N). If an elementa precedes b in an input
range, a is copied into the output range beforeb. If e1 is an element of[first1,last1) and e2 of
[first2,last2), e2 is copied into the output range beforee1 if and only ifE is true.
4 Returns:
—(4.1) result + N for the overloads in namespacestd.
—(4.2) {first1 + K, first2 + N - K, result + N} for the overloads in namespaceranges.
5 Complexity:
—(5.1) For the non-parallel algorithm overloads, at mostN −1 comparisons and applications of each
projection.
—(5.2) For the parallel algorithm overloads,O(N) comparisons and applications of each projection.
§ 26.8.6 © ISO/IEC
1526

===== PAGE 1538 =====

Dxxxx
6 Remarks: Stable (16.4.6.8).
template<class BidirectionalIterator>
constexpr void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
void inplace_merge(ExecutionPolicy&& exec,
BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last);
template<class BidirectionalIterator, class Compare>
constexpr void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last, Compare comp);
template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
void inplace_merge(ExecutionPolicy&& exec,
BidirectionalIterator first,
BidirectionalIterator middle,
BidirectionalIterator last, Compare comp);
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I ranges::inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Comp = ranges::less, class Proj = identity>
requires sortable<I, Comp, Proj>
I ranges::inplace_merge(Ep&& exec, I first, I middle, S last, Comp comp = {}, Proj proj = {});
7 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
8 Preconditions: [first,middle) and [middle,last) are valid ranges sorted with respect tocomp and
proj. For the overloads in namespacestd, BidirectionalIterator meets theCpp17ValueSwappable
requirements (16.4.4.3) and the type of*first meets theCpp17MoveConstructible (Table 31) and
Cpp17MoveAssignable (Table 33) requirements.
9 Effects: Merges two sorted consecutive ranges[first,middle) and [middle,last), putting the result
of the merge into the range[first,last). The resulting range is sorted with respect tocomp and proj.
10 Returns: last for the overload in namespaceranges.
11 Complexity: Let N = last - first:
—(11.1) For the non-parallel algorithm overloads, and if enough additional memory is available, at most
N −1 comparisons.
—(11.2) Otherwise, O(Nlog N) comparisons.
In either case, twice as many projections as comparisons.
12 Remarks: Stable (16.4.6.8).
template<bidirectional_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {}, Proj proj = {});
13 Effects: Equivalent to:
return ranges::inplace_merge(ranges::begin(r), middle, ranges::end(r), comp, proj);
template<execution-policy Ep, sized-random-access-range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
borrowed_iterator_t<R>
ranges::inplace_merge(Ep&& exec, R&& r, iterator_t<R> middle, Comp comp = {},
§ 26.8.6 © ISO/IEC
1527

===== PAGE 1539 =====

Dxxxx
Proj proj = {});
14 Effects: Equivalent to:
return ranges::inplace_merge(std::forward<Ep>(exec), ranges::begin(r), middle,
ranges::begin(r) + ranges::distance(r),
comp, proj);
26.8.7 Set operations on sorted structures [alg.set.operations]
26.8.7.1 General [alg.set.operations.general]
1 Subclause 26.8.7 defines all the basic set operations on sorted structures. They also work withmultisets
(23.4.7) containing multiple copies of equivalent elements. The semantics of the set operations are generalized
to multisets in a standard way by definingset_union to contain the maximum number of occurrences of
every element,set_intersection to contain the minimum, and so on.
26.8.7.2 includes [includes]
template<class InputIterator1, class InputIterator2>
constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool includes(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class InputIterator1, class InputIterator2, class Compare>
constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class Compare>
bool includes(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
Compare comp);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>,
projected<I2, Proj2>> Comp = ranges::less>
constexpr bool ranges::includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
constexpr bool ranges::includes(R1&& r1, R2&& r2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
ranges::less>
bool ranges::includes(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
bool ranges::includes(Ep&& exec, R1&& r1, R2&& r2,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let comp be less{}, proj1 be identity{}, and proj2 be identity{}, for the overloads with no
parameters by those names.
§ 26.8.7.2 © ISO/IEC
1528

===== PAGE 1540 =====

Dxxxx
2 Preconditions: The ranges[first1,last1) and [first2,last2) are sorted with respect tocomp and
proj1 or proj2, respectively.
3 Returns: true if and only if[first2,last2) is a subsequence of[first1,last1).
[Note 1: A sequenceS is a subsequence of another sequenceT if S can be obtained fromT by removing some,
all, or none ofT’s elements and keeping the remaining elements in the same order.—end note]
4 Complexity: At most2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons and applica-
tions of each projection.
26.8.7.3 set_union [set.union]
template<class InputIterator1, class InputIterator2, class OutputIterator>
constexpr OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_union(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
constexpr OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_union(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr ranges::set_union_result<I1, I2, O>
ranges::set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
ranges::set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
ranges::set_union_result<I1, I2, O>
ranges::set_union(Ep&& exec, I1 first1, S1 last1,
I2 first2, S2 last2, O result, OutS result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
§ 26.8.7.3 © ISO/IEC
1529

===== PAGE 1541 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
ranges::set_union(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) comp be less{}, andproj1 and proj2 be identity{} for the overloads with no parameters by
those names;
—(1.2) M be the number of elements in the sorted union (see below);
—(1.3) result_last be result + M for the overloads with no parameterresult_last or result_r;
—(1.4) N be min(M, result_last - result).
2 Preconditions: The ranges[first1,last1) and [first2,last2) are sorted with respect tocomp and
proj1 or proj2, respectively. The resulting range does not overlap with either of the original ranges.
3 Effects: Constructs a sorted union of the elements from the two ranges; that is, the set of elements that
are present in one or both of the ranges. If[first1,last1) contains m elements that are equivalent to
each other and[first2,last2) contains n elements that are equivalent to them, then allm elements
from the first range are included in the union, in order, and then the finalmax(n−m,0) elements
from the second range are included in the union, in order. If, of those elements,k elements from the
first range are copied to the output range, then the firstmin(k,n) elements from the second range are
considered skipped. Copies the firstN elements of the sorted union to the range[result,result + N).
4 Returns:
—(4.1) result_last for the overloads in namespacestd.
—(4.2) {last1, last2, result + N} for the overloads in namespaceranges, ifN is equal toM.
—(4.3) Otherwise, {first1 + A, first2 + B, result_last} for the overloads in namespaceranges,
where A and B are the numbers of copied or skipped elements in[first1,last1) and [first2,
last2), respectively.
5 Complexity: At most2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons and applica-
tions of each projection.
6 Remarks: Stable (16.4.6.8).
26.8.7.4 set_intersection [set.intersection]
template<class InputIterator1, class InputIterator2,
class OutputIterator>
constexpr OutputIterator
set_intersection(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_intersection(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class InputIterator1, class InputIterator2,
class OutputIterator, class Compare>
constexpr OutputIterator
set_intersection(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
§ 26.8.7.4 © ISO/IEC
1530

===== PAGE 1542 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_intersection(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr ranges::set_intersection_result<I1, I2, O>
ranges::set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr ranges::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
ranges::set_intersection(R1&& r1, R2&& r2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
ranges::set_intersection_result<I1, I2, O>
ranges::set_intersection(Ep&& exec, I1 first1, S1 last1,
I2 first2, S2 last2, O result, OutS result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
ranges::set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
ranges::set_intersection(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) comp be less{}, andproj1 and proj2 be identity{} for the overloads with no parameters by
those names;
—(1.2) M be the number of elements in the sorted intersection (see below);
—(1.3) result_last be result + M for the overloads with no parameterresult_last or result_r;
—(1.4) N be min(M, result_last - result).
2 Preconditions: The ranges[first1,last1) and [first2,last2) are sorted with respect tocomp and
proj1 or proj2, respectively. The resulting range does not overlap with either of the original ranges.
3 Effects: Constructs a sorted intersection of the elements from the two ranges; that is, the set of elements
that are present in both of the ranges. If[first1,last1) contains m elements that are equivalent to
each other and[first2,last2) contains n elements that are equivalent to them, the firstmin(m,n)
elements from the first range are included in the sorted intersection. If, of those elements,k elements
from the first range are copied to the output range, then the firstk elements from the second range are
considered skipped. If N <M, a non-copied element is also considered skipped if it compares less than
the (N + 1)th element of the sorted intersection. Copies the firstN elements of the sorted intersection
to the range[result,result + N).
4 Returns:
—(4.1) result_last for the overloads in namespacestd.
—(4.2) {last1, last2, result + N} for the overloads in namespaceranges, ifN is equal toM.
§ 26.8.7.4 © ISO/IEC
1531

===== PAGE 1543 =====

Dxxxx
—(4.3) Otherwise, {first1 + A, first2 + B, result_last} for the overloads in namespaceranges,
where A and B are the numbers of copied or skipped elements in[first1,last1) and [first2,
last2), respectively.
5 Complexity: At most2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons and applica-
tions of each projection.
6 Remarks: Stable (16.4.6.8).
26.8.7.5 set_difference [set.difference]
template<class InputIterator1, class InputIterator2,
class OutputIterator>
constexpr OutputIterator
set_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_difference(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class InputIterator1, class InputIterator2,
class OutputIterator, class Compare>
constexpr OutputIterator
set_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_difference(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr ranges::set_difference_result<I1, O>
ranges::set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr ranges::set_difference_result<borrowed_iterator_t<R1>, O>
ranges::set_difference(R1&& r1, R2&& r2, O result,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
ranges::set_difference_result<I1, O>
ranges::set_difference(Ep&& exec, I1 first1, S1 last1,
I2 first2, S2 last2, O result, OutS result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
§ 26.8.7.5 © ISO/IEC
1532

===== PAGE 1544 =====

Dxxxx
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
ranges::set_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<OutR>>
ranges::set_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) comp be less{}, andproj1 and proj2 be identity{} for the overloads with no parameters by
those names;
—(1.2) M be the number of elements in the sorted difference (see below);
—(1.3) result_last be result + M for the overloads with no parameterresult_last or result_r;
—(1.4) N be min(M, result_last - result).
2 Preconditions: The ranges[first1,last1) and [first2,last2) are sorted with respect tocomp and
proj1 or proj2, respectively. The resulting range does not overlap with either of the original ranges.
3 Effects: Constructs a sorted difference between the elements from the two ranges; that is, the set of
elements that are present in the range[first1,last1) but not [first2,last2). If [first1,last1)
contains melements that are equivalent to each other and[first2,last2) contains nelements that are
equivalent to them, the lastmax(m−n,0) elements from[first1,last1) are included in the sorted
difference, in order. Copies the firstN elements of the sorted difference to the range[result,result +
N).
4 Returns:
—(4.1) result_last for the overloads in namespacestd.
—(4.2) {last1, result + N} for the overloads in namespaceranges, ifN is equal toM.
—(4.3) Otherwise, {j1, result_last} for the overloads in namespaceranges, where the iteratorj1
points to the position of the element in[first1,last1) corresponding to the(N+ 1)th element of
the sorted difference.
5 Complexity: At most2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons and applica-
tions of each projection.
6 Remarks: Stable (16.4.6.8).
26.8.7.6 set_symmetric_difference [set.symmetric.difference]
template<class InputIterator1, class InputIterator2,
class OutputIterator>
constexpr OutputIterator
set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator>
ForwardIterator
set_symmetric_difference(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result);
template<class InputIterator1, class InputIterator2,
class OutputIterator, class Compare>
constexpr OutputIterator
set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);
§ 26.8.7.6 © ISO/IEC
1533

===== PAGE 1545 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class ForwardIterator, class Compare>
ForwardIterator
set_symmetric_difference(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
ForwardIterator result, Compare comp);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
weakly_incrementable O, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
constexpr ranges::set_symmetric_difference_result<I1, I2, O>
ranges::set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
Comp comp = {}, Proj1 proj1 = {},
Proj2 proj2 = {});
template<input_range R1, input_range R2, weakly_incrementable O,
class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
constexpr ranges::set_symmetric_difference_result<borrowed_iterator_t<R1>,
borrowed_iterator_t<R2>, O>
ranges::set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
random_access_iterator O, sized_sentinel_for<O> OutS, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<I1, I2, O, Comp, Proj1, Proj2>
ranges::set_symmetric_difference_result<I1, I2, O>
ranges::set_symmetric_difference(Ep&& exec, I1 first1, S1 last1,
I2 first2, S2 last2, O result, OutS result_last,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
sized-random-access-range OutR, class Comp = ranges::less,
class Proj1 = identity, class Proj2 = identity>
requires mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
ranges::set_symmetric_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
borrowed_iterator_t<OutR>>
ranges::set_symmetric_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
1 Let:
—(1.1) comp be less{}, andproj1 and proj2 be identity{} for the overloads with no parameters by
those names;
—(1.2) M be the number of elements in the sorted symmetric difference (see below);
—(1.3) result_last be result + M for the overloads with no parameterresult_last or result_r;
—(1.4) N be min(M, result_last - result).
2 Preconditions: The ranges[first1,last1) and [first2,last2) are sorted with respect tocomp and
proj1 or proj2, respectively. The resulting range does not overlap with either of the original ranges.
3 Effects: Constructs a sorted symmetric difference of the elements from the two ranges; that is, the set
of elements that are present in exactly one of[first1,last1) and [first2,last2). If [first1,last1)
contains melements that are equivalent to each other and[first2,last2) contains nelements that are
equivalent to them, then|m−n|of those elements are included in the symmetric difference: the last
m−nof these elements from[first1,last1), in order, ifm>n , and the lastn−mof these elements
from [first2,last2), in order, ifm<n . If N <M, a non-copied element is consideredskipped if it
compares less than or equivalent to the(N + 1)th element of the sorted symmetric difference, unless it
is from the same range as that element and does not precede it. Copies the firstN elements of the
sorted symmetric difference to the range[result,result + N).
4 Returns:
§ 26.8.7.6 © ISO/IEC
1534

===== PAGE 1546 =====

Dxxxx
—(4.1) result_last for the overloads in namespacestd.
—(4.2) {last1, last2, result + N} for the overloads in namespaceranges, ifN is equal toM + K.
—(4.3) Otherwise, {first1 + A, first2 + B, result_last} for the overloads in namespaceranges,
where A and B are the numbers of copied or skipped elements in[first1,last1) and [first2,
last2), respectively.
5 Complexity: At most2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons and applica-
tions of each projection.
6 Remarks: Stable (16.4.6.8).
26.8.8 Heap operations [alg.heap.operations]
26.8.8.1 General [alg.heap.operations.general]
1 A random access range[a,b) is aheap with respect tocomp and proj for a comparator and projectioncomp
and proj if its elements are organized such that:
—(1.1) With N = b - a, for all i, 0 < i < N, bool(invoke(comp, invoke(proj, a[
⌊i−1
2
⌋
]), invoke(
proj, a[i]))) is false.
—(1.2) *a may be removed bypop_heap, or a new element added bypush_heap, inO(log N) time.
2 These properties make heaps useful as priority queues.
3 make_heap converts a range into a heap andsort_heap turns a heap into a sorted sequence.
26.8.8.2 push_heap [push.heap]
template<class RandomAccessIterator>
constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
ranges::push_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::push_heap(R&& r, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: The range[first,last - 1) is a valid heap with respect tocomp and proj. For the
overloads in namespacestd, RandomAccessIterator meets theCpp17ValueSwappablerequirements
(16.4.4.3) and the type of*first meets theCpp17MoveConstructible requirements (Table 31) and the
Cpp17MoveAssignable requirements (Table 33).
3 Effects: Places the value in the locationlast - 1 into the resulting heap[first,last).
4 Returns: last for the overloads in namespaceranges.
5 Complexity: At mostlog(last - first) comparisons and twice as many projections.
26.8.8.3 pop_heap [pop.heap]
template<class RandomAccessIterator>
constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
§ 26.8.8.3 © ISO/IEC
1535

===== PAGE 1547 =====

Dxxxx
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
ranges::pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::pop_heap(R&& r, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: The range [first,last) is a valid non-empty heap with respect tocomp and proj.
For the overloads in namespacestd, RandomAccessIterator meets the Cpp17ValueSwappable re-
quirements (16.4.4.3) and the type of*first meets the Cpp17MoveConstructible (Table 31) and
Cpp17MoveAssignable (Table 33) requirements.
3 Effects: Swaps the value in the locationfirst with the value in the locationlast - 1 and makes
[first,last - 1) into a heap with respect tocomp and proj.
4 Returns: last for the overloads in namespaceranges.
5 Complexity: At most2 log(last - first) comparisons and twice as many projections.
26.8.8.4 make_heap [make.heap]
template<class RandomAccessIterator>
constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
ranges::make_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::make_heap(R&& r, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: Fortheoverloadsinnamespace std, RandomAccessIteratormeetsthe Cpp17ValueSwap-
pable requirements (16.4.4.3) and the type of*first meets theCpp17MoveConstructible (Table 31)
and Cpp17MoveAssignable (Table 33) requirements.
3 Effects: Constructs a heap with respect tocomp and proj out of the range[first,last).
4 Returns: last for the overloads in namespaceranges.
5 Complexity: At most3(last - first) comparisons and twice as many projections.
26.8.8.5 sort_heap [sort.heap]
template<class RandomAccessIterator>
constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<random_access_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr I
ranges::sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
§ 26.8.8.5 © ISO/IEC
1536

===== PAGE 1548 =====

Dxxxx
template<random_access_range R, class Comp = ranges::less, class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr borrowed_iterator_t<R>
ranges::sort_heap(R&& r, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
2 Preconditions: The range[first,last) is a valid heap with respect tocomp and proj. For the overloads
in namespacestd, RandomAccessIterator meets theCpp17ValueSwappable requirements (16.4.4.3)
and the type of*first meets the Cpp17MoveConstructible (Table 31) andCpp17MoveAssignable
(Table 33) requirements.
3 Effects: Sorts elements in the heap[first,last) with respect tocomp and proj.
4 Returns: last for the overloads in namespaceranges.
5 Complexity: At most2Nlog N comparisons, whereN = last - first, and twice as many projections.
26.8.8.6 is_heap [is.heap]
template<class RandomAccessIterator>
constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
1 Effects: Equivalent to:return is_heap_until(first, last) == last;
template<class ExecutionPolicy, class RandomAccessIterator>
bool is_heap(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last);
2 Effects: Equivalent to:
return is_heap_until(std::forward<ExecutionPolicy>(exec), first, last) == last;
template<class RandomAccessIterator, class Compare>
constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
3 Effects: Equivalent to:return is_heap_until(first, last, comp) == last;
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
bool is_heap(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
4 Effects: Equivalent to:
return is_heap_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last;
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr bool ranges::is_heap(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr bool ranges::is_heap(R&& r, Comp comp = {}, Proj proj = {});
5 Effects: Equivalent to:return ranges::is_heap_until(first, last, comp, proj) == last;
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
bool ranges::is_heap(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
bool ranges::is_heap(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
6 Effects: Equivalent to:
return ranges::is_heap_until(std::forward<Ep>(exec), first, last, comp, proj) == last;
template<class RandomAccessIterator>
constexpr RandomAccessIterator
is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
§ 26.8.8.6 © ISO/IEC
1537

===== PAGE 1549 =====

Dxxxx
template<class ExecutionPolicy, class RandomAccessIterator>
RandomAccessIterator
is_heap_until(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class Compare>
constexpr RandomAccessIterator
is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
RandomAccessIterator
is_heap_until(ExecutionPolicy&& exec,
RandomAccessIterator first, RandomAccessIterator last,
Compare comp);
template<random_access_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I ranges::is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
template<random_access_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
ranges::is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I ranges::is_heap_until(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
ranges::is_heap_until(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
7 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
8 Returns: The last iteratori in [first,last] for which the range[first,i) is a heap with respect to
comp and proj.
9 Complexity: Linear.
26.8.9 Minimum and maximum [alg.min.max]
template<class T>
constexpr const T& min(const T& a, const T& b);
template<class T, class Compare>
constexpr const T& min(const T& a, const T& b, Compare comp);
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr const T& ranges::min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
1 Preconditions: For the first form,T meets theCpp17LessThanComparablerequirements (Table 29).
2 Returns: The smaller value. Returns the first argument when the arguments are equivalent.
3 Complexity: Exactly one comparison and two applications of the projection, if any.
4 Remarks: An invocation may explicitly specify an argument for the template parameterT of the
overloads in namespacestd.
template<class T>
constexpr T min(initializer_list<T> r);
template<class T, class Compare>
constexpr T min(initializer_list<T> r, Compare comp);
template<copyable T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr T ranges::min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
§ 26.8.9 © ISO/IEC
1538

===== PAGE 1550 =====

Dxxxx
template<input_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
constexpr range_value_t<R>
ranges::min(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
range_value_t<R>
ranges::min(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
5 Preconditions: ranges::distance(r) > 0. For the overloads in namespacestd, T meets theCpp17-
CopyConstructible requirements. Forthefirstform, Tmeetsthe Cpp17LessThanComparablerequirements
(Table 29).
6 Returns: The smallest value in the input range. Returns a copy of the leftmost element when several
elements are equivalent to the smallest.
7 Complexity: Exactly ranges::distance(r) - 1 comparisons and twice as many applications of the
projection, if any.
8 Remarks: An invocation may explicitly specify an argument for the template parameterT of the
overloads in namespacestd.
template<class T>
constexpr const T& max(const T& a, const T& b);
template<class T, class Compare>
constexpr const T& max(const T& a, const T& b, Compare comp);
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr const T& ranges::max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
9 Preconditions: For the first form,T meets theCpp17LessThanComparablerequirements (Table 29).
10 Returns: The larger value. Returns the first argument when the arguments are equivalent.
11 Complexity: Exactly one comparison and two applications of the projection, if any.
12 Remarks: An invocation may explicitly specify an argument for the template parameterT of the
overloads in namespacestd.
template<class T>
constexpr T max(initializer_list<T> r);
template<class T, class Compare>
constexpr T max(initializer_list<T> r, Compare comp);
template<copyable T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr T ranges::max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
constexpr range_value_t<R>
ranges::max(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
range_value_t<R>
ranges::max(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
13 Preconditions: ranges::distance(r) > 0. For the overloads in namespacestd, T meets theCpp17-
CopyConstructible requirements. Forthefirstform, Tmeetsthe Cpp17LessThanComparablerequirements
(Table 29).
14 Returns: The largest value in the input range. Returns a copy of the leftmost element when several
elements are equivalent to the largest.
§ 26.8.9 © ISO/IEC
1539

===== PAGE 1551 =====

Dxxxx
15 Complexity: Exactly ranges::distance(r) - 1 comparisons and twice as many applications of the
projection, if any.
16 Remarks: An invocation may explicitly specify an argument for the template parameterT of the
overloads in namespacestd.
template<class T>
constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
template<class T, class Compare>
constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr ranges::minmax_result<const T&>
ranges::minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
17 Preconditions: For the first form,T meets theCpp17LessThanComparablerequirements (Table 29).
18 Returns: {b, a} if b is smaller thana, and{a, b} otherwise.
19 Complexity: Exactly one comparison and two applications of the projection, if any.
20 Remarks: An invocation may explicitly specify an argument for the template parameterT of the
overloads in namespacestd.
template<class T>
constexpr pair<T, T> minmax(initializer_list<T> t);
template<class T, class Compare>
constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);
template<copyable T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr ranges::minmax_result<T>
ranges::minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
template<input_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
constexpr ranges::minmax_result<range_value_t<R>>
ranges::minmax(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
requires indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
ranges::minmax_result<range_value_t<R>>
ranges::minmax(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
21 Preconditions: ranges::distance(r) > 0. For the overloads in namespacestd, T meets theCpp17-
CopyConstructible requirements. For the first form, typeT meets the Cpp17LessThanComparable
requirements (Table 29).
22 Returns: Let X be the return type. ReturnsX{x, y}, wherex is a copy of the leftmost element with
the smallest value andy a copy of the rightmost element with the largest value in the input range.
23 Complexity: At most(3/2)ranges::distance(r) applications of the corresponding predicate and twice
as many applications of the projection, if any.
24 Remarks: An invocation may explicitly specify an argument for the template parameterT of the
overloads in namespacestd.
template<class ForwardIterator>
constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator min_element(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
Compare comp);
§ 26.8.9 © ISO/IEC
1540

===== PAGE 1552 =====

Dxxxx
template<class ExecutionPolicy, class ForwardIterator, class Compare>
ForwardIterator min_element(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, Compare comp);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I ranges::min_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
ranges::min_element(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I ranges::min_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R,
class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
ranges::min_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
25 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
26 Returns: The first iteratori in the range[first,last) such that for every iteratorj in the range
[first,last),
bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))
is false. Returns last if first == last.
27 Complexity: Exactly max(last - first - 1,0) comparisons and twice as many projections.
template<class ForwardIterator>
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
ForwardIterator max_element(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
ForwardIterator max_element(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
Compare comp);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr I ranges::max_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr borrowed_iterator_t<R>
ranges::max_element(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
I ranges::max_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R,
class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
borrowed_iterator_t<R>
ranges::max_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
28 Let comp be less{} and proj be identity{} for the overloads with no parameters by those names.
§ 26.8.9 © ISO/IEC
1541

===== PAGE 1553 =====

Dxxxx
29 Returns: The first iteratori in the range[first,last) such that for every iteratorj in the range
[first,last),
bool(invoke(comp, invoke(proj, *i), invoke(proj, *j)))
is false. Returns last if first == last.
30 Complexity: Exactly max(last - first - 1,0) comparisons and twice as many projections.
template<class ForwardIterator>
constexpr pair<ForwardIterator, ForwardIterator>
minmax_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
pair<ForwardIterator, ForwardIterator>
minmax_element(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
template<class ForwardIterator, class Compare>
constexpr pair<ForwardIterator, ForwardIterator>
minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
pair<ForwardIterator, ForwardIterator>
minmax_element(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, Compare comp);
template<forward_iterator I, sentinel_for<I> S, class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
constexpr ranges::minmax_element_result<I>
ranges::minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
template<forward_range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
constexpr ranges::minmax_element_result<borrowed_iterator_t<R>>
ranges::minmax_element(R&& r, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, random_access_iterator I, sized_sentinel_for<I> S,
class Proj = identity,
indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
ranges::minmax_element_result<I>
ranges::minmax_element(Ep&& exec, I first, S last, Comp comp = {}, Proj proj = {});
template<execution-policy Ep, sized-random-access-range R, class Proj = identity,
indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
ranges::minmax_element_result<borrowed_iterator_t<R>>
ranges::minmax_element(Ep&& exec, R&& r, Comp comp = {}, Proj proj = {});
31 Returns: {first, first} if [first,last) is empty, otherwise{m, M}, wherem is the first iterator in
[first,last) such that no iterator in the range refers to a smaller element, and whereM is the last
iterator196 in [first,last) such that no iterator in the range refers to a larger element.
32 Complexity: Let N be last - first. At mostmax(
⌊3
2 (N −1)
⌋
,0) comparisons and twice as many
applications of the projection, if any.
26.8.10 Bounded value [alg.clamp]
template<class T>
constexpr const T& clamp(const T& v, const T& lo, const T& hi);
template<class T, class Compare>
constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);
template<class T, class Proj = identity,
indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
constexpr const T&
ranges::clamp(const T& v, const T& lo, const T& hi, Comp comp = {}, Proj proj = {});
1 Let comp be less{} for the overloads with no parametercomp, and letproj be identity{} for the
overloads with no parameterproj.
196) This behavior intentionally differs frommax_element.
§ 26.8.10 © ISO/IEC
1542

===== PAGE 1554 =====

Dxxxx
2 Preconditions: bool(invoke(comp, invoke(proj, hi), invoke(proj, lo))) is false. For the first
form, typeT meets theCpp17LessThanComparablerequirements (Table 29).
3 Returns: lo if bool(invoke(comp, invoke(proj, v), invoke(proj, lo))) is true, hi if bool(
invoke(comp, invoke(proj, hi), invoke(proj, v))) is true, otherwisev.
4 [Note 1: If NaN is avoided,T can be a floating-point type.—end note]
5 Complexity: At most two comparisons and three applications of the projection.
26.8.11 Lexicographical comparison [alg.lex.comparison]
template<class InputIterator1, class InputIterator2>
constexpr bool
lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
bool
lexicographical_compare(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2);
template<class InputIterator1, class InputIterator2, class Compare>
constexpr bool
lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2,
Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class Compare>
bool
lexicographical_compare(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, ForwardIterator2 last2,
Compare comp);
template<input_iterator I1, sentinel_for<I1> S1, input_iterator I2, sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>,
projected<I2, Proj2>> Comp = ranges::less>
constexpr bool
ranges::lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<input_range R1, input_range R2, class Proj1 = identity,
class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
constexpr bool
ranges::lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, random_access_iterator I1, sized_sentinel_for<I1> S1,
random_access_iterator I2, sized_sentinel_for<I2> S2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<I1, Proj1>,
projected<I2, Proj2>> Comp = ranges::less>
bool ranges::lexicographical_compare(Ep&& exec, I1 first1, S1 last1, I2 first2, S2 last2,
Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<execution-policy Ep, sized-random-access-range R1, sized-random-access-range R2,
class Proj1 = identity, class Proj2 = identity,
indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
bool ranges::lexicographical_compare(Ep&& exec, R1&& r1, R2&& r2, Comp comp = {},
Proj1 proj1 = {}, Proj2 proj2 = {});
1 Returns: true if and only if the sequence of elements defined by the range[first1,last1) is lexico-
graphically less than the sequence of elements defined by the range[first2,last2).
§ 26.8.11 © ISO/IEC
1543

===== PAGE 1555 =====

Dxxxx
2 Complexity: At most 2 min(last1 - first1, last2 - first2) applications of the corresponding
comparison and each projection, if any.
3 Remarks: If two sequences have the same number of elements and their corresponding elements (if
any) are equivalent, then neither sequence is lexicographically less than the other. If one sequence is a
proper prefix of the other, then the shorter sequence is lexicographically less than the longer sequence.
Otherwise, the lexicographical comparison of the sequences yields the same result as the comparison of
the first corresponding pair of elements that are not equivalent.
4 [Example 1: ranges::lexicographical_compare(I1, S1, I2, S2, Comp, Proj1, Proj2) can be implemen-
ted as:
for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
if (invoke(comp, invoke(proj1, *first1), invoke(proj2, *first2))) return true;
if (invoke(comp, invoke(proj2, *first2), invoke(proj1, *first1))) return false;
}
return first1 == last1 && first2 != last2;
—end example]
5 [Note 1: An empty sequence is lexicographically less than any non-empty sequence, but not less than any empty
sequence. —end note]
26.8.12 Three-way comparison algorithms [alg.three.way]
template<class InputIterator1, class InputIterator2, class Cmp>
constexpr auto
lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
InputIterator2 b2, InputIterator2 e2,
Cmp comp)
-> decltype(comp(*b1, *b2));
1 Let N be min(e1 - b1,e2 - b2). Let E(n) be comp(*(b1 + n), *(b2 + n)).
2 Mandates: decltype(comp(*b1, *b2)) is a comparison category type.
3 Returns: E(i), whereiis the smallest integer in[0,N) such thatE(i) != 0 is true, or(e1 - b1) <=>
(e2 - b2) if no such integer exists.
4 Complexity: At mostN applications ofcomp.
template<class InputIterator1, class InputIterator2>
constexpr auto
lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
InputIterator2 b2, InputIterator2 e2);
5 Effects: Equivalent to:
return lexicographical_compare_three_way(b1, e1, b2, e2, compare_three_way());
26.8.13 Permutation generators [alg.permutation.generators]
template<class BidirectionalIterator>
constexpr bool next_permutation(BidirectionalIterator first,
BidirectionalIterator last);
template<class BidirectionalIterator, class Compare>
constexpr bool next_permutation(BidirectionalIterator first,
BidirectionalIterator last, Compare comp);
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr ranges::next_permutation_result<I>
ranges::next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
§ 26.8.13 © ISO/IEC
1544

===== PAGE 1556 =====

Dxxxx
template<bidirectional_range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr ranges::next_permutation_result<borrowed_iterator_t<R>>
ranges::next_permutation(R&& r, Comp comp = {}, Proj proj = {});
1 Let comp be less{} and proj be identity{} for overloads with no parameters by those names.
2 Preconditions: For the overloads in namespacestd, BidirectionalIterator meets theCpp17Value-
Swappable requirements (16.4.4.3).
3 Effects: Takes a sequence defined by the range[first,last) and transforms it into the next permutation.
The next permutation is found by assuming that the set of all permutations is lexicographically sorted
with respect tocomp and proj. If no such permutation exists, transforms the sequence into the first
permutation; that is, the ascendingly-sorted one.
4 Returns: Let B be true if a next permutation was found and otherwisefalse. Returns:
—(4.1) B for the overloads in namespacestd.
—(4.2) { last, B } for the overloads in namespaceranges.
5 Complexity: At most(last - first) / 2 swaps.
template<class BidirectionalIterator>
constexpr bool prev_permutation(BidirectionalIterator first,
BidirectionalIterator last);
template<class BidirectionalIterator, class Compare>
constexpr bool prev_permutation(BidirectionalIterator first,
BidirectionalIterator last, Compare comp);
template<bidirectional_iterator I, sentinel_for<I> S, class Comp = ranges::less,
class Proj = identity>
requires sortable<I, Comp, Proj>
constexpr ranges::prev_permutation_result<I>
ranges::prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
template<bidirectional_range R, class Comp = ranges::less,
class Proj = identity>
requires sortable<iterator_t<R>, Comp, Proj>
constexpr ranges::prev_permutation_result<borrowed_iterator_t<R>>
ranges::prev_permutation(R&& r, Comp comp = {}, Proj proj = {});
6 Let comp be less{} and proj be identity{} for overloads with no parameters by those names.
7 Preconditions: For the overloads in namespacestd, BidirectionalIterator meets theCpp17Value-
Swappable requirements (16.4.4.3).
8 Effects: Takes a sequence defined by the range[first,last) and transforms it into the previous
permutation. The previous permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect tocomp and proj. If no such permutation exists, transforms the
sequence into the last permutation; that is, the descendingly-sorted one.
9 Returns: Let B be true if a previous permutation was found and otherwisefalse. Returns:
—(9.1) B for the overloads in namespacestd.
—(9.2) { last, B } for the overloads in namespaceranges.
10 Complexity: At most(last - first) / 2 swaps.
26.9 Header <numeric> synopsis [numeric.ops.overview]
// mostly freestanding
namespace std {
// 26.10.3, accumulate
template<class InputIterator, class T>
constexpr T accumulate(InputIterator first, InputIterator last, T init);
template<class InputIterator, class T, class BinaryOperation>
constexpr T accumulate(InputIterator first, InputIterator last, T init,
BinaryOperation binary_op);
§ 26.9 © ISO/IEC
1545

===== PAGE 1557 =====

Dxxxx
// 26.10.4, reduce
template<class InputIterator>
constexpr typename iterator_traits<InputIterator>::value_type
reduce(InputIterator first, InputIterator last);
template<class InputIterator, class T>
constexpr T reduce(InputIterator first, InputIterator last, T init);
template<class InputIterator, class T, class BinaryOperation>
constexpr T reduce(InputIterator first, InputIterator last, T init,
BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator>
typename iterator_traits<ForwardIterator>::value_type
reduce(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator, class T>
T reduce(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, T init);
template<class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation>
T reduce(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, T init, BinaryOperation binary_op);
// 26.10.5, inner product
template<class InputIterator1, class InputIterator2, class T>
constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, T init);
template<class InputIterator1, class InputIterator2, class T,
class BinaryOperation1, class BinaryOperation2>
constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, T init,
BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);
// 26.10.6, transform reduce
template<class InputIterator1, class InputIterator2, class T>
constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, T init);
template<class InputIterator1, class InputIterator2, class T,
class BinaryOperation1, class BinaryOperation2>
constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, T init,
BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);
template<class InputIterator, class T,
class BinaryOperation, class UnaryOperation>
constexpr T transform_reduce(InputIterator first, InputIterator last, T init,
BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2, class T>
T transform_reduce(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, T init);
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2, class T,
class BinaryOperation1, class BinaryOperation2>
T transform_reduce(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2, T init,
BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);
template<class ExecutionPolicy, class ForwardIterator, class T,
class BinaryOperation, class UnaryOperation>
T transform_reduce(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator first, ForwardIterator last, T init,
BinaryOperation binary_op, UnaryOperation unary_op);
§ 26.9 © ISO/IEC
1546

===== PAGE 1558 =====

Dxxxx
// 26.10.7, partial sum
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
partial_sum(InputIterator first, InputIterator last,
OutputIterator result);
template<class InputIterator, class OutputIterator, class BinaryOperation>
constexpr OutputIterator
partial_sum(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op);
// 26.10.8, exclusive scan
template<class InputIterator, class OutputIterator, class T>
constexpr OutputIterator
exclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, T init);
template<class InputIterator, class OutputIterator, class T, class BinaryOperation>
constexpr OutputIterator
exclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, T init, BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
ForwardIterator2
exclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, T init);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T,
class BinaryOperation>
ForwardIterator2
exclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, T init, BinaryOperation binary_op);
// 26.10.9, inclusive scan
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result);
template<class InputIterator, class OutputIterator, class BinaryOperation>
constexpr OutputIterator
inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op);
template<class InputIterator, class OutputIterator, class BinaryOperation, class T>
constexpr OutputIterator
inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op, T init);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
inclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryOperation>
ForwardIterator2
inclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryOperation, class T>
ForwardIterator2
inclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryOperation binary_op, T init);
§ 26.9 © ISO/IEC
1547

===== PAGE 1559 =====

Dxxxx
// 26.10.10, transform exclusive scan
template<class InputIterator, class OutputIterator, class T,
class BinaryOperation, class UnaryOperation>
constexpr OutputIterator
transform_exclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, T init,
BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T,
class BinaryOperation, class UnaryOperation>
ForwardIterator2
transform_exclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, T init,
BinaryOperation binary_op, UnaryOperation unary_op);
// 26.10.11, transform inclusive scan
template<class InputIterator, class OutputIterator,
class BinaryOperation, class UnaryOperation>
constexpr OutputIterator
transform_inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result,
BinaryOperation binary_op, UnaryOperation unary_op);
template<class InputIterator, class OutputIterator,
class BinaryOperation, class UnaryOperation, class T>
constexpr OutputIterator
transform_inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result,
BinaryOperation binary_op, UnaryOperation unary_op, T init);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryOperation, class UnaryOperation>
ForwardIterator2
transform_inclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryOperation binary_op,
UnaryOperation unary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryOperation, class UnaryOperation, class T>
ForwardIterator2
transform_inclusive_scan(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result,
BinaryOperation binary_op, UnaryOperation unary_op, T init);
// 26.10.12, adjacent difference
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
adjacent_difference(InputIterator first, InputIterator last,
OutputIterator result);
template<class InputIterator, class OutputIterator, class BinaryOperation>
constexpr OutputIterator
adjacent_difference(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
adjacent_difference(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryOperation>
ForwardIterator2
adjacent_difference(ExecutionPolicy&& exec, // freestanding-deleted, see 26.3.5
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryOperation binary_op);
§ 26.9 © ISO/IEC
1548

===== PAGE 1560 =====

Dxxxx
// 26.10.13, iota
template<class ForwardIterator, class T>
constexpr void iota(ForwardIterator first, ForwardIterator last, T value);
namespace ranges {
template<class O, class T>
using iota_result = out_value_result<O, T>;
template<input_or_output_iterator O, sentinel_for<O> S, weakly_incrementable T>
requires indirectly_writable<O, const T&>
constexpr iota_result<O, T> iota(O first, S last, T value);
template<weakly_incrementable T, output_range<const T&> R>
constexpr iota_result<borrowed_iterator_t<R>, T> iota(R&& r, T value);
}
// 26.10.14, greatest common divisor
template<class M, class N>
constexpr common_type_t<M, N> gcd(M m, N n);
// 26.10.15, least common multiple
template<class M, class N>
constexpr common_type_t<M, N> lcm(M m, N n);
// 26.10.16, midpoint
template<class T>
constexpr T midpoint(T a, T b) noexcept;
template<class T>
constexpr T* midpoint(T* a, T* b);
// 26.10.17, saturation arithmetic
template<class T>
constexpr T add_sat(T x, T y) noexcept;
template<class T>
constexpr T sub_sat(T x, T y) noexcept;
template<class T>
constexpr T mul_sat(T x, T y) noexcept;
template<class T>
constexpr T div_sat(T x, T y) noexcept;
template<class T, class U>
constexpr T saturate_cast(U x) noexcept;
}
26.10 Generalized numeric operations [numeric.ops]
26.10.1 General [numeric.ops.general]
1 [Note 1: The use of closed ranges as well as semi-open ranges to specify requirements throughout 26.10 is intentional.
—end note]
26.10.2 Definitions [numerics.defns]
1 Define GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ... , aN) as follows:
—(1.1) a1 when N is 1, otherwise
—(1.2) op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ... , aK),
GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, ... , aN)) for anyK where 1 <K + 1 = M ≤N.
2 Define GENERALIZED_SUM(op, a1, ... , aN) as GENERALIZED_NONCOMMUTATIVE_SUM(op, b1, ... , bN),
where b1, ... , bN may be any permutation ofa1, ... , aN.
26.10.3 Accumulate [accumulate]
template<class InputIterator, class T>
constexpr T accumulate(InputIterator first, InputIterator last, T init);
§ 26.10.3 © ISO/IEC
1549

===== PAGE 1561 =====

Dxxxx
template<class InputIterator, class T, class BinaryOperation>
constexpr T accumulate(InputIterator first, InputIterator last, T init,
BinaryOperation binary_op);
1 Preconditions: T meets theCpp17CopyConstructible (Table 32) andCpp17CopyAssignable (Table 34)
requirements. In the range[first,last], binary_op neither modifies elements nor invalidates iterators
or subranges.197
2 Effects: Computes its result by initializing the accumulatoracc with the initial valueinit and then
modifies it withacc = std::move(acc) + *i or acc = binary_op(std::move(acc), *i) for every
iterator i in the range[first,last) in order.198
26.10.4 Reduce [reduce]
template<class InputIterator>
constexpr typename iterator_traits<InputIterator>::value_type
reduce(InputIterator first, InputIterator last);
1 Effects: Equivalent to:
return reduce(first, last,
typename iterator_traits<InputIterator>::value_type{});
template<class ExecutionPolicy, class ForwardIterator>
typename iterator_traits<ForwardIterator>::value_type
reduce(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last);
2 Effects: Equivalent to:
return reduce(std::forward<ExecutionPolicy>(exec), first, last,
typename iterator_traits<ForwardIterator>::value_type{});
template<class InputIterator, class T>
constexpr T reduce(InputIterator first, InputIterator last, T init);
3 Effects: Equivalent to:
return reduce(first, last, init, plus<>());
template<class ExecutionPolicy, class ForwardIterator, class T>
T reduce(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, T init);
4 Effects: Equivalent to:
return reduce(std::forward<ExecutionPolicy>(exec), first, last, init, plus<>());
template<class InputIterator, class T, class BinaryOperation>
constexpr T reduce(InputIterator first, InputIterator last, T init,
BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator, class T, class BinaryOperation>
T reduce(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last, T init,
BinaryOperation binary_op);
5 Mandates: All of
—(5.1) binary_op(init, *first),
—(5.2) binary_op(*first, init),
—(5.3) binary_op(init, init), and
—(5.4) binary_op(*first, *first)
are convertible toT.
6 Preconditions:
—(6.1) T meets theCpp17MoveConstructible (Table 31) requirements.
197) The use of fully closed ranges is intentional.
198) accumulate is similar to the APL reduction operator and Common Lisp reduce function, but it avoids the difficulty of
defining the result of reduction on an empty sequence by always requiring an initial value.
§ 26.10.4 © ISO/IEC
1550

===== PAGE 1562 =====

Dxxxx
—(6.2) binary_op neither invalidates iterators or subranges, nor modifies elements in the range[first,
last].
7 Returns: GENERALIZED_SUM(binary_op, init, *i, ... ) for everyi in [first,last).
8 Complexity: O(last - first) applications ofbinary_op.
9 [Note 1: The difference betweenreduce and accumulate is thatreduce applies binary_op in an unspecified
order, which yields a nondeterministic result for non-associative or non-commutativebinary_op such as
floating-point addition. —end note]
26.10.5 Inner product [inner.product]
template<class InputIterator1, class InputIterator2, class T>
constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, T init);
template<class InputIterator1, class InputIterator2, class T,
class BinaryOperation1, class BinaryOperation2>
constexpr T inner_product(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, T init,
BinaryOperation1 binary_op1,
BinaryOperation2 binary_op2);
1 Preconditions: T meets theCpp17CopyConstructible (Table 32) andCpp17CopyAssignable (Table 34)
requirements. In the ranges[first1,last1] and [first2,first2 + (last1 - first1)] binary_op1
and binary_op2 neither modifies elements nor invalidates iterators or subranges.199
2 Effects: Computes its result by initializing the accumulatoracc with the initial valueinit and then
modifying it withacc = std::move(acc) + (*i1) * (*i2)or acc = binary_op1(std::move(acc),
binary_op2(*i1, *i2)) for every iteratori1 in the range[first1,last1) and iteratori2 in the range
[first2,first2 + (last1 - first1)) in order.
26.10.6 Transform reduce [transform.reduce]
template<class InputIterator1, class InputIterator2, class T>
constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2,
T init);
1 Effects: Equivalent to:
return transform_reduce(first1, last1, first2, init, plus<>(), multiplies<>());
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2, class T>
T transform_reduce(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2,
T init);
2 Effects: Equivalent to:
return transform_reduce(std::forward<ExecutionPolicy>(exec),
first1, last1, first2, init, plus<>(), multiplies<>());
template<class InputIterator1, class InputIterator2, class T,
class BinaryOperation1, class BinaryOperation2>
constexpr T transform_reduce(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2,
T init,
BinaryOperation1 binary_op1,
BinaryOperation2 binary_op2);
199) The use of fully closed ranges is intentional.
§ 26.10.6 © ISO/IEC
1551

===== PAGE 1563 =====

Dxxxx
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2, class T,
class BinaryOperation1, class BinaryOperation2>
T transform_reduce(ExecutionPolicy&& exec,
ForwardIterator1 first1, ForwardIterator1 last1,
ForwardIterator2 first2,
T init,
BinaryOperation1 binary_op1,
BinaryOperation2 binary_op2);
3 Mandates: All of
—(3.1) binary_op1(init, init),
—(3.2) binary_op1(init, binary_op2(*first1, *first2)),
—(3.3) binary_op1(binary_op2(*first1, *first2), init), and
—(3.4) binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))
are convertible toT.
4 Preconditions:
—(4.1) T meets theCpp17MoveConstructible (Table 31) requirements.
—(4.2) Neither binary_op1 nor binary_op2 invalidates subranges, nor modifies elements in the ranges
[first1,last1] and [first2,first2 + (last1 - first1)].
5 Returns:
GENERALIZED_SUM(binary_op1, init, binary_op2(*i, *(first2 + (i - first1))), ... )
for every iteratori in [first1,last1).
6 Complexity: O(last1 - first1) applications each ofbinary_op1 and binary_op2.
template<class InputIterator, class T,
class BinaryOperation, class UnaryOperation>
constexpr T transform_reduce(InputIterator first, InputIterator last, T init,
BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy,
class ForwardIterator, class T,
class BinaryOperation, class UnaryOperation>
T transform_reduce(ExecutionPolicy&& exec,
ForwardIterator first, ForwardIterator last,
T init, BinaryOperation binary_op, UnaryOperation unary_op);
7 Mandates: All of
—(7.1) binary_op(init, init),
—(7.2) binary_op(init, unary_op(*first)),
—(7.3) binary_op(unary_op(*first), init), and
—(7.4) binary_op(unary_op(*first), unary_op(*first))
are convertible toT.
8 Preconditions:
—(8.1) T meets theCpp17MoveConstructible (Table 31) requirements.
—(8.2) Neither unary_op nor binary_op invalidates subranges, nor modifies elements in the range
[first,last].
9 Returns:
GENERALIZED_SUM(binary_op, init, unary_op(*i), ... )
for every iteratori in [first,last).
10 Complexity: O(last - first) applications each ofunary_op and binary_op.
11 [Note 1: transform_reduce does not applyunary_op to init. —end note]
§ 26.10.6 © ISO/IEC
1552

===== PAGE 1564 =====

Dxxxx
26.10.7 Partial sum [partial.sum]
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
partial_sum(InputIterator first, InputIterator last,
OutputIterator result);
template<class InputIterator, class OutputIterator, class BinaryOperation>
constexpr OutputIterator
partial_sum(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op);
1 Mandates: InputIterator’s value type is constructible from*first. The result of the expression
std::move(acc) + *i or binary_op(std::move(acc), *i) is implicitly convertible toInputItera-
tor’s value type.acc is writable (24.3.1) toresult.
2 Preconditions: In the ranges[first,last] and [result,result + (last - first)] binary_opneither
modifies elements nor invalidates iterators or subranges.200
3 Effects: For a non-empty range, the function creates an accumulatoracc whose type isInputIterator’s
value type, initializes it with*first, and assigns the result to*result. For every iterator i in
[first + 1,last) in order,acc is then modified byacc = std::move(acc) + *i or acc = binary_-
op(std::move(acc), *i) and the result is assigned to*(result + (i - first)).
4 Returns: result + (last - first).
5 Complexity: Exactly (last - first) - 1 applications of the binary operation.
6 Remarks: result may be equal tofirst.
26.10.8 Exclusive scan [exclusive.scan]
template<class InputIterator, class OutputIterator, class T>
constexpr OutputIterator
exclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, T init);
1 Effects: Equivalent to:
return exclusive_scan(first, last, result, init, plus<>());
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
ForwardIterator2
exclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, T init);
2 Effects: Equivalent to:
return exclusive_scan(std::forward<ExecutionPolicy>(exec),
first, last, result, init, plus<>());
template<class InputIterator, class OutputIterator, class T, class BinaryOperation>
constexpr OutputIterator
exclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, T init, BinaryOperation binary_op);
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2, class T, class BinaryOperation>
ForwardIterator2
exclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, T init, BinaryOperation binary_op);
3 Mandates: All of
—(3.1) binary_op(init, init),
—(3.2) binary_op(init, *first), and
—(3.3) binary_op(*first, *first)
200) The use of fully closed ranges is intentional.
§ 26.10.8 © ISO/IEC
1553

===== PAGE 1565 =====

Dxxxx
are convertible toT.
4 Preconditions:
—(4.1) T meets theCpp17MoveConstructible (Table 31) requirements.
—(4.2) binary_op neither invalidates iterators or subranges, nor modifies elements in the ranges[first,
last] or [result,result + (last - first)].
5 Effects: For each integerK in [0,last - first) assigns throughresult + K the value of:
GENERALIZED_NONCOMMUTATIVE_SUM(
binary_op, init, *(first + 0), *(first + 1), ... , *(first + K - 1))
6 Returns: The end of the resulting range beginning atresult.
7 Complexity: O(last - first) applications ofbinary_op.
8 Remarks: result may be equal tofirst.
9 [Note 1: The difference betweenexclusive_scan and inclusive_scan is thatexclusive_scan excludes theith
input element from theith sum. If binary_op is not mathematically associative, the behavior ofexclusive_scan
can be nondeterministic. —end note]
26.10.9 Inclusive scan [inclusive.scan]
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result);
1 Effects: Equivalent to:
return inclusive_scan(first, last, result, plus<>());
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
inclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result);
2 Effects: Equivalent to:
return inclusive_scan(std::forward<ExecutionPolicy>(exec), first, last, result, plus<>());
template<class InputIterator, class OutputIterator, class BinaryOperation>
constexpr OutputIterator
inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryOperation>
ForwardIterator2
inclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryOperation binary_op);
template<class InputIterator, class OutputIterator, class BinaryOperation, class T>
constexpr OutputIterator
inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op, T init);
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2, class BinaryOperation, class T>
ForwardIterator2
inclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryOperation binary_op, T init);
3 Let U be the value type ofdecltype(first).
4 Mandates: If init is provided, all of
—(4.1) binary_op(init, init),
—(4.2) binary_op(init, *first), and
§ 26.10.9 © ISO/IEC
1554

===== PAGE 1566 =====

Dxxxx
—(4.3) binary_op(*first, *first)
are convertible toT; otherwise,binary_op(*first, *first) is convertible toU.
5 Preconditions:
—(5.1) If init is provided,T meets theCpp17MoveConstructible (Table 31) requirements; otherwise,U
meets theCpp17MoveConstructible requirements.
—(5.2) binary_op neither invalidates iterators or subranges, nor modifies elements in the ranges[first,
last] or [result,result + (last - first)].
6 Effects: For each integerK in [0,last - first) assigns throughresult + K the value of
—(6.1) GENERALIZED_NONCOMMUTATIVE_SUM(
binary_op, init, *(first + 0), *(first + 1), ... , *(first + K))
if init is provided, or
—(6.2) GENERALIZED_NONCOMMUTATIVE_SUM(
binary_op, *(first + 0), *(first + 1), ... , *(first + K))
otherwise.
7 Returns: The end of the resulting range beginning atresult.
8 Complexity: O(last - first) applications ofbinary_op.
9 Remarks: result may be equal tofirst.
10 [Note 1: The difference betweenexclusive_scan and inclusive_scan is thatinclusive_scan includes theith
input element in theith sum. If binary_op is not mathematically associative, the behavior ofinclusive_scan
can be nondeterministic. —end note]
26.10.10 Transform exclusive scan [transform.exclusive.scan]
template<class InputIterator, class OutputIterator, class T,
class BinaryOperation, class UnaryOperation>
constexpr OutputIterator
transform_exclusive_scan(InputIterator first, InputIterator last,
OutputIterator result, T init,
BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2, class T,
class BinaryOperation, class UnaryOperation>
ForwardIterator2
transform_exclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, T init,
BinaryOperation binary_op, UnaryOperation unary_op);
1 Mandates: All of
—(1.1) binary_op(init, init),
—(1.2) binary_op(init, unary_op(*first)), and
—(1.3) binary_op(unary_op(*first), unary_op(*first))
are convertible toT.
2 Preconditions:
—(2.1) T meets theCpp17MoveConstructible (Table 31) requirements.
—(2.2) Neither unary_op nor binary_op invalidates iterators or subranges, nor modifies elements in the
ranges [first,last] or [result,result + (last - first)].
3 Effects: For each integerK in [0,last - first) assigns throughresult + K the value of:
GENERALIZED_NONCOMMUTATIVE_SUM(
binary_op, init,
unary_op(*(first + 0)), unary_op(*(first + 1)), ... , unary_op(*(first + K - 1)))
4 Returns: The end of the resulting range beginning atresult.
5 Complexity: O(last - first) applications each ofunary_op and binary_op.
§ 26.10.10 © ISO/IEC
1555

===== PAGE 1567 =====

Dxxxx
6 Remarks: result may be equal tofirst.
7 [Note 1: The difference betweentransform_exclusive_scan and transform_inclusive_scan is thattrans-
form_exclusive_scan excludes theith input element from theith sum. If binary_op is not mathematically
associative, the behavior oftransform_exclusive_scan can be nondeterministic.transform_exclusive_scan
does not applyunary_op to init. —end note]
26.10.11 Transform inclusive scan [transform.inclusive.scan]
template<class InputIterator, class OutputIterator,
class BinaryOperation, class UnaryOperation>
constexpr OutputIterator
transform_inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result,
BinaryOperation binary_op, UnaryOperation unary_op);
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2,
class BinaryOperation, class UnaryOperation>
ForwardIterator2
transform_inclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result,
BinaryOperation binary_op, UnaryOperation unary_op);
template<class InputIterator, class OutputIterator,
class BinaryOperation, class UnaryOperation, class T>
constexpr OutputIterator
transform_inclusive_scan(InputIterator first, InputIterator last,
OutputIterator result,
BinaryOperation binary_op, UnaryOperation unary_op,
T init);
template<class ExecutionPolicy,
class ForwardIterator1, class ForwardIterator2,
class BinaryOperation, class UnaryOperation, class T>
ForwardIterator2
transform_inclusive_scan(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result,
BinaryOperation binary_op, UnaryOperation unary_op,
T init);
1 Let U be the value type ofdecltype(first).
2 Mandates: If init is provided, all of
—(2.1) binary_op(init, init),
—(2.2) binary_op(init, unary_op(*first)), and
—(2.3) binary_op(unary_op(*first), unary_op(*first))
are convertible toT; otherwise,binary_op(unary_op(*first), unary_op(*first)) is convertible to
U.
3 Preconditions:
—(3.1) If init is provided,T meets theCpp17MoveConstructible (Table 31) requirements; otherwise,U
meets theCpp17MoveConstructible requirements.
—(3.2) Neither unary_op nor binary_op invalidates iterators or subranges, nor modifies elements in the
ranges [first,last] or [result,result + (last - first)].
4 Effects: For each integerK in [0,last - first) assigns throughresult + K the value of
—(4.1) GENERALIZED_NONCOMMUTATIVE_SUM(
binary_op, init,
unary_op(*(first + 0)), unary_op(*(first + 1)), ... , unary_op(*(first + K)))
if init is provided, or
—(4.2) GENERALIZED_NONCOMMUTATIVE_SUM(
binary_op,
§ 26.10.11 © ISO/IEC
1556

===== PAGE 1568 =====

Dxxxx
unary_op(*(first + 0)), unary_op(*(first + 1)), ... , unary_op(*(first + K)))
otherwise.
5 Returns: The end of the resulting range beginning atresult.
6 Complexity: O(last - first) applications each ofunary_op and binary_op.
7 Remarks: result may be equal tofirst.
8 [Note 1: The difference betweentransform_exclusive_scan and transform_inclusive_scan is thattrans-
form_inclusive_scan includes the ith input element in theith sum. If binary_op is not mathematically
associative, the behavior oftransform_inclusive_scan can be nondeterministic.transform_inclusive_scan
does not applyunary_op to init. —end note]
26.10.12 Adjacent difference [adjacent.difference]
template<class InputIterator, class OutputIterator>
constexpr OutputIterator
adjacent_difference(InputIterator first, InputIterator last,
OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
ForwardIterator2
adjacent_difference(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result);
template<class InputIterator, class OutputIterator, class BinaryOperation>
constexpr OutputIterator
adjacent_difference(InputIterator first, InputIterator last,
OutputIterator result, BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
class BinaryOperation>
ForwardIterator2
adjacent_difference(ExecutionPolicy&& exec,
ForwardIterator1 first, ForwardIterator1 last,
ForwardIterator2 result, BinaryOperation binary_op);
1 LetTbe the value type ofdecltype(first). For the overloads that do not take an argumentbinary_op,
let binary_op be an lvalue that denotes an object of typeminus<>.
2 Mandates:
—(2.1) For the overloads with noExecutionPolicy, T is constructible from*first. acc (defined below)
is writable (24.3.1) to theresult output iterator. The result of the expressionbinary_op(val,
std::move(acc)) is writable toresult.
—(2.2) For the overloads with anExecutionPolicy, the result of the expressionsbinary_op(*first,
*first) and *first are writable toresult.
3 Preconditions:
—(3.1) For the overloads with no ExecutionPolicy, T meets the Cpp17MoveAssignable (Table 33)
requirements.
—(3.2) For all overloads, in the ranges[first,last] and [result,result + (last - first)], binary_-
op neither modifies elements nor invalidates iterators or subranges.201
4 Effects: For the overloads with noExecutionPolicy and a non-empty range, the function creates an
accumulator acc of typeT, initializes it with*first, and assigns the result to*result. For every
iterator i in [first + 1,last) in order, creates an objectval whose type isT, initializes it with*i,
computes binary_op(val, std::move(acc)), assigns the result to*(result + (i - first)), and
move assigns fromval to acc.
5 For the overloads with anExecutionPolicy and a non-empty range, performs*result = *first.
Then, for everyd in [1,last - first - 1], performs*(result + d) = binary_op(*(first + d),
*(first + (d - 1))).
6 Returns: result + (last - first).
7 Complexity: Exactly (last - first) - 1 applications of the binary operation.
201) The use of fully closed ranges is intentional.
§ 26.10.12 © ISO/IEC
1557

===== PAGE 1569 =====

Dxxxx
8 Remarks: Fortheoverloadswithno ExecutionPolicy, resultmaybeequal to first. Forthe overloads
with an ExecutionPolicy, the ranges[first,last) and [result,result + (last - first)) shall
not overlap.
26.10.13 Iota [numeric.iota]
template<class ForwardIterator, class T>
constexpr void iota(ForwardIterator first, ForwardIterator last, T value);
1 Mandates: T is convertible toForwardIterator’s value type. The expression++val, whereval has
type T, is well-formed.
2 Effects: For each element referred to by the iteratori in the range[first,last), assigns*i = value
and incrementsvalue as if by++value.
3 Complexity: Exactly last - first increments and assignments.
template<input_or_output_iterator O, sentinel_for<O> S, weakly_incrementable T>
requires indirectly_writable<O, const T&>
constexpr ranges::iota_result<O, T> ranges::iota(O first, S last, T value);
template<weakly_incrementable T, output_range<const T&> R>
constexpr ranges::iota_result<borrowed_iterator_t<R>, T> ranges::iota(R&& r, T value);
4 Effects: Equivalent to:
while (first != last) {
*first = as_const(value);
++first;
++value;
}
return {std::move(first), std::move(value)};
26.10.14 Greatest common divisor [numeric.ops.gcd]
template<class M, class N>
constexpr common_type_t<M, N> gcd(M m, N n);
1 Mandates: M and N both are integer types other thancv bool.
2 Preconditions: |m|and |n|are representable as a value ofcommon_type_t<M, N>.
[Note 1: These requirements ensure, for example, thatgcd(m, m) = |m|is representable as a value of typeM.
—end note]
3 Returns: Zero whenm and n are both zero. Otherwise, returns the greatest common divisor of|m|and
|n|.
4 Throws: Nothing.
26.10.15 Least common multiple [numeric.ops.lcm]
template<class M, class N>
constexpr common_type_t<M, N> lcm(M m, N n);
1 Mandates: M and N both are integer types other thancv bool.
2 Preconditions: |m|and |n|are representable as a value ofcommon_type_t<M, N>. The least common
multiple of|m|and |n|is representable as a value of typecommon_type_t<M, N>.
3 Returns: Zero when eitherm or n is zero. Otherwise, returns the least common multiple of|m|and |n|.
4 Throws: Nothing.
26.10.16 Midpoint [numeric.ops.midpoint]
template<class T>
constexpr T midpoint(T a, T b) noexcept;
1 Constraints: T is an arithmetic type other thancv bool.
2 Returns: Half the sum ofa and b. If T is an integer type and the sum is odd, the result is rounded
towards a.
3 Remarks: No overflow occurs. IfT is a floating-point type, at most one inexact operation occurs.
§ 26.10.16 © ISO/IEC
1558

===== PAGE 1570 =====

Dxxxx
template<class T>
constexpr T* midpoint(T* a, T* b);
4 Constraints: T is an object type.
5 Mandates: T is a complete type.
6 Preconditions: a and b point to, respectively, elementsi and j of the same array objectx.
[Note 1: As specified in 6.9.4, an object that is not an array element is considered to belong to a single-element
array for this purpose and a pointer past the last element of an array ofnelements is considered to be equivalent
to a pointer to a hypothetical array elementn for this purpose. —end note]
7 Returns: A pointer to array elementi+ j−i
2 of x, where the result of the division is truncated towards
zero.
26.10.17 Saturation arithmetic [numeric.sat]
26.10.17.1 Arithmetic functions [numeric.sat.func]
1 In the following descriptions, an arithmetic operation is performed as a mathematical operation with infinite
range and then it is determined whether the mathematical result fits into the result type.
template<class T>
constexpr T add_sat(T x, T y) noexcept;
2 Constraints: T is a signed or unsigned integer type (6.9.2).
3 Returns: If x+ y is representable as a value of typeT, x+ y; otherwise, either the largest or smallest
representable value of typeT, whichever is closer to the value ofx+ y.
template<class T>
constexpr T sub_sat(T x, T y) noexcept;
4 Constraints: T is a signed or unsigned integer type (6.9.2).
5 Returns: If x−y is representable as a value of typeT, x−y; otherwise, either the largest or smallest
representable value of typeT, whichever is closer to the value ofx−y.
template<class T>
constexpr T mul_sat(T x, T y) noexcept;
6 Constraints: T is a signed or unsigned integer type (6.9.2).
7 Returns: If x×y is representable as a value of typeT, x×y; otherwise, either the largest or smallest
representable value of typeT, whichever is closer to the value ofx×y.
template<class T>
constexpr T div_sat(T x, T y) noexcept;
8 Constraints: T is a signed or unsigned integer type (6.9.2).
9 Preconditions: y != 0 is true.
10 Returns: If T is a signed integer type andx == numeric_limits<T>::min() && y == -1 is true,
numeric_limits<T>::max(), otherwise,x / y.
11 Remarks: A function call expression that violates the precondition in thePreconditionselement is not
a core constant expression (7.7).
26.10.17.2 Casting [numeric.sat.cast]
template<class R, class T>
constexpr R saturate_cast(T x) noexcept;
1 Constraints: R and T are signed or unsigned integer types (6.9.2).
2 Returns: Ifxis representable as a value of typeR, x; otherwise, either the largest or smallest representable
value of typeR, whichever is closer to the value ofx.
26.11 Specialized <memory> algorithms [specialized.algorithms]
26.11.1 General [specialized.algorithms.general]
1 The contents specified in 26.11 are declared in the header<memory> (20.2.2).
§ 26.11.1 © ISO/IEC
1559

===== PAGE 1571 =====

Dxxxx
2 Unless otherwise specified, if an exception is thrown in the following algorithms, objects constructed by a
placement new-expression (7.6.2.8) are destroyed in an unspecified order before allowing the exception to
propagate.
3 [Note 1: When new objects are created by the algorithms specified in 26.11, the lifetime ends for any existing objects
(including potentially-overlapping subobjects 6.8.2) in storage that is reused 6.8.4.—end note]
4 Some algorithms specified in 26.11 make use of the following exposition-only function templates:
template<class T>
constexpr void* voidify(T& obj) noexcept {
return addressof(obj);
}
template<class I>
constexpr decltype(auto) deref-move (I& it) {
if constexpr (is_lvalue_reference_v<decltype(*it)>)
return std::move(*it);
else
return *it;
}
26.11.2 Special memory concepts [special.mem.concepts]
1 Some algorithms in this subclause are constrained with the following exposition-only concepts:
template<class I>
concept nothrow-input-iterator = // exposition only
input_iterator<I> &&
is_lvalue_reference_v<iter_reference_t<I>> &&
same_as<remove_cvref_t<iter_reference_t<I>>, iter_value_t<I>>;
2 A typeI models nothrow-input-iterator only if no exceptions are thrown from increment, copy
construction, move construction, copy assignment, move assignment, or indirection through valid
iterators.
3 [Note 1: This concept allows someinput_iterator (24.3.4.9) operations to throw exceptions.—end note]
template<class S, class I>
concept nothrow-sentinel-for = sentinel_for<S, I>; // exposition only
4 Types S and I model nothrow-sentinel-for only if no exceptions are thrown from copy construction,
move construction, copy assignment, move assignment, or comparisons between valid values of typeI
and S.
5 [Note 2: This concept allows somesentinel_for (24.3.4.7) operations to throw exceptions.—end note]
template<class S, class I>
concept nothrow-sized-sentinel-for = // exposition only
nothrow-sentinel-for <S, I> &&
sized_sentinel_for<S, I>;
6 Types S and I model nothrow-sized-sentinel-for only if no exceptions are thrown from the-
operator for valid values of typeI and S.
7 [Note 3: This concept allows somesized_sentinel_for (24.3.4.8) operations to throw exceptions.—end note]
template<class R>
concept nothrow-input-range = // exposition only
range<R> &&
nothrow-input-iterator <iterator_t<R>> &&
nothrow-sentinel-for <sentinel_t<R>, iterator_t<R>>;
8 A typeR models nothrow-input-range only if no exceptions are thrown from calls toranges::begin
and ranges::end on an object of typeR.
§ 26.11.2 © ISO/IEC
1560

===== PAGE 1572 =====

Dxxxx
template<class I>
concept nothrow-forward-iterator = // exposition only
nothrow-input-iterator <I> &&
forward_iterator<I> &&
nothrow-sentinel-for <I, I>;
9 [Note 4: This concept allows someforward_iterator (24.3.4.11) operations to throw exceptions.—end note]
template<class R>
concept nothrow-forward-range = // exposition only
nothrow-input-range <R> &&
nothrow-forward-iterator <iterator_t<R>>;
template<class I>
concept nothrow-bidirectional-iterator = // exposition only
nothrow-forward-iterator <I> &&
bidirectional_iterator<I>;
10 A typeI models nothrow-bidirectional-iterator only if no exceptions are thrown from decrement-
ing valid iterators.
[Note 5: This concept allows somebidirectional_iterator (24.3.4.12) operations to throw exceptions.—end
note]
template<class R>
concept nothrow-bidirectional-range = // exposition only
nothrow-forward-range <R> &&
nothrow-bidirectional-iterator <iterator_t<R>>;
template<class I>
concept nothrow-random-access-iterator = // exposition only
nothrow-bidirectional-iterator <I> &&
random_access_iterator<I> &&
nothrow-sized-sentinel-for <I, I>;
11 A typeImodels nothrow-random-access-iterator only if no exceptions are thrown from comparisons
of valid iterators, or the-, +, -=, +=, [] operators on valid values of typeI and iter_difference_t<I>.
[Note 6: This concept allows somerandom_access_iterator (24.3.4.13) operations to throw exceptions.—end
note]
template<class R>
concept nothrow-random-access-range = // exposition only
nothrow-bidirectional-range <R> &&
nothrow-random-access-iterator <iterator_t<R>>;
template<class R>
concept nothrow-sized-random-access-range = // exposition only
nothrow-random-access-range <R> && sized_range<R>;
12 A typeR models nothrow-sized-random-access-range only if no exceptions are thrown from the
call toranges::size on an object of typeR.
26.11.3 uninitialized_default_construct [uninitialized.construct.default]
template<class NoThrowForwardIterator>
constexpr void uninitialized_default_construct(NoThrowForwardIterator first,
NoThrowForwardIterator last);
1 Effects: Equivalent to:
for (; first != last; ++first)
::new (voidify(*first)) iterator_traits<NoThrowForwardIterator>::value_type;
namespace ranges {
template<nothrow-forward-iterator I, nothrow-sentinel-for <I> S>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_default_construct(I first, S last);
§ 26.11.3 © ISO/IEC
1561

===== PAGE 1573 =====

Dxxxx
template<nothrow-forward-range R>
requires default_initializable<range_value_t<R>>
constexpr borrowed_iterator_t<R> uninitialized_default_construct(R&& r);
}
2 Effects: Equivalent to:
for (; first != last; ++first)
::new (voidify(*first)) remove_reference_t<iter_reference_t<I>>;
return first;
template<class NoThrowForwardIterator, class Size>
constexpr NoThrowForwardIterator
uninitialized_default_construct_n(NoThrowForwardIterator first, Size n);
3 Effects: Equivalent to:
for (; n > 0; (void)++first, --n)
::new (voidify(*first)) iterator_traits<NoThrowForwardIterator>::value_type;
return first;
namespace ranges {
template<nothrow-forward-iterator I>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_default_construct_n(I first, iter_difference_t<I> n);
}
4 Effects: Equivalent to:
return uninitialized_default_construct(counted_iterator(first, n),
default_sentinel).base();
26.11.4 uninitialized_value_construct [uninitialized.construct.value]
template<class NoThrowForwardIterator>
constexpr void uninitialized_value_construct(NoThrowForwardIterator first,
NoThrowForwardIterator last);
1 Effects: Equivalent to:
for (; first != last; ++first)
::new (voidify(*first)) iterator_traits<NoThrowForwardIterator>::value_type();
namespace ranges {
template<nothrow-forward-iterator I, nothrow-sentinel-for <I> S>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_value_construct(I first, S last);
template<nothrow-forward-range R>
requires default_initializable<range_value_t<R>>
constexpr borrowed_iterator_t<R> uninitialized_value_construct(R&& r);
}
2 Effects: Equivalent to:
for (; first != last; ++first)
::new (voidify(*first)) remove_reference_t<iter_reference_t<I>>();
return first;
template<class NoThrowForwardIterator, class Size>
constexpr NoThrowForwardIterator
uninitialized_value_construct_n(NoThrowForwardIterator first, Size n);
3 Effects: Equivalent to:
for (; n > 0; (void)++first, --n)
::new (voidify(*first)) iterator_traits<NoThrowForwardIterator>::value_type();
return first;
§ 26.11.4 © ISO/IEC
1562

===== PAGE 1574 =====

Dxxxx
namespace ranges {
template<nothrow-forward-iterator I>
requires default_initializable<iter_value_t<I>>
constexpr I uninitialized_value_construct_n(I first, iter_difference_t<I> n);
}
4 Effects: Equivalent to:
return uninitialized_value_construct(counted_iterator(first, n),
default_sentinel).base();
26.11.5 uninitialized_copy [uninitialized.copy]
template<class InputIterator, class NoThrowForwardIterator>
constexpr NoThrowForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
NoThrowForwardIterator result);
1 Preconditions: result+ [0, (last - first)) does not overlap with[first,last).
2 Effects: Equivalent to:
for (; first != last; ++result, (void)++first)
::new (voidify(*result)) iterator_traits<NoThrowForwardIterator>::value_type(*first);
3 Returns: result.
namespace ranges {
template<input_iterator I, sentinel_for<I> S1,
nothrow-forward-iterator O, nothrow-sentinel-for <O> S2>
requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
constexpr uninitialized_copy_result<I, O>
uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
template<input_range IR, nothrow-forward-range OR>
requires constructible_from<range_value_t<OR>, range_reference_t<IR>>
constexpr uninitialized_copy_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
uninitialized_copy(IR&& in_range, OR&& out_range);
}
4 Preconditions: [ofirst,olast) does not overlap with[ifirst,ilast).
5 Effects: Equivalent to:
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst)
::new (voidify(*ofirst)) remove_reference_t<iter_reference_t<O>>(*ifirst);
return {std::move(ifirst), ofirst};
template<class InputIterator, class Size, class NoThrowForwardIterator>
constexpr NoThrowForwardIterator uninitialized_copy_n(InputIterator first, Size n,
NoThrowForwardIterator result);
6 Preconditions: result+ [0, n) does not overlap withfirst+ [0, n).
7 Effects: Equivalent to:
for (; n > 0; ++result, (void)++first, --n)
::new (voidify(*result)) iterator_traits<NoThrowForwardIterator>::value_type(*first);
8 Returns: result.
namespace ranges {
template<input_iterator I, nothrow-forward-iterator O, nothrow-sentinel-for <O> S>
requires constructible_from<iter_value_t<O>, iter_reference_t<I>>
constexpr uninitialized_copy_n_result<I, O>
uninitialized_copy_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
9 Preconditions: [ofirst,olast) does not overlap withifirst+ [0, n).
10 Effects: Equivalent to:
auto t = uninitialized_copy(counted_iterator(std::move(ifirst), n),
default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
§ 26.11.5 © ISO/IEC
1563

===== PAGE 1575 =====

Dxxxx
26.11.6 uninitialized_move [uninitialized.move]
template<class InputIterator, class NoThrowForwardIterator>
constexpr NoThrowForwardIterator uninitialized_move(InputIterator first, InputIterator last,
NoThrowForwardIterator result);
1 Preconditions: result+ [0, (last - first)) does not overlap with[first,last).
2 Effects: Equivalent to:
for (; first != last; (void)++result, ++first)
::new (voidify(*result))
iterator_traits<NoThrowForwardIterator>::value_type(deref-move (first));
return result;
namespace ranges {
template<input_iterator I, sentinel_for<I> S1,
nothrow-forward-iterator O, nothrow-sentinel-for <O> S2>
requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
constexpr uninitialized_move_result<I, O>
uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
template<input_range IR, nothrow-forward-range OR>
requires constructible_from<range_value_t<OR>, range_rvalue_reference_t<IR>>
constexpr uninitialized_move_result<borrowed_iterator_t<IR>, borrowed_iterator_t<OR>>
uninitialized_move(IR&& in_range, OR&& out_range);
}
3 Preconditions: [ofirst,olast) does not overlap with[ifirst,ilast).
4 Effects: Equivalent to:
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst)
::new (voidify (*ofirst))
remove_reference_t<iter_reference_t<O>>(ranges::iter_move(ifirst));
return {std::move(ifirst), ofirst};
5 [Note 1: If an exception is thrown, some objects in the range[ifirst,ilast) are left in a valid, but unspecified
state. —end note]
template<class InputIterator, class Size, class NoThrowForwardIterator>
constexpr pair<InputIterator, NoThrowForwardIterator>
uninitialized_move_n(InputIterator first, Size n, NoThrowForwardIterator result);
6 Preconditions: result+ [0, n) does not overlap withfirst+ [0, n).
7 Effects: Equivalent to:
for (; n > 0; ++result, (void)++first, --n)
::new (voidify(*result))
iterator_traits<NoThrowForwardIterator>::value_type(deref-move (first));
return {first, result};
namespace ranges {
template<input_iterator I, nothrow-forward-iterator O, nothrow-sentinel-for <O> S>
requires constructible_from<iter_value_t<O>, iter_rvalue_reference_t<I>>
constexpr uninitialized_move_n_result<I, O>
uninitialized_move_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
8 Preconditions: [ofirst,olast) does not overlap withifirst+ [0, n).
9 Effects: Equivalent to:
auto t = uninitialized_move(counted_iterator(std::move(ifirst), n),
default_sentinel, ofirst, olast);
return {std::move(t.in).base(), t.out};
10 [Note 2: If an exception is thrown, some objects in the rangeifirst + [0, n) are left in a valid but unspecified
state. —end note]
§ 26.11.6 © ISO/IEC
1564

===== PAGE 1576 =====

Dxxxx
26.11.7 uninitialized_fill [uninitialized.fill]
template<class NoThrowForwardIterator, class T>
constexpr void uninitialized_fill(NoThrowForwardIterator first,
NoThrowForwardIterator last, const T& x);
1 Effects: Equivalent to:
for (; first != last; ++first)
::new (voidify(*first)) iterator_traits<NoThrowForwardIterator>::value_type(x);
namespace ranges {
template<nothrow-forward-iterator I, nothrow-sentinel-for <I> S, class T>
requires constructible_from<iter_value_t<I>, const T&>
constexpr I uninitialized_fill(I first, S last, const T& x);
template<nothrow-forward-range R, class T>
requires constructible_from<range_value_t<R>, const T&>
constexpr borrowed_iterator_t<R> uninitialized_fill(R&& r, const T& x);
}
2 Effects: Equivalent to:
for (; first != last; ++first)
::new (voidify(*first)) remove_reference_t<iter_reference_t<I>>(x);
return first;
template<class NoThrowForwardIterator, class Size, class T>
constexpr NoThrowForwardIterator
uninitialized_fill_n(NoThrowForwardIterator first, Size n, const T& x);
3 Effects: Equivalent to:
for (; n--; ++first)
::new (voidify(*first)) iterator_traits<NoThrowForwardIterator>::value_type(x);
return first;
namespace ranges {
template<nothrow-forward-iterator I, class T>
requires constructible_from<iter_value_t<I>, const T&>
constexpr I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);
}
4 Effects: Equivalent to:
return uninitialized_fill(counted_iterator(first, n), default_sentinel, x).base();
26.11.8 construct_at [specialized.construct]
template<class T, class... Args>
constexpr T* construct_at(T* location, Args&&... args);
namespace ranges {
template<class T, class... Args>
constexpr T* construct_at(T* location, Args&&... args);
}
1 Constraints: is_unbounded_array_v<T> is false. The expression ::new (declval<void*>()) T(
declval<Args>()...) is well-formed when treated as an unevaluated operand (7.2.3).
2 Mandates: If is_array_v<T> is true, sizeof...(Args) is zero.
3 Effects: Equivalent to:
if constexpr (is_array_v<T>)
return ::new (voidify(*location)) T[1]();
else
return ::new (voidify(*location)) T(std::forward<Args>(args)...);
26.11.9 destroy [specialized.destroy]
template<class T>
constexpr void destroy_at(T* location);
§ 26.11.9 © ISO/IEC
1565

===== PAGE 1577 =====

Dxxxx
namespace ranges {
template<destructible T>
constexpr void destroy_at(T* location) noexcept;
}
1 Effects:
—(1.1) If T is an array type, equivalent todestroy(begin(*location), end(*location)).
—(1.2) Otherwise, equivalent tolocation->~T().
template<class NoThrowForwardIterator>
constexpr void destroy(NoThrowForwardIterator first, NoThrowForwardIterator last);
2 Effects: Equivalent to:
for (; first != last; ++first)
destroy_at(addressof(*first));
namespace ranges {
template<nothrow-input-iterator I, nothrow-sentinel-for <I> S>
requires destructible<iter_value_t<I>>
constexpr I destroy(I first, S last) noexcept;
template<nothrow-input-range R>
requires destructible<range_value_t<R>>
constexpr borrowed_iterator_t<R> destroy(R&& r) noexcept;
}
3 Effects: Equivalent to:
for (; first != last; ++first)
destroy_at(addressof(*first));
return first;
template<class NoThrowForwardIterator, class Size>
constexpr NoThrowForwardIterator destroy_n(NoThrowForwardIterator first, Size n);
4 Effects: Equivalent to:
for (; n > 0; (void)++first, --n)
destroy_at(addressof(*first));
return first;
namespace ranges {
template<nothrow-input-iterator I>
requires destructible<iter_value_t<I>>
constexpr I destroy_n(I first, iter_difference_t<I> n) noexcept;
}
5 Effects: Equivalent to:
return destroy(counted_iterator(std::move(first), n), default_sentinel).base();
26.12 Specialized <random> algorithms [alg.rand]
26.12.1 General [alg.rand.general]
1 The contents specified in 26.12 are declared in the header<random> (29.5.2).
26.12.2 generate_random [alg.rand.generate]
template<class R, class G>
requires output_range<R, invoke_result_t<G&>> && uniform_random_bit_generator<remove_cvref_t<G>>
constexpr borrowed_iterator_t<R> ranges::generate_random(R&& r, G&& g);
1 Effects:
—(1.1) Calls g.generate_random(std::forward<R>(r)) if this expression is well-formed.
—(1.2) Otherwise, if R models sized_range, fills r with ranges::size(r) values of type invoke_-
result_t<G&>byperforminganunspecifiednumberofinvocationsoftheform g()org.generate_-
random(s), if such an expression is well-formed for a valueNand an objectsof typespan<invoke_-
result_t<G&>, N>.
§ 26.12.2 © ISO/IEC
1566

===== PAGE 1578 =====

Dxxxx
[Note 1: Values ofN can differ between invocations.—end note]
—(1.3) Otherwise, callsranges::generate(std::forward<R>(r), ref(g)).
2 Returns: ranges::end(r).
3 Remarks: The effects ofgenerate_random(r, g) shall be equivalent toranges::generate(std::for-
ward<R>(r), ref(g)).
[Note 2: This implies thatg.generate_random(a) fills a with the same values as produced by invocation of
g(). —end note]
template<class G, output_iterator<invoke_result_t<G&>> O, sentinel_for<O> S>
requires uniform_random_bit_generator<remove_cvref_t<G>>
constexpr O ranges::generate_random(O first, S last, G&& g);
4 Effects: Equivalent to:
return generate_random(subrange<O, S>(std::move(first), last), g);
template<class R, class G, class D>
requires output_range<R, invoke_result_t<D&, G&>> && invocable<D&, G&> &&
uniform_random_bit_generator<remove_cvref_t<G>> &&
is_arithmetic_v<invoke_result_t<D&, G&>>
constexpr borrowed_iterator_t<R> ranges::generate_random(R&& r, G&& g, D&& d);
5 Effects:
—(5.1) Calls d.generate_random(std::forward<R>(r), g) if this expression is well-formed.
—(5.2) Otherwise, if R models sized_range, fills r with ranges::size(r) values of type invoke_-
result_t<D&, G&> by performing an unspecified number of invocations of the forminvoke(d,
g) or d.generate_random(s, g), if such an expression is well-formed for a valueN and an object
s of typespan<invoke_result_t<D&, G&>, N>.
[Note 3: Values of N can differ between invocations.—end note]
—(5.3) Otherwise, calls
ranges::generate(std::forward<R>(r), [&d, &g] { return invoke(d, g); });
6 Returns: ranges::end(r).
7 Remarks: The effects ofgenerate_random(r, g, d) shall be equivalent to
ranges::generate(std::forward<R>(r), [&d, &g] { return invoke(d, g); })
[Note 4: This implies thatd.generate_random(a, g) fills a with the values with the same random distribution
as produced by invocation ofinvoke(d, g). —end note]
template<class G, class D, output_iterator<invoke_result_t<D&, G&>> O, sentinel_for<O> S>
requires invocable<D&, G&> && uniform_random_bit_generator<remove_cvref_t<G>> &&
is_arithmetic_v<invoke_result_t<D&, G&>>
constexpr O ranges::generate_random(O first, S last, G&& g, D&& d);
8 Effects: Equivalent to:
return generate_random(subrange<O, S>(std::move(first), last), g, d);
26.13 C library algorithms [alg.c.library]
1 [Note 1: The header<cstdlib> (17.2.2) declares the functions described in this subclause.—end note]
void* bsearch(const void* key, void* base, size_t nmemb, size_t size,
c-compare-pred * compar);
void* bsearch(const void* key, void* base, size_t nmemb, size_t size,
compare-pred * compar);
const void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
c-compare-pred * compar);
const void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
compare-pred * compar);
void qsort(void* base, size_t nmemb, size_t size, c-compare-pred * compar);
void qsort(void* base, size_t nmemb, size_t size, compare-pred * compar);
2 Preconditions: Forqsort, the objects in the array pointed to bybase are of trivially copyable type.
§ 26.13 © ISO/IEC
1567

===== PAGE 1579 =====

Dxxxx
3 Effects: These functions have the semantics specified in the C standard library.
4 Throws: Any exception thrown bycompar (16.4.6.14).
See also: ISO/IEC 9899:2024, 7.24.6
§ 26.13 © ISO/IEC
1568

===== PAGE 1580 =====

Dxxxx
27 Strings library [strings]
27.1 General [strings.general]
1 This Clause describes components for manipulating sequences of any non-array trivially copyable standard-
layout (6.9.1) typeT where is_trivially_default_constructible_v<T> is true. Such types are called
char-like types, and objects of char-like types are calledchar-like objectsor simplycharacters.
2 The following subclauses describe a character traits class, string classes, and null-terminated sequence utilities,
as summarized in Table 86.
Table 86 — Strings library summary [tab:strings.summary]
Subclause Header
27.2 Character traits <string>
27.3 String view classes <string_view>
27.4 String classes <string>
27.5 Null-terminated sequence utilities <cstring>
27.2 Character traits [char.traits]
27.2.1 General [char.traits.general]
1 Subclause 27.2 defines requirements on classes representingcharacter traits, and defines a class template
char_traits<charT>, along with five specializations,char_traits<char>, char_traits<char8_t>, char_-
traits<char16_t>, char_traits<char32_t>, andchar_traits<wchar_t>, that meet those requirements.
2 Most classes specified in 27.4, 27.3, and Clause 31 need a set of related types and functions to complete
the definition of their semantics. These types and functions are provided as a set of membertypedef-names
and functions in the template parametertraits used by each such template. Subclause 27.2 defines the
semantics of these members.
3 To specialize those templates to generate a string, string view, or iostream class to handle a particular
character container type (3.10)C, that and its related character traits classX are passed as a pair of parameters
to the string, string view, or iostream template as parameterscharT and traits. If X::char_type is not
the same type asC, the program is ill-formed.
27.2.2 Character traits requirements [char.traits.require]
1 In Table 87,X denotes a traits class defining types and functions for the character container typeC; c
and d denote values of typeC; p and q denote values of typeconst C*; s denotes a value of typeC*; n, i
and j denote values of typesize_t; e and f denote values of typeX::int_type; pos denotes a value of
type X::pos_type; andr denotes an lvalue of typeC. No expression which is part of the character traits
requirements specified in 27.2.2 shall exit via an exception.
Table 87 — Character traits requirements [tab:char.traits.req]
Expression Return type Assertion/note Complexity
pre-/post-condition
X::char_type C
X::int_type (described in 27.2.3)
X::off_type (described in 31.2.3 and 31.3)
X::pos_type (described in 31.2.3 and 31.3)
X::state_type (described in 27.2.3)
X::eq(c,d) bool Returns: whether c is to be
treated as equal tod.
constant
X::lt(c,d) bool Returns: whether c is to be
treated as less thand.
constant
§ 27.2.2 © ISO/IEC
1569

===== PAGE 1581 =====

Dxxxx
Table 87 — Character traits requirements (continued)
Expression Return type Assertion/note Complexity
pre-/post-condition
X::compare(p,q,n) int Returns: 0 if for eachi in [0,n),
X::eq(p[i],q[i]) is true; else,
a negative value if, for somej in
[0,n), X::lt(p[j],q[j]) is
true and for eachi in [0,j)
X::eq(p[i],q[i]) is true; else
a positive value.
linear
X::length(p) size_t Returns: the smallesti such
that X::eq(p[i],charT()) is
true.
linear
X::find(p,n,c) const X::char_type* Returns: the smallestq in
[p,p+n) such thatX::eq(*q,c)
is true, nullptr otherwise.
linear
X::move(s,p,n) X::char_type* for eachi in [0,n), performs
X::assign(s[i],p[i]). Copies
correctly even where the ranges
[p,p+n) and [s,s+n) overlap.
Returns: s.
linear
X::copy(s,p,n) X::char_type* Preconditions: The ranges
[p,p+n) and [s,s+n) do not
overlap.
Returns: s.
for eachi in [0,n), performs
X::assign(s[i],p[i]).
linear
X::assign(r,d) (not used) assigns r=d. constant
X::assign(s,n,c) X::char_type* for eachi in [0,n), performs
X::assign(s[i],c).
Returns: s.
linear
X::not_eof(e) int_type Returns: e if
X::eq_int_type(e,X::eof())
is false, otherwise a valuef
such that
X::eq_int_type(f,X::eof())
is false.
constant
X::to_char_type(e) X::char_type Returns: if for somec,
X::eq_int_type(e,X::to_-
int_type(c)) is true, c; else
some unspecified value.
constant
X::to_int_type(c) X::int_type Returns: some valuee,
constrained by the definitions of
to_char_type and
eq_int_type.
constant
X::eq_int_type(e,f) bool Returns: for allc and d,
X::eq(c,d) is equal toX::eq_-
int_type(X::to_int_type(c),
X::to_int_type(d));
otherwise, yieldstrue if e and f
are both copies ofX::eof();
otherwise, yieldsfalse if one of
e and f is a copy ofX::eof()
and the other is not; otherwise
the value is unspecified.
constant
§ 27.2.2 © ISO/IEC
1570

===== PAGE 1582 =====

Dxxxx
Table 87 — Character traits requirements (continued)
Expression Return type Assertion/note Complexity
pre-/post-condition
X::eof() X::int_type Returns: a valuee such that
X::eq_int_type(e,X::to_-
int_type(c)) is false for all
values c.
constant
2 The class template
template<class charT> struct char_traits;
is provided in the header<string> (27.4.2) as a basis for explicit specializations.
27.2.3 Traits typedefs [char.traits.typedefs]
using int_type = see below ;
1 Preconditions: int_type shall be able to represent all of the valid characters converted from the
corresponding char_type values, as well as an end-of-file value,eof().202
using state_type = see below ;
2 Preconditions: state_type meets theCpp17Destructible (Table 35),Cpp17CopyAssignable (Table 34),
Cpp17CopyConstructible (Table 32), andCpp17DefaultConstructible (Table 30) requirements.
27.2.4 char_traits specializations [char.traits.specializations]
27.2.4.1 General [char.traits.specializations.general]
namespace std {
template<> struct char_traits<char>;
template<> struct char_traits<char8_t>;
template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;
}
1 The header<string> defines five specializations of the class templatechar_traits: char_traits<char>,
char_traits<char8_t>, char_traits<char16_t>, char_traits<char32_t>, andchar_traits<wchar_t>.
27.2.4.2 struct char_traits<char> [char.traits.specializations.char]
namespace std {
template<> struct char_traits<char> {
using char_type = char;
using int_type = int;
using off_type = streamoff;
using pos_type = streampos;
using state_type = mbstate_t;
using comparison_category = strong_ordering;
static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
static constexpr size_t length(const char_type* s);
static constexpr const char_type* find(const char_type* s, size_t n,
const char_type& a);
static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* assign(char_type* s, size_t n, char_type a);
202) If eof() can be held inchar_type then some iostreams operations can give surprising results.
§ 27.2.4.2 © ISO/IEC
1571

===== PAGE 1583 =====

Dxxxx
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The typembstate_t is defined in<cwchar> (28.7.3) and can represent any of the conversion states that can
occur in an implementation-defined set of supported multibyte character encoding rules.
2 The two-argument memberassign is defined identically to the built-in operator=. The two-argument
members eq and lt are defined identically to the built-in operators== and < for typeunsigned char.
3 The membereof() returns EOF.
27.2.4.3 struct char_traits<char8_t> [char.traits.specializations.char8.t]
namespace std {
template<> struct char_traits<char8_t> {
using char_type = char8_t;
using int_type = unsigned int;
using off_type = streamoff;
using pos_type = u8streampos;
using state_type = mbstate_t;
using comparison_category = strong_ordering;
static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
static constexpr size_t length(const char_type* s);
static constexpr const char_type* find(const char_type* s, size_t n,
const char_type& a);
static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* assign(char_type* s, size_t n, char_type a);
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The two-argument membersassign, eq, andlt are defined identically to the built-in operators=, ==, and<
respectively.
2 The membereof() returns an implementation-defined constant that cannot appear as a valid UTF-8 code
unit.
27.2.4.4 struct char_traits<char16_t> [char.traits.specializations.char16.t]
namespace std {
template<> struct char_traits<char16_t> {
using char_type = char16_t;
using int_type = uint_least16_t;
using off_type = streamoff;
using pos_type = u16streampos;
using state_type = mbstate_t;
using comparison_category = strong_ordering;
static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
§ 27.2.4.4 © ISO/IEC
1572

===== PAGE 1584 =====

Dxxxx
static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
static constexpr size_t length(const char_type* s);
static constexpr const char_type* find(const char_type* s, size_t n,
const char_type& a);
static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* assign(char_type* s, size_t n, char_type a);
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The two-argument membersassign, eq, andlt are defined identically to the built-in operators=, ==, and<,
respectively.
2 The membereof() returns an implementation-defined constant that cannot appear as a valid UTF-16 code
unit.
27.2.4.5 struct char_traits<char32_t> [char.traits.specializations.char32.t]
namespace std {
template<> struct char_traits<char32_t> {
using char_type = char32_t;
using int_type = uint_least32_t;
using off_type = streamoff;
using pos_type = u32streampos;
using state_type = mbstate_t;
using comparison_category = strong_ordering;
static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
static constexpr size_t length(const char_type* s);
static constexpr const char_type* find(const char_type* s, size_t n,
const char_type& a);
static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* assign(char_type* s, size_t n, char_type a);
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The two-argument membersassign, eq, andlt are defined identically to the built-in operators=, ==, and<,
respectively.
2 The membereof() returns an implementation-defined constant that cannot appear as a Unicode code point.
27.2.4.6 struct char_traits<wchar_t> [char.traits.specializations.wchar.t]
namespace std {
template<> struct char_traits<wchar_t> {
using char_type = wchar_t;
using int_type = wint_t;
using off_type = streamoff;
using pos_type = wstreampos;
using state_type = mbstate_t;
§ 27.2.4.6 © ISO/IEC
1573

===== PAGE 1585 =====

Dxxxx
using comparison_category = strong_ordering;
static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
static constexpr size_t length(const char_type* s);
static constexpr const char_type* find(const char_type* s, size_t n,
const char_type& a);
static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
static constexpr char_type* assign(char_type* s, size_t n, char_type a);
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The two-argument membersassign, eq, andlt are defined identically to the built-in operators=, ==, and<,
respectively.
2 The membereof() returns WEOF.
27.3 String view classes [string.view]
27.3.1 General [string.view.general]
1 The class templatebasic_string_view describes an object that can refer to a constant contiguous sequence
of char-like (27.1) objects with the first element of the sequence at position zero. In the rest of 27.3, the type
of the char-like objects held in abasic_string_view object is designated bycharT.
2 [Note 1: The library provides implicit conversions fromconst charT* and std::basic_string<charT, ...> to
std::basic_string_view<charT, ...> so that user code can accept juststd::basic_string_view<charT> as a
non-templated parameter wherever a sequence of characters is expected. User-defined types can define their own
implicit conversions tostd::basic_string_view<charT> in order to interoperate with these functions.—end note]
27.3.2 Header <string_view> synopsis [string.view.synop]
// mostly freestanding
#include <compare> // see 17.12.1
namespace std {
// 27.3.3, class templatebasic_string_view
template<class charT, class traits = char_traits<charT>>
class basic_string_view; // partially freestanding
template<class charT, class traits>
constexpr bool ranges::enable_view<basic_string_view<charT, traits>> = true;
template<class charT, class traits>
constexpr bool ranges::enable_borrowed_range<basic_string_view<charT, traits>> = true;
// 27.3.4, non-member comparison functions
template<class charT, class traits>
constexpr bool operator==(basic_string_view<charT, traits> x,
type_identity_t<basic_string_view<charT, traits>> y) noexcept;
template<class charT, class traits>
constexpr see below operator<=>(basic_string_view<charT, traits> x,
type_identity_t<basic_string_view<charT,
traits>> y) noexcept;
§ 27.3.2 © ISO/IEC
1574

===== PAGE 1586 =====

Dxxxx
// 27.3.5, inserters and extractors
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os,
basic_string_view<charT, traits> str); // hosted
// basic_string_view typedef-names
using string_view = basic_string_view<char>;
using u8string_view = basic_string_view<char8_t>;
using u16string_view = basic_string_view<char16_t>;
using u32string_view = basic_string_view<char32_t>;
using wstring_view = basic_string_view<wchar_t>;
// 27.3.6, hash support
template<class T> struct hash;
template<> struct hash<string_view>;
template<> struct hash<u8string_view>;
template<> struct hash<u16string_view>;
template<> struct hash<u32string_view>;
template<> struct hash<wstring_view>;
inline namespace literals {
inline namespace string_view_literals {
// 27.3.7, suffix forbasic_string_view literals
constexpr string_view operator""sv(const char* str, size_t len) noexcept;
constexpr u8string_view operator""sv(const char8_t* str, size_t len) noexcept;
constexpr u16string_view operator""sv(const char16_t* str, size_t len) noexcept;
constexpr u32string_view operator""sv(const char32_t* str, size_t len) noexcept;
constexpr wstring_view operator""sv(const wchar_t* str, size_t len) noexcept;
}
}
}
1 The function templates defined in 22.2.2 and 24.7 are available when<string_view> is included.
27.3.3 Class template basic_string_view [string.view.template]
27.3.3.1 General [string.view.template.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_string_view {
public:
// types
using traits_type = traits;
using value_type = charT;
using pointer = value_type*;
using const_pointer = const value_type*;
using reference = value_type&;
using const_reference = const value_type&;
using const_iterator = implementation-defined ; // see 27.3.3.4
using iterator = const_iterator; 203
using const_reverse_iterator = reverse_iterator<const_iterator>;
using reverse_iterator = const_reverse_iterator;
using size_type = size_t;
using difference_type = ptrdiff_t;
static constexpr size_type npos = size_type(-1);
// 27.3.3.2, construction and assignment
constexpr basic_string_view() noexcept;
constexpr basic_string_view(const basic_string_view&) noexcept = default;
constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
constexpr basic_string_view(const charT* str);
basic_string_view(nullptr_t) = delete;
203) Because basic_string_view refers to a constant sequence,iterator and const_iterator are the same type.
§ 27.3.3.1 © ISO/IEC
1575

===== PAGE 1587 =====

Dxxxx
constexpr basic_string_view(const charT* str, size_type len);
template<class It, class End>
constexpr basic_string_view(It begin, End end);
template<class R>
constexpr explicit basic_string_view(R&& r);
// 27.3.3.4, iterator support
constexpr const_iterator begin() const noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
// 27.3.3.5, capacity
constexpr size_type size() const noexcept;
constexpr size_type length() const noexcept;
constexpr size_type max_size() const noexcept;
constexpr bool empty() const noexcept;
// 27.3.3.6, element access
constexpr const_reference operator[](size_type pos) const;
constexpr const_reference at(size_type pos) const; // freestanding-deleted
constexpr const_reference front() const;
constexpr const_reference back() const;
constexpr const charT* data() const noexcept;
// 27.3.3.7, modifiers
constexpr void remove_prefix(size_type n);
constexpr void remove_suffix(size_type n);
constexpr void swap(basic_string_view& s) noexcept;
// 27.3.3.8, string operations
constexpr size_type copy(charT* s, size_type n,
size_type pos = 0) const; // freestanding-deleted
constexpr basic_string_view substr(size_type pos = 0,
size_type n = npos) const; // freestanding-deleted
constexpr basic_string_view subview(size_type pos = 0,
size_type n = npos) const; // freestanding-deleted
constexpr int compare(basic_string_view s) const noexcept;
constexpr int compare(size_type pos1, size_type n1,
basic_string_view s) const; // freestanding-deleted
constexpr int compare(size_type pos1, size_type n1, basic_string_view s,
size_type pos2, size_type n2) const; // freestanding-deleted
constexpr int compare(const charT* s) const;
constexpr int compare(size_type pos1, size_type n1,
const charT* s) const; // freestanding-deleted
constexpr int compare(size_type pos1, size_type n1, const charT* s,
size_type n2) const; // freestanding-deleted
constexpr bool starts_with(basic_string_view x) const noexcept;
constexpr bool starts_with(charT x) const noexcept;
constexpr bool starts_with(const charT* x) const;
constexpr bool ends_with(basic_string_view x) const noexcept;
constexpr bool ends_with(charT x) const noexcept;
constexpr bool ends_with(const charT* x) const;
constexpr bool contains(basic_string_view x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
§ 27.3.3.1 © ISO/IEC
1576

===== PAGE 1588 =====

Dxxxx
// 27.3.3.9, searching
constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
constexpr size_type find(charT c, size_type pos = 0) const noexcept;
constexpr size_type find(const charT* s, size_type pos, size_type n) const;
constexpr size_type find(const charT* s, size_type pos = 0) const;
constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
constexpr size_type rfind(const charT* s, size_type pos = npos) const;
constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
constexpr size_type find_first_not_of(const charT* s, size_type pos,
size_type n) const;
constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
constexpr size_type find_last_not_of(basic_string_view s,
size_type pos = npos) const noexcept;
constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
constexpr size_type find_last_not_of(const charT* s, size_type pos,
size_type n) const;
constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;
private:
const charT* data_; // exposition only
size_type size_; // exposition only
};
// 27.3.3.3, deduction guides
template<class It, class End>
basic_string_view(It, End) -> basic_string_view<iter_value_t<It>>;
template<class R>
basic_string_view(R&&) -> basic_string_view<ranges::range_value_t<R>>;
}
1 In every specialization basic_string_view<charT, traits>, the type traits shall meet the character
traits requirements (27.2).
[Note 1: The program is ill-formed iftraits::char_type is not the same type ascharT. —end note]
2 For abasic_string_view str, any operation that invalidates a pointer in the range
[str.data(),str.data() + str.size())
invalidates pointers, iterators, and references to elements ofstr.
3 The complexity ofbasic_string_view member functions isO(1) unless otherwise specified.
4 basic_string_view<charT, traits> is a trivially copyable type (6.9.1).
27.3.3.2 Construction and assignment [string.view.cons]
constexpr basic_string_view() noexcept;
1 Postconditions: size_ == 0 and data_ == nullptr.
constexpr basic_string_view(const charT* str);
2 Preconditions: [str,str + traits::length(str)) is a valid range.
3 Effects: Constructs a basic_string_view, initializing data_ with str and initializing size_ with
traits::length(str).
§ 27.3.3.2 © ISO/IEC
1577

===== PAGE 1589 =====

Dxxxx
4 Complexity: O(traits::length(str)).
constexpr basic_string_view(const charT* str, size_type len);
5 Preconditions: [str,str + len) is a valid range.
6 Effects: Constructs abasic_string_view, initializingdata_ with str and initializingsize_ with len.
template<class It, class End>
constexpr basic_string_view(It begin, End end);
7 Constraints:
—(7.1) It satisfies contiguous_iterator.
—(7.2) End satisfies sized_sentinel_for<It>.
—(7.3) is_same_v<iter_value_t<It>, charT> is true.
—(7.4) is_convertible_v<End, size_type> is false.
8 Preconditions:
—(8.1) [begin,end) is a valid range.
—(8.2) It models contiguous_iterator.
—(8.3) End models sized_sentinel_for<It>.
9 Effects: Initializes data_ with to_address(begin) and initializessize_ with end - begin.
10 Throws: When and whatend - begin throws.
template<class R>
constexpr explicit basic_string_view(R&& r);
11 Let d be an lvalue of typeremove_cvref_t<R>.
12 Constraints:
—(12.1) remove_cvref_t<R> is not the same type asbasic_string_view,
—(12.2) R models ranges::contiguous_range and ranges::sized_range,
—(12.3) is_same_v<ranges::range_value_t<R>, charT> is true,
—(12.4) is_convertible_v<R, const charT*> is false, and
—(12.5) d.operator ::std::basic_string_view<charT, traits>() is not a valid expression.
13 Effects: Initializes data_ with ranges::data(r) and size_ with ranges::size(r).
14 Throws: Any exception thrown byranges::data(r) and ranges::size(r).
27.3.3.3 Deduction guides [string.view.deduct]
template<class It, class End>
basic_string_view(It, End) -> basic_string_view<iter_value_t<It>>;
1 Constraints:
—(1.1) It satisfies contiguous_iterator.
—(1.2) End satisfies sized_sentinel_for<It>.
template<class R>
basic_string_view(R&&) -> basic_string_view<ranges::range_value_t<R>>;
2 Constraints: R satisfies ranges::contiguous_range.
27.3.3.4 Iterator support [string.view.iterators]
using const_iterator = implementation-defined ;
1 A type that meets the requirements of a constantCpp17RandomAccessIterator(24.3.5.7), models
contiguous_iterator (24.3.4.14), and meets the constexpr iterator requirements (24.3.1), whose
value_type is the template parametercharT.
2 All requirements on container iterators (23.2) apply tobasic_string_view::const_iterator as well.
§ 27.3.3.4 © ISO/IEC
1578

===== PAGE 1590 =====

Dxxxx
constexpr const_iterator begin() const noexcept;
constexpr const_iterator cbegin() const noexcept;
3 Returns: An iterator such that
—(3.1) if !empty(), addressof(*begin()) == data_,
—(3.2) otherwise, an unspecified value such that[begin(),end()) is a valid range.
constexpr const_iterator end() const noexcept;
constexpr const_iterator cend() const noexcept;
4 Returns: begin() + size().
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
5 Returns: const_reverse_iterator(end()).
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
6 Returns: const_reverse_iterator(begin()).
27.3.3.5 Capacity [string.view.capacity]
constexpr size_type size() const noexcept;
constexpr size_type length() const noexcept;
1 Returns: size_.
constexpr size_type max_size() const noexcept;
2 Returns: The largest possible number of char-like objects that can be referred to by abasic_string_-
view.
constexpr bool empty() const noexcept;
3 Returns: size_ == 0.
27.3.3.6 Element access [string.view.access]
constexpr const_reference operator[](size_type pos) const;
1 Hardened preconditions: pos < size() is true.
[Note 1: This precondition is stronger than the one onbasic_string::operator[]. —end note]
2 Returns: data_[pos].
3 Throws: Nothing.
constexpr const_reference at(size_type pos) const;
4 Returns: data_[pos].
5 Throws: out_of_range if pos >= size().
constexpr const_reference front() const;
6 Hardened preconditions: empty() is false.
7 Returns: data_[0].
8 Throws: Nothing.
constexpr const_reference back() const;
9 Hardened preconditions: empty() is false.
10 Returns: data_[size() - 1].
11 Throws: Nothing.
constexpr const charT* data() const noexcept;
12 Returns: data_.
§ 27.3.3.6 © ISO/IEC
1579

===== PAGE 1591 =====

Dxxxx
13 [Note 2: Unlikebasic_string::data() and string-literals, data() can return a pointer to a buffer that is not
null-terminated. Therefore it is typically a mistake to passdata() to a function that takes just aconst charT*
and expects a null-terminated string.—end note]
27.3.3.7 Modifiers [string.view.modifiers]
constexpr void remove_prefix(size_type n);
1 Hardened preconditions: n <= size() is true.
2 Effects: Equivalent to:data_ += n; size_ -= n;
constexpr void remove_suffix(size_type n);
3 Hardened preconditions: n <= size() is true.
4 Effects: Equivalent to:size_ -= n;
constexpr void swap(basic_string_view& s) noexcept;
5 Effects: Exchanges the values of*this and s.
27.3.3.8 String operations [string.view.ops]
constexpr size_type copy(charT* s, size_type n, size_type pos = 0) const;
1 Let rlen be the smaller ofn and size() - pos.
2 Preconditions: [s,s + rlen) is a valid range.
3 Effects: Equivalent totraits::copy(s, data() + pos, rlen).
4 Returns: rlen.
5 Throws: out_of_range if pos > size().
6 Complexity: O(rlen).
constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
constexpr basic_string_view subview(size_type pos = 0, size_type n = npos) const;
7 Let rlen be the smaller ofn and size() - pos.
8 Effects: Determines rlen, the effective length of the string to reference.
9 Returns: basic_string_view(data() + pos, rlen).
10 Throws: out_of_range if pos > size().
constexpr int compare(basic_string_view str) const noexcept;
11 Let rlen be the smaller ofsize() and str.size().
12 Effects: Determines rlen, the effective length of the strings to compare. The function then compares
the two strings by callingtraits::compare(data(), str.data(), rlen).
13 Returns: The nonzero result if the result of the comparison is nonzero. Otherwise, returns a value as
indicated in Table 88.
Table 88 —compare() results [tab:string.view.compare]
Condition Return Value
size() < str.size() < 0
size() == str.size() 0
size() > str.size() > 0
14 Complexity: O(rlen).
constexpr int compare(size_type pos1, size_type n1, basic_string_view str) const;
15 Effects: Equivalent to:return substr(pos1, n1).compare(str);
§ 27.3.3.8 © ISO/IEC
1580

===== PAGE 1592 =====

Dxxxx
constexpr int compare(size_type pos1, size_type n1, basic_string_view str,
size_type pos2, size_type n2) const;
16 Effects: Equivalent to:return substr(pos1, n1).compare(str.substr(pos2, n2));
constexpr int compare(const charT* s) const;
17 Effects: Equivalent to:return compare(basic_string_view(s));
constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
18 Effects: Equivalent to:return substr(pos1, n1).compare(basic_string_view(s));
constexpr int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;
19 Effects: Equivalent to:return substr(pos1, n1).compare(basic_string_view(s, n2));
constexpr bool starts_with(basic_string_view x) const noexcept;
20 Let rlen be the smaller ofsize() and x.size().
21 Effects: Equivalent to:return basic_string_view(data(), rlen) == x;
constexpr bool starts_with(charT x) const noexcept;
22 Effects: Equivalent to:return !empty() && traits::eq(front(), x);
constexpr bool starts_with(const charT* x) const;
23 Effects: Equivalent to:return starts_with(basic_string_view(x));
constexpr bool ends_with(basic_string_view x) const noexcept;
24 Let rlen be the smaller ofsize() and x.size().
25 Effects: Equivalent to:
return basic_string_view(data() + (size() - rlen), rlen) == x;
constexpr bool ends_with(charT x) const noexcept;
26 Effects: Equivalent to:return !empty() && traits::eq(back(), x);
constexpr bool ends_with(const charT* x) const;
27 Effects: Equivalent to:return ends_with(basic_string_view(x));
constexpr bool contains(basic_string_view x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
28 Effects: Equivalent to:return find(x) != npos;
27.3.3.9 Searching [string.view.find]
1 Member functions in this subclause have complexityO(size() * str.size()) at worst, although imple-
mentations should do better.
2 Let F be one offind, rfind, find_first_of, find_last_of, find_first_not_of, andfind_last_not_of.
—(2.1) Each member function of the form
constexpr return-type F (const charT* s, size_type pos) const;
has effects equivalent to:return F (basic_string_view(s), pos);
—(2.2) Each member function of the form
constexpr return-type F (const charT* s, size_type pos, size_type n) const;
has effects equivalent to:return F (basic_string_view(s, n), pos);
—(2.3) Each member function of the form
constexpr return-type F (charT c, size_type pos) const noexcept;
has effects equivalent to:return F (basic_string_view(addressof(c), 1), pos);
§ 27.3.3.9 © ISO/IEC
1581

===== PAGE 1593 =====

Dxxxx
constexpr size_type find(basic_string_view str, size_type pos = 0) const noexcept;
3 Let xpos be the lowest position, if possible, such that the following conditions hold:
—(3.1) pos <= xpos
—(3.2) xpos + str.size() <= size()
—(3.3) traits::eq(data_[xpos + I], str[I]) for all elementsI of the string referenced bystr.
4 Effects: Determines xpos.
5 Returns: xpos if the function can determine such a value forxpos. Otherwise, returnsnpos.
constexpr size_type rfind(basic_string_view str, size_type pos = npos) const noexcept;
6 Let xpos be the highest position, if possible, such that the following conditions hold:
—(6.1) xpos <= pos
—(6.2) xpos + str.size() <= size()
—(6.3) traits::eq(data_[xpos + I], str[I]) for all elementsI of the string referenced bystr.
7 Effects: Determines xpos.
8 Returns: xpos if the function can determine such a value forxpos. Otherwise, returnsnpos.
constexpr size_type find_first_of(basic_string_view str, size_type pos = 0) const noexcept;
9 Let xpos be the lowest position, if possible, such that the following conditions hold:
—(9.1) pos <= xpos
—(9.2) xpos < size()
—(9.3) traits::eq(data_[xpos], str[I]) for some elementI of the string referenced bystr.
10 Effects: Determines xpos.
11 Returns: xpos if the function can determine such a value forxpos. Otherwise, returnsnpos.
constexpr size_type find_last_of(basic_string_view str, size_type pos = npos) const noexcept;
12 Let xpos be the highest position, if possible, such that the following conditions hold:
—(12.1) xpos <= pos
—(12.2) xpos < size()
—(12.3) traits::eq(data_[xpos], str[I]) for some elementI of the string referenced bystr.
13 Effects: Determines xpos.
14 Returns: xpos if the function can determine such a value forxpos. Otherwise, returnsnpos.
constexpr size_type find_first_not_of(basic_string_view str, size_type pos = 0) const noexcept;
15 Let xpos be the lowest position, if possible, such that the following conditions hold:
—(15.1) pos <= xpos
—(15.2) xpos < size()
—(15.3) traits::eq(data_[xpos], str[I]) for no elementI of the string referenced bystr.
16 Effects: Determines xpos.
17 Returns: xpos if the function can determine such a value forxpos. Otherwise, returnsnpos.
constexpr size_type find_last_not_of(basic_string_view str, size_type pos = npos) const noexcept;
18 Let xpos be the highest position, if possible, such that the following conditions hold:
—(18.1) xpos <= pos
—(18.2) xpos < size()
—(18.3) traits::eq(data_[xpos], str[I]) for no elementI of the string referenced bystr.
19 Effects: Determines xpos.
20 Returns: xpos if the function can determine such a value forxpos. Otherwise, returnsnpos.
§ 27.3.3.9 © ISO/IEC
1582

===== PAGE 1594 =====

Dxxxx
27.3.4 Non-member comparison functions [string.view.comparison]
template<class charT, class traits>
constexpr bool operator==(basic_string_view<charT, traits> lhs,
type_identity_t<basic_string_view<charT, traits>> rhs) noexcept;
1 Returns: lhs.compare(rhs) == 0.
template<class charT, class traits>
constexpr see below operator<=>(basic_string_view<charT, traits> lhs,
type_identity_t<basic_string_view<charT, traits>> rhs) noexcept;
2 Let R denote the type traits::comparison_category if that qualified-id is valid and denotes a
type (13.10.3), otherwiseR is weak_ordering.
3 Mandates: R denotes a comparison category type (17.12.2).
4 Returns: static_cast<R>(lhs.compare(rhs) <=> 0).
5 [Note 1: The usage oftype_identity_t as parameter ensures that an object of typebasic_string_view<charT,
traits> can always be compared with an object of a typeT with an implicit conversion tobasic_string_-
view<charT, traits>, and vice versa, as per 12.2.2.3.—end note]
27.3.5 Inserters and extractors [string.view.io]
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, basic_string_view<charT, traits> str);
1 Effects: Behaves as a formatted output function (31.7.6.3.1) ofos. Forms a character sequenceseq,
initially consisting of the elements defined by the range[str.begin(),str.end()). Determines padding
for seq as described in 31.7.6.3.1. Then insertsseq as if by callingos.rdbuf()->sputn(seq, n),
where n is the larger ofos.width() and str.size(); then callsos.width(0).
2 Returns: os.
27.3.6 Hash support [string.view.hash]
template<> struct hash<string_view>;
template<> struct hash<u8string_view>;
template<> struct hash<u16string_view>;
template<> struct hash<u32string_view>;
template<> struct hash<wstring_view>;
1 The specialization is enabled (22.10.19).
[Note 1: The hash value of a string view object is equal to the hash value of the corresponding string
object (27.4.6). —end note]
27.3.7 Suffix for basic_string_view literals [string.view.literals]
constexpr string_view operator""sv(const char* str, size_t len) noexcept;
1 Returns: string_view{str, len}.
constexpr u8string_view operator""sv(const char8_t* str, size_t len) noexcept;
2 Returns: u8string_view{str, len}.
constexpr u16string_view operator""sv(const char16_t* str, size_t len) noexcept;
3 Returns: u16string_view{str, len}.
constexpr u32string_view operator""sv(const char32_t* str, size_t len) noexcept;
4 Returns: u32string_view{str, len}.
constexpr wstring_view operator""sv(const wchar_t* str, size_t len) noexcept;
5 Returns: wstring_view{str, len}.
§ 27.3.7 © ISO/IEC
1583

===== PAGE 1595 =====

Dxxxx
27.4 String classes [string.classes]
27.4.1 General [string.classes.general]
1 The header<string> defines thebasic_string class template for manipulating varying-length sequences
of char-like objects and five typedef-names, string, u8string, u16string, u32string, and wstring,
that name the specializationsbasic_string<char>, basic_string<char8_t>, basic_string<char16_t>,
basic_string<char32_t>, andbasic_string<wchar_t>, respectively.
27.4.2 Header <string> synopsis [string.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 27.2, character traits
template<class charT> struct char_traits; // freestanding
template<> struct char_traits<char>; // freestanding
template<> struct char_traits<char8_t>; // freestanding
template<> struct char_traits<char16_t>; // freestanding
template<> struct char_traits<char32_t>; // freestanding
template<> struct char_traits<wchar_t>; // freestanding
// 27.4.3,basic_string
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_string;
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
basic_string<charT, traits, Allocator>&& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
basic_string<charT, traits, Allocator>&& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const charT* lhs,
const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const charT* lhs,
basic_string<charT, traits, Allocator>&& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(charT lhs,
const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(charT lhs,
basic_string<charT, traits, Allocator>&& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
const charT* rhs);
§ 27.4.2 © ISO/IEC
1584

===== PAGE 1596 =====

Dxxxx
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
const charT* rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
charT rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
charT rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
type_identity_t<basic_string_view<charT, traits>> rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
type_identity_t<basic_string_view<charT, traits>> rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(type_identity_t<basic_string_view<charT, traits>> lhs,
const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(type_identity_t<basic_string_view<charT, traits>> lhs,
basic_string<charT, traits, Allocator>&& rhs);
template<class charT, class traits, class Allocator>
constexpr bool
operator==(const basic_string<charT, traits, Allocator>& lhs,
const basic_string<charT, traits, Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
constexpr bool operator==(const basic_string<charT, traits, Allocator>& lhs,
const charT* rhs);
template<class charT, class traits, class Allocator>
constexpr see below operator<=>(const basic_string<charT, traits, Allocator>& lhs,
const basic_string<charT, traits, Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
constexpr see below operator<=>(const basic_string<charT, traits, Allocator>& lhs,
const charT* rhs);
// 27.4.4.3, swap
template<class charT, class traits, class Allocator>
constexpr void
swap(basic_string<charT, traits, Allocator>& lhs,
basic_string<charT, traits, Allocator>& rhs)
noexcept(noexcept(lhs.swap(rhs)));
// 27.4.4.4, inserters and extractors
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is,
basic_string<charT, traits, Allocator>& str);
template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os,
const basic_string<charT, traits, Allocator>& str);
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is,
basic_string<charT, traits, Allocator>& str,
§ 27.4.2 © ISO/IEC
1585

===== PAGE 1597 =====

Dxxxx
charT delim);
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>&& is,
basic_string<charT, traits, Allocator>& str,
charT delim);
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is,
basic_string<charT, traits, Allocator>& str);
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>&& is,
basic_string<charT, traits, Allocator>& str);
// 27.4.4.5, erasure
template<class charT, class traits, class Allocator, class U = charT>
constexpr typename basic_string<charT, traits, Allocator>::size_type
erase(basic_string<charT, traits, Allocator>& c, const U& value);
template<class charT, class traits, class Allocator, class Predicate>
constexpr typename basic_string<charT, traits, Allocator>::size_type
erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred);
// basic_string typedef-names
using string = basic_string<char>;
using u8string = basic_string<char8_t>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
using wstring = basic_string<wchar_t>;
// 27.4.5, numeric conversions
int stoi(const string& str, size_t* idx = nullptr, int base = 10);
long stol(const string& str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(const string& str, size_t* idx = nullptr, int base = 10);
long long stoll(const string& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);
float stof(const string& str, size_t* idx = nullptr);
double stod(const string& str, size_t* idx = nullptr);
long double stold(const string& str, size_t* idx = nullptr);
constexpr string to_string(int val);
constexpr string to_string(unsigned val);
constexpr string to_string(long val);
constexpr string to_string(unsigned long val);
constexpr string to_string(long long val);
constexpr string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);
int stoi(const wstring& str, size_t* idx = nullptr, int base = 10);
long stol(const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(const wstring& str, size_t* idx = nullptr, int base = 10);
long long stoll(const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);
float stof(const wstring& str, size_t* idx = nullptr);
double stod(const wstring& str, size_t* idx = nullptr);
long double stold(const wstring& str, size_t* idx = nullptr);
constexpr wstring to_wstring(int val);
constexpr wstring to_wstring(unsigned val);
constexpr wstring to_wstring(long val);
constexpr wstring to_wstring(unsigned long val);
constexpr wstring to_wstring(long long val);
constexpr wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
§ 27.4.2 © ISO/IEC
1586

===== PAGE 1598 =====

Dxxxx
wstring to_wstring(double val);
wstring to_wstring(long double val);
namespace pmr {
template<class charT, class traits = char_traits<charT>>
using basic_string = std::basic_string<charT, traits, polymorphic_allocator<charT>>;
using string = basic_string<char>;
using u8string = basic_string<char8_t>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
using wstring = basic_string<wchar_t>;
}
// 27.4.6, hash support
template<class T> struct hash;
template<class A> struct hash<basic_string<char, char_traits<char>, A>>;
template<class A> struct hash<basic_string<char8_t, char_traits<char8_t>, A>>;
template<class A> struct hash<basic_string<char16_t, char_traits<char16_t>, A>>;
template<class A> struct hash<basic_string<char32_t, char_traits<char32_t>, A>>;
template<class A> struct hash<basic_string<wchar_t, char_traits<wchar_t>, A>>;
inline namespace literals {
inline namespace string_literals {
// 27.4.7, suffix forbasic_string literals
constexpr string operator""s(const char* str, size_t len);
constexpr u8string operator""s(const char8_t* str, size_t len);
constexpr u16string operator""s(const char16_t* str, size_t len);
constexpr u32string operator""s(const char32_t* str, size_t len);
constexpr wstring operator""s(const wchar_t* str, size_t len);
}
}
}
27.4.3 Class template basic_string [basic.string]
27.4.3.1 General [basic.string.general]
1 The class templatebasic_string describes objects that can store a sequence consisting of a varying number
of arbitrary char-like objects with the first element of the sequence at position zero. Such a sequence is also
called a “string” if the type of the char-like objects that it holds is clear from context. In the rest of 27.4.3,
the type of the char-like objects held in abasic_string object is designated bycharT.
2 A specialization ofbasic_string is a contiguous container (23.2.2.2).
3 In all cases,[data(),data() + size()] is a valid range,data() + size() points at an object with value
charT() (a “null terminator”), andsize() <= capacity() is true.
namespace std {
template<class charT, class traits = char_traits<charT>,
class Allocator = allocator<charT>>
class basic_string {
public:
// types
using traits_type = traits;
using value_type = charT;
using allocator_type = Allocator;
using size_type = allocator_traits<Allocator>::size_type;
using difference_type = allocator_traits<Allocator>::difference_type;
using pointer = allocator_traits<Allocator>::pointer;
using const_pointer = allocator_traits<Allocator>::const_pointer;
using reference = value_type&;
using const_reference = const value_type&;
using iterator = implementation-defined ; // see 23.2
using const_iterator = implementation-defined ; // see 23.2
§ 27.4.3.1 © ISO/IEC
1587

===== PAGE 1599 =====

Dxxxx
using reverse_iterator = std::reverse_iterator<iterator>;
using const_reverse_iterator = std::reverse_iterator<const_iterator>;
static constexpr size_type npos = size_type(-1);
// 27.4.3.3, construct/copy/destroy
constexpr basic_string() noexcept(noexcept(Allocator())) : basic_string(Allocator()) { }
constexpr explicit basic_string(const Allocator& a) noexcept;
constexpr basic_string(const basic_string& str);
constexpr basic_string(basic_string&& str) noexcept;
constexpr basic_string(const basic_string& str, size_type pos,
const Allocator& a = Allocator());
constexpr basic_string(const basic_string& str, size_type pos, size_type n,
const Allocator& a = Allocator());
constexpr basic_string(basic_string&& str, size_type pos,
const Allocator& a = Allocator());
constexpr basic_string(basic_string&& str, size_type pos, size_type n,
const Allocator& a = Allocator());
template<class T>
constexpr basic_string(const T& t, size_type pos, size_type n,
const Allocator& a = Allocator());
template<class T>
constexpr explicit basic_string(const T& t, const Allocator& a = Allocator());
constexpr basic_string(const charT* s, size_type n, const Allocator& a = Allocator());
constexpr basic_string(const charT* s, const Allocator& a = Allocator());
basic_string(nullptr_t) = delete;
constexpr basic_string(size_type n, charT c, const Allocator& a = Allocator());
template<class InputIterator>
constexpr basic_string(InputIterator begin, InputIterator end,
const Allocator& a = Allocator());
template<container-compatible-range <charT> R>
constexpr basic_string(from_range_t, R&& rg, const Allocator& a = Allocator());
constexpr basic_string(initializer_list<charT>, const Allocator& = Allocator());
constexpr basic_string(const basic_string&, const Allocator&);
constexpr basic_string(basic_string&&, const Allocator&);
constexpr ~basic_string();
constexpr basic_string& operator=(const basic_string& str);
constexpr basic_string& operator=(basic_string&& str)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
template<class T>
constexpr basic_string& operator=(const T& t);
constexpr basic_string& operator=(const charT* s);
basic_string& operator=(nullptr_t) = delete;
constexpr basic_string& operator=(charT c);
constexpr basic_string& operator=(initializer_list<charT>);
// 27.4.3.4, iterators
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_iterator cbegin() const noexcept;
constexpr const_iterator cend() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
§ 27.4.3.1 © ISO/IEC
1588

===== PAGE 1600 =====

Dxxxx
// 27.4.3.5, capacity
constexpr size_type size() const noexcept;
constexpr size_type length() const noexcept;
constexpr size_type max_size() const noexcept;
constexpr void resize(size_type n, charT c);
constexpr void resize(size_type n);
template<class Operation> constexpr void resize_and_overwrite(size_type n, Operation op);
constexpr size_type capacity() const noexcept;
constexpr void reserve(size_type res_arg);
constexpr void shrink_to_fit();
constexpr void clear() noexcept;
constexpr bool empty() const noexcept;
// 27.4.3.6, element access
constexpr const_reference operator[](size_type pos) const;
constexpr reference operator[](size_type pos);
constexpr const_reference at(size_type n) const;
constexpr reference at(size_type n);
constexpr const_reference front() const;
constexpr reference front();
constexpr const_reference back() const;
constexpr reference back();
// 27.4.3.7, modifiers
constexpr basic_string& operator+=(const basic_string& str);
template<class T>
constexpr basic_string& operator+=(const T& t);
constexpr basic_string& operator+=(const charT* s);
constexpr basic_string& operator+=(charT c);
constexpr basic_string& operator+=(initializer_list<charT>);
constexpr basic_string& append(const basic_string& str);
constexpr basic_string& append(const basic_string& str, size_type pos, size_type n = npos);
template<class T>
constexpr basic_string& append(const T& t);
template<class T>
constexpr basic_string& append(const T& t, size_type pos, size_type n = npos);
constexpr basic_string& append(const charT* s, size_type n);
constexpr basic_string& append(const charT* s);
constexpr basic_string& append(size_type n, charT c);
template<class InputIterator>
constexpr basic_string& append(InputIterator first, InputIterator last);
template<container-compatible-range <charT> R>
constexpr basic_string& append_range(R&& rg);
constexpr basic_string& append(initializer_list<charT>);
constexpr void push_back(charT c);
constexpr basic_string& assign(const basic_string& str);
constexpr basic_string& assign(basic_string&& str)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
constexpr basic_string& assign(const basic_string& str, size_type pos, size_type n = npos);
template<class T>
constexpr basic_string& assign(const T& t);
template<class T>
constexpr basic_string& assign(const T& t, size_type pos, size_type n = npos);
constexpr basic_string& assign(const charT* s, size_type n);
constexpr basic_string& assign(const charT* s);
constexpr basic_string& assign(size_type n, charT c);
template<class InputIterator>
constexpr basic_string& assign(InputIterator first, InputIterator last);
template<container-compatible-range <charT> R>
constexpr basic_string& assign_range(R&& rg);
§ 27.4.3.1 © ISO/IEC
1589