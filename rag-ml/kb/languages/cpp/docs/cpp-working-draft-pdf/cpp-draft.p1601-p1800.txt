

===== PAGE 1601 =====

Dxxxx
constexpr basic_string& assign(initializer_list<charT>);
constexpr basic_string& insert(size_type pos, const basic_string& str);
constexpr basic_string& insert(size_type pos1, const basic_string& str,
size_type pos2, size_type n = npos);
template<class T>
constexpr basic_string& insert(size_type pos, const T& t);
template<class T>
constexpr basic_string& insert(size_type pos1, const T& t,
size_type pos2, size_type n = npos);
constexpr basic_string& insert(size_type pos, const charT* s, size_type n);
constexpr basic_string& insert(size_type pos, const charT* s);
constexpr basic_string& insert(size_type pos, size_type n, charT c);
constexpr iterator insert(const_iterator p, charT c);
constexpr iterator insert(const_iterator p, size_type n, charT c);
template<class InputIterator>
constexpr iterator insert(const_iterator p, InputIterator first, InputIterator last);
template<container-compatible-range <charT> R>
constexpr iterator insert_range(const_iterator p, R&& rg);
constexpr iterator insert(const_iterator p, initializer_list<charT>);
constexpr basic_string& erase(size_type pos = 0, size_type n = npos);
constexpr iterator erase(const_iterator p);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();
constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
size_type pos2, size_type n2 = npos);
template<class T>
constexpr basic_string& replace(size_type pos1, size_type n1, const T& t);
template<class T>
constexpr basic_string& replace(size_type pos1, size_type n1, const T& t,
size_type pos2, size_type n2 = npos);
constexpr basic_string& replace(size_type pos, size_type n1, const charT* s, size_type n2);
constexpr basic_string& replace(size_type pos, size_type n1, const charT* s);
constexpr basic_string& replace(size_type pos, size_type n1, size_type n2, charT c);
constexpr basic_string& replace(const_iterator i1, const_iterator i2,
const basic_string& str);
template<class T>
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const T& t);
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s,
size_type n);
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);
constexpr basic_string& replace(const_iterator i1, const_iterator i2, size_type n, charT c);
template<class InputIterator>
constexpr basic_string& replace(const_iterator i1, const_iterator i2,
InputIterator j1, InputIterator j2);
template<container-compatible-range <charT> R>
constexpr basic_string& replace_with_range(const_iterator i1, const_iterator i2, R&& rg);
constexpr basic_string& replace(const_iterator, const_iterator, initializer_list<charT>);
constexpr size_type copy(charT* s, size_type n, size_type pos = 0) const;
constexpr void swap(basic_string& str)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
// 27.4.3.8, string operations
constexpr const charT* c_str() const noexcept;
constexpr const charT* data() const noexcept;
constexpr charT* data() noexcept;
constexpr operator basic_string_view<charT, traits>() const noexcept;
§ 27.4.3.1 © ISO/IEC
1590

===== PAGE 1602 =====

Dxxxx
constexpr allocator_type get_allocator() const noexcept;
template<class T>
constexpr size_type find(const T& t, size_type pos = 0) const noexcept(see below );
constexpr size_type find(const basic_string& str, size_type pos = 0) const noexcept;
constexpr size_type find(const charT* s, size_type pos, size_type n) const;
constexpr size_type find(const charT* s, size_type pos = 0) const;
constexpr size_type find(charT c, size_type pos = 0) const noexcept;
template<class T>
constexpr size_type rfind(const T& t, size_type pos = npos) const noexcept(see below );
constexpr size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
constexpr size_type rfind(const charT* s, size_type pos = npos) const;
constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
template<class T>
constexpr size_type find_first_of(const T& t, size_type pos = 0) const noexcept(see below );
constexpr size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;
constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
template<class T>
constexpr size_type find_last_of(const T& t,
size_type pos = npos) const noexcept(see below );
constexpr size_type find_last_of(const basic_string& str,
size_type pos = npos) const noexcept;
constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
template<class T>
constexpr size_type find_first_not_of(const T& t,
size_type pos = 0) const noexcept(see below );
constexpr size_type find_first_not_of(const basic_string& str,
size_type pos = 0) const noexcept;
constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
template<class T>
constexpr size_type find_last_not_of(const T& t,
size_type pos = npos) const noexcept(see below );
constexpr size_type find_last_not_of(const basic_string& str,
size_type pos = npos) const noexcept;
constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;
constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const &;
constexpr basic_string substr(size_type pos = 0, size_type n = npos) &&;
constexpr basic_string_view<charT, traits> subview(size_type pos = 0,
size_type n = npos) const;
template<class T>
constexpr int compare(const T& t) const noexcept(see below );
template<class T>
constexpr int compare(size_type pos1, size_type n1, const T& t) const;
template<class T>
constexpr int compare(size_type pos1, size_type n1, const T& t,
size_type pos2, size_type n2 = npos) const;
constexpr int compare(const basic_string& str) const noexcept;
constexpr int compare(size_type pos1, size_type n1, const basic_string& str) const;
constexpr int compare(size_type pos1, size_type n1, const basic_string& str,
size_type pos2, size_type n2 = npos) const;
constexpr int compare(const charT* s) const;
§ 27.4.3.1 © ISO/IEC
1591

===== PAGE 1603 =====

Dxxxx
constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
constexpr int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;
constexpr bool starts_with(basic_string_view<charT, traits> x) const noexcept;
constexpr bool starts_with(charT x) const noexcept;
constexpr bool starts_with(const charT* x) const;
constexpr bool ends_with(basic_string_view<charT, traits> x) const noexcept;
constexpr bool ends_with(charT x) const noexcept;
constexpr bool ends_with(const charT* x) const;
constexpr bool contains(basic_string_view<charT, traits> x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
};
template<class InputIterator,
class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
basic_string(InputIterator, InputIterator, Allocator = Allocator())
-> basic_string<typename iterator_traits<InputIterator>::value_type,
char_traits<typename iterator_traits<InputIterator>::value_type>,
Allocator>;
template<ranges::input_range R,
class Allocator = allocator<ranges::range_value_t<R>>>
basic_string(from_range_t, R&&, Allocator = Allocator())
-> basic_string<ranges::range_value_t<R>, char_traits<ranges::range_value_t<R>>,
Allocator>;
template<class charT,
class traits,
class Allocator = allocator<charT>>
explicit basic_string(basic_string_view<charT, traits>, const Allocator& = Allocator())
-> basic_string<charT, traits, Allocator>;
template<class charT,
class traits,
class Allocator = allocator<charT>>
basic_string(basic_string_view<charT, traits>,
typename see below ::size_type, typename see below ::size_type,
const Allocator& = Allocator())
-> basic_string<charT, traits, Allocator>;
}
4 A size_type parameter type in abasic_string deduction guide refers to thesize_type member type of
the type deduced by the deduction guide.
5 The typesiterator and const_iterator meet the constexpr iterator requirements (24.3.1).
27.4.3.2 General requirements [string.require]
1 If any operation would causesize() to exceedmax_size(), that operation throws an exception object of
type length_error.
2 If any member function or operator ofbasic_string throws an exception, that function or operator has no
other effect on thebasic_string object.
3 Every object of typebasic_string<charT, traits, Allocator> uses an object of typeAllocator to
allocate and free storage for the containedcharT objects as needed. TheAllocator object used is obtained as
described in 23.2.2.2. In every specializationbasic_string<charT, traits, Allocator>, the typetraits
shall meet the character traits requirements (27.2).
[Note 1: Every specializationbasic_string<charT, traits, Allocator> is an allocator-aware container (23.2.2.5),
but does not use the allocator’sconstruct and destroy member functions (23.2.1). The program is ill-formed if
Allocator::value_type is not the same type ascharT. —end note]
[Note 2: The program is ill-formed iftraits::char_type is not the same type ascharT. —end note]
§ 27.4.3.2 © ISO/IEC
1592

===== PAGE 1604 =====

Dxxxx
4 References, pointers, and iterators referring to the elements of abasic_string sequence may be invalidated
by the following uses of thatbasic_string object:
—(4.1) Passing as an argument to any standard library function taking a reference to non-constbasic_string
as an argument.204
—(4.2) Calling non-const member functions, exceptoperator[], at, data, front, back, begin, rbegin, end,
and rend.
27.4.3.3 Constructors and assignment operators [string.cons]
constexpr explicit basic_string(const Allocator& a) noexcept;
1 Postconditions: size() is equal to0.
constexpr basic_string(const basic_string& str);
constexpr basic_string(basic_string&& str) noexcept;
2 Effects: Constructs an object whose value is that ofstr prior to this call.
3 Remarks: In the second form,str is left in a valid but unspecified state.
constexpr basic_string(const basic_string& str, size_type pos,
const Allocator& a = Allocator());
constexpr basic_string(const basic_string& str, size_type pos, size_type n,
const Allocator& a = Allocator());
constexpr basic_string(basic_string&& str, size_type pos,
const Allocator& a = Allocator());
constexpr basic_string(basic_string&& str, size_type pos, size_type n,
const Allocator& a = Allocator());
4 Let
—(4.1) s be the value ofstr prior to this call and
—(4.2) rlen be pos + min(n, s.size() - pos) for the overloads with parametern, and s.size()
otherwise.
5 Effects: Constructs an object whose initial value is the range[s.data() + pos,s.data() + rlen).
6 Throws: out_of_range if pos > s.size().
7 Remarks: For the overloads with abasic_string&& parameter, str is left in a valid but unspecified
state.
8 Recommended practice: For the overloads with abasic_string&& parameter, implementations should
avoid allocation ifs.get_allocator() == a is true.
template<class T>
constexpr basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator());
9 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
10 Effects: Creates a variable, sv, as if by basic_string_view<charT, traits> sv = t; and then
behaves the same as:
basic_string(sv.substr(pos, n), a);
template<class T>
constexpr explicit basic_string(const T& t, const Allocator& a = Allocator());
11 Constraints:
—(11.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(11.2) is_convertible_v<const T&, const charT*> is false.
12 Effects: Creates a variable, sv, as if by basic_string_view<charT, traits> sv = t; and then
behaves the same asbasic_string(sv.data(), sv.size(), a).
204) For example, as an argument to non-member functionsswap() (27.4.4.3), operator>>() (27.4.4.4), andgetline() (27.4.4.4),
or as an argument tobasic_string::swap().
§ 27.4.3.3 © ISO/IEC
1593

===== PAGE 1605 =====

Dxxxx
constexpr basic_string(const charT* s, size_type n, const Allocator& a = Allocator());
13 Preconditions: [s,s + n) is a valid range.
14 Effects: Constructs an object whose initial value is the range[s,s + n).
15 Postconditions: size() is equal ton, andtraits::compare(data(), s, n) is equal to0.
constexpr basic_string(const charT* s, const Allocator& a = Allocator());
16 Constraints: Allocator is a type that qualifies as an allocator (23.2.2.2).
[Note 1: This affects class template argument deduction.—end note]
17 Effects: Equivalent to:basic_string(s, traits::length(s), a).
constexpr basic_string(size_type n, charT c, const Allocator& a = Allocator());
18 Constraints: Allocator is a type that qualifies as an allocator (23.2.2.2).
[Note 2: This affects class template argument deduction.—end note]
19 Effects: Constructs an object whose value consists ofn copies ofc.
template<class InputIterator>
constexpr basic_string(InputIterator begin, InputIterator end, const Allocator& a = Allocator());
20 Constraints: InputIterator is a type that qualifies as an input iterator (23.2.2.2).
21 Effects: Constructs a string from the values in the range[begin,end), as specified in 23.2.4.
template<container-compatible-range <charT> R>
constexpr basic_string(from_range_t, R&& rg, const Allocator& = Allocator());
22 Effects: Constructs a string from the values in the rangerg, as specified in 23.2.4.
constexpr basic_string(initializer_list<charT> il, const Allocator& a = Allocator());
23 Effects: Equivalent tobasic_string(il.begin(), il.end(), a).
constexpr basic_string(const basic_string& str, const Allocator& alloc);
constexpr basic_string(basic_string&& str, const Allocator& alloc);
24 Effects: Constructs an object whose value is that ofstr prior to this call. The stored allocator is
constructed fromalloc. In the second form,str is left in a valid but unspecified state.
25 Throws: The second form throws nothing ifalloc == str.get_allocator().
template<class InputIterator,
class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
basic_string(InputIterator, InputIterator, Allocator = Allocator())
-> basic_string<typename iterator_traits<InputIterator>::value_type,
char_traits<typename iterator_traits<InputIterator>::value_type>,
Allocator>;
26 Constraints: InputIterator is a type that qualifies as an input iterator, andAllocator is a type that
qualifies as an allocator (23.2.2.2).
template<class charT,
class traits,
class Allocator = allocator<charT>>
explicit basic_string(basic_string_view<charT, traits>, const Allocator& = Allocator())
-> basic_string<charT, traits, Allocator>;
template<class charT,
class traits,
class Allocator = allocator<charT>>
basic_string(basic_string_view<charT, traits>,
typename see below ::size_type, typename see below ::size_type,
const Allocator& = Allocator())
-> basic_string<charT, traits, Allocator>;
27 Constraints: Allocator is a type that qualifies as an allocator (23.2.2.2).
§ 27.4.3.3 © ISO/IEC
1594

===== PAGE 1606 =====

Dxxxx
constexpr basic_string& operator=(const basic_string& str);
28 Effects: If *this and str are the same object, has no effect. Otherwise, replaces the value of*this
with a copy ofstr.
29 Returns: *this.
constexpr basic_string& operator=(basic_string&& str)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
30 Effects: Move assigns as a sequence container (23.2.4), except that iterators, pointers and references
may be invalidated.
31 Returns: *this.
template<class T>
constexpr basic_string& operator=(const T& t);
32 Constraints:
—(32.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(32.2) is_convertible_v<const T&, const charT*> is false.
33 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return assign(sv);
constexpr basic_string& operator=(const charT* s);
34 Effects: Equivalent to:return *this = basic_string_view<charT, traits>(s);
constexpr basic_string& operator=(charT c);
35 Effects: Equivalent to:
return *this = basic_string_view<charT, traits>(addressof(c), 1);
constexpr basic_string& operator=(initializer_list<charT> il);
36 Effects: Equivalent to:
return *this = basic_string_view<charT, traits>(il.data(), il.size());
27.4.3.4 Iterator support [string.iterators]
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
constexpr const_iterator cbegin() const noexcept;
1 Returns: An iterator referring to the first character in the string.
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
constexpr const_iterator cend() const noexcept;
2 Returns: An iterator which is the past-the-end value.
constexpr reverse_iterator rbegin() noexcept;
constexpr const_reverse_iterator rbegin() const noexcept;
constexpr const_reverse_iterator crbegin() const noexcept;
3 Returns: An iterator which is semantically equivalent toreverse_iterator(end()).
constexpr reverse_iterator rend() noexcept;
constexpr const_reverse_iterator rend() const noexcept;
constexpr const_reverse_iterator crend() const noexcept;
4 Returns: An iterator which is semantically equivalent toreverse_iterator(begin()).
27.4.3.5 Capacity [string.capacity]
constexpr size_type size() const noexcept;
§ 27.4.3.5 © ISO/IEC
1595

===== PAGE 1607 =====

Dxxxx
constexpr size_type length() const noexcept;
1 Returns: A count of the number of char-like objects currently in the string.
2 Complexity: Constant time.
constexpr size_type max_size() const noexcept;
3 Returns: The largest possible number of char-like objects that can be stored in abasic_string.
4 Complexity: Constant time.
constexpr void resize(size_type n, charT c);
5 Effects: Alters the value of*this as follows:
—(5.1) If n <= size(), erases the lastsize() - n elements.
—(5.2) If n > size(), appendsn - size() copies ofc.
constexpr void resize(size_type n);
6 Effects: Equivalent toresize(n, charT()).
template<class Operation> constexpr void resize_and_overwrite(size_type n, Operation op);
7 Let
—(7.1) o = size() before the call toresize_and_overwrite.
—(7.2) k be min(o, n).
—(7.3) p be a value of type charT* or charT* const, such that the range [p,p + n] is valid and
this->compare(0, k, p, k) == 0 is true before the call. The values in the range[p + k,p +
n] may be indeterminate (6.8.5).
—(7.4) m be a value of typesize_type or const size_type equal ton.
—(7.5) OP be the expressionstd::move(op)(p, m).
—(7.6) r = OP .
8 Mandates: OP has an integer-like type (24.3.4.4).
9 Preconditions:
—(9.1) OP does not throw an exception or modifyp or m.
—(9.2) r ≥0.
—(9.3) r ≤m.
—(9.4) After evaluatingOP there are no indeterminate values in the range[p,p + r).
10 Effects: EvaluatesOP , replaces the contents of*this with [p,p + r), and invalidates all pointers and
references to the range[p,p + n].
11 Recommended practice: Implementations should avoid unnecessary copies and allocations by, for example,
making p a pointer into internal storage and by restoring*(p + r) to charT() after evaluatingOP .
constexpr size_type capacity() const noexcept;
12 Returns: The size of the allocated storage in the string.
13 Complexity: Constant time.
constexpr void reserve(size_type res_arg);
14 Effects: A directive that informs abasic_string of a planned change in size, so that the storage
allocation can be managed accordingly. Following a call toreserve, capacity() is greater or equal
to the argument ofreserve if reallocation happens; and equal to the previous value ofcapacity()
otherwise. Reallocation happens at this point if and only if the current capacity is less than the
argument ofreserve.
15 Throws: length_error if res_arg > max_size() or any exceptions thrown byallocator_traits
<Allocator>::allocate.
§ 27.4.3.5 © ISO/IEC
1596

===== PAGE 1608 =====

Dxxxx
constexpr void shrink_to_fit();
16 Effects: shrink_to_fit is a non-binding request to reducecapacity() to size().
[Note 1: The request is non-binding to allow latitude for implementation-specific optimizations.—end note]
It does not increasecapacity(), but may reducecapacity() by causing reallocation.
17 Complexity: If the size is not equal to the old capacity, linear in the size of the sequence; otherwise
constant.
18 Remarks: Reallocation invalidates all the references, pointers, and iterators referring to the elements in
the sequence, as well as the past-the-end iterator.
[Note 2: If no reallocation happens, they remain valid.—end note]
constexpr void clear() noexcept;
19 Effects: Equivalent to:erase(begin(), end());
constexpr bool empty() const noexcept;
20 Effects: Equivalent to:return size() == 0;
27.4.3.6 Element access [string.access]
constexpr const_reference operator[](size_type pos) const;
constexpr reference operator[](size_type pos);
1 Hardened preconditions: pos <= size() is true.
2 Returns: *(begin() + pos) if pos < size(). Otherwise, returns a reference to an object of type
charT with value charT(), where modifying the object to any value other thancharT() leads to
undefined behavior.
3 Throws: Nothing.
4 Complexity: Constant time.
constexpr const_reference at(size_type pos) const;
constexpr reference at(size_type pos);
5 Returns: operator[](pos).
6 Throws: out_of_range if pos >= size().
constexpr const_reference front() const;
constexpr reference front();
7 Hardened preconditions: empty() is false.
8 Effects: Equivalent to:return operator[](0);
constexpr const_reference back() const;
constexpr reference back();
9 Hardened preconditions: empty() is false.
10 Effects: Equivalent to:return operator[](size() - 1);
27.4.3.7 Modifiers [string.modifiers]
27.4.3.7.1 basic_string::operator+= [string.op.append]
constexpr basic_string& operator+=(const basic_string& str);
1 Effects: Equivalent to:return append(str);
template<class T>
constexpr basic_string& operator+=(const T& t);
2 Constraints:
—(2.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(2.2) is_convertible_v<const T&, const charT*> is false.
§ 27.4.3.7.1 © ISO/IEC
1597

===== PAGE 1609 =====

Dxxxx
3 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return append(sv);
constexpr basic_string& operator+=(const charT* s);
4 Effects: Equivalent to:return append(s);
constexpr basic_string& operator+=(charT c);
5 Effects: Equivalent to:return append(size_type{1}, c);
constexpr basic_string& operator+=(initializer_list<charT> il);
6 Effects: Equivalent to:return append(il);
27.4.3.7.2 basic_string::append [string.append]
constexpr basic_string& append(const basic_string& str);
1 Effects: Equivalent to:return append(str.data(), str.size());
constexpr basic_string& append(const basic_string& str, size_type pos, size_type n = npos);
2 Effects: Equivalent to:
return append(basic_string_view<charT, traits>(str).substr(pos, n));
template<class T>
constexpr basic_string& append(const T& t);
3 Constraints:
—(3.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(3.2) is_convertible_v<const T&, const charT*> is false.
4 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return append(sv.data(), sv.size());
template<class T>
constexpr basic_string& append(const T& t, size_type pos, size_type n = npos);
5 Constraints:
—(5.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(5.2) is_convertible_v<const T&, const charT*> is false.
6 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return append(sv.substr(pos, n));
constexpr basic_string& append(const charT* s, size_type n);
7 Preconditions: [s,s + n) is a valid range.
8 Effects: Appends a copy of the range[s,s + n) to the string.
9 Returns: *this.
constexpr basic_string& append(const charT* s);
10 Effects: Equivalent to:return append(s, traits::length(s));
constexpr basic_string& append(size_type n, charT c);
11 Effects: Appends n copies ofc to the string.
12 Returns: *this.
template<class InputIterator>
constexpr basic_string& append(InputIterator first, InputIterator last);
13 Constraints: InputIterator is a type that qualifies as an input iterator (23.2.2.2).
§ 27.4.3.7.2 © ISO/IEC
1598

===== PAGE 1610 =====

Dxxxx
14 Effects: Equivalent to:return append(basic_string(first, last, get_allocator()));
template<container-compatible-range <charT> R>
constexpr basic_string& append_range(R&& rg);
15 Effects: Equivalent to:return append(basic_string(from_range, std::forward<R>(rg), get_-
allocator()));
constexpr basic_string& append(initializer_list<charT> il);
16 Effects: Equivalent to:return append(il.data(), il.size());
constexpr void push_back(charT c);
17 Effects: Equivalent toappend(size_type{1}, c).
27.4.3.7.3 basic_string::assign [string.assign]
constexpr basic_string& assign(const basic_string& str);
1 Effects: Equivalent to:return *this = str;
constexpr basic_string& assign(basic_string&& str)
noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
allocator_traits<Allocator>::is_always_equal::value);
2 Effects: Equivalent to:return *this = std::move(str);
constexpr basic_string& assign(const basic_string& str, size_type pos, size_type n = npos);
3 Effects: Equivalent to:
return assign(basic_string_view<charT, traits>(str).substr(pos, n));
template<class T>
constexpr basic_string& assign(const T& t);
4 Constraints:
—(4.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(4.2) is_convertible_v<const T&, const charT*> is false.
5 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return assign(sv.data(), sv.size());
template<class T>
constexpr basic_string& assign(const T& t, size_type pos, size_type n = npos);
6 Constraints:
—(6.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(6.2) is_convertible_v<const T&, const charT*> is false.
7 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return assign(sv.substr(pos, n));
constexpr basic_string& assign(const charT* s, size_type n);
8 Preconditions: [s,s + n) is a valid range.
9 Effects: Replaces the string controlled by*this with a copy of the range[s,s + n).
10 Returns: *this.
constexpr basic_string& assign(const charT* s);
11 Effects: Equivalent to:return assign(s, traits::length(s));
constexpr basic_string& assign(initializer_list<charT> il);
12 Effects: Equivalent to:return assign(il.data(), il.size());
§ 27.4.3.7.3 © ISO/IEC
1599

===== PAGE 1611 =====

Dxxxx
constexpr basic_string& assign(size_type n, charT c);
13 Effects: Equivalent to:
clear();
resize(n, c);
return *this;
template<class InputIterator>
constexpr basic_string& assign(InputIterator first, InputIterator last);
14 Constraints: InputIterator is a type that qualifies as an input iterator (23.2.2.2).
15 Effects: Equivalent to:return assign(basic_string(first, last, get_allocator()));
template<container-compatible-range <charT> R>
constexpr basic_string& assign_range(R&& rg);
16 Effects: Equivalent to:return assign(basic_string(from_range, std::forward<R>(rg), get_-
allocator()));
27.4.3.7.4 basic_string::insert [string.insert]
constexpr basic_string& insert(size_type pos, const basic_string& str);
1 Effects: Equivalent to:return insert(pos, str.data(), str.size());
constexpr basic_string& insert(size_type pos1, const basic_string& str,
size_type pos2, size_type n = npos);
2 Effects: Equivalent to:
return insert(pos1, basic_string_view<charT, traits>(str), pos2, n);
template<class T>
constexpr basic_string& insert(size_type pos, const T& t);
3 Constraints:
—(3.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(3.2) is_convertible_v<const T&, const charT*> is false.
4 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return insert(pos, sv.data(), sv.size());
template<class T>
constexpr basic_string& insert(size_type pos1, const T& t,
size_type pos2, size_type n = npos);
5 Constraints:
—(5.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(5.2) is_convertible_v<const T&, const charT*> is false.
6 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return insert(pos1, sv.substr(pos2, n));
constexpr basic_string& insert(size_type pos, const charT* s, size_type n);
7 Preconditions: [s,s + n) is a valid range.
8 Effects: Inserts a copy of the range[s,s + n) immediately before the character at positionpos if pos
< size(), or otherwise at the end of the string.
9 Returns: *this.
10 Throws:
—(10.1) out_of_range if pos > size(),
—(10.2) length_error if n > max_size() - size(), or
—(10.3) any exceptions thrown byallocator_traits<Allocator>::allocate.
§ 27.4.3.7.4 © ISO/IEC
1600

===== PAGE 1612 =====

Dxxxx
constexpr basic_string& insert(size_type pos, const charT* s);
11 Effects: Equivalent to:return insert(pos, s, traits::length(s));
constexpr basic_string& insert(size_type pos, size_type n, charT c);
12 Effects: Inserts n copies of c before the character at positionpos if pos < size(), or otherwise at the
end of the string.
13 Returns: *this.
14 Throws:
—(14.1) out_of_range if pos > size(),
—(14.2) length_error if n > max_size() - size(), or
—(14.3) any exceptions thrown byallocator_traits<Allocator>::allocate.
constexpr iterator insert(const_iterator p, charT c);
15 Preconditions: p is a valid iterator on*this.
16 Effects: Inserts a copy ofc at the positionp.
17 Returns: An iterator which refers to the inserted character.
constexpr iterator insert(const_iterator p, size_type n, charT c);
18 Preconditions: p is a valid iterator on*this.
19 Effects: Inserts n copies ofc at the positionp.
20 Returns: An iterator which refers to the first inserted character, orp if n == 0.
template<class InputIterator>
constexpr iterator insert(const_iterator p, InputIterator first, InputIterator last);
21 Constraints: InputIterator is a type that qualifies as an input iterator (23.2.2.2).
22 Preconditions: p is a valid iterator on*this.
23 Effects: Equivalent toinsert(p - begin(), basic_string(first, last, get_allocator())).
24 Returns: An iterator which refers to the first inserted character, orp if first == last.
template<container-compatible-range <charT> R>
constexpr iterator insert_range(const_iterator p, R&& rg);
25 Preconditions: p is a valid iterator on*this.
26 Effects: Equivalent to insert(p - begin(), basic_string(from_range, std::forward<R>(rg),
get_allocator())).
27 Returns: An iterator which refers to the first inserted character, orp if rg is empty.
constexpr iterator insert(const_iterator p, initializer_list<charT> il);
28 Effects: Equivalent to:return insert(p, il.begin(), il.end());
27.4.3.7.5 basic_string::erase [string.erase]
constexpr basic_string& erase(size_type pos = 0, size_type n = npos);
1 Effects: Determines the effective lengthxlen of the string to be removed as the smaller ofn and size()
- pos. Removes the characters in the range[begin() + pos,begin() + pos + xlen).
2 Returns: *this.
3 Throws: out_of_range if pos > size().
constexpr iterator erase(const_iterator p);
4 Preconditions: p is a valid dereferenceable iterator on*this.
5 Effects: Removes the character referred to byp.
6 Returns: An iterator which points to the element immediately followingp prior to the element being
erased. If no such element exists,end() is returned.
§ 27.4.3.7.5 © ISO/IEC
1601

===== PAGE 1613 =====

Dxxxx
7 Throws: Nothing.
constexpr iterator erase(const_iterator first, const_iterator last);
8 Preconditions: first and last are valid iterators on*this. [first,last) is a valid range.
9 Effects: Removes the characters in the range[first,last).
10 Returns: An iterator which points to the element pointed to bylast prior to the other elements being
erased. If no such element exists,end() is returned.
11 Throws: Nothing.
constexpr void pop_back();
12 Hardened preconditions: empty() is false.
13 Effects: Equivalent toerase(end() - 1).
14 Throws: Nothing.
27.4.3.7.6 basic_string::replace [string.replace]
constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
1 Effects: Equivalent to:return replace(pos1, n1, str.data(), str.size());
constexpr basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
size_type pos2, size_type n2 = npos);
2 Effects: Equivalent to:
return replace(pos1, n1, basic_string_view<charT, traits>(str).substr(pos2, n2));
template<class T>
constexpr basic_string& replace(size_type pos1, size_type n1, const T& t);
3 Constraints:
—(3.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(3.2) is_convertible_v<const T&, const charT*> is false.
4 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return replace(pos1, n1, sv.data(), sv.size());
template<class T>
constexpr basic_string& replace(size_type pos1, size_type n1, const T& t,
size_type pos2, size_type n2 = npos);
5 Constraints:
—(5.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(5.2) is_convertible_v<const T&, const charT*> is false.
6 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return replace(pos1, n1, sv.substr(pos2, n2));
constexpr basic_string& replace(size_type pos1, size_type n1, const charT* s, size_type n2);
7 Preconditions: [s,s + n2) is a valid range.
8 Effects: Determines the effective lengthxlen of the string to be removed as the smaller ofn1 and size()
- pos1. If size() - xlen >= max_size() - n2 throws length_error. Otherwise, the function
replaces the characters in the range[begin() + pos1,begin() + pos1 + xlen) with a copy of the
range [s,s + n2).
9 Returns: *this.
10 Throws:
—(10.1) out_of_range if pos1 > size(),
—(10.2) length_error if the length of the resulting string would exceedmax_size(), or
§ 27.4.3.7.6 © ISO/IEC
1602

===== PAGE 1614 =====

Dxxxx
—(10.3) any exceptions thrown byallocator_traits<Allocator>::allocate.
constexpr basic_string& replace(size_type pos, size_type n, const charT* s);
11 Effects: Equivalent to:return replace(pos, n, s, traits::length(s));
constexpr basic_string& replace(size_type pos1, size_type n1, size_type n2, charT c);
12 Effects: Determines the effective lengthxlen of the string to be removed as the smaller ofn1 and size()
- pos1. If size() - xlen >= max_size() - n2 throws length_error. Otherwise, the function
replaces the characters in the range[begin() + pos1,begin() + pos1 + xlen) with n2 copies ofc.
13 Returns: *this.
14 Throws:
—(14.1) out_of_range if pos1 > size(),
—(14.2) length_error if the length of the resulting string would exceedmax_size(), or
—(14.3) any exceptions thrown byallocator_traits<Allocator>::allocate.
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);
15 Effects: Equivalent to:return replace(i1, i2, basic_string_view<charT, traits>(str));
template<class T>
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const T& t);
16 Constraints:
—(16.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(16.2) is_convertible_v<const T&, const charT*> is false.
17 Preconditions: [begin(),i1) and [i1,i2) are valid ranges.
18 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
return replace(i1 - begin(), i2 - i1, sv.data(), sv.size());
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s, size_type n);
19 Effects: Equivalent to:return replace(i1, i2, basic_string_view<charT, traits>(s, n));
constexpr basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);
20 Effects: Equivalent to:return replace(i1, i2, basic_string_view<charT, traits>(s));
constexpr basic_string& replace(const_iterator i1, const_iterator i2, size_type n, charT c);
21 Preconditions: [begin(),i1) and [i1,i2) are valid ranges.
22 Effects: Equivalent to:return replace(i1 - begin(), i2 - i1, n, c);
template<class InputIterator>
constexpr basic_string& replace(const_iterator i1, const_iterator i2,
InputIterator j1, InputIterator j2);
23 Constraints: InputIterator is a type that qualifies as an input iterator (23.2.2.2).
24 Effects: Equivalent to:return replace(i1, i2, basic_string(j1, j2, get_allocator()));
template<container-compatible-range <charT> R>
constexpr basic_string& replace_with_range(const_iterator i1, const_iterator i2, R&& rg);
25 Effects: Equivalent to:
return replace(i1, i2, basic_string(from_range, std::forward<R>(rg), get_allocator()));
constexpr basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<charT> il);
26 Effects: Equivalent to:return replace(i1, i2, il.data(), il.size());
§ 27.4.3.7.6 © ISO/IEC
1603

===== PAGE 1615 =====

Dxxxx
27.4.3.7.7 basic_string::copy [string.copy]
constexpr size_type copy(charT* s, size_type n, size_type pos = 0) const;
1 Effects: Equivalent to:return basic_string_view<charT, traits>(*this).copy(s, n, pos);
[Note 1: This does not terminates with a null object.—end note]
27.4.3.7.8 basic_string::swap [string.swap]
constexpr void swap(basic_string& s)
noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value);
1 Preconditions: allocator_traits<Allocator>::propagate_on_container_swap::value is true or
get_allocator() == s.get_allocator().
2 Postconditions: *this contains the same sequence of characters that was ins, s contains the same
sequence of characters that was in*this.
3 Throws: Nothing.
4 Complexity: Constant time.
27.4.3.8 String operations [string.ops]
27.4.3.8.1 Accessors [string.accessors]
constexpr const charT* c_str() const noexcept;
constexpr const charT* data() const noexcept;
1 Returns: A pointerp such thatp + i == addressof(operator[](i)) for eachi in [0,size()].
2 Complexity: Constant time.
3 Remarks: The program shall not modify any of the values stored in the character array; otherwise, the
behavior is undefined.
constexpr charT* data() noexcept;
4 Returns: A pointerp such thatp + i == addressof(operator[](i)) for eachi in [0,size()].
5 Complexity: Constant time.
6 Remarks: The program shall not modify the value stored atp + size() to any value other than
charT(); otherwise, the behavior is undefined.
constexpr operator basic_string_view<charT, traits>() const noexcept;
7 Effects: Equivalent to:return basic_string_view<charT, traits>(data(), size());
constexpr allocator_type get_allocator() const noexcept;
8 Returns: A copy of theAllocator object used to construct the string or, if that allocator has been
replaced, a copy of the most recent replacement.
27.4.3.8.2 Searching [string.find]
1 Let F be one offind, rfind, find_first_of, find_last_of, find_first_not_of, andfind_last_not_of.
—(1.1) Each member function of the form
constexpr size_type F (const basic_string& str, size_type pos) const noexcept;
has effects equivalent to:return F (basic_string_view<charT, traits>(str), pos);
—(1.2) Each member function of the form
constexpr size_type F (const charT* s, size_type pos) const;
has effects equivalent to:return F (basic_string_view<charT, traits>(s), pos);
—(1.3) Each member function of the form
constexpr size_type F (const charT* s, size_type pos, size_type n) const;
has effects equivalent to:return F (basic_string_view<charT, traits>(s, n), pos);
§ 27.4.3.8.2 © ISO/IEC
1604

===== PAGE 1616 =====

Dxxxx
—(1.4) Each member function of the form
constexpr size_type F (charT c, size_type pos) const noexcept;
has effects equivalent to:
return F (basic_string_view<charT, traits>(addressof(c), 1), pos);
template<class T>
constexpr size_type find(const T& t, size_type pos = 0) const noexcept(see below );
template<class T>
constexpr size_type rfind(const T& t, size_type pos = npos) const noexcept(see below );
template<class T>
constexpr size_type find_first_of(const T& t, size_type pos = 0) const noexcept(see below );
template<class T>
constexpr size_type find_last_of(const T& t, size_type pos = npos) const noexcept(see below );
template<class T>
constexpr size_type find_first_not_of(const T& t, size_type pos = 0) const noexcept(see below );
template<class T>
constexpr size_type find_last_not_of(const T& t, size_type pos = npos) const noexcept(see below );
2 Constraints:
—(2.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(2.2) is_convertible_v<const T&, const charT*> is false.
3 Effects: Let G be the name of the function. Equivalent to:
basic_string_view<charT, traits> s = *this, sv = t;
return s.G (sv, pos);
4 Remarks: Theexceptionspecificationisequivalentto is_nothrow_convertible_v<const T&, basic_-
string_view<charT, traits>>.
27.4.3.8.3 basic_string::substr [string.substr]
constexpr basic_string substr(size_type pos = 0, size_type n = npos) const &;
1 Effects: Equivalent to:return basic_string(*this, pos, n);
constexpr basic_string substr(size_type pos = 0, size_type n = npos) &&;
2 Effects: Equivalent to:return basic_string(std::move(*this), pos, n);
constexpr basic_string_view<charT, traits> subview(size_type pos = 0, size_type n = npos) const;
3 Effects: Equivalent to:return basic_string_view<charT, traits>(*this).subview(pos, n);
27.4.3.8.4 basic_string::compare [string.compare]
template<class T>
constexpr int compare(const T& t) const noexcept(see below );
1 Constraints:
—(1.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(1.2) is_convertible_v<const T&, const charT*> is false.
2 Effects: Equivalent to:return basic_string_view<charT, traits>(*this).compare(t);
3 Remarks: Theexceptionspecificationisequivalentto is_nothrow_convertible_v<const T&, basic_-
string_view<charT, traits>>.
template<class T>
constexpr int compare(size_type pos1, size_type n1, const T& t) const;
4 Constraints:
—(4.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(4.2) is_convertible_v<const T&, const charT*> is false.
5 Effects: Equivalent to:
return basic_string_view<charT, traits>(*this).substr(pos1, n1).compare(t);
§ 27.4.3.8.4 © ISO/IEC
1605

===== PAGE 1617 =====

Dxxxx
template<class T>
constexpr int compare(size_type pos1, size_type n1, const T& t,
size_type pos2, size_type n2 = npos) const;
6 Constraints:
—(6.1) is_convertible_v<const T&, basic_string_view<charT, traits>> is true and
—(6.2) is_convertible_v<const T&, const charT*> is false.
7 Effects: Equivalent to:
basic_string_view<charT, traits> s = *this, sv = t;
return s.substr(pos1, n1).compare(sv.substr(pos2, n2));
constexpr int compare(const basic_string& str) const noexcept;
8 Effects: Equivalent to:return compare(basic_string_view<charT, traits>(str));
constexpr int compare(size_type pos1, size_type n1, const basic_string& str) const;
9 Effects: Equivalent to:return compare(pos1, n1, basic_string_view<charT, traits>(str));
constexpr int compare(size_type pos1, size_type n1, const basic_string& str,
size_type pos2, size_type n2 = npos) const;
10 Effects: Equivalent to:
return compare(pos1, n1, basic_string_view<charT, traits>(str), pos2, n2);
constexpr int compare(const charT* s) const;
11 Effects: Equivalent to:return compare(basic_string_view<charT, traits>(s));
constexpr int compare(size_type pos, size_type n1, const charT* s) const;
12 Effects: Equivalent to:return compare(pos, n1, basic_string_view<charT, traits>(s));
constexpr int compare(size_type pos, size_type n1, const charT* s, size_type n2) const;
13 Effects: Equivalent to:return compare(pos, n1, basic_string_view<charT, traits>(s, n2));
27.4.3.8.5 basic_string::starts_with [string.starts.with]
constexpr bool starts_with(basic_string_view<charT, traits> x) const noexcept;
constexpr bool starts_with(charT x) const noexcept;
constexpr bool starts_with(const charT* x) const;
1 Effects: Equivalent to:
return basic_string_view<charT, traits>(data(), size()).starts_with(x);
27.4.3.8.6 basic_string::ends_with [string.ends.with]
constexpr bool ends_with(basic_string_view<charT, traits> x) const noexcept;
constexpr bool ends_with(charT x) const noexcept;
constexpr bool ends_with(const charT* x) const;
1 Effects: Equivalent to:
return basic_string_view<charT, traits>(data(), size()).ends_with(x);
27.4.3.8.7 basic_string::contains [string.contains]
constexpr bool contains(basic_string_view<charT, traits> x) const noexcept;
constexpr bool contains(charT x) const noexcept;
constexpr bool contains(const charT* x) const;
1 Effects: Equivalent to:
return basic_string_view<charT, traits>(data(), size()).contains(x);
§ 27.4.3.8.7 © ISO/IEC
1606

===== PAGE 1618 =====

Dxxxx
27.4.4 Non-member functions [string.nonmembers]
27.4.4.1 operator+ [string.op.plus]
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);
1 Effects: Equivalent to:
basic_string<charT, traits, Allocator> r = lhs;
r.append(rhs);
return r;
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
const basic_string<charT, traits, Allocator>& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs, const charT* rhs);
2 Effects: Equivalent to:
lhs.append(rhs);
return std::move(lhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
basic_string<charT, traits, Allocator>&& rhs);
3 Effects: Equivalent to:
lhs.append(rhs);
return std::move(lhs);
except that bothlhs and rhs are left in valid but unspecified states.
[Note 1: If lhs and rhs have equal allocators, the implementation can move from either.—end note]
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
basic_string<charT, traits, Allocator>&& rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const charT* lhs, basic_string<charT, traits, Allocator>&& rhs);
4 Effects: Equivalent to:
rhs.insert(0, lhs);
return std::move(rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs);
5 Effects: Equivalent to:
basic_string<charT, traits, Allocator> r = rhs;
r.insert(0, lhs);
return r;
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(charT lhs, const basic_string<charT, traits, Allocator>& rhs);
6 Effects: Equivalent to:
§ 27.4.4.1 © ISO/IEC
1607

===== PAGE 1619 =====

Dxxxx
basic_string<charT, traits, Allocator> r = rhs;
r.insert(r.begin(), lhs);
return r;
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(charT lhs, basic_string<charT, traits, Allocator>&& rhs);
7 Effects: Equivalent to:
rhs.insert(rhs.begin(), lhs);
return std::move(rhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);
8 Effects: Equivalent to:
basic_string<charT, traits, Allocator> r = lhs;
r.push_back(rhs);
return r;
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs, charT rhs);
9 Effects: Equivalent to:
lhs.push_back(rhs);
return std::move(lhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
type_identity_t<basic_string_view<charT, traits>> rhs);
10 Equivalent to:
basic_string<charT, traits, Allocator> r = lhs;
r.append(rhs);
return r;
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(basic_string<charT, traits, Allocator>&& lhs,
type_identity_t<basic_string_view<charT, traits>> rhs);
11 Equivalent to:
lhs.append(rhs);
return std::move(lhs);
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(type_identity_t<basic_string_view<charT, traits>> lhs,
const basic_string<charT, traits, Allocator>& rhs);
12 Equivalent to:
basic_string<charT, traits, Allocator> r = rhs;
r.insert(0, lhs);
return r;
template<class charT, class traits, class Allocator>
constexpr basic_string<charT, traits, Allocator>
operator+(type_identity_t<basic_string_view<charT, traits>> lhs,
basic_string<charT, traits, Allocator>&& rhs);
13 Equivalent to:
rhs.insert(0, lhs);
return std::move(rhs);
§ 27.4.4.1 © ISO/IEC
1608

===== PAGE 1620 =====

Dxxxx
14 [Note 2: Using a specialization oftype_identity_t as a parameter type ensures that an object of typebasic_-
string<charT, traits, Allocator> can be concatenated with an object of a typeT having an implicit conversion
to basic_string_view<charT, traits> (12.2.2.3). —end note]
27.4.4.2 Non-member comparison operator functions [string.cmp]
template<class charT, class traits, class Allocator>
constexpr bool
operator==(const basic_string<charT, traits, Allocator>& lhs,
const basic_string<charT, traits, Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
constexpr bool operator==(const basic_string<charT, traits, Allocator>& lhs,
const charT* rhs);
template<class charT, class traits, class Allocator>
constexpr see below operator<=>(const basic_string<charT, traits, Allocator>& lhs,
const basic_string<charT, traits, Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
constexpr see below operator<=>(const basic_string<charT, traits, Allocator>& lhs,
const charT* rhs);
1 Effects: Let op be the operator. Equivalent to:
return basic_string_view<charT, traits>(lhs) op basic_string_view<charT, traits>(rhs);
27.4.4.3 swap [string.special]
template<class charT, class traits, class Allocator>
constexpr void
swap(basic_string<charT, traits, Allocator>& lhs,
basic_string<charT, traits, Allocator>& rhs)
noexcept(noexcept(lhs.swap(rhs)));
1 Effects: Equivalent tolhs.swap(rhs).
27.4.4.4 Inserters and extractors [string.io]
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);
1 Effects: Behaves as a formatted input function (31.7.5.3.1). After constructing asentry object, if
the sentry object returnstrue when converted to a value of typebool, callsstr.erase() and then
extracts characters fromisand appends them tostras if by callingstr.append(1, c). If is.width()
is greater than zero, the maximum numbern of characters appended isis.width(); otherwisen is
str.max_size(). Characters are extracted and appended until any of the following occurs:
—(1.1) n characters are stored;
—(1.2) end-of-file occurs on the input sequence;
—(1.3) isspace(c, is.getloc()) is true for the next available input characterc.
2 After the last character (if any) is extracted,is.width(0) is called and thesentry object is destroyed.
3 If the function extracts no characters,ios_base::failbit is set in the input function’s local error
state beforesetstate is called.
4 Returns: is.
template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os,
const basic_string<charT, traits, Allocator>& str);
5 Effects: Equivalent to:return os << basic_string_view<charT, traits>(str);
§ 27.4.4.4 © ISO/IEC
1609

===== PAGE 1621 =====

Dxxxx
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is,
basic_string<charT, traits, Allocator>& str,
charT delim);
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>&& is,
basic_string<charT, traits, Allocator>& str,
charT delim);
6 Effects: Behaves as an unformatted input function (31.7.5.4), except that it does not affect the value
returned by subsequent calls tobasic_istream<>::gcount(). After constructing asentry object, if
the sentry object returnstrue when converted to a value of typebool, callsstr.erase() and then
extracts characters fromis and appends them tostr as if by callingstr.append(1, c) until any of
the following occurs:
—(6.1) end-of-file occurs on the input sequence;
—(6.2) traits::eq(c, delim) for the next available input characterc (in which case,c is extracted but
not appended);
—(6.3) str.max_size() characters are stored (in which case,ios_base::failbit is set in the input
function’s local error state).
7 The conditions are tested in the order shown. In any case, after the last character is extracted, the
sentry object is destroyed.
8 If the function extracts no characters,ios_base::failbit is set in the input function’s local error
state beforesetstate is called.
9 Returns: is.
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is,
basic_string<charT, traits, Allocator>& str);
template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>&& is,
basic_string<charT, traits, Allocator>& str);
10 Returns: getline(is, str, is.widen(’\n’)).
27.4.4.5 Erasure [string.erasure]
template<class charT, class traits, class Allocator, class U = charT>
constexpr typename basic_string<charT, traits, Allocator>::size_type
erase(basic_string<charT, traits, Allocator>& c, const U& value);
1 Effects: Equivalent to:
auto it = remove(c.begin(), c.end(), value);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
template<class charT, class traits, class Allocator, class Predicate>
constexpr typename basic_string<charT, traits, Allocator>::size_type
erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred);
2 Effects: Equivalent to:
auto it = remove_if(c.begin(), c.end(), pred);
auto r = distance(it, c.end());
c.erase(it, c.end());
return r;
27.4.5 Numeric conversions [string.conversions]
int stoi(const string& str, size_t* idx = nullptr, int base = 10);
§ 27.4.5 © ISO/IEC
1610

===== PAGE 1622 =====

Dxxxx
long stol(const string& str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(const string& str, size_t* idx = nullptr, int base = 10);
long long stoll(const string& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);
1 Effects: Thefirsttwofunctionscall strtol(str.c_str(), ptr, base), andthelastthreefunctionscall
strtoul(str.c_str(), ptr, base), strtoll(str.c_str(), ptr, base), and strtoull(str.c_-
str(), ptr, base), respectively. Each function returns the converted result, if any. The argument
ptr designates a pointer to an object internal to the function that is used to determine what to store
at *idx. If the function does not throw an exception andidx != nullptr, the function stores in*idx
the index of the first unconverted element ofstr.
2 Returns: The converted result.
3 Throws: invalid_argument if strtol, strtoul, strtoll, orstrtoull reports that no conversion can
be performed. Throwsout_of_range if strtol, strtoul, strtoll or strtoull sets errno to ERANGE,
or if the converted value is outside the range of representable values for the return type.
float stof(const string& str, size_t* idx = nullptr);
double stod(const string& str, size_t* idx = nullptr);
long double stold(const string& str, size_t* idx = nullptr);
4 Effects: These functions callstrtof(str.c_str(), ptr), strtod(str.c_str(), ptr), andstrtold(
str.c_str(), ptr), respectively. Each function returns the converted result, if any. The argument
ptr designates a pointer to an object internal to the function that is used to determine what to store
at *idx. If the function does not throw an exception andidx != nullptr, the function stores in*idx
the index of the first unconverted element ofstr.
5 Returns: The converted result.
6 Throws: invalid_argumentif strtof, strtod, orstrtoldreports that no conversion can be performed.
Throws out_of_range if strtof, strtod, orstrtold sets errno to ERANGE or if the converted value
is outside the range of representable values for the return type.
constexpr string to_string(int val);
constexpr string to_string(unsigned val);
constexpr string to_string(long val);
constexpr string to_string(unsigned long val);
constexpr string to_string(long long val);
constexpr string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);
7 Returns: format("{}", val).
int stoi(const wstring& str, size_t* idx = nullptr, int base = 10);
long stol(const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(const wstring& str, size_t* idx = nullptr, int base = 10);
long long stoll(const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);
8 Effects: Thefirsttwofunctionscall wcstol(str.c_str(), ptr, base), andthelastthreefunctionscall
wcstoul(str.c_str(), ptr, base), wcstoll(str.c_str(), ptr, base), and wcstoull(str.c_-
str(), ptr, base), respectively. Each function returns the converted result, if any. The argument
ptr designates a pointer to an object internal to the function that is used to determine what to store
at *idx. If the function does not throw an exception andidx != nullptr, the function stores in*idx
the index of the first unconverted element ofstr.
9 Returns: The converted result.
10 Throws: invalid_argument if wcstol, wcstoul, wcstoll, orwcstoull reports that no conversion can
be performed. Throwsout_of_range if the converted value is outside the range of representable values
for the return type.
float stof(const wstring& str, size_t* idx = nullptr);
double stod(const wstring& str, size_t* idx = nullptr);
§ 27.4.5 © ISO/IEC
1611

===== PAGE 1623 =====

Dxxxx
long double stold(const wstring& str, size_t* idx = nullptr);
11 Effects: These functions callwcstof(str.c_str(), ptr), wcstod(str.c_str(), ptr), andwcstold(
str.c_str(), ptr), respectively. Each function returns the converted result, if any. The argument
ptr designates a pointer to an object internal to the function that is used to determine what to store
at *idx. If the function does not throw an exception andidx != nullptr, the function stores in*idx
the index of the first unconverted element ofstr.
12 Returns: The converted result.
13 Throws: invalid_argumentif wcstof, wcstod, orwcstoldreports that no conversion can be performed.
Throws out_of_range if wcstof, wcstod, orwcstold sets errno to ERANGE.
constexpr wstring to_wstring(int val);
constexpr wstring to_wstring(unsigned val);
constexpr wstring to_wstring(long val);
constexpr wstring to_wstring(unsigned long val);
constexpr wstring to_wstring(long long val);
constexpr wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);
14 Returns: format(L"{}", val).
27.4.6 Hash support [basic.string.hash]
template<class A> struct hash<basic_string<char, char_traits<char>, A>>;
template<class A> struct hash<basic_string<char8_t, char_traits<char8_t>, A>>;
template<class A> struct hash<basic_string<char16_t, char_traits<char16_t>, A>>;
template<class A> struct hash<basic_string<char32_t, char_traits<char32_t>, A>>;
template<class A> struct hash<basic_string<wchar_t, char_traits<wchar_t>, A>>;
1 If S is one of these string types,SV is the corresponding string view type, ands is an object of typeS,
then hash<S>()(s) == hash<SV>()(SV(s)).
27.4.7 Suffix for basic_string literals [basic.string.literals]
constexpr string operator""s(const char* str, size_t len);
1 Returns: string{str, len}.
constexpr u8string operator""s(const char8_t* str, size_t len);
2 Returns: u8string{str, len}.
constexpr u16string operator""s(const char16_t* str, size_t len);
3 Returns: u16string{str, len}.
constexpr u32string operator""s(const char32_t* str, size_t len);
4 Returns: u32string{str, len}.
constexpr wstring operator""s(const wchar_t* str, size_t len);
5 Returns: wstring{str, len}.
6 [Note 1: The same suffixs is used forchrono::duration literals denoting seconds but there is no conflict, since
duration suffixes apply to numbers and string literal suffixes apply to character array literals.—end note]
27.5 Null-terminated sequence utilities [c.strings]
27.5.1 Header <cstring> synopsis [cstring.syn]
#define __STDC_VERSION_STRING_H__ 202311L
namespace std {
using size_t = see 17.2.4; // freestanding
§ 27.5.1 © ISO/IEC
1612

===== PAGE 1624 =====

Dxxxx
void* memcpy(void* s1, const void* s2, size_t n); // freestanding
void* memccpy(void* s1, const void* s2, int c, size_t n); // freestanding
void* memmove(void* s1, const void* s2, size_t n); // freestanding
char* strcpy(char* s1, const char* s2); // freestanding
char* strncpy(char* s1, const char* s2, size_t n); // freestanding
char* strdup(const char* s);
char* strndup(const char* s, size_t size);
char* strcat(char* s1, const char* s2); // freestanding
char* strncat(char* s1, const char* s2, size_t n); // freestanding
int memcmp(const void* s1, const void* s2, size_t n); // freestanding
int strcmp(const char* s1, const char* s2); // freestanding
int strcoll(const char* s1, const char* s2);
int strncmp(const char* s1, const char* s2, size_t n); // freestanding
size_t strxfrm(char* s1, const char* s2, size_t n);
const void* memchr(const void* s, int c, size_t n); // freestanding; see 16.2
void* memchr(void* s, int c, size_t n); // freestanding; see 16.2
const char* strchr(const char* s, int c); // freestanding; see 16.2
char* strchr(char* s, int c); // freestanding; see 16.2
size_t strcspn(const char* s1, const char* s2); // freestanding
const char* strpbrk(const char* s1, const char* s2); // freestanding; see 16.2
char* strpbrk(char* s1, const char* s2); // freestanding; see 16.2
const char* strrchr(const char* s, int c); // freestanding; see 16.2
char* strrchr(char* s, int c); // freestanding; see 16.2
size_t strspn(const char* s1, const char* s2); // freestanding
const char* strstr(const char* s1, const char* s2); // freestanding; see 16.2
char* strstr(char* s1, const char* s2); // freestanding; see 16.2
char* strtok(char* s1, const char* s2);
void* memset(void* s, int c, size_t n); // freestanding
void* memset_explicit(void* s, int c, size_t n); // freestanding
char* strerror(int errnum);
size_t strlen(const char* s); // freestanding
}
#define NULL see 17.2.3 // freestanding
1 The contents and meaning of the header<cstring>are the same as the C standard library header<string.h>.
2 The functionsstrerror and strtok are not required to avoid data races (16.4.6.10).
3 The functions memcpy and memmove are signal-safe (17.14.5). Each of these functions implicitly creates
objects (6.8.2) in the destination region of storage immediately prior to copying the sequence of characters to
the destination. Each of these functions returns a pointer to a suitable created object, if any, otherwise the
value of the first parameter.
4 [Note 1: The functionsstrchr, strpbrk, strrchr, strstr, andmemchr, have different signatures in this document,
but they have the same behavior as in the C standard library (16.2).—end note]
See also: ISO/IEC 9899:2024, 7.26
§ 27.5.1 © ISO/IEC
1613

===== PAGE 1625 =====

Dxxxx
28 Text processing library [text]
28.1 General [text.general]
This Clause describes components for dealing with text. These components are summarized in Table 89.
Table 89 — Text library summary [tab:text.summary]
Subclause Header
28.2 Primitive numeric conversions <charconv>
28.3 Localization library <locale>, <clocale>
28.5 Formatting <format>
28.4 Text encodings identification <text_encoding>
28.6 Regular expressions library <regex>
28.7 Null-terminated sequence utilities <cctype>, <cstdlib>, <cuchar>, <cwchar>, <cwctype>
28.2 Primitive numeric conversions [charconv]
28.2.1 Header <charconv> synopsis [charconv.syn]
1 When a function is specified with a type placeholder ofinteger-type , the implementation provides overloads
for char and all signed and unsigned integer types in lieu ofinteger-type . When a function is specified with
a type placeholder offloating-point-type , the implementation provides overloads for all cv-unqualified
floating-point types (6.9.2) in lieu offloating-point-type .
namespace std {
// floating-point format for primitive numerical conversion
enum class chars_format {
scientific = unspecified ,
fixed = unspecified ,
hex = unspecified ,
general = fixed | scientific
};
// 28.2.2, primitive numerical output conversion
struct to_chars_result { // freestanding
char* ptr;
errc ec;
friend bool operator==(const to_chars_result&, const to_chars_result&) = default;
constexpr explicit operator bool() const noexcept { return ec == errc{}; }
};
constexpr to_chars_result to_chars(char* first, char* last, // freestanding
integer-type value, int base = 10);
to_chars_result to_chars(char* first, char* last, // freestanding
bool value, int base = 10) = delete;
to_chars_result to_chars(char* first, char* last, // freestanding-deleted
floating-point-type value);
to_chars_result to_chars(char* first, char* last, // freestanding-deleted
floating-point-type value, chars_format fmt);
to_chars_result to_chars(char* first, char* last, // freestanding-deleted
floating-point-type value, chars_format fmt, int precision);
// 28.2.3, primitive numerical input conversion
struct from_chars_result { // freestanding
const char* ptr;
errc ec;
friend bool operator==(const from_chars_result&, const from_chars_result&) = default;
§ 28.2.1 © ISO/IEC
1614

===== PAGE 1626 =====

Dxxxx
constexpr explicit operator bool() const noexcept { return ec == errc{}; }
};
constexpr from_chars_result from_chars(const char* first, const char* last, // freestanding
integer-type & value, int base = 10);
from_chars_result from_chars(const char* first, const char* last, // freestanding-deleted
floating-point-type & value,
chars_format fmt = chars_format::general);
}
2 The typechars_format is a bitmask type (16.3.3.3.3) with elementsscientific, fixed, andhex.
3 The typesto_chars_result and from_chars_result have the data members and special members specified
above. They have no base classes or members other than those specified.
28.2.2 Primitive numeric output conversion [charconv.to.chars]
1 All functions named to_chars convert value into a character string by successively filling the range
[first,last), where[first,last) is required to be a valid range. If the memberec of the return value
is such that the value is equal to the value of a value-initializederrc, the conversion was successful and
the memberptr is the one-past-the-end pointer of the characters written. Otherwise, the memberec has
the value errc::value_too_large, the memberptr has the valuelast, and the contents of the range
[first,last) are unspecified.
2 The functions that take a floating-pointvalue but not a precision parameter ensure that the string
representation consists of the smallest number of characters such that there is at least one digit before the
radix point (if present) and parsing the representation using the correspondingfrom_chars function recovers
value exactly.
[Note 1: This guarantee applies only ifto_chars and from_chars are executed on the same implementation.—end
note]
If there are several such representations, the representation with the smallest difference from the floating-
point argument value is chosen, resolving any remaining ties using rounding according toround_to_-
nearest (17.3.4).
3 The functions taking achars_format parameter determine the conversion specifier forprintf as follows:
The conversion specifier isf if fmt is chars_format::fixed, e if fmt is chars_format::scientific, a
(without leading"0x" in the result) iffmt is chars_format::hex, andg if fmt is chars_format::general.
constexpr to_chars_result to_chars(char* first, char* last, integer-type value, int base = 10);
4 Preconditions: base has a value between 2 and 36 (inclusive).
5 Effects: The value ofvalue is converted to a string of digits in the given base (with no redundant
leading zeroes). Digits in the range 10..35 (inclusive) are represented as lowercase charactersa..z. If
value is less than zero, the representation starts with’-’.
6 Throws: Nothing.
to_chars_result to_chars(char* first, char* last, floating-point-type value);
7 Effects: value is converted to a string in the style ofprintf in the"C" locale. The conversion specifier
is f or e, chosen according to the requirement for a shortest representation (see above); a tie is resolved
in favor off.
8 Throws: Nothing.
to_chars_result to_chars(char* first, char* last, floating-point-type value, chars_format fmt);
9 Preconditions: fmt has the value of one of the enumerators ofchars_format.
10 Effects: value is converted to a string in the style ofprintf in the"C" locale.
11 Throws: Nothing.
to_chars_result to_chars(char* first, char* last, floating-point-type value,
chars_format fmt, int precision);
12 Preconditions: fmt has the value of one of the enumerators ofchars_format.
§ 28.2.2 © ISO/IEC
1615

===== PAGE 1627 =====

Dxxxx
13 Effects: value is converted to a string in the style ofprintf in the"C" locale with the given precision.
14 Throws: Nothing.
See also: ISO/IEC 9899:2024, 7.23.6.2
28.2.3 Primitive numeric input conversion [charconv.from.chars]
1 All functions named from_chars analyze the string [first,last) for a pattern, where[first,last) is
required to be a valid range. If no characters match the pattern,value is unmodified, the memberptr of
the return value isfirst and the memberec is equal toerrc::invalid_argument.
[Note 1: If the pattern allows for an optional sign, but the string has no digit characters following the sign, no
characters match the pattern.—end note]
Otherwise, the characters matching the pattern are interpreted as a representation of a value of the type of
value. The memberptr of the return value points to the first character not matching the pattern, or has
the valuelast if all characters match. If the parsed value is not in the range representable by the type of
value, value is unmodified and the memberec of the return value is equal toerrc::result_out_of_range.
Otherwise, value is set to the parsed value, after rounding according toround_to_nearest (17.3.4), and
the memberec is value-initialized.
constexpr from_chars_result from_chars(const char* first, const char* last,
integer-type & value, int base = 10);
2 Preconditions: base has a value between 2 and 36 (inclusive).
3 Effects: The pattern is the expected form of the subject sequence in the"C" locale for the given nonzero
base, as described forstrtol, except that no"0b" or "0B" prefix shall appear if the value ofbase is 2,
no "0x" or "0X" prefix shall appear if the value ofbase is 16, and except that’-’ is the only sign that
may appear, and only ifvalue has a signed type.
4 Throws: Nothing.
from_chars_result from_chars(const char* first, const char* last, floating-point-type & value,
chars_format fmt = chars_format::general);
5 Preconditions: fmt has the value of one of the enumerators ofchars_format.
6 Effects: The pattern is the expected form of the subject sequence in the"C" locale, as described for
strtod, except that
—(6.1) the sign’+’ may only appear in the exponent part;
—(6.2) if fmt has chars_format::scientific set but notchars_format::fixed, the otherwise optional
exponent part shall appear;
—(6.3) if fmt has chars_format::fixed set but notchars_format::scientific, the optional exponent
part shall not appear; and
—(6.4) if fmt is chars_format::hex, the prefix"0x" or "0X" is assumed.
[Example 1: The string 0x123 is parsed to have the value0 with remaining charactersx123. —end
example]
In any case, the resultingvalue is one of at most two floating-point values closest to the value of the
string matching the pattern.
7 Throws: Nothing.
See also: ISO/IEC 9899:2024, 7.24.2.6, 7.24.2.8
28.3 Localization library [localization]
28.3.1 General [localization.general]
1 Subclause 28.3 describes components that C++ programs may use to encapsulate (and therefore be more
portable when confronting) cultural differences. The locale facility includes internationalization support for
character classification and string collation, numeric, monetary, and date/time formatting and parsing, and
message retrieval.
2 The following subclauses describe components for locales themselves, the standard facets, and facilities from
the C library, as summarized in Table 90.
§ 28.3.1 © ISO/IEC
1616

===== PAGE 1628 =====

Dxxxx
Table 90 — Localization library summary [tab:localization.summary]
Subclause Header
28.3.3 Locales <locale>
28.3.4 Standard locale categories
28.3.5 C library locales <clocale>
28.3.2 Header <locale> synopsis [locale.syn]
namespace std {
// 28.3.3.1, locale
class locale;
template<class Facet> const Facet& use_facet(const locale&);
template<class Facet> bool has_facet(const locale&) noexcept;
// 28.3.3.3, convenience interfaces
template<class charT> bool isspace (charT c, const locale& loc);
template<class charT> bool isprint (charT c, const locale& loc);
template<class charT> bool iscntrl (charT c, const locale& loc);
template<class charT> bool isupper (charT c, const locale& loc);
template<class charT> bool islower (charT c, const locale& loc);
template<class charT> bool isalpha (charT c, const locale& loc);
template<class charT> bool isdigit (charT c, const locale& loc);
template<class charT> bool ispunct (charT c, const locale& loc);
template<class charT> bool isxdigit(charT c, const locale& loc);
template<class charT> bool isalnum (charT c, const locale& loc);
template<class charT> bool isgraph (charT c, const locale& loc);
template<class charT> bool isblank (charT c, const locale& loc);
template<class charT> charT toupper(charT c, const locale& loc);
template<class charT> charT tolower(charT c, const locale& loc);
// 28.3.4.2, ctype
class ctype_base;
template<class charT> class ctype;
template<> class ctype<char>; // specialization
template<class charT> class ctype_byname;
class codecvt_base;
template<class internT, class externT, class stateT> class codecvt;
template<class internT, class externT, class stateT> class codecvt_byname;
// 28.3.4.3, numeric
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class num_get;
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class num_put;
template<class charT>
class numpunct;
template<class charT>
class numpunct_byname;
// 28.3.4.5, collation
template<class charT> class collate;
template<class charT> class collate_byname;
// 28.3.4.6, date and time
class time_base;
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class time_get;
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class time_get_byname;
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class time_put;
§ 28.3.2 © ISO/IEC
1617

===== PAGE 1629 =====

Dxxxx
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class time_put_byname;
// 28.3.4.7, money
class money_base;
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class money_get;
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class money_put;
template<class charT, bool Intl = false>
class moneypunct;
template<class charT, bool Intl = false>
class moneypunct_byname;
// 28.3.4.8, message retrieval
class messages_base;
template<class charT> class messages;
template<class charT> class messages_byname;
}
1 The header<locale> defines classes and declares functions that encapsulate and manipulate the information
peculiar to a locale.205
28.3.3 Locales [locales]
28.3.3.1 Class locale [locale]
28.3.3.1.1 General [locale.general]
namespace std {
class locale {
public:
// 28.3.3.1.2, types
// 28.3.3.1.2.2, classlocale::facet
class facet;
// 28.3.3.1.2.3, classlocale::id
class id;
// 28.3.3.1.2.1, typelocale::category
using category = int;
static const category // values assigned here are for exposition only
none = 0,
collate = 0x010, ctype = 0x020,
monetary = 0x040, numeric = 0x080,
time = 0x100, messages = 0x200,
all = collate | ctype | monetary | numeric | time | messages;
// 28.3.3.1.3, construct/copy/destroy
locale() noexcept;
locale(const locale& other) noexcept;
explicit locale(const char* std_name);
explicit locale(const string& std_name);
locale(const locale& other, const char* std_name, category);
locale(const locale& other, const string& std_name, category);
template<class Facet> locale(const locale& other, Facet* f);
locale(const locale& other, const locale& one, category);
~locale(); // not virtual
const locale& operator=(const locale& other) noexcept;
// 28.3.3.1.4, locale operations
template<class Facet> locale combine(const locale& other) const;
string name() const;
text_encoding encoding() const;
bool operator==(const locale& other) const;
205) In this subclause, the type nametm is an incomplete type that is defined in<ctime> (30.15).
§ 28.3.3.1.1 © ISO/IEC
1618

===== PAGE 1630 =====

Dxxxx
template<class charT, class traits, class Allocator>
bool operator()(const basic_string<charT, traits, Allocator>& s1,
const basic_string<charT, traits, Allocator>& s2) const;
// 28.3.3.1.6, global locale objects
static locale global(const locale&);
static const locale& classic();
};
}
1 Class locale implements a type-safe polymorphic set of facets, indexed by facettype. In other words, a facet
has a dual role: in one sense, it’s just a class interface; at the same time, it’s an index into a locale’s set of
facets.
2 Access to the facets of alocale is via two function templates,use_facet<> and has_facet<>.
3 [Example 1: An iostreamoperator<< can be implemented as:206
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<< (basic_ostream<charT, traits>& s, Date d) {
typename basic_ostream<charT, traits>::sentry cerberos(s);
if (cerberos) {
tm tmbuf; d.extract(tmbuf);
bool failed =
use_facet<time_put<charT, ostreambuf_iterator<charT, traits>>>(
s.getloc()).put(s, s, s.fill(), &tmbuf, 'x').failed();
if (failed)
s.setstate(s.badbit); // can throw
}
return s;
}
—end example]
4 In the call touse_facet<Facet>(loc), the type argument chooses a facet, making available all members
of the named type. IfFacet is not present in a locale, it throws the standard exceptionbad_cast. A C++
program can check if a locale implements a particular facet with the function templatehas_facet<Facet>().
User-defined facets may be installed in a locale, and used identically as may standard facets.
5 [Note 1: All locale semantics are accessed viause_facet<> and has_facet<>, except that:
—(5.1) A member operator template
operator()(const basic_string<C, T, A>&, const basic_string<C, T, A>&)
is provided so that a locale can be used as a predicate argument to the standard collections, to collate strings.
—(5.2) Convenient global interfaces are provided for traditionalctype functions such asisdigit() and isspace(),
so that given a locale objectloc a C++ program can callisspace(c, loc). (This eases upgrading existing
extractors (31.7.5.3).)
—end note]
6 Once a facet reference is obtained from a locale object by callinguse_facet<>, that reference remains usable,
and the results from member functions of it may be cached and re-used, as long as some locale object refers
to that facet.
7 In successive calls to a locale facet member function on a facet object installed in the same locale, the returned
result shall be identical.
8 A locale constructed from a name string (such as"POSIX"), or from parts of two named locales, has a name;
all others do not. Named locales may be compared for equality; an unnamed locale is equal only to (copies
of) itself. For an unnamed locale,locale::name() returns the string"*".
9 Whether there is one global locale object for the entire program or one global locale object per thread is
implementation-defined. Implementations should provide one global locale object per thread. If there is a
single global locale object for the entire program, implementations are not required to avoid data races on
it (16.4.6.10).
206) Note that in the call toput, the stream is implicitly converted to anostreambuf_iterator<charT, traits>.
§ 28.3.3.1.1 © ISO/IEC
1619

===== PAGE 1631 =====

Dxxxx
28.3.3.1.2 Types [locale.types]
28.3.3.1.2.1 Type locale::category [locale.category]
using category = int;
1 Valid category values include thelocale member bitmask elementscollate, ctype, monetary, numeric,
time, andmessages, each of which represents a single locale category. In addition,locale member bitmask
constant none is defined as zero and represents no category. Andlocale member bitmask constantall is
defined such that the expression
(collate | ctype | monetary | numeric | time | messages | all) == all
is true, and represents the union of all categories. Further, the expression(X | Y), whereX and Y each
represent a single category, represents the union of the two categories.
2 locale member functions expecting acategory argument require one of thecategory values defined above,
or the union of two or more such values. Such acategory value identifies a set of locale categories. Each
locale category, in turn, identifies a set of locale facets, including at least those shown in Table 91.
Table 91 — Locale category facets [tab:locale.category.facets]
Category Includes facets
collate collate<char>, collate<wchar_t>
ctype ctype<char>, ctype<wchar_t>
codecvt<char, char, mbstate_t>
codecvt<wchar_t, char, mbstate_t>
monetary moneypunct<char>, moneypunct<wchar_t>
moneypunct<char, true>, moneypunct<wchar_t, true>
money_get<char>, money_get<wchar_t>
money_put<char>, money_put<wchar_t>
numeric numpunct<char>, numpunct<wchar_t>
num_get<char>, num_get<wchar_t>
num_put<char>, num_put<wchar_t>
time time_get<char>, time_get<wchar_t>
time_put<char>, time_put<wchar_t>
messages messages<char>, messages<wchar_t>
3 For any localeloc either constructed, or returned bylocale::classic(), and any facetFacet shown in
Table 91,has_facet<Facet>(loc) is true. Eachlocale member function which takes alocale::category
argument operates on the corresponding set of facets.
4 An implementation is required to provide those specializations for facet templates identified as members of a
category, and for those shown in Table 92.
5 The provided implementation of members of facetsnum_get<charT> and num_put<charT> calls use_fac-
et<F>(l) only for facetF of typesnumpunct<charT> and ctype<charT>, and for localel the value obtained
by calling membergetloc() on theios_base& argument to these functions.
6 In declarations of facets, a template parameter with nameInputIterator or OutputIterator indicates
the set of all possible specializations on parameters that meet theCpp17InputIterator requirements or
Cpp17OutputIterator requirements, respectively (24.3). A template parameter with nameC represents the set
of types containingchar, wchar_t, and any other implementation-defined character container types (3.10)
that meet the requirements for a character on which any of the iostream components can be instantiated. A
template parameter with nameInternational represents the set of all possible specializations on a bool
parameter.
28.3.3.1.2.2 Class locale::facet [locale.facet]
namespace std {
class locale::facet {
protected:
explicit facet(size_t refs = 0);
virtual ~facet();
facet(const facet&) = delete;
§ 28.3.3.1.2 © ISO/IEC
1620

===== PAGE 1632 =====

Dxxxx
Table 92 — Required specializations [tab:locale.spec]
Category Includes facets
collate collate_byname<char>, collate_byname<wchar_t>
ctype ctype_byname<char>, ctype_byname<wchar_t>
codecvt_byname<char, char, mbstate_t>
codecvt_byname<wchar_t, char, mbstate_t>
monetary moneypunct_byname<char, International>
moneypunct_byname<wchar_t, International>
money_get<C, InputIterator>
money_put<C, OutputIterator>
numeric numpunct_byname<char>, numpunct_byname<wchar_t>
num_get<C, InputIterator>, num_put<C, OutputIterator>
time time_get<char, InputIterator>
time_get_byname<char, InputIterator>
time_get<wchar_t, InputIterator>
time_get_byname<wchar_t, InputIterator>
time_put<char, OutputIterator>
time_put_byname<char, OutputIterator>
time_put<wchar_t, OutputIterator>
time_put_byname<wchar_t, OutputIterator>
messages messages_byname<char>, messages_byname<wchar_t>
void operator=(const facet&) = delete;
};
}
1 Class facet is the base class for locale feature sets. A class is afacet if it is publicly derived from another facet,
or if it is a class derived fromlocale::facet and contains a publicly accessible declaration as follows:207
static ::std::locale::id id;
2 Template parameters in this Clause which are required to be facets are those namedFacet in declarations. A
program that passes a type that isnot a facet, or a type that refers to a volatile-qualified facet, as an (explicit
or deduced) template parameter to a locale function expecting a facet, is ill-formed. A const-qualified facet is
a valid template argument to any locale function that expects aFacet template parameter.
3 The refs argument to the constructor is used for lifetime management. Forrefs == 0, the implementation
performs delete static_cast<locale::facet*>(f) (where f is a pointer to the facet) when the last
locale object containing the facet is destroyed; forrefs == 1, the implementation never destroys the facet.
4 Constructors of all facets defined in this Clause take such an argument and pass it along to theirfacet
base class constructor. All one-argument constructors defined in this Clause are explicit, preventing their
participation in implicit conversions.
5 For some standard facets a standard “... _byname” class, derived from it, implements the virtual function
semantics equivalent to that facet of the locale constructed bylocale(const char*) with the same name.
Each such facet provides a constructor that takes aconst char* argument, which names the locale, and a
refs argument, which is passed to the base class constructor. Each such facet also provides a constructor that
takes astring argument str and arefs argument, which has the same effect as calling the first constructor
with the two argumentsstr.c_str() and refs. If there is no “... _byname” version of a facet, the base class
implements named locale semantics itself by reference to other facets.
28.3.3.1.2.3 Class locale::id [locale.id]
namespace std {
class locale::id {
public:
id();
void operator=(const id&) = delete;
207) This is a complete list of requirements; there are no other requirements. Thus, a facet class need not have a public copy
constructor, assignment, default constructor, destructor, etc.
§ 28.3.3.1.2 © ISO/IEC
1621

===== PAGE 1633 =====

Dxxxx
id(const id&) = delete;
};
}
1 The classlocale::id provides identification of a locale facet interface, used as an index for lookup and to
encapsulate initialization.
2 [Note 1: Because facets are used by iostreams, potentially while static constructors are running, their initialization
cannot depend on programmed static initialization. One initialization strategy is forlocale to initialize each facet’s
id member the first time an instance of the facet is installed into a locale. This depends only on static storage being
zero before constructors run (6.10.3.2).—end note]
28.3.3.1.3 Constructors and destructor [locale.cons]
locale() noexcept;
1 Effects: Constructs a copy of the argument last passed tolocale::global(locale&), if it has been
called; else, the resulting facets have virtual function semantics identical to those oflocale::classic().
[Note 1: This constructor yields a copy of the current global locale. It is commonly used as a default argument
for function parameters of typeconst locale&. —end note]
explicit locale(const char* std_name);
2 Effects: Constructs a locale using standard C locale names, e.g., "POSIX". The resulting locale
implements semantics defined to be associated with that name.
3 Throws: runtime_error if the argument is not valid, or is null.
4 Remarks: The set of valid string argument values is"C", "", and any implementation-defined values.
explicit locale(const string& std_name);
5 Effects: Equivalent tolocale(std_name.c_str()).
locale(const locale& other, const char* std_name, category cats);
6 Preconditions: cats is a validcategory value (28.3.3.1.2.1).
7 Effects: Constructs a locale as a copy of other except for the facets identified by thecategory
argument, which instead implement the same semantics aslocale(std_name).
8 Throws: runtime_error if the second argument is not valid, or is null.
9 Remarks: The locale has a name if and only ifother has a name.
locale(const locale& other, const string& std_name, category cats);
10 Effects: Equivalent tolocale(other, std_name.c_str(), cats).
template<class Facet> locale(const locale& other, Facet* f);
11 Effects: Constructs a locale incorporating all facets from the first argument except that of typeFacet,
and installs the second argument as the remaining facet. Iff is null, the resulting object is a copy of
other.
12 Remarks: If f is null, the resulting locale has the same name asother. Otherwise, the resulting locale
has no name.
locale(const locale& other, const locale& one, category cats);
13 Preconditions: cats is a validcategory value.
14 Effects: Constructs a locale incorporating all facets from the first argument except those that implement
cats, which are instead incorporated from the second argument.
15 Remarks: If cats is equal tolocale::none, the resulting locale has a name if and only if the first
argument has a name. Otherwise, the resulting locale has a name if and only if the first two arguments
both have names.
const locale& operator=(const locale& other) noexcept;
16 Effects: Creates a copy ofother, replacing the current value.
17 Returns: *this.
§ 28.3.3.1.3 © ISO/IEC
1622

===== PAGE 1634 =====

Dxxxx
28.3.3.1.4 Members [locale.members]
template<class Facet> locale combine(const locale& other) const;
1 Effects: Constructs a locale incorporating all facets from*this except for that one facet ofother that
is identified byFacet.
2 Returns: The newly created locale.
3 Throws: runtime_error if has_facet<Facet>(other) is false.
4 Remarks: The resulting locale has no name.
string name() const;
5 Returns: The name of*this, if it has one; otherwise, the string"*".
text_encoding encoding() const;
6 Mandates: CHAR_BIT == 8 is true.
7 Returns: Atext_encoding object representing the implementation-defined encoding scheme associated
with the locale*this.
28.3.3.1.5 Operators [locale.operators]
bool operator==(const locale& other) const;
1 Returns: true if both arguments are the same locale, or one is a copy of the other, or each has a name
and the names are identical;false otherwise.
template<class charT, class traits, class Allocator>
bool operator()(const basic_string<charT, traits, Allocator>& s1,
const basic_string<charT, traits, Allocator>& s2) const;
2 Effects: Compares two strings according to thestd::collate<charT> facet.
3 Returns:
use_facet<std::collate<charT>>(*this).compare(s1.data(), s1.data() + s1.size(),
s2.data(), s2.data() + s2.size()) < 0
4 Remarks: This member operator template (and thereforelocale itself) meets the requirements for a
comparator predicate template argument (Clause 26) applied to strings.
5 [Example 1: A vector of stringsv can be collated according to collation rules in localeloc simply by (26.8.2,
23.3.13):
std::sort(v.begin(), v.end(), loc);
—end example]
28.3.3.1.6 Static members [locale.statics]
static locale global(const locale& loc);
1 Effects: Sets the global locale to its argument. Causes future calls to the constructorlocale() to
return a copy of the argument. If the argument has a name, does
setlocale(LC_ALL, loc.name().c_str());
otherwise, the effect on the C locale, if any, is implementation-defined.
2 Returns: The previous value oflocale().
3 Remarks: No library function other thanlocale::global() affects the value returned bylocale().
[Note 1: See 28.3.5 for data race considerations whensetlocale is invoked. —end note]
static const locale& classic();
4 The "C" locale.
5 Returns: A locale that implements the classic"C" locale semantics, equivalent to the valuelocale("C").
6 Remarks: This locale, its facets, and their member functions, do not change with time.
§ 28.3.3.1.6 © ISO/IEC
1623

===== PAGE 1635 =====

Dxxxx
28.3.3.2 locale globals [locale.global.templates]
template<class Facet> const Facet& use_facet(const locale& loc);
1 Mandates: Facet is a facet class whose definition contains the public static memberid as defined
in 28.3.3.1.2.2.
2 Returns: A reference to the corresponding facet ofloc, if present.
3 Throws: bad_cast if has_facet<Facet>(loc) is false.
4 Remarks: The reference returned remains valid at least as long as any copy ofloc exists.
template<class Facet> bool has_facet(const locale& loc) noexcept;
5 Returns: true if the facet requested is present inloc; otherwisefalse.
28.3.3.3 Convenience interfaces [locale.convenience]
28.3.3.3.1 Character classification [classification]
template<class charT> bool isspace (charT c, const locale& loc);
template<class charT> bool isprint (charT c, const locale& loc);
template<class charT> bool iscntrl (charT c, const locale& loc);
template<class charT> bool isupper (charT c, const locale& loc);
template<class charT> bool islower (charT c, const locale& loc);
template<class charT> bool isalpha (charT c, const locale& loc);
template<class charT> bool isdigit (charT c, const locale& loc);
template<class charT> bool ispunct (charT c, const locale& loc);
template<class charT> bool isxdigit(charT c, const locale& loc);
template<class charT> bool isalnum (charT c, const locale& loc);
template<class charT> bool isgraph (charT c, const locale& loc);
template<class charT> bool isblank (charT c, const locale& loc);
1 Each of these functionsisF returns the result of the expression:
use_facet<ctype<charT>>(loc).is(ctype_base::F , c)
where F is thectype_base::mask value corresponding to that function (28.3.4.2).208
28.3.3.3.2 Character conversions [conversions.character]
template<class charT> charT toupper(charT c, const locale& loc);
1 Returns: use_facet<ctype<charT>>(loc).toupper(c).
template<class charT> charT tolower(charT c, const locale& loc);
2 Returns: use_facet<ctype<charT>>(loc).tolower(c).
28.3.4 Standard locale categories [locale.categories]
28.3.4.1 General [locale.categories.general]
1 Each of the standard categories includes a family of facets. Some of these implement formatting or parsing of a
datum, for use by standard or users’ iostream operators<< and >>, as membersput() and get(), respectively.
Each such member function takes anios_base& argument whose membersflags(), precision(), and
width(), specify the format of the corresponding datum (31.5.2). Those functions which need to use other
facets call its membergetloc() to retrieve the locale imbued there. Formatting facets use the character
argument fill to fill out the specified width where necessary.
2 The put() members make no provision for error reporting. (Any failures of the OutputIterator argument
can be extracted from the returned iterator.) Theget() members take anios_base::iostate& argument
whose value they ignore, but set toios_base::failbit in case of a parse error.
3 Within 28.3.4 it is unspecified whether one virtual function calls another virtual function.
208) When used in a loop, it is faster to cache thectype<> facet and use it directly, or use the vector form ofctype<>::is.
§ 28.3.4.1 © ISO/IEC
1624

===== PAGE 1636 =====

Dxxxx
28.3.4.2 The ctype category [category.ctype]
28.3.4.2.1 General [category.ctype.general]
namespace std {
class ctype_base {
public:
using mask = see below ;
// numeric values are for exposition only.
static constexpr mask space = 1 << 0;
static constexpr mask print = 1 << 1;
static constexpr mask cntrl = 1 << 2;
static constexpr mask upper = 1 << 3;
static constexpr mask lower = 1 << 4;
static constexpr mask alpha = 1 << 5;
static constexpr mask digit = 1 << 6;
static constexpr mask punct = 1 << 7;
static constexpr mask xdigit = 1 << 8;
static constexpr mask blank = 1 << 9;
static constexpr mask alnum = alpha | digit;
static constexpr mask graph = alnum | punct;
};
}
1 The typemask is a bitmask type (16.3.3.3.3).
28.3.4.2.2 Class template ctype [locale.ctype]
28.3.4.2.2.1 General [locale.ctype.general]
namespace std {
template<class charT>
class ctype : public locale::facet, public ctype_base {
public:
using char_type = charT;
explicit ctype(size_t refs = 0);
bool is(mask m, charT c) const;
const charT* is(const charT* low, const charT* high, mask* vec) const;
const charT* scan_is(mask m, const charT* low, const charT* high) const;
const charT* scan_not(mask m, const charT* low, const charT* high) const;
charT toupper(charT c) const;
const charT* toupper(charT* low, const charT* high) const;
charT tolower(charT c) const;
const charT* tolower(charT* low, const charT* high) const;
charT widen(char c) const;
const char* widen(const char* low, const char* high, charT* to) const;
char narrow(charT c, char dfault) const;
const charT* narrow(const charT* low, const charT* high, char dfault, char* to) const;
static locale::id id;
protected:
~ctype();
virtual bool do_is(mask m, charT c) const;
virtual const charT* do_is(const charT* low, const charT* high, mask* vec) const;
virtual const charT* do_scan_is(mask m, const charT* low, const charT* high) const;
virtual const charT* do_scan_not(mask m, const charT* low, const charT* high) const;
virtual charT do_toupper(charT) const;
virtual const charT* do_toupper(charT* low, const charT* high) const;
virtual charT do_tolower(charT) const;
virtual const charT* do_tolower(charT* low, const charT* high) const;
virtual charT do_widen(char) const;
virtual const char* do_widen(const char* low, const char* high, charT* dest) const;
§ 28.3.4.2.2 © ISO/IEC
1625

===== PAGE 1637 =====

Dxxxx
virtual char do_narrow(charT, char dfault) const;
virtual const charT* do_narrow(const charT* low, const charT* high,
char dfault, char* dest) const;
};
}
1 Class ctype encapsulates the C library<cctype> (28.7.1) features. istream members are required to use
ctype<> for character classing during input parsing.
2 The specializations required in Table 91 (28.3.3.1.2.1), namelyctype<char> and ctype<wchar_t>, implement
character classing appropriate to the implementation’s native character set.
28.3.4.2.2.2 ctype members [locale.ctype.members]
bool is(mask m, charT c) const;
const charT* is(const charT* low, const charT* high, mask* vec) const;
1 Returns: do_is(m, c) or do_is(low, high, vec).
const charT* scan_is(mask m, const charT* low, const charT* high) const;
2 Returns: do_scan_is(m, low, high).
const charT* scan_not(mask m, const charT* low, const charT* high) const;
3 Returns: do_scan_not(m, low, high).
charT toupper(charT c) const;
const charT* toupper(charT* low, const charT* high) const;
4 Returns: do_toupper(c) or do_toupper(low, high).
charT tolower(charT c) const;
const charT* tolower(charT* low, const charT* high) const;
5 Returns: do_tolower(c) or do_tolower(low, high).
charT widen(char c) const;
const char* widen(const char* low, const char* high, charT* to) const;
6 Returns: do_widen(c) or do_widen(low, high, to).
char narrow(charT c, char dfault) const;
const charT* narrow(const charT* low, const charT* high, char dfault, char* to) const;
7 Returns: do_narrow(c, dfault) or do_narrow(low, high, dfault, to).
28.3.4.2.2.3 ctype virtual functions [locale.ctype.virtuals]
bool do_is(mask m, charT c) const;
const charT* do_is(const charT* low, const charT* high, mask* vec) const;
1 Effects: Classifies a character or sequence of characters. For each argument character, identifies a value
M of typectype_base::mask. The second form identifies a valueM of typectype_base::mask for each
*p where (low <= p && p < high), and places it intovec[p - low].
2 Returns: The first form returns the result of the expression(M & m) != 0; i.e.,true if the character
has the characteristics specified. The second form returnshigh.
const charT* do_scan_is(mask m, const charT* low, const charT* high) const;
3 Effects: Locates a character in a buffer that conforms to a classificationm.
4 Returns: The smallest pointer p in the range[low,high) such that is(m, *p) would return true;
otherwise, returnshigh.
const charT* do_scan_not(mask m, const charT* low, const charT* high) const;
5 Effects: Locates a character in a buffer that fails to conform to a classificationm.
6 Returns: The smallest pointerp, if any, in the range[low,high) such thatis(m, *p) would return
false; otherwise, returnshigh.
§ 28.3.4.2.2 © ISO/IEC
1626

===== PAGE 1638 =====

Dxxxx
charT do_toupper(charT c) const;
const charT* do_toupper(charT* low, const charT* high) const;
7 Effects: Converts a character or characters to upper case. The second form replaces each character*p
in the range[low,high) for which a corresponding upper-case character exists, with that character.
8 Returns: The first form returns the corresponding upper-case character if it is known to exist, or its
argument if not. The second form returnshigh.
charT do_tolower(charT c) const;
const charT* do_tolower(charT* low, const charT* high) const;
9 Effects: Converts a character or characters to lower case. The second form replaces each character*p
in the range[low,high) and for which a corresponding lower-case character exists, with that character.
10 Returns: The first form returns the corresponding lower-case character if it is known to exist, or its
argument if not. The second form returnshigh.
charT do_widen(char c) const;
const char* do_widen(const char* low, const char* high, charT* dest) const;
11 Effects: Applies the simplest reasonable transformation from achar value or sequence ofchar values
to the correspondingcharT value or values.209 The only characters for which unique transformations
are required are those in the basic character set (5.3.1).
For any namedctype category with actype<char> facet ctc and validctype_base::mask value M,
(ctc.is(M, c) || !is(M, do_widen(c)) ) is true.210
The second form transforms each character*p in the range[low,high), placing the result indest[p -
low].
12 Returns: The first form returns the transformed value. The second form returnshigh.
char do_narrow(charT c, char dfault) const;
const charT* do_narrow(const charT* low, const charT* high, char dfault, char* dest) const;
13 Effects: Applies the simplest reasonable transformation from acharT value or sequence ofcharT values
to the correspondingchar value or values.
For any characterc in the basic character set (5.3.1) the transformation is such that
do_widen(do_narrow(c, 0)) == c
For any namedctype category with actype<char> facet ctc however, andctype_base::mask value
M,
(is(M, c) || !ctc.is(M, do_narrow(c, dfault)) )
is true (unless do_narrow returns dfault). In addition, for any digit characterc, the expression(do_-
narrow(c, dfault) - ’0’) evaluates to the digit value of the character. The second form transforms
each character*p in the range[low,high), placing the result (ordfault if no simple transformation is
readily available) indest[p - low].
14 Returns: The first form returns the transformed value; ordfault if no mapping is readily available.
The second form returnshigh.
28.3.4.2.3 Class template ctype_byname [locale.ctype.byname]
namespace std {
template<class charT>
class ctype_byname : public ctype<charT> {
public:
using mask = ctype<charT>::mask;
explicit ctype_byname(const char*, size_t refs = 0);
explicit ctype_byname(const string&, size_t refs = 0);
protected:
~ctype_byname();
209) The parameter c of do_widen is intended to accept values derived fromcharacter-literals for conversion to the locale’s
encoding.
210) In other words, the transformed character is not a member of any character classification thatc is not also a member of.
§ 28.3.4.2.3 © ISO/IEC
1627

===== PAGE 1639 =====

Dxxxx
};
}
28.3.4.2.4 ctype<char> specialization [facet.ctype.special]
28.3.4.2.4.1 General [facet.ctype.special.general]
namespace std {
template<>
class ctype<char> : public locale::facet, public ctype_base {
public:
using char_type = char;
explicit ctype(const mask* tab = nullptr, bool del = false, size_t refs = 0);
bool is(mask m, char c) const;
const char* is(const char* low, const char* high, mask* vec) const;
const char* scan_is (mask m, const char* low, const char* high) const;
const char* scan_not(mask m, const char* low, const char* high) const;
char toupper(char c) const;
const char* toupper(char* low, const char* high) const;
char tolower(char c) const;
const char* tolower(char* low, const char* high) const;
char widen(char c) const;
const char* widen(const char* low, const char* high, char* to) const;
char narrow(char c, char dfault) const;
const char* narrow(const char* low, const char* high, char dfault, char* to) const;
static locale::id id;
static const size_t table_size = implementation-defined ;
const mask* table() const noexcept;
static const mask* classic_table() noexcept;
protected:
~ctype();
virtual char do_toupper(char c) const;
virtual const char* do_toupper(char* low, const char* high) const;
virtual char do_tolower(char c) const;
virtual const char* do_tolower(char* low, const char* high) const;
virtual char do_widen(char c) const;
virtual const char* do_widen(const char* low, const char* high, char* to) const;
virtual char do_narrow(char c, char dfault) const;
virtual const char* do_narrow(const char* low, const char* high,
char dfault, char* to) const;
};
}
1 A specializationctype<char> is provided so that the member functions on typechar can be implemented
inline.211 The implementation-defined value of membertable_size is at least 256.
28.3.4.2.4.2 Destructor [facet.ctype.char.dtor]
~ctype();
1 Effects: If the constructor’s first argument was nonzero, and its second argument wastrue, doesdelete
[] table().
211) Only thechar (not unsigned char and signed char) form is provided. The specialization is specified in the standard, and
not left as an implementation detail, because it affects the derivation interface forctype<char>.
§ 28.3.4.2.4 © ISO/IEC
1628

===== PAGE 1640 =====

Dxxxx
28.3.4.2.4.3 Members [facet.ctype.char.members]
1 In the following member descriptions, forunsigned char values v where v >= table_size, table()[v] is
assumed to have an implementation-specific value (possibly different for each such valuev) without performing
the array lookup.
explicit ctype(const mask* tbl = nullptr, bool del = false, size_t refs = 0);
2 Preconditions: Either tbl == nullptr is true or [tbl,tbl + table_size) is a valid range.
3 Effects: Passes itsrefs argument to its base class constructor.
bool is(mask m, char c) const;
const char* is(const char* low, const char* high, mask* vec) const;
4 Effects: The second form, for all*p in the range[low,high), assigns intovec[p - low] the value
table()[(unsigned char)*p].
5 Returns: The first form returnstable()[(unsigned char)c] & m; the second form returnshigh.
const char* scan_is(mask m, const char* low, const char* high) const;
6 Returns: The smallestp in the range[low,high) such that
table()[(unsigned char) *p] & m
is true.
const char* scan_not(mask m, const char* low, const char* high) const;
7 Returns: The smallestp in the range[low,high) such that
table()[(unsigned char) *p] & m
is false.
char toupper(char c) const;
const char* toupper(char* low, const char* high) const;
8 Returns: do_toupper(c) or do_toupper(low, high), respectively.
char tolower(char c) const;
const char* tolower(char* low, const char* high) const;
9 Returns: do_tolower(c) or do_tolower(low, high), respectively.
char widen(char c) const;
const char* widen(const char* low, const char* high, char* to) const;
10 Returns: do_widen(c) or do_widen(low, high, to), respectively.
char narrow(char c, char dfault) const;
const char* narrow(const char* low, const char* high, char dfault, char* to) const;
11 Returns: do_narrow(c, dfault) or do_narrow(low, high, dfault, to), respectively.
const mask* table() const noexcept;
12 Returns: The first constructor argument, if it was nonzero, otherwiseclassic_table().
28.3.4.2.4.4 Static members [facet.ctype.char.statics]
static const mask* classic_table() noexcept;
1 Returns: A pointer to the initial element of an array of sizetable_size which represents the classifica-
tions of characters in the"C" locale.
28.3.4.2.4.5 Virtual functions [facet.ctype.char.virtuals]
char do_toupper(char) const;
const char* do_toupper(char* low, const char* high) const;
char do_tolower(char) const;
const char* do_tolower(char* low, const char* high) const;
§ 28.3.4.2.4 © ISO/IEC
1629

===== PAGE 1641 =====

Dxxxx
virtual char do_widen(char c) const;
virtual const char* do_widen(const char* low, const char* high, char* to) const;
virtual char do_narrow(char c, char dfault) const;
virtual const char* do_narrow(const char* low, const char* high,
char dfault, char* to) const;
1 These functions are described identically as those members of the same name in thectype class template
(28.3.4.2.2.2).
28.3.4.2.5 Class template codecvt [locale.codecvt]
28.3.4.2.5.1 General [locale.codecvt.general]
namespace std {
class codecvt_base {
public:
enum result { ok, partial, error, noconv };
};
template<class internT, class externT, class stateT>
class codecvt : public locale::facet, public codecvt_base {
public:
using intern_type = internT;
using extern_type = externT;
using state_type = stateT;
explicit codecvt(size_t refs = 0);
result out(
stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;
result unshift(
stateT& state,
externT* to, externT* to_end, externT*& to_next) const;
result in(
stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
int encoding() const noexcept;
bool always_noconv() const noexcept;
int length(stateT&, const externT* from, const externT* end, size_t max) const;
int max_length() const noexcept;
static locale::id id;
protected:
~codecvt();
virtual result do_out(
stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;
virtual result do_in(
stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
virtual result do_unshift(
stateT& state,
externT* to, externT* to_end, externT*& to_next) const;
virtual int do_encoding() const noexcept;
virtual bool do_always_noconv() const noexcept;
virtual int do_length(stateT&, const externT* from, const externT* end, size_t max) const;
§ 28.3.4.2.5 © ISO/IEC
1630

===== PAGE 1642 =====

Dxxxx
virtual int do_max_length() const noexcept;
};
}
1 The classcodecvt<internT, externT, stateT> is for use when converting from one character encoding to
another, such as from wide characters to multibyte characters or between wide character encodings such as
UTF-32 and EUC.
2 The stateT argument selects the pair of character encodings being mapped between.
3 The specializations required in Table 91 (28.3.3.1.2.1) convert the implementation-defined native character
set. codecvt<char, char, mbstate_t> implements a degenerate conversion; it does not convert at all.
codecvt<wchar_t, char, mbstate_t> converts between the native character sets for ordinary and wide
characters. Specializations on mbstate_t perform conversion between encodings known to the library
implementer. Other encodings can be converted by specializing on a program-definedstateT type. Objects
of type stateT can contain any state that is useful to communicate to or from the specializeddo_in or
do_out members.
28.3.4.2.5.2 Members [locale.codecvt.members]
result out(
stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;
1 Returns: do_out(state, from, from_end, from_next, to, to_end, to_next).
result unshift(stateT& state, externT* to, externT* to_end, externT*& to_next) const;
2 Returns: do_unshift(state, to, to_end, to_next).
result in(
stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
3 Returns: do_in(state, from, from_end, from_next, to, to_end, to_next).
int encoding() const noexcept;
4 Returns: do_encoding().
bool always_noconv() const noexcept;
5 Returns: do_always_noconv().
int length(stateT& state, const externT* from, const externT* from_end, size_t max) const;
6 Returns: do_length(state, from, from_end, max).
int max_length() const noexcept;
7 Returns: do_max_length().
28.3.4.2.5.3 Virtual functions [locale.codecvt.virtuals]
result do_out(
stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;
result do_in(
stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
1 Preconditions: (from <= from_end && to <= to_end) is well-defined andtrue; state is initialized,
if at the beginning of a sequence, or else is equal to the result of converting the preceding characters in
the sequence.
§ 28.3.4.2.5 © ISO/IEC
1631

===== PAGE 1643 =====

Dxxxx
2 Effects: Translates characters in the source range[from,from_end), placing the results in sequential
positions starting at destinationto. Converts no more than(from_end - from) source elements, and
stores no more than(to_end - to) destination elements.
3 Stops if it encounters a character it cannot convert. It always leaves thefrom_nextandto_nextpointers
pointing one beyond the last element successfully converted. If it returnsnoconv, internT and externT
are the same type, and the converted sequence is identical to the input sequence[from,from_next),
to_next is set equal toto, the value ofstate is unchanged, and there are no changes to the values in
[to,to_end).
4 A codecvt facet that is used bybasic_filebuf (31.10) shall have the property that if
do_out(state, from, from_end, from_next, to, to_end, to_next)
would returnok, wherefrom != from_end, then
do_out(state, from, from + 1, from_next, to, to_end, to_next)
shall also returnok, and that if
do_in(state, from, from_end, from_next, to, to_end, to_next)
would returnok, whereto != to_end, then
do_in(state, from, from_end, from_next, to, to + 1, to_next)
shall also returnok.212
[Note 1: As a result of operations onstate, it can returnok or partial and set from_next == from and
to_next != to. —end note]
5 Returns: An enumeration value, as summarized in Table 93.
Table 93 —do_in/do_out result values [tab:locale.codecvt.inout]
Value Meaning
ok completed the conversion
partial not all source characters converted
error encountered a character in[from,from_end) that
cannot be converted
noconv internT andexternTare the same type, and input
sequence is identical to converted sequence
A return value ofpartial, if(from_next == from_end), indicates that either the destination sequence
has not absorbed all the available destination elements, or that additional source elements are needed
before another destination element can be produced.
6 Remarks: Its operations onstate are unspecified.
[Note 2: This argument can be used, for example, to maintain shift state, to specify conversion options (such as
count only), or to identify a cache of seek offsets.—end note]
result do_unshift(stateT& state, externT* to, externT* to_end, externT*& to_next) const;
7 Preconditions: (to <= to_end) is well-defined andtrue; state is initialized, if at the beginning of a
sequence, or else is equal to the result of converting the preceding characters in the sequence.
8 Effects: Places characters starting atto that should be appended to terminate a sequence when the
current stateT is given bystate.213 Stores no more than(to_end - to) destination elements, and
leaves theto_next pointer pointing one beyond the last element successfully stored.
9 Returns: An enumeration value, as summarized in Table 94.
212) Informally, this means thatbasic_filebuf assumes that the mappings from internal to external characters is 1 to N: that
a codecvt facet that is used bybasic_filebuf can translate characters one internal character at a time.
213) Typically these will be characters to return the state tostateT().
§ 28.3.4.2.5 © ISO/IEC
1632

===== PAGE 1644 =====

Dxxxx
Table 94 —do_unshift result values [tab:locale.codecvt.unshift]
Value Meaning
ok completed the sequence
partial space for more thanto_end - to destination elements
was needed to terminate a sequence given the value of
state
error an unspecified error has occurred
noconv no termination is needed for thisstate_type
int do_encoding() const noexcept;
10 Returns: -1 if the encoding of theexternT sequence is state-dependent; else the constant number of
externT characters needed to produce an internal character; or0 if this number is not a constant.214
bool do_always_noconv() const noexcept;
11 Returns: true if do_in() and do_out() return noconv for all valid argument values.codecvt<char,
char, mbstate_t> returns true.
int do_length(stateT& state, const externT* from, const externT* from_end, size_t max) const;
12 Preconditions: (from <= from_end) is well-defined andtrue; state is initialized, if at the beginning
of a sequence, or else is equal to the result of converting the preceding characters in the sequence.
13 Effects: The effect on thestate argument is as if it calleddo_in(state, from, from_end, from,
to, to + max, to) for to pointing to a buffer of at leastmax elements.
14 Returns: (from_next - from) where from_next is the largest value in the range[from,from_end]
such that the sequence of values in the range[from,from_next) represents max or fewer valid complete
characters of typeinternT. The specializationcodecvt<char, char, mbstate_t>, returns the lesser
of max and (from_end - from).
int do_max_length() const noexcept;
15 Returns: The maximum value thatdo_length(state, from, from_end, 1) can return for any valid
range [from,from_end) and stateT valuestate. The specializationcodecvt<char, char, mbstate_-
t>::do_max_length() returns 1.
28.3.4.2.6 Class template codecvt_byname [locale.codecvt.byname]
namespace std {
template<class internT, class externT, class stateT>
class codecvt_byname : public codecvt<internT, externT, stateT> {
public:
explicit codecvt_byname(const char*, size_t refs = 0);
explicit codecvt_byname(const string&, size_t refs = 0);
protected:
~codecvt_byname();
};
}
28.3.4.3 The numeric category [category.numeric]
28.3.4.3.1 General [category.numeric.general]
1 The classesnum_get<> and num_put<> handle numeric formatting and parsing. Virtual functions are provided
for several numeric types. Implementations may (but are not required to) delegate extraction of smaller
types to extractors for larger types.215
214) If encoding() yields -1, then more thanmax_length() externTelements can be consumed when producing a singleinternT
character, and additionalexternT elements can appear at the end of a sequence after those that yield the finalinternT character.
215) Parsing "-1" correctly into, e.g., anunsigned short requires that the corresponding memberget() at least extract the
sign before delegating.
§ 28.3.4.3.1 © ISO/IEC
1633

===== PAGE 1645 =====

Dxxxx
2 All specifications of member functions fornum_put and num_get in the subclauses of 28.3.4.3 only apply to the
specializations required in Tables 91 and 92 (28.3.3.1.2.1), namelynum_get<char>, num_get<wchar_t>, num_-
get<C, InputIterator>, num_put<char>, num_put<wchar_t>, andnum_put<C, OutputIterator>. These
specializations refer to theios_base& argument for formatting specifications (28.3.4), and to its imbued
locale for thenumpunct<> facet to identify all numeric punctuation preferences, and also for thectype<>
facet to perform character classification.
3 Extractor and inserter members of the standard iostreams usenum_get<> and num_put<> member functions
for formatting and parsing numeric values (31.7.5.3.1, 31.7.6.3.1).
28.3.4.3.2 Class template num_get [locale.num.get]
28.3.4.3.2.1 General [locale.num.get.general]
namespace std {
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class num_get : public locale::facet {
public:
using char_type = charT;
using iter_type = InputIterator;
explicit num_get(size_t refs = 0);
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, bool& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, long& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, long long& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, unsigned short& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, unsigned int& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, unsigned long& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, unsigned long long& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, float& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, double& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, long double& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, void*& v) const;
static locale::id id;
protected:
~num_get();
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, bool& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, long& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, long long& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned short& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned int& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned long& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned long long& v) const;
§ 28.3.4.3.2 © ISO/IEC
1634

===== PAGE 1646 =====

Dxxxx
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, float& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, double& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, long double& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, void*& v) const;
};
}
1 The facetnum_get is used to parse numeric values from an input sequence such as an istream.
28.3.4.3.2.2 Members [facet.num.get.members]
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, bool& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned short& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned int& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, float& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, double& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long double& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, void*& val) const;
1 Returns: do_get(in, end, str, err, val).
28.3.4.3.2.3 Virtual functions [facet.num.get.virtuals]
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned short& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned int& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, float& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, double& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long double& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, void*& val) const;
1 Effects: Reads characters fromin, interpreting them according tostr.flags(), use_facet<ctype<
charT>>(loc), anduse_facet<numpunct<charT>>(loc), whereloc is str.getloc().
2 The details of this operation occur in three stages:
§ 28.3.4.3.2 © ISO/IEC
1635

===== PAGE 1647 =====

Dxxxx
—(2.1) Stage 1: Determine a conversion specifier.
—(2.2) Stage 2: Extract characters fromin and determine a correspondingchar value for the format
expected by the conversion specification determined in stage 1.
—(2.3) Stage 3: Store results.
3 The details of the stages are presented below.
Stage 1:The function initializes local variables via
fmtflags flags = str.flags();
fmtflags basefield = (flags & ios_base::basefield);
fmtflags uppercase = (flags & ios_base::uppercase);
fmtflags boolalpha = (flags & ios_base::boolalpha);
For conversion to an integral type, the function determines the integral conversion specifier as
indicated in Table 95. The table is ordered. That is, the first line whose condition is true applies.
Table 95 — Integer conversions [tab:facet.num.get.int]
State stdio equivalent
basefield == oct %o
basefield == hex %X
basefield == 0 %i
signed integral type %d
unsigned integral type %u
For conversions to a floating-point type the specifier is%g.
For conversions tovoid* the specifier is%p.
A length modifier is added to the conversion specification, if needed, as indicated in Table 96.
Table 96 — Length modifier [tab:facet.num.get.length]
Type Length modifier
short h
unsigned short h
long l
unsigned long l
long long ll
unsigned long long ll
double l
long double L
Stage 2: If in == end then stage 2 terminates. Otherwise acharT is taken fromin and local variables
are initialized as if by
char_type ct = *in;
char c = src[find(atoms, atoms + sizeof(src) - 1, ct) - atoms];
if (ct == use_facet<numpunct<charT>>(loc).decimal_point())
c = '.';
bool discard =
ct == use_facet<numpunct<charT>>(loc).thousands_sep()
&& use_facet<numpunct<charT>>(loc).grouping().length() != 0;
where the valuessrc and atoms are defined as if by:
static const char src[] = "0123456789abcdefpxABCDEFPX+-";
char_type atoms[sizeof(src)];
use_facet<ctype<charT>>(loc).widen(src, src + sizeof(src), atoms);
for this value ofloc.
If discard is true, then if’.’ has not yet been accumulated, then the position of the character
is remembered, but the character is otherwise ignored. Otherwise, if ’.’ has already been
accumulated, the character is discarded and Stage 2 terminates. If it is not discarded, then a
§ 28.3.4.3.2 © ISO/IEC
1636

===== PAGE 1648 =====

Dxxxx
check is made to determine ifc is allowed as the next character of an input field of the conversion
specifier returned by Stage 1. If so, it is accumulated.
If the character is either discarded or accumulated thenin is advanced by++in and processing
returns to the beginning of stage 2.
[Example 1: Given an input sequence of"0x1a.bp+07p",
—(3.1) if the conversion specifier returned by Stage 1 is%d, "0" is accumulated;
—(3.2) if the conversion specifier returned by Stage 1 is%i, "0x1a" are accumulated;
—(3.3) if the conversion specifier returned by Stage 1 is%g, "0x1a.bp+07" are accumulated.
In all cases, the remainder is left in the input.—end example]
Stage 3:The sequence ofchars accumulated in stage 2 (the field) is converted to a numeric value by
the rules of one of the functions declared in the header<cstdlib> (17.2.2):
—(3.4) For a signed integer value, the functionstrtoll.
—(3.5) For an unsigned integer value, the functionstrtoull.
—(3.6) For afloat value, the functionstrtof.
—(3.7) For adouble value, the functionstrtod.
—(3.8) For along double value, the functionstrtold.
The numeric value to be stored can be one of:
—(3.9) zero, if the conversion function does not convert the entire field.
—(3.10) the most positive (or negative) representable value, if the field to be converted to a signed
integer type represents a value too large positive (or negative) to be represented inval.
—(3.11) the most positive representable value, if the field to be converted to an unsigned integer type
represents a value that cannot be represented inval.
—(3.12) the converted value, otherwise.
The resultant numeric value is stored inval. If the conversion function does not convert the entire
field, or if the field represents a value outside the range of representable values,ios_base::failbit
is assigned toerr.
4 Digitgroupingischecked. Thatis, thepositionsofdiscardedseparatorsareexaminedforconsistencywith
use_facet<numpunct<charT>>(loc).grouping(). Iftheyarenotconsistentthen ios_base::failbit
is assigned toerr.
5 In any case, if stage 2 processing was terminated by the test forin == end then err |= ios_-
base::eofbit is performed.
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, bool& val) const;
6 Effects: If (str.flags() & ios_base::boolalpha) == 0 then input proceeds as it would for along
except that if a value is being stored intoval, the value is determined according to the following: If
the value to be stored is 0 thenfalse is stored. If the value is1 then true is stored. Otherwisetrue
is stored andios_base::failbit is assigned toerr.
7 Otherwise target sequences are determined “as if” by calling the membersfalsename() and truename()
of the facet obtained byuse_facet<numpunct<charT>>(str.getloc()). Successive characters in the
range [in,end) (see 23.2.4) are obtained and matched against corresponding positions in the target
sequences only as necessary to identify a unique match. The input iteratorin is compared toend
only when necessary to obtain a character. If a target sequence is uniquely matched,val is set to the
corresponding value. Otherwisefalse is stored andios_base::failbit is assigned toerr.
8 The in iterator is always left pointing one position beyond the last character successfully matched.
If val is set, thenerr is set tostr.goodbit; or tostr.eofbit if, when seeking another character
to match, it is found that(in == end). If val is not set, thenerr is set tostr.failbit; or to
(str.failbit | str.eofbit) if the reason for the failure was that(in == end).
[Example 2: For targetstrue: "a" and false: "abb", the input sequence"a" yields val == true and err
== str.eofbit; the input sequence"abc" yields err = str.failbit, within ending at the’c’ element. For
targets true: "1" and false: "0", the input sequence"1" yields val == true and err == str.goodbit. For
empty targets(""), any input sequence yieldserr == str.failbit. —end example]
9 Returns: in.
§ 28.3.4.3.2 © ISO/IEC
1637

===== PAGE 1649 =====

Dxxxx
28.3.4.3.3 Class template num_put [locale.nm.put]
28.3.4.3.3.1 General [locale.nm.put.general]
namespace std {
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class num_put : public locale::facet {
public:
using char_type = charT;
using iter_type = OutputIterator;
explicit num_put(size_t refs = 0);
iter_type put(iter_type s, ios_base& f, char_type fill, bool v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, long long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, unsigned long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, unsigned long long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, double v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, long double v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, const void* v) const;
static locale::id id;
protected:
~num_put();
virtual iter_type do_put(iter_type, ios_base&, char_type fill, bool v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill, long v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill, long long v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill, unsigned long) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill, unsigned long long) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill, double v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill, long double v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill, const void* v) const;
};
}
1 The facetnum_put is used to format numeric values to a character sequence such as an ostream.
28.3.4.3.3.2 Members [facet.num.put.members]
iter_type put(iter_type out, ios_base& str, char_type fill, bool val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, long long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, unsigned long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, unsigned long long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, double val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, long double val) const;
iter_type put(iter_type out, ios_base& str, char_type fill, const void* val) const;
1 Returns: do_put(out, str, fill, val).
28.3.4.3.3.3 Virtual functions [facet.num.put.virtuals]
iter_type do_put(iter_type out, ios_base& str, char_type fill, long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, long long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, unsigned long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, unsigned long long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, double val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, long double val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill, const void* val) const;
1 Effects: Writes characters to the sequenceout, formattingval as desired. In the following description,
loc names a local variable initialized as
locale loc = str.getloc();
2 The details of this operation occur in several stages:
§ 28.3.4.3.3 © ISO/IEC
1638

===== PAGE 1650 =====

Dxxxx
—(2.1) Stage 1: Determine a printf conversion specifierspec and determine the characters that would be
printed byprintf (31.13) given this conversion specifier for
printf(spec, val)
assuming that the current locale is the"C" locale.
—(2.2) Stage 2: Adjust the representation by converting eachchar determined by stage 1 to acharT
using a conversion and values returned by members ofuse_facet<numpunct<charT>>(loc).
—(2.3) Stage 3: Determine where padding is required.
—(2.4) Stage 4: Insert the sequence into theout.
3 Detailed descriptions of each stage follow.
4 Returns: out.
Stage 1:The first action of stage 1 is to determine a conversion specifier. The tables that describe
this determination use the following local variables
fmtflags flags = str.flags();
fmtflags basefield = (flags & (ios_base::basefield));
fmtflags uppercase = (flags & (ios_base::uppercase));
fmtflags floatfield = (flags & (ios_base::floatfield));
fmtflags showpos = (flags & (ios_base::showpos));
fmtflags showbase = (flags & (ios_base::showbase));
fmtflags showpoint = (flags & (ios_base::showpoint));
All tables used in describing stage 1 are ordered. That is, the first line whose condition is true
applies. A line without a condition is the default behavior when none of the earlier lines apply.
For conversion from an integral type other than a character type, the function determines the
integral conversion specifier as indicated in Table 97.
Table 97 — Integer conversions [tab:facet.num.put.int]
State stdio equivalent
basefield == ios_base::oct %o
(basefield == ios_base::hex) && !uppercase %x
(basefield == ios_base::hex) %X
for asigned integral type %d
for anunsigned integral type %u
For conversion from a floating-point type, the function determines the floating-point conversion
specifier as indicated in Table 98.
Table 98 — Floating-point conversions [tab:facet.num.put.fp]
State stdio equivalent
floatfield == ios_base::fixed && !uppercase %f
floatfield == ios_base::fixed %F
floatfield == ios_base::scientific && !uppercase %e
floatfield == ios_base::scientific %E
floatfield == (ios_base::fixed | ios_base::scientific) && !uppercase %a
floatfield == (ios_base::fixed | ios_base::scientific) %A
!uppercase %g
otherwise %G
For conversions from an integral or floating-point type a length modifier is added to the conversion
specifier as indicated in Table 99.
The conversion specifier has the following optional additional qualifiers prepended as indicated in
Table 100.
For conversion from a floating-point type, iffloatfield != (ios_base::fixed | ios_base::
scientific), str.precision()is specified as precision in the conversion specification. Otherwise,
no precision is specified.
§ 28.3.4.3.3 © ISO/IEC
1639

===== PAGE 1651 =====

Dxxxx
Table 99 — Length modifier [tab:facet.num.put.length]
Type Length modifier
long l
long long ll
unsigned long l
unsigned long long ll
long double L
otherwise none
Table 100 — Numeric conversions [tab:facet.num.put.conv]
Type(s) State stdio equivalent
an integral type showpos +
showbase #
a floating-point type showpos +
showpoint #
For conversion fromvoid* the specifier is%p.
The representations at the end of stage 1 consists of thechar’s that would be printed by a call of
printf(s, val) where s is the conversion specifier determined above.
Stage 2:Any characterc other than a decimal point(.) is converted to acharT via
use_facet<ctype<charT>>(loc).widen(c)
A local variablepunct is initialized via
const numpunct<charT>& punct = use_facet<numpunct<charT>>(loc);
For arithmetic types,punct.thousands_sep() characters are inserted into the sequence as deter-
mined by the value returned bypunct.do_grouping() using the method described in 28.3.4.4.1.3.
Decimal point characters(.) are replaced bypunct.decimal_point().
Stage 3:A local variable is initialized as
fmtflags adjustfield = (flags & (ios_base::adjustfield));
The location of any padding216 is determined according to Table 101.
Table 101 — Fill padding [tab:facet.num.put.fill]
State Location
adjustfield == ios_base::left pad after
adjustfield == ios_base::right pad before
adjustfield == internal and a sign occurs in
the representation
pad after the sign
adjustfield == internal and representation af-
ter stage 1 began with 0x or 0X
pad after x or X
otherwise pad before
If str.width() is nonzero and the number ofcharT’s in the sequence after stage 2 is less than
str.width(), then enoughfill characters are added to the sequence at the position indicated
for padding to bring the length of the sequence tostr.width().
str.width(0) is called.
Stage 4:The sequence ofcharT’s at the end of stage 3 are output via
*out++ = c
216) The conversion specification#o generates a leading0 which isnot a padding character.
§ 28.3.4.3.3 © ISO/IEC
1640

===== PAGE 1652 =====

Dxxxx
iter_type do_put(iter_type out, ios_base& str, char_type fill, bool val) const;
5 Returns: If (str.flags() & ios_base::boolalpha) == 0 returns do_put(out, str, fill,
(int)val), otherwise obtains a strings as if by
string_type s =
val ? use_facet<numpunct<charT>>(loc).truename()
: use_facet<numpunct<charT>>(loc).falsename();
and then inserts each characterc of s into out via *out++ = c and returnsout.
28.3.4.4 The numeric punctuation facet [facet.numpunct]
28.3.4.4.1 Class template numpunct [locale.numpunct]
28.3.4.4.1.1 General [locale.numpunct.general]
namespace std {
template<class charT>
class numpunct : public locale::facet {
public:
using char_type = charT;
using string_type = basic_string<charT>;
explicit numpunct(size_t refs = 0);
char_type decimal_point() const;
char_type thousands_sep() const;
string grouping() const;
string_type truename() const;
string_type falsename() const;
static locale::id id;
protected:
~numpunct(); // virtual
virtual char_type do_decimal_point() const;
virtual char_type do_thousands_sep() const;
virtual string do_grouping() const;
virtual string_type do_truename() const; // for bool
virtual string_type do_falsename() const; // for bool
};
}
1 numpunct<> specifies numeric punctuation. The specializations required in Table 91 (28.3.3.1.2.1), namely
numpunct<wchar_t>and numpunct<char>, provide classic"C"numeric formats, i.e., they contain information
equivalent to that contained in the"C" locale or their wide character counterparts as if obtained by a call to
widen.
2 The syntax for number formats is as follows, wheredigit represents the radix set specified by thefmtflags
argument value, andthousands-sep and decimal-point are the results of correspondingnumpunct<charT>
members. Integer values have the format:
intval:
signopt units
sign:
+
-
units:
digits
digits thousands-sep units
digits:
digit digitsopt
and floating-point values have:
floatval:
signopt units fractionalopt exponentopt
signopt decimal-point digits exponentopt
§ 28.3.4.4.1 © ISO/IEC
1641

===== PAGE 1653 =====

Dxxxx
fractional:
decimal-point digitsopt
exponent:
e signopt digits
e:
e
E
where the number of digits betweenthousands-seps is as specified bydo_grouping(). For parsing, if the
digits portion contains no thousands-separators, no grouping constraint is applied.
28.3.4.4.1.2 Members [facet.numpunct.members]
char_type decimal_point() const;
1 Returns: do_decimal_point().
char_type thousands_sep() const;
2 Returns: do_thousands_sep().
string grouping() const;
3 Returns: do_grouping().
string_type truename() const;
string_type falsename() const;
4 Returns: do_truename() or do_falsename(), respectively.
28.3.4.4.1.3 Virtual functions [facet.numpunct.virtuals]
char_type do_decimal_point() const;
1 Returns: A character for use as the decimal radix separator. The required specializations return’.’ or
L’.’.
char_type do_thousands_sep() const;
2 Returns: A character for use as the digit group separator. The required specializations return’,’ or
L’,’.
string do_grouping() const;
3 Returns: A string vecused as a vector of integer values, in which each elementvec[i] represents
the number of digits217 in the group at positioni, starting with position 0 as the rightmost group. If
vec.size() <= i, the number is the same as group(i - 1); if (i < 0 || vec[i] <= 0 || vec[i]
== CHAR_MAX), the size of the digit group is unlimited.
4 The required specializations return the empty string, indicating no grouping.
string_type do_truename() const;
string_type do_falsename() const;
5 Returns: A string representing the name of the boolean valuetrue or false, respectively.
6 In the base class implementation these names are"true" and "false", orL"true" and L"false".
28.3.4.4.2 Class template numpunct_byname [locale.numpunct.byname]
namespace std {
template<class charT>
class numpunct_byname : public numpunct<charT> {
// this class is specialized forchar and wchar_t.
public:
using char_type = charT;
using string_type = basic_string<charT>;
217) Thus, the string"\003" specifies groups of 3 digits each, and"3" probably indicates groups of 51 (!) digits each, because 51
is the ASCII value of"3".
§ 28.3.4.4.2 © ISO/IEC
1642

===== PAGE 1654 =====

Dxxxx
explicit numpunct_byname(const char*, size_t refs = 0);
explicit numpunct_byname(const string&, size_t refs = 0);
protected:
~numpunct_byname();
};
}
28.3.4.5 The collate category [category.collate]
28.3.4.5.1 Class template collate [locale.collate]
28.3.4.5.1.1 General [locale.collate.general]
namespace std {
template<class charT>
class collate : public locale::facet {
public:
using char_type = charT;
using string_type = basic_string<charT>;
explicit collate(size_t refs = 0);
int compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
string_type transform(const charT* low, const charT* high) const;
long hash(const charT* low, const charT* high) const;
static locale::id id;
protected:
~collate();
virtual int do_compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
virtual string_type do_transform(const charT* low, const charT* high) const;
virtual long do_hash (const charT* low, const charT* high) const;
};
}
1 The classcollate<charT> provides features for use in the collation (comparison) and hashing of strings.
A locale member function template,operator(), uses the collate facet to allow a locale to act directly
as the predicate argument for standard algorithms (Clause 26) and containers operating on strings. The
specializations required in Table 91 (28.3.3.1.2.1), namelycollate<char> and collate<wchar_t>, apply
lexicographical ordering (26.8.11).
2 Each function compares a string of characters*p in the range[low,high).
28.3.4.5.1.2 Members [locale.collate.members]
int compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
1 Returns: do_compare(low1, high1, low2, high2).
string_type transform(const charT* low, const charT* high) const;
2 Returns: do_transform(low, high).
long hash(const charT* low, const charT* high) const;
3 Returns: do_hash(low, high).
28.3.4.5.1.3 Virtual functions [locale.collate.virtuals]
int do_compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
1 Returns: 1 if the first string is greater than the second,-1 if less, zero otherwise. The specializations
required in Table 91 (28.3.3.1.2.1), namelycollate<char> and collate<wchar_t>, implement a
lexicographical comparison (26.8.11).
§ 28.3.4.5.1 © ISO/IEC
1643

===== PAGE 1655 =====

Dxxxx
string_type do_transform(const charT* low, const charT* high) const;
2 Returns: A basic_string<charT> value that, compared lexicographically with the result of calling
transform() on another string, yields the same result as callingdo_compare() on the same two
strings.218
long do_hash(const charT* low, const charT* high) const;
3 Returns: An integer value equal to the result of callinghash() on any other string for whichdo_-
compare() returns 0 (equal) when passed the two strings.
4 Recommended practice: The probability that the result equals that for another string which does not
compare equal should be very small, approaching(1.0/numeric_limits<unsigned long>::max()).
28.3.4.5.2 Class template collate_byname [locale.collate.byname]
namespace std {
template<class charT>
class collate_byname : public collate<charT> {
public:
using string_type = basic_string<charT>;
explicit collate_byname(const char*, size_t refs = 0);
explicit collate_byname(const string&, size_t refs = 0);
protected:
~collate_byname();
};
}
28.3.4.6 The time category [category.time]
28.3.4.6.1 General [category.time.general]
1 Templatestime_get<charT, InputIterator> and time_put<charT, OutputIterator> provide date and
time formatting and parsing. All specifications of member functions fortime_put and time_get in the
subclauses of 28.3.4.6 only apply to the specializations required in Tables 91 and 92 (28.3.3.1.2.1). Their
members use theirios_base&, ios_base::iostate&, andfill arguments as described in 28.3.4, and the
ctype<> facet, to determine formatting details.
28.3.4.6.2 Class template time_get [locale.time.get]
28.3.4.6.2.1 General [locale.time.get.general]
namespace std {
class time_base {
public:
enum dateorder { no_order, dmy, mdy, ymd, ydm };
};
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class time_get : public locale::facet, public time_base {
public:
using char_type = charT;
using iter_type = InputIterator;
explicit time_get(size_t refs = 0);
dateorder date_order() const { return do_date_order(); }
iter_type get_time(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get_date(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get_weekday(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get_monthname(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
218) This function is useful when one string is being compared to many other strings.
§ 28.3.4.6.2 © ISO/IEC
1644

===== PAGE 1656 =====

Dxxxx
iter_type get_year(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t, char format, char modifier = 0) const;
iter_type get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t, const char_type* fmt,
const char_type* fmtend) const;
static locale::id id;
protected:
~time_get();
virtual dateorder do_date_order() const;
virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t, char format, char modifier) const;
};
}
1 time_get is used to parse a character sequence, extracting components of a time or date into atm object.
Each get member parses a format as produced by a corresponding format specifier totime_put<>::put. If
the sequence being parsed matches the correct format, the corresponding members of thetm argument are
set to the values used to produce the sequence; otherwise either an error is reported or unspecified values are
assigned.219
2 If the end iterator is reached during parsing by any of theget() member functions, the member sets
ios_base::eofbit in err.
28.3.4.6.2.2 Members [locale.time.get.members]
dateorder date_order() const;
1 Returns: do_date_order().
iter_type get_time(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
2 Returns: do_get_time(s, end, str, err, t).
iter_type get_date(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
3 Returns: do_get_date(s, end, str, err, t).
iter_type get_weekday(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
iter_type get_monthname(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
4 Returns: do_get_weekday(s, end, str, err, t) or do_get_monthname(s, end, str, err, t).
iter_type get_year(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
5 Returns: do_get_year(s, end, str, err, t).
219) In other words, user confirmation is required for reliable parsing of user-entered dates and times, but machine-generated
formats can be parsed reliably. This allows parsers to be aggressive about interpreting user variations on standard formats.
§ 28.3.4.6.2 © ISO/IEC
1645

===== PAGE 1657 =====

Dxxxx
iter_type get(iter_type s, iter_type end, ios_base& f, ios_base::iostate& err,
tm* t, char format, char modifier = 0) const;
6 Returns: do_get(s, end, f, err, t, format, modifier).
iter_type get(iter_type s, iter_type end, ios_base& f, ios_base::iostate& err,
tm* t, const char_type* fmt, const char_type* fmtend) const;
7 Preconditions: [fmt,fmtend) is a valid range.
8 Effects: The function starts by evaluatingerr = ios_base::goodbit. It then enters a loop, reading
zero or more characters froms at each iteration. Unless otherwise specified below, the loop terminates
when the first of the following conditions holds:
—(8.1) The expressionfmt == fmtend evaluates totrue.
—(8.2) The expressionerr == ios_base::goodbit evaluates tofalse.
—(8.3) The expressions == end evaluates totrue, in which case the function evaluateserr = ios_-
base::eofbit | ios_base::failbit.
—(8.4) The next element offmt is equal to’%’, optionally followed by a modifier character, followed by
a conversion specifier character,format, together forming a conversion specification valid for the
POSIX functionstrptime. If the number of elements in the range[fmt,fmtend) is not sufficient
to unambiguously determine whether the conversion specification is complete and valid, the
function evaluateserr = ios_base::failbit. Otherwise, the function evaluatess = do_get(s,
end, f, err, t, format, modifier), where the value ofmodifier is ’\0’ when the optional
modifier is absent from the conversion specification. Iferr == ios_base::goodbit holds after
the evaluation of the expression, the function incrementsfmt to point just past the end of the
conversion specification and continues looping.
—(8.5) The expressionisspace(*fmt, f.getloc()) evaluates totrue, in which case the function first
increments fmt until fmt == fmtend || !isspace(*fmt, f.getloc()) evaluates totrue, then
advances s until s == end || !isspace(*s, f.getloc()) is true, and finally resumes looping.
—(8.6) The next character read froms matches the element pointed to byfmt in a case-insensitive
comparison, in which case the function evaluates++fmt, ++s and continues looping. Otherwise,
the function evaluateserr = ios_base::failbit.
9 [Note 1: The function uses the ctype<charT> facet installed in f’s locale to determine valid whitespace
characters. It is unspecified by what means the function performs case-insensitive comparison or whether
multi-character sequences are considered while doing so.—end note]
10 Returns: s.
28.3.4.6.2.3 Virtual functions [locale.time.get.virtuals]
dateorder do_date_order() const;
1 Returns: An enumeration value indicating the preferred order of components for those date formats
that are composed of day, month, and year.220 Returns no_order if the date format specified by’x’
contains other variable components (e.g., Julian day, week number, week day).
iter_type do_get_time(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
2 Effects: Reads characters starting ats until it has extracted thosetm members, and remaining format
characters, used by time_put<>::put to produce the format specified by"%H:%M:%S", or until it
encounters an error or end of sequence.
3 Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid time.
iter_type do_get_date(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
4 Effects: Reads characters starting ats until it has extracted thosetm members and remaining format
characters used bytime_put<>::put to produce one of the following formats, or until it encounters an
error. The format depends on the value returned bydate_order() as shown in Table 102.
220) This function is intended as a convenience only, for common formats, and can returnno_order in valid locales.
§ 28.3.4.6.2 © ISO/IEC
1646

===== PAGE 1658 =====

Dxxxx
Table 102 —do_get_date effects [tab:locale.time.get.dogetdate]
date_order() Format
no_order "%m%d%y"
dmy "%d%m%y"
mdy "%m%d%y"
ymd "%y%m%d"
ydm "%y%d%m"
5 An implementation may also accept additional implementation-defined formats.
6 Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid date.
iter_type do_get_weekday(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
iter_type do_get_monthname(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
7 Effects: Reads characters starting ats until it has extracted the (perhaps abbreviated) name of a
weekday or month. If it finds an abbreviation that is followed by characters that can match a full
name, it continues reading until it matches the full name or fails. It sets the appropriatetm member
accordingly.
8 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid name.
iter_type do_get_year(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
9 Effects: Reads characters starting ats until it has extracted an unambiguous year identifier. It is
implementation-defined whether two-digit year numbers are accepted, and (if so) what century they
are assumed to lie in. Sets thet->tm_year member accordingly.
10 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid year
identifier.
iter_type do_get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t, char format, char modifier) const;
11 Preconditions: t points to an object.
12 Effects: The function starts by evaluatingerr = ios_base::goodbit. It then reads characters starting
at s until it encounters an error, or until it has extracted and assigned thosetm members, and any
remaining format characters, corresponding to a conversion specification appropriate for the POSIX
function strptime, formed by concatenating’%’, themodifier character, when non-NUL, and the
format character. When the concatenation fails to yield a complete valid directive the function leaves
the object pointed to byt unchanged and evaluateserr |= ios_base::failbit. When s == end
evaluates totrue after reading a character the function evaluateserr |= ios_base::eofbit.
13 For complex conversion specifications such as%c, %x, or%X, or conversion specifications that involve
the optional modifiersE or O, when the function is unable to unambiguously determine some or alltm
members from the input sequence[s,end), it evaluateserr |= ios_base::eofbit. In such cases the
values of thosetm members are unspecified and may be outside their valid range.
14 Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid input sequence for the givenformat and modifier.
15 Remarks: It is unspecified whether multiple calls todo_get() with the address of the sametm object
will update the current contents of the object or simply overwrite its members. Portable programs
should zero out the object before invoking the function.
28.3.4.6.3 Class template time_get_byname [locale.time.get.byname]
namespace std {
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class time_get_byname : public time_get<charT, InputIterator> {
§ 28.3.4.6.3 © ISO/IEC
1647

===== PAGE 1659 =====

Dxxxx
public:
using dateorder = time_base::dateorder;
using iter_type = InputIterator;
explicit time_get_byname(const char*, size_t refs = 0);
explicit time_get_byname(const string&, size_t refs = 0);
protected:
~time_get_byname();
};
}
28.3.4.6.4 Class template time_put [locale.time.put]
28.3.4.6.4.1 General [locale.time.put.general]
namespace std {
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class time_put : public locale::facet {
public:
using char_type = charT;
using iter_type = OutputIterator;
explicit time_put(size_t refs = 0);
// the following is implemented in terms of other member functions.
iter_type put(iter_type s, ios_base& f, char_type fill, const tm* tmb,
const charT* pattern, const charT* pat_end) const;
iter_type put(iter_type s, ios_base& f, char_type fill,
const tm* tmb, char format, char modifier = 0) const;
static locale::id id;
protected:
~time_put();
virtual iter_type do_put(iter_type s, ios_base&, char_type, const tm* t,
char format, char modifier) const;
};
}
28.3.4.6.4.2 Members [locale.time.put.members]
iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,
const charT* pattern, const charT* pat_end) const;
iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,
char format, char modifier = 0) const;
1 Effects: The first form steps through the sequence frompattern to pat_end, identifying characters
that are part of a format sequence. Each character that is not part of a format sequence is written to
s immediately, and each format sequence, as it is identified, results in a call todo_put; thus, format
elements and other characters are interleaved in the output in the order in which they appear in
the pattern. Format sequences are identified by converting each characterc to achar value as if by
ct.narrow(c, 0), wherect is a reference toctype<charT> obtained fromstr.getloc(). The first
character of each sequence is equal to’%’, followed by an optional modifier charactermod and a format
specifier characterspec as defined for the functionstrftime. If no modifier character is present,mod
is zero. For each valid format sequence identified, callsdo_put(s, str, fill, t, spec, mod).
2 The second form callsdo_put(s, str, fill, t, format, modifier).
3 [Note 1: The fill argument can be used in the implementation-defined formats or by derivations. A space
character is a reasonable default for this argument.—end note]
4 Returns: An iterator pointing immediately after the last character produced.
§ 28.3.4.6.4 © ISO/IEC
1648

===== PAGE 1660 =====

Dxxxx
28.3.4.6.4.3 Virtual functions [locale.time.put.virtuals]
iter_type do_put(iter_type s, ios_base&, char_type fill, const tm* t,
char format, char modifier) const;
1 Effects: Formats the contents of the parametert into characters placed on the output sequences.
Formatting is controlled by the parametersformat and modifier, interpreted identically as the format
specifiers in the string argument to the standard library functionstrftime(), except that the sequence
of characters produced for those specifiers that are described as depending on the C locale are instead
implementation-defined.
[Note 1: Interpretation of themodifier argument is implementation-defined.—end note]
2 Returns: An iterator pointing immediately after the last character produced.
[Note 2: The fill argument can be used in the implementation-defined formats or by derivations. A space
character is a reasonable default for this argument.—end note]
3 Recommended practice: Interpretation of themodifier should follow POSIX conventions. Implemen-
tations should refer to other standards such as POSIX for a specification of the character sequences
produced for those specifiers described as depending on the C locale.
28.3.4.6.5 Class template time_put_byname [locale.time.put.byname]
namespace std {
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class time_put_byname : public time_put<charT, OutputIterator> {
public:
using char_type = charT;
using iter_type = OutputIterator;
explicit time_put_byname(const char*, size_t refs = 0);
explicit time_put_byname(const string&, size_t refs = 0);
protected:
~time_put_byname();
};
}
28.3.4.7 The monetary category [category.monetary]
28.3.4.7.1 General [category.monetary.general]
1 These templates handle monetary formats. A template parameter indicates whether local or international
monetary formats are to be used.
2 All specifications of member functions formoney_put and money_get in the subclauses of 28.3.4.7 only
apply to the specializations required in Tables 91 and 92 (28.3.3.1.2.1). Their members use theirios_base&,
ios_base::iostate&, andfill arguments as described in 28.3.4, and themoneypunct<> and ctype<> facets,
to determine formatting details.
28.3.4.7.2 Class template money_get [locale.money.get]
28.3.4.7.2.1 General [locale.money.get.general]
namespace std {
template<class charT, class InputIterator = istreambuf_iterator<charT>>
class money_get : public locale::facet {
public:
using char_type = charT;
using iter_type = InputIterator;
using string_type = basic_string<charT>;
explicit money_get(size_t refs = 0);
iter_type get(iter_type s, iter_type end, bool intl,
ios_base& f, ios_base::iostate& err,
long double& units) const;
§ 28.3.4.7.2 © ISO/IEC
1649

===== PAGE 1661 =====

Dxxxx
iter_type get(iter_type s, iter_type end, bool intl,
ios_base& f, ios_base::iostate& err,
string_type& digits) const;
static locale::id id;
protected:
~money_get();
virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
ios_base::iostate& err, long double& units) const;
virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
ios_base::iostate& err, string_type& digits) const;
};
}
28.3.4.7.2.2 Members [locale.money.get.members]
iter_type get(iter_type s, iter_type end, bool intl, ios_base& f,
ios_base::iostate& err, long double& quant) const;
iter_type get(iter_type s, iter_type end, bool intl, ios_base& f,
ios_base::iostate& err, string_type& quant) const;
1 Returns: do_get(s, end, intl, f, err, quant).
28.3.4.7.2.3 Virtual functions [locale.money.get.virtuals]
iter_type do_get(iter_type s, iter_type end, bool intl, ios_base& str,
ios_base::iostate& err, long double& units) const;
iter_type do_get(iter_type s, iter_type end, bool intl, ios_base& str,
ios_base::iostate& err, string_type& digits) const;
1 Effects: Reads characters froms to parse and construct a monetary value according to the format
specified by amoneypunct<charT, Intl> facet referencemp and the character mapping specified by a
ctype<charT>facet referencectobtained from the locale returned bystr.getloc(), andstr.flags().
If a valid sequence is recognized, does not changeerr; otherwise, setserr to (err | str.failbit), or
(err | str.failbit | str.eofbit) if no more characters are available, and does not changeunits
or digits. Uses the pattern returned bymp.neg_format() to parse all values. The result is returned
as an integral value stored inunits or as a sequence of digits possibly preceded by a minus sign (as
produced byct.widen(c) where c is ’-’ or in the range from’0’ through ’9’ (inclusive)) stored in
digits.
[Example 1: The sequence$1,056.23 in a common United States locale would yield, forunits, 105623, or, for
digits, "105623". —end example]
If mp.grouping() indicates that no thousands separators are permitted, any such characters are not
read, and parsing is terminated at the point where they first appear. Otherwise, thousands separators
are optional; if present, they are checked for correct placement only after all format components have
been read.
2 Where money_base::space or money_base::none appears as the last element in the format pattern, no
whitespace is consumed. Otherwise, wheremoney_base::space appears in any of the initial elements of
the format pattern, at least one whitespace character is required. Wheremoney_base::none appears in
any of the initial elements of the format pattern, whitespace is allowed but not required. If(str.flags()
& str.showbase) is false, the currency symbol is optional and is consumed only if other characters
are needed to complete the format; otherwise, the currency symbol is required.
3 If the first character (if any) in the stringpos returned bymp.positive_sign() or the stringneg
returned bymp.negative_sign() is recognized in the position indicated bysign in the format pattern,
it is consumed and any remaining characters in the string are required after all the other format
components.
[Example 2: If showbase is off, then for aneg value of"()" and a currency symbol of"L", in"(100 L)" the
"L" is consumed; but ifneg is "-", the"L" in "-100 L" is not consumed. —end example]
If pos or neg is empty, the sign component is optional, and if no sign is detected, the result is given
the sign that corresponds to the source of the empty string. Otherwise, the character in the indicated
position must match the first character ofpos or neg, and the result is given the corresponding sign. If
§ 28.3.4.7.2 © ISO/IEC
1650

===== PAGE 1662 =====

Dxxxx
the first character ofpos is equal to the first character ofneg, or if both strings are empty, the result
is given a positive sign.
4 Digits in the numeric monetary component are extracted and placed indigits, or into a character
buffer buf1 for conversion to produce a value forunits, in the order in which they appear, preceded
by a minus sign if and only if the result is negative. The valueunits is produced as if by221
for (int i = 0; i < n; ++i)
buf2[i] = src[find(atoms, atoms + sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &units);
where n is the number of characters placed inbuf1, buf2 is a character buffer, and the valuessrc and
atoms are defined as if by
static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src, src + sizeof(src) - 1, atoms);
5 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid
monetary quantity.
28.3.4.7.3 Class template money_put [locale.money.put]
28.3.4.7.3.1 General [locale.money.put.general]
namespace std {
template<class charT, class OutputIterator = ostreambuf_iterator<charT>>
class money_put : public locale::facet {
public:
using char_type = charT;
using iter_type = OutputIterator;
using string_type = basic_string<charT>;
explicit money_put(size_t refs = 0);
iter_type put(iter_type s, bool intl, ios_base& f,
char_type fill, long double units) const;
iter_type put(iter_type s, bool intl, ios_base& f,
char_type fill, const string_type& digits) const;
static locale::id id;
protected:
~money_put();
virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,
long double units) const;
virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,
const string_type& digits) const;
};
}
28.3.4.7.3.2 Members [locale.money.put.members]
iter_type put(iter_type s, bool intl, ios_base& f, char_type fill, long double quant) const;
iter_type put(iter_type s, bool intl, ios_base& f, char_type fill, const string_type& quant) const;
1 Returns: do_put(s, intl, f, fill, quant).
28.3.4.7.3.3 Virtual functions [locale.money.put.virtuals]
iter_type do_put(iter_type s, bool intl, ios_base& str,
char_type fill, long double units) const;
iter_type do_put(iter_type s, bool intl, ios_base& str,
char_type fill, const string_type& digits) const;
1 Effects: Writes characters tos according to the format specified by amoneypunct<charT, Intl> facet
reference mp and the character mapping specified by actype<charT> facet referencect obtained from
221) The semantics here are different fromct.narrow.
§ 28.3.4.7.3 © ISO/IEC
1651

===== PAGE 1663 =====

Dxxxx
the locale returned bystr.getloc(), andstr.flags(). The argumentunits is transformed into a
sequence of wide characters as if by
ct.widen(buf1, buf1 + sprintf(buf1, "%.0Lf", units), buf2)
for character buffersbuf1 and buf2. If the first character indigits or buf2 is equal toct.widen(’-’),
then the pattern used for formatting is the result ofmp.neg_format(); otherwise the pattern is the result
of mp.pos_format(). Digit characters are written, interspersed with any thousands separators and
decimal point specified by the format, in the order they appear (after the optional leading minus sign) in
digits or buf2. In digits, only the optional leading minus sign and the immediately subsequent digit
characters (as classified according toct) are used; any trailing characters (including digits appearing
after a non-digit character) are ignored. Callsstr.width(0).
2 Returns: An iterator pointing immediately after the last character produced.
3 Remarks: The currency symbol is generated if and only if(str.flags() & str.showbase) is nonzero.
If the number of characters generated for the specified format is less than the value returned by
str.width() on entry to the function, then copies offill are inserted as necessary to pad to the speci-
fied width. For the valueaf equal to(str.flags() & str.adjustfield), if(af == str.internal)
is true, the fill characters are placed wherenone or space appears in the formatting pattern; otherwise
if (af == str.left) is true, they are placed after the other characters; otherwise, they are placed
before the other characters.
[Note 1: It is possible, with some combinations of format patterns and flag values, to produce output that
cannot be parsed usingnum_get<>::get. —end note]
28.3.4.7.4 Class template moneypunct [locale.moneypunct]
28.3.4.7.4.1 General [locale.moneypunct.general]
namespace std {
class money_base {
public:
enum part { none, space, symbol, sign, value };
struct pattern { char field[4]; };
};
template<class charT, bool International = false>
class moneypunct : public locale::facet, public money_base {
public:
using char_type = charT;
using string_type = basic_string<charT>;
explicit moneypunct(size_t refs = 0);
charT decimal_point() const;
charT thousands_sep() const;
string grouping() const;
string_type curr_symbol() const;
string_type positive_sign() const;
string_type negative_sign() const;
int frac_digits() const;
pattern pos_format() const;
pattern neg_format() const;
static locale::id id;
static const bool intl = International;
protected:
~moneypunct();
virtual charT do_decimal_point() const;
virtual charT do_thousands_sep() const;
virtual string do_grouping() const;
virtual string_type do_curr_symbol() const;
virtual string_type do_positive_sign() const;
virtual string_type do_negative_sign() const;
virtual int do_frac_digits() const;
§ 28.3.4.7.4 © ISO/IEC
1652

===== PAGE 1664 =====

Dxxxx
virtual pattern do_pos_format() const;
virtual pattern do_neg_format() const;
};
}
1 The moneypunct<> facet defines monetary formatting parameters used bymoney_get<> and money_put<>. A
monetary format is a sequence of four components, specified by apattern value p, such that thepart value
static_cast<part>(p.field[i]) determines theith component of the format.222 In thefield member
of apattern object, each valuesymbol, sign, value, and eitherspace or none appears exactly once. The
value none, if present, is not first; the valuespace, if present, is neither first nor last.
2 Where none or space appears, whitespace is permitted in the format, except wherenone appears at the end,
in which case no whitespace is permitted. The valuespace indicates that at least one space is required at
that position. Wheresymbol appears, the sequence of characters returned bycurr_symbol() is permitted,
and can be required. Where sign appears, the first (if any) of the sequence of characters returned by
positive_sign() or negative_sign() (respectively as the monetary value is non-negative or negative) is
required. Any remaining characters of the sign sequence are required after all other format components.
Where value appears, the absolute numeric monetary value is required.
3 The format of the numeric monetary value is a decimal number:
value:
units fractionalopt
decimal-point digits
fractional:
decimal-point digitsopt
if frac_digits() returns a positive value, or
value:
units
otherwise. The symbol decimal-point indicates the character returned bydecimal_point(). The other
symbols are defined as follows:
units:
digits
digits thousands-sep units
digits:
adigit digitsopt
In the syntax specification, the symboladigit is any of the valuesct.widen(c) for c in the range’0’ through
’9’ (inclusive) andct is a reference of typeconst ctype<charT>& obtained as described in the definitions of
money_get<> and money_put<>. The symbolthousands-sep is the character returned bythousands_sep().
The space character used is the valuect.widen(’ ’). Whitespace characters are those charactersc for
which ci.is(space, c) returns true. The number of digits required after the decimal point (if any) is
exactly the value returned byfrac_digits().
4 The placement of thousands-separator characters (if any) is determined by the value returned bygrouping(),
defined identically as the membernumpunct<>::do_grouping().
28.3.4.7.4.2 Members [locale.moneypunct.members]
charT decimal_point() const;
charT thousands_sep() const;
string grouping() const;
string_type curr_symbol() const;
string_type positive_sign() const;
string_type negative_sign() const;
int frac_digits() const;
pattern pos_format() const;
pattern neg_format() const;
1 Each of these functionsF returns the result of calling the corresponding virtual member functiondo_F ().
222) An array ofchar, rather than an array ofpart, is specified forpattern::field purely for efficiency.
§ 28.3.4.7.4 © ISO/IEC
1653

===== PAGE 1665 =====

Dxxxx
28.3.4.7.4.3 Virtual functions [locale.moneypunct.virtuals]
charT do_decimal_point() const;
1 Returns: The radix separator to use in casedo_frac_digits() is greater than zero.223
charT do_thousands_sep() const;
2 Returns: The digit group separator to use in casedo_grouping() specifies a digit grouping pattern.224
string do_grouping() const;
3 Returns: A pattern defined identically as, but not necessarily equal to, the result ofnumpunct<charT>::
do_grouping().225
string_type do_curr_symbol() const;
4 Returns: A string to use as the currency identifier symbol.
[Note 1: For specializations where the second template parameter istrue, this is typically four characters long:
a three-letter code as specified by ISO 4217[1] followed by a space.—end note]
string_type do_positive_sign() const;
string_type do_negative_sign() const;
5 Returns: do_positive_sign() returns the string to use to indicate a positive monetary value;226
do_negative_sign() returns the string to use to indicate a negative value.
int do_frac_digits() const;
6 Returns: The number of digits after the decimal radix separator, if any.227
pattern do_pos_format() const;
pattern do_neg_format() const;
7 Returns: The specializations required in Table 92 (28.3.3.1.2.1), namely
—(7.1) moneypunct<char>,
—(7.2) moneypunct<wchar_t>,
—(7.3) moneypunct<char, true>, and
—(7.4) moneypunct<wchar_t, true>,
return an object of typepattern initialized to{ symbol, sign, none, value }.228
28.3.4.7.5 Class template moneypunct_byname [locale.moneypunct.byname]
namespace std {
template<class charT, bool Intl = false>
class moneypunct_byname : public moneypunct<charT, Intl> {
public:
using pattern = money_base::pattern;
using string_type = basic_string<charT>;
explicit moneypunct_byname(const char*, size_t refs = 0);
explicit moneypunct_byname(const string&, size_t refs = 0);
protected:
~moneypunct_byname();
};
}
28.3.4.8 The message retrieval category [category.messages]
28.3.4.8.1 General [category.messages.general]
1 Class messages<charT> implements retrieval of strings from message catalogs.
223) In common U.S. locales this is’.’.
224) In common U.S. locales this is’,’.
225) To specify grouping by 3s, the value is"\003" not "3".
226) This is usually the empty string.
227) In common U.S. locales, this is 2.
228) Note that the international symbol returned bydo_curr_symbol() usually contains a space, itself; for example,"USD ".
§ 28.3.4.8.1 © ISO/IEC
1654

===== PAGE 1666 =====

Dxxxx
28.3.4.8.2 Class template messages [locale.messages]
28.3.4.8.2.1 General [locale.messages.general]
namespace std {
class messages_base {
public:
using catalog = unspecified signed integer type ;
};
template<class charT>
class messages : public locale::facet, public messages_base {
public:
using char_type = charT;
using string_type = basic_string<charT>;
explicit messages(size_t refs = 0);
catalog open(const string& fn, const locale&) const;
string_type get(catalog c, int set, int msgid,
const string_type& dfault) const;
void close(catalog c) const;
static locale::id id;
protected:
~messages();
virtual catalog do_open(const string&, const locale&) const;
virtual string_type do_get(catalog, int set, int msgid,
const string_type& dfault) const;
virtual void do_close(catalog) const;
};
}
1 Values of typemessages_base::catalog usable as arguments to membersget and close can be obtained
only by calling memberopen.
28.3.4.8.2.2 Members [locale.messages.members]
catalog open(const string& name, const locale& loc) const;
1 Returns: do_open(name, loc).
string_type get(catalog cat, int set, int msgid, const string_type& dfault) const;
2 Returns: do_get(cat, set, msgid, dfault).
void close(catalog cat) const;
3 Effects: Calls do_close(cat).
28.3.4.8.2.3 Virtual functions [locale.messages.virtuals]
catalog do_open(const string& name, const locale& loc) const;
1 Returns: A value that may be passed toget() to retrieve a message from the message catalog identified
by the stringname according to an implementation-defined mapping. The result can be used until it is
passed toclose().
2 Returns a value less than 0 if no such catalog can be opened.
3 Remarks: The locale argumentloc is used for character set code conversion when retrieving messages,
if needed.
string_type do_get(catalog cat, int set, int msgid, const string_type& dfault) const;
4 Preconditions: cat is a catalog obtained fromopen() and not yet closed.
5 Returns: A message identified by argumentsset, msgid, anddfault, according to an implementation-
defined mapping. If no such message can be found, returnsdfault.
§ 28.3.4.8.2 © ISO/IEC
1655

===== PAGE 1667 =====

Dxxxx
void do_close(catalog cat) const;
6 Preconditions: cat is a catalog obtained fromopen() and not yet closed.
7 Effects: Releases unspecified resources associated withcat.
8 Remarks: The limit on such resources, if any, is implementation-defined.
28.3.4.8.3 Class template messages_byname [locale.messages.byname]
namespace std {
template<class charT>
class messages_byname : public messages<charT> {
public:
using catalog = messages_base::catalog;
using string_type = basic_string<charT>;
explicit messages_byname(const char*, size_t refs = 0);
explicit messages_byname(const string&, size_t refs = 0);
protected:
~messages_byname();
};
}
28.3.5 C library locales [c.locales]
28.3.5.1 Header <clocale> synopsis [clocale.syn]
namespace std {
struct lconv;
char* setlocale(int category, const char* locale);
lconv* localeconv();
}
#define NULL see 17.2.3
#define LC_ALL see below
#define LC_COLLATE see below
#define LC_CTYPE see below
#define LC_MONETARY see below
#define LC_NUMERIC see below
#define LC_TIME see below
1 The contents and meaning of the header<clocale>are the same as the C standard library header<locale.h>.
28.3.5.2 Data races [clocale.data.races]
1 Calls to the functionsetlocale may introduce a data race (16.4.6.10) with other calls tosetlocale or with
calls to the functions listed in Table 103.
See also: ISO/IEC 9899:2024, 7.11
Table 103 — Potentialsetlocale data races [tab:setlocale.data.races]
fprintf isprint iswdigit localeconv tolower
fscanf ispunct iswgraph mblen toupper
isalnum isspace iswlower mbstowcs towlower
isalpha isupper iswprint mbtowc towupper
isblank iswalnum iswpunct setlocale wcscoll
iscntrl iswalpha iswspace strcoll wcstod
isdigit iswblank iswupper strerror wcstombs
isgraph iswcntrl iswxdigit strtod wcsxfrm
islower iswctype isxdigit strxfrm wctomb
§ 28.3.5.2 © ISO/IEC
1656

===== PAGE 1668 =====

Dxxxx
28.4 Text encodings identification [text.encoding]
28.4.1 Header <text_encoding> synopsis [text.encoding.syn]
namespace std {
struct text_encoding;
// 28.4.2.7, hash support
template<class T> struct hash;
template<> struct hash<text_encoding>;
}
28.4.2 Class text_encoding [text.encoding.class]
28.4.2.1 Overview [text.encoding.overview]
1 The classtext_encoding describes an interface for accessing the IANA Character Sets registry[10].
namespace std {
struct text_encoding {
static constexpr size_t max_name_length = 63;
// 28.4.2.6, enumerationtext_encoding::id
enum class id : int_least32_t {
see below
};
using enum id;
constexpr text_encoding() = default;
constexpr explicit text_encoding(string_view enc) noexcept;
constexpr text_encoding(id i) noexcept;
constexpr id mib() const noexcept;
constexpr const char* name() const noexcept;
// 28.4.2.5, classtext_encoding::aliases_view
struct aliases_view;
constexpr aliases_view aliases() const noexcept;
friend constexpr bool operator==(const text_encoding& a,
const text_encoding& b) noexcept;
friend constexpr bool operator==(const text_encoding& encoding, id i) noexcept;
static consteval text_encoding literal() noexcept;
static text_encoding environment();
template<id i> static bool environment_is();
private:
id mib_ = id::unknown; // exposition only
char name_[max_name_length + 1] = {0}; // exposition only
static constexpr bool comp-name(string_view a, string_view b); // exposition only
};
}
2 Class text_encoding is a trivially copyable type (6.9.1).
28.4.2.2 General [text.encoding.general]
1 A registered character encodingis a character encoding scheme in the IANA Character Sets registry.
[Note 1: The IANA Character Sets registry uses the term “character sets” to refer to character encodings.—end
note]
The primary name of a registered character encoding is the name of that encoding specified in the IANA
Character Sets registry.
2 The set of known registered character encodings contains every registered character encoding specified in the
IANA Character Sets registry except for the following:
—(2.1) NATS-DANO (33)
§ 28.4.2.2 © ISO/IEC
1657

===== PAGE 1669 =====

Dxxxx
—(2.2) NATS-DANO-ADD (34)
3 Each known registered character encoding is identified by an enumerator intext_encoding::id, and has a
set of zero or morealiases.
4 The set of aliases of a known registered character encoding is an implementation-defined superset of the
aliases specified in the IANA Character Sets registry. The set of aliases for US-ASCII includes “ASCII”. No
two aliases or primary names of distinct registered character encodings are equivalent when compared by
text_encoding::comp-name .
5 How atext_encoding object is determined to be representative of a character encoding scheme implemented
in the translation or execution environment is implementation-defined.
6 An object e of type text_encoding such that e.mib() == text_encoding::id::unknown is false and
e.mib() == text_encoding::id::other is false maintains the following invariants:
—(6.1) *e.name() == ’\0’ is false, and
—(6.2) e.mib() == text_encoding(e.name()).mib() is true.
7 Recommended practice:
—(7.1) Implementations should not consider registered encodings to be interchangeable.
[Example 1: Shift_JIS and Windows-31J denote different encodings.—end example]
—(7.2) Implementations should not use the name of a registered encoding to describe another similar yet
different non-registered encoding unless there is a precedent on that implementation.
[Example 2: Big5 —end example]
28.4.2.3 Members [text.encoding.members]
constexpr explicit text_encoding(string_view enc) noexcept;
1 Preconditions:
—(1.1) enc represents a string in the ordinary literal encoding consisting only of elements of the basic
character set (5.3.1).
—(1.2) enc.size() <= max_name_length is true.
—(1.3) enc.contains(’\0’) is false.
2 Postconditions:
—(2.1) If there exists a primary name or aliasa of a known registered character encoding such that
comp-name (a, enc) is true, mib_ has the value of the enumerator ofid associated with that
registered character encoding. Otherwise,mib_ == id::other is true.
—(2.2) enc.compare(name_) == 0 is true.
constexpr text_encoding(id i) noexcept;
3 Preconditions: i has the value of one of the enumerators ofid.
4 Postconditions:
—(4.1) mib_ == i is true.
—(4.2) If (mib_ == id::unknown || mib_ == id::other) is true, strlen(name_) == 0 is true. Oth-
erwise, ranges::contains(aliases(), string_view(name_)) is true.
constexpr id mib() const noexcept;
5 Returns: mib_.
constexpr const char* name() const noexcept;
6 Returns: name_.
7 Remarks: name() is an ntbs and accessing elements of name_ outside of the rangename() + [0,
strlen(name()) + 1) is undefined behavior.
constexpr aliases_view aliases() const noexcept;
Let r denote an instance ofaliases_view. If *this represents a known registered character encoding,
then:
§ 28.4.2.3 © ISO/IEC
1658

===== PAGE 1670 =====

Dxxxx
—(7.1) r.front() is the primary name of the registered character encoding,
—(7.2) r contains the aliases of the registered character encoding, and
—(7.3) r does not contain duplicate values when compared withstrcmp.
Otherwise, r is an empty range.
8 Each element in r is a non-null, non-empty ntbs encoded in the literal character encoding and
comprising only characters from the basic character set.
9 Returns: r.
10 [Note 1: The order of aliases inr is unspecified. —end note]
static consteval text_encoding literal() noexcept;
11 Mandates: CHAR_BIT == 8 is true.
12 Returns: A text_encoding object representing the ordinary character literal encoding (5.3.1).
static text_encoding environment();
13 Mandates: CHAR_BIT == 8 is true.
14 Returns: A text_encoding object representing the implementation-defined character encoding scheme
of the environment. On a POSIX implementation, this is the encoding scheme associated with the
POSIX locale denoted by the empty string"".
15 [Note 2: This function is not affected by calls tosetlocale. —end note]
16 Recommended practice: Implementations should return a value that is not affected by calls to the
POSIX functionsetenv and other functions which can modify the environment (17.14).
template<id i>
static bool environment_is();
17 Mandates: CHAR_BIT == 8 is true.
18 Returns: environment() == i.
static constexpr bool comp-name (string_view a, string_view b);
19 Returns: true if the two stringsa and b encoded in the ordinary literal encoding are equal, ignoring,
from left-to-right,
—(19.1) all elements that are not digits or letters (16.3.3.3.4.1),
—(19.2) character case, and
—(19.3) any sequence of one or more0 characters not immediately preceded by a numeric prefix, where a
numeric prefix is a sequence consisting of a digit in the range[1,9] optionally followed by one or
more elements which are not digits or letters,
and false otherwise.
[Note 3: This comparison is identical to the “Charset Alias Matching” algorithm described in the Unicode
Technical Standard 22[12]. —end note]
[Example 1:
static_assert(comp-name ("UTF-8", "utf8") == true);
static_assert(comp-name ("u.t.f-008", "utf8") == true);
static_assert(comp-name ("ut8", "utf8") == false);
static_assert(comp-name ("utf-80", "utf8") == false);
—end example]
28.4.2.4 Comparison functions [text.encoding.cmp]
friend constexpr bool operator==(const text_encoding& a, const text_encoding& b) noexcept;
1 Returns: If a.mib_ == id::other && b.mib_ == id::other is true, then comp-name (a.name_,
b.name_). Otherwise, a.mib_ == b.mib_.
friend constexpr bool operator==(const text_encoding& encoding, id i) noexcept;
2 Returns: encoding.mib_ == i.
§ 28.4.2.4 © ISO/IEC
1659

===== PAGE 1671 =====

Dxxxx
3 Remarks: This operator induces an equivalence relation on its arguments if and only ifi != id::other
is true.
28.4.2.5 Class text_encoding::aliases_view [text.encoding.aliases]
struct text_encoding::aliases_view : ranges::view_interface<text_encoding::aliases_view> {
constexpr implementation-defined begin() const;
constexpr implementation-defined end() const;
};
1 text_encoding::aliases_view models copyable, ranges::view, ranges::random_access_range,
and ranges::borrowed_range.
[Note 1: text_encoding::aliases_view is not required to satisfy ranges::common_range, nor default_-
initializable. —end note]
2 Both ranges::range_value_t<text_encoding::aliases_view> and ranges::range_reference_-
t<text_encoding::aliases_view> denote const char*.
3 ranges::iterator_t<text_encoding::aliases_view> is a constexpr iterator (24.3.1).
28.4.2.6 Enumeration text_encoding::id [text.encoding.id]
namespace std {
enum class text_encoding::id : int_least32_t {
other = 1,
unknown = 2,
ASCII = 3,
ISOLatin1 = 4,
ISOLatin2 = 5,
ISOLatin3 = 6,
ISOLatin4 = 7,
ISOLatinCyrillic = 8,
ISOLatinArabic = 9,
ISOLatinGreek = 10,
ISOLatinHebrew = 11,
ISOLatin5 = 12,
ISOLatin6 = 13,
ISOTextComm = 14,
HalfWidthKatakana = 15,
JISEncoding = 16,
ShiftJIS = 17,
EUCPkdFmtJapanese = 18,
EUCFixWidJapanese = 19,
ISO4UnitedKingdom = 20,
ISO11SwedishForNames = 21,
ISO15Italian = 22,
ISO17Spanish = 23,
ISO21German = 24,
ISO60DanishNorwegian = 25,
ISO69French = 26,
ISO10646UTF1 = 27,
ISO646basic1983 = 28,
INVARIANT = 29,
ISO2IntlRefVersion = 30,
NATSSEFI = 31,
NATSSEFIADD = 32,
ISO10Swedish = 35,
KSC56011987 = 36,
ISO2022KR = 37,
EUCKR = 38,
ISO2022JP = 39,
ISO2022JP2 = 40,
ISO13JISC6220jp = 41,
ISO14JISC6220ro = 42,
ISO16Portuguese = 43,
ISO18Greek7Old = 44,
§ 28.4.2.6 © ISO/IEC
1660

===== PAGE 1672 =====

Dxxxx
ISO19LatinGreek = 45,
ISO25French = 46,
ISO27LatinGreek1 = 47,
ISO5427Cyrillic = 48,
ISO42JISC62261978 = 49,
ISO47BSViewdata = 50,
ISO49INIS = 51,
ISO50INIS8 = 52,
ISO51INISCyrillic = 53,
ISO54271981 = 54,
ISO5428Greek = 55,
ISO57GB1988 = 56,
ISO58GB231280 = 57,
ISO61Norwegian2 = 58,
ISO70VideotexSupp1 = 59,
ISO84Portuguese2 = 60,
ISO85Spanish2 = 61,
ISO86Hungarian = 62,
ISO87JISX0208 = 63,
ISO88Greek7 = 64,
ISO89ASMO449 = 65,
ISO90 = 66,
ISO91JISC62291984a = 67,
ISO92JISC62991984b = 68,
ISO93JIS62291984badd = 69,
ISO94JIS62291984hand = 70,
ISO95JIS62291984handadd = 71,
ISO96JISC62291984kana = 72,
ISO2033 = 73,
ISO99NAPLPS = 74,
ISO102T617bit = 75,
ISO103T618bit = 76,
ISO111ECMACyrillic = 77,
ISO121Canadian1 = 78,
ISO122Canadian2 = 79,
ISO123CSAZ24341985gr = 80,
ISO88596E = 81,
ISO88596I = 82,
ISO128T101G2 = 83,
ISO88598E = 84,
ISO88598I = 85,
ISO139CSN369103 = 86,
ISO141JUSIB1002 = 87,
ISO143IECP271 = 88,
ISO146Serbian = 89,
ISO147Macedonian = 90,
ISO150 = 91,
ISO151Cuba = 92,
ISO6937Add = 93,
ISO153GOST1976874 = 94,
ISO8859Supp = 95,
ISO10367Box = 96,
ISO158Lap = 97,
ISO159JISX02121990 = 98,
ISO646Danish = 99,
USDK = 100,
DKUS = 101,
KSC5636 = 102,
Unicode11UTF7 = 103,
ISO2022CN = 104,
ISO2022CNEXT = 105,
UTF8 = 106,
ISO885913 = 109,
ISO885914 = 110,
§ 28.4.2.6 © ISO/IEC
1661

===== PAGE 1673 =====

Dxxxx
ISO885915 = 111,
ISO885916 = 112,
GBK = 113,
GB18030 = 114,
OSDEBCDICDF0415 = 115,
OSDEBCDICDF03IRV = 116,
OSDEBCDICDF041 = 117,
ISO115481 = 118,
KZ1048 = 119,
UCS2 = 1000,
UCS4 = 1001,
UnicodeASCII = 1002,
UnicodeLatin1 = 1003,
UnicodeJapanese = 1004,
UnicodeIBM1261 = 1005,
UnicodeIBM1268 = 1006,
UnicodeIBM1276 = 1007,
UnicodeIBM1264 = 1008,
UnicodeIBM1265 = 1009,
Unicode11 = 1010,
SCSU = 1011,
UTF7 = 1012,
UTF16BE = 1013,
UTF16LE = 1014,
UTF16 = 1015,
CESU8 = 1016,
UTF32 = 1017,
UTF32BE = 1018,
UTF32LE = 1019,
BOCU1 = 1020,
UTF7IMAP = 1021,
Windows30Latin1 = 2000,
Windows31Latin1 = 2001,
Windows31Latin2 = 2002,
Windows31Latin5 = 2003,
HPRoman8 = 2004,
AdobeStandardEncoding = 2005,
VenturaUS = 2006,
VenturaInternational = 2007,
DECMCS = 2008,
PC850Multilingual = 2009,
PCp852 = 2010,
PC8CodePage437 = 2011,
PC8DanishNorwegian = 2012,
PC862LatinHebrew = 2013,
PC8Turkish = 2014,
IBMSymbols = 2015,
IBMThai = 2016,
HPLegal = 2017,
HPPiFont = 2018,
HPMath8 = 2019,
HPPSMath = 2020,
HPDesktop = 2021,
VenturaMath = 2022,
MicrosoftPublishing = 2023,
Windows31J = 2024,
GB2312 = 2025,
Big5 = 2026,
Macintosh = 2027,
IBM037 = 2028,
IBM038 = 2029,
IBM273 = 2030,
IBM274 = 2031,
IBM275 = 2032,
§ 28.4.2.6 © ISO/IEC
1662

===== PAGE 1674 =====

Dxxxx
IBM277 = 2033,
IBM278 = 2034,
IBM280 = 2035,
IBM281 = 2036,
IBM284 = 2037,
IBM285 = 2038,
IBM290 = 2039,
IBM297 = 2040,
IBM420 = 2041,
IBM423 = 2042,
IBM424 = 2043,
IBM500 = 2044,
IBM851 = 2045,
IBM855 = 2046,
IBM857 = 2047,
IBM860 = 2048,
IBM861 = 2049,
IBM863 = 2050,
IBM864 = 2051,
IBM865 = 2052,
IBM868 = 2053,
IBM869 = 2054,
IBM870 = 2055,
IBM871 = 2056,
IBM880 = 2057,
IBM891 = 2058,
IBM903 = 2059,
IBM904 = 2060,
IBM905 = 2061,
IBM918 = 2062,
IBM1026 = 2063,
IBMEBCDICATDE = 2064,
EBCDICATDEA = 2065,
EBCDICCAFR = 2066,
EBCDICDKNO = 2067,
EBCDICDKNOA = 2068,
EBCDICFISE = 2069,
EBCDICFISEA = 2070,
EBCDICFR = 2071,
EBCDICIT = 2072,
EBCDICPT = 2073,
EBCDICES = 2074,
EBCDICESA = 2075,
EBCDICESS = 2076,
EBCDICUK = 2077,
EBCDICUS = 2078,
Unknown8BiT = 2079,
Mnemonic = 2080,
Mnem = 2081,
VISCII = 2082,
VIQR = 2083,
KOI8R = 2084,
HZGB2312 = 2085,
IBM866 = 2086,
PC775Baltic = 2087,
KOI8U = 2088,
IBM00858 = 2089,
IBM00924 = 2090,
IBM01140 = 2091,
IBM01141 = 2092,
IBM01142 = 2093,
IBM01143 = 2094,
IBM01144 = 2095,
IBM01145 = 2096,
§ 28.4.2.6 © ISO/IEC
1663

===== PAGE 1675 =====

Dxxxx
IBM01146 = 2097,
IBM01147 = 2098,
IBM01148 = 2099,
IBM01149 = 2100,
Big5HKSCS = 2101,
IBM1047 = 2102,
PTCP154 = 2103,
Amiga1251 = 2104,
KOI7switched = 2105,
BRF = 2106,
TSCII = 2107,
CP51932 = 2108,
windows874 = 2109,
windows1250 = 2250,
windows1251 = 2251,
windows1252 = 2252,
windows1253 = 2253,
windows1254 = 2254,
windows1255 = 2255,
windows1256 = 2256,
windows1257 = 2257,
windows1258 = 2258,
TIS620 = 2259,
CP50220 = 2260
};
}
[Note 1: The text_encoding::id enumeration contains an enumerator for each known registered character encoding.
For each encoding, the corresponding enumerator is derived from the alias beginning with “cs”, as follows
— csUnicode is mapped totext_encoding::id::UCS2,
— csIBBM904 is mapped totext_encoding::id::IBM904, and
— the “cs” prefix is removed from other names.
—end note]
28.4.2.7 Hash support [text.encoding.hash]
template<> struct hash<text_encoding>;
1 The specialization is enabled (22.10.19).
28.5 Formatting [format]
28.5.1 Header <format> synopsis [format.syn]
namespace std {
// 28.5.6.7, class templatebasic_format_context
template<class Out, class charT> class basic_format_context;
using format_context = basic_format_context<unspecified , char>;
using wformat_context = basic_format_context<unspecified , wchar_t>;
// 28.5.8.3, class templatebasic_format_args
template<class Context> class basic_format_args;
using format_args = basic_format_args<format_context>;
using wformat_args = basic_format_args<wformat_context>;
// 28.5.4, class templatebasic_format_string
template<class charT, class... Args>
struct basic_format_string;
template<class charT> struct runtime-format-string { // exposition only
private:
basic_string_view<charT> str ; // exposition only
public:
constexpr runtime-format-string (basic_string_view<charT> s) noexcept : str (s) {}
runtime-format-string (const runtime-format-string &) = delete;
§ 28.5.1 © ISO/IEC
1664

===== PAGE 1676 =====

Dxxxx
runtime-format-string & operator=(const runtime-format-string &) = delete;
};
constexpr runtime-format-string <char>
runtime_format(string_view fmt) noexcept { return fmt; }
constexpr runtime-format-string <wchar_t>
runtime_format(wstring_view fmt) noexcept { return fmt; }
template<class... Args>
using format_string = basic_format_string<char, type_identity_t<Args>...>;
template<class... Args>
using wformat_string = basic_format_string<wchar_t, type_identity_t<Args>...>;
// 28.5.5, formatting functions
template<class... Args>
constexpr string format(format_string<Args...> fmt, Args&&... args);
template<class... Args>
constexpr wstring format(wformat_string<Args...> fmt, Args&&... args);
template<class... Args>
string format(const locale& loc, format_string<Args...> fmt, Args&&... args);
template<class... Args>
wstring format(const locale& loc, wformat_string<Args...> fmt, Args&&... args);
constexpr string vformat(string_view fmt, format_args args);
constexpr wstring vformat(wstring_view fmt, wformat_args args);
string vformat(const locale& loc, string_view fmt, format_args args);
wstring vformat(const locale& loc, wstring_view fmt, wformat_args args);
template<class Out, class... Args>
constexpr Out format_to(Out out, format_string<Args...> fmt, Args&&... args);
template<class Out, class... Args>
constexpr Out format_to(Out out, wformat_string<Args...> fmt, Args&&... args);
template<class Out, class... Args>
Out format_to(Out out, const locale& loc, format_string<Args...> fmt, Args&&... args);
template<class Out, class... Args>
Out format_to(Out out, const locale& loc, wformat_string<Args...> fmt, Args&&... args);
template<class Out>
constexpr Out vformat_to(Out out, string_view fmt, format_args args);
template<class Out>
constexpr Out vformat_to(Out out, wstring_view fmt, wformat_args args);
template<class Out>
Out vformat_to(Out out, const locale& loc, string_view fmt, format_args args);
template<class Out>
Out vformat_to(Out out, const locale& loc, wstring_view fmt, wformat_args args);
template<class Out> struct format_to_n_result {
Out out;
iter_difference_t<Out> size;
};
template<class Out, class... Args>
constexpr format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
format_string<Args...> fmt,
Args&&... args);
template<class Out, class... Args>
constexpr format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
wformat_string<Args...> fmt,
Args&&... args);
template<class Out, class... Args>
format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
const locale& loc, format_string<Args...> fmt,
Args&&... args);
template<class Out, class... Args>
format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
const locale& loc, wformat_string<Args...> fmt,
§ 28.5.1 © ISO/IEC
1665

===== PAGE 1677 =====

Dxxxx
Args&&... args);
template<class... Args>
constexpr size_t formatted_size(format_string<Args...> fmt, Args&&... args);
template<class... Args>
constexpr size_t formatted_size(wformat_string<Args...> fmt, Args&&... args);
template<class... Args>
size_t formatted_size(const locale& loc, format_string<Args...> fmt, Args&&... args);
template<class... Args>
size_t formatted_size(const locale& loc, wformat_string<Args...> fmt, Args&&... args);
// 28.5.6, formatter
template<class T, class charT = char> struct formatter;
// 28.5.6.2, formatter locking
template<class T>
constexpr bool enable_nonlocking_formatter_optimization = false;
// 28.5.6.3, conceptformattable
template<class T, class charT>
concept formattable = see below ;
template<class R, class charT>
concept const-formattable-range = // exposition only
ranges::input_range<const R> &&
formattable<ranges::range_reference_t<const R>, charT>;
template<class R, class charT>
using fmt-maybe-const = // exposition only
conditional_t<const-formattable-range <R, charT>, const R, R>;
// 28.5.6.6, class templatebasic_format_parse_context
template<class charT> class basic_format_parse_context;
using format_parse_context = basic_format_parse_context<char>;
using wformat_parse_context = basic_format_parse_context<wchar_t>;
// 28.5.7, formatting of ranges
// 28.5.7.1, variable templateformat_kind
enum class range_format {
disabled,
map,
set,
sequence,
string,
debug_string
};
template<class R>
constexpr unspecified format_kind = unspecified ;
template<ranges::input_range R>
requires same_as<R, remove_cvref_t<R>>
constexpr range_format format_kind<R> = see below ;
// 28.5.7.2, class templaterange_formatter
template<class T, class charT = char>
requires same_as<remove_cvref_t<T>, T> && formattable<T, charT>
class range_formatter;
// 28.5.7.3, class templaterange-default-formatter
template<range_format K, ranges::input_range R, class charT>
struct range-default-formatter ; // exposition only
§ 28.5.1 © ISO/IEC
1666

===== PAGE 1678 =====

Dxxxx
// 28.5.7.4, 28.5.7.5, 28.5.7.6, specializations for maps, sets, and strings
template<ranges::input_range R, class charT>
requires (format_kind<R> != range_format::disabled) &&
formattable<ranges::range_reference_t<R>, charT>
struct formatter<R, charT> : range-default-formatter <format_kind<R>, R, charT> { };
template<ranges::input_range R>
requires (format_kind<R> != range_format::disabled)
constexpr bool enable_nonlocking_formatter_optimization<R> = false;
// 28.5.8, arguments
// 28.5.8.1, class templatebasic_format_arg
template<class Context> class basic_format_arg;
// 28.5.8.2, class templateformat-arg-store
template<class Context, class... Args> class format-arg-store; // exposition only
template<class Context = format_context, class... Args>
constexpr format-arg-store <Context, Args...>
make_format_args(Args&... fmt_args);
template<class... Args>
constexpr format-arg-store <wformat_context, Args...>
make_wformat_args(Args&... args);
// 28.5.10, classformat_error
class format_error;
}
1 The class templateformat_to_n_result has the template parameters, data members, and special members
specified above. It has no base classes or members other than those specified.
28.5.2 Format string [format.string]
28.5.2.1 General [format.string.general]
1 A format stringfor argumentsargs is a (possibly empty) sequence ofreplacement fields, escape sequences,
and characters other than{ and }. Let charT be the character type of the format string. Each character
that is not part of a replacement field or an escape sequence is copied unchanged to the output. An escape
sequence is one of{{ or }}. It is replaced with{ or }, respectively, in the output. The syntax of replacement
fields is as follows:
replacement-field:
{ arg-idopt format-specifieropt }
arg-id:
0
positive-integer
positive-integer:
nonzero-digit
positive-integer digit
nonnegative-integer:
digit
nonnegative-integer digit
nonzero-digit: one of
1 2 3 4 5 6 7 8 9
digit: one of
0 1 2 3 4 5 6 7 8 9
format-specifier:
: format-spec
format-spec:
as specified by theformatter specialization for the argument type; cannot start with}
2 The arg-id field specifies the index of the argument inargs whose value is to be formatted and inserted
into the output instead of the replacement field. If there is no argument with the indexarg-id in args, the
§ 28.5.2.1 © ISO/IEC
1667

===== PAGE 1679 =====

Dxxxx
string is not a format string forargs. The optionalformat-specifier field explicitly specifies a format for the
replacement value.
3 [Example 1:
string s = format("{0}-{{", 8); // value ofs is "8-{"
—end example]
4 If all arg-ids in a format string are omitted (including those in theformat-spec, as interpreted by the
corresponding formatter specialization), argument indices 0, 1, 2, ... will automatically be used in that
order. If somearg-ids are omitted and some are present, the string is not a format string.
[Note 1: A format string cannot contain a mixture of automatic and manual indexing.—end note]
[Example 2:
string s0 = format("{} to {}", "a", "b"); // OK, automatic indexing
string s1 = format("{1} to {0}", "a", "b"); // OK, manual indexing
string s2 = format("{0} to {}", "a", "b"); // not a format string (mixing automatic and manual indexing),
// ill-formed
string s3 = format("{} to {1}", "a", "b"); // not a format string (mixing automatic and manual indexing),
// ill-formed
—end example]
5 The format-spec field containsformat specificationsthat define how the value should be presented. Each
type can define its own interpretation of theformat-spec field. If format-spec does not conform to the format
specifications for the argument type referred to byarg-id, the string is not a format string forargs.
[Example 3:
—(5.1) For arithmetic, pointer, and string types theformat-spec is interpreted as astd-format-spec as described
in 28.5.2.2.
—(5.2) For chrono types theformat-spec is interpreted as achrono-format-spec as described in 30.12.
—(5.3) For user-definedformatter specializations, the behavior of theparse member function determines how the
format-spec is interpreted.
—end example]
28.5.2.2 Standard format specifiers [format.string.std]
1 Each formatter specialization described in 28.5.6.4 for fundamental and string types interpretsformat-spec
as astd-format-spec.
[Note 1: The format specification can be used to specify such details as minimum field width, alignment, padding,
and decimal precision. Some of the formatting options are only supported for arithmetic types.—end note]
The syntax of format specifications is as follows:
std-format-spec:
fill-and-alignopt signopt #opt 0opt widthopt precisionopt Lopt typeopt
fill-and-align:
fillopt align
fill:
any character other than{ or }
align: one of
< > ^
sign: one of
+ - space
width:
positive-integer
{ arg-idopt }
precision:
. nonnegative-integer
. { arg-idopt }
type: one of
a A b B c d e E f F g G o p P s x X ?
§ 28.5.2.2 © ISO/IEC
1668

===== PAGE 1680 =====

Dxxxx
2 Field widths are specified infield width units; the number of column positions required to display a sequence
of characters in a terminal. Theminimum field widthis the number of field width units a replacement field
minimally requires of the formatted sequence of characters produced for a format argument. Theestimated
field width is the number of field width units that are required for the formatted sequence of characters
produced for a format argument independent of the effects of thewidth option. The padding widthis the
greater of0 and the difference of the minimum field width and the estimated field width.
[Note 2: The POSIXwcswidth function is an example of a function that, given a string, returns the number of column
positions required by a terminal to display the string.—end note]
3 The fill character is the character denoted by thefill option or, if thefill option is absent, the space character.
For a format specification in UTF-8, UTF-16, or UTF-32, the fill character corresponds to a single Unicode
scalar value.
[Note 3: The presence of afill option is signaled by the character following it, which must be one of the alignment
options. If the second character ofstd-format-spec is not a valid alignment option, then it is assumed that thefill and
align options are both absent.—end note]
4 The align option applies to all argument types. The meaning of the various alignment options is as specified
in Table 104.
[Example 1:
char c = 120;
string s0 = format("{:6}", 42); // value ofs0 is " 42"
string s1 = format("{:6}", 'x'); // value ofs1 is "x "
string s2 = format("{:*<6}", 'x'); // value ofs2 is "x*****"
string s3 = format("{:*>6}", 'x'); // value ofs3 is "*****x"
string s4 = format("{:*^6}", 'x'); // value ofs4 is "**x***"
string s5 = format("{:6d}", c); // value ofs5 is " 120"
string s6 = format("{:6}", true); // value ofs6 is "true "
string s7 = format("{:*<6.3}", "123456"); // value ofs7 is "123***"
string s8 = format("{:02}", 1234); // value ofs8 is "1234"
string s9 = format("{:*<}", "12"); // value ofs9 is "12"
string sA = format("{:*<6}", "12345678"); // value ofsA is "12345678"
string sB = format("{:
 ^6}", "x"); // value ofsB is "
 x
 "
string sC = format("{:*^6}", "
 "); // value ofsC is "
 "
—end example]
[Note 4: The fill, align, and0 options have no effect when the minimum field width is not greater than the estimated
field width because padding width is0 in that case. Since fill characters are assumed to have a field width of1, use of
a character with a different field width can produce misaligned output. The
(u+1f921 clown face) character has
a field width of2. The examples above that include that character illustrate the effect of the field width when that
character is used as a fill character as opposed to when it is used as a formatting argument.—end note]
Table 104 — Meaning ofalign options [tab:format.align]
Option Meaning
< Forces the formatted argument to be aligned to the start of the field by insertingn
fill characters after the formatted argument wheren is the padding width. This is
the default for non-arithmetic non-pointer types,charT, andbool, unless an integer
presentation type is specified.
> Forces the formatted argument to be aligned to the end of the field by insertingn fill
characters before the formatted argument wheren is the padding width. This is the
default for arithmetic types other thancharT and bool, pointer types, or when an
integer presentation type is specified.
^ Forces the formatted argument to be centered within the field by inserting
⌊n
2
⌋
fill
characters before and
⌈n
2
⌉
fill characters after the formatted argument, wheren is the
padding width.
5 The sign option is only valid for arithmetic types other thancharT and bool or when an integer presentation
type is specified. The meaning of the various options is as specified in Table 105.
6 The sign option applies to floating-point infinity and NaN.
§ 28.5.2.2 © ISO/IEC
1669

===== PAGE 1681 =====

Dxxxx
Table 105 — Meaning ofsign options [tab:format.sign]
Option Meaning
+ Indicates that a sign should be used for both non-negative and negative numbers. The
+ sign is inserted before the output ofto_chars for non-negative numbers other than
negative zero.
[Note 5: For negative numbers and negative zero the output ofto_chars will already contain
the sign so no additional transformation is performed.—end note]
- Indicates that a sign should be used for negative numbers and negative zero only (this
is the default behavior).
space Indicates that a leading space should be used for non-negative numbers other than
negative zero, and a minus sign for negative numbers and negative zero.
[Example 2:
double inf = numeric_limits<double>::infinity();
double nan = numeric_limits<double>::quiet_NaN();
string s0 = format("{0:},{0:+},{0:-},{0: }", 1); // value ofs0 is "1,+1,1, 1"
string s1 = format("{0:},{0:+},{0:-},{0: }", -1); // value ofs1 is "-1,-1,-1,-1"
string s2 = format("{0:},{0:+},{0:-},{0: }", inf); // value ofs2 is "inf,+inf,inf, inf"
string s3 = format("{0:},{0:+},{0:-},{0: }", nan); // value ofs3 is "nan,+nan,nan, nan"
—end example]
7 The # option causes thealternate formto be used for the conversion. This option is valid for arithmetic types
other thancharT and bool or when an integer presentation type is specified, and not otherwise. For integral
types, the alternate form inserts the base prefix (if any) specified in Table 107 into the output after the sign
character (possibly space) if there is one, or before the output ofto_chars otherwise. For floating-point
types, the alternate form causes the result of the conversion of finite values to always contain a decimal-point
character, even if no digits follow it. Normally, a decimal-point character appears in the result of these
conversions only if a digit follows it. In addition, forg and G conversions, trailing zeros are not removed from
the result.
8 The 0 option is valid for arithmetic types other thancharT and bool, pointer types, or when an integer
presentation type is specified. For formatting arguments that have a value other than an infinity or a NaN,
this option pads the formatted argument by inserting the0 character ntimes following the sign or base prefix
indicators (if any) wheren is 0 if thealign option is present and is the padding width otherwise.
[Example 3:
char c = 120;
string s1 = format("{:+06d}", c); // value ofs1 is "+00120"
string s2 = format("{:#06x}", 0xa); // value ofs2 is "0x000a"
string s3 = format("{:<06}", -42); // value ofs3 is "-42 " (0 has no effect)
string s4 = format("{:06}", inf); // value ofs4 is " inf" (0 has no effect)
—end example]
9 The width option specifies the minimum field width. If thewidth option is absent, the minimum field width
is 0.
10 If { arg-idopt } is used in awidth or precision option, the value of the corresponding formatting argument
is used as the value of the option. The option is valid only if the corresponding formatting argument is of
standard signed or unsigned integer type. If its value is negative, an exception of typeformat_error is
thrown.
11 If positive-integer is used in awidth option, the value of thepositive-integer is interpreted as a decimal integer
and used as the value of the option.
12 For the purposes of width computation, a string is assumed to be in a locale-independent, implementation-
defined encoding. Implementations should use either UTF-8, UTF-16, or UTF-32, on platforms capable of
displaying Unicode text in a terminal.
§ 28.5.2.2 © ISO/IEC
1670

===== PAGE 1682 =====

Dxxxx
[Note 6: This is the case for Windows®-based229 and many POSIX-based operating systems.—end note]
13 For a sequence of characters in UTF-8, UTF-16, or UTF-32, an implementation should use as its field width
the sum of the field widths of the first code point of each extended grapheme cluster. Extended grapheme
clusters are defined by UAX#29 of the Unicode Standard. The following code points have a field width of 2:
—(13.1) any code point with theEast_Asian_Width="W" or East_Asian_Width="F" property as described by
UAX #44 of the Unicode Standard
—(13.2) u+4dc0 – u+4dff (Yijing Hexagram Symbols)
—(13.3) u+1f300 – u+1f5ff (Miscellaneous Symbols and Pictographs)
—(13.4) u+1f900 – u+1f9ff (Supplemental Symbols and Pictographs)
The field width of all other code points is 1.
14 For a sequence of characters in neither UTF-8, UTF-16, nor UTF-32, the field width is unspecified.
15 The precision option is valid for floating-point and string types. For floating-point types, the value of this
option specifies the precision to be used for the floating-point presentation type. For string types, this option
specifies the longest prefix of the formatted argument to be included in the replacement field such that the
field width of the prefix is no greater than the value of this option.
16 If nonnegative-integer is used in aprecision option, the value of the decimal integer is used as the value of the
option.
17 When theL option is used, the form used for the conversion is called thelocale-specific form. The L option is
only valid for arithmetic types, and its effect depends upon the type. A call toformat on a given formatter
specialization is not a constant subexpression if the locale-specific form is specified.
—(17.1) For integral types, the locale-specific form causes the context’s locale to be used to insert the appropriate
digit group separator characters.
—(17.2) For floating-point types, the locale-specific form causes the context’s locale to be used to insert the
appropriate digit group and radix separator characters.
—(17.3) For the textual representation ofbool, the locale-specific form causes the context’s locale to be used to
insert the appropriate string as if obtained withnumpunct::truename or numpunct::falsename.
18 The type determines how the data should be presented.
19 The available string presentation types are specified in Table 106.
Table 106 — Meaning oftype options for strings [tab:format.type.string]
Type Meaning
none, s Copies the string to the output.
? Copies the escaped string (28.5.6.5) to the output.
20 The meaning of some non-string presentation types is defined in terms of a call toto_chars. In such cases, let
[first,last) be a range large enough to hold theto_chars output andvalue be the formatting argument
value. Formatting is done as if by callingto_chars as specified and copying the output through the output
iterator of the format context.
[Note 7: Additional padding and adjustments are performed prior to copying the output through the output iterator
as specified by the format specifiers.—end note]
21 The available integer presentation types for integral types other thanbool and charT are specified in
Table 107.
[Example 4:
string s0 = format("{}", 42); // value ofs0 is "42"
string s1 = format("{0:b} {0:d} {0:o} {0:x}", 42); // value ofs1 is "101010 42 52 2a"
string s2 = format("{0:#x} {0:#X}", 42); // value ofs2 is "0x2a 0X2A"
string s3 = format("{:L}", 1234); // value ofs3 can be"1,234"
// (depending on the locale)
229) Windows® is a registered trademark of Microsoft Corporation. This information is given for the convenience of users of this
document and does not constitute an endorsement by ISO or IEC of this product.
§ 28.5.2.2 © ISO/IEC
1671

===== PAGE 1683 =====

Dxxxx
—end example]
Table 107 — Meaning oftype options for integer types [tab:format.type.int]
Type Meaning
b to_chars(first, last, value, 2) ; the base prefix is0b.
B The same asb, except that the base prefix is0B.
c Copies the characterstatic_cast<charT>(value) to the output. Throwsformat_-
error if value is not in the range of representable values forcharT.
d to_chars(first, last, value) .
o to_chars(first, last, value, 8) ; the base prefix is0 if value is nonzero and is
empty otherwise.
x to_chars(first, last, value, 16) ; the base prefix is0x.
X The same asx, except that it uses uppercase letters for digits above 9 and the base
prefix is0X.
none The same as d.
[Note 8: If the formatting argument type ischarT or bool, the default is insteadc or s,
respectively. —end note]
22 The availablecharT presentation types are specified in Table 108.
Table 108 — Meaning oftype options forcharT [tab:format.type.char]
Type Meaning
none, c Copies the character to the output.
b, B, d, o, x, X As specified in Table 107 withvalue converted to the unsigned version of the underlying
type.
? Copies the escaped character (28.5.6.5) to the output.
23 The availablebool presentation types are specified in Table 109.
Table 109 — Meaning oftype options forbool [tab:format.type.bool]
Type Meaning
none, s Copies textual representation, eithertrue or false, to the output.
b, B, d, o, x, X As specified in Table 107 for the valuestatic_cast<unsigned char>(value).
24 The available floating-point presentation types and their meanings for values other than infinity and NaN are
specified in Table 110. For lower-case presentation types, infinity and NaN are formatted asinf and nan,
respectively. For upper-case presentation types, infinity and NaN are formatted asINF and NAN, respectively.
[Note 9: In either case, a sign is included if indicated by thesign option. —end note]
25 The available pointer presentation types and their mapping toto_chars are specified in Table 111.
[Note 10: Pointer presentation types also apply tonullptr_t. —end note]
28.5.3 Error reporting [format.err.report]
1 Formatting functions throwformat_error if an argumentfmt is passed that is not a format string forargs.
They propagate exceptions thrown by operations offormatter specializations and iterators. Failure to
allocate storage is reported by throwing an exception as described in 16.4.6.14.
28.5.4 Class template basic_format_string [format.fmt.string]
namespace std {
template<class charT, class... Args>
struct basic_format_string {
private:
basic_string_view<charT> str; // exposition only
§ 28.5.4 © ISO/IEC
1672

===== PAGE 1684 =====

Dxxxx
Table 110 — Meaning oftype options for floating-point types [tab:format.type.float]
Type Meaning
a If precision is specified, equivalent to
to_chars(first, last, value, chars_format::hex, precision)
where precision is the specified formatting precision; equivalent to
to_chars(first, last, value, chars_format::hex)
otherwise.
A The same asa, except that it uses uppercase letters for digits above 9 andP to indicate
the exponent.
e Equivalent to
to_chars(first, last, value, chars_format::scientific, precision)
where precision is the specified formatting precision, or6 if precision is not specified.
E The same ase, except that it usesE to indicate exponent.
f, F Equivalent to
to_chars(first, last, value, chars_format::fixed, precision)
where precision is the specified formatting precision, or6 if precision is not specified.
g Equivalent to
to_chars(first, last, value, chars_format::general, precision)
where precision is the specified formatting precision, or6 if precision is not specified.
G The same asg, except that it usesE to indicate exponent.
none If precision is specified, equivalent to
to_chars(first, last, value, chars_format::general, precision)
where precision is the specified formatting precision; equivalent to
to_chars(first, last, value)
otherwise.
Table 111 — Meaning oftype options for pointer types [tab:format.type.ptr]
Type Meaning
none, p If uintptr_t is defined,
to_chars(first, last, reinterpret_cast<uintptr_t>(value), 16)
with the prefix 0x inserted immediately before the output ofto_chars; otherwise,
implementation-defined.
P The same asp, except that it uses uppercase letters for digits above9 and the base
prefix is0X.
public:
template<class T> consteval basic_format_string(const T& s);
constexpr basic_format_string(runtime-format-string <charT> s) noexcept : str(s.str ) {}
constexpr basic_string_view<charT> get() const noexcept { return str ; }
};
}
template<class T> consteval basic_format_string(const T& s);
1 Constraints: const T& models convertible_to<basic_string_view<charT>>.
2 Effects: Direct-non-list-initializes str with s.
3 Remarks: A call to this function is not a core constant expression (7.7) unless there existargs of types
Args such thatstr is a format string forargs.
28.5.5 Formatting functions [format.functions]
1 A call to any of the functions defined in this subclause is a constant subexpression only if each of the used
formatter specializations is a constexpr-enabled specialization (28.5.6.4).
2 In the description of the functions, operator+ is used for some of the iterator categories for which it does not
have to be defined. In these cases the semantics ofa + n are the same as in 26.2.
§ 28.5.5 © ISO/IEC
1673

===== PAGE 1685 =====

Dxxxx
template<class... Args>
string format(format_string<Args...> fmt, Args&&... args);
3 Effects: Equivalent to:
return vformat(fmt.str , make_format_args(args...));
template<class... Args>
wstring format(wformat_string<Args...> fmt, Args&&... args);
4 Effects: Equivalent to:
return vformat(fmt.str , make_wformat_args(args...));
template<class... Args>
string format(const locale& loc, format_string<Args...> fmt, Args&&... args);
5 Effects: Equivalent to:
return vformat(loc, fmt.str , make_format_args(args...));
template<class... Args>
wstring format(const locale& loc, wformat_string<Args...> fmt, Args&&... args);
6 Effects: Equivalent to:
return vformat(loc, fmt.str , make_wformat_args(args...));
string vformat(string_view fmt, format_args args);
wstring vformat(wstring_view fmt, wformat_args args);
string vformat(const locale& loc, string_view fmt, format_args args);
wstring vformat(const locale& loc, wstring_view fmt, wformat_args args);
7 Returns: A string object holding the character representation of formatting arguments provided byargs
formatted according to specifications given infmt. If present,loc is used for locale-specific formatting.
8 Throws: As specified in 28.5.3.
template<class Out, class... Args>
Out format_to(Out out, format_string<Args...> fmt, Args&&... args);
9 Effects: Equivalent to:
return vformat_to(std::move(out), fmt.str , make_format_args(args...));
template<class Out, class... Args>
Out format_to(Out out, wformat_string<Args...> fmt, Args&&... args);
10 Effects: Equivalent to:
return vformat_to(std::move(out), fmt.str , make_wformat_args(args...));
template<class Out, class... Args>
Out format_to(Out out, const locale& loc, format_string<Args...> fmt, Args&&... args);
11 Effects: Equivalent to:
return vformat_to(std::move(out), loc, fmt.str , make_format_args(args...));
template<class Out, class... Args>
Out format_to(Out out, const locale& loc, wformat_string<Args...> fmt, Args&&... args);
12 Effects: Equivalent to:
return vformat_to(std::move(out), loc, fmt.str , make_wformat_args(args...));
template<class Out>
Out vformat_to(Out out, string_view fmt, format_args args);
template<class Out>
Out vformat_to(Out out, wstring_view fmt, wformat_args args);
template<class Out>
Out vformat_to(Out out, const locale& loc, string_view fmt, format_args args);
template<class Out>
Out vformat_to(Out out, const locale& loc, wstring_view fmt, wformat_args args);
13 Let charT be decltype(fmt)::value_type.
§ 28.5.5 © ISO/IEC
1674

===== PAGE 1686 =====

Dxxxx
14 Constraints: Out satisfies output_iterator<const charT&>.
15 Preconditions: Out models output_iterator<const charT&>.
16 Effects: Places the character representation of formatting the arguments provided byargs, formatted
according to the specifications given infmt, into the range[out,out + N), whereN is the number of
characters in that character representation. If present,loc is used for locale-specific formatting.
17 Returns: out + N.
18 Throws: As specified in 28.5.3.
template<class Out, class... Args>
format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
format_string<Args...> fmt, Args&&... args);
template<class Out, class... Args>
format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
wformat_string<Args...> fmt, Args&&... args);
template<class Out, class... Args>
format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
const locale& loc, format_string<Args...> fmt,
Args&&... args);
template<class Out, class... Args>
format_to_n_result<Out> format_to_n(Out out, iter_difference_t<Out> n,
const locale& loc, wformat_string<Args...> fmt,
Args&&... args);
19 Let
—(19.1) charT be decltype(fmt.str )::value_type,
—(19.2) Nbe formatted_size(fmt, args...)for the functions without alocparameter andformatted_-
size(loc, fmt, args...) for the functions with aloc parameter, and
—(19.3) M be clamp(n, 0, N).
20 Constraints: Out satisfies output_iterator<const charT&>.
21 Preconditions: Out models output_iterator<const charT&>, andformatter<remove_cvref_t<Ti>,
charT> meets theBasicFormatter requirements (28.5.6.1) for eachTi in Args.
22 Effects: Places the first M characters of the character representation of formatting the arguments
provided byargs, formatted according to the specifications given infmt, into the range[out,out +
M). If present,loc is used for locale-specific formatting.
23 Returns: {out + M, N}.
24 Throws: As specified in 28.5.3.
template<class... Args>
size_t formatted_size(format_string<Args...> fmt, Args&&... args);
template<class... Args>
size_t formatted_size(wformat_string<Args...> fmt, Args&&... args);
template<class... Args>
size_t formatted_size(const locale& loc, format_string<Args...> fmt, Args&&... args);
template<class... Args>
size_t formatted_size(const locale& loc, wformat_string<Args...> fmt, Args&&... args);
25 Let charT be decltype(fmt.str )::value_type.
26 Preconditions: formatter<remove_cvref_t<Ti>, charT> meets the BasicFormatter requirements
(28.5.6.1) for eachTi in Args.
27 Returns: The number of characters in the character representation of formatting argumentsargs
formatted according to specifications given infmt. If present,loc is used for locale-specific formatting.
28 Throws: As specified in 28.5.3.
28.5.6 Formatter [format.formatter]
28.5.6.1 Formatter requirements [formatter.requirements]
1 A typeF meets theBasicFormatter requirements if it meets the
§ 28.5.6.1 © ISO/IEC
1675

===== PAGE 1687 =====

Dxxxx
—(1.1) Cpp17DefaultConstructible (Table 30),
—(1.2) Cpp17CopyConstructible (Table 32),
—(1.3) Cpp17CopyAssignable (Table 34),
—(1.4) Cpp17Swappable (16.4.4.3), and
—(1.5) Cpp17Destructible (Table 35)
requirements, and the expressions shown in Table 112 are valid and have the indicated semantics.
2 A typeF meets theFormatter requirements if it meets theBasicFormatter requirements and the expressions
shown in Table 113 are valid and have the indicated semantics.
3 Given character typecharT, output iterator typeOut, and formatting argument typeT, in Table 112 and
Table 113:
—(3.1) f is a value of type (possibly const)F,
—(3.2) g is an lvalue of typeF,
—(3.3) u is an lvalue of typeT,
—(3.4) t is a value of a type convertible to (possibly const)T,
—(3.5) PC is basic_format_parse_context<charT>,
—(3.6) FC is basic_format_context<Out, charT>,
—(3.7) pc is an lvalue of typePC, and
—(3.8) fc is an lvalue of typeFC.
pc.begin() points to the beginning of theformat-spec (28.5.2) of the replacement field being formatted in the
format string. Ifformat-spec is not present or empty then eitherpc.begin() == pc.end() or *pc.begin()
== ’}’.
Table 112 —BasicFormatter requirements [tab:formatter.basic]
Expression Return type Requirement
g.parse(pc) PC::iterator Parses format-spec (28.5.2) for type T in the
range [pc.begin(),pc.end()) until the first un-
matched character. Throws format_error un-
less the whole range is parsed or the unmatched
character is}.
[Note 1: This allows formatters to emit meaningful
error messages. —end note]
Stores the parsed format specifiers in*this and
returns an iterator past the end of the parsed
range.
f.format(u, fc) FC::iterator Formats u according to the specifiers stored in
*this, writes the output tofc.out(), and re-
turns an iterator past the end of the output range.
The output shall only depend onu, fc.locale(),
fc.arg(n) for any valuen of typesize_t, and
the range[pc.begin(),pc.end()) from the last
call tof.parse(pc).
28.5.6.2 Formatter locking [format.formatter.locking]
template<class T>
constexpr bool enable_nonlocking_formatter_optimization = false;
1 Remarks: Pursuant to 16.4.5.2.1, users may specializeenable_nonlocking_formatter_optimization
for cv-unqualified program-defined types. Such specializations shall be usable in constant expressions
(7.7) and have typeconst bool.
§ 28.5.6.2 © ISO/IEC
1676

===== PAGE 1688 =====

Dxxxx
Table 113 —Formatter requirements [tab:formatter]
Expression Return type Requirement
f.format(t, fc) FC::iterator Formats t according to the specifiers stored in
*this, writes the output tofc.out(), and re-
turns an iterator past the end of the output range.
The output shall only depend ont, fc.locale(),
fc.arg(n) for any valuen of typesize_t, and
the range[pc.begin(),pc.end()) from the last
call tof.parse(pc).
f.format(u, fc) FC::iterator As above, but does not modifyu.
28.5.6.3 Concept formattable [format.formattable]
1 Letfmt-iter-for <charT>be anunspecifiedtype thatmodels output_iterator<const charT&>(24.3.4.10).
template<class T, class Context,
class Formatter = typename Context::template formatter_type<remove_const_t<T>>>
concept formattable-with = // exposition only
semiregular<Formatter> &&
requires(Formatter& f, const Formatter& cf, T&& t, Context fc,
basic_format_parse_context<typename Context::char_type> pc)
{
{ f.parse(pc) } -> same_as<typename decltype(pc)::iterator>;
{ cf.format(t, fc) } -> same_as<typename Context::iterator>;
};
template<class T, class charT>
concept formattable =
formattable-with <remove_reference_t<T>, basic_format_context<fmt-iter-for <charT>, charT>>;
2 A typeT and a character typecharT model formattable if formatter<remove_cvref_t<T>, charT> meets
the BasicFormatter requirements (28.5.6.1) and, ifremove_reference_t<T> is const-qualified, theFormatter
requirements.
28.5.6.4 Formatter specializations [format.formatter.spec]
1 The functions defined in 28.5.5 use specializations of the class templateformatter to format individual
arguments.
2 Let charT be eitherchar or wchar_t. Each specialization offormatter is either enabled or disabled, as
described below. A debug-enabled specialization of formatter additionally provides a public, constexpr,
non-static member functionset_debug_format() which modifies the state of theformatter to be as if the
type of thestd-format-spec parsed by the last call toparse were ?. A constexpr-enabled specialization of
formatter has itsformat member function declaredconstexpr. Each header that declares the template
formatter provides the following enabled specializations:
—(2.1) The debug-enabled and constexpr-enabled specializations
template<> struct formatter<char, char>;
template<> struct formatter<char, wchar_t>;
template<> struct formatter<wchar_t, wchar_t>;
—(2.2) For eachcharT, the debug-enabled and constexpr-enabled string type specializations
template<> struct formatter<charT*, charT>;
template<> struct formatter<const charT*, charT>;
template<size_t N> struct formatter<charT[N], charT>;
template<class traits, class Allocator>
struct formatter<basic_string<charT, traits, Allocator>, charT>;
template<class traits>
struct formatter<basic_string_view<charT, traits>, charT>;
—(2.3) For eachcharT, for eachIntegerT that is either a signed or unsigned integer type orbool, a constexpr-
enabled specialization
§ 28.5.6.4 © ISO/IEC
1677

===== PAGE 1689 =====

Dxxxx
template<> struct formatter<IntegerT, charT>;
—(2.4) For eachcharT, for eachFloatingT that is a cv-unqualified floating-point type, a specialization
template<> struct formatter<FloatingT, charT>;
—(2.5) For eachcharT, the constexpr-enabled pointer type specialization
template<> struct formatter<nullptr_t, charT>;
—(2.6) For eachcharT, the pointer type specializations
template<> struct formatter<void*, charT>;
template<> struct formatter<const void*, charT>;
The parse member functions of these formatters interpret the format specification as astd-format-spec as
described in 28.5.2.2.
3 Unless specified otherwise, for each typeT for which aformatter specialization is provided by the library,
each of the headers provides the following specialization:
template<> inline constexpr bool enable_nonlocking_formatter_optimization<T> = true;
[Note 1: Specializations such asformatter<wchar_t, char> that would require implicit multibyte / wide string or
character conversion are disabled.—end note]
4 The header<format> provides the following disabled specializations:
—(4.1) The string type specializations
template<> struct formatter<char*, wchar_t>;
template<> struct formatter<const char*, wchar_t>;
template<size_t N> struct formatter<char[N], wchar_t>;
template<class traits, class Allocator>
struct formatter<basic_string<char, traits, Allocator>, wchar_t>;
template<class traits>
struct formatter<basic_string_view<char, traits>, wchar_t>;
5 For any types T and charT for which neither the library nor the user provides an explicit or partial
specialization of the class templateformatter, formatter<T, charT> is disabled.
6 If the library provides an explicit or partial specialization offormatter<T, charT>, that specialization is
enabled and meets theFormatter requirements except as noted otherwise.
7 If F is a disabled specialization offormatter, these values arefalse:
—(7.1) is_default_constructible_v<F>,
—(7.2) is_copy_constructible_v<F>,
—(7.3) is_move_constructible_v<F>,
—(7.4) is_copy_assignable_v<F>, and
—(7.5) is_move_assignable_v<F>.
8 An enabled specializationformatter<T, charT> meets theBasicFormatter requirements (28.5.6.1).
[Example 1:
#include <format>
#include <string>
enum color { red, green, blue };
const char* color_names[] = { "red", "green", "blue" };
template<> struct std::formatter<color> : std::formatter<const char*> {
auto format(color c, format_context& ctx) const {
return formatter<const char*>::format(color_names[c], ctx);
}
};
struct err {};
std::string s0 = std::format("{}", 42); // OK, library-provided formatter
std::string s1 = std::format("{}", L"foo"); // error: disabled formatter
std::string s2 = std::format("{}", red); // OK, user-provided formatter
§ 28.5.6.4 © ISO/IEC
1678

===== PAGE 1690 =====

Dxxxx
std::string s3 = std::format("{}", err{}); // error: disabled formatter
—end example]
28.5.6.5 Formatting escaped characters and strings [format.string.escaped]
1 A character or string can be formatted asescaped to make it more suitable for debugging or for logging.
2 The escaped stringE representation of a stringS is constructed by encoding a sequence of characters as
follows. The associated character encodingCE for charT (Table 12) is used to both interpretS and construct
E.
—(2.1) u+0022 quotation mark(") is appended toE.
—(2.2) For each code unit sequenceX in S that either encodes a single character, is a shift sequence, or is a
sequence of ill-formed code units, processing is in order as follows:
—(2.2.1) If X encodes a single characterC, then:
—(2.2.1.1) If C is one of the characters in Table 114, then the two characters shown as the corresponding
escape sequence are appended toE.
—(2.2.1.2) Otherwise, ifC is notu+0020 space and
—(2.2.1.2) CE is UTF-8, UTF-16, or UTF-32 andC corresponds to a Unicode scalar value whose
Unicode propertyGeneral_Category has a value in the groupsSeparator (Z) orOther
(C), as described by UAX#44 of the Unicode Standard, or
—(2.2.1.2) CE is UTF-8, UTF-16, or UTF-32 andC corresponds to a Unicode scalar value with
the Unicode propertyGrapheme_Extend=Yes as described by UAX#44 of the Unicode
Standard andC is not immediately preceded inS by a characterP appended toE without
translation to an escape sequence, or
—(2.2.1.2) CE is neither UTF-8, UTF-16, nor UTF-32 andC is one of an implementation-defined
set of separator or non-printable characters
then the sequence\u{hex-digit-sequence } is appended toE, wherehex-digit-sequence
is the shortest hexadecimal representation ofC using lower-case hexadecimal digits.
—(2.2.1.3) Otherwise, C is appended toE.
—(2.2.2) Otherwise, ifX is a shift sequence, the effect onE and further decoding ofS is unspecified.
Recommended practice: A shift sequence should be represented inE such that the original code
unit sequence ofS can be reconstructed.
—(2.2.3) Otherwise (X is a sequence of ill-formed code units), each code unitU is appended toE in order as
the sequence\x{hex-digit-sequence }, wherehex-digit-sequence is the shortest hexadecimal
representation ofU using lower-case hexadecimal digits.
—(2.3) Finally,u+0022 quotation mark(") is appended toE.
Table 114 — Mapping of characters to escape sequences [tab:format.escape.sequences]
Character Escape sequence
u+0009 character tabulation \t
u+000a line feed \n
u+000d carriage return \r
u+0022 quotation mark \"
u+005c reverse solidus \\
3 The escaped string representation of a characterC is equivalent to the escaped string representation of a
string ofC, except that:
—(3.1) the result starts and ends withu+0027 apostrophe (’) instead ofu+0022 quotation mark("), and
—(3.2) if C is u+0027 apostrophe, the two characters\’ are appended toE, and
—(3.3) if C is u+0022 quotation mark, thenC is appended unchanged.
§ 28.5.6.5 © ISO/IEC
1679

===== PAGE 1691 =====

Dxxxx
[Example 1:
string s0 = format("[{}]", "h\tllo"); // s0 has value: [h llo]
string s1 = format("[{:?}]", "h\tllo"); // s1 has value: ["h\tllo"]
string s2 = format("[{:?}]", "
Спасибо, Виктор
 ! "); // s2 has value: ["
Спасибо, Виктор
 ! "]
string s3 = format("[{:?}, {:?}]", '\'', '"'); // s3 has value: [’\’’, ’"’]
// The following examples assume use of the UTF-8 encoding
string s4 = format("[{:?}]", string("\0 \n \t \x02 \x1b", 9));
// s4 has value: ["\u{0} \n \t \u{2} \u{1b}"]
string s5 = format("[{:?}]", "\xc3\x28"); // invalid UTF-8,s5 has value: ["\x{c3}("]
string s6 = format("[{:?}]", "
 "); // s6 has value: ["
 \u{200d}
 "]
string s7 = format("[{:?}]", "\u0301"); // s7 has value: ["\u{301}"]
string s8 = format("[{:?}]", "\\\u0301"); // s8 has value: ["\\\u{301}"]
string s9 = format("[{:?}]", "e\u0301\u0323"); // s9 has value: ["
ẹ́ "]
—end example]
28.5.6.6 Class template basic_format_parse_context [format.parse.ctx]
namespace std {
template<class charT>
class basic_format_parse_context {
public:
using char_type = charT;
using const_iterator = basic_string_view<charT>::const_iterator;
using iterator = const_iterator;
private:
iterator begin_; // exposition only
iterator end_; // exposition only
enum indexing { unknown, manual, automatic }; // exposition only
indexing indexing_; // exposition only
size_t next_arg_id_; // exposition only
size_t num_args_; // exposition only
public:
constexpr explicit basic_format_parse_context(basic_string_view<charT> fmt) noexcept;
basic_format_parse_context(const basic_format_parse_context&) = delete;
basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;
constexpr const_iterator begin() const noexcept;
constexpr const_iterator end() const noexcept;
constexpr void advance_to(const_iterator it);
constexpr size_t next_arg_id();
constexpr void check_arg_id(size_t id);
template<class... Ts>
constexpr void check_dynamic_spec(size_t id) noexcept;
constexpr void check_dynamic_spec_integral(size_t id) noexcept;
constexpr void check_dynamic_spec_string(size_t id) noexcept;
};
}
1 An instance ofbasic_format_parse_context holds the format string parsing state, consisting of the format
string range being parsed and the argument counter for automatic indexing.
2 If a program declares an explicit or partial specialization ofbasic_format_parse_context, the program is
ill-formed, no diagnostic required.
constexpr explicit basic_format_parse_context(basic_string_view<charT> fmt) noexcept;
3 Effects: Initializes begin_ with fmt.begin(), end_ with fmt.end(), indexing_ with unknown, next_-
arg_id_ with 0, andnum_args_ with 0.
[Note 1: Any call tonext_arg_id, check_arg_id, orcheck_dynamic_spec on an instance ofbasic_format_-
parse_context initialized using this constructor is not a core constant expression.—end note]
§ 28.5.6.6 © ISO/IEC
1680

===== PAGE 1692 =====

Dxxxx
constexpr const_iterator begin() const noexcept;
4 Returns: begin_.
constexpr const_iterator end() const noexcept;
5 Returns: end_.
constexpr void advance_to(const_iterator it);
6 Preconditions: end() is reachable fromit.
7 Effects: Equivalent to:begin_ = it;
constexpr size_t next_arg_id();
8 Effects: If indexing_ != manual is true, equivalent to:
if (indexing_ == unknown)
indexing_ = automatic;
return next_arg_id_++;
9 Throws: format_error if indexing_ == manual is true.
[Note 2: This indicates mixing of automatic and manual argument indexing.—end note]
10 Remarks: Let cur-arg-id be the value ofnext_arg_id_ prior to this call. Call expressions where
cur-arg-id >= num_args_ is true are not core constant expressions (7.7).
constexpr void check_arg_id(size_t id);
11 Effects: If indexing_ != automatic is true, equivalent to:
if (indexing_ == unknown)
indexing_ = manual;
12 Throws: format_error if indexing_ == automatic is true.
[Note 3: This indicates mixing of automatic and manual argument indexing.—end note]
13 Remarks: A call to this function is a core constant expression (7.7) only ifid < num_args_ is true.
template<class... Ts>
constexpr void check_dynamic_spec(size_t id) noexcept;
14 Mandates: sizeof...(Ts) ≥1. The types inTs... are unique. Each type inTs... is one ofbool,
char_type, int, unsigned int, long long int, unsigned long long int, float, double, long
double, const char_type*, basic_string_view<char_type>, orconst void*.
15 Remarks: A call to this function is a core constant expression only if
—(15.1) id < num_args_ is true and
—(15.2) the type of the corresponding format argument (after conversion tobasic_format_arg<Context>)
is one of the types inTs....
constexpr void check_dynamic_spec_integral(size_t id) noexcept;
16 Effects: Equivalent to:
check_dynamic_spec<int, unsigned int, long long int, unsigned long long int>(id);
constexpr void check_dynamic_spec_string(size_t id) noexcept;
17 Effects: Equivalent to:
check_dynamic_spec<const char_type*, basic_string_view<char_type>>(id);
28.5.6.7 Class template basic_format_context [format.context]
namespace std {
template<class Out, class charT>
class basic_format_context {
basic_format_args<basic_format_context> args_; // exposition only
Out out_; // exposition only
basic_format_context(const basic_format_context&) = delete;
basic_format_context& operator=(const basic_format_context&) = delete;
§ 28.5.6.7 © ISO/IEC
1681

===== PAGE 1693 =====

Dxxxx
public:
using iterator = Out;
using char_type = charT;
template<class T> using formatter_type = formatter<T, charT>;
constexpr basic_format_arg<basic_format_context> arg(size_t id) const noexcept;
std::locale locale();
constexpr iterator out();
constexpr void advance_to(iterator it);
};
}
1 An instance ofbasic_format_context holds formatting state consisting of the formatting arguments and
the output iterator.
2 If a program declares an explicit or partial specialization ofbasic_format_context, the program is ill-formed,
no diagnostic required.
3 Out shall modeloutput_iterator<const charT&>.
4 format_context is an alias for a specialization ofbasic_format_context with an output iterator that
appends tostring, such asback_insert_iterator<string>. Similarly,wformat_context is an alias for a
specialization of basic_format_context with an output iterator that appends towstring.
5 Recommended practice: For a given typecharT, implementations should provide a single instantiation of
basic_format_context for appending tobasic_string<charT>, vector<charT>, or any other container
with contiguous storage by wrapping those in temporary objects with a uniform interface (such as a
span<charT>) and polymorphic reallocation.
basic_format_arg<basic_format_context> arg(size_t id) const noexcept;
6 Returns: args_.get(id).
std::locale locale();
7 Returns: The locale passed to the formatting function if the latter takes one, andstd::locale()
otherwise.
iterator out();
8 Effects: Equivalent to:return std::move(out_);
void advance_to(iterator it);
9 Effects: Equivalent to:out_ = std::move(it);
[Example 1:
struct S { int value; };
template<> struct std::formatter<S> {
size_t width_arg_id = 0;
// Parses a width argument id in the format{ digit }.
constexpr auto parse(format_parse_context& ctx) {
auto iter = ctx.begin();
auto is_digit = [](auto c) { return c >= '0' && c <= '9'; };
auto get_char = [&]() { return iter != ctx.end() ? *iter : 0; };
if (get_char() != '{')
return iter;
++iter;
char c = get_char();
if (!is_digit(c) || (++iter, get_char()) != '}')
throw format_error("invalid format");
width_arg_id = c - '0';
ctx.check_arg_id(width_arg_id);
return ++iter;
}
§ 28.5.6.7 © ISO/IEC
1682

===== PAGE 1694 =====

Dxxxx
// Formats anS with width given by the argumentwidth_arg_id.
auto format(S s, format_context& ctx) const {
int width = ctx.arg(width_arg_id).visit([](auto value) -> int {
if constexpr (!is_integral_v<decltype(value)>)
throw format_error("width is not integral");
else if (value < 0 || value > numeric_limits<int>::max())
throw format_error("invalid width");
else
return value;
});
return format_to(ctx.out(), "{0:x>{1}}", s.value, width);
}
};
std::string s = std::format("{0:{1}}", S{42}, 10); // value ofs is "xxxxxxxx42"
—end example]
28.5.7 Formatting of ranges [format.range]
28.5.7.1 Variable template format_kind [format.range.fmtkind]
template<ranges::input_range R>
requires same_as<R, remove_cvref_t<R>>
constexpr range_format format_kind<R> = see below ;
1 A program that instantiates the primary template offormat_kind is ill-formed.
2 For a typeR, format_kind<R> is defined as follows:
—(2.1) If same_as<remove_cvref_t<ranges::range_reference_t<R>>, R> is true, format_kind<R>
is range_format::disabled.
[Note 1: This prevents constraint recursion for ranges whose reference type is the same range type. For
example, std::filesystem::path is a range ofstd::filesystem::path. —end note]
—(2.2) Otherwise, if thequalified-id R::key_type is valid and denotes a type:
—(2.2.1) If the qualified-id R::mapped_type is valid and denotes a type, letU be remove_cvref_-
t<ranges::range_reference_t<R>>. If eitherU is a specialization ofpair or U is a special-
ization oftuple and tuple_size_v<U> == 2, format_kind<R> is range_format::map.
—(2.2.2) Otherwise, format_kind<R> is range_format::set.
—(2.3) Otherwise, format_kind<R> is range_format::sequence.
3 Remarks: Pursuant to 16.4.5.2.1, users may specializeformat_kind for cv-unqualified program-defined
types that modelranges::input_range. Such specializations shall be usable in constant expressions
(7.7) and have typeconst range_format.
28.5.7.2 Class template range_formatter [format.range.formatter]
namespace std {
template<class T, class charT = char>
requires same_as<remove_cvref_t<T>, T> && formattable<T, charT>
class range_formatter {
formatter<T, charT> underlying_; // exposition only
basic_string_view<charT> separator_ = STATICALLY-WIDEN <charT>(", "); // exposition only
basic_string_view<charT> opening-bracket_ = STATICALLY-WIDEN <charT>("["); // exposition only
basic_string_view<charT> closing-bracket_ = STATICALLY-WIDEN <charT>("]"); // exposition only
public:
constexpr void set_separator(basic_string_view<charT> sep) noexcept;
constexpr void set_brackets(basic_string_view<charT> opening,
basic_string_view<charT> closing) noexcept;
constexpr formatter<T, charT>& underlying() noexcept { return underlying_; }
constexpr const formatter<T, charT>& underlying() const noexcept { return underlying_; }
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
§ 28.5.7.2 © ISO/IEC
1683

===== PAGE 1695 =====

Dxxxx
template<ranges::input_range R, class FormatContext>
requires formattable<ranges::range_reference_t<R>, charT> &&
same_as<remove_cvref_t<ranges::range_reference_t<R>>, T>
constexpr typename FormatContext::iterator
format(R&& r, FormatContext& ctx) const;
};
}
1 The class templaterange_formatter is a utility for implementingformatter specializations for range types.
2 range_formatter interprets format-spec as arange-format-spec. The syntax of format specifications is as
follows:
range-format-spec:
range-fill-and-alignopt widthopt nopt range-typeopt range-underlying-specopt
range-fill-and-align:
range-fillopt align
range-fill:
any character other than{ or } or :
range-type:
m
s
?s
range-underlying-spec:
: format-spec
3 For range_formatter<T, charT>, the format-spec in a range-underlying-spec, if any, is interpreted by
formatter<T, charT>.
4 The range-fill-and-align is interpreted the same way as afill-and-align (28.5.2.2). The productionsalign and
width are described in 28.5.2.
5 The n option causes the range to be formatted without the opening and closing brackets.
[Note 1: This is equivalent to invokingset_brackets({}, {}). —end note]
6 The range-type specifier changes the way a range is formatted, with certain options only valid with certain
argument types. The meaning of the various type options is as specified in Table 115.
Table 115 — Meaning ofrange-type options [tab:formatter.range.type]
Option Requirements Meaning
m T shall be either a
specialization of pair
or a specialization
of tuple such that
tuple_size_v<T> is 2.
Indicates that the opening bracket should be
"{", the closing bracket should be"}", the
separator should be ", ", and each range
element should be formatted as ifm were spec-
ified for itstuple-type.
[Note 2: If then option is provided in addition
to the m option, both the opening and closing
brackets are still empty.—end note]
s T shall becharT. Indicates that the range should be formatted
as astring.
?s T shall becharT. Indicates that the range should be formatted
as an escaped string (28.5.6.5).
If therange-type is s or ?s, then there shall be non option and norange-underlying-spec.
constexpr void set_separator(basic_string_view<charT> sep) noexcept;
7 Effects: Equivalent to:separator_ = sep;
constexpr void set_brackets(basic_string_view<charT> opening,
basic_string_view<charT> closing) noexcept;
8 Effects: Equivalent to:
§ 28.5.7.2 © ISO/IEC
1684

===== PAGE 1696 =====

Dxxxx
opening-bracket_ = opening;
closing-bracket_ = closing;
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
9 Effects: Parses the format specifiers as arange-format-spec and stores the parsed specifiers in*this.
Calls underlying_.parse(ctx) to parseformat-spec in range-format-spec or, if the latter is not present,
an emptyformat-spec. The values of opening-bracket_, closing-bracket_, and separator_ are
modified if and only if required by therange-type or then option, if present. If:
—(9.1) the range-type is neithers nor ?s,
—(9.2) underlying_.set_debug_format() is a valid expression, and
—(9.3) there is norange-underlying-spec,
then callsunderlying_.set_debug_format().
10 Returns: An iterator past the end of therange-format-spec.
template<ranges::input_range R, class FormatContext>
requires formattable<ranges::range_reference_t<R>, charT> &&
same_as<remove_cvref_t<ranges::range_reference_t<R>>, T>
typename FormatContext::iterator
format(R&& r, FormatContext& ctx) const;
11 Effects: Writes the following intoctx.out(), adjusted according to therange-format-spec:
—(11.1) If therange-type was s, then as if by formattingbasic_string<charT>(from_range, r).
—(11.2) Otherwise, if therange-type was ?s, then as if by formattingbasic_string<charT>(from_range,
r) as an escaped string (28.5.6.5).
—(11.3) Otherwise,
—(11.3.1) opening-bracket_,
—(11.3.2) for each elemente of the ranger:
—(11.3.2.1) the result of writinge via underlying_ and
—(11.3.2.2) separator_, unlesse is the last element ofr, and
—(11.3.3) closing-bracket_.
12 Returns: An iterator past the end of the output range.
28.5.7.3 Class template range-default-formatter [format.range.fmtdef]
namespace std {
template<ranges::input_range R, class charT>
struct range-default-formatter<range_format::sequence, R, charT> { // exposition only
private:
using maybe-const-r = fmt-maybe-const<R, charT>; // exposition only
range_formatter<remove_cvref_t<ranges::range_reference_t<maybe-const-r >>,
charT> underlying_; // exposition only
public:
constexpr void set_separator(basic_string_view<charT> sep) noexcept;
constexpr void set_brackets(basic_string_view<charT> opening,
basic_string_view<charT> closing) noexcept;
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
template<class FormatContext>
constexpr typename FormatContext::iterator
format(maybe-const-r & elems, FormatContext& ctx) const;
};
}
§ 28.5.7.3 © ISO/IEC
1685

===== PAGE 1697 =====

Dxxxx
constexpr void set_separator(basic_string_view<charT> sep) noexcept;
1 Effects: Equivalent to:underlying_.set_separator(sep);
constexpr void set_brackets(basic_string_view<charT> opening,
basic_string_view<charT> closing) noexcept;
2 Effects: Equivalent to:underlying_.set_brackets(opening, closing);
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
3 Effects: Equivalent to:return underlying_.parse(ctx);
template<class FormatContext>
typename FormatContext::iterator
format(maybe-const-r & elems, FormatContext& ctx) const;
4 Effects: Equivalent to:return underlying_.format(elems, ctx);
28.5.7.4 Specialization of range-default-formatter for maps [format.range.fmtmap]
namespace std {
template<ranges::input_range R, class charT>
struct range-default-formatter <range_format::map, R, charT> {
private:
using maybe-const-map = fmt-maybe-const<R, charT>; // exposition only
using element-type = // exposition only
remove_cvref_t<ranges::range_reference_t<maybe-const-map >>;
range_formatter<element-type, charT> underlying_; // exposition only
public:
constexpr range-default-formatter ();
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
template<class FormatContext>
constexpr typename FormatContext::iterator
format(maybe-const-map & r, FormatContext& ctx) const;
};
}
constexpr range-default-formatter ();
1 Mandates: Either:
—(1.1) element-type is a specialization ofpair, or
—(1.2) element-type is a specialization oftuple and tuple_size_v<element-type > == 2.
2 Effects: Equivalent to:
underlying_.set_brackets(STATICALLY-WIDEN <charT>("{"), STATICALLY-WIDEN <charT>("}"));
underlying_.underlying().set_brackets({}, {});
underlying_.underlying().set_separator(STATICALLY-WIDEN <charT>(": "));
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
3 Effects: Equivalent to:return underlying_.parse(ctx);
template<class FormatContext>
typename FormatContext::iterator
format(maybe-const-map & r, FormatContext& ctx) const;
4 Effects: Equivalent to:return underlying_.format(r, ctx);
§ 28.5.7.4 © ISO/IEC
1686

===== PAGE 1698 =====

Dxxxx
28.5.7.5 Specialization of range-default-formatter for sets [format.range.fmtset]
namespace std {
template<ranges::input_range R, class charT>
struct range-default-formatter <range_format::set, R, charT> {
private:
using maybe-const-set = fmt-maybe-const<R, charT>; // exposition only
range_formatter<remove_cvref_t<ranges::range_reference_t<maybe-const-set >>,
charT> underlying_; // exposition only
public:
constexpr range-default-formatter ();
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
template<class FormatContext>
constexpr typename FormatContext::iterator
format(maybe-const-set & r, FormatContext& ctx) const;
};
}
constexpr range-default-formatter ();
1 Effects: Equivalent to:
underlying_.set_brackets(STATICALLY-WIDEN <charT>("{"), STATICALLY-WIDEN <charT>("}"));
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
2 Effects: Equivalent to:return underlying_.parse(ctx);
template<class FormatContext>
typename FormatContext::iterator
format(maybe-const-set & r, FormatContext& ctx) const;
3 Effects: Equivalent to:return underlying_.format(r, ctx);
28.5.7.6 Specialization of range-default-formatter for strings [format.range.fmtstr]
namespace std {
template<range_format K, ranges::input_range R, class charT>
requires (K == range_format::string || K == range_format::debug_string)
struct range-default-formatter <K, R, charT> {
private:
formatter<basic_string<charT>, charT> underlying_; // exposition only
public:
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
template<class FormatContext>
constexpr typename FormatContext::iterator
format(see below & str, FormatContext& ctx) const;
};
}
1 Mandates: same_as<remove_cvref_t<range_reference_t<R>>, charT> is true.
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
2 Effects: Equivalent to:
auto i = underlying_.parse(ctx);
§ 28.5.7.6 © ISO/IEC
1687

===== PAGE 1699 =====

Dxxxx
if constexpr (K == range_format::debug_string) {
underlying_.set_debug_format();
}
return i;
template<class FormatContext>
typename FormatContext::iterator
format(see below & r, FormatContext& ctx) const;
3 The type ofr is const R& if ranges::input_range<const R> is true and R& otherwise.
4 Effects: Let s be a basic_string<charT> such thatranges::equal(s, r) is true. Equivalent to:
return underlying_.format(s, ctx);
28.5.8 Arguments [format.arguments]
28.5.8.1 Class template basic_format_arg [format.arg]
namespace std {
template<class Context>
class basic_format_arg {
public:
class handle;
private:
using char_type = Context::char_type; // exposition only
variant<monostate, bool, char_type,
int, unsigned int, long long int, unsigned long long int,
float, double, long double,
const char_type*, basic_string_view<char_type>,
const void*, handle> value; // exposition only
template<class T> constexpr explicit basic_format_arg(T& v) noexcept; // exposition only
public:
constexpr basic_format_arg() noexcept;
constexpr explicit operator bool() const noexcept;
template<class Visitor>
constexpr decltype(auto) visit(this basic_format_arg arg, Visitor&& vis);
template<class R, class Visitor>
constexpr R visit(this basic_format_arg arg, Visitor&& vis);
};
}
1 An instance ofbasic_format_arg provides access to a formatting argument for user-defined formatters.
2 The behavior of a program that adds specializations ofbasic_format_arg is undefined.
basic_format_arg() noexcept;
3 Postconditions: !(*this).
template<class T> explicit basic_format_arg(T& v) noexcept;
4 Constraints: T satisfies formattable-with <Context>.
5 Preconditions: If decay_t<T> is char_type* or const char_type*, static_cast<const char_
type*>(v) points to an NTCTS (3.36).
6 Effects: Let TD be remove_const_t<T>.
—(6.1) If TD is bool or char_type, initializesvalue with v;
—(6.2) otherwise, ifTD is char and char_type is wchar_t, initializesvalue with static_cast<wchar_-
t>(static_cast<unsigned char>(v));
—(6.3) otherwise, if TD is a signed integer type (6.9.2) andsizeof(TD) <= sizeof(int), initializes
value with static_cast<int>(v);
§ 28.5.8.1 © ISO/IEC
1688

===== PAGE 1700 =====

Dxxxx
—(6.4) otherwise, if TD is an unsigned integer type andsizeof(TD) <= sizeof(unsigned int), initial-
izes value with static_cast<unsigned int>(v);
—(6.5) otherwise, if TD is a signed integer type andsizeof(TD) <= sizeof(long long int), initializes
value with static_cast<long long int>(v);
—(6.6) otherwise, if TD is an unsigned integer type andsizeof(TD) <= sizeof(unsigned long long
int), initializesvalue with static_cast<unsigned long long int>(v);
—(6.7) otherwise, ifTD is a standard floating-point type, initializesvalue with v;
—(6.8) otherwise, ifTD is a specialization ofbasic_string_view or basic_string and TD::value_type
is char_type, initializesvalue with basic_string_view<char_type>(v.data(), v.size());
—(6.9) otherwise, if decay_t<TD> is char_type* or const char_type*, initializesvalue with static_-
cast<const char_type*>(v);
—(6.10) otherwise, if is_void_v<remove_pointer_t<TD>> is true or is_null_pointer_v<TD> is true,
initializes value with static_cast<const void*>(v);
—(6.11) otherwise, initializesvalue with handle(v).
[Note 1: Constructing basic_format_arg from a pointer to a member is ill-formed unless the user provides an
enabled specialization offormatter for that pointer to member type.—end note]
explicit operator bool() const noexcept;
7 Returns: !holds_alternative<monostate>(value).
template<class Visitor>
decltype(auto) visit(this basic_format_arg arg, Visitor&& vis);
8 Effects: Equivalent to:return arg.value.visit(std::forward<Visitor>(vis));
template<class R, class Visitor>
R visit(this basic_format_arg arg, Visitor&& vis);
9 Effects: Equivalent to:return arg.value.visit<R>(std::forward<Visitor>(vis));
10 The classhandle allows formatting an object of a user-defined type.
namespace std {
template<class Context>
class basic_format_arg<Context>::handle {
const void* ptr_; // exposition only
void (*format_)(basic_format_parse_context<char_type>&,
Context&, const void*); // exposition only
template<class T> constexpr explicit handle(T& val) noexcept; // exposition only
public:
constexpr void format(basic_format_parse_context<char_type>&, Context& ctx) const;
};
}
template<class T> explicit handle(T& val) noexcept;
11 Let
—(11.1) TD be remove_const_t<T>,
—(11.2) TQ be const TD if const TD satisfies formattable-with <Context> and TD otherwise.
12 Mandates: TQ satisfies formattable-with <Context>.
13 Effects: Initializes ptr_ with addressof(val) and format_ with
[](basic_format_parse_context<char_type>& parse_ctx,
Context& format_ctx, const void* ptr) {
typename Context::template formatter_type<TD> f;
parse_ctx.advance_to(f.parse(parse_ctx));
format_ctx.advance_to(f.format(*const_cast<TQ*>(static_cast<const TD*>(ptr)),
format_ctx));
}
§ 28.5.8.1 © ISO/IEC
1689

===== PAGE 1701 =====

Dxxxx
void format(basic_format_parse_context<char_type>& parse_ctx, Context& format_ctx) const;
14 Effects: Equivalent to:format_(parse_ctx, format_ctx, ptr_);
28.5.8.2 Class template format-arg-store [format.arg.store]
namespace std {
template<class Context, class... Args>
class format-arg-store { // exposition only
array<basic_format_arg<Context>, sizeof...(Args)> args; // exposition only
};
}
1 An instance offormat-arg-store stores formatting arguments.
template<class Context = format_context, class... Args>
format-arg-store <Context, Args...> make_format_args(Args&... fmt_args);
2 Preconditions: The type typename Context::template formatter_type<remove_const_t<Ti>>
meets theBasicFormatter requirements (28.5.6.1) for eachTi in Args.
3 Returns: An object of type format-arg-store <Context, Args...> whose args data member is
initialized with{basic_format_arg<Context>(fmt_args)...}.
template<class... Args>
format-arg-store <wformat_context, Args...> make_wformat_args(Args&... args);
4 Effects: Equivalent to:return make_format_args<wformat_context>(args...);
28.5.8.3 Class template basic_format_args [format.args]
namespace std {
template<class Context>
class basic_format_args {
size_t size_; // exposition only
const basic_format_arg<Context>* data_; // exposition only
public:
template<class... Args>
constexpr basic_format_args(const format-arg-store <Context, Args...>& store) noexcept;
constexpr basic_format_arg<Context> get(size_t i) const noexcept;
};
template<class Context, class... Args>
basic_format_args(format-arg-store <Context, Args...>) -> basic_format_args<Context>;
}
1 An instance ofbasic_format_args provides access to formatting arguments.
2 Recommended practice: Implementations should optimize the representation ofbasic_format_args for a
small number of formatting arguments.
[Note 1: For example, by storing indices of type alternatives separately from values and packing the former.—end
note]
template<class... Args>
basic_format_args(const format-arg-store <Context, Args...>& store) noexcept;
3 Effects: Initializes size_ with sizeof...(Args) and data_ with store.args.data().
basic_format_arg<Context> get(size_t i) const noexcept;
4 Returns: i < size_ ? data_[i] : basic_format_arg<Context>().
28.5.9 Tuple formatter [format.tuple]
1 For each ofpair and tuple, the library provides the following formatter specialization wherepair-or-tuple
is the name of the template:
§ 28.5.9 © ISO/IEC
1690

===== PAGE 1702 =====

Dxxxx
namespace std {
template<class charT, formattable<charT>... Ts>
struct formatter<pair-or-tuple <Ts...>, charT> {
private:
tuple<formatter<remove_cvref_t<Ts>, charT>...> underlying_; // exposition only
basic_string_view<charT> separator_ = STATICALLY-WIDEN <charT>(", "); // exposition only
basic_string_view<charT> opening-bracket_ = STATICALLY-WIDEN <charT>("("); // exposition only
basic_string_view<charT> closing-bracket_ = STATICALLY-WIDEN <charT>(")"); // exposition only
public:
constexpr void set_separator(basic_string_view<charT> sep) noexcept;
constexpr void set_brackets(basic_string_view<charT> opening,
basic_string_view<charT> closing) noexcept;
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
template<class FormatContext>
constexpr typename FormatContext::iterator
format(see below & elems, FormatContext& ctx) const;
};
template<class... Ts>
constexpr bool enable_nonlocking_formatter_optimization<pair-or-tuple <Ts...>> =
(enable_nonlocking_formatter_optimization<remove_cvref_t<Ts>> && ...);
}
2 The parse member functions of these formatters interpret the format specification as atuple-format-spec
according to the following syntax:
tuple-format-spec:
tuple-fill-and-alignopt widthopt tuple-typeopt
tuple-fill-and-align:
tuple-fillopt align
tuple-fill:
any character other than{ or } or :
tuple-type:
m
n
3 The tuple-fill-and-align is interpreted the same way as afill-and-align (28.5.2.2). The productionsalign and
width are described in 28.5.2.
4 The tuple-type specifier changes the way apair or tuple is formatted, with certain options only valid with
certain argument types. The meaning of the various type options is as specified in Table 116.
Table 116 — Meaning oftuple-type options [tab:formatter.tuple.type]
Option Requirements Meaning
m sizeof...(Ts) == 2 Equivalent to:
set_separator(STATICALLY-WIDEN <charT>(": "));
set_brackets({}, {});
n none Equivalent to: set_brackets({}, {});
none none No effects
constexpr void set_separator(basic_string_view<charT> sep) noexcept;
5 Effects: Equivalent to:separator_ = sep;
§ 28.5.9 © ISO/IEC
1691

===== PAGE 1703 =====

Dxxxx
constexpr void set_brackets(basic_string_view<charT> opening,
basic_string_view<charT> closing) noexcept;
6 Effects: Equivalent to:
opening-bracket_ = opening;
closing-bracket_ = closing;
template<class ParseContext>
constexpr typename ParseContext::iterator
parse(ParseContext& ctx);
7 Effects: Parses the format specifiers as atuple-format-spec and stores the parsed specifiers in*this. The
values ofopening-bracket_, closing-bracket_, andseparator_ are modified if and only if required
by thetuple-type, if present. For each elemente in underlying_, calls e.parse(ctx) to parse an
empty format-spec and, if e.set_debug_format() is a valid expression, callse.set_debug_format().
8 Returns: An iterator past the end of thetuple-format-spec.
template<class FormatContext>
typename FormatContext::iterator
format(see below & elems, FormatContext& ctx) const;
9 The type ofelems is:
—(9.1) If (formattable<const Ts, charT> && ...) is true, const pair-or-tuple <Ts...>&.
—(9.2) Otherwise pair-or-tuple <Ts...>&.
10 Effects: Writes the following intoctx.out(), adjusted according to thetuple-format-spec:
—(10.1) opening-bracket_,
—(10.2) for each indexI in the[0,sizeof...(Ts)):
—(10.2.1) if I != 0, separator_,
—(10.2.2) the result of writingget<I>(elems) via get<I>(underlying_), and
—(10.3) closing-bracket_.
11 Returns: An iterator past the end of the output range.
28.5.10 Class format_error [format.error]
namespace std {
class format_error : public runtime_error {
public:
constexpr explicit format_error(const string& what_arg);
constexpr explicit format_error(const char* what_arg);
};
}
1 The classformat_error defines the type of objects thrown as exceptions to report errors from the formatting
library.
constexpr format_error(const string& what_arg);
2 Postconditions: strcmp(what(), what_arg.c_str()) == 0.
constexpr format_error(const char* what_arg);
3 Postconditions: strcmp(what(), what_arg) == 0.
28.6 Regular expressions library [re]
28.6.1 General [re.general]
1 Subclause 28.6 describes components that C++ programs may use to perform operations involving regular
expression matching and searching.
2 The following subclauses describe a basic regular expression class template and its traits that can handle
char-like (27.1) template arguments, two specializations of this class template that handle sequences ofchar
and wchar_t, a class template that holds the result of a regular expression match, a series of algorithms
§ 28.6.1 © ISO/IEC
1692

===== PAGE 1704 =====

Dxxxx
that allow a character sequence to be operated upon by a regular expression, and two iterator types for
enumerating regular expression matches, as summarized in Table 117.
Table 117 — Regular expressions library summary [tab:re.summary]
Subclause Header
28.6.2 Requirements
28.6.4 Constants <regex>
28.6.5 Exception type
28.6.6 Traits
28.6.7 Regular expression template
28.6.8 Submatches
28.6.9 Match results
28.6.10 Algorithms
28.6.11 Iterators
28.6.12 Grammar
3 The ECMAScript Language Specification described in Standard Ecma-262 is calledECMA-262 in this Clause.
28.6.2 Requirements [re.req]
1 This subclause defines requirements on classes representing regular expression traits.
[Note 1: The class templateregex_traits, defined in 28.6.6, meets these requirements.—end note]
2 The class templatebasic_regex, defined in 28.6.7, needs a set of related types and functions to complete
the definition of its semantics. These types and functions are provided as a set of membertypedef-names and
functions in the template parametertraits used by thebasic_regex class template. This subclause defines
the semantics of these members.
3 To specialize class templatebasic_regex for a character containerCharT and its related regular expression
traits classTraits, usebasic_regex<CharT, Traits>.
4 In the following requirements,
—(4.1) X denotes a traits class defining types and functions for the character container typecharT;
—(4.2) u is an object of typeX;
—(4.3) v is an object of typeconst X;
—(4.4) p is a value of typeconst charT*;
—(4.5) I1 and I2 are input iterators (24.3.5.3);
—(4.6) F1 and F2 are forward iterators (24.3.5.5);
—(4.7) c is a value of typeconst charT;
—(4.8) s is an object of typeX::string_type;
—(4.9) cs is an object of typeconst X::string_type;
—(4.10) b is a value of typebool;
—(4.11) I is a value of typeint;
—(4.12) cl is an object of typeX::char_class_type; and
—(4.13) loc is an object of typeX::locale_type.
5 A traits classX meets the regular expression traits requirements if the following types and expressions are
well-formed and have the specified semantics.
typename X::char_type
6 Result: charT, the character container type used in the implementation of class templatebasic_regex.
typename X::string_type
7 Result: basic_string<charT>
§ 28.6.2 © ISO/IEC
1693

===== PAGE 1705 =====

Dxxxx
typename X::locale_type
8 Result: A copy constructible type that represents the locale used by the traits class.
typename X::char_class_type
9 Result: A bitmask type (16.3.3.3.3) representing a particular character classification.
X::length(p)
10 Result: size_t
11 Returns: The smallesti such thatp[i] == 0.
12 Complexity: Linear ini.
v.translate(c)
13 Result: X::char_type
14 Returns: A character such that for any characterd that is to be considered equivalent toc then
v.translate(c) == v.translate(d).
v.translate_nocase(c)
15 Result: X::char_type
16 Returns: For all charactersC that are to be considered equivalent toc when comparisons are to be
performed without regard to case, thenv.translate_nocase(c) == v.translate_nocase(C).
v.transform(F1, F2)
17 Result: X::string_type
18 Returns: A sort key for the character sequence designated by the iterator range[F1,F2) such that if
the character sequence[G1,G2) sorts before the character sequence[H1,H2) then v.transform(G1, G2)
< v.transform(H1, H2).
v.transform_primary(F1, F2)
19 Result: X::string_type
20 Returns: A sort key for the character sequence designated by the iterator range[F1,F2) such that if
the character sequence[G1,G2) sorts before the character sequence[H1,H2) when character case is not
considered thenv.transform_primary(G1, G2) < v.transform_primary(H1, H2).
v.lookup_collatename(F1, F2)
21 Result: X::string_type
22 Returns: A sequence of characters that represents the collating element consisting of the character
sequence designated by the iterator range[F1,F2). Returns an empty string if the character sequence is
not a valid collating element.
v.lookup_classname(F1, F2, b)
23 Result: X::char_class_type
24 Returns: Converts the character sequence designated by the iterator range[F1,F2) into a value of a
bitmask type that can subsequently be passed toisctype. Values returned fromlookup_classname
can be bitwiseor’ed together; the resulting value represents membership in either of the corresponding
character classes. Ifb is true, the returned bitmask is suitable for matching characters without regard
to their case. Returns0 if the character sequence is not the name of a character class recognized byX.
The value returned shall be independent of the case of the characters in the sequence.
v.isctype(c, cl)
25 Result: bool
26 Returns: Returns true if characterc is a member of one of the character classes designated bycl,
false otherwise.
v.value(c, I)
27 Result: int
§ 28.6.2 © ISO/IEC
1694

===== PAGE 1706 =====

Dxxxx
28 Returns: Returns the value represented by the digitc in baseI if the characterc is a valid digit in
base I; otherwise returns-1.
[Note 2: The value ofI will only be 8, 10, or 16.—end note]
u.imbue(loc)
29 Result: X::locale_type
30 Effects: Imbuesu with the localeloc and returns the previous locale used byu if any.
v.getloc()
31 Result: X::locale_type
32 Returns: Returns the current locale used byv, if any.
33 [Note 3: Class templateregex_traits meets the requirements for a regular expression traits class when it is specialized
for char or wchar_t. This class template is described in the header<regex>, and is described in 28.6.6.—end note]
28.6.3 Header <regex> synopsis [re.syn]
#include <compare> // see 17.12.1
#include <initializer_list> // see 17.11.2
namespace std {
// 28.6.4, regex constants
namespace regex_constants {
using syntax_option_type = T1;
using match_flag_type = T2;
using error_type = T3;
}
// 28.6.5, classregex_error
class regex_error;
// 28.6.6, class templateregex_traits
template<class charT> struct regex_traits;
// 28.6.7, class templatebasic_regex
template<class charT, class traits = regex_traits<charT>> class basic_regex;
using regex = basic_regex<char>;
using wregex = basic_regex<wchar_t>;
// 28.6.7.6,basic_regex swap
template<class charT, class traits>
void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2);
// 28.6.8, class templatesub_match
template<class BidirectionalIterator>
class sub_match;
using csub_match = sub_match<const char*>;
using wcsub_match = sub_match<const wchar_t*>;
using ssub_match = sub_match<string::const_iterator>;
using wssub_match = sub_match<wstring::const_iterator>;
// 28.6.8.3,sub_match non-member operators
template<class BiIter>
bool operator==(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);
template<class BiIter>
auto operator<=>(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);
template<class BiIter, class ST, class SA>
bool operator==(
const sub_match<BiIter>& lhs,
const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
§ 28.6.3 © ISO/IEC
1695

===== PAGE 1707 =====

Dxxxx
template<class BiIter, class ST, class SA>
auto operator<=>(
const sub_match<BiIter>& lhs,
const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
template<class BiIter>
bool operator==(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type* rhs);
template<class BiIter>
auto operator<=>(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type* rhs);
template<class BiIter>
bool operator==(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type& rhs);
template<class BiIter>
auto operator<=>(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type& rhs);
template<class charT, class ST, class BiIter>
basic_ostream<charT, ST>&
operator<<(basic_ostream<charT, ST>& os, const sub_match<BiIter>& m);
// 28.6.9, class templatematch_results
template<class BidirectionalIterator,
class Allocator = allocator<sub_match<BidirectionalIterator>>>
class match_results;
using cmatch = match_results<const char*>;
using wcmatch = match_results<const wchar_t*>;
using smatch = match_results<string::const_iterator>;
using wsmatch = match_results<wstring::const_iterator>;
// match_results comparisons
template<class BidirectionalIterator, class Allocator>
bool operator==(const match_results<BidirectionalIterator, Allocator>& m1,
const match_results<BidirectionalIterator, Allocator>& m2);
// 28.6.9.8,match_results swap
template<class BidirectionalIterator, class Allocator>
void swap(match_results<BidirectionalIterator, Allocator>& m1,
match_results<BidirectionalIterator, Allocator>& m2);
// 28.6.10.2, function templateregex_match
template<class BidirectionalIterator, class Allocator, class charT, class traits>
bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class BidirectionalIterator, class charT, class traits>
bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class charT, class Allocator, class traits>
bool regex_match(const charT* str, match_results<const charT*, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class ST, class SA, class Allocator, class charT, class traits>
bool regex_match(const basic_string<charT, ST, SA>& s,
match_results<typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
§ 28.6.3 © ISO/IEC
1696

===== PAGE 1708 =====

Dxxxx
template<class ST, class SA, class Allocator, class charT, class traits>
bool regex_match(const basic_string<charT, ST, SA>&&,
match_results<typename basic_string<charT, ST, SA>::const_iterator,
Allocator>&,
const basic_regex<charT, traits>&,
regex_constants::match_flag_type = regex_constants::match_default) = delete;
template<class charT, class traits>
bool regex_match(const charT* str,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class ST, class SA, class charT, class traits>
bool regex_match(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
// 28.6.10.3, function templateregex_search
template<class BidirectionalIterator, class Allocator, class charT, class traits>
bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class BidirectionalIterator, class charT, class traits>
bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class charT, class Allocator, class traits>
bool regex_search(const charT* str,
match_results<const charT*, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class charT, class traits>
bool regex_search(const charT* str,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class ST, class SA, class charT, class traits>
bool regex_search(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class ST, class SA, class Allocator, class charT, class traits>
bool regex_search(const basic_string<charT, ST, SA>& s,
match_results<typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class ST, class SA, class Allocator, class charT, class traits>
bool regex_search(const basic_string<charT, ST, SA>&&,
match_results<typename basic_string<charT, ST, SA>::const_iterator,
Allocator>&,
const basic_regex<charT, traits>&,
regex_constants::match_flag_type
= regex_constants::match_default) = delete;
// 28.6.10.4, function templateregex_replace
template<class OutputIterator, class BidirectionalIterator,
class traits, class charT, class ST, class SA>
OutputIterator
regex_replace(OutputIterator out,
BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class OutputIterator, class BidirectionalIterator, class traits, class charT>
OutputIterator
regex_replace(OutputIterator out,
§ 28.6.3 © ISO/IEC
1697

===== PAGE 1709 =====

Dxxxx
BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT, class ST, class SA, class FST, class FSA>
basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
const basic_string<charT, FST, FSA>& fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT, class ST, class SA>
basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT, class ST, class SA>
basic_string<charT>
regex_replace(const charT* s,
const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT>
basic_string<charT>
regex_replace(const charT* s,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
// 28.6.11.1, class templateregex_iterator
template<class BidirectionalIterator,
class charT = typename iterator_traits<BidirectionalIterator>::value_type,
class traits = regex_traits<charT>>
class regex_iterator;
using cregex_iterator = regex_iterator<const char*>;
using wcregex_iterator = regex_iterator<const wchar_t*>;
using sregex_iterator = regex_iterator<string::const_iterator>;
using wsregex_iterator = regex_iterator<wstring::const_iterator>;
// 28.6.11.2, class templateregex_token_iterator
template<class BidirectionalIterator,
class charT = typename iterator_traits<BidirectionalIterator>::value_type,
class traits = regex_traits<charT>>
class regex_token_iterator;
using cregex_token_iterator = regex_token_iterator<const char*>;
using wcregex_token_iterator = regex_token_iterator<const wchar_t*>;
using sregex_token_iterator = regex_token_iterator<string::const_iterator>;
using wsregex_token_iterator = regex_token_iterator<wstring::const_iterator>;
namespace pmr {
template<class BidirectionalIterator>
using match_results =
std::match_results<BidirectionalIterator,
polymorphic_allocator<sub_match<BidirectionalIterator>>>;
using cmatch = match_results<const char*>;
using wcmatch = match_results<const wchar_t*>;
using smatch = match_results<string::const_iterator>;
using wsmatch = match_results<wstring::const_iterator>;
}
}
§ 28.6.3 © ISO/IEC
1698

===== PAGE 1710 =====

Dxxxx
28.6.4 Namespace std::regex_constants [re.const]
28.6.4.1 General [re.const.general]
1 The namespace std::regex_constants holds symbolic constants used by the regular expression library.
This namespace provides three types,syntax_option_type, match_flag_type, anderror_type, along with
several constants of these types.
28.6.4.2 Bitmask type syntax_option_type [re.synopt]
namespace std::regex_constants {
using syntax_option_type = T1;
inline constexpr syntax_option_type icase = unspecified ;
inline constexpr syntax_option_type nosubs = unspecified ;
inline constexpr syntax_option_type optimize = unspecified ;
inline constexpr syntax_option_type collate = unspecified ;
inline constexpr syntax_option_type ECMAScript = unspecified ;
inline constexpr syntax_option_type basic = unspecified ;
inline constexpr syntax_option_type extended = unspecified ;
inline constexpr syntax_option_type awk = unspecified ;
inline constexpr syntax_option_type grep = unspecified ;
inline constexpr syntax_option_type egrep = unspecified ;
inline constexpr syntax_option_type multiline = unspecified ;
}
1 The typesyntax_option_type is an implementation-defined bitmask type (16.3.3.3.3). Setting its elements
has the effects listed in Table 118. A valid value of typesyntax_option_type shall have at most one of the
grammar elementsECMAScript, basic, extended, awk, grep, egrep, set. If no grammar element is set, the
default grammar isECMAScript.
Table 118 —syntax_option_type effects [tab:re.synopt]
Element Effect(s) if set
icase Specifies that matching of regular expressions against a character container
sequence shall be performed without regard to case.
nosubs Specifies that no sub-expressions shall be considered to be marked, so that
when a regular expression is matched against a character container sequence,
no sub-expression matches shall be stored in the suppliedmatch_results
object.
optimize Specifies that the regular expression engine should pay more attention to
the speed with which regular expressions are matched, and less to the speed
with which regular expression objects are constructed. Otherwise it has no
detectable effect on the program output.
collate Specifies that character ranges of the form"[a-b]" shall be locale sensitive.
ECMAScript Specifies that the grammar recognized by the regular expression engine shall
be that used by ECMAScript in ECMA-262, as modified in 28.6.12.
See also: ECMA-262 15.10
basic Specifies that the grammar recognized by the regular expression engine shall
be that used by basic regular expressions in POSIX.
See also: POSIX, Base Definitions and Headers, Section 9.3
extended Specifies that the grammar recognized by the regular expression engine shall
be that used by extended regular expressions in POSIX.
See also: POSIX, Base Definitions and Headers, Section 9.4
awk Specifies that the grammar recognized by the regular expression engine shall
be that used by the utility awk in POSIX.
grep Specifies that the grammar recognized by the regular expression engine shall
be that used by the utility grep in POSIX.
egrep Specifies that the grammar recognized by the regular expression engine shall
be that used by the utility grep when given the -E option in POSIX.
multiline Specifies that^ shall match the beginning of a line and$ shall match the
end of a line, if theECMAScript engine is selected.
§ 28.6.4.2 © ISO/IEC
1699

===== PAGE 1711 =====

Dxxxx
28.6.4.3 Bitmask type match_flag_type [re.matchflag]
namespace std::regex_constants {
using match_flag_type = T2;
inline constexpr match_flag_type match_default = {};
inline constexpr match_flag_type match_not_bol = unspecified ;
inline constexpr match_flag_type match_not_eol = unspecified ;
inline constexpr match_flag_type match_not_bow = unspecified ;
inline constexpr match_flag_type match_not_eow = unspecified ;
inline constexpr match_flag_type match_any = unspecified ;
inline constexpr match_flag_type match_not_null = unspecified ;
inline constexpr match_flag_type match_continuous = unspecified ;
inline constexpr match_flag_type match_prev_avail = unspecified ;
inline constexpr match_flag_type format_default = {};
inline constexpr match_flag_type format_sed = unspecified ;
inline constexpr match_flag_type format_no_copy = unspecified ;
inline constexpr match_flag_type format_first_only = unspecified ;
}
1 The type match_flag_type is an implementation-defined bitmask type (16.3.3.3.3). The constants of
that type, except formatch_default and format_default, are bitmask elements. The match_default
and format_default constants are empty bitmasks. Matching a regular expression against a sequence of
characters [first,last) proceeds according to the rules of the grammar specified for the regular expression
object, modified according to the effects listed in Table 119 for any bitmask elements set.
Table 119 —regex_constants::match_flag_type effects [tab:re.matchflag]
Element Effect(s) if set
match_not_bol The first character in the sequence[first,last) shall be treated as though
it is not at the beginning of a line, so the character^in the regular expression
shall not match[first,first).
match_not_eol The last character in the sequence[first,last) shall be treated as though
it is not at the end of a line, so the character"$" in the regular expression
shall not match[last,last).
match_not_bow The expression"\\b" shall not match the sub-sequence[first,first).
match_not_eow The expression"\\b" shall not match the sub-sequence[last,last).
match_any If more than one match is possible then any match is an acceptable result.
match_not_null The expression shall not match an empty sequence.
match_continuous The expression shall only match a sub-sequence that begins atfirst.
match_prev_avail --first is a valid iterator position. When this flag is set the flagsmatch_-
not_bol and match_not_bow shall be ignored by the regular expression
algorithms (28.6.10) and iterators (28.6.11).
format_default When a regular expression match is to be replaced by a new string, the new
string shall be constructed using the rules used by the ECMAScript replace
function in ECMA-262, part 15.5.4.11 String.prototype.replace. In addition,
during search and replace operations all non-overlapping occurrences of the
regular expression shall be located and replaced, and sections of the input
that did not match the expression shall be copied unchanged to the output
string.
format_sed When a regular expression match is to be replaced by a new string, the new
string shall be constructed using the rules used by the sed utility in POSIX.
format_no_copy During a search and replace operation, sections of the character container
sequence being searched that do not match the regular expression shall not
be copied to the output string.
format_first_only When specified during a search and replace operation, only the first occur-
rence of the regular expression shall be replaced.
28.6.4.4 Implementation-defined error_type [re.err]
namespace std::regex_constants {
using error_type = T3;
§ 28.6.4.4 © ISO/IEC
1700

===== PAGE 1712 =====

Dxxxx
inline constexpr error_type error_collate = unspecified ;
inline constexpr error_type error_ctype = unspecified ;
inline constexpr error_type error_escape = unspecified ;
inline constexpr error_type error_backref = unspecified ;
inline constexpr error_type error_brack = unspecified ;
inline constexpr error_type error_paren = unspecified ;
inline constexpr error_type error_brace = unspecified ;
inline constexpr error_type error_badbrace = unspecified ;
inline constexpr error_type error_range = unspecified ;
inline constexpr error_type error_space = unspecified ;
inline constexpr error_type error_badrepeat = unspecified ;
inline constexpr error_type error_complexity = unspecified ;
inline constexpr error_type error_stack = unspecified ;
}
1 The typeerror_type is an implementation-defined enumerated type (16.3.3.3.2). Values of typeerror_type
represent the error conditions described in Table 120:
Table 120 —error_type values in the C locale [tab:re.err]
Value Error condition
error_collate The expression contains an invalid collating element name.
error_ctype The expression contains an invalid character class name.
error_escape The expression contains an invalid escaped character, or a trailing escape.
error_backref The expression contains an invalid back reference.
error_brack The expression contains mismatched[ and ].
error_paren The expression contains mismatched( and ).
error_brace The expression contains mismatched{ and }.
error_badbrace The expression contains an invalid range in a{} expression.
error_range The expression contains an invalid character range, such as[b-a] in most
encodings.
error_space There is insufficient memory to convert the expression into a finite state
machine.
error_badrepeat One of*?+{ is not preceded by a valid regular expression.
error_complexity The complexity of an attempted match against a regular expression exceeds
a pre-set level.
error_stack There is insufficient memory to determine whether the regular expression
matches the specified character sequence.
28.6.5 Class regex_error [re.badexp]
namespace std {
class regex_error : public runtime_error {
public:
explicit regex_error(regex_constants::error_type ecode);
regex_constants::error_type code() const;
};
}
1 The classregex_error defines the type of objects thrown as exceptions to report errors from the regular
expression library.
regex_error(regex_constants::error_type ecode);
2 Postconditions: ecode == code().
regex_constants::error_type code() const;
3 Returns: The error code that was passed to the constructor.
§ 28.6.5 © ISO/IEC
1701

===== PAGE 1713 =====

Dxxxx
28.6.6 Class template regex_traits [re.traits]
namespace std {
template<class charT>
struct regex_traits {
using char_type = charT;
using string_type = basic_string<char_type>;
using locale_type = locale;
using char_class_type = bitmask_type;
regex_traits();
static size_t length(const char_type* p);
charT translate(charT c) const;
charT translate_nocase(charT c) const;
template<class ForwardIterator>
string_type transform(ForwardIterator first, ForwardIterator last) const;
template<class ForwardIterator>
string_type transform_primary(
ForwardIterator first, ForwardIterator last) const;
template<class ForwardIterator>
string_type lookup_collatename(
ForwardIterator first, ForwardIterator last) const;
template<class ForwardIterator>
char_class_type lookup_classname(
ForwardIterator first, ForwardIterator last, bool icase = false) const;
bool isctype(charT c, char_class_type f) const;
int value(charT ch, int radix) const;
locale_type imbue(locale_type l);
locale_type getloc() const;
};
}
1 The specializationsregex_traits<char> and regex_traits<wchar_t> meet the requirements for a regular
expression traits class (28.6.2).
using char_class_type = bitmask_type ;
2 The typechar_class_type is used to represent a character classification and is capable of holding an
implementation specific set returned bylookup_classname.
static size_t length(const char_type* p);
3 Returns: char_traits<charT>::length(p).
charT translate(charT c) const;
4 Returns: c.
charT translate_nocase(charT c) const;
5 Returns: use_facet<ctype<charT>>(getloc()).tolower(c).
template<class ForwardIterator>
string_type transform(ForwardIterator first, ForwardIterator last) const;
6 Effects: As if by:
string_type str(first, last);
return use_facet<collate<charT>>(
getloc()).transform(str.data(), str.data() + str.length());
template<class ForwardIterator>
string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
7 Effects: If
typeid(use_facet<collate<charT>>(getloc())) == typeid(collate_byname<charT>)
and the form of the sort key returned bycollate_byname<charT>::transform(first, last) is
known and can be converted into a primary sort key then returns that key, otherwise returns an empty
string.
§ 28.6.6 © ISO/IEC
1702

===== PAGE 1714 =====

Dxxxx
template<class ForwardIterator>
string_type lookup_collatename(ForwardIterator first, ForwardIterator last) const;
8 Returns: A sequence of one or more characters that represents the collating element consisting of the
character sequence designated by the iterator range[first,last). Returns an empty string if the
character sequence is not a valid collating element.
template<class ForwardIterator>
char_class_type lookup_classname(
ForwardIterator first, ForwardIterator last, bool icase = false) const;
9 Returns: An unspecified value that represents the character classification named by the character
sequence designated by the iterator range[first,last). If the parameter icase is true then the
returned mask identifies the character classification without regard to the case of the characters being
matched, otherwise it does honor the case of the characters being matched.230 The value returned shall
be independent of the case of the characters in the character sequence. If the name is not recognized
then returnschar_class_type().
10 Remarks: For regex_traits<char>, at least the narrow character names in Table 121 shall be
recognized. For regex_traits<wchar_t>, at least the wide character names in Table 121 shall be
recognized.
bool isctype(charT c, char_class_type f) const;
11 Effects: Determines if the characterc is a member of the character classification represented byf.
12 Returns: Given the following function declaration:
// for exposition only
template<class C>
ctype_base::mask convert(typename regex_traits<C>::char_class_type f);
that returns a value in which eachctype_base::mask value corresponding to a value inf named in
Table 121 is set, then the result is determined as if by:
ctype_base::mask m = convert<charT>(f);
const ctype<charT>& ct = use_facet<ctype<charT>>(getloc());
if (ct.is(m, c)) {
return true;
} else if (c == ct.widen('_')) {
charT w[1] = { ct.widen('w') };
char_class_type x = lookup_classname(w, w+1);
return (f&x) == x;
} else {
return false;
}
[Example 1:
regex_traits<char> t;
string d("d");
string u("upper");
regex_traits<char>::char_class_type f;
f = t.lookup_classname(d.begin(), d.end());
f |= t.lookup_classname(u.begin(), u.end());
ctype_base::mask m = convert<char>(f); // m == ctype_base::digit | ctype_base::upper
—end example]
[Example 2:
regex_traits<char> t;
string w("w");
regex_traits<char>::char_class_type f;
f = t.lookup_classname(w.begin(), w.end());
t.isctype('A', f); // returnstrue
t.isctype('_', f); // returnstrue
t.isctype(' ', f); // returnsfalse
—end example]
230) For example, if the parametericase is true then [[:lower:]] is the same as[[:alpha:]].
§ 28.6.6 © ISO/IEC
1703

===== PAGE 1715 =====

Dxxxx
int value(charT ch, int radix) const;
13 Preconditions: The value ofradix is 8, 10, or 16.
14 Returns: The value represented by the digitch in baseradix if the characterch is a valid digit in base
radix; otherwise returns-1.
locale_type imbue(locale_type loc);
15 Effects: Imbues*this with a copy of the localeloc.
[Note 1: Calling imbue with a different locale than the one currently in use invalidates all cached data held by
*this. —end note]
16 Postconditions: getloc() == loc.
17 Returns: If no locale has been previously imbued then a copy of the global locale in effect at the time
of construction of*this, otherwise a copy of the last argument passed toimbue.
locale_type getloc() const;
18 Returns: If no locale has been imbued then a copy of the global locale in effect at the time of construction
of *this, otherwise a copy of the last argument passed toimbue.
Table 121 — Character class names and correspondingctype masks [tab:re.traits.classnames]
Narrow character name Wide character name Corresponding ctype_base::mask value
"alnum" L"alnum" ctype_base::alnum
"alpha" L"alpha" ctype_base::alpha
"blank" L"blank" ctype_base::blank
"cntrl" L"cntrl" ctype_base::cntrl
"digit" L"digit" ctype_base::digit
"d" L"d" ctype_base::digit
"graph" L"graph" ctype_base::graph
"lower" L"lower" ctype_base::lower
"print" L"print" ctype_base::print
"punct" L"punct" ctype_base::punct
"space" L"space" ctype_base::space
"s" L"s" ctype_base::space
"upper" L"upper" ctype_base::upper
"w" L"w" ctype_base::alnum
"xdigit" L"xdigit" ctype_base::xdigit
28.6.7 Class template basic_regex [re.regex]
28.6.7.1 General [re.regex.general]
1 For a char-like typecharT, specializations of class templatebasic_regex represent regular expressions
constructed from character sequences ofcharT characters. In the rest of 28.6.7,charT denotes a given
char-like type. Storage for a regular expression is allocated and freed as necessary by the member functions
of classbasic_regex.
2 Objects of type specialization ofbasic_regex are responsible for converting the sequence ofcharT objects
to an internal representation. It is not specified what form this representation takes, nor how it is accessed
by algorithms that operate on regular expressions.
[Note 1: Implementations will typically declare some function templates as friends ofbasic_regex to achieve this.
—end note]
3 The functions described in 28.6.7 report errors by throwing exceptions of typeregex_error.
namespace std {
template<class charT, class traits = regex_traits<charT>>
class basic_regex {
public:
// types
using value_type = charT;
§ 28.6.7.1 © ISO/IEC
1704

===== PAGE 1716 =====

Dxxxx
using traits_type = traits;
using string_type = traits::string_type;
using flag_type = regex_constants::syntax_option_type;
using locale_type = traits::locale_type;
// 28.6.4.2, constants
static constexpr flag_type icase = regex_constants::icase;
static constexpr flag_type nosubs = regex_constants::nosubs;
static constexpr flag_type optimize = regex_constants::optimize;
static constexpr flag_type collate = regex_constants::collate;
static constexpr flag_type ECMAScript = regex_constants::ECMAScript;
static constexpr flag_type basic = regex_constants::basic;
static constexpr flag_type extended = regex_constants::extended;
static constexpr flag_type awk = regex_constants::awk;
static constexpr flag_type grep = regex_constants::grep;
static constexpr flag_type egrep = regex_constants::egrep;
static constexpr flag_type multiline = regex_constants::multiline;
// 28.6.7.2, construct/copy/destroy
basic_regex();
explicit basic_regex(const charT* p, flag_type f = regex_constants::ECMAScript);
basic_regex(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
basic_regex(const basic_regex&);
basic_regex(basic_regex&&) noexcept;
template<class ST, class SA>
explicit basic_regex(const basic_string<charT, ST, SA>& s,
flag_type f = regex_constants::ECMAScript);
template<class ForwardIterator>
basic_regex(ForwardIterator first, ForwardIterator last,
flag_type f = regex_constants::ECMAScript);
basic_regex(initializer_list<charT> il, flag_type f = regex_constants::ECMAScript);
~basic_regex();
// 28.6.7.3, assign
basic_regex& operator=(const basic_regex& e);
basic_regex& operator=(basic_regex&& e) noexcept;
basic_regex& operator=(const charT* p);
basic_regex& operator=(initializer_list<charT> il);
template<class ST, class SA>
basic_regex& operator=(const basic_string<charT, ST, SA>& s);
basic_regex& assign(const basic_regex& e);
basic_regex& assign(basic_regex&& e) noexcept;
basic_regex& assign(const charT* p, flag_type f = regex_constants::ECMAScript);
basic_regex& assign(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
template<class ST, class SA>
basic_regex& assign(const basic_string<charT, ST, SA>& s,
flag_type f = regex_constants::ECMAScript);
template<class InputIterator>
basic_regex& assign(InputIterator first, InputIterator last,
flag_type f = regex_constants::ECMAScript);
basic_regex& assign(initializer_list<charT>,
flag_type f = regex_constants::ECMAScript);
// 28.6.7.4, const operations
unsigned mark_count() const;
flag_type flags() const;
// 28.6.7.5, locale
locale_type imbue(locale_type loc);
locale_type getloc() const;
§ 28.6.7.1 © ISO/IEC
1705

===== PAGE 1717 =====

Dxxxx
// 28.6.7.6, swap
void swap(basic_regex&);
};
template<class ForwardIterator>
basic_regex(ForwardIterator, ForwardIterator,
regex_constants::syntax_option_type = regex_constants::ECMAScript)
-> basic_regex<typename iterator_traits<ForwardIterator>::value_type>;
}
28.6.7.2 Constructors [re.regex.construct]
basic_regex();
1 Postconditions: *this does not match any character sequence.
explicit basic_regex(const charT* p, flag_type f = regex_constants::ECMAScript);
2 Preconditions: [p,p + char_traits<charT>::length(p)) is a valid range.
3 Effects: The object’s internal finite state machine is constructed from the regular expression contained
in the sequence of characters[p,p + char_traits<charT>::length(p)), and interpreted according to
the flagsf.
4 Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.
5 Throws: regex_error if [p,p + char_traits<charT>::length(p)) is not a valid regular expression.
basic_regex(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
6 Preconditions: [p,p + len) is a valid range.
7 Effects: The object’s internal finite state machine is constructed from the regular expression contained
in the sequence of characters[p,p + len), and interpreted according the flags specified inf.
8 Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.
9 Throws: regex_error if [p,p + len) is not a valid regular expression.
basic_regex(const basic_regex& e);
10 Postconditions: flags() and mark_count() return e.flags() and e.mark_count(), respectively.
basic_regex(basic_regex&& e) noexcept;
11 Postconditions: flags() and mark_count() return the values thate.flags() and e.mark_count(),
respectively, had before construction.
template<class ST, class SA>
explicit basic_regex(const basic_string<charT, ST, SA>& s,
flag_type f = regex_constants::ECMAScript);
12 Effects: The object’s internal finite state machine is constructed from the regular expression contained
in the strings, and interpreted according to the flags specified inf.
13 Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.
14 Throws: regex_error if s is not a valid regular expression.
template<class ForwardIterator>
basic_regex(ForwardIterator first, ForwardIterator last,
flag_type f = regex_constants::ECMAScript);
15 Effects: The object’s internal finite state machine is constructed from the regular expression contained
in the sequence of characters[first,last), and interpreted according to the flags specified inf.
16 Postconditions: flags() returns f. mark_count() returns the number of marked sub-expressions
within the expression.
17 Throws: regex_error if the sequence[first,last) is not a valid regular expression.
§ 28.6.7.2 © ISO/IEC
1706

===== PAGE 1718 =====

Dxxxx
basic_regex(initializer_list<charT> il, flag_type f = regex_constants::ECMAScript);
18 Effects: Same asbasic_regex(il.begin(), il.end(), f).
28.6.7.3 Assignment [re.regex.assign]
basic_regex& operator=(const basic_regex& e);
1 Postconditions: flags() and mark_count() return e.flags() and e.mark_count(), respectively.
basic_regex& operator=(basic_regex&& e) noexcept;
2 Postconditions: flags() and mark_count() return the values thate.flags() and e.mark_count(),
respectively, had before assignment.e is in a valid state with unspecified value.
basic_regex& operator=(const charT* p);
3 Effects: Equivalent to:return assign(p);
basic_regex& operator=(initializer_list<charT> il);
4 Effects: Equivalent to:return assign(il.begin(), il.end());
template<class ST, class SA>
basic_regex& operator=(const basic_string<charT, ST, SA>& s);
5 Effects: Equivalent to:return assign(s);
basic_regex& assign(const basic_regex& e);
6 Effects: Equivalent to:return *this = e;
basic_regex& assign(basic_regex&& e) noexcept;
7 Effects: Equivalent to:return *this = std::move(e);
basic_regex& assign(const charT* p, flag_type f = regex_constants::ECMAScript);
8 Effects: Equivalent to:return assign(string_type(p), f);
basic_regex& assign(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
9 Effects: Equivalent to:return assign(string_type(p, len), f);
template<class ST, class SA>
basic_regex& assign(const basic_string<charT, ST, SA>& s,
flag_type f = regex_constants::ECMAScript);
10 Effects: Assigns the regular expression contained in the strings, interpreted according the flags specified
in f. If an exception is thrown,*this is unchanged.
11 Postconditions: If no exception is thrown,flags() returns f and mark_count() returns the number of
marked sub-expressions within the expression.
12 Returns: *this.
13 Throws: regex_error if s is not a valid regular expression.
template<class InputIterator>
basic_regex& assign(InputIterator first, InputIterator last,
flag_type f = regex_constants::ECMAScript);
14 Effects: Equivalent to:return assign(string_type(first, last), f);
basic_regex& assign(initializer_list<charT> il,
flag_type f = regex_constants::ECMAScript);
15 Effects: Equivalent to:return assign(il.begin(), il.end(), f);
28.6.7.4 Constant operations [re.regex.operations]
unsigned mark_count() const;
1 Effects: Returns the number of marked sub-expressions within the regular expression.
§ 28.6.7.4 © ISO/IEC
1707

===== PAGE 1719 =====

Dxxxx
flag_type flags() const;
2 Effects: Returns a copy of the regular expression syntax flags that were passed to the object’s constructor
or to the last call toassign.
28.6.7.5 Locale [re.regex.locale]
locale_type imbue(locale_type loc);
1 Effects: Returns the result oftraits_inst.imbue(loc) where traits_inst is a (default-initialized)
instance of the template type argumenttraits stored within the object. After a call toimbue the
basic_regex object does not match any character sequence.
locale_type getloc() const;
2 Effects: Returns the result oftraits_inst.getloc() where traits_inst is a (default-initialized)
instance of the template parametertraits stored within the object.
28.6.7.6 Swap [re.regex.swap]
void swap(basic_regex& e);
1 Effects: Swaps the contents of the two regular expressions.
2 Postconditions: *this contains the regular expression that was ine, e contains the regular expression
that was in*this.
3 Complexity: Constant time.
28.6.7.7 Non-member functions [re.regex.nonmemb]
template<class charT, class traits>
void swap(basic_regex<charT, traits>& lhs, basic_regex<charT, traits>& rhs);
1 Effects: Calls lhs.swap(rhs).
28.6.8 Class template sub_match [re.submatch]
28.6.8.1 General [re.submatch.general]
1 Class templatesub_match denotes the sequence of characters matched by a particular marked sub-expression.
namespace std {
template<class BidirectionalIterator>
class sub_match : public pair<BidirectionalIterator, BidirectionalIterator> {
public:
using value_type = iterator_traits<BidirectionalIterator>::value_type;
using difference_type = iterator_traits<BidirectionalIterator>::difference_type;
using iterator = BidirectionalIterator;
using string_type = basic_string<value_type>;
bool matched;
constexpr sub_match();
difference_type length() const;
operator string_type() const;
string_type str() const;
int compare(const sub_match& s) const;
int compare(const string_type& s) const;
int compare(const value_type* s) const;
void swap(sub_match& s) noexcept(see below );
};
}
28.6.8.2 Members [re.submatch.members]
constexpr sub_match();
1 Effects: Value-initializes thepair base class subobject and the membermatched.
§ 28.6.8.2 © ISO/IEC
1708

===== PAGE 1720 =====

Dxxxx
difference_type length() const;
2 Returns: matched ? distance(first, second) : 0.
operator string_type() const;
3 Returns: matched ? string_type(first, second) : string_type().
string_type str() const;
4 Returns: matched ? string_type(first, second) : string_type().
int compare(const sub_match& s) const;
5 Returns: str().compare(s.str()).
int compare(const string_type& s) const;
6 Returns: str().compare(s).
int compare(const value_type* s) const;
7 Returns: str().compare(s).
void swap(sub_match& s) noexcept(see below );
8 Preconditions: BidirectionalIterator meets theCpp17Swappable requirements (16.4.4.3).
9 Effects: Equivalent to:
this->pair<BidirectionalIterator, BidirectionalIterator>::swap(s);
std::swap(matched, s.matched);
10 Remarks: The exception specification is equivalent tois_nothrow_swappable_v<BidirectionalIter-
ator>.
28.6.8.3 Non-member operators [re.submatch.op]
1 Let SM-CAT(I) be
compare_three_way_result_t<basic_string<typename iterator_traits<I>::value_type>>
template<class BiIter>
bool operator==(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);
2 Returns: lhs.compare(rhs) == 0.
template<class BiIter>
auto operator<=>(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs);
3 Returns: static_cast<SM-CAT(BiIter)>(lhs.compare(rhs) <=> 0).
template<class BiIter, class ST, class SA>
bool operator==(
const sub_match<BiIter>& lhs,
const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
4 Returns:
lhs.compare(typename sub_match<BiIter>::string_type(rhs.data(), rhs.size())) == 0
template<class BiIter, class ST, class SA>
auto operator<=>(
const sub_match<BiIter>& lhs,
const basic_string<typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
5 Returns:
static_cast<SM-CAT(BiIter)>(lhs.compare(
typename sub_match<BiIter>::string_type(rhs.data(), rhs.size()))
<=> 0
)
§ 28.6.8.3 © ISO/IEC
1709

===== PAGE 1721 =====

Dxxxx
template<class BiIter>
bool operator==(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type* rhs);
6 Returns: lhs.compare(rhs) == 0.
template<class BiIter>
auto operator<=>(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type* rhs);
7 Returns: static_cast<SM-CAT(BiIter)>(lhs.compare(rhs) <=> 0).
template<class BiIter>
bool operator==(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type& rhs);
8 Returns: lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) == 0.
template<class BiIter>
auto operator<=>(const sub_match<BiIter>& lhs,
const typename iterator_traits<BiIter>::value_type& rhs);
9 Returns:
static_cast<SM-CAT(BiIter)>(lhs.compare(
typename sub_match<BiIter>::string_type(1, rhs))
<=> 0
)
template<class charT, class ST, class BiIter>
basic_ostream<charT, ST>&
operator<<(basic_ostream<charT, ST>& os, const sub_match<BiIter>& m);
10 Returns: os << m.str().
28.6.9 Class template match_results [re.results]
28.6.9.1 General [re.results.general]
1 Class templatematch_results denotes a collection of character sequences representing the result of a regular
expression match. Storage for the collection is allocated and freed as necessary by the member functions of
class templatematch_results.
2 The class templatematch_results meets the requirements of an allocator-aware container (23.2.2.5) and of
a sequence container (23.2.2, 23.2.4) except that only copy assignment, move assignment, and operations
defined for const-qualified sequence containers are supported and that the semantics of the comparison
operator functions are different from those required for a container.
3 A default-constructedmatch_results object has no fully established result state. A match result isready
when, as a consequence of a completed regular expression match modifying such an object, its result state
becomes fully established. The effects of calling most member functions from amatch_results object that
is not ready are undefined.
4 The sub_match object stored at index 0 represents sub-expression 0, i.e., the whole match. In this case the
sub_match member matched is alwaystrue. The sub_match object stored at indexn denotes what matched
the marked sub-expressionn within the matched expression. If the sub-expressionn participated in a regular
expression match then thesub_match member matched evaluates totrue, and membersfirst and second
denote the range of characters[first,second) which formed that match. Otherwisematched is false, and
members first and second point to the end of the sequence that was searched.
[Note 1: The sub_match objects representing different sub-expressions that did not participate in a regular expression
match need not be distinct.—end note]
namespace std {
template<class BidirectionalIterator,
class Allocator = allocator<sub_match<BidirectionalIterator>>>
class match_results {
public:
using value_type = sub_match<BidirectionalIterator>;
using const_reference = const value_type&;
using reference = value_type&;
§ 28.6.9.1 © ISO/IEC
1710

===== PAGE 1722 =====

Dxxxx
using const_iterator = implementation-defined ;
using iterator = const_iterator;
using difference_type = iterator_traits<BidirectionalIterator>::difference_type;
using size_type = allocator_traits<Allocator>::size_type;
using allocator_type = Allocator;
using char_type = iterator_traits<BidirectionalIterator>::value_type;
using string_type = basic_string<char_type>;
// 28.6.9.2, construct/copy/destroy
match_results() : match_results(Allocator()) {}
explicit match_results(const Allocator& a);
match_results(const match_results& m);
match_results(const match_results& m, const Allocator& a);
match_results(match_results&& m) noexcept;
match_results(match_results&& m, const Allocator& a);
match_results& operator=(const match_results& m);
match_results& operator=(match_results&& m);
~match_results();
// 28.6.9.3, state
bool ready() const;
// 28.6.9.4, size
size_type size() const;
size_type max_size() const;
bool empty() const;
// 28.6.9.5, element access
difference_type length(size_type sub = 0) const;
difference_type position(size_type sub = 0) const;
string_type str(size_type sub = 0) const;
const_reference operator[](size_type n) const;
const_reference prefix() const;
const_reference suffix() const;
const_iterator begin() const;
const_iterator end() const;
const_iterator cbegin() const;
const_iterator cend() const;
// 28.6.9.6, format
template<class OutputIter>
OutputIter
format(OutputIter out,
const char_type* fmt_first, const char_type* fmt_last,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
template<class OutputIter, class ST, class SA>
OutputIter
format(OutputIter out,
const basic_string<char_type, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
template<class ST, class SA>
basic_string<char_type, ST, SA>
format(const basic_string<char_type, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
string_type
format(const char_type* fmt,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
// 28.6.9.7, allocator
allocator_type get_allocator() const;
// 28.6.9.8, swap
void swap(match_results& that);
§ 28.6.9.1 © ISO/IEC
1711

===== PAGE 1723 =====

Dxxxx
};
}
28.6.9.2 Constructors [re.results.const]
1 Table 122 lists the postconditions ofmatch_results copy/move constructors and copy/move assignment
operators. For move operations, the results of the expressions depending on the parameterm denote the
values they had before the respective function calls.
explicit match_results(const Allocator& a);
2 Effects: The storedAllocator value is constructed froma.
3 Postconditions: ready() returns false. size() returns 0.
match_results(const match_results& m);
match_results(const match_results& m, const Allocator& a);
4 Effects: For the first form, the storedAllocator value is obtained as specified in 23.2.2.2. For the
second form, the storedAllocator value is constructed froma.
5 Postconditions: As specified in Table 122.
match_results(match_results&& m) noexcept;
match_results(match_results&& m, const Allocator& a);
6 Effects: For the first form, the storedAllocator value is move constructed fromm.get_allocator().
For the second form, the storedAllocator value is constructed froma.
7 Postconditions: As specified in Table 122.
8 Throws: The second form throws nothing ifa == m.get_allocator() is true.
match_results& operator=(const match_results& m);
9 Postconditions: As specified in Table 122.
match_results& operator=(match_results&& m);
10 Postconditions: As specified in Table 122.
Table 122 —match_results copy/move operation postconditions [tab:re.results.const]
Element Value
ready() m.ready()
size() m.size()
str(n) m.str(n) for all non-negative integers n <
m.size()
prefix() m.prefix()
suffix() m.suffix()
(*this)[n] m[n] for all non-negative integersn < m.size()
length(n) m.length(n) for all non-negative integers n <
m.size()
position(n) m.position(n) for all non-negative integersn <
m.size()
28.6.9.3 State [re.results.state]
bool ready() const;
1 Returns: true if *this has a fully established result state, otherwisefalse.
28.6.9.4 Size [re.results.size]
size_type size() const;
1 Returns: One plus the number of marked sub-expressions in the regular expression that was matched if
*this represents the result of a successful match. Otherwise returns0.
§ 28.6.9.4 © ISO/IEC
1712

===== PAGE 1724 =====

Dxxxx
[Note 1: The state of amatch_results object can be modified only by passing that object toregex_match or
regex_search. Subclauses 28.6.10.2 and 28.6.10.3 specify the effects of those algorithms on theirmatch_results
arguments. —end note]
size_type max_size() const;
2 Returns: The maximum number ofsub_match elements that can be stored in*this.
bool empty() const;
3 Returns: size() == 0.
28.6.9.5 Element access [re.results.acc]
difference_type length(size_type sub = 0) const;
1 Preconditions: ready() == true.
2 Returns: (*this)[sub].length().
difference_type position(size_type sub = 0) const;
3 Preconditions: ready() == true.
4 Returns: The distance from the start of the target sequence to(*this)[sub].first.
string_type str(size_type sub = 0) const;
5 Preconditions: ready() == true.
6 Returns: string_type((*this)[sub]).
const_reference operator[](size_type n) const;
7 Preconditions: ready() == true.
8 Returns: A reference to thesub_match object representing the character sequence that matched marked
sub-expression n. If n == 0 then returns a reference to asub_match object representing the character
sequence that matched the whole regular expression. Ifn >= size() then returns asub_match object
representing an unmatched sub-expression.
const_reference prefix() const;
9 Preconditions: ready() == true.
10 Returns: A reference to thesub_match object representing the character sequence from the start of the
string being matched/searched to the start of the match found.
const_reference suffix() const;
11 Preconditions: ready() == true.
12 Returns: A reference to thesub_match object representing the character sequence from the end of the
match found to the end of the string being matched/searched.
const_iterator begin() const;
const_iterator cbegin() const;
13 Returns: A starting iterator that enumerates over all the sub-expressions stored in*this.
const_iterator end() const;
const_iterator cend() const;
14 Returns: A terminating iterator that enumerates over all the sub-expressions stored in*this.
28.6.9.6 Formatting [re.results.form]
template<class OutputIter>
OutputIter format(
OutputIter out,
const char_type* fmt_first, const char_type* fmt_last,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
1 Preconditions: ready() == true and OutputIter meets the requirements for aCpp17OutputIterator
(24.3.5.4).
§ 28.6.9.6 © ISO/IEC
1713

===== PAGE 1725 =====

Dxxxx
2 Effects: Copies the character sequence[fmt_first,fmt_last) to OutputIterout. Replaces each format
specifier or escape sequence in the copied range with either the character(s) it represents or the sequence
of characters within*this to which it refers. The bitmasks specified inflags determine which format
specifiers and escape sequences are recognized.
3 Returns: out.
template<class OutputIter, class ST, class SA>
OutputIter format(
OutputIter out,
const basic_string<char_type, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
4 Effects: Equivalent to:
return format(out, fmt.data(), fmt.data() + fmt.size(), flags);
template<class ST, class SA>
basic_string<char_type, ST, SA> format(
const basic_string<char_type, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
5 Preconditions: ready() == true.
6 Effects: Constructs an empty stringresult of typebasic_string<char_type, ST, SA> and calls:
format(back_inserter(result), fmt, flags);
7 Returns: result.
string_type format(
const char_type* fmt,
regex_constants::match_flag_type flags = regex_constants::format_default) const;
8 Preconditions: ready() == true.
9 Effects: Constructs an empty stringresult of typestring_type and calls:
format(back_inserter(result), fmt, fmt + char_traits<char_type>::length(fmt), flags);
10 Returns: result.
28.6.9.7 Allocator [re.results.all]
allocator_type get_allocator() const;
1 Returns: A copy of the Allocator that was passed to the object’s constructor or, if that allocator has
been replaced, a copy of the most recent replacement.
28.6.9.8 Swap [re.results.swap]
void swap(match_results& that);
1 Effects: Swaps the contents of the two sequences.
2 Postconditions: *this contains the sequence of matched sub-expressions that were inthat, that
contains the sequence of matched sub-expressions that were in*this.
3 Complexity: Constant time.
template<class BidirectionalIterator, class Allocator>
void swap(match_results<BidirectionalIterator, Allocator>& m1,
match_results<BidirectionalIterator, Allocator>& m2);
4 Effects: As if bym1.swap(m2).
28.6.9.9 Non-member functions [re.results.nonmember]
template<class BidirectionalIterator, class Allocator>
bool operator==(const match_results<BidirectionalIterator, Allocator>& m1,
const match_results<BidirectionalIterator, Allocator>& m2);
1 Returns: true if neither match result is ready,false if one match result is ready and the other is not.
If both match results are ready, returnstrue only if
§ 28.6.9.9 © ISO/IEC
1714

===== PAGE 1726 =====

Dxxxx
—(1.1) m1.empty() && m2.empty(), or
—(1.2) !m1.empty() && !m2.empty(), and the following conditions are satisfied:
—(1.2.1) m1.prefix() == m2.prefix(),
—(1.2.2) m1.size() == m2.size() && equal(m1.begin(), m1.end(), m2.begin()), and
—(1.2.3) m1.suffix() == m2.suffix().
[Note 1: The algorithmequal is defined in Clause 26.—end note]
28.6.10 Regular expression algorithms [re.alg]
28.6.10.1 Exceptions [re.except]
1 The algorithms described in subclause 28.6.10 may throw an exception of typeregex_error. If such
an exceptione is thrown,e.code() shall return eitherregex_constants::error_complexity or regex_-
constants::error_stack.
28.6.10.2 regex_match [re.alg.match]
template<class BidirectionalIterator, class Allocator, class charT, class traits>
bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
1 Preconditions: BidirectionalIterator models bidirectional_iterator (24.3.4.12).
2 Effects: Determines whether there is a match between the regular expressione, and all of the character
sequence [first,last). The parameterflags is used to control how the expression is matched against
the character sequence. When determining if there is a match, only potential matches that match the
entire character sequence are considered. Returnstrue if such a match exists,false otherwise.
[Example 1:
std::regex re("Get|GetValue");
std::cmatch m;
regex_search("GetValue", m, re); // returnstrue, and m[0] contains "Get"
regex_match ("GetValue", m, re); // returnstrue, and m[0] contains "GetValue"
regex_search("GetValues", m, re); // returnstrue, and m[0] contains "Get"
regex_match ("GetValues", m, re); // returnsfalse
—end example]
3 Postconditions: m.ready() == true in all cases. If the function returnsfalse, then the effect on
parameter m is unspecified except thatm.size() returns 0 and m.empty() returns true. Otherwise
the effects on parameterm are given in Table 123.
Table 123 — Effects ofregex_match algorithm [tab:re.alg.match]
Element Value
m.size() 1 + e.mark_count()
m.empty() false
m.prefix().first first
m.prefix().second first
m.prefix().matched false
m.suffix().first last
m.suffix().second last
m.suffix().matched false
m[0].first first
m[0].second last
m[0].matched true
m[n].first For all integers 0 < n < m.size(), the start of the se-
quence that matched sub-expressionn. Alternatively, if
sub-expression n did not participate in the match, then
last.
§ 28.6.10.2 © ISO/IEC
1715

===== PAGE 1727 =====

Dxxxx
Table 123 — Effects ofregex_match algorithm (continued)
Element Value
m[n].second For all integers 0 < n < m.size(), the end of the se-
quence that matched sub-expressionn. Alternatively, if
sub-expression n did not participate in the match, then
last.
m[n].matched For all integers0 < n < m.size(), true if sub-expression
n participated in the match,false otherwise.
template<class BidirectionalIterator, class charT, class traits>
bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
4 Effects: Behaves “as if” by constructing an instance ofmatch_results<BidirectionalIterator>
what, and then returning the result ofregex_match(first, last, what, e, flags).
template<class charT, class Allocator, class traits>
bool regex_match(const charT* str,
match_results<const charT*, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
5 Returns: regex_match(str, str + char_traits<charT>::length(str), m, e, flags).
template<class ST, class SA, class Allocator, class charT, class traits>
bool regex_match(const basic_string<charT, ST, SA>& s,
match_results<typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
6 Returns: regex_match(s.begin(), s.end(), m, e, flags).
template<class charT, class traits>
bool regex_match(const charT* str,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
7 Returns: regex_match(str, str + char_traits<charT>::length(str), e, flags).
template<class ST, class SA, class charT, class traits>
bool regex_match(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
8 Returns: regex_match(s.begin(), s.end(), e, flags).
28.6.10.3 regex_search [re.alg.search]
template<class BidirectionalIterator, class Allocator, class charT, class traits>
bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
match_results<BidirectionalIterator, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
1 Preconditions: BidirectionalIterator models bidirectional_iterator (24.3.4.12).
2 Effects: Determines whether there is some sub-sequence within[first,last) that matches the regular
expression e. The parameter flags is used to control how the expression is matched against the
character sequence. Returnstrue if such a sequence exists,false otherwise.
3 Postconditions: m.ready() == true in all cases. If the function returnsfalse, then the effect on
parameter m is unspecified except thatm.size() returns 0 and m.empty() returns true. Otherwise
the effects on parameterm are given in Table 124.
§ 28.6.10.3 © ISO/IEC
1716

===== PAGE 1728 =====

Dxxxx
Table 124 — Effects ofregex_search algorithm [tab:re.alg.search]
Element Value
m.size() 1 + e.mark_count()
m.empty() false
m.prefix().first first
m.prefix().second m[0].first
m.prefix().matched m.prefix().first != m.prefix().second
m.suffix().first m[0].second
m.suffix().second last
m.suffix().matched m.suffix().first != m.suffix().second
m[0].first The start of the sequence of characters that matched the
regular expression
m[0].second The end of the sequence of characters that matched the
regular expression
m[0].matched true
m[n].first For all integers 0 < n < m.size(), the start of the se-
quence that matched sub-expressionn. Alternatively, if
sub-expression n did not participate in the match, then
last.
m[n].second For all integers 0 < n < m.size(), the end of the se-
quence that matched sub-expressionn. Alternatively, if
sub-expression n did not participate in the match, then
last.
m[n].matched For all integers0 < n < m.size(), true if sub-expression
n participated in the match,false otherwise.
template<class charT, class Allocator, class traits>
bool regex_search(const charT* str, match_results<const charT*, Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
4 Returns: regex_search(str, str + char_traits<charT>::length(str), m, e, flags).
template<class ST, class SA, class Allocator, class charT, class traits>
bool regex_search(const basic_string<charT, ST, SA>& s,
match_results<typename basic_string<charT, ST, SA>::const_iterator,
Allocator>& m,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
5 Returns: regex_search(s.begin(), s.end(), m, e, flags).
template<class BidirectionalIterator, class charT, class traits>
bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
6 Effects: Behaves “as if” by constructing an object what of type match_results<Bidirectional-
Iterator> and returningregex_search(first, last, what, e, flags).
template<class charT, class traits>
bool regex_search(const charT* str,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
7 Returns: regex_search(str, str + char_traits<charT>::length(str), e, flags).
template<class ST, class SA, class charT, class traits>
bool regex_search(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
regex_constants::match_flag_type flags = regex_constants::match_default);
8 Returns: regex_search(s.begin(), s.end(), e, flags).
§ 28.6.10.3 © ISO/IEC
1717

===== PAGE 1729 =====

Dxxxx
28.6.10.4 regex_replace [re.alg.replace]
template<class OutputIterator, class BidirectionalIterator,
class traits, class charT, class ST, class SA>
OutputIterator
regex_replace(OutputIterator out,
BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class OutputIterator, class BidirectionalIterator, class traits, class charT>
OutputIterator
regex_replace(OutputIterator out,
BidirectionalIterator first, BidirectionalIterator last,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
1 Effects: Constructs aregex_iterator object i as if by
regex_iterator<BidirectionalIterator, charT, traits> i(first, last, e, flags)
and usesito enumerate through all of the matchesmof typematch_results<BidirectionalIterator>
that occur within the sequence[first,last). If no such matches are found and!(flags & regex_-
constants::format_no_copy), then calls
out = copy(first, last, out)
If any matches are found then, for each such match:
—(1.1) If !(flags & regex_constants::format_no_copy), calls
out = copy(m.prefix().first, m.prefix().second, out)
—(1.2) Then calls
out = m.format(out, fmt, flags)
for the first form of the function and
out = m.format(out, fmt, fmt + char_traits<charT>::length(fmt), flags)
for the second.
Finally, if such a match is found and!(flags & regex_constants::format_no_copy), calls
out = copy(last_m.suffix().first, last_m.suffix().second, out)
where last_m is a copy of the last match found. Ifflags & regex_constants::format_first_only
is nonzero, then only the first match found is replaced.
2 Returns: out.
template<class traits, class charT, class ST, class SA, class FST, class FSA>
basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
const basic_string<charT, FST, FSA>& fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT, class ST, class SA>
basic_string<charT, ST, SA>
regex_replace(const basic_string<charT, ST, SA>& s,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
3 Effects: Constructs an empty stringresult of typebasic_string<charT, ST, SA> and calls:
regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags);
4 Returns: result.
§ 28.6.10.4 © ISO/IEC
1718

===== PAGE 1730 =====

Dxxxx
template<class traits, class charT, class ST, class SA>
basic_string<charT>
regex_replace(const charT* s,
const basic_regex<charT, traits>& e,
const basic_string<charT, ST, SA>& fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
template<class traits, class charT>
basic_string<charT>
regex_replace(const charT* s,
const basic_regex<charT, traits>& e,
const charT* fmt,
regex_constants::match_flag_type flags = regex_constants::match_default);
5 Effects: Constructs an empty stringresult of typebasic_string<charT> and calls:
regex_replace(back_inserter(result), s, s + char_traits<charT>::length(s), e, fmt, flags);
6 Returns: result.
28.6.11 Regular expression iterators [re.iter]
28.6.11.1 Class template regex_iterator [re.regiter]
28.6.11.1.1 General [re.regiter.general]
1 The class templateregex_iterator is an iterator adaptor. It represents a new view of an existing iterator
sequence, by enumerating all the occurrences of a regular expression within that sequence. Aregex_-
iterator uses regex_search to find successive regular expression matches within the sequence from which
it was constructed. After the iterator is constructed, and every timeoperator++ is used, the iterator finds
and stores a value ofmatch_results<BidirectionalIterator>. If the end of the sequence is reached
(regex_search returns false), the iterator becomes equal to the end-of-sequence iterator value. The
default constructor constructs an end-of-sequence iterator object, which is the only legitimate iterator to
be used for the end condition. The result ofoperator* on an end-of-sequence iterator is not defined. For
any other iterator value aconst match_results<BidirectionalIterator>& is returned. The result of
operator-> on an end-of-sequence iterator is not defined. For any other iterator value aconst match_-
results<BidirectionalIterator>*is returned. It is impossible to store things intoregex_iterators. Two
end-of-sequence iterators are always equal. An end-of-sequence iterator is not equal to a non-end-of-sequence
iterator. Two non-end-of-sequence iterators are equal when they are constructed from the same arguments.
namespace std {
template<class BidirectionalIterator,
class charT = typename iterator_traits<BidirectionalIterator>::value_type,
class traits = regex_traits<charT>>
class regex_iterator {
public:
using regex_type = basic_regex<charT, traits>;
using iterator_category = forward_iterator_tag;
using iterator_concept = input_iterator_tag;
using value_type = match_results<BidirectionalIterator>;
using difference_type = ptrdiff_t;
using pointer = const value_type*;
using reference = const value_type&;
regex_iterator();
regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
regex_constants::match_flag_type m = regex_constants::match_default);
regex_iterator(BidirectionalIterator, BidirectionalIterator,
const regex_type&&,
regex_constants::match_flag_type = regex_constants::match_default) = delete;
regex_iterator(const regex_iterator&);
regex_iterator& operator=(const regex_iterator&);
bool operator==(const regex_iterator&) const;
bool operator==(default_sentinel_t) const { return *this == regex_iterator(); }
const value_type& operator*() const;
const value_type* operator->() const;
regex_iterator& operator++();
§ 28.6.11.1.1 © ISO/IEC
1719

===== PAGE 1731 =====

Dxxxx
regex_iterator operator++(int);
private:
BidirectionalIterator begin; // exposition only
BidirectionalIterator end; // exposition only
const regex_type* pregex; // exposition only
regex_constants::match_flag_type flags; // exposition only
match_results<BidirectionalIterator> match; // exposition only
};
}
2 An object of typeregex_iterator that is not an end-of-sequence iterator holds azero-length match if
match[0].matched == true and match[0].first == match[0].second.
[Note 1: For example, this can occur when the part of the regular expression that matched consists only of an assertion
(such as’^’, ’$’, ’\b’, ’\B’). —end note]
28.6.11.1.2 Constructors [re.regiter.cnstr]
regex_iterator();
1 Effects: Constructs an end-of-sequence iterator.
regex_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
regex_constants::match_flag_type m = regex_constants::match_default);
2 Effects: Initializes begin and end to a and b, respectively, setspregex to addressof(re), setsflags
to m, then callsregex_search(begin, end, match, *pregex, flags). If this call returnsfalse the
constructor sets*this to the end-of-sequence iterator.
28.6.11.1.3 Comparisons [re.regiter.comp]
bool operator==(const regex_iterator& right) const;
1 Returns: true if *this and right are both end-of-sequence iterators or if the following conditions all
hold:
—(1.1) begin == right.begin,
—(1.2) end == right.end,
—(1.3) pregex == right.pregex,
—(1.4) flags == right.flags, and
—(1.5) match[0] == right.match[0];
otherwise false.
28.6.11.1.4 Indirection [re.regiter.deref]
const value_type& operator*() const;
1 Returns: match.
const value_type* operator->() const;
2 Returns: addressof(match).
28.6.11.1.5 Increment [re.regiter.incr]
regex_iterator& operator++();
1 Effects: Constructs a local variablestart of typeBidirectionalIterator and initializes it with the
value ofmatch[0].second.
2 If the iterator holds a zero-length match andstart == end the operator sets*this to the end-of-
sequence iterator and returns*this.
3 Otherwise, if the iterator holds a zero-length match, the operator calls:
regex_search(start, end, match, *pregex,
flags | regex_constants::match_not_null | regex_constants::match_continuous)
§ 28.6.11.1.5 © ISO/IEC
1720

===== PAGE 1732 =====

Dxxxx
If the call returnstrue the operator returns*this. Otherwise the operator incrementsstart and
continues as if the most recent match was not a zero-length match.
4 If the most recent match was not a zero-length match, the operator setsflags to flags | regex_-
constants::match_prev_availand callsregex_search(start, end, match, *pregex, flags). If
the call returnsfalse the iterator sets*this to the end-of-sequence iterator. The iterator then returns
*this.
5 In all cases in which the call toregex_search returns true, match.prefix().first shall be equal to
the previous value ofmatch[0].second, and for each indexi in the half-open range[0,match.size())
for whichmatch[i].matched is true, match.position(i) shall returndistance(begin, match[i].
first).
6 [Note 1: This means thatmatch.position(i) gives the offset from the beginning of the target sequence, which
is often not the same as the offset from the sequence passed in the call toregex_search. —end note]
7 It is unspecified how the implementation makes these adjustments.
8 [Note 2: This means that an implementation can call an implementation-specific search function, in which case
a program-defined specialization ofregex_search will not be called.—end note]
regex_iterator operator++(int);
9 Effects: As if by:
regex_iterator tmp = *this;
++(*this);
return tmp;
28.6.11.2 Class template regex_token_iterator [re.tokiter]
28.6.11.2.1 General [re.tokiter.general]
1 The class templateregex_token_iterator is an iterator adaptor; that is to say it represents a new view of
an existing iterator sequence, by enumerating all the occurrences of a regular expression within that sequence,
and presenting one or more sub-expressions for each match found. Each position enumerated by the iterator
is asub_match class template instance that represents what matched a particular sub-expression within the
regular expression.
2 When classregex_token_iterator is used to enumerate a single sub-expression with index−1 the iterator
performs field splitting: that is to say it enumerates one sub-expression for each section of the character
container sequence that does not match the regular expression specified.
3 After it is constructed, the iterator finds and stores a valueregex_iterator<BidirectionalIterator>
position and sets the internal countN to zero. It also maintains a sequencesubs which contains a list of
the sub-expressions which will be enumerated. Every timeoperator++ is used the countN is incremented; if
N exceeds or equalssubs.size(), then the iterator increments memberposition and sets countN to zero.
4 If the end of sequence is reached (position is equal to the end of sequence iterator), the iterator becomes
equal to the end-of-sequence iterator value, unless the sub-expression being enumerated has index−1, in
which case the iterator enumerates one last sub-expression that contains all the characters from the end of
the last regular expression match to the end of the input sequence being enumerated, provided that this
would not be an empty sub-expression.
5 The default constructor constructs an end-of-sequence iterator object, which is the only legitimate iterator
to be used for the end condition. The result ofoperator* on an end-of-sequence iterator is not defined.
For any other iterator value aconst sub_match<BidirectionalIterator>& is returned. The result of
operator-> on an end-of-sequence iterator is not defined. For any other iterator value aconst sub_-
match<BidirectionalIterator>* is returned.
6 It is impossible to store things intoregex_token_iterators. Two end-of-sequence iterators are always equal.
An end-of-sequence iterator is not equal to a non-end-of-sequence iterator. Two non-end-of-sequence iterators
are equal when they are constructed from the same arguments.
namespace std {
template<class BidirectionalIterator,
class charT = typename iterator_traits<BidirectionalIterator>::value_type,
class traits = regex_traits<charT>>
class regex_token_iterator {
public:
§ 28.6.11.2.1 © ISO/IEC
1721

===== PAGE 1733 =====

Dxxxx
using regex_type = basic_regex<charT, traits>;
using iterator_category = forward_iterator_tag;
using iterator_concept = input_iterator_tag;
using value_type = sub_match<BidirectionalIterator>;
using difference_type = ptrdiff_t;
using pointer = const value_type*;
using reference = const value_type&;
regex_token_iterator();
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
int submatch = 0,
regex_constants::match_flag_type m =
regex_constants::match_default);
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
const vector<int>& submatches,
regex_constants::match_flag_type m =
regex_constants::match_default);
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
initializer_list<int> submatches,
regex_constants::match_flag_type m =
regex_constants::match_default);
template<size_t N>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
const int (&submatches)[N],
regex_constants::match_flag_type m =
regex_constants::match_default);
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type&& re,
int submatch = 0,
regex_constants::match_flag_type m =
regex_constants::match_default) = delete;
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type&& re,
const vector<int>& submatches,
regex_constants::match_flag_type m =
regex_constants::match_default) = delete;
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type&& re,
initializer_list<int> submatches,
regex_constants::match_flag_type m =
regex_constants::match_default) = delete;
template<size_t N>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type&& re,
const int (&submatches)[N],
regex_constants::match_flag_type m =
regex_constants::match_default) = delete;
regex_token_iterator(const regex_token_iterator&);
regex_token_iterator& operator=(const regex_token_iterator&);
bool operator==(const regex_token_iterator&) const;
bool operator==(default_sentinel_t) const { return *this == regex_token_iterator(); }
const value_type& operator*() const;
const value_type* operator->() const;
regex_token_iterator& operator++();
regex_token_iterator operator++(int);
private:
using position_iterator =
regex_iterator<BidirectionalIterator, charT, traits>; // exposition only
position_iterator position; // exposition only
§ 28.6.11.2.1 © ISO/IEC
1722

===== PAGE 1734 =====

Dxxxx
const value_type* result; // exposition only
value_type suffix; // exposition only
size_t N; // exposition only
vector<int> subs; // exposition only
};
}
7 A suffix iteratoris aregex_token_iterator object that points to a final sequence of characters at the end
of the target sequence. In a suffix iterator the memberresult holds a pointer to the data membersuffix,
the value of the membersuffix.match is true, suffix.first points to the beginning of the final sequence,
and suffix.second points to the end of the final sequence.
8 [Note 1: For a suffix iterator, data membersuffix.first is the same as the end of the last match found, and
suffix.second is the same as the end of the target sequence.—end note]
9 The current matchis (*position).prefix() if subs[N] == -1, or(*position)[subs[N]] for any other
value ofsubs[N].
28.6.11.2.2 Constructors [re.tokiter.cnstr]
regex_token_iterator();
1 Effects: Constructs the end-of-sequence iterator.
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
int submatch = 0,
regex_constants::match_flag_type m = regex_constants::match_default);
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
const vector<int>& submatches,
regex_constants::match_flag_type m = regex_constants::match_default);
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
initializer_list<int> submatches,
regex_constants::match_flag_type m = regex_constants::match_default);
template<size_t N>
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b,
const regex_type& re,
const int (&submatches)[N],
regex_constants::match_flag_type m = regex_constants::match_default);
2 Preconditions: Each of the initialization values ofsubmatches is >= -1.
3 Effects: The first constructor initializes the membersubs to hold the single valuesubmatch. The
second, third, and fourth constructors initialize the membersubs to hold a copy of the sequence of
integer values pointed to by the iterator range[begin(submatches),end(submatches)).
4 Each constructor then setsN to 0, andposition to position_iterator(a, b, re, m). If position
is not an end-of-sequence iterator the constructor setsresult to the address of the current match.
Otherwise if any of the values stored insubs is equal to−1 the constructor sets*this to a suffix
iterator that points to the range[a,b), otherwise the constructor sets*this to an end-of-sequence
iterator.
28.6.11.2.3 Comparisons [re.tokiter.comp]
bool operator==(const regex_token_iterator& right) const;
1 Returns: true if *this and right are both end-of-sequence iterators, or if*this and right are
both suffix iterators andsuffix == right.suffix; otherwise returnsfalse if *this or right is an
end-of-sequence iterator or a suffix iterator. Otherwise returnstrue if position == right.position,
N == right.N, andsubs == right.subs. Otherwise returnsfalse.
§ 28.6.11.2.3 © ISO/IEC
1723

===== PAGE 1735 =====

Dxxxx
28.6.11.2.4 Indirection [re.tokiter.deref]
const value_type& operator*() const;
1 Returns: *result.
const value_type* operator->() const;
2 Returns: result.
28.6.11.2.5 Increment [re.tokiter.incr]
regex_token_iterator& operator++();
1 Effects: Constructs a local variableprev of type position_iterator, initialized with the value of
position.
2 If *this is a suffix iterator, sets*this to an end-of-sequence iterator.
3 Otherwise, ifN + 1 < subs.size(), incrementsN and setsresult to the address of the current match.
4 Otherwise, setsN to 0 and incrementsposition. If position is not an end-of-sequence iterator the
operator setsresult to the address of the current match.
5 Otherwise, if any of the values stored insubs is equal to −1 and prev->suffix().length() is
not 0 the operator sets*this to a suffix iterator that points to the range[prev->suffix().first,
prev->suffix().second).
6 Otherwise, sets*this to an end-of-sequence iterator.
7 Returns: *this.
regex_token_iterator& operator++(int);
8 Effects: Constructs a copytmp of *this, then calls++(*this).
9 Returns: tmp.
28.6.12 Modified ECMAScript regular expression grammar [re.grammar]
1 The regular expression grammar recognized bybasic_regex objects constructed with the ECMAScript flag
is that specified by ECMA-262, except as specified below.
2 Objects of type specialization ofbasic_regex store within themselves a default-constructed instance of
their traits template parameter, henceforth referred to astraits_inst. This traits_inst object is
used to support localization of the regular expression;basic_regex member functions shall not call any
locale dependent C or C++ API, including the formatted string input functions. Instead they shall call the
appropriate traits member function to achieve the required effect.
3 The following productions within the ECMAScript grammar are modified as follows:
ClassAtom::
-
ClassAtomNoDash
ClassAtomExClass
ClassAtomCollatingElement
ClassAtomEquivalence
IdentityEscape::
SourceCharacter but notc
4 The following new productions are then added:
ClassAtomExClass::
[: ClassName :]
ClassAtomCollatingElement ::
[. ClassName .]
ClassAtomEquivalence::
[= ClassName =]
ClassName::
ClassNameCharacter
ClassNameCharacter ClassName
§ 28.6.12 © ISO/IEC
1724

===== PAGE 1736 =====

Dxxxx
ClassNameCharacter::
SourceCharacter but not one of. or = or :
5 The productionsClassAtomExClass, ClassAtomCollatingElement and ClassAtomEquivalence provide func-
tionality equivalent to that of the same features in regular expressions in POSIX.
6 The regular expression grammar may be modified by anyregex_constants::syntax_option_type flags
specified when constructing an object of type specialization of basic_regex according to the rules in
Table 118.
7 A ClassName production, when used inClassAtomExClass, is not valid iftraits_inst.lookup_classname
returns zero for that name. The names recognized as validClassNames are determined by the type of
the traits class, but at least the following names shall be recognized:alnum, alpha, blank, cntrl, digit,
graph, lower, print, punct, space, upper, xdigit, d, s, w. In addition the following expressions shall be
equivalent:
\d and [[:digit:]]
\D and [^[:digit:]]
\s and [[:space:]]
\S and [^[:space:]]
\w and [_[:alnum:]]
\W and [^_[:alnum:]]
8 A ClassName production when used in aClassAtomCollatingElement production is not valid if the value
returned bytraits_inst.lookup_collatename for that name is an empty string.
9 The results from multiple calls totraits_inst.lookup_classname can be bitwise or’ed together and
subsequently passed totraits_inst.isctype.
10 A ClassName production when used in aClassAtomEquivalence production is not valid if the value returned
by traits_inst.lookup_collatename for that name is an empty string or if the value returned bytraits_-
inst.transform_primary for the result of the call to traits_inst.lookup_collatename is an empty
string.
11 When the sequence of characters being transformed to a finite state machine contains an invalid class name
the translator shall throw an exception object of typeregex_error.
12 If theCV of aUnicodeEscapeSequenceis greater than the largest value that can be held in an object of type
charT the translator shall throw an exception object of typeregex_error.
[Note 1: This means that values of the form"\uxxxx" that do not fit in a character are invalid.—end note]
13 Where the regular expression grammar requires the conversion of a sequence of characters to an integral
value, this is accomplished by callingtraits_inst.value.
14 The behavior of the internal finite state machine representation when used to match a sequence of characters
is as described in ECMA-262. The behavior is modified according to anymatch_flag_type flags (28.6.4.3)
specified when using the regular expression object in one of the regular expression algorithms (28.6.10). The
behavior is also localized by interaction with the traits class template parameter as follows:
—(14.1) During matching of a regular expression finite state machine against a sequence of characters, two
characters c and d are compared using the following rules:
—(14.1.1) if (flags() & regex_constants::icase) the two characters are equal iftraits_inst.trans-
late_nocase(c) == traits_inst.translate_nocase(d);
—(14.1.2) otherwise, if flags() & regex_constants::collate the two characters are equal iftraits_-
inst.translate(c) == traits_inst.translate(d);
—(14.1.3) otherwise, the two characters are equal ifc == d.
—(14.2) During matching of a regular expression finite state machine against a sequence of characters, comparison
of a collating element rangec1-c2 against a characterc is conducted as follows: ifflags() & regex_-
constants::collate is false then the characterc is matched ifc1 <= c && c <= c2, otherwisec
is matched in accordance with the following algorithm:
§ 28.6.12 © ISO/IEC
1725

===== PAGE 1737 =====

Dxxxx
string_type str1 = string_type(1,
flags() & icase ?
traits_inst.translate_nocase(c1) : traits_inst.translate(c1));
string_type str2 = string_type(1,
flags() & icase ?
traits_inst.translate_nocase(c2) : traits_inst.translate(c2));
string_type str = string_type(1,
flags() & icase ?
traits_inst.translate_nocase(c) : traits_inst.translate(c));
return traits_inst.transform(str1.begin(), str1.end())
<= traits_inst.transform(str.begin(), str.end())
&& traits_inst.transform(str.begin(), str.end())
<= traits_inst.transform(str2.begin(), str2.end());
—(14.3) During matching of a regular expression finite state machine against a sequence of characters, testing
whether a collating element is a member of a primary equivalence class is conducted by first converting
the collating element and the equivalence class to sort keys usingtraits::transform_primary, and
then comparing the sort keys for equality.
—(14.4) During matching of a regular expression finite state machine against a sequence of characters, a
character c is a member of a character class designated by an iterator range[first,last) if traits_-
inst.isctype(c, traits_inst.lookup_classname(first, last, flags() & icase)) is true.
See also: ECMA-262 15.10
28.7 Null-terminated sequence utilities [text.c.strings]
28.7.1 Header <cctype> synopsis [cctype.syn]
namespace std {
int isalnum(int c);
int isalpha(int c);
int isblank(int c);
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);
int tolower(int c);
int toupper(int c);
}
1 The contents and meaning of the header<cctype> are the same as the C standard library header<ctype.h>.
See also: ISO/IEC 9899:2024, 7.4
28.7.2 Header <cwctype> synopsis [cwctype.syn]
namespace std {
using wint_t = see below ;
using wctrans_t = see below ;
using wctype_t = see below ;
int iswalnum(wint_t wc);
int iswalpha(wint_t wc);
int iswblank(wint_t wc);
int iswcntrl(wint_t wc);
int iswdigit(wint_t wc);
int iswgraph(wint_t wc);
int iswlower(wint_t wc);
int iswprint(wint_t wc);
int iswpunct(wint_t wc);
int iswspace(wint_t wc);
int iswupper(wint_t wc);
§ 28.7.2 © ISO/IEC
1726

===== PAGE 1738 =====

Dxxxx
int iswxdigit(wint_t wc);
int iswctype(wint_t wc, wctype_t desc);
wctype_t wctype(const char* property);
wint_t towlower(wint_t wc);
wint_t towupper(wint_t wc);
wint_t towctrans(wint_t wc, wctrans_t desc);
wctrans_t wctrans(const char* property);
}
#define WEOF see below
1 The contents and meaning of the header<cwctype>are the same as the C standard library header<wctype.h>.
See also: ISO/IEC 9899:2024, 7.32
28.7.3 Header <cwchar> synopsis [cwchar.syn]
#define __STDC_VERSION_WCHAR_H__ 202311L
namespace std {
using size_t = see 17.2.4; // freestanding
using mbstate_t = see below ; // freestanding
using wint_t = see below ; // freestanding
struct tm;
int fwprintf(FILE* stream, const wchar_t* format, ...);
int fwscanf(FILE* stream, const wchar_t* format, ...);
int swprintf(wchar_t* s, size_t n, const wchar_t* format, ...);
int swscanf(const wchar_t* s, const wchar_t* format, ...);
int vfwprintf(FILE* stream, const wchar_t* format, va_list arg);
int vfwscanf(FILE* stream, const wchar_t* format, va_list arg);
int vswprintf(wchar_t* s, size_t n, const wchar_t* format, va_list arg);
int vswscanf(const wchar_t* s, const wchar_t* format, va_list arg);
int vwprintf(const wchar_t* format, va_list arg);
int vwscanf(const wchar_t* format, va_list arg);
int wprintf(const wchar_t* format, ...);
int wscanf(const wchar_t* format, ...);
wint_t fgetwc(FILE* stream);
wchar_t* fgetws(wchar_t* s, int n, FILE* stream);
wint_t fputwc(wchar_t c, FILE* stream);
int fputws(const wchar_t* s, FILE* stream);
int fwide(FILE* stream, int mode);
wint_t getwc(FILE* stream);
wint_t getwchar();
wint_t putwc(wchar_t c, FILE* stream);
wint_t putwchar(wchar_t c);
wint_t ungetwc(wint_t c, FILE* stream);
double wcstod(const wchar_t* nptr, wchar_t** endptr);
float wcstof(const wchar_t* nptr, wchar_t** endptr);
long double wcstold(const wchar_t* nptr, wchar_t** endptr);
long int wcstol(const wchar_t* nptr, wchar_t** endptr, int base);
long long int wcstoll(const wchar_t* nptr, wchar_t** endptr, int base);
unsigned long int wcstoul(const wchar_t* nptr, wchar_t** endptr, int base);
unsigned long long int wcstoull(const wchar_t* nptr, wchar_t** endptr, int base);
wchar_t* wcscpy(wchar_t* s1, const wchar_t* s2); // freestanding
wchar_t* wcsncpy(wchar_t* s1, const wchar_t* s2, size_t n); // freestanding
wchar_t* wmemcpy(wchar_t* s1, const wchar_t* s2, size_t n); // freestanding
wchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n); // freestanding
wchar_t* wcscat(wchar_t* s1, const wchar_t* s2); // freestanding
wchar_t* wcsncat(wchar_t* s1, const wchar_t* s2, size_t n); // freestanding
int wcscmp(const wchar_t* s1, const wchar_t* s2); // freestanding
int wcscoll(const wchar_t* s1, const wchar_t* s2);
int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n); // freestanding
size_t wcsxfrm(wchar_t* s1, const wchar_t* s2, size_t n);
int wmemcmp(const wchar_t* s1, const wchar_t* s2, size_t n); // freestanding
§ 28.7.3 © ISO/IEC
1727

===== PAGE 1739 =====

Dxxxx
const wchar_t* wcschr(const wchar_t* s, wchar_t c); // freestanding; see 16.2
wchar_t* wcschr(wchar_t* s, wchar_t c); // freestanding; see 16.2
size_t wcscspn(const wchar_t* s1, const wchar_t* s2); // freestanding
const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2); // freestanding; see 16.2
wchar_t* wcspbrk(wchar_t* s1, const wchar_t* s2); // freestanding; see 16.2
const wchar_t* wcsrchr(const wchar_t* s, wchar_t c); // freestanding; see 16.2
wchar_t* wcsrchr(wchar_t* s, wchar_t c); // freestanding; see 16.2
size_t wcsspn(const wchar_t* s1, const wchar_t* s2); // freestanding
const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2); // freestanding; see 16.2
wchar_t* wcsstr(wchar_t* s1, const wchar_t* s2); // freestanding; see 16.2
wchar_t* wcstok(wchar_t* s1, const wchar_t* s2, wchar_t** ptr); // freestanding
const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n); // freestanding; see 16.2
wchar_t* wmemchr(wchar_t* s, wchar_t c, size_t n); // freestanding; see 16.2
size_t wcslen(const wchar_t* s); // freestanding
wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n); // freestanding
size_t wcsftime(wchar_t* s, size_t maxsize, const wchar_t* format, const tm* timeptr);
wint_t btowc(int c);
int wctob(wint_t c);
// 28.7.5, multibyte / wide string and character conversion functions
int mbsinit(const mbstate_t* ps);
size_t mbrlen(const char* s, size_t n, mbstate_t* ps);
size_t mbrtowc(wchar_t* pwc, const char* s, size_t n, mbstate_t* ps);
size_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);
size_t mbsrtowcs(wchar_t* dst, const char** src, size_t len, mbstate_t* ps);
size_t wcsrtombs(char* dst, const wchar_t** src, size_t len, mbstate_t* ps);
}
#define NULL see 17.2.3 // freestanding
#define WCHAR_MAX see below // freestanding
#define WCHAR_MIN see below // freestanding
#define WEOF see below // freestanding
#define WCHAR_WIDTH see below // freestanding
1 The contents and meaning of the header<cwchar> are the same as the C standard library header<wchar.h>,
except that it does not declare a typewchar_t.
2 [Note 1: The functionswcschr, wcspbrk, wcsrchr, wcsstr, andwmemchr have different signatures in this document,
but they have the same behavior as in the C standard library (16.2).—end note]
See also: ISO/IEC 9899:2024, 7.31
28.7.4 Header <cuchar> synopsis [cuchar.syn]
#define __STDC_VERSION_UCHAR_H__ 202311L
namespace std {
using mbstate_t = see below ;
using size_t = see 17.2.4;
size_t mbrtoc8(char8_t* pc8, const char* s, size_t n, mbstate_t* ps);
size_t c8rtomb(char* s, char8_t c8, mbstate_t* ps);
size_t mbrtoc16(char16_t* pc16, const char* s, size_t n, mbstate_t* ps);
size_t c16rtomb(char* s, char16_t c16, mbstate_t* ps);
size_t mbrtoc32(char32_t* pc32, const char* s, size_t n, mbstate_t* ps);
size_t c32rtomb(char* s, char32_t c32, mbstate_t* ps);
}
1 The contents and meaning of the header<cuchar> are the same as the C standard library header<uchar.h>,
except that it does not declare typeschar8_t, char16_t, orchar32_t.
See also: ISO/IEC 9899:2024, 7.30
28.7.5 Multibyte / wide string and character conversion functions [c.mb.wcs]
1 [Note 1: The headers<cstdlib> (17.2.2), <cuchar> (28.7.4), and<cwchar> (28.7.3) declare the functions described
in this subclause. —end note]
§ 28.7.5 © ISO/IEC
1728

===== PAGE 1740 =====

Dxxxx
int mbsinit(const mbstate_t* ps);
int mblen(const char* s, size_t n);
size_t mbstowcs(wchar_t* pwcs, const char* s, size_t n);
size_t wcstombs(char* s, const wchar_t* pwcs, size_t n);
2 Effects: These functions have the semantics specified in the C standard library.
See also: ISO/IEC 9899:2024, 7.24.8.2, 7.24.9, 7.31.6.3.1
int mbtowc(wchar_t* pwc, const char* s, size_t n);
int wctomb(char* s, wchar_t wchar);
3 Effects: These functions have the semantics specified in the C standard library.
4 Remarks: Calls to these functions may introduce a data race (16.4.6.10) with other calls to the same
function.
See also: ISO/IEC 9899:2024, 7.24.8
size_t mbrlen(const char* s, size_t n, mbstate_t* ps);
size_t mbrtowc(wchar_t* pwc, const char* s, size_t n, mbstate_t* ps);
size_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);
size_t mbrtoc8(char8_t* pc8, const char* s, size_t n, mbstate_t* ps);
size_t c8rtomb(char* s, char8_t c8, mbstate_t* ps);
size_t mbrtoc16(char16_t* pc16, const char* s, size_t n, mbstate_t* ps);
size_t c16rtomb(char* s, char16_t c16, mbstate_t* ps);
size_t mbrtoc32(char32_t* pc32, const char* s, size_t n, mbstate_t* ps);
size_t c32rtomb(char* s, char32_t c32, mbstate_t* ps);
size_t mbsrtowcs(wchar_t* dst, const char** src, size_t len, mbstate_t* ps);
size_t wcsrtombs(char* dst, const wchar_t** src, size_t len, mbstate_t* ps);
5 Effects: These functions have the semantics specified in the C standard library.
6 Remarks: Calling these functions with anmbstate_t* argument that is a null pointer value may
introduce a data race (16.4.6.10) with other calls to the same function with anmbstate_t* argument
that is a null pointer value.
See also: ISO/IEC 9899:2024, 7.30.2, 7.31.6.4, 7.31.6.5
§ 28.7.5 © ISO/IEC
1729

===== PAGE 1741 =====

Dxxxx
29 Numerics library [numerics]
29.1 General [numerics.general]
1 This Clause describes components that C++ programs may use to perform seminumerical operations.
2 The following subclauses describe components for complex number types, random number generation,
numeric (n-at-a-time) arrays, generalized numeric algorithms, and mathematical constants and functions for
floating-point types, as summarized in Table 125.
Table 125 — Numerics library summary [tab:numerics.summary]
Subclause Header
29.2 Requirements
29.3 Floating-point environment <cfenv>
29.4 Complex numbers <complex>
29.5 Random number generation <random>
29.6 Numeric arrays <valarray>
29.7 Mathematical functions for floating-point types <cmath>, <cstdlib>
29.8 Numbers <numbers>
29.9 Linear algebra <linalg>
29.10 Data-parallel types <simd>
29.2 Numeric type requirements [numeric.requirements]
1 The complex and valarray components are parameterized by the type of information they contain and
manipulate. A C++ program shall instantiate these components only with a numeric type. Anumeric
type is a cv-unqualified object typeT that meets theCpp17DefaultConstructible, Cpp17CopyConstructible,
Cpp17CopyAssignable, andCpp17Destructible requirements (16.4.4.2).231
2 If any operation onT throws an exception the effects are undefined.
3 In addition, many member and related functions ofvalarray<T> can be successfully instantiated and will
exhibit well-defined behavior if and only ifT meets additional requirements specified for each such member
or related function.
4 [Example 1: It is valid to instantiatevalarray<complex>, butoperator>() will not be successfully instantiated for
valarray<complex> operands, sincecomplex does not have any ordering operators.—end example]
29.3 The floating-point environment [cfenv]
29.3.1 Header <cfenv> synopsis [cfenv.syn]
#define FE_ALL_EXCEPT see below
#define FE_DIVBYZERO see below // optional
#define FE_INEXACT see below // optional
#define FE_INVALID see below // optional
#define FE_OVERFLOW see below // optional
#define FE_UNDERFLOW see below // optional
#define FE_DOWNWARD see below // optional
#define FE_TONEAREST see below // optional
#define FE_TOWARDZERO see below // optional
#define FE_UPWARD see below // optional
#define FE_DFL_ENV see below
231) In other words, value types. These include arithmetic types, pointers, the library classcomplex, and instantiations of
valarray for value types.
§ 29.3.1 © ISO/IEC
1730

===== PAGE 1742 =====

Dxxxx
namespace std {
// types
using fenv_t = object type ;
using fexcept_t = object type ;
// functions
int feclearexcept(int except);
int fegetexceptflag(fexcept_t* pflag, int except);
int feraiseexcept(int except);
int fesetexceptflag(const fexcept_t* pflag, int except);
int fetestexcept(int except);
int fegetround();
int fesetround(int mode);
int fegetenv(fenv_t* penv);
int feholdexcept(fenv_t* penv);
int fesetenv(const fenv_t* penv);
int feupdateenv(const fenv_t* penv);
}
1 The contents and meaning of the header<cfenv> are a subset of the C standard library header<fenv.h>
and only the declarations shown in the synopsis above are present.
[Note 1: This document does not require an implementation to support theFENV_ACCESS pragma; it is implementa-
tion-defined (15.10) whether the pragma is supported. As a consequence, it is implementation-defined whether these
functions can be used to test floating-point status flags, set floating-point control modes, or run under non-default
mode settings. If the pragma is used to enable control over the floating-point environment, this document does not
specify the effect on floating-point evaluation in constant expressions.—end note]
See also: ISO/IEC 9899:2024, 7.6
29.3.2 Threads [cfenv.thread]
1 The floating-point environment has thread storage duration (6.8.6.3). The initial state for a thread’s
floating-point environment is the state of the floating-point environment of the thread that constructs the
corresponding thread object (32.4.3) orjthread object (32.4.4) at the time it constructed the object.
[Note 1: That is, the child thread gets the floating-point state of the parent thread at the time of the child’s creation.
—end note]
2 A separate floating-point environment is maintained for each thread. Each function accesses the environment
corresponding to its calling thread.
29.4 Complex numbers [complex.numbers]
29.4.1 General [complex.numbers.general]
1 The header<complex> defines a class template, and numerous functions for representing and manipulating
complex numbers.
2 The effect of instantiating the primary template ofcomplex for any type that is not a cv-unqualified
floating-point type (6.9.2) is unspecified. Specializations ofcomplex for cv-unqualified floating-point types
are trivially copyable literal types (6.9.1).
3 If the result of a function is not mathematically defined or not in the range of representable values for its
type, the behavior is undefined.
4 If z is an lvalue of typecv complex<T> then:
—(4.1) the expressionreinterpret_cast<cv T(&)[2]>(z) is well-formed,
—(4.2) reinterpret_cast<cv T(&)[2]>(z)[0] designates the real part ofz, and
—(4.3) reinterpret_cast<cv T(&)[2]>(z)[1] designates the imaginary part ofz.
Moreover, ifa is an expression of typecv complex<T>* and the expressiona[i] is well-defined for an integer
expression i, then:
—(4.4) reinterpret_cast<cv T*>(a)[2 * i] designates the real part ofa[i], and
—(4.5) reinterpret_cast<cv T*>(a)[2 * i + 1] designates the imaginary part ofa[i].
§ 29.4.1 © ISO/IEC
1731

===== PAGE 1743 =====

Dxxxx
29.4.2 Header <complex> synopsis [complex.syn]
namespace std {
// 29.4.3, class templatecomplex
template<class T> class complex;
// 29.4.6, operators
template<class T> constexpr complex<T> operator+(const complex<T>&, const complex<T>&);
template<class T> constexpr complex<T> operator+(const complex<T>&, const T&);
template<class T> constexpr complex<T> operator+(const T&, const complex<T>&);
template<class T> constexpr complex<T> operator-(const complex<T>&, const complex<T>&);
template<class T> constexpr complex<T> operator-(const complex<T>&, const T&);
template<class T> constexpr complex<T> operator-(const T&, const complex<T>&);
template<class T> constexpr complex<T> operator*(const complex<T>&, const complex<T>&);
template<class T> constexpr complex<T> operator*(const complex<T>&, const T&);
template<class T> constexpr complex<T> operator*(const T&, const complex<T>&);
template<class T> constexpr complex<T> operator/(const complex<T>&, const complex<T>&);
template<class T> constexpr complex<T> operator/(const complex<T>&, const T&);
template<class T> constexpr complex<T> operator/(const T&, const complex<T>&);
template<class T> constexpr complex<T> operator+(const complex<T>&);
template<class T> constexpr complex<T> operator-(const complex<T>&);
template<class T> constexpr bool operator==(const complex<T>&, const complex<T>&);
template<class T> constexpr bool operator==(const complex<T>&, const T&);
template<class T, class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>&, complex<T>&);
template<class T, class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>&, const complex<T>&);
// 29.4.7, values
template<class T> constexpr T real(const complex<T>&);
template<class T> constexpr T imag(const complex<T>&);
template<class T> constexpr T abs(const complex<T>&);
template<class T> constexpr T arg(const complex<T>&);
template<class T> constexpr T norm(const complex<T>&);
template<class T> constexpr complex<T> conj(const complex<T>&);
template<class T> constexpr complex<T> proj(const complex<T>&);
template<class T> constexpr complex<T> polar(const T&, const T& = T());
// 29.4.8, transcendentals
template<class T> constexpr complex<T> acos(const complex<T>&);
template<class T> constexpr complex<T> asin(const complex<T>&);
template<class T> constexpr complex<T> atan(const complex<T>&);
template<class T> constexpr complex<T> acosh(const complex<T>&);
template<class T> constexpr complex<T> asinh(const complex<T>&);
template<class T> constexpr complex<T> atanh(const complex<T>&);
template<class T> constexpr complex<T> cos (const complex<T>&);
template<class T> constexpr complex<T> cosh (const complex<T>&);
template<class T> constexpr complex<T> exp (const complex<T>&);
template<class T> constexpr complex<T> log (const complex<T>&);
template<class T> constexpr complex<T> log10(const complex<T>&);
template<class T> constexpr complex<T> pow (const complex<T>&, const T&);
template<class T> constexpr complex<T> pow (const complex<T>&, const complex<T>&);
template<class T> constexpr complex<T> pow (const T&, const complex<T>&);
§ 29.4.2 © ISO/IEC
1732

===== PAGE 1744 =====

Dxxxx
template<class T> constexpr complex<T> sin (const complex<T>&);
template<class T> constexpr complex<T> sinh (const complex<T>&);
template<class T> constexpr complex<T> sqrt (const complex<T>&);
template<class T> constexpr complex<T> tan (const complex<T>&);
template<class T> constexpr complex<T> tanh (const complex<T>&);
// 29.4.9, tuple interface
template<class T> struct tuple_size;
template<size_t I, class T> struct tuple_element;
template<class T> struct tuple_size<complex<T>>;
template<size_t I, class T> struct tuple_element<I, complex<T>>;
template<size_t I, class T>
constexpr T& get(complex<T>&) noexcept;
template<size_t I, class T>
constexpr T&& get(complex<T>&&) noexcept;
template<size_t I, class T>
constexpr const T& get(const complex<T>&) noexcept;
template<size_t I, class T>
constexpr const T&& get(const complex<T>&&) noexcept;
// 29.4.11, complex literals
inline namespace literals {
inline namespace complex_literals {
constexpr complex<long double> operator""il(long double);
constexpr complex<long double> operator""il(unsigned long long);
constexpr complex<double> operator""i(long double);
constexpr complex<double> operator""i(unsigned long long);
constexpr complex<float> operator""if(long double);
constexpr complex<float> operator""if(unsigned long long);
}
}
}
29.4.3 Class template complex [complex]
namespace std {
template<class T> class complex {
public:
using value_type = T;
constexpr complex(const T& re = T(), const T& im = T());
constexpr complex(const complex&) = default;
template<class X> constexpr explicit(see below ) complex(const complex<X>&);
constexpr T real() const;
constexpr void real(T);
constexpr T imag() const;
constexpr void imag(T);
constexpr complex& operator= (const T&);
constexpr complex& operator+=(const T&);
constexpr complex& operator-=(const T&);
constexpr complex& operator*=(const T&);
constexpr complex& operator/=(const T&);
constexpr complex& operator=(const complex&);
template<class X> constexpr complex& operator= (const complex<X>&);
template<class X> constexpr complex& operator+=(const complex<X>&);
template<class X> constexpr complex& operator-=(const complex<X>&);
template<class X> constexpr complex& operator*=(const complex<X>&);
template<class X> constexpr complex& operator/=(const complex<X>&);
};
}
§ 29.4.3 © ISO/IEC
1733

===== PAGE 1745 =====

Dxxxx
1 The classcomplex describes an object that can store the Cartesian components,real() and imag(), of a
complex number.
29.4.4 Member functions [complex.members]
constexpr complex(const T& re = T(), const T& im = T());
1 Postconditions: real() == re && imag() == im is true.
template<class X> constexpr explicit(see below ) complex(const complex<X>& other);
2 Effects: Initializes the real part withother.real() and the imaginary part withother.imag().
3 Remarks: The expression insideexplicit evaluates tofalse if and only if the floating-point conversion
rank ofT is greater than or equal to the floating-point conversion rank ofX.
constexpr T real() const;
4 Returns: The value of the real component.
constexpr void real(T val);
5 Effects: Assigns val to the real component.
constexpr T imag() const;
6 Returns: The value of the imaginary component.
constexpr void imag(T val);
7 Effects: Assigns val to the imaginary component.
29.4.5 Member operators [complex.member.ops]
constexpr complex& operator+=(const T& rhs);
1 Effects: Adds the scalar valuerhs to the real part of the complex value*this and stores the result in
the real part of*this, leaving the imaginary part unchanged.
2 Returns: *this.
constexpr complex& operator-=(const T& rhs);
3 Effects: Subtracts the scalar valuerhs from the real part of the complex value*this and stores the
result in the real part of*this, leaving the imaginary part unchanged.
4 Returns: *this.
constexpr complex& operator*=(const T& rhs);
5 Effects: Multiplies the scalar valuerhs by the complex value*this and stores the result in*this.
6 Returns: *this.
constexpr complex& operator/=(const T& rhs);
7 Effects: Divides the scalar valuerhs into the complex value*this and stores the result in*this.
8 Returns: *this.
template<class X> constexpr complex& operator=(const complex<X>& rhs);
9 Effects: Assigns the valuerhs.real() to the real part and the valuerhs.imag() to the imaginary
part of the complex value*this.
10 Returns: *this.
template<class X> constexpr complex& operator+=(const complex<X>& rhs);
11 Effects: Adds the complex valuerhs to the complex value*this and stores the sum in*this.
12 Returns: *this.
template<class X> constexpr complex& operator-=(const complex<X>& rhs);
13 Effects: Subtracts the complex valuerhs from the complex value*this and stores the difference in
*this.
§ 29.4.5 © ISO/IEC
1734

===== PAGE 1746 =====

Dxxxx
14 Returns: *this.
template<class X> constexpr complex& operator*=(const complex<X>& rhs);
15 Effects: Multiplies the complex valuerhs by the complex value*this and stores the product in*this.
16 Returns: *this.
template<class X> constexpr complex& operator/=(const complex<X>& rhs);
17 Effects: Divides the complex valuerhs into the complex value*this and stores the quotient in*this.
18 Returns: *this.
29.4.6 Non-member operations [complex.ops]
template<class T> constexpr complex<T> operator+(const complex<T>& lhs);
1 Returns: complex<T>(lhs).
template<class T> constexpr complex<T> operator+(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator+(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator+(const T& lhs, const complex<T>& rhs);
2 Returns: complex<T>(lhs) += rhs.
template<class T> constexpr complex<T> operator-(const complex<T>& lhs);
3 Returns: complex<T>(-lhs.real(),-lhs.imag()).
template<class T> constexpr complex<T> operator-(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator-(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator-(const T& lhs, const complex<T>& rhs);
4 Returns: complex<T>(lhs) -= rhs.
template<class T> constexpr complex<T> operator*(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator*(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator*(const T& lhs, const complex<T>& rhs);
5 Returns: complex<T>(lhs) *= rhs.
template<class T> constexpr complex<T> operator/(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr complex<T> operator/(const complex<T>& lhs, const T& rhs);
template<class T> constexpr complex<T> operator/(const T& lhs, const complex<T>& rhs);
6 Returns: complex<T>(lhs) /= rhs.
template<class T> constexpr bool operator==(const complex<T>& lhs, const complex<T>& rhs);
template<class T> constexpr bool operator==(const complex<T>& lhs, const T& rhs);
7 Returns: lhs.real() == rhs.real() && lhs.imag() == rhs.imag().
8 Remarks: The imaginary part is assumed to beT(), or 0.0, for theT arguments.
template<class T, class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is, complex<T>& x);
9 Preconditions: The input values are convertible toT.
10 Effects: Extracts a complex numberx of the form:u, (u), or(u,v), whereu is the real part andv is
the imaginary part (31.7.5.3).
11 If bad input is encountered, callsis.setstate(ios_base::failbit) (which may throwios_base::
failure (31.5.4.4)).
12 Returns: is.
13 Remarks: This extraction is performed as a series of simpler extractions. Therefore, the skipping of
whitespace is specified to be the same for each of the simpler extractions.
template<class T, class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& o, const complex<T>& x);
14 Effects: Inserts the complex numberx onto the streamo as if it were implemented as follows:
§ 29.4.6 © ISO/IEC
1735

===== PAGE 1747 =====

Dxxxx
basic_ostringstream<charT, traits> s;
s.flags(o.flags());
s.imbue(o.getloc());
s.precision(o.precision());
s << '(' << x.real() << ',' << x.imag() << ')';
return o << s.str();
15 [Note 1: In a locale in which comma is used as a decimal point character, the use of comma as a field separator
can be ambiguous. Insertingshowpoint into the output stream forces all outputs to show an explicit decimal
point character; as a result, all inserted sequences of complex numbers can be extracted unambiguously.—end
note]
29.4.7 Value operations [complex.value.ops]
template<class T> constexpr T real(const complex<T>& x);
1 Returns: x.real().
template<class T> constexpr T imag(const complex<T>& x);
2 Returns: x.imag().
template<class T> constexpr T abs(const complex<T>& x);
3 Returns: The magnitude ofx.
template<class T> constexpr T arg(const complex<T>& x);
4 Returns: The phase angle ofx, oratan2(imag(x), real(x)).
template<class T> constexpr T norm(const complex<T>& x);
5 Returns: The squared magnitude ofx.
template<class T> constexpr complex<T> conj(const complex<T>& x);
6 Returns: The complex conjugate ofx.
template<class T> constexpr complex<T> proj(const complex<T>& x);
7 Returns: The projection ofx onto the Riemann sphere.
8 Remarks: Behaves the same as the C functioncproj. See also: ISO/IEC 9899:2024, 7.3.9.5
template<class T> constexpr complex<T> polar(const T& rho, const T& theta = T());
9 Preconditions: rho is non-negative and non-NaN.theta is finite.
10 Returns: The complex value corresponding to a complex number whose magnitude isrho and whose
phase angle istheta.
29.4.8 Transcendentals [complex.transcendentals]
template<class T> constexpr complex<T> acos(const complex<T>& x);
1 Returns: The complex arc cosine ofx.
2 Remarks: Behaves the same as the C functioncacos. See also: ISO/IEC 9899:2024, 7.3.5.1
template<class T> constexpr complex<T> asin(const complex<T>& x);
3 Returns: The complex arc sine ofx.
4 Remarks: Behaves the same as the C functioncasin. See also: ISO/IEC 9899:2024, 7.3.5.2
template<class T> constexpr complex<T> atan(const complex<T>& x);
5 Returns: The complex arc tangent ofx.
6 Remarks: Behaves the same as the C functioncatan. See also: ISO/IEC 9899:2024, 7.3.5.3
template<class T> constexpr complex<T> acosh(const complex<T>& x);
7 Returns: The complex arc hyperbolic cosine ofx.
8 Remarks: Behaves the same as the C functioncacosh. See also: ISO/IEC 9899:2024, 7.3.6.1
§ 29.4.8 © ISO/IEC
1736

===== PAGE 1748 =====

Dxxxx
template<class T> constexpr complex<T> asinh(const complex<T>& x);
9 Returns: The complex arc hyperbolic sine ofx.
10 Remarks: Behaves the same as the C functioncasinh. See also: ISO/IEC 9899:2024, 7.3.6.2
template<class T> constexpr complex<T> atanh(const complex<T>& x);
11 Returns: The complex arc hyperbolic tangent ofx.
12 Remarks: Behaves the same as the C functioncatanh. See also: ISO/IEC 9899:2024, 7.3.6.3
template<class T> constexpr complex<T> cos(const complex<T>& x);
13 Returns: The complex cosine ofx.
template<class T> constexpr complex<T> cosh(const complex<T>& x);
14 Returns: The complex hyperbolic cosine ofx.
template<class T> constexpr complex<T> exp(const complex<T>& x);
15 Returns: The complex base-e exponential ofx.
template<class T> constexpr complex<T> log(const complex<T>& x);
16 Returns: The complex natural (base-e) logarithm ofx. For allx, imag(log(x)) lies in the interval
[−π,π].
[Note 1: The semantics of this function are intended to be the same in C++ as they are forclog in C. —end
note]
17 Remarks: The branch cuts are along the negative real axis.
template<class T> constexpr complex<T> log10(const complex<T>& x);
18 Returns: The complex common (base-10) logarithm ofx, defined aslog(x) / log(10).
19 Remarks: The branch cuts are along the negative real axis.
template<class T> constexpr complex<T> pow(const complex<T>& x, const complex<T>& y);
template<class T> constexpr complex<T> pow(const complex<T>& x, const T& y);
template<class T> constexpr complex<T> pow(const T& x, const complex<T>& y);
20 Returns: The complex power of basex raised to theyth power, defined asexp(y * log(x)). The
value returned forpow(0, 0) is implementation-defined.
21 Remarks: The branch cuts are along the negative real axis.
template<class T> constexpr complex<T> sin(const complex<T>& x);
22 Returns: The complex sine ofx.
template<class T> constexpr complex<T> sinh(const complex<T>& x);
23 Returns: The complex hyperbolic sine ofx.
template<class T> constexpr complex<T> sqrt(const complex<T>& x);
24 Returns: The complex square root ofx, in the range of the right half-plane.
[Note 2: The semantics of this function are intended to be the same in C++ as they are forcsqrt in C. —end
note]
25 Remarks: The branch cuts are along the negative real axis.
template<class T> constexpr complex<T> tan(const complex<T>& x);
26 Returns: The complex tangent ofx.
template<class T> constexpr complex<T> tanh(const complex<T>& x);
27 Returns: The complex hyperbolic tangent ofx.
29.4.9 Tuple interface [complex.tuple]
template<class T>
struct tuple_size<complex<T>> : integral_constant<size_t, 2> {};
§ 29.4.9 © ISO/IEC
1737

===== PAGE 1749 =====

Dxxxx
template<size_t I, class T>
struct tuple_element<I, complex<T>> {
using type = T;
};
1 Mandates: I < 2 is true.
template<size_t I, class T>
constexpr T& get(complex<T>& z) noexcept;
template<size_t I, class T>
constexpr T&& get(complex<T>&& z) noexcept;
template<size_t I, class T>
constexpr const T& get(const complex<T>& z) noexcept;
template<size_t I, class T>
constexpr const T&& get(const complex<T>&& z) noexcept;
2 Mandates: I < 2 is true.
3 Returns: A reference to the real part ofz if I == 0 is true, otherwise a reference to the imaginary
part ofz.
29.4.10 Additional overloads [cmplx.over]
1 The following function templates have additional constexpr overloads:
arg norm
conj proj
imag real
2 The additional constexpr overloads are sufficient to ensure:
—(2.1) If the argument has a floating-point typeT, then it is effectively cast tocomplex<T>.
—(2.2) Otherwise, if the argument has integer type, then it is effectively cast tocomplex<double>.
3 Function templatepow has additional constexpr overloads sufficient to ensure, for a call with one argument
of typecomplex<T1> and the other argument of typeT2 or complex<T2>, both arguments are effectively
cast tocomplex<common_type_t<T1, T3>>, whereT3 is double if T2 is an integer type andT2 otherwise. If
common_type_t<T1, T3> is not well-formed, then the program is ill-formed.
29.4.11 Suffixes for complex number literals [complex.literals]
1 This subclause describes literal suffixes for constructing complex number literals. The suffixesi, il, and
if create complex numbers of the typescomplex<double>, complex<long double>, andcomplex<float>
respectively, with their imaginary part denoted by the given literal number and the real part being zero.
constexpr complex<long double> operator""il(long double d);
constexpr complex<long double> operator""il(unsigned long long d);
2 Returns: complex<long double>{0.0L, static_cast<long double>(d)}.
constexpr complex<double> operator""i(long double d);
constexpr complex<double> operator""i(unsigned long long d);
3 Returns: complex<double>{0.0, static_cast<double>(d)}.
constexpr complex<float> operator""if(long double d);
constexpr complex<float> operator""if(unsigned long long d);
4 Returns: complex<float>{0.0f, static_cast<float>(d)}.
29.5 Random number generation [rand]
29.5.1 General [rand.general]
1 Subclause 29.5 defines a facility for generating (pseudo-)random numbers.
2 In addition to a few utilities, four categories of entities are described:uniform random bit generators, random
number engines, random number engine adaptors, andrandom number distributions. These categorizations
are applicable to types that meet the corresponding requirements, to objects instantiated from such types,
and to templates producing such types when instantiated.
§ 29.5.1 © ISO/IEC
1738

===== PAGE 1750 =====

Dxxxx
[Note 1: These entities are specified in such a way as to permit the binding of any uniform random bit generator
object e as the argument to any random number distribution objectd, thus producing a zero-argument function object
such as given bybind(d,e). —end note]
3 Each of the entities specified in 29.5 has an associated arithmetic type (6.9.2) identified asresult_type.
With T as theresult_type thus associated with such an entity, that entity is characterized:
—(3.1) as booleanor equivalently asboolean-valued, ifT is bool;
—(3.2) otherwise asintegral or equivalently asinteger-valued, ifnumeric_limits<T>::is_integer is true;
—(3.3) otherwise asfloating-point or equivalently asreal-valued.
If integer-valued, an entity may optionally be further characterized assigned or unsigned, according to
numeric_limits<T>::is_signed.
4 Unless otherwise specified, all descriptions of calculations in 29.5 use mathematical real numbers.
5 Throughout 29.5, the operatorsbitand, bitor, andxor denote the respective conventional bitwise operations.
Further:
—(5.1) the operatorrshift denotes a bitwise right shift with zero-valued bits appearing in the high bits of the
result, and
—(5.2) the operatorlshiftw denotes a bitwise left shift with zero-valued bits appearing in the low bits of the
result, and whose result is always taken modulo2w.
29.5.2 Header <random> synopsis [rand.synopsis]
#include <initializer_list> // see 17.11.2
namespace std {
// 29.5.3.3, uniform random bit generator requirements
template<class G>
concept uniform_random_bit_generator = see below ; // freestanding
// 29.5.4.2, class templatelinear_congruential_engine
template<class UIntType, UIntType a, UIntType c, UIntType m>
class linear_congruential_engine; // partially freestanding
// 29.5.4.3, class templatemersenne_twister_engine
template<class UIntType, size_t w, size_t n, size_t m, size_t r,
UIntType a, size_t u, UIntType d, size_t s,
UIntType b, size_t t,
UIntType c, size_t l, UIntType f>
class mersenne_twister_engine;
// 29.5.4.4, class templatesubtract_with_carry_engine
template<class UIntType, size_t w, size_t s, size_t r>
class subtract_with_carry_engine; // partially freestanding
// 29.5.5.2, class templatediscard_block_engine
template<class Engine, size_t p, size_t r>
class discard_block_engine; // partially freestanding
// 29.5.5.3, class templateindependent_bits_engine
template<class Engine, size_t w, class UIntType>
class independent_bits_engine; // partially freestanding
// 29.5.5.4, class templateshuffle_order_engine
template<class Engine, size_t k>
class shuffle_order_engine;
// 29.5.4.5, class templatephilox_engine
template<class UIntType, size_t w, size_t n, size_t r, UIntType... consts>
class philox_engine; // partially freestanding
// 29.5.6, engines and engine adaptors with predefined parameters
using minstd_rand0 = see below ; // freestanding
§ 29.5.2 © ISO/IEC
1739

===== PAGE 1751 =====

Dxxxx
using minstd_rand = see below ; // freestanding
using mt19937 = see below ; // freestanding
using mt19937_64 = see below ; // freestanding
using ranlux24_base = see below ; // freestanding
using ranlux48_base = see below ; // freestanding
using ranlux24 = see below ; // freestanding
using ranlux48 = see below ; // freestanding
using knuth_b = see below ;
using philox4x32 = see below ; // freestanding
using philox4x64 = see below ; // freestanding
using default_random_engine = see below ;
// 29.5.7, classrandom_device
class random_device;
// 29.5.8.1, classseed_seq
class seed_seq;
// 29.5.8.2, function templategenerate_canonical
template<class RealType, size_t digits, class URBG>
RealType generate_canonical(URBG& g);
namespace ranges {
// 26.12.2,generate_random
template<class R, class G>
requires output_range<R, invoke_result_t<G&>> &&
uniform_random_bit_generator<remove_cvref_t<G>>
constexpr borrowed_iterator_t<R> generate_random(R&& r, G&& g);
template<class G, output_iterator<invoke_result_t<G&>> O, sentinel_for<O> S>
requires uniform_random_bit_generator<remove_cvref_t<G>>
constexpr O generate_random(O first, S last, G&& g);
template<class R, class G, class D>
requires output_range<R, invoke_result_t<D&, G&>> && invocable<D&, G&> &&
uniform_random_bit_generator<remove_cvref_t<G>> &&
is_arithmetic_v<invoke_result_t<D&, G&>>
constexpr borrowed_iterator_t<R> generate_random(R&& r, G&& g, D&& d);
template<class G, class D, output_iterator<invoke_result_t<D&, G&>> O, sentinel_for<O> S>
requires invocable<D&, G&> && uniform_random_bit_generator<remove_cvref_t<G>> &&
is_arithmetic_v<invoke_result_t<D&, G&>>
constexpr O generate_random(O first, S last, G&& g, D&& d);
}
// 29.5.9.2.1, class templateuniform_int_distribution
template<class IntType = int>
class uniform_int_distribution; // partially freestanding
// 29.5.9.2.2, class templateuniform_real_distribution
template<class RealType = double>
class uniform_real_distribution;
// 29.5.9.3.1, classbernoulli_distribution
class bernoulli_distribution;
// 29.5.9.3.2, class templatebinomial_distribution
template<class IntType = int>
class binomial_distribution;
// 29.5.9.3.3, class templategeometric_distribution
template<class IntType = int>
class geometric_distribution;
§ 29.5.2 © ISO/IEC
1740

===== PAGE 1752 =====

Dxxxx
// 29.5.9.3.4, class templatenegative_binomial_distribution
template<class IntType = int>
class negative_binomial_distribution;
// 29.5.9.4.1, class templatepoisson_distribution
template<class IntType = int>
class poisson_distribution;
// 29.5.9.4.2, class templateexponential_distribution
template<class RealType = double>
class exponential_distribution;
// 29.5.9.4.3, class templategamma_distribution
template<class RealType = double>
class gamma_distribution;
// 29.5.9.4.4, class templateweibull_distribution
template<class RealType = double>
class weibull_distribution;
// 29.5.9.4.5, class templateextreme_value_distribution
template<class RealType = double>
class extreme_value_distribution;
// 29.5.9.5.1, class templatenormal_distribution
template<class RealType = double>
class normal_distribution;
// 29.5.9.5.2, class templatelognormal_distribution
template<class RealType = double>
class lognormal_distribution;
// 29.5.9.5.3, class templatechi_squared_distribution
template<class RealType = double>
class chi_squared_distribution;
// 29.5.9.5.4, class templatecauchy_distribution
template<class RealType = double>
class cauchy_distribution;
// 29.5.9.5.5, class templatefisher_f_distribution
template<class RealType = double>
class fisher_f_distribution;
// 29.5.9.5.6, class templatestudent_t_distribution
template<class RealType = double>
class student_t_distribution;
// 29.5.9.6.1, class templatediscrete_distribution
template<class IntType = int>
class discrete_distribution;
// 29.5.9.6.2, class templatepiecewise_constant_distribution
template<class RealType = double>
class piecewise_constant_distribution;
// 29.5.9.6.3, class templatepiecewise_linear_distribution
template<class RealType = double>
class piecewise_linear_distribution;
}
§ 29.5.2 © ISO/IEC
1741

===== PAGE 1753 =====

Dxxxx
29.5.3 Requirements [rand.req]
29.5.3.1 General requirements [rand.req.genl]
1 Throughout 29.5, the effect of instantiating a template:
—(1.1) that has a template type parameter namedSseq is undefined unless the corresponding template
argument is cv-unqualified and meets the requirements of seed sequence (29.5.3.2).
—(1.2) that has a template type parameter namedURBG is undefined unless the corresponding template
argument is cv-unqualified and meets the requirements of uniform random bit generator (29.5.3.3).
—(1.3) that has a template type parameter namedEngine is undefined unless the corresponding template
argument is cv-unqualified and meets the requirements of random number engine (29.5.3.4).
—(1.4) that has a template type parameter namedRealType is undefined unless the corresponding template
argument is cv-unqualified and is one offloat, double, orlong double.
—(1.5) that has a template type parameter namedIntType is undefined unless the corresponding template
argument is cv-unqualified and is one ofshort, int, long, long long, unsigned short, unsigned
int, unsigned long, orunsigned long long.
—(1.6) that has a template type parameter namedUIntType is undefined unless the corresponding template
argument is cv-unqualified and is one ofunsigned short, unsigned int, unsigned long, orunsigned
long long.
2 Throughout 29.5, phrases of the form “x is an iterator of a specific kind” shall be interpreted as equivalent to
the more formal requirement that “x is a value of a type meeting the requirements of the specified iterator
type”.
3 Throughout 29.5, any constructor that can be called with a single argument and that meets a requirement
specified in this subclause shall be declaredexplicit.
29.5.3.2 Seed sequence requirements [rand.req.seedseq]
1 A seed sequenceis an object that consumes a sequence of integer-valued data and produces a requested
number of unsigned integer valuesi, 0 ≤i< 232, based on the consumed data.
[Note 1: Such an object provides a mechanism to avoid replication of streams of random variates. This can be useful,
for example, in applications requiring large numbers of random number engines.—end note]
2 A classS meets the requirements of a seed sequence if the expressions shown in Table 126 are valid and have
the indicated semantics, and ifS also meets all other requirements of 29.5.3.2. In Table 126 and throughout
this subclause:
—(2.1) T is the type named byS’s associatedresult_type;
—(2.2) q is a value of typeS and r is a value of typeS or const S;
—(2.3) ib and ie are input iterators with an unsigned integervalue_type of at least 32 bits;
—(2.4) rb and re are mutable random access iterators with an unsigned integervalue_type of at least 32 bits;
—(2.5) ob is an output iterator; and
—(2.6) il is a value of typeinitializer_list<T>.
Table 126 — Seed sequence requirements [tab:rand.req.seedseq]
Expression Return type Pre/post-condition Complexity
S::result_type T T is an unsigned integer
type (6.9.2) of at least 32 bits.
S() Creates a seed sequence with
the same initial state as all
other default-constructed seed
sequences of typeS.
constant
S(ib,ie) Creates a seed sequence having
internal state that depends on
some or all of the bits of the
supplied sequence[ib,ie).
O(ie−ib)
§ 29.5.3.2 © ISO/IEC
1742

===== PAGE 1754 =====

Dxxxx
Table 126 — Seed sequence requirements (continued)
Expression Return type Pre/post-condition Complexity
S(il) Same asS(il.begin(),
il.end()).
same as
S(il.begin(),
il.end())
q.generate(rb,re) void Does nothing ifrb == re.
Otherwise, fills the supplied
sequence [rb,re) with 32-bit
quantities that depend on the
sequence supplied to the
constructor and possibly also
depend on the history of
generate’s previous
invocations.
O(re−rb)
r.size() size_t The number of 32-bit units that
would be copied by a call to
r.param.
constant
r.param(ob) void Copies to the given destination
a sequence of 32-bit units that
can be provided to the
constructor of a second object of
type S, and that would
reproduce in that second object
a state indistinguishable from
the state of the first object.
O(r.size())
29.5.3.3 Uniform random bit generator requirements [rand.req.urng]
1 A uniform random bit generatorg of typeG is a function object returning unsigned integer values such that
each value in the range of possible results has (ideally) equal probability of being returned.
[Note 1: The degree to whichg’s results approximate the ideal is often determined statistically.—end note]
template<class G>
concept uniform_random_bit_generator =
invocable<G&> && unsigned_integral<invoke_result_t<G&>> &&
requires {
{ G::min() } -> same_as<invoke_result_t<G&>>;
{ G::max() } -> same_as<invoke_result_t<G&>>;
requires bool_constant<(G::min() < G::max())>::value;
};
2 Let g be an object of typeG. G models uniform_random_bit_generator only if
—(2.1) G::min() <= g(),
—(2.2) g() <= G::max(), and
—(2.3) g() has amortized constant complexity.
3 A classG meets theuniform random bit generatorrequirements ifG models uniform_random_bit_generator,
invoke_result_t<G&>is an unsigned integer type (6.9.2), andGprovides a nestedtypedef-name result_type
that denotes the same type asinvoke_result_t<G&>.
29.5.3.4 Random number engine requirements [rand.req.eng]
1 A random number engine(commonly shortened toengine) e of typeE is a uniform random bit generator
that additionally meets the requirements (e.g., for seeding and for input/output) specified in this subclause.
2 At any given time,e has a stateei for some integeri≥0. Upon construction,e has an initial statee0. An
engine’s state may be established via a constructor, aseed function, assignment, or a suitableoperator>>.
3 E’s specification shall define:
—(3.1) the size ofE’s state in multiples of the size ofresult_type, given as an integral constant expression;
§ 29.5.3.4 © ISO/IEC
1743

===== PAGE 1755 =====

Dxxxx
—(3.2) the transition algorithmTA by whiche’s stateei is advanced to itssuccessor stateei+1; and
—(3.3) the generation algorithmGA by which an engine’s state is mapped to a value of typeresult_type.
4 A classEthat meets the requirements of a uniform random bit generator (29.5.3.3) also meets the requirements
of arandom number engineif the expressions shown in Table 127 are valid and have the indicated semantics,
and ifE also meets all other requirements of 29.5.3.4. In Table 127 and throughout this subclause:
—(4.1) T is the type named byE’s associatedresult_type;
—(4.2) e is a value ofE, v is an lvalue ofE, x and y are (possibly const) values ofE;
—(4.3) s is a value ofT;
—(4.4) q is an lvalue meeting the requirements of a seed sequence (29.5.3.2);
—(4.5) z is a value of typeunsigned long long;
—(4.6) os is an lvalue of the type of some class template specializationbasic_ostream<charT, traits>; and
—(4.7) is is an lvalue of the type of some class template specializationbasic_istream<charT, traits>;
where charT and traits are constrained according to Clause 27 and Clause 31.
Table 127 — Random number engine requirements [tab:rand.req.eng]
Expression Return type Pre/post-condition Complexity
E() Creates an engine with the same
initial state as all other
default-constructed engines of
type E.
O(size of state)
E(x) Creates an engine that compares
equal tox.
O(size of state)
E(s) Creates an engine with initial
state determined bys.
O(size of state)
E(q)232 Creates an engine with an initial
state that depends on a
sequence produced by one call
to q.generate.
same as
complexity of
q.generate
called on a
sequence whose
length is size of
state
e.seed() void Postconditions: e == E(). same as E()
e.seed(s) void Postconditions: e == E(s). same as E(s)
e.seed(q) void Postconditions: e == E(q). same as E(q)
e() T Advancese’s stateei to ei+1
= TA(ei) and returnsGA(ei).
per 29.5.3.3
e.discard(z)233 void Advancese’s stateei to ei+z by
any means equivalent toz
consecutive callse().
no worse than
the complexity
of z consecutive
calls e()
x == y bool This operator is an equivalence
relation. With Sx and Sy as the
infinite sequences of values that
would be generated by repeated
future calls tox() and y(),
respectively, returnstrue if
Sx = Sy; else returnsfalse.
O(size of state)
x != y bool !(x == y) . O(size of state)
232) This constructor (as well as the subsequent correspondingseed() function) can be particularly useful to applications
requiring a large number of independent random sequences.
233) This operation is common in user code, and can often be implemented in an engine-specific manner so as to provide
significant performance improvements over an equivalent naive loop that makesz consecutive callse().
§ 29.5.3.4 © ISO/IEC
1744

===== PAGE 1756 =====

Dxxxx
5 E shall meet theCpp17CopyConstructible (Table 32) andCpp17CopyAssignable (Table 34) requirements.
These operations shall each be of complexity no worse thanO(size of state).
6 On hosted implementations, the following expressions are well-formed and have the specified semantics.
os << x
7 Effects: With os.fmtflags set toios_base::dec|ios_base::left and the fill character set to the
space character, writes toos the textual representation ofx’s current state. In the output, adjacent
numbers are separated by one or more space characters.
8 Postconditions: The os.fmtflags and fill character are unchanged.
9 Result: reference to the type ofos.
10 Returns: os.
11 Complexity: O(size of state)
is >> v
12 Preconditions: is provides a textual representation that was previously written using an output stream
whose imbued locale was the same as that ofis, and whose type’s template specialization arguments
charT and traits were respectively the same as those ofis.
13 Effects: With is.fmtflags set toios_base::dec, setsv’s state as determined by reading its textual
representation fromis. If bad input is encountered, ensures thatv’s state is unchanged by the operation
and callsis.setstate(ios_base::failbit) (which may throwios_base::failure (31.5.4.4)). If a
textual representation written viaos << x was subsequently read viais >> v, thenx == v provided
that there have been no intervening invocations ofx or ofv.
14 Postconditions: The is.fmtflags are unchanged.
15 Result: reference to the type ofis.
16 Returns: is.
17 Complexity: O(size of state)
29.5.3.5 Random number engine adaptor requirements [rand.req.adapt]
1 A random number engine adaptor(commonly shortened toadaptor) a of typeA is a random number engine
that takes values produced by some other random number engine, and applies an algorithm to those values
in order to deliver a sequence of values with different randomness properties. An engineb of typeB adapted
in this way is termed abase enginein this context. The expressiona.base() shall be valid and shall return
a const reference toa’s base engine.
2 The requirements of a random number engine type shall be interpreted as follows with respect to a random
number engine adaptor type.
A::A();
3 Effects: The base engine is initialized as if by its default constructor.
bool operator==(const A& a1, const A& a2);
4 Returns: true if a1’s base engine is equal toa2’s base engine. Otherwise returnsfalse.
A::A(result_type s);
5 Effects: The base engine is initialized withs.
template<class Sseq> A::A(Sseq& q);
6 Effects: The base engine is initialized withq.
void seed();
7 Effects: With b as the base engine, invokesb.seed().
void seed(result_type s);
8 Effects: With b as the base engine, invokesb.seed(s).
§ 29.5.3.5 © ISO/IEC
1745

===== PAGE 1757 =====

Dxxxx
template<class Sseq> void seed(Sseq& q);
9 Effects: With b as the base engine, invokesb.seed(q).
10 A shall also meet the following additional requirements:
—(10.1) The complexity of each function shall not exceed the complexity of the corresponding function applied
to the base engine.
—(10.2) The state ofA shall include the state of its base engine. The size ofA’s state shall be no less than the
size of the base engine.
—(10.3) Copying A’s state (e.g., during copy construction or copy assignment) shall include copying the state of
the base engine ofA.
—(10.4) The textual representation ofA shall include the textual representation of its base engine.
29.5.3.6 Random number distribution requirements [rand.req.dist]
1 A random number distribution(commonly shortened todistribution) d of typeD is a function object returning
values that are distributed according to an associated mathematicalprobability density functionp(z) or
according to an associateddiscrete probability functionP(zi). A distribution’s specification identifies its
associated probability functionp(z) or P(zi).
2 An associated probability function is typically expressed using certain externally-supplied quantities known
as theparameters of the distribution. Such distribution parameters are identified in this context by writing,
for example,p(z|a,b) or P(zi|a,b), to name specific parameters, or by writing, for example,p(z|{p}) or
P(zi|{p}), to denote a distribution’s parametersp taken as a whole.
3 A classD meets the requirements of arandom number distributionif the expressions shown in Table 128 are
valid and have the indicated semantics, and ifD and its associated types also meet all other requirements of
29.5.3.6. In Table 128 and throughout this subclause,
—(3.1) T is the type named byD’s associatedresult_type;
—(3.2) P is the type named byD’s associatedparam_type;
—(3.3) d is a value ofD, andx and y are (possibly const) values ofD;
—(3.4) glb and lub are values ofT respectively corresponding to the greatest lower bound and the least upper
bound on the values potentially returned byd’s operator(), as determined by the current values of
d’s parameters;
—(3.5) p is a (possibly const) value ofP;
—(3.6) g, g1, andg2 are lvalues of a type meeting the requirements of a uniform random bit generator (29.5.3.3);
—(3.7) os is an lvalue of the type of some class template specializationbasic_ostream<charT, traits>; and
—(3.8) is is an lvalue of the type of some class template specializationbasic_istream<charT, traits>;
where charT and traits are constrained according to Clause 27 and Clause 31.
Table 128 — Random number distribution requirements [tab:rand.req.dist]
Expression Return type Pre/post-condition Complexity
D::result_type T T is an arithmetic type (6.9.2).
D::param_type P
D() Creates a distribution whose
behavior is indistinguishable
from that of any other newly
default-constructed distribution
of typeD.
constant
D(p) Creates a distribution whose
behavior is indistinguishable
from that of a distribution
newly constructed directly from
the values used to constructp.
same asp’s
construction
§ 29.5.3.6 © ISO/IEC
1746

===== PAGE 1758 =====

Dxxxx
Table 128 — Random number distribution requirements (continued)
Expression Return type Pre/post-condition Complexity
d.reset() void Subsequent uses ofd do not
depend on values produced by
any engine prior to invoking
reset.
constant
x.param() P Returns a valuep such that
D(p).param() == p.
no worse than
the complexity
of D(p)
d.param(p) void Postconditions: d.param() ==
p.
no worse than
the complexity
of D(p)
d(g) T With p = d.param(), the
sequence of numbers returned by
successive invocations with the
same objectg is randomly
distributed according to the
associated p(z|{p}) or
P(zi|{p}) function.
amortized
constant
number of
invocations ofg
d(g,p) T The sequence of numbers
returned by successive
invocations with the same
objects g and p is randomly
distributed according to the
associated p(z|{p}) or
P(zi|{p}) function.
amortized
constant
number of
invocations ofg
x.min() T Returns glb. constant
x.max() T Returns lub. constant
x == y bool This operator is an equivalence
relation. Returns true if
x.param() == y.param() and
S1 = S2, whereS1 and S2 are
the infinite sequences of values
that would be generated,
respectively, by repeated future
calls tox(g1) and y(g2)
whenever g1 == g2. Otherwise
returns false.
constant
x != y bool !(x == y) . same asx == y.
4 D shall meet theCpp17CopyConstructible (Table 32) andCpp17CopyAssignable (Table 34) requirements.
5 The sequence of numbers produced by repeated invocations ofd(g) shall be independent of any invocation
of os << d or of anyconst member function ofD between any of the invocations ofd(g).
6 If a textual representation is written usingos << x and that representation is restored into the same or
a different objecty of the same type usingis >> y, repeated invocations ofy(g) shall produce the same
sequence of numbers as would repeated invocations ofx(g).
7 It is unspecified whetherD::param_typeis declared as a (nested)classor via atypedef. In 29.5, declarations
of D::param_type are in the form oftypedefs for convenience of exposition only.
8 P shall meet theCpp17CopyConstructible (Table 32),Cpp17CopyAssignable (Table 34), andCpp17Equality-
Comparable (Table 28) requirements.
9 For each of the constructors ofD taking arguments corresponding to parameters of the distribution,P shall
have a corresponding constructor subject to the same requirements and taking arguments identical in number,
type, and default values. Moreover, for each of the member functions ofD that return values corresponding
to parameters of the distribution,P shall have a corresponding member function with the identical name,
type, and semantics.
§ 29.5.3.6 © ISO/IEC
1747

===== PAGE 1759 =====

Dxxxx
10 P shall have a declaration of the form
using distribution_type = D;
11 On hosted implementations, the following expressions are well-formed and have the specified semantics.
os << x
12 Effects: Writes toos a textual representation for the parameters and the additional internal data ofx.
13 Postconditions: The os.fmtflags and fill character are unchanged.
14 Result: reference to the type ofos.
15 Returns: os.
is >> d
16 Preconditions: is provides a textual representation that was previously written using anos whose
imbued locale and whose type’s template specialization argumentscharT and traits were the same as
those ofis.
17 Effects: Restores fromis the parameters and additional internal data of the lvalued. If bad input is
encountered, ensures thatdis unchanged by the operation and callsis.setstate(ios_base::failbit)
(which may throwios_base::failure (31.5.4.4)).
18 Postconditions: The is.fmtflags are unchanged.
19 Result: reference to the type ofis.
20 Returns: is.
29.5.4 Random number engine class templates [rand.eng]
29.5.4.1 General [rand.eng.general]
1 Each type instantiated from a class template specified in 29.5.4 meets the requirements of a random number
engine (29.5.3.4) type.
2 Except where specified otherwise, the complexity of each function specified in 29.5.4 is constant.
3 Except where specified otherwise, no function described in 29.5.4 throws an exception.
4 Every function described in 29.5.4 that has a function parameterqof typeSseq&for a template type parameter
named Sseq that is different from typeseed_seq throws what and when the invocation ofq.generate
throws.
5 Descriptions are provided in 29.5.4 only for engine operations that are not described in 29.5.3.4 or for
operations where there is additional semantic information. In particular, declarations for copy constructors,
for copy assignment operators, for streaming operators, and for equality and inequality operators are not
shown in the synopses.
6 Each template specified in 29.5.4 requires one or more relationships, involving the value(s) of its constant
template parameter(s), to hold. A program instantiating any of these templates is ill-formed if any such
required relationship fails to hold.
7 For every random number engine and for every random number engine adaptorX defined in 29.5.4 and in
29.5.5:
—(7.1) if the constructor
template<class Sseq> explicit X(Sseq& q);
is called with a typeSseq that does not qualify as a seed sequence, then this constructor shall not
participate in overload resolution;
—(7.2) if the member function
template<class Sseq> void seed(Sseq& q);
is called with a typeSseq that does not qualify as a seed sequence, then this function shall not
participate in overload resolution.
The extent to which an implementation determines that a type cannot be a seed sequence is unspecified,
except that as a minimum a type shall not qualify as a seed sequence if it is implicitly convertible to
X::result_type.
§ 29.5.4.1 © ISO/IEC
1748

===== PAGE 1760 =====

Dxxxx
29.5.4.2 Class template linear_congruential_engine [rand.eng.lcong]
1 A linear_congruential_engine random number engine produces unsigned integer random numbers. The
state xi of alinear_congruential_engineobject xis of size1 and consists of a single integer. The transition
algorithm is a modular linear function of the formTA(xi) = (a·xi + c) mod m; the generation algorithm is
GA(xi) = xi+1.
namespace std {
template<class UIntType, UIntType a, UIntType c, UIntType m>
class linear_congruential_engine {
public:
// types
using result_type = UIntType;
// engine characteristics
static constexpr result_type multiplier = a;
static constexpr result_type increment = c;
static constexpr result_type modulus = m;
static constexpr result_type min() { return c == 0u ? 1u: 0u; }
static constexpr result_type max() { return m - 1u; }
static constexpr result_type default_seed = 1u;
// constructors and seeding functions
linear_congruential_engine() : linear_congruential_engine(default_seed) {}
explicit linear_congruential_engine(result_type s);
template<class Sseq> explicit linear_congruential_engine(Sseq& q);
void seed(result_type s = default_seed);
template<class Sseq> void seed(Sseq& q);
// equality operators
friend bool operator==(const linear_congruential_engine& x,
const linear_congruential_engine& y);
// generating functions
result_type operator()();
void discard(unsigned long long z);
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, // hosted
const linear_congruential_engine& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, // hosted
linear_congruential_engine& x);
};
}
2 If the template parameterm is 0, the modulusm used throughout 29.5.4.2 isnumeric_limits<result_-
type>::max() plus 1.
[Note 1: m need not be representable as a value of typeresult_type. —end note]
3 If the template parameterm is not0, the following relations shall hold:a < m and c < m.
4 The textual representation consists of the value ofxi.
explicit linear_congruential_engine(result_type s);
5 Effects: If cmod mis 0 and s mod mis 0, sets the engine’s state to1, otherwise sets the engine’s state
to s mod m.
template<class Sseq> explicit linear_congruential_engine(Sseq& q);
6 Effects: With k=
⌈
log2 m
32
⌉
and a an array (or equivalent) of lengthk+ 3, invokesq.generate(a+ 0,
a+ k+ 3) and then computesS =
(∑k−1
j=0 aj+3 ·232j
)
mod m. If cmod m is 0 and S is 0, sets the
§ 29.5.4.2 © ISO/IEC
1749

===== PAGE 1761 =====

Dxxxx
engine’s state to1, else sets the engine’s state toS.
29.5.4.3 Class template mersenne_twister_engine [rand.eng.mers]
1 A mersenne_twister_engine random number engine234 produces unsigned integer random numbers in the
closed interval[0,2w −1]. The statexi of amersenne_twister_engine object x is of sizen and consists of
a sequenceX of n values of the type delivered byx; all subscripts applied toX are to be taken modulon.
2 The transition algorithm employs a twisted generalized feedback shift register defined by shift valuesn and
m, a twist valuer, and a conditional xor-maska. To improve the uniformity of the result, the bits of the
raw shift register are additionallytempered (i.e., scrambled) according to a bit-scrambling matrix defined by
values u, d, s, b, t, c, andℓ.
The state transition is performed as follows:
—(2.1) Concatenate the upperw−rbits ofXi−n with the lowerrbits ofXi+1−n to obtain an unsigned integer
value Y.
—(2.2) With α= a·(Y bitand 1), setXi to Xi+m−n xor (Y rshift 1) xor α.
The sequenceX is initialized with the help of an initialization multiplierf.
3 The generation algorithm determines the unsigned integer valuesz1,z2,z3,z4 as follows, then deliversz4 as
its result:
—(3.1) Let z1 = Xi xor
(
(Xi rshift u) bitand d
)
.
—(3.2) Let z2 = z1 xor
(
(z1 lshiftw s) bitand b
)
.
—(3.3) Let z3 = z2 xor
(
(z2 lshiftw t) bitand c
)
.
—(3.4) Let z4 = z3 xor (z3 rshift ℓ).
namespace std {
template<class UIntType, size_t w, size_t n, size_t m, size_t r,
UIntType a, size_t u, UIntType d, size_t s,
UIntType b, size_t t,
UIntType c, size_t l, UIntType f>
class mersenne_twister_engine {
public:
// types
using result_type = UIntType;
// engine characteristics
static constexpr size_t word_size = w;
static constexpr size_t state_size = n;
static constexpr size_t shift_size = m;
static constexpr size_t mask_bits = r;
static constexpr UIntType xor_mask = a;
static constexpr size_t tempering_u = u;
static constexpr UIntType tempering_d = d;
static constexpr size_t tempering_s = s;
static constexpr UIntType tempering_b = b;
static constexpr size_t tempering_t = t;
static constexpr UIntType tempering_c = c;
static constexpr size_t tempering_l = l;
static constexpr UIntType initialization_multiplier = f;
static constexpr result_type min() { return 0; }
static constexpr result_type max() { return 2w −1; }
static constexpr result_type default_seed = 5489u;
// constructors and seeding functions
mersenne_twister_engine() : mersenne_twister_engine(default_seed) {}
explicit mersenne_twister_engine(result_type value);
template<class Sseq> explicit mersenne_twister_engine(Sseq& q);
void seed(result_type value = default_seed);
template<class Sseq> void seed(Sseq& q);
234) The name of this engine refers, in part, to a property of its period: For properly-selected values of the parameters, the
period is closely related to a large Mersenne prime number.
§ 29.5.4.3 © ISO/IEC
1750

===== PAGE 1762 =====

Dxxxx
// equality operators
friend bool operator==(const mersenne_twister_engine& x, const mersenne_twister_engine& y);
// generating functions
result_type operator()();
void discard(unsigned long long z);
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, // hosted
const mersenne_twister_engine& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, // hosted
mersenne_twister_engine& x);
};
}
4 The following relations shall hold:0 < m, m <= n, 2u < w, r <= w, u <= w, s <= w, t <= w, l <= w, w <=
numeric_limits<UIntType>::digits, a <= (1u << w) - 1u, b <= (1u << w) - 1u, c <= (1u << w) -
1u, d <= (1u << w) - 1u, andf <= (1u << w) - 1u.
5 The textual representation ofxi consists of the values ofXi−n,...,X i−1, in that order.
explicit mersenne_twister_engine(result_type value);
6 Effects: Sets X−n to value mod 2w. Then, iteratively fori= 1 −n,..., −1, setsXi to
[
f ·
(
Xi−1 xor
(
Xi−1 rshift (w−2)
))
+ imod n
]
mod 2w .
7 Complexity: O(n).
template<class Sseq> explicit mersenne_twister_engine(Sseq& q);
8 Effects: With k = ⌈w/32⌉and a an array (or equivalent) of lengthn·k, invokesq.generate(a+ 0,
a+ n·k) and then, iteratively fori= −n,..., −1, setsXi to
(∑k−1
j=0 ak(i+n)+j ·232j
)
mod 2w. Finally,
if the most significantw−r bits ofX−n are zero, and if each of the other resultingXi is 0, changes
X−n to 2w−1.
29.5.4.4 Class template subtract_with_carry_engine [rand.eng.sub]
1 A subtract_with_carry_engine random number engine produces unsigned integer random numbers.
2 The statexi of asubtract_with_carry_engine object x is of sizeO(r), and consists of a sequenceX of
r integer values0 ≤Xi < m= 2w; all subscripts applied toX are to be taken modulor. The state xi
additionally consists of an integerc (known as thecarry) whose value is either0 or 1.
3 The state transition is performed as follows:
—(3.1) Let Y = Xi−s −Xi−r −c.
—(3.2) Set Xi to y= Y mod m. Set c to 1 ifY <0, otherwise setc to 0.
[Note 1: This algorithm corresponds to a modular linear function of the formTA(xi) = (a·xi) mod b, whereb is of
the formmr −ms + 1and a= b−(b−1)/m. —end note]
4 The generation algorithm is given byGA(xi) = y, wherey is the value produced as a result of advancing the
engine’s state as described above.
namespace std {
template<class UIntType, size_t w, size_t s, size_t r>
class subtract_with_carry_engine {
public:
// types
using result_type = UIntType;
// engine characteristics
static constexpr size_t word_size = w;
§ 29.5.4.4 © ISO/IEC
1751

===== PAGE 1763 =====

Dxxxx
static constexpr size_t short_lag = s;
static constexpr size_t long_lag = r;
static constexpr result_type min() { return 0; }
static constexpr result_type max() { return m−1; }
static constexpr uint_least32_t default_seed = 19780503u;
// constructors and seeding functions
subtract_with_carry_engine() : subtract_with_carry_engine(0u) {}
explicit subtract_with_carry_engine(result_type value);
template<class Sseq> explicit subtract_with_carry_engine(Sseq& q);
void seed(result_type value = 0u);
template<class Sseq> void seed(Sseq& q);
// equality operators
friend bool operator==(const subtract_with_carry_engine& x,
const subtract_with_carry_engine& y);
// generating functions
result_type operator()();
void discard(unsigned long long z);
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, // hosted
const subtract_with_carry_engine& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, // hosted
subtract_with_carry_engine& x);
};
}
5 The following relations shall hold:0u < s, s < r, 0 < w, andw <= numeric_limits<UIntType>::digits.
6 The textual representation consists of the values ofXi−r,...,X i−1, in that order, followed byc.
explicit subtract_with_carry_engine(result_type value);
7 Effects: Sets the values ofX−r,...,X −1, in that order, as specified below. IfX−1 is then0, setscto 1;
otherwise setsc to 0.
To set the valuesXk, first constructe, alinear_congruential_engine object, as if by the following
definition:
linear_congruential_engine<uint_least32_t, 40014u, 0u, 2147483563u> e(
value == 0u ? default_seed : static_cast<uint_least32_t>(value % 2147483563u));
Then, to set eachXk, obtain new valuesz0,...,z n−1 from n= ⌈w/32⌉successive invocations ofe. Set
Xk to
(∑n−1
j=0 zj ·232j
)
mod m.
8 Complexity: Exactly n·r invocations ofe.
template<class Sseq> explicit subtract_with_carry_engine(Sseq& q);
9 Effects: With k = ⌈w/32⌉and a an array (or equivalent) of lengthr·k, invokesq.generate(a+ 0,
a+ r·k) and then, iteratively fori= −r,..., −1, setsXi to
(∑k−1
j=0 ak(i+r)+j ·232j
)
mod m. If X−1
is then0, setsc to 1; otherwise setsc to 0.
29.5.4.5 Class template philox_engine [rand.eng.philox]
1 A philox_engine random number engine produces unsigned integer random numbers in the interval[0,m),
where m= 2w and the template parameterw defines the range of the produced numbers. The state of a
philox_engine object consists of a sequenceX of n unsigned integer values of widthw, a sequenceK of
n/2 values ofresult_type, a sequenceY of n values ofresult_type, and a scalari, where
—(1.1) X is the interpretation of the unsigned integercounter value Z := ∑n−1
j=0 Xj ·2wj of n·w bits,
§ 29.5.4.5 © ISO/IEC
1752

===== PAGE 1764 =====

Dxxxx
—(1.2) K are keys, which are generated once from the seed (see constructors below) and remain constant
unless theseed function (29.5.3.4) is invoked,
—(1.3) Y stores a batch of output values, and
—(1.4) i is an index for an element of the sequenceY.
2 The generation algorithm returnsYi, the value stored in theith element ofY after applying the transition
algorithm.
3 The state transition is performed as if by the following algorithm:
i = i + 1
if (i == n) {
Y = Philox(K, X) // see below
Z = Z + 1
i = 0
}
4 The Philox function maps the length-n/2 sequence K and the length-n sequence X into a length-n output
sequence Y. Philox applies anr-round substitution-permutation network to the values inX. A single round
of the generation algorithm performs the following steps:
—(4.1) The output sequenceX′of the previous round (X in case of the first round) is permuted to obtain the
intermediate stateV:
Vj = X′
fn(j)
where j = 0,...,n −1 and fn(j) is defined in Table 129.
Table 129 — Values for the word permutationfn(j) [tab:rand.eng.philox.f]
fn(j) j
0 1 2 3
n 2 0 1
4 2 1 0 3
[Note 1: Forn= 2the sequence is not permuted.—end note]
—(4.2) The following computations are applied to the elements of theV sequence:
X2k+0 = mulhi(V2k,Mk,w) xor keyq
k xor V2k+1
X2k+1 = mullo(V2k,Mk,w)
where:
—(4.2.1) mullo(a,b,w) is the low half of the modular multiplication ofa and b: (a·b) mod 2 w,
—(4.2.2) mulhi(a,b,w) is the high half of the modular multiplication ofa and b: (⌊(a·b)/2w⌋),
—(4.2.3) k= 0,...,n/ 2 −1 is the index in the sequences,
—(4.2.4) q= 0,...,r −1 is the index of the round,
—(4.2.5) keyq
k is thekth round key for roundq, keyq
k := (Kk + q·Ck) mod 2 w,
—(4.2.6) Kk are the elements of the key sequenceK,
—(4.2.7) Mk is multipliers[k], and
—(4.2.8) Ck is round_consts[k].
5 After r applications of the single-round function,Philox returns the sequenceY = X′.
namespace std {
template<class UIntType, size_t w, size_t n, size_t r, UIntType... consts>
class philox_engine {
static constexpr size_t array-size = n / 2; // exposition only
public:
// types
using result_type = UIntType;
§ 29.5.4.5 © ISO/IEC
1753

===== PAGE 1765 =====

Dxxxx
// engine characteristics
static constexpr size_t word_size = w;
static constexpr size_t word_count = n;
static constexpr size_t round_count = r;
static constexpr array<result_type, array-size > multipliers;
static constexpr array<result_type, array-size> round_consts;
static constexpr result_type min() { return 0; }
static constexpr result_type max() { return m - 1; }
static constexpr result_type default_seed = 20111115u;
// constructors and seeding functions
philox_engine() : philox_engine(default_seed) {}
explicit philox_engine(result_type value);
template<class Sseq> explicit philox_engine(Sseq& q);
void seed(result_type value = default_seed);
template<class Sseq> void seed(Sseq& q);
void set_counter(const array<result_type, n>& counter);
// equality operators
friend bool operator==(const philox_engine& x, const philox_engine& y);
// generating functions
result_type operator()();
void discard(unsigned long long z);
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const philox_engine& x); // hosted
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, philox_engine& x); // hosted
};
}
6 Mandates:
—(6.1) sizeof...(consts) == n is true, and
—(6.2) n == 2 || n == 4 is true, and
—(6.3) 0 < r is true, and
—(6.4) 0 < w && w <= numeric_limits<UIntType>::digits is true.
7 The template parameter packconsts represents theMk and Ck constants which are grouped as follows:
[M0,C0,M1,C1,M2,C2,...,M n/2−1,Cn/2−1].
8 The textual representation consists of the values ofK0,...,K n/2−1,X0,...,X n−1,i, in that order.
[Note 2: The stream extraction operator can reconstructY from K and X, as needed. —end note]
explicit philox_engine(result_type value);
9 Effects: Sets theK0 element of sequenceK to value mod 2w. All elements of sequencesX and K
(except K0) are set to0. The value ofi is set ton−1.
template<class Sseq> explicit philox_engine(Sseq& q);
10 Effects: Withp= ⌈w/32⌉and an array (or equivalent)a of length(n/2)·p, invokesq.generate(a + 0,
a + n / 2 * p) and then iteratively fork= 0,...,n/ 2 −1, setsKk to
(∑p−1
j=0 akp+j ·232j
)
mod 2w.
All elements of sequenceX are set to0. The value ofi is set ton−1.
void set_counter(const array<result_type, n>& c);
11 Effects: Forj = 0,...,n −1 sets Xj to Cn−1−j mod 2w. The value ofi is set ton−1.
[Note 3: The counter is the valueZ introduced at the beginning of this subclause.—end note]
§ 29.5.4.5 © ISO/IEC
1754

===== PAGE 1766 =====

Dxxxx
29.5.5 Random number engine adaptor class templates [rand.adapt]
29.5.5.1 General [rand.adapt.general]
1 Each type instantiated from a class template specified in 29.5.5 meets the requirements of a random number
engine adaptor (29.5.3.5) type.
2 Except where specified otherwise, the complexity of each function specified in 29.5.5 is constant.
3 Except where specified otherwise, no function described in 29.5.5 throws an exception.
4 Every function described in 29.5.5 that has a function parameterqof typeSseq&for a template type parameter
named Sseq that is different from typeseed_seq throws what and when the invocation ofq.generate
throws.
5 Descriptions are provided in 29.5.5 only for adaptor operations that are not described in subclause 29.5.3.5 or
for operations where there is additional semantic information. In particular, declarations for copy constructors,
for copy assignment operators, for streaming operators, and for equality and inequality operators are not
shown in the synopses.
6 Each template specified in 29.5.5 requires one or more relationships, involving the value(s) of its constant
template parameter(s), to hold. A program instantiating any of these templates is ill-formed if any such
required relationship fails to hold.
29.5.5.2 Class template discard_block_engine [rand.adapt.disc]
1 A discard_block_engine random number engine adaptor produces random numbers selected from those
produced by some base enginee. The statexi of adiscard_block_engine engine adaptor objectx consists
of the stateei of its base enginee and an additional integern. The size of the state is the size ofe’s state
plus 1.
2 The transition algorithm discards all butr> 0 values from each block ofp≥r values delivered bye. The
state transition is performed as follows: Ifn≥r, advance the state ofe from ei to ei+p−r and setn to 0. In
any case, then incrementn and advancee’s then-current stateej to ej+1.
3 The generation algorithm yields the value returned by the last invocation ofe() while advancinge’s state as
described above.
namespace std {
template<class Engine, size_t p, size_t r>
class discard_block_engine {
public:
// types
using result_type = Engine::result_type;
// engine characteristics
static constexpr size_t block_size = p;
static constexpr size_t used_block = r;
static constexpr result_type min() { return Engine::min(); }
static constexpr result_type max() { return Engine::max(); }
// constructors and seeding functions
discard_block_engine();
explicit discard_block_engine(const Engine& e);
explicit discard_block_engine(Engine&& e);
explicit discard_block_engine(result_type s);
template<class Sseq> explicit discard_block_engine(Sseq& q);
void seed();
void seed(result_type s);
template<class Sseq> void seed(Sseq& q);
// equality operators
friend bool operator==(const discard_block_engine& x, const discard_block_engine& y);
// generating functions
result_type operator()();
void discard(unsigned long long z);
§ 29.5.5.2 © ISO/IEC
1755

===== PAGE 1767 =====

Dxxxx
// property functions
const Engine& base() const noexcept { return e; }
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const discard_block_engine& x); // hosted
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, discard_block_engine& x); // hosted
private:
Engine e; // exposition only
size_t n; // exposition only
};
}
4 The following relations shall hold:0 < r and r <= p.
5 The textual representation consists of the textual representation ofe followed by the value ofn.
6 In addition to its behavior pursuant to subclause 29.5.3.5, each constructor that is not a copy constructor
sets n to 0.
29.5.5.3 Class template independent_bits_engine [rand.adapt.ibits]
1 An independent_bits_engine random number engine adaptor combines random numbers that are produced
by some base enginee, so as to produce random numbers with a specified number of bitsw. The statexi of
an independent_bits_engine engine adaptor objectx consists of the stateei of its base enginee; the size
of the state is the size ofe’s state.
2 The transition and generation algorithms are described in terms of the following integral constants:
—(2.1) Let R= e.max() - e.min() + 1 and m= ⌊log2 R⌋.
—(2.2) With n as determined below, let w0 = ⌊w/n⌋, n0 = n−wmod n, y0 = 2 w0 ⌊R/2w0 ⌋, and y1 =
2w0+1 ⌊
R/2w0+1⌋
.
—(2.3) Let n= ⌈w/m⌉if and only if the relationR−y0 ≤⌊y0/n⌋holds as a result. Otherwise letn= 1+⌈w/m⌉.
[Note 1: The relationw= n0w0 + (n−n0)(w0 + 1)always holds. —end note]
3 The transition algorithm is carried out by invokinge() as often as needed to obtainn0 values less than
y0 + e.min() and n−n0 values less thany1 + e.min().
4 The generation algorithm uses the values produced while advancing the state as described above to yield a
quantity S obtained as if by the following algorithm:
S = 0;
for (k = 0; k̸= n0; k += 1) {
do u = e() - e.min(); while (u≥y0);
S = 2w0 ·S+ umod 2w0 ;
}
for (k = n0; k̸= n; k += 1) {
do u = e() - e.min(); while (u≥y1);
S = 2w0+1 ·S+ umod 2w0+1;
}
namespace std {
template<class Engine, size_t w, class UIntType>
class independent_bits_engine {
public:
// types
using result_type = UIntType;
// engine characteristics
static constexpr result_type min() { return 0; }
static constexpr result_type max() { return 2w −1; }
§ 29.5.5.3 © ISO/IEC
1756

===== PAGE 1768 =====

Dxxxx
// constructors and seeding functions
independent_bits_engine();
explicit independent_bits_engine(const Engine& e);
explicit independent_bits_engine(Engine&& e);
explicit independent_bits_engine(result_type s);
template<class Sseq> explicit independent_bits_engine(Sseq& q);
void seed();
void seed(result_type s);
template<class Sseq> void seed(Sseq& q);
// equality operators
friend bool operator==(const independent_bits_engine& x, const independent_bits_engine& y);
// generating functions
result_type operator()();
void discard(unsigned long long z);
// property functions
const Engine& base() const noexcept { return e; }
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const independent_bits_engine& x); // hosted
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, independent_bits_engine& x); // hosted
private:
Engine e; // exposition only
};
}
5 The following relations shall hold:0 < w and w <= numeric_limits<result_type>::digits.
6 The textual representation consists of the textual representation ofe.
29.5.5.4 Class template shuffle_order_engine [rand.adapt.shuf]
1 A shuffle_order_engine random number engine adaptor produces the same random numbers that are
produced by some base enginee, but delivers them in a different sequence. The statexi of a shuffle_-
order_engine engine adaptor objectx consists of the stateei of its base enginee, an additional valueY of
the type delivered bye, and an additional sequenceV of k values also of the type delivered bye. The size of
the state is the size ofe’s state plusk+ 1.
2 The transition algorithm permutes the values produced bye. The state transition is performed as follows:
—(2.1) Calculate an integerj =
⌊
k·(Y−emin)
emax−emin+1
⌋
.
—(2.2) Set Y to Vj and then setVj to e().
3 The generation algorithm yields the last value ofY produced while advancinge’s state as described above.
namespace std {
template<class Engine, size_t k>
class shuffle_order_engine {
public:
// types
using result_type = Engine::result_type;
// engine characteristics
static constexpr size_t table_size = k;
static constexpr result_type min() { return Engine::min(); }
static constexpr result_type max() { return Engine::max(); }
// constructors and seeding functions
shuffle_order_engine();
§ 29.5.5.4 © ISO/IEC
1757

===== PAGE 1769 =====

Dxxxx
explicit shuffle_order_engine(const Engine& e);
explicit shuffle_order_engine(Engine&& e);
explicit shuffle_order_engine(result_type s);
template<class Sseq> explicit shuffle_order_engine(Sseq& q);
void seed();
void seed(result_type s);
template<class Sseq> void seed(Sseq& q);
// equality operators
friend bool operator==(const shuffle_order_engine& x, const shuffle_order_engine& y);
// generating functions
result_type operator()();
void discard(unsigned long long z);
// property functions
const Engine& base() const noexcept { return e; }
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const shuffle_order_engine& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, shuffle_order_engine& x);
private:
Engine e; // exposition only
result_type V[k]; // exposition only
result_type Y; // exposition only
};
}
4 The following relation shall hold:0 < k.
5 The textual representation consists of the textual representation ofe, followed by thek values ofV, followed
by the value ofY.
6 In addition to its behavior pursuant to subclause 29.5.3.5, each constructor that is not a copy constructor
initializes V[0],..., V[k - 1] and Y, in that order, with values returned by successive invocations ofe().
29.5.6 Engines and engine adaptors with predefined parameters [rand.predef]
using minstd_rand0 =
linear_congruential_engine<uint_fast32_t, 16’807, 0, 2’147’483’647>;
1 Required behavior: The 10000th consecutive invocation of a default-constructed object of typeminstd_-
rand0 produces the value1043618065.
using minstd_rand =
linear_congruential_engine<uint_fast32_t, 48’271, 0, 2’147’483’647>;
2 Required behavior: The 10000th consecutive invocation of a default-constructed object of typeminstd_-
rand produces the value399268537.
using mt19937 =
mersenne_twister_engine<uint_fast32_t, 32, 624, 397, 31,
0x9908’b0df, 11, 0xffff’ffff, 7, 0x9d2c’5680, 15, 0xefc6’0000, 18, 1’812’433’253>;
3 Required behavior: The 10000th consecutive invocation of a default-constructed object of typemt19937
produces the value4123659995.
using mt19937_64 =
mersenne_twister_engine<uint_fast64_t, 64, 312, 156, 31,
0xb502’6f5a’a966’19e9, 29, 0x5555’5555’5555’5555, 17,
0x71d6’7fff’eda6’0000, 37, 0xfff7’eee0’0000’0000, 43, 6’364’136’223’846’793’005>;
§ 29.5.6 © ISO/IEC
1758

===== PAGE 1770 =====

Dxxxx
4 Required behavior: The10000th consecutive invocation of a default-constructed object of typemt19937_-
64 produces the value9981545732273789042.
using ranlux24_base =
subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>;
5 Required behavior: The 10000th consecutive invocation of a default-constructed object of typeran-
lux24_base produces the value7937952.
using ranlux48_base =
subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>;
6 Required behavior: The 10000th consecutive invocation of a default-constructed object of typeran-
lux48_base produces the value61839128582725.
using ranlux24 = discard_block_engine<ranlux24_base, 223, 23>;
7 Required behavior: The10000th consecutive invocation of a default-constructed object of typeranlux24
produces the value9901578.
using ranlux48 = discard_block_engine<ranlux48_base, 389, 11>;
8 Required behavior: The10000th consecutive invocation of a default-constructed object of typeranlux48
produces the value249142670248501.
using knuth_b = shuffle_order_engine<minstd_rand0,256>;
9 Required behavior: The 10000th consecutive invocation of a default-constructed object of typeknuth_b
produces the value1112339016.
using default_random_engine = implementation-defined ;
10 Remarks: The choice of engine type named by thistypedef is implementation-defined.
[Note 1: The implementation can select this type on the basis of performance, size, quality, or any combination
of such factors, so as to provide at least acceptable engine behavior for relatively casual, inexpert, and/or
lightweight use. Because different implementations can select different underlying engine types, code that uses
this typedef need not generate identical sequences across implementations.—end note]
using philox4x32 =
philox_engine<uint_fast32_t, 32, 4, 10,
0xCD9E8D57, 0x9E3779B9, 0xD2511F53, 0xBB67AE85>;
11 Required behavior: The10000th consecutive invocation a default-constructed object of typephilox4x32
produces the value1955073260.
using philox4x64 =
philox_engine<uint_fast64_t, 64, 4, 10,
0xCA5A826395121157, 0x9E3779B97F4A7C15, 0xD2E7470EE14C6C93, 0xBB67AE8584CAA73B>;
12 Required behavior: The10000th consecutive invocation a default-constructed object of typephilox4x64
produces the value3409172418970261260.
29.5.7 Class random_device [rand.device]
1 A random_device uniform random bit generator produces nondeterministic random numbers.
2 If implementation limitations prevent generating nondeterministic random numbers, the implementation may
employ a random number engine.
namespace std {
class random_device {
public:
// types
using result_type = unsigned int;
// generator characteristics
static constexpr result_type min() { return numeric_limits<result_type>::min(); }
static constexpr result_type max() { return numeric_limits<result_type>::max(); }
§ 29.5.7 © ISO/IEC
1759

===== PAGE 1771 =====

Dxxxx
// constructors
random_device() : random_device(implementation-defined ) {}
explicit random_device(const string& token);
// generating functions
result_type operator()();
// property functions
double entropy() const noexcept;
// no copy functions
random_device(const random_device&) = delete;
void operator=(const random_device&) = delete;
};
}
explicit random_device(const string& token);
3 Throws: A value of an implementation-defined type derived fromexception if therandom_device
cannot be initialized.
4 Remarks: The semantics of thetoken parameter and the token value used by the default constructor
are implementation-defined.235
double entropy() const noexcept;
5 Returns: If the implementation employs a random number engine, returns0.0. Otherwise, returns
an entropy estimate236 for the random numbers returned byoperator(), in the range min() to
log2(max()+ 1).
result_type operator()();
6 Returns: A nondeterministic random value, uniformly distributed betweenmin() and max() (inclusive).
It is implementation-defined how these values are generated.
7 Throws: A value of an implementation-defined type derived fromexception if a random number
cannot be obtained.
29.5.8 Utilities [rand.util]
29.5.8.1 Class seed_seq [rand.util.seedseq]
namespace std {
class seed_seq {
public:
// types
using result_type = uint_least32_t;
// constructors
seed_seq() noexcept;
template<class T>
seed_seq(initializer_list<T> il);
template<class InputIterator>
seed_seq(InputIterator begin, InputIterator end);
// generating functions
template<class RandomAccessIterator>
void generate(RandomAccessIterator begin, RandomAccessIterator end);
// property functions
size_t size() const noexcept;
template<class OutputIterator>
void param(OutputIterator dest) const;
235) The parameter is intended to allow an implementation to differentiate between different sources of randomness.
236) If a device hasn states whose respective probabilities areP0, . . . , Pn−1, the device entropyS is defined as
S = −
∑n−1
i=0 Pi ·log Pi.
§ 29.5.8.1 © ISO/IEC
1760

===== PAGE 1772 =====

Dxxxx
// no copy functions
seed_seq(const seed_seq&) = delete;
void operator=(const seed_seq&) = delete;
private:
vector<result_type> v; // exposition only
};
}
seed_seq() noexcept;
1 Postconditions: v.empty() is true.
template<class T>
seed_seq(initializer_list<T> il);
2 Constraints: T is an integer type.
3 Effects: Same asseed_seq(il.begin(), il.end()).
template<class InputIterator>
seed_seq(InputIterator begin, InputIterator end);
4 Mandates: iterator_traits<InputIterator>::value_type is an integer type.
5 Preconditions: InputIterator meets theCpp17InputIterator requirements (24.3.5.3).
6 Effects: Initializes v by the following algorithm:
for (InputIterator s = begin; s != end; ++s)
v.push_back((*s)mod232);
template<class RandomAccessIterator>
void generate(RandomAccessIterator begin, RandomAccessIterator end);
7 Mandates: iterator_traits<RandomAccessIterator>::value_type is an unsigned integer type ca-
pable of accommodating 32-bit quantities.
8 Preconditions: RandomAccessIterator meets theCpp17RandomAccessIteratorrequirements (24.3.5.7)
and the requirements of a mutable iterator.
9 Effects: Does nothing if begin == end. Otherwise, with s = v.size() and n = end−begin, fills
the supplied range[begin,end) according to the following algorithm in which each operation is to be
carried out modulo232, each indexing operator applied tobegin is to be taken modulon, andT(x) is
defined asxxor (xrshift 27):
—(9.1) By way of initialization, set each element of the range to the value0x8b8b8b8b. Additionally, for
use in subsequent steps, letp= (n−t)/2 and letq= p+ t, where
t= (n≥623) ? 11 : (n≥68) ? 7 : (n≥39) ? 5 : (n≥7) ? 3 : (n−1)/2;
—(9.2) With m as the larger of s + 1 and n, transform the elements of the range: iteratively for
k= 0,...,m −1, calculate values
r1 = 1664525 ·T(begin[k]xor begin[k+ p]xor begin[k−1])
r2 = r1 +



s , k= 0
kmod n+ v[k−1] , 0 <k ≤s
kmod n , s<k
and, in order, incrementbegin[k+ p] by r1, incrementbegin[k+ q] by r2, and setbegin[k] to
r2.
—(9.3) Transform the elements of the range again, beginning where the previous step ended: iteratively
for k= m,...,m + n−1, calculate values
r3 = 1566083941 ·T(begin[k]+ begin[k+ p]+ begin[k−1])
r4 = r3 −(kmod n)
and, in order, updatebegin[k+ p] by xoring it withr3, updatebegin[k+ q] by xoring it with
r4, and setbegin[k] to r4.
§ 29.5.8.1 © ISO/IEC
1761

===== PAGE 1773 =====

Dxxxx
10 Throws: What and whenRandomAccessIterator operations of begin and end throw.
size_t size() const noexcept;
11 Returns: The number of 32-bit units that would be returned by a call toparam().
12 Complexity: Constant time.
template<class OutputIterator>
void param(OutputIterator dest) const;
13 Mandates: Values of typeresult_type are writable (24.3.1) todest.
14 Preconditions: OutputIterator meets theCpp17OutputIterator requirements (24.3.5.4).
15 Effects: Copies the sequence of prepared 32-bit units to the given destination, as if by executing the
following statement:
copy(v.begin(), v.end(), dest);
16 Throws: What and whenOutputIterator operations of dest throw.
29.5.8.2 Function template generate_canonical [rand.util.canonical]
template<class RealType, size_t digits, class URBG>
RealType generate_canonical(URBG& g);
1 Let
—(1.1) r be numeric_limits<RealType>::radix,
—(1.2) R be g.max()−g.min()+ 1,
—(1.3) d be the smaller ofdigits and numeric_limits<RealType>::digits,237
—(1.4) k be the smallest integer such thatRk ≥rd, and
—(1.5) x be
⌊
Rk/rd⌋
.
An attempt is k invocations ofg() to obtain valuesg0,...,g k−1, respectively, and the calculation of a
quantity S given by Formula 29.1:
S =
k−1∑
i=0
(gi −g.min()) ·Ri (29.1)
2 Effects: Attempts are made untilS <xrd.
[Note 1: When R is a power ofr, precisely one attempt is made.—end note]
3 Returns: ⌊S/x⌋/rd.
[Note 2: The return valuec satisfies 0 ≤c< 1. —end note]
4 Throws: What and wheng throws.
5 Complexity: Exactly k invocations ofg per attempt.
6 [Note 3: If the valuesgi produced byg are uniformly distributed, the instantiation’s results are distributed
as uniformly as possible. Obtaining a value in this way can be a useful step in the process of transforming a
value generated by a uniform random bit generator into a value that can be delivered by a random number
distribution. —end note]
7 [Note 4: When R is a power ofr, an implementation can avoid using an arithmetic type that is wider than the
output when computingS. —end note]
29.5.9 Random number distribution class templates [rand.dist]
29.5.9.1 General [rand.dist.general]
1 Each type instantiated from a class template specified in 29.5.9 meets the requirements of a random number
distribution (29.5.3.6) type.
2 Descriptions are provided in 29.5.9 only for distribution operations that are not described in 29.5.3.6 or for
operations where there is additional semantic information. In particular, declarations for copy constructors,
237) d is introduced to avoid any attempt to produce more bits of randomness than can be held inRealType.
§ 29.5.9.1 © ISO/IEC
1762

===== PAGE 1774 =====

Dxxxx
for copy assignment operators, for streaming operators, and for equality and inequality operators are not
shown in the synopses.
3 The algorithms for producing each of the specified distributions are implementation-defined.
4 The value of each probability density functionp(z) and of each discrete probability functionP(zi) specified
in this subclause is0 everywhere outside its stated domain.
29.5.9.2 Uniform distributions [rand.dist.uni]
29.5.9.2.1 Class template uniform_int_distribution [rand.dist.uni.int]
1 A uniform_int_distribution random number distribution produces random integersi, a ≤i ≤b, dis-
tributed according to the constant discrete probability function in Formula 29.2.
P(i|a,b) = 1/(b−a+ 1) (29.2)
namespace std {
template<class IntType = int>
class uniform_int_distribution {
public:
// types
using result_type = IntType;
using param_type = unspecified ;
// constructors and reset functions
uniform_int_distribution() : uniform_int_distribution(0) {}
explicit uniform_int_distribution(IntType a, IntType b = numeric_limits<IntType>::max());
explicit uniform_int_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const uniform_int_distribution& x, const uniform_int_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
result_type a() const;
result_type b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, // hosted
const uniform_int_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, // hosted
uniform_int_distribution& x);
};
}
explicit uniform_int_distribution(IntType a, IntType b = numeric_limits<IntType>::max());
2 Preconditions: a ≤b.
3 Remarks: a and b correspond to the respective parameters of the distribution.
§ 29.5.9.2.1 © ISO/IEC
1763

===== PAGE 1775 =====

Dxxxx
result_type a() const;
4 Returns: The value of thea parameter with which the object was constructed.
result_type b() const;
5 Returns: The value of theb parameter with which the object was constructed.
29.5.9.2.2 Class template uniform_real_distribution [rand.dist.uni.real]
1 A uniform_real_distribution random number distribution produces random numbersx, a ≤x < b,
distributed according to the constant probability density function in Formula 29.3.
p(x|a,b) = 1/(b−a) (29.3)
[Note 1: This implies thatp(x|a,b) is undefined whena == b. —end note]
namespace std {
template<class RealType = double>
class uniform_real_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructors and reset functions
uniform_real_distribution() : uniform_real_distribution(0.0) {}
explicit uniform_real_distribution(RealType a, RealType b = 1.0);
explicit uniform_real_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const uniform_real_distribution& x,
const uniform_real_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
result_type a() const;
result_type b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const uniform_real_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, uniform_real_distribution& x);
};
}
explicit uniform_real_distribution(RealType a, RealType b = 1.0);
2 Preconditions: a ≤b and b−a ≤numeric_limits<RealType>::max().
3 Remarks: a and b correspond to the respective parameters of the distribution.
result_type a() const;
4 Returns: The value of thea parameter with which the object was constructed.
§ 29.5.9.2.2 © ISO/IEC
1764

===== PAGE 1776 =====

Dxxxx
result_type b() const;
5 Returns: The value of theb parameter with which the object was constructed.
29.5.9.3 Bernoulli distributions [rand.dist.bern]
29.5.9.3.1 Class bernoulli_distribution [rand.dist.bern.bernoulli]
1 A bernoulli_distribution random number distribution producesbool values b distributed according to
the discrete probability function in Formula 29.4.
P(b|p) =
{ p if b= true
1 −p if b= false (29.4)
namespace std {
class bernoulli_distribution {
public:
// types
using result_type = bool;
using param_type = unspecified ;
// constructors and reset functions
bernoulli_distribution() : bernoulli_distribution(0.5) {}
explicit bernoulli_distribution(double p);
explicit bernoulli_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const bernoulli_distribution& x, const bernoulli_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bernoulli_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bernoulli_distribution& x);
};
}
explicit bernoulli_distribution(double p);
2 Preconditions: 0 ≤p ≤1.
3 Remarks: p corresponds to the parameter of the distribution.
double p() const;
4 Returns: The value of thep parameter with which the object was constructed.
29.5.9.3.2 Class template binomial_distribution [rand.dist.bern.bin]
1 A binomial_distribution random number distribution produces integer valuesi≥0 distributed according
to the discrete probability function in Formula 29.5.
§ 29.5.9.3.2 © ISO/IEC
1765

===== PAGE 1777 =====

Dxxxx
P(i|t,p) =
(t
i
)
·pi ·(1 −p)t−i (29.5)
namespace std {
template<class IntType = int>
class binomial_distribution {
public:
// types
using result_type = IntType;
using param_type = unspecified ;
// constructors and reset functions
binomial_distribution() : binomial_distribution(1) {}
explicit binomial_distribution(IntType t, double p = 0.5);
explicit binomial_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const binomial_distribution& x, const binomial_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
IntType t() const;
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const binomial_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, binomial_distribution& x);
};
}
explicit binomial_distribution(IntType t, double p = 0.5);
2 Preconditions: 0 ≤p ≤1 and 0 ≤t.
3 Remarks: t and p correspond to the respective parameters of the distribution.
IntType t() const;
4 Returns: The value of thet parameter with which the object was constructed.
double p() const;
5 Returns: The value of thep parameter with which the object was constructed.
29.5.9.3.3 Class template geometric_distribution [rand.dist.bern.geo]
1 A geometric_distribution random number distribution produces integer valuesi≥0 distributed according
to the discrete probability function in Formula 29.6.
P(i|p) = p·(1 −p)i (29.6)
§ 29.5.9.3.3 © ISO/IEC
1766

===== PAGE 1778 =====

Dxxxx
namespace std {
template<class IntType = int>
class geometric_distribution {
public:
// types
using result_type = IntType;
using param_type = unspecified ;
// constructors and reset functions
geometric_distribution() : geometric_distribution(0.5) {}
explicit geometric_distribution(double p);
explicit geometric_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const geometric_distribution& x, const geometric_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const geometric_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, geometric_distribution& x);
};
}
explicit geometric_distribution(double p);
2 Preconditions: 0 <p <1.
3 Remarks: p corresponds to the parameter of the distribution.
double p() const;
4 Returns: The value of thep parameter with which the object was constructed.
29.5.9.3.4 Class template negative_binomial_distribution [rand.dist.bern.negbin]
1 A negative_binomial_distribution random number distribution produces random integersi ≥0 dis-
tributed according to the discrete probability function in Formula 29.7.
P(i|k,p) =
(k+ i−1
i
)
·pk ·(1 −p)i (29.7)
[Note 1: This implies thatP(i|k,p) is undefined whenp == 1. —end note]
namespace std {
template<class IntType = int>
class negative_binomial_distribution {
public:
// types
using result_type = IntType;
using param_type = unspecified ;
§ 29.5.9.3.4 © ISO/IEC
1767

===== PAGE 1779 =====

Dxxxx
// constructor and reset functions
negative_binomial_distribution() : negative_binomial_distribution(1) {}
explicit negative_binomial_distribution(IntType k, double p = 0.5);
explicit negative_binomial_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const negative_binomial_distribution& x,
const negative_binomial_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
IntType k() const;
double p() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const negative_binomial_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, negative_binomial_distribution& x);
};
}
explicit negative_binomial_distribution(IntType k, double p = 0.5);
2 Preconditions: 0 <p ≤1 and 0 <k.
3 Remarks: k and p correspond to the respective parameters of the distribution.
IntType k() const;
4 Returns: The value of thek parameter with which the object was constructed.
double p() const;
5 Returns: The value of thep parameter with which the object was constructed.
29.5.9.4 Poisson distributions [rand.dist.pois]
29.5.9.4.1 Class template poisson_distribution [rand.dist.pois.poisson]
1 A poisson_distribution random number distribution produces integer valuesi≥0 distributed according
to the discrete probability function in Formula 29.8.
P(i|µ) = e−µµi
i! (29.8)
The distribution parameterµ is also known as this distribution’smean.
namespace std {
template<class IntType = int>
class poisson_distribution {
public:
// types
using result_type = IntType;
using param_type = unspecified ;
§ 29.5.9.4.1 © ISO/IEC
1768

===== PAGE 1780 =====

Dxxxx
// constructors and reset functions
poisson_distribution() : poisson_distribution(1.0) {}
explicit poisson_distribution(double mean);
explicit poisson_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const poisson_distribution& x, const poisson_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
double mean() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const poisson_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, poisson_distribution& x);
};
}
explicit poisson_distribution(double mean);
2 Preconditions: 0 <mean.
3 Remarks: mean corresponds to the parameter of the distribution.
double mean() const;
4 Returns: The value of themean parameter with which the object was constructed.
29.5.9.4.2 Class template exponential_distribution [rand.dist.pois.exp]
1 An exponential_distribution random number distribution produces random numbersx> 0 distributed
according to the probability density function in Formula 29.9.
p(x|λ) = λe−λx (29.9)
namespace std {
template<class RealType = double>
class exponential_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructors and reset functions
exponential_distribution() : exponential_distribution(1.0) {}
explicit exponential_distribution(RealType lambda);
explicit exponential_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const exponential_distribution& x, const exponential_distribution& y);
§ 29.5.9.4.2 © ISO/IEC
1769

===== PAGE 1781 =====

Dxxxx
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType lambda() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const exponential_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, exponential_distribution& x);
};
}
explicit exponential_distribution(RealType lambda);
2 Preconditions: 0 <lambda.
3 Remarks: lambda corresponds to the parameter of the distribution.
RealType lambda() const;
4 Returns: The value of thelambda parameter with which the object was constructed.
29.5.9.4.3 Class template gamma_distribution [rand.dist.pois.gamma]
1 A gamma_distribution random number distribution produces random numbersx> 0 distributed according
to the probability density function in Formula 29.10.
p(x|α,β) = e−x/β
βα ·Γ(α) ·xα−1 (29.10)
namespace std {
template<class RealType = double>
class gamma_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructors and reset functions
gamma_distribution() : gamma_distribution(1.0) {}
explicit gamma_distribution(RealType alpha, RealType beta = 1.0);
explicit gamma_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const gamma_distribution& x, const gamma_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
§ 29.5.9.4.3 © ISO/IEC
1770

===== PAGE 1782 =====

Dxxxx
// property functions
RealType alpha() const;
RealType beta() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const gamma_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, gamma_distribution& x);
};
}
explicit gamma_distribution(RealType alpha, RealType beta = 1.0);
2 Preconditions: 0 <alpha and 0 <beta.
3 Remarks: alpha and beta correspond to the parameters of the distribution.
RealType alpha() const;
4 Returns: The value of thealpha parameter with which the object was constructed.
RealType beta() const;
5 Returns: The value of thebeta parameter with which the object was constructed.
29.5.9.4.4 Class template weibull_distribution [rand.dist.pois.weibull]
1 Aweibull_distributionrandomnumberdistributionproducesrandomnumbers x≥0 distributedaccording
to the probability density function in Formula 29.11.
p(x|a,b) = a
b ·
(x
b
)a−1
·exp
(
−
(x
b
)a)
(29.11)
namespace std {
template<class RealType = double>
class weibull_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
weibull_distribution() : weibull_distribution(1.0) {}
explicit weibull_distribution(RealType a, RealType b = 1.0);
explicit weibull_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const weibull_distribution& x, const weibull_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType a() const;
RealType b() const;
param_type param() const;
§ 29.5.9.4.4 © ISO/IEC
1771

===== PAGE 1783 =====

Dxxxx
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const weibull_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, weibull_distribution& x);
};
}
explicit weibull_distribution(RealType a, RealType b = 1.0);
2 Preconditions: 0 <a and 0 <b.
3 Remarks: a and b correspond to the respective parameters of the distribution.
RealType a() const;
4 Returns: The value of thea parameter with which the object was constructed.
RealType b() const;
5 Returns: The value of theb parameter with which the object was constructed.
29.5.9.4.5 Class template extreme_value_distribution [rand.dist.pois.extreme]
1 An extreme_value_distribution random number distribution produces random numbersx distributed
according to the probability density function in Formula 29.12.238
p(x|a,b) = 1
b ·exp
(a−x
b −exp
(a−x
b
))
(29.12)
namespace std {
template<class RealType = double>
class extreme_value_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
extreme_value_distribution() : extreme_value_distribution(0.0) {}
explicit extreme_value_distribution(RealType a, RealType b = 1.0);
explicit extreme_value_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const extreme_value_distribution& x,
const extreme_value_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType a() const;
RealType b() const;
param_type param() const;
238) The distribution corresponding to this probability density function is also known (with a possible change of variable) as the
Gumbel Type I, the log-Weibull, or the Fisher-Tippett Type I distribution.
§ 29.5.9.4.5 © ISO/IEC
1772

===== PAGE 1784 =====

Dxxxx
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const extreme_value_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, extreme_value_distribution& x);
};
}
explicit extreme_value_distribution(RealType a, RealType b = 1.0);
2 Preconditions: 0 <b.
3 Remarks: a and b correspond to the respective parameters of the distribution.
RealType a() const;
4 Returns: The value of thea parameter with which the object was constructed.
RealType b() const;
5 Returns: The value of theb parameter with which the object was constructed.
29.5.9.5 Normal distributions [rand.dist.norm]
29.5.9.5.1 Class template normal_distribution [rand.dist.norm.normal]
1 A normal_distribution random number distribution produces random numbersx distributed according to
the probability density function in Formula 29.13.
p(x|µ,σ) = 1
σ
√
2π ·exp
(
−(x−µ)2
2σ2
)
(29.13)
The distribution parametersµ and σ are also known as this distribution’smean and standard deviation.
namespace std {
template<class RealType = double>
class normal_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructors and reset functions
normal_distribution() : normal_distribution(0.0) {}
explicit normal_distribution(RealType mean, RealType stddev = 1.0);
explicit normal_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const normal_distribution& x, const normal_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType mean() const;
RealType stddev() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
§ 29.5.9.5.1 © ISO/IEC
1773

===== PAGE 1785 =====

Dxxxx
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const normal_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, normal_distribution& x);
};
}
explicit normal_distribution(RealType mean, RealType stddev = 1.0);
2 Preconditions: 0 <stddev.
3 Remarks: mean and stddev correspond to the respective parameters of the distribution.
RealType mean() const;
4 Returns: The value of themean parameter with which the object was constructed.
RealType stddev() const;
5 Returns: The value of thestddev parameter with which the object was constructed.
29.5.9.5.2 Class template lognormal_distribution [rand.dist.norm.lognormal]
1 A lognormal_distribution random number distribution produces random numbersx >0 distributed
according to the probability density function in Formula 29.14.
p(x|m,s) = 1
sx
√
2π ·exp
(
−(ln x−m)2
2s2
)
(29.14)
namespace std {
template<class RealType = double>
class lognormal_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
lognormal_distribution() : lognormal_distribution(0.0) {}
explicit lognormal_distribution(RealType m, RealType s = 1.0);
explicit lognormal_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const lognormal_distribution& x, const lognormal_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType m() const;
RealType s() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
§ 29.5.9.5.2 © ISO/IEC
1774

===== PAGE 1786 =====

Dxxxx
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const lognormal_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, lognormal_distribution& x);
};
}
explicit lognormal_distribution(RealType m, RealType s = 1.0);
2 Preconditions: 0 <s.
3 Remarks: m and s correspond to the respective parameters of the distribution.
RealType m() const;
4 Returns: The value of them parameter with which the object was constructed.
RealType s() const;
5 Returns: The value of thes parameter with which the object was constructed.
29.5.9.5.3 Class template chi_squared_distribution [rand.dist.norm.chisq]
1 A chi_squared_distribution random number distribution produces random numbersx> 0 distributed
according to the probability density function in Formula 29.15.
p(x|n) = x(n/2)−1 ·e−x/2
Γ(n/2) ·2n/2 (29.15)
namespace std {
template<class RealType = double>
class chi_squared_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
chi_squared_distribution() : chi_squared_distribution(1.0) {}
explicit chi_squared_distribution(RealType n);
explicit chi_squared_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const chi_squared_distribution& x, const chi_squared_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType n() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const chi_squared_distribution& x);
§ 29.5.9.5.3 © ISO/IEC
1775

===== PAGE 1787 =====

Dxxxx
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, chi_squared_distribution& x);
};
}
explicit chi_squared_distribution(RealType n);
2 Preconditions: 0 <n.
3 Remarks: n corresponds to the parameter of the distribution.
RealType n() const;
4 Returns: The value of then parameter with which the object was constructed.
29.5.9.5.4 Class template cauchy_distribution [rand.dist.norm.cauchy]
1 A cauchy_distribution random number distribution produces random numbersx distributed according to
the probability density function in Formula 29.16.
p(x|a,b) =
(
πb
(
1 +
(x−a
b
)2 ))−1
(29.16)
namespace std {
template<class RealType = double>
class cauchy_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
cauchy_distribution() : cauchy_distribution(0.0) {}
explicit cauchy_distribution(RealType a, RealType b = 1.0);
explicit cauchy_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const cauchy_distribution& x, const cauchy_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType a() const;
RealType b() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const cauchy_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, cauchy_distribution& x);
};
}
§ 29.5.9.5.4 © ISO/IEC
1776

===== PAGE 1788 =====

Dxxxx
explicit cauchy_distribution(RealType a, RealType b = 1.0);
2 Preconditions: 0 <b.
3 Remarks: a and b correspond to the respective parameters of the distribution.
RealType a() const;
4 Returns: The value of thea parameter with which the object was constructed.
RealType b() const;
5 Returns: The value of theb parameter with which the object was constructed.
29.5.9.5.5 Class template fisher_f_distribution [rand.dist.norm.f]
1 A fisher_f_distribution random number distribution produces random numbersx ≥ 0 distributed
according to the probability density function in Formula 29.17.
p(x|m,n) = Γ
(
(m+ n)/2
)
Γ(m/2) Γ(n/2) ·
(m
n
)m/2
·x(m/2)−1 ·
(
1 + mx
n
)−(m+n)/2
(29.17)
namespace std {
template<class RealType = double>
class fisher_f_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
fisher_f_distribution() : fisher_f_distribution(1.0) {}
explicit fisher_f_distribution(RealType m, RealType n = 1.0);
explicit fisher_f_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const fisher_f_distribution& x, const fisher_f_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType m() const;
RealType n() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const fisher_f_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, fisher_f_distribution& x);
};
}
explicit fisher_f_distribution(RealType m, RealType n = 1);
2 Preconditions: 0 <m and 0 <n.
3 Remarks: m and n correspond to the respective parameters of the distribution.
§ 29.5.9.5.5 © ISO/IEC
1777

===== PAGE 1789 =====

Dxxxx
RealType m() const;
4 Returns: The value of them parameter with which the object was constructed.
RealType n() const;
5 Returns: The value of then parameter with which the object was constructed.
29.5.9.5.6 Class template student_t_distribution [rand.dist.norm.t]
1 A student_t_distribution random number distribution produces random numbersxdistributed according
to the probability density function in Formula 29.18.
p(x|n) = 1√nπ ·Γ
(
(n+ 1)/2
)
Γ(n/2) ·
(
1 + x2
n
)−(n+1)/2
(29.18)
namespace std {
template<class RealType = double>
class student_t_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
student_t_distribution() : student_t_distribution(1.0) {}
explicit student_t_distribution(RealType n);
explicit student_t_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const student_t_distribution& x, const student_t_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
RealType n() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const student_t_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, student_t_distribution& x);
};
}
explicit student_t_distribution(RealType n);
2 Preconditions: 0 <n.
3 Remarks: n corresponds to the parameter of the distribution.
RealType n() const;
4 Returns: The value of then parameter with which the object was constructed.
§ 29.5.9.5.6 © ISO/IEC
1778

===== PAGE 1790 =====

Dxxxx
29.5.9.6 Sampling distributions [rand.dist.samp]
29.5.9.6.1 Class template discrete_distribution [rand.dist.samp.discrete]
1 A discrete_distribution random number distribution produces random integersi, 0 ≤i<n , distributed
according to the discrete probability function in Formula 29.19.
P(i|p0,...,p n−1) = pi (29.19)
2 Unless specified otherwise, the distribution parameters are calculated as:pk = wk/S for k = 0,...,n −1,
in which the valueswk, commonly known as theweights, shall be non-negative, non-NaN, and non-infinity.
Moreover, the following relation shall hold:0 <S = w0 + ··· + wn−1.
namespace std {
template<class IntType = int>
class discrete_distribution {
public:
// types
using result_type = IntType;
using param_type = unspecified ;
// constructor and reset functions
discrete_distribution();
template<class InputIterator>
discrete_distribution(InputIterator firstW, InputIterator lastW);
discrete_distribution(initializer_list<double> wl);
template<class UnaryOperation>
discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw);
explicit discrete_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const discrete_distribution& x, const discrete_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
vector<double> probabilities() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const discrete_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, discrete_distribution& x);
};
}
discrete_distribution();
3 Effects: Constructs adiscrete_distribution object withn= 1 and p0 = 1.
[Note 1: Such an object will always deliver the value0. —end note]
template<class InputIterator>
discrete_distribution(InputIterator firstW, InputIterator lastW);
4 Mandates: is_convertible_v<iterator_traits<InputIterator>::value_type, double> is true.
§ 29.5.9.6.1 © ISO/IEC
1779

===== PAGE 1791 =====

Dxxxx
5 Preconditions: InputIterator meets theCpp17InputIterator requirements (24.3.5.3). IffirstW ==
lastW, letn= 1 and w0 = 1. Otherwise,
[
firstW,lastW
)
forms a sequencew of lengthn> 0.
6 Effects: Constructs adiscrete_distribution object with probabilities given by the Formula 29.19.
discrete_distribution(initializer_list<double> wl);
7 Effects: Same asdiscrete_distribution(wl.begin(), wl.end()).
template<class UnaryOperation>
discrete_distribution(size_t nw, double xmin, double xmax, UnaryOperation fw);
8 Mandates: is_invocable_r_v<double, UnaryOperation&, double> is true.
9 Preconditions: If nw = 0, letn= 1, otherwise letn= nw. The relation0 <δ = (xmax−xmin)/n holds.
10 Effects: Constructs adiscrete_distribution object with probabilities given by the formula above,
using the following values: Ifnw = 0, let w0 = 1. Otherwise, let wk = fw(xmin + k·δ+ δ/2) for
k= 0,...,n −1.
11 Complexity: The number of invocations offw does not exceedn.
vector<double> probabilities() const;
12 Returns: A vector<double> whose size member returnsn and whoseoperator[] member returns
pk when invoked with argumentk for k= 0,...,n −1.
29.5.9.6.2 Class template piecewise_constant_distribution [rand.dist.samp.pconst]
1 A piecewise_constant_distribution random number distribution produces random numbersx, b0 ≤x<
bn, uniformly distributed over each subinterval[bi,bi+1) according to the probability density function in
Formula 29.20.
p(x|b0,...,b n, ρ0,...,ρ n−1) = ρi , forbi ≤x<b i+1 (29.20)
2 The n+ 1 distribution parametersbi, also known as this distribution’sinterval boundaries, shall satisfy the
relation bi <bi+1 for i= 0,...,n −1. Unless specified otherwise, the remainingn distribution parameters
are calculated as:
ρk = wk
S·(bk+1 −bk) for k= 0,...,n −1 ,
in which the valueswk, commonly known as theweights, shall be non-negative, non-NaN, and non-infinity.
Moreover, the following relation shall hold:0 <S = w0 + ··· + wn−1.
namespace std {
template<class RealType = double>
class piecewise_constant_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
piecewise_constant_distribution();
template<class InputIteratorB, class InputIteratorW>
piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
InputIteratorW firstW);
template<class UnaryOperation>
piecewise_constant_distribution(initializer_list<RealType> bl, UnaryOperation fw);
template<class UnaryOperation>
piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax,
UnaryOperation fw);
explicit piecewise_constant_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const piecewise_constant_distribution& x,
const piecewise_constant_distribution& y);
§ 29.5.9.6.2 © ISO/IEC
1780

===== PAGE 1792 =====

Dxxxx
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
vector<result_type> intervals() const;
vector<result_type> densities() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const piecewise_constant_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, piecewise_constant_distribution& x);
};
}
piecewise_constant_distribution();
3 Effects: Constructs a piecewise_constant_distribution object with n = 1, ρ0 = 1, b0 = 0, and
b1 = 1.
template<class InputIteratorB, class InputIteratorW>
piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
InputIteratorW firstW);
4 Mandates: Both of
—(4.1) is_convertible_v<iterator_traits<InputIteratorB>::value_type, double>
—(4.2) is_convertible_v<iterator_traits<InputIteratorW>::value_type, double>
are true.
5 Preconditions: InputIteratorB and InputIteratorW each meet theCpp17InputIterator requirements
(24.3.5.3). If firstB == lastB or ++firstB == lastB, let n = 1 , w0 = 1 , b0 = 0 , and b1 = 1 .
Otherwise,
[
firstB,lastB
)
forms a sequenceb of lengthn+ 1, the length of the sequencew starting
from firstW is at leastn, and anywk for k≥n are ignored by the distribution.
6 Effects: Constructs apiecewise_constant_distribution object with parameters as specified above.
template<class UnaryOperation>
piecewise_constant_distribution(initializer_list<RealType> bl, UnaryOperation fw);
7 Mandates: is_invocable_r_v<double, UnaryOperation&, double> is true.
8 Effects: Constructs apiecewise_constant_distribution object with parameters taken or calculated
from the following values: Ifbl.size() < 2, letn = 1, w0 = 1, b0 = 0, andb1 = 1. Otherwise, let[
bl.begin(),bl.end()
)
form a sequenceb0,...,b n, and letwk = fw
((
bk+1 +bk
)
/2
)
for k= 0,...,n −1.
9 Complexity: The number of invocations offw does not exceedn.
template<class UnaryOperation>
piecewise_constant_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
10 Mandates: is_invocable_r_v<double, UnaryOperation&, double> is true.
11 Preconditions: If nw = 0, letn= 1, otherwise letn= nw. The relation0 <δ = (xmax−xmin)/n holds.
12 Effects: Constructs apiecewise_constant_distribution object with parameters taken or calculated
from the following values: Letbk = xmin+k·δfork= 0,...,n , andwk = fw(bk+δ/2) fork= 0,...,n −1.
13 Complexity: The number of invocations offw does not exceedn.
§ 29.5.9.6.2 © ISO/IEC
1781

===== PAGE 1793 =====

Dxxxx
vector<result_type> intervals() const;
14 Returns: A vector<result_type> whose size member returnsn+ 1 and whoseoperator[] member
returns bk when invoked with argumentk for k= 0,...,n .
vector<result_type> densities() const;
15 Returns: A vector<result_type> whose size member returns n and whose operator[] member
returns ρk when invoked with argumentk for k= 0,...,n −1.
29.5.9.6.3 Class template piecewise_linear_distribution [rand.dist.samp.plinear]
1 A piecewise_linear_distribution random number distribution produces random numbersx, b0 ≤x<b n,
distributed over each subinterval[bi,bi+1) according to the probability density function in Formula 29.21.
p(x|b0,...,b n, ρ0,...,ρ n) = ρi ·bi+1 −x
bi+1 −bi
+ ρi+1 · x−bi
bi+1 −bi
, forbi ≤x<b i+1. (29.21)
2 The n+ 1 distribution parametersbi, also known as this distribution’sinterval boundaries, shall satisfy the
relation bi <bi+1 for i= 0,...,n −1. Unless specified otherwise, the remainingn+ 1 distribution parameters
are calculated asρk = wk/S for k = 0,...,n , in which the valueswk, commonly known as theweights at
boundaries, shall be non-negative, non-NaN, and non-infinity. Moreover, the following relation shall hold:
0 <S = 1
2 ·
n−1∑
k=0
(wk + wk+1) ·(bk+1 −bk) .
namespace std {
template<class RealType = double>
class piecewise_linear_distribution {
public:
// types
using result_type = RealType;
using param_type = unspecified ;
// constructor and reset functions
piecewise_linear_distribution();
template<class InputIteratorB, class InputIteratorW>
piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
InputIteratorW firstW);
template<class UnaryOperation>
piecewise_linear_distribution(initializer_list<RealType> bl, UnaryOperation fw);
template<class UnaryOperation>
piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
explicit piecewise_linear_distribution(const param_type& parm);
void reset();
// equality operators
friend bool operator==(const piecewise_linear_distribution& x,
const piecewise_linear_distribution& y);
// generating functions
template<class URBG>
result_type operator()(URBG& g);
template<class URBG>
result_type operator()(URBG& g, const param_type& parm);
// property functions
vector<result_type> intervals() const;
vector<result_type> densities() const;
param_type param() const;
void param(const param_type& parm);
result_type min() const;
result_type max() const;
§ 29.5.9.6.3 © ISO/IEC
1782

===== PAGE 1794 =====

Dxxxx
// inserters and extractors
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const piecewise_linear_distribution& x);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, piecewise_linear_distribution& x);
};
}
piecewise_linear_distribution();
3 Effects: Constructs apiecewise_linear_distribution object withn= 1, ρ0 = ρ1 = 1, b0 = 0, and
b1 = 1.
template<class InputIteratorB, class InputIteratorW>
piecewise_linear_distribution(InputIteratorB firstB, InputIteratorB lastB,
InputIteratorW firstW);
4 Mandates: Both of
—(4.1) is_convertible_v<iterator_traits<InputIteratorB>::value_type, double>
—(4.2) is_convertible_v<iterator_traits<InputIteratorW>::value_type, double>
are true.
5 Preconditions: InputIteratorB and InputIteratorW each meet theCpp17InputIterator requirements
(24.3.5.3). If firstB == lastB or ++firstB == lastB, letn = 1, ρ0 = ρ1 = 1, b0 = 0, andb1 = 1.
Otherwise,
[
firstB,lastB
)
forms a sequenceb of lengthn+ 1, the length of the sequencew starting
from firstW is at leastn+ 1, and anywk for k≥n+ 1 are ignored by the distribution.
6 Effects: Constructs apiecewise_linear_distribution object with parameters as specified above.
template<class UnaryOperation>
piecewise_linear_distribution(initializer_list<RealType> bl, UnaryOperation fw);
7 Mandates: is_invocable_r_v<double, UnaryOperation&, double> is true.
8 Effects: Constructs apiecewise_linear_distribution object with parameters taken or calculated
from the following values: Ifbl.size() <2, letn= 1, ρ0 = ρ1 = 1, b0 = 0, andb1 = 1. Otherwise, let[
bl.begin(),bl.end()
)
form a sequenceb0,...,b n, and letwk = fw(bk) for k= 0,...,n .
9 Complexity: The number of invocations offw does not exceedn+ 1.
template<class UnaryOperation>
piecewise_linear_distribution(size_t nw, RealType xmin, RealType xmax, UnaryOperation fw);
10 Mandates: is_invocable_r_v<double, UnaryOperation&, double> is true.
11 Preconditions: If nw = 0, letn= 1, otherwise letn= nw. The relation0 <δ = (xmax−xmin)/n holds.
12 Effects: Constructs apiecewise_linear_distribution object with parameters taken or calculated
from the following values: Letbk = xmin+ k·δ for k= 0,...,n , andwk = fw(bk) for k= 0,...,n .
13 Complexity: The number of invocations offw does not exceedn+ 1.
vector<result_type> intervals() const;
14 Returns: A vector<result_type> whose size member returnsn+ 1 and whoseoperator[] member
returns bk when invoked with argumentk for k= 0,...,n .
vector<result_type> densities() const;
15 Returns: A vector<result_type> whose size member returns n and whose operator[] member
returns ρk when invoked with argumentk for k= 0,...,n .
29.5.10 Low-quality random number generation [c.math.rand]
1 [Note 1: The header<cstdlib> (17.2.2) declares the functions described in this subclause.—end note]
int rand();
§ 29.5.10 © ISO/IEC
1783

===== PAGE 1795 =====

Dxxxx
void srand(unsigned int seed);
2 Effects: The rand and srand functions have the semantics specified in the C standard library.
3 Remarks: The implementation may specify that particular library functions may callrand. It is
implementation-defined whether therand function may introduce data races (16.4.6.10).
[Note 2: The other random number generation facilities in this document (29.5) are often preferable torand,
because rand’s underlying algorithm is unspecified. Use ofrand therefore continues to be non-portable, with
unpredictable and oft-questionable quality and performance.—end note]
See also: ISO/IEC 9899:2024, 7.24.3
29.6 Numeric arrays [numarray]
29.6.1 Header <valarray> synopsis [valarray.syn]
#include <initializer_list> // see 17.11.2
namespace std {
template<class T> class valarray; // An array of typeT
class slice; // a BLAS-like slice out of an array
template<class T> class slice_array;
class gslice; // a generalized slice out of an array
template<class T> class gslice_array;
template<class T> class mask_array; // a masked array
template<class T> class indirect_array; // an indirected array
template<class T> void swap(valarray<T>&, valarray<T>&) noexcept;
template<class T> valarray<T> operator* (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator* (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator* (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator/ (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator% (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator+ (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator- (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator^ (const typename valarray<T>::value_type&,
const valarray<T>&);
§ 29.6.1 © ISO/IEC
1784

===== PAGE 1796 =====

Dxxxx
template<class T> valarray<T> operator& (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator& (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator| (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator<<(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator<<(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator>>(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> operator>>(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator&&(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator&&(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator||(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator||(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator==(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator==(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator!=(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator!=(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator< (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator< (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator> (const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator> (const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator<=(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator<=(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
§ 29.6.1 © ISO/IEC
1785

===== PAGE 1797 =====

Dxxxx
template<class T> valarray<bool> operator>=(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<bool> operator>=(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> abs (const valarray<T>&);
template<class T> valarray<T> acos (const valarray<T>&);
template<class T> valarray<T> asin (const valarray<T>&);
template<class T> valarray<T> atan (const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&,
const typename valarray<T>::value_type&);
template<class T> valarray<T> atan2(const typename valarray<T>::value_type&,
const valarray<T>&);
template<class T> valarray<T> cos (const valarray<T>&);
template<class T> valarray<T> cosh (const valarray<T>&);
template<class T> valarray<T> exp (const valarray<T>&);
template<class T> valarray<T> log (const valarray<T>&);
template<class T> valarray<T> log10(const valarray<T>&);
template<class T> valarray<T> pow(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> pow(const valarray<T>&, const typename valarray<T>::value_type&);
template<class T> valarray<T> pow(const typename valarray<T>::value_type&, const valarray<T>&);
template<class T> valarray<T> sin (const valarray<T>&);
template<class T> valarray<T> sinh (const valarray<T>&);
template<class T> valarray<T> sqrt (const valarray<T>&);
template<class T> valarray<T> tan (const valarray<T>&);
template<class T> valarray<T> tanh (const valarray<T>&);
}
1 The header<valarray> defines five class templates (valarray, slice_array, gslice_array, mask_array,
and indirect_array), two classes (slice and gslice), and a series of related function templates for
representing and manipulating arrays of values.
2 The valarray array classes are defined to be free of certain forms of aliasing, thus allowing operations on
these classes to be optimized.
3 Any function returning avalarray<T> is permitted to return an object of another type, provided all the
const member functions ofvalarray<T> other thanbegin and end are also applicable to this type. This
return type shall not add more than two levels of template nesting over the most deeply nested argument
type.239
4 Implementations introducing such replacement types shall provide additional functions and operators as
follows:
—(4.1) for every function taking aconst valarray<T>&, identical functions taking the replacement types shall
be added;
—(4.2) for every function taking twoconst valarray<T>& arguments, identical functions taking every combi-
nation ofconst valarray<T>& and replacement types shall be added.
5 In particular, an implementation shall allow avalarray<T> to be constructed from such replacement types
and shall allow assignments and compound assignments of such types tovalarray<T>, slice_array<T>,
gslice_array<T>, mask_array<T> and indirect_array<T> objects.
6 These library functions are permitted to throw abad_alloc (17.6.4.1) exception if there are not sufficient
resources available to carry out the operation. Note that the exception is not mandated.
29.6.2 Class template valarray [template.valarray]
29.6.2.1 Overview [template.valarray.overview]
namespace std {
239) Annex B recommends a minimum number of recursively nested template instantiations. This requirement thus indirectly
suggests a minimum allowable complexity for valarray expressions.
§ 29.6.2.1 © ISO/IEC
1786

===== PAGE 1798 =====

Dxxxx
template<class T> class valarray {
public:
using value_type = T;
using iterator = unspecified ;
using const_iterator = unspecified ;
// 29.6.2.2, construct/destroy
valarray();
explicit valarray(size_t);
valarray(const T&, size_t);
valarray(const T*, size_t);
valarray(const valarray&);
valarray(valarray&&) noexcept;
valarray(const slice_array<T>&);
valarray(const gslice_array<T>&);
valarray(const mask_array<T>&);
valarray(const indirect_array<T>&);
valarray(initializer_list<T>);
~valarray();
// 29.6.2.3, assignment
valarray& operator=(const valarray&);
valarray& operator=(valarray&&) noexcept;
valarray& operator=(initializer_list<T>);
valarray& operator=(const T&);
valarray& operator=(const slice_array<T>&);
valarray& operator=(const gslice_array<T>&);
valarray& operator=(const mask_array<T>&);
valarray& operator=(const indirect_array<T>&);
// 29.6.2.4, element access
const T& operator[](size_t) const;
T& operator[](size_t);
// 29.6.2.5, subset operations
valarray operator[](slice) const;
slice_array<T> operator[](slice);
valarray operator[](const gslice&) const;
gslice_array<T> operator[](const gslice&);
valarray operator[](const valarray<bool>&) const;
mask_array<T> operator[](const valarray<bool>&);
valarray operator[](const valarray<size_t>&) const;
indirect_array<T> operator[](const valarray<size_t>&);
// 29.6.2.6, unary operators
valarray operator+() const;
valarray operator-() const;
valarray operator~() const;
valarray<bool> operator!() const;
// 29.6.2.7, compound assignment
valarray& operator*= (const T&);
valarray& operator/= (const T&);
valarray& operator%= (const T&);
valarray& operator+= (const T&);
valarray& operator-= (const T&);
valarray& operator^= (const T&);
valarray& operator&= (const T&);
valarray& operator|= (const T&);
valarray& operator<<=(const T&);
valarray& operator>>=(const T&);
valarray& operator*= (const valarray&);
valarray& operator/= (const valarray&);
§ 29.6.2.1 © ISO/IEC
1787

===== PAGE 1799 =====

Dxxxx
valarray& operator%= (const valarray&);
valarray& operator+= (const valarray&);
valarray& operator-= (const valarray&);
valarray& operator^= (const valarray&);
valarray& operator|= (const valarray&);
valarray& operator&= (const valarray&);
valarray& operator<<=(const valarray&);
valarray& operator>>=(const valarray&);
// 29.6.10, range access
iterator begin();
iterator end();
const_iterator begin() const;
const_iterator end() const;
// 29.6.2.8, member functions
void swap(valarray&) noexcept;
size_t size() const;
T sum() const;
T min() const;
T max() const;
valarray shift (int) const;
valarray cshift(int) const;
valarray apply(T func(T)) const;
valarray apply(T func(const T&)) const;
void resize(size_t sz, T c = T());
};
template<class T, size_t cnt> valarray(const T(&)[cnt], size_t) -> valarray<T>;
}
1 The class templatevalarray<T> is a one-dimensional smart array, with elements numbered sequentially from
zero. It is a representation of the mathematical concept of an ordered set of values. For convenience, an
object of typevalarray<T> is referred to as an “array” throughout the remainder of 29.6. The illusion of
higher dimensionality may be produced by the familiar idiom of computed indices, together with the powerful
subsetting capabilities provided by the generalized subscript operators.240
29.6.2.2 Constructors [valarray.cons]
valarray();
1 Effects: Constructs avalarray that has zero length.241
explicit valarray(size_t n);
2 Effects: Constructs avalarray that has lengthn. Each element of the array is value-initialized (9.5).
valarray(const T& v, size_t n);
3 Effects: Constructs avalarray that has lengthn. Each element of the array is initialized withv.
valarray(const T* p, size_t n);
4 Preconditions: [p,p + n) is a valid range.
5 Effects: Constructs avalarray that has lengthn. The values of the elements of the array are initialized
with the firstn values pointed to by the first argument.242
240) The intent is to specify an array template that has the minimum functionality necessary to address aliasing ambiguities
and the proliferation of temporary objects. Thus, thevalarray template is neither a matrix class nor a field class. However, it
is a very useful building block for designing such classes.
241) This default constructor is essential, since arrays ofvalarray can be useful. After initialization, the length of an empty
array can be increased with theresize member function.
242) This constructor is the preferred method for converting a C array to avalarray object.
§ 29.6.2.2 © ISO/IEC
1788

===== PAGE 1800 =====

Dxxxx
valarray(const valarray& v);
6 Effects: Constructs avalarray that has the same length asv. The elements are initialized with the
values of the corresponding elements ofv.243
valarray(valarray&& v) noexcept;
7 Effects: Constructs avalarray that has the same length asv. The elements are initialized with the
values of the corresponding elements ofv.
8 Complexity: Constant.
valarray(initializer_list<T> il);
9 Effects: Equivalent tovalarray(il.data(), il.size()).
valarray(const slice_array<T>&);
valarray(const gslice_array<T>&);
valarray(const mask_array<T>&);
valarray(const indirect_array<T>&);
10 These conversion constructors convert one of the four reference templates to avalarray.
~valarray();
11 Effects: The destructor is applied to every element of*this; an implementation may return all allocated
memory.
29.6.2.3 Assignment [valarray.assign]
valarray& operator=(const valarray& v);
1 Effects: Each element of the*this array is assigned the value of the corresponding element ofv. If the
length ofv is not equal to the length of*this, resizes*this to make the two arrays the same length,
as if by callingresize(v.size()), before performing the assignment.
2 Postconditions: size() == v.size().
3 Returns: *this.
valarray& operator=(valarray&& v) noexcept;
4 Effects: *this obtains the value ofv. The value ofv after the assignment is not specified.
5 Returns: *this.
6 Complexity: Linear.
valarray& operator=(initializer_list<T> il);
7 Effects: Equivalent to:return *this = valarray(il);
valarray& operator=(const T& v);
8 Effects: Assigns v to each element of*this.
9 Returns: *this.
valarray& operator=(const slice_array<T>&);
valarray& operator=(const gslice_array<T>&);
valarray& operator=(const mask_array<T>&);
valarray& operator=(const indirect_array<T>&);
10 Preconditions: The length of the array to which the argument refers equalssize(). The value of
an element in the left-hand side of avalarray assignment operator does not depend on the value of
another element in that left-hand side.
11 These operators allow the results of a generalized subscripting operation to be assigned directly to a
valarray.
243) This copy constructor creates a distinct array rather than an alias. Implementations in which arrays share storage are
permitted, but they would need to implement a copy-on-reference mechanism to ensure that arrays are conceptually distinct.
§ 29.6.2.3 © ISO/IEC
1789