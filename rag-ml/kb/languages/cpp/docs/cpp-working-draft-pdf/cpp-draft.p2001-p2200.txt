

===== PAGE 2001 =====

Dxxxx
17 Effects: Initializes zone_ with std::move(z) and tp_ with zone_->to_sys(tp).
zoned_time(string_view name, const local_time<Duration>& tp);
18 Constraints: zoned_time is constructible from the return type oftraits::locate_zone(name) and
tp.
19 Effects: Equivalent to construction with{traits::locate_zone(name), tp}.
zoned_time(TimeZonePtr z, const local_time<Duration>& tp, choose c);
20 Constraints:
is_convertible_v<
decltype(declval<TimeZonePtr&>()->to_sys(local_time<Duration>{}, choose::earliest)),
sys_time<duration>>
is true.
21 Preconditions: z refers to a time zone.
22 Effects: Initializes zone_ with std::move(z) and tp_ with zone_->to_sys(tp, c).
zoned_time(string_view name, const local_time<Duration>& tp, choose c);
23 Constraints: zoned_time is constructible from the return type of traits::locate_zone(name),
local_time<Duration>, andchoose.
24 Effects: Equivalent to construction with{traits::locate_zone(name), tp, c}.
template<class Duration2, class TimeZonePtr2>
zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& y);
25 Constraints: is_convertible_v<sys_time<Duration2>, sys_time<Duration>> is true.
26 Preconditions: z refers to a valid time zone.
27 Effects: Initializes zone_ with std::move(z) and tp_ with y.tp_.
template<class Duration2, class TimeZonePtr2>
zoned_time(TimeZonePtr z, const zoned_time<Duration2, TimeZonePtr2>& y, choose);
28 Constraints: is_convertible_v<sys_time<Duration2>, sys_time<Duration>> is true.
29 Preconditions: z refers to a valid time zone.
30 Effects: Equivalent to construction with{z, y}.
31 [Note 1: The choose parameter has no effect.—end note]
template<class Duration2, class TimeZonePtr2>
zoned_time(string_view name, const zoned_time<Duration2, TimeZonePtr2>& y);
32 Constraints: zoned_time is constructible from the return type oftraits::locate_zone(name) and
the typezoned_time<Duration2, TimeZonePtr2>.
33 Effects: Equivalent to construction with{traits::locate_zone(name), y}.
template<class Duration2, class TimeZonePtr2>
zoned_time(string_view name, const zoned_time<Duration2, TimeZonePtr2>& y, choose c);
34 Constraints: zoned_time is constructible from the return type oftraits::locate_zone(name), the
type zoned_time<Duration2, TimeZonePtr2>, and the typechoose.
35 Effects: Equivalent to construction with{traits::locate_zone(name), y, c}.
36 [Note 2: The choose parameter has no effect.—end note]
30.11.7.3 Member functions [time.zone.zonedtime.members]
zoned_time& operator=(const sys_time<Duration>& st);
1 Effects: After assignment,get_sys_time() == st. This assignment has no effect on the return value
of get_time_zone().
2 Returns: *this.
§ 30.11.7.3 © ISO/IEC
1990

===== PAGE 2002 =====

Dxxxx
zoned_time& operator=(const local_time<Duration>& lt);
3 Effects: After assignment, get_local_time() == lt. This assignment has no effect on the return
value ofget_time_zone().
4 Returns: *this.
operator sys_time<duration>() const;
5 Returns: get_sys_time().
explicit operator local_time<duration>() const;
6 Returns: get_local_time().
TimeZonePtr get_time_zone() const;
7 Returns: zone_.
local_time<duration> get_local_time() const;
8 Returns: zone_->to_local(tp_).
sys_time<duration> get_sys_time() const;
9 Returns: tp_.
sys_info get_info() const;
10 Returns: zone_->get_info(tp_).
30.11.7.4 Non-member functions [time.zone.zonedtime.nonmembers]
template<class Duration1, class Duration2, class TimeZonePtr>
bool operator==(const zoned_time<Duration1, TimeZonePtr>& x,
const zoned_time<Duration2, TimeZonePtr>& y);
1 Returns: x.zone_ == y.zone_ && x.tp_ == y.tp_.
template<class charT, class traits, class Duration, class TimeZonePtr>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os,
const zoned_time<Duration, TimeZonePtr>& t);
2 Effects: Equivalent to:
return os << format(os.getloc(), STATICALLY-WIDEN <charT>("{:L%F %T %Z}"), t);
30.11.8 Class leap_second [time.zone.leap]
30.11.8.1 Overview [time.zone.leap.overview]
namespace std::chrono {
class leap_second {
public:
leap_second(const leap_second&) = default;
leap_second& operator=(const leap_second&) = default;
// unspecified additional constructors
constexpr sys_seconds date() const noexcept;
constexpr seconds value() const noexcept;
};
}
1 Objects of typeleap_second representing the date and value of the leap second insertions are constructed
and stored in the time zone database when initialized.
2 [Example 1:
for (auto& l : get_tzdb().leap_seconds)
if (l <= sys_days{2018y/March/17d})
cout << l.date() << ": " << l.value() << '\n';
§ 30.11.8.1 © ISO/IEC
1991

===== PAGE 2003 =====

Dxxxx
Produces the output:
1972-07-01 00:00:00: 1s
1973-01-01 00:00:00: 1s
1974-01-01 00:00:00: 1s
1975-01-01 00:00:00: 1s
1976-01-01 00:00:00: 1s
1977-01-01 00:00:00: 1s
1978-01-01 00:00:00: 1s
1979-01-01 00:00:00: 1s
1980-01-01 00:00:00: 1s
1981-07-01 00:00:00: 1s
1982-07-01 00:00:00: 1s
1983-07-01 00:00:00: 1s
1985-07-01 00:00:00: 1s
1988-01-01 00:00:00: 1s
1990-01-01 00:00:00: 1s
1991-01-01 00:00:00: 1s
1992-07-01 00:00:00: 1s
1993-07-01 00:00:00: 1s
1994-07-01 00:00:00: 1s
1996-01-01 00:00:00: 1s
1997-07-01 00:00:00: 1s
1999-01-01 00:00:00: 1s
2006-01-01 00:00:00: 1s
2009-01-01 00:00:00: 1s
2012-07-01 00:00:00: 1s
2015-07-01 00:00:00: 1s
2017-01-01 00:00:00: 1s
—end example]
30.11.8.2 Member functions [time.zone.leap.members]
constexpr sys_seconds date() const noexcept;
1 Returns: The date and time at which the leap second was inserted.
constexpr seconds value() const noexcept;
2 Returns: +1s to indicate a positive leap second or-1s to indicate a negative leap second.
[Note 1: All leap seconds inserted up through 2022 were positive leap seconds.—end note]
30.11.8.3 Non-member functions [time.zone.leap.nonmembers]
constexpr bool operator==(const leap_second& x, const leap_second& y) noexcept;
1 Returns: x.date() == y.date().
constexpr strong_ordering operator<=>(const leap_second& x, const leap_second& y) noexcept;
2 Returns: x.date() <=> y.date().
template<class Duration>
constexpr bool operator==(const leap_second& x, const sys_time<Duration>& y) noexcept;
3 Returns: x.date() == y.
template<class Duration>
constexpr bool operator<(const leap_second& x, const sys_time<Duration>& y) noexcept;
4 Returns: x.date() < y.
template<class Duration>
constexpr bool operator<(const sys_time<Duration>& x, const leap_second& y) noexcept;
5 Returns: x < y.date().
§ 30.11.8.3 © ISO/IEC
1992

===== PAGE 2004 =====

Dxxxx
template<class Duration>
constexpr bool operator>(const leap_second& x, const sys_time<Duration>& y) noexcept;
6 Returns: y < x.
template<class Duration>
constexpr bool operator>(const sys_time<Duration>& x, const leap_second& y) noexcept;
7 Returns: y < x.
template<class Duration>
constexpr bool operator<=(const leap_second& x, const sys_time<Duration>& y) noexcept;
8 Returns: !(y < x).
template<class Duration>
constexpr bool operator<=(const sys_time<Duration>& x, const leap_second& y) noexcept;
9 Returns: !(y < x).
template<class Duration>
constexpr bool operator>=(const leap_second& x, const sys_time<Duration>& y) noexcept;
10 Returns: !(x < y).
template<class Duration>
constexpr bool operator>=(const sys_time<Duration>& x, const leap_second& y) noexcept;
11 Returns: !(x < y).
template<class Duration>
requires three_way_comparable_with<sys_seconds, sys_time<Duration>>
constexpr auto operator<=>(const leap_second& x, const sys_time<Duration>& y) noexcept;
12 Returns: x.date() <=> y.
30.11.9 Class time_zone_link [time.zone.link]
30.11.9.1 Overview [time.zone.link.overview]
namespace std::chrono {
class time_zone_link {
public:
time_zone_link(time_zone_link&&) = default;
time_zone_link& operator=(time_zone_link&&) = default;
// unspecified additional constructors
string_view name() const noexcept;
string_view target() const noexcept;
};
}
1 A time_zone_link specifies an alternative name for atime_zone. time_zone_links are constructed when
the time zone database is initialized.
30.11.9.2 Member functions [time.zone.link.members]
string_view name() const noexcept;
1 Returns: The alternative name for the time zone.
string_view target() const noexcept;
2 Returns: The name of thetime_zone for which thistime_zone_link provides an alternative name.
30.11.9.3 Non-member functions [time.zone.link.nonmembers]
bool operator==(const time_zone_link& x, const time_zone_link& y) noexcept;
1 Returns: x.name() == y.name().
§ 30.11.9.3 © ISO/IEC
1993

===== PAGE 2005 =====

Dxxxx
strong_ordering operator<=>(const time_zone_link& x, const time_zone_link& y) noexcept;
2 Returns: x.name() <=> y.name().
30.12 Formatting [time.format]
1 Each formatter (28.5.6) specialization in the chrono library (30.2) meets theFormatter requirements
(28.5.6.1). The parse member functions of these formatters interpret the format specification as achrono-
format-spec according to the following syntax:
chrono-format-spec:
fill-and-alignopt widthopt precisionopt Lopt chrono-specsopt
chrono-specs:
conversion-spec
chrono-specs conversion-spec
chrono-specs literal-char
literal-char:
any character other than{, }, or%
conversion-spec:
% modifieropt type
modifier: one of
E O
type: one of
a A b B c C d D e F g G h H I j m M n
p q Q r R S t T u U V w W x X y Y z Z %
The productionsfill-and-align, width, andprecision are described in 28.5.2. Giving aprecision specification
in the chrono-format-spec is valid only for types that are specializations ofstd::chrono::duration for
which the nestedtypedef-name rep denotes a floating-point type. For all other types, an exception of type
format_error is thrown if thechrono-format-spec contains aprecision specification. All ordinary multibyte
characters represented byliteral-char are copied unchanged to the output.
2 A formatting localeis an instance oflocale used by a formatting function, defined as
—(2.1) the "C" locale if theL option is not present inchrono-format-spec, otherwise
—(2.2) the locale passed to the formatting function if any, otherwise
—(2.3) the global locale.
3 Each conversion specifierconversion-spec is replaced by appropriate characters as described in Table 133;
the formats specified in ISO 8601-1:2019 shall be used where so described. Some of the conversion specifiers
depend on the formatting locale. If the string literal encoding is a Unicode encoding form and the locale is
among an implementation-defined set of locales, each replacement that depends on the locale is performed as
if the replacement character sequence is converted to the string literal encoding. If the formatted object does
not contain the information the conversion specifier refers to, an exception of typeformat_error is thrown.
4 The result of formatting astd::chrono::duration instance holding a negative value, or anhh_mm_ss object
h for whichh.is_negative() is true, is equivalent to the output of the corresponding positive value, with a
STATICALLY-WIDEN <charT>("-") character sequence placed before the replacement of the initial conversion
specifier.
[Example 1:
cout << format("{:%T}", -10'000s); // prints: -02:46:40
cout << format("{:%H:%M:%S}", -10'000s); // prints: -02:46:40
cout << format("minutes {:%M, hours %H, seconds %S}", -10'000s);
// prints: minutes -46, hours 02, seconds 40
—end example]
5 Unless explicitly requested, the result of formatting a chrono type does not contain time zone abbreviation
and time zone offset information. If the information is available, the conversion specifiers%Z and %z will
format this information (respectively).
[Note 1: If the information is not available and a%Z or %z conversion specifier appears in thechrono-format-spec, an
exception of typeformat_error is thrown, as described above.—end note]
§ 30.12 © ISO/IEC
1994

===== PAGE 2006 =====

Dxxxx
6 If the type being formatted does not contain the information that the format flag needs, an exception of type
format_error is thrown.
[Example 2: A duration does not contain enough information to format as aweekday. —end example]
However, if a flag refers to a “time of day” (e.g.,%H, %I, %p, etc.), then a specialization ofduration is
interpreted as the time of day elapsed since midnight.
Table 133 — Meaning of conversion specifiers [tab:time.format.spec]
Specifier Replacement
%a The locale’s abbreviated weekday name. If the value does not contain a valid weekday,
an exception of typeformat_error is thrown.
%A The locale’s full weekday name. If the value does not contain a valid weekday, an
exception of typeformat_error is thrown.
%b The locale’s abbreviated month name. If the value does not contain a valid month, an
exception of typeformat_error is thrown.
%B The locale’s full month name. If the value does not contain a valid month, an
exception of typeformat_error is thrown.
%c The locale’s date and time representation. The modified command%Ec produces the
locale’s alternate date and time representation.
%C The year divided by 100 using floored division. If the result is a single decimal digit, it
is prefixed with0. The modified command%EC produces the locale’s alternative
representation of the century.
%d The day of month as a decimal number. If the result is a single decimal digit, it is
prefixed with0. The modified command%Od produces the locale’s alternative
representation.
%D Equivalent to%m/%d/%y.
%e The day of month as a decimal number. If the result is a single decimal digit, it is
prefixed with a space. The modified command%Oe produces the locale’s alternative
representation.
%F Equivalent to%Y-%m-%d.
%g The last two decimal digits of the calendar year as specified in ISO 8601-1:2019 for the
week calendar. If the result is a single digit it is prefixed by0.
%G The calendar year as a decimal number, as specified in ISO 8601-1:2019 for the week
calendar. If the result is less than four digits it is left-padded with0 to four digits.
%h Equivalent to%b.
%H The hour (24-hour clock) as a decimal number. If the result is a single digit, it is
prefixed with0. The modified command%OH produces the locale’s alternative
representation.
%I The hour (12-hour clock) as a decimal number. If the result is a single digit, it is
prefixed with0. The modified command%OI produces the locale’s alternative
representation.
%j If the type being formatted is a specialization ofduration, the decimal number of
days without padding. Otherwise, the day of the year as a decimal number. January 1
is 001. If the result is less than three digits, it is left-padded with0 to three digits.
%m The month as a decimal number. Jan is01. If the result is a single digit, it is prefixed
with 0. The modified command%Om produces the locale’s alternative representation.
%M The minute as a decimal number. If the result is a single digit, it is prefixed with0.
The modified command%OM produces the locale’s alternative representation.
%n A new-line character.
%p The locale’s equivalent of the AM/PM designations associated with a 12-hour clock.
%q The duration’s unit suffix as specified in 30.5.11.
%Q The duration’s numeric value (as if extracted via.count()).
%r The locale’s 12-hour clock time.
%R Equivalent to%H:%M.
§ 30.12 © ISO/IEC
1995

===== PAGE 2007 =====

Dxxxx
Table 133 — Meaning of conversion specifiers (continued)
Specifier Replacement
%S Seconds as a decimal number. If the number of seconds is less than10, the result is
prefixed with0. If the precision of the input cannot be exactly represented with
seconds, then the format is a decimal floating-point number with a fixed format and a
precision matching that of the precision of the input (or to a microseconds precision if
the conversion to floating-point decimal seconds cannot be made within 18 fractional
digits). The character for the decimal point is localized according to the locale. The
modified command%OS produces the locale’s alternative representation.
%t A horizontal-tab character.
%T Equivalent to%H:%M:%S.
%u The calendar day of week as a decimal number (1-7), as specified in ISO 8601-1:2019,
where Monday is1. The modified command%Ou produces the locale’s alternative
representation.
%U The week number of the year as a decimal number. The first Sunday of the year is the
first day of week01. Days of the same year prior to that are in week00. If the result is
a single digit, it is prefixed with0. The modified command%OU produces the locale’s
alternative representation.
%V The calendar week of year as a decimal number, as specified in ISO 8601-1:2019 for the
week calendar. If the result is a single digit, it is prefixed with0. The modified
command %OV produces the locale’s alternative representation.
%w The weekday as a decimal number (0-6), where Sunday is0. The modified command
%Ow produces the locale’s alternative representation.
%W The week number of the year as a decimal number. The first Monday of the year is the
first day of week01. Days of the same year prior to that are in week00. If the result is
a single digit, it is prefixed with0. The modified command%OW produces the locale’s
alternative representation.
%x The locale’s date representation. The modified command%Ex produces the locale’s
alternate date representation.
%X The locale’s time representation. The modified command%EX produces the locale’s
alternate time representation.
%y The last two decimal digits of the year. If the result is a single digit, it is prefixed by0.
The modified command%Oy produces the locale’s alternative representation. The
modified command%Ey produces the locale’s alternative representation of offset from
%EC (year only).
%Y The year as a decimal number. If the result is less than four digits, it is left-padded
with 0 to four digits. The modified command%EY produces the locale’s alternative full
year representation.
%z The offset from UTC as specified in ISO 8601-1:2019, 5.3.4.1. For example-0430 refers
to 4 hours 30 minutes behind UTC. If the offset is zero,+0000 is used. The modified
commands %Ez and %Oz insert a: between the hours and minutes:-04:30. If the
offset information is not available, an exception of typeformat_error is thrown.
%Z The time zone abbreviation. If the time zone abbreviation is not available, an
exception of typeformat_error is thrown.
%% A % character.
7 Unless otherwise specified, if thechrono-specs is omitted, the chrono object is formatted as if by streaming it
to basic_ostringstream<charT> os with the formatting locale imbued and copyingos.str() through the
output iterator of the context with additional padding and adjustments as specified by the format specifiers.
[Example 3:
string s = format("{:=>8}", 42ms); // value ofs is "====42ms"
—end example]
8 For chrono::duration the library only provides the following specialization of enable_nonlocking_-
formatter_optimization:
§ 30.12 © ISO/IEC
1996

===== PAGE 2008 =====

Dxxxx
template<class Rep, class Period>
constexpr bool enable_nonlocking_formatter_optimization<
chrono::duration<Rep, Period>> =
enable_nonlocking_formatter_optimization<Rep>;
9 For chrono::zoned_time the library only provides the following specialization ofenable_nonlocking_-
formatter_optimization:
template<class Duration>
constexpr bool enable_nonlocking_formatter_optimization<
chrono::zoned_time<Duration, const std::chrono::time_zone*>> = true;
template<class Duration, class charT>
struct formatter<chrono::sys_time<Duration>, charT>;
10 Remarks: If %Z is used, it is replaced withSTATICALLY-WIDEN <charT>("UTC"). If %z (or a modified
variant of%z) is used, an offset of0min is formatted.
template<class Duration, class charT>
struct formatter<chrono::utc_time<Duration>, charT>;
11 Remarks: If %Z is used, it is replaced withSTATICALLY-WIDEN <charT>("UTC"). If %z (or a modified
variant of %z) is used, an offset of0min is formatted. If the argument represents a time during a
positive leap second insertion, and if a seconds field is formatted, the integral portion of that format is
STATICALLY-WIDEN <charT>("60").
template<class Duration, class charT>
struct formatter<chrono::tai_time<Duration>, charT>;
12 Remarks: If %Z is used, it is replaced withSTATICALLY-WIDEN <charT>("TAI"). If %z (or a modified
variant of%z) is used, an offset of0min is formatted. The date and time formatted are equivalent to
those formatted by asys_time initialized with
sys_time<Duration>{tp.time_since_epoch()} -
(sys_days{1970y/January/1} - sys_days{1958y/January/1})
template<class Duration, class charT>
struct formatter<chrono::gps_time<Duration>, charT>;
13 Remarks: If %Z is used, it is replaced withSTATICALLY-WIDEN <charT>("GPS"). If %z (or a modified
variant of%z) is used, an offset of0min is formatted. The date and time formatted are equivalent to
those formatted by asys_time initialized with
sys_time<Duration>{tp.time_since_epoch()} +
(sys_days{1980y/January/Sunday[1]} - sys_days{1970y/January/1})
template<class Duration, class charT>
struct formatter<chrono::file_time<Duration>, charT>;
14 Remarks: If %Z is used, it is replaced withSTATICALLY-WIDEN <charT>("UTC"). If %z (or a modified
variant of%z) is used, an offset of0min is formatted. The date and time formatted are equivalent
to those formatted by asys_time initialized withclock_cast<system_clock>(t), or by autc_time
initialized withclock_cast<utc_clock>(t), wheret is the first argument toformat.
template<class Duration, class charT>
struct formatter<chrono::local_time<Duration>, charT>;
15 Remarks: If %Z, %z, or a modified version of%z is used, an exception of typeformat_error is thrown.
template<class Duration> struct local-time-format-t { // exposition only
local_time<Duration> time; // exposition only
const string* abbrev; // exposition only
const seconds* offset_sec; // exposition only
};
template<class Duration>
local-time-format-t <Duration>
local_time_format(local_time<Duration> time, const string* abbrev = nullptr,
const seconds* offset_sec = nullptr);
16 Returns: {time, abbrev, offset_sec}.
§ 30.12 © ISO/IEC
1997

===== PAGE 2009 =====

Dxxxx
template<class Duration, class charT>
struct formatter<chrono::local-time-format-t <Duration>, charT>;
17 Let f be alocal-time-format-t <Duration> object passed toformatter::format.
18 Remarks: If thechrono-specs is omitted, the result is equivalent to using%F %T %Z as thechrono-specs.
If %Z is used, it is replaced with*f.abbrev if f.abbrev is not a null pointer value. If%Z is used and
f.abbrev is a null pointer value, an exception of typeformat_error is thrown. If%z (or a modified
variant of%z) is used, it is formatted with the value of*f.offset_sec if f.offset_sec is not a null
pointer value. If%z (or a modified variant of%z) is used andf.offset_sec is a null pointer value,
then an exception of typeformat_error is thrown.
template<class Duration, class TimeZonePtr, class charT>
struct formatter<chrono::zoned_time<Duration, TimeZonePtr>, charT>
: formatter<chrono::local-time-format-t <common_type_t<Duration, seconds>>, charT> {
template<class FormatContext>
typename FormatContext::iterator
format(const chrono::zoned_time<Duration, TimeZonePtr>& tp, FormatContext& ctx) const;
};
template<class FormatContext>
typename FormatContext::iterator
format(const chrono::zoned_time<Duration, TimeZonePtr>& tp, FormatContext& ctx) const;
19 Effects: Equivalent to:
sys_info info = tp.get_info();
return formatter<chrono::local-time-format-t <common_type_t<Duration, seconds>>, charT>::
format({tp.get_local_time(), &info.abbrev, &info.offset}, ctx);
30.13 Parsing [time.parse]
1 Each parse overload specified in this subclause callsfrom_stream unqualified, so as to enable argument-
dependent lookup (6.5.4). In the following paragraphs, letis denote an object of typebasic_istream<charT,
traits> and letI be basic_istream<charT, traits>&, wherecharT and traits are template parameters
in that context.
2 Recommended practice: Implementations should make it difficult to accidentally store or use a manipulator
that may contain a dangling reference to a format string, for example by making the manipulators produced
by parse immovable and preventing stream extraction into an lvalue of such a manipulator type.
template<class charT, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp);
3 Let F be fmt for the first overload andfmt.c_str() for the second overload. Lettraits be char_-
traits<charT> for the first overload.
4 Constraints: The expression
from_stream(declval<basic_istream<charT, traits>&>(), F, tp)
is well-formed when treated as an unevaluated operand (7.2.3).
5 Returns: A manipulator such that the expressionis >> parse(fmt, tp) has typeI, has valueis,
and callsfrom_stream(is, F, tp).
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev);
6 Let F be fmt for the first overload andfmt.c_str() for the second overload.
§ 30.13 © ISO/IEC
1998

===== PAGE 2010 =====

Dxxxx
7 Constraints: The expression
from_stream(declval<basic_istream<charT, traits>&>(), F, tp, addressof(abbrev))
is well-formed when treated as an unevaluated operand (7.2.3).
8 Returns: A manipulator such that the expressionis >> parse(fmt, tp, abbrev) has typeI, has
value is, and callsfrom_stream(is, F, tp, addressof(abbrev)).
template<class charT, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp, minutes& offset);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
minutes& offset);
9 Let F be fmt for the first overload andfmt.c_str() for the second overload. Lettraits be char_-
traits<charT> and Alloc be allocator<charT> for the first overload.
10 Constraints: The expression
from_stream(declval<basic_istream<charT, traits>&>(),
F, tp,
declval<basic_string<charT, traits, Alloc>*>(),
&offset)
is well-formed when treated as an unevaluated operand (7.2.3).
11 Returns: A manipulator such that the expressionis >> parse(fmt, tp, offset) has typeI, has
value is, and calls:
from_stream(is,
F, tp,
static_cast<basic_string<charT, traits, Alloc>*>(nullptr),
&offset)
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const charT* fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev, minutes& offset);
template<class charT, class traits, class Alloc, class Parsable>
unspecified
parse(const basic_string<charT, traits, Alloc>& fmt, Parsable& tp,
basic_string<charT, traits, Alloc>& abbrev, minutes& offset);
12 Let F be fmt for the first overload andfmt.c_str() for the second overload.
13 Constraints: The expression
from_stream(declval<basic_istream<charT, traits>&>(),
F, tp, addressof(abbrev), &offset)
is well-formed when treated as an unevaluated operand (7.2.3).
14 Returns: A manipulator such that the expressionis >> parse(fmt, tp, abbrev, offset) has type
I, has valueis, and callsfrom_stream(is, F, tp, addressof(abbrev), &offset).
15 All from_stream overloads behave as unformatted input functions, except that they have an unspecified
effect on the value returned by subsequent calls tobasic_istream<>::gcount(). Each overload takes a
format string containing ordinary characters and flags which have special meaning. Each flag begins with a%.
Some flags can be modified byE or O. During parsing each flag interprets characters as parts of date and
time types according to Table 134. Some flags can be modified by a width parameter given as a positive
decimal integer called out asN below which governs how many characters are parsed from the stream in
interpreting the flag. All characters in the format string that are not represented in Table 134, except for
whitespace, are parsed unchanged from the stream. A whitespace character matches zero or more whitespace
characters in the input stream.
16 If the type being parsed cannot represent the information that the format flag refers to,is.setstate(ios_-
base::failbit) is called.
[Example 1: A duration cannot represent aweekday. —end example]
§ 30.13 © ISO/IEC
1999

===== PAGE 2011 =====

Dxxxx
However, if a flag refers to a “time of day” (e.g.,%H, %I, %p, etc.), then a specialization ofduration is parsed
as the time of day elapsed since midnight.
17 If the from_stream overload fails to parse everything specified by the format string, or if insufficient
information is parsed to specify a complete duration, time point, or calendrical data structure,setstate(ios_-
base::failbit) is called on thebasic_istream.
Table 134 — Meaning ofparse flags [tab:time.parse.spec]
Flag Parsed value
%a The locale’s full or abbreviated case-insensitive weekday name.
%A Equivalent to%a.
%b The locale’s full or abbreviated case-insensitive month name.
%B Equivalent to%b.
%c The locale’s date and time representation. The modified command%Ec interprets the
locale’s alternate date and time representation.
%C The century as a decimal number. The modified command%N C specifies the maximum
number of characters to read. IfN is not specified, the default is 2. Leading zeroes are
permitted but not required. The modified command%EC interprets the locale’s
alternative representation of the century.
%d The day of the month as a decimal number. The modified command%N d specifies the
maximum number of characters to read. IfN is not specified, the default is 2. Leading
zeroes are permitted but not required. The modified command%Od interprets the
locale’s alternative representation of the day of the month.
%D Equivalent to%m/%d/%y.
%e Equivalent to%d and can be modified like%d.
%F Equivalent to%Y-%m-%d. If modified with a widthN , the width is applied to only%Y.
%g The last two decimal digits of the calendar year, as specified in ISO 8601-1:2019 for the
week calendar. The modified command%N g specifies the maximum number of
characters to read. IfN is not specified, the default is 2. Leading zeroes are permitted
but not required.
%G The calendar year as a decimal number, as specified in ISO 8601-1:2019 for the week
calendar. The modified command%N G specifies the maximum number of characters to
read. If N is not specified, the default is 4. Leading zeroes are permitted but not
required.
%h Equivalent to%b.
%H The hour (24-hour clock) as a decimal number. The modified command%N H specifies
the maximum number of characters to read. IfN is not specified, the default is 2.
Leading zeroes are permitted but not required. The modified command%OH interprets
the locale’s alternative representation.
%I The hour (12-hour clock) as a decimal number. The modified command%N I specifies
the maximum number of characters to read. IfN is not specified, the default is 2.
Leading zeroes are permitted but not required. The modified command%OI interprets
the locale’s alternative representation.
%j If the type being parsed is a specialization ofduration, a decimal number ofdays.
Otherwise, the day of the year as a decimal number. January 1 is1. In either case, the
modified command%N j specifies the maximum number of characters to read. IfN is
not specified, the default is 3. Leading zeroes are permitted but not required.
%m The month as a decimal number. January is1. The modified command%N m specifies
the maximum number of characters to read. IfN is not specified, the default is 2.
Leading zeroes are permitted but not required. The modified command%Om interprets
the locale’s alternative representation.
%M The minutes as a decimal number. The modified command%N M specifies the maximum
number of characters to read. IfN is not specified, the default is 2. Leading zeroes are
permitted but not required. The modified command%OM interprets the locale’s
alternative representation.
§ 30.13 © ISO/IEC
2000

===== PAGE 2012 =====

Dxxxx
Table 134 — Meaning ofparse flags (continued)
Flag Parsed value
%n Matches one whitespace character.
[Note 1: %n, %t, and a space can be combined to match a wide range of whitespace patterns.
For example,"%n " matches one or more whitespace characters, and"%n%t%t" matches one to
three whitespace characters. —end note]
%p The locale’s equivalent of the AM/PM designations associated with a 12-hour clock.
%r The locale’s 12-hour clock time.
%R Equivalent to%H:%M.
%S The seconds as a decimal number. The modified command%N S specifies the maximum
number of characters to read. IfN is not specified, the default is 2 if the input time
has a precision convertible to seconds. Otherwise the default width is determined by
the decimal precision of the input and the field is interpreted as along double in a
fixed format. If encountered, the locale determines the decimal point character.
Leading zeroes are permitted but not required. The modified command%OS interprets
the locale’s alternative representation.
%t Matches zero or one whitespace characters.
%T Equivalent to%H:%M:%S.
%u The calendar day of week as a decimal number (1-7), as specified in ISO 8601-1:2019,
where Monday is1. The modified command%N u specifies the maximum number of
characters to read. IfN is not specified, the default is1. Leading zeroes are permitted
but not required.
%U The week number of the year as a decimal number. The first Sunday of the year is the
first day of week01. Days of the same year prior to that are in week00. The modified
command %N U specifies the maximum number of characters to read. IfN is not
specified, the default is 2. Leading zeroes are permitted but not required. The
modified command%OU interprets the locale’s alternative representation.
%V The calendar week of year as a decimal number, as specified in ISO 8601-1:2019 for the
week calendar. The modified command%N V specifies the maximum number of
characters to read. IfN is not specified, the default is 2. Leading zeroes are permitted
but not required.
%w The weekday as a decimal number (0-6), where Sunday is0. The modified command
%N w specifies the maximum number of characters to read. IfN is not specified, the
default is1. Leading zeroes are permitted but not required. The modified command
%Ow interprets the locale’s alternative representation.
%W The week number of the year as a decimal number. The first Monday of the year is the
first day of week01. Days of the same year prior to that are in week00. The modified
command %N W specifies the maximum number of characters to read. IfN is not
specified, the default is 2. Leading zeroes are permitted but not required. The
modified command%OW interprets the locale’s alternative representation.
%x The locale’s date representation. The modified command%Ex interprets the locale’s
alternate date representation.
%X The locale’s time representation. The modified command%EX interprets the locale’s
alternate time representation.
%y The last two decimal digits of the year. If the century is not otherwise specified (e.g.,
with %C), values in the range[69,99] are presumed to refer to the years 1969 to 1999,
and values in the range[00,68] are presumed to refer to the years 2000 to 2068. The
modified command%N y specifies the maximum number of characters to read. IfN is
not specified, the default is 2. Leading zeroes are permitted but not required. The
modified commands%Ey and %Oy interpret the locale’s alternative representation.
%Y The year as a decimal number. The modified command%N Y specifies the maximum
number of characters to read. IfN is not specified, the default is 4. Leading zeroes are
permitted but not required. The modified command%EY interprets the locale’s
alternative representation.
§ 30.13 © ISO/IEC
2001

===== PAGE 2013 =====

Dxxxx
Table 134 — Meaning ofparse flags (continued)
Flag Parsed value
%z The offset from UTC in the format[+|-]hh[mm]. For example-0430 refers to 4 hours
30 minutes behind UTC, and04 refers to 4 hours ahead of UTC. The modified
commands %Ez and %Oz parse a: between the hours and minutes and render leading
zeroes on the hour field optional:[+|-]h[h][:mm]. For example-04:30 refers to 4
hours 30 minutes behind UTC, and4 refers to 4 hours ahead of UTC.
%Z The time zone abbreviation or name. A single word is parsed. This word can only
contain characters from the basic character set (5.3.1) that are alphanumeric, or one of
’_’, ’/’, ’-’, or’+’.
%% A % character is extracted.
30.14 Hash support [time.hash]
template<class Rep, class Period> struct hash<chrono::duration<Rep, Period>>;
1 The specializationhash<chrono::duration<Rep, Period>> is enabled (22.10.19) if and only if
hash<Rep> is enabled. The member functions are not guaranteed to benoexcept.
template<class Clock, class Duration> struct hash<chrono::time_point<Clock, Duration>>;
2 The specializationhash<chrono::time_point<Clock, Duration>> is enabled (22.10.19) if and only
if hash<Duration> is enabled. The member functions are not guaranteed to benoexcept.
template<> struct hash<chrono::day>;
template<> struct hash<chrono::month>;
template<> struct hash<chrono::year>;
template<> struct hash<chrono::weekday>;
template<> struct hash<chrono::weekday_indexed>;
template<> struct hash<chrono::weekday_last>;
template<> struct hash<chrono::month_day>;
template<> struct hash<chrono::month_day_last>;
template<> struct hash<chrono::month_weekday>;
template<> struct hash<chrono::month_weekday_last>;
template<> struct hash<chrono::year_month>;
template<> struct hash<chrono::year_month_day>;
template<> struct hash<chrono::year_month_day_last>;
template<> struct hash<chrono::year_month_weekday>;
template<> struct hash<chrono::year_month_weekday_last>;
3 The specializations are enabled (22.10.19).
[Note 1: All thehash<Key> specializations listed above meet theCpp17Hash requirements, even when called on
objects k of typeKey such thatk.ok() is false. —end note]
template<class Duration, class TimeZonePtr>
struct hash<chrono::zoned_time<Duration, TimeZonePtr>>;
4 The specializationhash<chrono::zoned_time<Duration, TimeZonePtr>> is enabled (22.10.19) if and
only ifhash<Duration> is enabled andhash<TimeZonePtr> is enabled. The member functions are not
guaranteed to benoexcept.
template<> struct hash<chrono::leap_second>;
5 The specialization is enabled (22.10.19).
30.15 Header <ctime> synopsis [ctime.syn]
#define __STDC_VERSION_TIME_H__ 202311L
#define NULL see 17.2.3
#define CLOCKS_PER_SEC see below
#define TIME_UTC see below
#define TIME_MONOTONIC see below // optional
#define TIME_ACTIVE see below // optional
#define TIME_THREAD_ACTIVE see below // optional
§ 30.15 © ISO/IEC
2002

===== PAGE 2014 =====

Dxxxx
namespace std {
using size_t = see 17.2.4;
using clock_t = see below ;
using time_t = see below ;
struct timespec;
struct tm;
clock_t clock();
double difftime(time_t time1, time_t time0);
time_t mktime(tm* timeptr);
time_t timegm(tm* timeptr);
time_t time(time_t* timer);
int timespec_get(timespec* ts, int base);
int timespec_getres(timespec* ts, int base);
tm* gmtime(const time_t* timer);
tm* gmtime_r(const time_t* timer, tm* buf);
tm* localtime(const time_t* timer);
tm* localtime_r(const time_t* timer, tm* buf);
size_t strftime(char* s, size_t maxsize, const char* format, const tm* timeptr);
}
1 The contents of the header<ctime> are the same as the C standard library header<time.h>.246
2 The functionsgmtime and localtime are not required to avoid data races (16.4.6.10).
See also: ISO/IEC 9899:2024, 7.29
246) strftime supports the C conversion specifiersC, D, e, F, g, G, h, r, R, t, T, u, V, andz, and the modifiersE and O.
§ 30.15 © ISO/IEC
2003

===== PAGE 2015 =====

Dxxxx
31 Input/output library [input.output]
31.1 General [input.output.general]
1 This Clause describes components that C++ programs may use to perform input/output operations.
2 The following subclauses describe requirements for stream parameters, and components for forward declara-
tions of iostreams, predefined iostreams objects, base iostreams classes, stream buffering, stream formatting
and manipulators, string streams, and file streams, as summarized in Table 135.
Table 135 — Input/output library summary [tab:iostreams.summary]
Subclause Header
31.2 Requirements
31.3 Forward declarations <iosfwd>
31.4 Standard iostream objects <iostream>
31.5 Iostreams base classes <ios>
31.6 Stream buffers <streambuf>
31.7 Formatting and manipulators <istream>, <ostream>, <iomanip>, <print>
31.8 String streams <sstream>
31.9 Span-based streams <spanstream>
31.10 File streams <fstream>
31.11 Synchronized output streams <syncstream>
31.12 File systems <filesystem>
31.13 C library files <cstdio>, <cinttypes>
31.2 Iostreams requirements [iostreams.requirements]
31.2.1 Imbue limitations [iostream.limits.imbue]
1 No function described in Clause 31 except forios_base::imbue and basic_filebuf::pubimbue causes any
instance of basic_ios::imbue or basic_streambuf::imbue to be called. If any user function called from a
function declared in Clause 31 or as an overriding virtual function of any class declared in Clause 31 calls
imbue, the behavior is undefined.
31.2.2 Types [stream.types]
using streamoff = implementation-defined ;
1 The typestreamoff is a synonym for one of the signed basic integral types of sufficient size to represent
the maximum possible file size for the operating system.247
using streamsize = implementation-defined ;
2 The typestreamsize is a synonym for one of the signed basic integral types. It is used to represent
the number of characters transferred in an I/O operation, or the size of I/O buffers.248
31.2.3 Positioning type limitations [iostreams.limits.pos]
1 The classes of Clause 31 with template argumentscharT and traits behave as described iftraits::pos_-
type and traits::off_type are streampos and streamoff respectively. Except as noted explicitly below,
their behavior whentraits::pos_type and traits::off_type are other types is implementation-defined.
2 [Note 1: For each of the specializations ofchar_traits defined in 27.2.4,state_type denotes mbstate_t, pos_type
denotes fpos<mbstate_t>, andoff_type denotes streamoff. —end note]
3 In the classes of Clause 31, a template parameter with namecharT represents a member of the set of types
containing char, wchar_t, and any other implementation-defined character container types (3.10) that meet
the requirements for a character on which any of the iostream components can be instantiated.
247) Typically long long.
248) Most places wherestreamsize is used would usesize_t in C, orssize_t in POSIX.
§ 31.2.3 © ISO/IEC
2004

===== PAGE 2016 =====

Dxxxx
31.2.4 Thread safety [iostreams.threadsafety]
1 Concurrent access to a stream object (31.8, 31.10), stream buffer object (31.6), or C Library stream (31.13)
by multiple threads may result in a data race (6.10.2) unless otherwise specified (31.4).
[Note 1: Data races result in undefined behavior (6.10.2).—end note]
2 If one thread makes a library calla that writes a value to a stream and, as a result, another thread reads this
value from the stream through a library callb such that this does not result in a data race, thena’s write
synchronizes withb’s read.
31.3 Forward declarations [iostream.forward]
31.3.1 Header <iosfwd> synopsis [iosfwd.syn]
namespace std {
template<class charT> struct char_traits;
template<> struct char_traits<char>;
template<> struct char_traits<char8_t>;
template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;
template<class T> class allocator;
template<class charT, class traits = char_traits<charT>>
class basic_ios;
template<class charT, class traits = char_traits<charT>>
class basic_streambuf;
template<class charT, class traits = char_traits<charT>>
class basic_istream;
template<class charT, class traits = char_traits<charT>>
class basic_ostream;
template<class charT, class traits = char_traits<charT>>
class basic_iostream;
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_stringbuf;
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_istringstream;
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_ostringstream;
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_stringstream;
template<class charT, class traits = char_traits<charT>>
class basic_spanbuf;
template<class charT, class traits = char_traits<charT>>
class basic_ispanstream;
template<class charT, class traits = char_traits<charT>>
class basic_ospanstream;
template<class charT, class traits = char_traits<charT>>
class basic_spanstream;
template<class charT, class traits = char_traits<charT>>
class basic_filebuf;
template<class charT, class traits = char_traits<charT>>
class basic_ifstream;
template<class charT, class traits = char_traits<charT>>
class basic_ofstream;
template<class charT, class traits = char_traits<charT>>
class basic_fstream;
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_syncbuf;
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_osyncstream;
§ 31.3.1 © ISO/IEC
2005

===== PAGE 2017 =====

Dxxxx
template<class charT, class traits = char_traits<charT>>
class istreambuf_iterator;
template<class charT, class traits = char_traits<charT>>
class ostreambuf_iterator;
using ios = basic_ios<char>;
using wios = basic_ios<wchar_t>;
using streambuf = basic_streambuf<char>;
using istream = basic_istream<char>;
using ostream = basic_ostream<char>;
using iostream = basic_iostream<char>;
using stringbuf = basic_stringbuf<char>;
using istringstream = basic_istringstream<char>;
using ostringstream = basic_ostringstream<char>;
using stringstream = basic_stringstream<char>;
using spanbuf = basic_spanbuf<char>;
using ispanstream = basic_ispanstream<char>;
using ospanstream = basic_ospanstream<char>;
using spanstream = basic_spanstream<char>;
using filebuf = basic_filebuf<char>;
using ifstream = basic_ifstream<char>;
using ofstream = basic_ofstream<char>;
using fstream = basic_fstream<char>;
using syncbuf = basic_syncbuf<char>;
using osyncstream = basic_osyncstream<char>;
using wstreambuf = basic_streambuf<wchar_t>;
using wistream = basic_istream<wchar_t>;
using wostream = basic_ostream<wchar_t>;
using wiostream = basic_iostream<wchar_t>;
using wstringbuf = basic_stringbuf<wchar_t>;
using wistringstream = basic_istringstream<wchar_t>;
using wostringstream = basic_ostringstream<wchar_t>;
using wstringstream = basic_stringstream<wchar_t>;
using wspanbuf = basic_spanbuf<wchar_t>;
using wispanstream = basic_ispanstream<wchar_t>;
using wospanstream = basic_ospanstream<wchar_t>;
using wspanstream = basic_spanstream<wchar_t>;
using wfilebuf = basic_filebuf<wchar_t>;
using wifstream = basic_ifstream<wchar_t>;
using wofstream = basic_ofstream<wchar_t>;
using wfstream = basic_fstream<wchar_t>;
using wsyncbuf = basic_syncbuf<wchar_t>;
using wosyncstream = basic_osyncstream<wchar_t>;
template<class state> class fpos;
using streampos = fpos<char_traits<char>::state_type>;
using wstreampos = fpos<char_traits<wchar_t>::state_type>;
using u8streampos = fpos<char_traits<char8_t>::state_type>;
using u16streampos = fpos<char_traits<char16_t>::state_type>;
using u32streampos = fpos<char_traits<char32_t>::state_type>;
}
§ 31.3.1 © ISO/IEC
2006

===== PAGE 2018 =====

Dxxxx
1 Default template arguments are described as appearing both in<iosfwd> and in the synopsis of other headers
but it is well-formed to include both<iosfwd> and one or more of the other headers.249
31.3.2 Overview [iostream.forward.overview]
1 The class template specializationbasic_ios<charT, traits> serves as a virtual base class for the class
templates basic_istream, basic_ostream, and class templates derived from them.basic_iostream is a
class template derived from bothbasic_istream<charT, traits> and basic_ostream<charT, traits>.
2 The class template specializationbasic_streambuf<charT, traits>serves as a base class for class templates
basic_stringbuf, basic_filebuf, andbasic_syncbuf.
3 The class template specializationbasic_istream<charT, traits> serves as a base class for class templates
basic_istringstream and basic_ifstream.
4 The class template specializationbasic_ostream<charT, traits> serves as a base class for class templates
basic_ostringstream, basic_ofstream, andbasic_osyncstream.
5 The class template specializationbasic_iostream<charT, traits> serves as a base class for class templates
basic_stringstream and basic_fstream.
6 [Note 1: For each of the class templates above, the program is ill-formed iftraits::char_type is not the same type
as charT (27.2). —end note]
7 Other typedef-names define instances of class templates specialized forchar or wchar_t types.
8 Specializations of the class templatefpos are used for specifying file position information.
[Example 1: The typesstreampos and wstreampos are used for positioning streams specialized onchar and wchar_t
respectively. —end example]
9 [Note 2: This synopsis suggests a circularity betweenstreampos and char_traits<char>. An implementation can
avoid this circularity by substituting equivalent types.—end note]
31.4 Standard iostream objects [iostream.objects]
31.4.1 Header <iostream> synopsis [iostream.syn]
#include <ios> // see 31.5.1
#include <streambuf> // see 31.6.1
#include <istream> // see 31.7.1
#include <ostream> // see 31.7.2
namespace std {
extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;
extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;
}
31.4.2 Overview [iostream.objects.overview]
1 In this Clause, the type nameFILE refers to the typeFILE declared in<cstdio> (31.13.1).
2 The header<iostream> declares objects that associate objects with the standard C streams provided for by
the functions declared in<cstdio>, and includes all the headers necessary to use these objects. The dynamic
types of the stream buffers initially associated with these objects are unspecified, but they have the behavior
specified forstd::basic_filebuf<char> or std::basic_filebuf<wchar_t>.
3 The objects are constructed and the associations are established at some time prior to or during the first
time an object of classios_base::Init is constructed, and in any case before the body ofmain (6.10.3.1)
begins execution. The objects are not destroyed during program execution.250
249) It is the implementation’s responsibility to implement headers so that including<iosfwd> and other headers does not
violate the rules about multiple occurrences of default arguments.
250) Constructors and destructors for objects with static storage duration can access these objects to read input fromstdin or
write output tostdout or stderr.
§ 31.4.2 © ISO/IEC
2007

===== PAGE 2019 =====

Dxxxx
4 Recommended practice: If it is possible for them to do so, implementations should initialize the objects earlier
than required.
5 The results of including<iostream> in a translation unit shall be as if<iostream> defined an instance of
ios_base::Init with static storage duration. Each C++ library module (16.4.2.4) in a hosted implementation
shall behave as if it contains an interface unit that defines an unexportedios_base::Init variable with
ordered initialization (6.10.3.3).
[Note 1: As a result, the definition of that variable is appearance-ordered before any declaration following the point of
importation of a C++ library module. Whether such a definition exists is unobservable by a program that does not
reference any of the standard iostream objects.—end note]
6 Mixing operations on corresponding wide- and narrow-character streams follows the same semantics as mixing
such operations onFILEs, as specified in the C standard library.
7 Concurrent access to a synchronized (31.5.2.5) standard iostream object’s formatted and unformatted
input (31.7.5.2) and output (31.7.6.2) functions or a standard C stream by multiple threads does not result
in a data race (6.10.2).
[Note 2: Unsynchronized concurrent use of these objects and streams by multiple threads can result in interleaved
characters. —end note]
See also: ISO/IEC 9899:2024, 7.23.2
31.4.3 Narrow stream objects [narrow.stream.objects]
istream cin;
1 The object cin controls input from a stream buffer associated with the objectstdin, declared in
<cstdio> (31.13.1).
2 After the objectcin is initialized,cin.tie() returns &cout. Its state is otherwise the same as required
for basic_ios<char>::init (31.5.4.2).
ostream cout;
3 The object cout controls output to a stream buffer associated with the objectstdout, declared in
<cstdio> (31.13.1).
ostream cerr;
4 The object cerr controls output to a stream buffer associated with the objectstderr, declared in
<cstdio> (31.13.1).
5 After the object cerr is initialized, cerr.flags() & unitbuf is nonzero and cerr.tie() returns
&cout. Its state is otherwise the same as required forbasic_ios<char>::init (31.5.4.2).
ostream clog;
6 The object clog controls output to a stream buffer associated with the objectstderr, declared in
<cstdio> (31.13.1).
31.4.4 Wide stream objects [wide.stream.objects]
wistream wcin;
1 The object wcin controls input from a stream buffer associated with the objectstdin, declared in
<cstdio> (31.13.1).
2 After the objectwcin is initialized, wcin.tie() returns &wcout. Its state is otherwise the same as
required forbasic_ios<wchar_t>::init (31.5.4.2).
wostream wcout;
3 The objectwcout controls output to a stream buffer associated with the objectstdout, declared in
<cstdio> (31.13.1).
wostream wcerr;
4 The objectwcerr controls output to a stream buffer associated with the objectstderr, declared in
<cstdio> (31.13.1).
§ 31.4.4 © ISO/IEC
2008

===== PAGE 2020 =====

Dxxxx
5 After the objectwcerr is initialized,wcerr.flags() & unitbuf is nonzero andwcerr.tie() returns
&wcout. Its state is otherwise the same as required forbasic_ios<wchar_t>::init (31.5.4.2).
wostream wclog;
6 The objectwclog controls output to a stream buffer associated with the objectstderr, declared in
<cstdio> (31.13.1).
31.5 Iostreams base classes [iostreams.base]
31.5.1 Header <ios> synopsis [ios.syn]
#include <iosfwd> // see 31.3.1
namespace std {
// 31.2.2, types
using streamoff = implementation-defined ;
using streamsize = implementation-defined ;
// 31.5.3, class templatefpos
template<class stateT> class fpos;
// 31.5.2, classios_base
class ios_base;
// 31.5.4, class templatebasic_ios
template<class charT, class traits = char_traits<charT>>
class basic_ios;
// 31.5.5, manipulators
ios_base& boolalpha (ios_base& str);
ios_base& noboolalpha(ios_base& str);
ios_base& showbase (ios_base& str);
ios_base& noshowbase (ios_base& str);
ios_base& showpoint (ios_base& str);
ios_base& noshowpoint(ios_base& str);
ios_base& showpos (ios_base& str);
ios_base& noshowpos (ios_base& str);
ios_base& skipws (ios_base& str);
ios_base& noskipws (ios_base& str);
ios_base& uppercase (ios_base& str);
ios_base& nouppercase(ios_base& str);
ios_base& unitbuf (ios_base& str);
ios_base& nounitbuf (ios_base& str);
// 31.5.5.2, adjustfield
ios_base& internal (ios_base& str);
ios_base& left (ios_base& str);
ios_base& right (ios_base& str);
// 31.5.5.3, basefield
ios_base& dec (ios_base& str);
ios_base& hex (ios_base& str);
ios_base& oct (ios_base& str);
// 31.5.5.4, floatfield
ios_base& fixed (ios_base& str);
ios_base& scientific (ios_base& str);
ios_base& hexfloat (ios_base& str);
ios_base& defaultfloat(ios_base& str);
§ 31.5.1 © ISO/IEC
2009

===== PAGE 2021 =====

Dxxxx
// 31.5.6, error reporting
enum class io_errc {
stream = 1
};
template<> struct is_error_code_enum<io_errc> : public true_type { };
error_code make_error_code(io_errc e) noexcept;
error_condition make_error_condition(io_errc e) noexcept;
const error_category& iostream_category() noexcept;
}
31.5.2 Class ios_base [ios.base]
31.5.2.1 General [ios.base.general]
namespace std {
class ios_base {
public:
class failure; // see below
// 31.5.2.2.2,fmtflags
using fmtflags = T1;
static constexpr fmtflags boolalpha = unspecified ;
static constexpr fmtflags dec = unspecified ;
static constexpr fmtflags fixed = unspecified ;
static constexpr fmtflags hex = unspecified ;
static constexpr fmtflags internal = unspecified ;
static constexpr fmtflags left = unspecified ;
static constexpr fmtflags oct = unspecified ;
static constexpr fmtflags right = unspecified ;
static constexpr fmtflags scientific = unspecified ;
static constexpr fmtflags showbase = unspecified ;
static constexpr fmtflags showpoint = unspecified ;
static constexpr fmtflags showpos = unspecified ;
static constexpr fmtflags skipws = unspecified ;
static constexpr fmtflags unitbuf = unspecified ;
static constexpr fmtflags uppercase = unspecified ;
static constexpr fmtflags adjustfield = see below ;
static constexpr fmtflags basefield = see below ;
static constexpr fmtflags floatfield = see below ;
// 31.5.2.2.3,iostate
using iostate = T2;
static constexpr iostate badbit = unspecified ;
static constexpr iostate eofbit = unspecified ;
static constexpr iostate failbit = unspecified ;
static constexpr iostate goodbit = see below ;
// 31.5.2.2.4,openmode
using openmode = T3;
static constexpr openmode app = unspecified ;
static constexpr openmode ate = unspecified ;
static constexpr openmode binary = unspecified ;
static constexpr openmode in = unspecified ;
static constexpr openmode noreplace = unspecified ;
static constexpr openmode out = unspecified ;
static constexpr openmode trunc = unspecified ;
// 31.5.2.2.5,seekdir
using seekdir = T4;
static constexpr seekdir beg = unspecified ;
static constexpr seekdir cur = unspecified ;
static constexpr seekdir end = unspecified ;
class Init;
§ 31.5.2.1 © ISO/IEC
2010

===== PAGE 2022 =====

Dxxxx
// 31.5.2.3,fmtflags state
fmtflags flags() const;
fmtflags flags(fmtflags fmtfl);
fmtflags setf(fmtflags fmtfl);
fmtflags setf(fmtflags fmtfl, fmtflags mask);
void unsetf(fmtflags mask);
streamsize precision() const;
streamsize precision(streamsize prec);
streamsize width() const;
streamsize width(streamsize wide);
// 31.5.2.4, locales
locale imbue(const locale& loc);
locale getloc() const;
// 31.5.2.6, storage
static int xalloc();
long& iword(int idx);
void*& pword(int idx);
// destructor
virtual ~ios_base();
// 31.5.2.7, callbacks
enum event { erase_event, imbue_event, copyfmt_event };
using event_callback = void (*)(event, ios_base&, int idx);
void register_callback(event_callback fn, int idx);
ios_base(const ios_base&) = delete;
ios_base& operator=(const ios_base&) = delete;
static bool sync_with_stdio(bool sync = true);
protected:
ios_base();
private:
static int index ; // exposition only
long* iarray ; // exposition only
void** parray ; // exposition only
};
}
1 ios_base defines several member types:
—(1.1) a typefailure, defined as either a class derived fromsystem_error or a synonym for a class derived
from system_error;
—(1.2) a classInit;
—(1.3) three bitmask types,fmtflags, iostate, andopenmode;
—(1.4) an enumerated type,seekdir.
2 It maintains several kinds of data:
—(2.1) state information that reflects the integrity of the stream buffer;
—(2.2) control information that influences how to interpret (format) input sequences and how to generate
(format) output sequences;
—(2.3) additional information that is stored by the program for its private use.
3 [Note 1: For the sake of exposition, the maintained data is presented here as:
—(3.1) static int index , specifies the next available unique index for the integer or pointer arrays maintained for
the private use of the program, initialized to an unspecified value;
§ 31.5.2.1 © ISO/IEC
2011

===== PAGE 2023 =====

Dxxxx
—(3.2) long* iarray , points to the first element of an arbitrary-lengthlong array maintained for the private use of
the program;
—(3.3) void** parray , points to the first element of an arbitrary-length pointer array maintained for the private use
of the program.
—end note]
31.5.2.2 Types [ios.types]
31.5.2.2.1 Class ios_base::failure [ios.failure]
namespace std {
class ios_base::failure : public system_error {
public:
explicit failure(const string& msg, const error_code& ec = io_errc::stream);
explicit failure(const char* msg, const error_code& ec = io_errc::stream);
};
}
1 An implementation is permitted to defineios_base::failure as a synonym for a class with equivalent
functionality to classios_base::failure shown in this subclause.
[Note 1: When ios_base::failure is a synonym for another type, that type needs to provide a nested typefailure
to emulate the injected-class-name.—end note]
The classfailure defines the base class for the types of all objects thrown as exceptions, by functions in the
iostreams library, to report errors detected during stream buffer operations.
2 When throwingios_base::failure exceptions, implementations should provide values ofec that identify
the specific reason for the failure.
[Note 2: Errors arising from the operating system would typically be reported assystem_category() errors with an
error value of the error number reported by the operating system. Errors arising from within the stream library would
typically be reported aserror_code(io_errc::stream, iostream_category()). —end note]
explicit failure(const string& msg, const error_code& ec = io_errc::stream);
3 Effects: Constructs the base class withmsg and ec.
explicit failure(const char* msg, const error_code& ec = io_errc::stream);
4 Effects: Constructs the base class withmsg and ec.
31.5.2.2.2 Type ios_base::fmtflags [ios.fmtflags]
using fmtflags = T1;
1 The typefmtflags is a bitmask type (16.3.3.3.3). Setting its elements has the effects indicated in
Table 136.
2 Type fmtflags also defines the constants indicated in Table 137.
31.5.2.2.3 Type ios_base::iostate [ios.iostate]
using iostate = T2;
1 The typeiostate is a bitmask type (16.3.3.3.3) that contains the elements indicated in Table 138.
2 Type iostate also defines the constant:
—(2.1) goodbit, the value zero.
31.5.2.2.4 Type ios_base::openmode [ios.openmode]
using openmode = T3;
1 The typeopenmode is a bitmask type (16.3.3.3.3). It contains the elements indicated in Table 139.
31.5.2.2.5 Type ios_base::seekdir [ios.seekdir]
using seekdir = T4;
1 The typeseekdir is an enumerated type (16.3.3.3.2) that contains the elements indicated in Table 140.
§ 31.5.2.2.5 © ISO/IEC
2012

===== PAGE 2024 =====

Dxxxx
Table 136 —fmtflags effects [tab:ios.fmtflags]
Element Effect(s) if set
boolalpha insert and extractbool type in alphabetic format
dec converts integer input or generates integer output in decimal base
fixed generate floating-point output in fixed-point notation
hex converts integer input or generates integer output in hexadecimal base
internal adds fill characters at a designated internal point in certain generated output,
or identical toright if no such point is designated
left adds fill characters on the right (final positions) of certain generated output
oct converts integer input or generates integer output in octal base
right adds fill characters on the left (initial positions) of certain generated output
scientific generates floating-point output in scientific notation
showbase generates a prefix indicating the numeric base of generated integer output
showpoint generates a decimal-point character unconditionally in generated floating-
point output
showpos generates a+ sign in non-negative generated numeric output
skipws skips leading whitespace before certain input operations
unitbuf flushes output after each output operation
uppercase replaces certain lowercase letters with their uppercase equivalents in gener-
ated output
Table 137 —fmtflags constants [tab:ios.fmtflags.const]
Constant Allowable values
adjustfield left | right | internal
basefield dec | oct | hex
floatfield scientific | fixed
Table 138 —iostate effects [tab:ios.iostate]
Element Effect(s) if set
badbit indicates a loss of integrity in an input or output sequence (such as an
irrecoverable read error from a file);
eofbit indicates that an input operation reached the end of an input sequence;
failbit indicates that an input operation failed to read the expected characters, or
that an output operation failed to generate the desired characters.
Table 139 —openmode effects [tab:ios.openmode]
Element Effect(s) if set
app seek to end before each write
ate open and seek to end immediately after opening
binary perform input and output in binary mode (as opposed to text mode)
in open for input
noreplace open in exclusive mode
out open for output
trunc truncate an existing stream when opening
§ 31.5.2.2.5 © ISO/IEC
2013

===== PAGE 2025 =====

Dxxxx
Table 140 —seekdir effects [tab:ios.seekdir]
Element Meaning
beg request a seek (for subsequent input or output) relative to the beginning of
the stream
cur request a seek relative to the current position within the sequence
end request a seek relative to the current end of the sequence
31.5.2.2.6 Class ios_base::Init [ios.init]
namespace std {
class ios_base::Init {
public:
Init();
Init(const Init&) = default;
~Init();
Init& operator=(const Init&) = default;
};
}
1 The classInit describes an object whose construction ensures the construction of the eight objects declared
in <iostream> (31.4) that associate file stream buffers with the standard C streams provided for by the
functions declared in<cstdio> (31.13.1).
Init();
2 Effects: Constructs and initializes the objectscin, cout, cerr, clog, wcin, wcout, wcerr, andwclog
if they have not already been constructed and initialized.
~Init();
3 Effects: If there are no other instances of the class still in existence, callscout.flush(), cerr.flush(),
clog.flush(), wcout.flush(), wcerr.flush(), wclog.flush().
31.5.2.3 State functions [fmtflags.state]
fmtflags flags() const;
1 Returns: The format control information for both input and output.
fmtflags flags(fmtflags fmtfl);
2 Postconditions: fmtfl == flags().
3 Returns: The previous value offlags().
fmtflags setf(fmtflags fmtfl);
4 Effects: Sets fmtfl in flags().
5 Returns: The previous value offlags().
fmtflags setf(fmtflags fmtfl, fmtflags mask);
6 Effects: Clears mask in flags(), setsfmtfl & mask in flags().
7 Returns: The previous value offlags().
void unsetf(fmtflags mask);
8 Effects: Clears mask in flags().
streamsize precision() const;
9 Returns: The precision to generate on certain output conversions.
streamsize precision(streamsize prec);
10 Postconditions: prec == precision().
11 Returns: The previous value ofprecision().
§ 31.5.2.3 © ISO/IEC
2014

===== PAGE 2026 =====

Dxxxx
streamsize width() const;
12 Returns: The minimum field width (number of characters) to generate on certain output conversions.
streamsize width(streamsize wide);
13 Postconditions: wide == width().
14 Returns: The previous value ofwidth().
31.5.2.4 Functions [ios.base.locales]
locale imbue(const locale& loc);
1 Effects: Calls each registered callback pair(fn, idx) (31.5.2.7) as(*fn)(imbue_event, *this, idx)
at such a time that a call toios_base::getloc() from withinfn returns the new locale valueloc.
2 Postconditions: loc == getloc().
3 Returns: The previous value ofgetloc().
locale getloc() const;
4 Returns: If no locale has been imbued, a copy of the global C++ locale, locale(), in effect at the time
of construction. Otherwise, returns the imbued locale, to be used to perform locale-dependent input
and output operations.
31.5.2.5 Static members [ios.members.static]
static bool sync_with_stdio(bool sync = true);
1 Effects: If any input or output operation has occurred using the standard streams prior to the call,
the effect is implementation-defined. Otherwise, called with afalse argument, it allows the standard
streams to operate independently of the standard C streams.
2 Returns: true if the previous state of the standard iostream objects (31.4) was synchronized and
otherwise returnsfalse. The first time it is called, the function returnstrue.
3 Remarks: When a standard iostream objectstr is synchronized with a standard stdio streamf, the
effect of inserting a characterc by
fputc(f, c);
is the same as the effect of
str.rdbuf()->sputc(c);
for any sequences of characters; the effect of extracting a characterc by
c = fgetc(f);
is the same as the effect of
c = str.rdbuf()->sbumpc();
for any sequences of characters; and the effect of pushing back a characterc by
ungetc(c, f);
is the same as the effect of
str.rdbuf()->sputbackc(c);
for any sequence of characters.251
31.5.2.6 Storage functions [ios.base.storage]
static int xalloc();
1 Returns: index ++.
2 Remarks: Concurrent access to this function by multiple threads does not result in a data race (6.10.2).
251) This implies that operations on a standard iostream object can be mixed arbitrarily with operations on the corresponding
stdio stream. In practical terms, synchronization usually means that a standard iostream object and a standard stdio object
share a buffer.
§ 31.5.2.6 © ISO/IEC
2015

===== PAGE 2027 =====

Dxxxx
long& iword(int idx);
3 Preconditions: idx is a value obtained by a call toxalloc.
4 Effects: If iarray is a null pointer, allocates an array oflong of unspecified size and stores a pointer to
its first element iniarray . The function then extends the array pointed at byiarray as necessary to
include the elementiarray [idx]. Each newly allocated element of the array is initialized to zero. The
reference returned is invalid after any other operation on the object.252 However, the value of the storage
referred to is retained, so that until the next call tocopyfmt, callingiword with the same index yields
another reference to the same value. If the function fails253 and *this is a base class subobject of a
basic_ios<> object or subobject, the effect is equivalent to callingbasic_ios<>::setstate(badbit)
on the derived object (which may throwfailure).
5 Returns: On successiarray [idx]. On failure, a validlong& initialized to 0.
void*& pword(int idx);
6 Preconditions: idx is a value obtained by a call toxalloc.
7 Effects: If parray is a null pointer, allocates an array of pointers tovoid of unspecified size and
stores a pointer to its first element inparray . The function then extends the array pointed at by
parray as necessary to include the elementparray [idx]. Each newly allocated element of the array
is initialized to a null pointer. The reference returned is invalid after any other operation on the object.
However, the value of the storage referred to is retained, so that until the next call tocopyfmt, calling
pword with the same index yields another reference to the same value. If the function fails254 and
*this is a base class subobject of abasic_ios<> object or subobject, the effect is equivalent to calling
basic_ios<>::setstate(badbit) on the derived object (which may throwfailure).
8 Returns: On successparray[idx]. On failure a validvoid*& initialized to 0.
9 Remarks: After a subsequent call topword(int) for the same object, the earlier return value may no
longer be valid.
31.5.2.7 Callbacks [ios.base.callback]
void register_callback(event_callback fn, int idx);
1 Preconditions: The functionfn does not throw exceptions.
2 Effects: Registers the pair (fn, idx) such that during calls toimbue() (31.5.2.4), copyfmt(), or
~ios_base() (31.5.2.8), the functionfn is called with argumentidx. Functions registered are called
when an event occurs, in opposite order of registration. Functions registered while a callback function
is active are not called until the next event.
3 Remarks: Identical pairs are not merged. A function registered twice will be called twice.
31.5.2.8 Constructors and destructor [ios.base.cons]
ios_base();
1 Effects: Each ios_base member has an indeterminate value after construction. The object’s members
shall be initialized by callingbasic_ios::init before the object’s first use or before it is destroyed,
whichever comes first; otherwise the behavior is undefined.
~ios_base();
2 Effects: Calls each registered callback pair(fn, idx) (31.5.2.7) as(*fn)(erase_event, *this, idx)
at such time that anyios_base member function called from withinfn has well-defined results. Then,
any memory obtained is deallocated.
31.5.3 Class template fpos [fpos]
31.5.3.1 General [fpos.general]
namespace std {
template<class stateT> class fpos {
252) An implementation is free to implement both the integer array pointed at byiarray and the pointer array pointed at by
parray as sparse data structures, possibly with a one-element cache for each.
253) For example, because it cannot allocate space.
254) For example, because it cannot allocate space.
§ 31.5.3.1 © ISO/IEC
2016

===== PAGE 2028 =====

Dxxxx
public:
// 31.5.3.2, members
stateT state() const;
void state(stateT);
private:
stateT st ; // exposition only
};
}
31.5.3.2 Members [fpos.members]
void state(stateT s);
1 Effects: Assigns s to st .
stateT state() const;
2 Returns: Current value ofst .
31.5.3.3 Requirements [fpos.operations]
1 An fpos type specifies file position information. It holds a state object whose type is equal to the template pa-
rameter stateT. TypestateT shall meet theCpp17DefaultConstructible (Table 30),Cpp17CopyConstructible
(Table 32), Cpp17CopyAssignable (Table 34), and Cpp17Destructible (Table 35) requirements. If is_-
trivially_copy_constructible_v<stateT> is true, thenfpos<stateT> has a trivial copy constructor. If
is_trivially_copy_assignable_v<stateT> is true, thenfpos<stateT> has a trivial copy assignment op-
erator. If is_trivially_destructible_v<stateT> is true, thenfpos<stateT> has a trivial destructor. All
specializations of fpos meet theCpp17DefaultConstructible, Cpp17CopyConstructible, Cpp17CopyAssignable,
Cpp17Destructible, and Cpp17EqualityComparable (Table 28) requirements. In addition, the expressions
shown in Table 141 are valid and have the indicated semantics. In that table,
—(1.1) P refers to a specialization offpos,
—(1.2) p and q refer to values of typeP or const P,
—(1.3) pl and ql refer to modifiable lvalues of typeP,
—(1.4) O refers to typestreamoff, and
—(1.5) o and o2 refer to values of typestreamoff or const streamoff.
Table 141 — Position type requirements [tab:fpos.operations]
Expression Return type Operational Assertion/note
semantics pre-/post-condition
P(o) P converts fromoffset Effects: Value-initializes the
state object.
P p(o);
P p = o;
Effects: Value-initializes the
state object.
Postconditions: p == P(o) is
true.
P() P P(0)
P p; P p(0);
O(p) streamoff converts tooffset P(O(p)) == p
p == q bool Remarks: For any two valueso
and o2, ifp is obtained fromo
converted toP or from a copy of
such P value and ifq is obtained
from o2 converted toP or from
a copy of suchP value, thenp
== q is true only ifo == o2 is
true.
p != q bool !(p == q)
p + o P + offset Remarks: With ql = p + o;,
then: ql - o == p
§ 31.5.3.3 © ISO/IEC
2017

===== PAGE 2029 =====

Dxxxx
Table 141 — Position type requirements (continued)
Expression Return type Operational Assertion/note
semantics pre-/post-condition
pl += o P& += offset Remarks: With ql = pl; before
the +=, then: pl - o == ql
p - o P - offset Remarks: With ql = p - o;,
then: ql + o == p
pl -= o P& -= offset Remarks: With ql = pl; before
the -=, then: pl + o == ql
o + p convertible toP p + o P(o + p) == p + o
p - q streamoff distance p == q + (p - q)
2 Stream operations that return a value of typetraits::pos_type return P(O(-1)) as an invalid value to
signal an error. If this value is used as an argument to anyistream, ostream, orstreambuf member that
accepts a value of typetraits::pos_type then the behavior of that function is undefined.
31.5.4 Class template basic_ios [ios]
31.5.4.1 Overview [ios.overview]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_ios : public ios_base {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.5.4.4, flags functions
explicit operator bool() const;
bool operator!() const;
iostate rdstate() const;
void clear(iostate state = goodbit);
void setstate(iostate state);
bool good() const;
bool eof() const;
bool fail() const;
bool bad() const;
iostate exceptions() const;
void exceptions(iostate except);
// 31.5.4.2, constructor/destructor
explicit basic_ios(basic_streambuf<charT, traits>* sb);
virtual ~basic_ios();
// 31.5.4.3, members
basic_ostream<charT, traits>* tie() const;
basic_ostream<charT, traits>* tie(basic_ostream<charT, traits>* tiestr);
basic_streambuf<charT, traits>* rdbuf() const;
basic_streambuf<charT, traits>* rdbuf(basic_streambuf<charT, traits>* sb);
basic_ios& copyfmt(const basic_ios& rhs);
char_type fill() const;
char_type fill(char_type ch);
locale imbue(const locale& loc);
§ 31.5.4.1 © ISO/IEC
2018

===== PAGE 2030 =====

Dxxxx
char narrow(char_type c, char dfault) const;
char_type widen(char c) const;
basic_ios(const basic_ios&) = delete;
basic_ios& operator=(const basic_ios&) = delete;
protected:
basic_ios();
void init(basic_streambuf<charT, traits>* sb);
void move(basic_ios& rhs);
void move(basic_ios&& rhs);
void swap(basic_ios& rhs) noexcept;
void set_rdbuf(basic_streambuf<charT, traits>* sb);
};
}
31.5.4.2 Constructors [basic.ios.cons]
explicit basic_ios(basic_streambuf<charT, traits>* sb);
1 Effects: Assigns initial values to its member objects by callinginit(sb).
basic_ios();
2 Effects: Leaves its member objects uninitialized. The object shall be initialized by callingbasic_-
ios::init before its first use or before it is destroyed, whichever comes first; otherwise the behavior is
undefined.
~basic_ios();
3 Remarks: The destructor does not destroyrdbuf().
void init(basic_streambuf<charT, traits>* sb);
4 Postconditions: The postconditions of this function are indicated in Table 142.
Table 142 —basic_ios::init() effects [tab:basic.ios.cons]
Element Value
rdbuf() sb
tie() 0
rdstate() goodbit if sb is not a null pointer, otherwise
badbit.
exceptions() goodbit
flags() skipws | dec
width() 0
precision() 6
fill() widen(’ ’)
getloc() a copy of the value returned bylocale()
iarray a null pointer
parray a null pointer
31.5.4.3 Member functions [basic.ios.members]
basic_ostream<charT, traits>* tie() const;
1 Returns: An output sequence that istied to (synchronized with) the sequence controlled by the stream
buffer.
basic_ostream<charT, traits>* tie(basic_ostream<charT, traits>* tiestr);
2 Preconditions: If tiestr is not null,tiestr is not reachable by traversing the linked list of tied stream
objects starting fromtiestr->tie().
3 Postconditions: tiestr == tie().
§ 31.5.4.3 © ISO/IEC
2019

===== PAGE 2031 =====

Dxxxx
4 Returns: The previous value oftie().
basic_streambuf<charT, traits>* rdbuf() const;
5 Returns: A pointer to thestreambuf associated with the stream.
basic_streambuf<charT, traits>* rdbuf(basic_streambuf<charT, traits>* sb);
6 Effects: Calls clear().
7 Postconditions: sb == rdbuf().
8 Returns: The previous value ofrdbuf().
locale imbue(const locale& loc);
9 Effects: Calls ios_base::imbue(loc) (31.5.2.4) and ifrdbuf() != 0 then rdbuf()->pubimbue(loc)
(31.6.3.3.1).
10 Returns: The prior value ofios_base::imbue().
char narrow(char_type c, char dfault) const;
11 Returns: use_facet<ctype<char_type>>(getloc()).narrow(c, dfault).
char_type widen(char c) const;
12 Returns: use_facet<ctype<char_type>>(getloc()).widen(c).
char_type fill() const;
13 Returns: The character used to pad (fill) an output conversion to the specified field width.
char_type fill(char_type fillch);
14 Postconditions: traits::eq(fillch, fill()).
15 Returns: The previous value offill().
basic_ios& copyfmt(const basic_ios& rhs);
16 Effects: If (this == addressof(rhs)) is true does nothing. Otherwise assigns to the member objects
of *this the corresponding member objects ofrhs as follows:
—(16.1) calls each registered callback pair(fn, idx) as (*fn)(erase_event, *this, idx);
—(16.2) then, assigns to the member objects of*this the corresponding member objects ofrhs, except
that
—(16.2.1) rdstate(), rdbuf(), andexceptions() are left unchanged;
—(16.2.2) thecontentsofarrayspointedatby pwordandiwordarecopied, notthepointersthemselves; 255
and
—(16.2.3) if any newly stored pointer values in*this point at objects stored outside the objectrhs and
those objects are destroyed whenrhs is destroyed, the newly stored pointer values are altered
to point at newly constructed copies of the objects;
—(16.3) then, calls each callback pair that was copied fromrhs as (*fn)(copyfmt_event, *this, idx);
—(16.4) then, callsexceptions(rhs.exceptions()).
17 [Note 1: The second pass through the callback pairs permits a copiedpword value to be zeroed, or to have its
referent deep copied or reference counted, or to have other special action taken.—end note]
18 Postconditions: The postconditions of this function are indicated in Table 143.
19 Returns: *this.
void move(basic_ios& rhs);
void move(basic_ios&& rhs);
20 Postconditions: *this has the state thatrhs had before the function call, except thatrdbuf() returns
nullptr. rhs is in a valid but unspecified state, except thatrhs.rdbuf() returns the same value as it
returned before the function call, andrhs.tie() returns nullptr.
255) This suggests an infinite amount of copying, but the implementation can keep track of the maximum element of the arrays
that is nonzero.
§ 31.5.4.3 © ISO/IEC
2020

===== PAGE 2032 =====

Dxxxx
Table 143 —basic_ios::copyfmt() effects [tab:basic.ios.copyfmt]
Element Value
rdbuf() unchanged
tie() rhs.tie()
rdstate() unchanged
exceptions() rhs.exceptions()
flags() rhs.flags()
width() rhs.width()
precision() rhs.precision()
fill() rhs.fill()
getloc() rhs.getloc()
void swap(basic_ios& rhs) noexcept;
21 Effects: The states of*this and rhs are exchanged, except thatrdbuf() returns the same value as it
returned before the function call, andrhs.rdbuf() returns the same value as it returned before the
function call.
void set_rdbuf(basic_streambuf<charT, traits>* sb);
22 Preconditions: sb != nullptr is true.
23 Effects: Associates the basic_streambuf object pointed to bysb with this stream without calling
clear().
24 Postconditions: rdbuf() == sb is true.
25 Throws: Nothing.
31.5.4.4 Flags functions [iostate.flags]
explicit operator bool() const;
1 Returns: !fail().
bool operator!() const;
2 Returns: fail().
iostate rdstate() const;
3 Returns: The error state of the stream buffer.
void clear(iostate state = goodbit);
4 Effects: If ((state | (rdbuf() ? goodbit : badbit)) & exceptions()) == 0, returns. Other-
wise, the function throws an object of classios_base::failure (31.5.2.2.1), constructed with imple-
mentation-defined argument values.
5 Postconditions: If rdbuf() != 0 then state == rdstate(); otherwise rdstate() == (state |
ios_base::badbit).
void setstate(iostate state);
6 Effects: Calls clear(rdstate() | state) (which may throwios_base::failure (31.5.2.2.1)).
bool good() const;
7 Returns: rdstate() == 0.
bool eof() const;
8 Returns: true if eofbit is set inrdstate().
bool fail() const;
9 Returns: true if failbit or badbit is set inrdstate().256
256) Checking badbit also forfail() is historical practice.
§ 31.5.4.4 © ISO/IEC
2021

===== PAGE 2033 =====

Dxxxx
bool bad() const;
10 Returns: true if badbit is set inrdstate().
iostate exceptions() const;
11 Returns: A mask that determines what elements set inrdstate() cause exceptions to be thrown.
void exceptions(iostate except);
12 Effects: Calls clear(rdstate()).
13 Postconditions: except == exceptions().
31.5.5 ios_base manipulators [std.ios.manip]
31.5.5.1 fmtflags manipulators [fmtflags.manip]
1 Each function specified in this subclause is a designated addressable function (16.4.5.2.1).
ios_base& boolalpha(ios_base& str);
2 Effects: Calls str.setf(ios_base::boolalpha).
3 Returns: str.
ios_base& noboolalpha(ios_base& str);
4 Effects: Calls str.unsetf(ios_base::boolalpha).
5 Returns: str.
ios_base& showbase(ios_base& str);
6 Effects: Calls str.setf(ios_base::showbase).
7 Returns: str.
ios_base& noshowbase(ios_base& str);
8 Effects: Calls str.unsetf(ios_base::showbase).
9 Returns: str.
ios_base& showpoint(ios_base& str);
10 Effects: Calls str.setf(ios_base::showpoint).
11 Returns: str.
ios_base& noshowpoint(ios_base& str);
12 Effects: Calls str.unsetf(ios_base::showpoint).
13 Returns: str.
ios_base& showpos(ios_base& str);
14 Effects: Calls str.setf(ios_base::showpos).
15 Returns: str.
ios_base& noshowpos(ios_base& str);
16 Effects: Calls str.unsetf(ios_base::showpos).
17 Returns: str.
ios_base& skipws(ios_base& str);
18 Effects: Calls str.setf(ios_base::skipws).
19 Returns: str.
ios_base& noskipws(ios_base& str);
20 Effects: Calls str.unsetf(ios_base::skipws).
21 Returns: str.
§ 31.5.5.1 © ISO/IEC
2022

===== PAGE 2034 =====

Dxxxx
ios_base& uppercase(ios_base& str);
22 Effects: Calls str.setf(ios_base::uppercase).
23 Returns: str.
ios_base& nouppercase(ios_base& str);
24 Effects: Calls str.unsetf(ios_base::uppercase).
25 Returns: str.
ios_base& unitbuf(ios_base& str);
26 Effects: Calls str.setf(ios_base::unitbuf).
27 Returns: str.
ios_base& nounitbuf(ios_base& str);
28 Effects: Calls str.unsetf(ios_base::unitbuf).
29 Returns: str.
31.5.5.2 adjustfield manipulators [adjustfield.manip]
1 Each function specified in this subclause is a designated addressable function (16.4.5.2.1).
ios_base& internal(ios_base& str);
2 Effects: Calls str.setf(ios_base::internal, ios_base::adjustfield).
3 Returns: str.
ios_base& left(ios_base& str);
4 Effects: Calls str.setf(ios_base::left, ios_base::adjustfield).
5 Returns: str.
ios_base& right(ios_base& str);
6 Effects: Calls str.setf(ios_base::right, ios_base::adjustfield).
7 Returns: str.
31.5.5.3 basefield manipulators [basefield.manip]
1 Each function specified in this subclause is a designated addressable function (16.4.5.2.1).
ios_base& dec(ios_base& str);
2 Effects: Calls str.setf(ios_base::dec, ios_base::basefield).
3 Returns: str.257
ios_base& hex(ios_base& str);
4 Effects: Calls str.setf(ios_base::hex, ios_base::basefield).
5 Returns: str.
ios_base& oct(ios_base& str);
6 Effects: Calls str.setf(ios_base::oct, ios_base::basefield).
7 Returns: str.
31.5.5.4 floatfield manipulators [floatfield.manip]
1 Each function specified in this subclause is a designated addressable function (16.4.5.2.1).
ios_base& fixed(ios_base& str);
2 Effects: Calls str.setf(ios_base::fixed, ios_base::floatfield).
3 Returns: str.
257) The function signaturedec(ios_base&) can be called by the function signaturebasic_ostream& stream::operator<<(ios_-
base& (*)(ios_base&)) to permit expressions of the formcout << dec to change the format flags stored incout.
§ 31.5.5.4 © ISO/IEC
2023

===== PAGE 2035 =====

Dxxxx
ios_base& scientific(ios_base& str);
4 Effects: Calls str.setf(ios_base::scientific, ios_base::floatfield).
5 Returns: str.
ios_base& hexfloat(ios_base& str);
6 Effects: Calls str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield).
7 Returns: str.
8 [Note 1: ios_base::hex cannot be used to specify a hexadecimal floating-point format, because it is not part of
ios_base::floatfield (Table 137). —end note]
ios_base& defaultfloat(ios_base& str);
9 Effects: Calls str.unsetf(ios_base::floatfield).
10 Returns: str.
31.5.6 Error reporting [error.reporting]
error_code make_error_code(io_errc e) noexcept;
1 Returns: error_code(static_cast<int>(e), iostream_category()).
error_condition make_error_condition(io_errc e) noexcept;
2 Returns: error_condition(static_cast<int>(e), iostream_category()).
const error_category& iostream_category() noexcept;
3 Returns: A reference to an object of a type derived from classerror_category.
4 The object’sdefault_error_condition and equivalent virtual functions shall behave as specified
for the classerror_category. The object’sname virtual function shall return a pointer to the string
"iostream".
31.6 Stream buffers [stream.buffers]
31.6.1 Header <streambuf> synopsis [streambuf.syn]
namespace std {
// 31.6.3, class templatebasic_streambuf
template<class charT, class traits = char_traits<charT>>
class basic_streambuf;
using streambuf = basic_streambuf<char>;
using wstreambuf = basic_streambuf<wchar_t>;
}
1 The header<streambuf> defines types that control input from and output tocharacter sequences.
31.6.2 Stream buffer requirements [streambuf.reqts]
1 Stream buffers can impose various constraints on the sequences they control. Some constraints are:
—(1.1) The controlled input sequence can be not readable.
—(1.2) The controlled output sequence can be not writable.
—(1.3) The controlled sequences can be associated with the contents of other representations for character
sequences, such as external files.
—(1.4) The controlled sequences can support operationsdirectly to or from associated sequences.
—(1.5) The controlled sequences can impose limitations on how the program can read characters from a
sequence, write characters to a sequence, put characters back into an input sequence, or alter the stream
position.
2 Each sequence is characterized by three pointers which, if non-null, all point into the samecharT array object.
The array object represents, at any moment, a (sub)sequence of characters from the sequence. Operations
performed on a sequence alter the values stored in these pointers, perform reads and writes directly to or
from associated sequences, and alter “the stream position” and conversion state as needed to maintain this
subsequence relationship. The three pointers are:
§ 31.6.2 © ISO/IEC
2024

===== PAGE 2036 =====

Dxxxx
—(2.1) the beginning pointer, or lowest element address in the array (calledxbeg here);
—(2.2) the next pointer, or next element address that is a current candidate for reading or writing (called
xnext here);
—(2.3) the end pointer, or first element address beyond the end of the array (calledxend here).
3 The following semantic constraints shall always apply for any set of three pointers for a sequence, using the
pointer names given immediately above:
—(3.1) If xnext is not a null pointer, thenxbeg and xend shall also be non-null pointers into the samecharT
array, as described above; otherwise,xbeg and xend shall also be null.
—(3.2) If xnext is not a null pointer andxnext < xend for an output sequence, then awrite position is
available. In this case,*xnext shall be assignable as the next element to write (to put, or to store a
character value, into the sequence).
—(3.3) If xnext is not a null pointer andxbeg < xnext for an input sequence, then aputback positionis
available. In this case,xnext[-1] shall have a defined value and is the next (preceding) element to
store a character that is put back into the input sequence.
—(3.4) If xnext is not a null pointer andxnext < xend for an input sequence, then aread positionis available.
In this case,*xnext shall have a defined value and is the next element to read (to get, or to obtain a
character value, from the sequence).
31.6.3 Class template basic_streambuf [streambuf]
31.6.3.1 General [streambuf.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_streambuf {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
virtual ~basic_streambuf();
// 31.6.3.3.1, locales
locale pubimbue(const locale& loc);
locale getloc() const;
// 31.6.3.3.2, buffer and positioning
basic_streambuf* pubsetbuf(char_type* s, streamsize n);
pos_type pubseekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which
= ios_base::in | ios_base::out);
pos_type pubseekpos(pos_type sp,
ios_base::openmode which
= ios_base::in | ios_base::out);
int pubsync();
// get and put areas
// 31.6.3.3.3, get area
streamsize in_avail();
int_type snextc();
int_type sbumpc();
int_type sgetc();
streamsize sgetn(char_type* s, streamsize n);
// 31.6.3.3.4, putback
int_type sputbackc(char_type c);
int_type sungetc();
§ 31.6.3.1 © ISO/IEC
2025

===== PAGE 2037 =====

Dxxxx
// 31.6.3.3.5, put area
int_type sputc(char_type c);
streamsize sputn(const char_type* s, streamsize n);
protected:
basic_streambuf();
basic_streambuf(const basic_streambuf& rhs);
basic_streambuf& operator=(const basic_streambuf& rhs);
void swap(basic_streambuf& rhs);
// 31.6.3.4.2, get area access
char_type* eback() const;
char_type* gptr() const;
char_type* egptr() const;
void gbump(int n);
void setg(char_type* gbeg, char_type* gnext, char_type* gend);
// 31.6.3.4.3, put area access
char_type* pbase() const;
char_type* pptr() const;
char_type* epptr() const;
void pbump(int n);
void setp(char_type* pbeg, char_type* pend);
// 31.6.3.5, virtual functions
// 31.6.3.5.1, locales
virtual void imbue(const locale& loc);
// 31.6.3.5.2, buffer management and positioning
virtual basic_streambuf* setbuf(char_type* s, streamsize n);
virtual pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which
= ios_base::in | ios_base::out);
virtual pos_type seekpos(pos_type sp,
ios_base::openmode which
= ios_base::in | ios_base::out);
virtual int sync();
// 31.6.3.5.3, get area
virtual streamsize showmanyc();
virtual streamsize xsgetn(char_type* s, streamsize n);
virtual int_type underflow();
virtual int_type uflow();
// 31.6.3.5.4, putback
virtual int_type pbackfail(int_type c = traits::eof());
// 31.6.3.5.5, put area
virtual streamsize xsputn(const char_type* s, streamsize n);
virtual int_type overflow(int_type c = traits::eof());
};
}
1 The class templatebasic_streambuf serves as a base class for deriving variousstream bufferswhose objects
each control twocharacter sequences:
—(1.1) a characterinput sequence;
—(1.2) a characteroutput sequence.
31.6.3.2 Constructors [streambuf.cons]
basic_streambuf();
§ 31.6.3.2 © ISO/IEC
2026

===== PAGE 2038 =====

Dxxxx
1 Effects: Initializes:258
—(1.1) all pointer member objects to null pointers,
—(1.2) the getloc() member to a copy of the global locale,locale(), at the time of construction.
2 Remarks: Once thegetloc() member is initialized, results of calling locale member functions, and of
members of facets so obtained, can safely be cached until the next time the memberimbue is called.
basic_streambuf(const basic_streambuf& rhs);
3 Postconditions:
—(3.1) eback() == rhs.eback()
—(3.2) gptr() == rhs.gptr()
—(3.3) egptr() == rhs.egptr()
—(3.4) pbase() == rhs.pbase()
—(3.5) pptr() == rhs.pptr()
—(3.6) epptr() == rhs.epptr()
—(3.7) getloc() == rhs.getloc()
~basic_streambuf();
4 Effects: None.
31.6.3.3 Public member functions [streambuf.members]
31.6.3.3.1 Locales [streambuf.locales]
locale pubimbue(const locale& loc);
1 Effects: Calls imbue(loc).
2 Postconditions: loc == getloc().
3 Returns: Previous value ofgetloc().
locale getloc() const;
4 Returns: If pubimbue() has ever been called, then the last value ofloc supplied, otherwise the current
global locale,locale(), in effect at the time of construction. If called afterpubimbue() has been called
but beforepubimbue has returned (i.e., from within the call ofimbue()) then it returns the previous
value.
31.6.3.3.2 Buffer management and positioning [streambuf.buffer]
basic_streambuf* pubsetbuf(char_type* s, streamsize n);
1 Returns: setbuf(s, n).
pos_type pubseekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which
= ios_base::in | ios_base::out);
2 Returns: seekoff(off, way, which).
pos_type pubseekpos(pos_type sp,
ios_base::openmode which
= ios_base::in | ios_base::out);
3 Returns: seekpos(sp, which).
int pubsync();
4 Returns: sync().
258) The default constructor is protected for classbasic_streambuf to assure that only objects for classes derived from this
class can be constructed.
§ 31.6.3.3.2 © ISO/IEC
2027

===== PAGE 2039 =====

Dxxxx
31.6.3.3.3 Get area [streambuf.pub.get]
streamsize in_avail();
1 Returns: If a read position is available, returnsegptr() - gptr(). Otherwise returnsshowmanyc()
(31.6.3.5.3).
int_type snextc();
2 Effects: Calls sbumpc().
3 Returns: If that function returnstraits::eof(), returnstraits::eof(). Otherwise, returnssgetc().
int_type sbumpc();
4 Effects: If the input sequence read position is not available, returnsuflow(). Otherwise, returns
traits::to_int_type(*gptr()) and increments the next pointer for the input sequence.
int_type sgetc();
5 Returns: If the input sequence read position is not available, returnsunderflow(). Otherwise, returns
traits::to_int_type(*gptr()).
streamsize sgetn(char_type* s, streamsize n);
6 Returns: xsgetn(s, n).
31.6.3.3.4 Putback [streambuf.pub.pback]
int_type sputbackc(char_type c);
1 Effects: If the input sequence putback position is not available, or iftraits::eq(c, gptr()[-1]) is
false, returnspbackfail(traits::to_int_type(c)). Otherwise, decrements the next pointer for
the input sequence and returnstraits::to_int_type(*gptr()).
int_type sungetc();
2 Effects: If the input sequence putback position is not available, returnspbackfail(). Otherwise,
decrements the next pointer for the input sequence and returnstraits::to_int_type(*gptr()).
31.6.3.3.5 Put area [streambuf.pub.put]
int_type sputc(char_type c);
1 Effects: If the output sequence write position is not available, returnsoverflow(traits::to_int_-
type(c)). Otherwise, storesc at the next pointer for the output sequence, increments the pointer, and
returns traits::to_int_type(c).
streamsize sputn(const char_type* s, streamsize n);
2 Returns: xsputn(s, n).
31.6.3.4 Protected member functions [streambuf.protected]
31.6.3.4.1 Assignment [streambuf.assign]
basic_streambuf& operator=(const basic_streambuf& rhs);
1 Postconditions:
—(1.1) eback() == rhs.eback()
—(1.2) gptr() == rhs.gptr()
—(1.3) egptr() == rhs.egptr()
—(1.4) pbase() == rhs.pbase()
—(1.5) pptr() == rhs.pptr()
—(1.6) epptr() == rhs.epptr()
—(1.7) getloc() == rhs.getloc()
2 Returns: *this.
§ 31.6.3.4.1 © ISO/IEC
2028

===== PAGE 2040 =====

Dxxxx
void swap(basic_streambuf& rhs);
3 Effects: Swaps the data members ofrhs and *this.
31.6.3.4.2 Get area access [streambuf.get.area]
char_type* eback() const;
1 Returns: The beginning pointer for the input sequence.
char_type* gptr() const;
2 Returns: The next pointer for the input sequence.
char_type* egptr() const;
3 Returns: The end pointer for the input sequence.
void gbump(int n);
4 Effects: Addsn to the next pointer for the input sequence.
void setg(char_type* gbeg, char_type* gnext, char_type* gend);
5 Preconditions: [gbeg,gnext), [gbeg,gend), and[gnext,gend) are all valid ranges.
6 Postconditions: gbeg == eback(), gnext == gptr(), andgend == egptr() are alltrue.
31.6.3.4.3 Put area access [streambuf.put.area]
char_type* pbase() const;
1 Returns: The beginning pointer for the output sequence.
char_type* pptr() const;
2 Returns: The next pointer for the output sequence.
char_type* epptr() const;
3 Returns: The end pointer for the output sequence.
void pbump(int n);
4 Effects: Addsn to the next pointer for the output sequence.
void setp(char_type* pbeg, char_type* pend);
5 Preconditions: [pbeg,pend) is a valid range.
6 Postconditions: pbeg == pbase(), pbeg == pptr(), andpend == epptr() are alltrue.
31.6.3.5 Virtual functions [streambuf.virtuals]
31.6.3.5.1 Locales [streambuf.virt.locales]
void imbue(const locale&);
1 Effects: Change any translations based on locale.
2 Remarks: Allows the derived class to be informed of changes in locale at the time they occur. Between
invocations of this function a class derived from streambuf can safely cache results of calls to locale
functions and to members of facets so obtained.
3 Default behavior: Does nothing.
31.6.3.5.2 Buffer management and positioning [streambuf.virt.buffer]
basic_streambuf* setbuf(char_type* s, streamsize n);
1 Effects: Influences stream buffering in a way that is defined separately for each class derived from
basic_streambuf in this Clause (31.8.2.5, 31.10.3.5).
2 Default behavior: Does nothing. Returnsthis.
§ 31.6.3.5.2 © ISO/IEC
2029

===== PAGE 2041 =====

Dxxxx
pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which
= ios_base::in | ios_base::out);
3 Effects: Alters the stream positions within one or more of the controlled sequences in a way that is
defined separately for each class derived frombasic_streambuf in this Clause (31.8.2.5, 31.10.3.5).
4 Default behavior: Returns pos_type(off_type(-1)).
pos_type seekpos(pos_type sp,
ios_base::openmode which
= ios_base::in | ios_base::out);
5 Effects: Alters the stream positions within one or more of the controlled sequences in a way that is
defined separately for each class derived frombasic_streambuf in this Clause (31.8.2, 31.10.3).
6 Default behavior: Returns pos_type(off_type(-1)).
int sync();
7 Effects: Synchronizes the controlled sequences with the arrays. That is, ifpbase() is non-null the
characters betweenpbase() and pptr() are written to the controlled sequence. The pointers may then
be reset as appropriate.
8 Returns: -1 on failure. What constitutes failure is determined by each derived class (31.10.3.5).
9 Default behavior: Returns zero.
31.6.3.5.3 Get area [streambuf.virt.get]
streamsize showmanyc();259
1 Returns: An estimate of the number of characters available in the sequence, or−1. If it returns a
positive value, then successive calls tounderflow() will not returntraits::eof() until at least that
number of characters have been extracted from the stream. Ifshowmanyc() returns −1, then calls to
underflow() or uflow() will fail.260
2 Default behavior: Returns zero.
3 Remarks: Uses traits::eof().
streamsize xsgetn(char_type* s, streamsize n);
4 Effects: Assigns up ton characters to successive elements of the array whose first element is designated
by s. The characters assigned are read from the input sequence as if by repeated calls tosbumpc().
Assigning stops when either n characters have been assigned or a call tosbumpc() would return
traits::eof().
5 Returns: The number of characters assigned.261
6 Remarks: Uses traits::eof().
int_type underflow();
7 The pending sequenceof characters is defined as the concatenation of
—(7.1) the empty sequence ifgptr() is null, otherwise the characters in[gptr(),egptr()), followed by
—(7.2) some (possibly empty) sequence of characters read from the input sequence.
8 The result characteris the first character of the pending sequence if it is non-empty, otherwise the next
character that would be read from the input sequence.
9 The backup sequenceis the empty sequence ifeback() is null, otherwise the characters in[eback(),
gptr()).
10 Effects: The function sets up thegptr() and egptr() such that if the pending sequence is non-empty,
then egptr() is non-null and the characters in[gptr(),egptr()) are the characters in the pending
sequence, otherwise eithergptr() is null orgptr() == egptr().
259) The morphemes ofshowmanyc are “es-how-many-see”, not “show-manic”.
260) underflow or uflow can fail by throwing an exception prematurely. The intention is not only that the calls will not return
eof() but that they will return “immediately”.
261) Classes derived frombasic_streambuf can provide more efficient ways to implementxsgetn() and xsputn() by overriding
these definitions from the base class.
§ 31.6.3.5.3 © ISO/IEC
2030

===== PAGE 2042 =====

Dxxxx
11 If eback() and gptr() are non-null then the function is not constrained as to their contents, but the
“usual backup condition” is that either
—(11.1) the backup sequence contains at leastgptr() - eback() characters, in which case the characters
in [eback(),gptr()) agree with the lastgptr() - eback() characters of the backup sequence, or
—(11.2) the characters in[gptr() - n,gptr()) agree with the backup sequence (wheren is the length of
the backup sequence).
12 Returns: traits::to_int_type(c), wherec is the firstcharacter of thepending sequence, without
moving the input sequence position past it. If the pending sequence is null then the function returns
traits::eof() to indicate failure.
13 Default behavior: Returns traits::eof().
14 Remarks: The public members ofbasic_streambuf call this virtual function only ifgptr() is null or
gptr() >= egptr().
int_type uflow();
15 Preconditions: The constraints are the same as forunderflow(), except that the result character is
transferred from the pending sequence to the backup sequence, and the pending sequence is not empty
before the transfer.
16 Default behavior: Callsunderflow(). If underflow()returns traits::eof(), returnstraits::eof().
Otherwise, returns the value oftraits::to_int_type(*gptr()) and increments the value of the next
pointer for the input sequence.
17 Returns: traits::eof() to indicate failure.
31.6.3.5.4 Putback [streambuf.virt.pback]
int_type pbackfail(int_type c = traits::eof());
1 The pending sequenceis defined as forunderflow(), with the modifications that
—(1.1) If traits::eq_int_type(c, traits::eof()) returns true, then the input sequence is backed
up one character before the pending sequence is determined.
—(1.2) If traits::eq_int_type(c, traits::eof()) returns false, thenc is prepended. Whether the
input sequence is backed up or modified in any other way is unspecified.
2 Postconditions: On return, the constraints of gptr(), eback(), and pptr() are the same as for
underflow().
3 Returns: traits::eof() to indicate failure. Failure may occur because the input sequence could not
be backed up, or if for some other reason the pointers cannot be set consistent with the constraints.
pbackfail() is called only when put back has really failed.
4 Returns some value other thantraits::eof() to indicate success.
5 Default behavior: Returns traits::eof().
6 Remarks: The public functions ofbasic_streambuf call this virtual function only whengptr() is
null, gptr() == eback(), ortraits::eq(traits::to_char_type(c), gptr()[-1]) returns false.
Other calls shall also satisfy that constraint.
31.6.3.5.5 Put area [streambuf.virt.put]
streamsize xsputn(const char_type* s, streamsize n);
1 Effects: Writes up ton characters to the output sequence as if by repeated calls tosputc(c). The
characters written are obtained from successive elements of the array whose first element is designated
by s. Writing stops when eithern characters have been written or a call tosputc(c) would return
traits::eof(). It is unspecified whether the function callsoverflow() when pptr() == epptr()
becomes true or whether it achieves the same effects by other means.
2 Returns: The number of characters written.
int_type overflow(int_type c = traits::eof());
3 Effects: Consumes some initial subsequence of the characters of thepending sequence. The pending
sequence is defined as the concatenation of
§ 31.6.3.5.5 © ISO/IEC
2031

===== PAGE 2043 =====

Dxxxx
—(3.1) the empty sequence ifpbase() is null, otherwise thepptr() - pbase() characters beginning at
pbase(), followed by
—(3.2) the empty sequence iftraits::eq_int_type(c, traits::eof()) returns true, otherwise the
sequence consisting ofc.
4 Preconditions: Every overriding definition of this virtual function obeys the following constraints:
—(4.1) The effect of consuming a character on the associated output sequence is specified.262
—(4.2) Let r be the number of characters in the pending sequence not consumed. Ifr is nonzero then
pbase() and pptr() are set so that:pptr() - pbase() == r and ther characters starting at
pbase() are the associated output stream. In caser is zero (all characters of the pending sequence
have been consumed) then eitherpbase() is set tonullptr, orpbase() and pptr() are both set
to the same non-null value.
—(4.3) The function may fail if either appending some character to the associated output stream fails or
if it is unable to establishpbase() and pptr() according to the above rules.
5 Returns: traits::eof() or throws an exception if the function fails.
Otherwise, returns some value other thantraits::eof() to indicate success.263
6 Default behavior: Returns traits::eof().
7 Remarks: The member functionssputc() and sputn() call this function in case that no room can be
found in the put buffer enough to accommodate the argument character sequence.
31.7 Formatting and manipulators [iostream.format]
31.7.1 Header <istream> synopsis [istream.syn]
namespace std {
// 31.7.5.2, class templatebasic_istream
template<class charT, class traits = char_traits<charT>>
class basic_istream;
using istream = basic_istream<char>;
using wistream = basic_istream<wchar_t>;
// 31.7.5.7, class templatebasic_iostream
template<class charT, class traits = char_traits<charT>>
class basic_iostream;
using iostream = basic_iostream<char>;
using wiostream = basic_iostream<wchar_t>;
// 31.7.5.5, standardbasic_istream manipulators
template<class charT, class traits>
basic_istream<charT, traits>& ws(basic_istream<charT, traits>& is);
// 31.7.5.6, rvalue stream extraction
template<class Istream, class T>
Istream&& operator>>(Istream&& is, T&& x);
}
31.7.2 Header <ostream> synopsis [ostream.syn]
namespace std {
// 31.7.6.2, class templatebasic_ostream
template<class charT, class traits = char_traits<charT>>
class basic_ostream;
using ostream = basic_ostream<char>;
using wostream = basic_ostream<wchar_t>;
262) That is, for each class derived from a specialization ofbasic_streambuf in this Clause (31.8.2, 31.10.3), a specification of
how consuming a character affects the associated output sequence is given. There is no requirement on a program-defined class.
263) Typically,overflow returns c to indicate success, except whentraits::eq_int_type(c, traits::eof()) returns true, in
which case it returnstraits::not_eof(c).
§ 31.7.2 © ISO/IEC
2032

===== PAGE 2044 =====

Dxxxx
// 31.7.6.5, standardbasic_ostream manipulators
template<class charT, class traits>
basic_ostream<charT, traits>& endl(basic_ostream<charT, traits>& os);
template<class charT, class traits>
basic_ostream<charT, traits>& ends(basic_ostream<charT, traits>& os);
template<class charT, class traits>
basic_ostream<charT, traits>& flush(basic_ostream<charT, traits>& os);
template<class charT, class traits>
basic_ostream<charT, traits>& emit_on_flush(basic_ostream<charT, traits>& os);
template<class charT, class traits>
basic_ostream<charT, traits>& noemit_on_flush(basic_ostream<charT, traits>& os);
template<class charT, class traits>
basic_ostream<charT, traits>& flush_emit(basic_ostream<charT, traits>& os);
// 31.7.6.6, rvalue stream insertion
template<class Ostream, class T>
Ostream&& operator<<(Ostream&& os, const T& x);
// 31.7.6.3.5, print functions
template<class... Args>
void print(ostream& os, format_string<Args...> fmt, Args&&... args);
template<class... Args>
void println(ostream& os, format_string<Args...> fmt, Args&&... args);
void println(ostream& os);
void vprint_unicode(ostream& os, string_view fmt, format_args args);
void vprint_nonunicode(ostream& os, string_view fmt, format_args args);
}
31.7.3 Header <iomanip> synopsis [iomanip.syn]
namespace std {
// 31.7.7, standard manipulators
unspecified resetiosflags(ios_base::fmtflags mask);
unspecified setiosflags (ios_base::fmtflags mask);
unspecified setbase(int base);
template<class charT> unspecified setfill(charT c);
unspecified setprecision(int n);
unspecified setw(int n);
// 31.7.8, extended manipulators
template<class moneyT> unspecified get_money(moneyT& mon, bool intl = false);
template<class moneyT> unspecified put_money(const moneyT& mon, bool intl = false);
template<class charT> unspecified get_time(tm* tmb, const charT* fmt);
template<class charT> unspecified put_time(const tm* tmb, const charT* fmt);
// 31.7.9, quoted manipulators
template<class charT>
unspecified quoted(const charT* s, charT delim = charT('"'), charT escape = charT('\\'));
template<class charT, class traits, class Allocator>
unspecified quoted(const basic_string<charT, traits, Allocator>& s,
charT delim = charT('"'), charT escape = charT('\\'));
template<class charT, class traits, class Allocator>
unspecified quoted(basic_string<charT, traits, Allocator>& s,
charT delim = charT('"'), charT escape = charT('\\'));
template<class charT, class traits>
unspecified quoted(basic_string_view<charT, traits> s,
charT delim = charT('"'), charT escape = charT('\\'));
}
§ 31.7.3 © ISO/IEC
2033

===== PAGE 2045 =====

Dxxxx
31.7.4 Header <print> synopsis [print.syn]
namespace std {
// 31.7.10, print functions
template<class... Args>
void print(format_string<Args...> fmt, Args&&... args);
template<class... Args>
void print(FILE* stream, format_string<Args...> fmt, Args&&... args);
template<class... Args>
void println(format_string<Args...> fmt, Args&&... args);
void println();
template<class... Args>
void println(FILE* stream, format_string<Args...> fmt, Args&&... args);
void println(FILE* stream);
void vprint_unicode(string_view fmt, format_args args);
void vprint_unicode(FILE* stream, string_view fmt, format_args args);
void vprint_unicode_buffered(FILE* stream, string_view fmt, format_args args);
void vprint_nonunicode(string_view fmt, format_args args);
void vprint_nonunicode(FILE* stream, string_view fmt, format_args args);
void vprint_nonunicode_buffered(FILE* stream, string_view fmt, format_args args);
}
31.7.5 Input streams [input.streams]
31.7.5.1 General [input.streams.general]
1 The header<istream> defines two class templates and a function template that control input from a stream
buffer, along with a function template that extracts from stream rvalues.
31.7.5.2 Class template basic_istream [istream]
31.7.5.2.1 General [istream.general]
1 When a function is specified with a type placeholder ofextended-floating-point-type , the implementation
provides overloads for all cv-unqualified extended floating-point types (6.9.2) in lieu ofextended-floating-
point-type .
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_istream : virtual public basic_ios<charT, traits> {
public:
// types (inherited frombasic_ios (31.5.4))
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.7.5.2.2, constructor/destructor
explicit basic_istream(basic_streambuf<charT, traits>* sb);
virtual ~basic_istream();
// 31.7.5.2.4, prefix/suffix
class sentry;
// 31.7.5.3, formatted input
basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));
basic_istream& operator>>(basic_ios<charT, traits>& (*pf)(basic_ios<charT, traits>&));
basic_istream& operator>>(ios_base& (*pf)(ios_base&));
basic_istream& operator>>(bool& n);
basic_istream& operator>>(short& n);
basic_istream& operator>>(unsigned short& n);
basic_istream& operator>>(int& n);
§ 31.7.5.2.1 © ISO/IEC
2034

===== PAGE 2046 =====

Dxxxx
basic_istream& operator>>(unsigned int& n);
basic_istream& operator>>(long& n);
basic_istream& operator>>(unsigned long& n);
basic_istream& operator>>(long long& n);
basic_istream& operator>>(unsigned long long& n);
basic_istream& operator>>(float& f);
basic_istream& operator>>(double& f);
basic_istream& operator>>(long double& f);
basic_istream& operator>>(extended-floating-point-type & f);
basic_istream& operator>>(void*& p);
basic_istream& operator>>(basic_streambuf<char_type, traits>* sb);
// 31.7.5.4, unformatted input
streamsize gcount() const;
int_type get();
basic_istream& get(char_type& c);
basic_istream& get(char_type* s, streamsize n);
basic_istream& get(char_type* s, streamsize n, char_type delim);
basic_istream& get(basic_streambuf<char_type, traits>& sb);
basic_istream& get(basic_streambuf<char_type, traits>& sb, char_type delim);
basic_istream& getline(char_type* s, streamsize n);
basic_istream& getline(char_type* s, streamsize n, char_type delim);
basic_istream& ignore(streamsize n = 1, int_type delim = traits::eof());
basic_istream& ignore(streamsize n, char_type delim);
int_type peek();
basic_istream& read (char_type* s, streamsize n);
streamsize readsome(char_type* s, streamsize n);
basic_istream& putback(char_type c);
basic_istream& unget();
int sync();
pos_type tellg();
basic_istream& seekg(pos_type);
basic_istream& seekg(off_type, ios_base::seekdir);
protected:
// 31.7.5.2.2, copy/move constructor
basic_istream(const basic_istream&) = delete;
basic_istream(basic_istream&& rhs);
// 31.7.5.2.3, assignment and swap
basic_istream& operator=(const basic_istream&) = delete;
basic_istream& operator=(basic_istream&& rhs);
void swap(basic_istream& rhs);
};
// 31.7.5.3.3, character extraction templates
template<class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>&, charT&);
template<class traits>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>&, unsigned char&);
template<class traits>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>&, signed char&);
template<class charT, class traits, size_t N>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>&, charT(&)[N]);
template<class traits, size_t N>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>&, unsigned char(&)[N]);
§ 31.7.5.2.1 © ISO/IEC
2035

===== PAGE 2047 =====

Dxxxx
template<class traits, size_t N>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>&, signed char(&)[N]);
}
2 The class templatebasic_istream defines a number of member function signatures that assist in reading
and interpreting input from sequences controlled by a stream buffer.
3 Two groups of member function signatures share common properties: theformatted input functions(or
extractors) and theunformatted input functions.Both groups of input functions are described as if they
obtain (orextract) inputcharacters by callingrdbuf()->sbumpc() or rdbuf()->sgetc(). They may use
other public members ofistream.
31.7.5.2.2 Constructors [istream.cons]
explicit basic_istream(basic_streambuf<charT, traits>* sb);
1 Effects: Initializes the base class subobject withbasic_ios::init(sb) (31.5.4.2).
2 Postconditions: gcount() == 0.
basic_istream(basic_istream&& rhs);
3 Effects: Default constructs the base class, copies thegcount() from rhs, calls basic_ios<charT,
traits>::move(rhs) to initialize the base class, and sets thegcount() for rhs to 0.
virtual ~basic_istream();
4 Remarks: Does not perform any operations ofrdbuf().
31.7.5.2.3 Assignment and swap [istream.assign]
basic_istream& operator=(basic_istream&& rhs);
1 Effects: Equivalent toswap(rhs).
2 Returns: *this.
void swap(basic_istream& rhs);
3 Effects: Calls basic_ios<charT, traits>::swap(rhs). Exchanges the values returned bygcount()
and rhs.gcount().
31.7.5.2.4 Class basic_istream::sentry [istream.sentry]
namespace std {
template<class charT, class traits>
class basic_istream<charT, traits>::sentry {
bool ok_; // exposition only
public:
explicit sentry(basic_istream& is, bool noskipws = false);
~sentry();
explicit operator bool() const { return ok_; }
sentry(const sentry&) = delete;
sentry& operator=(const sentry&) = delete;
};
}
1 The classsentry defines a class that is responsible for doing exception safe prefix and suffix operations.
explicit sentry(basic_istream& is, bool noskipws = false);
2 Effects: If is.good() is false, callsis.setstate(failbit). Otherwise, prepares for formatted or
unformatted input. First, if is.tie() is not a null pointer, the function callsis.tie()->flush()
to synchronize the output sequence with any associated external C stream. Except that this call
can be suppressed if the put area ofis.tie() is empty. Further an implementation is allowed to
defer the call toflush until a call ofis.rdbuf()->underflow() occurs. If no such call occurs before
the sentry object is destroyed, the call toflush may be eliminated entirely.264 If noskipws is zero
264) This will be possible only in functions that are part of the library. The semantics of the constructor used in user code is as
specified.
§ 31.7.5.2.4 © ISO/IEC
2036

===== PAGE 2048 =====

Dxxxx
and is.flags() & ios_base::skipws is nonzero, the function extracts and discards each character
as long as the next available input characterc is a whitespace character. Ifis.rdbuf()->sbumpc()
or is.rdbuf()->sgetc() returns traits::eof(), the function callssetstate(failbit | eofbit)
(which may throwios_base::failure).
3 Remarks: The constructor
explicit sentry(basic_istream& is, bool noskipws = false)
uses the currently imbued locale inis, to determine whether the next input character is whitespace or
not.
4 To decide if the characterc is a whitespace character, the constructor performs as if it executes the
following code fragment:
const ctype<charT>& ctype = use_facet<ctype<charT>>(is.getloc());
if (ctype.is(ctype.space, c) != 0)
// c is a whitespace character.
5 If, after any preparation is completed,is.good() is true, ok_ != false otherwise, ok_ == false.
During preparation, the constructor may callsetstate(failbit) (which may throw ios_base::
failure (31.5.4.4)).265
~sentry();
6 Effects: None.
explicit operator bool() const;
7 Returns: ok_.
31.7.5.3 Formatted input functions [istream.formatted]
31.7.5.3.1 Common requirements [istream.formatted.reqmts]
1 Each formatted input function begins execution by constructing an object of typeios_base::iostate,
termed the local error state, and initializing it toios_base::goodbit. It then creates an object of class
sentry with thenoskipws (second) argumentfalse. If thesentry object returnstrue, when converted
to a value of typebool, the function endeavors to obtain the requested input. Otherwise, if thesentry
constructor exits by throwing an exception or if thesentry object produces false when converted to a
value of typebool, the function returns without attempting to obtain any input. Ifrdbuf()->sbumpc()
or rdbuf()->sgetc() returns traits::eof(), thenios_base::eofbit is set in the local error state and
the input function stops trying to obtain the requested input. If an exception is thrown during input then
ios_base::badbit is set in the local error state,*this’s error state is set to the local error state, and the
exception is rethrown if(exceptions() & badbit) != 0. After extraction is done, the input function calls
setstate, which sets*this’s error state to the local error state, and may throw an exception. In any case,
the formatted input function destroys thesentry object. If no exception has been thrown, it returns*this.
31.7.5.3.2 Arithmetic extractors [istream.formatted.arithmetic]
basic_istream& operator>>(unsigned short& val);
basic_istream& operator>>(unsigned int& val);
basic_istream& operator>>(long& val);
basic_istream& operator>>(unsigned long& val);
basic_istream& operator>>(long long& val);
basic_istream& operator>>(unsigned long long& val);
basic_istream& operator>>(float& val);
basic_istream& operator>>(double& val);
basic_istream& operator>>(long double& val);
basic_istream& operator>>(bool& val);
basic_istream& operator>>(void*& val);
1 As in the case of the inserters, these extractors depend on the locale’snum_get<> (28.3.4.3.2) object
to perform parsing the input stream data. These extractors behave as formatted input functions (as
described in 31.7.5.3.1). After asentry object is constructed, the conversion occurs as if performed by
the following code fragment, wherestate represents the input function’s local error state:
using numget = num_get<charT, istreambuf_iterator<charT, traits>>;
265) The sentry constructor and destructor can also perform additional implementation-dependent operations.
§ 31.7.5.3.2 © ISO/IEC
2037

===== PAGE 2049 =====

Dxxxx
use_facet<numget>(loc).get(*this, 0, *this, state, val);
In the above fragment,loc stands for the private member of thebasic_ios class.
[Note 1: The first argument provides an object of theistreambuf_iterator class which is an iterator pointed
to an input stream. It bypasses istreams and uses streambufs directly.—end note]
Class locale relies on this type as its interface toistream, so that it does not need to depend directly
on istream.
basic_istream& operator>>(short& val);
2 The conversion occurs as if performed by the following code fragment (using the same notation as for
the preceding code fragment):
using numget = num_get<charT, istreambuf_iterator<charT, traits>>;
long lval;
use_facet<numget>(loc).get(*this, 0, *this, state, lval);
if (lval < numeric_limits<short>::min()) {
state |= ios_base::failbit;
val = numeric_limits<short>::min();
} else if (numeric_limits<short>::max() < lval) {
state |= ios_base::failbit;
val = numeric_limits<short>::max();
} else
val = static_cast<short>(lval);
basic_istream& operator>>(int& val);
3 The conversion occurs as if performed by the following code fragment (using the same notation as for
the preceding code fragment):
using numget = num_get<charT, istreambuf_iterator<charT, traits>>;
long lval;
use_facet<numget>(loc).get(*this, 0, *this, state, lval);
if (lval < numeric_limits<int>::min()) {
state |= ios_base::failbit;
val = numeric_limits<int>::min();
} else if (numeric_limits<int>::max() < lval) {
state |= ios_base::failbit;
val = numeric_limits<int>::max();
} else
val = static_cast<int>(lval);
basic_istream& operator>>(extended-floating-point-type & val);
4 If the floating-point conversion rank ofextended-floating-point-type is not less than or equal
to that oflong double, then an invocation of the operator function is conditionally supported with
implementation-defined semantics.
5 Otherwise, letFP be a standard floating-point type:
—(5.1) if the floating-point conversion rank ofextended-floating-point-type is less than or equal to
that offloat, thenFP is float,
—(5.2) otherwise, if the floating-point conversion rank ofextended-floating-point-type is less than
or equal to that ofdouble, thenFP is double,
—(5.3) otherwise, FP is long double.
6 The conversion occurs as if performed by the following code fragment (using the same notation as for
the preceding code fragment):
using numget = num_get<charT, istreambuf_iterator<charT, traits>>;
FP fval;
use_facet<numget>(loc).get(*this, 0, *this, state, fval);
if (fval < -numeric_limits<extended-floating-point-type >::max()) {
state |= ios_base::failbit;
val = -numeric_limits<extended-floating-point-type >::max();
} else if (numeric_limits<extended-floating-point-type >::max() < fval) {
state |= ios_base::failbit;
§ 31.7.5.3.2 © ISO/IEC
2038

===== PAGE 2050 =====

Dxxxx
val = numeric_limits<extended-floating-point-type >::max();
} else {
val = static_cast<extended-floating-point-type >(fval);
}
[Note 2: When the extended floating-point type has a floating-point conversion rank that is not equal to the
rank of any standard floating-point type, then double rounding during the conversion can result in inaccurate
results. from_chars can be used in situations where maximum accuracy is important.—end note]
31.7.5.3.3 basic_istream::operator>> [istream.extractors]
basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));
1 Effects: None. This extractor does not behave as a formatted input function (as described in 31.7.5.3.1).
2 Returns: pf(*this).266
basic_istream& operator>>(basic_ios<charT, traits>& (*pf)(basic_ios<charT, traits>&));
3 Effects: Calls pf(*this). This extractor does not behave as a formatted input function (as described
in 31.7.5.3.1).
4 Returns: *this.
basic_istream& operator>>(ios_base& (*pf)(ios_base&));
5 Effects: Callspf(*this).267 This extractor does not behave as a formatted input function (as described
in 31.7.5.3.1).
6 Returns: *this.
template<class charT, class traits, size_t N>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& in, charT (&s)[N]);
template<class traits, size_t N>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>& in, unsigned char (&s)[N]);
template<class traits, size_t N>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>& in, signed char (&s)[N]);
7 Effects: Behaves like a formatted input member (as described in 31.7.5.3.1) ofin. After a sentry
object is constructed,operator>> extracts characters and stores them intos. If width() is greater
than zero,n is min(size_t(width()), N). Otherwise n is N. n is the maximum number of characters
stored.
8 Characters are extracted and stored until any of the following occurs:
—(8.1) n - 1 characters are stored;
—(8.2) end of file occurs on the input sequence;
—(8.3) letting ct be use_facet<ctype<charT>>(in.getloc()), ct.is(ct.space, c) is true.
9 operator>> then stores a null byte (charT()) in the next position, which may be the first position if
no characters were extracted.operator>> then callswidth(0).
10 If the function extracted no characters,ios_base::failbit is set in the input function’s local error
state beforesetstate is called.
11 Returns: in.
template<class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& in, charT& c);
template<class traits>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>& in, unsigned char& c);
template<class traits>
basic_istream<char, traits>& operator>>(basic_istream<char, traits>& in, signed char& c);
12 Effects: Behaves like a formatted input member (as described in 31.7.5.3.1) ofin. A character is
extracted fromin, if one is available, and stored inc. Otherwise, ios_base::failbit is set in the
input function’s local error state beforesetstate is called.
13 Returns: in.
266) See, for example, the function signaturews(basic_istream&) (31.7.5.5).
267) See, for example, the function signaturedec(ios_base&) (31.5.5.3).
§ 31.7.5.3.3 © ISO/IEC
2039

===== PAGE 2051 =====

Dxxxx
basic_istream& operator>>(basic_streambuf<charT, traits>* sb);
14 Effects: Behaves as an unformatted input function (31.7.5.4). Ifsb is null, callssetstate(fail-
bit), which may throwios_base::failure (31.5.4.4). After asentry object is constructed, extracts
characters from *this and inserts them in the output sequence controlled bysb. Characters are
extracted and inserted until any of the following occurs:
—(14.1) end-of-file occurs on the input sequence;
—(14.2) inserting in the output sequence fails (in which case the character to be inserted is not extracted);
—(14.3) an exception occurs (in which case the exception is caught).
15 If the function inserts no characters,ios_base::failbit is set in the input function’s local error state
before setstate is called.
16 Returns: *this.
31.7.5.4 Unformatted input functions [istream.unformatted]
1 Each unformatted input function begins execution by constructing an object of typeios_base::iostate,
termed the local error state, and initializing it toios_base::goodbit. It then creates an object of class
sentry with the default argumentnoskipws (second) argumenttrue. If thesentry object returnstrue,
when converted to a value of typebool, the function endeavors to obtain the requested input. Otherwise,
if the sentry constructor exits by throwing an exception or if thesentry object produces false, when
converted to a value of typebool, the function returns without attempting to obtain any input. In either
case the number of extracted characters is set to 0; unformatted input functions taking a character array of
nonzero size as an argument shall also store a null character (usingcharT()) in the first location of the array.
If rdbuf()->sbumpc() or rdbuf()->sgetc() returns traits::eof(), thenios_base::eofbit is set in the
local error state and the input function stops trying to obtain the requested input. If an exception is thrown
during input thenios_base::badbit is set in the local error state,*this’s error state is set to the local
error state, and the exception is rethrown if(exceptions() & badbit) != 0. If no exception has been
thrown it stores the number of characters extracted in a member object. After extraction is done, the input
function callssetstate, which sets*this’s error state to the local error state, and may throw an exception.
In any event thesentry object is destroyed before leaving the unformatted input function.
streamsize gcount() const;
2 Effects: None. This member function does not behave as an unformatted input function (as described
above).
3 Returns: The number of characters extracted by the last unformatted input member function called for
the object. If the number cannot be represented, returnsnumeric_limits<streamsize>::max().
int_type get();
4 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, extracts a characterc, if one is available. Otherwise,ios_base::failbit is set in the input
function’s local error state beforesetstate is called.
5 Returns: c if available, otherwisetraits::eof().
basic_istream& get(char_type& c);
6 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, extracts a character, if one is available, and assigns it toc.268 Otherwise, ios_base::failbit
is set in the input function’s local error state beforesetstate is called.
7 Returns: *this.
basic_istream& get(char_type* s, streamsize n, char_type delim);
8 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, extracts characters and stores them into successive locations of an array whose first element is
designated bys.269 Characters are extracted and stored until any of the following occurs:
—(8.1) n is less than one orn - 1 characters are stored;
268) Note that this function is not overloaded on typessigned char and unsigned char.
269) Note that this function is not overloaded on typessigned char and unsigned char.
§ 31.7.5.4 © ISO/IEC
2040

===== PAGE 2052 =====

Dxxxx
—(8.2) end-of-file occurs on the input sequence;
—(8.3) traits::eq(c, delim) for the next available input characterc (in which casec is not extracted).
9 If the function stores no characters,ios_base::failbit is set in the input function’s local error state
before setstate is called. In any case, ifn is greater than zero it then stores a null character into the
next successive location of the array.
10 Returns: *this.
basic_istream& get(char_type* s, streamsize n);
11 Effects: Calls get(s, n, widen(’\n’)).
12 Returns: Value returned by the call.
basic_istream& get(basic_streambuf<char_type, traits>& sb, char_type delim);
13 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, extracts characters and inserts them in the output sequence controlled bysb. Characters are
extracted and inserted until any of the following occurs:
—(13.1) end-of-file occurs on the input sequence;
—(13.2) inserting in the output sequence fails (in which case the character to be inserted is not extracted);
—(13.3) traits::eq(c, delim) for the next available input characterc (in which casec is not extracted);
—(13.4) an exception occurs (in which case, the exception is caught but not rethrown).
14 If the function inserts no characters,ios_base::failbit is set in the input function’s local error state
before setstate is called.
15 Returns: *this.
basic_istream& get(basic_streambuf<char_type, traits>& sb);
16 Effects: Calls get(sb, widen(’\n’)).
17 Returns: Value returned by the call.
basic_istream& getline(char_type* s, streamsize n, char_type delim);
18 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, extracts characters and stores them into successive locations of an array whose first element is
designated bys.270 Characters are extracted and stored until one of the following occurs:
1. end-of-file occurs on the input sequence;
2. traits::eq(c, delim) for the next available input characterc (in which case the input character
is extracted but not stored);271
3. n is less than one orn - 1 characters are stored (in which case the function callssetstate(
failbit)).
19 These conditions are tested in the order shown.272
20 If the function extracts no characters,ios_base::failbit is set in the input function’s local error
state beforesetstate is called.273
21 In any case, ifn is greater than zero, it then stores a null character (usingcharT()) into the next
successive location of the array.
22 Returns: *this.
23 [Example 1:
#include <iostream>
int main() {
using namespace std;
270) Note that this function is not overloaded on typessigned char and unsigned char.
271) Since the final input character is “extracted”, it is counted in thegcount(), even though it is not stored.
272) This allows an input line which exactly fills the buffer, without settingfailbit. This is different behavior than the historical
AT&T implementation.
273) This implies an empty input line will not causefailbit to be set.
§ 31.7.5.4 © ISO/IEC
2041

===== PAGE 2053 =====

Dxxxx
const int line_buffer_size = 100;
char buffer[line_buffer_size];
int line_number = 0;
while (cin.getline(buffer, line_buffer_size, '\n') || cin.gcount()) {
int count = cin.gcount();
if (cin.eof())
cout << "Partial final line"; // cin.fail() is false
else if (cin.fail()) {
cout << "Partial long line";
cin.clear(cin.rdstate() & ~ios_base::failbit);
} else {
count--; // Don’t include newline incount
cout << "Line " << ++line_number;
}
cout << " (" << count << " chars): " << buffer << endl;
}
}
—end example]
basic_istream& getline(char_type* s, streamsize n);
24 Returns: getline(s, n, widen(’\n’)).
basic_istream& ignore(streamsize n = 1, int_type delim = traits::eof());
25 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, extracts characters and discards them. Characters are extracted until any of the following
occurs:
—(25.1) n != numeric_limits<streamsize>::max() (17.3.5) andn characters have been extracted so
far;
—(25.2) end-of-file occurs on the input sequence (in which case the function callssetstate(eofbit),
which may throwios_base::failure (31.5.4.4));
—(25.3) traits::eq_int_type(traits::to_int_type(c), delim) for the next available input character
c (in which casec is extracted).
[Note 1: The last condition will never occur iftraits::eq_int_type(delim, traits::eof()). —end note]
26 Returns: *this.
basic_istream& ignore(streamsize n, char_type delim);
27 Constraints: is_same_v<char_type, char> is true.
28 Effects: Equivalent to:return ignore(n, traits::to_int_type(delim));
int_type peek();
29 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, reads but does not extract the current input character.
30 Returns: traits::eof() if good() is false. Otherwise, returnsrdbuf()->sgetc().
basic_istream& read(char_type* s, streamsize n);
31 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, if !good() calls setstate(failbit) which may throw an exception, and return. Otherwise
extracts characters and stores them into successive locations of an array whose first element is designated
by s.274 Characters are extracted and stored until either of the following occurs:
—(31.1) n characters are stored;
—(31.2) end-of-file occurs on the input sequence (in which case the function callssetstate(failbit |
eofbit), which may throwios_base::failure (31.5.4.4)).
32 Returns: *this.
274) Note that this function is not overloaded on typessigned char and unsigned char.
§ 31.7.5.4 © ISO/IEC
2042

===== PAGE 2054 =====

Dxxxx
streamsize readsome(char_type* s, streamsize n);
33 Effects: Behaves as an unformatted input function (as described above). After constructing asentry
object, if !good() calls setstate(failbit) which may throw an exception, and return. Other-
wise extracts characters and stores them into successive locations of an array whose first element
is designated by s. If rdbuf()->in_avail() == -1, calls setstate(eofbit) (which may throw
ios_base::failure (31.5.4.4)), and extracts no characters;
—(33.1) If rdbuf()->in_avail() == 0, extracts no characters
—(33.2) If rdbuf()->in_avail() > 0, extractsmin(rdbuf()->in_avail(), n)).
34 Returns: The number of characters extracted.
basic_istream& putback(char_type c);
35 Effects: Behaves as an unformatted input function (as described above), except that the function
first clearseofbit. After constructing asentry object, if !good() calls setstate(failbit) which
may throw an exception, and return. If rdbuf() is not null, calls rdbuf()->sputbackc(c). If
rdbuf() is null, or ifsputbackc returns traits::eof(), callssetstate(badbit) (which may throw
ios_base::failure (31.5.4.4)).
[Note 2: This function extracts no characters, so the value returned by the next call togcount() is 0. —end
note]
36 Returns: *this.
basic_istream& unget();
37 Effects: Behaves as an unformatted input function (as described above), except that the function
first clearseofbit. After constructing asentry object, if !good() calls setstate(failbit) which
may throw an exception, and return. Ifrdbuf() is not null, callsrdbuf()->sungetc(). If rdbuf()
is null, or if sungetc returns traits::eof(), calls setstate(badbit) (which may throw ios_-
base::failure (31.5.4.4)).
[Note 3: This function extracts no characters, so the value returned by the next call togcount() is 0. —end
note]
38 Returns: *this.
int sync();
39 Effects: Behaves as an unformatted input function (as described above), except that it does not count
the number of characters extracted and does not affect the value returned by subsequent calls to
gcount(). After constructing asentry object, if rdbuf() is a null pointer, returns-1. Otherwise,
calls rdbuf()->pubsync() and, if that function returns-1 calls setstate(badbit) (which may throw
ios_base::failure (31.5.4.4), and returns-1. Otherwise, returns zero.
pos_type tellg();
40 Effects: Behaves as an unformatted input function (as described above), except that it does not count
the number of characters extracted and does not affect the value returned by subsequent calls to
gcount().
41 Returns: After constructing asentry object, if fail() != false, returnspos_type(-1) to indicate
failure. Otherwise, returnsrdbuf()->pubseekoff(0, cur, in).
basic_istream& seekg(pos_type pos);
42 Effects: Behaves as an unformatted input function (as described above), except that the function
first clearseofbit, it does not count the number of characters extracted, and it does not affect the
value returned by subsequent calls togcount(). After constructing asentry object, if fail() !=
true, executes rdbuf()->pubseekpos(pos, ios_base::in). In case of failure, the function calls
setstate(failbit) (which may throwios_base::failure).
43 Returns: *this.
basic_istream& seekg(off_type off, ios_base::seekdir dir);
44 Effects: Behaves as an unformatted input function (as described above), except that the function
first clearseofbit, does not count the number of characters extracted, and does not affect the value
§ 31.7.5.4 © ISO/IEC
2043

===== PAGE 2055 =====

Dxxxx
returned by subsequent calls togcount(). After constructing asentry object, if fail() != true,
executes rdbuf()->pubseekoff(off, dir, ios_base::in). In case of failure, the function calls
setstate(failbit) (which may throwios_base::failure).
45 Returns: *this.
31.7.5.5 Standard basic_istream manipulators [istream.manip]
1 Each instantiation of the function template specified in this subclause is a designated addressable function
(16.4.5.2.1).
template<class charT, class traits>
basic_istream<charT, traits>& ws(basic_istream<charT, traits>& is);
2 Effects: Behaves as an unformatted input function (31.7.5.4), except that it does not count the number
of characters extracted and does not affect the value returned by subsequent calls tois.gcount(). After
constructing asentry object extracts characters as long as the next available characterc is whitespace
or until there are no more characters in the sequence. Whitespace characters are distinguished with the
same criterion as used bysentry::sentry (31.7.5.2.4). If ws stops extracting characters because there
are no more available it setseofbit, but notfailbit.
3 Returns: is.
31.7.5.6 Rvalue stream extraction [istream.rvalue]
template<class Istream, class T>
Istream&& operator>>(Istream&& is, T&& x);
1 Constraints: The expressionis >> std::forward<T>(x)is well-formed when treated as an unevaluated
operand (7.2.3) andIstream is publicly and unambiguously derived fromios_base.
2 Effects: Equivalent to:
is >> std::forward<T>(x);
return std::move(is);
31.7.5.7 Class template basic_iostream [iostreamclass]
31.7.5.7.1 General [iostreamclass.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_iostream
: public basic_istream<charT, traits>,
public basic_ostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.7.5.7.2, constructor
explicit basic_iostream(basic_streambuf<charT, traits>* sb);
// 31.7.5.7.3, destructor
virtual ~basic_iostream();
protected:
// 31.7.5.7.2, constructor
basic_iostream(const basic_iostream&) = delete;
basic_iostream(basic_iostream&& rhs);
// 31.7.5.7.4, assignment and swap
basic_iostream& operator=(const basic_iostream&) = delete;
basic_iostream& operator=(basic_iostream&& rhs);
void swap(basic_iostream& rhs);
};
}
§ 31.7.5.7.1 © ISO/IEC
2044

===== PAGE 2056 =====

Dxxxx
1 The class templatebasic_iostream inherits a number of functions that allow reading input and writing
output to sequences controlled by a stream buffer.
31.7.5.7.2 Constructors [iostream.cons]
explicit basic_iostream(basic_streambuf<charT, traits>* sb);
1 Effects: Initializes the base class subobjects withbasic_istream<charT, traits>(sb) (31.7.5.2) and
basic_ostream<charT, traits>(sb) (31.7.6.2).
2 Postconditions: rdbuf() == sb and gcount() == 0.
basic_iostream(basic_iostream&& rhs);
3 Effects: Move constructs from the rvaluerhs by constructing thebasic_istream base class with
std::move(rhs).
31.7.5.7.3 Destructor [iostream.dest]
virtual ~basic_iostream();
1 Remarks: Does not perform any operations onrdbuf().
31.7.5.7.4 Assignment and swap [iostream.assign]
basic_iostream& operator=(basic_iostream&& rhs);
1 Effects: Equivalent toswap(rhs).
void swap(basic_iostream& rhs);
2 Effects: Calls basic_istream<charT, traits>::swap(rhs).
31.7.6 Output streams [output.streams]
31.7.6.1 General [output.streams.general]
1 The header <ostream> defines a class template and several function templates that control output to a
stream buffer, along with a function template that inserts into stream rvalues.
31.7.6.2 Class template basic_ostream [ostream]
31.7.6.2.1 General [ostream.general]
1 When a function has a parameter typeextended-floating-point-type , the implementation provides
overloads for all cv-unqualified extended floating-point types (6.9.2).
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_ostream : virtual public basic_ios<charT, traits> {
public:
// types (inherited frombasic_ios (31.5.4))
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.7.6.2.2, constructor/destructor
explicit basic_ostream(basic_streambuf<char_type, traits>* sb);
virtual ~basic_ostream();
// 31.7.6.2.4, prefix/suffix
class sentry;
// 31.7.6.3, formatted output
basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));
basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT, traits>&));
basic_ostream& operator<<(ios_base& (*pf)(ios_base&));
§ 31.7.6.2.1 © ISO/IEC
2045

===== PAGE 2057 =====

Dxxxx
basic_ostream& operator<<(bool n);
basic_ostream& operator<<(short n);
basic_ostream& operator<<(unsigned short n);
basic_ostream& operator<<(int n);
basic_ostream& operator<<(unsigned int n);
basic_ostream& operator<<(long n);
basic_ostream& operator<<(unsigned long n);
basic_ostream& operator<<(long long n);
basic_ostream& operator<<(unsigned long long n);
basic_ostream& operator<<(float f);
basic_ostream& operator<<(double f);
basic_ostream& operator<<(long double f);
basic_ostream& operator<<(extended-floating-point-type f);
basic_ostream& operator<<(const void* p);
basic_ostream& operator<<(const volatile void* p);
basic_ostream& operator<<(nullptr_t);
basic_ostream& operator<<(basic_streambuf<char_type, traits>* sb);
// 31.7.6.4, unformatted output
basic_ostream& put(char_type c);
basic_ostream& write(const char_type* s, streamsize n);
basic_ostream& flush();
// 31.7.6.2.5, seeks
pos_type tellp();
basic_ostream& seekp(pos_type);
basic_ostream& seekp(off_type, ios_base::seekdir);
protected:
// 31.7.6.2.2, copy/move constructor
basic_ostream(const basic_ostream&) = delete;
basic_ostream(basic_ostream&& rhs);
// 31.7.6.2.3, assignment and swap
basic_ostream& operator=(const basic_ostream&) = delete;
basic_ostream& operator=(basic_ostream&& rhs);
void swap(basic_ostream& rhs);
};
// 31.7.6.3.4, character inserters
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>&, charT);
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>&, char);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, char);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, signed char);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, unsigned char);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, wchar_t) = delete;
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, char8_t) = delete;
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, char16_t) = delete;
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, char32_t) = delete;
§ 31.7.6.2.1 © ISO/IEC
2046

===== PAGE 2058 =====

Dxxxx
template<class traits>
basic_ostream<wchar_t, traits>&
operator<<(basic_ostream<wchar_t, traits>&, char8_t) = delete;
template<class traits>
basic_ostream<wchar_t, traits>&
operator<<(basic_ostream<wchar_t, traits>&, char16_t) = delete;
template<class traits>
basic_ostream<wchar_t, traits>&
operator<<(basic_ostream<wchar_t, traits>&, char32_t) = delete;
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>&, const charT*);
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>&, const char*);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, const char*);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, const signed char*);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, const unsigned char*);
template<class traits>
basic_ostream<char, traits>&
operator<<(basic_ostream<char, traits>&, const wchar_t*) = delete;
template<class traits>
basic_ostream<char, traits>&
operator<<(basic_ostream<char, traits>&, const char8_t*) = delete;
template<class traits>
basic_ostream<char, traits>&
operator<<(basic_ostream<char, traits>&, const char16_t*) = delete;
template<class traits>
basic_ostream<char, traits>&
operator<<(basic_ostream<char, traits>&, const char32_t*) = delete;
template<class traits>
basic_ostream<wchar_t, traits>&
operator<<(basic_ostream<wchar_t, traits>&, const char8_t*) = delete;
template<class traits>
basic_ostream<wchar_t, traits>&
operator<<(basic_ostream<wchar_t, traits>&, const char16_t*) = delete;
template<class traits>
basic_ostream<wchar_t, traits>&
operator<<(basic_ostream<wchar_t, traits>&, const char32_t*) = delete;
}
2 The class templatebasic_ostream defines a number of member function signatures that assist in formatting
and writing output to output sequences controlled by a stream buffer.
3 Two groups of member function signatures share common properties: theformatted output functions(or
inserters) and theunformatted output functions.Both groups of output functions generate (orinsert) output
characters by actions equivalent to callingrdbuf()->sputc(int_type). They may use other public members
of basic_ostream except that they shall not invoke any virtual members ofrdbuf() except overflow(),
xsputn(), andsync().
4 If one of these called functions throws an exception, then unless explicitly noted otherwise the output function
sets badbit in the error state. Ifbadbit is set inexceptions(), the output function rethrows the exception
without completing its actions, otherwise it does not throw anything and proceeds as if the called function
had returned a failure indication.
5 [Note 1: The deleted overloads ofoperator<< prevent formatting characters as integers and strings as pointers.
—end note]
§ 31.7.6.2.1 © ISO/IEC
2047

===== PAGE 2059 =====

Dxxxx
31.7.6.2.2 Constructors [ostream.cons]
explicit basic_ostream(basic_streambuf<charT, traits>* sb);
1 Effects: Initializes the base class subobject withbasic_ios<charT, traits>::init(sb) (31.5.4.2).
2 Postconditions: rdbuf() == sb.
basic_ostream(basic_ostream&& rhs);
3 Effects: Move constructs from the rvaluerhs. This is accomplished by default constructing the base
class and callingbasic_ios<charT, traits>::move(rhs) to initialize the base class.
virtual ~basic_ostream();
4 Remarks: Does not perform any operations onrdbuf().
31.7.6.2.3 Assignment and swap [ostream.assign]
basic_ostream& operator=(basic_ostream&& rhs);
1 Effects: Equivalent toswap(rhs).
2 Returns: *this.
void swap(basic_ostream& rhs);
3 Effects: Calls basic_ios<charT, traits>::swap(rhs).
31.7.6.2.4 Class basic_ostream::sentry [ostream.sentry]
namespace std {
template<class charT, class traits>
class basic_ostream<charT, traits>::sentry {
bool ok_; // exposition only
public:
explicit sentry(basic_ostream& os);
~sentry();
explicit operator bool() const { return ok_; }
sentry(const sentry&) = delete;
sentry& operator=(const sentry&) = delete;
};
}
1 The classsentry defines a class that is responsible for doing exception safe prefix and suffix operations.
explicit sentry(basic_ostream& os);
2 If os.good() is nonzero, prepares for formatted or unformatted output. Ifos.tie() is not a null
pointer, callsos.tie()->flush().275
3 If, after any preparation is completed,os.good() is true, ok_ == true otherwise, ok_ == false.
During preparation, the constructor may callsetstate(failbit) (which may throw ios_base::
failure (31.5.4.4)).276
~sentry();
4 If (os.flags() & ios_base::unitbuf) && !uncaught_exceptions() && os.good() is true, calls
os.rdbuf()->pubsync(). If that function returns −1 or exits via an exception, sets badbit in
os.rdstate() without propagating an exception.
explicit operator bool() const;
5 Effects: Returns ok_.
275) The callos.tie()->flush() does not necessarily occur if the function can determine that no synchronization is necessary.
276) The sentry constructor and destructor can also perform additional implementation-dependent operations.
§ 31.7.6.2.4 © ISO/IEC
2048

===== PAGE 2060 =====

Dxxxx
31.7.6.2.5 Seek members [ostream.seeks]
1 Each seek member function begins execution by constructing an object of classsentry. It returns by
destroying thesentry object.
pos_type tellp();
2 Returns: If fail() != false, returnspos_type(-1) to indicate failure. Otherwise, returnsrdbuf()->
pubseekoff(0, cur, out).
basic_ostream& seekp(pos_type pos);
3 Effects: Iffail() != true, executesrdbuf()->pubseekpos(pos, ios_base::out). In case of failure,
the function callssetstate(failbit) (which may throwios_base::failure).
4 Returns: *this.
basic_ostream& seekp(off_type off, ios_base::seekdir dir);
5 Effects: If fail() != true, executesrdbuf()->pubseekoff(off, dir, ios_base::out). In case of
failure, the function callssetstate(failbit) (which may throwios_base::failure).
6 Returns: *this.
31.7.6.3 Formatted output functions [ostream.formatted]
31.7.6.3.1 Common requirements [ostream.formatted.reqmts]
1 Each formatted output function begins execution by constructing an object of classsentry. If that object
returns true when converted to a value of typebool, the function endeavors to generate the requested
output. If the generation fails, then the formatted output function doessetstate(ios_base::failbit),
which can throw an exception. If an exception is thrown during output, thenios_base::badbit is set277
in *this’s error state. If(exceptions() & badbit) != 0 then the exception is rethrown. Whether or not
an exception is thrown, thesentry object is destroyed before leaving the formatted output function. If no
exception is thrown, the result of the formatted output function is*this.
2 The descriptions of the individual formatted output functions describe how they perform output and do not
mention thesentry object.
3 If a formatted output function of a streamos determines padding, it does so as follows. Given acharT
character sequenceseq where charT is the character container type of the stream, if the length ofseq is
less than os.width(), then enough copies ofos.fill() are added to this sequence as necessary to pad
to a width ofos.width() characters. If (os.flags() & ios_base::adjustfield) == ios_base::left
is true, the fill characters are placed after the character sequence; otherwise, they are placed before the
character sequence.
31.7.6.3.2 Arithmetic inserters [ostream.inserters.arithmetic]
basic_ostream& operator<<(bool val);
basic_ostream& operator<<(short val);
basic_ostream& operator<<(unsigned short val);
basic_ostream& operator<<(int val);
basic_ostream& operator<<(unsigned int val);
basic_ostream& operator<<(long val);
basic_ostream& operator<<(unsigned long val);
basic_ostream& operator<<(long long val);
basic_ostream& operator<<(unsigned long long val);
basic_ostream& operator<<(float val);
basic_ostream& operator<<(double val);
basic_ostream& operator<<(long double val);
basic_ostream& operator<<(const void* val);
1 Effects: The classesnum_get<>and num_put<>handle locale-dependent numeric formatting and parsing.
These inserter functions use the imbuedlocale value to perform numeric formatting. Whenval is of
type bool, long, unsigned long, long long, unsigned long long, double, long double, orconst
void*, the formatting conversion occurs as if it performed the following code fragment:
277) This is done without causing anios_base::failure to be thrown.
§ 31.7.6.3.2 © ISO/IEC
2049

===== PAGE 2061 =====

Dxxxx
bool failed = use_facet<num_put<charT, ostreambuf_iterator<charT, traits>>>(
getloc()).put(*this, *this, fill(), val).failed();
When val is of typeshort the formatting conversion occurs as if it performed the following code
fragment:
ios_base::fmtflags baseflags = ios_base::flags() & ios_base::basefield;
bool failed = use_facet<num_put<charT, ostreambuf_iterator<charT, traits>>>(
getloc()).put(*this, *this, fill(),
baseflags == ios_base::oct || baseflags == ios_base::hex
? static_cast<long>(static_cast<unsigned short>(val))
: static_cast<long>(val)).failed();
When valis of typeintthe formatting conversion occurs as if it performed the following code fragment:
ios_base::fmtflags baseflags = ios_base::flags() & ios_base::basefield;
bool failed = use_facet<num_put<charT, ostreambuf_iterator<charT, traits>>>(
getloc()).put(*this, *this, fill(),
baseflags == ios_base::oct || baseflags == ios_base::hex
? static_cast<long>(static_cast<unsigned int>(val))
: static_cast<long>(val)).failed();
When val is of type unsigned short or unsigned int the formatting conversion occurs as if it
performed the following code fragment:
bool failed = use_facet<num_put<charT, ostreambuf_iterator<charT, traits>>>(
getloc()).put(*this, *this, fill(), static_cast<unsigned long>(val)).failed();
When val is of typefloat the formatting conversion occurs as if it performed the following code
fragment:
bool failed = use_facet<num_put<charT, ostreambuf_iterator<charT, traits>>>(
getloc()).put(*this, *this, fill(), static_cast<double>(val)).failed();
2 The first argument provides an object of theostreambuf_iterator<> class which is an iterator for
class basic_ostream<>. It bypassesostreams and usesstreambufs directly. Classlocale relies on
these types as its interface to iostreams, since for flexibility it has been abstracted away from direct
dependence on ostream. The second parameter is a reference to the base class subobject of type
ios_base. It provides formatting specifications such as field width, and a locale from which to obtain
other facets. If failed is true then does setstate(badbit), which may throw an exception, and
returns.
3 Returns: *this.
basic_ostream& operator<<(const volatile void* p);
4 Effects: Equivalent to:return operator<<(const_cast<const void*>(p));
basic_ostream& operator<<(extended-floating-point-type val);
5 Effects: If the floating-point conversion rank ofextended-floating-point-type is less than or equal
to that ofdouble, the formatting conversion occurs as if it performed the following code fragment:
bool failed = use_facet<num_put<charT, ostreambuf_iterator<charT, traits>>>(
getloc()).put(*this, *this, fill(), static_cast<double>(val)).failed();
Otherwise, if the floating-point conversion rank ofextended-floating-point-type is less than or
equal to that oflong double, the formatting conversion occurs as if it performed the following code
fragment:
bool failed = use_facet<num_put<charT, ostreambuf_iterator<charT, traits>>>(
getloc()).put(*this, *this, fill(), static_cast<long double>(val)).failed();
Otherwise, an invocation of the operator function is conditionally supported with implementation-defined
semantics.
If failed is true then doessetstate(badbit), which may throw an exception, and returns.
6 Returns: *this.
§ 31.7.6.3.2 © ISO/IEC
2050

===== PAGE 2062 =====

Dxxxx
31.7.6.3.3 basic_ostream::operator<< [ostream.inserters]
basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));
1 Effects: None. Does not behave as a formatted output function (as described in 31.7.6.3.1).
2 Returns: pf(*this).278
basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT, traits>&));
3 Effects: Calls pf(*this). This inserter does not behave as a formatted output function (as described
in 31.7.6.3.1).
4 Returns: *this.279
basic_ostream& operator<<(ios_base& (*pf)(ios_base&));
5 Effects: Calls pf(*this). This inserter does not behave as a formatted output function (as described
in 31.7.6.3.1).
6 Returns: *this.
basic_ostream& operator<<(basic_streambuf<charT, traits>* sb);
7 Effects: Behaves as an unformatted output function (31.7.6.4). After thesentry object is constructed,
if sb is null callssetstate(badbit) (which may throwios_base::failure).
8 Gets characters fromsb and inserts them in*this. Characters are read fromsb and inserted until any
of the following occurs:
—(8.1) end-of-file occurs on the input sequence;
—(8.2) inserting in the output sequence fails (in which case the character to be inserted is not extracted);
—(8.3) an exception occurs while getting a character fromsb.
9 If the function inserts no characters, it calls setstate(failbit) (which may throw ios_base::
failure (31.5.4.4)). If an exception was thrown while extracting a character, the function setsfailbit
in the error state, and iffailbit is set inexceptions() the caught exception is rethrown.
10 Returns: *this.
basic_ostream& operator<<(nullptr_t);
11 Effects: Equivalent to:
return *this << s;
where s is an implementation-defined NTCTS (3.36).
31.7.6.3.4 Character inserter function templates [ostream.inserters.character]
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& out, charT c);
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& out, char c);
// specialization
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>& out, char c);
// signed and unsigned
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>& out, signed char c);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>& out, unsigned char c);
1 Effects: Behaves as a formatted output function (31.7.6.3.1) ofout. Constructs a character sequence
seq. If c has typechar and the character container type of the stream is notchar, thenseq consists
of out.widen(c); otherwiseseq consists ofc. Determines padding forseq as described in 31.7.6.3.1.
Inserts seq into out. Calls os.width(0).
2 Returns: out.
278) See, for example, the function signatureendl(basic_ostream&) (31.7.6.5).
279) See, for example, the function signaturedec(ios_base&) (31.5.5.3).
§ 31.7.6.3.4 © ISO/IEC
2051

===== PAGE 2063 =====

Dxxxx
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& out, const charT* s);
template<class charT, class traits>
basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& out, const char* s);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>& out, const char* s);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>& out, const signed char* s);
template<class traits>
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>& out,
const unsigned char* s);
3 Preconditions: s is not a null pointer.
4 Effects: Behaves like a formatted inserter (as described in 31.7.6.3.1) ofout. Creates a character
sequence seq of n characters starting ats, each widened usingout.widen() (31.5.4.3), wheren is the
number that would be computed as if by:
—(4.1) traits::length(s) for the overload where the first argument is of typebasic_ostream<charT,
traits>& and the second is of typeconst charT*, and also for the overload where the first
argument is of typebasic_ostream<char, traits>& and the second is of typeconst char*,
—(4.2) char_traits<char>::length(s) for the overload where the first argument is of typebasic_-
ostream<charT, traits>& and the second is of typeconst char*,
—(4.3) traits::length(reinterpret_cast<const char*>(s)) for the other two overloads.
Determines padding forseq as described in 31.7.6.3.1. Insertsseq into out. Calls width(0).
5 Returns: out.
31.7.6.3.5 Print [ostream.formatted.print]
template<class... Args>
void print(ostream& os, format_string<Args...> fmt, Args&&... args);
1 Effects: If the ordinary literal encoding (5.3.1) is UTF-8, equivalent to:
vprint_unicode(os, fmt.str , make_format_args(args...));
Otherwise, equivalent to:
vprint_nonunicode(os, fmt.str , make_format_args(args...));
template<class... Args>
void println(ostream& os, format_string<Args...> fmt, Args&&... args);
2 Effects: Equivalent to:
print(os, "{}\n", format(os.getloc(), fmt, std::forward<Args>(args)...));
void println(ostream& os);
3 Effects: Equivalent to:
print(os, "\n");
void vprint_unicode(ostream& os, string_view fmt, format_args args);
void vprint_nonunicode(ostream& os, string_view fmt, format_args args);
4 Effects: Behaves as a formatted output function (31.7.6.3.1) ofos, except that:
—(4.1) failure to generate output is reported as specified below, and
—(4.2) any exception thrown by the call tovformat is propagated without regard to the value of
os.exceptions() and without turning onios_base::badbit in the error state ofos.
After constructing asentry object, the function initializes a variable with automatic storage duration
via
string out = vformat(os.getloc(), fmt, args);
—(4.3) If the function isvprint_unicode and os is a stream that refers to a terminal that is capable of
displaying Unicode only via a native Unicode API, which is determined in an implementation-
defined manner, flushesos and then writesout to the terminal using the native Unicode API;
§ 31.7.6.3.5 © ISO/IEC
2052

===== PAGE 2064 =====

Dxxxx
if out contains invalid code units, the behavior is undefined. Then establishes an observable
checkpoint (4.1.2).
—(4.4) Otherwise inserts the character sequence[out.begin(),out.end()) into os.
If writing to the terminal or inserting intoos fails, callsos.setstate(ios_base::badbit) (which may
throw ios_base::failure).
5 Recommended practice: Forvprint_unicode, if invoking the native Unicode API requires transcoding,
implementations should substitute invalid code units withu+fffd replacement characterper the
Unicode Standard, Chapter 3.9u+fffd Substitution in Conversion.
31.7.6.4 Unformatted output functions [ostream.unformatted]
1 Each unformatted output function begins execution by constructing an object of classsentry. If that object
returns true, while converting to a value of typebool, the function endeavors to generate the requested
output. If an exception is thrown during output, thenios_base::badbit is set280 in *this’s error state.
If (exceptions() & badbit) != 0 then the exception is rethrown. In any case, the unformatted output
function ends by destroying thesentry object, then, if no exception was thrown, returning the value specified
for the unformatted output function.
basic_ostream& put(char_type c);
2 Effects: Behaves as an unformatted output function (as described above). After constructing asentry
object, inserts the characterc, if possible.281
3 Otherwise, callssetstate(badbit) (which may throwios_base::failure (31.5.4.4)).
4 Returns: *this.
basic_ostream& write(const char_type* s, streamsize n);
5 Effects: Behaves as an unformatted output function (as described above). After constructing asentry
object, obtains characters to insert from successive locations of an array whose first element is designated
by s.282 Characters are inserted until either of the following occurs:
—(5.1) n characters are inserted;
—(5.2) inserting in the output sequence fails (in which case the function callssetstate(badbit), which
may throwios_base::failure (31.5.4.4)).
6 Returns: *this.
basic_ostream& flush();
7 Effects: Behaves as an unformatted output function (as described above). Ifrdbuf() is not a null
pointer, constructs asentry object. If that object returnstrue when converted to a value of type
bool the function callsrdbuf()->pubsync(). If that function returns−1 calls setstate(badbit)
(which may throwios_base::failure (31.5.4.4)). Otherwise, if thesentry object returnsfalse, does
nothing.
8 Returns: *this.
31.7.6.5 Standard basic_ostream manipulators [ostream.manip]
1 Each instantiation of any of the function templates specified in this subclause is a designated addressable
function (16.4.5.2.1).
template<class charT, class traits>
basic_ostream<charT, traits>& endl(basic_ostream<charT, traits>& os);
2 Effects: Calls os.put(os.widen(’\n’)), thenos.flush().
3 Returns: os.
template<class charT, class traits>
basic_ostream<charT, traits>& ends(basic_ostream<charT, traits>& os);
4 Effects: Inserts a null character into the output sequence: callsos.put(charT()).
280) This is done without causing anios_base::failure to be thrown.
281) Note that this function is not overloaded on typessigned char and unsigned char.
282) Note that this function is not overloaded on typessigned char and unsigned char.
§ 31.7.6.5 © ISO/IEC
2053

===== PAGE 2065 =====

Dxxxx
5 Returns: os.
template<class charT, class traits>
basic_ostream<charT, traits>& flush(basic_ostream<charT, traits>& os);
6 Effects: Calls os.flush().
7 Returns: os.
template<class charT, class traits>
basic_ostream<charT, traits>& emit_on_flush(basic_ostream<charT, traits>& os);
8 Effects: If os.rdbuf() is abasic_syncbuf<charT, traits, Allocator>*, calledbuf for the purpose
of exposition, callsbuf->set_emit_on_sync(true). Otherwise this manipulator has no effect.
[Note 1: To work around the issue that theAllocator template argument cannot be deduced, implementations
can introduce an intermediate base class tobasic_syncbuf that manages itsemit-on-sync flag. —end note]
9 Returns: os.
template<class charT, class traits>
basic_ostream<charT, traits>& noemit_on_flush(basic_ostream<charT, traits>& os);
10 Effects: If os.rdbuf() is abasic_syncbuf<charT, traits, Allocator>*, calledbuf for the purpose
of exposition, callsbuf->set_emit_on_sync(false). Otherwise this manipulator has no effect.
11 Returns: os.
template<class charT, class traits>
basic_ostream<charT, traits>& flush_emit(basic_ostream<charT, traits>& os);
12 Effects: Calls os.flush(). Then, ifos.rdbuf() is abasic_syncbuf<charT, traits, Allocator>*,
called buf for the purpose of exposition, behaves as an unformatted output function (31.7.6.4)
of os. After constructing a sentry object, calls buf->emit(). If that call returns false, calls
os.setstate(ios_base::badbit).
13 Returns: os.
31.7.6.6 Rvalue stream insertion [ostream.rvalue]
template<class Ostream, class T>
Ostream&& operator<<(Ostream&& os, const T& x);
1 Constraints: The expression os << x is well-formed when treated as an unevaluated operand and
Ostream is publicly and unambiguously derived fromios_base.
2 Effects: As if by:os << x;
3 Returns: std::move(os).
31.7.7 Standard manipulators [std.manip]
1 The header<iomanip> defines several functions that support extractors and inserters that alter information
maintained by classios_base and its derived classes.
unspecified resetiosflags(ios_base::fmtflags mask);
2 Returns: An object of unspecified type such that ifout is an object of typebasic_ostream<charT,
traits> then the expressionout << resetiosflags(mask) behaves as if it calledf(out, mask), or if
in is an object of typebasic_istream<charT, traits> then the expressionin >> resetiosflags(
mask) behaves as if it calledf(in, mask), where the functionf is defined as:283
void f(ios_base& str, ios_base::fmtflags mask) {
// reset specified flags
str.setf(ios_base::fmtflags(0), mask);
}
283) The expression cin >> resetiosflags(ios_base::skipws) clears ios_base::skipws in the format flags stored in the
basic_istream<charT, traits> object cin (the same ascin >> noskipws), and the expressioncout << resetiosflags(ios_-
base::showbase) clears ios_base::showbase in the format flags stored in thebasic_ostream<charT, traits> object cout (the
same ascout << noshowbase).
§ 31.7.7 © ISO/IEC
2054

===== PAGE 2066 =====

Dxxxx
The expressionout << resetiosflags(mask) has typebasic_ostream<charT, traits>& and value
out. The expression in >> resetiosflags(mask) has typebasic_istream<charT, traits>& and
value in.
unspecified setiosflags(ios_base::fmtflags mask);
3 Returns: An object of unspecified type such that ifout is an object of typebasic_ostream<charT,
traits> then the expressionout << setiosflags(mask) behaves as if it calledf(out, mask), or ifin
is an object of typebasic_istream<charT, traits> then the expressionin >> setiosflags(mask)
behaves as if it calledf(in, mask), where the functionf is defined as:
void f(ios_base& str, ios_base::fmtflags mask) {
// set specified flags
str.setf(mask);
}
The expression out << setiosflags(mask) has type basic_ostream<charT, traits>& and value
out. The expressionin >> setiosflags(mask)has typebasic_istream<charT, traits>&and value
in.
unspecified setbase(int base);
4 Returns: An object of unspecified type such that ifout is an object of typebasic_ostream<charT,
traits> then the expressionout << setbase(base) behaves as if it calledf(out, base), or ifin is
an object of typebasic_istream<charT, traits> then the expressionin >> setbase(base) behaves
as if it calledf(in, base), where the functionf is defined as:
void f(ios_base& str, int base) {
// set basefield
str.setf(base == 8 ? ios_base::oct :
base == 10 ? ios_base::dec :
base == 16 ? ios_base::hex :
ios_base::fmtflags(0), ios_base::basefield);
}
The expression out << setbase(base) has type basic_ostream<charT, traits>& and value out.
The expressionin >> setbase(base) has typebasic_istream<charT, traits>& and valuein.
unspecified setfill(char_type c);
5 Returns: An object of unspecified type such that ifout is an object of typebasic_ostream<charT,
traits> and c has typecharT then the expressionout << setfill(c) behaves as if it calledf(out,
c), where the functionf is defined as:
template<class charT, class traits>
void f(basic_ios<charT, traits>& str, charT c) {
// set fill character
str.fill(c);
}
The expressionout << setfill(c) has typebasic_ostream<charT, traits>& and valueout.
unspecified setprecision(int n);
6 Returns: An object of unspecified type such that ifout is an object of typebasic_ostream<charT,
traits> then the expressionout << setprecision(n) behaves as if it calledf(out, n), or ifin is an
object of typebasic_istream<charT, traits> then the expressionin >> setprecision(n) behaves
as if it calledf(in, n), where the functionf is defined as:
void f(ios_base& str, int n) {
// set precision
str.precision(n);
}
The expressionout << setprecision(n) has typebasic_ostream<charT, traits>& and valueout.
The expressionin >> setprecision(n) has typebasic_istream<charT, traits>& and valuein.
§ 31.7.7 © ISO/IEC
2055

===== PAGE 2067 =====

Dxxxx
unspecified setw(int n);
7 Returns: An object of unspecified type such that ifout is an instance of basic_ostream<charT,
traits> then the expressionout << setw(n) behaves as if it calledf(out, n), or ifin is an object
of typebasic_istream<charT, traits> then the expressionin >> setw(n) behaves as if it called
f(in, n), where the functionf is defined as:
void f(ios_base& str, int n) {
// set width
str.width(n);
}
The expression out << setw(n) has type basic_ostream<charT, traits>& and value out. The
expression in >> setw(n) has typebasic_istream<charT, traits>& and valuein.
31.7.8 Extended manipulators [ext.manip]
1 The header <iomanip> defines several functions that support extractors and inserters that allow for the
parsing and formatting of sequences and values for money and time.
template<class moneyT> unspecified get_money(moneyT& mon, bool intl = false);
2 Mandates: The typemoneyT is eitherlong double or a specialization of thebasic_string template
(Clause 27).
3 Effects: The expressionin >> get_money(mon, intl) described below behaves as a formatted input
function (31.7.5.3.1).
4 Returns: An object of unspecified type such that ifin is an object of typebasic_istream<charT,
traits> then the expressionin >> get_money(mon, intl) behaves as if it calledf(in, mon, intl),
where the functionf is defined as:
template<class charT, class traits, class moneyT>
void f(basic_ios<charT, traits>& str, moneyT& mon, bool intl) {
using Iter = istreambuf_iterator<charT, traits>;
using MoneyGet = money_get<charT, Iter>;
ios_base::iostate err = ios_base::goodbit;
const MoneyGet& mg = use_facet<MoneyGet>(str.getloc());
mg.get(Iter(str.rdbuf()), Iter(), intl, str, err, mon);
if (ios_base::goodbit != err)
str.setstate(err);
}
The expressionin >> get_money(mon, intl) has typebasic_istream<charT, traits>& and value
in.
template<class moneyT> unspecified put_money(const moneyT& mon, bool intl = false);
5 Mandates: The typemoneyT is eitherlong double or a specialization of thebasic_string template
(Clause 27).
6 Returns: An object of unspecified type such that ifout is an object of typebasic_ostream<charT,
traits> then the expressionout << put_money(mon, intl) behaves as a formatted output function
(31.7.6.3.1) that callsf(out, mon, intl), where the functionf is defined as:
template<class charT, class traits, class moneyT>
void f(basic_ios<charT, traits>& str, const moneyT& mon, bool intl) {
using Iter = ostreambuf_iterator<charT, traits>;
using MoneyPut = money_put<charT, Iter>;
const MoneyPut& mp = use_facet<MoneyPut>(str.getloc());
const Iter end = mp.put(Iter(str.rdbuf()), intl, str, str.fill(), mon);
if (end.failed())
str.setstate(ios_base::badbit);
}
§ 31.7.8 © ISO/IEC
2056

===== PAGE 2068 =====

Dxxxx
The expressionout << put_money(mon, intl) has typebasic_ostream<charT, traits>& and value
out.
template<class charT> unspecified get_time(tm* tmb, const charT* fmt);
7 Preconditions: The argumenttmb is a valid pointer to an object of typetm, and[fmt,fmt + char_-
traits<charT>::length(fmt)) is a valid range.
8 Returns: An object of unspecified type such that ifin is an object of typebasic_istream<charT,
traits> then the expressionin >> get_time(tmb, fmt) behaves as if it calledf(in, tmb, fmt),
where the functionf is defined as:
template<class charT, class traits>
void f(basic_ios<charT, traits>& str, tm* tmb, const charT* fmt) {
using Iter = istreambuf_iterator<charT, traits>;
using TimeGet = time_get<charT, Iter>;
ios_base::iostate err = ios_base::goodbit;
const TimeGet& tg = use_facet<TimeGet>(str.getloc());
tg.get(Iter(str.rdbuf()), Iter(), str, err, tmb,
fmt, fmt + traits::length(fmt));
if (err != ios_base::goodbit)
str.setstate(err);
}
The expression in >> get_time(tmb, fmt) has type basic_istream<charT, traits>& and value
in.
template<class charT> unspecified put_time(const tm* tmb, const charT* fmt);
9 Preconditions: The argumenttmb is a valid pointer to an object of typetm, and[fmt,fmt + char_-
traits<charT>::length(fmt)) is a valid range.
10 Returns: An object of unspecified type such that ifout is an object of typebasic_ostream<charT,
traits> then the expressionout << put_time(tmb, fmt) behaves as if it calledf(out, tmb, fmt),
where the functionf is defined as:
template<class charT, class traits>
void f(basic_ios<charT, traits>& str, const tm* tmb, const charT* fmt) {
using Iter = ostreambuf_iterator<charT, traits>;
using TimePut = time_put<charT, Iter>;
const TimePut& tp = use_facet<TimePut>(str.getloc());
const Iter end = tp.put(Iter(str.rdbuf()), str, str.fill(), tmb,
fmt, fmt + traits::length(fmt));
if (end.failed())
str.setstate(ios_base::badbit);
}
The expressionout << put_time(tmb, fmt) has typebasic_ostream<charT, traits>& and value
out.
31.7.9 Quoted manipulators [quoted.manip]
1 [Note 1: Quoted manipulators provide string insertion and extraction of quoted strings (for example, XML and CSV
formats). Quoted manipulators are useful in ensuring that the content of a string with embedded spaces remains
unchanged if inserted and then extracted via stream I/O.—end note]
template<class charT>
unspecified quoted(const charT* s, charT delim = charT(’"’), charT escape = charT(’\\’));
template<class charT, class traits, class Allocator>
unspecified quoted(const basic_string<charT, traits, Allocator>& s,
charT delim = charT(’"’), charT escape = charT(’\\’));
§ 31.7.9 © ISO/IEC
2057

===== PAGE 2069 =====

Dxxxx
template<class charT, class traits>
unspecified quoted(basic_string_view<charT, traits> s,
charT delim = charT(’"’), charT escape = charT(’\\’));
2 Returns: An object of unspecified type such that ifout is an instance ofbasic_ostream with member
type char_type the same ascharT and with member typetraits_type, which in the second and third
forms is the same astraits, then the expressionout << quoted(s, delim, escape) behaves as a
formatted output function (31.7.6.3.1) ofout. This forms a character sequenceseq, initially consisting
of the following elements:
—(2.1) delim.
—(2.2) Each character ins. If the character to be output is equal toescape or delim, as determined by
traits_type::eq, first outputescape.
—(2.3) delim.
Let x be the number of elements initially inseq. Then padding is determined forseq as described
in 31.7.6.3.1,seq is inserted as if by callingout.rdbuf()->sputn(seq, n), wheren is the larger of
out.width() and x, andout.width(0) is called. The expressionout << quoted(s, delim, escape)
has typebasic_ostream<charT, traits>& and valueout.
template<class charT, class traits, class Allocator>
unspecified quoted(basic_string<charT, traits, Allocator>& s,
charT delim = charT(’"’), charT escape = charT(’\\’));
3 Returns: An object of unspecified type such that:
—(3.1) If in is an instance of basic_istream with member types char_type and traits_type the
same ascharT and traits, respectively, then the expressionin >> quoted(s, delim, escape)
behavesasifitextractsthefollowingcharactersfrom inusingoperator>>(basic_istream<charT,
traits>&, charT&) (31.7.5.3.3) which may throwios_base::failure (31.5.2.2.1):
—(3.1.1) If the first character extracted is equal todelim, as determined bytraits_type::eq, then:
—(3.1.1.1) Turn off theskipws flag.
—(3.1.1.2) s.clear()
—(3.1.1.3) Until an unescapeddelim character is reached or!in, extract characters fromin and
append them tos, except that if anescape is reached, ignore it and append the next
character tos.
—(3.1.1.4) Discard the finaldelim character.
—(3.1.1.5) Restore theskipws flag to its original value.
—(3.1.2) Otherwise, in >> s.
—(3.2) If out is an instance ofbasic_ostream with member typeschar_type and traits_type the
same ascharT and traits, respectively, then the expressionout << quoted(s, delim, escape)
behaves as specified for theconst basic_string<charT, traits, Allocator>& overload of the
quoted function.
—(3.3) The expressionin >> quoted(s, delim, escape) has typebasic_istream<charT, traits>&
and valuein.
—(3.4) The expressionout << quoted(s, delim, escape) has typebasic_ostream<charT, traits>&
and valueout.
31.7.10 Print functions [print.fun]
template<class... Args>
void print(format_string<Args...> fmt, Args&&... args);
1 Effects: Equivalent to:
print(stdout, fmt, std::forward<Args>(args)...);
§ 31.7.10 © ISO/IEC
2058

===== PAGE 2070 =====

Dxxxx
template<class... Args>
void print(FILE* stream, format_string<Args...> fmt, Args&&... args);
2 Effects: Let locksafe be (enable_nonlocking_formatter_optimization<remove_cvref_t<Args>>
&& ...). If the ordinary literal encoding (5.3.1) is UTF-8, equivalent to:
locksafe
? vprint_unicode(stream, fmt.str, make_format_args(args...))
: vprint_unicode_buffered(stream, fmt.str, make_format_args(args...));
Otherwise, equivalent to:
locksafe
? vprint_nonunicode(stream, fmt.str, make_format_args(args...))
: vprint_nonunicode_buffered(stream, fmt.str, make_format_args(args...));
template<class... Args>
void println(format_string<Args...> fmt, Args&&... args);
3 Effects: Equivalent to:
println(stdout, fmt, std::forward<Args>(args)...);
void println();
4 Effects: Equivalent to:
println(stdout);
template<class... Args>
void println(FILE* stream, format_string<Args...> fmt, Args&&... args);
5 Effects: Equivalent to:
print(stream, runtime_format(string(fmt.get()) + '\n'), std::forward<Args>(args)...);
void println(FILE* stream);
6 Effects: Equivalent to:
print(stream, "\n");
void vprint_unicode(string_view fmt, format_args args);
7 Effects: Equivalent to:
vprint_unicode(stdout, fmt, args);
void vprint_unicode_buffered(FILE* stream, string_view fmt, format_args args);
8 Effects: Equivalent to:
string out = vformat(fmt, args);
vprint_unicode(stream, "{}", make_format_args(out));
void vprint_unicode(FILE* stream, string_view fmt, format_args args);
9 Preconditions: stream is a valid pointer to an output C stream.
10 Effects: Locks stream. Let out denote the character representation of formatting arguments provided
by args formatted according to specifications given infmt.
—(10.1) If stream refers to a terminal that is capable of displaying Unicode only via a native Unicode API,
flushes stream and then writesout to the terminal using the native Unicode API; ifout contains
invalid code units, the behavior is undefined. Then establishes an observable checkpoint (4.1.2).
—(10.2) Otherwise writesout to stream unchanged.
Unconditionally unlocksstream on function exit.
See also: ISO/IEC 9899:2024, 7.23.2.
[Note 1: On Windows the native Unicode API isWriteConsoleW and stream referring to a terminal means
that GetConsoleMode(_get_osfhandle(_fileno(stream)), ...) returns nonzero. —end note]
11 Throws: Any exception thrown by the call tovformat (28.5.3). system_error if writing to the terminal
or stream fails. May throwbad_alloc.
§ 31.7.10 © ISO/IEC
2059

===== PAGE 2071 =====

Dxxxx
12 Recommended practice: If invoking the native Unicode API requires transcoding, implementations
should substitute invalid code units withu+fffd replacement characterper the Unicode Standard,
Chapter 3.9u+fffd Substitution in Conversion.
void vprint_nonunicode(string_view fmt, format_args args);
13 Effects: Equivalent to:
vprint_nonunicode(stdout, fmt, args);
void vprint_nonunicode_buffered(FILE* stream, string_view fmt, format_args args);
14 Effects: Equivalent to:
string out = vformat(fmt, args);
vprint_nonunicode("{}", make_format_args(out));
void vprint_nonunicode(FILE* stream, string_view fmt, format_args args);
15 Preconditions: stream is a valid pointer to an output C stream.
16 Effects: While holding the lock onstream, writes the character representation of formatting arguments
provided byargs formatted according to specifications given infmt to stream.
17 Throws: Any exception thrown by the call tovformat (28.5.3). system_error if writing tostream
fails. May throwbad_alloc.
31.8 String-based streams [string.streams]
31.8.1 Header <sstream> synopsis [sstream.syn]
namespace std {
// 31.8.2, class templatebasic_stringbuf
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_stringbuf;
template<class charT, class traits, class Allocator>
void swap(basic_stringbuf<charT, traits, Allocator>& x,
basic_stringbuf<charT, traits, Allocator>& y) noexcept(noexcept(x.swap(y)));
using stringbuf = basic_stringbuf<char>;
using wstringbuf = basic_stringbuf<wchar_t>;
// 31.8.3, class templatebasic_istringstream
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_istringstream;
template<class charT, class traits, class Allocator>
void swap(basic_istringstream<charT, traits, Allocator>& x,
basic_istringstream<charT, traits, Allocator>& y);
using istringstream = basic_istringstream<char>;
using wistringstream = basic_istringstream<wchar_t>;
// 31.8.4, class templatebasic_ostringstream
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_ostringstream;
template<class charT, class traits, class Allocator>
void swap(basic_ostringstream<charT, traits, Allocator>& x,
basic_ostringstream<charT, traits, Allocator>& y);
using ostringstream = basic_ostringstream<char>;
using wostringstream = basic_ostringstream<wchar_t>;
// 31.8.5, class templatebasic_stringstream
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_stringstream;
§ 31.8.1 © ISO/IEC
2060

===== PAGE 2072 =====

Dxxxx
template<class charT, class traits, class Allocator>
void swap(basic_stringstream<charT, traits, Allocator>& x,
basic_stringstream<charT, traits, Allocator>& y);
using stringstream = basic_stringstream<char>;
using wstringstream = basic_stringstream<wchar_t>;
}
1 The header<sstream> defines four class templates and eight types that associate stream buffers with objects
of classbasic_string, as described in 27.4.
31.8.2 Class template basic_stringbuf [stringbuf]
31.8.2.1 General [stringbuf.general]
namespace std {
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_stringbuf : public basic_streambuf<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using allocator_type = Allocator;
// 31.8.2.2, constructors
basic_stringbuf() : basic_stringbuf(ios_base::in | ios_base::out) {}
explicit basic_stringbuf(ios_base::openmode which);
explicit basic_stringbuf(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::in | ios_base::out);
explicit basic_stringbuf(const Allocator& a)
: basic_stringbuf(ios_base::in | ios_base::out, a) {}
basic_stringbuf(ios_base::openmode which, const Allocator& a);
explicit basic_stringbuf(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::in | ios_base::out);
template<class SAlloc>
basic_stringbuf(
const basic_string<charT, traits, SAlloc>& s, const Allocator& a)
: basic_stringbuf(s, ios_base::in | ios_base::out, a) {}
template<class SAlloc>
basic_stringbuf(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
template<class SAlloc>
explicit basic_stringbuf(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::in | ios_base::out);
template<class T>
explicit basic_stringbuf(const T& t,
ios_base::openmode which = ios_base::in | ios_base::out);
template<class T>
basic_stringbuf(const T& t, const Allocator& a);
template<class T>
basic_stringbuf(const T& t, ios_base::openmode which, const Allocator& a);
basic_stringbuf(const basic_stringbuf&) = delete;
basic_stringbuf(basic_stringbuf&& rhs);
basic_stringbuf(basic_stringbuf&& rhs, const Allocator& a);
// 31.8.2.3, assignment and swap
basic_stringbuf& operator=(const basic_stringbuf&) = delete;
basic_stringbuf& operator=(basic_stringbuf&& rhs);
void swap(basic_stringbuf& rhs) noexcept(see below );
§ 31.8.2.1 © ISO/IEC
2061

===== PAGE 2073 =====

Dxxxx
// 31.8.2.4, getters and setters
allocator_type get_allocator() const noexcept;
basic_string<charT, traits, Allocator> str() const &;
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
basic_string<charT, traits, Allocator> str() &&;
basic_string_view<charT, traits> view() const noexcept;
void str(const basic_string<charT, traits, Allocator>& s);
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
void str(basic_string<charT, traits, Allocator>&& s);
template<class T>
void str(const T& t);
protected:
// 31.8.2.5, overridden virtual functions
int_type underflow() override;
int_type pbackfail(int_type c = traits::eof()) override;
int_type overflow (int_type c = traits::eof()) override;
basic_streambuf<charT, traits>* setbuf(charT*, streamsize) override;
pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which
= ios_base::in | ios_base::out) override;
pos_type seekpos(pos_type sp,
ios_base::openmode which
= ios_base::in | ios_base::out) override;
private:
ios_base::openmode mode ; // exposition only
basic_string<charT, traits, Allocator> buf ; // exposition only
void init-buf-ptrs (); // exposition only
};
}
1 The classbasic_stringbuf is derived frombasic_streambuf to associate possibly the input sequence and
possibly the output sequence with a sequence of arbitrarycharacters. The sequence can be initialized from,
or made available as, an object of classbasic_string.
2 For the sake of exposition, the maintained data and internal pointer initialization is presented here as:
—(2.1) ios_base::openmode mode , hasin set if the input sequence can be read, andout set if the output
sequence can be written.
—(2.2) basic_string<charT, traits, Allocator> buf contains the underlying character sequence.
—(2.3) init-buf-ptrs () sets the base class’ get area (31.6.3.4.2) and put area (31.6.3.4.3) pointers after
initializing, moving from, or assigning tobuf accordingly.
31.8.2.2 Constructors [stringbuf.cons]
explicit basic_stringbuf(ios_base::openmode which);
1 Effects: Initializes the base class withbasic_streambuf() (31.6.3.2), and mode with which. It is
implementation-defined whether the sequence pointers (eback(), gptr(), egptr(), pbase(), pptr(),
epptr()) are initialized to null pointers.
2 Postconditions: str().empty() is true.
explicit basic_stringbuf(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::in | ios_base::out);
3 Effects: Initializes the base class withbasic_streambuf() (31.6.3.2), mode with which, andbuf with
s, then callsinit-buf-ptrs ().
§ 31.8.2.2 © ISO/IEC
2062

===== PAGE 2074 =====

Dxxxx
basic_stringbuf(ios_base::openmode which, const Allocator& a);
4 Effects: Initializes the base class withbasic_streambuf() (31.6.3.2), mode with which, andbuf with
a, then callsinit-buf-ptrs ().
5 Postconditions: str().empty() is true.
explicit basic_stringbuf(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::in | ios_base::out);
6 Effects: Initializes the base class withbasic_streambuf() (31.6.3.2), mode with which, andbuf with
std::move(s), then callsinit-buf-ptrs ().
template<class SAlloc>
basic_stringbuf(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
7 Effects: Initializes the base class withbasic_streambuf() (31.6.3.2), mode with which, andbuf with
{s,a}, then callsinit-buf-ptrs ().
template<class SAlloc>
explicit basic_stringbuf(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::in | ios_base::out);
8 Constraints: is_same_v<SAlloc, Allocator> is false.
9 Effects: Initializes the base class withbasic_streambuf() (31.6.3.2), mode with which, andbuf with
s, then callsinit-buf-ptrs ().
template<class T>
explicit basic_stringbuf(const T& t, ios_base::openmode which = ios_base::in | ios_base::out);
template<class T>
basic_stringbuf(const T& t, const Allocator& a);
template<class T>
basic_stringbuf(const T& t, ios_base::openmode which, const Allocator& a);
10 Let which be ios_base::in | ios_base::out for the overload with no parameterwhich, anda be
Allocator() for the overload with no parametera.
11 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
12 Effects: Creates a variable sv as if by basic_string_view<charT, traits> sv = t, then value-
initializes the base class, initializesmode with which, and direct-non-list-initializesbuf with sv, a,
then callsinit-buf-ptrs ().
basic_stringbuf(basic_stringbuf&& rhs);
basic_stringbuf(basic_stringbuf&& rhs, const Allocator& a);
13 Effects: Copy constructs the base class fromrhs and initializes mode with rhs.mode. In the first
form buf is initialized from std::move(rhs).str(). In the second form buf is initialized from
{std::move(rhs).str(), a}. It is implementation-defined whether the sequence pointers in*this
(eback(), gptr(), egptr(), pbase(), pptr(), epptr()) obtain the values whichrhs had.
14 Postconditions: Let rhs_p refer to the state ofrhs just prior to this construction and letrhs_a refer
to the state ofrhs just after this construction.
—(14.1) str() == rhs_p.str()
—(14.2) gptr() - eback() == rhs_p.gptr() - rhs_p.eback()
—(14.3) egptr() - eback() == rhs_p.egptr() - rhs_p.eback()
—(14.4) pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()
—(14.5) epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()
—(14.6) if (eback()) eback() != rhs_a.eback()
—(14.7) if (gptr()) gptr() != rhs_a.gptr()
—(14.8) if (egptr()) egptr() != rhs_a.egptr()
§ 31.8.2.2 © ISO/IEC
2063

===== PAGE 2075 =====

Dxxxx
—(14.9) if (pbase()) pbase() != rhs_a.pbase()
—(14.10) if (pptr()) pptr() != rhs_a.pptr()
—(14.11) if (epptr()) epptr() != rhs_a.epptr()
—(14.12) getloc() == rhs_p.getloc()
—(14.13) rhs is empty but usable, as ifstd::move(rhs).str() was called.
31.8.2.3 Assignment and swap [stringbuf.assign]
basic_stringbuf& operator=(basic_stringbuf&& rhs);
1 Effects: After the move assignment*this has the observable state it would have had if it had been
move constructed fromrhs (see 31.8.2.2).
2 Returns: *this.
void swap(basic_stringbuf& rhs) noexcept(see below );
3 Preconditions: allocator_traits<Allocator>::propagate_on_container_swap::value is true or
get_allocator() == rhs.get_allocator() is true.
4 Effects: Exchanges the state of*this and rhs.
5 Remarks: The exception specification is equivalent to:
allocator_traits<Allocator>::propagate_on_container_swap::value ||
allocator_traits<Allocator>::is_always_equal::value
template<class charT, class traits, class Allocator>
void swap(basic_stringbuf<charT, traits, Allocator>& x,
basic_stringbuf<charT, traits, Allocator>& y) noexcept(noexcept(x.swap(y)));
6 Effects: Equivalent tox.swap(y).
31.8.2.4 Member functions [stringbuf.members]
1 The member functions getting the underlying character sequence all refer to ahigh_mark value, where
high_mark represents the position one past the highest initialized character in the buffer. Characters can
be initialized by writing to the stream, by constructing thebasic_stringbuf passing a basic_string
argument, or by calling one of thestr member functions passing abasic_string as an argument. In the
latter case, all characters initialized prior to the call are now considered uninitialized (except for those
characters re-initialized by the newbasic_string).
void init-buf-ptrs ();
2 Effects: Initializes the input and output sequences frombuf according tomode .
3 Postconditions:
—(3.1) If ios_base::out is set inmode , pbase() points tobuf .front() and epptr() >= pbase() +
buf .size() is true;
—(3.1.1) in addition, ifios_base::ate is set inmode , pptr() == pbase() + buf .size() is true,
—(3.1.2) otherwise pptr() == pbase() is true.
—(3.2) If ios_base::in is set inmode , eback() points tobuf .front(), and(gptr() == eback() &&
egptr() == eback() + buf .size()) is true.
4 [Note 1: For efficiency reasons, stream buffer operations can violate invariants ofbuf while it is held encapsulated
in thebasic_stringbuf, e.g., by writing to characters in the range[buf .data() + buf .size(),buf .data() +
buf .capacity()). All operations retrieving abasic_string from buf ensure that thebasic_string invariants
hold on the returned value.—end note]
allocator_type get_allocator() const noexcept;
5 Returns: buf .get_allocator().
basic_string<charT, traits, Allocator> str() const &;
6 Effects: Equivalent to:
return basic_string<charT, traits, Allocator>(view(), get_allocator());
§ 31.8.2.4 © ISO/IEC
2064

===== PAGE 2076 =====

Dxxxx
template<class SAlloc>
basic_string<charT, traits, SAlloc> str(const SAlloc& sa) const;
7 Constraints: SAlloc is a type that qualifies as an allocator (23.2.2.2).
8 Effects: Equivalent to:
return basic_string<charT, traits, SAlloc>(view(), sa);
basic_string<charT, traits, Allocator> str() &&;
9 Postconditions: The underlying character sequence buf is empty and pbase(), pptr(), epptr(),
eback(), gptr(), andegptr() are initialized as if by callinginit-buf-ptrs () with an emptybuf.
10 Returns: A basic_string<charT, traits, Allocator> object move constructed from thebasic_-
stringbuf’s underlying character sequence inbuf. This can be achieved by first adjustingbuf to have
the same content asview().
basic_string_view<charT, traits> view() const noexcept;
11 Let sv be basic_string_view<charT, traits>.
12 Returns: A sv object referring to thebasic_stringbuf’s underlying character sequence inbuf:
—(12.1) If ios_base::out is set inmode , thensv(pbase(), high_mark - pbase()) is returned.
—(12.2) Otherwise, if ios_base::in is set inmode , thensv(eback(), egptr() - eback()) is returned.
—(12.3) Otherwise, sv() is returned.
13 [Note 2: Using the returnedsv object after destruction or invalidation of the character sequence underlying
*this is undefined behavior, unlesssv.empty() is true. —end note]
void str(const basic_string<charT, traits, Allocator>& s);
14 Effects: Equivalent to:
buf = s;
init-buf-ptrs ();
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
15 Constraints: is_same_v<SAlloc, Allocator> is false.
16 Effects: Equivalent to:
buf = s;
init-buf-ptrs ();
void str(basic_string<charT, traits, Allocator>&& s);
17 Effects: Equivalent to:
buf = std::move(s);
init-buf-ptrs ();
template<class T>
void str(const T& t);
18 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
19 Effects: Equivalent to:
basic_string_view<charT, traits> sv = t;
buf = sv;
init-buf-ptrs ();
31.8.2.5 Overridden virtual functions [stringbuf.virtuals]
int_type underflow() override;
1 Returns: If the input sequence has a read position available, returnstraits::to_int_type(*gptr()).
Otherwise, returnstraits::eof(). Any character in the underlying buffer which has been initialized
is considered to be part of the input sequence.
§ 31.8.2.5 © ISO/IEC
2065

===== PAGE 2077 =====

Dxxxx
int_type pbackfail(int_type c = traits::eof()) override;
2 Effects: Puts back the character designated byc to the input sequence, if possible, in one of three ways:
—(2.1) If traits::eq_int_type(c, traits::eof()) returns false and if the input sequence has a
putback position available, and iftraits::eq(to_char_type(c), gptr()[-1]) returns true,
assigns gptr() - 1 to gptr().
Returns: c.
—(2.2) If traits::eq_int_type(c, traits::eof()) returns false and if the input sequence has a
putback position available, and ifmode & ios_base::outis nonzero, assignsc to *--gptr().
Returns: c.
—(2.3) If traits::eq_int_type(c, traits::eof()) returns true and if the input sequence has a
putback position available, assignsgptr() - 1 to gptr().
Returns: traits::not_eof(c).
3 Returns: As specified above, ortraits::eof() to indicate failure.
4 Remarks: If the function can succeed in more than one of these ways, it is unspecified which way is
chosen.
int_type overflow(int_type c = traits::eof()) override;
5 Effects: Appends the character designated byc to the output sequence, if possible, in one of two ways:
—(5.1) If traits::eq_int_type(c, traits::eof()) returns false and if either the output sequence
has a write position available or the function makes a write position available (as described below),
the function callssputc(c).
Signals success by returningc.
—(5.2) If traits::eq_int_type(c, traits::eof()) returns true, there is no character to append.
Signals success by returning a value other thantraits::eof().
6 Returns: As specified above, ortraits::eof() to indicate failure.
7 Remarks: The function can alter the number of write positions available as a result of any call.
8 The function can make a write position available only ifios_base::out is set inmode . To make a
write position available, the function reallocates (or initially allocates) an array object with a sufficient
number of elements to hold the current array object (if any), plus at least one additional write position.
If ios_base::in is set inmode , the function alters the read end pointeregptr() to point just past
the new write position.
pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which
= ios_base::in | ios_base::out) override;
9 Effects: Alters the stream position within one of the controlled sequences, if possible, as indicated in
Table 144.
Table 144 —seekoff positioning [tab:stringbuf.seekoff.pos]
Conditions Result
ios_base::in is set inwhich positions the input sequence
ios_base::out is set inwhich positions the output sequence
both ios_base::in and ios_base::out
are set inwhich and either
way == ios_base::beg or
way == ios_base::end
positions both the input and the output sequences
Otherwise the positioning operation fails.
10 For a sequence to be positioned, the function determinesnewoff as indicated in Table 145. If the
sequence’s next pointer (eithergptr()orpptr()) is a null pointer andnewoffis nonzero, the positioning
operation fails.
§ 31.8.2.5 © ISO/IEC
2066

===== PAGE 2078 =====

Dxxxx
Table 145 —newoff values [tab:stringbuf.seekoff.newoff]
Condition newoff Value
way == ios_base::beg 0
way == ios_base::cur the next pointer minus the begin-
ning pointer (xnext - xbeg).
way == ios_base::end the high mark pointer minus the
beginning pointer (high_mark -
xbeg).
11 If (newoff + off) < 0, or ifnewoff + off refers to an uninitialized character (31.8.2.4), the posi-
tioning operation fails. Otherwise, the function assignsxbeg + newoff + off to the next pointer
xnext.
12 Returns: pos_type(newoff), constructed from the resultant offsetnewoff (of typeoff_type), that
stores the resultant stream position, if possible. If the positioning operation fails, or if the constructed
object cannot represent the resultant stream position, the return value ispos_type(off_type(-1)).
pos_type seekpos(pos_type sp,
ios_base::openmode which
= ios_base::in | ios_base::out) override;
13 Effects: Equivalent toseekoff(off_type(sp), ios_base::beg, which).
14 Returns: sp to indicate success, orpos_type(off_type(-1)) to indicate failure.
basic_streambuf<charT, traits>* setbuf(charT* s, streamsize n) override;
15 Effects: implementation-defined, except thatsetbuf(0, 0) has no effect.
16 Returns: this.
31.8.3 Class template basic_istringstream [istringstream]
31.8.3.1 General [istringstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_istringstream : public basic_istream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using allocator_type = Allocator;
// 31.8.3.2, constructors
basic_istringstream() : basic_istringstream(ios_base::in) {}
explicit basic_istringstream(ios_base::openmode which);
explicit basic_istringstream(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::in);
basic_istringstream(ios_base::openmode which, const Allocator& a);
explicit basic_istringstream(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::in);
template<class SAlloc>
basic_istringstream(
const basic_string<charT, traits, SAlloc>& s, const Allocator& a)
: basic_istringstream(s, ios_base::in, a) {}
template<class SAlloc>
basic_istringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
§ 31.8.3.1 © ISO/IEC
2067

===== PAGE 2079 =====

Dxxxx
template<class SAlloc>
explicit basic_istringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::in);
template<class T>
explicit basic_istringstream(const T& t, ios_base::openmode which = ios_base::in);
template<class T>
basic_istringstream(const T& t, const Allocator& a);
template<class T>
basic_istringstream(const T& t, ios_base::openmode which, const Allocator& a);
basic_istringstream(const basic_istringstream&) = delete;
basic_istringstream(basic_istringstream&& rhs);
basic_istringstream& operator=(const basic_istringstream&) = delete;
basic_istringstream& operator=(basic_istringstream&& rhs);
// 31.8.3.3, swap
void swap(basic_istringstream& rhs);
// 31.8.3.4, members
basic_stringbuf<charT, traits, Allocator>* rdbuf() const;
basic_string<charT, traits, Allocator> str() const &;
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
basic_string<charT, traits, Allocator> str() &&;
basic_string_view<charT, traits> view() const noexcept;
void str(const basic_string<charT, traits, Allocator>& s);
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
void str(basic_string<charT, traits, Allocator>&& s);
template<class T>
void str(const T& t);
private:
basic_stringbuf<charT, traits, Allocator> sb ; // exposition only
};
}
1 The classbasic_istringstream<charT, traits, Allocator> supports reading objects of classbasic_-
string<charT, traits, Allocator>. It uses abasic_stringbuf<charT, traits, Allocator> object to
control the associated storage. For the sake of exposition, the maintained data is presented here as:
—(1.1) sb , thestringbuf object.
31.8.3.2 Constructors [istringstream.cons]
explicit basic_istringstream(ios_base::openmode which);
1 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2)
and sb with basic_stringbuf<charT, traits, Allocator>(which | ios_base::in) (31.8.2.2).
explicit basic_istringstream(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::in);
2 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::in)
(31.8.2.2).
basic_istringstream(ios_base::openmode which, const Allocator& a);
3 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2)
andsb withbasic_stringbuf<charT, traits, Allocator>(which | ios_base::in, a)(31.8.2.2).
§ 31.8.3.2 © ISO/IEC
2068

===== PAGE 2080 =====

Dxxxx
explicit basic_istringstream(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::in);
4 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2)
and sb with basic_stringbuf<charT, traits, Allocator>(std::move(s), which | ios_base::
in) (31.8.2.2).
template<class SAlloc>
basic_istringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
5 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::in, a)
(31.8.2.2).
template<class SAlloc>
explicit basic_istringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::in);
6 Constraints: is_same_v<SAlloc, Allocator> is false.
7 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2)
andsb withbasic_stringbuf<charT, traits, Allocator>(s, which | ios_base::in)(31.8.2.2).
template<class T>
explicit basic_istringstream(const T& t, ios_base::openmode which = ios_base::in);
template<class T>
basic_istringstream(const T& t, const Allocator& a);
template<class T>
basic_istringstream(const T& t, ios_base::openmode which, const Allocator& a);
8 Let which be ios_base::in for the overload with no parameterwhich, anda be Allocator() for the
overload with no parametera.
9 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
10 Effects: Initializes the base class withaddressof(sb ), and direct-non-list-initializessb with t, which
| ios_base::in, a.
basic_istringstream(basic_istringstream&& rhs);
11 Effects: Move constructs from the rvalue rhs. This is accomplished by move constructing the
base class, and the containedbasic_stringbuf. Then callsbasic_istream<charT, traits>::set_-
rdbuf(addressof(sb )) to install the containedbasic_stringbuf.
31.8.3.3 Swap [istringstream.swap]
void swap(basic_istringstream& rhs);
1 Effects: Equivalent to:
basic_istream<charT, traits>::swap(rhs);
sb .swap(rhs.sb );
template<class charT, class traits, class Allocator>
void swap(basic_istringstream<charT, traits, Allocator>& x,
basic_istringstream<charT, traits, Allocator>& y);
2 Effects: Equivalent tox.swap(y).
31.8.3.4 Member functions [istringstream.members]
basic_stringbuf<charT, traits, Allocator>* rdbuf() const;
1 Returns: const_cast<basic_stringbuf<charT, traits, Allocator>*>(addressof(sb )).
basic_string<charT, traits, Allocator> str() const &;
2 Effects: Equivalent to:return rdbuf()->str();
§ 31.8.3.4 © ISO/IEC
2069

===== PAGE 2081 =====

Dxxxx
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
3 Effects: Equivalent to:return rdbuf()->str(sa);
basic_string<charT,traits,Allocator> str() &&;
4 Effects: Equivalent to:return std::move(*rdbuf()).str();
basic_string_view<charT, traits> view() const noexcept;
5 Effects: Equivalent to:return rdbuf()->view();
void str(const basic_string<charT, traits, Allocator>& s);
6 Effects: Equivalent to:rdbuf()->str(s);
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
7 Effects: Equivalent to:rdbuf()->str(s);
void str(basic_string<charT, traits, Allocator>&& s);
8 Effects: Equivalent to:rdbuf()->str(std::move(s));
template<class T>
void str(const T& t);
9 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
10 Effects: Equivalent to:rdbuf()->str(t);
31.8.4 Class template basic_ostringstream [ostringstream]
31.8.4.1 General [ostringstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_ostringstream : public basic_ostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using allocator_type = Allocator;
// 31.8.4.2, constructors
basic_ostringstream() : basic_ostringstream(ios_base::out) {}
explicit basic_ostringstream(ios_base::openmode which);
explicit basic_ostringstream(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::out);
basic_ostringstream(ios_base::openmode which, const Allocator& a);
explicit basic_ostringstream(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::out);
template<class SAlloc>
basic_ostringstream(
const basic_string<charT, traits, SAlloc>& s, const Allocator& a)
: basic_ostringstream(s, ios_base::out, a) {}
template<class SAlloc>
basic_ostringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
template<class SAlloc>
explicit basic_ostringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::out);
§ 31.8.4.1 © ISO/IEC
2070

===== PAGE 2082 =====

Dxxxx
template<class T>
explicit basic_ostringstream(const T& t, ios_base::openmode which = ios_base::out);
template<class T>
basic_ostringstream(const T& t, const Allocator& a);
template<class T>
basic_ostringstream(const T& t, ios_base::openmode which, const Allocator& a);
basic_ostringstream(const basic_ostringstream&) = delete;
basic_ostringstream(basic_ostringstream&& rhs);
basic_ostringstream& operator=(const basic_ostringstream&) = delete;
basic_ostringstream& operator=(basic_ostringstream&& rhs);
// 31.8.4.3, swap
void swap(basic_ostringstream& rhs);
// 31.8.4.4, members
basic_stringbuf<charT, traits, Allocator>* rdbuf() const;
basic_string<charT, traits, Allocator> str() const &;
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
basic_string<charT, traits, Allocator> str() &&;
basic_string_view<charT, traits> view() const noexcept;
void str(const basic_string<charT, traits, Allocator>& s);
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
void str(basic_string<charT, traits, Allocator>&& s);
template<class T>
void str(const T& t);
private:
basic_stringbuf<charT, traits, Allocator> sb ; // exposition only
};
}
1 The classbasic_ostringstream<charT, traits, Allocator> supports writing objects of classbasic_-
string<charT, traits, Allocator>. It uses abasic_stringbuf object to control the associated storage.
For the sake of exposition, the maintained data is presented here as:
—(1.1) sb , thestringbuf object.
31.8.4.2 Constructors [ostringstream.cons]
explicit basic_ostringstream(ios_base::openmode which);
1 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2)
and sb with basic_stringbuf<charT, traits, Allocator>(which | ios_base::out) (31.8.2.2).
explicit basic_ostringstream(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::out);
2 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::out)
(31.8.2.2).
basic_ostringstream(ios_base::openmode which, const Allocator& a);
3 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2)
and sb with basic_stringbuf<charT, traits, Allocator>(which | ios_base::out, a)
(31.8.2.2).
§ 31.8.4.2 © ISO/IEC
2071

===== PAGE 2083 =====

Dxxxx
explicit basic_ostringstream(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::out);
4 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2)
and sb with basic_stringbuf<charT, traits, Allocator>(std::move(s), which | ios_base::
out) (31.8.2.2).
template<class SAlloc>
basic_ostringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
5 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::out, a)
(31.8.2.2).
template<class SAlloc>
explicit basic_ostringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::out);
6 Constraints: is_same_v<SAlloc, Allocator> is false.
7 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::out)
(31.8.2.2).
template<class T>
explicit basic_ostringstream(const T& t, ios_base::openmode which = ios_base::out);
template<class T>
basic_ostringstream(const T& t, const Allocator& a);
template<class T>
basic_ostringstream(const T& t, ios_base::openmode which, const Allocator& a);
8 Let which be ios_base::out for the overload with no parameterwhich, anda be Allocator() for
the overload with no parametera.
9 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
10 Effects: Initializes the base class withaddressof(sb ), and direct-non-list-initializessb with t, which
| ios_base::out, a.
basic_ostringstream(basic_ostringstream&& rhs);
11 Effects: Move constructs from the rvalue rhs. This is accomplished by move constructing the
base class, and the containedbasic_stringbuf. Then callsbasic_ostream<charT, traits>::set_-
rdbuf(addressof(sb )) to install the containedbasic_stringbuf.
31.8.4.3 Swap [ostringstream.swap]
void swap(basic_ostringstream& rhs);
1 Effects: Equivalent to:
basic_ostream<charT, traits>::swap(rhs);
sb .swap(rhs.sb );
template<class charT, class traits, class Allocator>
void swap(basic_ostringstream<charT, traits, Allocator>& x,
basic_ostringstream<charT, traits, Allocator>& y);
2 Effects: Equivalent tox.swap(y).
31.8.4.4 Member functions [ostringstream.members]
basic_stringbuf<charT, traits, Allocator>* rdbuf() const;
1 Returns: const_cast<basic_stringbuf<charT, traits, Allocator>*>(addressof(sb )).
§ 31.8.4.4 © ISO/IEC
2072

===== PAGE 2084 =====

Dxxxx
basic_string<charT, traits, Allocator> str() const &;
2 Effects: Equivalent to:return rdbuf()->str();
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
3 Effects: Equivalent to:return rdbuf()->str(sa);
basic_string<charT,traits,Allocator> str() &&;
4 Effects: Equivalent to:return std::move(*rdbuf()).str();
basic_string_view<charT, traits> view() const noexcept;
5 Effects: Equivalent to:return rdbuf()->view();
void str(const basic_string<charT, traits, Allocator>& s);
6 Effects: Equivalent to:rdbuf()->str(s);
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
7 Effects: Equivalent to:rdbuf()->str(s);
void str(basic_string<charT, traits, Allocator>&& s);
8 Effects: Equivalent to:rdbuf()->str(std::move(s));
template<class T>
void str(const T& t);
9 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
10 Effects: Equivalent to:rdbuf()->str(t);
31.8.5 Class template basic_stringstream [stringstream]
31.8.5.1 General [stringstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_stringstream : public basic_iostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using allocator_type = Allocator;
// 31.8.5.2, constructors
basic_stringstream() : basic_stringstream(ios_base::out | ios_base::in) {}
explicit basic_stringstream(ios_base::openmode which);
explicit basic_stringstream(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::out | ios_base::in);
basic_stringstream(ios_base::openmode which, const Allocator& a);
explicit basic_stringstream(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::out | ios_base::in);
template<class SAlloc>
basic_stringstream(
const basic_string<charT, traits, SAlloc>& s, const Allocator& a)
: basic_stringstream(s, ios_base::out | ios_base::in, a) {}
template<class SAlloc>
basic_stringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
§ 31.8.5.1 © ISO/IEC
2073

===== PAGE 2085 =====

Dxxxx
template<class SAlloc>
explicit basic_stringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::out | ios_base::in);
template<class T>
explicit basic_stringstream(const T& t,
ios_base::openmode which = ios_base::out | ios_base::in);
template<class T>
basic_stringstream(const T& t, const Allocator& a);
template<class T>
basic_stringstream(const T& t, ios_base::openmode which, const Allocator& a);
basic_stringstream(const basic_stringstream&) = delete;
basic_stringstream(basic_stringstream&& rhs);
basic_stringstream& operator=(const basic_stringstream&) = delete;
basic_stringstream& operator=(basic_stringstream&& rhs);
// 31.8.5.3, swap
void swap(basic_stringstream& rhs);
// 31.8.5.4, members
basic_stringbuf<charT, traits, Allocator>* rdbuf() const;
basic_string<charT, traits, Allocator> str() const &;
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
basic_string<charT, traits, Allocator> str() &&;
basic_string_view<charT, traits> view() const noexcept;
void str(const basic_string<charT, traits, Allocator>& s);
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
void str(basic_string<charT, traits, Allocator>&& s);
template<class T>
void str(const T& t);
private:
basic_stringbuf<charT, traits, Allocator> sb ; // exposition only
};
}
1 The class templatebasic_stringstream<charT, traits> supports reading and writing from objects of
class basic_string<charT, traits, Allocator>. It uses abasic_stringbuf<charT, traits, Alloca-
tor> object to control the associated sequence. For the sake of exposition, the maintained data is presented
here as
—(1.1) sb , thestringbuf object.
31.8.5.2 Constructors [stringstream.cons]
explicit basic_stringstream(ios_base::openmode which);
1 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_stringbuf<charT, traits, Allocator>(which).
explicit basic_stringstream(
const basic_string<charT, traits, Allocator>& s,
ios_base::openmode which = ios_base::out | ios_base::in);
2 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which).
basic_stringstream(ios_base::openmode which, const Allocator& a);
3 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_stringbuf<charT, traits, Allocator>(which, a) (31.8.2.2).
§ 31.8.5.2 © ISO/IEC
2074

===== PAGE 2086 =====

Dxxxx
explicit basic_stringstream(
basic_string<charT, traits, Allocator>&& s,
ios_base::openmode which = ios_base::out | ios_base::in);
4 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_stringbuf<charT, traits, Allocator>(std::move(s), which) (31.8.2.2).
template<class SAlloc>
basic_stringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which, const Allocator& a);
5 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which, a) (31.8.2.2).
template<class SAlloc>
explicit basic_stringstream(
const basic_string<charT, traits, SAlloc>& s,
ios_base::openmode which = ios_base::out | ios_base::in);
6 Constraints: is_same_v<SAlloc, Allocator> is false.
7 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_stringbuf<charT, traits, Allocator>(s, which) (31.8.2.2).
template<class T>
explicit basic_stringstream(const T& t, ios_base::openmode which = ios_base::out | ios_base::in);
template<class T>
basic_stringstream(const T& t, const Allocator& a);
template<class T>
basic_stringstream(const T& t, ios_base::openmode which, const Allocator& a);
8 Let which be ios_base::out | ios_base::in for the overload with no parameterwhich, anda be
Allocator() for the overload with no parametera.
9 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
10 Effects: Initializes the base class withaddressof(sb ), and direct-non-list-initializessb with t, which,
a.
basic_stringstream(basic_stringstream&& rhs);
11 Effects: Move constructs from the rvalue rhs. This is accomplished by move constructing the
base class, and the containedbasic_stringbuf. Then callsbasic_istream<charT, traits>::set_-
rdbuf(addressof(sb )) to install the containedbasic_stringbuf.
31.8.5.3 Swap [stringstream.swap]
void swap(basic_stringstream& rhs);
1 Effects: Equivalent to:
basic_iostream<charT,traits>::swap(rhs);
sb .swap(rhs.sb );
template<class charT, class traits, class Allocator>
void swap(basic_stringstream<charT, traits, Allocator>& x,
basic_stringstream<charT, traits, Allocator>& y);
2 Effects: Equivalent tox.swap(y).
31.8.5.4 Member functions [stringstream.members]
basic_stringbuf<charT, traits, Allocator>* rdbuf() const;
1 Returns: const_cast<basic_stringbuf<charT, traits, Allocator>*>(addressof(sb )).
basic_string<charT, traits, Allocator> str() const &;
2 Effects: Equivalent to:return rdbuf()->str();
§ 31.8.5.4 © ISO/IEC
2075

===== PAGE 2087 =====

Dxxxx
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
3 Effects: Equivalent to:return rdbuf()->str(sa);
basic_string<charT,traits,Allocator> str() &&;
4 Effects: Equivalent to:return std::move(*rdbuf()).str();
basic_string_view<charT, traits> view() const noexcept;
5 Effects: Equivalent to:return rdbuf()->view();
void str(const basic_string<charT, traits, Allocator>& s);
6 Effects: Equivalent to:rdbuf()->str(s);
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
7 Effects: Equivalent to:rdbuf()->str(s);
void str(basic_string<charT, traits, Allocator>&& s);
8 Effects: Equivalent to:rdbuf()->str(std::move(s));
template<class T>
void str(const T& t);
9 Constraints: is_convertible_v<const T&, basic_string_view<charT, traits>> is true.
10 Effects: Equivalent to:rdbuf()->str(t);
31.9 Span-based streams [span.streams]
31.9.1 Overview [span.streams.overview]
1 The header<spanstream> defines class templates and types that associate stream buffers with objects whose
types are specializations ofspan as described in 23.7.2.2.
[Note 1: A user of these classes is responsible for ensuring that the character sequence represented by the givenspan
outlives the use of the sequence by objects of the classes in 31.9. Using multiplebasic_spanbuf objects referring to
overlapping underlying sequences from different threads, where at least onebasic_spanbuf object is used for writing
to the sequence, results in a data race.—end note]
31.9.2 Header <spanstream> synopsis [spanstream.syn]
namespace std {
// 31.9.3, class templatebasic_spanbuf
template<class charT, class traits = char_traits<charT>>
class basic_spanbuf;
template<class charT, class traits>
void swap(basic_spanbuf<charT, traits>& x, basic_spanbuf<charT, traits>& y);
using spanbuf = basic_spanbuf<char>;
using wspanbuf = basic_spanbuf<wchar_t>;
// 31.9.4, class templatebasic_ispanstream
template<class charT, class traits = char_traits<charT>>
class basic_ispanstream;
template<class charT, class traits>
void swap(basic_ispanstream<charT, traits>& x, basic_ispanstream<charT, traits>& y);
using ispanstream = basic_ispanstream<char>;
using wispanstream = basic_ispanstream<wchar_t>;
// 31.9.5, class templatebasic_ospanstream
template<class charT, class traits = char_traits<charT>>
class basic_ospanstream;
§ 31.9.2 © ISO/IEC
2076

===== PAGE 2088 =====

Dxxxx
template<class charT, class traits>
void swap(basic_ospanstream<charT, traits>& x, basic_ospanstream<charT, traits>& y);
using ospanstream = basic_ospanstream<char>;
using wospanstream = basic_ospanstream<wchar_t>;
// 31.9.6, class templatebasic_spanstream
template<class charT, class traits = char_traits<charT>>
class basic_spanstream;
template<class charT, class traits>
void swap(basic_spanstream<charT, traits>& x, basic_spanstream<charT, traits>& y);
using spanstream = basic_spanstream<char>;
using wspanstream = basic_spanstream<wchar_t>;
}
31.9.3 Class template basic_spanbuf [spanbuf]
31.9.3.1 General [spanbuf.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_spanbuf
: public basic_streambuf<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.9.3.2, constructors
basic_spanbuf() : basic_spanbuf(ios_base::in | ios_base::out) {}
explicit basic_spanbuf(ios_base::openmode which)
: basic_spanbuf(std::span<charT>(), which) {}
explicit basic_spanbuf(std::span<charT> s,
ios_base::openmode which = ios_base::in | ios_base::out);
basic_spanbuf(const basic_spanbuf&) = delete;
basic_spanbuf(basic_spanbuf&& rhs);
// 31.9.3.3, assignment and swap
basic_spanbuf& operator=(const basic_spanbuf&) = delete;
basic_spanbuf& operator=(basic_spanbuf&& rhs);
void swap(basic_spanbuf& rhs);
// 31.9.3.4, member functions
std::span<charT> span() const noexcept;
void span(std::span<charT> s) noexcept;
protected:
// 31.9.3.5, overridden virtual functions
basic_streambuf<charT, traits>* setbuf(charT*, streamsize) override;
pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which = ios_base::in | ios_base::out) override;
pos_type seekpos(pos_type sp,
ios_base::openmode which = ios_base::in | ios_base::out) override;
private:
ios_base::openmode mode ; // exposition only
std::span<charT> buf ; // exposition only
};
}
§ 31.9.3.1 © ISO/IEC
2077

===== PAGE 2089 =====

Dxxxx
1 The class templatebasic_spanbuf is derived frombasic_streambuf to associate possibly the input sequence
and possibly the output sequence with a sequence of arbitrary characters. The sequence is provided by an
object of classspan<charT>.
2 For the sake of exposition, the maintained data is presented here as:
—(2.1) ios_base::openmode mode , hasin set if the input sequence can be read, andout set if the output
sequence can be written.
—(2.2) std::span<charT> buf is the view to the underlying character sequence.
31.9.3.2 Constructors [spanbuf.cons]
explicit basic_spanbuf(std::span<charT> s,
ios_base::openmode which = ios_base::in | ios_base::out);
1 Effects: Initializes the base class withbasic_streambuf() (31.6.3.2), andmode with which. Initializes
the internal pointers as if callingspan(s).
basic_spanbuf(basic_spanbuf&& rhs);
2 Effects: Initializes the base class withstd::move(rhs) and mode with std::move(rhs.mode ) and buf
with std::move(rhs.buf ). The sequence pointers in*this (eback(), gptr(), egptr(), pbase(),
pptr(), epptr()) obtain the values whichrhs had. It is implementation-defined whetherrhs.buf .
empty() returns true after the move.
3 Postconditions: Let rhs_p refer to the state ofrhs just prior to this construction.
—(3.1) span().data() == rhs_p.span().data()
—(3.2) span().size() == rhs_p.span().size()
—(3.3) eback() == rhs_p.eback()
—(3.4) gptr() == rhs_p.gptr()
—(3.5) egptr() == rhs_p.egptr()
—(3.6) pbase() == rhs_p.pbase()
—(3.7) pptr() == rhs_p.pptr()
—(3.8) epptr() == rhs_p.epptr()
—(3.9) getloc() == rhs_p.getloc()
31.9.3.3 Assignment and swap [spanbuf.assign]
basic_spanbuf& operator=(basic_spanbuf&& rhs);
1 Effects: Equivalent to:
basic_spanbuf tmp{std::move(rhs)};
this->swap(tmp);
return *this;
void swap(basic_spanbuf& rhs);
2 Effects: Equivalent to:
basic_streambuf<charT, traits>::swap(rhs);
std::swap(mode , rhs.mode );
std::swap(buf , rhs.buf );
template<class charT, class traits>
void swap(basic_spanbuf<charT, traits>& x, basic_spanbuf<charT, traits>& y);
3 Effects: Equivalent tox.swap(y).
31.9.3.4 Member functions [spanbuf.members]
std::span<charT> span() const noexcept;
1 Returns: If ios_base::out is set inmode , returnsstd::span<charT>(pbase(), pptr()), otherwise
returns buf .
§ 31.9.3.4 © ISO/IEC
2078

===== PAGE 2090 =====

Dxxxx
[Note 1: In contrast tobasic_stringbuf, the underlying sequence never grows and is not owned. An owning
copy can be obtained by converting the result tobasic_string<charT>. —end note]
void span(std::span<charT> s) noexcept;
2 Effects: buf = s. Initializes the input and output sequences according tomode .
3 Postconditions:
—(3.1) If ios_base::out is set inmode , pbase() == s.data() && epptr() == pbase() + s.size()
is true;
—(3.1.1) in addition, ifios_base::ate is set inmode , pptr() == pbase() + s.size() is true,
—(3.1.2) otherwise pptr() == pbase() is true.
—(3.2) If ios_base::inis set inmode , eback() == s.data() && gptr() == eback() && egptr() ==
eback() + s.size() is true.
31.9.3.5 Overridden virtual functions [spanbuf.virtuals]
1 [Note 1: Because the underlying buffer is of fixed size, neitheroverflow, underflow, nor pbackfail can provide
useful behavior. —end note]
pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which = ios_base::in | ios_base::out) override;
2 Effects: Alters the stream position within one or both of the controlled sequences, if possible, as follows:
—(2.1) If ios_base::in is set inwhich, positions the input sequence;xnext is gptr(), xbeg is eback().
—(2.2) If ios_base::out is set in which, positions the output sequence; xnext is pptr(), xbeg is
pbase().
3 If bothios_base::in and ios_base::out are set inwhich and way is ios_base::cur, the positioning
operation fails.
4 For a sequence to be positioned, if its next pointerxnext (either gptr() or pptr()) is a null pointer
and the new offsetnewoff as computed below is nonzero, the positioning operation fails. Otherwise,
the function determinesbaseoff as a value of typeoff_type as follows:
—(4.1) 0 when way is ios_base::beg;
—(4.2) (pptr() - pbase()) for the output sequence, or(gptr() - eback()) for the input sequence
when way is ios_base::cur;
—(4.3) when way is ios_base::end :
—(4.3.1) (pptr() - pbase()) if ios_base::out is set inmode and ios_base::in is not set inmode ,
—(4.3.2) buf .size() otherwise.
5 If baseoff+ off would overflow, or ifbaseoff+ off is less than zero, or ifbaseoff+ off is greater
than buf .size(), the positioning operation fails. Otherwise, the function computes
off_type newoff = baseoff + off;
and assignsxbeg + newoff to the next pointerxnext.
6 Returns: pos_type(off_type(-1)) if the positioning operation fails;pos_type(newoff) otherwise.
pos_type seekpos(pos_type sp, ios_base::openmode which = ios_base::in | ios_base::out) override;
7 Effects: Equivalent to:
return seekoff(off_type(sp), ios_base::beg, which);
basic_streambuf<charT, traits>* setbuf(charT* s, streamsize n) override;
8 Effects: Equivalent to:
this->span(std::span<charT>(s, n));
return this;
31.9.4 Class template basic_ispanstream [ispanstream]
31.9.4.1 General [ispanstream.general]
namespace std {
§ 31.9.4.1 © ISO/IEC
2079

===== PAGE 2091 =====

Dxxxx
template<class charT, class traits = char_traits<charT>>
class basic_ispanstream
: public basic_istream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.9.4.2, constructors
explicit basic_ispanstream(std::span<charT> s,
ios_base::openmode which = ios_base::in);
basic_ispanstream(const basic_ispanstream&) = delete;
basic_ispanstream(basic_ispanstream&& rhs);
template<class ROS> explicit basic_ispanstream(ROS&& s);
basic_ispanstream& operator=(const basic_ispanstream&) = delete;
basic_ispanstream& operator=(basic_ispanstream&& rhs);
// 31.9.4.3, swap
void swap(basic_ispanstream& rhs);
// 31.9.4.4, member functions
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
std::span<const charT> span() const noexcept;
void span(std::span<charT> s) noexcept;
template<class ROS> void span(ROS&& s) noexcept;
private:
basic_spanbuf<charT, traits> sb ; // exposition only
};
}
1 [Note 1: Constructing anispanstream from astring-literal includes the termination character’\0’ in the underlying
spanbuf. —end note]
31.9.4.2 Constructors [ispanstream.cons]
explicit basic_ispanstream(std::span<charT> s, ios_base::openmode which = ios_base::in);
1 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) and sb with
basic_spanbuf<charT, traits>(s, which | ios_base::in) (31.9.3.2).
basic_ispanstream(basic_ispanstream&& rhs);
2 Effects: Initializes the base class with std::move(rhs) and sb with std::move(rhs.sb ). Next,
basic_istream<charT, traits>::set_rdbuf(addressof(sb )) is called to install the containedba-
sic_spanbuf.
template<class ROS> explicit basic_ispanstream(ROS&& s)
3 Constraints: ROSmodels ranges::borrowed_range. !convertible_to<ROS, std::span<charT>> &&
convertible_to<ROS, std::span<charT const>> is true.
4 Effects: Let sp be std::span<const charT>(std::forward<ROS>(s)). Equivalent to:
basic_ispanstream(std::span<charT>(const_cast<charT*>(sp.data()), sp.size()))
31.9.4.3 Swap [ispanstream.swap]
void swap(basic_ispanstream& rhs);
1 Effects: Equivalent to:
basic_istream<charT, traits>::swap(rhs);
sb .swap(rhs.sb );
§ 31.9.4.3 © ISO/IEC
2080

===== PAGE 2092 =====

Dxxxx
template<class charT, class traits>
void swap(basic_ispanstream<charT, traits>& x, basic_ispanstream<charT, traits>& y);
2 Effects: Equivalent tox.swap(y).
31.9.4.4 Member functions [ispanstream.members]
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
1 Effects: Equivalent to:
return const_cast<basic_spanbuf<charT, traits>*>(addressof(sb ));
std::span<const charT> span() const noexcept;
2 Effects: Equivalent to:return rdbuf()->span();
void span(std::span<charT> s) noexcept;
3 Effects: Equivalent tordbuf()->span(s).
template<class ROS> void span(ROS&& s) noexcept;
4 Constraints: ROS models ranges::borrowed_range. (!convertible_to<ROS, std::span<charT>>)
&& convertible_to<ROS, std::span<const charT>> is true.
5 Effects: Let sp be std::span<const charT>(std::forward<ROS>(s)). Equivalent to:
this->span(std::span<charT>(const_cast<charT*>(sp.data()), sp.size()));
31.9.5 Class template basic_ospanstream [ospanstream]
31.9.5.1 General [ospanstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_ospanstream
: public basic_ostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.9.5.2, constructors
explicit basic_ospanstream(std::span<charT> s,
ios_base::openmode which = ios_base::out);
basic_ospanstream(const basic_ospanstream&) = delete;
basic_ospanstream(basic_ospanstream&& rhs);
basic_ospanstream& operator=(const basic_ospanstream&) = delete;
basic_ospanstream& operator=(basic_ospanstream&& rhs);
// 31.9.5.3, swap
void swap(basic_ospanstream& rhs);
// 31.9.5.4, member functions
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
std::span<charT> span() const noexcept;
void span(std::span<charT> s) noexcept;
private:
basic_spanbuf<charT, traits> sb ; // exposition only
};
}
§ 31.9.5.1 © ISO/IEC
2081

===== PAGE 2093 =====

Dxxxx
31.9.5.2 Constructors [ospanstream.cons]
explicit basic_ospanstream(std::span<charT> s,
ios_base::openmode which = ios_base::out);
1 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) and sb with
basic_spanbuf<charT, traits>(s, which | ios_base::out) (31.9.3.2).
basic_ospanstream(basic_ospanstream&& rhs) noexcept;
2 Effects: Initializes the base class with std::move(rhs) and sb with std::move(rhs.sb ). Next,
basic_ostream<charT, traits>::set_rdbuf(addressof(sb )) is called to install the containedba-
sic_spanbuf.
31.9.5.3 Swap [ospanstream.swap]
void swap(basic_ospanstream& rhs);
1 Effects: Equivalent to:
basic_ostream<charT, traits>::swap(rhs);
sb .swap(rhs.sb );
template<class charT, class traits>
void swap(basic_ospanstream<charT, traits>& x, basic_ospanstream<charT, traits>& y);
2 Effects: Equivalent tox.swap(y).
31.9.5.4 Member functions [ospanstream.members]
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
1 Effects: Equivalent to:
return const_cast<basic_spanbuf<charT, traits>*>(addressof(sb ));
std::span<charT> span() const noexcept;
2 Effects: Equivalent to:return rdbuf()->span();
void span(std::span<charT> s) noexcept;
3 Effects: Equivalent tordbuf()->span(s).
31.9.6 Class template basic_spanstream [spanstream]
31.9.6.1 General [spanstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_spanstream
: public basic_iostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
// 31.9.6.2, constructors
explicit basic_spanstream(std::span<charT> s,
ios_base::openmode which = ios_base::out | ios_base::in);
basic_spanstream(const basic_spanstream&) = delete;
basic_spanstream(basic_spanstream&& rhs);
basic_spanstream& operator=(const basic_spanstream&) = delete;
basic_spanstream& operator=(basic_spanstream&& rhs);
// 31.9.6.3, swap
void swap(basic_spanstream& rhs);
§ 31.9.6.1 © ISO/IEC
2082

===== PAGE 2094 =====

Dxxxx
// 31.9.6.4, members
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
std::span<charT> span() const noexcept;
void span(std::span<charT> s) noexcept;
private:
basic_spanbuf<charT, traits> sb ; // exposition only
};
}
31.9.6.2 Constructors [spanstream.cons]
explicit basic_spanstream(std::span<charT> s,
ios_base::openmode which = ios_base::out | ios_bas::in);
1 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) and sb
with basic_spanbuf<charT, traits>(s, which) (31.9.3.2).
basic_spanstream(basic_spanstream&& rhs);
2 Effects: Initializes the base class with std::move(rhs) and sb with std::move(rhs.sb ). Next,
basic_iostream<charT, traits>::set_rdbuf(addressof(sb )) is called to install the contained
basic_spanbuf.
31.9.6.3 Swap [spanstream.swap]
void swap(basic_spanstream& rhs);
1 Effects: Equivalent to:
basic_iostream<charT, traits>::swap(rhs);
sb .swap(rhs.sb );
template<class charT, class traits>
void swap(basic_spanstream<charT, traits>& x, basic_spanstream<charT, traits>& y);
2 Effects: Equivalent tox.swap(y).
31.9.6.4 Member functions [spanstream.members]
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
1 Effects: Equivalent to:
return const_cast<basic_spanbuf<charT, traits>*>(addressof(sb ));
std::span<charT> span() const noexcept;
2 Effects: Equivalent to:return rdbuf()->span();
void span(std::span<charT> s) noexcept;
3 Effects: Equivalent tordbuf()->span(s).
31.10 File-based streams [file.streams]
31.10.1 Header <fstream> synopsis [fstream.syn]
namespace std {
// 31.10.3, class templatebasic_filebuf
template<class charT, class traits = char_traits<charT>>
class basic_filebuf;
template<class charT, class traits>
void swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);
using filebuf = basic_filebuf<char>;
using wfilebuf = basic_filebuf<wchar_t>;
§ 31.10.1 © ISO/IEC
2083

===== PAGE 2095 =====

Dxxxx
// 31.10.4, class templatebasic_ifstream
template<class charT, class traits = char_traits<charT>>
class basic_ifstream;
template<class charT, class traits>
void swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);
using ifstream = basic_ifstream<char>;
using wifstream = basic_ifstream<wchar_t>;
// 31.10.5, class templatebasic_ofstream
template<class charT, class traits = char_traits<charT>>
class basic_ofstream;
template<class charT, class traits>
void swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);
using ofstream = basic_ofstream<char>;
using wofstream = basic_ofstream<wchar_t>;
// 31.10.6, class templatebasic_fstream
template<class charT, class traits = char_traits<charT>>
class basic_fstream;
template<class charT, class traits>
void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);
using fstream = basic_fstream<char>;
using wfstream = basic_fstream<wchar_t>;
}
1 The header<fstream> defines four class templates and eight types that associate stream buffers with files
and assist reading and writing files.
2 [Note 1: The class templatebasic_filebuf treats a file as a source or sink of bytes. In an environment that uses
a large character set, the file typically holds multibyte character sequences and thebasic_filebuf object converts
those multibyte sequences into wide character sequences.—end note]
3 In subclause 31.10, member functions taking arguments ofconst filesystem::path::value_type* are
only provided on systems wherefilesystem::path::value_type (31.12.6) is notchar.
[Note 2: These functions enable classpath support for systems with a wide native path character type, such as
wchar_t. —end note]
31.10.2 Native handles [file.native]
1 Several classes described in 31.10 have a membernative_handle_type.
2 The typenative_handle_type represents a platform-specificnative handle to a file. It is trivially copyable
and modelssemiregular.
[Note 1: For operating systems based on POSIX,native_handle_type is int. For Windows-based operating systems,
native_handle_type is HANDLE. —end note]
31.10.3 Class template basic_filebuf [filebuf]
31.10.3.1 General [filebuf.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_filebuf : public basic_streambuf<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using native_handle_type = implementation-defined ; // see 31.10.2
§ 31.10.3.1 © ISO/IEC
2084

===== PAGE 2096 =====

Dxxxx
// 31.10.3.2, constructors/destructor
basic_filebuf();
basic_filebuf(const basic_filebuf&) = delete;
basic_filebuf(basic_filebuf&& rhs);
virtual ~basic_filebuf();
// 31.10.3.3, assignment and swap
basic_filebuf& operator=(const basic_filebuf&) = delete;
basic_filebuf& operator=(basic_filebuf&& rhs);
void swap(basic_filebuf& rhs);
// 31.10.3.4, members
bool is_open() const;
basic_filebuf* open(const char* s, ios_base::openmode mode);
basic_filebuf* open(const filesystem::path::value_type* s,
ios_base::openmode mode); // wide systems only; see 31.10.1
basic_filebuf* open(const string& s, ios_base::openmode mode);
basic_filebuf* open(const filesystem::path& s, ios_base::openmode mode);
basic_filebuf* close();
native_handle_type native_handle() const noexcept;
protected:
// 31.10.3.5, overridden virtual functions
streamsize showmanyc() override;
int_type underflow() override;
int_type uflow() override;
int_type pbackfail(int_type c = traits::eof()) override;
int_type overflow (int_type c = traits::eof()) override;
basic_streambuf<charT, traits>* setbuf(char_type* s, streamsize n) override;
pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which = ios_base::in | ios_base::out) override;
pos_type seekpos(pos_type sp,
ios_base::openmode which = ios_base::in | ios_base::out) override;
int sync() override;
void imbue(const locale& loc) override;
};
}
1 The classbasic_filebuf<charT, traits> associates both the input sequence and the output sequence with
a file.
2 The restrictions on reading and writing a sequence controlled by an object of classbasic_filebuf<charT,
traits> are the same as for reading and writing with the C standard libraryFILEs.
3 In particular:
—(3.1) If the file is not open for reading the input sequence cannot be read.
—(3.2) If the file is not open for writing the output sequence cannot be written.
—(3.3) A joint file position is maintained for both the input sequence and the output sequence.
4 An instance ofbasic_filebufbehaves as described in 31.10.3 providedtraits::pos_typeis fpos<traits::
state_type>. Otherwise the behavior is undefined.
5 The file associated with abasic_filebuf has an associated value of typenative_handle_type, called the
native handle (31.10.2) of that file. This native handle can be obtained by calling the member function
native_handle.
6 For any openedbasic_filebuf f, the native handle returned byf.native_handle() is invalidated when
f.close() is called, orf is destroyed.
7 In order to support file I/O and multibyte/wide character conversion, conversions are performed using
members of a facet, referred to asa_codecvt in following subclauses, obtained as if by
§ 31.10.3.1 © ISO/IEC
2085

===== PAGE 2097 =====

Dxxxx
const codecvt<charT, char, typename traits::state_type>& a_codecvt =
use_facet<codecvt<charT, char, typename traits::state_type>>(getloc());
31.10.3.2 Constructors [filebuf.cons]
basic_filebuf();
1 Effects: Initializes the base class withbasic_streambuf<charT, traits>() (31.6.3.2).
2 Postconditions: is_open() == false.
basic_filebuf(basic_filebuf&& rhs);
3 Effects: It is implementation-defined whether the sequence pointers in *this (eback(), gptr(),
egptr(), pbase(), pptr(), epptr()) obtain the values whichrhs had. Whether they do or not,*this
and rhs reference separate buffers (if any at all) after the construction. Additionally*this references
the file whichrhs did before the construction, andrhs references no file after the construction. The
openmode, locale and any other state ofrhs is also copied.
4 Postconditions: Let rhs_p refer to the state ofrhs just prior to this construction and letrhs_a refer
to the state ofrhs just after this construction.
—(4.1) is_open() == rhs_p.is_open()
—(4.2) rhs_a.is_open() == false
—(4.3) gptr() - eback() == rhs_p.gptr() - rhs_p.eback()
—(4.4) egptr() - eback() == rhs_p.egptr() - rhs_p.eback()
—(4.5) pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()
—(4.6) epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()
—(4.7) if (eback()) eback() != rhs_a.eback()
—(4.8) if (gptr()) gptr() != rhs_a.gptr()
—(4.9) if (egptr()) egptr() != rhs_a.egptr()
—(4.10) if (pbase()) pbase() != rhs_a.pbase()
—(4.11) if (pptr()) pptr() != rhs_a.pptr()
—(4.12) if (epptr()) epptr() != rhs_a.epptr()
virtual ~basic_filebuf();
5 Effects: Calls close(). If an exception occurs during the destruction of the object, including the call
to close(), the exception is caught but not rethrown (see 16.4.6.14).
31.10.3.3 Assignment and swap [filebuf.assign]
basic_filebuf& operator=(basic_filebuf&& rhs);
1 Effects: Callsclose()then move assigns fromrhs. After the move assignment*thishas the observable
state it would have had if it had been move constructed fromrhs (see 31.10.3.2).
2 Returns: *this.
void swap(basic_filebuf& rhs);
3 Effects: Exchanges the state of*this and rhs.
template<class charT, class traits>
void swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);
4 Effects: Equivalent tox.swap(y).
31.10.3.4 Member functions [filebuf.members]
bool is_open() const;
1 Returns: true if a previous call toopen succeeded (returned a non-null value) and there has been no
intervening call to close.
§ 31.10.3.4 © ISO/IEC
2086

===== PAGE 2098 =====

Dxxxx
basic_filebuf* open(const char* s, ios_base::openmode mode);
basic_filebuf* open(const filesystem::path::value_type* s,
ios_base::openmode mode); // wide systems only; see 31.10.1
2 Preconditions: s points to an NTCTS (3.36).
3 Effects: If is_open() != false, returns a null pointer. Otherwise, initializes thefilebuf as required.
It then opens the file to whichs resolves, if possible, as if by a call tofopen with the second argument
determined frommode & ~ios_base::ate as indicated in Table 146. Ifmode is not some combination
of flags shown in the table then the open fails.
Table 146 — File open modes [tab:filebuf.open.modes]
ios_base flag combination stdio equivalent
binary in out trunc app noreplace
+ "w"
+ + "wx"
+ + "w"
+ + + "wx"
+ + "a"
+ "a"
+ "r"
+ + "r+"
+ + + "w+"
+ + + + "w+x"
+ + + "a+"
+ + "a+"
+ + "wb"
+ + + "wbx"
+ + + "wb"
+ + + + "wbx"
+ + + "ab"
+ + "ab"
+ + "rb"
+ + + "r+b"
+ + + + "w+b"
+ + + + + "w+bx"
+ + + + "a+b"
+ + + "a+b"
4 If the open operation succeeds andios_base::ate is set inmode, positions the file to the end (as if by
calling fseek(file, 0, SEEK_END), wherefile is the pointer returned by callingfopen).284
5 If the repositioning operation fails, callsclose() and returns a null pointer to indicate failure.
6 Returns: this if successful, a null pointer otherwise.
basic_filebuf* open(const string& s, ios_base::openmode mode);
basic_filebuf* open(const filesystem::path& s, ios_base::openmode mode);
7 Returns: open(s.c_str(), mode);
basic_filebuf* close();
8 Effects: If is_open() == false, returns a null pointer. If a put area exists, callsoverflow(traits::
eof()) to flush characters. If the last virtual member function called on*this (between underflow,
overflow, seekoff, and seekpos) was overflow then calls a_codecvt.unshift (possibly several
times) to determine a termination sequence, inserts those characters and callsoverflow(traits::
eof()) again. Finally, regardless of whether any of the preceding calls fails or throws an exception,
284) The macroSEEK_END is defined, and the function signaturesfopen(const char*, const char*) and fseek(FILE*, long,
int) are declared, in<cstdio> (31.13.1).
§ 31.10.3.4 © ISO/IEC
2087

===== PAGE 2099 =====

Dxxxx
the function closes the file (as if by callingfclose(file)). If any of the calls made by the function,
including fclose, fails,close fails by returning a null pointer. If one of these calls throws an exception,
the exception is caught and rethrown after closing the file.
9 Postconditions: is_open() == false.
10 Returns: this on success, a null pointer otherwise.
native_handle_type native_handle() const noexcept;
11 Preconditions: is_open() is true.
12 Returns: The native handle associated with*this.
31.10.3.5 Overridden virtual functions [filebuf.virtuals]
streamsize showmanyc() override;
1 Effects: Behaves the same asbasic_streambuf::showmanyc() (31.6.3.5).
2 Remarks: An implementation may provide an overriding definition for this function signature if it can
determine whether more characters can be read from the input sequence.
int_type underflow() override;
3 Effects: Behaves according to the description ofbasic_streambuf<charT, traits>::underflow(),
with the specialization that a sequence of characters is read from the input sequence as if by reading
from the associated file into an internal buffer (extern_buf) and then as if by doing:
char extern_buf[XSIZE];
const char* extern_end;
charT intern_buf[ISIZE];
charT* intern_end;
codecvt_base::result r =
a_codecvt.in(state, extern_buf, extern_buf+XSIZE, extern_end,
intern_buf, intern_buf+ISIZE, intern_end);
This shall be done in such a way that the class can recover the position (fpos_t) corresponding to each
character betweenintern_buf and intern_end. If the value ofr indicates thata_codecvt.in() ran
out of space inintern_buf, retry with a largerintern_buf.
int_type uflow() override;
4 Effects: Behaves according to the description ofbasic_streambuf<charT, traits>::uflow(), with
the specialization that a sequence of characters is read from the input with the same method as used
by underflow.
int_type pbackfail(int_type c = traits::eof()) override;
5 Effects: Puts back the character designated byc to the input sequence, if possible, in one of three ways:
—(5.1) If traits::eq_int_type(c, traits::eof()) returns false and if the function makes a putback
position available and iftraits::eq(to_char_type(c), gptr()[-1]) returns true, decrements
the next pointer for the input sequence,gptr().
Returns: c.
—(5.2) If traits::eq_int_type(c, traits::eof()) returns false and if the function makes a putback
position available and if the function is permitted to assign to the putback position, decrements
the next pointer for the input sequence, and storesc there.
Returns: c.
—(5.3) If traits::eq_int_type(c, traits::eof()) returns true, and if either the input sequence has
a putback position available or the function makes a putback position available, decrements the
next pointer for the input sequence,gptr().
Returns: traits::not_eof(c).
6 Returns: As specified above, ortraits::eof() to indicate failure.
7 Remarks: If is_open() == false, the function always fails.
8 The function does not put back a character directly to the input sequence.
§ 31.10.3.5 © ISO/IEC
2088

===== PAGE 2100 =====

Dxxxx
9 If the function can succeed in more than one of these ways, it is unspecified which way is chosen. The
function can alter the number of putback positions available as a result of any call.
int_type overflow(int_type c = traits::eof()) override;
10 Effects: Behaves according to the description ofbasic_streambuf<charT, traits>::overflow(c),
except that the behavior of “consuming characters” is performed by first converting as if by:
charT* b = pbase();
charT* p = pptr();
const charT* end;
char xbuf[XSIZE];
char* xbuf_end;
codecvt_base::result r =
a_codecvt.out(state, b, p, end, xbuf, xbuf+XSIZE, xbuf_end);
and then
—(10.1) If r == codecvt_base::error then fail.
—(10.2) If r == codecvt_base::noconv then output characters fromb up to (and not including)p.
—(10.3) If r == codecvt_base::partial then output to the file characters fromxbuf up toxbuf_end,
and repeat using characters fromend to p. If output fails, fail (without repeating).
—(10.4) Otherwise output fromxbuf to xbuf_end, and fail if output fails. At this point ifb != p and b
== end (xbuf isn’t large enough) then increaseXSIZE and repeat from the beginning.
Then establishes an observable checkpoint (4.1.2).
11 Returns: traits::not_eof(c) to indicate success, andtraits::eof() to indicate failure. If is_-
open() == false, the function always fails.
basic_streambuf* setbuf(char_type* s, streamsize n) override;
12 Effects: If setbuf(0, 0) is called on a stream before any I/O has occurred on that stream, the stream
becomes unbuffered. Otherwise the results are implementation-defined. “Unbuffered” means that
pbase() and pptr() always return null and output to the file should appear as soon as possible.
pos_type seekoff(off_type off, ios_base::seekdir way,
ios_base::openmode which
= ios_base::in | ios_base::out) override;
13 Effects: Let width denote a_codecvt.encoding(). If is_open() == false, oroff != 0 && width
<= 0, then the positioning operation fails. Otherwise, ifway != basic_ios::cur or off != 0, and
if the last operation was output, then update the output sequence and write any unshift sequence.
Next, seek to the new position: ifwidth > 0, callfseek(file, width * off, whence), otherwise
call fseek(file, 0, whence).
14 Returns: A newly constructedpos_type object that stores the resultant stream position, if possible. If
the positioning operation fails, or if the object cannot represent the resultant stream position, returns
pos_type(off_type(-1)).
15 Remarks: “The last operation was output” means either the last virtual operation was overflow or
the put buffer is non-empty. “Write any unshift sequence” means, ifwidth is less than zero then
call a_codecvt.unshift(state, xbuf, xbuf+XSIZE, xbuf_end) and output the resulting unshift
sequence. The function determines one of three values for the argumentwhence, of type int, as
indicated in Table 147.
Table 147 —seekoff effects [tab:filebuf.seekoff]
way Value stdio Equivalent
basic_ios::beg SEEK_SET
basic_ios::cur SEEK_CUR
basic_ios::end SEEK_END
§ 31.10.3.5 © ISO/IEC
2089

===== PAGE 2101 =====

Dxxxx
pos_type seekpos(pos_type sp,
ios_base::openmode which
= ios_base::in | ios_base::out) override;
16 Alters the file position, if possible, to correspond to the position stored insp (as described below).
Altering the file position performs as follows:
1. if (om & ios_base::out) != 0, then update the output sequence and write any unshift sequence;
2. set the file position tosp as if by a call tofsetpos;
3. if (om & ios_base::in) != 0, then update the input sequence;
where om is the open mode passed to the last call toopen(). The operation fails ifis_open() returns
false.
17 If sp is an invalid stream position, or if the function positions neither sequence, the positioning operation
fails. If sp has not been obtained by a previous successful call to one of the positioning functions
(seekoff or seekpos) on the same file the effects are undefined.
18 Returns: sp on success. Otherwise returnspos_type(off_type(-1)).
int sync() override;
19 Effects: If a put area exists, callsfilebuf::overflow to write the characters to the file, then flushes
the file as if by callingfflush(file). If a get area exists, the effect is implementation-defined.
void imbue(const locale& loc) override;
20 Preconditions: If the file is not positioned at its beginning and the encoding of the current locale as
determined bya_codecvt.encoding() is state-dependent (28.3.4.2.5.3) then that facet is the same as
the corresponding facet ofloc.
21 Effects: Causes characters inserted or extracted after this call to be converted according toloc until
another call ofimbue.
22 Remarks: This may require reconversion of previously converted characters. This in turn may require
the implementation to be able to reconstruct the original contents of the file.
31.10.4 Class template basic_ifstream [ifstream]
31.10.4.1 General [ifstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_ifstream : public basic_istream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using native_handle_type = basic_filebuf<charT, traits>::native_handle_type;
// 31.10.4.2, constructors
basic_ifstream();
explicit basic_ifstream(const char* s,
ios_base::openmode mode = ios_base::in);
explicit basic_ifstream(const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in);// wide systems only; see 31.10.1
explicit basic_ifstream(const string& s,
ios_base::openmode mode = ios_base::in);
template<class T>
explicit basic_ifstream(const T& s, ios_base::openmode mode = ios_base::in);
basic_ifstream(const basic_ifstream&) = delete;
basic_ifstream(basic_ifstream&& rhs);
basic_ifstream& operator=(const basic_ifstream&) = delete;
basic_ifstream& operator=(basic_ifstream&& rhs);
§ 31.10.4.1 © ISO/IEC
2090

===== PAGE 2102 =====

Dxxxx
// 31.10.4.3, swap
void swap(basic_ifstream& rhs);
// 31.10.4.4, members
basic_filebuf<charT, traits>* rdbuf() const;
native_handle_type native_handle() const noexcept;
bool is_open() const;
void open(const char* s, ios_base::openmode mode = ios_base::in);
void open(const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in); // wide systems only; see 31.10.1
void open(const string& s, ios_base::openmode mode = ios_base::in);
void open(const filesystem::path& s, ios_base::openmode mode = ios_base::in);
void close();
private:
basic_filebuf<charT, traits> sb ; // exposition only
};
}
1 The classbasic_ifstream<charT, traits> supports reading from named files. It uses abasic_filebuf<
charT, traits> object to control the associated sequence. For the sake of exposition, the maintained data
is presented here as:
—(1.1) sb , thefilebuf object.
31.10.4.2 Constructors [ifstream.cons]
basic_ifstream();
1 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2.2)
and sb with basic_filebuf<charT, traits>() (31.10.3.2).
explicit basic_ifstream(const char* s,
ios_base::openmode mode = ios_base::in);
explicit basic_ifstream(const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in); // wide systems only; see 31.10.1
2 Effects: Initializes the base class withbasic_istream<charT, traits>(addressof(sb )) (31.7.5.2.2)
and sb with basic_filebuf<charT, traits>() (31.10.3.2), then callsrdbuf()->open(s, mode |
ios_base::in). If that function returns a null pointer, callssetstate(failbit).
explicit basic_ifstream(const string& s,
ios_base::openmode mode = ios_base::in);
3 Effects: Equivalent tobasic_ifstream(s.c_str(), mode).
template<class T>
explicit basic_ifstream(const T& s, ios_base::openmode mode = ios_base::in);
4 Constraints: is_same_v<T, filesystem::path> is true.
5 Effects: Equivalent tobasic_ifstream(s.c_str(), mode).
basic_ifstream(basic_ifstream&& rhs);
6 Effects: Move constructs the base class, and the contained basic_filebuf. Then calls basic_-
istream<charT, traits>::set_rdbuf(addressof(sb )) to install the containedbasic_filebuf.
31.10.4.3 Swap [ifstream.swap]
void swap(basic_ifstream& rhs);
1 Effects: Exchangesthestate of *thisandrhsbycalling basic_istream<charT, traits>::swap(rhs)
and sb .swap(rhs.sb ).
template<class charT, class traits>
void swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);
2 Effects: Equivalent tox.swap(y).
§ 31.10.4.3 © ISO/IEC
2091

===== PAGE 2103 =====

Dxxxx
31.10.4.4 Member functions [ifstream.members]
basic_filebuf<charT, traits>* rdbuf() const;
1 Returns: const_cast<basic_filebuf<charT, traits>*>(addressof(sb )).
native_handle_type native_handle() const noexcept;
2 Effects: Equivalent to:return rdbuf()->native_handle();
bool is_open() const;
3 Returns: rdbuf()->is_open().
void open(const char* s, ios_base::openmode mode = ios_base::in);
void open(const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in); // wide systems only; see 31.10.1
4 Effects: Calls rdbuf()->open(s, mode | ios_base::in). If that function does not return a null
pointer calls clear(), otherwise callssetstate(failbit) (which may throwios_base::failure)
(31.5.4.4).
void open(const string& s, ios_base::openmode mode = ios_base::in);
void open(const filesystem::path& s, ios_base::openmode mode = ios_base::in);
5 Effects: Calls open(s.c_str(), mode).
void close();
6 Effects: Calls rdbuf()->close() and, if that function returns a null pointer, callssetstate(failbit)
(which may throwios_base::failure) (31.5.4.4).
31.10.5 Class template basic_ofstream [ofstream]
31.10.5.1 General [ofstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_ofstream : public basic_ostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using native_handle_type = basic_filebuf<charT, traits>::native_handle_type;
// 31.10.5.2, constructors
basic_ofstream();
explicit basic_ofstream(const char* s,
ios_base::openmode mode = ios_base::out);
explicit basic_ofstream(const filesystem::path::value_type* s, // wide systems only; see 31.10.1
ios_base::openmode mode = ios_base::out);
explicit basic_ofstream(const string& s,
ios_base::openmode mode = ios_base::out);
template<class T>
explicit basic_ofstream(const T& s, ios_base::openmode mode = ios_base::out);
basic_ofstream(const basic_ofstream&) = delete;
basic_ofstream(basic_ofstream&& rhs);
basic_ofstream& operator=(const basic_ofstream&) = delete;
basic_ofstream& operator=(basic_ofstream&& rhs);
// 31.10.5.3, swap
void swap(basic_ofstream& rhs);
// 31.10.5.4, members
basic_filebuf<charT, traits>* rdbuf() const;
native_handle_type native_handle() const noexcept;
§ 31.10.5.1 © ISO/IEC
2092

===== PAGE 2104 =====

Dxxxx
bool is_open() const;
void open(const char* s, ios_base::openmode mode = ios_base::out);
void open(const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::out); // wide systems only; see 31.10.1
void open(const string& s, ios_base::openmode mode = ios_base::out);
void open(const filesystem::path& s, ios_base::openmode mode = ios_base::out);
void close();
private:
basic_filebuf<charT, traits> sb ; // exposition only
};
}
1 The class basic_ofstream<charT, traits> supports writing to named files. It uses abasic_filebuf<
charT, traits> object to control the associated sequence. For the sake of exposition, the maintained data
is presented here as:
—(1.1) sb , thefilebuf object.
31.10.5.2 Constructors [ofstream.cons]
basic_ofstream();
1 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2.2)
and sb with basic_filebuf<charT, traits>() (31.10.3.2).
explicit basic_ofstream(const char* s,
ios_base::openmode mode = ios_base::out);
explicit basic_ofstream(const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::out); // wide systems only; see 31.10.1
2 Effects: Initializes the base class withbasic_ostream<charT, traits>(addressof(sb )) (31.7.6.2.2)
and sb with basic_filebuf<charT, traits>() (31.10.3.2), then callsrdbuf()->open(s, mode |
ios_base::out). If that function returns a null pointer, callssetstate(failbit).
explicit basic_ofstream(const string& s,
ios_base::openmode mode = ios_base::out);
3 Effects: Equivalent tobasic_ofstream(s.c_str(), mode).
template<class T>
explicit basic_ofstream(const T& s, ios_base::openmode mode = ios_base::out);
4 Constraints: is_same_v<T, filesystem::path> is true.
5 Effects: Equivalent tobasic_ofstream(s.c_str(), mode).
basic_ofstream(basic_ofstream&& rhs);
6 Effects: Move constructs the base class, and the contained basic_filebuf. Then calls basic_-
ostream<charT, traits>::set_rdbuf(addressof(sb )) to install the containedbasic_filebuf.
31.10.5.3 Swap [ofstream.swap]
void swap(basic_ofstream& rhs);
1 Effects: Exchangesthestate of *thisandrhsbycalling basic_ostream<charT, traits>::swap(rhs)
and sb .swap(rhs.sb ).
template<class charT, class traits>
void swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);
2 Effects: Equivalent tox.swap(y).
31.10.5.4 Member functions [ofstream.members]
basic_filebuf<charT, traits>* rdbuf() const;
1 Returns: const_cast<basic_filebuf<charT, traits>*>(addressof(sb )).
§ 31.10.5.4 © ISO/IEC
2093

===== PAGE 2105 =====

Dxxxx
native_handle_type native_handle() const noexcept;
2 Effects: Equivalent to:return rdbuf()->native_handle();
bool is_open() const;
3 Returns: rdbuf()->is_open().
void open(const char* s, ios_base::openmode mode = ios_base::out);
void open(const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::out); // wide systems only; see 31.10.1
4 Effects: Calls rdbuf()->open(s, mode | ios_base::out). If that function does not return a null
pointer calls clear(), otherwise callssetstate(failbit) (which may throwios_base::failure)
(31.5.4.4).
void close();
5 Effects: Calls rdbuf()->close() and, if that function fails (returns a null pointer), callssetstate(
failbit) (which may throwios_base::failure) (31.5.4.4).
void open(const string& s, ios_base::openmode mode = ios_base::out);
void open(const filesystem::path& s, ios_base::openmode mode = ios_base::out);
6 Effects: Calls open(s.c_str(), mode).
31.10.6 Class template basic_fstream [fstream]
31.10.6.1 General [fstream.general]
namespace std {
template<class charT, class traits = char_traits<charT>>
class basic_fstream : public basic_iostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using native_handle_type = basic_filebuf<charT, traits>::native_handle_type;
// 31.10.6.2, constructors
basic_fstream();
explicit basic_fstream(
const char* s,
ios_base::openmode mode = ios_base::in | ios_base::out);
explicit basic_fstream(
const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in | ios_base::out); // wide systems only; see 31.10.1
explicit basic_fstream(
const string& s,
ios_base::openmode mode = ios_base::in | ios_base::out);
template<class T>
explicit basic_fstream(const T& s, ios_base::openmode mode = ios_base::in | ios_base::out);
basic_fstream(const basic_fstream&) = delete;
basic_fstream(basic_fstream&& rhs);
basic_fstream& operator=(const basic_fstream&) = delete;
basic_fstream& operator=(basic_fstream&& rhs);
// 31.10.6.3, swap
void swap(basic_fstream& rhs);
// 31.10.6.4, members
basic_filebuf<charT, traits>* rdbuf() const;
native_handle_type native_handle() const noexcept;
§ 31.10.6.1 © ISO/IEC
2094

===== PAGE 2106 =====

Dxxxx
bool is_open() const;
void open(
const char* s,
ios_base::openmode mode = ios_base::in | ios_base::out);
void open(
const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in | ios_base::out); // wide systems only; see 31.10.1
void open(
const string& s,
ios_base::openmode mode = ios_base::in | ios_base::out);
void open(
const filesystem::path& s,
ios_base::openmode mode = ios_base::in | ios_base::out);
void close();
private:
basic_filebuf<charT, traits> sb ; // exposition only
};
}
1 The class templatebasic_fstream<charT, traits> supports reading and writing from named files. It uses
a basic_filebuf<charT, traits> object to control the associated sequences. For the sake of exposition,
the maintained data is presented here as:
—(1.1) sb , thebasic_filebuf object.
31.10.6.2 Constructors [fstream.cons]
basic_fstream();
1 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_filebuf<charT, traits>().
explicit basic_fstream(
const char* s,
ios_base::openmode mode = ios_base::in | ios_base::out);
explicit basic_fstream(
const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in | ios_base::out); // wide systems only; see 31.10.1
2 Effects: Initializes the base class withbasic_iostream<charT, traits>(addressof(sb )) (31.7.5.7.2)
and sb with basic_filebuf<charT, traits>(). Then callsrdbuf()->open(s, mode). If that func-
tion returns a null pointer, callssetstate(failbit).
explicit basic_fstream(
const string& s,
ios_base::openmode mode = ios_base::in | ios_base::out);
3 Effects: Equivalent tobasic_fstream(s.c_str(), mode).
template<class T>
explicit basic_fstream(const T& s, ios_base::openmode mode = ios_base::in | ios_base::out);
4 Constraints: is_same_v<T, filesystem::path> is true.
5 Effects: Equivalent tobasic_fstream(s.c_str(), mode).
basic_fstream(basic_fstream&& rhs);
6 Effects: Move constructs the base class, and the contained basic_filebuf. Then calls basic_-
istream<charT, traits>::set_rdbuf(addressof(sb )) to install the containedbasic_filebuf.
31.10.6.3 Swap [fstream.swap]
void swap(basic_fstream& rhs);
1 Effects: Exchangesthestate of *thisandrhsbycalling basic_iostream<charT,traits>::swap(rhs)
and sb .swap(rhs.sb ).
§ 31.10.6.3 © ISO/IEC
2095

===== PAGE 2107 =====

Dxxxx
template<class charT, class traits>
void swap(basic_fstream<charT, traits>& x,
basic_fstream<charT, traits>& y);
2 Effects: Equivalent tox.swap(y).
31.10.6.4 Member functions [fstream.members]
basic_filebuf<charT, traits>* rdbuf() const;
1 Returns: const_cast<basic_filebuf<charT, traits>*>(addressof(sb )).
native_handle_type native_handle() const noexcept;
2 Effects: Equivalent to:return rdbuf()->native_handle();
bool is_open() const;
3 Returns: rdbuf()->is_open().
void open(
const char* s,
ios_base::openmode mode = ios_base::in | ios_base::out);
void open(
const filesystem::path::value_type* s,
ios_base::openmode mode = ios_base::in | ios_base::out); // wide systems only; see 31.10.1
4 Effects: Calls rdbuf()->open(s, mode). If that function does not return a null pointer callsclear(),
otherwise callssetstate(failbit) (which may throwios_base::failure) (31.5.4.4).
void open(
const string& s,
ios_base::openmode mode = ios_base::in | ios_base::out);
void open(
const filesystem::path& s,
ios_base::openmode mode = ios_base::in | ios_base::out);
5 Effects: Calls open(s.c_str(), mode).
void close();
6 Effects: Calls rdbuf()->close() and, if that function returns a null pointer, callssetstate(failbit)
(which may throwios_base::failure) (31.5.4.4).
31.11 Synchronized output streams [syncstream]
31.11.1 Header <syncstream> synopsis [syncstream.syn]
#include <ostream> // see 31.7.2
namespace std {
// 31.11.2, class templatebasic_syncbuf
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_syncbuf;
// 31.11.2.6, specialized algorithms
template<class charT, class traits, class Allocator>
void swap(basic_syncbuf<charT, traits, Allocator>&,
basic_syncbuf<charT, traits, Allocator>&);
using syncbuf = basic_syncbuf<char>;
using wsyncbuf = basic_syncbuf<wchar_t>;
// 31.11.3, class templatebasic_osyncstream
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_osyncstream;
using osyncstream = basic_osyncstream<char>;
using wosyncstream = basic_osyncstream<wchar_t>;
}
§ 31.11.1 © ISO/IEC
2096

===== PAGE 2108 =====

Dxxxx
1 The header<syncstream> provides a mechanism to synchronize execution agents writing to the same stream.
31.11.2 Class template basic_syncbuf [syncstream.syncbuf]
31.11.2.1 Overview [syncstream.syncbuf.overview]
namespace std {
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_syncbuf : public basic_streambuf<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using allocator_type = Allocator;
using streambuf_type = basic_streambuf<charT, traits>;
// 31.11.2.2, construction and destruction
basic_syncbuf()
: basic_syncbuf(nullptr) {}
explicit basic_syncbuf(streambuf_type* obuf)
: basic_syncbuf(obuf, Allocator()) {}
basic_syncbuf(streambuf_type*, const Allocator&);
basic_syncbuf(basic_syncbuf&&);
~basic_syncbuf();
// 31.11.2.3, assignment and swap
basic_syncbuf& operator=(basic_syncbuf&&);
void swap(basic_syncbuf&);
// 31.11.2.4, member functions
bool emit();
streambuf_type* get_wrapped() const noexcept;
allocator_type get_allocator() const noexcept;
void set_emit_on_sync(bool) noexcept;
protected:
// 31.11.2.5, overridden virtual functions
int sync() override;
private:
streambuf_type* wrapped ; // exposition only
bool emit-on-sync {}; // exposition only
};
}
1 Class templatebasic_syncbuf stores character data written to it, known as the associated output, into
internal buffers allocated using the object’s allocator. The associated output is transferred to the wrapped
stream buffer object*wrapped when emit() is called or when thebasic_syncbuf object is destroyed. Such
transfers are atomic with respect to transfers by otherbasic_syncbuf objects with the same wrapped stream
buffer object.
31.11.2.2 Construction and destruction [syncstream.syncbuf.cons]
basic_syncbuf(streambuf_type* obuf, const Allocator& allocator);
1 Effects: Sets wrapped to obuf.
2 Postconditions: get_wrapped() == obuf and get_allocator() == allocator are true.
3 Throws: Nothing unless an exception is thrown by the construction of a mutex or by memory allocation.
4 Remarks: A copy ofallocator is used to allocate memory for internal buffers holding the associated
output.
§ 31.11.2.2 © ISO/IEC
2097

===== PAGE 2109 =====

Dxxxx
basic_syncbuf(basic_syncbuf&& other);
5 Postconditions: The value returned bythis->get_wrapped() is the value returned byother.get_-
wrapped() prior to calling this constructor. Output stored inother prior to calling this constructor
will be stored in*this afterwards. other.pbase() == other.pptr() and other.get_wrapped() ==
nullptr are true.
6 Remarks: This constructor disassociatesother from its wrapped stream buffer, ensuring destruction of
other produces no output.
~basic_syncbuf();
7 Effects: Calls emit().
8 Throws: Nothing. If an exception is thrown fromemit(), the destructor catches and ignores that
exception.
31.11.2.3 Assignment and swap [syncstream.syncbuf.assign]
basic_syncbuf& operator=(basic_syncbuf&& rhs);
1 Effects: Callsemit() then move assigns fromrhs. After the move assignment*this has the observable
state it would have had if it had been move constructed fromrhs (31.11.2.2).
2 Postconditions:
—(2.1) rhs.get_wrapped() == nullptr is true.
—(2.2) this->get_allocator() == rhs.get_allocator() is true when
allocator_traits<Allocator>::propagate_on_container_move_assignment::value
is true; otherwise, the allocator is unchanged.
3 Returns: *this.
4 Remarks: This assignment operator disassociates rhs from its wrapped stream buffer, ensuring
destruction ofrhs produces no output.
void swap(basic_syncbuf& other);
5 Preconditions: Either allocator_traits<Allocator>::propagate_on_container_swap::value is
true or this->get_allocator() == other.get_allocator() is true.
6 Effects: Exchanges the state of*this and other.
31.11.2.4 Member functions [syncstream.syncbuf.members]
bool emit();
1 Effects: Atomically transfers the associated output of*this to the stream buffer*wrapped , so that it
appears in the output stream as a contiguous sequence of characters.wrapped ->pubsync() is called if
and only if a call was made tosync() since the most recent call toemit(), if any.
2 Synchronization: All emit() calls transferring characters to the same stream buffer object appear to
execute in a total order consistent with the “happens before” relation (6.10.2.2), where eachemit()
call synchronizes with subsequentemit() calls in that total order.
3 Postconditions: On success, the associated output is empty.
4 Returns: true if all of the following conditions hold; otherwisefalse:
—(4.1) wrapped == nullptr is false.
—(4.2) All of the characters in the associated output were successfully transferred.
—(4.3) The call towrapped ->pubsync() (if any) succeeded.
5 Remarks: May call member functions of wrapped while holding a lock uniquely associated with
wrapped .
streambuf_type* get_wrapped() const noexcept;
6 Returns: wrapped .
§ 31.11.2.4 © ISO/IEC
2098

===== PAGE 2110 =====

Dxxxx
allocator_type get_allocator() const noexcept;
7 Returns: A copy of the allocator that was set in the constructor or assignment operator.
void set_emit_on_sync(bool b) noexcept;
8 Effects: emit-on-sync = b.
31.11.2.5 Overridden virtual functions [syncstream.syncbuf.virtuals]
int sync() override;
1 Effects: Records that the wrapped stream buffer is to be flushed. Then, ifemit-on-sync is true, calls
emit().
[Note 1: If emit-on-sync is false, the actual flush is delayed until a call toemit(). —end note]
2 Returns: If emit() was called and returnedfalse, returns-1; otherwise0.
31.11.2.6 Specialized algorithms [syncstream.syncbuf.special]
template<class charT, class traits, class Allocator>
void swap(basic_syncbuf<charT, traits, Allocator>& a,
basic_syncbuf<charT, traits, Allocator>& b);
1 Effects: Equivalent toa.swap(b).
31.11.3 Class template basic_osyncstream [syncstream.osyncstream]
31.11.3.1 Overview [syncstream.osyncstream.overview]
namespace std {
template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT>>
class basic_osyncstream : public basic_ostream<charT, traits> {
public:
using char_type = charT;
using int_type = traits::int_type;
using pos_type = traits::pos_type;
using off_type = traits::off_type;
using traits_type = traits;
using allocator_type = Allocator;
using streambuf_type = basic_streambuf<charT, traits>;
using syncbuf_type = basic_syncbuf<charT, traits, Allocator>;
// 31.11.3.2, construction and destruction
basic_osyncstream(streambuf_type*, const Allocator&);
explicit basic_osyncstream(streambuf_type* obuf)
: basic_osyncstream(obuf, Allocator()) {}
basic_osyncstream(basic_ostream<charT, traits>& os, const Allocator& allocator)
: basic_osyncstream(os.rdbuf(), allocator) {}
explicit basic_osyncstream(basic_ostream<charT, traits>& os)
: basic_osyncstream(os, Allocator()) {}
basic_osyncstream(basic_osyncstream&&) noexcept;
~basic_osyncstream();
// assignment
basic_osyncstream& operator=(basic_osyncstream&&);
// 31.11.3.3, member functions
void emit();
streambuf_type* get_wrapped() const noexcept;
syncbuf_type* rdbuf() const noexcept { return const_cast<syncbuf_type*>(addressof(sb )); }
private:
syncbuf_type sb ; // exposition only
};
}
1 Allocator shall meet theCpp17Allocator requirements (16.4.4.6.1).
§ 31.11.3.1 © ISO/IEC
2099

===== PAGE 2111 =====

Dxxxx
2 [Example 1: A named variable can be used within a block statement for streaming.
{
osyncstream bout(cout);
bout << "Hello, ";
bout << "World!";
bout << endl; // flush is noted
bout << "and more!\n";
} // characters are transferred andcout is flushed
—end example]
3 [Example 2: A temporary object can be used for streaming within a single statement.
osyncstream(cout) << "Hello, " << "World!" << '\n';
In this example,cout is not flushed. —end example]
31.11.3.2 Construction and destruction [syncstream.osyncstream.cons]
basic_osyncstream(streambuf_type* buf, const Allocator& allocator);
1 Effects: Initializes sb from buf and allocator. Initializes the base class withbasic_ostream<charT,
traits>(addressof(sb )).
2 [Note 1: The member functions of the provided stream buffer can be called fromemit() while a lock is held,
which might result in a deadlock if used incautiously.—end note]
3 Postconditions: get_wrapped() == buf is true.
basic_osyncstream(basic_osyncstream&& other) noexcept;
4 Effects: Move constructs the base class andsb from the corresponding subobjects ofother, and calls
basic_ostream<charT, traits>::set_rdbuf(addressof(sb )).
5 Postconditions: The value returned byget_wrapped() is the value returned byother.get_wrapped()
prior to calling this constructor.nullptr == other.get_wrapped() is true.
31.11.3.3 Member functions [syncstream.osyncstream.members]
void emit();
1 Effects: Behaves as an unformatted output function (31.7.6.4). After constructing asentry object,
calls sb .emit(). If that call returnsfalse, callssetstate(ios_base::badbit).
2 [Example 1: A flush on abasic_osyncstream does not flush immediately:
{
osyncstream bout(cout);
bout << "Hello," << '\n'; // no flush
bout.emit(); // characters transferred;cout not flushed
bout << "World!" << endl; // flush noted;cout not flushed
bout.emit(); // characters transferred;cout flushed
bout << "Greetings." << '\n'; // no flush
} // characters transferred;cout not flushed
—end example]
3 [Example 2: The functionemit() can be used to handle exceptions from operations on the underlying stream.
{
osyncstream bout(cout);
bout << "Hello, " << "World!" << '\n';
try {
bout.emit();
} catch (...) {
// handle exception
}
}
—end example]
streambuf_type* get_wrapped() const noexcept;
4 Returns: sb .get_wrapped().
§ 31.11.3.3 © ISO/IEC
2100

===== PAGE 2112 =====

Dxxxx
5 [Example 3: Obtaining the wrapped stream buffer withget_wrapped() allows wrapping it again with an
osyncstream. For example,
{
osyncstream bout1(cout);
bout1 << "Hello, ";
{
osyncstream(bout1.get_wrapped()) << "Goodbye, " << "Planet!" << '\n';
}
bout1 << "World!" << '\n';
}
produces theuninterleaved output
Goodbye, Planet!
Hello, World!
—end example]
31.12 File systems [filesystems]
31.12.1 General [fs.general]
1 Subclause 31.12 describes operations on file systems and their components, such as paths, regular files, and
directories.
2 A file systemis a collection of files and their attributes.
3 A file is an object within a file system that holds user or system data. Files can be written to, or read from,
or both. A file has certain attributes, including type. File types include regular files and directories. Other
types of files, such as symbolic links, may be supported by the implementation.
4 A directory is a file within a file system that acts as a container of directory entries that contain information
aboutotherfiles, possiblyincludingotherdirectoryfiles. The parent directoryofadirectoryisthedirectorythat
both contains a directory entry for the given directory and is represented by the dot-dot filename (31.12.6.2)
in the given directory. Theparent directoryof other types of files is a directory containing a directory entry
for the file under discussion.
5 A link is an object that associates a filename with a file. Several links can associate names with the same file.
A hard linkis a link to an existing file. Some file systems support multiple hard links to a file. If the last
hard link to a file is removed, the file itself is removed.
[Note 1: A hard link can be thought of as a shared-ownership smart pointer to a file.—end note]
A symbolic link is a type of file with the property that when the file is encountered during pathname
resolution (31.12.6), a string stored by the file is used to modify the pathname resolution.
[Note 2: Symbolic links are often called symlinks. A symbolic link can be thought of as a raw pointer to a file. If the
file pointed to does not exist, the symbolic link is said to be a “dangling” symbolic link.—end note]
31.12.2 Conformance [fs.conformance]
31.12.2.1 General [fs.conformance.general]
1 Conformance is specified in terms of behavior. Ideal behavior is not always implementable, so the conformance
subclauses take that into account.
31.12.2.2 POSIX conformance [fs.conform.9945]
1 Some behavior is specified by reference to POSIX. How such behavior is actually implemented is unspecified.
[Note 1: This constitutes an “as if” rule allowing implementations to call native operating system or other APIs.
—end note]
2 Implementations should provide such behavior as it is defined by POSIX. Implementations shall document
any behavior that differs from the behavior defined by POSIX. Implementations that do not support exact
POSIX behavior should provide behavior as close to POSIX behavior as is reasonable given the limitations of
actual operating systems and file systems. If an implementation cannot provide any reasonable behavior, the
implementation shall report an error as specified in 31.12.5.
[Note 2: This allows users to rely on an exception being thrown or an error code being set when an implementation
cannot provide any reasonable behavior.—end note]
§ 31.12.2.2 © ISO/IEC
2101

===== PAGE 2113 =====

Dxxxx
3 Implementations are not required to provide behavior that is not supported by a particular file system.
[Example 1: The FAT file system used by some memory cards, camera memory, and floppy disks does not support
hard links, symlinks, and many other features of more capable file systems, so implementations are not required to
support those features on the FAT file system but instead are required to report an error as described above.—end
example]
31.12.2.3 Operating system dependent behavior conformance [fs.conform.os]
1 Behavior that is specified as beingoperating system dependentis dependent upon the behavior and character-
istics of an operating system. The operating system an implementation is dependent upon is implementation-
defined.
2 It is permissible for an implementation to be dependent upon an operating system emulator rather than the
actual underlying operating system.
31.12.2.4 File system race behavior [fs.race.behavior]
1 A file system raceis the condition that occurs when multiple threads, processes, or computers interleave
access and modification of the same object within a file system. Behavior is undefined if calls to functions
provided by subclause 31.12 introduce a file system race.
2 If the possibility of a file system race would make it unreliable for a program to test for a precondition before
calling a function described herein,Preconditions: is not specified for the function.
[Note 1: As a design practice, preconditions are not specified when it is unreasonable for a program to detect them
prior to calling the function.—end note]
31.12.3 Requirements [fs.req]
1 Throughout subclause 31.12, char, wchar_t, char8_t, char16_t, and char32_t are collectively called
encoded character types.
2 Functions with template parameters namedEcharT shall not participate in overload resolution unlessEcharT
is one of the encoded character types.
3 Template parameters namedInputIterator shall meet theCpp17InputIterator requirements (24.3.5.3) and
shall have a value type that is one of the encoded character types.
4 [Note 1: Use of an encoded character type implies an associated character set and encoding. Sincesigned char and
unsigned char have no implied character set and encoding, they are not included as permitted types.—end note]
5 Template parameters namedAllocator shall meet theCpp17Allocator requirements (16.4.4.6.1).
31.12.4 Header <filesystem> synopsis [fs.filesystem.syn]
#include <compare> // see 17.12.1
namespace std::filesystem {
// 31.12.6, paths
class path;
// 31.12.6.8,path non-member functions
void swap(path& lhs, path& rhs) noexcept;
size_t hash_value(const path& p) noexcept;
// 31.12.7, filesystem errors
class filesystem_error;
// 31.12.10, directory entries
class directory_entry;
// 31.12.11, directory iterators
class directory_iterator;
// 31.12.11.3, range access for directory iterators
directory_iterator begin(directory_iterator iter) noexcept;
directory_iterator end(directory_iterator) noexcept;
§ 31.12.4 © ISO/IEC
2102

===== PAGE 2114 =====

Dxxxx
// 31.12.12, recursive directory iterators
class recursive_directory_iterator;
// 31.12.12.3, range access for recursive directory iterators
recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;
recursive_directory_iterator end(recursive_directory_iterator) noexcept;
// 31.12.9, file status
class file_status;
struct space_info {
uintmax_t capacity;
uintmax_t free;
uintmax_t available;
friend bool operator==(const space_info&, const space_info&) = default;
};
// 31.12.8, enumerations
enum class file_type;
enum class perms;
enum class perm_options;
enum class copy_options;
enum class directory_options;
using file_time_type = chrono::time_point<chrono::file_clock>;
// 31.12.13, filesystem operations
path absolute(const path& p);
path absolute(const path& p, error_code& ec);
path canonical(const path& p);
path canonical(const path& p, error_code& ec);
void copy(const path& from, const path& to);
void copy(const path& from, const path& to, error_code& ec);
void copy(const path& from, const path& to, copy_options options);
void copy(const path& from, const path& to, copy_options options,
error_code& ec);
bool copy_file(const path& from, const path& to);
bool copy_file(const path& from, const path& to, error_code& ec);
bool copy_file(const path& from, const path& to, copy_options option);
bool copy_file(const path& from, const path& to, copy_options option,
error_code& ec);
void copy_symlink(const path& existing_symlink, const path& new_symlink);
void copy_symlink(const path& existing_symlink, const path& new_symlink,
error_code& ec) noexcept;
bool create_directories(const path& p);
bool create_directories(const path& p, error_code& ec);
bool create_directory(const path& p);
bool create_directory(const path& p, error_code& ec) noexcept;
bool create_directory(const path& p, const path& attributes);
bool create_directory(const path& p, const path& attributes,
error_code& ec) noexcept;
void create_directory_symlink(const path& to, const path& new_symlink);
void create_directory_symlink(const path& to, const path& new_symlink,
error_code& ec) noexcept;
§ 31.12.4 © ISO/IEC
2103

===== PAGE 2115 =====

Dxxxx
void create_hard_link(const path& to, const path& new_hard_link);
void create_hard_link(const path& to, const path& new_hard_link,
error_code& ec) noexcept;
void create_symlink(const path& to, const path& new_symlink);
void create_symlink(const path& to, const path& new_symlink,
error_code& ec) noexcept;
path current_path();
path current_path(error_code& ec);
void current_path(const path& p);
void current_path(const path& p, error_code& ec) noexcept;
bool equivalent(const path& p1, const path& p2);
bool equivalent(const path& p1, const path& p2, error_code& ec) noexcept;
bool exists(file_status s) noexcept;
bool exists(const path& p);
bool exists(const path& p, error_code& ec) noexcept;
uintmax_t file_size(const path& p);
uintmax_t file_size(const path& p, error_code& ec) noexcept;
uintmax_t hard_link_count(const path& p);
uintmax_t hard_link_count(const path& p, error_code& ec) noexcept;
bool is_block_file(file_status s) noexcept;
bool is_block_file(const path& p);
bool is_block_file(const path& p, error_code& ec) noexcept;
bool is_character_file(file_status s) noexcept;
bool is_character_file(const path& p);
bool is_character_file(const path& p, error_code& ec) noexcept;
bool is_directory(file_status s) noexcept;
bool is_directory(const path& p);
bool is_directory(const path& p, error_code& ec) noexcept;
bool is_empty(const path& p);
bool is_empty(const path& p, error_code& ec);
bool is_fifo(file_status s) noexcept;
bool is_fifo(const path& p);
bool is_fifo(const path& p, error_code& ec) noexcept;
bool is_other(file_status s) noexcept;
bool is_other(const path& p);
bool is_other(const path& p, error_code& ec) noexcept;
bool is_regular_file(file_status s) noexcept;
bool is_regular_file(const path& p);
bool is_regular_file(const path& p, error_code& ec) noexcept;
bool is_socket(file_status s) noexcept;
bool is_socket(const path& p);
bool is_socket(const path& p, error_code& ec) noexcept;
bool is_symlink(file_status s) noexcept;
bool is_symlink(const path& p);
bool is_symlink(const path& p, error_code& ec) noexcept;
file_time_type last_write_time(const path& p);
file_time_type last_write_time(const path& p, error_code& ec) noexcept;
void last_write_time(const path& p, file_time_type new_time);
§ 31.12.4 © ISO/IEC
2104

===== PAGE 2116 =====

Dxxxx
void last_write_time(const path& p, file_time_type new_time,
error_code& ec) noexcept;
void permissions(const path& p, perms prms, perm_options opts=perm_options::replace);
void permissions(const path& p, perms prms, error_code& ec) noexcept;
void permissions(const path& p, perms prms, perm_options opts, error_code& ec);
path proximate(const path& p, error_code& ec);
path proximate(const path& p, const path& base = current_path());
path proximate(const path& p, const path& base, error_code& ec);
path read_symlink(const path& p);
path read_symlink(const path& p, error_code& ec);
path relative(const path& p, error_code& ec);
path relative(const path& p, const path& base = current_path());
path relative(const path& p, const path& base, error_code& ec);
bool remove(const path& p);
bool remove(const path& p, error_code& ec) noexcept;
uintmax_t remove_all(const path& p);
uintmax_t remove_all(const path& p, error_code& ec);
void rename(const path& from, const path& to);
void rename(const path& from, const path& to, error_code& ec) noexcept;
void resize_file(const path& p, uintmax_t size);
void resize_file(const path& p, uintmax_t size, error_code& ec) noexcept;
space_info space(const path& p);
space_info space(const path& p, error_code& ec) noexcept;
file_status status(const path& p);
file_status status(const path& p, error_code& ec) noexcept;
bool status_known(file_status s) noexcept;
file_status symlink_status(const path& p);
file_status symlink_status(const path& p, error_code& ec) noexcept;
path temp_directory_path();
path temp_directory_path(error_code& ec);
path weakly_canonical(const path& p);
path weakly_canonical(const path& p, error_code& ec);
}
namespace std {
// 31.12.6.9, formatting support
template<class charT> struct formatter<filesystem::path, charT>;
// 31.12.6.10, hash support
template<class T> struct hash;
template<> struct hash<filesystem::path>;
}
namespace std::ranges {
template<>
inline constexpr bool enable_borrowed_range<filesystem::directory_iterator> = true;
template<>
inline constexpr bool enable_borrowed_range<filesystem::recursive_directory_iterator> = true;
§ 31.12.4 © ISO/IEC
2105

===== PAGE 2117 =====

Dxxxx
template<>
inline constexpr bool enable_view<filesystem::directory_iterator> = true;
template<>
inline constexpr bool enable_view<filesystem::recursive_directory_iterator> = true;
}
1 Implementations should ensure that the resolution and range offile_time_type reflect the operating system
dependent resolution and range of file time values.
31.12.5 Error reporting [fs.err.report]
1 Filesystem library functions often provide two overloads, one that throws an exception to report file system
errors, and another that sets anerror_code.
[Note 1: This supports two common use cases:
—(1.1) Uses where file system errors are truly exceptional and indicate a serious failure. Throwing an exception is an
appropriate response.
—(1.2) Uses where file system errors are routine and do not necessarily represent failure. Returning an error code is the
most appropriate response. This allows application specific error handling, including simply ignoring the error.
—end note]
2 Functions not having an argument of typeerror_code& handle errors as follows, unless otherwise specified:
—(2.1) When a call by the implementation to an operating system or other underlying API results in an
error that prevents the function from meeting its specifications, an exception of typefilesystem_-
error shall be thrown. For functions with a single path argument, that argument shall be passed
to the filesystem_error constructor with a single path argument. For functions with two path
arguments, the first of these arguments shall be passed to thefilesystem_error constructor as the
path1 argument, and the second shall be passed as thepath2 argument. The filesystem_error
constructor’s error_code argument is set as appropriate for the specific operating system dependent
error.
—(2.2) Failure to allocate storage is reported by throwing an exception as described in 16.4.6.14.
—(2.3) Destructors throw nothing.
3 Functions having an argument of typeerror_code& handle errors as follows, unless otherwise specified:
—(3.1) If a call by the implementation to an operating system or other underlying API results in an error that
prevents the function from meeting its specifications, theerror_code& argument is set as appropriate
for the specific operating system dependent error. Otherwise,clear() is called on theerror_code&
argument.
31.12.6 Class path [fs.class.path]
31.12.6.1 General [fs.class.path.general]
1 An object of classpath represents a path and contains a pathname. Such an object is concerned only with
the lexical and syntactic aspects of a path. The path does not necessarily exist in external storage, and the
pathname is not necessarily valid for the current operating system or for a particular file system.
2 [Note 1: Class path is used to support the differences between the string types used by different operating systems to
represent pathnames, and to perform conversions between encodings when necessary.—end note]
3 A path is a sequence of elements that identify the location of a file within a filesystem. The elements are the
root-nameopt, root-directoryopt, and an optional sequence offilenames (31.12.6.2). The maximum number of
elements in the sequence is operating system dependent (31.12.2.3).
4 An absolute path is a path that unambiguously identifies the location of a file without reference to an
additional starting location. The elements of a path that determine if it is absolute are operating system
dependent. A relative pathis a path that is not absolute, and as such, only unambiguously identifies the
location of a file when resolved relative to an implied starting location. The elements of a path that determine
if it is relative are operating system dependent.
[Note 2: Pathnames “.” and “..” are relative paths.—end note]
5 A pathname is a character string that represents the name of a path. Pathnames are formatted according to
the generic pathname format grammar (31.12.6.2) or according to an operating system dependentnative
pathname formataccepted by the host operating system.
§ 31.12.6.1 © ISO/IEC
2106

===== PAGE 2118 =====

Dxxxx
6 Pathname resolutionis the operating system dependent mechanism for resolving a pathname to a particular
file in a file hierarchy. There may be multiple pathnames that resolve to the same file.
[Example 1: For POSIX-based operating systems, this mechanism is specified in POSIX, section 4.12, Pathname
resolution. —end example]
namespace std::filesystem {
class path {
public:
using value_type = see below ;
using string_type = basic_string<value_type>;
static constexpr value_type preferred_separator = see below ;
// 31.12.8.1, enumerationformat
enum format;
// 31.12.6.5.1, constructors and destructor
path() noexcept;
path(const path& p);
path(path&& p) noexcept;
path(string_type&& source, format fmt = auto_format);
template<class Source>
path(const Source& source, format fmt = auto_format);
template<class InputIterator>
path(InputIterator first, InputIterator last, format fmt = auto_format);
template<class Source>
path(const Source& source, const locale& loc, format fmt = auto_format);
template<class InputIterator>
path(InputIterator first, InputIterator last, const locale& loc, format fmt = auto_format);
~path();
// 31.12.6.5.2, assignments
path& operator=(const path& p);
path& operator=(path&& p) noexcept;
path& operator=(string_type&& source);
path& assign(string_type&& source);
template<class Source>
path& operator=(const Source& source);
template<class Source>
path& assign(const Source& source);
template<class InputIterator>
path& assign(InputIterator first, InputIterator last);
// 31.12.6.5.3, appends
path& operator/=(const path& p);
template<class Source>
path& operator/=(const Source& source);
template<class Source>
path& append(const Source& source);
template<class InputIterator>
path& append(InputIterator first, InputIterator last);
// 31.12.6.5.4, concatenation
path& operator+=(const path& x);
path& operator+=(const string_type& x);
path& operator+=(basic_string_view<value_type> x);
path& operator+=(const value_type* x);
path& operator+=(value_type x);
template<class Source>
path& operator+=(const Source& x);
template<class EcharT>
path& operator+=(EcharT x);
template<class Source>
path& concat(const Source& x);
§ 31.12.6.1 © ISO/IEC
2107

===== PAGE 2119 =====

Dxxxx
template<class InputIterator>
path& concat(InputIterator first, InputIterator last);
// 31.12.6.5.5, modifiers
void clear() noexcept;
path& make_preferred();
path& remove_filename();
path& replace_filename(const path& replacement);
path& replace_extension(const path& replacement = path());
void swap(path& rhs) noexcept;
// 31.12.6.8, non-member operators
friend bool operator==(const path& lhs, const path& rhs) noexcept;
friend strong_ordering operator<=>(const path& lhs, const path& rhs) noexcept;
friend path operator/(const path& lhs, const path& rhs);
// 31.12.6.5.6, native format observers
const string_type& native() const noexcept;
const value_type* c_str() const noexcept;
operator string_type() const;
template<class EcharT, class traits = char_traits<EcharT>,
class Allocator = allocator<EcharT>>
basic_string<EcharT, traits, Allocator>
string(const Allocator& a = Allocator()) const;
std::string display_string() const;
std::string system_encoded_string() const;
std::wstring wstring() const;
std::u8string u8string() const;
std::u16string u16string() const;
std::u32string u32string() const;
// 31.12.6.5.7, generic format observers
template<class EcharT, class traits = char_traits<EcharT>,
class Allocator = allocator<EcharT>>
basic_string<EcharT, traits, Allocator>
generic_string(const Allocator& a = Allocator()) const;
std::string generic_display_string() const;
std::string generic_system_encoded_string() const;
std::wstring generic_wstring() const;
std::u8string generic_u8string() const;
std::u16string generic_u16string() const;
std::u32string generic_u32string() const;
// 31.12.6.5.8, compare
int compare(const path& p) const noexcept;
int compare(const string_type& s) const;
int compare(basic_string_view<value_type> s) const;
int compare(const value_type* s) const;
// 31.12.6.5.9, decomposition
path root_name() const;
path root_directory() const;
path root_path() const;
path relative_path() const;
path parent_path() const;
path filename() const;
path stem() const;
path extension() const;
// 31.12.6.5.10, query
bool empty() const noexcept;
bool has_root_name() const;
§ 31.12.6.1 © ISO/IEC
2108

===== PAGE 2120 =====

Dxxxx
bool has_root_directory() const;
bool has_root_path() const;
bool has_relative_path() const;
bool has_parent_path() const;
bool has_filename() const;
bool has_stem() const;
bool has_extension() const;
bool is_absolute() const;
bool is_relative() const;
// 31.12.6.5.11, generation
path lexically_normal() const;
path lexically_relative(const path& base) const;
path lexically_proximate(const path& base) const;
// 31.12.6.6, iterators
class iterator;
using const_iterator = iterator;
iterator begin() const;
iterator end() const;
// 31.12.6.7,path inserter and extractor
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const path& p);
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, path& p);
};
}
7 value_type is a typedef for the operating system dependent encoded character type used to represent
pathnames.
8 The value of thepreferred_separator member is the operating system dependentpreferred-separator
character (31.12.6.2).
9 [Example 2: For POSIX-based operating systems,value_type is char and preferred_separator is the slash character
(’/’). For Windows-based operating systems,value_type is wchar_t and preferred_separator is the backslash
character (L’\\’). —end example]
31.12.6.2 Generic pathname format [fs.path.generic]
pathname:
root-nameopt root-directoryopt relative-path
root-name:
operating system dependent sequences of characters
implementation-defined sequences of characters
root-directory:
directory-separator
relative-path:
filename
filename directory-separator relative-path
an empty path
filename:
non-empty sequence of characters other thandirectory-separator characters
directory-separator:
preferred-separator directory-separatoropt
fallback-separator directory-separatoropt
preferred-separator:
operating system dependent directory separator character
§ 31.12.6.2 © ISO/IEC
2109

===== PAGE 2121 =====

Dxxxx
fallback-separator:
/, ifpreferred-separator is not/
1 A filename is the name of a file. Thedot and dot-dot filenames, consisting solely of one and two period
characters respectively, have special meaning. The following characteristics of filenames are operating system
dependent:
—(1.1) The permitted characters.
[Example 1: Some operating systems prohibit the ASCII control characters (0x00 – 0x1F) in filenames.—end
example]
[Note 1: Wider portability can be achieved by limitingfilename characters to the POSIX Portable Filename
Character Set:
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m n o p q r s t u v w x y z
0 1 2 3 4 5 6 7 8 9 . _ - —end note]
—(1.2) The maximum permitted length.
—(1.3) Filenames that are not permitted.
—(1.4) Filenames that have special meaning.
—(1.5) Case awareness and sensitivity during path resolution.
—(1.6) Special rules that may apply to file types other than regular files, such as directories.
2 Except in aroot-name, multiple successivedirectory-separator characters are considered to be the same as one
directory-separator character.
3 The dot filename is treated as a reference to the current directory. The dot-dot filename is treated as a reference
to the parent directory. What the dot-dot filename refers to relative toroot-directory is implementation-defined.
Specific filenames may have special meanings for a particular operating system.
4 A root-name identifies the starting location for pathname resolution (31.12.6). If there are no operating
system dependentroot-names, at least one implementation-definedroot-name is required.
[Note 2: Many operating systems define a name beginning with twodirectory-separator characters as aroot-name that
identifies network or other resource locations. Some operating systems define a single letter followed by a colon as a
drive specifier — aroot-name identifying a specific device such as a disk drive.—end note]
5 If aroot-name is otherwise ambiguous, the possibility with the longest sequence of characters is chosen.
[Note 3: On a POSIX-like operating system, it is impossible to have aroot-name and arelative-path without an
intervening root-directory element. —end note]
6 Normalization of a generic format pathname means:
1. If the path is empty, stop.
2. Replace each slash character in theroot-name with apreferred-separator.
3. Replace eachdirectory-separator with apreferred-separator.
[Note 4: The generic pathname grammar definesdirectory-separator as one or more slashes andpreferred-
separators. —end note]
4. Remove each dot filename and any immediately followingdirectory-separator.
5. As long as any appear, remove a non-dot-dot filename immediately followed by adirectory-separator
and a dot-dot filename, along with any immediately followingdirectory-separator.
6. If there is a root-directory, remove all dot-dot filenames and anydirectory-separators immediately
following them.
[Note 5: These dot-dot filenames attempt to refer to nonexistent parent directories.—end note]
7. If the last filename is dot-dot, remove any trailingdirectory-separator.
8. If the path is empty, add a dot.
The result of normalization is a path innormal form, which is said to benormalized.
31.12.6.3 Conversions [fs.path.cvt]
31.12.6.3.1 Argument format conversions [fs.path.fmt.cvt]
§ 31.12.6.3.1 © ISO/IEC
2110

===== PAGE 2122 =====

Dxxxx
1 [Note 1: The format conversions described in this subclause are not applied on POSIX-based operating systems
because on these systems:
—(1.1) The generic format is acceptable as a native path.
—(1.2) There is no need to distinguish between native format and generic format in function arguments.
—(1.3) Paths for regular files and paths for directories share the same syntax.
—end note]
2 Several functions are defined to acceptdetected-format arguments, which are character sequences. A detected-
format argument represents a path using either a pathname in the generic format (31.12.6.2) or a pathname
in the native format (31.12.6). Such an argument is taken to be in the generic format if and only if it matches
the generic format and is not acceptable to the operating system as a native path.
3 [Note 2: Some operating systems have no unambiguous way to distinguish between native format and generic format
arguments. This is by design as it simplifies use for operating systems that do not require disambiguation. It is
possible that an implementation for an operating system where disambiguation is needed distinguishes between the
formats. —end note]
4 Pathnames are converted as needed between the generic and native formats in an operating-system-dependent
manner. Let G(n) and N(g) in a mathematical sense be the implementation’s functions that convert native-
to-generic and generic-to-native formats respectively. Ifg=G(n) for somen, thenG(N(g))=g; ifn=N(g) for
some g, thenN(G(n))=n.
[Note 3: Neither G nor N need be invertible. —end note]
5 If the native format requires paths for regular files to be formatted differently from paths for directories,
the path shall be treated as a directory path if its last element is adirectory-separator, otherwise it shall be
treated as a path to a regular file.
6 [Note 4: A path stores a native format pathname (31.12.6.5.6) and acts as if it also stores a generic format pathname,
related as given below. The implementation can generate the generic format pathname based on the native format
pathname (and possibly other information) when requested.—end note]
7 When a path is constructed from or is assigned a single representation separate from any path, the other
representation is selected by the appropriate conversion function (G or N).
8 When the (new) valuep of one representation of a path is derived from the representation of that or another
path, a valueq is chosen for the other representation. The valueq converts top (by G or N as appropriate)
if any such value does so;q is otherwise unspecified.
[Note 5: If q is the result of converting any path at all, it is the result of convertingp. —end note]
31.12.6.3.2 Type and encoding conversions [fs.path.type.cvt]
1 The native encodingof an ordinary character string is the operating system dependent current encoding for
pathnames (31.12.6). Thenative encodingfor wide character strings is the implementation-defined execution
wide-character set encoding (16.3.3.3.4).
2 For member function arguments that take character sequences representing paths and for member functions
returning strings, value type and encoding conversion is performed if the value type of the argument or return
value differs frompath::value_type. For the argument or return value, the method of conversion and the
encoding to be converted to is determined by its value type:
—(2.1) char: The encoding is the native ordinary encoding. The method of conversion, if any, is operating
system dependent.
[Note 1: For POSIX-based operating systemspath::value_type is char so no conversion fromchar value type
arguments or tochar value type return values is performed. For Windows-based operating systems, the native
ordinary encoding is determined by calling a Windows API function.—end note]
[Note 2: This results in behavior identical to other C and C++ standard library functions that perform file
operations using ordinary character strings to identify paths. Changing this behavior would be surprising and
error-prone. —end note]
—(2.2) wchar_t: The encoding is the native wide encoding. The method of conversion is unspecified.
[Note 3: For Windows-based operating systemspath::value_type is wchar_t so no conversion fromwchar_t
value type arguments or towchar_t value type return values is performed.—end note]
—(2.3) char8_t: The encoding is UTF-8. The method of conversion is unspecified.
—(2.4) char16_t: The encoding is UTF-16. The method of conversion is unspecified.
§ 31.12.6.3.2 © ISO/IEC
2111

===== PAGE 2123 =====

Dxxxx
—(2.5) char32_t: The encoding is UTF-32. The method of conversion is unspecified.
3 If the encoding being converted to has no representation for source characters, the resulting converted
characters, if any, are unspecified. Implementations should not modify member function arguments if already
of typepath::value_type.
31.12.6.4 Requirements [fs.path.req]
1 In addition to the requirements (31.12.3), function template parameters namedSource shall be one of:
—(1.1) basic_string<EcharT, traits, Allocator>. A function argument const Source& source shall
have an effective range[source.begin(),source.end()).
—(1.2) basic_string_view<EcharT, traits>. A function argumentconst Source& sourceshall have an
effective range[source.begin(),source.end()).
—(1.3) A type meeting theCpp17InputIterator requirements that iterates over an NTCTS. The value type
shall be an encoded character type. A function argument const Source& source shall have an
effective range [source,end) where end is the first iterator value with an element value equal to
iterator_traits<Source>::value_type().
—(1.4) A character array that after array-to-pointer decay results in a pointer to the start of an NTCTS. The
value type shall be an encoded character type. A function argumentconst Source& sourceshall have
an effective range[source,end) where end is the first iterator value with an element value equal to
iterator_traits<decay_t<Source>>::value_type().
2 Functions taking template parameters namedSource shall not participate in overload resolution unless
Source denotes a type other thanpath, and either
—(2.1) Source is a specialization ofbasic_string or basic_string_view, or
—(2.2) the qualified-id iterator_traits<decay_t<Source>>::value_type is valid and denotes a possibly
const encoded character type (13.10.3).
3 [Note 1: See path conversions (31.12.6.3) for how the value types above and their encodings convert topath::value_-
type and its encoding. —end note]
4 Arguments of typeSource shall not be null pointers.
31.12.6.5 Members [fs.path.member]
31.12.6.5.1 Constructors [fs.path.construct]
path() noexcept;
1 Postconditions: empty() is true.
path(const path& p);
path(path&& p) noexcept;
2 Effects: Constructs an object of classpath having the same pathname in the native and generic formats,
respectively, as the original value ofp. In the second form,p is left in a valid but unspecified state.
path(string_type&& source, format fmt = auto_format);
3 Effects: Constructs an object of classpath for which the pathname in the detected-format ofsource
has the original value ofsource (31.12.6.3.1), converting format if required (31.12.6.3.1).source is
left in a valid but unspecified state.
template<class Source>
path(const Source& source, format fmt = auto_format);
template<class InputIterator>
path(InputIterator first, InputIterator last, format fmt = auto_format);
4 Effects: Lets be the effective range ofsource (31.12.6.4) or the range[first,last), with the encoding
converted if required (31.12.6.3). Finds the detected-format ofs (31.12.6.3.1) and constructs an object
of classpath for which the pathname in that format iss.
template<class Source>
path(const Source& source, const locale& loc, format fmt = auto_format);
§ 31.12.6.5.1 © ISO/IEC
2112

===== PAGE 2124 =====

Dxxxx
template<class InputIterator>
path(InputIterator first, InputIterator last, const locale& loc, format fmt = auto_format);
5 Mandates: The value type ofSource and InputIterator is char.
6 Effects: Lets be the effective range ofsource or the range[first,last), after converting the encoding
as follows:
—(6.1) If value_type is wchar_t, converts to the native wide encoding (31.12.6.3.2) using thecodecvt<
wchar_t, char, mbstate_t> facet ofloc.
—(6.2) Otherwise a conversion is performed using thecodecvt<wchar_t, char, mbstate_t> facet of
loc, and then a second conversion to the current ordinary encoding.
7 Finds the detected-format ofs (31.12.6.3.1) and constructs an object of classpath for which the
pathname in that format iss.
[Example 1: A string is to be read from a database that is encoded in ISO/IEC 8859-1, and used to create a
directory:
namespace fs = std::filesystem;
std::string latin1_string = read_latin1_data();
codecvt_8859_1<wchar_t> latin1_facet;
std::locale latin1_locale(std::locale(), latin1_facet);
fs::create_directory(fs::path(latin1_string, latin1_locale));
For POSIX-based operating systems, the path is constructed by first usinglatin1_facet to convert ISO/IEC
8859-1 encoded latin1_string to a wide character string in the native wide encoding (31.12.6.3.2). The
resulting wide string is then converted to an ordinary character pathname string in the current native ordinary
encoding. If the native wide encoding is UTF-16 or UTF-32, and the current native ordinary encoding is UTF-8,
all of the characters in the ISO/IEC 8859-1 character set will be converted to their Unicode representation, but
for other native ordinary encodings some characters may have no representation.
For Windows-based operating systems, the path is constructed by usinglatin1_facet to convert ISO/IEC
8859-1 encodedlatin1_string to a UTF-16 encoded wide character pathname string. All of the characters in
the ISO/IEC 8859-1 character set will be converted to their Unicode representation.—end example]
31.12.6.5.2 Assignments [fs.path.assign]
path& operator=(const path& p);
1 Effects: If *this and p are the same object, has no effect. Otherwise, sets both respective pathnames
of *this to the respective pathnames ofp.
2 Returns: *this.
path& operator=(path&& p) noexcept;
3 Effects: If *this and p are the same object, has no effect. Otherwise, sets both respective pathnames
of *this to the respective pathnames ofp. p is left in a valid but unspecified state.
[Note 1: A valid implementation isswap(p). —end note]
4 Returns: *this.
path& operator=(string_type&& source);
path& assign(string_type&& source);
5 Effects: Sets the pathname in the detected-format ofsource to the original value ofsource. source
is left in a valid but unspecified state.
6 Returns: *this.
template<class Source>
path& operator=(const Source& source);
template<class Source>
path& assign(const Source& source);
template<class InputIterator>
path& assign(InputIterator first, InputIterator last);
7 Effects: Lets be the effective range ofsource (31.12.6.4) or the range[first,last), with the encoding
converted if required (31.12.6.3). Finds the detected-format ofs (31.12.6.3.1) and sets the pathname in
that format tos.
§ 31.12.6.5.2 © ISO/IEC
2113

===== PAGE 2125 =====

Dxxxx
8 Returns: *this.
31.12.6.5.3 Appends [fs.path.append]
1 The append operations useoperator/= to denote their semantic effect of appendingpreferred-separator when
needed.
path& operator/=(const path& p);
2 Effects: If p.is_absolute() || (p.has_root_name() && p.root_name() != root_name()), then
operator=(p).
3 Otherwise, modifies*this as if by these steps:
—(3.1) If p.has_root_directory(), then removes any root directory and relative path from the generic
format pathname. Otherwise, if!has_root_directory() && is_absolute() is true or ifhas_-
filename() is true, then appendspath::preferred_separator to the generic format pathname.
—(3.2) Then appends the native format pathname ofp, omitting anyroot-name from its generic format
pathname, to the native format pathname.
4 [Example 1: Even if //host is interpreted as aroot-name, both of the pathspath("//host")/"foo" and
path("//host/")/"foo" equal "//host/foo" (although the former might use backslash as the preferred sepa-
rator).
Expression examples:
// On POSIX,
path("foo") /= path(""); // yieldspath("foo/")
path("foo") /= path("/bar"); // yieldspath("/bar")
// On Windows,
path("foo") /= path(""); // yieldspath("foo\\")
path("foo") /= path("/bar"); // yieldspath("/bar")
path("foo") /= path("c:/bar"); // yieldspath("c:/bar")
path("foo") /= path("c:"); // yieldspath("c:")
path("c:") /= path(""); // yieldspath("c:")
path("c:foo") /= path("/bar"); // yieldspath("c:/bar")
path("c:foo") /= path("c:bar"); // yieldspath("c:foo\\bar")
—end example]
5 Returns: *this.
template<class Source>
path& operator/=(const Source& source);
template<class Source>
path& append(const Source& source);
6 Effects: Equivalent to:return operator/=(path(source));
template<class InputIterator>
path& append(InputIterator first, InputIterator last);
7 Effects: Equivalent to:return operator/=(path(first, last));
31.12.6.5.4 Concatenation [fs.path.concat]
path& operator+=(const path& x);
path& operator+=(const string_type& x);
path& operator+=(basic_string_view<value_type> x);
path& operator+=(const value_type* x);
template<class Source>
path& operator+=(const Source& x);
template<class Source>
path& concat(const Source& x);
1 Effects: Appends path(x).native() to the pathname in the native format.
[Note 1: This directly manipulates the value ofnative(), which is not necessarily portable between operating
systems. —end note]
2 Returns: *this.
§ 31.12.6.5.4 © ISO/IEC
2114

===== PAGE 2126 =====

Dxxxx
path& operator+=(value_type x);
template<class EcharT>
path& operator+=(EcharT x);
3 Effects: Equivalent to:return *this += basic_string_view(&x, 1);
template<class InputIterator>
path& concat(InputIterator first, InputIterator last);
4 Effects: Equivalent to:return *this += path(first, last);
31.12.6.5.5 Modifiers [fs.path.modifiers]
void clear() noexcept;
1 Postconditions: empty() is true.
path& make_preferred();
2 Effects: Eachdirectory-separator of the pathname in the generic format is converted topreferred-separator.
3 Returns: *this.
4 [Example 1:
path p("foo/bar");
std::cout << p << '\n';
p.make_preferred();
std::cout << p << '\n';
On an operating system wherepreferred-separator is a slash, the output is:
"foo/bar"
"foo/bar"
On an operating system wherepreferred-separator is a backslash, the output is:
"foo/bar"
"foo\bar"
—end example]
path& remove_filename();
5 Effects: Remove the generic format pathname offilename() from the generic format pathname.
6 Postconditions: !has_filename().
7 Returns: *this.
8 [Example 2:
path("foo/bar").remove_filename(); // yields"foo/"
path("foo/").remove_filename(); // yields"foo/"
path("/foo").remove_filename(); // yields"/"
path("/").remove_filename(); // yields"/"
—end example]
path& replace_filename(const path& replacement);
9 Effects: Equivalent to:
remove_filename();
operator/=(replacement);
10 Returns: *this.
11 [Example 3:
path("/foo").replace_filename("bar"); // yields"/bar" on POSIX
path("/").replace_filename("bar"); // yields"/bar" on POSIX
—end example]
path& replace_extension(const path& replacement = path());
12 Effects:
—(12.1) Any existingextension() (31.12.6.5.9) is removed from the pathname in the generic format, then
§ 31.12.6.5.5 © ISO/IEC
2115

===== PAGE 2127 =====

Dxxxx
—(12.2) If replacement is not empty and does not begin with a dot character, a dot character is appended
to the pathname in the generic format, then
—(12.3) operator+=(replacement);.
13 Returns: *this.
void swap(path& rhs) noexcept;
14 Effects: Swaps the contents (in all formats) of the two paths.
15 Complexity: Constant time.
31.12.6.5.6 Native format observers [fs.path.native.obs]
1 The string returned by all native format observers is in the native pathname format (31.12.6).
const string_type& native() const noexcept;
2 Returns: The pathname in the native format.
const value_type* c_str() const noexcept;
3 Effects: Equivalent to:return native().c_str();
operator string_type() const;
4 Returns: native().
template<class EcharT, class traits = char_traits<EcharT>, class Allocator = allocator<EcharT>>
basic_string<EcharT, traits, Allocator> string(const Allocator& a = Allocator()) const;
5 Returns: native().
6 Remarks: All memory allocation, including for the return value, shall be performed bya. Conversion,
if any, is specified by 31.12.6.3.
std::string system_encoded_string() const;
std::wstring wstring() const;
std::u8string u8string() const;
std::u16string u16string() const;
std::u32string u32string() const;
7 Returns: native().
8 Remarks: Conversion, if any, is performed as specified by 31.12.6.3.
std::string display_string() const;
9 Returns: std::format("{}", *this).
[Note 1: The returned string is suitable for use with formatting (28.5.5) and print functions (31.7.10).—end
note]
31.12.6.5.7 Generic format observers [fs.path.generic.obs]
1 Generic format observer functions return strings formatted according to the generic pathname format
(31.12.6.2). A single slash (’/’) character is used as thedirectory-separator.
2 [Example 1: On an operating system that uses backslash as itspreferred-separator,
path("foo\\bar").generic_string()
returns "foo/bar". —end example]
template<class EcharT, class traits = char_traits<EcharT>, class Allocator = allocator<EcharT>>
basic_string<EcharT, traits, Allocator> generic_string(const Allocator& a = Allocator()) const;
3 Returns: The pathname in the generic format.
4 Remarks: All memory allocation, including for the return value, shall be performed bya. Conversion,
if any, is specified by 31.12.6.3.
std::string generic_system_encoded_string() const;
std::wstring generic_wstring() const;
std::u8string generic_u8string() const;
std::u16string generic_u16string() const;
§ 31.12.6.5.7 © ISO/IEC
2116

===== PAGE 2128 =====

Dxxxx
std::u32string generic_u32string() const;
5 Returns: The pathname in the generic format.
6 Remarks: Conversion, if any, is specified by 31.12.6.3.
std::string generic_display_string() const;
7 Returns: std::format("{:g}", *this).
[Note 1: The returned string is suitable for use with formatting (28.5.5) and print functions (31.7.10).—end
note]
31.12.6.5.8 Compare [fs.path.compare]
int compare(const path& p) const noexcept;
1 Returns:
—(1.1) Let rootNameComparison be the result of this->root_name().native().compare(p.root_-
name().native()). If rootNameComparison is not0, rootNameComparison.
—(1.2) Otherwise, if!this->has_root_directory() and p.has_root_directory(), a value less than
0.
—(1.3) Otherwise, if this->has_root_directory() and !p.has_root_directory(), a value greater
than 0.
—(1.4) Otherwise, if native() for the elements ofthis->relative_path() are lexicographically less
than native() for the elements ofp.relative_path(), a value less than0.
—(1.5) Otherwise, ifnative() for the elements ofthis->relative_path() are lexicographically greater
than native() for the elements ofp.relative_path(), a value greater than0.
—(1.6) Otherwise, 0.
int compare(const string_type& s) const;
int compare(basic_string_view<value_type> s) const;
int compare(const value_type* s) const;
2 Effects: Equivalent to:return compare(path(s));
31.12.6.5.9 Decomposition [fs.path.decompose]
path root_name() const;
1 Returns: root-name, if the pathname in the generic format includesroot-name, otherwisepath().
path root_directory() const;
2 Returns: root-directory, if the pathname in the generic format includesroot-directory, otherwisepath().
path root_path() const;
3 Returns: root_name() / root_directory().
path relative_path() const;
4 Returns: A path composed from the pathname in the generic format, ifempty() is false, beginning
with the firstfilename after root_path(). Otherwise, path().
path parent_path() const;
5 Returns: *this if has_relative_path() is false, otherwise a path whose generic format pathname
is the longest prefix of the generic format pathname of*this that produces one fewer element in its
iteration.
path filename() const;
6 Returns: relative_path().empty() ? path() : *--end().
7 [Example 1:
path("/foo/bar.txt").filename(); // yields"bar.txt"
path("/foo/bar").filename(); // yields"bar"
path("/foo/bar/").filename(); // yields""
§ 31.12.6.5.9 © ISO/IEC
2117

===== PAGE 2129 =====

Dxxxx
path("/").filename(); // yields""
path("//host").filename(); // yields""
path(".").filename(); // yields"."
path("..").filename(); // yields".."
—end example]
path stem() const;
8 Returns: Let f be the generic format pathname offilename(). Returns a path whose pathname in
the generic format is
—(8.1) f, if it contains no periods other than a leading period or consists solely of one or two periods;
—(8.2) otherwise, the prefix off ending before its last period.
9 [Example 2:
std::cout << path("/foo/bar.txt").stem(); // outputs"bar"
path p = "foo.bar.baz.tar";
for (; !p.extension().empty(); p = p.stem())
std::cout << p.extension() << '\n';
// outputs: .tar
// .baz
// .bar
—end example]
path extension() const;
10 Returns: A path whose pathname in the generic format is the suffix offilename() not included in
stem().
11 [Example 3:
path("/foo/bar.txt").extension(); // yields".txt" and stem() is "bar"
path("/foo/bar").extension(); // yields"" and stem() is "bar"
path("/foo/.profile").extension(); // yields"" and stem() is ".profile"
path(".bar").extension(); // yields"" and stem() is ".bar"
path("..bar").extension(); // yields".bar" and stem() is "."
—end example]
12 [Note 1: The period is included in the return value so that it is possible to distinguish between no extension
and an empty extension.—end note]
13 [Note 2: On non-POSIX operating systems, for a pathp, it is possible thatp.stem() + p.extension() ==
p.filename() is false, even though the generic format pathnames are the same.—end note]
31.12.6.5.10 Query [fs.path.query]
bool empty() const noexcept;
1 Returns: true if the pathname in the generic format is empty, otherwisefalse.
bool has_root_path() const;
2 Returns: !root_path().empty().
bool has_root_name() const;
3 Returns: !root_name().empty().
bool has_root_directory() const;
4 Returns: !root_directory().empty().
bool has_relative_path() const;
5 Returns: !relative_path().empty().
bool has_parent_path() const;
6 Returns: !parent_path().empty().
§ 31.12.6.5.10 © ISO/IEC
2118

===== PAGE 2130 =====

Dxxxx
bool has_filename() const;
7 Returns: !filename().empty().
bool has_stem() const;
8 Returns: !stem().empty().
bool has_extension() const;
9 Returns: !extension().empty().
bool is_absolute() const;
10 Returns: true if the pathname in the native format contains an absolute path (31.12.6), otherwise
false.
11 [Example 1: path("/").is_absolute() is true for POSIX-based operating systems, andfalse for Windows-
based operating systems. —end example]
bool is_relative() const;
12 Returns: !is_absolute().
31.12.6.5.11 Generation [fs.path.gen]
path lexically_normal() const;
1 Returns: A path whose pathname in the generic format is the normal form (31.12.6.2) of the pathname
in the generic format of*this.
2 [Example 1:
assert(path("foo/./bar/..").lexically_normal() == "foo/");
assert(path("foo/.///bar/../").lexically_normal() == "foo/");
The above assertions will succeed. On Windows, the returned path’sdirectory-separator characters will be
backslashes rather than slashes, but that does not affectpath equality. —end example]
path lexically_relative(const path& base) const;
3 Effects: If:
—(3.1) root_name() != base.root_name() is true, or
—(3.2) is_absolute() != base.is_absolute() is true, or
—(3.3) !has_root_directory() && base.has_root_directory() is true, or
—(3.4) any filename in relative_path() or base.relative_path() can be interpreted as aroot-name,
returns path().
[Note 1: On a POSIX implementation, nofilename in arelative-path is acceptable as aroot-name. —end note]
Determines the first mismatched element of*this and base as if by:
auto [a, b] = mismatch(begin(), end(), base.begin(), base.end());
Then,
—(3.5) if a == end() and b == base.end(), returnspath("."); otherwise
—(3.6) let n be the number offilename elements in[b,base.end()) that are not dot or dot-dot or empty,
minus the number that are dot-dot. Ifn<0, returns path(); otherwise
—(3.7) if n == 0 and (a == end() || a->empty()), returnspath("."); otherwise
—(3.8) returns an object of classpath that is default-constructed, followed by
—(3.8.1) application ofoperator/=(path("..")) ntimes, and then
—(3.8.2) application ofoperator/= for each element in[a,end()).
4 Returns: *this made relative tobase. Does not resolve (31.12.6) symlinks. Does not first normalize
(31.12.6.2) *this or base.
5 [Example 2:
assert(path("/a/d").lexically_relative("/a/b/c") == "../../d");
assert(path("/a/b/c").lexically_relative("/a/d") == "../b/c");
§ 31.12.6.5.11 © ISO/IEC
2119

===== PAGE 2131 =====

Dxxxx
assert(path("a/b/c").lexically_relative("a") == "b/c");
assert(path("a/b/c").lexically_relative("a/b/c/x/y") == "../..");
assert(path("a/b/c").lexically_relative("a/b/c") == ".");
assert(path("a/b").lexically_relative("c/d") == "../../a/b");
The above assertions will succeed. On Windows, the returned path’sdirectory-separator characters will be
backslashes rather than slashes, but that does not affectpath equality. —end example]
6 [Note 2: If symlink following semantics are desired, use the operational functionrelative(). —end note]
7 [Note 3: If normalization (31.12.6.2) is needed to ensure consistent matching of elements, applylexically_-
normal() to *this, base, or both. —end note]
path lexically_proximate(const path& base) const;
8 Returns: If the value oflexically_relative(base) is not an empty path, return it. Otherwise return
*this.
9 [Note 4: If symlink following semantics are desired, use the operational functionproximate(). —end note]
10 [Note 5: If normalization (31.12.6.2) is needed to ensure consistent matching of elements, applylexically_-
normal() to *this, base, or both. —end note]
31.12.6.6 Iterators [fs.path.itr]
1 Path iterators iterate over the elements of the pathname in the generic format (31.12.6.2).
2 A path::iterator is a constant iterator meeting all the requirements of a bidirectional iterator (24.3.5.6)
except that, for dereferenceable iteratorsaandbof typepath::iteratorwitha == b, there is no requirement
that *a and *b are bound to the same object. Itsvalue_type is path.
3 Calling any non-const member function of apath object invalidates all iterators referring to elements of that
object.
4 For the elements of the pathname in the generic format, the forward traversal order is as follows:
—(4.1) The root-name element, if present.
—(4.2) The root-directory element, if present.
[Note 1: It is possible that the use of the generic format is needed to ensure correct lexicographical comparison.
—end note]
—(4.3) Each successivefilename element, if present.
—(4.4) An empty element, if a trailing non-rootdirectory-separator is present.
5 The backward traversal order is the reverse of forward traversal.
iterator begin() const;
6 Returns: An iterator for the first present element in the traversal list above. If no elements are present,
the end iterator.
iterator end() const;
7 Returns: The end iterator.
31.12.6.7 Inserter and extractor [fs.path.io]
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const path& p);
1 Effects: Equivalent toos << quoted(p.string<charT, traits>()).
[Note 1: The quoted function is described in 31.7.9.—end note]
2 Returns: os.
template<class charT, class traits>
friend basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, path& p);
3 Effects: Equivalent to:
basic_string<charT, traits> tmp;
is >> quoted(tmp);
§ 31.12.6.7 © ISO/IEC
2120

===== PAGE 2132 =====

Dxxxx
p = tmp;
4 Returns: is.
31.12.6.8 Non-member functions [fs.path.nonmember]
void swap(path& lhs, path& rhs) noexcept;
1 Effects: Equivalent tolhs.swap(rhs).
size_t hash_value(const path& p) noexcept;
2 Returns: A hash value for the pathp. If for two paths,p1 == p2 then hash_value(p1) == hash_-
value(p2).
friend bool operator==(const path& lhs, const path& rhs) noexcept;
3 Returns: lhs.compare(rhs) == 0.
4 [Note 1: Path equality and path equivalence have different semantics.
—(4.1) Equality is determined by thepath non-member operator==, which considers the two paths’ lexical
representations only.
[Example 1: path("foo") == "bar" is nevertrue. —end example]
—(4.2) Equivalence is determined by theequivalent() non-member function, which determines if two paths
resolve (31.12.6) to the same file system entity.
[Example 2: equivalent("foo", "bar") will betrue when both paths resolve to the same file.—end
example]
—end note]
friend strong_ordering operator<=>(const path& lhs, const path& rhs) noexcept;
5 Returns: lhs.compare(rhs) <=> 0.
friend path operator/(const path& lhs, const path& rhs);
6 Effects: Equivalent to:return path(lhs) /= rhs;
31.12.6.9 Formatting support [fs.path.fmtr]
31.12.6.9.1 Formatting support overview [fs.path.fmtr.general]
namespace std {
template<class charT> struct formatter<filesystem::path, charT> {
constexpr void set_debug_format();
constexpr typename basic_format_parse_context<charT>::iterator
parse(basic_format_parse_context<charT>& ctx);
template<class FormatContext>
typename FormatContext::iterator
format(const filesystem::path& path, FormatContext& ctx) const;
};
}
31.12.6.9.2 Formatting support functions [fs.path.fmtr.funcs]
1 Formatting of paths uses formatting specifiers of the form
path-format-spec:
fill-and-alignopt widthopt ?opt gopt
where the productionsfill-and-align and width are described in 28.5.2. If the? option is used then the path is
formatted as an escaped string (28.5.6.5).
constexpr void set_debug_format();
2 Effects: Modifies the state of theformatter to be as if thepath-format-spec parsed by the last call to
parse contained the? option.
§ 31.12.6.9.2 © ISO/IEC
2121

===== PAGE 2133 =====

Dxxxx
constexpr typename basic_format_parse_context<charT>::iterator
parse(basic_format_parse_context<charT>& ctx);
3 Effects: Parses the format specifier as apath-format-spec and stores the parsed specifiers in*this.
4 Returns: An iterator past the end of thepath-format-spec.
template<class FormatContext>
typename FormatContext::iterator
format(const filesystem::path& p, FormatContext& ctx) const;
5 Effects: Let s be p.generic_string<filesystem::path::value_type>() if the g option is used,
otherwise p.native(). Writess into ctx.out(), adjusted according to thepath-format-spec. If charT
is char, path::value_type is wchar_t, and the literal encoding is UTF-8, then the escaped path is
transcoded from the native encoding for wide character strings to UTF-8 with maximal subparts of
ill-formed subsequences substituted withu+fffd replacement characterper the Unicode Standard,
Chapter 3.9u+fffd Substitution in Conversion. IfcharT and path::value_type are the same then
no transcoding is performed. Otherwise, transcoding is implementation-defined.
6 Returns: An iterator past the end of the output range.
31.12.6.10 Hash support [fs.path.hash]
template<> struct hash<filesystem::path>;
1 For an objectp of type filesystem::path, hash<filesystem::path>()(p) evaluates to the same
result asfilesystem::hash_value(p).
31.12.7 Class filesystem_error [fs.class.filesystem.error]
31.12.7.1 General [fs.class.filesystem.error.general]
namespace std::filesystem {
class filesystem_error : public system_error {
public:
filesystem_error(const string& what_arg, error_code ec);
filesystem_error(const string& what_arg,
const path& p1, error_code ec);
filesystem_error(const string& what_arg,
const path& p1, const path& p2, error_code ec);
const path& path1() const noexcept;
const path& path2() const noexcept;
const char* what() const noexcept override;
};
}
1 The classfilesystem_error defines the type of objects thrown as exceptions to report file system errors
from functions described in subclause 31.12.
31.12.7.2 Members [fs.filesystem.error.members]
1 Constructors are provided that store zero, one, or two paths associated with an error.
filesystem_error(const string& what_arg, error_code ec);
2 Postconditions:
—(2.1) code() == ec is true,
—(2.2) path1().empty() is true,
—(2.3) path2().empty() is true, and
—(2.4) string_view(what()).find(what_arg.c_str()) != string_view::nposis true.
filesystem_error(const string& what_arg, const path& p1, error_code ec);
3 Postconditions:
—(3.1) code() == ec is true,
—(3.2) path1() returns a reference to the stored copy ofp1,
§ 31.12.7.2 © ISO/IEC
2122

===== PAGE 2134 =====

Dxxxx
—(3.3) path2().empty() is true, and
—(3.4) string_view(what()).find(what_arg.c_str()) != string_view::nposis true.
filesystem_error(const string& what_arg, const path& p1, const path& p2, error_code ec);
4 Postconditions:
—(4.1) code() == ec,
—(4.2) path1() returns a reference to the stored copy ofp1,
—(4.3) path2() returns a reference to the stored copy ofp2, and
—(4.4) string_view(what()).find(what_arg.c_str()) != string_view::npos.
const path& path1() const noexcept;
5 Returns: A reference to the copy ofp1 stored by the constructor, or, if none, an empty path.
const path& path2() const noexcept;
6 Returns: A reference to the copy ofp2 stored by the constructor, or, if none, an empty path.
const char* what() const noexcept override;
7 Returns: An ntbs that incorporates thewhat_arg argument supplied to the constructor. The exact
format is unspecified. Implementations should include thesystem_error::what() string and the
pathnames ofpath1 and path2 in the native format in the returned string.
31.12.8 Enumerations [fs.enum]
31.12.8.1 Enum path::format [fs.enum.path.format]
1 This enum specifies constants used to identify the format of the character sequence, with the meanings listed
in Table 148.
Table 148 — Enumpath::format [tab:fs.enum.path.format]
Name Meaning
native_format The native pathname format.
generic_format The generic pathname format.
auto_format The interpretation of the format of the character sequence is imple-
mentation-defined. The implementation may inspect the content of
the character sequence to determine the format.
Recommended practice: For POSIX-based systems, native and
generic formats are equivalent and the character sequence should
always be interpreted in the same way.
31.12.8.2 Enum class file_type [fs.enum.file.type]
1 This enum class specifies constants used to identify file types, with the meanings listed in Table 149. The
values of the constants are distinct.
31.12.8.3 Enum class copy_options [fs.enum.copy.opts]
1 The enum class type copy_options is a bitmask type (16.3.3.3.3) that specifies bitmask constants used to
control the semantics of copy operations. The constants are specified in option groups with the meanings
listed in Table 150. The constantnone represents the empty bitmask, and is shown in each option group for
purposes of exposition; implementations shall provide only a single definition. Every other constant in the
table represents a distinct bitmask element.
31.12.8.4 Enum class perms [fs.enum.perms]
1 The enum class type perms is a bitmask type (16.3.3.3.3) that specifies bitmask constants used to identify
file permissions, with the meanings listed in Table 151.
§ 31.12.8.4 © ISO/IEC
2123

===== PAGE 2135 =====

Dxxxx
Table 149 — Enum classfile_type [tab:fs.enum.file.type]
Constant Meaning
none The type of the file has not been determined or an error occurred while
trying to determine the type.
not_found Pseudo-type indicating the file was not found.
[Note 1: The file not being found is not considered an error while determining
the type of a file.—end note]
regular Regular file
directory Directory file
symlink Symbolic link file
block Block special file
character Character special file
fifo FIFO or pipe file
socket Socket file
implementation-defined Implementations that support file systems having file types in addition to
the abovefile_type types shall supply implementation-definedfile_type
constants to separately identify each of those additional file types
unknown The file exists but the type cannot be determined
Table 150 — Enum classcopy_options [tab:fs.enum.copy.opts]
Option group controllingcopy_file function effects for existing target files
Constant Meaning
none (Default) Error; file already exists.
skip_existing Do not overwrite existing file, do not report an error.
overwrite_existing Overwrite the existing file.
update_existing Overwrite the existing file if it is older than the replacement file.
Option group controllingcopy function effects for subdirectories
Constant Meaning
none (Default) Do not copy subdirectories.
recursive Recursively copy subdirectories and their contents.
Option group controllingcopy function effects for symbolic links
Constant Meaning
none (Default) Follow symbolic links.
copy_symlinks Copy symbolic links as symbolic links rather than copying the files
that they point to.
skip_symlinks Ignore symbolic links.
Option group controllingcopy function effects for choosing the form of copying
Constant Meaning
none (Default) Copy content.
directories_only Copy directory structure only, do not copy non-directory files.
create_symlinks Make symbolic links instead of copies of files. The source path shall
be an absolute path unless the destination path is in the current
directory.
create_hard_links Make hard links instead of copies of files.
§ 31.12.8.4 © ISO/IEC
2124

===== PAGE 2136 =====

Dxxxx
Table 151 — Enum classperms [tab:fs.enum.perms]
Name Value POSIX Definition or notes
(octal) macro
none 0 There are no permissions set for the file.
owner_read 0400 S_IRUSR Read permission, owner
owner_write 0200 S_IWUSR Write permission, owner
owner_exec 0100 S_IXUSR Execute/search permission, owner
owner_all 0700 S_IRWXU Read, write, execute/search by owner;
owner_read | owner_write | owner_exec
group_read 040 S_IRGRP Read permission, group
group_write 020 S_IWGRP Write permission, group
group_exec 010 S_IXGRP Execute/search permission, group
group_all 070 S_IRWXG Read, write, execute/search by group;
group_read | group_write | group_exec
others_read 04 S_IROTH Read permission, others
others_write 02 S_IWOTH Write permission, others
others_exec 01 S_IXOTH Execute/search permission, others
others_all 07 S_IRWXO Read, write, execute/search by others;
others_read | others_write | others_exec
all 0777 owner_all | group_all | others_all
set_uid 04000 S_ISUID Set-user-ID on execution
set_gid 02000 S_ISGID Set-group-ID on execution
sticky_bit 01000 S_ISVTX Operating system dependent.
mask 07777 all | set_uid | set_gid | sticky_bit
unknown 0xFFFF The permissions are not known, such as when afile_-
status object is created without specifying the per-
missions
31.12.8.5 Enum class perm_options [fs.enum.perm.opts]
1 The enum class type perm_options is a bitmask type (16.3.3.3.3) that specifies bitmask constants used
to control the semantics of permissions operations, with the meanings listed in Table 152. The bitmask
constants are bitmask elements. In Table 152perm denotes a value of typeperms passed topermissions.
Table 152 — Enum classperm_options [tab:fs.enum.perm.opts]
Name Meaning
replace permissions shall replace the file’s permission bits withperm
add permissions shall replace the file’s permission bits with the bitwiseor of
perm and the file’s current permission bits.
remove permissions shall replace the file’s permission bits with the bitwiseand of
the complement ofperm and the file’s current permission bits.
nofollow permissions shall change the permissions of a symbolic link itself rather
than the permissions of the file the link resolves to.
31.12.8.6 Enum class directory_options [fs.enum.dir.opts]
1 The enum class type directory_options is a bitmask type (16.3.3.3.3) that specifies bitmask constants
used to identify directory traversal options, with the meanings listed in Table 153. The constantnone
represents the empty bitmask; every other constant in the table represents a distinct bitmask element.
31.12.9 Class file_status [fs.class.file.status]
31.12.9.1 General [fs.class.file.status.general]
namespace std::filesystem {
class file_status {
§ 31.12.9.1 © ISO/IEC
2125

===== PAGE 2137 =====

Dxxxx
Table 153 — Enum classdirectory_options [tab:fs.enum.dir.opts]
Name Meaning
none (Default) Skip directory symlinks, permission de-
nied is an error.
follow_directory_symlink Follow rather than skip directory symlinks.
skip_permission_denied Skip directories that would otherwise result in per-
mission denied.
public:
// 31.12.9.2, constructors and destructor
file_status() noexcept : file_status(file_type::none) {}
explicit file_status(file_type ft,
perms prms = perms::unknown) noexcept;
file_status(const file_status&) noexcept = default;
file_status(file_status&&) noexcept = default;
~file_status();
// assignments
file_status& operator=(const file_status&) noexcept = default;
file_status& operator=(file_status&&) noexcept = default;
// 31.12.9.4, modifiers
void type(file_type ft) noexcept;
void permissions(perms prms) noexcept;
// 31.12.9.3, observers
file_type type() const noexcept;
perms permissions() const noexcept;
friend bool operator==(const file_status& lhs, const file_status& rhs) noexcept
{ return lhs.type() == rhs.type() && lhs.permissions() == rhs.permissions(); }
};
}
1 An object of typefile_status stores information about the type and permissions of a file.
31.12.9.2 Constructors [fs.file.status.cons]
explicit file_status(file_type ft, perms prms = perms::unknown) noexcept;
1 Postconditions: type() == ft and permissions() == prms.
31.12.9.3 Observers [fs.file.status.obs]
file_type type() const noexcept;
1 Returns: The value oftype() specified by the postconditions of the most recent call to a constructor,
operator=, ortype(file_type) function.
perms permissions() const noexcept;
2 Returns: The value ofpermissions() specified by the postconditions of the most recent call to a
constructor, operator=, orpermissions(perms) function.
31.12.9.4 Modifiers [fs.file.status.mods]
void type(file_type ft) noexcept;
1 Postconditions: type() == ft.
void permissions(perms prms) noexcept;
2 Postconditions: permissions() == prms.
§ 31.12.9.4 © ISO/IEC
2126

===== PAGE 2138 =====

Dxxxx
31.12.10 Class directory_entry [fs.class.directory.entry]
31.12.10.1 General [fs.class.directory.entry.general]
namespace std::filesystem {
class directory_entry {
public:
// 31.12.10.2, constructors and destructor
directory_entry() noexcept = default;
directory_entry(const directory_entry&) = default;
directory_entry(directory_entry&&) noexcept = default;
explicit directory_entry(const filesystem::path& p);
directory_entry(const filesystem::path& p, error_code& ec);
~directory_entry();
// assignments
directory_entry& operator=(const directory_entry&) = default;
directory_entry& operator=(directory_entry&&) noexcept = default;
// 31.12.10.3, modifiers
void assign(const filesystem::path& p);
void assign(const filesystem::path& p, error_code& ec);
void replace_filename(const filesystem::path& p);
void replace_filename(const filesystem::path& p, error_code& ec);
void refresh();
void refresh(error_code& ec) noexcept;
// 31.12.10.4, observers
const filesystem::path& path() const noexcept;
operator const filesystem::path&() const noexcept;
bool exists() const;
bool exists(error_code& ec) const noexcept;
bool is_block_file() const;
bool is_block_file(error_code& ec) const noexcept;
bool is_character_file() const;
bool is_character_file(error_code& ec) const noexcept;
bool is_directory() const;
bool is_directory(error_code& ec) const noexcept;
bool is_fifo() const;
bool is_fifo(error_code& ec) const noexcept;
bool is_other() const;
bool is_other(error_code& ec) const noexcept;
bool is_regular_file() const;
bool is_regular_file(error_code& ec) const noexcept;
bool is_socket() const;
bool is_socket(error_code& ec) const noexcept;
bool is_symlink() const;
bool is_symlink(error_code& ec) const noexcept;
uintmax_t file_size() const;
uintmax_t file_size(error_code& ec) const noexcept;
uintmax_t hard_link_count() const;
uintmax_t hard_link_count(error_code& ec) const noexcept;
file_time_type last_write_time() const;
file_time_type last_write_time(error_code& ec) const noexcept;
file_status status() const;
file_status status(error_code& ec) const noexcept;
file_status symlink_status() const;
file_status symlink_status(error_code& ec) const noexcept;
bool operator==(const directory_entry& rhs) const noexcept;
strong_ordering operator<=>(const directory_entry& rhs) const noexcept;
// 31.12.10.5, inserter
template<class charT, class traits>
friend basic_ostream<charT, traits>&
§ 31.12.10.1 © ISO/IEC
2127

===== PAGE 2139 =====

Dxxxx
operator<<(basic_ostream<charT, traits>& os, const directory_entry& d);
private:
filesystem::path path-object ; // exposition only
};
}
1 A directory_entry object stores apath object and may store additional objects for file attributes such as
hard link count, status, symlink status, file size, and last write time.
2 Implementations should store such additional file attributes during directory iteration if their values are avail-
able and storing the values would allow the implementation to eliminate file system accesses bydirectory_-
entry observer functions (31.12.13). Such stored file attribute values are said to becached.
3 [Note 1: directory_iterator can cache already available attribute values directly into adirectory_entry object
without the cost of a call torefresh(). —end note]
4 [Example 1:
using namespace std::filesystem;
// use possibly cached last write time to minimize disk accesses
for (auto&& x : directory_iterator("."))
{
std::cout << x.path() << " " << x.last_write_time() << std::endl;
}
// call refresh() to refresh a stale cache
for (auto&& x : directory_iterator("."))
{
lengthy_function(x.path()); // cache becomes stale
x.refresh();
std::cout << x.path() << " " << x.last_write_time() << std::endl;
}
On implementations that do not cache the last write time, both loops will result in a potentially expensive call to the
std::filesystem::last_write_time function. On implementations that do cache the last write time, the first loop
will use the cached value and so will not result in a potentially expensive call to thestd::filesystem::last_write_-
time function. The code is portable to any implementation, regardless of whether or not it employs caching.—end
example]
31.12.10.2 Constructors [fs.dir.entry.cons]
explicit directory_entry(const filesystem::path& p);
directory_entry(const filesystem::path& p, error_code& ec);
1 Effects: Calls refresh() or refresh(ec), respectively.
2 Postconditions: path() == p if no error occurs, otherwisepath() == filesystem::path().
3 Throws: As specified in 31.12.5.
31.12.10.3 Modifiers [fs.dir.entry.mods]
void assign(const filesystem::path& p);
void assign(const filesystem::path& p, error_code& ec);
1 Effects: Equivalent topath-object = p, thenrefresh() or refresh(ec), respectively. If an error
occurs, the values of any cached attributes are unspecified.
2 Throws: As specified in 31.12.5.
void replace_filename(const filesystem::path& p);
void replace_filename(const filesystem::path& p, error_code& ec);
3 Effects: Equivalent topath-object .replace_filename(p), thenrefresh() or refresh(ec), respec-
tively. If an error occurs, the values of any cached attributes are unspecified.
4 Throws: As specified in 31.12.5.
§ 31.12.10.3 © ISO/IEC
2128

===== PAGE 2140 =====

Dxxxx
void refresh();
void refresh(error_code& ec) noexcept;
5 Effects: Stores the current values of any cached attributes of the filep resolves to. If an error occurs,
an error is reported (31.12.5) and the values of any cached attributes are unspecified.
6 Throws: As specified in 31.12.5.
7 [Note 1: Implementations ofdirectory_iterator (31.12.11) are prohibited from directly or indirectly calling
the refresh function as described in 31.12.11.1.—end note]
31.12.10.4 Observers [fs.dir.entry.obs]
1 Unqualified function names in theReturns: elements of thedirectory_entry observers described below
refer to members of thestd::filesystem namespace.
const filesystem::path& path() const noexcept;
operator const filesystem::path&() const noexcept;
2 Returns: path-object .
bool exists() const;
bool exists(error_code& ec) const noexcept;
3 Returns: exists(this->status()) or exists(this->status(ec)), respectively.
4 Throws: As specified in 31.12.5.
bool is_block_file() const;
bool is_block_file(error_code& ec) const noexcept;
5 Returns: is_block_file(this->status()) or is_block_file(this->status(ec)), respectively.
6 Throws: As specified in 31.12.5.
bool is_character_file() const;
bool is_character_file(error_code& ec) const noexcept;
7 Returns: is_character_file(this->status())oris_character_file(this->status(ec)), respec-
tively.
8 Throws: As specified in 31.12.5.
bool is_directory() const;
bool is_directory(error_code& ec) const noexcept;
9 Returns: is_directory(this->status()) or is_directory(this->status(ec)), respectively.
10 Throws: As specified in 31.12.5.
bool is_fifo() const;
bool is_fifo(error_code& ec) const noexcept;
11 Returns: is_fifo(this->status()) or is_fifo(this->status(ec)), respectively.
12 Throws: As specified in 31.12.5.
bool is_other() const;
bool is_other(error_code& ec) const noexcept;
13 Returns: is_other(this->status()) or is_other(this->status(ec)), respectively.
14 Throws: As specified in 31.12.5.
bool is_regular_file() const;
bool is_regular_file(error_code& ec) const noexcept;
15 Returns: is_regular_file(this->status()) or is_regular_file(this->status(ec)), respective-
ly.
16 Throws: As specified in 31.12.5.
bool is_socket() const;
bool is_socket(error_code& ec) const noexcept;
17 Returns: is_socket(this->status()) or is_socket(this->status(ec)), respectively.
§ 31.12.10.4 © ISO/IEC
2129

===== PAGE 2141 =====

Dxxxx
18 Throws: As specified in 31.12.5.
bool is_symlink() const;
bool is_symlink(error_code& ec) const noexcept;
19 Returns: is_symlink(this->symlink_status()) or is_symlink(this->symlink_status(ec)), re-
spectively.
20 Throws: As specified in 31.12.5.
uintmax_t file_size() const;
uintmax_t file_size(error_code& ec) const noexcept;
21 Returns: If cached, the file size attribute value. Otherwise,file_size(path()) or file_size(path(),
ec), respectively.
22 Throws: As specified in 31.12.5.
uintmax_t hard_link_count() const;
uintmax_t hard_link_count(error_code& ec) const noexcept;
23 Returns: If cached, the hard link count attribute value. Otherwise,hard_link_count(path()) or
hard_link_count(path(), ec), respectively.
24 Throws: As specified in 31.12.5.
file_time_type last_write_time() const;
file_time_type last_write_time(error_code& ec) const noexcept;
25 Returns: If cached, the last write time attribute value. Otherwise,last_write_time(path()) or
last_write_time(path(), ec), respectively.
26 Throws: As specified in 31.12.5.
file_status status() const;
file_status status(error_code& ec) const noexcept;
27 Returns: If cached, the status attribute value. Otherwise,status(path()) or status(path(), ec),
respectively.
28 Throws: As specified in 31.12.5.
file_status symlink_status() const;
file_status symlink_status(error_code& ec) const noexcept;
29 Returns: If cached, the symlink status attribute value. Otherwise, symlink_status(path()) or
symlink_status(path(), ec), respectively.
30 Throws: As specified in 31.12.5.
bool operator==(const directory_entry& rhs) const noexcept;
31 Returns: path-object == rhs.path-object .
strong_ordering operator<=>(const directory_entry& rhs) const noexcept;
32 Returns: path-object <=> rhs.path-object .
31.12.10.5 Inserter [fs.dir.entry.io]
template<class charT, class traits>
friend basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const directory_entry& d);
1 Effects: Equivalent to:return os << d.path();
31.12.11 Class directory_iterator [fs.class.directory.iterator]
31.12.11.1 General [fs.class.directory.iterator.general]
1 An object of typedirectory_iterator provides an iterator for a sequence ofdirectory_entry elements
representing the path and any cached attribute values (31.12.10) for each file in a directory or in an
implementation-defined directory-like file type.
[Note 1: For iteration into subdirectories, see classrecursive_directory_iterator (31.12.12). —end note]
§ 31.12.11.1 © ISO/IEC
2130

===== PAGE 2142 =====

Dxxxx
namespace std::filesystem {
class directory_iterator {
public:
using iterator_category = input_iterator_tag;
using value_type = directory_entry;
using difference_type = ptrdiff_t;
using pointer = const directory_entry*;
using reference = const directory_entry&;
// 31.12.11.2, member functions
directory_iterator() noexcept;
explicit directory_iterator(const path& p);
directory_iterator(const path& p, directory_options options);
directory_iterator(const path& p, error_code& ec);
directory_iterator(const path& p, directory_options options,
error_code& ec);
directory_iterator(const directory_iterator& rhs);
directory_iterator(directory_iterator&& rhs) noexcept;
~directory_iterator();
directory_iterator& operator=(const directory_iterator& rhs);
directory_iterator& operator=(directory_iterator&& rhs) noexcept;
const directory_entry& operator*() const;
const directory_entry* operator->() const;
directory_iterator& operator++();
directory_iterator& increment(error_code& ec);
bool operator==(default_sentinel_t) const noexcept {
return *this == directory_iterator();
}
// other members as required by 24.3.5.3, input iterators
};
}
2 directory_iterator meets theCpp17InputIterator requirements (24.3.5.3).
3 If an iterator of typedirectory_iterator reports an error or is advanced past the last directory element,
that iterator shall become equal to the end iterator value. Thedirectory_iterator default constructor
shall create an iterator equal to the end iterator value, and this shall be the only valid iterator for the end
condition.
4 The end iterator is not dereferenceable.
5 Two end iterators are always equal. An end iterator shall not be equal to a non-end iterator.
6 The result of calling the path() member of the directory_entry object obtained by dereferencing a
directory_iterator is a reference to apath object composed of the directory argument from which the
iterator was constructed with the filename of the directory entry appended as if byoperator/=.
7 Directory iteration shall not yield directory entries for the current (dot) and parent (dot-dot) directories.
8 The order of directory entries obtained by dereferencing successive increments of adirectory_iterator is
unspecified.
9 Constructors and non-const directory_iterator member functions store the values of any cached at-
tributes (31.12.10) in thedirectory_entry element returned byoperator*(). directory_iterator mem-
ber functions shall not directly or indirectly call anydirectory_entry refreshfunction.
[Note 2: The exact mechanism for storing cached attribute values is not exposed to users.—end note]
10 [Note 3: A path obtained by dereferencing a directory iterator might not actually exist; it could be a symbolic link to
a non-existent file. Recursively walking directory trees for purposes of removing and renaming entries might invalidate
symbolic links that are being followed.—end note]
11 [Note 4: If a file is removed from or added to a directory after the construction of adirectory_iterator for the
directory, it is unspecified whether or not subsequently incrementing the iterator will ever result in an iterator
referencing the removed or added directory entry. See POSIXreaddir. —end note]
§ 31.12.11.1 © ISO/IEC
2131

===== PAGE 2143 =====

Dxxxx
31.12.11.2 Members [fs.dir.itr.members]
directory_iterator() noexcept;
1 Effects: Constructs the end iterator.
explicit directory_iterator(const path& p);
directory_iterator(const path& p, directory_options options);
directory_iterator(const path& p, error_code& ec);
directory_iterator(const path& p, directory_options options, error_code& ec);
2 Effects: For the directory thatp resolves to, constructs an iterator for the first element in a sequence of
directory_entry elements representing the files in the directory, if any; otherwise the end iterator.
However, if
(options & directory_options::skip_permission_denied) != directory_options::none
and construction encounters an error indicating that permission to accessp is denied, constructs the
end iterator and does not report an error.
3 Throws: As specified in 31.12.5.
4 [Note 1: To iterate over the current directory, use directory_iterator(".") rather than directory_-
iterator(""). —end note]
directory_iterator(const directory_iterator& rhs);
directory_iterator(directory_iterator&& rhs) noexcept;
5 Postconditions: *this has the original value ofrhs.
directory_iterator& operator=(const directory_iterator& rhs);
directory_iterator& operator=(directory_iterator&& rhs) noexcept;
6 Effects: If *this and rhs are the same object, the member has no effect.
7 Postconditions: *this has the original value ofrhs.
8 Returns: *this.
directory_iterator& operator++();
directory_iterator& increment(error_code& ec);
9 Effects: As specified for the prefix increment operation of Input iterators (24.3.5.3).
10 Returns: *this.
11 Throws: As specified in 31.12.5.
31.12.11.3 Non-member functions [fs.dir.itr.nonmembers]
1 These functions enable range access fordirectory_iterator.
directory_iterator begin(directory_iterator iter) noexcept;
2 Returns: iter.
directory_iterator end(directory_iterator) noexcept;
3 Returns: directory_iterator().
31.12.12 Class recursive_directory_iterator [fs.class.rec.dir.itr]
31.12.12.1 General [fs.class.rec.dir.itr.general]
1 An object of typerecursive_directory_iterator provides an iterator for a sequence ofdirectory_entry
elements representing the files in a directory or in an implementation-defined directory-like file type, and its
subdirectories.
namespace std::filesystem {
class recursive_directory_iterator {
public:
using iterator_category = input_iterator_tag;
using value_type = directory_entry;
using difference_type = ptrdiff_t;
using pointer = const directory_entry*;
using reference = const directory_entry&;
§ 31.12.12.1 © ISO/IEC
2132

===== PAGE 2144 =====

Dxxxx
// 31.12.12.2, constructors and destructor
recursive_directory_iterator() noexcept;
explicit recursive_directory_iterator(const path& p);
recursive_directory_iterator(const path& p, directory_options options);
recursive_directory_iterator(const path& p, directory_options options,
error_code& ec);
recursive_directory_iterator(const path& p, error_code& ec);
recursive_directory_iterator(const recursive_directory_iterator& rhs);
recursive_directory_iterator(recursive_directory_iterator&& rhs) noexcept;
~recursive_directory_iterator();
// 31.12.12.2, observers
directory_options options() const;
int depth() const;
bool recursion_pending() const;
const directory_entry& operator*() const;
const directory_entry* operator->() const;
// 31.12.12.2, modifiers
recursive_directory_iterator&
operator=(const recursive_directory_iterator& rhs);
recursive_directory_iterator&
operator=(recursive_directory_iterator&& rhs) noexcept;
recursive_directory_iterator& operator++();
recursive_directory_iterator& increment(error_code& ec);
void pop();
void pop(error_code& ec);
void disable_recursion_pending();
bool operator==(default_sentinel_t) const noexcept {
return *this == recursive_directory_iterator();
}
// other members as required by 24.3.5.3, input iterators
};
}
2 Calling options, depth, recursion_pending, pop or disable_recursion_pending on an iterator that is
not dereferenceable results in undefined behavior.
3 The behavior of arecursive_directory_iterator is the same as adirectory_iterator unless otherwise
specified.
4 [Note 1: If the directory structure being iterated over contains cycles then it is possible that the end iterator is
unreachable. —end note]
31.12.12.2 Members [fs.rec.dir.itr.members]
recursive_directory_iterator() noexcept;
1 Effects: Constructs the end iterator.
explicit recursive_directory_iterator(const path& p);
recursive_directory_iterator(const path& p, directory_options options);
recursive_directory_iterator(const path& p, directory_options options, error_code& ec);
recursive_directory_iterator(const path& p, error_code& ec);
2 Effects: Constructs an iterator representing the first entry in the directory to whichp resolves, if any;
otherwise, the end iterator. However, if
(options & directory_options::skip_permission_denied) != directory_options::none
and construction encounters an error indicating that permission to accessp is denied, constructs the
end iterator and does not report an error.
§ 31.12.12.2 © ISO/IEC
2133

===== PAGE 2145 =====

Dxxxx
3 Postconditions: options() == options for the signatures with a directory_options argument,
otherwise options() == directory_options::none.
4 Throws: As specified in 31.12.5.
5 [Note 1: Use recursive_directory_iterator(".") rather thanrecursive_directory_iterator("") to iter-
ate over the current directory.—end note]
6 [Note 2: By default,recursive_directory_iterator does not follow directory symlinks. To follow directory
symlinks, specifyoptions as directory_options::follow_directory_symlink. —end note]
recursive_directory_iterator(const recursive_directory_iterator& rhs);
7 Postconditions:
—(7.1) options() == rhs.options()
—(7.2) depth() == rhs.depth()
—(7.3) recursion_pending() == rhs.recursion_pending()
recursive_directory_iterator(recursive_directory_iterator&& rhs) noexcept;
8 Postconditions: options(), depth(), andrecursion_pending() have the values thatrhs.options(),
rhs.depth(), andrhs.recursion_pending(), respectively, had before the function call.
recursive_directory_iterator& operator=(const recursive_directory_iterator& rhs);
9 Effects: If *this and rhs are the same object, the member has no effect.
10 Postconditions:
—(10.1) options() == rhs.options()
—(10.2) depth() == rhs.depth()
—(10.3) recursion_pending() == rhs.recursion_pending()
11 Returns: *this.
recursive_directory_iterator& operator=(recursive_directory_iterator&& rhs) noexcept;
12 Effects: If *this and rhs are the same object, the member has no effect.
13 Postconditions: options(), depth(), andrecursion_pending() have the values thatrhs.options(),
rhs.depth(), andrhs.recursion_pending(), respectively, had before the function call.
14 Returns: *this.
directory_options options() const;
15 Returns: The value of the argument passed to the constructor for theoptions parameter, if present,
otherwise directory_options::none.
16 Throws: Nothing.
int depth() const;
17 Returns: The current depth of the directory tree being traversed.
[Note 3: The initial directory is depth0, its immediate subdirectories are depth1, and so forth.—end note]
18 Throws: Nothing.
bool recursion_pending() const;
19 Returns: true if disable_recursion_pending() has not been called subsequent to the prior construc-
tion or increment operation, otherwisefalse.
20 Throws: Nothing.
recursive_directory_iterator& operator++();
recursive_directory_iterator& increment(error_code& ec);
21 Effects: As specified for the prefix increment operation of Input iterators (24.3.5.3), except that:
—(21.1) If there are no more entries at the current depth, then ifdepth() != 0 iteration over the parent
directory resumes; otherwise*this = recursive_directory_iterator().
§ 31.12.12.2 © ISO/IEC
2134

===== PAGE 2146 =====

Dxxxx
—(21.2) Otherwise if
recursion_pending() && is_directory((*this)->status()) &&
(!is_symlink((*this)->symlink_status()) ||
(options() & directory_options::follow_directory_symlink) != directory_options::none)
then either directory(*this)->path() is recursively iterated into or, if
(options() & directory_options::skip_permission_denied) != directory_options::none
and an error occurs indicating that permission to access directory(*this)->path() is denied,
then directory(*this)->path() is treated as an empty directory and no error is reported.
22 Returns: *this.
23 Throws: As specified in 31.12.5.
void pop();
void pop(error_code& ec);
24 Effects: If depth() == 0, set*this to recursive_directory_iterator(). Otherwise, cease iteration
of the directory currently being iterated over, and continue iteration over the parent directory.
25 Throws: As specified in 31.12.5.
26 Remarks: Any copies of the previous value of*this are no longer required to be dereferenceable nor to be in
the domain of==.
void disable_recursion_pending();
27 Postconditions: recursion_pending() == false.
28 [Note 4: disable_recursion_pending() is used to prevent unwanted recursion into a directory.—end note]
31.12.12.3 Non-member functions [fs.rec.dir.itr.nonmembers]
1 These functions enable use ofrecursive_directory_iterator with range-basedfor statements.
recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;
2 Returns: iter.
recursive_directory_iterator end(recursive_directory_iterator) noexcept;
3 Returns: recursive_directory_iterator().
31.12.13 Filesystem operation functions [fs.op.funcs]
31.12.13.1 General [fs.op.funcs.general]
1 Filesystem operation functions query or modify files, including directories, in external storage.
2 [Note 1: Because hardware failures, network failures, file system races (31.12.2.4), and many other kinds of errors
occur frequently in file system operations, any filesystem operation function, no matter how apparently innocuous,
can encounter an error; see 31.12.5.—end note]
31.12.13.2 Absolute [fs.op.absolute]
path filesystem::absolute(const path& p);
path filesystem::absolute(const path& p, error_code& ec);
1 Effects: Composes an absolute path referencing the same file system location asp according to the
operating system (31.12.2.3).
2 Returns: The composed path. The signature with argumentec returns path() if an error occurs.
3 [Note 1: For the returned path,rp, rp.is_absolute() is true unless an error occurs.—end note]
4 Throws: As specified in 31.12.5.
5 [Note 2: To resolve symlinks or perform other sanitization that can involve queries to secondary storage, such
as hard disks, considercanonical (31.12.13.3). —end note]
6 [Note 3: Implementations are strongly encouraged to not query secondary storage, and not consider!exists(p)
an error. —end note]
7 [Example 1: For POSIX-based operating systems,absolute(p) is simplycurrent_path()/p. For Windows-
based operating systems,absolute might have the same semantics asGetFullPathNameW. —end example]
§ 31.12.13.2 © ISO/IEC
2135

===== PAGE 2147 =====

Dxxxx
31.12.13.3 Canonical [fs.op.canonical]
path filesystem::canonical(const path& p);
path filesystem::canonical(const path& p, error_code& ec);
1 Effects: Converts p to an absolute path that has no symbolic link, dot, or dot-dot elements in its
pathname in the generic format.
2 Returns: A path that refers to the same file system object asabsolute(p). The signature with
argument ec returns path() if an error occurs.
3 Throws: As specified in 31.12.5.
4 Remarks: !exists(p) is an error.
31.12.13.4 Copy [fs.op.copy]
void filesystem::copy(const path& from, const path& to);
1 Effects: Equivalent tocopy(from, to, copy_options::none).
void filesystem::copy(const path& from, const path& to, error_code& ec);
2 Effects: Equivalent tocopy(from, to, copy_options::none, ec).
void filesystem::copy(const path& from, const path& to, copy_options options);
void filesystem::copy(const path& from, const path& to, copy_options options,
error_code& ec);
3 Preconditions: At most one element from each option group (31.12.8.3) is set inoptions.
4 Effects: Before the first use off and t:
—(4.1) If
(options & copy_options::create_symlinks) != copy_options::none ||
(options & copy_options::skip_symlinks) != copy_options::none
then auto f = symlink_status(from) and if neededauto t = symlink_status(to).
—(4.2) Otherwise, if
(options & copy_options::copy_symlinks) != copy_options::none
then auto f = symlink_status(from) and if neededauto t = status(to).
—(4.3) Otherwise, auto f = status(from) and if neededauto t = status(to).
Effects are then as follows:
—(4.4) If f.type() or t.type() is an implementation-defined file type (31.12.8.2), then the effects are
implementation-defined.
—(4.5) Otherwise, an error is reported as specified in 31.12.5 if
—(4.5.1) exists(f) is false, or
—(4.5.2) equivalent(from, to) is true, or
—(4.5.3) is_other(f) || is_other(t) is true, or
—(4.5.4) is_directory(f) && is_regular_file(t) is true.
—(4.6) Otherwise, ifis_symlink(f), then:
—(4.6.1) If (options & copy_options::skip_symlinks) != copy_options::none then return.
—(4.6.2) Otherwise if
!exists(t) && (options & copy_options::copy_symlinks) != copy_options::none
then copy_symlink(from, to).
—(4.6.3) Otherwise report an error as specified in 31.12.5.
—(4.7) Otherwise, ifis_regular_file(f), then:
—(4.7.1) If (options & copy_options::directories_only) != copy_options::none, then return.
—(4.7.2) Otherwise, if (options & copy_options::create_symlinks) != copy_options::none ,
then create a symbolic link to the source file.
§ 31.12.13.4 © ISO/IEC
2136

===== PAGE 2148 =====

Dxxxx
—(4.7.3) Otherwise, if(options & copy_options::create_hard_links) != copy_options::none,
then create a hard link to the source file.
—(4.7.4) Otherwise, ifis_directory(t), thencopy_file(from, to/from.filename(), options).
—(4.7.5) Otherwise, copy_file(from, to, options).
—(4.8) Otherwise, if
is_directory(f) &&
(options & copy_options::create_symlinks) != copy_options::none
then report an error with anerror_code argument equal tomake_error_code(errc::is_a_-
directory).
—(4.9) Otherwise, if
is_directory(f) &&
((options & copy_options::recursive) != copy_options::none ||
options == copy_options::none)
then:
—(4.9.1) If exists(t) is false, thencreate_directory(to, from).
—(4.9.2) Then, iterate over the files infrom, as if by
for (const directory_entry& x : directory_iterator(from))
copy(x.path(), to/x.path().filename(),
options | copy_options::in-recursive-copy );
where in-recursive-copy is a bitmask element ofcopy_options that is not one of the
elements in 31.12.8.3.
—(4.10) Otherwise, for the signature with argumentec, ec.clear().
—(4.11) Otherwise, no effects.
5 Throws: As specified in 31.12.5.
6 Remarks: For the signature with argumentec, any library functions called by the implementation shall
have anerror_code argument if applicable.
7 [Example 1: Given this directory structure:
/dir1
file1
file2
dir2
file3
Calling copy("/dir1", "/dir3") would result in:
/dir1
file1
file2
dir2
file3
/dir3
file1
file2
Alternatively, callingcopy("/dir1", "/dir3", copy_options::recursive) would result in:
/dir1
file1
file2
dir2
file3
/dir3
file1
file2
dir2
file3
§ 31.12.13.4 © ISO/IEC
2137

===== PAGE 2149 =====

Dxxxx
—end example]
31.12.13.5 Copy file [fs.op.copy.file]
bool filesystem::copy_file(const path& from, const path& to);
bool filesystem::copy_file(const path& from, const path& to, error_code& ec);
1 Returns: copy_file(from, to, copy_options::none) or
copy_file(from, to, copy_options::none, ec), respectively.
2 Throws: As specified in 31.12.5.
bool filesystem::copy_file(const path& from, const path& to, copy_options options);
bool filesystem::copy_file(const path& from, const path& to, copy_options options,
error_code& ec);
3 Preconditions: At most one element from each option group (31.12.8.3) is set inoptions.
4 Effects: As follows:
—(4.1) Report an error as specified in 31.12.5 if
—(4.1.1) is_regular_file(from) is false, or
—(4.1.2) exists(to) is true and is_regular_file(to) is false, or
—(4.1.3) exists(to) is true and equivalent(from, to) is true, or
—(4.1.4) exists(to) is true and
(options & (copy_options::skip_existing |
copy_options::overwrite_existing |
copy_options::update_existing)) == copy_options::none
—(4.2) Otherwise, copy the contents and attributes of the filefrom resolves to, to the fileto resolves to, if
—(4.2.1) exists(to) is false, or
—(4.2.2) (options & copy_options::overwrite_existing) != copy_options::none, or
—(4.2.3) (options & copy_options::update_existing) != copy_options::none and from is
more recent thanto, determined as if by use of thelast_write_time function (31.12.13.26).
—(4.3) Otherwise, no effects.
5 Returns: true if thefrom file was copied, otherwisefalse. The signature with argumentec returns
false if an error occurs.
6 Throws: As specified in 31.12.5.
7 Complexity: At most one direct or indirect invocation ofstatus(to).
31.12.13.6 Copy symlink [fs.op.copy.symlink]
void filesystem::copy_symlink(const path& existing_symlink, const path& new_symlink);
void filesystem::copy_symlink(const path& existing_symlink, const path& new_symlink,
error_code& ec) noexcept;
1 Effects: Equivalent tofunction (read_symlink(existing_symlink), new_symlink) or
function (read_symlink(existing_symlink, ec), new_symlink, ec), respectively, where in each
case function is create_symlink or create_directory_symlink as appropriate.
2 Throws: As specified in 31.12.5.
31.12.13.7 Create directories [fs.op.create.directories]
bool filesystem::create_directories(const path& p);
bool filesystem::create_directories(const path& p, error_code& ec);
1 Effects: Calls create_directory for each element ofp that does not exist.
2 Returns: true if a new directory was created for the directoryp resolves to, otherwisefalse.
3 Throws: As specified in 31.12.5.
4 Complexity: O(n) where n is the number of elements ofp.
§ 31.12.13.7 © ISO/IEC
2138

===== PAGE 2150 =====

Dxxxx
31.12.13.8 Create directory [fs.op.create.directory]
bool filesystem::create_directory(const path& p);
bool filesystem::create_directory(const path& p, error_code& ec) noexcept;
1 Effects: Creates the directoryp resolves to, as if by POSIXmkdir with a second argument ofstatic_-
cast<int>(perms::all). If mkdir fails becausep resolves to an existing directory, no error is reported.
Otherwise on failure an error is reported.
2 Returns: true if a new directory was created, otherwisefalse.
3 Throws: As specified in 31.12.5.
bool filesystem::create_directory(const path& p, const path& existing_p);
bool filesystem::create_directory(const path& p, const path& existing_p, error_code& ec) noexcept;
4 Effects: Creates the directoryp resolves to, with attributes copied from directoryexisting_p. The set
of attributes copied is operating system dependent. Ifmkdir fails becausep resolves to an existing
directory, no error is reported. Otherwise on failure an error is reported.
[Note 1: For POSIX-based operating systems, the attributes are those copied by native APIstat(existing_-
p.c_str(), &attributes_stat) followed bymkdir(p.c_str(), attributes_stat.st_mode). For Windows-
based operating systems, the attributes are those copied by native APICreateDirectoryExW(existing_p.c_-
str(), p.c_str(), 0). —end note]
5 Returns: true if a new directory was created with attributes copied from directoryexisting_p,
otherwise false.
6 Throws: As specified in 31.12.5.
31.12.13.9 Create directory symlink [fs.op.create.dir.symlk]
void filesystem::create_directory_symlink(const path& to, const path& new_symlink);
void filesystem::create_directory_symlink(const path& to, const path& new_symlink,
error_code& ec) noexcept;
1 Effects: Establishes the postcondition, as if by POSIXsymlink.
2 Postconditions: new_symlink resolves to a symbolic link file that contains an unspecified representation
of to.
3 Throws: As specified in 31.12.5.
4 [Note 1: Some operating systems require symlink creation to identify that the link is to a directory. Thus,
create_symlink (instead of create_directory_symlink) cannot be used reliably to create directory symlinks.
—end note]
5 [Note 2: Some operating systems do not support symbolic links at all or support them only for regular files.
Some file systems (such as the FAT file system) do not support symbolic links regardless of the operating system.
—end note]
31.12.13.10 Create hard link [fs.op.create.hard.lk]
void filesystem::create_hard_link(const path& to, const path& new_hard_link);
void filesystem::create_hard_link(const path& to, const path& new_hard_link,
error_code& ec) noexcept;
1 Effects: Establishes the postcondition, as if by POSIXlink.
2 Postconditions:
—(2.1) exists(to) && exists(new_hard_link) && equivalent(to, new_hard_link)
—(2.2) The contents of the file or directoryto resolves to are unchanged.
3 Throws: As specified in 31.12.5.
4 [Note 1: Some operating systems do not support hard links at all or support them only for regular files. Some
file systems (such as the FAT file system) do not support hard links regardless of the operating system. Some
file systems limit the number of links per file.—end note]
31.12.13.11 Create symlink [fs.op.create.symlink]
void filesystem::create_symlink(const path& to, const path& new_symlink);
§ 31.12.13.11 © ISO/IEC
2139

===== PAGE 2151 =====

Dxxxx
void filesystem::create_symlink(const path& to, const path& new_symlink,
error_code& ec) noexcept;
1 Effects: Establishes the postcondition, as if by POSIXsymlink.
2 Postconditions: new_symlink resolves to a symbolic link file that contains an unspecified representation
of to.
3 Throws: As specified in 31.12.5.
4 [Note 1: Some operating systems do not support symbolic links at all or support them only for regular files.
Some file systems (such as the FAT file system) do not support symbolic links regardless of the operating system.
—end note]
31.12.13.12 Current path [fs.op.current.path]
path filesystem::current_path();
path filesystem::current_path(error_code& ec);
1 Returns: The absolute path of the current working directory, whose pathname in the native format is
obtained as if by POSIXgetcwd. The signature with argumentec returns path() if an error occurs.
2 Throws: As specified in 31.12.5.
3 Remarks: The current working directory is the directory, associated with the process, that is used as
the starting location in pathname resolution for relative paths.
4 [Note 1: The current path as returned by many operating systems is a dangerous global variable and can be
changed unexpectedly by third-party or system library functions, or by another thread.—end note]
void filesystem::current_path(const path& p);
void filesystem::current_path(const path& p, error_code& ec) noexcept;
5 Effects: Establishes the postcondition, as if by POSIXchdir.
6 Postconditions: equivalent(p, current_path()).
7 Throws: As specified in 31.12.5.
8 [Note 2: The current path for many operating systems is a dangerous global state and can be changed
unexpectedly by third-party or system library functions, or by another thread.—end note]
31.12.13.13 Equivalent [fs.op.equivalent]
bool filesystem::equivalent(const path& p1, const path& p2);
bool filesystem::equivalent(const path& p1, const path& p2, error_code& ec) noexcept;
1 Two paths are considered to resolve to the same file system entity if two candidate entities reside on
the same device at the same location.
[Note 1: On POSIX platforms, this is determined as if by the values of the POSIXstat class, obtained as if by
stat for the two paths, having equalst_dev values and equalst_ino values. —end note]
2 Returns: true, ifp1 and p2 resolve to the same file system entity, otherwisefalse. The signature with
argument ec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
4 Remarks: !exists(p1) || !exists(p2) is an error.
31.12.13.14 Exists [fs.op.exists]
bool filesystem::exists(file_status s) noexcept;
1 Returns: status_known(s) && s.type() != file_type::not_found.
bool filesystem::exists(const path& p);
bool filesystem::exists(const path& p, error_code& ec) noexcept;
2 Let s be afile_status, determined as if bystatus(p) or status(p, ec), respectively.
3 Effects: The signature with argumentec calls ec.clear() if status_known(s).
4 Returns: exists(s).
5 Throws: As specified in 31.12.5.
§ 31.12.13.14 © ISO/IEC
2140

===== PAGE 2152 =====

Dxxxx
31.12.13.15 File size [fs.op.file.size]
uintmax_t filesystem::file_size(const path& p);
uintmax_t filesystem::file_size(const path& p, error_code& ec) noexcept;
1 Effects: If exists(p) is false, an error is reported (31.12.5).
2 Returns:
—(2.1) If is_regular_file(p), the size in bytes of the filep resolves to, determined as if by the value of
the POSIXstat class memberst_size obtained as if by POSIXstat.
—(2.2) Otherwise, the result is implementation-defined.
The signature with argumentec returns static_cast<uintmax_t>(-1) if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.16 Hard link count [fs.op.hard.lk.ct]
uintmax_t filesystem::hard_link_count(const path& p);
uintmax_t filesystem::hard_link_count(const path& p, error_code& ec) noexcept;
1 Returns: The number of hard links for p. The signature with argument ec returns static_-
cast<uintmax_t>(-1) if an error occurs.
2 Throws: As specified in 31.12.5.
31.12.13.17 Is block file [fs.op.is.block.file]
bool filesystem::is_block_file(file_status s) noexcept;
1 Returns: s.type() == file_type::block.
bool filesystem::is_block_file(const path& p);
bool filesystem::is_block_file(const path& p, error_code& ec) noexcept;
2 Returns: is_block_file(status(p)) or is_block_file(status(p, ec)), respectively. The signa-
ture with argumentec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.18 Is character file [fs.op.is.char.file]
bool filesystem::is_character_file(file_status s) noexcept;
1 Returns: s.type() == file_type::character.
bool filesystem::is_character_file(const path& p);
bool filesystem::is_character_file(const path& p, error_code& ec) noexcept;
2 Returns: is_character_file(status(p)) or is_character_file(status(p, ec)), respectively.
The signature with argumentec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.19 Is directory [fs.op.is.directory]
bool filesystem::is_directory(file_status s) noexcept;
1 Returns: s.type() == file_type::directory.
bool filesystem::is_directory(const path& p);
bool filesystem::is_directory(const path& p, error_code& ec) noexcept;
2 Returns: is_directory(status(p)) or is_directory(status(p, ec)), respectively. The signature
with argumentec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.20 Is empty [fs.op.is.empty]
bool filesystem::is_empty(const path& p);
§ 31.12.13.20 © ISO/IEC
2141

===== PAGE 2153 =====

Dxxxx
bool filesystem::is_empty(const path& p, error_code& ec);
1 Effects:
—(1.1) Determine file_status s, as if bystatus(p) or status(p, ec), respectively.
—(1.2) For the signature with argumentec, returnfalse if an error occurred.
—(1.3) Otherwise, ifis_directory(s):
—(1.3.1) Create a variableitr, as if bydirectory_iterator itr(p) or directory_iterator itr(p,
ec), respectively.
—(1.3.2) For the signature with argumentec, returnfalse if an error occurred.
—(1.3.3) Otherwise, returnitr == directory_iterator().
—(1.4) Otherwise:
—(1.4.1) Determine uintmax_t sz, as if byfile_size(p) or file_size(p, ec), respectively.
—(1.4.2) For the signature with argumentec, returnfalse if an error occurred.
—(1.4.3) Otherwise, returnsz == 0.
2 Throws: As specified in 31.12.5.
31.12.13.21 Is fifo [fs.op.is.fifo]
bool filesystem::is_fifo(file_status s) noexcept;
1 Returns: s.type() == file_type::fifo.
bool filesystem::is_fifo(const path& p);
bool filesystem::is_fifo(const path& p, error_code& ec) noexcept;
2 Returns: is_fifo(status(p)) or is_fifo(status(p, ec)), respectively. The signature with argu-
ment ec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.22 Is other [fs.op.is.other]
bool filesystem::is_other(file_status s) noexcept;
1 Returns: exists(s) && !is_regular_file(s) && !is_directory(s) && !is_symlink(s).
bool filesystem::is_other(const path& p);
bool filesystem::is_other(const path& p, error_code& ec) noexcept;
2 Returns: is_other(status(p)) or is_other(status(p, ec)), respectively. The signature with
argument ec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.23 Is regular file [fs.op.is.regular.file]
bool filesystem::is_regular_file(file_status s) noexcept;
1 Returns: s.type() == file_type::regular.
bool filesystem::is_regular_file(const path& p);
2 Returns: is_regular_file(status(p)).
3 Throws: filesystem_error if status(p) would throwfilesystem_error.
bool filesystem::is_regular_file(const path& p, error_code& ec) noexcept;
4 Effects: Sets ec as if bystatus(p, ec).
[Note 1: file_type::none, file_type::not_found and file_type::unknown cases setec to error values. To
distinguish between cases, call thestatus function directly. —end note]
5 Returns: is_regular_file(status(p, ec)). Returns false if an error occurs.
§ 31.12.13.23 © ISO/IEC
2142

===== PAGE 2154 =====

Dxxxx
31.12.13.24 Is socket [fs.op.is.socket]
bool filesystem::is_socket(file_status s) noexcept;
1 Returns: s.type() == file_type::socket.
bool filesystem::is_socket(const path& p);
bool filesystem::is_socket(const path& p, error_code& ec) noexcept;
2 Returns: is_socket(status(p)) or is_socket(status(p, ec)), respectively. The signature with
argument ec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.25 Is symlink [fs.op.is.symlink]
bool filesystem::is_symlink(file_status s) noexcept;
1 Returns: s.type() == file_type::symlink.
bool filesystem::is_symlink(const path& p);
bool filesystem::is_symlink(const path& p, error_code& ec) noexcept;
2 Returns: is_symlink(symlink_status(p)) or is_symlink(symlink_status(p, ec)), respectively.
The signature with argumentec returns false if an error occurs.
3 Throws: As specified in 31.12.5.
31.12.13.26 Last write time [fs.op.last.write.time]
file_time_type filesystem::last_write_time(const path& p);
file_time_type filesystem::last_write_time(const path& p, error_code& ec) noexcept;
1 Returns: The time of last data modification ofp, determined as if by the value of the POSIXstat
class member st_mtime obtained as if by POSIXstat. The signature with argument ec returns
file_time_type::min() if an error occurs.
2 Throws: As specified in 31.12.5.
void filesystem::last_write_time(const path& p, file_time_type new_time);
void filesystem::last_write_time(const path& p, file_time_type new_time,
error_code& ec) noexcept;
3 Effects: Sets the time of last data modification of the file resolved to byp to new_time, as if by POSIX
futimens.
4 Throws: As specified in 31.12.5.
5 [Note 1: A postcondition oflast_write_time(p) == new_time is not specified because it does not necessarily
hold for file systems with coarse time granularity.—end note]
31.12.13.27 Permissions [fs.op.permissions]
void filesystem::permissions(const path& p, perms prms, perm_options opts=perm_options::replace);
void filesystem::permissions(const path& p, perms prms, error_code& ec) noexcept;
void filesystem::permissions(const path& p, perms prms, perm_options opts, error_code& ec);
1 Preconditions: Exactly one of theperm_options constants replace, add, orremove is present inopts.
2 Effects: Applies the action specified byopts to the filep resolves to, or to filep itself ifp is a symbolic
link andperm_options::nofollow is set inopts. The action is applied as if by POSIXfchmodat.
3 [Note 1: Conceptually permissions are viewed as bits, but the actual implementation can use some other
mechanism. —end note]
4 Throws: As specified in 31.12.5.
5 Remarks: The second signature behaves as if it had an additional parameterperm_options optswith
an argument ofperm_options::replace.
31.12.13.28 Proximate [fs.op.proximate]
path filesystem::proximate(const path& p, error_code& ec);
1 Returns: proximate(p, current_path(), ec).
§ 31.12.13.28 © ISO/IEC
2143

===== PAGE 2155 =====

Dxxxx
2 Throws: As specified in 31.12.5.
path filesystem::proximate(const path& p, const path& base = current_path());
path filesystem::proximate(const path& p, const path& base, error_code& ec);
3 Returns: For the first form:
weakly_canonical(p).lexically_proximate(weakly_canonical(base));
For the second form:
weakly_canonical(p, ec).lexically_proximate(weakly_canonical(base, ec));
or path() at the first error occurrence, if any.
4 Throws: As specified in 31.12.5.
31.12.13.29 Read symlink [fs.op.read.symlink]
path filesystem::read_symlink(const path& p);
path filesystem::read_symlink(const path& p, error_code& ec);
1 Returns: If p resolves to a symbolic link, apath object containing the contents of that symbolic link.
The signature with argumentec returns path() if an error occurs.
2 Throws: As specified in 31.12.5.
[Note 1: It is an error ifp does not resolve to a symbolic link.—end note]
31.12.13.30 Relative [fs.op.relative]
path filesystem::relative(const path& p, error_code& ec);
1 Returns: relative(p, current_path(), ec).
2 Throws: As specified in 31.12.5.
path filesystem::relative(const path& p, const path& base = current_path());
path filesystem::relative(const path& p, const path& base, error_code& ec);
3 Returns: For the first form:
weakly_canonical(p).lexically_relative(weakly_canonical(base));
For the second form:
weakly_canonical(p, ec).lexically_relative(weakly_canonical(base, ec));
or path() at the first error occurrence, if any.
4 Throws: As specified in 31.12.5.
31.12.13.31 Remove [fs.op.remove]
bool filesystem::remove(const path& p);
bool filesystem::remove(const path& p, error_code& ec) noexcept;
1 Effects: If exists(symlink_status(p, ec)), the filep is removed as if by POSIXremove.
[Note 1: A symbolic link is itself removed, rather than the file it resolves to.—end note]
2 Postconditions: exists(symlink_status(p)) is false.
3 Returns: true if a filep has been removed andfalse otherwise.
[Note 2: Absence of a filep is not an error.—end note]
4 Throws: As specified in 31.12.5.
31.12.13.32 Remove all [fs.op.remove.all]
uintmax_t filesystem::remove_all(const path& p);
uintmax_t filesystem::remove_all(const path& p, error_code& ec);
1 Effects: Recursively deletes the contents ofp if it exists, then deletes filep itself, as if by POSIX
remove.
[Note 1: A symbolic link is itself removed, rather than the file it resolves to.—end note]
§ 31.12.13.32 © ISO/IEC
2144

===== PAGE 2156 =====

Dxxxx
2 Postconditions: exists(symlink_status(p)) is false.
3 Returns: The number of files removed. The signature with argument ec returns static_cast<
uintmax_t>(-1) if an error occurs.
4 Throws: As specified in 31.12.5.
31.12.13.33 Rename [fs.op.rename]
void filesystem::rename(const path& old_p, const path& new_p);
void filesystem::rename(const path& old_p, const path& new_p, error_code& ec) noexcept;
1 Effects: Renames old_p to new_p, as if by POSIXrename.
[Note 1:
—(1.1) If old_p and new_p resolve to the same existing file, no action is taken.
—(1.2) Otherwise, the rename can include the following effects:
—(1.2.1) if new_p resolves to an existing non-directory file,new_p is removed; otherwise,
—(1.2.2) if new_p resolves to an existing directory,new_p is removed if empty on POSIX compliant operating
systems but might be an error on other operating systems.
A symbolic link is itself renamed, rather than the file it resolves to.—end note]
2 Throws: As specified in 31.12.5.
31.12.13.34 Resize file [fs.op.resize.file]
void filesystem::resize_file(const path& p, uintmax_t new_size);
void filesystem::resize_file(const path& p, uintmax_t new_size, error_code& ec) noexcept;
1 Effects: Causes the size that would be returned byfile_size(p) to be equal tonew_size, as if by
POSIX truncate.
2 Throws: As specified in 31.12.5.
31.12.13.35 Space [fs.op.space]
space_info filesystem::space(const path& p);
space_info filesystem::space(const path& p, error_code& ec) noexcept;
1 Returns: An object of type space_info. The value of the space_info object is determined as if
by using POSIXstatvfs to obtain a POSIXstruct statvfs, and then multiplying itsf_blocks,
f_bfree, andf_bavail members by itsf_frsize member, and assigning the results to thecapacity,
free, andavailable members respectively. Any members for which the value cannot be determined
shall be set tostatic_cast<uintmax_t>(-1). For the signature with argumentec, all members are
set tostatic_cast<uintmax_t>(-1) if an error occurs.
2 Throws: As specified in 31.12.5.
3 Remarks: The value of memberspace_info::available is operating system dependent.
[Note 1: available might be less thanfree. —end note]
31.12.13.36 Status [fs.op.status]
file_status filesystem::status(const path& p);
1 Effects: As if by:
error_code ec;
file_status result = status(p, ec);
if (result.type() == file_type::none)
throw filesystem_error(implementation-supplied-message , p, ec);
return result;
2 Returns: See above.
3 Throws: filesystem_error.
[Note 1: result values offile_status(file_type::not_found) and file_status(file_type::unknown) are
not considered failures and do not cause an exception to be thrown.—end note]
§ 31.12.13.36 © ISO/IEC
2145

===== PAGE 2157 =====

Dxxxx
file_status filesystem::status(const path& p, error_code& ec) noexcept;
4 Effects: If possible, determines the attributes of the filep resolves to, as if by using POSIXstat to
obtain a POSIXstruct stat. If, during attribute determination, the underlying file system API
reports an error, setsec to indicate the specific error reported. Otherwise,ec.clear().
[Note 2: This allows users to inspect the specifics of underlying API errors even when the value returned by
status is notfile_status(file_type::none). —end note]
5 Let prms denote the result of(m & perms::mask), where m is determined as if by converting the
st_mode member of the obtainedstruct stat to the typeperms.
6 Returns:
—(6.1) If ec != error_code():
—(6.1.1) If the specific error indicates thatp cannot be resolved because some element of the path does
not exist, returnsfile_status(file_type::not_found).
—(6.1.2) Otherwise, if the specific error indicates thatp can be resolved but the attributes cannot be
determined, returnsfile_status(file_type::unknown).
—(6.1.3) Otherwise, returnsfile_status(file_type::none).
[Note 3: These semantics distinguish betweenp being known not to exist,p existing but not being able to
determine its attributes, and there being an error that prevents even knowing ifp exists. These distinctions
are important to some use cases.—end note]
—(6.2) Otherwise,
—(6.2.1) If the attributes indicate a regular file, as if by POSIXS_ISREG, returnsfile_status(file_-
type::regular, prms).
[Note 4: file_type::regular implies appropriate<fstream> operations would succeed, assuming
no hardware, permission, access, or file system race errors. Lack offile_type::regular does not
necessarily imply<fstream> operations would fail on a directory.—end note]
—(6.2.2) Otherwise, if the attributes indicate a directory, as if by POSIXS_ISDIR, returns file_-
status(file_type::directory, prms).
[Note 5: file_type::directory implies that callingdirectory_iterator(p) would succeed. —end
note]
—(6.2.3) Otherwise, if the attributes indicate a block special file, as if by POSIXS_ISBLK, returns
file_status(file_type::block, prms).
—(6.2.4) Otherwise, if the attributes indicate a character special file, as if by POSIXS_ISCHR, returns
file_status(file_type::character, prms).
—(6.2.5) Otherwise, if the attributes indicate a fifo or pipe file, as if by POSIXS_ISFIFO, returns
file_status(file_type::fifo, prms).
—(6.2.6) Otherwise, if the attributes indicate a socket, as if by POSIXS_ISSOCK, returns file_-
status(file_type::socket, prms).
—(6.2.7) Otherwise, if the attributes indicate an implementation-defined file type (31.12.8.2), returns
file_status(file_type::A, prms), whereA is the constant for the implementation-defined
file type.
—(6.2.8) Otherwise, returnsfile_status(file_type::unknown, prms).
7 Remarks: If a symbolic link is encountered during pathname resolution, pathname resolution continues
using the contents of the symbolic link.
31.12.13.37 Status known [fs.op.status.known]
bool filesystem::status_known(file_status s) noexcept;
1 Returns: s.type() != file_type::none.
31.12.13.38 Symlink status [fs.op.symlink.status]
file_status filesystem::symlink_status(const path& p);
§ 31.12.13.38 © ISO/IEC
2146

===== PAGE 2158 =====

Dxxxx
file_status filesystem::symlink_status(const path& p, error_code& ec) noexcept;
1 Effects: Same asstatus, above, except that the attributes ofp are determined as if by using POSIX
lstat to obtain a POSIXstruct stat.
2 Let prms denote the result of(m & perms::mask), where m is determined as if by converting the
st_mode member of the obtainedstruct stat to the typeperms.
3 Returns: Same as status, above, except that if the attributes indicate a symbolic link, as if by
POSIX S_ISLNK, returnsfile_status(file_type::symlink, prms). The signature with argument
ec returns file_status(file_type::none) if an error occurs.
4 Throws: As specified in 31.12.5.
5 Remarks: Pathname resolution terminates ifp names a symbolic link.
31.12.13.39 Temporary directory path [fs.op.temp.dir.path]
path filesystem::temp_directory_path();
path filesystem::temp_directory_path(error_code& ec);
1 Let p be an unspecified directory path suitable for temporary files.
2 Effects: If exists(p) is false or is_directory(p) is false, an error is reported (31.12.5).
3 Returns: The pathp. The signature with argumentec returns path() if an error occurs.
4 Throws: As specified in 31.12.5.
5 [Example 1: For POSIX-based operating systems, an implementation might return the path supplied by the
first environment variable found in the list TMPDIR, TMP, TEMP, TEMPDIR, or if none of these are found,
"/tmp".
For Windows-based operating systems, an implementation might return the path reported by the Windows
GetTempPath API function. —end example]
31.12.13.40 Weakly canonical [fs.op.weakly.canonical]
path filesystem::weakly_canonical(const path& p);
path filesystem::weakly_canonical(const path& p, error_code& ec);
1 Effects: Using status(p) or status(p, ec), respectively, to determine existence, return a path
composed byoperator/= from the result of callingcanonical with a path argument composed of the
leading elements ofp that exist, if any, followed by the elements ofp that do not exist, if any. For the
first form,canonical is called without anerror_code argument. For the second form,canonical is
called withec as anerror_code argument, andpath() is returned at the first error occurrence, if any.
2 Postconditions: The returned path is in normal form (31.12.6.2).
3 Returns: p with symlinks resolved and the result normalized (31.12.6.2).
4 Throws: As specified in 31.12.5.
31.13 C library files [c.files]
31.13.1 Header <cstdio> synopsis [cstdio.syn]
#define __STDC_VERSION_STDIO_H__ 202311L
namespace std {
using size_t = see 17.2.4;
using FILE = see below ;
using fpos_t = see below ;
}
#define NULL see 17.2.3
#define _IOFBF see below
#define _IOLBF see below
#define _IONBF see below
#define BUFSIZ see below
#define EOF see below
#define FOPEN_MAX see below
#define FILENAME_MAX see below
§ 31.13.1 © ISO/IEC
2147

===== PAGE 2159 =====

Dxxxx
#define _PRINTF_NAN_LEN_MAX see below
#define L_tmpnam see below
#define SEEK_CUR see below
#define SEEK_END see below
#define SEEK_SET see below
#define TMP_MAX see below
#define stderr see below
#define stdin see below
#define stdout see below
namespace std {
int remove(const char* filename);
int rename(const char* old_p, const char* new_p);
FILE* tmpfile();
char* tmpnam(char* s);
int fclose(FILE* stream);
int fflush(FILE* stream);
FILE* fopen(const char* filename, const char* mode);
FILE* freopen(const char* filename, const char* mode, FILE* stream);
void setbuf(FILE* stream, char* buf);
int setvbuf(FILE* stream, char* buf, int mode, size_t size);
int fprintf(FILE* stream, const char* format, ...);
int fscanf(FILE* stream, const char* format, ...);
int printf(const char* format, ...);
int scanf(const char* format, ...);
int snprintf(char* s, size_t n, const char* format, ...);
int sprintf(char* s, const char* format, ...);
int sscanf(const char* s, const char* format, ...);
int vfprintf(FILE* stream, const char* format, va_list arg);
int vfscanf(FILE* stream, const char* format, va_list arg);
int vprintf(const char* format, va_list arg);
int vscanf(const char* format, va_list arg);
int vsnprintf(char* s, size_t n, const char* format, va_list arg);
int vsprintf(char* s, const char* format, va_list arg);
int vsscanf(const char* s, const char* format, va_list arg);
int fgetc(FILE* stream);
char* fgets(char* s, int n, FILE* stream);
int fputc(int c, FILE* stream);
int fputs(const char* s, FILE* stream);
int getc(FILE* stream);
int getchar();
int putc(int c, FILE* stream);
int putchar(int c);
int puts(const char* s);
int ungetc(int c, FILE* stream);
size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);
size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE* stream);
int fgetpos(FILE* stream, fpos_t* pos);
int fseek(FILE* stream, long int offset, int whence);
int fsetpos(FILE* stream, const fpos_t* pos);
long int ftell(FILE* stream);
void rewind(FILE* stream);
void clearerr(FILE* stream);
int feof(FILE* stream);
int ferror(FILE* stream);
void perror(const char* s);
}
1 The contents and meaning of the header<cstdio> are the same as the C standard library header<stdio.h>.
2 The return from each function call that delivers data to the host environment to be written to a file (See
also: ISO/IEC 9899:2024, 7.23.3) is an observable checkpoint (4.1.2).
3 Calls to the functiontmpnamwith an argument that is a null pointer value may introduce a data race (16.4.6.10)
with other calls totmpnam with an argument that is a null pointer value.
§ 31.13.1 © ISO/IEC
2148

===== PAGE 2160 =====

Dxxxx
See also: ISO/IEC 9899:2024, 7.23
31.13.2 Header <cinttypes> synopsis [cinttypes.syn]
#include <cstdint> // see 17.4.1
namespace std {
using imaxdiv_t = see below ;
constexpr intmax_t imaxabs(intmax_t j);
constexpr imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
intmax_t strtoimax(const char* nptr, char** endptr, int base);
uintmax_t strtoumax(const char* nptr, char** endptr, int base);
intmax_t wcstoimax(const wchar_t* nptr, wchar_t** endptr, int base);
uintmax_t wcstoumax(const wchar_t* nptr, wchar_t** endptr, int base);
constexpr intmax_t abs(intmax_t); // optional, see below
constexpr imaxdiv_t div(intmax_t, intmax_t); // optional, see below
}
#define __STDC_VERSION_INTTYPES_H__ 202311L
#define PRIdN see below
#define PRIiN see below
#define PRIoN see below
#define PRIuN see below
#define PRIxN see below
#define PRIXN see below
#define PRIbN see below
#define PRIBN see below
#define SCNdN see below
#define SCNiN see below
#define SCNoN see below
#define SCNuN see below
#define SCNxN see below
#define SCNbN see below
#define PRIdLEASTN see below
#define PRIiLEASTN see below
#define PRIoLEASTN see below
#define PRIuLEASTN see below
#define PRIxLEASTN see below
#define PRIXLEASTN see below
#define PRIbLEASTN see below
#define PRIBLEASTN see below
#define SCNdLEASTN see below
#define SCNiLEASTN see below
#define SCNoLEASTN see below
#define SCNuLEASTN see below
#define SCNxLEASTN see below
#define SCNbLEASTN see below
#define PRIdFASTN see below
#define PRIiFASTN see below
#define PRIoFASTN see below
#define PRIuFASTN see below
#define PRIxFASTN see below
#define PRIXFASTN see below
#define PRIbFASTN see below
#define PRIBFASTN see below
#define SCNdFASTN see below
#define SCNiFASTN see below
#define SCNoFASTN see below
#define SCNuFASTN see below
#define SCNxFASTN see below
#define SCNbFASTN see below
§ 31.13.2 © ISO/IEC
2149

===== PAGE 2161 =====

Dxxxx
#define PRIdMAX see below
#define PRIiMAX see below
#define PRIoMAX see below
#define PRIuMAX see below
#define PRIxMAX see below
#define PRIXMAX see below
#define PRIbMAX see below
#define PRIBMAX see below
#define SCNdMAX see below
#define SCNiMAX see below
#define SCNoMAX see below
#define SCNuMAX see below
#define SCNxMAX see below
#define SCNbMAX see below
#define PRIdPTR see below
#define PRIiPTR see below
#define PRIoPTR see below
#define PRIuPTR see below
#define PRIxPTR see below
#define PRIXPTR see below
#define PRIbPTR see below
#define PRIBPTR see below
#define SCNdPTR see below
#define SCNiPTR see below
#define SCNoPTR see below
#define SCNuPTR see below
#define SCNxPTR see below
#define SCNbPTR see below
1 The contents and meaning of the header<cinttypes> are the same as the C standard library header
<inttypes.h>, with the following changes:
—(1.1) The header<cinttypes> includes the header<cstdint> (17.4.1) instead of<stdint.h>, and
—(1.2) if and only if the typeintmax_t designates an extended integer type (6.9.2), the following function
signatures are added:
constexpr intmax_t abs(intmax_t);
constexpr imaxdiv_t div(intmax_t, intmax_t);
whichshallhavethesamesemanticsasthefunctionsignatures constexpr intmax_t imaxabs(intmax_-
t) and constexpr imaxdiv_t imaxdiv(intmax_t, intmax_t), respectively.
See also: ISO/IEC 9899:2024, 7.8
2 Each of thePRI macros listed in this subclause is defined if and only if the implementation defines the
corresponding typedef-name in 17.4.1. Each of theSCN macros listed in this subclause is defined if and only
if the implementation defines the correspondingtypedef-name in 17.4.1 and has a suitablefscanf length
modifier for the type. Each of thePRIB macros listed in this subclause is defined if and only iffprintf
supports theB conversion specifier.
§ 31.13.2 © ISO/IEC
2150

===== PAGE 2162 =====

Dxxxx
32 Concurrency support library [thread]
32.1 General [thread.general]
1 The following subclauses describe components to create and manage threads (6.10.2), perform mutual
exclusion, and communicate conditions and values between threads, as summarized in Table 154.
Table 154 — Concurrency support library summary [tab:thread.summary]
Subclause Header
32.2 Requirements
32.3 Stop tokens <stop_token>
32.4 Threads <thread>
32.5 Atomic operations <atomic>, <stdatomic.h>
32.6 Mutual exclusion <mutex>, <shared_mutex>
32.7 Condition variables <condition_variable>
32.8 Semaphores <semaphore>
32.9 Coordination types <latch>, <barrier>
32.10 Futures <future>
32.11 Safe reclamation <rcu>, <hazard_pointer>
32.2 Requirements [thread.req]
32.2.1 Template parameter names [thread.req.paramname]
1 Throughout this Clause, the names of template parameters are used to express type requirements.Predicate
is a function object type (22.10). Letpred denote an lvalue of typePredicate. Then the expressionpred()
shall be well-formed and the typedecltype(pred()) shall modelboolean-testable (18.5.2). The return
value ofpred(), converted tobool, yieldstrue if the corresponding test condition is satisfied, andfalse
otherwise. If a template parameter is namedClock, the corresponding template argument shall be a typeC
that meets theCpp17Clock requirements (30.3); the program is ill-formed ifis_clock_v<C> is false.
32.2.2 Exceptions [thread.req.exception]
1 Some functions described in this Clause are specified to throw exceptions of typesystem_error (19.5.8).
Such exceptions are thrown if any of the function’s error conditions is detected or a call to an operating system
or other underlying API results in an error that prevents the library function from meeting its specifications.
Failure to allocate storage is reported as described in 16.4.6.14.
[Example 1: Consider a function in this Clause that is specified to throw exceptions of typesystem_error and specifies
error conditions that includeoperation_not_permitted for a thread that does not have the privilege to perform the
operation. Assume that, during the execution of this function, anerrno of EPERM is reported by a POSIX API call
used by the implementation. Since POSIX specifies anerrno of EPERM when “the caller does not have the privilege to
perform the operation”, the implementation mapsEPERM to anerror_condition of operation_not_permitted (19.5)
and an exception of typesystem_error is thrown. —end example]
2 The error_code reported by such an exception’scode() member function compares equal to one of the
conditions specified in the function’s error condition element.
32.2.3 Native handles [thread.req.native]
1 Several classes described in this Clause have membersnative_handle_type and native_handle. The
presence of these members and their semantics is implementation-defined.
[Note 1: These members allow implementations to provide access to implementation details. Their names are specified
to facilitate portable compile-time detection. Actual use of these members is inherently non-portable.—end note]
§ 32.2.3 © ISO/IEC
2151

===== PAGE 2163 =====

Dxxxx
32.2.4 Timing specifications [thread.req.timing]
1 Several functions described in this Clause take an argument to specify a timeout. These timeouts are specified
as either aduration or atime_point type as specified in Clause 30.
2 Implementations necessarily have some delay in returning from a timeout. Any overhead in interrupt response,
function return, and scheduling induces a “quality of implementation” delay, expressed as durationDi. Ideally,
this delay would be zero. Further, any contention for processor and memory resources induces a “quality of
management” delay, expressed as durationDm. The delay durations may vary from timeout to timeout, but
in all cases shorter is better.
3 The functions whose names end in_for take an argument that specifies a duration. These functions produce
relative timeouts. Implementations should use a steady clock to measure time for these functions.285 Given a
duration argumentDt, the real-time duration of the timeout isDt + Di + Dm.
4 The functions whose names end in_until take an argument that specifies a time point. These functions
produce absolute timeouts. Implementations should use the clock specified in the time point to measure time
for these functions. Given a clock time point argumentCt, the clock time point of the return from timeout
should beCt + Di + Dm when the clock is not adjusted during the timeout. If the clock is adjusted to the
time Ca during the timeout, the behavior should be as follows:
—(4.1) If Ca >Ct, the waiting function should wake as soon as possible, i.e.,Ca+ Di+ Dm, since the timeout
is already satisfied. This specification may result in the total duration of the wait decreasing when
measured against a steady clock.
—(4.2) If Ca ≤Ct, the waiting function should not time out untilClock::now() returns a timeCn ≥Ct, i.e.,
waking atCt + Di + Dm.
[Note 1: When the clock is adjusted backwards, this specification can result in the total duration of the wait
increasing when measured against a steady clock. When the clock is adjusted forwards, this specification can
result in the total duration of the wait decreasing when measured against a steady clock.—end note]
An implementation returns from such a timeout at any point from the time specified above to the time it
would return from a steady-clock relative timeout on the difference betweenCt and the time point of the call
to the_until function.
Recommended practice: Implementations should decrease the duration of the wait when the clock is adjusted
forwards.
5 [Note 2: If the clock is not synchronized with a steady clock, e.g., a CPU time clock, these timeouts can fail to provide
useful functionality. —end note]
6 The resolution of timing provided by an implementation depends on both operating system and hardware.
The finest resolution provided by an implementation is called thenative resolution.
7 Implementation-provided clocks that are used for these functions meet theCpp17TrivialClock requirements
(30.3).
8 A function that takes an argument which specifies a timeout will throw if, during its execution, a clock, time
point, or time duration throws an exception. Such exceptions are referred to astimeout-related exceptions.
[Note 3: Instantiations of clock, time point and duration types supplied by the implementation as specified in 30.7 do
not throw exceptions. —end note]
32.2.5 Requirements for Cpp17Lockable types [thread.req.lockable]
32.2.5.1 General [thread.req.lockable.general]
1 An execution agentis an entity such as a thread that may perform work in parallel with other execution
agents.
[Note 1: Implementations or users can introduce other kinds of agents such as processes or thread-pool tasks.—end
note]
The calling agent is determined by context, e.g., the calling thread that contains the call, and so on.
2 [Note 2: Some lockable objects are “agent oblivious” in that they work for any execution agent model because they
do not determine or store the agent’s ID (e.g., an ordinary spin lock).—end note]
285) Implementations for which standard time units are meaningful will typically have a steady clock within their hardware
implementation.
§ 32.2.5.1 © ISO/IEC
2152

===== PAGE 2164 =====

Dxxxx
3 The standard library templatesunique_lock (32.6.5.4), shared_lock (32.6.5.5), scoped_lock (32.6.5.3),
lock_guard (32.6.5.2), lock, try_lock (32.6.6), andcondition_variable_any (32.7.5) all operate on user-
supplied lockable objects. The Cpp17BasicLockable requirements, the Cpp17Lockable requirements, the
Cpp17TimedLockablerequirements, theCpp17SharedLockablerequirements, and theCpp17SharedTimedLock-
able requirements list the requirements imposed by these library types in order to acquire or release ownership
of alock by a given execution agent.
[Note 3: The nature of any lock ownership and any synchronization it entails are not part of these requirements.
—end note]
4 A lock on an objectm is said to be
—(4.1) a non-shared lockif it is acquired by a call tolock, try_lock, try_lock_for, ortry_lock_until on
m, or
—(4.2) a shared lockif it is acquired by a call tolock_shared, try_lock_shared, try_lock_shared_for, or
try_lock_shared_until on m.
[Note 4: Only the method of lock acquisition is considered; the nature of any lock ownership is not part of these
definitions. —end note]
32.2.5.2 Cpp17BasicLockable requirements [thread.req.lockable.basic]
1 A typeL meets theCpp17BasicLockable requirements if the following expressions are well-formed and have
the specified semantics (m denotes a value of typeL).
m.lock()
2 Effects: Blocks until a lock can be acquired for the current execution agent. If an exception is thrown
then a lock shall not have been acquired for the current execution agent.
m.unlock()
3 Preconditions: The current execution agent holds a non-shared lock onm.
4 Effects: Releases a non-shared lock onm held by the current execution agent.
5 Throws: Nothing.
32.2.5.3 Cpp17Lockable requirements [thread.req.lockable.req]
1 A typeL meets theCpp17Lockable requirements if it meets theCpp17BasicLockable requirements and the
following expressions are well-formed and have the specified semantics (m denotes a value of typeL).
m.try_lock()
2 Effects: Attempts to acquire a lock for the current execution agent without blocking. If an exception is
thrown then a lock shall not have been acquired for the current execution agent.
3 Return type: bool.
4 Returns: true if the lock was acquired, otherwisefalse.
32.2.5.4 Cpp17TimedLockable requirements [thread.req.lockable.timed]
1 A typeL meets theCpp17TimedLockablerequirements if it meets theCpp17Lockable requirements and the
following expressions are well-formed and have the specified semantics (m denotes a value of typeL, rel_time
denotes a value of an instantiation ofduration (30.5), andabs_time denotes a value of an instantiation of
time_point (30.6)).
m.try_lock_for(rel_time)
2 Effects: Attempts to acquire a lock for the current execution agent within the relative timeout (32.2.4)
specified byrel_time. The function will not return within the timeout specified byrel_time unless it
has obtained a lock onm for the current execution agent. If an exception is thrown then a lock has not
been acquired for the current execution agent.
3 Return type: bool.
4 Returns: true if the lock was acquired, otherwisefalse.
§ 32.2.5.4 © ISO/IEC
2153

===== PAGE 2165 =====

Dxxxx
m.try_lock_until(abs_time)
5 Effects: Attempts to acquire a lock for the current execution agent before the absolute timeout (32.2.4)
specified byabs_time. The function will not return before the timeout specified byabs_time unless it
has obtained a lock onm for the current execution agent. If an exception is thrown then a lock has not
been acquired for the current execution agent.
6 Return type: bool.
7 Returns: true if the lock was acquired, otherwisefalse.
32.2.5.5 Cpp17SharedLockable requirements [thread.req.lockable.shared]
1 A typeL meets theCpp17SharedLockablerequirements if the following expressions are well-formed, have the
specified semantics, and the expressionm.try_lock_shared() has typebool (m denotes a value of typeL):
m.lock_shared()
2 Effects: Blocks until a lock can be acquired for the current execution agent. If an exception is thrown
then a lock shall not have been acquired for the current execution agent.
m.try_lock_shared()
3 Effects: Attempts to acquire a lock for the current execution agent without blocking. If an exception is
thrown then a lock shall not have been acquired for the current execution agent.
4 Returns: true if the lock was acquired,false otherwise.
m.unlock_shared()
5 Preconditions: The current execution agent holds a shared lock onm.
6 Effects: Releases a shared lock onm held by the current execution agent.
7 Throws: Nothing.
32.2.5.6 Cpp17SharedTimedLockablerequirements [thread.req.lockable.shared.timed]
1 A typeLmeets theCpp17SharedTimedLockablerequirements if it meets theCpp17SharedLockablerequirements,
and the following expressions are well-formed, have typebool, and have the specified semantics (m denotes a
value of typeL, rel_time denotes a value of a specialization ofchrono::duration, andabs_time denotes a
value of a specialization ofchrono::time_point).
m.try_lock_shared_for(rel_time)
2 Effects: Attempts to acquire a lock for the current execution agent within the relative timeout (32.2.4)
specified byrel_time. The function will not return within the timeout specified byrel_time unless it
has obtained a lock onm for the current execution agent. If an exception is thrown then a lock has not
been acquired for the current execution agent.
3 Returns: true if the lock was acquired,false otherwise.
m.try_lock_shared_until(abs_time)
4 Effects: Attempts to acquire a lock for the current execution agent before the absolute timeout (32.2.4)
specified byabs_time. The function will not return before the timeout specified byabs_time unless it
has obtained a lock onm for the current execution agent. If an exception is thrown then a lock has not
been acquired for the current execution agent.
5 Returns: true if the lock was acquired,false otherwise.
32.3 Stop tokens [thread.stoptoken]
32.3.1 Introduction [thread.stoptoken.intro]
1 Subclause 32.3 describes components that can be used to asynchronously request that an operation stops
execution in a timely manner, typically because the result is no longer required. Such a request is called a
stop request.
2 The conceptsstoppable-source , stoppable_token, andstoppable-callback-for specify the required
syntax and semantics of shared access to astop state. Any object modelingstoppable-source , stoppable_-
token, orstoppable-callback-for that refers to the same stop state is anassociated stoppable-source ,
stoppable_token, orstoppable-callback-for , respectively.
§ 32.3.1 © ISO/IEC
2154

===== PAGE 2166 =====

Dxxxx
3 An object of a type that modelsstoppable_token can be passed to an operation that can either
—(3.1) actively poll the token to check if there has been a stop request, or
—(3.2) register a callback that will be called in the event that a stop request is made.
A stop request made via an object whose type modelsstoppable-source will be visible to all associated
stoppable_token and stoppable-source objects. Once a stop request has been made it cannot be
withdrawn (a subsequent stop request has no effect).
4 Callbacks registered via an object whose type modelsstoppable-callback-for are called when a stop
request is first made by any associatedstoppable-source object.
5 The typesstop_source and stop_token and the class templatestop_callback implement the semantics
of shared ownership of a stop state. The last remaining owner of the stop state automatically releases the
resources associated with the stop state.
6 An object of typeinplace_stop_source is the sole owner of its stop state. An object of typeinplace_-
stop_token or of a specialization of the class templateinplace_stop_callback does not participate in
ownership of its associated stop state.
[Note 1: They are for use when all uses of the associated token and callback objects are known to nest within the
lifetime of theinplace_stop_source object. —end note]
32.3.2 Header <stop_token> synopsis [thread.stoptoken.syn]
namespace std {
// 32.3.3, stop token concepts
template<class CallbackFn, class Token, class Initializer = CallbackFn>
concept stoppable-callback-for = see below ; // exposition only
template<class Token>
concept stoppable_token = see below ;
template<class Token>
concept unstoppable_token = see below ;
template<class Source>
concept stoppable-source = see below ; // exposition only
// 32.3.4, classstop_token
class stop_token;
// 32.3.5, classstop_source
class stop_source;
// no-shared-stop-state indicator
struct nostopstate_t {
explicit nostopstate_t() = default;
};
inline constexpr nostopstate_t nostopstate{};
// 32.3.6, class templatestop_callback
template<class Callback>
class stop_callback;
// 32.3.7, classnever_stop_token
class never_stop_token;
// 32.3.8, classinplace_stop_token
class inplace_stop_token;
// 32.3.9, classinplace_stop_source
class inplace_stop_source;
// 32.3.10, class templateinplace_stop_callback
template<class CallbackFn>
class inplace_stop_callback;
§ 32.3.2 © ISO/IEC
2155

===== PAGE 2167 =====

Dxxxx
template<class T, class CallbackFn>
using stop_callback_for_t = T::template callback_type<CallbackFn>;
}
32.3.3 Stop token concepts [stoptoken.concepts]
1 The exposition-onlystoppable-callback-for concept checks for a callback compatible with a givenToken
type.
template<class CallbackFn, class Token, class Initializer = CallbackFn>
concept stoppable-callback-for = // exposition only
invocable<CallbackFn> &&
constructible_from<CallbackFn, Initializer> &&
requires { typename stop_callback_for_t<Token, CallbackFn>; } &&
constructible_from<stop_callback_for_t<Token, CallbackFn>, const Token&, Initializer>;
2 Let t and u be distinct, valid objects of typeToken that reference the same logical stop state; letinit be
an expression such thatsame_as<decltype(init), Initializer> is true; and letSCB denote the type
stop_callback_for_t<Token, CallbackFn>.
3 The conceptstoppable-callback-for <CallbackFn, Token, Initializer> is modeled only if:
—(3.1) The following concepts are modeled:
—(3.1.1) constructible_from<SCB, Token, Initializer>
—(3.1.2) constructible_from<SCB, Token&, Initializer>
—(3.1.3) constructible_from<SCB, const Token, Initializer>
—(3.2) An object of typeSCB has an associated callback function of typeCallbackFn. Let scb be an object of
type SCB and letcallback_fn denote scb’s associated callback function. Direct-non-list-initializing
scb from argumentst and init shall execute astoppable callback registrationas follows:
—(3.2.1) If t.stop_possible() is true:
—(3.2.1.1) callback_fn shall be direct-initialized withinit.
—(3.2.1.2) Construction of scb shall only throw exceptions thrown by the initialization ofcallback_fn
from init.
—(3.2.1.3) The callback invocationstd::forward<CallbackFn>(callback_fn)() shall be registered
with t’s associated stop state as follows:
—(3.2.1.3) If t.stop_requested() evaluates tofalse at the time of registration, the callback invo-
cation is added to the stop state’s list of callbacks such thatstd::forward<CallbackFn>(
callback_fn)() is evaluated if a stop request is made on the stop state.
—(3.2.1.3) Otherwise, std::forward<CallbackFn>(callback_fn)()shall be immediately evaluated
on the thread executingscb’s constructor, and the callback invocation shall not be added
to the list of callback invocations.
If the callback invocation was added to stop state’s list of callbacks,scb shall be associated
with the stop state.
[Note 1: If t.stop_possible() is false, there is no requirement that the initialization ofscb causes the
initialization ofcallback_fn. —end note]
—(3.2.2)
—(3.3) Destruction ofscb shall execute astoppable callback deregistrationas follows (in order):
—(3.3.1) If the constructor ofscb did not register a callback invocation witht’s stop state, then the
stoppable callback deregistration shall have no effect other than destroyingcallback_fn if it was
constructed.
—(3.3.2) Otherwise, the invocation ofcallback_fn shall be removed from the associated stop state.
—(3.3.3) If callback_fn is concurrently executing on another thread, then the stoppable callback deregis-
tration shall block (3.6) until the invocation ofcallback_fn returns such that the return from the
invocation ofcallback_fn strongly happens before (6.10.2.2) the destruction ofcallback_fn.
—(3.3.4) If callback_fn is executing on the current thread, then the destructor shall not block waiting for
the return from the invocation ofcallback_fn.
§ 32.3.3 © ISO/IEC
2156

===== PAGE 2168 =====

Dxxxx
—(3.3.5) A stoppable callback deregistration shall not block on the completion of the invocation of some
other callback registered with the same logical stop state.
—(3.3.6) The stoppable callback deregistration shall destroycallback_fn.
4 The stoppable_token concept checks for the basic interface of a stop token that is copyable and allows
polling to see if stop has been requested and also whether a stop request is possible. Theunstoppable_token
concept checks for astoppable_token type that does not allow stopping.
template<template<class> class>
struct check-type-alias-exists ; // exposition only
template<class Token>
concept stoppable_token =
requires (const Token tok) {
typename check-type-alias-exists <Token::template callback_type>;
{ tok.stop_requested() } noexcept -> same_as<bool>;
{ tok.stop_possible() } noexcept -> same_as<bool>;
{ Token(tok) } noexcept; // see implicit expression variations (18.2)
} &&
copyable<Token> &&
equality_comparable<Token>;
template<class Token>
concept unstoppable_token =
stoppable_token<Token> &&
requires (const Token tok) {
requires bool_constant<(!tok.stop_possible())>::value;
};
5 An object whose type modelsstoppable_token has at most one associated logical stop state. Astoppable_-
token object with no associated stop state is said to bedisengaged.
6 Let SP be an evaluation oft.stop_possible() that is false, and let SR be an evaluation oft.stop_-
requested() that istrue.
7 The typeToken models stoppable_token only if:
—(7.1) Any evaluation ofu.stop_possible() or u.stop_requested() that happens after (6.10.2.2)SP is
false.
—(7.2) Any evaluation ofu.stop_possible() or u.stop_requested() that happens afterSR is true.
—(7.3) For any typesCallbackFn and Initializer such thatstoppable-callback-for <CallbackFn, To-
ken, Initializer> is satisfied, stoppable-callback-for <CallbackFn, Token, Initializer> is
modeled.
—(7.4) If t is disengaged, evaluations oft.stop_possible() and t.stop_requested() are false.
—(7.5) If t and u reference the same stop state, or if botht and u are disengaged,t == u is true; otherwise,
it isfalse.
8 An object whose type models the exposition-onlystoppable-source concept can be queried whether stop
has been requested (stop_requested) and whether stop is possible (stop_possible). It is a factory for
associated stop tokens (get_token), and a stop request can be made on it (request_stop). It maintains a
list of registered stop callback invocations that it executes when a stop request is first made.
template<class Source>
concept stoppable-source = // exposition only
requires (Source& src, const Source csrc) { // see implicit expression variations (18.2)
{ csrc.get_token() } -> stoppable_token;
{ csrc.stop_possible() } noexcept -> same_as<bool>;
{ csrc.stop_requested() } noexcept -> same_as<bool>;
{ src.request_stop() } -> same_as<bool>;
};
9 An object whose type modelsstoppable-source has at most one associated logical stop state. If it has no
associated stop state, it is said to be disengaged. Lets be an object whose type modelsstoppable-source
and that is disengaged.s.stop_possible() and s.stop_requested() shall befalse.
§ 32.3.3 © ISO/IEC
2157

===== PAGE 2169 =====

Dxxxx
10 Let t be an object whose type modelsstoppable-source . If t is disengaged,t.get_token() shall return a
disengaged stop token; otherwise, it shall return a stop token that is associated with the stop state oft.
11 Calls to the member functionsrequest_stop, stop_requested, andstop_possible and similarly named
member functions on associatedstoppable_token objects do not introduce data races. A call torequest_-
stop that returnstrue synchronizes with a call tostop_requested on an associatedstoppable_token or
stoppable-source object that returnstrue. Registration of a callback synchronizes with the invocation of
that callback.
12 If thestoppable-source is disengaged,request_stop shall have no effect and returnfalse. Otherwise,
it shall execute astop request operationon the associated stop state. A stop request operation determines
whether the stop state has received a stop request, and if not, makes a stop request. The determination and
making of the stop request shall happen atomically, as-if by a read-modify-write operation (6.10.2.2). If the
request was made, the stop state’s registered callback invocations shall be synchronously executed. If an
invocation of a callback exits via an exception thenterminate shall be invoked (14.6.2).
[Note 2: No constraint is placed on the order in which the callback invocations are executed.—end note]
request_stop shall returntrue if a stop request was made, andfalse otherwise. After a call torequest_-
stop either a call tostop_possible shall returnfalse or a call tostop_requested shall returntrue.
[Note 3: A stop request includes notifying all condition variables of typecondition_variable_any temporarily
registered during an interruptible wait (32.7.5.3).—end note]
32.3.4 Class stop_token [stoptoken]
32.3.4.1 General [stoptoken.general]
1 The classstop_token models the conceptstoppable_token. It shares ownership of its stop state, if any,
with its associatedstop_source object (32.3.5) and anystop_token objects to which it compares equal.
namespace std {
class stop_token {
public:
template<class CallbackFn>
using callback_type = stop_callback<CallbackFn>;
stop_token() noexcept = default;
// 32.3.4.2, member functions
void swap(stop_token&) noexcept;
bool stop_requested() const noexcept;
bool stop_possible() const noexcept;
bool operator==(const stop_token& rhs) noexcept = default;
private:
shared_ptr<unspecified > stop-state ; // exposition only
};
}
2 stop-state refers to thestop_token’s associated stop state. Astop_token object is disengaged when
stop-state is empty.
32.3.4.2 Member functions [stoptoken.mem]
void swap(stop_token& rhs) noexcept;
1 Effects: Equivalent to:
stop-state .swap(rhs.stop-state );
bool stop_requested() const noexcept;
2 Returns: true if stop-state refers to a stop state that has received a stop request; otherwise,false.
bool stop_possible() const noexcept;
3 Returns: false if
§ 32.3.4.2 © ISO/IEC
2158

===== PAGE 2170 =====

Dxxxx
—(3.1) *this is disengaged, or
—(3.2) a stop request was not made and there are no associatedstop_source objects;
otherwise, true.
32.3.5 Class stop_source [stopsource]
32.3.5.1 General [stopsource.general]
namespace std {
class stop_source {
public:
// 32.3.5.2, constructors, copy, and assignment
stop_source();
explicit stop_source(nostopstate_t) noexcept {}
// 32.3.5.3, member functions
void swap(stop_source&) noexcept;
stop_token get_token() const noexcept;
bool stop_possible() const noexcept;
bool stop_requested() const noexcept;
bool request_stop() noexcept;
bool operator==(const stop_source& rhs) noexcept = default;
private:
shared_ptr<unspecified > stop-state ; // exposition only
};
}
1 stop-state refers to thestop_source’s associated stop state. Astop_source object is disengaged when
stop-state is empty.
2 stop_source models stoppable-source , copyable, equality_comparable, andswappable.
32.3.5.2 Constructors, copy, and assignment [stopsource.cons]
stop_source();
1 Effects: Initializes stop-state with a pointer to a new stop state.
2 Postconditions: stop_possible() is true and stop_requested() is false.
3 Throws: bad_alloc if memory cannot be allocated for the stop state.
32.3.5.3 Member functions [stopsource.mem]
void swap(stop_source& rhs) noexcept;
1 Effects: Equivalent to:
stop-state .swap(rhs.stop-state );
stop_token get_token() const noexcept;
2 Returns: stop_token() if stop_possible() is false; otherwise a new associatedstop_token object;
i.e., itsstop-state member is equal to thestop-state member of*this.
bool stop_possible() const noexcept;
3 Returns: stop-state != nullptr.
bool stop_requested() const noexcept;
4 Returns: true if stop-state refers to a stop state that has received a stop request; otherwise,false.
bool request_stop() noexcept;
5 Effects: Executes a stop request operation (32.3.3) on the associated stop state, if any.
§ 32.3.5.3 © ISO/IEC
2159

===== PAGE 2171 =====

Dxxxx
32.3.6 Class template stop_callback [stopcallback]
32.3.6.1 General [stopcallback.general]
1 namespace std {
template<class CallbackFn>
class stop_callback {
public:
using callback_type = CallbackFn;
// 32.3.6.2, constructors and destructor
template<class Initializer>
explicit stop_callback(const stop_token& st, Initializer&& init)
noexcept(is_nothrow_constructible_v<CallbackFn, Initializer>);
template<class Initializer>
explicit stop_callback(stop_token&& st, Initializer&& init)
noexcept(is_nothrow_constructible_v<CallbackFn, Initializer>);
~stop_callback();
stop_callback(const stop_callback&) = delete;
stop_callback(stop_callback&&) = delete;
stop_callback& operator=(const stop_callback&) = delete;
stop_callback& operator=(stop_callback&&) = delete;
private:
CallbackFn callback-fn ; // exposition only
};
template<class CallbackFn>
stop_callback(stop_token, CallbackFn) -> stop_callback<CallbackFn>;
}
2 Mandates: stop_callback is instantiated with an argument for the template parameterCallbackFn that
satisfies bothinvocable and destructible.
3 Remarks: For a type Initializer, if stoppable-callback-for <CallbackFn, stop_token, Initiali-
zer> is satisfied, then stoppable-callback-for <CallbackFn, stop_token, Initializer> is modeled.
The exposition-onlycallback-fn member is the associated callback function (32.3.3) ofstop_callback<
CallbackFn> objects.
32.3.6.2 Constructors and destructor [stopcallback.cons]
template<class Initializer>
explicit stop_callback(const stop_token& st, Initializer&& init)
noexcept(is_nothrow_constructible_v<CallbackFn, Initializer>);
template<class Initializer>
explicit stop_callback(stop_token&& st, Initializer&& init)
noexcept(is_nothrow_constructible_v<CallbackFn, Initializer>);
1 Constraints: CallbackFn and Initializer satisfy constructible_from<CallbackFn, Initiali-
zer>.
2 Effects: Initializes callback-fn with std::forward<Initializer>(init) and executes a stoppable
callback registration (32.3.3). If a callback is registered withst’s shared stop state, then*this acquires
shared ownership of that stop state.
~stop_callback();
3 Effects: Executes a stoppable callback deregistration (32.3.3) and releases ownership of the stop state,
if any.
32.3.7 Class never_stop_token [stoptoken.never]
1 The classnever_stop_token models theunstoppable_token concept. It provides a stop token interface,
but also provides static information that a stop is never possible nor requested.
§ 32.3.7 © ISO/IEC
2160

===== PAGE 2172 =====

Dxxxx
namespace std {
class never_stop_token {
struct callback-type { // exposition only
explicit callback-type (never_stop_token, auto&&) noexcept {}
};
public:
template<class>
using callback_type = callback-type ;
static constexpr bool stop_requested() noexcept { return false; }
static constexpr bool stop_possible() noexcept { return false; }
bool operator==(const never_stop_token&) const = default;
};
}
32.3.8 Class inplace_stop_token [stoptoken.inplace]
32.3.8.1 General [stoptoken.inplace.general]
1 The classinplace_stop_token models the conceptstoppable_token. It references the stop state of its
associated inplace_stop_source object (32.3.9), if any.
namespace std {
class inplace_stop_token {
public:
template<class CallbackFn>
using callback_type = inplace_stop_callback<CallbackFn>;
inplace_stop_token() = default;
bool operator==(const inplace_stop_token&) const = default;
// 32.3.8.2, member functions
bool stop_requested() const noexcept;
bool stop_possible() const noexcept;
void swap(inplace_stop_token&) noexcept;
private:
const inplace_stop_source* stop-source = nullptr; // exposition only
};
}
32.3.8.2 Member functions [stoptoken.inplace.mem]
void swap(inplace_stop_token& rhs) noexcept;
1 Effects: Exchanges the values ofstop-source and rhs.stop-source .
bool stop_requested() const noexcept;
2 Effects: Equivalent to:
return stop-source != nullptr && stop-source ->stop_requested();
3 [Note 1: As specified in 6.8.4, the behavior ofstop_requested is undefined unless the call strongly happens
before the start of the destructor of the associatedinplace_stop_source object, if any.—end note]
stop_possible() const noexcept;
4 Returns: stop-source != nullptr.
5 [Note 2: As specified in 6.8.6.1, the behavior ofstop_possible is implementation-defined unless the call
strongly happens before the end of the storage duration of the associatedinplace_stop_source object, if any.
—end note]
32.3.9 Class inplace_stop_source [stopsource.inplace]
32.3.9.1 General [stopsource.inplace.general]
1 The classinplace_stop_source models stoppable-source .
§ 32.3.9.1 © ISO/IEC
2161

===== PAGE 2173 =====

Dxxxx
namespace std {
class inplace_stop_source {
public:
// 32.3.9.2, constructors
constexpr inplace_stop_source() noexcept;
inplace_stop_source(inplace_stop_source&&) = delete;
inplace_stop_source(const inplace_stop_source&) = delete;
inplace_stop_source& operator=(inplace_stop_source&&) = delete;
inplace_stop_source& operator=(const inplace_stop_source&) = delete;
~inplace_stop_source();
// 32.3.9.3, stop handling
constexpr inplace_stop_token get_token() const noexcept;
static constexpr bool stop_possible() noexcept { return true; }
bool stop_requested() const noexcept;
bool request_stop() noexcept;
};
}
32.3.9.2 Constructors [stopsource.inplace.cons]
constexpr inplace_stop_source() noexcept;
1 Effects: Initializes a new stop state inside*this.
2 Postconditions: stop_requested() is false.
32.3.9.3 Member functions [stopsource.inplace.mem]
constexpr inplace_stop_token get_token() const noexcept;
1 Returns: A new associatedinplace_stop_token object whosestop-source member is equal tothis.
bool stop_requested() const noexcept;
2 Returns: true if the stop state inside*this has received a stop request; otherwise,false.
bool request_stop() noexcept;
3 Effects: Executes a stop request operation (32.3.3).
4 Postconditions: stop_requested() is true.
32.3.10 Class template inplace_stop_callback [stopcallback.inplace]
32.3.10.1 General [stopcallback.inplace.general]
namespace std {
template<class CallbackFn>
class inplace_stop_callback {
public:
using callback_type = CallbackFn;
// 32.3.10.2, constructors and destructor
template<class Initializer>
explicit inplace_stop_callback(inplace_stop_token st, Initializer&& init)
noexcept(is_nothrow_constructible_v<CallbackFn, Initializer>);
~inplace_stop_callback();
inplace_stop_callback(inplace_stop_callback&&) = delete;
inplace_stop_callback(const inplace_stop_callback&) = delete;
inplace_stop_callback& operator=(inplace_stop_callback&&) = delete;
inplace_stop_callback& operator=(const inplace_stop_callback&) = delete;
private:
CallbackFn callback-fn ; // exposition only
};
§ 32.3.10.1 © ISO/IEC
2162

===== PAGE 2174 =====

Dxxxx
template<class CallbackFn>
inplace_stop_callback(inplace_stop_token, CallbackFn)
-> inplace_stop_callback<CallbackFn>;
}
1 Mandates: CallbackFn satisfies bothinvocable and destructible.
2 Remarks: For a typeInitializer, if
stoppable-callback-for <CallbackFn, inplace_stop_token, Initializer>
is satisfied, then
stoppable-callback-for <CallbackFn, inplace_stop_token, Initializer>
is modeled. For aninplace_stop_callback<CallbackFn>object, the exposition-onlycallback-fn member
is its associated callback function (32.3.3).
32.3.10.2 Constructors and destructor [stopcallback.inplace.cons]
template<class Initializer>
explicit inplace_stop_callback(inplace_stop_token st, Initializer&& init)
noexcept(is_nothrow_constructible_v<CallbackFn, Initializer>);
1 Constraints: constructible_from<CallbackFn, Initializer> is satisfied.
2 Effects: Initializes callback-fn with std::forward<Initializer>(init) and executes a stoppable
callback registration (32.3.3).
~inplace_stop_callback();
3 Effects: Executes a stoppable callback deregistration (32.3.3).
32.4 Threads [thread.threads]
32.4.1 General [thread.threads.general]
1 32.4 describes components that can be used to create and manage threads.
[Note 1: These threads are intended to map one-to-one with operating system threads.—end note]
32.4.2 Header <thread> synopsis [thread.syn]
#include <compare> // see 17.12.1
namespace std {
// 32.4.3, classthread
class thread;
void swap(thread& x, thread& y) noexcept;
// 32.4.4, classjthread
class jthread;
// 32.4.5, namespacethis_thread
namespace this_thread {
thread::id get_id() noexcept;
void yield() noexcept;
template<class Clock, class Duration>
void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);
template<class Rep, class Period>
void sleep_for(const chrono::duration<Rep, Period>& rel_time);
}
}
32.4.3 Class thread [thread.thread.class]
32.4.3.1 General [thread.thread.class.general]
1 The classthread provides a mechanism to create a new thread of execution, to join with a thread (i.e., wait
for a thread to complete), and to perform other operations that manage and query the state of a thread. A
§ 32.4.3.1 © ISO/IEC
2163

===== PAGE 2175 =====

Dxxxx
thread object uniquely represents a particular thread of execution. That representation may be transferred
to otherthread objects in such a way that no twothread objects simultaneously represent the same thread
of execution. A thread of execution isdetached when nothread object represents that thread. Objects of
class thread can be in a state that does not represent a thread of execution.
[Note 1: A thread object does not represent a thread of execution after default construction, after being moved from,
or after a successful call todetach or join. —end note]
namespace std {
class thread {
public:
// 32.4.3.2, classthread::id
class id;
using native_handle_type = implementation-defined; // see 32.2.3
// construct/copy/destroy
thread() noexcept;
template<class F, class... Args> explicit thread(F&& f, Args&&... args);
~thread();
thread(const thread&) = delete;
thread(thread&&) noexcept;
thread& operator=(const thread&) = delete;
thread& operator=(thread&&) noexcept;
// 32.4.3.6, members
void swap(thread&) noexcept;
bool joinable() const noexcept;
void join();
void detach();
id get_id() const noexcept;
native_handle_type native_handle(); // see 32.2.3
// static members
static unsigned int hardware_concurrency() noexcept;
};
}
32.4.3.2 Class thread::id [thread.thread.id]
namespace std {
class thread::id {
public:
id() noexcept;
};
bool operator==(thread::id x, thread::id y) noexcept;
strong_ordering operator<=>(thread::id x, thread::id y) noexcept;
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& out, thread::id id);
template<class charT> struct formatter<thread::id, charT>;
// hash support
template<class T> struct hash;
template<> struct hash<thread::id>;
}
1 An object of typethread::id provides a unique identifier for each thread of execution and a single distinct
value for allthread objects that do not represent a thread of execution (32.4.3). Each thread of execution has
an associatedthread::id object that is not equal to thethread::id object of any other thread of execution
and that is not equal to thethread::id object of anythread object that does not represent threads of
execution.
§ 32.4.3.2 © ISO/IEC
2164

===== PAGE 2176 =====

Dxxxx
2 The text representation for the character typecharT of an object of typethread::id is an unspecified
sequence ofcharT such that, for two objects of typethread::id xand y, ifx == y is true, thethread::id
objects have the same text representation, and ifx != y is true, thethread::id objects have distinct text
representations.
3 thread::id is a trivially copyable class (11.2). The library may reuse the value of athread::id of a
terminated thread that can no longer be joined.
4 [Note 1: Relational operators allowthread::id objects to be used as keys in associative containers.—end note]
id() noexcept;
5 Postconditions: The constructed object does not represent a thread of execution.
bool operator==(thread::id x, thread::id y) noexcept;
6 Returns: true only ifx and y represent the same thread of execution or neitherx nor y represents a
thread of execution.
strong_ordering operator<=>(thread::id x, thread::id y) noexcept;
7 Let P(x,y) be an unspecified total ordering overthread::id as described in 26.8.
8 Returns: strong_ordering::lessifP(x,y) istrue. Otherwise,strong_ordering::greaterifP(y,x)
is true. Otherwise, strong_ordering::equal.
template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& out, thread::id id);
9 Effects: Inserts the text representation forcharT of id into out.
10 Returns: out.
template<class charT> struct formatter<thread::id, charT>;
11 formatter<thread::id, charT> interprets format-spec as a thread-id-format-spec. The syntax of
format specifications is as follows:
thread-id-format-spec:
fill-and-alignopt widthopt
[Note 2: The productionsfill-and-align and width are described in 28.5.2.2.—end note]
12 If thealign option is omitted it defaults to>.
13 A thread::id object is formatted by writing its text representation forcharT to the output with
additional padding and adjustments as specified by the format specifiers.
template<> struct hash<thread::id>;
14 The specialization is enabled (22.10.19).
32.4.3.3 Constructors [thread.thread.constr]
thread() noexcept;
1 Effects: The object does not represent a thread of execution.
2 Postconditions: get_id() == id().
template<class F, class... Args> explicit thread(F&& f, Args&&... args);
3 Constraints: remove_cvref_t<F> is not the same type asthread.
4 Mandates: The following are alltrue:
—(4.1) is_constructible_v<decay_t<F>, F>,
—(4.2) (is_constructible_v<decay_t<Args>, Args> && ...), and
—(4.3) is_invocable_v<decay_t<F>, decay_t<Args>...>.
5 Effects: The new thread of execution executes
invoke(auto(std::forward<F>(f)), // for invoke, see 22.10.5
auto(std::forward<Args>(args))...)
§ 32.4.3.3 © ISO/IEC
2165

===== PAGE 2177 =====

Dxxxx
with the values produced byauto being materialized (7.3.5) in the constructing thread. Any return
value from this invocation is ignored.
[Note 1: This implies that any exceptions not thrown from the invocation of the copy off will be thrown in
the constructing thread, not the new thread.—end note]
If the invocation ofinvoke terminates with an uncaught exception,terminate is invoked (14.6.2).
6 Synchronization: The completion of the invocation of the constructor synchronizes with the beginning
of the invocation of the copy off.
7 Postconditions: get_id() != id(). *this represents the newly started thread.
8 Throws: system_error if unable to start the new thread.
9 Error conditions:
—(9.1) resource_unavailable_try_again— the system lacked the necessary resources to create another
thread, or the system-imposed limit on the number of threads in a process would be exceeded.
thread(thread&& x) noexcept;
10 Postconditions: x.get_id() == id() and get_id() returns the value ofx.get_id() prior to the start
of construction.
32.4.3.4 Destructor [thread.thread.destr]
~thread();
1 Effects: If joinable(), invokesterminate (14.6.2). Otherwise, has no effects.
[Note 1: Either implicitly detaching or joining ajoinable() thread in its destructor can result in difficult to
debug correctness (for detach) or performance (for join) bugs encountered only when an exception is thrown.
These bugs can be avoided by ensuring that the destructor is never executed while the thread is still joinable.
—end note]
32.4.3.5 Assignment [thread.thread.assign]
thread& operator=(thread&& x) noexcept;
1 Effects: If joinable(), invokesterminate (14.6.2). Otherwise, assigns the state ofx to *this and
sets x to a default constructed state.
2 Postconditions: x.get_id() == id() and get_id() returns the value ofx.get_id() prior to the
assignment.
3 Returns: *this.
32.4.3.6 Members [thread.thread.member]
void swap(thread& x) noexcept;
1 Effects: Swaps the state of*this and x.
bool joinable() const noexcept;
2 Returns: get_id() != id().
void join();
3 Effects: Blocks until the thread represented by*this has completed.
4 Synchronization: The completion of the thread represented by*this synchronizes with (6.10.2) the
corresponding successfuljoin() return.
[Note 1: Operations on*this are not synchronized. —end note]
5 Postconditions: The thread represented by*this has completed. get_id() == id().
6 Throws: system_error when an exception is required (32.2.2).
7 Error conditions:
—(7.1) resource_deadlock_would_occur — if deadlock is detected or get_id() == this_thread::
get_id().
—(7.2) no_such_process — if the thread is not valid.
§ 32.4.3.6 © ISO/IEC
2166

===== PAGE 2178 =====

Dxxxx
—(7.3) invalid_argument — if the thread is not joinable.
void detach();
8 Effects: The thread represented by*this continues execution without the calling thread blocking.
When detach() returns, *this no longer represents the possibly continuing thread of execution. When
the thread previously represented by*this ends execution, the implementation releases any owned
resources.
9 Postconditions: get_id() == id().
10 Throws: system_error when an exception is required (32.2.2).
11 Error conditions:
—(11.1) no_such_process — if the thread is not valid.
—(11.2) invalid_argument — if the thread is not joinable.
id get_id() const noexcept;
12 Returns: A default constructed id object if *this does not represent a thread, otherwisethis_-
thread::get_id() for the thread of execution represented by*this.
32.4.3.7 Static members [thread.thread.static]
unsigned hardware_concurrency() noexcept;
1 Returns: The number of hardware thread contexts.
[Note 1: This value should only be considered to be a hint.—end note]
If this value is not computable or well-defined, an implementation should return 0.
32.4.3.8 Specialized algorithms [thread.thread.algorithm]
void swap(thread& x, thread& y) noexcept;
1 Effects: As if byx.swap(y).
32.4.4 Class jthread [thread.jthread.class]
32.4.4.1 General [thread.jthread.class.general]
1 The classjthread provides a mechanism to create a new thread of execution. The functionality is the same
as for classthread (32.4.3) with the additional abilities to provide astop_token (32.3) to the new thread of
execution, make stop requests, and automatically join.
namespace std {
class jthread {
public:
// types
using id = thread::id;
using native_handle_type = thread::native_handle_type;
// 32.4.4.2, constructors, move, and assignment
jthread() noexcept;
template<class F, class... Args> explicit jthread(F&& f, Args&&... args);
~jthread();
jthread(const jthread&) = delete;
jthread(jthread&&) noexcept;
jthread& operator=(const jthread&) = delete;
jthread& operator=(jthread&&) noexcept;
// 32.4.4.3, members
void swap(jthread&) noexcept;
bool joinable() const noexcept;
void join();
void detach();
id get_id() const noexcept;
native_handle_type native_handle(); // see 32.2.3
§ 32.4.4.1 © ISO/IEC
2167

===== PAGE 2179 =====

Dxxxx
// 32.4.4.4, stop token handling
stop_source get_stop_source() noexcept;
stop_token get_stop_token() const noexcept;
bool request_stop() noexcept;
// 32.4.4.5, specialized algorithms
friend void swap(jthread& lhs, jthread& rhs) noexcept;
// 32.4.4.6, static members
static unsigned int hardware_concurrency() noexcept;
private:
stop_source ssource; // exposition only
};
}
32.4.4.2 Constructors, move, and assignment [thread.jthread.cons]
jthread() noexcept;
1 Effects: Constructs ajthread object that does not represent a thread of execution.
2 Postconditions: get_id() == id() is true and ssource.stop_possible() is false.
template<class F, class... Args> explicit jthread(F&& f, Args&&... args);
3 Constraints: remove_cvref_t<F> is not the same type asjthread.
4 Mandates: The following are alltrue:
—(4.1) is_constructible_v<decay_t<F>, F>,
—(4.2) (is_constructible_v<decay_t<Args>, Args> && ...), and
—(4.3) is_invocable_v<decay_t<F>, decay_t<Args>...> ||
is_invocable_v<decay_t<F>, stop_token, decay_t<Args>...>.
5 Effects: Initializes ssource. The new thread of execution executes
invoke(auto(std::forward<F>(f)), get_stop_token(), // for invoke, see 22.10.5
auto(std::forward<Args>(args))...)
if that expression is well-formed, otherwise
invoke(auto(std::forward<F>(f)), auto(std::forward<Args>(args))...)
with the values produced byauto being materialized (7.3.5) in the constructing thread. Any return
value from this invocation is ignored.
[Note 1: This implies that any exceptions not thrown from the invocation of the copy off will be thrown in
the constructing thread, not the new thread.—end note]
If theinvoke expression exits via an exception,terminate is called.
6 Synchronization: The completion of the invocation of the constructor synchronizes with the beginning
of the invocation of the copy off.
7 Postconditions: get_id() != id() is true and ssource.stop_possible() is true and *this repre-
sents the newly started thread.
[Note 2: The calling thread can make a stop request only once, because it cannot replace this stop token.
—end note]
8 Throws: system_error if unable to start the new thread.
9 Error conditions:
—(9.1) resource_unavailable_try_again— the system lacked the necessary resources to create another
thread, or the system-imposed limit on the number of threads in a process would be exceeded.
jthread(jthread&& x) noexcept;
10 Postconditions: x.get_id() == id() and get_id() returns the value ofx.get_id() prior to the
start of construction. ssource has the value ofx.ssource prior to the start of construction and
x.ssource.stop_possible() is false.
§ 32.4.4.2 © ISO/IEC
2168

===== PAGE 2180 =====

Dxxxx
~jthread();
11 Effects: If joinable() is true, callsrequest_stop() and thenjoin().
[Note 3: Operations on*this are not synchronized. —end note]
jthread& operator=(jthread&& x) noexcept;
12 Effects: If &x == this is true, there are no effects. Otherwise, ifjoinable() is true, callsrequest_-
stop() and then join(), then assigns the state ofx to *this and sets x to a default constructed
state.
13 Postconditions: get_id() returns the value ofx.get_id() prior to the assignment.ssource has the
value ofx.ssource prior to the assignment.
14 Returns: *this.
32.4.4.3 Members [thread.jthread.mem]
void swap(jthread& x) noexcept;
1 Effects: Exchanges the values of*this and x.
bool joinable() const noexcept;
2 Returns: get_id() != id().
void join();
3 Effects: Blocks until the thread represented by*this has completed.
4 Synchronization: The completion of the thread represented by*this synchronizes with (6.10.2) the
corresponding successfuljoin() return.
[Note 1: Operations on*this are not synchronized. —end note]
5 Postconditions: The thread represented by*this has completed. get_id() == id().
6 Throws: system_error when an exception is required (32.2.2).
7 Error conditions:
—(7.1) resource_deadlock_would_occur — if deadlock is detected or get_id() == this_thread::
get_id().
—(7.2) no_such_process — if the thread is not valid.
—(7.3) invalid_argument — if the thread is not joinable.
void detach();
8 Effects: The thread represented by*this continues execution without the calling thread blocking.
When detach() returns, *this no longer represents the possibly continuing thread of execution. When
the thread previously represented by*this ends execution, the implementation releases any owned
resources.
9 Postconditions: get_id() == id().
10 Throws: system_error when an exception is required (32.2.2).
11 Error conditions:
—(11.1) no_such_process — if the thread is not valid.
—(11.2) invalid_argument — if the thread is not joinable.
id get_id() const noexcept;
12 Returns: A default constructed id object if *this does not represent a thread, otherwisethis_-
thread::get_id() for the thread of execution represented by*this.
32.4.4.4 Stop token handling [thread.jthread.stop]
stop_source get_stop_source() noexcept;
1 Effects: Equivalent to:return ssource;
§ 32.4.4.4 © ISO/IEC
2169

===== PAGE 2181 =====

Dxxxx
stop_token get_stop_token() const noexcept;
2 Effects: Equivalent to:return ssource.get_token();
bool request_stop() noexcept;
3 Effects: Equivalent to:return ssource.request_stop();
32.4.4.5 Specialized algorithms [thread.jthread.special]
friend void swap(jthread& x, jthread& y) noexcept;
1 Effects: Equivalent to:x.swap(y).
32.4.4.6 Static members [thread.jthread.static]
static unsigned int hardware_concurrency() noexcept;
1 Returns: thread::hardware_concurrency().
32.4.5 Namespace this_thread [thread.thread.this]
namespace std::this_thread {
thread::id get_id() noexcept;
void yield() noexcept;
template<class Clock, class Duration>
void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);
template<class Rep, class Period>
void sleep_for(const chrono::duration<Rep, Period>& rel_time);
}
thread::id this_thread::get_id() noexcept;
1 Returns: An object of typethread::id that uniquely identifies the current thread of execution. Every
invocation from this thread of execution returns the same value. The object returned does not compare
equal to a default-constructedthread::id.
void this_thread::yield() noexcept;
2 Effects: Offers the implementation the opportunity to reschedule.
3 Synchronization: None.
template<class Clock, class Duration>
void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);
4 Effects: Blocks the calling thread for the absolute timeout (32.2.4) specified byabs_time.
5 Synchronization: None.
6 Throws: Timeout-related exceptions (32.2.4).
template<class Rep, class Period>
void sleep_for(const chrono::duration<Rep, Period>& rel_time);
7 Effects: Blocks the calling thread for the relative timeout (32.2.4) specified byrel_time.
8 Synchronization: None.
9 Throws: Timeout-related exceptions (32.2.4).
32.5 Atomic operations [atomics]
32.5.1 General [atomics.general]
1 Subclause 32.5 describes components for fine-grained atomic access. This access is provided via operations
on atomic objects.
32.5.2 Header <atomic> synopsis [atomics.syn]
// mostly freestanding
namespace std {
// 32.5.4, order and consistency
enum class memory_order : unspecified;
§ 32.5.2 © ISO/IEC
2170

===== PAGE 2182 =====

Dxxxx
inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
inline constexpr memory_order memory_order_acquire = memory_order::acquire;
inline constexpr memory_order memory_order_release = memory_order::release;
inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;
}
// 32.5.5, lock-free property
#define ATOMIC_BOOL_LOCK_FREE unspecified
#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR8_T_LOCK_FREE unspecified
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified
#define ATOMIC_POINTER_LOCK_FREE unspecified
namespace std {
// 32.5.7, class templateatomic_ref
template<class T> struct atomic_ref;
// 32.5.8, class templateatomic
template<class T> struct atomic;
// 32.5.8.5, partial specialization for pointers
template<class T> struct atomic<T*>;
// 32.5.9, non-member functions
template<class T>
bool atomic_is_lock_free(const volatile atomic<T>*) noexcept;
template<class T>
bool atomic_is_lock_free(const atomic<T>*) noexcept;
template<class T>
void atomic_store(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr void atomic_store(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
void atomic_store_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
T atomic_load(const volatile atomic<T>*) noexcept;
template<class T>
constexpr T atomic_load(const atomic<T>*) noexcept;
template<class T>
T atomic_load_explicit(const volatile atomic<T>*, memory_order) noexcept;
template<class T>
constexpr T atomic_load_explicit(const atomic<T>*, memory_order) noexcept;
template<class T>
T atomic_exchange(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr T atomic_exchange(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
T atomic_exchange_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr T atomic_exchange_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
§ 32.5.2 © ISO/IEC
2171

===== PAGE 2183 =====

Dxxxx
template<class T>
bool atomic_compare_exchange_weak(volatile atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type) noexcept;
template<class T>
constexpr bool atomic_compare_exchange_weak(atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type) noexcept;
template<class T>
bool atomic_compare_exchange_strong(volatile atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type) noexcept;
template<class T>
constexpr bool atomic_compare_exchange_strong(atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type) noexcept;
template<class T>
bool atomic_compare_exchange_weak_explicit(volatile atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type,
memory_order, memory_order) noexcept;
template<class T>
constexpr bool atomic_compare_exchange_weak_explicit(atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type,
memory_order, memory_order) noexcept;
template<class T>
bool atomic_compare_exchange_strong_explicit(volatile atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type,
memory_order, memory_order) noexcept;
template<class T>
constexpr bool atomic_compare_exchange_strong_explicit(atomic<T>*,
typename atomic<T>::value_type*,
typename atomic<T>::value_type,
memory_order, memory_order) noexcept;
template<class T>
T atomic_fetch_add(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
constexpr T atomic_fetch_add(atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
T atomic_fetch_add_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
template<class T>
constexpr T atomic_fetch_add_explicit(atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
template<class T>
T atomic_fetch_sub(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
constexpr T atomic_fetch_sub(atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
T atomic_fetch_sub_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
template<class T>
constexpr T atomic_fetch_sub_explicit(atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
template<class T>
T atomic_fetch_and(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr T atomic_fetch_and(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
T atomic_fetch_and_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
§ 32.5.2 © ISO/IEC
2172

===== PAGE 2184 =====

Dxxxx
template<class T>
constexpr T atomic_fetch_and_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
T atomic_fetch_or(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr T atomic_fetch_or(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
T atomic_fetch_or_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr T atomic_fetch_or_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
T atomic_fetch_xor(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr T atomic_fetch_xor(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
T atomic_fetch_xor_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr T atomic_fetch_xor_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
T atomic_fetch_max(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr T atomic_fetch_max(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
T atomic_fetch_max_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr T atomic_fetch_max_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
T atomic_fetch_min(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr T atomic_fetch_min(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
T atomic_fetch_min_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr T atomic_fetch_min_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
void atomic_store_add(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
constexpr void atomic_store_add(atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
void atomic_store_add_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_add_explicit(atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
template<class T>
void atomic_store_sub(volatile atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
constexpr void atomic_store_sub(atomic<T>*, typename atomic<T>::difference_type) noexcept;
template<class T>
void atomic_store_sub_explicit(volatile atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_sub_explicit(atomic<T>*, typename atomic<T>::difference_type,
memory_order) noexcept;
§ 32.5.2 © ISO/IEC
2173

===== PAGE 2185 =====

Dxxxx
template<class T>
void atomic_store_and(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr void atomic_store_and(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
void atomic_store_and_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_and_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
void atomic_store_or(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr void atomic_store_or(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
void atomic_store_or_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_or_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
void atomic_store_xor(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr void atomic_store_xor(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
void atomic_store_xor_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_xor_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
void atomic_store_max(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr void atomic_store_max(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
void atomic_store_max_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_max_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
void atomic_store_min(volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr void atomic_store_min(atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
void atomic_store_min_explicit(volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_store_min_explicit(atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
void atomic_wait(const volatile atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
constexpr void atomic_wait(const atomic<T>*, typename atomic<T>::value_type) noexcept;
template<class T>
void atomic_wait_explicit(const volatile atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
constexpr void atomic_wait_explicit(const atomic<T>*, typename atomic<T>::value_type,
memory_order) noexcept;
template<class T>
void atomic_notify_one(volatile atomic<T>*) noexcept;
§ 32.5.2 © ISO/IEC
2174

===== PAGE 2186 =====

Dxxxx
template<class T>
constexpr void atomic_notify_one(atomic<T>*) noexcept;
template<class T>
void atomic_notify_all(volatile atomic<T>*) noexcept;
template<class T>
constexpr void atomic_notify_all(atomic<T>*) noexcept;
// 32.5.3, type aliases
using atomic_bool = atomic<bool>;
using atomic_char = atomic<char>;
using atomic_schar = atomic<signed char>;
using atomic_uchar = atomic<unsigned char>;
using atomic_short = atomic<short>;
using atomic_ushort = atomic<unsigned short>;
using atomic_int = atomic<int>;
using atomic_uint = atomic<unsigned int>;
using atomic_long = atomic<long>;
using atomic_ulong = atomic<unsigned long>;
using atomic_llong = atomic<long long>;
using atomic_ullong = atomic<unsigned long long>;
using atomic_char8_t = atomic<char8_t>;
using atomic_char16_t = atomic<char16_t>;
using atomic_char32_t = atomic<char32_t>;
using atomic_wchar_t = atomic<wchar_t>;
using atomic_int8_t = atomic<int8_t>;
using atomic_uint8_t = atomic<uint8_t>;
using atomic_int16_t = atomic<int16_t>;
using atomic_uint16_t = atomic<uint16_t>;
using atomic_int32_t = atomic<int32_t>;
using atomic_uint32_t = atomic<uint32_t>;
using atomic_int64_t = atomic<int64_t>;
using atomic_uint64_t = atomic<uint64_t>;
using atomic_int_least8_t = atomic<int_least8_t>;
using atomic_uint_least8_t = atomic<uint_least8_t>;
using atomic_int_least16_t = atomic<int_least16_t>;
using atomic_uint_least16_t = atomic<uint_least16_t>;
using atomic_int_least32_t = atomic<int_least32_t>;
using atomic_uint_least32_t = atomic<uint_least32_t>;
using atomic_int_least64_t = atomic<int_least64_t>;
using atomic_uint_least64_t = atomic<uint_least64_t>;
using atomic_int_fast8_t = atomic<int_fast8_t>;
using atomic_uint_fast8_t = atomic<uint_fast8_t>;
using atomic_int_fast16_t = atomic<int_fast16_t>;
using atomic_uint_fast16_t = atomic<uint_fast16_t>;
using atomic_int_fast32_t = atomic<int_fast32_t>;
using atomic_uint_fast32_t = atomic<uint_fast32_t>;
using atomic_int_fast64_t = atomic<int_fast64_t>;
using atomic_uint_fast64_t = atomic<uint_fast64_t>;
using atomic_intptr_t = atomic<intptr_t>;
using atomic_uintptr_t = atomic<uintptr_t>;
using atomic_size_t = atomic<size_t>;
using atomic_ptrdiff_t = atomic<ptrdiff_t>;
using atomic_intmax_t = atomic<intmax_t>;
using atomic_uintmax_t = atomic<uintmax_t>;
using atomic_signed_lock_free = see below ; // hosted
using atomic_unsigned_lock_free = see below ; // hosted
// 32.5.10, flag type and operations
struct atomic_flag;
§ 32.5.2 © ISO/IEC
2175

===== PAGE 2187 =====

Dxxxx
bool atomic_flag_test(const volatile atomic_flag*) noexcept;
constexpr bool atomic_flag_test(const atomic_flag*) noexcept;
bool atomic_flag_test_explicit(const volatile atomic_flag*, memory_order) noexcept;
constexpr bool atomic_flag_test_explicit(const atomic_flag*, memory_order) noexcept;
bool atomic_flag_test_and_set(volatile atomic_flag*) noexcept;
constexpr bool atomic_flag_test_and_set(atomic_flag*) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order) noexcept;
constexpr bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order) noexcept;
void atomic_flag_clear(volatile atomic_flag*) noexcept;
constexpr void atomic_flag_clear(atomic_flag*) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order) noexcept;
constexpr void atomic_flag_clear_explicit(atomic_flag*, memory_order) noexcept;
void atomic_flag_wait(const volatile atomic_flag*, bool) noexcept;
constexpr void atomic_flag_wait(const atomic_flag*, bool) noexcept;
void atomic_flag_wait_explicit(const volatile atomic_flag*, bool, memory_order) noexcept;
constexpr void atomic_flag_wait_explicit(const atomic_flag*, bool, memory_order) noexcept;
void atomic_flag_notify_one(volatile atomic_flag*) noexcept;
constexpr void atomic_flag_notify_one(atomic_flag*) noexcept;
void atomic_flag_notify_all(volatile atomic_flag*) noexcept;
constexpr void atomic_flag_notify_all(atomic_flag*) noexcept;
#define ATOMIC_FLAG_INIT see below
// 32.5.11, fences
extern "C" constexpr void atomic_thread_fence(memory_order) noexcept;
extern "C" constexpr void atomic_signal_fence(memory_order) noexcept;
}
32.5.3 Type aliases [atomics.alias]
1 The type aliasesatomic_intN_t, atomic_uintN_t, atomic_intptr_t, andatomic_uintptr_t are defined
if and only ifintN_t, uintN_t, intptr_t, anduintptr_t are defined, respectively.
2 The type aliases atomic_signed_lock_free and atomic_unsigned_lock_free name specializations of
atomic whose template arguments are integral types, respectively signed and unsigned, and whoseis_-
always_lock_free property istrue.
[Note 1: These aliases are optional in freestanding implementations (16.4.2.5).—end note]
Implementations should choose for these aliases the integral specializations ofatomic for which the atomic
waiting and notifying operations (32.5.6) are most efficient.
32.5.4 Order and consistency [atomics.order]
namespace std {
enum class memory_order : unspecified {
relaxed = 0, acquire = 2, release = 3, acq_rel = 4, seq_cst = 5
};
}
1 The enumerationmemory_order specifies the detailed regular (non-atomic) memory synchronization order as
defined in 6.10.2 and may provide for operation ordering. Its enumerated values and their meanings are as
follows:
—(1.1) memory_order::relaxed: no operation orders memory.
—(1.2) memory_order::release, memory_order::acq_rel, andmemory_order::seq_cst: a store operation
performs a release operation on the affected memory location.
—(1.3) memory_order::acquire, memory_order::acq_rel, andmemory_order::seq_cst: a load operation
performs an acquire operation on the affected memory location.
[Note 1: Atomic operations specifyingmemory_order::relaxed are relaxed with respect to memory ordering. Imple-
mentations must still guarantee that any given atomic access to a particular atomic object be indivisible with respect
to all other atomic accesses to that object.—end note]
2 An atomic operationAthat performs a release operation on an atomic objectM synchronizes with an atomic
operation B that performs an acquire operation onM and takes its value from any side effect in the release
sequence headed byA.
§ 32.5.4 © ISO/IEC
2176

===== PAGE 2188 =====

Dxxxx
3 An atomic operationA on some atomic objectM is coherence-ordered beforeanother atomic operationB on
M if
—(3.1) A is a modification, andB reads the value stored byA, or
—(3.2) A precedes B in the modification order ofM, or
—(3.3) Aand B are not the same atomic read-modify-write operation, and there exists an atomic modification
X of M such thatA reads the value stored byX and X precedes B in the modification order ofM, or
—(3.4) there exists an atomic modificationX of M such that A is coherence-ordered before X and X is
coherence-ordered beforeB.
4 There is a single total orderS on allmemory_order::seq_cst operations, including fences, that satisfies the
following constraints. First, ifA and B are memory_order::seq_cst operations andA strongly happens
before B, thenA precedes B in S. Second, for every pair of atomic operationsA and B on an objectM,
where A is coherence-ordered beforeB, the following four conditions are required to be satisfied byS:
—(4.1) if A and B are bothmemory_order::seq_cst operations, thenA precedes B in S; and
—(4.2) if A is amemory_order::seq_cst operation andB happens before amemory_order::seq_cst fence
Y, thenA precedes Y in S; and
—(4.3) if amemory_order::seq_cst fence X happens beforeAand B is amemory_order::seq_cst operation,
then X precedes B in S; and
—(4.4) if amemory_order::seq_cst fence X happens beforeAand B happens before amemory_order::seq_-
cst fence Y, thenX precedes Y in S.
5 [Note 2: This definition ensures thatS is consistent with the modification order of any atomic objectM. It also
ensures that amemory_order::seq_cst load Aof M gets its value either from the last modification ofM that precedes
A in S or from some non-memory_order::seq_cst modification ofM that does not happen before any modification
of M that precedesA in S. —end note]
6 [Note 3: We do not require that S be consistent with “happens before” (6.10.2.2). This allows more efficient
implementation of memory_order::acquire and memory_order::release on some machine architectures. It can
produce surprising results when these are mixed withmemory_order::seq_cst accesses. —end note]
7 [Note 4: memory_order::seq_cst ensures sequential consistency only for a program that is free of data races and
uses exclusivelymemory_order::seq_cst atomic operations. Any use of weaker ordering will invalidate this guarantee
unless extreme care is used. In many cases,memory_order::seq_cst atomic operations are reorderable with respect
to other atomic operations performed by the same thread.—end note]
8 Implementations should ensure that no “out-of-thin-air” values are computed that circularly depend on their
own computation.
[Note 5: For example, withx and y initially zero,
// Thread 1:
r1 = y.load(memory_order::relaxed);
x.store(r1, memory_order::relaxed);
// Thread 2:
r2 = x.load(memory_order::relaxed);
y.store(r2, memory_order::relaxed);
this recommendation discourages producingr1 == r2 == 42, since the store of 42 toy is only possible if the store
to x stores 42, which circularly depends on the store toy storing 42. Note that without this restriction, such an
execution is possible. —end note]
9 [Note 6: The recommendation similarly disallowsr1 == r2 == 42 in the following example, withx and y again
initially zero:
// Thread 1:
r1 = x.load(memory_order::relaxed);
if (r1 == 42) y.store(42, memory_order::relaxed);
// Thread 2:
r2 = y.load(memory_order::relaxed);
if (r2 == 42) x.store(42, memory_order::relaxed);
—end note]
10 Atomic read-modify-write operations shall always read the last value (in the modification order) written
before the write associated with the read-modify-write operation.
§ 32.5.4 © ISO/IEC
2177

===== PAGE 2189 =====

Dxxxx
11 An atomic modify-write operationis an atomic read-modify-write operation with weaker synchronization
requirements as specified in 32.5.11.
[Note 7: The intent is for atomic modify-write operations to be implemented using mechanisms that are not ordered, in
hardware, by the implementation of acquire fences. No other semantic or hardware property (e.g., that the mechanism
is a far atomic operation) is implied.—end note]
12 Recommended practice: The implementation should make atomic stores visible to atomic loads, and atomic
loads should observe atomic stores, within a reasonable amount of time.
32.5.5 Lock-free property [atomics.lockfree]
#define ATOMIC_BOOL_LOCK_FREE unspecified
#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR8_T_LOCK_FREE unspecified
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified
#define ATOMIC_POINTER_LOCK_FREE unspecified
1 The ATOMIC_..._LOCK_FREE macros indicate the lock-free property of the corresponding atomic types, with
the signed and unsigned variants grouped together. The properties also apply to the corresponding (partial)
specializations of theatomic template. A value of 0 indicates that the types are never lock-free. A value of 1
indicates that the types are sometimes lock-free. A value of 2 indicates that the types are always lock-free.
2 On a hosted implementation (16.4.2.5), at least one signed integral specialization of theatomic template,
along with the specialization for the corresponding unsigned type (6.9.2), is always lock-free.
3 The functionsatomic<T>::is_lock_free and atomic_is_lock_free (32.5.8.2) indicate whether the object
is lock-free. In any given program execution, the result of the lock-free query is the same for all atomic
objects of the same type.
4 Atomic operations that are not lock-free are considered to potentially block (6.10.2.3).
5 Recommended practice: Operations that are lock-free should also be address-free.286 The implementation of
these operations should not depend on any per-process state.
[Note 1: This restriction enables communication by memory that is mapped into a process more than once and by
memory that is shared between two processes.—end note]
32.5.6 Waiting and notifying [atomics.wait]
1 Atomic waiting operationsand atomic notifying operationsprovide a mechanism to wait for the value of an
atomic object to change more efficiently than can be achieved with polling. An atomic waiting operation
may block until it is unblocked by an atomic notifying operation, according to each function’s effects.
[Note 1: Programs are not guaranteed to observe transient atomic values, an issue known as the A-B-A problem,
resulting in continued blocking if a condition is only temporarily met.—end note]
2 [Note 2: The following functions are atomic waiting operations:
—(2.1) atomic<T>::wait,
—(2.2) atomic_flag::wait,
—(2.3) atomic_wait and atomic_wait_explicit,
—(2.4) atomic_flag_wait and atomic_flag_wait_explicit, and
—(2.5) atomic_ref<T>::wait.
—end note]
3 [Note 3: The following functions are atomic notifying operations:
—(3.1) atomic<T>::notify_one and atomic<T>::notify_all,
—(3.2) atomic_flag::notify_one and atomic_flag::notify_all,
—(3.3) atomic_notify_one and atomic_notify_all,
286) That is, atomic operations on the same memory location via two different addresses will communicate atomically.
§ 32.5.6 © ISO/IEC
2178

===== PAGE 2190 =====

Dxxxx
—(3.4) atomic_flag_notify_one and atomic_flag_notify_all, and
—(3.5) atomic_ref<T>::notify_one and atomic_ref<T>::notify_all.
—end note]
4 A call to an atomic waiting operation on an atomic objectM is eligible to be unblockedby a call to an atomic
notifying operation onM if there exist side effectsX and Y on M such that:
—(4.1) the atomic waiting operation has blocked after observing the result ofX,
—(4.2) X precedes Y in the modification order ofM, and
—(4.3) Y happens before the call to the atomic notifying operation.
32.5.7 Class template atomic_ref [atomics.ref.generic]
32.5.7.1 General [atomics.ref.generic.general]
namespace std {
template<class T> struct atomic_ref {
private:
T* ptr; // exposition only
public:
using value_type = remove_cv_t<T>;
static constexpr size_t required_alignment = implementation-defined ;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const noexcept;
constexpr explicit atomic_ref(T&);
constexpr atomic_ref(const atomic_ref&) noexcept;
template<class U>
constexpr atomic_ref(const atomic_ref<U>&) noexcept;
atomic_ref& operator=(const atomic_ref&) = delete;
constexpr void store(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type operator=(value_type) const noexcept;
constexpr value_type load(memory_order = memory_order::seq_cst) const noexcept;
constexpr operator value_type() const noexcept;
constexpr value_type exchange(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order, memory_order) const noexcept;
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order, memory_order) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void wait(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr void notify_one() const noexcept;
constexpr void notify_all() const noexcept;
constexpr T* address() const noexcept;
};
}
1 An atomic_ref object applies atomic operations (32.5.1) to the object referenced by*ptr such that, for the
lifetime (6.8.4) of theatomic_ref object, the object referenced by*ptr is an atomic object (6.10.2.2).
2 The program is ill-formed ifis_trivially_copyable_v<T> is false.
3 The lifetime (6.8.4) of an object referenced by*ptr shall exceed the lifetime of allatomic_refs that reference
the object. While anyatomic_ref instances exist that reference the*ptr object, all accesses to that object
shall exclusively occur through thoseatomic_ref instances. No subobject of the object referenced by
atomic_ref shall be concurrently referenced by any otheratomic_ref object.
§ 32.5.7.1 © ISO/IEC
2179

===== PAGE 2191 =====

Dxxxx
4 Atomic operations applied to an object through a referencingatomic_ref are atomic with respect to atomic
operations applied through any otheratomic_ref referencing the same object.
[Note 1: Atomic operations or theatomic_ref constructor can acquire a shared resource, such as a lock associated
with the referenced object, to enable atomic operations to be applied to the referenced object.—end note]
5 The program is ill-formed ifis_always_lock_free is false and is_volatile_v<T> is true.
32.5.7.2 Operations [atomics.ref.ops]
static constexpr size_t required_alignment;
1 The alignment required for an object to be referenced by an atomic reference, which is at least
alignof(T).
2 [Note 1: An implementation can choose to defineatomic_ref<T>::required_alignment to a value greater
than alignof(T) in order to ensure that operations on all objects of typeatomic_ref<T> are lock-free. —end
note]
static constexpr bool is_always_lock_free;
3 The static data memberis_always_lock_free is true if theatomic_ref type’s operations are always
lock-free, andfalse otherwise.
bool is_lock_free() const noexcept;
4 Returns: true if operations on all objects of the typeatomic_ref<T> are lock-free,false otherwise.
constexpr atomic_ref(T& obj);
5 Preconditions: The referenced object is aligned torequired_alignment.
6 Postconditions: *this references obj.
7 Throws: Nothing.
constexpr atomic_ref(const atomic_ref& ref) noexcept;
8 Postconditions: *this references the object referenced byref.
template<class U>
constexpr atomic_ref(const atomic_ref<U>&) noexcept;
9 Constraints:
—(9.1) T and U are similar types (7.3.6), and
—(9.2) is_convertible_v<U*, T*> is true.
10 Postconditions: *this references the object referenced byref.
constexpr void store(value_type desired,
memory_order order = memory_order::seq_cst) const noexcept;
11 Constraints: is_const_v<T> is false.
12 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
13 Effects: Atomically replaces the value referenced by*ptr with the value ofdesired. Memory is affected
according to the value oforder.
constexpr value_type operator=(value_type desired) const noexcept;
14 Constraints: is_const_v<T> is false.
15 Effects: Equivalent to:
store(desired);
return desired;
constexpr value_type load(memory_order order = memory_order::seq_cst) const noexcept;
16 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
17 Effects: Memory is affected according to the value oforder.
§ 32.5.7.2 © ISO/IEC
2180

===== PAGE 2192 =====

Dxxxx
18 Returns: Atomically returns the value referenced by*ptr.
constexpr operator value_type() const noexcept;
19 Effects: Equivalent to:return load();
constexpr value_type exchange(value_type desired,
memory_order order = memory_order::seq_cst) const noexcept;
20 Constraints: is_const_v<T> is false.
21 Effects: Atomically replaces the value referenced by*ptr with desired. Memory is affected according
to the value oforder. This operation is an atomic read-modify-write operation (6.10.2).
22 Returns: Atomically returns the value referenced by*ptr immediately before the effects.
constexpr bool compare_exchange_weak(value_type& expected, value_type desired,
memory_order success, memory_order failure) const noexcept;
constexpr bool compare_exchange_strong(value_type& expected, value_type desired,
memory_order success, memory_order failure) const noexcept;
constexpr bool compare_exchange_weak(value_type& expected, value_type desired,
memory_order order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_strong(value_type& expected, value_type desired,
memory_order order = memory_order::seq_cst) const noexcept;
23 Constraints: is_const_v<T> is false.
24 Preconditions: failure is memory_order::relaxed, memory_order::acquire, or memory_order::
seq_cst.
25 Effects: Retrieves the value inexpected. It then atomically compares the value representation of the
value referenced by*ptrfor equality with that previously retrieved fromexpected, and iftrue, replaces
the value referenced by*ptr with that indesired. If and only if the comparison istrue, memory
is affected according to the value ofsuccess, and if the comparison isfalse, memory is affected
according to the value offailure. When only onememory_order argument is supplied, the value of
success is order, and the value offailure is order except that a value ofmemory_order::acq_rel
shall be replaced by the valuememory_order::acquire and a value ofmemory_order::release shall
be replaced by the valuememory_order::relaxed. If and only if the comparison isfalse then, after
the atomic operation, the value inexpected is replaced by the value read from the value referenced
by *ptr during the atomic comparison. If the operation returnstrue, these operations are atomic
read-modify-write operations (6.10.2.2) on the value referenced by*ptr. Otherwise, these operations
are atomic load operations on that memory.
26 Returns: The result of the comparison.
27 Remarks: A weak compare-and-exchange operation may fail spuriously. That is, even when the contents
of memory referred to byexpected and ptr are equal, it may returnfalse and store back toexpected
the same memory contents that were originally there.
[Note 2: This spurious failure enables implementation of compare-and-exchange on a broader class of machines,
e.g., load-locked store-conditional machines. A consequence of spurious failure is that nearly all uses of weak
compare-and-exchange will be in a loop. When a compare-and-exchange is in a loop, the weak version will yield
better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong
one would not, the strong one is preferable.—end note]
constexpr void wait(value_type old, memory_order order = memory_order::seq_cst) const noexcept;
28 Preconditions: order is memory_order::relaxed, memory_order::acquire, ormemory_order::seq_-
cst.
29 Effects: Repeatedly performs the following steps, in order:
—(29.1) Evaluates load(order) and compares its value representation for equality against that ofold.
—(29.2) If they compare unequal, returns.
—(29.3) Blocks until it is unblocked by an atomic notifying operation or is unblocked spuriously.
30 Remarks: This function is an atomic waiting operation (32.5.6) on atomic object*ptr.
§ 32.5.7.2 © ISO/IEC
2181

===== PAGE 2193 =====

Dxxxx
constexpr void notify_one() const noexcept;
31 Constraints: is_const_v<T> is false.
32 Effects: Unblocks the execution of at least one atomic waiting operation on*ptr that is eligible to be
unblocked (32.5.6) by this call, if any such atomic waiting operations exist.
33 Remarks: This function is an atomic notifying operation (32.5.6) on atomic object*ptr.
constexpr void notify_all() const noexcept;
34 Constraints: is_const_v<T> is false.
35 Effects: Unblocks the execution of all atomic waiting operations on*ptr that are eligible to be
unblocked (32.5.6) by this call.
36 Remarks: This function is an atomic notifying operation (32.5.6) on atomic object*ptr.
constexpr T* address() const noexcept;
37 Returns: ptr.
32.5.7.3 Specializations for integral types [atomics.ref.int]
1 There are specializations of theatomic_ref class template for all integral types exceptcv bool. For each such
type integral-type , the specializationatomic_ref<integral-type > provides additional atomic operations
appropriate to integral types.
[Note 1: The specializationatomic_ref<bool> uses the primary template (32.5.7).—end note]
2 The program is ill-formed ifis_always_lock_free is false and is_volatile_v<integral-type > is true.
namespace std {
template<> struct atomic_ref<integral-type > {
private:
integral-type * ptr; // exposition only
public:
using value_type = remove_cv_t<integral-type >;
using difference_type = value_type;
static constexpr size_t required_alignment = implementation-defined ;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const noexcept;
constexpr explicit atomic_ref(integral-type &);
constexpr atomic_ref(const atomic_ref&) noexcept;
template<class U>
constexpr atomic_ref(const atomic_ref<U>&) noexcept;
atomic_ref& operator=(const atomic_ref&) = delete;
constexpr void store(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type operator=(value_type) const noexcept;
constexpr value_type load(memory_order = memory_order::seq_cst) const noexcept;
constexpr operator value_type() const noexcept;
constexpr value_type exchange(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order, memory_order) const noexcept;
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order, memory_order) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_add(value_type,
memory_order = memory_order::seq_cst) const noexcept;
§ 32.5.7.3 © ISO/IEC
2182

===== PAGE 2194 =====

Dxxxx
constexpr value_type fetch_sub(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_and(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_or(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_xor(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_max(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_min(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_add(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_sub(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_and(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_or(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_xor(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_max(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_min(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type operator++(int) const noexcept;
constexpr value_type operator--(int) const noexcept;
constexpr value_type operator++() const noexcept;
constexpr value_type operator--() const noexcept;
constexpr value_type operator+=(value_type) const noexcept;
constexpr value_type operator-=(value_type) const noexcept;
constexpr value_type operator&=(value_type) const noexcept;
constexpr value_type operator|=(value_type) const noexcept;
constexpr value_type operator^=(value_type) const noexcept;
constexpr void wait(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr void notify_one() const noexcept;
constexpr void notify_all() const noexcept;
constexpr integral-type * address() const noexcept;
};
}
3 Descriptions are provided below only for members that differ from the primary template.
4 The following operations perform arithmetic computations. The correspondence among key, operator, and
computation is specified in Table 155.
constexpr value_type fetch_key(value_type operand,
memory_order order = memory_order::seq_cst) const noexcept;
5 Constraints: is_const_v<integral-type > is false.
6 Effects: Atomically replaces the value referenced by*ptr with the result of the computation applied
to the value referenced by*ptr and the given operand. Memory is affected according to the value of
order. These operations are atomic read-modify-write operations (6.10.2.2).
7 Returns: Atomically, the value referenced by*ptr immediately before the effects.
8 Remarks: Except forfetch_max and fetch_min, for signed integer types the result is as if the object
value and parameters were converted to their corresponding unsigned types, the computation performed
on those types, and the result converted back to the signed type.
[Note 2: There are no undefined results arising from the computation.—end note]
§ 32.5.7.3 © ISO/IEC
2183

===== PAGE 2195 =====

Dxxxx
9 Forfetch_max and fetch_min, the maximum and minimum computation is performed as if bymax and
min algorithms (26.8.9), respectively, with the object value and the first parameter as the arguments.
constexpr void store_key(value_type operand,
memory_order order = memory_order::seq_cst) const noexcept;
10 Constraints: is_const_v<integral-type > is false.
11 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
12 Effects: Atomically replaces the value referenced by*ptr with the result of the computation applied
to the value referenced by*ptr and the givenoperand. Memory is affected according to the value of
order. These operations are atomic modify-write operations (32.5.4).
13 Remarks: Except forstore_max and store_min, for signed integer types, the result is as if*ptr and
parameters were converted to their corresponding unsigned types, the computation performed on those
types, and the result converted back to the signed type.
[Note 3: There are no undefined results arising from the computation.—end note]
For store_max and store_min, the maximum and minimum computation is performed as if bymax
and min algorithms (26.8.9), respectively, with*ptr and the first parameter as the arguments.
constexpr value_type operator op =(value_type operand) const noexcept;
14 Constraints: is_const_v<integral-type > is false.
15 Effects: Equivalent to:return fetch_key(operand) op operand;
32.5.7.4 Specializations for floating-point types [atomics.ref.float]
1 There are specializations of theatomic_ref class template for all floating-point types. For each such type
floating-point-type , the specializationatomic_ref<floating-point-type > provides additional atomic
operations appropriate to floating-point types.
2 The program is ill-formed ifis_always_lock_free is false and is_volatile_v<floating-point-type >
is true.
namespace std {
template<> struct atomic_ref<floating-point-type > {
private:
floating-point-type * ptr; // exposition only
public:
using value_type = remove_cv_t<floating-point-type >;
using difference_type = value_type;
static constexpr size_t required_alignment = implementation-defined ;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const noexcept;
constexpr explicit atomic_ref(floating-point-type &);
constexpr atomic_ref(const atomic_ref&) noexcept;
template<class U>
constexpr atomic_ref(const atomic_ref<U>&) noexcept;
atomic_ref& operator=(const atomic_ref&) = delete;
constexpr void store(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type operator=(value_type) const noexcept;
constexpr value_type load(memory_order = memory_order::seq_cst) const noexcept;
constexpr operator value_type() const noexcept;
constexpr value_type exchange(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order, memory_order) const noexcept;
§ 32.5.7.4 © ISO/IEC
2184

===== PAGE 2196 =====

Dxxxx
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order, memory_order) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_add(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_sub(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_max(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_min(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_fmaximum(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_fminimum(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_fmaximum_num(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_fminimum_num(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_add(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_sub(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_max(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_min(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_fmaximum(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_fminimum(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_fmaximum_num(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_fminimum_num(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type operator+=(value_type) const noexcept;
constexpr value_type operator-=(value_type) const noexcept;
constexpr void wait(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void notify_one() const noexcept;
constexpr void notify_all() const noexcept;
constexpr floating-point-type * address() const noexcept;
};
}
3 Descriptions are provided below only for members that differ from the primary template.
4 The following operations perform arithmetic computations. The correspondence among key, operator, and
computation is specified in Table 155, except for the keysmax, min, fmaximum, fminimum, fmaximum_num,
and fminimum_num, which are specified below.
constexpr value_type fetch_key(value_type operand,
memory_order order = memory_order::seq_cst) const noexcept;
5 Constraints: is_const_v<floating-point-type > is false.
6 Effects: Atomically replaces the value referenced by*ptr with the result of the computation applied
to the value referenced by*ptr and the given operand. Memory is affected according to the value of
order. These operations are atomic read-modify-write operations (6.10.2.2).
7 Returns: Atomically, the value referenced by*ptr immediately before the effects.
§ 32.5.7.4 © ISO/IEC
2185

===== PAGE 2197 =====

Dxxxx
8 Remarks: If the result is not a representable value for its type (7.1), the result is unspecified, but the op-
erations otherwise have no undefined behavior. Atomic arithmetic operations onfloating-point-type
should conform to thestd::numeric_limits<value_type> traits associated with the floating-point
type (17.3.3). The floating-point environment (29.3) for atomic arithmetic operations onfloating-
point-type may be different than the calling thread’s floating-point environment.
—(8.1) Forfetch_fmaximumand fetch_fminimum, the maximum and minimum computation is performed
as if byfmaximum and fminimum, respectively, with*ptr and the first parameter as the arguments.
—(8.2) Forfetch_fmaximum_num and fetch_fminimum_num, the maximum and minimum computation
is performed as if byfmaximum_num and fminimum_num, respectively, with*ptr and the first
parameter as the arguments.
—(8.3) For fetch_max and fetch_min, the maximum and minimum computation is performed as if
by fmaximum_num and fminimum_num, respectively, with *ptr and the first parameter as the
arguments, except that:
—(8.3.1) If both arguments are NaN, an unspecified NaN value is stored at*ptr.
—(8.3.2) If exactly one argument is a NaN, either the other argument or an unspecified NaN value is
stored at*ptr; it is unspecified which.
—(8.3.3) If the arguments are differently signed zeros, which of these values is stored at*ptr is
unspecified.
9 Recommended practice: The implementation offetch_max and fetch_min should treat negative zero
as smaller than positive zero.
constexpr void store_key(value_type operand,
memory_order order = memory_order::seq_cst) const noexcept;
10 Constraints: is_const_v<floating-point-type > is false.
11 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
12 Effects: Atomically replaces the value referenced by*ptr with the result of the computation applied
to the value referenced by*ptr and the givenoperand. Memory is affected according to the value of
order. These operations are atomic modify-write operations (32.5.4).
13 Remarks: If the result is not a representable value for its type (7.1), the result is unspecified, but the op-
erations otherwise have no undefined behavior. Atomic arithmetic operations onfloating-point-type
should conform to thenumeric_limits<floating-point-type > traits associated with the floating-
point type (17.3.3). The floating-point environment (29.3) for atomic arithmetic operations on
floating-point-type may be different than the calling thread’s floating-point environment. The
arithmetic rules of floating-point atomic modify-write operations may be different from operations on
floating-point types or atomic floating-point types.
[Note 1: Tree reductions are permitted for atomic modify-write operations.—end note]
—(13.1) Forstore_fmaximumand store_fminimum, the maximum and minimum computation is performed
as if byfmaximum and fminimum, respectively, with*ptr and the first parameter as the arguments.
—(13.2) Forstore_fmaximum_num and store_fminimum_num, the maximum and minimum computation
is performed as if byfmaximum_num and fminimum_num, respectively, with*ptr and the first
parameter as the arguments.
—(13.3) For store_max and store_min, the maximum and minimum computation is performed as if
by fmaximum_num and fminimum_num, respectively, with *ptr and the first parameter as the
arguments, except that:
—(13.3.1) If both arguments are NaN, an unspecified NaN value is stored at*ptr.
—(13.3.2) If exactly one argument is a NaN, either the other argument or an unspecified NaN value is
stored at*ptr, it is unspecified which.
—(13.3.3) If the arguments are differently signed zeros, which of these values is stored at*ptr is
unspecified.
14 Recommended practice: The implementation ofstore_max and store_min should treat negative zero
as smaller than positive zero.
§ 32.5.7.4 © ISO/IEC
2186

===== PAGE 2198 =====

Dxxxx
constexpr value_type operator op =(value_type operand) const noexcept;
15 Constraints: is_const_v<floating-point-type > is false.
16 Effects: Equivalent to:return fetch_key (operand) op operand;
32.5.7.5 Specialization for pointers [atomics.ref.pointer]
1 There are specializations of theatomic_ref class template for all pointer-to-object types. For each such
type pointer-type , the specializationatomic_ref<pointer-type > provides additional atomic operations
appropriate to pointer types.
2 The program is ill-formed ifis_always_lock_free is false and is_volatile_v<pointer-type > is true.
namespace std {
template<> struct atomic_ref<pointer-type > {
private:
pointer-type * ptr; // exposition only
public:
using value_type = remove_cv_t<pointer-type >;
using difference_type = ptrdiff_t;
static constexpr size_t required_alignment = implementation-defined ;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const noexcept;
constexpr explicit atomic_ref(pointer-type &);
constexpr atomic_ref(const atomic_ref&) noexcept;
template<class U>
constexpr atomic_ref(const atomic_ref<U>&) noexcept;
atomic_ref& operator=(const atomic_ref&) = delete;
constexpr void store(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type operator=(value_type) const noexcept;
constexpr value_type load(memory_order = memory_order::seq_cst) const noexcept;
constexpr operator value_type() const noexcept;
constexpr value_type exchange(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order, memory_order) const noexcept;
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order, memory_order) const noexcept;
constexpr bool compare_exchange_weak(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr bool compare_exchange_strong(value_type&, value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_add(difference_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_sub(difference_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_max(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr value_type fetch_min(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_add(difference_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_sub(difference_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_max(value_type,
memory_order = memory_order::seq_cst) const noexcept;
constexpr void store_min(value_type,
memory_order = memory_order::seq_cst) const noexcept;
§ 32.5.7.5 © ISO/IEC
2187

===== PAGE 2199 =====

Dxxxx
constexpr value_type operator++(int) const noexcept;
constexpr value_type operator--(int) const noexcept;
constexpr value_type operator++() const noexcept;
constexpr value_type operator--() const noexcept;
constexpr value_type operator+=(difference_type) const noexcept;
constexpr value_type operator-=(difference_type) const noexcept;
constexpr void wait(value_type, memory_order = memory_order::seq_cst) const noexcept;
constexpr void notify_one() const noexcept;
constexpr void notify_all() const noexcept;
constexpr pointer-type * address() const noexcept;
};
}
3 Descriptions are provided below only for members that differ from the primary template.
4 The following operations perform arithmetic computations. The correspondence among key, operator, and
computation is specified in Table 156.
constexpr value_type fetch_key(see above operand,
memory_order order = memory_order::seq_cst) const noexcept;
5 Constraints: is_const_v<pointer-type > is false.
6 Mandates: remove_pointer_t<pointer-type > is a complete object type.
7 Effects: Atomically replaces the value referenced by*ptr with the result of the computation applied
to the value referenced by*ptr and the given operand. Memory is affected according to the value of
order. These operations are atomic read-modify-write operations (6.10.2.2).
8 Returns: Atomically, the value referenced by*ptr immediately before the effects.
9 Remarks: The result may be an undefined address, but the operations otherwise have no undefined
behavior.
10 Forfetch_max and fetch_min, the maximum and minimum computation is performed as if bymax and
min algorithms (26.8.9), respectively, with the object value and the first parameter as the arguments.
[Note 1: If the pointers point to different complete objects (or subobjects thereof), the< operator does not
establish a strict weak ordering (Table 29, 7.6.9).—end note]
constexpr void store_key(see above operand,
memory_order order = memory_order::seq_cst) const noexcept;
11 Constraints: is_const_v<pointer-type > is false.
12 Mandates: remove_pointer_t<pointer-type > is a complete object type.
13 Preconditions: order is memory_order::relaxed, memory_order::release, ormemory_order::seq_-
cst.
14 Effects: Atomically replaces the value referenced by*ptr with the result of the computation applied
to the value referenced by*ptr and the givenoperand. Memory is affected according to the value of
order. These operations are atomic modify-write operations (32.5.4).
15 Remarks: The result may be an undefined address, but the operations otherwise have no undefined
behavior. Forstore_max and store_min, themaximum and minimum computation is performed as if by
max and min algorithms (26.8.9), respectively, with*ptr and the first parameter as the arguments.
[Note 2: If the pointers point to different complete objects (or subobjects thereof), the< operator does not
establish a strict weak ordering (Table 29, 7.6.9).—end note]
constexpr value_type operator op =(difference_type operand) const noexcept;
16 Constraints: is_const_v<pointer-type > is false.
17 Effects: Equivalent to:return fetch_key (operand) op operand;
32.5.7.6 Member operators common to integers and pointers to objects[atomics.ref.memop]
1 Let referred-type be pointer-type for the specializations in 32.5.7.5 and beintegral-type for the
specializations in 32.5.7.3.
§ 32.5.7.6 © ISO/IEC
2188

===== PAGE 2200 =====

Dxxxx
constexpr value_type operator++(int) const noexcept;
2 Constraints: is_const_v<referred-type > is false.
3 Effects: Equivalent to:return fetch_add(1);
constexpr value_type operator--(int) const noexcept;
4 Constraints: is_const_v<referred-type > is false.
5 Effects: Equivalent to:return fetch_sub(1);
constexpr value_type operator++() const noexcept;
6 Constraints: is_const_v<referred-type > is false.
7 Effects: Equivalent to:return fetch_add(1) + 1;
constexpr value_type operator--() const noexcept;
8 Constraints: is_const_v<referred-type > is false.
9 Effects: Equivalent to:return fetch_sub(1) - 1;
32.5.8 Class template atomic [atomics.types.generic]
32.5.8.1 General [atomics.types.generic.general]
namespace std {
template<class T> struct atomic {
using value_type = T;
static constexpr bool is_always_lock_free = implementation-defined ;
bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;
// 32.5.8.2, operations on atomic types
constexpr atomic() noexcept(is_nothrow_default_constructible_v<T>);
constexpr atomic(T) noexcept;
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
atomic& operator=(const atomic&) volatile = delete;
T load(memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr T load(memory_order = memory_order::seq_cst) const noexcept;
operator T() const volatile noexcept;
constexpr operator T() const noexcept;
void store(T, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr void store(T, memory_order = memory_order::seq_cst) noexcept;
T operator=(T) volatile noexcept;
constexpr T operator=(T) noexcept;
T exchange(T, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr T exchange(T, memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_weak(T&, T, memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_weak(T&, T, memory_order, memory_order) noexcept;
bool compare_exchange_strong(T&, T, memory_order, memory_order) volatile noexcept;
constexpr bool compare_exchange_strong(T&, T, memory_order, memory_order) noexcept;
bool compare_exchange_weak(T&, T, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_weak(T&, T, memory_order = memory_order::seq_cst) noexcept;
bool compare_exchange_strong(T&, T, memory_order = memory_order::seq_cst) volatile noexcept;
constexpr bool compare_exchange_strong(T&, T, memory_order = memory_order::seq_cst) noexcept;
void wait(T, memory_order = memory_order::seq_cst) const volatile noexcept;
constexpr void wait(T, memory_order = memory_order::seq_cst) const noexcept;
void notify_one() volatile noexcept;
constexpr void notify_one() noexcept;
void notify_all() volatile noexcept;
constexpr void notify_all() noexcept;
§ 32.5.8.1 © ISO/IEC
2189